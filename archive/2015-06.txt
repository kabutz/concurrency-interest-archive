From viktor.klang at gmail.com  Tue Jun  2 06:56:54 2015
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 2 Jun 2015 12:56:54 +0200
Subject: [concurrency-interest] jdk9 Candidate classes Flow and
	SubmissionPublisher
In-Reply-To: <CAH_y2NEJFFdQgOc_XosOkxdRpKNVgBKOjrh0R383W5PtJfKbyg@mail.gmail.com>
References: <CAH_y2NEJFFdQgOc_XosOkxdRpKNVgBKOjrh0R383W5PtJfKbyg@mail.gmail.com>
Message-ID: <CANPzfU-YvQZiq03_+y1BN7TgBSnztDqwFBbmnye0R00fbfS-UA@mail.gmail.com>

Hi Greg,

May I suggest keeping the discussion in a single place, saves a lot of
duplicate answers:

https://github.com/reactive-streams/reactive-streams-jvm/issues/270

On Fri, May 29, 2015 at 2:52 AM, Greg Wilkins <gregw at webtide.com> wrote:

>
> Hi,
>
> I'm looking at the Flow classes as a potential better API for asynchronous
> IO than the current Servlet async API for the Jetty webserver.
>
> However, it is not clear to me that the current proposed API is sufficient
> for types that have natural aggregations that would be natural to use.
>
> Specifically to replace Servlet async IO, semantically I need a
> Flow.Subscriber<byte>  so that calls to Flow.Subscription.request(long n)
> can be expressed in terms of the number of bytes the subscriber is prepared
> to receive. However, delivering those bytes as successive calls to
> Flow.Subscriber.onNext(byte item) will be highly inefficient.
>
> How should such aggregations be handled?   Note the same goes for
> characters in string Strings/CharSequences/Messages and probably for any
> Flow of objects where the size of the object can vary greatly and the
> ability to receive relies more on the size of the items rather than the
> number of them.
>
>
> To me it makes little sense to actually declare the subscriber in terms of
> byte or character, as they are not the preferred delivery types.   Rather
> the type should be declared as the aggregate type (ByteBuffer,
> CharSequence, WebSocketMessage etc.)
>
> What is then needed is for the subscriber to be able to request both the
> number and total size in a request. ie perhaps a method could be added to
> Flow.Subscription
>
>   request(long items,long totalSize)
>
> The semantic could be that a Subscriber could call either request method
> and a call to request(long n) would be equivalent to a call to
> request(n,Long.MAX_VALUE).
>
> cheers
>
>
>
>
>
> --
> Greg Wilkins <gregw at webtide.com <gregw at intalio.com>>  - *an Intalio.com
> subsidiary*
> http://eclipse.org/jetty HTTP, SPDY, Websocket server and client that
> scales
> http://www.webtide.com  advice and support for jetty and cometd.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20150602/c9908102/attachment.html>

From heinz at javaspecialists.eu  Tue Jun  2 13:08:02 2015
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Tue, 02 Jun 2015 20:08:02 +0300
Subject: [concurrency-interest] Basic Question about F/J
Message-ID: <556DE2F2.4080607@javaspecialists.eu>

Hi everyone,

inside the compute method of a recursive action or task, I usually 
recommend calling the invoke() method of any created FJTask.  However, 
in the RecursiveTask example, the compute() method of f2 is called.  
Putting aside the fact that it's a dumb algorithm and that no, you would 
not want to use the linear algorithm either, but instead a recursive 
decomposition version of Dijkstra's Sum of Squares, I was just wondering 
whether it is more correct to call compute() or invoke() on a task that 
you wish to call on your current thread?

Regards

Heinz
-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun/Oracle Java Champion since 2005
JavaOne Rock Star Speaker 2012
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz


From davidcholmes at aapt.net.au  Tue Jun  2 16:53:14 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 3 Jun 2015 06:53:14 +1000
Subject: [concurrency-interest] Basic Question about F/J
In-Reply-To: <556DE2F2.4080607@javaspecialists.eu>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEHPLAAA.davidcholmes@aapt.net.au>

Hi Heinz,

Dr Heinz M. Kabutz writes:
> Hi everyone,
>
> inside the compute method of a recursive action or task, I usually
> recommend calling the invoke() method of any created FJTask.  However,
> in the RecursiveTask example, the compute() method of f2 is called.
> Putting aside the fact that it's a dumb algorithm and that no, you would
> not want to use the linear algorithm either, but instead a recursive
> decomposition version of Dijkstra's Sum of Squares, I was just wondering
> whether it is more correct to call compute() or invoke() on a task that
> you wish to call on your current thread?

invoke() doesn't process the task on the current thread - it arranges for
async execution and then waits for it to complete - so you are wasting a
thread if you use invoke() rather than compute().

The optimal version of a compute() method would do:

  rs.fork();
  ls.compute();
  if (rs.tryUnfork())
    rs.compute();
  else
    rs.join();

Ref: "Data parallelism with the ForkJoin Framework in Java 7" - JavaOne SF
2011

Cheers,
David

> Regards
>
> Heinz
> --
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun/Oracle Java Champion since 2005
> JavaOne Rock Star Speaker 2012
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From aleksey.shipilev at oracle.com  Tue Jun  2 18:52:59 2015
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 03 Jun 2015 01:52:59 +0300
Subject: [concurrency-interest] Basic Question about F/J
In-Reply-To: <556DE2F2.4080607@javaspecialists.eu>
References: <556DE2F2.4080607@javaspecialists.eu>
Message-ID: <556E33CB.3070709@oracle.com>

On 06/02/2015 08:08 PM, Dr Heinz M. Kabutz wrote:
> inside the compute method of a recursive action or task, I usually
> recommend calling the invoke() method of any created FJTask.  However,
> in the RecursiveTask example, the compute() method of f2 is called. 
> Putting aside the fact that it's a dumb algorithm and that no, you would
> not want to use the linear algorithm either, but instead a recursive
> decomposition version of Dijkstra's Sum of Squares, I was just wondering
> whether it is more correct to call compute() or invoke() on a task that
> you wish to call on your current thread?

Correctness is in the eye of beholder here.

compute() does not call through any FJP infrastructure
(RecursiveTask.compute() is abstract), it just calls the payload method.
Think about compute() as the naked payload method.

invoke() calls through FJP code, and among other things, it will compute
and store the result or return immediately if the result is available
already, plus notify waiters the result is available (notice
RecursiveTask<T> is also a Future<T>). But in the end, it will try to
call compute() in the same thread:

 * ... Method {@link #invoke} is semantically
 * equivalent to {@code fork(); join()} but always attempts to begin
 * execution in the current thread. ...

AFAIU, current implementation does not even try to fork, and goes
straight to execution.

Since two compute()-s will execute the payload method twice, and
invoke() will behave like one-shot action (which is what you probably
want anyway when you are decomposing stuff), I'd recommend using
invoke() as a rule to avoid double computations and unblock whoever is
waiting on task result.

If your code is trivial, and there is no room for a programming error,
you may save a few cycles going straight to compute(). (Or,
understanding this is just a plain payload call, rewrite the recursion
into the loop).

I think RecursiveTask Fibonacci example is written that particular way
to demonstrate how would you "fork off" an right-hand-side execution,
while still doing an old-style recursive call on the left-hand-side.
That is, not to mix the invoke() in this story unnecessarily.

-Aleksey.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20150603/d0f1a37c/attachment.bin>

From aleksey.shipilev at oracle.com  Tue Jun  2 18:59:45 2015
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 03 Jun 2015 01:59:45 +0300
Subject: [concurrency-interest] Basic Question about F/J
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEHPLAAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCAEHPLAAA.davidcholmes@aapt.net.au>
Message-ID: <556E3561.9090507@oracle.com>

On 06/02/2015 11:53 PM, David Holmes wrote:
> invoke() doesn't process the task on the current thread - it arranges for
> async execution and then waits for it to complete - so you are wasting a
> thread if you use invoke() rather than compute().

Current implementation tries to process invoke() in the same thread. FJP
is actually about not wasting threads on dumb stuff :)

> The optimal version of a compute() method would do:
> 
>   rs.fork();
>   ls.compute();
>   if (rs.tryUnfork())
>     rs.compute();
>   else
>     rs.join();
> 
> Ref: "Data parallelism with the ForkJoin Framework in Java 7" - JavaOne SF
> 2011

I don't think it is necessary to expose these low-level things anymore.
FJT.join() does the same tryUnpush and exec undercover, so:

   rs.fork();
   T lres = ls.compute();
   T rres = rs.join();
   return combine(lres, rres);

...is enough. Or, if you don't care about results, just

   ForkJoinTask.invokeAll(ls, rs);

-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20150603/b412aec3/attachment.bin>

From davidcholmes at aapt.net.au  Tue Jun  2 19:06:05 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 3 Jun 2015 09:06:05 +1000
Subject: [concurrency-interest] Basic Question about F/J
In-Reply-To: <556E3561.9090507@oracle.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEHPLAAA.davidcholmes@aapt.net.au>

Aleksey Shipilev writes:
> On 06/02/2015 11:53 PM, David Holmes wrote:
> > invoke() doesn't process the task on the current thread - it
> arranges for
> > async execution and then waits for it to complete - so you are wasting a
> > thread if you use invoke() rather than compute().
>
> Current implementation tries to process invoke() in the same thread. FJP
> is actually about not wasting threads on dumb stuff :)

Yes it tries, so I should have said "potentially wasting a thread".

Cheers,
David

> > The optimal version of a compute() method would do:
> >
> >   rs.fork();
> >   ls.compute();
> >   if (rs.tryUnfork())
> >     rs.compute();
> >   else
> >     rs.join();
> >
> > Ref: "Data parallelism with the ForkJoin Framework in Java 7" -
> JavaOne SF
> > 2011
>
> I don't think it is necessary to expose these low-level things anymore.
> FJT.join() does the same tryUnpush and exec undercover, so:
>
>    rs.fork();
>    T lres = ls.compute();
>    T rres = rs.join();
>    return combine(lres, rres);
>
> ...is enough. Or, if you don't care about results, just
>
>    ForkJoinTask.invokeAll(ls, rs);
>
> -Aleksey
>
>


From peter.levart at gmail.com  Wed Jun  3 04:43:16 2015
From: peter.levart at gmail.com (Peter Levart)
Date: Wed, 03 Jun 2015 10:43:16 +0200
Subject: [concurrency-interest] Basic Question about F/J
In-Reply-To: <556DE2F2.4080607@javaspecialists.eu>
References: <556DE2F2.4080607@javaspecialists.eu>
Message-ID: <556EBE24.9080608@gmail.com>

Hi,

On 06/02/2015 07:08 PM, Dr Heinz M. Kabutz wrote:
> Hi everyone,
>
> inside the compute method of a recursive action or task, I usually 
> recommend calling the invoke() method of any created FJTask. However, 
> in the RecursiveTask example, the compute() method of f2 is called.  
> Putting aside the fact that it's a dumb algorithm and that no, you 
> would not want to use the linear algorithm either, but instead a 
> recursive decomposition version of Dijkstra's Sum of Squares, I was 
> just wondering whether it is more correct to call compute() or 
> invoke() on a task that you wish to call on your current thread?
>
> Regards
>
> Heinz

I think David and Aleksey have already answered your question pretty 
well. I don't think RecursiveTask.compute() method is meant to be called 
directly. It is a protected abstract method after all that is meant to 
be implemented by subclass and called by FJ-pool. It may be OK to call 
it for demonstration purposes, but otherwise it is pointless to pack the 
parameters of a computation into an object meant to execute in a managed 
environment just to invoke it's implemented method directly. Better use 
of resources can be achieved by factoring the computation into a static 
method that takes all the parameters (can be hosted in the FJ task 
itself) and just call that method with the parameters instead of 
creating the task with them and calling compute(). The FJ-task can 
implement it's compute() method by delegating to the same static method 
then.

Regards, Peter


From gregw at webtide.com  Wed Jun  3 19:19:53 2015
From: gregw at webtide.com (Greg Wilkins)
Date: Thu, 4 Jun 2015 09:19:53 +1000
Subject: [concurrency-interest] jdk9 Candidate classes Flow and
	SubmissionPublisher
In-Reply-To: <CANPzfU-YvQZiq03_+y1BN7TgBSnztDqwFBbmnye0R00fbfS-UA@mail.gmail.com>
References: <CAH_y2NEJFFdQgOc_XosOkxdRpKNVgBKOjrh0R383W5PtJfKbyg@mail.gmail.com>
	<CANPzfU-YvQZiq03_+y1BN7TgBSnztDqwFBbmnye0R00fbfS-UA@mail.gmail.com>
Message-ID: <CAH_y2NE2-9zK2CBUEJjumdhvUX+B44R8wTXTOGY6ceq1mxDKSA@mail.gmail.com>

On 2 June 2015 at 20:56, Viktor Klang <viktor.klang at gmail.com> wrote:

> Hi Greg,
>
> May I suggest keeping the discussion in a single place, saves a lot of
> duplicate answers:
>
> https://github.com/reactive-streams/reactive-streams-jvm/issues/270
>
>
Viktor,

now that discussion on that issue has run to a reasonable conclusion on my
initial concerns, is it more appropriate to continue general discussions
here rather than as comments on a closed issue?

So with the jetty-reactive experiements we are doing, we are not looking at
providing a full Reactive Streams implementation, but rather a library of
Publishers, Subscribers and Processors aimed at adapting async services
within jetty to the RS API.  This such as:

   - Servlet Async IO
   - Websockets
   - HTTP2 Push
   - Servlet Request and Responses as RSs

As the #270 issue shows, it is still very early days for us understanding
the paradigm, but I think we've made a lot of progress and we're liking the
API so far.

However, one concern that we currently have is the lack of acknowledgement
of success or failure in the reverse direction to the RS.

Receiving acknowledgement of success would make it possible for a publisher
to recycle published items (eg reuse buffers or put them back in a buffer
pool).   But perhaps more importantly, acknowledgement of failure is very
important for making robust scalable servers.

Our experience with asynchronous code is that making it work well is the
easy part, often taking a few short hours of coding. It is making it fail
well that the really hard part and can take months of hard work to even
understand all the failure modes, let alone deal with them properly without
leaking resources etc.

So with the standard RS API, we can see how you can push failure
notification down a stream using Subscriber.onError(Throwble),  but we
can't see a standard way of sending failure notification up a stream.

For example, consider a Publisher connected to a chain of Processors,
finishing with a final Subscriber that is actually an adapter over a
servlet output stream.      Somewhere in that chain, there will be a
processor that will serialize the item objects or convert them to JSON.

Lets say there is an exception serializing one of these objects, then what
should the processor do?   Well it can tell it's subscriber with
onError(Throwable) that there was a problem, but in this case the
subscriber can do very little with that knowledge other than log the
throwable and close its servlet stream.    But there is no standard way for
the processor to tell the publisher that send the bad object that there was
a problem with the passed object.

It can Subscription.cancel(), but that does not provide any information
about what failed.  It can't just throw an exception as in an async
environment, the processing of the objects passed may often end up being in
the calling stack of the servlet container calling onWritePossible which
calls subscription.request(n).  Thus throwing an exception may end up going
down the stream rather than up.

So why is onError on the Subscriber and cancel on Subscription?   For our
initial thinking on error handling it should be on the other way around so
exceptions go up stream not down?  Our rough early thinking is that it
would make more sense to have:

Publisher{
  void subscribe(Subscriber<T> s);
}

Subscriber{
  void onSubsciption(Subscription<T> s);
  void onNext(T item);
  void onCompleted();
  void cancel();
}

Subscription{
  void request(long n);
  void acknowledge(T item);
  void onError(Throwable x);
}

Thus exceptions would propagate upstream and cancellation would go
downstream, which is the opposite of what the API has today.   I've also
added an upstream acknowledge(T item) to support success notification that
would allow transaction to be closed, buffers to be recycled etc. etc.

Now, having just been schooled in the whole way this API works
asynchronously... I'm expecting that I've perhaps not understood how error
handling is intended to be used.

cheers






















-- 
Greg Wilkins <gregw at webtide.com <gregw at intalio.com>>  - *an Intalio.com
subsidiary*
http://eclipse.org/jetty HTTP, SPDY, Websocket server and client that scales
http://www.webtide.com  advice and support for jetty and cometd.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20150604/6c000e9b/attachment.html>

From viktor.klang at gmail.com  Thu Jun  4 06:55:17 2015
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 4 Jun 2015 12:55:17 +0200
Subject: [concurrency-interest] jdk9 Candidate classes Flow and
	SubmissionPublisher
In-Reply-To: <CAH_y2NE2-9zK2CBUEJjumdhvUX+B44R8wTXTOGY6ceq1mxDKSA@mail.gmail.com>
References: <CAH_y2NEJFFdQgOc_XosOkxdRpKNVgBKOjrh0R383W5PtJfKbyg@mail.gmail.com>
	<CANPzfU-YvQZiq03_+y1BN7TgBSnztDqwFBbmnye0R00fbfS-UA@mail.gmail.com>
	<CAH_y2NE2-9zK2CBUEJjumdhvUX+B44R8wTXTOGY6ceq1mxDKSA@mail.gmail.com>
Message-ID: <CANPzfU8TBkH0K15RnkLbuzFc6OqMMdZAOOtKAmpFnW=piWbAiA@mail.gmail.com>

Hi Greg,

Thanks for the feedback!

RS is as minimalistic as possible, focusing on solving a well-defined and
narrow set of problems, so that more sophisticated solutions can be built
on top. This is why communication is essentially uni-directional (you can
have a pair of unidirectionals to get bidirectionality).

On Thu, Jun 4, 2015 at 1:19 AM, Greg Wilkins <gregw at webtide.com> wrote:

>
> On 2 June 2015 at 20:56, Viktor Klang <viktor.klang at gmail.com> wrote:
>
>> Hi Greg,
>>
>> May I suggest keeping the discussion in a single place, saves a lot of
>> duplicate answers:
>>
>> https://github.com/reactive-streams/reactive-streams-jvm/issues/270
>>
>>
> Viktor,
>
> now that discussion on that issue has run to a reasonable conclusion on my
> initial concerns, is it more appropriate to continue general discussions
> here rather than as comments on a closed issue?
>

Having read your email I'll have to disagree, since you/we are talking
about why RS wasn't implemented in some other way I think it still belongs
as a discussion over at RS?to keep things close to where they belong. Would
you agree?


>
> So with the jetty-reactive experiements we are doing, we are not looking
> at providing a full Reactive Streams implementation, but rather a library
> of Publishers, Subscribers and Processors
>

There's no such thing as a "full Reactive Streams" implementation, if you
implement Publisher, Processor or Subscriber and it passes the TCK it is
for all intents and purposes an implementation of Reactive Streams :)


> aimed at adapting async services within jetty to the RS API.  This such as:
>
>    - Servlet Async IO
>    - Websockets
>    - HTTP2 Push
>    - Servlet Request and Responses as RSs
>
> As the #270 issue shows, it is still very early days for us understanding
> the paradigm, but I think we've made a lot of progress and we're liking the
> API so far.
>

I'm delighted to hear this! Keep the feedback flowing


> However, one concern that we currently have is the lack of acknowledgement
> of success or failure in the reverse direction to the RS.
>
This is by design. Acks are expensive as they double the number of messages
that have to travel (think of Reactive Streams as a protocol), so if you
need to ack every message you'll have to send twice as many messages. This
is too constraining in the general sense. If you want that kind of
functionality it is rather trivial to use 2 "flows" one downstream and one
upstream.



> Receiving acknowledgement of success would make it possible for a
> publisher to recycle published items (eg reuse buffers or put them back in
> a buffer pool).   But perhaps more importantly, acknowledgement of failure
> is very important for making robust scalable servers.
>
Since RS does not mandate that the Subscriber runs locally, assuming that
elements are always shared without copying/marshalling is not appropriate
or feasible. Also, for the "object pooling" use-case, you also need to go
to great lengths to avoid aliasing of the elements.



> Our experience with asynchronous code is that making it work well is the
> easy part, often taking a few short hours of coding. It is making it fail
> well that the really hard part and can take months of hard work to even
> understand all the failure modes, let alone deal with them properly without
> leaking resources etc.
>

Absolutely! Failure management strategy was at the very core of the spec.
(As a sidenote, I think we as an industry have been focusing waaay too much
on "blue skies" solutions)


> So with the standard RS API, we can see how you can push failure
> notification down a stream using Subscriber.onError(Throwble),  but we
> can't see a standard way of sending failure notification up a stream.
>
Because it is not the responsibility of the Publisher to deal with the
failures of the Subscriber?there is nothing it could do about it.
`onError` is the signal that travels downstream to notify the Subscriber
that there will be no more elements coming, because of a failure, not
because of End-Of-Stream.



> For example, consider a Publisher connected to a chain of Processors,
> finishing with a final Subscriber that is actually an adapter over a
> servlet output stream.      Somewhere in that chain, there will be a
> processor that will serialize the item objects or convert them to JSON.
>
> Lets say there is an exception serializing one of these objects, then what
> should the processor do?   Well it can tell it's subscriber with
> onError(Throwable) that there was a problem, but in this case the
> subscriber can do very little with that knowledge other than log the
> throwable and close its servlet stream.    But there is no standard way for
> the processor to tell the publisher that send the bad object that there was
> a problem with the passed object.
>
If serialization errors are to be considered fatal to the processing, it
should immediately cancel its upstream subscription and signal onError
downstream so that the entire pipeline can clean itself up.

If serialization is not to be considered fatal you have 2 choices:

A) Represent "errors" (i.e. non-fatal situations) in the element type
downstream?this means that the stream will not have any gaps.
B) Divert "errors" to a side-channel (log etc)?this means that the stream
will have "gaps".


> It can Subscription.cancel(), but that does not provide any information
> about what failed.  It can't just throw an exception as in an async
> environment, the processing of the objects passed may often end up being in
> the calling stack of the servlet container calling onWritePossible which
> calls subscription.request(n).  Thus throwing an exception may end up going
> down the stream rather than up.
>

The spec prescribes where exceptions are and aren't allowed to be thrown:
https://github.com/reactive-streams/reactive-streams-jvm#specification


> So why is onError on the Subscriber and cancel on Subscription?
>
The Publisher can not do anything about -why- the Subscriber is unable to
continue it; onError is a fast-path teardown signal whereas onComplete is
an ordered teardown.

   For our initial thinking on error handling it should be on the other way
> around so exceptions go up stream not down?  Our rough early thinking is
> that it would make more sense to have:
>
> Publisher{
>   void subscribe(Subscriber<T> s);
> }
>
> Subscriber{
>   void onSubsciption(Subscription<T> s);
>   void onNext(T item);
>   void onCompleted();
>   void cancel();
> }
>
> Subscription{
>   void request(long n);
>   void acknowledge(T item);
>   void onError(Throwable x);
> }
>
> Thus exceptions would propagate upstream and cancellation would go
> downstream, which is the opposite of what the API has today.
>
If I udnerstand this proposal correctly it means that Subscribers will
never know if there's an EOS or Error upstream?


> I've also added an upstream acknowledge(T item) to support success
> notification that would allow transaction to be closed, buffers to be
> recycled etc. etc.
>
This not only means that traffic will double (sending items both back and
forth across the medium), but it also means that Publishers will need to
retain references to all elements they send that have not been
acknowledged, which will have quite drastic effects on memory consumption,
especially when the element traverses a binary boundary
(serialization/marshalling).

> Now, having just been schooled in the whole way this API works
> asynchronously... I'm expecting that I've perhaps not understood how error
> handling is intended to be used.
>
I hope things are clearer,
I suspect you'll find RS easier to reason about if you think of it as a
protocol rather than "just" methods and interfaces.

Let's continue this discussion over at RS!


> cheers
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
> --
> Greg Wilkins <gregw at webtide.com <gregw at intalio.com>>  - *an Intalio.com
> subsidiary*
> http://eclipse.org/jetty HTTP, SPDY, Websocket server and client that
> scales
> http://www.webtide.com  advice and support for jetty and cometd.
>



-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20150604/8d7803fd/attachment-0001.html>

From viktor.klang at gmail.com  Thu Jun  4 07:07:33 2015
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 4 Jun 2015 13:07:33 +0200
Subject: [concurrency-interest] jdk9 Candidate classes Flow and
	SubmissionPublisher
In-Reply-To: <CANPzfU8TBkH0K15RnkLbuzFc6OqMMdZAOOtKAmpFnW=piWbAiA@mail.gmail.com>
References: <CAH_y2NEJFFdQgOc_XosOkxdRpKNVgBKOjrh0R383W5PtJfKbyg@mail.gmail.com>
	<CANPzfU-YvQZiq03_+y1BN7TgBSnztDqwFBbmnye0R00fbfS-UA@mail.gmail.com>
	<CAH_y2NE2-9zK2CBUEJjumdhvUX+B44R8wTXTOGY6ceq1mxDKSA@mail.gmail.com>
	<CANPzfU8TBkH0K15RnkLbuzFc6OqMMdZAOOtKAmpFnW=piWbAiA@mail.gmail.com>
Message-ID: <CANPzfU8wcOLbBi9O_VpzmAgm-d35tfpMYZO=gOfwbDHTOBBoBQ@mail.gmail.com>

Noticed that I lost a sentence in editing, adding below

On 4 Jun 2015 12:55, "Viktor Klang" <viktor.klang at gmail.com> wrote:
>
> Hi Greg,
>
> Thanks for the feedback!
>
> RS is as minimalistic as possible, focusing on solving a well-defined and
narrow set of problems, so that more sophisticated solutions can be built
on top. This is why communication is essentially uni-directional (you can
have a pair of unidirectionals to get bidirectionality).
>
> On Thu, Jun 4, 2015 at 1:19 AM, Greg Wilkins <gregw at webtide.com> wrote:
>>
>>
>> On 2 June 2015 at 20:56, Viktor Klang <viktor.klang at gmail.com> wrote:
>>>
>>> Hi Greg,
>>>
>>> May I suggest keeping the discussion in a single place, saves a lot of
duplicate answers:
>>>
>>> https://github.com/reactive-streams/reactive-streams-jvm/issues/270
>>>
>>
>> Viktor,
>>
>> now that discussion on that issue has run to a reasonable conclusion on
my initial concerns, is it more appropriate to continue general discussions
here rather than as comments on a closed issue?
>
>
> Having read your email I'll have to disagree, since you/we are talking
about why RS wasn't implemented in some other way I think it still belongs
as a discussion over at RS?to keep things close to where they belong. Would
you agree?
>
>>
>>
>> So with the jetty-reactive experiements we are doing, we are not looking
at providing a full Reactive Streams implementation, but rather a library
of Publishers, Subscribers and Processors
>
>
> There's no such thing as a "full Reactive Streams" implementation, if you
implement Publisher, Processor or Subscriber and it passes the TCK it is
for all intents and purposes an implementation of Reactive Streams :)
>
>>
>> aimed at adapting async services within jetty to the RS API.  This such
as:
>> Servlet Async IO
>> Websockets
>> HTTP2 Push
>> Servlet Request and Responses as RSs
>>
>> As the #270 issue shows, it is still very early days for us
understanding the paradigm, but I think we've made a lot of progress and
we're liking the API so far.
>
>
> I'm delighted to hear this! Keep the feedback flowing
>
>>
>> However, one concern that we currently have is the lack of
acknowledgement of success or failure in the reverse direction to the RS.
>
> This is by design. Acks are expensive as they double the number of
messages that have to travel (think of Reactive Streams as a protocol), so
if you need to ack every message you'll have to send twice as many
messages. This is too constraining in the general sense. If you want that
kind of functionality it is rather trivial to use 2 "flows" one downstream
and one upstream.
>
>
>>
>> Receiving acknowledgement of success would make it possible for a
publisher to recycle published items (eg reuse buffers or put them back in
a buffer pool).   But perhaps more importantly, acknowledgement of failure
is very important for making robust scalable servers.
>
> Since RS does not mandate that the Subscriber runs locally, assuming that
elements are always shared without copying/marshalling is not appropriate
or feasible. Also, for the "object pooling" use-case, you also need to go
to great lengths to avoid aliasing of the elements.
>
>
>>
>> Our experience with asynchronous code is that making it work well is the
easy part, often taking a few short hours of coding. It is making it fail
well that the really hard part and can take months of hard work to even
understand all the failure modes, let alone deal with them properly without
leaking resources etc.
>
>
> Absolutely! Failure management strategy was at the very core of the spec.
(As a sidenote, I think we as an industry have been focusing waaay too much
on "blue skies" solutions)
>
>>
>> So with the standard RS API, we can see how you can push failure
notification down a stream using Subscriber.onError(Throwble),  but we
can't see a standard way of sending failure notification up a stream.
>
> Because it is not the responsibility of the Publisher to deal with the
failures of the Subscriber?there is nothing it could do about it.
> `onError` is the signal that travels downstream to notify the Subscriber
that there will be no more elements coming, because of a failure, not
because of End-Of-Stream.
>
>
>>
>> For example, consider a Publisher connected to a chain of Processors,
finishing with a final Subscriber that is actually an adapter over a
servlet output stream.      Somewhere in that chain, there will be a
processor that will serialize the item objects or convert them to JSON.
>>
>> Lets say there is an exception serializing one of these objects, then
what should the processor do?   Well it can tell it's subscriber with
onError(Throwable) that there was a problem, but in this case the
subscriber can do very little with that knowledge other than log the
throwable and close its servlet stream.    But there is no standard way for
the processor to tell the publisher that send the bad object that there was
a problem with the passed object.
>
> If serialization errors are to be considered fatal to the processing, it
should immediately cancel its upstream subscription and signal onError
downstream so that the entire pipeline can clean itself up.
>
> If serialization is not to be considered fatal you have 2 choices:
>
> A) Represent "errors" (i.e. non-fatal situations) in the element type
downstream?this means that the stream will not have any gaps.
> B) Divert "errors" to a side-channel (log etc)?this means that the stream
will have "gaps".
>
>>
>> It can Subscription.cancel(), but that does not provide any information
about what failed.  It can't just throw an exception as in an async
environment, the processing of the objects passed may often end up being in
the calling stack of the servlet container calling onWritePossible which
calls subscription.request(n).  Thus throwing an exception may end up going
down the stream rather than up.
>
>
> The spec prescribes where exceptions are and aren't allowed to be thrown:
https://github.com/reactive-streams/reactive-streams-jvm#specification
>
>>
>> So why is onError on the Subscriber and cancel on Subscription?
>
> The Publisher can not do anything about -why- the Subscriber is unable to
continue it; onError is a fast-path teardown signal whereas onComplete is
an ordered teardown.
>
>>    For our initial thinking on error handling it should be on the other
way around so exceptions go up stream not down?  Our rough early thinking
is that it would make more sense to have:
>>
>> Publisher{
>>   void subscribe(Subscriber<T> s);
>> }
>>
>> Subscriber{
>>   void onSubsciption(Subscription<T> s);
>>   void onNext(T item);
>>   void onCompleted();
>>   void cancel();
>> }
>>
>> Subscription{
>>   void request(long n);
>>   void acknowledge(T item);
>>   void onError(Throwable x);
>> }
>>
>> Thus exceptions would propagate upstream and cancellation would go
downstream, which is the opposite of what the API has today.
>
> If I udnerstand this proposal correctly it means that Subscribers will
never know if there's an EOS or Error upstream?

Or does it mean that cancel == onError(new CancellationException)?

>
>>
>> I've also added an upstream acknowledge(T item) to support success
notification that would allow transaction to be closed, buffers to be
recycled etc. etc.
>
> This not only means that traffic will double (sending items both back and
forth across the medium), but it also means that Publishers will need to
retain references to all elements they send that have not been
acknowledged, which will have quite drastic effects on memory consumption,
especially when the element traverses a binary boundary
(serialization/marshalling).
>>
>> Now, having just been schooled in the whole way this API works
asynchronously... I'm expecting that I've perhaps not understood how error
handling is intended to be used.
>
> I hope things are clearer,
> I suspect you'll find RS easier to reason about if you think of it as a
protocol rather than "just" methods and interfaces.
>
> Let's continue this discussion over at RS!
>
>>
>> cheers
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>> --
>> Greg Wilkins <gregw at webtide.com>  - an Intalio.com subsidiary
>> http://eclipse.org/jetty HTTP, SPDY, Websocket server and client that
scales
>> http://www.webtide.com  advice and support for jetty and cometd.
>
>
>
>
> --
> Cheers,
> ?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20150604/50dd7108/attachment.html>

From gregw at webtide.com  Thu Jun  4 19:52:50 2015
From: gregw at webtide.com (Greg Wilkins)
Date: Fri, 5 Jun 2015 09:52:50 +1000
Subject: [concurrency-interest] jdk9 Candidate classes Flow and
	SubmissionPublisher
In-Reply-To: <CANPzfU8TBkH0K15RnkLbuzFc6OqMMdZAOOtKAmpFnW=piWbAiA@mail.gmail.com>
References: <CAH_y2NEJFFdQgOc_XosOkxdRpKNVgBKOjrh0R383W5PtJfKbyg@mail.gmail.com>
	<CANPzfU-YvQZiq03_+y1BN7TgBSnztDqwFBbmnye0R00fbfS-UA@mail.gmail.com>
	<CAH_y2NE2-9zK2CBUEJjumdhvUX+B44R8wTXTOGY6ceq1mxDKSA@mail.gmail.com>
	<CANPzfU8TBkH0K15RnkLbuzFc6OqMMdZAOOtKAmpFnW=piWbAiA@mail.gmail.com>
Message-ID: <CAH_y2NHAMbs2HA994LMqVs=+zkEFj7x6kEP+k81XRHKopBpqiA@mail.gmail.com>

On 4 June 2015 at 20:55, Viktor Klang <viktor.klang at gmail.com> wrote:

> Having read your email I'll have to disagree, since you/we are talking
> about why RS wasn't implemented in some other way I think it still belongs
> as a discussion over at RS?to keep things close to where they belong. Would
> you agree?


Taking this back to a new issue:
https://github.com/reactive-streams/reactive-streams-jvm/issues/271

cheers

-- 
Greg Wilkins <gregw at webtide.com <gregw at intalio.com>>  - *an Intalio.com
subsidiary*
http://eclipse.org/jetty HTTP, SPDY, Websocket server and client that scales
http://www.webtide.com  advice and support for jetty and cometd.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20150605/b64fb292/attachment.html>

From thurston at nomagicsoftware.com  Fri Jun 12 06:51:21 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Fri, 12 Jun 2015 03:51:21 -0700 (MST)
Subject: [concurrency-interest] Basic Question about F/J
In-Reply-To: <556DE2F2.4080607@javaspecialists.eu>
References: <556DE2F2.4080607@javaspecialists.eu>
Message-ID: <1434106281049-12605.post@n7.nabble.com>

Dr Heinz M. Kabutz wrote
> Hi everyone,
> 
> inside the compute method of a recursive action or task, I usually 
> recommend calling the invoke() method of 
*
> any created FJTask
*
> .  

Do you mean that your implementations do:

<code>
class MyRecursiveTask

Integer compute()
MyRecursiveTask right = new MyRecursiveTask(...)
MyRecursiveTask left = new MyRecursiveTask(...)
return right.invoke() + left.invoke()
</code>

Surely not?




--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Basic-Question-about-F-J-tp12595p12605.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From heinz at javaspecialists.eu  Fri Jun 12 08:04:45 2015
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Fri, 12 Jun 2015 15:04:45 +0300
Subject: [concurrency-interest] Basic Question about F/J
In-Reply-To: <1434106281049-12605.post@n7.nabble.com>
References: <556DE2F2.4080607@javaspecialists.eu>
	<1434106281049-12605.post@n7.nabble.com>
Message-ID: <557ACADD.3090005@javaspecialists.eu>

LOL, no of course not.


It would actually be nice to have an invokeAll() method also for 
RecursiveTask, not just RecursiveAction.  To do that, we would need a 
merge function that can combine results.  Something like this ....

    public static <T> T invokeAll(BiFunction<T, T, T> merger,
                                  T initial,
                                  RecursiveTask<T>... tasks) {
        T result = initial;
        Throwable ex = null;
        int last = tasks.length - 1;
        for (int i = last; i >= 0; --i) {
            ForkJoinTask<T> t = tasks[i];
            if (t == null) {
                if (ex == null)
                    ex = new NullPointerException();
            } else if (i != 0)
                t.fork();
            else {
                result = merger.apply(result, t.invoke());
                if (ex == null && t.isCompletedAbnormally()) {
                    ex = t.getException();
                }
            }
        }
        for (int i = 1; i <= last; ++i) {
            ForkJoinTask<T> t = tasks[i];
            if (t != null) {
                if (ex != null)
                    t.cancel(false);
                else {
                    result = merger.apply(result, 
t.join());                   
                    if (t.isCompletedAbnormally()) {
                        ex = t.getException();
                    }
                }
            }
        }
        if (ex != null)
            rethrow(ex);
        return result;
    }


Regards

Heinz
-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun/Oracle Java Champion since 2005
JavaOne Rock Star Speaker 2012
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz



thurstonn wrote:
> Dr Heinz M. Kabutz wrote
>   
>> Hi everyone,
>>
>> inside the compute method of a recursive action or task, I usually 
>> recommend calling the invoke() method of 
>>     
> *
>   
>> any created FJTask
>>     
> *
>   
>> .  
>>     
>
> Do you mean that your implementations do:
>
> <code>
> class MyRecursiveTask
>
> Integer compute()
> MyRecursiveTask right = new MyRecursiveTask(...)
> MyRecursiveTask left = new MyRecursiveTask(...)
> return right.invoke() + left.invoke()
> </code>
>
> Surely not?
>
>
>
>
> --
> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Basic-Question-about-F-J-tp12595p12605.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>   
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20150612/4655c153/attachment.html>

From oleksandr.otenko at oracle.com  Fri Jun 12 09:26:03 2015
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Fri, 12 Jun 2015 14:26:03 +0100
Subject: [concurrency-interest] Basic Question about F/J
In-Reply-To: <557ACADD.3090005@javaspecialists.eu>
References: <556DE2F2.4080607@javaspecialists.eu>	<1434106281049-12605.post@n7.nabble.com>
	<557ACADD.3090005@javaspecialists.eu>
Message-ID: <557ADDEB.5090306@oracle.com>

Wouldn't it be better to have fold in Arrays (or reduce like in Stream, 
but specialized to arrays)

Alex

On 12/06/2015 13:04, Dr Heinz M. Kabutz wrote:
> LOL, no of course not.
>
>
> It would actually be nice to have an invokeAll() method also for 
> RecursiveTask, not just RecursiveAction.  To do that, we would need a 
> merge function that can combine results.  Something like this ....
>
>     public static <T> T invokeAll(BiFunction<T, T, T> merger,
>                                   T initial,
>                                   RecursiveTask<T>... tasks) {
>         T result = initial;
>         Throwable ex = null;
>         int last = tasks.length - 1;
>         for (int i = last; i >= 0; --i) {
>             ForkJoinTask<T> t = tasks[i];
>             if (t == null) {
>                 if (ex == null)
>                     ex = new NullPointerException();
>             } else if (i != 0)
>                 t.fork();
>             else {
>                 result = merger.apply(result, t.invoke());
>                 if (ex == null && t.isCompletedAbnormally()) {
>                     ex = t.getException();
>                 }
>             }
>         }
>         for (int i = 1; i <= last; ++i) {
>             ForkJoinTask<T> t = tasks[i];
>             if (t != null) {
>                 if (ex != null)
>                     t.cancel(false);
>                 else {
>                     result = merger.apply(result, t.join());
>                     if (t.isCompletedAbnormally()) {
>                         ex = t.getException();
>                     }
>                 }
>             }
>         }
>         if (ex != null)
>             rethrow(ex);
>         return result;
>     }
>
>
> Regards
>
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun/Oracle Java Champion since 2005
> JavaOne Rock Star Speaker 2012
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
>
> thurstonn wrote:
>> Dr Heinz M. Kabutz wrote
>>    
>>> Hi everyone,
>>>
>>> inside the compute method of a recursive action or task, I usually
>>> recommend calling the invoke() method of
>>>      
>> *
>>    
>>> any created FJTask
>>>      
>> *
>>    
>>> .
>>>      
>>
>> Do you mean that your implementations do:
>>
>> <code>
>> class MyRecursiveTask
>>
>> Integer compute()
>> MyRecursiveTask right = new MyRecursiveTask(...)
>> MyRecursiveTask left = new MyRecursiveTask(...)
>> return right.invoke() + left.invoke()
>> </code>
>>
>> Surely not?
>>
>>
>>
>>
>> --
>> View this message in context:http://jsr166-concurrency.10961.n7.nabble.com/Basic-Question-about-F-J-tp12595p12605.html
>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>    
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20150612/755226ef/attachment.html>

From heinz at javaspecialists.eu  Fri Jun 12 10:01:49 2015
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Fri, 12 Jun 2015 17:01:49 +0300
Subject: [concurrency-interest] Basic Question about F/J
In-Reply-To: <557ADDEB.5090306@oracle.com>
References: <556DE2F2.4080607@javaspecialists.eu>	<1434106281049-12605.post@n7.nabble.com>
	<557ACADD.3090005@javaspecialists.eu> <557ADDEB.5090306@oracle.com>
Message-ID: <557AE64D.5070904@javaspecialists.eu>

Thanks for the suggestion Oleksandr.

I guess we could do it that way, but it would mean that we don't have 
the option of canceling all the tasks if one of them throws an 
exception.  We would also /always/ call fork/join, even when we could 
just call invoke():

    public static <T> T invokeAll(BinaryOperator<T> merger,
                                  T identity,
                                  RecursiveTask<T>... tasks) {
        Stream.of(tasks).forEach(ForkJoinTask::fork);
        return Stream.of(tasks).map(ForkJoinTask::join).reduce(identity, 
merger);
    }

Regards

Heinz
-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun/Oracle Java Champion since 2005
JavaOne Rock Star Speaker 2012
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz



Oleksandr Otenko wrote:
> Wouldn't it be better to have fold in Arrays (or reduce like in 
> Stream, but specialized to arrays)
>
> Alex
>
> On 12/06/2015 13:04, Dr Heinz M. Kabutz wrote:
>> LOL, no of course not.
>>
>>
>> It would actually be nice to have an invokeAll() method also for 
>> RecursiveTask, not just RecursiveAction.  To do that, we would need a 
>> merge function that can combine results.  Something like this ....
>>
>>     public static <T> T invokeAll(BiFunction<T, T, T> merger,
>>                                   T initial,
>>                                   RecursiveTask<T>... tasks) {
>>         T result = initial;
>>         Throwable ex = null;
>>         int last = tasks.length - 1;
>>         for (int i = last; i >= 0; --i) {
>>             ForkJoinTask<T> t = tasks[i];
>>             if (t == null) {
>>                 if (ex == null)
>>                     ex = new NullPointerException();
>>             } else if (i != 0)
>>                 t.fork();
>>             else {
>>                 result = merger.apply(result, t.invoke());
>>                 if (ex == null && t.isCompletedAbnormally()) {
>>                     ex = t.getException();
>>                 }
>>             }
>>         }
>>         for (int i = 1; i <= last; ++i) {
>>             ForkJoinTask<T> t = tasks[i];
>>             if (t != null) {
>>                 if (ex != null)
>>                     t.cancel(false);
>>                 else {
>>                     result = merger.apply(result, 
>> t.join());                   
>>                     if (t.isCompletedAbnormally()) {
>>                         ex = t.getException();
>>                     }
>>                 }
>>             }
>>         }
>>         if (ex != null)
>>             rethrow(ex);
>>         return result;
>>     }
>>
>>
>> Regards
>>
>> Heinz
>> -- 
>> Dr Heinz M. Kabutz (PhD CompSci)
>> Author of "The Java(tm) Specialists' Newsletter"
>> Sun/Oracle Java Champion since 2005
>> JavaOne Rock Star Speaker 2012
>> http://www.javaspecialists.eu
>> Tel: +30 69 75 595 262
>> Skype: kabutz
>>     
>>
>>
>> thurstonn wrote:
>>> Dr Heinz M. Kabutz wrote
>>>   
>>>> Hi everyone,
>>>>
>>>> inside the compute method of a recursive action or task, I usually 
>>>> recommend calling the invoke() method of 
>>>>     
>>> *
>>>   
>>>> any created FJTask
>>>>     
>>> *
>>>   
>>>> .  
>>>>     
>>>
>>> Do you mean that your implementations do:
>>>
>>> <code>
>>> class MyRecursiveTask
>>>
>>> Integer compute()
>>> MyRecursiveTask right = new MyRecursiveTask(...)
>>> MyRecursiveTask left = new MyRecursiveTask(...)
>>> return right.invoke() + left.invoke()
>>> </code>
>>>
>>> Surely not?
>>>
>>>
>>>
>>>
>>> --
>>> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Basic-Question-about-F-J-tp12595p12605.html
>>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>   
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>     
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20150612/db610209/attachment-0001.html>

From oleksandr.otenko at oracle.com  Fri Jun 12 11:23:27 2015
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Fri, 12 Jun 2015 16:23:27 +0100
Subject: [concurrency-interest] Basic Question about F/J
In-Reply-To: <557AE64D.5070904@javaspecialists.eu>
References: <556DE2F2.4080607@javaspecialists.eu>	<1434106281049-12605.post@n7.nabble.com>
	<557ACADD.3090005@javaspecialists.eu> <557ADDEB.5090306@oracle.com>
	<557AE64D.5070904@javaspecialists.eu>
Message-ID: <557AF96F.2060804@oracle.com>

Yes, we can cancel. There's a version of reduce that can do that.

After fork,

Stream.of(tasks).reduce(identity, (prev, next) -> {if (prev instanceof 
Exception) next.cancel(false);
                                                   else { T y = next.join();
                                                          if 
(next.isCompletedAbnormally()) prev=next.getException();
else prev = merger(prev, y);};
return prev;}, null)

You don't have to fail if one of the tasks fails - what you do upon 
failure is really task-dependent.

Alex

On 12/06/2015 15:01, Dr Heinz M. Kabutz wrote:
> Thanks for the suggestion Oleksandr.
>
> I guess we could do it that way, but it would mean that we don't have 
> the option of canceling all the tasks if one of them throws an 
> exception.  We would also /always/ call fork/join, even when we could 
> just call invoke():
>
>     public static <T> T invokeAll(BinaryOperator<T> merger,
>                                   T identity,
>                                   RecursiveTask<T>... tasks) {
>         Stream.of(tasks).forEach(ForkJoinTask::fork);
>         return 
> Stream.of(tasks).map(ForkJoinTask::join).reduce(identity, merger);
>     }
>
> Regards
>
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun/Oracle Java Champion since 2005
> JavaOne Rock Star Speaker 2012
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
>
> Oleksandr Otenko wrote:
>> Wouldn't it be better to have fold in Arrays (or reduce like in 
>> Stream, but specialized to arrays)
>>
>> Alex
>>
>> On 12/06/2015 13:04, Dr Heinz M. Kabutz wrote:
>>> LOL, no of course not.
>>>
>>>
>>> It would actually be nice to have an invokeAll() method also for 
>>> RecursiveTask, not just RecursiveAction.  To do that, we would need 
>>> a merge function that can combine results.  Something like this ....
>>>
>>>     public static <T> T invokeAll(BiFunction<T, T, T> merger,
>>>                                   T initial,
>>>                                   RecursiveTask<T>... tasks) {
>>>         T result = initial;
>>>         Throwable ex = null;
>>>         int last = tasks.length - 1;
>>>         for (int i = last; i >= 0; --i) {
>>>             ForkJoinTask<T> t = tasks[i];
>>>             if (t == null) {
>>>                 if (ex == null)
>>>                     ex = new NullPointerException();
>>>             } else if (i != 0)
>>>                 t.fork();
>>>             else {
>>>                 result = merger.apply(result, t.invoke());
>>>                 if (ex == null && t.isCompletedAbnormally()) {
>>>                     ex = t.getException();
>>>                 }
>>>             }
>>>         }
>>>         for (int i = 1; i <= last; ++i) {
>>>             ForkJoinTask<T> t = tasks[i];
>>>             if (t != null) {
>>>                 if (ex != null)
>>>                     t.cancel(false);
>>>                 else {
>>>                     result = merger.apply(result, t.join());
>>>                     if (t.isCompletedAbnormally()) {
>>>                         ex = t.getException();
>>>                     }
>>>                 }
>>>             }
>>>         }
>>>         if (ex != null)
>>>             rethrow(ex);
>>>         return result;
>>>     }
>>>
>>>
>>> Regards
>>>
>>> Heinz
>>> -- 
>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> Author of "The Java(tm) Specialists' Newsletter"
>>> Sun/Oracle Java Champion since 2005
>>> JavaOne Rock Star Speaker 2012
>>> http://www.javaspecialists.eu
>>> Tel: +30 69 75 595 262
>>> Skype: kabutz
>>>      
>>>
>>>
>>> thurstonn wrote:
>>>> Dr Heinz M. Kabutz wrote
>>>>    
>>>>> Hi everyone,
>>>>>
>>>>> inside the compute method of a recursive action or task, I usually
>>>>> recommend calling the invoke() method of
>>>>>      
>>>> *
>>>>    
>>>>> any created FJTask
>>>>>      
>>>> *
>>>>    
>>>>> .
>>>>>      
>>>>
>>>> Do you mean that your implementations do:
>>>>
>>>> <code>
>>>> class MyRecursiveTask
>>>>
>>>> Integer compute()
>>>> MyRecursiveTask right = new MyRecursiveTask(...)
>>>> MyRecursiveTask left = new MyRecursiveTask(...)
>>>> return right.invoke() + left.invoke()
>>>> </code>
>>>>
>>>> Surely not?
>>>>
>>>>
>>>>
>>>>
>>>> --
>>>> View this message in context:http://jsr166-concurrency.10961.n7.nabble.com/Basic-Question-about-F-J-tp12595p12605.html
>>>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>    
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>      
>>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20150612/7feb393a/attachment.html>

From thurston at nomagicsoftware.com  Sat Jun 13 01:27:38 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Fri, 12 Jun 2015 22:27:38 -0700 (MST)
Subject: [concurrency-interest] Basic Question about F/J
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEHPLAAA.davidcholmes@aapt.net.au>
References: <556DE2F2.4080607@javaspecialists.eu>
	<NFBBKALFDCPFIDBNKAPCAEHPLAAA.davidcholmes@aapt.net.au>
	<556E3561.9090507@oracle.com>
	<NFBBKALFDCPFIDBNKAPCKEHPLAAA.davidcholmes@aapt.net.au>
Message-ID: <1434173258625-12610.post@n7.nabble.com>

David Holmes-6 wrote
> Aleksey Shipilev writes:
>> On 06/02/2015 11:53 PM, David Holmes wrote:
>> > invoke() doesn't process the task on the current thread - it
>> arranges for
>> > async execution and then waits for it to complete - so you are wasting
>> a
>> > thread if you use invoke() rather than compute().
>>
>> Current implementation tries to process invoke() in the same thread. FJP
>> is actually about not wasting threads on dumb stuff :)
> 
> Yes it tries, so I should have said "potentially wasting a thread".
> 
> Cheers,
> David

No, invoke's logic is basically:
if (this task is not scheduled/forked)
      compute()
       
else
      join() // simplified a bit

Of course, after compute(), it does all of the necessary work for satisfying
the Future contract (invoke returns void).

So in respect to the OP, I can't think of any reason to prefer invoke() over
compute(), unless you intend to publish the RecursiveTask outside of the
compute() method, since otherwise invoke does unnecessary writes (including
a volatile write).

I've always thought of the example code in the javadoc (ignoring whether
fibonacci is the best example) as idiomatic, which I think is the real point
of the question



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Basic-Question-about-F-J-tp12595p12610.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From thurston at nomagicsoftware.com  Sat Jun 13 07:41:13 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Sat, 13 Jun 2015 04:41:13 -0700 (MST)
Subject: [concurrency-interest] Basic Question about F/J
In-Reply-To: <557ACADD.3090005@javaspecialists.eu>
References: <556DE2F2.4080607@javaspecialists.eu>
	<1434106281049-12605.post@n7.nabble.com>
	<557ACADD.3090005@javaspecialists.eu>
Message-ID: <1434195673832-12611.post@n7.nabble.com>

Well, that's what you wrote.

I guess you must have meant replacing (using the javadoc example):

Integer compute() {
      if (n <= 1)
        return n;
      Fibonacci f1 = new Fibonacci(n - 1);
      f1.fork();
      Fibonacci f2 = new Fibonacci(n - 2);
      *return f2.compute() + f1.join();*
    }

with:
Integer compute() {
      if (n <= 1)
        return n;
      Fibonacci f1 = new Fibonacci(n - 1);
      f1.fork();
      Fibonacci f2 = new Fibonacci(n - 2);
      *return f2.invoke() + f1.join();*
    }

or did you mean:
Integer compute() {
      if (n <= 1)
        return n;
      Fibonacci f1 = new Fibonacci(n - 1);
      Fibonacci f2 = new Fibonacci(n - 2);

      *ForkJoinTask.invokeAll(f1, f2);
      return f1.join() + f2.join();*
    }







--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Basic-Question-about-F-J-tp12595p12611.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From christian.schudt at gmx.de  Sun Jun 28 16:14:22 2015
From: christian.schudt at gmx.de (Christian Schudt)
Date: Sun, 28 Jun 2015 22:14:22 +0200
Subject: [concurrency-interest] CompletableFuture inconsistent exception
	handling?!
Message-ID: <63DCA0D8-7D67-47E1-A8E2-23B755BD682C@gmx.de>

Hi,

I am new to this list, because I have a couple of questions with regards to CompletableFuture and CompletionStage.

I discovered inconsistent behavior with the exception handling of CompletableFuture. When using completeExceptionally and there is no other CompletionStage in between, then the Exception is not wrapped in CompletionException. Otherwise or when using supplyAsync, it is wrapped.

Is this a bug or a design decision?

The problem for API users is that they never know if they are dealing with a CompletionException or with another one, leading to code like this in the handle or whenComplete function:

Throwable realException = t instanceof CompletionException ? t.getCause() : t;

Thanks for answers!

?Christian

Here?s my test code:


CompletableFuture<String> completableFuture1 = new CompletableFuture<>();
completableFuture1.whenComplete((x, t) -> System.out.println("1: " + t));
completableFuture1.completeExceptionally(new RuntimeException("test"));

CompletableFuture<String> completableFuture2 = new CompletableFuture<>();
completableFuture2.thenApply(result -> null).whenComplete((x, t) -> System.out.println("2: " + t));
completableFuture2.completeExceptionally(new RuntimeException("test"));

CompletableFuture<String> completableFuture3 = CompletableFuture.supplyAsync(() -> {
    throw new RuntimeException("test");
});
completableFuture3.whenComplete((x, t) -> System.out.println("3: " + t));


It prints:

1: java.lang.RuntimeException: test
2: java.util.concurrent.CompletionException: java.lang.RuntimeException: test
3: java.util.concurrent.CompletionException: java.lang.RuntimeException: test

From martinrb at google.com  Mon Jun 29 19:23:39 2015
From: martinrb at google.com (Martin Buchholz)
Date: Mon, 29 Jun 2015 16:23:39 -0700
Subject: [concurrency-interest] CompletableFuture inconsistent exception
	handling?!
In-Reply-To: <63DCA0D8-7D67-47E1-A8E2-23B755BD682C@gmx.de>
References: <63DCA0D8-7D67-47E1-A8E2-23B755BD682C@gmx.de>
Message-ID: <CA+kOe0_wMb770vG2904tHmFU+0aSwLLie02zuECVFJx5gu6gJw@mail.gmail.com>

Hopefully Doug will answer authoritatively, but I'll try:

On Sun, Jun 28, 2015 at 1:14 PM, Christian Schudt <christian.schudt at gmx.de>
wrote:

> Hi,
>
> I am new to this list, because I have a couple of questions with regards
> to CompletableFuture and CompletionStage.
>
> I discovered inconsistent behavior with the exception handling of
> CompletableFuture. When using completeExceptionally and there is no other
> CompletionStage in between, then the Exception is not wrapped in
> CompletionException. Otherwise or when using supplyAsync, it is wrapped.
>
> Is this a bug or a design decision?
>

Design decision.  I agree it's a confusing situation.


> The problem for API users is that they never know if they are dealing with
> a CompletionException or with another one, leading to code like this in the
> handle or whenComplete function:
>
> Throwable realException = t instanceof CompletionException ? t.getCause()
> : t;
>
>
It allows you (forces you to?) distinguish between futures explicitly
completed vs. inherited from another source, where it will be wrapped.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20150629/e23e6516/attachment.html>

