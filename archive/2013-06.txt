From alex.snaps at gmail.com  Sat Jun  1 10:31:28 2013
From: alex.snaps at gmail.com (Alex Snaps)
Date: Sat, 1 Jun 2013 10:31:28 -0400
Subject: [concurrency-interest] jsr166e.CHMv8.TreeBin bug ?
Message-ID: <CAKux6pZebkLJgX83+6DOhZE9me=wJRqqFaJ94RkdD7=YO5Qndg@mail.gmail.com>

Hey,
We've been starting using CHMv8 at Terracotta a little while back to power
some of Ehcache's data structure. Back in Dec. we found some entries "being
lost", but hunting the bug down, it turned out it got fixed at the very
same time. But we kept the test around (and more actually, since we were
actually not using the vanilla CHMv8).
Sadly a slight variant of it seems to still be in current code. It only
bubbled up now, after months on continuous testing in our CI environment.
The bug manifest when having lots of colliding in hash codes or rather even
identical ones.
During a debug session with my colleagues Chris & Louis, we believe we've
hunted it down to how the tree is walked. More specifically,
in jsr166e.ConcurrentHashMapV8.TreeBin.getTreeNode, this last inner bit is
probably the culprit:

                            TreeNode<V> r = null, pl, pr; // check both
sides
                            if ((pr = p.right) != null && h >= pr.hash &&
                                (r = getTreeNode(h, k, pr)) != null)
                                return r;
                            else if ((pl = p.left) != null && h <= pl.hash)
                                dir = -1;
                            else // nothing there
                                return null;

On the second line above (line 834 in jsr166e.CHMv8) the second condition
doesn't seem right. If we understood it right, both left and right might
have identical hashes to p.hash, so that left might need to be checked too.
Feels like this condition would apply if duplicated hashes weren't an
option, but sadly they are.

Attached is the test I quickly ported from Ehcache's tests that exposes the
issue and the one we used to track it down on jsr166e code. It certainly
could be ported to only test TreeNode now that we believe we've narrowed it
down to being the culprit (and using less entries!).

Basically it shows how EvilKey ( "6137" ) can't be retrieved anymore. I
actually becomes "missing" when inserting the entry for i ==
8372 (ConcurrentHashMapV8$1) and the tree gets rebalanced. As far as we
could tell the rebalancing doesn't break any invariance... So
that jsr166e.ConcurrentHashMapV8.TreeBin.getTreeNode seems to be where the
problem lies. Actually putTreeNode probably shares the issue, even though
this test doesn't expose this (as p isn't the root of the tree in this
case). Looks like this "h >= pr.hash" condition should just not be there...
Hope this makes sense and helps.
Alex

-- 
Alex Snaps <alex.snaps at gmail.com>
Principal Software Engineer - Terracotta
http://twitter.com/alexsnaps
http://www.linkedin.com/in/alexsnaps
http://withinthefra.me
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130601/379e1c7a/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ConcurrentHashMapV8Test.java
Type: application/octet-stream
Size: 2434 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130601/379e1c7a/attachment.obj>

From dl at cs.oswego.edu  Sat Jun  1 10:37:35 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 01 Jun 2013 10:37:35 -0400
Subject: [concurrency-interest] jsr166e.CHMv8.TreeBin bug ?
In-Reply-To: <CAKux6pZebkLJgX83+6DOhZE9me=wJRqqFaJ94RkdD7=YO5Qndg@mail.gmail.com>
References: <CAKux6pZebkLJgX83+6DOhZE9me=wJRqqFaJ94RkdD7=YO5Qndg@mail.gmail.com>
Message-ID: <51AA072F.8040905@cs.oswego.edu>

On 06/01/13 10:31, Alex Snaps wrote:

> During a debug session with my colleagues Chris & Louis, we believe we've hunted
> it down to how the tree is walked.

Yes. Sorry. This is one consequence of jsr166e version not
keeping up with jdk8 java.util.concurrent version. I'll
put out an update within a few days.

-Doug



From alex.snaps at gmail.com  Sat Jun  1 10:46:43 2013
From: alex.snaps at gmail.com (Alex Snaps)
Date: Sat, 1 Jun 2013 10:46:43 -0400
Subject: [concurrency-interest] jsr166e.CHMv8.TreeBin bug ?
In-Reply-To: <51AA072F.8040905@cs.oswego.edu>
References: <CAKux6pZebkLJgX83+6DOhZE9me=wJRqqFaJ94RkdD7=YO5Qndg@mail.gmail.com>
	<51AA072F.8040905@cs.oswego.edu>
Message-ID: <CAKux6paN4QQOoW2LCvSVyW-iHvhuPbdvyjs=SBo=bQrYHwUJ=Q@mail.gmail.com>

Haha! Yes... I see now it was fixed in jsr166's repo on Wed.
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.java?r1=1.216&r2=1.217
Awesome! Thanks...
Alex



On Sat, Jun 1, 2013 at 10:37 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 06/01/13 10:31, Alex Snaps wrote:
>
>  During a debug session with my colleagues Chris & Louis, we believe we've
>> hunted
>> it down to how the tree is walked.
>>
>
> Yes. Sorry. This is one consequence of jsr166e version not
> keeping up with jdk8 java.util.concurrent version. I'll
> put out an update within a few days.
>
> -Doug
>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Alex Snaps <alex.snaps at gmail.com>
Principal Software Engineer - Terracotta
http://twitter.com/alexsnaps
http://www.linkedin.com/in/alexsnaps
http://withinthefra.me
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130601/3e0069b7/attachment.html>

From esarge at pobox.com  Mon Jun  3 19:43:54 2013
From: esarge at pobox.com (Edward Sargisson)
Date: Mon, 3 Jun 2013 16:43:54 -0700
Subject: [concurrency-interest] Does j.u.c.SynchronousQueue's use of
	Interrupt interfere with NIO AbstractInterruptibleChannel?
Message-ID: <CAH4ZcEv8WhP7QPa2f1k_VB-_Anwzci=C9dAj7zEJBhX8idE3RA@mail.gmail.com>

Hi all,
I've been chasing down issues with Apache Flume and Log4j2. I ~may~ be able
to explain a problem as SynchronousQueue interacting with
AbstractInterruptibleChannel but I'm not convinced my understanding is
sufficient to be certain. I decided it might be worth asking the question
here - if only for my own learning.

The problem[1] appears to be that if a put or a take fail on the
SynchronousQueue in the AvroIpcClient then it causes an interrupt on the
Flume FileChannel thread (which uses NIO FileChannel which inherits from
AbstractInterruptibleChannel).

The docs and code for the NIO channels show that it does not expect to be
interrupted.

Is SynchronousQueue actually interrupting the thread or is the use of
Interrupt in that class doing something else?

Many thanks in advance,
Edward

Links:
[1] https://issues.apache.org/jira/browse/FLUME-2067
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130603/8c319afc/attachment.html>

From nathan.reynolds at oracle.com  Tue Jun  4 16:19:22 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 04 Jun 2013 13:19:22 -0700
Subject: [concurrency-interest] JEP-159 Enhanced Class Redefinition vs
	Unsafe.___FieldOffset()
Message-ID: <51AE4BCA.8060005@oracle.com>

JEP 159 Enhanced Class Redefinition 
(seehttp://openjdk.java.net/jeps/159) will allow for adding and removing 
fields in a class.  Also, a field could be changed in size as well (e.g. 
long ? int).  When the change happens, the heap is scanned for all of 
the instances of the class(es) and all of the instances are modified.  
The cost is about that of a full GC.

I think the original driver for JEP 159 was to enhance what debuggers 
can change on the fly as the program is running.  I envision using JEP 
159 to remove dead fields, deal with fields used in a small percentage 
of instances (rarely used) and reduce the size of oversized fields.  
Dead and rarely used fields account for 6.9% of an average heap.  
Oversized fields account for 1.5% of an average heap.  By _occasionally_ 
using JEP 159 at runtime, we could change the class definitions to save 
most of this space and hence improve GC times and perhaps response times.

If I understand correctly, Unsafe.objectFieldOffset() and 
Unsafe.staticFieldOffset() return the number bytes from the beginning of 
the instance or class where the field is located.  This offset is 
typically obtained when the class is loaded or the instance is 
constructed.  For example, 
java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater will get 
the offset in the constructor for the specified field and class.  It 
keeps this offset for the lifetime of the CASUpdater instance.  The 
field and class can be any loaded class.

So, what will happen when JEP 159...

 1. removes the field used by CASUpdater?  It seems like CASUpdater will
    corrupt the instance or the object header of the next object.
 2. adds or removes a different field and this shifts the field used by
    CASUpdater?
 3. changes the long field to an int?
 4. adds or removes @Contended?  This will rearrange the fields in all
    of the instances.

CASUpdater is just one class.  What about all of the other classes which 
use or _will_ use Unsafe.___FieldOffset?

Maybe JEP 159 has already solved the problem.  If so, I would like to 
hear how.  If not, how can this problem be solved?

If JEP 159 changes the returned value of ___FieldOffset() from an offset 
to a cookie, what code will break which assumes it is an offset?

The value returned from Unsafe.___FieldOffset seems to be used as a 
cookie.  This cookie can be an index into an array of field offsets.  
JEP 159 will then have to fix up the array of field offsets for the 
affected classes.  If a field is removed or altered in size, then the 
existing entry in the array should be changed to an error flag (i.e. 
-1).  In the case of adding or altering a field, then a new entry should 
be added to the array.  This will prevent corruptions since the Unsafe 
operations will check the entry for the error flag.

The engineer will have to be aware that if they change the size of the 
field from a long to an int, then they have to change the 
AtomicLongFieldUpdater to an AtomicIntegerFieldUpdater.  Currently, the 
compiler doesn't flag a problem if an Atomic__FieldUpdater specifies a 
non-existent field or a field of the wrong type or non-volatile.  These 
checks are left for runtime.  Maybe the compiler should make this check 
as well.

The code that deals with dead, rarely used and oversized fields can't 
change the fields that were used by Unsafe.___FieldOffsets. If a field 
is changed and then Unsafe.___FieldOffset is called on that field, then 
those fields will have to be reverted.

Is there a better solution?
-- 
Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130604/0333b8c1/attachment.html>

From andrew_nuss at yahoo.com  Fri Jun  7 09:17:52 2013
From: andrew_nuss at yahoo.com (Andy Nuss)
Date: Fri, 7 Jun 2013 06:17:52 -0700 (PDT)
Subject: [concurrency-interest] safe publication ("initializing an object
	from static initializer")
Message-ID: <1370611072.1771.YahooMailNeo@web141101.mail.bf1.yahoo.com>

Hi,

The quote from JCIP section 3.5.3, "initializing an object from static initializer", has me wondering in terms of non-64 bit static, but non-final, scalar and object variables initialized in an initializer directly, or indirectly thru a static function called by the initializer that sets such variable, what are the rules for publishing the change safely to other cores?

Are all changes to static variables published at the end of the static initialization of the class?? What does hotspot do, and what exactly does this JCIP reference mean?

Andy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130607/8533f26d/attachment.html>

From thurston at nomagicsoftware.com  Mon Jun 10 01:07:44 2013
From: thurston at nomagicsoftware.com (thurstonn)
Date: Sun, 9 Jun 2013 22:07:44 -0700 (PDT)
Subject: [concurrency-interest] can a core see semi-constructed objects
 in array before the publishing act
In-Reply-To: <1369196676.49726.YahooMailNeo@web141104.mail.bf1.yahoo.com>
References: <1369196676.49726.YahooMailNeo@web141104.mail.bf1.yahoo.com>
Message-ID: <1370840864808-9713.post@n7.nabble.com>

Andy Nuss wrote
> Hi,
> 
> I have a volatile array "ar" of objects.? I wish to add tuples of N
> objects to the array with the following idiom:
> 
> void publish (Object obj1, Object obj2, Object obj3, Object obj4)
> {
> ???? lock();????????????????????????????????????? // atomic lock
> 
> ???? Object[] ar = this.ar;
> ???? int pos = calculatepos(...);
> ???? ar[pos+1] = obj2;
> ???? ar[pos+2] = obj3;
> ???? ar[pos+3] = obj4;
> 
> ???? ar[pos] = obj1;???????????????????????? // if the reader sees null,
> the tuple is empty to him at that moment
> ???? this.ar = this.ar;?????????????????????? // java.util.concurrency
> uses this idiom to publish
> ???? unlock();
> }
> 
> ...
> 
> Andy

Why not define a Tuple class:
class Tuple
{
final Object partOne
final Object partTwo
final Object partThree
final Object partFour

Tuple(Object partOne, Object partTwo, Object partThree, Object partFour)
{
     this.partOne = partOne;
     this.partTwo = partTwo;
     this.partThree = partThree;
     this.partFour = partFour;
}

then define ar as Tuple[] ar;

this would obviate any visibility problems for the readers, i.e. when
iterating over /ar/, they would either see null or a reference to a Tuple
with the fully *initialized* four parts even if the part Objects were not
strictly immutable (not to mention it's more O-O) (this assumes of course
that the parts are not mutated after constructing the Tuple)

as far as "effectively final", we use that term to refer to classes that
have fields that are only set once, but for a variety of reasons it may not
be possible/advisable to set in the constructor (cf: DCL).  I've always
thought that would be a useful annotation for a field; although I'm
guessing, I would think that the VM might be able to make useful
optimizations from that?

and finally, does this.ar = this.ar serve any purpose?  I would have thought
that the JVM (maybe even javac?) could simple elide that, regardless of *ar*
being volatile.  I was unaware that j.u.c. relied on that.
Also would have thought that there is no difference between 
Object lar = this.ar
....
this.ar = this.ar and
this.ar = lar








--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/can-a-core-see-semi-constructed-objects-in-array-before-the-publishing-act-tp9691p9713.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.


From corporate.piyush at gmail.com  Mon Jun 10 02:37:57 2013
From: corporate.piyush at gmail.com (piyush katariya)
Date: Mon, 10 Jun 2013 07:37:57 +0100
Subject: [concurrency-interest]  Design of Thread Safe Iterator Proxy
Message-ID: <CAA5REoU+3sMAHa7Z2=k3pdETeZck1z5WGDe8P9v18_fGQUTQmA@mail.gmail.com>

Hi,

       so i was in the need of ThreadSafe iterator, so that multiple
threads can access over it concurrently without  throwing
"ConcurrentModificationException".

i came with solution attached herewith, but for some reason..multiple
threads from thread pool after iterating over, stucks...

can somebody help me with it..


Regards,
Piyush Katariya
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130610/f015fcbc/attachment-0001.html>
-------------- next part --------------
package org.jhighfun.util.batch;

import java.util.Iterator;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Thread safe proxy for existing Iterator
 *
 * @author Piyush Katariya
 */
public class SafeIterator<T> implements Iterator<T> {

    private final Iterator<T> iterator;
    private final Lock lock = new ReentrantLock();

    public SafeIterator(Iterator<T> iterator) {
        this.iterator = iterator;
    }

    public boolean hasNext() {
        lock.lock();
        boolean hasNext = false;
        try {
            hasNext = iterator.hasNext();
        } catch (Exception e) {
            lock.unlock();
        }
        return hasNext;
    }

    public T next() {
        T next = null;
        try {
            next = iterator.next();
        } finally {
            lock.unlock();
        }
        return next;
    }

    public void remove() {
        lock.lock();
        try {
            iterator.remove();
        } finally {
            lock.unlock();
        }
    }
}

From mudit.f2004912 at gmail.com  Wed Jun 12 12:47:09 2013
From: mudit.f2004912 at gmail.com (Mudit Verma)
Date: Wed, 12 Jun 2013 18:47:09 +0200
Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely wait-free?
Message-ID: <CAMM2gsP_x7387eCaR1jsm1RsoDFf3ijw=4u+YJCjPyyW+=nnDQ@mail.gmail.com>

Hi All,

As I read the documentation in java.util.concurrent it says the
implementation is wait-free. However, I doubt it.  For example an
enqueue operation loops forever until it is able to CAS new element to
the tail of queue.  Now, there could be a case, where other threads
are just fast enough and never give this guy a chance to apply its
CAS.

However, it helps other threads to update their 2nd CAS (which is to
update the tail pointer).     As far as first CAS goes, it's not
wait-free I believe.   Any thoughts?


 188:     public boolean offer(E e) {
 189:         if (e == null) throw new NullPointerException();
 190:         Node<E> n = new Node<E>(e, null);
 191:         for (;;) {
 192:             Node<E> t = tail;
 193:             Node<E> s = t.getNext();
 194:             if (t == tail) {
 195:                 if (s == null) {
 196:                     if (t.casNext(s, n)) {
 197:                         casTail(t, n);
 198:                         return true;
 199:                     }
 200:                 } else {
 201:                     casTail(t, s);
 202:                 }
 203:             }
 204:         }
 205:     }
 206:


Thanks,
Mudit

From nitsanw at yahoo.com  Thu Jun 13 05:11:15 2013
From: nitsanw at yahoo.com (Nitsan Wakart)
Date: Thu, 13 Jun 2013 02:11:15 -0700 (PDT)
Subject: [concurrency-interest] What is the eetop field on Thread for?
Message-ID: <1371114675.99491.YahooMailNeo@web120701.mail.ne1.yahoo.com>

What would happen if I changed it(I know I shouldn't, but for the sake of the question)?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130613/ea86bddd/attachment.html>

From yankee.sierra at gmail.com  Sun Jun 16 17:51:23 2013
From: yankee.sierra at gmail.com (Yuval Shavit)
Date: Sun, 16 Jun 2013 17:51:23 -0400
Subject: [concurrency-interest] Design of Thread Safe Iterator Proxy
In-Reply-To: <CAA5REoU+3sMAHa7Z2=k3pdETeZck1z5WGDe8P9v18_fGQUTQmA@mail.gmail.com>
References: <CAA5REoU+3sMAHa7Z2=k3pdETeZck1z5WGDe8P9v18_fGQUTQmA@mail.gmail.com>
Message-ID: <CAE+h5-CqEFuEfExNB9Q8auTvc2nT56=HkiJzWsS4nJydtd+v3A@mail.gmail.com>

Hi Piyush,

This is a bit of a lengthy reply, apologies for that. The short of it is
that (a) this iterator still isn't thread-safe and (b) it's not needed to
fix a ConcurrentModificationException.

Firstly, note that the ConcurrentModificationException doesn't necessarily
have to do with concurrency. You can easily trigger it with a single
thread, as it just means that the collection was modified between an
iterator being created and next() being invoked on it. For instance, this
will trigger a CME:

    List<Integer> list = new ArrayList<Integer>();
    list.add(1);
    for (Integer i : list) {
        list.add(2); // modify the list, and then the implicit Iterator
will invoke next() for the next iteration
    }

    Exception in thread "main" java.util.ConcurrentModificationException
at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)
 at java.util.AbstractList$Itr.next(AbstractList.java:343)
at Cme.main(Cme.java:6)

That said, in your SafeIterator.hasNext() method, you only unlock the
ReentrantLock when the delegate iterator throws an exception. You probably
meant to put the unlock within a finally block, not a catch block. This bug
means that invoking hasNext() will never unlock the lock if there's no
exception thrown (which there usually isn't), which is what's causing
things to stick.

This error illustrates the importance of using the simplest mechanism that
works. In this case, I would make the lock object just a new Object() --
not a ReentrantLock -- and use synchronized blocks with it. That takes care
of the lock-try-finally-unlock pattern for you, eliminating the possibility
of this error.

  final Object lock = new Object();
 public boolean hasNext() { synchronized (lock) { return
iterator.hasNext(); } }
  ...

It's important to note that this iterator will still not be thread-safe if
the delegate iterator isn't thread-safe, which usually means that the
collection that originally created the iterator is itself thread-safe. One
obvious way to break the thread safety is to (a) create an ArrayList (which
is not thread-safe), (b) create an iterator from it (which is also not
thread safe), call this iterator-u (c) create a SafeIterator from
iterator-1, call it iterator-s, (d) publish iterator-s to some thread, then
(e) modify iterator-u (by calling next, remove() or possibly even hasNext()
on it) *or* modify the original ArrayList somehow. Those actions won't be
synchronized on the SafeIterator's "lock" object, breaking thread safety.

In fact, because the Iterator interface inherently uses a check-then-act
pattern (first you check if there's a next element using hasNext(), then
you get that element using next()), it's pretty tricky to create a
thread-safe Iterator. For instance, if an iterator has one element left in
it, you could have two threads invoke hasNext() on it and see that there's
a next element; then both invoke next() on it, and the second one of those
will trigger a NoSuchElementException because the first one had already
"taken" the last element. That's just a classic race condition, nothing
tricky as far as data races or such. It's best to just have each Iterator
be thread-local. If you need something like a thread-safe queue that
various threads can take from, try one of the interfaces/classes
in java.util.concurrent, such as BlockingQueue.

-Yuval


On Mon, Jun 10, 2013 at 2:37 AM, piyush katariya <corporate.piyush at gmail.com
> wrote:

> Hi,
>
>        so i was in the need of ThreadSafe iterator, so that multiple
> threads can access over it concurrently without  throwing
> "ConcurrentModificationException".
>
> i came with solution attached herewith, but for some reason..multiple
> threads from thread pool after iterating over, stucks...
>
> can somebody help me with it..
>
>
> Regards,
> Piyush Katariya
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130616/98ae3c6c/attachment.html>

From forax at univ-mlv.fr  Sun Jun 16 19:04:48 2013
From: forax at univ-mlv.fr (Remi Forax)
Date: Mon, 17 Jun 2013 01:04:48 +0200
Subject: [concurrency-interest] Design of Thread Safe Iterator Proxy
In-Reply-To: <CAA5REoU+3sMAHa7Z2=k3pdETeZck1z5WGDe8P9v18_fGQUTQmA@mail.gmail.com>
References: <CAA5REoU+3sMAHa7Z2=k3pdETeZck1z5WGDe8P9v18_fGQUTQmA@mail.gmail.com>
Message-ID: <51BE4490.1070407@univ-mlv.fr>

On 06/10/2013 08:37 AM, piyush katariya wrote:
> Hi,
>
>        so i was in the need of ThreadSafe iterator, so that multiple 
> threads can access over it concurrently without  throwing 
> "ConcurrentModificationException".
>
> i came with solution attached herewith, but for some reason..multiple 
> threads from thread pool after iterating over, stucks...
>
> can somebody help me with it..
>

I can explain why your program deadlock, it's easy.
I will only explain why it deadlock if the client code is:
   while(hasNext()) { it.next(); }
but it can also deadlock is hasNext is called multiple times without 
calling next and vice-versa.

so if the client code is:
   while(hasNext()) { it.next(); }
when hasNext returns false, next is not called because you go out of the 
loop but you still hold the lock,
so the next thread will stop when trying to acquire the lock in hasNext.

BTW, I think there is no way to write a thread-safe proxy iterator if 
remove() is supported.

>
> Regards,
> Piyush Katariya

cheers,
R?mi




From davidcholmes at aapt.net.au  Sun Jun 16 19:26:11 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 17 Jun 2013 09:26:11 +1000
Subject: [concurrency-interest] JEP-159 Enhanced Class Redefinition
	vsUnsafe.___FieldOffset()
In-Reply-To: <51AE4BCA.8060005@oracle.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEBEJOAA.davidcholmes@aapt.net.au>

Nathan,

JEP-159 is going to have to figure all this out before it can be enabled. You can't just add a feature that will break a whole heap of other thing.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan Reynolds
  Sent: Wednesday, 5 June 2013 6:19 AM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] JEP-159 Enhanced Class Redefinition vsUnsafe.___FieldOffset()


  JEP 159 Enhanced Class Redefinition (see http://openjdk.java.net/jeps/159) will allow for adding and removing fields in a class.  Also, a field could be changed in size as well (e.g. long ? int).  When the change happens, the heap is scanned for all of the instances of the class(es) and all of the instances are modified.  The cost is about that of a full GC.

  I think the original driver for JEP 159 was to enhance what debuggers can change on the fly as the program is running.  I envision using JEP 159 to remove dead fields, deal with fields used in a small percentage of instances (rarely used) and reduce the size of oversized fields.  Dead and rarely used fields account for 6.9% of an average heap.  Oversized fields account for 1.5% of an average heap.  By occasionally using JEP 159 at runtime, we could change the class definitions to save most of this space and hence improve GC times and perhaps response times.

  If I understand correctly, Unsafe.objectFieldOffset() and Unsafe.staticFieldOffset() return the number bytes from the beginning of the instance or class where the field is located.  This offset is typically obtained when the class is loaded or the instance is constructed.  For example, java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater will get the offset in the constructor for the specified field and class.  It keeps this offset for the lifetime of the CASUpdater instance.  The field and class can be any loaded class.

  So, what will happen when JEP 159...

    1.. removes the field used by CASUpdater?  It seems like CASUpdater will corrupt the instance or the object header of the next object. 
    2.. adds or removes a different field and this shifts the field used by CASUpdater?

    3.. changes the long field to an int? 
    4.. adds or removes @Contended?  This will rearrange the fields in all of the instances.

  CASUpdater is just one class.  What about all of the other classes which use or will use Unsafe.___FieldOffset?

  Maybe JEP 159 has already solved the problem.  If so, I would like to hear how.  If not, how can this problem be solved?

  If JEP 159 changes the returned value of ___FieldOffset() from an offset to a cookie, what code will break which assumes it is an offset?

  The value returned from Unsafe.___FieldOffset seems to be used as a cookie.  This cookie can be an index into an array of field offsets.  JEP 159 will then have to fix up the array of field offsets for the affected classes.  If a field is removed or altered in size, then the existing entry in the array should be changed to an error flag (i.e. -1).  In the case of adding or altering a field, then a new entry should be added to the array.  This will prevent corruptions since the Unsafe operations will check the entry for the error flag.

  The engineer will have to be aware that if they change the size of the field from a long to an int, then they have to change the AtomicLongFieldUpdater to an AtomicIntegerFieldUpdater.  Currently, the compiler doesn't flag a problem if an Atomic__FieldUpdater specifies a non-existent field or a field of the wrong type or non-volatile.  These checks are left for runtime.  Maybe the compiler should make this check as well.

  The code that deals with dead, rarely used and oversized fields can't change the fields that were used by Unsafe.___FieldOffsets.  If a field is changed and then Unsafe.___FieldOffset is called on that field, then those fields will have to be reverted.

  Is there a better solution?

  -- 
  Nathan Reynolds | Architect | 602.333.9091
  Oracle PSR Engineering | Server Technology
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130617/53d24f02/attachment-0001.html>

From davidcholmes at aapt.net.au  Sun Jun 16 19:31:17 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 17 Jun 2013 09:31:17 +1000
Subject: [concurrency-interest] Does j.u.c.SynchronousQueue's use
	ofInterrupt interfere with NIO AbstractInterruptibleChannel?
In-Reply-To: <CAH4ZcEv8WhP7QPa2f1k_VB-_Anwzci=C9dAj7zEJBhX8idE3RA@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEBFJOAA.davidcholmes@aapt.net.au>

Edward,

SynchronousQueue does not issue interrupts. The SynchronousQueue code
responds to interrupts as a cancellation mechanism.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Edward
Sargisson
  Sent: Tuesday, 4 June 2013 9:44 AM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] Does j.u.c.SynchronousQueue's use
ofInterrupt interfere with NIO AbstractInterruptibleChannel?


  Hi all,

  I've been chasing down issues with Apache Flume and Log4j2. I ~may~ be
able to explain a problem as SynchronousQueue interacting with
AbstractInterruptibleChannel but I'm not convinced my understanding is
sufficient to be certain. I decided it might be worth asking the question
here - if only for my own learning.


  The problem[1] appears to be that if a put or a take fail on the
SynchronousQueue in the AvroIpcClient then it causes an interrupt on the
Flume FileChannel thread (which uses NIO FileChannel which inherits from
AbstractInterruptibleChannel).


  The docs and code for the NIO channels show that it does not expect to be
interrupted.


  Is SynchronousQueue actually interrupting the thread or is the use of
Interrupt in that class doing something else?

  Many thanks in advance,
  Edward



  Links:
  [1] https://issues.apache.org/jira/browse/FLUME-2067
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130617/f48ffd70/attachment.html>

From davidcholmes at aapt.net.au  Sun Jun 16 19:44:57 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 17 Jun 2013 09:44:57 +1000
Subject: [concurrency-interest] What is the eetop field on Thread for?
In-Reply-To: <1371114675.99491.YahooMailNeo@web120701.mail.ne1.yahoo.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEBFJOAA.davidcholmes@aapt.net.au>

The eetop field holds a reference to the VM's native thread for this Thread
object as a long. If you change it you will crash the VM most likely.

See javaClasses.cpp

JavaThread* java_lang_Thread::thread(oop java_thread) {
  return (JavaThread*)java_thread->address_field(_eetop_offset);
}


void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
  java_thread->address_field_put(_eetop_offset, (address)thread);
}


David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nitsan
Wakart
  Sent: Thursday, 13 June 2013 7:11 PM
  To: Concurrency Interest
  Subject: [concurrency-interest] What is the eetop field on Thread for?


  What would happen if I changed it(I know I shouldn't, but for the sake of
the question)?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130617/c00b8eb9/attachment.html>

From martinrb at google.com  Mon Jun 17 00:53:52 2013
From: martinrb at google.com (Martin Buchholz)
Date: Sun, 16 Jun 2013 21:53:52 -0700
Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
	wait-free?
In-Reply-To: <CAMM2gsP_x7387eCaR1jsm1RsoDFf3ijw=4u+YJCjPyyW+=nnDQ@mail.gmail.com>
References: <CAMM2gsP_x7387eCaR1jsm1RsoDFf3ijw=4u+YJCjPyyW+=nnDQ@mail.gmail.com>
Message-ID: <CA+kOe0_vgzRwK9ESwb8=+TH7V5CGtmyCiutW5Pj5oyHU51H28Q@mail.gmail.com>

Your code snippet is outdated, but yes, I think the term "wait-free" seems
sloppy to me as well.

- * <p>This implementation employs an efficient &quot;wait-free&quot;
+ * <p>This implementation employs an efficient <em>non-blocking</em>
  * algorithm based on one described in <a
  * href="http://www.cs.rochester.edu/u/michael/PODC96.html"> Simple,
  * Fast, and Practical Non-Blocking and Blocking Concurrent Queue



On Wed, Jun 12, 2013 at 9:47 AM, Mudit Verma <mudit.f2004912 at gmail.com>wrote:

> Hi All,
>
> As I read the documentation in java.util.concurrent it says the
> implementation is wait-free. However, I doubt it.  For example an
> enqueue operation loops forever until it is able to CAS new element to
> the tail of queue.  Now, there could be a case, where other threads
> are just fast enough and never give this guy a chance to apply its
> CAS.
>
> However, it helps other threads to update their 2nd CAS (which is to
> update the tail pointer).     As far as first CAS goes, it's not
> wait-free I believe.   Any thoughts?
>
>
>  188:     public boolean offer(E e) {
>  189:         if (e == null) throw new NullPointerException();
>  190:         Node<E> n = new Node<E>(e, null);
>  191:         for (;;) {
>  192:             Node<E> t = tail;
>  193:             Node<E> s = t.getNext();
>  194:             if (t == tail) {
>  195:                 if (s == null) {
>  196:                     if (t.casNext(s, n)) {
>  197:                         casTail(t, n);
>  198:                         return true;
>  199:                     }
>  200:                 } else {
>  201:                     casTail(t, s);
>  202:                 }
>  203:             }
>  204:         }
>  205:     }
>  206:
>
>
> Thanks,
> Mudit
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130616/b3355199/attachment.html>

From kirk at kodewerk.com  Mon Jun 17 03:14:15 2013
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Mon, 17 Jun 2013 09:14:15 +0200
Subject: [concurrency-interest] Mechanical sympathy used in hashtable
In-Reply-To: <CAOgwmTh53C8SmuAApi9Oipv-mpL5nZ8jbxAzByaSH=2ke4jJ-A@mail.gmail.com>
References: <da1a6976-c9b7-403c-9098-8fef745ead92@googlegroups.com>
	<1370939012.11825.YahooMailNeo@web120702.mail.ne1.yahoo.com>
	<344b9d36-d09d-49ee-8cf9-a2c47c03d934@googlegroups.com>
	<ccc504a9-22cd-4492-a5bd-23b9c5b582af@googlegroups.com>
	<CAJ_mLLq6NcMsZ3tbtGh5Y=+pUqg6+YJWRRNRu=D0dHDKtoY6oQ@mail.gmail.com>
	<E88BF56B-F7AF-4963-83C3-4D1E5A90EDB3@kodewerk.com>
	<CAJ_mLLo=ty9+Oe12pj-vPzk+ZU8xV_To0wiurpNfN1G3OwcdVA@mail.gmail.com>
	<CAFWmRJ2njOwBnP1owmoj64==YMkowGb1SJY8AvoBUO3YceMp=Q@mail.gmail.com>
	<CAHNMKAp1JoGbR4yCxjXpuyEhAy1CaFZ4sWWnnoeoRjzXzHajuQ@mail.gmail.com>
	<fa7fc06b-39e6-488e-ae68-f04053d4ae8c@googlegroups.com>
	<CAOgwmTh53C8SmuAApi9Oipv-mpL5nZ8jbxAzByaSH=2ke4jJ-A@mail.gmail.com>
Message-ID: <055263CF-2713-4078-BC59-3B7A526DA627@kodewerk.com>

Hi Peter,

Every VM I've ever used has an equivalent to unsafre. So if this is an historical artifact it seems sensible that we finally recognize the need and get a spec for it. I'd also suggest that there is behaviour such as Fence that should be moved into the JDK. Unfortunately this couldn't happen until 9 but for it to be in 9 work on it would have to start now.

-- Kirk

On 2013-06-16, at 1:01 PM, Peter Lawrey <peter.lawrey at gmail.com> wrote:

> Gil's very good arguments aside, while sun.misc.Unsafe is rarely missing as a class, it's methods are not the same across JVMs.  So while you can be reasonably sure the class exists, you can't be sure that all it's methods exist or what they might do.  From example, if you do a 
> 
>     UNSAFE.putOrderedInt(Object o, long offset, int value)
> 
> It is pretty vague about what happens if you give it a null and if you call this with putOrderInt(null, address, value) this will write to an address not an object. But you can't be sure unless you test it.
> 
> The Javadoc says
> 
> > @param Object o Java heap object in which the variable resides, if any, else null
> > @param offset indication of where the variable resides in a Java heap object, if any, else a memory address locating the variable statically
> 
> In short Unsafe is a hack, almost by design, but without a spec.  It is very much use at your own risk.
> 
> Why do I use Unsafe?  because the alternative is to use JNI in some cases, and this is less portable (between OSes 32/64-bit), slower, no more reliable and more difficult to work with than using Unsafe.
> 
> Peter.
> .
> 
> 
> On 16 June 2013 00:00, Gil Tene <gil at azulsystems.com> wrote:
> It's got nothing to do with portability, and everything to do with the big bad waring sign hanging on top of the entire name space.
> 
> Unsafe is.... Un-Safe!
> 
> As in "nothing is guaranteed to be checked." and "Any use of this without knowing exactly what you are doing and how the JVM will handle it may result in random crashes in your code."
> 
> Remember:
> 
> - You can access the wrong field of an object with unsafe.
> 
> - You can easily corrupt the heap with unsafe.
> 
> - There is no consistent bounds checking, type checking or any other checking being enforced.
> 
> The reason you see most JVMs implement sun.misc.Unsafe is not that it's part of some standard. It's simply becasue most JDKs use core libraries that are based on Sun/Oracle's core library implementation, and the quickest way to support that code with a new JVM is to implement the same ad-hoc APIs that happen to be needed by the precise version of library code used.
> 
> Unsafe is intended to inly be used from within the core libraries that ship with the JDK. It was never intended to be used by "user" code directly. The fact that this can be done so easily is a bug. The fact that so many people are actually using it is a very real problem. The notion that having a way to do something with Unsafe means we don't need an actual, well-speced Java API for that behavior is plain dangerous. Any common use of Unsafe form outside of the JDK libraries should be taken seriously (much more so than it seems to be) as a hint that future JDK specs need to add some proper API spec'ed functionality to cure the evident need to do this obviously broken stuff.
> 
> Remember, Unsafe it is nowhere in the Java SE Spec. It is (quite intentionally) not well documented and is not an official API for Java applications to use or rely on. A compatible Java platform doesn't need to expose it (or even have it) in any way.
> 
> Unsafe APIs can legitimately be modified and "broken" in any JDK release (including underscores releases). All it takes to [legitimately] get rid of or change the semantics of an existing unsfae API call is to have all the code in the core libraries (and *only* in the core libraries) that ship in the same JDK as the new JVM change to adapt. Since the two are released and shipped together, that's a pretty simple thing to do (and actually happens more often than you may think).
> 
> My biggest issue is knowing what to do when things crash. We have this relatively rare clarity in the JVM world: As a JVM builder, if a JVM crashes, our knee jerk assumption is that we have a bug in our code. "User code" is never supposed to be able to core-dump a JVM. If a JVM core dumps, it is *always* a JVM bug. Unless, of course, the user code happens to have used Unsafe or JNI, and corrupted things with some bug. We make it intentionally extra-hard for JNI to corrupt and mess up the Java heap. Unfortunately Unsafe is basically a toolchain for messing up and corrupting the heap.
> 
> So, back to the original point in hand: Fence operations should be added in the form of actual Java APIs. Using them before that, especially if they are just now being added, is a very risky thing from a code longevity point of view.
> 
> -- Gil.
> 
> On Tuesday, June 11, 2013 9:27:58 AM UTC-4, Wojciech Kudla wrote:
> > Because it's not portable
> 
> Any example of a popular JVM with sun.misc.Unsafe missing?
> 
> 
> 2013/6/11 Simone Bordet <sbo... at intalio.com>
> Hi,
> 
> >> 2013/6/11 Kirk Pepperdine <ki... at kodewerk.com>
> 
> >> Too bad they are in unsafe... :-\
> 
> > On Tue, Jun 11, 2013 at 3:09 PM, Micha? Warecki <michal.... at gmail.com> wrote:
> > Hmm, Why? Do you see better place for them?
> 
> Because it's not portable.
> Does not work in non-Oracle JVMs, and it's very OSGi unfriendly: for
> applications to use Unsafe in OSGi, you need to crack a black egg,
> spill dragon blood, burn everything with a fire ignited by a lightning
> and, well... just hope.
> 
> --
> Simone Bordet
> ----
> http://cometd.org
> http://webtide.com
> http://intalio.com
> Developer advice, training, services and support
> from the Jetty & CometD experts.
> Intalio, the modern way to build business applications.
> 
> -- 
> You received this message because you are subscribed to the Google Groups "mechanical-sympathy" group.
> To unsubscribe from this group and stop receiving emails from it, send an email to mechanical-sympathy+unsubscribe at googlegroups.com.
> For more options, visit https://groups.google.com/groups/opt_out.
>  
>  
> 
> 
> -- 
> You received this message because you are subscribed to the Google Groups "mechanical-sympathy" group.
> To unsubscribe from this group and stop receiving emails from it, send an email to mechanical-sympathy+unsubscribe at googlegroups.com.
> For more options, visit https://groups.google.com/groups/opt_out.
>  
>  

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130617/2d9e63ba/attachment-0001.html>

From aleksey.shipilev at oracle.com  Mon Jun 17 03:44:06 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Mon, 17 Jun 2013 11:44:06 +0400
Subject: [concurrency-interest] safe publication ("initializing an
 object from static initializer")
In-Reply-To: <1370611072.1771.YahooMailNeo@web141101.mail.bf1.yahoo.com>
References: <1370611072.1771.YahooMailNeo@web141101.mail.bf1.yahoo.com>
Message-ID: <51BEBE46.2020303@oracle.com>

On 06/07/2013 05:17 PM, Andy Nuss wrote:
> The quote from JCIP section 3.5.3, "initializing an object from static
> initializer", has me wondering in terms of non-64 bit static, but
> non-final, scalar and object variables initialized in an initializer
> directly, or indirectly thru a static function called by the initializer
> that sets such variable, what are the rules for publishing the change
> safely to other cores?

Makes no difference whether you are calling other methods from the
static initializer or not.

> Are all changes to static variables published at the end of the static
> initialization of the class?  What does hotspot do, and what exactly
> does this JCIP reference mean?

See the initialization rules in JVM spec:
 http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.5

All the fields initialized in the static initializers should be visible
to any user of that class. In other words, if the code observes the
initialized class, then it observes it's static state completely.

-Aleksey.

From william.louth at jinspired.com  Mon Jun 17 03:50:23 2013
From: william.louth at jinspired.com (william.louth at jinspired.com)
Date: Mon, 17 Jun 2013 07:50:23 +0000
Subject: [concurrency-interest] JEP-159 Enhanced Class Redefinition
 vs	Unsafe.___FieldOffset()
Message-ID: <W54702132637561371455423@atl4webmail10>

The "small impact" mention in the proposal seems like an understatement to say the least.

With regard to field addition might I suggest that instead we look at the introduction of "twinned" class instances such that for any instance of class A I can obtain (with ease and speed) a "twinned" instance of class B (struct) which would hold the fields I would like added. An added benefit of this is that the twinned class would not need to be exposed (inadvertently) to other code access class A. Doing this without support within the JVM today results in far too much memory management work and relatively expensive hash lookups. I have not given my proposal much thought until this morning so apologies if I have over simplified the problem itself.

William

>-----Original Message-----
>From: Nathan Reynolds [mailto:nathan.reynolds at oracle.com]
>Sent: Tuesday, June 4, 2013 10:19 PM
>To: concurrency-interest at cs.oswego.edu
>Subject: [concurrency-interest] JEP-159 Enhanced Class Redefinition vs	Unsafe.___FieldOffset()
>
>JEP 159 Enhanced Class Redefinition 
>(seehttp://openjdk.java.net/jeps/159) will allow for adding and removing 
>fields in a class.  Also, a field could be changed in size as well (e.g. 
>long ? int).  When the change happens, the heap is scanned for all of 
>the instances of the class(es) and all of the instances are modified.  
>The cost is about that of a full GC.
>
>I think the original driver for JEP 159 was to enhance what debuggers 
>can change on the fly as the program is running.  I envision using JEP 
>159 to remove dead fields, deal with fields used in a small percentage 
>of instances (rarely used) and reduce the size of oversized fields.  
>Dead and rarely used fields account for 6.9% of an average heap.  
>Oversized fields account for 1.5% of an average heap.  By _occasionally_ 
>using JEP 159 at runtime, we could change the class definitions to save 
>most of this space and hence improve GC times and perhaps response times.
>
>If I understand correctly, Unsafe.objectFieldOffset() and 
>Unsafe.staticFieldOffset() return the number bytes from the beginning of 
>the instance or class where the field is located.  This offset is 
>typically obtained when the class is loaded or the instance is 
>constructed.  For example, 
>java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater will get 
>the offset in the constructor for the specified field and class.  It 
>keeps this offset for the lifetime of the CASUpdater instance.  The 
>field and class can be any loaded class.
>
>So, what will happen when JEP 159...
>
> 1. removes the field used by CASUpdater?  It seems like CASUpdater will
>    corrupt the instance or the object header of the next object.
> 2. adds or removes a different field and this shifts the field used by
>    CASUpdater?
> 3. changes the long field to an int?
> 4. adds or removes @Contended?  This will rearrange the fields in all
>    of the instances.
>
>CASUpdater is just one class.  What about all of the other classes which 
>use or _will_ use Unsafe.___FieldOffset?
>
>Maybe JEP 159 has already solved the problem.  If so, I would like to 
>hear how.  If not, how can this problem be solved?
>
>If JEP 159 changes the returned value of ___FieldOffset() from an offset 
>to a cookie, what code will break which assumes it is an offset?
>
>The value returned from Unsafe.___FieldOffset seems to be used as a 
>cookie.  This cookie can be an index into an array of field offsets.  
>JEP 159 will then have to fix up the array of field offsets for the 
>affected classes.  If a field is removed or altered in size, then the 
>existing entry in the array should be changed to an error flag (i.e. 
>-1).  In the case of adding or altering a field, then a new entry should 
>be added to the array.  This will prevent corruptions since the Unsafe 
>operations will check the entry for the error flag.
>
>The engineer will have to be aware that if they change the size of the 
>field from a long to an int, then they have to change the 
>AtomicLongFieldUpdater to an AtomicIntegerFieldUpdater.  Currently, the 
>compiler doesn't flag a problem if an Atomic__FieldUpdater specifies a 
>non-existent field or a field of the wrong type or non-volatile.  These 
>checks are left for runtime.  Maybe the compiler should make this check 
>as well.
>
>The code that deals with dead, rarely used and oversized fields can't 
>change the fields that were used by Unsafe.___FieldOffsets. If a field 
>is changed and then Unsafe.___FieldOffset is called on that field, then 
>those fields will have to be reverted.
>
>Is there a better solution?
>-- 
>Nathan Reynolds 
><http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>Architect | 602.333.9091
>Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>




From davidcholmes at aapt.net.au  Mon Jun 17 06:42:10 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 17 Jun 2013 20:42:10 +1000
Subject: [concurrency-interest] JEP-159 Enhanced Class Redefinition
	vs	Unsafe.___FieldOffset()
In-Reply-To: <W54702132637561371455423@atl4webmail10>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEBLJOAA.davidcholmes@aapt.net.au>

william.louth at jinspired.com writes:
> The "small impact" mention in the proposal seems like an 
> understatement to say the least.

To be fair it says: "There is a small impact on the API documentation for the class redefinition functionality in JVMTI, JDWP, JDI, and the java.lang.instrument API."

Personally I think that field removal should only be possible if it can be shown that the redefined methods never access the field - an enhanced form of verification. Otherwise you are going to have to add numerous checks to the VM to handle the possibility of suddenly vanishing fields. I can't imagine such checks being favourable to performance.

David
-----
 
> With regard to field addition might I suggest that instead we 
> look at the introduction of "twinned" class instances such that 
> for any instance of class A I can obtain (with ease and speed) a 
> "twinned" instance of class B (struct) which would hold the 
> fields I would like added. An added benefit of this is that the 
> twinned class would not need to be exposed (inadvertently) to 
> other code access class A. Doing this without support within the 
> JVM today results in far too much memory management work and 
> relatively expensive hash lookups. I have not given my proposal 
> much thought until this morning so apologies if I have over 
> simplified the problem itself.
> 
> William
> 
> >-----Original Message-----
> >From: Nathan Reynolds [mailto:nathan.reynolds at oracle.com]
> >Sent: Tuesday, June 4, 2013 10:19 PM
> >To: concurrency-interest at cs.oswego.edu
> >Subject: [concurrency-interest] JEP-159 Enhanced Class 
> Redefinition vs	Unsafe.___FieldOffset()
> >
> >JEP 159 Enhanced Class Redefinition 
> >(seehttp://openjdk.java.net/jeps/159) will allow for adding and removing 
> >fields in a class.  Also, a field could be changed in size as well (e.g. 
> >long ? int).  When the change happens, the heap is scanned for all of 
> >the instances of the class(es) and all of the instances are modified.  
> >The cost is about that of a full GC.
> >
> >I think the original driver for JEP 159 was to enhance what debuggers 
> >can change on the fly as the program is running.  I envision using JEP 
> >159 to remove dead fields, deal with fields used in a small percentage 
> >of instances (rarely used) and reduce the size of oversized fields.  
> >Dead and rarely used fields account for 6.9% of an average heap.  
> >Oversized fields account for 1.5% of an average heap.  By _occasionally_ 
> >using JEP 159 at runtime, we could change the class definitions to save 
> >most of this space and hence improve GC times and perhaps response times.
> >
> >If I understand correctly, Unsafe.objectFieldOffset() and 
> >Unsafe.staticFieldOffset() return the number bytes from the beginning of 
> >the instance or class where the field is located.  This offset is 
> >typically obtained when the class is loaded or the instance is 
> >constructed.  For example, 
> >java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater will get 
> >the offset in the constructor for the specified field and class.  It 
> >keeps this offset for the lifetime of the CASUpdater instance.  The 
> >field and class can be any loaded class.
> >
> >So, what will happen when JEP 159...
> >
> > 1. removes the field used by CASUpdater?  It seems like CASUpdater will
> >    corrupt the instance or the object header of the next object.
> > 2. adds or removes a different field and this shifts the field used by
> >    CASUpdater?
> > 3. changes the long field to an int?
> > 4. adds or removes @Contended?  This will rearrange the fields in all
> >    of the instances.
> >
> >CASUpdater is just one class.  What about all of the other classes which 
> >use or _will_ use Unsafe.___FieldOffset?
> >
> >Maybe JEP 159 has already solved the problem.  If so, I would like to 
> >hear how.  If not, how can this problem be solved?
> >
> >If JEP 159 changes the returned value of ___FieldOffset() from an offset 
> >to a cookie, what code will break which assumes it is an offset?
> >
> >The value returned from Unsafe.___FieldOffset seems to be used as a 
> >cookie.  This cookie can be an index into an array of field offsets.  
> >JEP 159 will then have to fix up the array of field offsets for the 
> >affected classes.  If a field is removed or altered in size, then the 
> >existing entry in the array should be changed to an error flag (i.e. 
> >-1).  In the case of adding or altering a field, then a new entry should 
> >be added to the array.  This will prevent corruptions since the Unsafe 
> >operations will check the entry for the error flag.
> >
> >The engineer will have to be aware that if they change the size of the 
> >field from a long to an int, then they have to change the 
> >AtomicLongFieldUpdater to an AtomicIntegerFieldUpdater.  Currently, the 
> >compiler doesn't flag a problem if an Atomic__FieldUpdater specifies a 
> >non-existent field or a field of the wrong type or non-volatile.  These 
> >checks are left for runtime.  Maybe the compiler should make this check 
> >as well.
> >
> >The code that deals with dead, rarely used and oversized fields can't 
> >change the fields that were used by Unsafe.___FieldOffsets. If a field 
> >is changed and then Unsafe.___FieldOffset is called on that field, then 
> >those fields will have to be reverted.
> >
> >Is there a better solution?
> >-- 
> >Nathan Reynolds 
> ><http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
> >Architect | 602.333.9091
> >Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
> >
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> -----
> No virus found in this message.
> Checked by AVG - www.avg.com
> Version: 2013.0.3345 / Virus Database: 3199/6417 - Release Date: 06/16/13
> 



From oleksandr.otenko at oracle.com  Mon Jun 17 06:42:44 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Mon, 17 Jun 2013 11:42:44 +0100
Subject: [concurrency-interest] JEP-159 Enhanced Class Redefinition vs
 Unsafe.___FieldOffset()
In-Reply-To: <51AE4BCA.8060005@oracle.com>
References: <51AE4BCA.8060005@oracle.com>
Message-ID: <51BEE824.5060801@oracle.com>

Change the return type of the methods returning field offsets from int 
to FieldOffset. Now all references to FieldOffsets are accounted for.

Alex

On 04/06/2013 21:19, Nathan Reynolds wrote:
> JEP 159 Enhanced Class Redefinition 
> (seehttp://openjdk.java.net/jeps/159) will allow for adding and 
> removing fields in a class.  Also, a field could be changed in size as 
> well (e.g. long ? int).  When the change happens, the heap is scanned 
> for all of the instances of the class(es) and all of the instances are 
> modified.  The cost is about that of a full GC.
>
> I think the original driver for JEP 159 was to enhance what debuggers 
> can change on the fly as the program is running.  I envision using JEP 
> 159 to remove dead fields, deal with fields used in a small percentage 
> of instances (rarely used) and reduce the size of oversized fields.  
> Dead and rarely used fields account for 6.9% of an average heap.  
> Oversized fields account for 1.5% of an average heap.  By 
> _occasionally_ using JEP 159 at runtime, we could change the class 
> definitions to save most of this space and hence improve GC times and 
> perhaps response times.
>
> If I understand correctly, Unsafe.objectFieldOffset() and 
> Unsafe.staticFieldOffset() return the number bytes from the beginning 
> of the instance or class where the field is located. This offset is 
> typically obtained when the class is loaded or the instance is 
> constructed.  For example, 
> java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater will get 
> the offset in the constructor for the specified field and class.  It 
> keeps this offset for the lifetime of the CASUpdater instance.  The 
> field and class can be any loaded class.
>
> So, what will happen when JEP 159...
>
>  1. removes the field used by CASUpdater?  It seems like CASUpdater
>     will corrupt the instance or the object header of the next object.
>  2. adds or removes a different field and this shifts the field used
>     by CASUpdater?
>  3. changes the long field to an int?
>  4. adds or removes @Contended?  This will rearrange the fields in all
>     of the instances.
>
> CASUpdater is just one class.  What about all of the other classes 
> which use or _will_ use Unsafe.___FieldOffset?
>
> Maybe JEP 159 has already solved the problem.  If so, I would like to 
> hear how.  If not, how can this problem be solved?
>
> If JEP 159 changes the returned value of ___FieldOffset() from an 
> offset to a cookie, what code will break which assumes it is an offset?
>
> The value returned from Unsafe.___FieldOffset seems to be used as a 
> cookie.  This cookie can be an index into an array of field offsets.  
> JEP 159 will then have to fix up the array of field offsets for the 
> affected classes.  If a field is removed or altered in size, then the 
> existing entry in the array should be changed to an error flag (i.e. 
> -1).  In the case of adding or altering a field, then a new entry 
> should be added to the array. This will prevent corruptions since the 
> Unsafe operations will check the entry for the error flag.
>
> The engineer will have to be aware that if they change the size of the 
> field from a long to an int, then they have to change the 
> AtomicLongFieldUpdater to an AtomicIntegerFieldUpdater. Currently, the 
> compiler doesn't flag a problem if an Atomic__FieldUpdater specifies a 
> non-existent field or a field of the wrong type or non-volatile.  
> These checks are left for runtime.  Maybe the compiler should make 
> this check as well.
>
> The code that deals with dead, rarely used and oversized fields can't 
> change the fields that were used by Unsafe.___FieldOffsets. If a field 
> is changed and then Unsafe.___FieldOffset is called on that field, 
> then those fields will have to be reverted.
>
> Is there a better solution?
> -- 
> Nathan Reynolds 
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
> Architect | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130617/09a3b1c2/attachment-0001.html>

From william.louth at jinspired.com  Mon Jun 17 07:04:39 2013
From: william.louth at jinspired.com (William Louth (JINSPIRED.COM))
Date: Mon, 17 Jun 2013 13:04:39 +0200
Subject: [concurrency-interest] JEP-159 Enhanced Class Redefinition vs
 Unsafe.___FieldOffset()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEBLJOAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCEEBLJOAA.davidcholmes@aapt.net.au>
Message-ID: <51BEED47.5010705@jinspired.com>

Hi David,

Big things have small beginnings.

I would have to understand more of what this small API change would look 
like before I could determine the impact it would have on all current 
native and non-native agents out in the wild which have been designed 
with the current restrictions (listed in the jep) in mind. What if these 
agents have built up (meta)caches around methods which they now 
incorrectly assume will never be removed? What if the redefinition of a 
superclass invalidates all previous sub classes modifications 
made...this could trigger an avalanche of redefinitions which could 
trigger further redefinitions within one agent or across multiple 
agents. Today there are already issues with the co-existence of multiple 
class transformation agents which we have not worked out in a manner 
that I believe is scalable (in terms of no. of agents).

Well we might very well have to rewrite all agents anyway with the 
module stuff coming ;-).

William

On 17/06/2013 12:42, David Holmes wrote:
> william.louth at jinspired.com writes:
>> The "small impact" mention in the proposal seems like an
>> understatement to say the least.
> To be fair it says: "There is a small impact on the API documentation for the class redefinition functionality in JVMTI, JDWP, JDI, and the java.lang.instrument API."
>
> Personally I think that field removal should only be possible if it can be shown that the redefined methods never access the field - an enhanced form of verification. Otherwise you are going to have to add numerous checks to the VM to handle the possibility of suddenly vanishing fields. I can't imagine such checks being favourable to performance.
>
> David
> -----
>   
>> With regard to field addition might I suggest that instead we
>> look at the introduction of "twinned" class instances such that
>> for any instance of class A I can obtain (with ease and speed) a
>> "twinned" instance of class B (struct) which would hold the
>> fields I would like added. An added benefit of this is that the
>> twinned class would not need to be exposed (inadvertently) to
>> other code access class A. Doing this without support within the
>> JVM today results in far too much memory management work and
>> relatively expensive hash lookups. I have not given my proposal
>> much thought until this morning so apologies if I have over
>> simplified the problem itself.
>>
>> William
>>
>>> -----Original Message-----
>>> From: Nathan Reynolds [mailto:nathan.reynolds at oracle.com]
>>> Sent: Tuesday, June 4, 2013 10:19 PM
>>> To: concurrency-interest at cs.oswego.edu
>>> Subject: [concurrency-interest] JEP-159 Enhanced Class
>> Redefinition vs	Unsafe.___FieldOffset()
>>> JEP 159 Enhanced Class Redefinition
>>> (seehttp://openjdk.java.net/jeps/159) will allow for adding and removing
>>> fields in a class.  Also, a field could be changed in size as well (e.g.
>>> long ??? int).  When the change happens, the heap is scanned for all of
>>> the instances of the class(es) and all of the instances are modified.
>>> The cost is about that of a full GC.
>>>
>>> I think the original driver for JEP 159 was to enhance what debuggers
>>> can change on the fly as the program is running.  I envision using JEP
>>> 159 to remove dead fields, deal with fields used in a small percentage
>>> of instances (rarely used) and reduce the size of oversized fields.
>>> Dead and rarely used fields account for 6.9% of an average heap.
>>> Oversized fields account for 1.5% of an average heap.  By _occasionally_
>>> using JEP 159 at runtime, we could change the class definitions to save
>>> most of this space and hence improve GC times and perhaps response times.
>>>
>>> If I understand correctly, Unsafe.objectFieldOffset() and
>>> Unsafe.staticFieldOffset() return the number bytes from the beginning of
>>> the instance or class where the field is located.  This offset is
>>> typically obtained when the class is loaded or the instance is
>>> constructed.  For example,
>>> java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater will get
>>> the offset in the constructor for the specified field and class.  It
>>> keeps this offset for the lifetime of the CASUpdater instance.  The
>>> field and class can be any loaded class.
>>>
>>> So, what will happen when JEP 159...
>>>
>>> 1. removes the field used by CASUpdater?  It seems like CASUpdater will
>>>     corrupt the instance or the object header of the next object.
>>> 2. adds or removes a different field and this shifts the field used by
>>>     CASUpdater?
>>> 3. changes the long field to an int?
>>> 4. adds or removes @Contended?  This will rearrange the fields in all
>>>     of the instances.
>>>
>>> CASUpdater is just one class.  What about all of the other classes which
>>> use or _will_ use Unsafe.___FieldOffset?
>>>
>>> Maybe JEP 159 has already solved the problem.  If so, I would like to
>>> hear how.  If not, how can this problem be solved?
>>>
>>> If JEP 159 changes the returned value of ___FieldOffset() from an offset
>>> to a cookie, what code will break which assumes it is an offset?
>>>
>>> The value returned from Unsafe.___FieldOffset seems to be used as a
>>> cookie.  This cookie can be an index into an array of field offsets.
>>> JEP 159 will then have to fix up the array of field offsets for the
>>> affected classes.  If a field is removed or altered in size, then the
>>> existing entry in the array should be changed to an error flag (i.e.
>>> -1).  In the case of adding or altering a field, then a new entry should
>>> be added to the array.  This will prevent corruptions since the Unsafe
>>> operations will check the entry for the error flag.
>>>
>>> The engineer will have to be aware that if they change the size of the
>>> field from a long to an int, then they have to change the
>>> AtomicLongFieldUpdater to an AtomicIntegerFieldUpdater.  Currently, the
>>> compiler doesn't flag a problem if an Atomic__FieldUpdater specifies a
>>> non-existent field or a field of the wrong type or non-volatile.  These
>>> checks are left for runtime.  Maybe the compiler should make this check
>>> as well.
>>>
>>> The code that deals with dead, rarely used and oversized fields can't
>>> change the fields that were used by Unsafe.___FieldOffsets. If a field
>>> is changed and then Unsafe.___FieldOffset is called on that field, then
>>> those fields will have to be reverted.
>>>
>>> Is there a better solution?
>>> -- 
>>> Nathan Reynolds
>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>> Architect | 602.333.9091
>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> -----
>> No virus found in this message.
>> Checked by AVG - www.avg.com
>> Version: 2013.0.3345 / Virus Database: 3199/6417 - Release Date: 06/16/13
>>
>
>


From peter.levart at gmail.com  Mon Jun 17 11:39:44 2013
From: peter.levart at gmail.com (Peter Levart)
Date: Mon, 17 Jun 2013 17:39:44 +0200
Subject: [concurrency-interest] JEP-159 Enhanced Class Redefinition vs
 Unsafe.___FieldOffset()
In-Reply-To: <51BEE824.5060801@oracle.com>
References: <51AE4BCA.8060005@oracle.com> <51BEE824.5060801@oracle.com>
Message-ID: <51BF2DC0.8080207@gmail.com>

On 06/17/2013 12:42 PM, Oleksandr Otenko wrote:
> Change the return type of the methods returning field offsets from int 
> to FieldOffset. Now all references to FieldOffsets are accounted for.

Perhaps the Unsafe API could be gradually replaced with some other more 
manageable API that would be "Safe", in addition to provide for class 
redefinition.

The MethodHandle API is safe and at least for constant direct method 
handles it has been proven that it can be JIT-ed to fast in-lined code. 
Suppose that in addition to:

Lookup.findGetter/findSetter

There would also be:

Lookup.findVolatileGetter/findVolatileSetter/findOrderedSetter
Lookup.findCompareAndSwap/findGetAndSet/findGetAndAdd

+ the support for array access.

Now that there is Unsafe.[load|store|full]Fence, the 
Unsafe.[put|get][Volatile|Ordered] or equivalents are not needed any 
more and only the replacements for CAS/GAS/GAA are needed.

Regards, Peter

>
> Alex
>
> On 04/06/2013 21:19, Nathan Reynolds wrote:
>> JEP 159 Enhanced Class Redefinition 
>> (seehttp://openjdk.java.net/jeps/159) will allow for adding and 
>> removing fields in a class.  Also, a field could be changed in size 
>> as well (e.g. long ? int).  When the change happens, the heap is 
>> scanned for all of the instances of the class(es) and all of the 
>> instances are modified.  The cost is about that of a full GC.
>>
>> I think the original driver for JEP 159 was to enhance what debuggers 
>> can change on the fly as the program is running.  I envision using 
>> JEP 159 to remove dead fields, deal with fields used in a small 
>> percentage of instances (rarely used) and reduce the size of 
>> oversized fields.  Dead and rarely used fields account for 6.9% of an 
>> average heap.  Oversized fields account for 1.5% of an average heap.  
>> By _occasionally_ using JEP 159 at runtime, we could change the class 
>> definitions to save most of this space and hence improve GC times and 
>> perhaps response times.
>>
>> If I understand correctly, Unsafe.objectFieldOffset() and 
>> Unsafe.staticFieldOffset() return the number bytes from the beginning 
>> of the instance or class where the field is located. This offset is 
>> typically obtained when the class is loaded or the instance is 
>> constructed.  For example, 
>> java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater will 
>> get the offset in the constructor for the specified field and class.  
>> It keeps this offset for the lifetime of the CASUpdater instance.  
>> The field and class can be any loaded class.
>>
>> So, what will happen when JEP 159...
>>
>>  1. removes the field used by CASUpdater?  It seems like CASUpdater
>>     will corrupt the instance or the object header of the next object.
>>  2. adds or removes a different field and this shifts the field used
>>     by CASUpdater?
>>  3. changes the long field to an int?
>>  4. adds or removes @Contended?  This will rearrange the fields in
>>     all of the instances.
>>
>> CASUpdater is just one class.  What about all of the other classes 
>> which use or _will_ use Unsafe.___FieldOffset?
>>
>> Maybe JEP 159 has already solved the problem.  If so, I would like to 
>> hear how.  If not, how can this problem be solved?
>>
>> If JEP 159 changes the returned value of ___FieldOffset() from an 
>> offset to a cookie, what code will break which assumes it is an offset?
>>
>> The value returned from Unsafe.___FieldOffset seems to be used as a 
>> cookie.  This cookie can be an index into an array of field offsets.  
>> JEP 159 will then have to fix up the array of field offsets for the 
>> affected classes.  If a field is removed or altered in size, then the 
>> existing entry in the array should be changed to an error flag (i.e. 
>> -1).  In the case of adding or altering a field, then a new entry 
>> should be added to the array.  This will prevent corruptions since 
>> the Unsafe operations will check the entry for the error flag.
>>
>> The engineer will have to be aware that if they change the size of 
>> the field from a long to an int, then they have to change the 
>> AtomicLongFieldUpdater to an AtomicIntegerFieldUpdater. Currently, 
>> the compiler doesn't flag a problem if an Atomic__FieldUpdater 
>> specifies a non-existent field or a field of the wrong type or 
>> non-volatile.  These checks are left for runtime.  Maybe the compiler 
>> should make this check as well.
>>
>> The code that deals with dead, rarely used and oversized fields can't 
>> change the fields that were used by Unsafe.___FieldOffsets.  If a 
>> field is changed and then Unsafe.___FieldOffset is called on that 
>> field, then those fields will have to be reverted.
>>
>> Is there a better solution?
>> -- 
>> Nathan Reynolds 
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>> Architect | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130617/5dccb8bb/attachment.html>

From viktor.klang at gmail.com  Mon Jun 17 13:26:42 2013
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Mon, 17 Jun 2013 13:26:42 -0400
Subject: [concurrency-interest] JEP-159 Enhanced Class Redefinition vs
	Unsafe.___FieldOffset()
In-Reply-To: <51BF2DC0.8080207@gmail.com>
References: <51AE4BCA.8060005@oracle.com> <51BEE824.5060801@oracle.com>
	<51BF2DC0.8080207@gmail.com>
Message-ID: <CANPzfU_ghtUpeOu=KiemeojQAFyXY5rM21ogdDtyquzP4QjHqw@mail.gmail.com>

To be honest, I see no way of solving this in a non-breaking fashion, but
I'd be more than happy to be proved wrong there.

Cheers,
?


On Mon, Jun 17, 2013 at 11:39 AM, Peter Levart <peter.levart at gmail.com>wrote:

>  On 06/17/2013 12:42 PM, Oleksandr Otenko wrote:
>
> Change the return type of the methods returning field offsets from int to
> FieldOffset. Now all references to FieldOffsets are accounted for.
>
>
> Perhaps the Unsafe API could be gradually replaced with some other more
> manageable API that would be "Safe", in addition to provide for class
> redefinition.
>
> The MethodHandle API is safe and at least for constant direct method
> handles it has been proven that it can be JIT-ed to fast in-lined code.
> Suppose that in addition to:
>
> Lookup.findGetter/findSetter
>
> There would also be:
>
> Lookup.findVolatileGetter/findVolatileSetter/findOrderedSetter
> Lookup.findCompareAndSwap/findGetAndSet/findGetAndAdd
>
> + the support for array access.
>
> Now that there is Unsafe.[load|store|full]Fence, the
> Unsafe.[put|get][Volatile|Ordered] or equivalents are not needed any more
> and only the replacements for CAS/GAS/GAA are needed.
>
> Regards, Peter
>
>
>
> Alex
>
> On 04/06/2013 21:19, Nathan Reynolds wrote:
>
> JEP 159 Enhanced Class Redefinition (see http://openjdk.java.net/jeps/159)
> will allow for adding and removing fields in a class.  Also, a field could
> be changed in size as well (e.g. long ? int).  When the change happens, the
> heap is scanned for all of the instances of the class(es) and all of the
> instances are modified.  The cost is about that of a full GC.
>
> I think the original driver for JEP 159 was to enhance what debuggers can
> change on the fly as the program is running.  I envision using JEP 159 to
> remove dead fields, deal with fields used in a small percentage of
> instances (rarely used) and reduce the size of oversized fields.  Dead and
> rarely used fields account for 6.9% of an average heap.  Oversized fields
> account for 1.5% of an average heap.  By *occasionally* using JEP 159 at
> runtime, we could change the class definitions to save most of this space
> and hence improve GC times and perhaps response times.
>
> If I understand correctly, Unsafe.objectFieldOffset() and
> Unsafe.staticFieldOffset() return the number bytes from the beginning of
> the instance or class where the field is located.  This offset is typically
> obtained when the class is loaded or the instance is constructed.  For
> example, java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater will
> get the offset in the constructor for the specified field and class.  It
> keeps this offset for the lifetime of the CASUpdater instance.  The field
> and class can be any loaded class.
>
> So, what will happen when JEP 159...
>
>    1. removes the field used by CASUpdater?  It seems like CASUpdater
>    will corrupt the instance or the object header of the next object.
>    2. adds or removes a different field and this shifts the field used by
>    CASUpdater?
>     3. changes the long field to an int?
>    4. adds or removes @Contended?  This will rearrange the fields in all
>    of the instances.
>
> CASUpdater is just one class.  What about all of the other classes which
> use or *will* use Unsafe.___FieldOffset?
>
> Maybe JEP 159 has already solved the problem.  If so, I would like to hear
> how.  If not, how can this problem be solved?
>
> If JEP 159 changes the returned value of ___FieldOffset() from an offset
> to a cookie, what code will break which assumes it is an offset?
>
> The value returned from Unsafe.___FieldOffset seems to be used as a
> cookie.  This cookie can be an index into an array of field offsets.  JEP
> 159 will then have to fix up the array of field offsets for the affected
> classes.  If a field is removed or altered in size, then the existing entry
> in the array should be changed to an error flag (i.e. -1).  In the case of
> adding or altering a field, then a new entry should be added to the array.
> This will prevent corruptions since the Unsafe operations will check the
> entry for the error flag.
>
> The engineer will have to be aware that if they change the size of the
> field from a long to an int, then they have to change the
> AtomicLongFieldUpdater to an AtomicIntegerFieldUpdater.  Currently, the
> compiler doesn't flag a problem if an Atomic__FieldUpdater specifies a
> non-existent field or a field of the wrong type or non-volatile.  These
> checks are left for runtime.  Maybe the compiler should make this check as
> well.
>
> The code that deals with dead, rarely used and oversized fields can't
> change the fields that were used by Unsafe.___FieldOffsets.  If a field is
> changed and then Unsafe.___FieldOffset is called on that field, then those
> fields will have to be reverted.
>
> Is there a better solution?
> --
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Architect | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
*Viktor Klang*
*Director of Engineering*
Typesafe <http://www.typesafe.com/>

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130617/87a840cc/attachment.html>

From pramalhe at gmail.com  Tue Jun 18 16:23:32 2013
From: pramalhe at gmail.com (Pedro Ramalhete)
Date: Tue, 18 Jun 2013 22:23:32 +0200
Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely wait-free?
Message-ID: <CAAApjO1-VG-JTRVigNknhpNng9kPq3zQ=Hi7LznNskG7AVOeYA@mail.gmail.com>

Hi Mudit,

After a quick inspection it seems to me that some of the methods of
ConcurrentLinkedQueue are Lock-Free and others are Wait-Free, namely:

Lock-Free:
add()
addAll()
offer()
poll()
remove()
clear()

Wait-Free:
contains()
isEmpty()
peek()
size()
toArray() - uses "new" which by itself is not truly wait-free
iterator()
element()

To be more accurate, the functions described above are not just Wait-Free,
they are Wait-Free Population-Oblivious.

Hope it helps,
Pedro Ramalhete

------------------------------
Date: Wed, 12 Jun 2013 18:47:09 +0200
From: Mudit Verma <mudit.f2004912 at gmail.com>
To: concurrency-interest <concurrency-interest at cs.oswego.edu>
Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
        wait-free?
Message-ID:
        <CAMM2gsP_
x7387eCaR1jsm1RsoDFf3ijw=4u+YJCjPyyW+=nnDQ at mail.gmail.com>
Content-Type: text/plain; charset=ISO-8859-1

Hi All,

As I read the documentation in java.util.concurrent it says the
implementation is wait-free. However, I doubt it.  For example an
enqueue operation loops forever until it is able to CAS new element to
the tail of queue.  Now, there could be a case, where other threads
are just fast enough and never give this guy a chance to apply its
CAS.

However, it helps other threads to update their 2nd CAS (which is to
update the tail pointer).     As far as first CAS goes, it's not
wait-free I believe.   Any thoughts?


 188:     public boolean offer(E e) {
 189:         if (e == null) throw new NullPointerException();
 190:         Node<E> n = new Node<E>(e, null);
 191:         for (;;) {
 192:             Node<E> t = tail;
 193:             Node<E> s = t.getNext();
 194:             if (t == tail) {
 195:                 if (s == null) {
 196:                     if (t.casNext(s, n)) {
 197:                         casTail(t, n);
 198:                         return true;
 199:                     }
 200:                 } else {
 201:                     casTail(t, s);
 202:                 }
 203:             }
 204:         }
 205:     }
 206:


Thanks,
Mudit
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130618/17c9b6d7/attachment.html>

From mudit.f2004912 at gmail.com  Tue Jun 18 16:38:39 2013
From: mudit.f2004912 at gmail.com (Mudit Verma)
Date: Tue, 18 Jun 2013 22:38:39 +0200
Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
	wait-free?
In-Reply-To: <CAAApjO1-VG-JTRVigNknhpNng9kPq3zQ=Hi7LznNskG7AVOeYA@mail.gmail.com>
References: <CAAApjO1-VG-JTRVigNknhpNng9kPq3zQ=Hi7LznNskG7AVOeYA@mail.gmail.com>
Message-ID: <CAMM2gsPs1nURTreW-ixZcvpp--Q-pHHO1n6C31=jafmYbLV0Qg@mail.gmail.com>

Hello Pedro,

Thanks for your inspection.  Queue is known for two operations,
enqueue and dequeue.  If these two operations are not wait-free, I am
not sure whether it will be right to call whole implementation as
wait-free even thought there are other methods which are wait-free.

Just my take.

Thanks,
Mudit

On Tue, Jun 18, 2013 at 10:23 PM, Pedro Ramalhete <pramalhe at gmail.com> wrote:
> Hi Mudit,
>
> After a quick inspection it seems to me that some of the methods of
> ConcurrentLinkedQueue are Lock-Free and others are Wait-Free, namely:
>
> Lock-Free:
> add()
> addAll()
> offer()
> poll()
> remove()
> clear()
>
> Wait-Free:
> contains()
> isEmpty()
> peek()
> size()
> toArray() - uses "new" which by itself is not truly wait-free
> iterator()
> element()
>
> To be more accurate, the functions described above are not just Wait-Free,
> they are Wait-Free Population-Oblivious.
>
> Hope it helps,
> Pedro Ramalhete
>
> ------------------------------
> Date: Wed, 12 Jun 2013 18:47:09 +0200
> From: Mudit Verma <mudit.f2004912 at gmail.com>
> To: concurrency-interest <concurrency-interest at cs.oswego.edu>
> Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
>         wait-free?
> Message-ID:
>         <CAMM2gsP_
> x7387eCaR1jsm1RsoDFf3ijw=4u+YJCjPyyW+=nnDQ at mail.gmail.com>
> Content-Type: text/plain; charset=ISO-8859-1
>
> Hi All,
>
> As I read the documentation in java.util.concurrent it says the
> implementation is wait-free. However, I doubt it.  For example an
> enqueue operation loops forever until it is able to CAS new element to
> the tail of queue.  Now, there could be a case, where other threads
> are just fast enough and never give this guy a chance to apply its
> CAS.
>
> However, it helps other threads to update their 2nd CAS (which is to
> update the tail pointer).     As far as first CAS goes, it's not
> wait-free I believe.   Any thoughts?
>
>
>  188:     public boolean offer(E e) {
>  189:         if (e == null) throw new NullPointerException();
>  190:         Node<E> n = new Node<E>(e, null);
>  191:         for (;;) {
>  192:             Node<E> t = tail;
>  193:             Node<E> s = t.getNext();
>  194:             if (t == tail) {
>  195:                 if (s == null) {
>  196:                     if (t.casNext(s, n)) {
>  197:                         casTail(t, n);
>  198:                         return true;
>  199:                     }
>  200:                 } else {
>  201:                     casTail(t, s);
>  202:                 }
>  203:             }
>  204:         }
>  205:     }
>  206:
>
>
> Thanks,
> Mudit

From martinrb at google.com  Tue Jun 18 16:52:54 2013
From: martinrb at google.com (Martin Buchholz)
Date: Tue, 18 Jun 2013 13:52:54 -0700
Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
	wait-free?
In-Reply-To: <CAAApjO1-VG-JTRVigNknhpNng9kPq3zQ=Hi7LznNskG7AVOeYA@mail.gmail.com>
References: <CAAApjO1-VG-JTRVigNknhpNng9kPq3zQ=Hi7LznNskG7AVOeYA@mail.gmail.com>
Message-ID: <CA+kOe08NJrH=dtDDNFww7MtcD=-3Azvt3JQpsCp73+Oj8t_S0w@mail.gmail.com>

I don't think any of the listed methods are technically wait-free.
Frantic activity from other threads can cause even isEmpty to spend
unbounded time traversing the linked list of nodes.


On Tue, Jun 18, 2013 at 1:23 PM, Pedro Ramalhete <pramalhe at gmail.com> wrote:

> Hi Mudit,
>
> After a quick inspection it seems to me that some of the methods of
> ConcurrentLinkedQueue are Lock-Free and others are Wait-Free, namely:
>
> Lock-Free:
> add()
> addAll()
> offer()
> poll()
> remove()
> clear()
>
> Wait-Free:
> contains()
> isEmpty()
> peek()
> size()
> toArray() - uses "new" which by itself is not truly wait-free
> iterator()
> element()
>
> To be more accurate, the functions described above are not just Wait-Free,
> they are Wait-Free Population-Oblivious.
>
> Hope it helps,
> Pedro Ramalhete
>
> ------------------------------
> Date: Wed, 12 Jun 2013 18:47:09 +0200
> From: Mudit Verma <mudit.f2004912 at gmail.com>
> To: concurrency-interest <concurrency-interest at cs.oswego.edu>
> Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
>         wait-free?
> Message-ID:
>         <CAMM2gsP_
> x7387eCaR1jsm1RsoDFf3ijw=4u+YJCjPyyW+=nnDQ at mail.gmail.com>
> Content-Type: text/plain; charset=ISO-8859-1
>
> Hi All,
>
> As I read the documentation in java.util.concurrent it says the
> implementation is wait-free. However, I doubt it.  For example an
> enqueue operation loops forever until it is able to CAS new element to
> the tail of queue.  Now, there could be a case, where other threads
> are just fast enough and never give this guy a chance to apply its
> CAS.
>
> However, it helps other threads to update their 2nd CAS (which is to
> update the tail pointer).     As far as first CAS goes, it's not
> wait-free I believe.   Any thoughts?
>
>
>  188:     public boolean offer(E e) {
>  189:         if (e == null) throw new NullPointerException();
>  190:         Node<E> n = new Node<E>(e, null);
>  191:         for (;;) {
>  192:             Node<E> t = tail;
>  193:             Node<E> s = t.getNext();
>  194:             if (t == tail) {
>  195:                 if (s == null) {
>  196:                     if (t.casNext(s, n)) {
>  197:                         casTail(t, n);
>  198:                         return true;
>  199:                     }
>  200:                 } else {
>  201:                     casTail(t, s);
>  202:                 }
>  203:             }
>  204:         }
>  205:     }
>  206:
>
>
> Thanks,
> Mudit
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130618/133f8d2d/attachment.html>

From alex at puredanger.com  Tue Jun 18 23:51:53 2013
From: alex at puredanger.com (Alex Miller)
Date: Tue, 18 Jun 2013 22:51:53 -0500
Subject: [concurrency-interest] Best FJ version for various JDKs
Message-ID: <CAOdgdgybXF6Ybmbjnmz8LBZ7PZmV52knwvMH_9VzvnVzDfJcfw@mail.gmail.com>

My assumption is that the "best" ForkJoin version to use for executor-style
use cases (no dependent tasks) on various JDK's is:

- JDK 1.8 (when released) - whatever is in the JDK
- JDK 1.7 - jsr166e
- JDK 1.6 - jsr166y

If not, then which? Is this documented anywhere?

Thanks!
Alex
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130618/e1683b4c/attachment.html>

From dl at cs.oswego.edu  Wed Jun 19 07:48:11 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 19 Jun 2013 07:48:11 -0400
Subject: [concurrency-interest] Best FJ version for various JDKs
In-Reply-To: <CAOdgdgybXF6Ybmbjnmz8LBZ7PZmV52knwvMH_9VzvnVzDfJcfw@mail.gmail.com>
References: <CAOdgdgybXF6Ybmbjnmz8LBZ7PZmV52knwvMH_9VzvnVzDfJcfw@mail.gmail.com>
Message-ID: <51C19A7B.1020908@cs.oswego.edu>

On 06/18/13 23:51, Alex Miller wrote:
> My assumption is that the "best" ForkJoin version to use for executor-style use
> cases (no dependent tasks) on various JDK's is:
>
> - JDK 1.8 (when released) - whatever is in the JDK
> - JDK 1.7 - jsr166e
> - JDK 1.6 - jsr166y
>

Yes. I'm in the process of sync'ing up various versions
to be maximally compatible (although the JDK6 version
can't ever be nearly as good as the others). I'll post
something on state of repositories soon.

-Doug


From oleksandr.otenko at oracle.com  Wed Jun 19 10:38:16 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Wed, 19 Jun 2013 15:38:16 +0100
Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
	wait-free?
In-Reply-To: <CAMM2gsPs1nURTreW-ixZcvpp--Q-pHHO1n6C31=jafmYbLV0Qg@mail.gmail.com>
References: <CAAApjO1-VG-JTRVigNknhpNng9kPq3zQ=Hi7LznNskG7AVOeYA@mail.gmail.com>
	<CAMM2gsPs1nURTreW-ixZcvpp--Q-pHHO1n6C31=jafmYbLV0Qg@mail.gmail.com>
Message-ID: <51C1C258.3080703@oracle.com>

If the queue is blocking, how can it be wait-free.

If the queue is non-blocking, there must be a non-blocking alternative 
to (possibly even wait-free) failure to poll() or offer().

I am not sure what a certain *-freedom gives you in this context.

Alex

On 18/06/2013 21:38, Mudit Verma wrote:
> Hello Pedro,
>
> Thanks for your inspection.  Queue is known for two operations,
> enqueue and dequeue.  If these two operations are not wait-free, I am
> not sure whether it will be right to call whole implementation as
> wait-free even thought there are other methods which are wait-free.
>
> Just my take.
>
> Thanks,
> Mudit
>
> On Tue, Jun 18, 2013 at 10:23 PM, Pedro Ramalhete <pramalhe at gmail.com> wrote:
>> Hi Mudit,
>>
>> After a quick inspection it seems to me that some of the methods of
>> ConcurrentLinkedQueue are Lock-Free and others are Wait-Free, namely:
>>
>> Lock-Free:
>> add()
>> addAll()
>> offer()
>> poll()
>> remove()
>> clear()
>>
>> Wait-Free:
>> contains()
>> isEmpty()
>> peek()
>> size()
>> toArray() - uses "new" which by itself is not truly wait-free
>> iterator()
>> element()
>>
>> To be more accurate, the functions described above are not just Wait-Free,
>> they are Wait-Free Population-Oblivious.
>>
>> Hope it helps,
>> Pedro Ramalhete
>>
>> ------------------------------
>> Date: Wed, 12 Jun 2013 18:47:09 +0200
>> From: Mudit Verma <mudit.f2004912 at gmail.com>
>> To: concurrency-interest <concurrency-interest at cs.oswego.edu>
>> Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
>>          wait-free?
>> Message-ID:
>>          <CAMM2gsP_
>> x7387eCaR1jsm1RsoDFf3ijw=4u+YJCjPyyW+=nnDQ at mail.gmail.com>
>> Content-Type: text/plain; charset=ISO-8859-1
>>
>> Hi All,
>>
>> As I read the documentation in java.util.concurrent it says the
>> implementation is wait-free. However, I doubt it.  For example an
>> enqueue operation loops forever until it is able to CAS new element to
>> the tail of queue.  Now, there could be a case, where other threads
>> are just fast enough and never give this guy a chance to apply its
>> CAS.
>>
>> However, it helps other threads to update their 2nd CAS (which is to
>> update the tail pointer).     As far as first CAS goes, it's not
>> wait-free I believe.   Any thoughts?
>>
>>
>>   188:     public boolean offer(E e) {
>>   189:         if (e == null) throw new NullPointerException();
>>   190:         Node<E> n = new Node<E>(e, null);
>>   191:         for (;;) {
>>   192:             Node<E> t = tail;
>>   193:             Node<E> s = t.getNext();
>>   194:             if (t == tail) {
>>   195:                 if (s == null) {
>>   196:                     if (t.casNext(s, n)) {
>>   197:                         casTail(t, n);
>>   198:                         return true;
>>   199:                     }
>>   200:                 } else {
>>   201:                     casTail(t, s);
>>   202:                 }
>>   203:             }
>>   204:         }
>>   205:     }
>>   206:
>>
>>
>> Thanks,
>> Mudit
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From martinrb at google.com  Wed Jun 19 13:45:46 2013
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 19 Jun 2013 10:45:46 -0700
Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
	wait-free?
In-Reply-To: <51C1C258.3080703@oracle.com>
References: <CAAApjO1-VG-JTRVigNknhpNng9kPq3zQ=Hi7LznNskG7AVOeYA@mail.gmail.com>
	<CAMM2gsPs1nURTreW-ixZcvpp--Q-pHHO1n6C31=jafmYbLV0Qg@mail.gmail.com>
	<51C1C258.3080703@oracle.com>
Message-ID: <CA+kOe08Rf9rshLV2Py7ZHtGx7fcp7WGO5qNyTSUkeUVkM+pWBA@mail.gmail.com>

On Wed, Jun 19, 2013 at 7:38 AM, Oleksandr Otenko <
oleksandr.otenko at oracle.com> wrote:

> If the queue is blocking, how can it be wait-free.
>
> If the queue is non-blocking, there must be a non-blocking alternative to
> (possibly even wait-free) failure to poll() or offer().
>
> I am not sure what a certain *-freedom gives you in this context.
>

If you're saying it doesn't matter much to the user whether poll() is
wait-free or lock-free, then I agree.  This is mostly of academic interest.
 Especially when java thread priorities generally don't work, and there's
no risk of priority inversion.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130619/ee697ff0/attachment.html>

From dl at cs.oswego.edu  Wed Jun 19 19:37:37 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 19 Jun 2013 19:37:37 -0400
Subject: [concurrency-interest] refreshes + outage
Message-ID: <51C240C1.5090905@cs.oswego.edu>


As the main JDK8 java.util.concurrent classes are finally in the
process of being integrated into OpenJDK8, I updated jsr166e
packages (i.e., classes with as much of the functionality
as JDK8 classes as possible without JDK8 language/VM support).
This includes some bugfixes and performance improvements.

The only jsr166e change worth noting is that the bulk
tasks and Spliterator APIs changed a lot in the course
of implementing lambda support. So jsr166e.ConcurrentHashMapV8
now includes an updated nested ConcurrentHashMapSpliterator
interface that provides a subset of JDK8 java.util.Spliterator.
Sorry to those using ConcurrentHashMapV8 for parallel tasks
that you'll need to update usage code.

Also, due to popular demand, we set up a "jsr166-4jdk7"
repository that includes the most recent internal
implementations, but with (almost) the same externals
as initial JDK7. (There are few added things compared to initial
JDK7, for example FJP commonPool, that would cause too much
disruption to pull out.) There's no separate packaging,
just files.

The concurrency-interest page has all of the usual details
and links to source, API docs, and jar files:
http://gee.cs.oswego.edu/dl/concurrency-interest/index.html

You might want to grab things soon, maybe the entire
tarball pf everything, at:
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/#dirlist

Any day now (possibly this Friday 21 June), our department
will be moving across the street to a new building, and nothing
will work until we re-set-up servers and labs. It could
only be a day, but I wouldn't bet on it. (Try asking
Google maps for "Takamine Street, Oswego, NY" if
you are geographically curious. That's the street we are
moving across. Well, it used to be a street.)

-Doug

From ron.pressler at gmail.com  Sat Jun 22 20:42:32 2013
From: ron.pressler at gmail.com (Ron Pressler)
Date: Sun, 23 Jun 2013 03:42:32 +0300
Subject: [concurrency-interest] Performance regression in newest (6/20/2013)
	jsr166 update
Message-ID: <CABg6-qj0FxrUgA7atMdVVVuUGqVvzyvo7F+btpKsFjtaPG4LVA@mail.gmail.com>

Hi.

A couple of months ago I described the behavior detailed in the email
exchange below. The newest update causes a slowdown of about 25% of this
benchmark:

import java.util.concurrent.TimeUnit;
import jsr166e.ForkJoinPool;
import jsr166e.ForkJoinTask;
import jsr166e.RecursiveAction;

public class FJBenchmark {
    static final int PARALLELISM = 4;
    static final int COUNT = 1000000;
    static ForkJoinPool fjPool = new ForkJoinPool(PARALLELISM,
ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);

    public static void main(String[] args) throws Exception {
        for (int i = 0; i < 10; i++)
            run(COUNT);
    }

    static void run(int count) throws Exception {
        RecursiveAction lastTask = new RecursiveAction() {
            protected void compute() {
            }
        };
        final long start = System.nanoTime();
        fjPool.submit(new MyTask(count, lastTask));
        lastTask.get();
        System.out.println("count: " + count + " time: " +
TimeUnit.MILLISECONDS.convert(System.nanoTime() - start,
TimeUnit.NANOSECONDS));
    }

    static class MyTask extends RecursiveAction {
        final int count;
        final ForkJoinTask lastTask;

        public MyTask(int count, ForkJoinTask lastTask) {
            this.count = count;
            this.lastTask = lastTask;
        }

        protected void compute() {
            if (count > 0)
                new MyTask(count - 1, lastTask).fork();
            else
                lastTask.fork();
        }
    }
}

---------- Forwarded message ----------
From: Doug Lea <dl at cs.oswego.edu>
Date: Mon, Apr 8, 2013 at 8:22 PM
Subject: Re: [concurrency-interest] jsr166e.ForkJoinPool performance issue
To: concurrency-interest at cs.oswego.edu


On 04/08/13 13:08, Ron Pressler wrote:

> Now, we're trying to use FJ for scheduling a message-passing component,
> and I've
> noticed a performance issue that the code below demonstrates. This is a
> degenerate case where only one FJTask is active at a time -- a single task
> is
> submitted, which forks a single task and terminates. The new task
> subsequently
> forks another one and so on.
>
> When the parallelism level is set to 1, a run completes in about 35ms on my
> machine. When it is set to 4 (I'm running on a 4-core i7, 8 virtual
> cores), that
> duration rises above 120ms. The NetBeans profiler shows the hot-spot to be
> ForkJoinPool.WorkQueue.push(), and, in particular, its call to
> ForkJoinPool.signalWork. The NetBeans profiler provides far-from-definite
> proof,
> but further testing has shown that this may, in fact, be true. In our
> code, when
> some computation takes place in the tasks, NetBeans attributes almost 40%
> of CPU
> time to WorkQueue.push().
>
> It seems that this should actually be a simple case, with only one non-idle
> Worker continually executing each new task as it forks. However, it seems
> like
> in this case (and unlike with our other FJ uses), the pool is sensitive to
> the
> parallelism level, which could be a problem.
>
>
The underlying issue is that the pushing task does not know that
the single worker is already available, so activates another.
(It can take a few dozen nanoseconds for workers to rescan before
idling.) So it is not so much parallelism-level as intrinsic raciness.
This turns out to be a common issue when processing small Streams
in upcoming jdk8 support, so I've been working to improve it.
Stay tuned...

-Doug



______________________________**_________________
Concurrency-interest mailing list
Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130623/6d3348e4/attachment.html>

From mikeb01 at gmail.com  Sat Jun 22 23:03:02 2013
From: mikeb01 at gmail.com (Michael Barker)
Date: Sun, 23 Jun 2013 15:03:02 +1200
Subject: [concurrency-interest] AtomicLong and @Contended
Message-ID: <CALwNKeTsduRpCo5ZE4eFwxqaznqnzEd_DLFoQzWtb7F3tDJjWQ@mail.gmail.com>

Apologies for the cross post, but I wasn't sure of the best place the
ask the following question.

Now that @Contended is implemented is there any chance that it will be
applied to AtomicLong or an alternative "PaddedAtomicLong" be provided
in JDK8?

I'd be happy to submit a patch if that is what would be required to
get this implemented.  My personal interest in this is that I could
drop a whole bunch of code that currently uses the Unsafe and replace
it with this class.

Regards,
Michael Barker.

From corporate.piyush at gmail.com  Sun Jun 23 03:20:25 2013
From: corporate.piyush at gmail.com (corporate.piyush at gmail.com)
Date: Sun, 23 Jun 2013 12:50:25 +0530
Subject: [concurrency-interest] Design of Thread Safe Iterator Proxy
In-Reply-To: <51BE4490.1070407@univ-mlv.fr>
References: <CAA5REoU+3sMAHa7Z2=k3pdETeZck1z5WGDe8P9v18_fGQUTQmA@mail.gmail.com>
	<51BE4490.1070407@univ-mlv.fr>
Message-ID: <62E18E2DC09C43C79AC494F289A9703B@PiyushPC>

sorry for late reply...

@Remi & @Yuvit

thanks for your time.
I know that concrete solution to this problem is not possible as hasNext() 
and next() are two different methods.

But we can at least think of Safe Iterator proxy , assuming the following

1. every thread which calls hasNext() is expected to call next() , again in 
order
2. once a particular thread calls hasNext(), a lock will be active until the 
same thread calls next() and retrieves the element from underlying iterator
3. during the execution of step 2, all other threads have to wait for their 
turn.


Regards,
Piyush Katariya

-----Original Message----- 
From: Remi Forax
Sent: Monday, June 17, 2013 4:34 AM
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Design of Thread Safe Iterator Proxy

On 06/10/2013 08:37 AM, piyush katariya wrote:
> Hi,
>
>        so i was in the need of ThreadSafe iterator, so that multiple 
> threads can access over it concurrently without  throwing 
> "ConcurrentModificationException".
>
> i came with solution attached herewith, but for some reason..multiple 
> threads from thread pool after iterating over, stucks...
>
> can somebody help me with it..
>

I can explain why your program deadlock, it's easy.
I will only explain why it deadlock if the client code is:
   while(hasNext()) { it.next(); }
but it can also deadlock is hasNext is called multiple times without
calling next and vice-versa.

so if the client code is:
   while(hasNext()) { it.next(); }
when hasNext returns false, next is not called because you go out of the
loop but you still hold the lock,
so the next thread will stop when trying to acquire the lock in hasNext.

BTW, I think there is no way to write a thread-safe proxy iterator if
remove() is supported.

>
> Regards,
> Piyush Katariya

cheers,
R?mi



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest 
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: SafeIterator.txt
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130623/376d86ea/attachment.txt>

From discus at kotek.net  Mon Jun 24 06:38:52 2013
From: discus at kotek.net (Jan Kotek)
Date: Mon, 24 Jun 2013 11:38:52 +0100
Subject: [concurrency-interest] Hardware for testing
Message-ID: <13212550.WqCPNCZgUp@artemis>

Hi,

I need to test parallel computations (mostly fork-join) and I am looking for  
hardware to use for testing. I want many cores and mainstream architecture. It 
should be affordable.

So far I came with those options:

 -  rent a server on AWS or similar. But virtualization could render tests 
useless. Also long-term price is not so good.

 - buy second-hand rack server. For example HP ProLiant with 4x6 core Opteron 
is very cheap. Also old AMDs are probably best for testing since there is no 
power management. 

 - build machine from parts (2x12 core Opteron, dual socket EATX motherboard). 
This would be basically standard desktop, expandable with DDR3 memory modules 
and PCIe cards. 

 - Parallella has 64 cores ARM CPU. But it may not run Java and probably has 
strange architecture, so not rally an option for testing.

Any comments?


--
Thanks
Jan Kotek



From stanimir at riflexo.com  Mon Jun 24 07:18:48 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Mon, 24 Jun 2013 14:18:48 +0300
Subject: [concurrency-interest] Hardware for testing
In-Reply-To: <13212550.WqCPNCZgUp@artemis>
References: <13212550.WqCPNCZgUp@artemis>
Message-ID: <CAEJX8org5J1Fn0WM9+8aba-T=2qp6fJAJ8xNazD-Woyagy9cgg@mail.gmail.com>

You can rent 32core AMD /64GB for less than 250e/month.

Stanimir

On Mon, Jun 24, 2013 at 1:38 PM, Jan Kotek <discus at kotek.net> wrote:

> Hi,
>
> I need to test parallel computations (mostly fork-join) and I am looking
> for
> hardware to use for testing. I want many cores and mainstream
> architecture. It
> should be affordable.
>
> So far I came with those options:
>
>  -  rent a server on AWS or similar. But virtualization could render tests
> useless. Also long-term price is not so good.
>
>  - buy second-hand rack server. For example HP ProLiant with 4x6 core
> Opteron
> is very cheap. Also old AMDs are probably best for testing since there is
> no
> power management.
>
>  - build machine from parts (2x12 core Opteron, dual socket EATX
> motherboard).
> This would be basically standard desktop, expandable with DDR3 memory
> modules
> and PCIe cards.
>
>  - Parallella has 64 cores ARM CPU. But it may not run Java and probably
> has
> strange architecture, so not rally an option for testing.
>
> Any comments?
>
>
> --
> Thanks
> Jan Kotek
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130624/4df06cca/attachment.html>

From ariel at weisberg.ws  Mon Jun 24 10:33:02 2013
From: ariel at weisberg.ws (Ariel Weisberg)
Date: Mon, 24 Jun 2013 10:33:02 -0400
Subject: [concurrency-interest] Hardware for testing
In-Reply-To: <13212550.WqCPNCZgUp@artemis>
References: <13212550.WqCPNCZgUp@artemis>
Message-ID: <1372084382.26807.140661247824598.4E949816@webmail.messagingengine.com>

Hi,

Amazon cluster compute spot instances are reasonably priced,
reproducable, and don't suffer from noisy neighbor issues because you
get the entire machine. I don't think virtualization is as much of an
issue as multi-tenancy. It's slower, but when you aren't interacting
with disk or network it is not that much slower.

Regards,
Ariel

On Mon, Jun 24, 2013, at 06:38 AM, Jan Kotek wrote:
> Hi,
> 
> I need to test parallel computations (mostly fork-join) and I am looking
> for  
> hardware to use for testing. I want many cores and mainstream
> architecture. It 
> should be affordable.
> 
> So far I came with those options:
> 
>  -  rent a server on AWS or similar. But virtualization could render
>  tests 
> useless. Also long-term price is not so good.
> 
>  - buy second-hand rack server. For example HP ProLiant with 4x6 core
>  Opteron 
> is very cheap. Also old AMDs are probably best for testing since there is
> no 
> power management. 
> 
>  - build machine from parts (2x12 core Opteron, dual socket EATX
>  motherboard). 
> This would be basically standard desktop, expandable with DDR3 memory
> modules 
> and PCIe cards. 
> 
>  - Parallella has 64 cores ARM CPU. But it may not run Java and probably
>  has 
> strange architecture, so not rally an option for testing.
> 
> Any comments?
> 
> 
> --
> Thanks
> Jan Kotek
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From nathan.reynolds at oracle.com  Mon Jun 24 16:26:35 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 24 Jun 2013 13:26:35 -0700
Subject: [concurrency-interest] Design of Thread Safe Iterator Proxy
In-Reply-To: <62E18E2DC09C43C79AC494F289A9703B@PiyushPC>
References: <CAA5REoU+3sMAHa7Z2=k3pdETeZck1z5WGDe8P9v18_fGQUTQmA@mail.gmail.com>
	<51BE4490.1070407@univ-mlv.fr>
	<62E18E2DC09C43C79AC494F289A9703B@PiyushPC>
Message-ID: <51C8AB7B.2020303@oracle.com>

The lock needs to be acquired in hasNext() and released when the thread 
calls hasNext() again or remove().  It has to hold the lock until the 
next hasNext() since the thread could call remove().  If the thread 
calls remove() outside of the lock then underlying collection may have 
been changed.

Typically what I do is have hasNext() cache the object.  Then next() and 
remove() use that object in their operations.  next() will succeed 
because of the cached object.  remove() may or may not succeed.  Either 
way, it doesn't throw an exception.

Another idea is to just allow for calling next().  If there are no more 
objects available, then next() returns null or an end of "stream" object.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 6/23/2013 12:20 AM, corporate.piyush at gmail.com wrote:
> sorry for late reply...
>
> @Remi & @Yuvit
>
> thanks for your time.
> I know that concrete solution to this problem is not possible as 
> hasNext() and next() are two different methods.
>
> But we can at least think of Safe Iterator proxy , assuming the following
>
> 1. every thread which calls hasNext() is expected to call next() , 
> again in order
> 2. once a particular thread calls hasNext(), a lock will be active 
> until the same thread calls next() and retrieves the element from 
> underlying iterator
> 3. during the execution of step 2, all other threads have to wait for 
> their turn.
>
>
> Regards,
> Piyush Katariya
>
> -----Original Message----- From: Remi Forax
> Sent: Monday, June 17, 2013 4:34 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Design of Thread Safe Iterator Proxy
>
> On 06/10/2013 08:37 AM, piyush katariya wrote:
>> Hi,
>>
>>        so i was in the need of ThreadSafe iterator, so that multiple 
>> threads can access over it concurrently without throwing 
>> "ConcurrentModificationException".
>>
>> i came with solution attached herewith, but for some reason..multiple 
>> threads from thread pool after iterating over, stucks...
>>
>> can somebody help me with it..
>>
>
> I can explain why your program deadlock, it's easy.
> I will only explain why it deadlock if the client code is:
>   while(hasNext()) { it.next(); }
> but it can also deadlock is hasNext is called multiple times without
> calling next and vice-versa.
>
> so if the client code is:
>   while(hasNext()) { it.next(); }
> when hasNext returns false, next is not called because you go out of the
> loop but you still hold the lock,
> so the next thread will stop when trying to acquire the lock in hasNext.
>
> BTW, I think there is no way to write a thread-safe proxy iterator if
> remove() is supported.
>
>>
>> Regards,
>> Piyush Katariya
>
> cheers,
> R?mi
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130624/186aa540/attachment.html>

From pramalhe at gmail.com  Mon Jun 24 17:27:37 2013
From: pramalhe at gmail.com (Pedro Ramalhete)
Date: Mon, 24 Jun 2013 22:27:37 +0100
Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
	wait-free?
In-Reply-To: <CA+kOe08Rf9rshLV2Py7ZHtGx7fcp7WGO5qNyTSUkeUVkM+pWBA@mail.gmail.com>
References: <CAAApjO1-VG-JTRVigNknhpNng9kPq3zQ=Hi7LznNskG7AVOeYA@mail.gmail.com>
	<CAMM2gsPs1nURTreW-ixZcvpp--Q-pHHO1n6C31=jafmYbLV0Qg@mail.gmail.com>
	<51C1C258.3080703@oracle.com>
	<CA+kOe08Rf9rshLV2Py7ZHtGx7fcp7WGO5qNyTSUkeUVkM+pWBA@mail.gmail.com>
Message-ID: <CAAApjO3pJyAsBFNOrzJYKwOL_2S+qa794Yro4BiJWV=7OD+yhA@mail.gmail.com>

Hi Mudit,
I completely agree with you. According to the the definition of wait-free,
an object or data-structure can only be called wait-free if _all_ of its
methods are wait-free, which is clearly not the case of the
ConcurrentLinkedQueue and, therefore, the documentation should be corrected.


Martin, I believe that some of the methods in the CLQ are technically
wait-free, but in case I'm wrong, then it's even a stronger reason to
change the documentation ;)
Moreover, I agree with you that the difference between a wait-free queue
and a lock-free queue is mostly academic, but only for queues, not for
other data structures.



On Wed, Jun 19, 2013 at 6:45 PM, Martin Buchholz <martinrb at google.com>wrote:

>
>
>
> On Wed, Jun 19, 2013 at 7:38 AM, Oleksandr Otenko <
> oleksandr.otenko at oracle.com> wrote:
>
>> If the queue is blocking, how can it be wait-free.
>>
>> If the queue is non-blocking, there must be a non-blocking alternative to
>> (possibly even wait-free) failure to poll() or offer().
>>
>> I am not sure what a certain *-freedom gives you in this context.
>>
>
> If you're saying it doesn't matter much to the user whether poll() is
> wait-free or lock-free, then I agree.  This is mostly of academic interest.
>  Especially when java thread priorities generally don't work, and there's
> no risk of priority inversion.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130624/1036a36c/attachment.html>

From mudit.f2004912 at gmail.com  Mon Jun 24 17:48:31 2013
From: mudit.f2004912 at gmail.com (Mudit Verma)
Date: Mon, 24 Jun 2013 23:48:31 +0200
Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
	wait-free?
In-Reply-To: <CAAApjO3pJyAsBFNOrzJYKwOL_2S+qa794Yro4BiJWV=7OD+yhA@mail.gmail.com>
References: <CAAApjO1-VG-JTRVigNknhpNng9kPq3zQ=Hi7LznNskG7AVOeYA@mail.gmail.com>
	<CAMM2gsPs1nURTreW-ixZcvpp--Q-pHHO1n6C31=jafmYbLV0Qg@mail.gmail.com>
	<51C1C258.3080703@oracle.com>
	<CA+kOe08Rf9rshLV2Py7ZHtGx7fcp7WGO5qNyTSUkeUVkM+pWBA@mail.gmail.com>
	<CAAApjO3pJyAsBFNOrzJYKwOL_2S+qa794Yro4BiJWV=7OD+yhA@mail.gmail.com>
Message-ID: <CAMM2gsO-P0DoEaGabXnAJYrzNU3d5vM2geqco03EcNUwNx3MNw@mail.gmail.com>

Hello Everyone,

I think, its only right to change the documentation.

I am currently doing my master thesis on Concurrent Data Structures
(specially on queue) and we have experimental proofs that with large scale
multicore systems (such as ccNUMA), some of the threads just don't get fair
access to shared data structures (queue in this case).

This totally depends on, which NUMA node hosts the queue memory. Threads
running locally on that NUMA node gets unfairly easy access to the queue as
compared to threads running on other nodes. In this case, other threads
have to send remote memory access request for queue operations, which makes
the whole difference.  The time it takes to access the remote memory, by
that time local threads already changes the structure by applying their
operations. This results in failed CAS for remote threads.

In our results we have seen starvation for few threads (worst case), or
highly disproportionate per operation completion time (normal case).

Therefore, I believe, wait-freedom is as much required in queues as in any
other data structure. Obviously this problem is only seen when the queue is
accessed heavily left right center by all the threads.

Thanks,
Mudit

On Mon, Jun 24, 2013 at 11:27 PM, Pedro Ramalhete <pramalhe at gmail.com>wrote:

> Hi Mudit,
> I completely agree with you. According to the the definition of wait-free,
> an object or data-structure can only be called wait-free if _all_ of its
> methods are wait-free, which is clearly not the case of the
> ConcurrentLinkedQueue and, therefore, the documentation should be corrected.
>
>
> Martin, I believe that some of the methods in the CLQ are technically
> wait-free, but in case I'm wrong, then it's even a stronger reason to
> change the documentation ;)
> Moreover, I agree with you that the difference between a wait-free queue
> and a lock-free queue is mostly academic, but only for queues, not for
> other data structures.
>
>
>
> On Wed, Jun 19, 2013 at 6:45 PM, Martin Buchholz <martinrb at google.com>wrote:
>
>>
>>
>>
>> On Wed, Jun 19, 2013 at 7:38 AM, Oleksandr Otenko <
>> oleksandr.otenko at oracle.com> wrote:
>>
>>> If the queue is blocking, how can it be wait-free.
>>>
>>> If the queue is non-blocking, there must be a non-blocking alternative
>>> to (possibly even wait-free) failure to poll() or offer().
>>>
>>> I am not sure what a certain *-freedom gives you in this context.
>>>
>>
>> If you're saying it doesn't matter much to the user whether poll() is
>> wait-free or lock-free, then I agree.  This is mostly of academic interest.
>>  Especially when java thread priorities generally don't work, and there's
>> no risk of priority inversion.
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130624/3e002032/attachment.html>

From nathan.reynolds at oracle.com  Mon Jun 24 19:31:45 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 24 Jun 2013 16:31:45 -0700
Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
	wait-free?
In-Reply-To: <CAMM2gsO-P0DoEaGabXnAJYrzNU3d5vM2geqco03EcNUwNx3MNw@mail.gmail.com>
References: <CAAApjO1-VG-JTRVigNknhpNng9kPq3zQ=Hi7LznNskG7AVOeYA@mail.gmail.com>
	<CAMM2gsPs1nURTreW-ixZcvpp--Q-pHHO1n6C31=jafmYbLV0Qg@mail.gmail.com>
	<51C1C258.3080703@oracle.com>
	<CA+kOe08Rf9rshLV2Py7ZHtGx7fcp7WGO5qNyTSUkeUVkM+pWBA@mail.gmail.com>
	<CAAApjO3pJyAsBFNOrzJYKwOL_2S+qa794Yro4BiJWV=7OD+yhA@mail.gmail.com>
	<CAMM2gsO-P0DoEaGabXnAJYrzNU3d5vM2geqco03EcNUwNx3MNw@mail.gmail.com>
Message-ID: <51C8D6E1.3080107@oracle.com>

Mudit,

You might want to check out this blog entry from Dave Dice.  It probably 
is relevant to your work. 
https://blogs.oracle.com/dave/entry/numa_aware_placement_of_communication1

Another entry compares CAS vs atomic add. 
https://blogs.oracle.com/dave/entry/atomic_fetch_and_add_vs

I find Dave Dice's blog to be very enlightening for concurrency work.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 6/24/2013 2:48 PM, Mudit Verma wrote:
> Hello Everyone,
>
> I think, its only right to change the documentation.
>
> I am currently doing my master thesis on Concurrent Data Structures 
> (specially on queue) and we have experimental proofs that with large 
> scale multicore systems (such as ccNUMA), some of the threads just 
> don't get fair access to shared data structures (queue in this case).
>
> This totally depends on, which NUMA node hosts the queue memory. 
> Threads running locally on that NUMA node gets unfairly easy access to 
> the queue as compared to threads running on other nodes. In this case, 
> other threads have to send remote memory access request for queue 
> operations, which makes the whole difference. The time it takes to 
> access the remote memory, by that time local threads already changes 
> the structure by applying their operations. This results in failed CAS 
> for remote threads.
>
> In our results we have seen starvation for few threads (worst case), 
> or highly disproportionate per operation completion time (normal case).
>
> Therefore, I believe, wait-freedom is as much required in queues as in 
> any other data structure. Obviously this problem is only seen when the 
> queue is accessed heavily left right center by all the threads.
>
> Thanks,
> Mudit
>
> On Mon, Jun 24, 2013 at 11:27 PM, Pedro Ramalhete <pramalhe at gmail.com 
> <mailto:pramalhe at gmail.com>> wrote:
>
>     Hi Mudit,
>     I completely agree with you. According to the the definition of
>     wait-free, an object or data-structure can only be called
>     wait-free if _all_ of its methods are wait-free, which is clearly
>     not the case of the ConcurrentLinkedQueue and, therefore, the
>     documentation should be corrected.
>
>
>     Martin, I believe that some of the methods in the CLQ are
>     technically wait-free, but in case I'm wrong, then it's even a
>     stronger reason to change the documentation ;)
>     Moreover, I agree with you that the difference between a wait-free
>     queue and a lock-free queue is mostly academic, but only for
>     queues, not for other data structures.
>
>
>
>     On Wed, Jun 19, 2013 at 6:45 PM, Martin Buchholz
>     <martinrb at google.com <mailto:martinrb at google.com>> wrote:
>
>
>
>
>         On Wed, Jun 19, 2013 at 7:38 AM, Oleksandr Otenko
>         <oleksandr.otenko at oracle.com
>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>             If the queue is blocking, how can it be wait-free.
>
>             If the queue is non-blocking, there must be a non-blocking
>             alternative to (possibly even wait-free) failure to poll()
>             or offer().
>
>             I am not sure what a certain *-freedom gives you in this
>             context.
>
>
>         If you're saying it doesn't matter much to the user whether
>         poll() is wait-free or lock-free, then I agree.  This is
>         mostly of academic interest.  Especially when java thread
>         priorities generally don't work, and there's no risk of
>         priority inversion.
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130624/6bfdb150/attachment-0001.html>

From martinrb at google.com  Tue Jun 25 00:51:37 2013
From: martinrb at google.com (Martin Buchholz)
Date: Mon, 24 Jun 2013 21:51:37 -0700
Subject: [concurrency-interest] is ConcurrentLinkedQueue is truely
	wait-free?
In-Reply-To: <CAAApjO3pJyAsBFNOrzJYKwOL_2S+qa794Yro4BiJWV=7OD+yhA@mail.gmail.com>
References: <CAAApjO1-VG-JTRVigNknhpNng9kPq3zQ=Hi7LznNskG7AVOeYA@mail.gmail.com>
	<CAMM2gsPs1nURTreW-ixZcvpp--Q-pHHO1n6C31=jafmYbLV0Qg@mail.gmail.com>
	<51C1C258.3080703@oracle.com>
	<CA+kOe08Rf9rshLV2Py7ZHtGx7fcp7WGO5qNyTSUkeUVkM+pWBA@mail.gmail.com>
	<CAAApjO3pJyAsBFNOrzJYKwOL_2S+qa794Yro4BiJWV=7OD+yhA@mail.gmail.com>
Message-ID: <CA+kOe0-FFf1kajjjKceysYv45Qe1Zb1XdyDL5=aM0ixk3+tY1Q@mail.gmail.com>

Everyone agreed that the use of "wait-free" in the CLQ docs was poor and it
has been changed in jsr166 CVS.  In the fullness of time it should appear
in openjdk.


On Mon, Jun 24, 2013 at 2:27 PM, Pedro Ramalhete <pramalhe at gmail.com> wrote:

> Martin, I believe that some of the methods in the CLQ are technically
> wait-free, but in case I'm wrong, then it's even a stronger reason to
> change the documentation ;)
>

I continue to believe the most likely to be wait-free methods like peek and
isEmpty are not, in fact.


> Moreover, I agree with you that the difference between a wait-free queue
> and a lock-free queue is mostly academic, but only for queues, not for
> other data structures.
>

Hmmm...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130624/f9d3ccf1/attachment.html>

From peter.levart at gmail.com  Tue Jun 25 08:48:55 2013
From: peter.levart at gmail.com (Peter Levart)
Date: Tue, 25 Jun 2013 14:48:55 +0200
Subject: [concurrency-interest] Design of Thread Safe Iterator Proxy
In-Reply-To: <62E18E2DC09C43C79AC494F289A9703B@PiyushPC>
References: <CAA5REoU+3sMAHa7Z2=k3pdETeZck1z5WGDe8P9v18_fGQUTQmA@mail.gmail.com>
	<51BE4490.1070407@univ-mlv.fr>
	<62E18E2DC09C43C79AC494F289A9703B@PiyushPC>
Message-ID: <51C991B7.7060807@gmail.com>

On 06/23/2013 09:20 AM, corporate.piyush at gmail.com wrote:
> sorry for late reply...
>
> @Remi & @Yuvit
>
> thanks for your time.
> I know that concrete solution to this problem is not possible as 
> hasNext() and next() are two different methods.
>
> But we can at least think of Safe Iterator proxy , assuming the following
>
> 1. every thread which calls hasNext() is expected to call next() , 
> again in order
> 2. once a particular thread calls hasNext(), a lock will be active 
> until the same thread calls next() and retrieves the element from 
> underlying iterator
> 3. during the execution of step 2, all other threads have to wait for 
> their turn.
>
>
> Regards,
> Piyush Katariya
>
> -----Original Message----- From: Remi Forax
> Sent: Monday, June 17, 2013 4:34 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Design of Thread Safe Iterator Proxy
>
> On 06/10/2013 08:37 AM, piyush katariya wrote:
>> Hi,
>>
>>        so i was in the need of ThreadSafe iterator, so that multiple 
>> threads can access over it concurrently without throwing 
>> "ConcurrentModificationException".
>>
>> i came with solution attached herewith, but for some reason..multiple 
>> threads from thread pool after iterating over, stucks...
>>
>> can somebody help me with it..
>>
>
> I can explain why your program deadlock, it's easy.
> I will only explain why it deadlock if the client code is:
>   while(hasNext()) { it.next(); }
> but it can also deadlock is hasNext is called multiple times without
> calling next and vice-versa.
>
> so if the client code is:
>   while(hasNext()) { it.next(); }
> when hasNext returns false, next is not called because you go out of the
> loop but you still hold the lock,
> so the next thread will stop when trying to acquire the lock in hasNext.
>
> BTW, I think there is no way to write a thread-safe proxy iterator if
> remove() is supported.

Bu if you don't need remove() method, then the following might be a 
better approximation. It only requires that the thread that got a true 
result from hasNext() also calls next() at least once after that (Note: 
I would not encourage you to use such Iterator in you code if you can 
solve your problem otherwise, like using BlockingQueue for example...):


public class ConcurrentIterator<T> implements Iterator<T> {
     private final Iterator<T> iterator;

     public ConcurrentIterator(Iterator<T> iterator) {
         this.iterator = iterator;
     }

     // fair lock allows previous waiters to have priority over thread 
that had lock,
     // released it and attempts to gain it immediately after that...
     private final ReentrantLock lock = new ReentrantLock(true);

     @Override
     public boolean hasNext() {
         if (!lock.isHeldByCurrentThread()) {
             lock.lock(); // obtain lock if necessary
         }

         try {
             if (iterator.hasNext()) {
                 return true;
             }
         }
         catch (Throwable t) {
             lock.unlock(); // unlock and re-throw when hasNext() throws
             throw t;
         }

         lock.unlock(); // also unlock immediately when no more elements
         return false;
     }

     @Override
     public T next() {
         if (!lock.isHeldByCurrentThread()) {
             lock.lock(); // obtain lock if necessary
         }

         try {
             return iterator.next();
         }
         finally {
             lock.unlock(); // unlock immediately regardless of outcome
         }
     }

     @Override
     public void remove() {
         throw new UnsupportedOperationException();
     }
}


Regards, Peter

>
>>
>> Regards,
>> Piyush Katariya
>
> cheers,
> R?mi
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/5b1abeca/attachment.html>

From chris.w.dennis at gmail.com  Tue Jun 25 12:50:33 2013
From: chris.w.dennis at gmail.com (Chris Dennis)
Date: Tue, 25 Jun 2013 12:50:33 -0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
Message-ID: <CDEF4299.2F31E%chris.w.dennis@gmail.com>

Hi All,

While dealing with a customer issue, I ran in to the possibility of
breaking a RRWL by feeding in Thread instances with colliding thread-ids.
Inside RRWL the cachedHoldCounter logic assumes that getId() will return a
unique identifier for a thread.  Do people consider this a bug in RRWL or
not? (I think it would be agreed that this is also a bug in the
subclassing of Thread)

Regards,

Chris Dennis

public static void main(String[] args) {
  final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
  final CyclicBarrier barrier = new CyclicBarrier(2);
    
  Thread t1 = new EvilThread() {
    public void run() {
      try {
        lock.readLock().lock();
        barrier.await();
        //T2 locks
        barrier.await();
        //T3 locks
        //T3 unlocks
        barrier.await();
        //T2 unlocks
        barrier.await();
        lock.readLock().unlock();
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
      
  };
  Thread t2 = new EvilThread() {
    public void run() {
      try {
        //T1 locks
                  barrier.await();
                  lock.readLock().lock();
                  barrier.await();
                  //T3 locks
                  //T3 unlocks
                  barrier.await();
                  lock.readLock().unlock();
                  barrier.await();
                  //T1 unlocks
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
      
  };
  Thread t3 = new EvilThread() {
    public void run() {
      try {
        //T1 locks
        barrier.await();
                  //T2 locks
                  barrier.await();
                  lock.readLock().lock();
                  lock.readLock().unlock();
                  barrier.await();
                  //T2 unlocks
                  barrier.await();
                  //T3 unlocks
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
      
  };
    
  t1.start();
  t2.start();
  t3.start();
  }

  
  static class EvilThread extends Thread {
  public long getId() {
    return 42L;
  }
  }



From nathan.reynolds at oracle.com  Tue Jun 25 13:24:05 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 25 Jun 2013 10:24:05 -0700
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <CDEF4299.2F31E%chris.w.dennis@gmail.com>
References: <CDEF4299.2F31E%chris.w.dennis@gmail.com>
Message-ID: <51C9D235.9040106@oracle.com>

The JavaDoc for Thread.getId() says "...thread ID is unique..." so I 
don't think this is a bug in RRWL.  Maybe Thread.getId() should be 
declared final.

We might want to consider going as far as declaring the member field 
"tid" as final.  This could be done via "private long tid = nextThreadID();"

I find it very interesting that threadInitNumber and threadSeqNumber are 
both used in the Thread class.  It seems we only need 1.  It seems that 
the constructor should use "Thread-" + tid for a thread name.  In fact, 
the name could read "Thread-10" and the tid could be 7 because there is 
a race between when the name is generated and the tid is set.  The 
mismatch probably doesn't matter functionally.  However, it could make 
it easier for debugging.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 6/25/2013 9:50 AM, Chris Dennis wrote:
> Hi All,
>
> While dealing with a customer issue, I ran in to the possibility of
> breaking a RRWL by feeding in Thread instances with colliding thread-ids.
> Inside RRWL the cachedHoldCounter logic assumes that getId() will return a
> unique identifier for a thread.  Do people consider this a bug in RRWL or
> not? (I think it would be agreed that this is also a bug in the
> subclassing of Thread)
>
> Regards,
>
> Chris Dennis
>
> public static void main(String[] args) {
>    final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
>    final CyclicBarrier barrier = new CyclicBarrier(2);
>      
>    Thread t1 = new EvilThread() {
>      public void run() {
>        try {
>          lock.readLock().lock();
>          barrier.await();
>          //T2 locks
>          barrier.await();
>          //T3 locks
>          //T3 unlocks
>          barrier.await();
>          //T2 unlocks
>          barrier.await();
>          lock.readLock().unlock();
>        } catch (Exception e) {
>          e.printStackTrace();
>        }
>      }
>        
>    };
>    Thread t2 = new EvilThread() {
>      public void run() {
>        try {
>          //T1 locks
>                    barrier.await();
>                    lock.readLock().lock();
>                    barrier.await();
>                    //T3 locks
>                    //T3 unlocks
>                    barrier.await();
>                    lock.readLock().unlock();
>                    barrier.await();
>                    //T1 unlocks
>        } catch (Exception e) {
>          e.printStackTrace();
>        }
>      }
>        
>    };
>    Thread t3 = new EvilThread() {
>      public void run() {
>        try {
>          //T1 locks
>          barrier.await();
>                    //T2 locks
>                    barrier.await();
>                    lock.readLock().lock();
>                    lock.readLock().unlock();
>                    barrier.await();
>                    //T2 unlocks
>                    barrier.await();
>                    //T3 unlocks
>        } catch (Exception e) {
>          e.printStackTrace();
>        }
>      }
>        
>    };
>      
>    t1.start();
>    t2.start();
>    t3.start();
>    }
>
>    
>    static class EvilThread extends Thread {
>    public long getId() {
>      return 42L;
>    }
>    }
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/4305eeb6/attachment.html>

From chris.w.dennis at gmail.com  Tue Jun 25 13:56:00 2013
From: chris.w.dennis at gmail.com (Chris Dennis)
Date: Tue, 25 Jun 2013 13:56:00 -0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
 implementations
In-Reply-To: <51C9D235.9040106@oracle.com>
Message-ID: <CDEF507C.2F340%chris.w.dennis@gmail.com>

The issue about getId() not being final has been thrown about forever ? it's
not going to be fixed because it would cause too much breakage in user code.
Seems strange to me though given that we know the non finality of getId
allows users to do this, we aren't avoiding relying on that method ? why
don't we have some other way for library code (JDK or third-party) to get
access to a unique identifier for a thread?

On 6/25/13 1:24 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com> wrote:

    
 
The JavaDoc for Thread.getId() says "...thread ID is unique..." so I don't
think this is a bug in RRWL.  Maybe Thread.getId() should be declared final.
 
 We might want to consider going as far as declaring the member field "tid"
as final.  This could be done via "private long tid = nextThreadID();"
 
 I find it very interesting that threadInitNumber and threadSeqNumber are
both used in the Thread class.  It seems we only need 1.  It seems that the
constructor should use "Thread-" + tid for a thread name.  In fact, the name
could read "Thread-10" and the tid could be 7 because there is a race
between when the name is generated and the tid is set.  The mismatch
probably doesn't matter functionally.  However, it could make it easier for
debugging.
 
 
Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>  | Architect
| 602.333.9091
 Oracle PSR Engineering <http://psr.us.oracle.com/>  | Server Technology
 
 On 6/25/2013 9:50 AM, Chris Dennis wrote:
 
 
>  
> Hi All,
> 
> While dealing with a customer issue, I ran in to the possibility of
> breaking a RRWL by feeding in Thread instances with colliding thread-ids.
> Inside RRWL the cachedHoldCounter logic assumes that getId() will return a
> unique identifier for a thread.  Do people consider this a bug in RRWL or
> not? (I think it would be agreed that this is also a bug in the
> subclassing of Thread)
> 
> Regards,
> 
> Chris Dennis
> 
> public static void main(String[] args) {
>   final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
>   final CyclicBarrier barrier = new CyclicBarrier(2);
>     
>   Thread t1 = new EvilThread() {
>     public void run() {
>       try {
>         lock.readLock().lock();
>         barrier.await();
>         //T2 locks
>         barrier.await();
>         //T3 locks
>         //T3 unlocks
>         barrier.await();
>         //T2 unlocks
>         barrier.await();
>         lock.readLock().unlock();
>       } catch (Exception e) {
>         e.printStackTrace();
>       }
>     }
>       
>   };
>   Thread t2 = new EvilThread() {
>     public void run() {
>       try {
>         //T1 locks
>                   barrier.await();
>                   lock.readLock().lock();
>                   barrier.await();
>                   //T3 locks
>                   //T3 unlocks
>                   barrier.await();
>                   lock.readLock().unlock();
>                   barrier.await();
>                   //T1 unlocks
>       } catch (Exception e) {
>         e.printStackTrace();
>       }
>     }
>       
>   };
>   Thread t3 = new EvilThread() {
>     public void run() {
>       try {
>         //T1 locks
>         barrier.await();
>                   //T2 locks
>                   barrier.await();
>                   lock.readLock().lock();
>                   lock.readLock().unlock();
>                   barrier.await();
>                   //T2 unlocks
>                   barrier.await();
>                   //T3 unlocks
>       } catch (Exception e) {
>         e.printStackTrace();
>       }
>     }
>       
>   };
>     
>   t1.start();
>   t2.start();
>   t3.start();
>   }
> 
>   
>   static class EvilThread extends Thread {
>   public long getId() {
>     return 42L;
>   }
>   }
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concur
> rency-interest
>  
 
 
_______________________________________________ Concurrency-interest mailing
list Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/86c20585/attachment.html>

From nathan.reynolds at oracle.com  Tue Jun 25 14:02:31 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 25 Jun 2013 11:02:31 -0700
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <CDEF507C.2F340%chris.w.dennis@gmail.com>
References: <CDEF507C.2F340%chris.w.dennis@gmail.com>
Message-ID: <51C9DB37.10100@oracle.com>

Wow!  Final getId() would break user code?  Interesting.  Are there any 
examples?  I can dream up a few but I am curious what is out in the wild.

I guess we need another method in Thread which is declared final and 
returns the "tid" member variable value.  Maybe it could be called 
getFinalId(), getImmutableId(), getFirmId(), or getStableId().

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 6/25/2013 10:56 AM, Chris Dennis wrote:
> The issue about getId() not being final has been thrown about forever 
> ? it's not going to be fixed because it would cause too much breakage 
> in user code.  Seems strange to me though given that we know the non 
> finality of getId allows users to do this, we aren't avoiding relying 
> on that method ? why don't we have some other way for library code 
> (JDK or third-party) to get access to a unique identifier for a thread?
>
> On 6/25/13 1:24 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com 
> <mailto:nathan.reynolds at oracle.com>> wrote:
>
> The JavaDoc for Thread.getId() says "...thread ID is unique..." so I 
> don't think this is a bug in RRWL.  Maybe Thread.getId() should be 
> declared final.
>
> We might want to consider going as far as declaring the member field 
> "tid" as final.  This could be done via "private long tid = 
> nextThreadID();"
>
> I find it very interesting that threadInitNumber and threadSeqNumber 
> are both used in the Thread class.  It seems we only need 1.  It seems 
> that the constructor should use "Thread-" + tid for a thread name.  In 
> fact, the name could read "Thread-10" and the tid could be 7 because 
> there is a race between when the name is generated and the tid is 
> set.  The mismatch probably doesn't matter functionally.  However, it 
> could make it easier for debugging.
>
> Nathan Reynolds 
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
> Architect | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
> On 6/25/2013 9:50 AM, Chris Dennis wrote:
>> Hi All,
>>
>> While dealing with a customer issue, I ran in to the possibility of
>> breaking a RRWL by feeding in Thread instances with colliding thread-ids.
>> Inside RRWL the cachedHoldCounter logic assumes that getId() will return a
>> unique identifier for a thread.  Do people consider this a bug in RRWL or
>> not? (I think it would be agreed that this is also a bug in the
>> subclassing of Thread)
>>
>> Regards,
>>
>> Chris Dennis
>>
>> public static void main(String[] args) {
>>    final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
>>    final CyclicBarrier barrier = new CyclicBarrier(2);
>>      
>>    Thread t1 = new EvilThread() {
>>      public void run() {
>>        try {
>>          lock.readLock().lock();
>>          barrier.await();
>>          //T2 locks
>>          barrier.await();
>>          //T3 locks
>>          //T3 unlocks
>>          barrier.await();
>>          //T2 unlocks
>>          barrier.await();
>>          lock.readLock().unlock();
>>        } catch (Exception e) {
>>          e.printStackTrace();
>>        }
>>      }
>>        
>>    };
>>    Thread t2 = new EvilThread() {
>>      public void run() {
>>        try {
>>          //T1 locks
>>                    barrier.await();
>>                    lock.readLock().lock();
>>                    barrier.await();
>>                    //T3 locks
>>                    //T3 unlocks
>>                    barrier.await();
>>                    lock.readLock().unlock();
>>                    barrier.await();
>>                    //T1 unlocks
>>        } catch (Exception e) {
>>          e.printStackTrace();
>>        }
>>      }
>>        
>>    };
>>    Thread t3 = new EvilThread() {
>>      public void run() {
>>        try {
>>          //T1 locks
>>          barrier.await();
>>                    //T2 locks
>>                    barrier.await();
>>                    lock.readLock().lock();
>>                    lock.readLock().unlock();
>>                    barrier.await();
>>                    //T2 unlocks
>>                    barrier.await();
>>                    //T3 unlocks
>>        } catch (Exception e) {
>>          e.printStackTrace();
>>        }
>>      }
>>        
>>    };
>>      
>>    t1.start();
>>    t2.start();
>>    t3.start();
>>    }
>>
>>    
>>    static class EvilThread extends Thread {
>>    public long getId() {
>>      return 42L;
>>    }
>>    }
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________ Concurrency-interest 
> mailing list Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu> 
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/66d1ace6/attachment-0001.html>

From viktor.klang at gmail.com  Tue Jun 25 14:09:36 2013
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Tue, 25 Jun 2013 14:09:36 -0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <51C9DB37.10100@oracle.com>
References: <CDEF507C.2F340%chris.w.dennis@gmail.com>
	<51C9DB37.10100@oracle.com>
Message-ID: <CANPzfU-_AfH1WOqskC5x9bGstUHvkPeepGQkcN1A4xcE4kr1VQ@mail.gmail.com>

Yeah, deprecate getId and introduce new final method sounds like a plan.
On Jun 25, 2013 8:08 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com>
wrote:

>  Wow!  Final getId() would break user code?  Interesting.  Are there any
> examples?  I can dream up a few but I am curious what is out in the wild.
>
> I guess we need another method in Thread which is declared final and
> returns the "tid" member variable value.  Maybe it could be called
> getFinalId(), getImmutableId(), getFirmId(), or getStableId().
>
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Architect |
> 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>  On 6/25/2013 10:56 AM, Chris Dennis wrote:
>
> The issue about getId() not being final has been thrown about forever ?
> it's not going to be fixed because it would cause too much breakage in user
> code.  Seems strange to me though given that we know the non finality of
> getId allows users to do this, we aren't avoiding relying on that method ?
> why don't we have some other way for library code (JDK or third-party) to
> get access to a unique identifier for a thread?
>
>   On 6/25/13 1:24 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com>
> wrote:
>
>   The JavaDoc for Thread.getId() says "...thread ID is unique..." so I
> don't think this is a bug in RRWL.  Maybe Thread.getId() should be declared
> final.
>
> We might want to consider going as far as declaring the member field "tid"
> as final.  This could be done via "private long tid = nextThreadID();"
>
> I find it very interesting that threadInitNumber and threadSeqNumber are
> both used in the Thread class.  It seems we only need 1.  It seems that the
> constructor should use "Thread-" + tid for a thread name.  In fact, the
> name could read "Thread-10" and the tid could be 7 because there is a race
> between when the name is generated and the tid is set.  The mismatch
> probably doesn't matter functionally.  However, it could make it easier for
> debugging.
>
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Architect |
> 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>  On 6/25/2013 9:50 AM, Chris Dennis wrote:
>
> Hi All,
>
> While dealing with a customer issue, I ran in to the possibility of
> breaking a RRWL by feeding in Thread instances with colliding thread-ids.
> Inside RRWL the cachedHoldCounter logic assumes that getId() will return a
> unique identifier for a thread.  Do people consider this a bug in RRWL or
> not? (I think it would be agreed that this is also a bug in the
> subclassing of Thread)
>
> Regards,
>
> Chris Dennis
>
> public static void main(String[] args) {
>   final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
>   final CyclicBarrier barrier = new CyclicBarrier(2);
>
>   Thread t1 = new EvilThread() {
>     public void run() {
>       try {
>         lock.readLock().lock();
>         barrier.await();
>         //T2 locks
>         barrier.await();
>         //T3 locks
>         //T3 unlocks
>         barrier.await();
>         //T2 unlocks
>         barrier.await();
>         lock.readLock().unlock();
>       } catch (Exception e) {
>         e.printStackTrace();
>       }
>     }
>
>   };
>   Thread t2 = new EvilThread() {
>     public void run() {
>       try {
>         //T1 locks
>                   barrier.await();
>                   lock.readLock().lock();
>                   barrier.await();
>                   //T3 locks
>                   //T3 unlocks
>                   barrier.await();
>                   lock.readLock().unlock();
>                   barrier.await();
>                   //T1 unlocks
>       } catch (Exception e) {
>         e.printStackTrace();
>       }
>     }
>
>   };
>   Thread t3 = new EvilThread() {
>     public void run() {
>       try {
>         //T1 locks
>         barrier.await();
>                   //T2 locks
>                   barrier.await();
>                   lock.readLock().lock();
>                   lock.readLock().unlock();
>                   barrier.await();
>                   //T2 unlocks
>                   barrier.await();
>                   //T3 unlocks
>       } catch (Exception e) {
>         e.printStackTrace();
>       }
>     }
>
>   };
>
>   t1.start();
>   t2.start();
>   t3.start();
>   }
>
>
>   static class EvilThread extends Thread {
>   public long getId() {
>     return 42L;
>   }
>   }
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>  _______________________________________________ Concurrency-interest
> mailing list Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/354bc9e5/attachment.html>

From chris.w.dennis at gmail.com  Tue Jun 25 14:30:15 2013
From: chris.w.dennis at gmail.com (Chris Dennis)
Date: Tue, 25 Jun 2013 14:30:15 -0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
 implementations
In-Reply-To: <51C9DB37.10100@oracle.com>
Message-ID: <CDEF5927.2F36B%chris.w.dennis@gmail.com>

Yes, sadly people will insist on hanging themselves whenever we give them
enough rope.  I don't think I've actually seen someones code that did this,
but I have seen it's fallout:
http://forums.terracotta.org/forums/posts/list/0/2116.page

Something like getStableId() would seem like a good idea, although I
strongly suspect this debate has occurred within Sun/Oracle and there are
probably good technical reasons why it's not happened yet.  What I would
like to see as a minimum is someone adding some stronger wording to the
Javadoc for the method.

Chris

On 6/25/13 2:02 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com> wrote:

    
 Wow!  Final getId() would break user code?  Interesting.  Are there any
examples?  I can dream up a few but I am curious what is out in the wild.
 
 I guess we need another method in Thread which is declared final and
returns the "tid" member variable value.  Maybe it could be called
getFinalId(), getImmutableId(), getFirmId(), or getStableId().
 

 
Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>  | Architect
| 602.333.9091
 Oracle PSR Engineering <http://psr.us.oracle.com/>  | Server Technology
 
 On 6/25/2013 10:56 AM, Chris Dennis wrote:
 
 
>  
> The issue about getId() not being final has been thrown about forever ? it's
> not going to be fixed because it would cause too much breakage in user code.
> Seems strange to me though given that we know the non finality of getId allows
> users to do this, we aren't avoiding relying on that method ? why don't we
> have some other way for library code (JDK or third-party) to get access to a
> unique identifier for a thread?
>  
> 
>  
>   
>  
> On 6/25/13 1:24 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com> wrote:
>  
>  
> 
>  
>  
>   
>  
> The JavaDoc for Thread.getId() says "...thread ID is unique..." so I don't
> think this is a bug in RRWL.  Maybe Thread.getId() should be declared final.
>  
>  We might want to consider going as far as declaring the member field "tid" as
> final.  This could be done via "private long tid = nextThreadID();"
>  
>  I find it very interesting that threadInitNumber and threadSeqNumber are both
> used in the Thread class.  It seems we only need 1.  It seems that the
> constructor should use "Thread-" + tid for a thread name.  In fact, the name
> could read "Thread-10" and the tid could be 7 because there is a race between
> when the name is generated and the tid is set.  The mismatch probably doesn't
> matter functionally.  However, it could make it easier for debugging.
>  
>  
> Nathan  Reynolds 
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>  | Architect |
> 602.333.9091
>  Oracle PSR Engineering <http://psr.us.oracle.com/>  | Server Technology
>  
>  On 6/25/2013 9:50 AM, Chris Dennis wrote:
>  
>  
>>  
>> Hi All,
>> 
>> While dealing with a customer issue, I ran in to the possibility of
>> breaking a RRWL by feeding in Thread instances with colliding thread-ids.
>> Inside RRWL the cachedHoldCounter logic assumes that getId() will return a
>> unique identifier for a thread.  Do people consider this a bug in RRWL or
>> not? (I think it would be agreed that this is also a bug in the
>> subclassing of Thread)
>> 
>> Regards,
>> 
>> Chris Dennis
>> 
>> public static void main(String[] args) {
>>   final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
>>   final CyclicBarrier barrier = new CyclicBarrier(2);
>>     
>>   Thread t1 = new EvilThread() {
>>     public void run() {
>>       try {
>>         lock.readLock().lock();
>>         barrier.await();
>>         //T2 locks
>>         barrier.await();
>>         //T3 locks
>>         //T3 unlocks
>>         barrier.await();
>>         //T2 unlocks
>>         barrier.await();
>>         lock.readLock().unlock();
>>       } catch (Exception e) {
>>         e.printStackTrace();
>>       }
>>     }
>>       
>>   };
>>   Thread t2 = new EvilThread() {
>>     public void run() {
>>       try {
>>         //T1 locks
>>                   barrier.await();
>>                   lock.readLock().lock();
>>                   barrier.await();
>>                   //T3 locks
>>                   //T3 unlocks
>>                   barrier.await();
>>                   lock.readLock().unlock();
>>                   barrier.await();
>>                   //T1 unlocks
>>       } catch (Exception e) {
>>         e.printStackTrace();
>>       }
>>     }
>>       
>>   };
>>   Thread t3 = new EvilThread() {
>>     public void run() {
>>       try {
>>         //T1 locks
>>         barrier.await();
>>                   //T2 locks
>>                   barrier.await();
>>                   lock.readLock().lock();
>>                   lock.readLock().unlock();
>>                   barrier.await();
>>                   //T2 unlocks
>>                   barrier.await();
>>                   //T3 unlocks
>>       } catch (Exception e) {
>>         e.printStackTrace();
>>       }
>>     }
>>       
>>   };
>>     
>>   t1.start();
>>   t2.start();
>>   t3.start();
>>   }
>> 
>>   
>>   static class EvilThread extends Thread {
>>   public long getId() {
>>     return 42L;
>>   }
>>   }
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concu
>> rrency-interest
>>  
>  
>  
>  
>  _______________________________________________ Concurrency-interest mailing
> list Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
 
 


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/6b5ca73e/attachment-0001.html>

From nathan.reynolds at oracle.com  Tue Jun 25 14:33:08 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 25 Jun 2013 11:33:08 -0700
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <CDEF5927.2F36B%chris.w.dennis@gmail.com>
References: <CDEF5927.2F36B%chris.w.dennis@gmail.com>
Message-ID: <51C9E264.4080908@oracle.com>

I have filed bug https://jbs.oracle.com/bugs/browse/JDK-8017617 for this.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 6/25/2013 11:30 AM, Chris Dennis wrote:
> Yes, sadly people will insist on hanging themselves whenever we give 
> them enough rope.  I don't think I've actually seen someones code that 
> did this, but I have seen it's fallout: 
> http://forums.terracotta.org/forums/posts/list/0/2116.page
>
> Something like getStableId() would seem like a good idea, although I 
> strongly suspect this debate has occurred within Sun/Oracle and there 
> are probably good technical reasons why it's not happened yet.  What I 
> would like to see as a minimum is someone adding some stronger wording 
> to the Javadoc for the method.
>
> Chris
>
> On 6/25/13 2:02 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com 
> <mailto:nathan.reynolds at oracle.com>> wrote:
>
> Wow!  Final getId() would break user code?  Interesting.  Are there 
> any examples?  I can dream up a few but I am curious what is out in 
> the wild.
>
> I guess we need another method in Thread which is declared final and 
> returns the "tid" member variable value.  Maybe it could be called 
> getFinalId(), getImmutableId(), getFirmId(), or getStableId().
>
> Nathan Reynolds 
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
> Architect | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
> On 6/25/2013 10:56 AM, Chris Dennis wrote:
>> The issue about getId() not being final has been thrown about forever 
>> ? it's not going to be fixed because it would cause too much breakage 
>> in user code.  Seems strange to me though given that we know the non 
>> finality of getId allows users to do this, we aren't avoiding relying 
>> on that method ? why don't we have some other way for library code 
>> (JDK or third-party) to get access to a unique identifier for a thread?
>>
>> On 6/25/13 1:24 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com 
>> <mailto:nathan.reynolds at oracle.com>> wrote:
>>
>> The JavaDoc for Thread.getId() says "...thread ID is unique..." so I 
>> don't think this is a bug in RRWL.  Maybe Thread.getId() should be 
>> declared final.
>>
>> We might want to consider going as far as declaring the member field 
>> "tid" as final.  This could be done via "private long tid = 
>> nextThreadID();"
>>
>> I find it very interesting that threadInitNumber and threadSeqNumber 
>> are both used in the Thread class.  It seems we only need 1.  It 
>> seems that the constructor should use "Thread-" + tid for a thread 
>> name.  In fact, the name could read "Thread-10" and the tid could be 
>> 7 because there is a race between when the name is generated and the 
>> tid is set.  The mismatch probably doesn't matter functionally.  
>> However, it could make it easier for debugging.
>>
>> Nathan Reynolds 
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>> Architect | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>> On 6/25/2013 9:50 AM, Chris Dennis wrote:
>>> Hi All,
>>>
>>> While dealing with a customer issue, I ran in to the possibility of
>>> breaking a RRWL by feeding in Thread instances with colliding thread-ids.
>>> Inside RRWL the cachedHoldCounter logic assumes that getId() will return a
>>> unique identifier for a thread.  Do people consider this a bug in RRWL or
>>> not? (I think it would be agreed that this is also a bug in the
>>> subclassing of Thread)
>>>
>>> Regards,
>>>
>>> Chris Dennis
>>>
>>> public static void main(String[] args) {
>>>    final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
>>>    final CyclicBarrier barrier = new CyclicBarrier(2);
>>>      
>>>    Thread t1 = new EvilThread() {
>>>      public void run() {
>>>        try {
>>>          lock.readLock().lock();
>>>          barrier.await();
>>>          //T2 locks
>>>          barrier.await();
>>>          //T3 locks
>>>          //T3 unlocks
>>>          barrier.await();
>>>          //T2 unlocks
>>>          barrier.await();
>>>          lock.readLock().unlock();
>>>        } catch (Exception e) {
>>>          e.printStackTrace();
>>>        }
>>>      }
>>>        
>>>    };
>>>    Thread t2 = new EvilThread() {
>>>      public void run() {
>>>        try {
>>>          //T1 locks
>>>                    barrier.await();
>>>                    lock.readLock().lock();
>>>                    barrier.await();
>>>                    //T3 locks
>>>                    //T3 unlocks
>>>                    barrier.await();
>>>                    lock.readLock().unlock();
>>>                    barrier.await();
>>>                    //T1 unlocks
>>>        } catch (Exception e) {
>>>          e.printStackTrace();
>>>        }
>>>      }
>>>        
>>>    };
>>>    Thread t3 = new EvilThread() {
>>>      public void run() {
>>>        try {
>>>          //T1 locks
>>>          barrier.await();
>>>                    //T2 locks
>>>                    barrier.await();
>>>                    lock.readLock().lock();
>>>                    lock.readLock().unlock();
>>>                    barrier.await();
>>>                    //T2 unlocks
>>>                    barrier.await();
>>>                    //T3 unlocks
>>>        } catch (Exception e) {
>>>          e.printStackTrace();
>>>        }
>>>      }
>>>        
>>>    };
>>>      
>>>    t1.start();
>>>    t2.start();
>>>    t3.start();
>>>    }
>>>
>>>    
>>>    static class EvilThread extends Thread {
>>>    public long getId() {
>>>      return 42L;
>>>    }
>>>    }
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________ Concurrency-interest 
>> mailing list Concurrency-interest at cs.oswego.edu 
>> <mailto:Concurrency-interest at cs.oswego.edu> 
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest 
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/292ab5d1/attachment.html>

From stanimir at riflexo.com  Tue Jun 25 14:55:51 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Tue, 25 Jun 2013 21:55:51 +0300
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <51C9E264.4080908@oracle.com>
References: <CDEF5927.2F36B%chris.w.dennis@gmail.com>
	<51C9E264.4080908@oracle.com>
Message-ID: <CAEJX8oonnAvbBq2+GejwwTEQPYgNnuk4WJeor207NBy5LsVz9g@mail.gmail.com>

I thought that Thread.getId() breaking RWLock was a known issue. That was
one of the 1st observation I made years ago. The reliance on it was awkward
and done in a rush, the way to verify uniqueness is via == and weak
references, thread.id looked like a hash back then.

While getId() shall not be declared final it shall be a subject of the same
inspection as set/getClassLoaderContext.

I have personally overridden Thread.getId() to get around some library
restrictions about calling conventions. So it's way too late to be declared
final.

Stanimir

On Tue, Jun 25, 2013 at 9:33 PM, Nathan Reynolds <nathan.reynolds at oracle.com
> wrote:

>  I have filed bug https://jbs.oracle.com/bugs/browse/JDK-8017617 for this.
>
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Architect |
> 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>  On 6/25/2013 11:30 AM, Chris Dennis wrote:
>
> Yes, sadly people will insist on hanging themselves whenever we give them
> enough rope.  I don't think I've actually seen someones code that did this,
> but I have seen it's fallout:
> http://forums.terracotta.org/forums/posts/list/0/2116.page
>
>  Something like getStableId() would seem like a good idea, although I
> strongly suspect this debate has occurred within Sun/Oracle and there are
> probably good technical reasons why it's not happened yet.  What I would
> like to see as a minimum is someone adding some stronger wording to the
> Javadoc for the method.
>
>  Chris
>
>   On 6/25/13 2:02 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com>
> wrote:
>
>   Wow!  Final getId() would break user code?  Interesting.  Are there any
> examples?  I can dream up a few but I am curious what is out in the wild.
>
> I guess we need another method in Thread which is declared final and
> returns the "tid" member variable value.  Maybe it could be called
> getFinalId(), getImmutableId(), getFirmId(), or getStableId().
>
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Architect |
> 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>  On 6/25/2013 10:56 AM, Chris Dennis wrote:
>
> The issue about getId() not being final has been thrown about forever ?
> it's not going to be fixed because it would cause too much breakage in user
> code.  Seems strange to me though given that we know the non finality of
> getId allows users to do this, we aren't avoiding relying on that method ?
> why don't we have some other way for library code (JDK or third-party) to
> get access to a unique identifier for a thread?
>
>   On 6/25/13 1:24 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com>
> wrote:
>
>   The JavaDoc for Thread.getId() says "...thread ID is unique..." so I
> don't think this is a bug in RRWL.  Maybe Thread.getId() should be declared
> final.
>
> We might want to consider going as far as declaring the member field "tid"
> as final.  This could be done via "private long tid = nextThreadID();"
>
> I find it very interesting that threadInitNumber and threadSeqNumber are
> both used in the Thread class.  It seems we only need 1.  It seems that the
> constructor should use "Thread-" + tid for a thread name.  In fact, the
> name could read "Thread-10" and the tid could be 7 because there is a race
> between when the name is generated and the tid is set.  The mismatch
> probably doesn't matter functionally.  However, it could make it easier for
> debugging.
>
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Architect |
> 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>  On 6/25/2013 9:50 AM, Chris Dennis wrote:
>
> Hi All,
>
> While dealing with a customer issue, I ran in to the possibility of
> breaking a RRWL by feeding in Thread instances with colliding thread-ids.
> Inside RRWL the cachedHoldCounter logic assumes that getId() will return a
> unique identifier for a thread.  Do people consider this a bug in RRWL or
> not? (I think it would be agreed that this is also a bug in the
> subclassing of Thread)
>
> Regards,
>
> Chris Dennis
>
> public static void main(String[] args) {
>   final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
>   final CyclicBarrier barrier = new CyclicBarrier(2);
>
>   Thread t1 = new EvilThread() {
>     public void run() {
>       try {
>         lock.readLock().lock();
>         barrier.await();
>         //T2 locks
>         barrier.await();
>         //T3 locks
>         //T3 unlocks
>         barrier.await();
>         //T2 unlocks
>         barrier.await();
>         lock.readLock().unlock();
>       } catch (Exception e) {
>         e.printStackTrace();
>       }
>     }
>
>   };
>   Thread t2 = new EvilThread() {
>     public void run() {
>       try {
>         //T1 locks
>                   barrier.await();
>                   lock.readLock().lock();
>                   barrier.await();
>                   //T3 locks
>                   //T3 unlocks
>                   barrier.await();
>                   lock.readLock().unlock();
>                   barrier.await();
>                   //T1 unlocks
>       } catch (Exception e) {
>         e.printStackTrace();
>       }
>     }
>
>   };
>   Thread t3 = new EvilThread() {
>     public void run() {
>       try {
>         //T1 locks
>         barrier.await();
>                   //T2 locks
>                   barrier.await();
>                   lock.readLock().lock();
>                   lock.readLock().unlock();
>                   barrier.await();
>                   //T2 unlocks
>                   barrier.await();
>                   //T3 unlocks
>       } catch (Exception e) {
>         e.printStackTrace();
>       }
>     }
>
>   };
>
>   t1.start();
>   t2.start();
>   t3.start();
>   }
>
>
>   static class EvilThread extends Thread {
>   public long getId() {
>     return 42L;
>   }
>   }
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>  _______________________________________________ Concurrency-interest
> mailing list Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/76215b14/attachment-0001.html>

From stanimir at riflexo.com  Tue Jun 25 15:02:31 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Tue, 25 Jun 2013 22:02:31 +0300
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <51C9E264.4080908@oracle.com>
References: <CDEF5927.2F36B%chris.w.dennis@gmail.com>
	<51C9E264.4080908@oracle.com>
Message-ID: <CAEJX8oqLLKFC453trVYfaz23Ey2TgszUR-UmrAV+jwr9sr=PQQ@mail.gmail.com>

Speaking of modifying Thread class:
Adding "public static Thread[] getAllThreads" would a welcome change. The
functionally is available already through getAllStackTraces().keySet() but
it has the added penalty of fetching the stack traces which is a
non-trivial penalty hit.

Stanimir

On Tue, Jun 25, 2013 at 9:33 PM, Nathan Reynolds <nathan.reynolds at oracle.com
> wrote:

>  I have filed bug https://jbs.oracle.com/bugs/browse/JDK-8017617 for this.
>
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Architect |
> 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>  On 6/25/2013 11:30 AM, Chris Dennis wrote:
>
> Yes, sadly people will insist on hanging themselves whenever we give them
> enough rope.  I don't think I've actually seen someones code that did this,
> but I have seen it's fallout:
> http://forums.terracotta.org/forums/posts/list/0/2116.page
>
>  Something like getStableId() would seem like a good idea, although I
> strongly suspect this debate has occurred within Sun/Oracle and there are
> probably good technical reasons why it's not happened yet.  What I would
> like to see as a minimum is someone adding some stronger wording to the
> Javadoc for the method.
>
>  Chris
>
>   On 6/25/13 2:02 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com>
> wrote:
>
>   Wow!  Final getId() would break user code?  Interesting.  Are there any
> examples?  I can dream up a few but I am curious what is out in the wild.
>
> I guess we need another method in Thread which is declared final and
> returns the "tid" member variable value.  Maybe it could be called
> getFinalId(), getImmutableId(), getFirmId(), or getStableId().
>
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Architect |
> 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>  On 6/25/2013 10:56 AM, Chris Dennis wrote:
>
> The issue about getId() not being final has been thrown about forever ?
> it's not going to be fixed because it would cause too much breakage in user
> code.  Seems strange to me though given that we know the non finality of
> getId allows users to do this, we aren't avoiding relying on that method ?
> why don't we have some other way for library code (JDK or third-party) to
> get access to a unique identifier for a thread?
>
>   On 6/25/13 1:24 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com>
> wrote:
>
>   The JavaDoc for Thread.getId() says "...thread ID is unique..." so I
> don't think this is a bug in RRWL.  Maybe Thread.getId() should be declared
> final.
>
> We might want to consider going as far as declaring the member field "tid"
> as final.  This could be done via "private long tid = nextThreadID();"
>
> I find it very interesting that threadInitNumber and threadSeqNumber are
> both used in the Thread class.  It seems we only need 1.  It seems that the
> constructor should use "Thread-" + tid for a thread name.  In fact, the
> name could read "Thread-10" and the tid could be 7 because there is a race
> between when the name is generated and the tid is set.  The mismatch
> probably doesn't matter functionally.  However, it could make it easier for
> debugging.
>
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Architect |
> 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>  On 6/25/2013 9:50 AM, Chris Dennis wrote:
>
> Hi All,
>
> While dealing with a customer issue, I ran in to the possibility of
> breaking a RRWL by feeding in Thread instances with colliding thread-ids.
> Inside RRWL the cachedHoldCounter logic assumes that getId() will return a
> unique identifier for a thread.  Do people consider this a bug in RRWL or
> not? (I think it would be agreed that this is also a bug in the
> subclassing of Thread)
>
> Regards,
>
> Chris Dennis
>
> public static void main(String[] args) {
>   final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
>   final CyclicBarrier barrier = new CyclicBarrier(2);
>
>   Thread t1 = new EvilThread() {
>     public void run() {
>       try {
>         lock.readLock().lock();
>         barrier.await();
>         //T2 locks
>         barrier.await();
>         //T3 locks
>         //T3 unlocks
>         barrier.await();
>         //T2 unlocks
>         barrier.await();
>         lock.readLock().unlock();
>       } catch (Exception e) {
>         e.printStackTrace();
>       }
>     }
>
>   };
>   Thread t2 = new EvilThread() {
>     public void run() {
>       try {
>         //T1 locks
>                   barrier.await();
>                   lock.readLock().lock();
>                   barrier.await();
>                   //T3 locks
>                   //T3 unlocks
>                   barrier.await();
>                   lock.readLock().unlock();
>                   barrier.await();
>                   //T1 unlocks
>       } catch (Exception e) {
>         e.printStackTrace();
>       }
>     }
>
>   };
>   Thread t3 = new EvilThread() {
>     public void run() {
>       try {
>         //T1 locks
>         barrier.await();
>                   //T2 locks
>                   barrier.await();
>                   lock.readLock().lock();
>                   lock.readLock().unlock();
>                   barrier.await();
>                   //T2 unlocks
>                   barrier.await();
>                   //T3 unlocks
>       } catch (Exception e) {
>         e.printStackTrace();
>       }
>     }
>
>   };
>
>   t1.start();
>   t2.start();
>   t3.start();
>   }
>
>
>   static class EvilThread extends Thread {
>   public long getId() {
>     return 42L;
>   }
>   }
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>  _______________________________________________ Concurrency-interest
> mailing list Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/12e40191/attachment.html>

From william.louth at jinspired.com  Tue Jun 25 15:03:50 2013
From: william.louth at jinspired.com (william.louth at jinspired.com)
Date: Tue, 25 Jun 2013 19:03:50 +0000
Subject: [concurrency-interest] RRWL with 'bad'
	Thread.getId()	implementations
Message-ID: <W856664662289971372187030@atl4webmail29>

I believe the (old) OC4J container did in fact override this method in Thread subclasses it used for request processing and returned a different int value. Many of us had to work around this by accessing the field itself through reflection.

I will give you one example in which one might consider overriding this value: a simulated playback of a metered software execution recording. Here having the threads ID match across process runs (and playbacks) would be extremely useful in comparing the playback with other less useful data collection approaches such as logging.

We eventually discounted this approach when we started thinking about near real-time playback of multiple JVM's within a single JVM which is exactly what Simz (http://www.jinspired.com/products/simz) offers today. Instead opting for a standardized thread specific Environment interface (across offline/online playbacks) in which we could lookup the id as well as the server id.

http://www.jinspired.com/site/plugin-to-the-matrix-for-virtual-machines-simulated-threads-stacks

>-----Original Message-----
>From: Nathan Reynolds [mailto:nathan.reynolds at oracle.com]
>Sent: Tuesday, June 25, 2013 08:02 PM
>To: 'Chris Dennis'
>Cc: concurrency-interest at cs.oswego.edu
>Subject: Re: [concurrency-interest] RRWL with 'bad' Thread.getId()	implementations
>
>Wow!  Final getId() would break user code?  Interesting.  Are there any 
>examples?  I can dream up a few but I am curious what is out in the wild.
>
>I guess we need another method in Thread which is declared final and 
>returns the "tid" member variable value.  Maybe it could be called 
>getFinalId(), getImmutableId(), getFirmId(), or getStableId().
>
>Nathan Reynolds 
><http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>Architect | 602.333.9091
>Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>On 6/25/2013 10:56 AM, Chris Dennis wrote:
>> The issue about getId() not being final has been thrown about forever 
>> ? it's not going to be fixed because it would cause too much breakage 
>> in user code.  Seems strange to me though given that we know the non 
>> finality of getId allows users to do this, we aren't avoiding relying 
>> on that method ? why don't we have some other way for library code 
>> (JDK or third-party) to get access to a unique identifier for a thread?
>>
>> On 6/25/13 1:24 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com 
>> <mailto:nathan.reynolds at oracle.com>> wrote:
>>
>> The JavaDoc for Thread.getId() says "...thread ID is unique..." so I 
>> don't think this is a bug in RRWL.  Maybe Thread.getId() should be 
>> declared final.
>>
>> We might want to consider going as far as declaring the member field 
>> "tid" as final.  This could be done via "private long tid = 
>> nextThreadID();"
>>
>> I find it very interesting that threadInitNumber and threadSeqNumber 
>> are both used in the Thread class.  It seems we only need 1.  It seems 
>> that the constructor should use "Thread-" + tid for a thread name.  In 
>> fact, the name could read "Thread-10" and the tid could be 7 because 
>> there is a race between when the name is generated and the tid is 
>> set.  The mismatch probably doesn't matter functionally.  However, it 
>> could make it easier for debugging.
>>
>> Nathan Reynolds 
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>> Architect | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>> On 6/25/2013 9:50 AM, Chris Dennis wrote:
>>> Hi All,
>>>
>>> While dealing with a customer issue, I ran in to the possibility of
>>> breaking a RRWL by feeding in Thread instances with colliding thread-ids.
>>> Inside RRWL the cachedHoldCounter logic assumes that getId() will return a
>>> unique identifier for a thread.  Do people consider this a bug in RRWL or
>>> not? (I think it would be agreed that this is also a bug in the
>>> subclassing of Thread)
>>>
>>> Regards,
>>>
>>> Chris Dennis
>>>
>>> public static void main(String[] args) {
>>>    final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
>>>    final CyclicBarrier barrier = new CyclicBarrier(2);
>>>      
>>>    Thread t1 = new EvilThread() {
>>>      public void run() {
>>>        try {
>>>          lock.readLock().lock();
>>>          barrier.await();
>>>          //T2 locks
>>>          barrier.await();
>>>          //T3 locks
>>>          //T3 unlocks
>>>          barrier.await();
>>>          //T2 unlocks
>>>          barrier.await();
>>>          lock.readLock().unlock();
>>>        } catch (Exception e) {
>>>          e.printStackTrace();
>>>        }
>>>      }
>>>        
>>>    };
>>>    Thread t2 = new EvilThread() {
>>>      public void run() {
>>>        try {
>>>          //T1 locks
>>>                    barrier.await();
>>>                    lock.readLock().lock();
>>>                    barrier.await();
>>>                    //T3 locks
>>>                    //T3 unlocks
>>>                    barrier.await();
>>>                    lock.readLock().unlock();
>>>                    barrier.await();
>>>                    //T1 unlocks
>>>        } catch (Exception e) {
>>>          e.printStackTrace();
>>>        }
>>>      }
>>>        
>>>    };
>>>    Thread t3 = new EvilThread() {
>>>      public void run() {
>>>        try {
>>>          //T1 locks
>>>          barrier.await();
>>>                    //T2 locks
>>>                    barrier.await();
>>>                    lock.readLock().lock();
>>>                    lock.readLock().unlock();
>>>                    barrier.await();
>>>                    //T2 unlocks
>>>                    barrier.await();
>>>                    //T3 unlocks
>>>        } catch (Exception e) {
>>>          e.printStackTrace();
>>>        }
>>>      }
>>>        
>>>    };
>>>      
>>>    t1.start();
>>>    t2.start();
>>>    t3.start();
>>>    }
>>>
>>>    
>>>    static class EvilThread extends Thread {
>>>    public long getId() {
>>>      return 42L;
>>>    }
>>>    }
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________ Concurrency-interest 
>> mailing list Concurrency-interest at cs.oswego.edu 
>> <mailto:Concurrency-interest at cs.oswego.edu> 
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest 
>
>




From chris.hegarty at oracle.com  Tue Jun 25 15:19:19 2013
From: chris.hegarty at oracle.com (Chris Hegarty)
Date: Tue, 25 Jun 2013 20:19:19 +0100
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <51C9E264.4080908@oracle.com>
References: <CDEF5927.2F36B%chris.w.dennis@gmail.com>
	<51C9E264.4080908@oracle.com>
Message-ID: <51C9ED37.70800@oracle.com>

On 06/25/2013 07:33 PM, Nathan Reynolds wrote:
> I have filed bug https://jbs.oracle.com/bugs/browse/JDK-8017617 for this.

The public bug for this will available, soon, at:
   http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=8017617

If there is agreement that getId() is fundamentally flawed and cannot be 
depended upon, even for internal JDK implementation, then I see this as 
pretty good justification to add a new final method to return the 
stable/final Id.

I can float this on the OpenJDK mailing lists and see if there are any 
objections.

-Chris.

>
> Nathan Reynolds
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> Architect | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
> On 6/25/2013 11:30 AM, Chris Dennis wrote:
>> Yes, sadly people will insist on hanging themselves whenever we give
>> them enough rope.  I don't think I've actually seen someones code that
>> did this, but I have seen it's fallout:
>> http://forums.terracotta.org/forums/posts/list/0/2116.page
>>
>> Something like getStableId() would seem like a good idea, although I
>> strongly suspect this debate has occurred within Sun/Oracle and there
>> are probably good technical reasons why it's not happened yet.  What I
>> would like to see as a minimum is someone adding some stronger wording
>> to the Javadoc for the method.
>>
>> Chris
>>
>> On 6/25/13 2:02 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com
>> <mailto:nathan.reynolds at oracle.com>> wrote:
>>
>> Wow!  Final getId() would break user code?  Interesting.  Are there
>> any examples?  I can dream up a few but I am curious what is out in
>> the wild.
>>
>> I guess we need another method in Thread which is declared final and
>> returns the "tid" member variable value.  Maybe it could be called
>> getFinalId(), getImmutableId(), getFirmId(), or getStableId().
>>
>> Nathan Reynolds
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>> Architect | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>> On 6/25/2013 10:56 AM, Chris Dennis wrote:
>>> The issue about getId() not being final has been thrown about forever
>>> ? it's not going to be fixed because it would cause too much breakage
>>> in user code.  Seems strange to me though given that we know the non
>>> finality of getId allows users to do this, we aren't avoiding relying
>>> on that method ? why don't we have some other way for library code
>>> (JDK or third-party) to get access to a unique identifier for a thread?
>>>
>>> On 6/25/13 1:24 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com
>>> <mailto:nathan.reynolds at oracle.com>> wrote:
>>>
>>> The JavaDoc for Thread.getId() says "...thread ID is unique..." so I
>>> don't think this is a bug in RRWL.  Maybe Thread.getId() should be
>>> declared final.
>>>
>>> We might want to consider going as far as declaring the member field
>>> "tid" as final.  This could be done via "private long tid =
>>> nextThreadID();"
>>>
>>> I find it very interesting that threadInitNumber and threadSeqNumber
>>> are both used in the Thread class.  It seems we only need 1.  It
>>> seems that the constructor should use "Thread-" + tid for a thread
>>> name.  In fact, the name could read "Thread-10" and the tid could be
>>> 7 because there is a race between when the name is generated and the
>>> tid is set.  The mismatch probably doesn't matter functionally.
>>> However, it could make it easier for debugging.
>>>
>>> Nathan Reynolds
>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>> Architect | 602.333.9091
>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>> On 6/25/2013 9:50 AM, Chris Dennis wrote:
>>>> Hi All,
>>>>
>>>> While dealing with a customer issue, I ran in to the possibility of
>>>> breaking a RRWL by feeding in Thread instances with colliding thread-ids.
>>>> Inside RRWL the cachedHoldCounter logic assumes that getId() will return a
>>>> unique identifier for a thread.  Do people consider this a bug in RRWL or
>>>> not? (I think it would be agreed that this is also a bug in the
>>>> subclassing of Thread)
>>>>
>>>> Regards,
>>>>
>>>> Chris Dennis
>>>>
>>>> public static void main(String[] args) {
>>>>    final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
>>>>    final CyclicBarrier barrier = new CyclicBarrier(2);
>>>>
>>>>    Thread t1 = new EvilThread() {
>>>>      public void run() {
>>>>        try {
>>>>          lock.readLock().lock();
>>>>          barrier.await();
>>>>          //T2 locks
>>>>          barrier.await();
>>>>          //T3 locks
>>>>          //T3 unlocks
>>>>          barrier.await();
>>>>          //T2 unlocks
>>>>          barrier.await();
>>>>          lock.readLock().unlock();
>>>>        } catch (Exception e) {
>>>>          e.printStackTrace();
>>>>        }
>>>>      }
>>>>
>>>>    };
>>>>    Thread t2 = new EvilThread() {
>>>>      public void run() {
>>>>        try {
>>>>          //T1 locks
>>>>                    barrier.await();
>>>>                    lock.readLock().lock();
>>>>                    barrier.await();
>>>>                    //T3 locks
>>>>                    //T3 unlocks
>>>>                    barrier.await();
>>>>                    lock.readLock().unlock();
>>>>                    barrier.await();
>>>>                    //T1 unlocks
>>>>        } catch (Exception e) {
>>>>          e.printStackTrace();
>>>>        }
>>>>      }
>>>>
>>>>    };
>>>>    Thread t3 = new EvilThread() {
>>>>      public void run() {
>>>>        try {
>>>>          //T1 locks
>>>>          barrier.await();
>>>>                    //T2 locks
>>>>                    barrier.await();
>>>>                    lock.readLock().lock();
>>>>                    lock.readLock().unlock();
>>>>                    barrier.await();
>>>>                    //T2 unlocks
>>>>                    barrier.await();
>>>>                    //T3 unlocks
>>>>        } catch (Exception e) {
>>>>          e.printStackTrace();
>>>>        }
>>>>      }
>>>>
>>>>    };
>>>>
>>>>    t1.start();
>>>>    t2.start();
>>>>    t3.start();
>>>>    }
>>>>
>>>>
>>>>    static class EvilThread extends Thread {
>>>>    public long getId() {
>>>>      return 42L;
>>>>    }
>>>>    }
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>> _______________________________________________ Concurrency-interest
>>> mailing list Concurrency-interest at cs.oswego.edu
>>> <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From aleksey.shipilev at oracle.com  Tue Jun 25 15:24:04 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Tue, 25 Jun 2013 23:24:04 +0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <51C9D235.9040106@oracle.com>
References: <CDEF4299.2F31E%chris.w.dennis@gmail.com>
	<51C9D235.9040106@oracle.com>
Message-ID: <51C9EE54.6030700@oracle.com>

On 06/25/2013 09:24 PM, Nathan Reynolds wrote:
> The JavaDoc for Thread.getId() says "...thread ID is unique..." so I
> don't think this is a bug in RRWL.  

+1. Intentionally breaking the Thread contract does seem bad.

> I find it very interesting that threadInitNumber and threadSeqNumber are
> both used in the Thread class.  It seems we only need 1.  It seems that
> the constructor should use "Thread-" + tid for a thread name.  In fact,
> the name could read "Thread-10" and the tid could be 7 because there is
> a race between when the name is generated and the tid is set.  The
> mismatch probably doesn't matter functionally.  However, it could make
> it easier for debugging.

In addition, we could finally eliminate those synchronized{} in JDK 8.
(Since Thread is the primordial class, you can't easily use atomics
there, but now as we have Unsafe.getAndAdd*... ;)

This looks like a good and simple task for a newcomer to OpenJDK. If
anyone from the community is interested in prototyping the patch,
testing it, and pushing through OpenJDK, but does not know where to
start, PM me ;)

-Aleksey.

From chris.w.dennis at gmail.com  Tue Jun 25 15:54:25 2013
From: chris.w.dennis at gmail.com (Chris Dennis)
Date: Tue, 25 Jun 2013 15:54:25 -0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
 implementations
In-Reply-To: <51C9EE54.6030700@oracle.com>
Message-ID: <CDEF6D23.2F3B4%chris.w.dennis@gmail.com>

In a similar vein, the following code doesn't behave like you'd expect
either (although it's arguable as to whether this is a reasonable way for
RRWL to behave in this circumstance).  Note here that this is totally
legal per the getId() contract, because the id doesn't get recycled until
after the join returns.

Chris

  public static void main(String[] args) throws InterruptedException {
    final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    final CyclicBarrier barrier = new CyclicBarrier(2);
    
    Thread t1 = new LegalThread(1) {

      @Override
      public void run() {
        try {
          lock.readLock().lock();
          barrier.await();
          //T2a locks
          //T2b unlocks
          barrier.await();
          lock.readLock().unlock();
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
    };
    Thread t2a = new LegalThread(2) {

      @Override
      public void run() {
        try {
          //T1 locks
          barrier.await();
          lock.readLock().lock();
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
      
    };
    
    t1.start();
    t2a.start();
    t2a.join();
    
    Thread t2b = new LegalThread(2) {

      @Override
      public void run() {
        try {
          lock.readLock().unlock();
          barrier.await();
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
      
    };
    t2b.start();
  }
  
  static class LegalThread extends Thread {

    private final int id;
    
    public LegalThread(int id) {
      this.id = id;
    }
    
    @Override
    public long getId() {
      return id;
    }
  }



On 6/25/13 3:24 PM, "Aleksey Shipilev" <aleksey.shipilev at oracle.com> wrote:

>On 06/25/2013 09:24 PM, Nathan Reynolds wrote:
>> The JavaDoc for Thread.getId() says "...thread ID is unique..." so I
>> don't think this is a bug in RRWL.
>
>+1. Intentionally breaking the Thread contract does seem bad.
>
>> I find it very interesting that threadInitNumber and threadSeqNumber are
>> both used in the Thread class.  It seems we only need 1.  It seems that
>> the constructor should use "Thread-" + tid for a thread name.  In fact,
>> the name could read "Thread-10" and the tid could be 7 because there is
>> a race between when the name is generated and the tid is set.  The
>> mismatch probably doesn't matter functionally.  However, it could make
>> it easier for debugging.
>
>In addition, we could finally eliminate those synchronized{} in JDK 8.
>(Since Thread is the primordial class, you can't easily use atomics
>there, but now as we have Unsafe.getAndAdd*... ;)
>
>This looks like a good and simple task for a newcomer to OpenJDK. If
>anyone from the community is interested in prototyping the patch,
>testing it, and pushing through OpenJDK, but does not know where to
>start, PM me ;)
>
>-Aleksey.
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest at cs.oswego.edu
>http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From aleksey.shipilev at oracle.com  Tue Jun 25 16:09:36 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 26 Jun 2013 00:09:36 +0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <CDEF6D23.2F3B4%chris.w.dennis@gmail.com>
References: <CDEF6D23.2F3B4%chris.w.dennis@gmail.com>
Message-ID: <51C9F900.9070106@oracle.com>

On 06/25/2013 11:54 PM, Chris Dennis wrote:
> In a similar vein, the following code doesn't behave like you'd expect
> either (although it's arguable as to whether this is a reasonable way for
> RRWL to behave in this circumstance).  Note here that this is totally
> legal per the getId() contract, because the id doesn't get recycled until
> after the join returns.

Now that's a good example!

This highlights the potential problem in RRWL. The code should instead
throw the IllegalMonitorStateException in t2b.run(). I wonder what harm
is done if we disregard the comment there and store the reference to
Thread instead.

        /**
         * A counter for per-thread read hold counts.
         * Maintained as a ThreadLocal; cached in cachedHoldCounter
         */
        static final class HoldCounter {
            int count = 0;
            // Use id, not reference, to avoid garbage retention
            final long tid = Thread.currentThread().getId();
        }

        static final class ThreadLocalHoldCounter
            extends ThreadLocal<HoldCounter> {
            public HoldCounter initialValue() {
                return new HoldCounter();
            }
        }

I don't see the problem off-hand: if thread dies, so do the associated
ThreadLocalMap-s. RRWL does not reference the live
ThreadLocalHoldCounter when nobody is holding the read lock... What else
is missing?

-Aleksey.

From chris.w.dennis at gmail.com  Tue Jun 25 16:27:54 2013
From: chris.w.dennis at gmail.com (Chris Dennis)
Date: Tue, 25 Jun 2013 16:27:54 -0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
 implementations
In-Reply-To: <51C9F900.9070106@oracle.com>
Message-ID: <CDEF737F.2F3C6%chris.w.dennis@gmail.com>

(Sorry for mixing top and bottom posting - hope nobody is offended!)

You'll need to blank the cachedHoldCounter when a thread releases it's
last hold as well, right?  Otherwise we still leak a reference to the last
reader to take this lock, even if that thread has unlocked fully.

On 6/25/13 4:09 PM, "Aleksey Shipilev" <aleksey.shipilev at oracle.com> wrote:

>On 06/25/2013 11:54 PM, Chris Dennis wrote:
>> In a similar vein, the following code doesn't behave like you'd expect
>> either (although it's arguable as to whether this is a reasonable way
>>for
>> RRWL to behave in this circumstance).  Note here that this is totally
>> legal per the getId() contract, because the id doesn't get recycled
>>until
>> after the join returns.
>
>Now that's a good example!
>
>This highlights the potential problem in RRWL. The code should instead
>throw the IllegalMonitorStateException in t2b.run(). I wonder what harm
>is done if we disregard the comment there and store the reference to
>Thread instead.
>
>        /**
>         * A counter for per-thread read hold counts.
>         * Maintained as a ThreadLocal; cached in cachedHoldCounter
>         */
>        static final class HoldCounter {
>            int count = 0;
>            // Use id, not reference, to avoid garbage retention
>            final long tid = Thread.currentThread().getId();
>        }
>
>        static final class ThreadLocalHoldCounter
>            extends ThreadLocal<HoldCounter> {
>            public HoldCounter initialValue() {
>                return new HoldCounter();
>            }
>        }
>
>I don't see the problem off-hand: if thread dies, so do the associated
>ThreadLocalMap-s. RRWL does not reference the live
>ThreadLocalHoldCounter when nobody is holding the read lock... What else
>is missing?
>
>-Aleksey.



From aleksey.shipilev at oracle.com  Tue Jun 25 16:37:20 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 26 Jun 2013 00:37:20 +0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <CDEF737F.2F3C6%chris.w.dennis@gmail.com>
References: <CDEF737F.2F3C6%chris.w.dennis@gmail.com>
Message-ID: <51C9FF80.8090709@oracle.com>

Right. In fact, it is specifically said:

        /**
         * [snip]
         *
         * <p>Can outlive the Thread for which it is caching the read
         * hold count, but avoids garbage retention by not retaining a
         * reference to the Thread.
         *
         * [snip]
         */
        private transient HoldCounter cachedHoldCounter;

Other ideas how to solve this?

-Aleksey.

On 06/26/2013 12:27 AM, Chris Dennis wrote:
> (Sorry for mixing top and bottom posting - hope nobody is offended!)
> 
> You'll need to blank the cachedHoldCounter when a thread releases it's
> last hold as well, right?  Otherwise we still leak a reference to the last
> reader to take this lock, even if that thread has unlocked fully.
> 
> On 6/25/13 4:09 PM, "Aleksey Shipilev" <aleksey.shipilev at oracle.com> wrote:
> 
>> On 06/25/2013 11:54 PM, Chris Dennis wrote:
>>> In a similar vein, the following code doesn't behave like you'd expect
>>> either (although it's arguable as to whether this is a reasonable way
>>> for
>>> RRWL to behave in this circumstance).  Note here that this is totally
>>> legal per the getId() contract, because the id doesn't get recycled
>>> until
>>> after the join returns.
>>
>> Now that's a good example!
>>
>> This highlights the potential problem in RRWL. The code should instead
>> throw the IllegalMonitorStateException in t2b.run(). I wonder what harm
>> is done if we disregard the comment there and store the reference to
>> Thread instead.
>>
>>        /**
>>         * A counter for per-thread read hold counts.
>>         * Maintained as a ThreadLocal; cached in cachedHoldCounter
>>         */
>>        static final class HoldCounter {
>>            int count = 0;
>>            // Use id, not reference, to avoid garbage retention
>>            final long tid = Thread.currentThread().getId();
>>        }
>>
>>        static final class ThreadLocalHoldCounter
>>            extends ThreadLocal<HoldCounter> {
>>            public HoldCounter initialValue() {
>>                return new HoldCounter();
>>            }
>>        }
>>
>> I don't see the problem off-hand: if thread dies, so do the associated
>> ThreadLocalMap-s. RRWL does not reference the live
>> ThreadLocalHoldCounter when nobody is holding the read lock... What else
>> is missing?
>>
>> -Aleksey.
> 
> 


From stanimir at riflexo.com  Tue Jun 25 16:55:39 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Tue, 25 Jun 2013 23:55:39 +0300
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <51C9FF80.8090709@oracle.com>
References: <CDEF737F.2F3C6%chris.w.dennis@gmail.com>
	<51C9FF80.8090709@oracle.com>
Message-ID: <CAEJX8oquvXT6dLWyWKjJjbonW8O_HFXLvw+0gibdtuWhOjAaZA@mail.gmail.com>

WeakReference obviously,
Like I've said: Thread.id is a cheap hack for == and weak reference.
Alternative incl. eetop field.

Stanimir

On Tue, Jun 25, 2013 at 11:37 PM, Aleksey Shipilev <
aleksey.shipilev at oracle.com> wrote:

> Right. In fact, it is specifically said:
>
>         /**
>          * [snip]
>          *
>          * <p>Can outlive the Thread for which it is caching the read
>          * hold count, but avoids garbage retention by not retaining a
>          * reference to the Thread.
>          *
>          * [snip]
>          */
>         private transient HoldCounter cachedHoldCounter;
>
> Other ideas how to solve this?
>
> -Aleksey.
>
> On 06/26/2013 12:27 AM, Chris Dennis wrote:
> > (Sorry for mixing top and bottom posting - hope nobody is offended!)
> >
> > You'll need to blank the cachedHoldCounter when a thread releases it's
> > last hold as well, right?  Otherwise we still leak a reference to the
> last
> > reader to take this lock, even if that thread has unlocked fully.
> >
> > On 6/25/13 4:09 PM, "Aleksey Shipilev" <aleksey.shipilev at oracle.com>
> wrote:
> >
> >> On 06/25/2013 11:54 PM, Chris Dennis wrote:
> >>> In a similar vein, the following code doesn't behave like you'd expect
> >>> either (although it's arguable as to whether this is a reasonable way
> >>> for
> >>> RRWL to behave in this circumstance).  Note here that this is totally
> >>> legal per the getId() contract, because the id doesn't get recycled
> >>> until
> >>> after the join returns.
> >>
> >> Now that's a good example!
> >>
> >> This highlights the potential problem in RRWL. The code should instead
> >> throw the IllegalMonitorStateException in t2b.run(). I wonder what harm
> >> is done if we disregard the comment there and store the reference to
> >> Thread instead.
> >>
> >>        /**
> >>         * A counter for per-thread read hold counts.
> >>         * Maintained as a ThreadLocal; cached in cachedHoldCounter
> >>         */
> >>        static final class HoldCounter {
> >>            int count = 0;
> >>            // Use id, not reference, to avoid garbage retention
> >>            final long tid = Thread.currentThread().getId();
> >>        }
> >>
> >>        static final class ThreadLocalHoldCounter
> >>            extends ThreadLocal<HoldCounter> {
> >>            public HoldCounter initialValue() {
> >>                return new HoldCounter();
> >>            }
> >>        }
> >>
> >> I don't see the problem off-hand: if thread dies, so do the associated
> >> ThreadLocalMap-s. RRWL does not reference the live
> >> ThreadLocalHoldCounter when nobody is holding the read lock... What else
> >> is missing?
> >>
> >> -Aleksey.
> >
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/3d3ad36a/attachment-0001.html>

From martinrb at google.com  Tue Jun 25 17:13:29 2013
From: martinrb at google.com (Martin Buchholz)
Date: Tue, 25 Jun 2013 14:13:29 -0700
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <CAEJX8oquvXT6dLWyWKjJjbonW8O_HFXLvw+0gibdtuWhOjAaZA@mail.gmail.com>
References: <CDEF737F.2F3C6%chris.w.dennis@gmail.com>
	<51C9FF80.8090709@oracle.com>
	<CAEJX8oquvXT6dLWyWKjJjbonW8O_HFXLvw+0gibdtuWhOjAaZA@mail.gmail.com>
Message-ID: <CA+kOe0_gE7Y49=YJ7msnrg4iQWTDoZUeMDqdFtNUGXPiRHT-aw@mail.gmail.com>

On Tue, Jun 25, 2013 at 1:55 PM, Stanimir Simeonoff <stanimir at riflexo.com>wrote:

> WeakReference obviously,
> Like I've said: Thread.id is a cheap hack for == and weak reference.
> Alternative incl. eetop field.
>
>
We the maintainers of RRWL dislike the use of both ThreadLocals and
WeakReferences and wish that RRWL could be implemented without either.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/4ff88a92/attachment.html>

From aleksey.shipilev at oracle.com  Tue Jun 25 17:16:34 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 26 Jun 2013 01:16:34 +0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <CA+kOe0_gE7Y49=YJ7msnrg4iQWTDoZUeMDqdFtNUGXPiRHT-aw@mail.gmail.com>
References: <CDEF737F.2F3C6%chris.w.dennis@gmail.com>
	<51C9FF80.8090709@oracle.com>
	<CAEJX8oquvXT6dLWyWKjJjbonW8O_HFXLvw+0gibdtuWhOjAaZA@mail.gmail.com>
	<CA+kOe0_gE7Y49=YJ7msnrg4iQWTDoZUeMDqdFtNUGXPiRHT-aw@mail.gmail.com>
Message-ID: <51CA08B2.9080606@oracle.com>

On 06/26/2013 01:13 AM, Martin Buchholz wrote:
> On Tue, Jun 25, 2013 at 1:55 PM, Stanimir Simeonoff
> <stanimir at riflexo.com <mailto:stanimir at riflexo.com>> wrote:
> 
>     WeakReference obviously,
>     Like I've said: Thread.id is a cheap hack for == and weak reference.
>     Alternative incl. eetop field.
> 
> 
> We the maintainers of RRWL dislike the use of both ThreadLocals and
> WeakReferences and wish that RRWL could be implemented without either. 

That's why you have "invented" StampedLock, all right!

On the serious note, we need to frame this discussion a bit. Do you want
the bug against RRWL with the testcase Chris had came up with? (That is,
do you agree this is the bug in RRWL?)

-Aleksey.

From martinrb at google.com  Tue Jun 25 17:20:13 2013
From: martinrb at google.com (Martin Buchholz)
Date: Tue, 25 Jun 2013 14:20:13 -0700
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <51CA08B2.9080606@oracle.com>
References: <CDEF737F.2F3C6%chris.w.dennis@gmail.com>
	<51C9FF80.8090709@oracle.com>
	<CAEJX8oquvXT6dLWyWKjJjbonW8O_HFXLvw+0gibdtuWhOjAaZA@mail.gmail.com>
	<CA+kOe0_gE7Y49=YJ7msnrg4iQWTDoZUeMDqdFtNUGXPiRHT-aw@mail.gmail.com>
	<51CA08B2.9080606@oracle.com>
Message-ID: <CA+kOe08+GjjTWz9gO8-rziMy7MCzd6vhrYxqDQ46tOc489a9MQ@mail.gmail.com>

On Tue, Jun 25, 2013 at 2:16 PM, Aleksey Shipilev <
aleksey.shipilev at oracle.com> wrote:

> On 06/26/2013 01:13 AM, Martin Buchholz wrote:
> On the serious note, we need to frame this discussion a bit. Do you want
> the bug against RRWL with the testcase Chris had came up with? (That is,
> do you agree this is the bug in RRWL?)
>

I think I agree this is a small bug in RRWL, but I suspect any attempt to
cure it would be worse than the disease.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/8a64dea6/attachment.html>

From aleksey.shipilev at oracle.com  Tue Jun 25 17:32:46 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 26 Jun 2013 01:32:46 +0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <CA+kOe08+GjjTWz9gO8-rziMy7MCzd6vhrYxqDQ46tOc489a9MQ@mail.gmail.com>
References: <CDEF737F.2F3C6%chris.w.dennis@gmail.com>
	<51C9FF80.8090709@oracle.com>
	<CAEJX8oquvXT6dLWyWKjJjbonW8O_HFXLvw+0gibdtuWhOjAaZA@mail.gmail.com>
	<CA+kOe0_gE7Y49=YJ7msnrg4iQWTDoZUeMDqdFtNUGXPiRHT-aw@mail.gmail.com>
	<51CA08B2.9080606@oracle.com>
	<CA+kOe08+GjjTWz9gO8-rziMy7MCzd6vhrYxqDQ46tOc489a9MQ@mail.gmail.com>
Message-ID: <51CA0C7E.9020605@oracle.com>

On 06/26/2013 01:20 AM, Martin Buchholz wrote:
> 
> 
> 
> On Tue, Jun 25, 2013 at 2:16 PM, Aleksey Shipilev
> <aleksey.shipilev at oracle.com <mailto:aleksey.shipilev at oracle.com>> wrote:
> 
>     On 06/26/2013 01:13 AM, Martin Buchholz wrote:
>     On the serious note, we need to frame this discussion a bit. Do you want
>     the bug against RRWL with the testcase Chris had came up with? (That is,
>     do you agree this is the bug in RRWL?)
> 
> 
> I think I agree this is a small bug in RRWL, but I suspect any attempt
> to cure it would be worse than the disease.

I think the same. Nevertheless, the issue is recorded as CR 8017739.
Will be publicly available soon as:
 http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=8017739

Thanks everyone!

-Aleksey.


From stanimir at riflexo.com  Tue Jun 25 18:24:23 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Wed, 26 Jun 2013 01:24:23 +0300
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <CA+kOe08+GjjTWz9gO8-rziMy7MCzd6vhrYxqDQ46tOc489a9MQ@mail.gmail.com>
References: <CDEF737F.2F3C6%chris.w.dennis@gmail.com>
	<51C9FF80.8090709@oracle.com>
	<CAEJX8oquvXT6dLWyWKjJjbonW8O_HFXLvw+0gibdtuWhOjAaZA@mail.gmail.com>
	<CA+kOe0_gE7Y49=YJ7msnrg4iQWTDoZUeMDqdFtNUGXPiRHT-aw@mail.gmail.com>
	<51CA08B2.9080606@oracle.com>
	<CA+kOe08+GjjTWz9gO8-rziMy7MCzd6vhrYxqDQ46tOc489a9MQ@mail.gmail.com>
Message-ID: <CAEJX8oq07B6fSzp74edXQipLxNtnZOrUgPHKJOCPGsktJ1rSgw@mail.gmail.com>

On Wed, Jun 26, 2013 at 12:20 AM, Martin Buchholz <martinrb at google.com>wrote:

>
>
>
> On Tue, Jun 25, 2013 at 2:16 PM, Aleksey Shipilev <
> aleksey.shipilev at oracle.com> wrote:
>
>> On 06/26/2013 01:13 AM, Martin Buchholz wrote:
>> On the serious note, we need to frame this discussion a bit. Do you want
>> the bug against RRWL with the testcase Chris had came up with? (That is,
>> do you agree this is the bug in RRWL?)
>>
>
> I think I agree this is a small bug in RRWL, but I suspect any attempt to
> cure it would be worse than the disease.
>

Still, you can use another (new) field, the field can be obtained/set
similar to "parkBlocker" in LockSupport.
No ThreadLocal, no Thread.getId()... just need to push the update in the
Thread class which might be more challenging.
Sometimes I think Thread should have a designated long[] accessible through
Java secrets and index obtainable the same way. Cheaper than ThreadLocals
and guaranteed no leaks, usable by core classes only.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/27478d47/attachment.html>

From chris.hegarty at oracle.com  Tue Jun 25 18:26:40 2013
From: chris.hegarty at oracle.com (Chris Hegarty)
Date: Tue, 25 Jun 2013 23:26:40 +0100
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <CA+kOe08+GjjTWz9gO8-rziMy7MCzd6vhrYxqDQ46tOc489a9MQ@mail.gmail.com>
References: <CDEF737F.2F3C6%chris.w.dennis@gmail.com>
	<51C9FF80.8090709@oracle.com>
	<CAEJX8oquvXT6dLWyWKjJjbonW8O_HFXLvw+0gibdtuWhOjAaZA@mail.gmail.com>
	<CA+kOe0_gE7Y49=YJ7msnrg4iQWTDoZUeMDqdFtNUGXPiRHT-aw@mail.gmail.com>
	<51CA08B2.9080606@oracle.com>
	<CA+kOe08+GjjTWz9gO8-rziMy7MCzd6vhrYxqDQ46tOc489a9MQ@mail.gmail.com>
Message-ID: <ED686545-2982-452E-BCF0-77DC400325D6@oracle.com>


On 25 Jun 2013, at 22:20, Martin Buchholz <martinrb at google.com> wrote:

> On Tue, Jun 25, 2013 at 2:16 PM, Aleksey Shipilev <aleksey.shipilev at oracle.com> wrote:
>> On 06/26/2013 01:13 AM, Martin Buchholz wrote:
>> On the serious note, we need to frame this discussion a bit. Do you want
>> the bug against RRWL with the testcase Chris had came up with? (That is,
>> do you agree this is the bug in RRWL?)
> 
> I think I agree this is a small bug in RRWL, but I suspect any attempt to cure it would be worse than the disease.

Even with the addition of Thread.getFinalId() in jdk8? It would seem like RRWL could be "fixed" for free!

-Chris


> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130625/43b78695/attachment.html>

From dl at cs.oswego.edu  Tue Jun 25 19:03:17 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 25 Jun 2013 19:03:17 -0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <CDEF4299.2F31E%chris.w.dennis@gmail.com>
References: <CDEF4299.2F31E%chris.w.dennis@gmail.com>
Message-ID: <51CA21B5.2010907@cs.oswego.edu>


Most people know that I consider acceding to requests
to support per-thread read counts in JDK6 RRWL to be the
worst decision I've ever made in j.u.c. But still not as
bad as someone's decision not to make Thread.getId() a final
method.

We can and probably should fix this immediately by grabbing
the Thread's "tid" field instead of calling getId. Additionally,
I like Chris's idea of adding a non-overridable method so
that others who face this issue can cope.

The alternative of using a weak ref is not a good option.
The reason we use id's to begin with is that if you store
a Thread ref in a ThreadLocal, even with a weak rewf wrapper,
there several common scenarios where it cannot be GCed.
(Some of you might recall discussions about Ephemerons
motivated by this issue. But these never arrived.)

On the form of the added method:
By analogy to Object.hashCode() (orverridable) vs
System.identityHashCode(Object) (not). maybe the
best place for this method is System.getThreadId(Thread)?

(And beyond all this, please start using StampedLock
instead or RRWL if you can. We designed it to be better
in every way, when it is applicable.)

-Doug




On 06/25/13 12:50, Chris Dennis wrote:
> Hi All,
>
> While dealing with a customer issue, I ran in to the possibility of
> breaking a RRWL by feeding in Thread instances with colliding thread-ids.
> Inside RRWL the cachedHoldCounter logic assumes that getId() will return a
> unique identifier for a thread.  Do people consider this a bug in RRWL or
> not? (I think it would be agreed that this is also a bug in the
> subclassing of Thread)
> /
...


From dl at cs.oswego.edu  Tue Jun 25 20:03:54 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 25 Jun 2013 20:03:54 -0400
Subject: [concurrency-interest] Performance regression in newest
 (6/20/2013) jsr166 update
In-Reply-To: <CABg6-qj0FxrUgA7atMdVVVuUGqVvzyvo7F+btpKsFjtaPG4LVA@mail.gmail.com>
References: <CABg6-qj0FxrUgA7atMdVVVuUGqVvzyvo7F+btpKsFjtaPG4LVA@mail.gmail.com>
Message-ID: <51CA2FEA.3070509@cs.oswego.edu>

On 06/22/13 20:42, Ron Pressler wrote:
> A couple of months ago I described the behavior detailed in the email exchange
> below. The newest update causes a slowdown of about 25% of this benchmark:
> ...


>      static ForkJoinPool fjPool = new ForkJoinPool(PARALLELISM,
> ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);

Yes, some handling for pools run in async mode (which is not common)
got a little worse in the course of improving vastly more common cases.
Most of this can be reinstated though, which on a quick check of
a quick touch-up recovers performance on your test case. Stay tuned.

-Doug


From dl at cs.oswego.edu  Wed Jun 26 06:43:54 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 26 Jun 2013 06:43:54 -0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <51CA21B5.2010907@cs.oswego.edu>
References: <CDEF4299.2F31E%chris.w.dennis@gmail.com>
	<51CA21B5.2010907@cs.oswego.edu>
Message-ID: <51CAC5EA.9080209@cs.oswego.edu>

On 06/25/13 19:03, Doug Lea wrote:
>

> We can and probably should fix this immediately by grabbing
> the Thread's "tid" field instead of calling getId.

I committed this change to jsr166 sources, so it should eventually
make its way into OpenJDK.


> On the form of the added method:
> By analogy to Object.hashCode() (orverridable) vs
> System.identityHashCode(Object) (not). maybe the
> best place for this method is System.getThreadId(Thread)?

Or less disruptively, it might as well be in class Thread, but
with spec wording adapted from System.identityHashCode:

     /**
      * Returns the identifier for the given Thread, as would
      * be returned by the default {@link #getId} method,
      * whether or not the thread's class overrides {@code getId()}.
      *
      * @param thread the thread
      * @return the id
      */
     public static final long getThreadId(Thread thread) {
         return thread.tid;
     }




From nitsanw at yahoo.com  Wed Jun 26 06:55:32 2013
From: nitsanw at yahoo.com (Nitsan Wakart)
Date: Wed, 26 Jun 2013 03:55:32 -0700 (PDT)
Subject: [concurrency-interest] Should CopyOnWriteArrayList implement
	RandomAccess?
Message-ID: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>

Hi,
Given the the javadoc for?RandomAccess suggests that:
"As a rule of thumb, a?List?implementation should implement this interface if,?for typical instances of the class, this loop:
for (int i=0, n=list.size(); i < n; i++)?list.get(i);

runs faster than this loop:
for (Iterator i=list.iterator(); i.hasNext(); )?i.next();"
But the above is not true for?CopyOnWriteArrayList where the iterator performs better as the volatile read of the array is avoided on each entry and where the first loop is incorrect in any case(can lead to index out of bounds).
Is that a bug or am I missing something here?
Thanks,
Nitsan


From stanimir at riflexo.com  Wed Jun 26 08:06:52 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Wed, 26 Jun 2013 15:06:52 +0300
Subject: [concurrency-interest] Should CopyOnWriteArrayList implement
	RandomAccess?
In-Reply-To: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>
References: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>
Message-ID: <CAEJX8orEUz78FSBm_xG71hFo+qC0m8RsRz3XDpDuE69FNG7G3A@mail.gmail.com>

I can't think of a practical use of loop and COWList.get. If you are to
concurrently modify and read a concurrent structure many algorithm won't
work - sorting, reverse, etc.
Even so the volatile read might not be slower than the iterator use, the
volatile read can be as cheap as L1 cache hit. Still the JIT cannot
aggressively optimized the access to the array.

Stanimir

On Wed, Jun 26, 2013 at 1:55 PM, Nitsan Wakart <nitsanw at yahoo.com> wrote:

> Hi,
> Given the the javadoc for RandomAccess suggests that:
> "As a rule of thumb, a List implementation should implement this interface
> if, for typical instances of the class, this loop:
> for (int i=0, n=list.size(); i < n; i++) list.get(i);
>
> runs faster than this loop:
> for (Iterator i=list.iterator(); i.hasNext(); ) i.next();"
> But the above is not true for CopyOnWriteArrayList where the iterator
> performs better as the volatile read of the array is avoided on each entry
> and where the first loop is incorrect in any case(can lead to index out of
> bounds).
> Is that a bug or am I missing something here?
> Thanks,
> Nitsan
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/b5e96ee3/attachment.html>

From valentin.male.kovalenko at gmail.com  Wed Jun 26 08:32:33 2013
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Wed, 26 Jun 2013 16:32:33 +0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
Message-ID: <CAO-wXwJ20TxqaJF9hg2+KwsCBkAW2eE7gPG6+zz0n6+vDtw-gw@mail.gmail.com>

Aleksey Shipilev wrote: >>Now that's a good example!
I think we don't actually need three threads in order to reproduce the bug.
The following example with only two threads do the same (allows us to
invoke ReentrantReadWriteLock.ReadLock.unlock() from the thread that
doesn't hold the read lock):

public class Main {
       public static void main(String[] args) throws InterruptedException {
             final ReentrantReadWriteLock lock = new
ReentrantReadWriteLock();
             Thread t1 = new LegalThread(1) {
                    @Override
                    public void run() {
                           try {
                                  lock.readLock().lock();
                           } catch (Exception e) {
                                  e.printStackTrace();
                           }
                    }
             };

             t1.start();
             t1.join();

             Thread t2 = new LegalThread(t1.getId()) {// t1 was terminated;
according to the Thread.getId() specification one can reuse id of t1
             //Thread t2 = new LegalThread(2) { //use this line of code to
break the trick
                    @Override
                    public void run() {
                           try {
                                  lock.readLock().unlock();// the trick
                                  System.out.println("the trick was
successfully performed");
                           } catch (Exception e) {
                                  e.printStackTrace();
                           }
                    }
             };

             t2.start();
             t2.join();
       }

       static class LegalThread extends Thread {
             private final long id;

             public LegalThread(long id) {
                    this.id = id;
             }

             @Override
             public long getId() {
                    return id;
             }
       }
}

I also want to note that documentation of the method
ReentrantReadWriteLock.ReadLock.unlock() doesn't specify that it can throw
IllegalMonitorStateException if the thread doesn't hold the read lock,
while documentation of the method Lock.unlock() specifies that such a
restriction is an implementation detail and it _must_  be documented. So
for me it seems like documentation of the method
ReentrantReadWriteLock.ReadLock.unlock() should also be improved. Am I
right?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/4d9891c6/attachment.html>

From chris.w.dennis at gmail.com  Wed Jun 26 08:58:00 2013
From: chris.w.dennis at gmail.com (Chris Dennis)
Date: Wed, 26 Jun 2013 08:58:00 -0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
 implementations
In-Reply-To: <CAO-wXwJ20TxqaJF9hg2+KwsCBkAW2eE7gPG6+zz0n6+vDtw-gw@mail.gmail.com>
Message-ID: <CDF05CC1.2F4FF%chris.w.dennis@gmail.com>

There is special logic in place in RRWL (firstReader/firstReaderHoldCount)
to optimize the uncontended read lock scenario, this is why you need to have
the an additional thread to push you past this logic and expose the issue
with cachedHoldCounter.

On 6/26/13 8:32 AM, "Valentin Kovalenko" <valentin.male.kovalenko at gmail.com>
wrote:

Aleksey Shipilev wrote: >>Now that's a good example!
I think we don't actually need three threads in order to reproduce the bug.
The following example with only two threads do the same (allows us to invoke
ReentrantReadWriteLock.ReadLock.unlock() from the thread that doesn't hold
the read lock):

public class Main {
       public static void main(String[] args) throws InterruptedException {
             final ReentrantReadWriteLock lock = new
ReentrantReadWriteLock();
             Thread t1 = new LegalThread(1) {
                    @Override
                    public void run() {
                           try {
                                  lock.readLock().lock();
                           } catch (Exception e) {
                                  e.printStackTrace();
                           }
                    }
             };

             t1.start();
             t1.join();
             
             Thread t2 = new LegalThread(t1.getId()) {// t1 was terminated;
according to the Thread.getId() specification one can reuse id of t1
             //Thread t2 = new LegalThread(2) { //use this line of code to
break the trick
                    @Override
                    public void run() {
                           try {
                                  lock.readLock().unlock();// the trick
                                  System.out.println("the trick was
successfully performed");
                           } catch (Exception e) {
                                  e.printStackTrace();
                           }
                    }
             };

             t2.start();
             t2.join();
       }

       static class LegalThread extends Thread {
             private final long id;

             public LegalThread(long id) {
                    this.id <http://this.id>  = id;
             }

             @Override
             public long getId() {
                    return id;
             }
       }
}

I also want to note that documentation of the method
ReentrantReadWriteLock.ReadLock.unlock() doesn't specify that it can throw
IllegalMonitorStateException if the thread doesn't hold the read lock, while
documentation of the method Lock.unlock() specifies that such a restriction
is an implementation detail and it _must_  be documented. So for me it seems
like documentation of the method ReentrantReadWriteLock.ReadLock.unlock()
should also be improved. Am I right?
_______________________________________________ Concurrency-interest mailing
list Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/093f5251/attachment-0001.html>

From ron.pressler at gmail.com  Wed Jun 26 11:13:45 2013
From: ron.pressler at gmail.com (Ron Pressler)
Date: Wed, 26 Jun 2013 18:13:45 +0300
Subject: [concurrency-interest] Performance regression in newest
 (6/20/2013) jsr166 update
In-Reply-To: <51CA2FEA.3070509@cs.oswego.edu>
References: <CABg6-qj0FxrUgA7atMdVVVuUGqVvzyvo7F+btpKsFjtaPG4LVA@mail.gmail.com>
	<51CA2FEA.3070509@cs.oswego.edu>
Message-ID: <CABg6-qjKeKiANENs=+xt1QtNQJ-btaDHYhsZ-mf1vQL4W+QnRg@mail.gmail.com>

> ... async mode (which is not common) ...

AFAIK, all actor/messaging libraries that on FJ (like Akka and Quasar) use
FJPool in async mode.

> Most of this can be reinstated though, which on a quick check of a quick
touch-up recovers performance on your test case. Stay tuned.

Great. Thanks.
Obviously, FJ is mostly intended for batch parallelization, but it's such a
good scheduler that online, low latency software is relying on FJ for
scheduling. It would be a shame to sacrifice the async mode for the sake of
the default mode. If it has to be done, maybe we should have different
class for the async case?

On Wed, Jun 26, 2013 at 3:03 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 06/22/13 20:42, Ron Pressler wrote:
>
>> A couple of months ago I described the behavior detailed in the email
>> exchange
>> below. The newest update causes a slowdown of about 25% of this benchmark:
>> ...
>>
>
>
>       static ForkJoinPool fjPool = new ForkJoinPool(PARALLELISM,
>> ForkJoinPool.**defaultForkJoinWorkerThreadFac**tory, null, true);
>>
>
> Yes, some handling for pools run in async mode (which is not common)
> got a little worse in the course of improving vastly more common cases.
> Most of this can be reinstated though, which on a quick check of
> a quick touch-up recovers performance on your test case. Stay tuned.
>
>
> -Doug
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/9b9e2587/attachment.html>

From viktor.klang at gmail.com  Wed Jun 26 11:23:00 2013
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 26 Jun 2013 17:23:00 +0200
Subject: [concurrency-interest] Performance regression in newest
 (6/20/2013) jsr166 update
In-Reply-To: <CABg6-qjKeKiANENs=+xt1QtNQJ-btaDHYhsZ-mf1vQL4W+QnRg@mail.gmail.com>
References: <CABg6-qj0FxrUgA7atMdVVVuUGqVvzyvo7F+btpKsFjtaPG4LVA@mail.gmail.com>
	<51CA2FEA.3070509@cs.oswego.edu>
	<CABg6-qjKeKiANENs=+xt1QtNQJ-btaDHYhsZ-mf1vQL4W+QnRg@mail.gmail.com>
Message-ID: <CANPzfU9n3y3mrsu-U-RO1iJMdBzEQ2NajjkgJuHE8t_Kcok5AQ@mail.gmail.com>

Hi Ron,

On Wed, Jun 26, 2013 at 5:13 PM, Ron Pressler <ron.pressler at gmail.com>wrote:

> > ... async mode (which is not common) ...
>
> AFAIK, all actor/messaging libraries that on FJ (like Akka and Quasar) use
> FJPool in async mode.
>

Yes, Akka and scala.concurrent relies heavily on the async mode.


>
> > Most of this can be reinstated though, which on a quick check of a quick
> touch-up recovers performance on your test case. Stay tuned.
>
> Great. Thanks.
> Obviously, FJ is mostly intended for batch parallelization, but it's such
> a good scheduler that online, low latency software is relying on FJ for
> scheduling. It would be a shame to sacrifice the async mode for the sake of
> the default mode. If it has to be done, maybe we should have different
> class for the async case?
>

Would be nice with a stripped-down version of FJP which only contains the
worker-local queues and the work-stealing.
Anyone up for that?

Cheers,
?


>
>
> On Wed, Jun 26, 2013 at 3:03 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>
>> On 06/22/13 20:42, Ron Pressler wrote:
>>
>>> A couple of months ago I described the behavior detailed in the email
>>> exchange
>>> below. The newest update causes a slowdown of about 25% of this
>>> benchmark:
>>> ...
>>>
>>
>>
>>       static ForkJoinPool fjPool = new ForkJoinPool(PARALLELISM,
>>> ForkJoinPool.**defaultForkJoinWorkerThreadFac**tory, null, true);
>>>
>>
>> Yes, some handling for pools run in async mode (which is not common)
>> got a little worse in the course of improving vastly more common cases.
>> Most of this can be reinstated though, which on a quick check of
>> a quick touch-up recovers performance on your test case. Stay tuned.
>>
>>
>> -Doug
>>
>> ______________________________**_________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
*Viktor Klang*
*Director of Engineering*
Typesafe <http://www.typesafe.com/>

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/b4207b72/attachment.html>

From dl at cs.oswego.edu  Wed Jun 26 11:36:48 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 26 Jun 2013 11:36:48 -0400
Subject: [concurrency-interest] Performance regression in newest
 (6/20/2013) jsr166 update
In-Reply-To: <CABg6-qjKeKiANENs=+xt1QtNQJ-btaDHYhsZ-mf1vQL4W+QnRg@mail.gmail.com>
References: <CABg6-qj0FxrUgA7atMdVVVuUGqVvzyvo7F+btpKsFjtaPG4LVA@mail.gmail.com>
	<51CA2FEA.3070509@cs.oswego.edu>
	<CABg6-qjKeKiANENs=+xt1QtNQJ-btaDHYhsZ-mf1vQL4W+QnRg@mail.gmail.com>
Message-ID: <51CB0A90.1010807@cs.oswego.edu>

On 06/26/13 11:13, Ron Pressler wrote:

>  > Most of this can be reinstated though, which on a quick check of a quick
> touch-up recovers performance on your test case. Stay tuned.
>
> Great. Thanks.
> Obviously, FJ is mostly intended for batch parallelization, but it's such a good
> scheduler that online, low latency software is relying on FJ for scheduling. It
> would be a shame to sacrifice the async mode for the sake of the default mode.
> If it has to be done, maybe we should have different class for the async case?
>

Nearly all the (sometimes substantial) performance differences are
due to at most a few dozen lines of code scattered among a few
thousand, so it would be nice not to have to split these off.

Most differences reflect mainly-heuristic
signalling and related policies. For bulk parallelism
and most other usages, you need predictive wakeups
to ramp up computations, while most async loads benefit
from a more reactive scheme. (Part of which got
anti-optimized away in current version but will be
re-incorporated hopefully soon.

-Doug




From ron.pressler at gmail.com  Wed Jun 26 12:07:37 2013
From: ron.pressler at gmail.com (Ron Pressler)
Date: Wed, 26 Jun 2013 19:07:37 +0300
Subject: [concurrency-interest] Performance regression in newest
 (6/20/2013) jsr166 update
In-Reply-To: <51CB0A90.1010807@cs.oswego.edu>
References: <CABg6-qj0FxrUgA7atMdVVVuUGqVvzyvo7F+btpKsFjtaPG4LVA@mail.gmail.com>
	<51CA2FEA.3070509@cs.oswego.edu>
	<CABg6-qjKeKiANENs=+xt1QtNQJ-btaDHYhsZ-mf1vQL4W+QnRg@mail.gmail.com>
	<51CB0A90.1010807@cs.oswego.edu>
Message-ID: <CABg6-qhEE54AdJ1DLPr_G4Wofq=NzTc_KyEf3VKVxXbPLY_NUg@mail.gmail.com>

On Wed, Jun 26, 2013 at 6:36 PM, Doug Lea <dl at cs.oswego.edu> wrote:
>
>
> Most differences reflect mainly-heuristic
> signalling and related policies. For bulk parallelism
> and most other usages, you need predictive wakeups
> to ramp up computations, while most async loads benefit
> from a more reactive scheme. (Part of which got
> anti-optimized away in current version but will be
> re-incorporated hopefully soon.
>
>
A couple of months ago (regarding the benchmark), you said this:

> The underlying issue is that the pushing task does not know that
> the single worker is already available, so activates another.
> (It can take a few dozen nanoseconds for workers to rescan before
> idling.) So it is not so much parallelism-level as intrinsic raciness.

So is the intention to improve this in the default mode only, or
will you address the problem in the async mode, too?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/bad1ce5b/attachment.html>

From alex at puredanger.com  Wed Jun 26 12:31:02 2013
From: alex at puredanger.com (Alex Miller)
Date: Wed, 26 Jun 2013 11:31:02 -0500
Subject: [concurrency-interest] Performance regression in newest
	(6/20/2013) jsr166 update
Message-ID: <CAOdgdgwGtpy15ESzAXCDO93+vLSoZqx2cFEJyoGrGx3Fjfi4Dg@mail.gmail.com>

On  Wed, 26 Jun 2013 17:23:00 +0200, <viktor.klang at gmail.com> wrote:

On Wed, Jun 26, 2013 at 5:13 PM, Ron Pressler <ron.pressler at gmail.com>wrote:
>
> > > ... async mode (which is not common) ...
> >
> > AFAIK, all actor/messaging libraries that on FJ (like Akka and Quasar)
> use
> > FJPool in async mode.
> >
>
> Yes, Akka and scala.concurrent relies heavily on the async mode.
>

The Clojure reducer library and nascent core.async library are also taking
this path so add us to the interested parties watching this use case. :)

Alex
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/3f7621e1/attachment.html>

From nathan.reynolds at oracle.com  Wed Jun 26 12:54:52 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Wed, 26 Jun 2013 09:54:52 -0700
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
In-Reply-To: <51CAC5EA.9080209@cs.oswego.edu>
References: <CDEF4299.2F31E%chris.w.dennis@gmail.com>
	<51CA21B5.2010907@cs.oswego.edu> <51CAC5EA.9080209@cs.oswego.edu>
Message-ID: <51CB1CDC.10003@oracle.com>

 > public static final long getThreadId(Thread thread) {

Doesn't it make more sense to have a member method instead of a static 
method?

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 6/26/2013 3:43 AM, Doug Lea wrote:
> On 06/25/13 19:03, Doug Lea wrote:
>>
>
>> We can and probably should fix this immediately by grabbing
>> the Thread's "tid" field instead of calling getId.
>
> I committed this change to jsr166 sources, so it should eventually
> make its way into OpenJDK.
>
>
>> On the form of the added method:
>> By analogy to Object.hashCode() (orverridable) vs
>> System.identityHashCode(Object) (not). maybe the
>> best place for this method is System.getThreadId(Thread)?
>
> Or less disruptively, it might as well be in class Thread, but
> with spec wording adapted from System.identityHashCode:
>
>     /**
>      * Returns the identifier for the given Thread, as would
>      * be returned by the default {@link #getId} method,
>      * whether or not the thread's class overrides {@code getId()}.
>      *
>      * @param thread the thread
>      * @return the id
>      */
>     public static final long getThreadId(Thread thread) {
>         return thread.tid;
>     }
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/0d6f5cdf/attachment.html>

From ron.pressler at gmail.com  Wed Jun 26 13:42:44 2013
From: ron.pressler at gmail.com (Ron Pressler)
Date: Wed, 26 Jun 2013 20:42:44 +0300
Subject: [concurrency-interest] Performance regression in newest
 (6/20/2013) jsr166 update
In-Reply-To: <CAOdgdgwGtpy15ESzAXCDO93+vLSoZqx2cFEJyoGrGx3Fjfi4Dg@mail.gmail.com>
References: <CAOdgdgwGtpy15ESzAXCDO93+vLSoZqx2cFEJyoGrGx3Fjfi4Dg@mail.gmail.com>
Message-ID: <CABg6-qgFR59c3jagTB-TBcCE9VL47VESk9g22yaSCsmYq4W0-Q@mail.gmail.com>

On Wed, Jun 26, 2013 at 7:31 PM, Alex Miller <alex at puredanger.com> wrote:
>
>
> The Clojure reducer library and nascent core.async library are also taking
> this path so add us to the interested parties watching this use case. :)
>
>
Reducers, too? I would have thought that reducers are a classic computation
tree, just the kind that would benefit from FJ's default mode, which gives
you a "depth-first" traversal, which is just what you need if you want
work-stealing to yield good multi-core load balancing.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/abccd625/attachment.html>

From alex at puredanger.com  Wed Jun 26 13:46:14 2013
From: alex at puredanger.com (Alex Miller)
Date: Wed, 26 Jun 2013 12:46:14 -0500
Subject: [concurrency-interest] Performance regression in newest
 (6/20/2013) jsr166 update
In-Reply-To: <CABg6-qgFR59c3jagTB-TBcCE9VL47VESk9g22yaSCsmYq4W0-Q@mail.gmail.com>
References: <CAOdgdgwGtpy15ESzAXCDO93+vLSoZqx2cFEJyoGrGx3Fjfi4Dg@mail.gmail.com>
	<CABg6-qgFR59c3jagTB-TBcCE9VL47VESk9g22yaSCsmYq4W0-Q@mail.gmail.com>
Message-ID: <CAOdgdgzgm4+G0_gHtoyQxrf_QOv6j8R7XP0G7Voz6rqJph_eCg@mail.gmail.com>

Sorry, you're absolutely correct! The algorithmic parallelism in reducers
is the classic fork/join model.


On Wed, Jun 26, 2013 at 12:42 PM, Ron Pressler <ron.pressler at gmail.com>wrote:

>
>
> On Wed, Jun 26, 2013 at 7:31 PM, Alex Miller <alex at puredanger.com> wrote:
>
>>
>> The Clojure reducer library and nascent core.async library are also
>> taking this path so add us to the interested parties watching this use
>> case. :)
>>
>>
> Reducers, too? I would have thought that reducers are a classic
> computation tree, just the kind that would benefit from FJ's default mode,
> which gives you a "depth-first" traversal, which is just what you need if
> you want work-stealing to yield good multi-core load balancing.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/635917a1/attachment.html>

From dragonsinth at gmail.com  Wed Jun 26 13:55:40 2013
From: dragonsinth at gmail.com (Scott Blum)
Date: Wed, 26 Jun 2013 13:55:40 -0400
Subject: [concurrency-interest] Should CopyOnWriteArrayList implement
	RandomAccess?
In-Reply-To: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>
References: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>
Message-ID: <CALuNCpii6jvv5nAhKYn=nX1+_+5hsQD7E1jD-31p69Xi_q2+UQ@mail.gmail.com>

Seems like a nit to me.  You can still do random lookup in constant time.
On Jun 26, 2013 3:58 AM, "Nitsan Wakart" <nitsanw at yahoo.com> wrote:

> Hi,
> Given the the javadoc for RandomAccess suggests that:
> "As a rule of thumb, a List implementation should implement this interface
> if, for typical instances of the class, this loop:
> for (int i=0, n=list.size(); i < n; i++) list.get(i);
>
> runs faster than this loop:
> for (Iterator i=list.iterator(); i.hasNext(); ) i.next();"
> But the above is not true for CopyOnWriteArrayList where the iterator
> performs better as the volatile read of the array is avoided on each entry
> and where the first loop is incorrect in any case(can lead to index out of
> bounds).
> Is that a bug or am I missing something here?
> Thanks,
> Nitsan
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/af2375c0/attachment-0001.html>

From gustav.r.akesson at gmail.com  Wed Jun 26 14:23:10 2013
From: gustav.r.akesson at gmail.com (=?ISO-8859-1?Q?Gustav_=C5kesson?=)
Date: Wed, 26 Jun 2013 20:23:10 +0200
Subject: [concurrency-interest]  Bounded PriorityBlockingQueue
Message-ID: <CAKEw5+7=pyc3W5v9h6HMs80R4DWr5D-97J5s04OVAU8juL5A8w@mail.gmail.com>

Hi,

I had a use case for a bounded priority blocking queue in a large-scale
server but couldn't find any useful implementation. Below is my
implementation:

https://github.com/gakesson/ConcurrencyUtils/blob/c5794c5b7c0ada763549cadfbbbd345713ace79a/BoundedPriorityBlockingQueue.java

Feel free to have a look at it, test it and come up with feedback and
improvements. Also, if you have had the same requirements as I, feel free
to use it but don't forget to contribute if/when you find improvements. :-)


Best Regards,

Gustav ?kesson
Cogitel AB
Sweden
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/c61bc82d/attachment.html>

From heinz at javaspecialists.eu  Wed Jun 26 14:48:18 2013
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Wed, 26 Jun 2013 21:48:18 +0300
Subject: [concurrency-interest] Bounded PriorityBlockingQueue
In-Reply-To: <CAKEw5+7=pyc3W5v9h6HMs80R4DWr5D-97J5s04OVAU8juL5A8w@mail.gmail.com>
References: <CAKEw5+7=pyc3W5v9h6HMs80R4DWr5D-97J5s04OVAU8juL5A8w@mail.gmail.com>
Message-ID: <CACLL95rxQXsCz-CLSiFCZioUFeTYRh1sjkgz3zReZkbjUoudfg@mail.gmail.com>

Hi Gustav,

Would it not be a lot easier to wrap a PriorityBoundedQueue with
another class that simply uses a Semaphore to limit the total number
of elements inside the queue?  Goetz's book has an implementation for
a BoundedQueue.

Heinz

On 26/06/2013, Gustav ?kesson <gustav.r.akesson at gmail.com> wrote:
> Hi,
>
> I had a use case for a bounded priority blocking queue in a large-scale
> server but couldn't find any useful implementation. Below is my
> implementation:
>
> https://github.com/gakesson/ConcurrencyUtils/blob/c5794c5b7c0ada763549cadfbbbd345713ace79a/BoundedPriorityBlockingQueue.java
>
> Feel free to have a look at it, test it and come up with feedback and
> improvements. Also, if you have had the same requirements as I, feel free
> to use it but don't forget to contribute if/when you find improvements. :-)
>
>
> Best Regards,
>
> Gustav ?kesson
> Cogitel AB
> Sweden
>


-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun/Oracle Java Champion 2005-2013
JavaOne Rockstar Speaker 2012
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz


From viktor.klang at gmail.com  Wed Jun 26 15:01:58 2013
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 26 Jun 2013 15:01:58 -0400
Subject: [concurrency-interest] Bounded PriorityBlockingQueue
In-Reply-To: <CAKEw5+7=pyc3W5v9h6HMs80R4DWr5D-97J5s04OVAU8juL5A8w@mail.gmail.com>
References: <CAKEw5+7=pyc3W5v9h6HMs80R4DWr5D-97J5s04OVAU8juL5A8w@mail.gmail.com>
Message-ID: <CANPzfU8yhqKUAG3u_bh1AAVE8DNDthA1aKTBxsarQbgNzg_6kQ@mail.gmail.com>

Hi Gustav!

I was in that exact same situation a while back, (I sadly didn't market it
though),
I ended up going for generality instead of performance (figuring that if
one wanted a Priority Queue one was not going for max performance)

Impl:


https://github.com/akka/akka/blob/master/akka-actor/src/main/scala/akka/util/BoundedBlockingQueue.scala

Usage:

    new BoundedBlockingQueue[T](capacity, new
PriorityQueue[T](initialCapacity, comparator))

Cheers,
?


On Wed, Jun 26, 2013 at 2:23 PM, Gustav ?kesson
<gustav.r.akesson at gmail.com>wrote:

> Hi,
>
> I had a use case for a bounded priority blocking queue in a large-scale
> server but couldn't find any useful implementation. Below is my
> implementation:
>
>
> https://github.com/gakesson/ConcurrencyUtils/blob/c5794c5b7c0ada763549cadfbbbd345713ace79a/BoundedPriorityBlockingQueue.java
>
> Feel free to have a look at it, test it and come up with feedback and
> improvements. Also, if you have had the same requirements as I, feel free
> to use it but don't forget to contribute if/when you find improvements. :-)
>
>
> Best Regards,
>
> Gustav ?kesson
> Cogitel AB
> Sweden
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
*Viktor Klang*
*Director of Engineering*
Typesafe <http://www.typesafe.com/>

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/387b8096/attachment.html>

From oleksandr.otenko at oracle.com  Wed Jun 26 15:12:22 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Wed, 26 Jun 2013 20:12:22 +0100
Subject: [concurrency-interest] Bounded PriorityBlockingQueue
In-Reply-To: <CAKEw5+7=pyc3W5v9h6HMs80R4DWr5D-97J5s04OVAU8juL5A8w@mail.gmail.com>
References: <CAKEw5+7=pyc3W5v9h6HMs80R4DWr5D-97J5s04OVAU8juL5A8w@mail.gmail.com>
Message-ID: <51CB3D16.80404@oracle.com>

Your queue always rearranges elements - both on enqueue and dequeue.

You need to figure out how to take advantage of elements being ordered 
after any enqueue. There are many publications on this.


Alex


On 26/06/2013 19:23, Gustav ?kesson wrote:
> Hi,
>
> I had a use case for a bounded priority blocking queue in a 
> large-scale server but couldn't find any useful implementation. Below 
> is my implementation:
>
> https://github.com/gakesson/ConcurrencyUtils/blob/c5794c5b7c0ada763549cadfbbbd345713ace79a/BoundedPriorityBlockingQueue.java
>
> Feel free to have a look at it, test it and come up with feedback and 
> improvements. Also, if you have had the same requirements as I, feel 
> free to use it but don't forget to contribute if/when you find 
> improvements. :-)
>
>
> Best Regards,
>
> Gustav ?kesson
> Cogitel AB
> Sweden
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/87ad8189/attachment.html>

From oleksandr.otenko at oracle.com  Wed Jun 26 15:17:15 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Wed, 26 Jun 2013 20:17:15 +0100
Subject: [concurrency-interest] Bounded PriorityBlockingQueue
In-Reply-To: <CANPzfU8yhqKUAG3u_bh1AAVE8DNDthA1aKTBxsarQbgNzg_6kQ@mail.gmail.com>
References: <CAKEw5+7=pyc3W5v9h6HMs80R4DWr5D-97J5s04OVAU8juL5A8w@mail.gmail.com>
	<CANPzfU8yhqKUAG3u_bh1AAVE8DNDthA1aKTBxsarQbgNzg_6kQ@mail.gmail.com>
Message-ID: <51CB3E3B.3020603@oracle.com>

Obviously, if the queue is contended a lot, you don't need to sort so 
much. So, you can still go for max performance.

Alex


On 26/06/2013 20:01, ?iktor ?lang wrote:
> Hi Gustav!
>
> I was in that exact same situation a while back, (I sadly didn't 
> market it though),
> I ended up going for generality instead of performance (figuring that 
> if one wanted a Priority Queue one was not going for max performance)
>
> Impl:
>
> https://github.com/akka/akka/blob/master/akka-actor/src/main/scala/akka/util/BoundedBlockingQueue.scala
>
> Usage:
>
>     new BoundedBlockingQueue[T](capacity, new 
> PriorityQueue[T](initialCapacity, comparator))
>
> Cheers,
> ?
>
>
> On Wed, Jun 26, 2013 at 2:23 PM, Gustav ?kesson 
> <gustav.r.akesson at gmail.com <mailto:gustav.r.akesson at gmail.com>> wrote:
>
>     Hi,
>
>     I had a use case for a bounded priority blocking queue in a
>     large-scale server but couldn't find any useful implementation.
>     Below is my implementation:
>
>     https://github.com/gakesson/ConcurrencyUtils/blob/c5794c5b7c0ada763549cadfbbbd345713ace79a/BoundedPriorityBlockingQueue.java
>
>     Feel free to have a look at it, test it and come up with feedback
>     and improvements. Also, if you have had the same requirements as
>     I, feel free to use it but don't forget to contribute if/when you
>     find improvements. :-)
>
>
>     Best Regards,
>
>     Gustav ?kesson
>     Cogitel AB
>     Sweden
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> -- 
> *Viktor Klang*
> /Director of Engineering/
> Typesafe <http://www.typesafe.com/>
>
> Twitter: @viktorklang
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/4a086c4f/attachment-0001.html>

From martinrb at google.com  Wed Jun 26 15:33:42 2013
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 26 Jun 2013 12:33:42 -0700
Subject: [concurrency-interest] Should CopyOnWriteArrayList implement
	RandomAccess?
In-Reply-To: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>
References: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>
Message-ID: <CA+kOe0-ZiWteRwzAuxKJ1ioOCgnxFEEe8VrW4z-bCNqu6ibJnA@mail.gmail.com>

I agree that the original decision to have COWAL implement RandomAccess was
a (very small) mistake, but it's too late to fix now.

In any case, "concurrent list" is a bit of an oxymoron.


On Wed, Jun 26, 2013 at 3:55 AM, Nitsan Wakart <nitsanw at yahoo.com> wrote:

> Hi,
> Given the the javadoc for RandomAccess suggests that:
> "As a rule of thumb, a List implementation should implement this interface
> if, for typical instances of the class, this loop:
> for (int i=0, n=list.size(); i < n; i++) list.get(i);
>
> runs faster than this loop:
> for (Iterator i=list.iterator(); i.hasNext(); ) i.next();"
> But the above is not true for CopyOnWriteArrayList where the iterator
> performs better as the volatile read of the array is avoided on each entry
> and where the first loop is incorrect in any case(can lead to index out of
> bounds).
> Is that a bug or am I missing something here?
> Thanks,
> Nitsan
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/c4293a7c/attachment.html>

From gustav.r.akesson at gmail.com  Wed Jun 26 16:51:42 2013
From: gustav.r.akesson at gmail.com (=?ISO-8859-1?Q?Gustav_=C5kesson?=)
Date: Wed, 26 Jun 2013 22:51:42 +0200
Subject: [concurrency-interest] Bounded PriorityBlockingQueue
In-Reply-To: <CACLL95rxQXsCz-CLSiFCZioUFeTYRh1sjkgz3zReZkbjUoudfg@mail.gmail.com>
References: <CAKEw5+7=pyc3W5v9h6HMs80R4DWr5D-97J5s04OVAU8juL5A8w@mail.gmail.com>
	<CACLL95rxQXsCz-CLSiFCZioUFeTYRh1sjkgz3zReZkbjUoudfg@mail.gmail.com>
Message-ID: <CAKEw5+4PPJD7GaBLGbP8R95tKu-CwyUUd6izv+dA-Bc9_hsFRQ@mail.gmail.com>

Sorry for the spam - still figuring out how to reply properly on e-mails.
;-)

------

Heinz,

Your mean like acquiring a permit when putting and releasing when taking? I
thought of such a solution but I didn't like introducing that extra
contention point of a Semaphore besides the queue's internal ReentrantLock
(and a lock-based collection is needed in such a case since Semaphore
doesn't provide mutual exclusion). Additionally, I wanted to get rid of
some of the PriorityBlockedQueue characteristics such as size() not being
constant in time. I now Dough hates size() in a concurrent collection, but
it could be useful to perform some sort of estimation.

Performance still matters (ideally the same as a ABQ), but needed
prioritization to enforce that important tasks always got executed before
any other.

_______________________________________

Viktor,

Nice implementation (gosh, Scala is pretty damn nice) - your general
solution isn't too different from my more specific. One concern I have is
the backing.size() which could potentially be expensive, especially in the
context of repeatedly trying to get the lock. On the other hand, if I'm not
mistaken, the collection's with size of linear cost usually belongs to the
concurrent ones, and I don't see any point in using a concurrent as backing
when using your implementation.

Also, the drainTo methods don't signal that the queue (potentially) has
been drained of element(s). That could lead to threads waiting for signal
to insert when the queue is in fact not full. Same thing with clear().

Got a couple of tips from it, though, which I will push to Github. Will
also push the basic tests. Thanks for input!


Best Regards,

Gustav ?kesson


On Wed, Jun 26, 2013 at 8:48 PM, Dr Heinz M. Kabutz <
heinz at javaspecialists.eu> wrote:

> Hi Gustav,
>
> Would it not be a lot easier to wrap a PriorityBoundedQueue with
> another class that simply uses a Semaphore to limit the total number
> of elements inside the queue?  Goetz's book has an implementation for
> a BoundedQueue.
>
> Heinz
>
> On 26/06/2013, Gustav ?kesson <gustav.r.akesson at gmail.com> wrote:
> > Hi,
> >
> > I had a use case for a bounded priority blocking queue in a large-scale
> > server but couldn't find any useful implementation. Below is my
> > implementation:
> >
> >
> https://github.com/gakesson/ConcurrencyUtils/blob/c5794c5b7c0ada763549cadfbbbd345713ace79a/BoundedPriorityBlockingQueue.java
> >
> > Feel free to have a look at it, test it and come up with feedback and
> > improvements. Also, if you have had the same requirements as I, feel free
> > to use it but don't forget to contribute if/when you find improvements.
> :-)
> >
> >
> > Best Regards,
> >
> > Gustav ?kesson
> > Cogitel AB
> > Sweden
> >
>
>
> --
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun/Oracle Java Champion 2005-2013
> JavaOne Rockstar Speaker 2012
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/f269e1c9/attachment.html>

From valentin.male.kovalenko at gmail.com  Wed Jun 26 17:05:30 2013
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Thu, 27 Jun 2013 01:05:30 +0400
Subject: [concurrency-interest] RRWL with 'bad' Thread.getId()
	implementations
Message-ID: <CAO-wXwKhVL5eS1JejU6mwbp2g3jF7C3wFGVkOb2GWZ4YZeTZ6Q@mail.gmail.com>

Thenks!
Now I see, my code with only two threads reproduces the bug for Oracle
JDK1.6 implementation, but for JDK1.7 implementation one actually need
three threads to reproduce the bug.

>>There is special logic in place in RRWL (firstReader/firstReaderHoldCount)
>>to optimize the uncontended read lock scenario, this is why you need to
have
>>the an additional thread to push you past this logic and expose the issue
>>with cachedHoldCounter.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130627/2b210dc1/attachment.html>

From viktor.klang at gmail.com  Wed Jun 26 17:07:31 2013
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 26 Jun 2013 17:07:31 -0400
Subject: [concurrency-interest] Bounded PriorityBlockingQueue
In-Reply-To: <CAKEw5+4PPJD7GaBLGbP8R95tKu-CwyUUd6izv+dA-Bc9_hsFRQ@mail.gmail.com>
References: <CAKEw5+7=pyc3W5v9h6HMs80R4DWr5D-97J5s04OVAU8juL5A8w@mail.gmail.com>
	<CACLL95rxQXsCz-CLSiFCZioUFeTYRh1sjkgz3zReZkbjUoudfg@mail.gmail.com>
	<CAKEw5+4PPJD7GaBLGbP8R95tKu-CwyUUd6izv+dA-Bc9_hsFRQ@mail.gmail.com>
Message-ID: <CANPzfU-Cp_jqu9SqzuQ30F2yAs5ku=Fik=Pj9OAPqvSzu8yN=g@mail.gmail.com>

Gustav,


On Wed, Jun 26, 2013 at 4:51 PM, Gustav ?kesson
<gustav.r.akesson at gmail.com>wrote:

> Sorry for the spam - still figuring out how to reply properly on e-mails.
> ;-)
>
> ------
>
> Heinz,
>
> Your mean like acquiring a permit when putting and releasing when taking?
> I thought of such a solution but I didn't like introducing that extra
> contention point of a Semaphore besides the queue's internal ReentrantLock
> (and a lock-based collection is needed in such a case since Semaphore
> doesn't provide mutual exclusion). Additionally, I wanted to get rid of
> some of the PriorityBlockedQueue characteristics such as size() not being
> constant in time. I now Dough hates size() in a concurrent collection, but
> it could be useful to perform some sort of estimation.
>
> Performance still matters (ideally the same as a ABQ), but needed
> prioritization to enforce that important tasks always got executed before
> any other.
>
> _______________________________________
>
> Viktor,
>
> Nice implementation (gosh, Scala is pretty damn nice) - your general
> solution isn't too different from my more specific.
>

Thanks! Yeah, Scala is pretty easy on the eyes at times :)


> One concern I have is the backing.size() which could potentially be
> expensive, especially in the context of repeatedly trying to get the lock.
> On the other hand, if I'm not mistaken, the collection's with size of
> linear cost usually belongs to the concurrent ones, and I don't see any
> point in using a concurrent as backing when using your implementation.
>

Exactly, which is why I am requiring java.util.Queue.


>
> Also, the drainTo methods don't signal that the queue (potentially) has
> been drained of element(s). That could lead to threads waiting for signal
> to insert when the queue is in fact not full. Same thing with clear().
>

Ouch! Nice catch, will fix.


>
> Got a couple of tips from it, though, which I will push to Github. Will
> also push the basic tests. Thanks for input!
>

You're most welcome, have fun :)

Cheers,
?


>
>
> Best Regards,
>
> Gustav ?kesson
>
>
> On Wed, Jun 26, 2013 at 8:48 PM, Dr Heinz M. Kabutz <
> heinz at javaspecialists.eu> wrote:
>
>> Hi Gustav,
>>
>> Would it not be a lot easier to wrap a PriorityBoundedQueue with
>> another class that simply uses a Semaphore to limit the total number
>> of elements inside the queue?  Goetz's book has an implementation for
>> a BoundedQueue.
>>
>> Heinz
>>
>> On 26/06/2013, Gustav ?kesson <gustav.r.akesson at gmail.com> wrote:
>> > Hi,
>> >
>> > I had a use case for a bounded priority blocking queue in a large-scale
>> > server but couldn't find any useful implementation. Below is my
>> > implementation:
>> >
>> >
>> https://github.com/gakesson/ConcurrencyUtils/blob/c5794c5b7c0ada763549cadfbbbd345713ace79a/BoundedPriorityBlockingQueue.java
>> >
>> > Feel free to have a look at it, test it and come up with feedback and
>> > improvements. Also, if you have had the same requirements as I, feel
>> free
>> > to use it but don't forget to contribute if/when you find improvements.
>> :-)
>> >
>> >
>> > Best Regards,
>> >
>> > Gustav ?kesson
>> > Cogitel AB
>> > Sweden
>> >
>>
>>
>> --
>> Dr Heinz M. Kabutz (PhD CompSci)
>> Author of "The Java(tm) Specialists' Newsletter"
>> Sun/Oracle Java Champion 2005-2013
>> JavaOne Rockstar Speaker 2012
>> http://www.javaspecialists.eu
>> Tel: +30 69 75 595 262
>> Skype: kabutz
>>
>
>


-- 
*Viktor Klang*
*Director of Engineering*
Typesafe <http://www.typesafe.com/>

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130626/5f4cd233/attachment-0001.html>

From nitsanw at yahoo.com  Thu Jun 27 03:27:36 2013
From: nitsanw at yahoo.com (Nitsan Wakart)
Date: Thu, 27 Jun 2013 00:27:36 -0700 (PDT)
Subject: [concurrency-interest] Should CopyOnWriteArrayList implement
	RandomAccess?
In-Reply-To: <CA+kOe0-ZiWteRwzAuxKJ1ioOCgnxFEEe8VrW4z-bCNqu6ibJnA@mail.gmail.com>
References: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>
	<CA+kOe0-ZiWteRwzAuxKJ1ioOCgnxFEEe8VrW4z-bCNqu6ibJnA@mail.gmail.com>
Message-ID: <1372318056.51680.YahooMailNeo@web120703.mail.ne1.yahoo.com>

> I agree that the original decision to have COWAL implement RandomAccess was a (very small) mistake, but it's too late to fix now.
I agree it's small, but how is it hard to fix?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130627/a5807bb7/attachment.html>

From gustav.r.akesson at gmail.com  Thu Jun 27 03:37:35 2013
From: gustav.r.akesson at gmail.com (=?ISO-8859-1?Q?Gustav_=C5kesson?=)
Date: Thu, 27 Jun 2013 09:37:35 +0200
Subject: [concurrency-interest] Should CopyOnWriteArrayList implement
	RandomAccess?
In-Reply-To: <1372318056.51680.YahooMailNeo@web120703.mail.ne1.yahoo.com>
References: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>
	<CA+kOe0-ZiWteRwzAuxKJ1ioOCgnxFEEe8VrW4z-bCNqu6ibJnA@mail.gmail.com>
	<1372318056.51680.YahooMailNeo@web120703.mail.ne1.yahoo.com>
Message-ID: <CAKEw5+63onrEQx0+Da7i-W7RE5oS1ajSejauE-nQjx447QY0DQ@mail.gmail.com>

Because if it would have been removed it would also break people's code
(e.g. those assigning a COWAL instance to a RandomAccess type).


Best Regards,

Gustav ?kesson


On Thu, Jun 27, 2013 at 9:27 AM, Nitsan Wakart <nitsanw at yahoo.com> wrote:

> > I agree that the original decision to have COWAL implement RandomAccess
> was a (very small) mistake, but it's too late to fix now.
> I agree it's small, but how is it hard to fix?
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130627/f927deac/attachment.html>

From dl at cs.oswego.edu  Thu Jun 27 10:37:44 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 27 Jun 2013 10:37:44 -0400
Subject: [concurrency-interest] Performance regression in newest
 (6/20/2013) jsr166 update
In-Reply-To: <CABg6-qhEE54AdJ1DLPr_G4Wofq=NzTc_KyEf3VKVxXbPLY_NUg@mail.gmail.com>
References: <CABg6-qj0FxrUgA7atMdVVVuUGqVvzyvo7F+btpKsFjtaPG4LVA@mail.gmail.com>
	<51CA2FEA.3070509@cs.oswego.edu>
	<CABg6-qjKeKiANENs=+xt1QtNQJ-btaDHYhsZ-mf1vQL4W+QnRg@mail.gmail.com>
	<51CB0A90.1010807@cs.oswego.edu>
	<CABg6-qhEE54AdJ1DLPr_G4Wofq=NzTc_KyEf3VKVxXbPLY_NUg@mail.gmail.com>
Message-ID: <51CC4E38.8010007@cs.oswego.edu>

On 06/26/13 12:07, Ron Pressler wrote:
> On Wed, Jun 26, 2013 at 6:36 PM, Doug Lea <dl at cs.oswego.edu
> <mailto:dl at cs.oswego.edu>> wrote:
>
>
>     Most differences reflect mainly-heuristic
>     signalling and related policies. ...
>
> A couple of months ago (regarding the benchmark), you said this:
>
>  > The underlying issue is that the pushing task does not know that
>  > the single worker is already available, ...

> So is the intention to improve this in the default mode only, or
> will you address the problem in the async mode, too?
>

Stepping back a bit: Work-stealing has many, many advantages
over other schemes, but also has one source of overhead that
can hurt in some usage patterns: In order for a thread to
steal work, it must be awake (not blocked). (Aside: in
classic high-performance applications, this doesn't arise
because you can just keep them all awake spinning for the
duration of a program. People would not appreciate it
if we did this in Java.). Once computations get going
and there is no one left to wake up, this overhead evaporates.
But otherwise, blocking and unblocking threads on modern systems
is just not cheap (and further compounded by bookkeeping required
to check if wakeups are or may be needed). For example, in your
FJBenchmark program, I measure that this accounts for about 77%
of the run time. So, performance on artificial benchmarks like
this is heavily impacted by small details in how we manage to
avoid some or all of this overhead across various cases. The last
update hurt a bit on this benchmark, but even still, I'm not
sure yet whether it hurt more than helped any actual async usages.
As I said, stay tuned...

-Doug








From yankee.sierra at gmail.com  Thu Jun 27 10:51:02 2013
From: yankee.sierra at gmail.com (Yuval Shavit)
Date: Thu, 27 Jun 2013 10:51:02 -0400
Subject: [concurrency-interest] Should CopyOnWriteArrayList implement
	RandomAccess?
In-Reply-To: <CAKEw5+63onrEQx0+Da7i-W7RE5oS1ajSejauE-nQjx447QY0DQ@mail.gmail.com>
References: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>
	<CA+kOe0-ZiWteRwzAuxKJ1ioOCgnxFEEe8VrW4z-bCNqu6ibJnA@mail.gmail.com>
	<1372318056.51680.YahooMailNeo@web120703.mail.ne1.yahoo.com>
	<CAKEw5+63onrEQx0+Da7i-W7RE5oS1ajSejauE-nQjx447QY0DQ@mail.gmail.com>
Message-ID: <CAE+h5-AgN9YmssySafw9BeunaXD=uWuVHPNZsqaHuVfrRBF=9A@mail.gmail.com>

On Thu, Jun 27, 2013 at 3:37 AM, Gustav ?kesson
<gustav.r.akesson at gmail.com>wrote:

> Because if it would have been removed it would also break people's code
> (e.g. those assigning a COWAL instance to a RandomAccess type).
>

This seems like over-sensitivity to backwards compatibility. There are no
methods on RandomAccess, so I don't know why you would take a List of known
type and cast it to RandomAccess (e.g. RandomAccess r = new COWAL()). In
fact, I don't know why you would do *anything* with RandomAccess other than
checking for it with instanceof; I suspect that if it had come into being
in 1.5, it would have been an annotation instead of an interface.

In the unlikely event that anyone actually assigns an instance to
RandomAccess without first checking instanceof, I think it'd be valid to
tell them to use Object instead.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130627/52df806f/attachment.html>

From dl at cs.oswego.edu  Thu Jun 27 11:09:06 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 27 Jun 2013 11:09:06 -0400
Subject: [concurrency-interest] Should CopyOnWriteArrayList implement
 RandomAccess?
In-Reply-To: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>
References: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>
Message-ID: <51CC5592.9050604@cs.oswego.edu>

The lead sentence in RandomAccess says:

"Marker interface used by List implementations to indicate that they support 
fast (generally constant time) random access."

This is true of CopyOnWriteArrayList. For example get(43) is as fast as get(0).

One unfortunate aspect of this and other marker interfaces is that
some other code might make further assumptions based on instanceof
RandomAccess that don't hold here. One nice thing about JDK8 extension
methods is that you can overcome some of these problems by overriding
default implementations rather than worrying about non-overridable
utilities in classes like Collections. So JDK8 COWAL does in fact
do this. For example, you can actually sort one in reasonable time.

-Doug


On 06/26/13 06:55, Nitsan Wakart wrote:
> Hi,
> Given the the javadoc for RandomAccess suggests that:
> "As a rule of thumb, a List implementation should implement this interface if, for typical instances of the class, this loop:
> for (int i=0, n=list.size(); i < n; i++) list.get(i);
>
> runs faster than this loop:
> for (Iterator i=list.iterator(); i.hasNext(); ) i.next();"
> But the above is not true for CopyOnWriteArrayList where the iterator performs better as the volatile read of the array is avoided on each entry and where the first loop is incorrect in any case(can lead to index out of bounds).
> Is that a bug or am I missing something here?
> Thanks,
> Nitsan
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From concurrency at kuli.org  Thu Jun 27 11:14:55 2013
From: concurrency at kuli.org (Michael Kuhlmann)
Date: Thu, 27 Jun 2013 17:14:55 +0200
Subject: [concurrency-interest] Should CopyOnWriteArrayList implement
 RandomAccess?
In-Reply-To: <CAE+h5-AgN9YmssySafw9BeunaXD=uWuVHPNZsqaHuVfrRBF=9A@mail.gmail.com>
References: <1372244132.65033.YahooMailNeo@web120706.mail.ne1.yahoo.com>
	<CA+kOe0-ZiWteRwzAuxKJ1ioOCgnxFEEe8VrW4z-bCNqu6ibJnA@mail.gmail.com>
	<1372318056.51680.YahooMailNeo@web120703.mail.ne1.yahoo.com>
	<CAKEw5+63onrEQx0+Da7i-W7RE5oS1ajSejauE-nQjx447QY0DQ@mail.gmail.com>
	<CAE+h5-AgN9YmssySafw9BeunaXD=uWuVHPNZsqaHuVfrRBF=9A@mail.gmail.com>
Message-ID: <51CC56EF.7050104@kuli.org>

Am 27.06.2013 16:51, schrieb Yuval Shavit:
> This seems like over-sensitivity to backwards compatibility. There are
> no methods on RandomAccess, so I don't know why you would take a List of
> known type and cast it to RandomAccess (e.g. RandomAccess r = new
> COWAL()). In fact, I don't know why you would do *anything* with
> RandomAccess other than checking for it with instanceof; I suspect that
> if it had come into being in 1.5, it would have been an annotation
> instead of an interface.

First of all, an Annotation is - in this case - no way better than a
marker interface. Checking for RandomAccess is easy and simple by a
quick and fast instanceof. If it would be marked by an annotation,
checking for that would be much more complicated. (I personally don't
like the reflection-like usage of getClass() in user code.) And what
about subclasses or even anonymous classes? Aren't they random
accessible any more? And what if the interface is marked, but not the
implementation? Should you check every implemented interface for
@RandomAccess?

Breaking user code is easy when a library only accepts RandomAccess
lists because it relies heavily on fast get() implementations.

Even ThreadDeath wasn't made package private for backwards compatibility.

The whole discussion seems to be rather academic to me. The volatile
read in COWAL.getArray() is so fast on most systems that you only have
to care in very specific situations, where you wouldn't rely on the
general implementation of RandomAccess anyway.

And, the Javadoc of RandomAccess claims that it's only a "rule of thumb"
that get() should be faster than iterator.next(). If you look into, for
example, java.util.Vector, you'll see that the difference is so marginal
that it would be hard to measure even in a loop of millions of iterations.

I'd rather see RandomAccess as just a hint that get() is "quite fast"
and independent of the list's size and the index parameter. So it's
perfectly clear that COWAL should implement this.

If you rely on get() not throwing IndexOutOfBoundsException after you
checked for size() before, then you'll have a problem in every
concurrent situation. This has nothing to do with COWAL, it's true for
Vector or even every other synchronized List.

Greetings,
Michael


From thurston at nomagicsoftware.com  Sat Jun 29 22:27:49 2013
From: thurston at nomagicsoftware.com (thurstonn)
Date: Sat, 29 Jun 2013 19:27:49 -0700 (PDT)
Subject: [concurrency-interest] Why can't wait-set Threads be privileged?
Message-ID: <1372559269449-9808.post@n7.nabble.com>

So, in java the behavior of Object.wait and Object.notify():

Thread 1:

obj.wait() // Thread 1 is put in the wait-set

Thread 2: 

obj.notify() // Select a Thread from the wait-set and move it to the
*entry-set*



What I've always wondered is why there isn't some sort of 'overloaded'
Object.notify(...) that would essentially do:
whichever thread is selected from the notify() call, put it at the 'head' of
the wait-set so that it will enter the monitor next. (Note: what I'm
suggesting is not the same thing as the 'fairness' parameter to
ReentrantLock, e.g.)

Obviously wait() and notify() are native methods, so what I'm wondering is:
is this a limitation in modern OS's? CPUs?

I don't know enough about the actual implementation to know what the issues
are, but this would definitely be a useful feature (think multi-producer,
single-consumer, etc).

Of course there are other patterns that you can take to achieve similar
results, but it would appear to be a lot simpler if you could just specify
that is the behavior you want in an Object.notify(boolean: privilegewaiters)
or some equivalent.

Any insights?






--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Why-can-t-wait-set-Threads-be-privileged-tp9808.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From ron.pressler at gmail.com  Sun Jun 30 02:03:03 2013
From: ron.pressler at gmail.com (Ron Pressler)
Date: Sun, 30 Jun 2013 09:03:03 +0300
Subject: [concurrency-interest] Why can't wait-set Threads be privileged?
In-Reply-To: <1372559269449-9808.post@n7.nabble.com>
References: <1372559269449-9808.post@n7.nabble.com>
Message-ID: <CABg6-qiWa0nCz1AYjE8WQ0b_ASEgcWxayNi3DajLjjyhGZJ12Q@mail.gmail.com>

This is not a technical limitation, but (probably) an API decision.

Object.wait/notify dates back to Java 1. It was not intended as a low-level
synchronization-object-building toolkit, but as a high-level, everyday,
bread-and-butter synchronization mechanism. Allowing the programmer to
choose which particular thread to wake up doesn't make much sense within
those goals.

j.u.c.locks, however, is a low-level synchronization-object-building
toolkit, and you may use it in your hand-rolled constructs to
LockSupport.unpark() whichever thread you like.

On Sun, Jun 30, 2013 at 5:27 AM, thurstonn <thurston at nomagicsoftware.com>wrote:

> So, in java the behavior of Object.wait and Object.notify():
>
> Thread 1:
>
> obj.wait() // Thread 1 is put in the wait-set
>
> Thread 2:
>
> obj.notify() // Select a Thread from the wait-set and move it to the
> *entry-set*
>
>
>
> What I've always wondered is why there isn't some sort of 'overloaded'
> Object.notify(...) that would essentially do:
> whichever thread is selected from the notify() call, put it at the 'head'
> of
> the wait-set so that it will enter the monitor next. (Note: what I'm
> suggesting is not the same thing as the 'fairness' parameter to
> ReentrantLock, e.g.)
>
> Obviously wait() and notify() are native methods, so what I'm wondering is:
> is this a limitation in modern OS's? CPUs?
>
> I don't know enough about the actual implementation to know what the issues
> are, but this would definitely be a useful feature (think multi-producer,
> single-consumer, etc).
>
> Of course there are other patterns that you can take to achieve similar
> results, but it would appear to be a lot simpler if you could just specify
> that is the behavior you want in an Object.notify(boolean:
> privilegewaiters)
> or some equivalent.
>
> Any insights?
>
>
>
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/Why-can-t-wait-set-Threads-be-privileged-tp9808.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130630/a6c103a8/attachment.html>

From davidcholmes at aapt.net.au  Sun Jun 30 18:30:53 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 1 Jul 2013 08:30:53 +1000
Subject: [concurrency-interest] Why can't wait-set Threads be privileged?
In-Reply-To: <1372559269449-9808.post@n7.nabble.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEICJOAA.davidcholmes@aapt.net.au>

If you over-specify these things then you get locked into specific
implementations and if you are not careful you may not even be able to
implement them all on all platforms (ref the original Java Threads
whitepaper).

The main reason to leave this loosely specified is performance. Any policy
that requires a specific hand-off of a monitor to another thread forces
context switches that may not be necessary. Think of a simple bounded-buffer
producers consumer situation where the consumer has blocked in wait()
because the buffer is empty and a producer is starting to fill it in  a
loop:

  while (true) {
    Item x = new Item();
    buf.put(item);
  }

inside put() there is logic to notify any waiting take() operations; and
put() /take() are synchronized of course. If the notify acted by moving the
consumer thread to the head of the monitor queue, and forced the producer to
block on the monitor the next time it called put() then the producer and
consumer will operate in lock-step with a lot of context switches. Instead
the current implementation simply places the consumer thread in the monitor
entry queue, but allows the producer thread to "barge" past the queued
consumer. This potentially allows the producer to fill the buffer before it
has to block, at which point the consumer generally gets a chance to drain
the buffer.

The devil is in the details of course, but the looser the spec the more
flexibility in the implementation.

Also note that the underlying system primitives (pthread condition
variables, UI-thread condition variables, win32 events) are equally loosely
specified.

David Holmes
------------

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
> thurstonn
> Sent: Sunday, 30 June 2013 12:28 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Why can't wait-set Threads be
> privileged?
>
>
> So, in java the behavior of Object.wait and Object.notify():
>
> Thread 1:
>
> obj.wait() // Thread 1 is put in the wait-set
>
> Thread 2:
>
> obj.notify() // Select a Thread from the wait-set and move it to the
> *entry-set*
>
>
>
> What I've always wondered is why there isn't some sort of 'overloaded'
> Object.notify(...) that would essentially do:
> whichever thread is selected from the notify() call, put it at
> the 'head' of
> the wait-set so that it will enter the monitor next. (Note: what I'm
> suggesting is not the same thing as the 'fairness' parameter to
> ReentrantLock, e.g.)
>
> Obviously wait() and notify() are native methods, so what I'm
> wondering is:
> is this a limitation in modern OS's? CPUs?
>
> I don't know enough about the actual implementation to know what
> the issues
> are, but this would definitely be a useful feature (think multi-producer,
> single-consumer, etc).
>
> Of course there are other patterns that you can take to achieve similar
> results, but it would appear to be a lot simpler if you could just specify
> that is the behavior you want in an Object.notify(boolean:
> privilegewaiters)
> or some equivalent.
>
> Any insights?
>
>
>
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/Why-can-t-wait-set-T
hreads-be-privileged-tp9808.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-----
No virus found in this message.
Checked by AVG - www.avg.com
Version: 2013.0.3345 / Virus Database: 3204/6448 - Release Date: 06/28/13


From gergg at cox.net  Sun Jun 30 23:45:08 2013
From: gergg at cox.net (Gregg Wonderly)
Date: Sun, 30 Jun 2013 22:45:08 -0500
Subject: [concurrency-interest] Why can't wait-set Threads be privileged?
In-Reply-To: <uW5A1l00K02hR0p01W5PFw>
References: <1372559269449-9808.post@n7.nabble.com> <uW5A1l00K02hR0p01W5PFw>
Message-ID: <81A441E0-38C3-4826-A49F-614049B825B7@cox.net>

It's easy to add additional signatures for wait/notify to provide additional behaviors.  A List<Thread> could be added as an argument to wait/notify which was used to perform and ordering.  It could be a "queue" that wait enqueued threads to, and that notify peeled off elements from, to wake.  Clearly, you could implement your own such API to behave that way. The larger issue, is what makes sense as a JDK API because it could be tailored for better behavior/performance on different "OSes" vs what makes sense to provide API support for in the JDK so that applications can be more uniformly developed with predictable behaviors.

As a pair, wait/notify are pretty rarely used it seems to me.   I see a lot of wait/notifyAll instead, because most people are trying to use a single object with multiple threads, instead of passing multiple work items off to multiple threads, where a Queue is almost always a better choice with a single thread driving the use of a thread pool so that very little "contention" is actually occurring.

wait/notifyAll creates all kind of contention, and is most often used to "circulate" work amongst a pool of things.  With the queue on wait/notify, you get that behavior (processor/core mobility) without the contention that wait/notifyAll creates.

Gregg Wonderly

On Jun 30, 2013, at 1:03 AM, Ron Pressler <ron.pressler at gmail.com> wrote:

> This is not a technical limitation, but (probably) an API decision.
> 
> Object.wait/notify dates back to Java 1. It was not intended as a low-level synchronization-object-building toolkit, but as a high-level, everyday, bread-and-butter synchronization mechanism. Allowing the programmer to choose which particular thread to wake up doesn't make much sense within those goals.
> 
> j.u.c.locks, however, is a low-level synchronization-object-building toolkit, and you may use it in your hand-rolled constructs to LockSupport.unpark() whichever thread you like.
> 
> On Sun, Jun 30, 2013 at 5:27 AM, thurstonn <thurston at nomagicsoftware.com> wrote:
> So, in java the behavior of Object.wait and Object.notify():
> 
> Thread 1:
> 
> obj.wait() // Thread 1 is put in the wait-set
> 
> Thread 2:
> 
> obj.notify() // Select a Thread from the wait-set and move it to the
> *entry-set*
> 
> 
> 
> What I've always wondered is why there isn't some sort of 'overloaded'
> Object.notify(...) that would essentially do:
> whichever thread is selected from the notify() call, put it at the 'head' of
> the wait-set so that it will enter the monitor next. (Note: what I'm
> suggesting is not the same thing as the 'fairness' parameter to
> ReentrantLock, e.g.)
> 
> Obviously wait() and notify() are native methods, so what I'm wondering is:
> is this a limitation in modern OS's? CPUs?
> 
> I don't know enough about the actual implementation to know what the issues
> are, but this would definitely be a useful feature (think multi-producer,
> single-consumer, etc).
> 
> Of course there are other patterns that you can take to achieve similar
> results, but it would appear to be a lot simpler if you could just specify
> that is the behavior you want in an Object.notify(boolean: privilegewaiters)
> or some equivalent.
> 
> Any insights?
> 
> 
> 
> 
> 
> 
> --
> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Why-can-t-wait-set-Threads-be-privileged-tp9808.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130630/0dd98962/attachment.html>

