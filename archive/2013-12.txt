From pramalhe at gmail.com  Sun Dec  1 10:39:31 2013
From: pramalhe at gmail.com (Pedro Ramalhete)
Date: Sun, 1 Dec 2013 16:39:31 +0100
Subject: [concurrency-interest] ConcurrentHashMap.get() can sometimes fail
	to find a present key
Message-ID: <CAAApjO0VBhTkGe8UZyjcZY4-OfBHJVAdp59eNtaS0UEwKdwcbA@mail.gmail.com>

Hi,

There is an issue in ConcurrentHashMap.TreeBin.find().
It occurs when there is no (WRITER|WAITER) set in lockState and the thread
doing the get() tries to acquire the read-lock but fails the CAS. This
causes one iteration of the loop to advance because of the "e = e.next" in
the for() statement, thus skipping one of the keys in the list. Notice that
this can happen even if there are no ongoing mutating operations.

    for (Node<K,V> e = first; e != null; e = e.next) {
        int s; K ek;
        if (((s = lockState) & (WAITER|WRITER)) != 0) {
            if (...) return e;
        }
        else if (U.compareAndSwapInt(this, LOCKSTATE, s,
                                                 s + READER)) {
            (...)
            return p;
         }
     }

One possible fix is to move the "e = e.next" to be inside the first if()
statement, after the "return e;" expression:
2796c2796
<                 for (Node<K,V> e = first; e != null;) {
---
>                 for (Node<K,V> e = first; e != null; e = e.next) {
2802d2801
<                         e = e.next;


Andreia has written a small test with only containsKey() operations that
can show this issue in action, ran in a machine with 32 cores:
http://sourceforge.net/projects/ccfreaks/files/java/src/com/concurrencyfreaks/tests/TestValidationReads.java


Thanks,
Pedro
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131201/00f60c9c/attachment.html>

From dl at cs.oswego.edu  Sun Dec  1 11:08:45 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 01 Dec 2013 11:08:45 -0500
Subject: [concurrency-interest] ConcurrentHashMap.get() can sometimes
 fail to find a present key
In-Reply-To: <CAAApjO0VBhTkGe8UZyjcZY4-OfBHJVAdp59eNtaS0UEwKdwcbA@mail.gmail.com>
References: <CAAApjO0VBhTkGe8UZyjcZY4-OfBHJVAdp59eNtaS0UEwKdwcbA@mail.gmail.com>
Message-ID: <529B5F0D.6040001@cs.oswego.edu>

On 12/01/2013 10:39 AM, Pedro Ramalhete wrote:

> One possible fix is to move the "e = e.next" to be inside the first if()
> statement, after the "return e;" expression:
> 2796c2796
> <                 for (Node<K,V> e = first; e != null;) {
> ---
>  >                 for (Node<K,V> e = first; e != null; e = e.next) {
> 2802d2801
> <                         e = e.next;
>

Thanks! This is clearly the right thing to do here.
Coincidentally, there is also another related fix to CHM
committed today.

-Doug



From hans.boehm at hp.com  Sun Dec  1 14:58:06 2013
From: hans.boehm at hp.com (Boehm, Hans)
Date: Sun, 1 Dec 2013 19:58:06 +0000
Subject: [concurrency-interest] Single writer multiple readers no
 barriers -- safe ?
In-Reply-To: <CAHjP37EtmdQCCoBXpbktUr2q-E6KuKGO38r+Gkd8WONuWQsW=w@mail.gmail.com>
References: <CAHbGfh1-5txgrnPn3V1Ee5yY261Mg8_iaaaWAVJkSVo9wKTL8Q@mail.gmail.com>
	<CAHjP37EtmdQCCoBXpbktUr2q-E6KuKGO38r+Gkd8WONuWQsW=w@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD23D50EBAA@G9W0725.americas.hpqcorp.net>

From: Vitaly Davidovich

> AtomicReference.lazySet is the way to go here - on x86 this is just normal mov instruction with compiler barrier only (StoreStore).? .

You hopefully meant StoreStore | LoadStore .  Otherwise we have a very subtle but serious problem.  (See http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/no_write_fences.html for a C++ discussion from a few years ago.)

Hans


From vitalyd at gmail.com  Sun Dec  1 20:07:24 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Sun, 1 Dec 2013 20:07:24 -0500
Subject: [concurrency-interest] Single writer multiple readers no
 barriers -- safe ?
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD23D50EBAA@G9W0725.americas.hpqcorp.net>
References: <CAHbGfh1-5txgrnPn3V1Ee5yY261Mg8_iaaaWAVJkSVo9wKTL8Q@mail.gmail.com>
	<CAHjP37EtmdQCCoBXpbktUr2q-E6KuKGO38r+Gkd8WONuWQsW=w@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D50EBAA@G9W0725.americas.hpqcorp.net>
Message-ID: <CAHjP37HAzdGEeT1+mDwqrkZwg7v6YFnd8_CGfgFii3B0FbdPfg@mail.gmail.com>

Yes, prior loads can't move past lazySet either, AFAIK.  Although for this
example I think all that's important is the storestore portion.

Sent from my phone
On Dec 1, 2013 2:58 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:

> From: Vitaly Davidovich
>
> > AtomicReference.lazySet is the way to go here - on x86 this is just
> normal mov instruction with compiler barrier only (StoreStore).  .
>
> You hopefully meant StoreStore | LoadStore .  Otherwise we have a very
> subtle but serious problem.  (See
> http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/no_write_fences.html for
> a C++ discussion from a few years ago.)
>
> Hans
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131201/d42b721f/attachment.html>

From cheremin at gmail.com  Mon Dec  2 03:57:49 2013
From: cheremin at gmail.com (Cheremin Ruslan)
Date: Mon, 2 Dec 2013 12:57:49 +0400
Subject: [concurrency-interest] Volatile stores in constructors,
	disallowed to see the default value
In-Reply-To: <52964752.3020104@cs.oswego.edu>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
Message-ID: <C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>

Doug, could you explain why it is so important to have this kind of safe publication for volatile? I mean, could we just go with .value=0 through data race to be allowed result, as current model (seem to) imply? It seems to be a dr-case anyway, why we need special handling of it?

Ruslan

> 27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
> 
>> On 11/27/2013 02:06 PM, Vitaly Davidovich wrote:
>> But either
>> way, optimizations to avoid zeroing memory is an implementation detail and thus
>> cannot be relied upon from JMM standpoint, which I think you're saying.
>> 
>> The other issue is that even if we determine that volatiles don't get this
>> treatment, if JVM is already ensuring it, it's not going to be practical to
>> change it and risk hard to debug problems creeping in.  May as well update the
>> spec now ...
> 
> Right. To summarize:
> 
> * Programmers do not expect that even though final fields are specifically
> publication-safe, volatile fields are not always so.
> 
> * For various implementation reasons, JVMs arrange that
> volatile fields are publication safe anyway, at least in
> cases we know about.
> 
> * Actually updating the JMM/JLS to mandate this is not easy
> (no small tweak that I know applies). But now is a good time
> to be considering a full revision for JDK9.
> 
> * In the mean time, it would make sense to further test
> and validate JVMs as meeting this likely future spec.
> 
> -Doug
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From tomasz.kowalczewski at gmail.com  Mon Dec  2 04:02:09 2013
From: tomasz.kowalczewski at gmail.com (Tomasz Kowalczewski)
Date: Mon, 2 Dec 2013 10:02:09 +0100
Subject: [concurrency-interest] Single writer multiple readers no
 barriers -- safe ?
In-Reply-To: <CAHjP37HAzdGEeT1+mDwqrkZwg7v6YFnd8_CGfgFii3B0FbdPfg@mail.gmail.com>
References: <CAHbGfh1-5txgrnPn3V1Ee5yY261Mg8_iaaaWAVJkSVo9wKTL8Q@mail.gmail.com>
	<CAHjP37EtmdQCCoBXpbktUr2q-E6KuKGO38r+Gkd8WONuWQsW=w@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D50EBAA@G9W0725.americas.hpqcorp.net>
	<CAHjP37HAzdGEeT1+mDwqrkZwg7v6YFnd8_CGfgFii3B0FbdPfg@mail.gmail.com>
Message-ID: <CANTKXYmC9-cA=4jctJFPPU5rE3SZ=sB3OoaRJHj6EPZKsR-eHQ@mail.gmail.com>

Hi all,

I believe I am posting here for the first time and am certainly not an
expert on concurrency, but still would like to suggest (and stand corrected
if necessary) a possible solution to OP question. IFF the map is changed so
infrequently AND it is immutable then you can use invokedynamic to treat
the map reference as constant and deoptimize when the map changes as
described by Remi:

http://weblogs.java.net/blog/forax/archive/2011/12/17/jsr-292-goodness-almost-static-final-field



On Mon, Dec 2, 2013 at 2:07 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:

> Yes, prior loads can't move past lazySet either, AFAIK.  Although for this
> example I think all that's important is the storestore portion.
>
> Sent from my phone
> On Dec 1, 2013 2:58 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:
>
>> From: Vitaly Davidovich
>>
>> > AtomicReference.lazySet is the way to go here - on x86 this is just
>> normal mov instruction with compiler barrier only (StoreStore).  .
>>
>> You hopefully meant StoreStore | LoadStore .  Otherwise we have a very
>> subtle but serious problem.  (See
>> http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/no_write_fences.html for
>> a C++ discussion from a few years ago.)
>>
>> Hans
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Tomasz Kowalczewski
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131202/e77abbaf/attachment.html>

From dl at cs.oswego.edu  Mon Dec  2 06:02:25 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 02 Dec 2013 06:02:25 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
Message-ID: <529C68C1.2040100@cs.oswego.edu>

On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
> Doug, could you explain why it is so important to have this kind of safe
> publication for volatile? I mean, could we just go with .value=0 through data
> race to be allowed result, as current model (seem to) imply? It seems to be a
> dr-case anyway, why we need special handling of it?

The main reason is that it is highly irregular and unexpected
by programmers. Except in this case, volatiles definitionally cannot
be subject to data races. Dealing with it requires cleverness,
complexity, and/or error-proneness that isn't even required for
correctness on current JVMs. We have several constructions
in j.u.c that work around problems by using explicit ordered
writes in constructors, redundant-looking null-checks, and so
on. If we are going to repair the JMM anyway, this is a clear
candidate for reconsideration.

-Doug


>
> Ruslan
>
>> 27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>
>>> On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>> optimizations to avoid zeroing memory is an implementation detail and
>>> thus cannot be relied upon from JMM standpoint, which I think you're
>>> saying.
>>>
>>> The other issue is that even if we determine that volatiles don't get
>>> this treatment, if JVM is already ensuring it, it's not going to be
>>> practical to change it and risk hard to debug problems creeping in.  May
>>> as well update the spec now ...
>>
>> Right. To summarize:
>>
>> * Programmers do not expect that even though final fields are specifically
>> publication-safe, volatile fields are not always so.
>>
>> * For various implementation reasons, JVMs arrange that volatile fields are
>> publication safe anyway, at least in cases we know about.
>>
>> * Actually updating the JMM/JLS to mandate this is not easy (no small tweak
>> that I know applies). But now is a good time to be considering a full
>> revision for JDK9.
>>
>> * In the mean time, it would make sense to further test and validate JVMs
>> as meeting this likely future spec.
>>
>> -Doug
>>
>> _______________________________________________ Concurrency-interest
>> mailing list Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>




From yankee.sierra at gmail.com  Mon Dec  2 11:08:53 2013
From: yankee.sierra at gmail.com (Yuval Shavit)
Date: Mon, 2 Dec 2013 11:08:53 -0500
Subject: [concurrency-interest] Single writer multiple readers no
 barriers -- safe ?
In-Reply-To: <CANTKXYmC9-cA=4jctJFPPU5rE3SZ=sB3OoaRJHj6EPZKsR-eHQ@mail.gmail.com>
References: <CAHbGfh1-5txgrnPn3V1Ee5yY261Mg8_iaaaWAVJkSVo9wKTL8Q@mail.gmail.com>
	<CAHjP37EtmdQCCoBXpbktUr2q-E6KuKGO38r+Gkd8WONuWQsW=w@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D50EBAA@G9W0725.americas.hpqcorp.net>
	<CAHjP37HAzdGEeT1+mDwqrkZwg7v6YFnd8_CGfgFii3B0FbdPfg@mail.gmail.com>
	<CANTKXYmC9-cA=4jctJFPPU5rE3SZ=sB3OoaRJHj6EPZKsR-eHQ@mail.gmail.com>
Message-ID: <CAE+h5-BKq=HeHwvVOMQFAcv3W0wEawpmrMt7-8Q01RkyLHMXGQ@mail.gmail.com>

The thread safety issues are actually even worse than not seeing an update
-- you could see only *part* of an update, if the values aren't thread safe
in the absence of safe publication. Contrived example:

    public class MyUnsafeFoo {
        int i = 5; // not volatile or final

        public int getValue() {
            assert i == 5;
            return i;
        }
    }

If you put a MyUnsafeFoo into a HashMap with no memory barriers, another
thread could read that map and get a reference to the MyUnsafeFoo with i ==
0 (the initial value), which in this example breaks a class invariant.
Obviously this example is very simplified, but you can see the dangers
involved.


On Mon, Dec 2, 2013 at 4:02 AM, Tomasz Kowalczewski <
tomasz.kowalczewski at gmail.com> wrote:

> Hi all,
>
> I believe I am posting here for the first time and am certainly not an
> expert on concurrency, but still would like to suggest (and stand corrected
> if necessary) a possible solution to OP question. IFF the map is changed so
> infrequently AND it is immutable then you can use invokedynamic to treat
> the map reference as constant and deoptimize when the map changes as
> described by Remi:
>
>
> http://weblogs.java.net/blog/forax/archive/2011/12/17/jsr-292-goodness-almost-static-final-field
>
>
>
> On Mon, Dec 2, 2013 at 2:07 AM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>
>> Yes, prior loads can't move past lazySet either, AFAIK.  Although for
>> this example I think all that's important is the storestore portion.
>>
>> Sent from my phone
>> On Dec 1, 2013 2:58 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:
>>
>>> From: Vitaly Davidovich
>>>
>>> > AtomicReference.lazySet is the way to go here - on x86 this is just
>>> normal mov instruction with compiler barrier only (StoreStore).  .
>>>
>>> You hopefully meant StoreStore | LoadStore .  Otherwise we have a very
>>> subtle but serious problem.  (See
>>> http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/no_write_fences.htmlfor a C++ discussion from a few years ago.)
>>>
>>> Hans
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> --
> Tomasz Kowalczewski
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131202/2b048ec8/attachment-0001.html>

From zhong.j.yu at gmail.com  Mon Dec  2 13:12:14 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Mon, 2 Dec 2013 12:12:14 -0600
Subject: [concurrency-interest] Single writer multiple readers no
 barriers -- safe ?
In-Reply-To: <CANTKXYmC9-cA=4jctJFPPU5rE3SZ=sB3OoaRJHj6EPZKsR-eHQ@mail.gmail.com>
References: <CAHbGfh1-5txgrnPn3V1Ee5yY261Mg8_iaaaWAVJkSVo9wKTL8Q@mail.gmail.com>
	<CAHjP37EtmdQCCoBXpbktUr2q-E6KuKGO38r+Gkd8WONuWQsW=w@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D50EBAA@G9W0725.americas.hpqcorp.net>
	<CAHjP37HAzdGEeT1+mDwqrkZwg7v6YFnd8_CGfgFii3B0FbdPfg@mail.gmail.com>
	<CANTKXYmC9-cA=4jctJFPPU5rE3SZ=sB3OoaRJHj6EPZKsR-eHQ@mail.gmail.com>
Message-ID: <CACuKZqGdFLA6pJVbBaB0oPxg3hAfi=Gi1rLG7+vZ299VyoKTHg@mail.gmail.com>

On Mon, Dec 2, 2013 at 3:02 AM, Tomasz Kowalczewski
<tomasz.kowalczewski at gmail.com> wrote:
> Hi all,
>
> I believe I am posting here for the first time and am certainly not an
> expert on concurrency, but still would like to suggest (and stand corrected
> if necessary) a possible solution to OP question. IFF the map is changed so
> infrequently AND it is immutable then you can use invokedynamic to treat the

Does Remi's solution require the that map be immutable? Perhaps not.

> map reference as constant and deoptimize when the map changes as described

It's not a given that the cost of this solution is lower than the
simple `volatile` solution in this specific application.

> by Remi:
>
> http://weblogs.java.net/blog/forax/archive/2011/12/17/jsr-292-goodness-almost-static-final-field
>
>
>
> On Mon, Dec 2, 2013 at 2:07 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>>
>> Yes, prior loads can't move past lazySet either, AFAIK.  Although for this
>> example I think all that's important is the storestore portion.
>>
>> Sent from my phone
>>
>> On Dec 1, 2013 2:58 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:
>>>
>>> From: Vitaly Davidovich
>>>
>>> > AtomicReference.lazySet is the way to go here - on x86 this is just
>>> > normal mov instruction with compiler barrier only (StoreStore).  .
>>>
>>> You hopefully meant StoreStore | LoadStore .  Otherwise we have a very
>>> subtle but serious problem.  (See
>>> http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/no_write_fences.html for a
>>> C++ discussion from a few years ago.)
>>>
>>> Hans
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> --
> Tomasz Kowalczewski
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From tomasz.kowalczewski at gmail.com  Mon Dec  2 13:57:08 2013
From: tomasz.kowalczewski at gmail.com (Tomasz Kowalczewski)
Date: Mon, 2 Dec 2013 19:57:08 +0100
Subject: [concurrency-interest] Single writer multiple readers no
 barriers -- safe ?
In-Reply-To: <CACuKZqGdFLA6pJVbBaB0oPxg3hAfi=Gi1rLG7+vZ299VyoKTHg@mail.gmail.com>
References: <CAHbGfh1-5txgrnPn3V1Ee5yY261Mg8_iaaaWAVJkSVo9wKTL8Q@mail.gmail.com>
	<CAHjP37EtmdQCCoBXpbktUr2q-E6KuKGO38r+Gkd8WONuWQsW=w@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D50EBAA@G9W0725.americas.hpqcorp.net>
	<CAHjP37HAzdGEeT1+mDwqrkZwg7v6YFnd8_CGfgFii3B0FbdPfg@mail.gmail.com>
	<CANTKXYmC9-cA=4jctJFPPU5rE3SZ=sB3OoaRJHj6EPZKsR-eHQ@mail.gmail.com>
	<CACuKZqGdFLA6pJVbBaB0oPxg3hAfi=Gi1rLG7+vZ299VyoKTHg@mail.gmail.com>
Message-ID: <CANTKXYnY6cQaje-NcQ413tC3ZTODJSEvUvQU5cktEgL8yfEG8Q@mail.gmail.com>

On Mon, Dec 2, 2013 at 7:12 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> On Mon, Dec 2, 2013 at 3:02 AM, Tomasz Kowalczewski
> <tomasz.kowalczewski at gmail.com> wrote:
> > Hi all,
> >
> > I believe I am posting here for the first time and am certainly not an
> > expert on concurrency, but still would like to suggest (and stand
> corrected
> > if necessary) a possible solution to OP question. IFF the map is changed
> so
> > infrequently AND it is immutable then you can use invokedynamic to treat
> the
>
> Does Remi's solution require the that map be immutable? Perhaps not.
>
>
No, but it does not introduce any orderings plain load does not have.

 > map reference as constant and deoptimize when the map changes as
> described
>
> It's not a given that the cost of this solution is lower than the
> simple `volatile` solution in this specific application.
>
>
I would not use it before benchmarking it first (might be hard in a system
where map access is not the bottleneck) but accessing the map reference
should translate to plain load, so it is not more expensive than volatile
or atomic operations. This is assuming that:
- switch point invalidation is implemented as push (JVM safepoint and
deoptimization) and not pull (checking switch point state before every
reference load).
- map mutation is very infrequent (cost of a single safepoint per mutation
against cost paid on each access).


> > by Remi:
> >
> >
> http://weblogs.java.net/blog/forax/archive/2011/12/17/jsr-292-goodness-almost-static-final-field
> >
> >
> >
> > On Mon, Dec 2, 2013 at 2:07 AM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
> >>
> >> Yes, prior loads can't move past lazySet either, AFAIK.  Although for
> this
> >> example I think all that's important is the storestore portion.
> >>
> >> Sent from my phone
> >>
> >> On Dec 1, 2013 2:58 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:
> >>>
> >>> From: Vitaly Davidovich
> >>>
> >>> > AtomicReference.lazySet is the way to go here - on x86 this is just
> >>> > normal mov instruction with compiler barrier only (StoreStore).  .
> >>>
> >>> You hopefully meant StoreStore | LoadStore .  Otherwise we have a very
> >>> subtle but serious problem.  (See
> >>> http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/no_write_fences.htmlfor a
> >>> C++ discussion from a few years ago.)
> >>>
> >>> Hans
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >
> >
> >
> > --
> > Tomasz Kowalczewski
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>



-- 
Tomasz Kowalczewski
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131202/e3390aa0/attachment.html>

From zhong.j.yu at gmail.com  Mon Dec  2 14:05:49 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Mon, 2 Dec 2013 13:05:49 -0600
Subject: [concurrency-interest] Single writer multiple readers no
 barriers -- safe ?
In-Reply-To: <CANTKXYnY6cQaje-NcQ413tC3ZTODJSEvUvQU5cktEgL8yfEG8Q@mail.gmail.com>
References: <CAHbGfh1-5txgrnPn3V1Ee5yY261Mg8_iaaaWAVJkSVo9wKTL8Q@mail.gmail.com>
	<CAHjP37EtmdQCCoBXpbktUr2q-E6KuKGO38r+Gkd8WONuWQsW=w@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D50EBAA@G9W0725.americas.hpqcorp.net>
	<CAHjP37HAzdGEeT1+mDwqrkZwg7v6YFnd8_CGfgFii3B0FbdPfg@mail.gmail.com>
	<CANTKXYmC9-cA=4jctJFPPU5rE3SZ=sB3OoaRJHj6EPZKsR-eHQ@mail.gmail.com>
	<CACuKZqGdFLA6pJVbBaB0oPxg3hAfi=Gi1rLG7+vZ299VyoKTHg@mail.gmail.com>
	<CANTKXYnY6cQaje-NcQ413tC3ZTODJSEvUvQU5cktEgL8yfEG8Q@mail.gmail.com>
Message-ID: <CACuKZqEaZvVTotBpcEN3hENu=C63fosjx6BHp+AAKgKPmchLNQ@mail.gmail.com>

On Mon, Dec 2, 2013 at 12:57 PM, Tomasz Kowalczewski
<tomasz.kowalczewski at gmail.com> wrote:
> On Mon, Dec 2, 2013 at 7:12 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>
>> On Mon, Dec 2, 2013 at 3:02 AM, Tomasz Kowalczewski
>> <tomasz.kowalczewski at gmail.com> wrote:
>> > Hi all,
>> >
>> > I believe I am posting here for the first time and am certainly not an
>> > expert on concurrency, but still would like to suggest (and stand
>> > corrected
>> > if necessary) a possible solution to OP question. IFF the map is changed
>> > so
>> > infrequently AND it is immutable then you can use invokedynamic to treat
>> > the
>>
>> Does Remi's solution require the that map be immutable? Perhaps not.
>>
>
> No, but it does not introduce any orderings plain load does not have.

It seems to me that the code contains enough synchronizations to
guarantee safe publication of `value`.

>
>> > map reference as constant and deoptimize when the map changes as
>> > described
>>
>> It's not a given that the cost of this solution is lower than the
>> simple `volatile` solution in this specific application.
>>
>
> I would not use it before benchmarking it first (might be hard in a system
> where map access is not the bottleneck) but accessing the map reference
> should translate to plain load, so it is not more expensive than volatile or
> atomic operations. This is assuming that:
> - switch point invalidation is implemented as push (JVM safepoint and
> deoptimization) and not pull (checking switch point state before every
> reference load).
> - map mutation is very infrequent (cost of a single safepoint per mutation
> against cost paid on each access).

How much havoc the deoptimization will trigger throughout the VM? Does
it seriously impact the performance on the spot? Would the application
choke every 5 minutes?

>
>>
>> > by Remi:
>> >
>> >
>> > http://weblogs.java.net/blog/forax/archive/2011/12/17/jsr-292-goodness-almost-static-final-field
>> >
>> >
>> >
>> > On Mon, Dec 2, 2013 at 2:07 AM, Vitaly Davidovich <vitalyd at gmail.com>
>> > wrote:
>> >>
>> >> Yes, prior loads can't move past lazySet either, AFAIK.  Although for
>> >> this
>> >> example I think all that's important is the storestore portion.
>> >>
>> >> Sent from my phone
>> >>
>> >> On Dec 1, 2013 2:58 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:
>> >>>
>> >>> From: Vitaly Davidovich
>> >>>
>> >>> > AtomicReference.lazySet is the way to go here - on x86 this is just
>> >>> > normal mov instruction with compiler barrier only (StoreStore).  .
>> >>>
>> >>> You hopefully meant StoreStore | LoadStore .  Otherwise we have a very
>> >>> subtle but serious problem.  (See
>> >>> http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/no_write_fences.html
>> >>> for a
>> >>> C++ discussion from a few years ago.)
>> >>>
>> >>> Hans
>> >>
>> >>
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>
>> >
>> >
>> >
>> > --
>> > Tomasz Kowalczewski
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>
>
>
>
> --
> Tomasz Kowalczewski

From tomasz.kowalczewski at gmail.com  Mon Dec  2 14:10:23 2013
From: tomasz.kowalczewski at gmail.com (Tomasz Kowalczewski)
Date: Mon, 2 Dec 2013 20:10:23 +0100
Subject: [concurrency-interest] Single writer multiple readers no
 barriers -- safe ?
In-Reply-To: <CACuKZqEaZvVTotBpcEN3hENu=C63fosjx6BHp+AAKgKPmchLNQ@mail.gmail.com>
References: <CAHbGfh1-5txgrnPn3V1Ee5yY261Mg8_iaaaWAVJkSVo9wKTL8Q@mail.gmail.com>
	<CAHjP37EtmdQCCoBXpbktUr2q-E6KuKGO38r+Gkd8WONuWQsW=w@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D50EBAA@G9W0725.americas.hpqcorp.net>
	<CAHjP37HAzdGEeT1+mDwqrkZwg7v6YFnd8_CGfgFii3B0FbdPfg@mail.gmail.com>
	<CANTKXYmC9-cA=4jctJFPPU5rE3SZ=sB3OoaRJHj6EPZKsR-eHQ@mail.gmail.com>
	<CACuKZqGdFLA6pJVbBaB0oPxg3hAfi=Gi1rLG7+vZ299VyoKTHg@mail.gmail.com>
	<CANTKXYnY6cQaje-NcQ413tC3ZTODJSEvUvQU5cktEgL8yfEG8Q@mail.gmail.com>
	<CACuKZqEaZvVTotBpcEN3hENu=C63fosjx6BHp+AAKgKPmchLNQ@mail.gmail.com>
Message-ID: <CANTKXY=FqATKEOzEfe_smyJKfYbFLUieVGqAj9K=tM2-brD0KQ@mail.gmail.com>

On Mon, Dec 2, 2013 at 8:05 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> On Mon, Dec 2, 2013 at 12:57 PM, Tomasz Kowalczewski
> <tomasz.kowalczewski at gmail.com> wrote:
> > On Mon, Dec 2, 2013 at 7:12 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
> >>
> >> On Mon, Dec 2, 2013 at 3:02 AM, Tomasz Kowalczewski
> >> <tomasz.kowalczewski at gmail.com> wrote:
> >> > Hi all,
> >> >
> >> > I believe I am posting here for the first time and am certainly not an
> >> > expert on concurrency, but still would like to suggest (and stand
> >> > corrected
> >> > if necessary) a possible solution to OP question. IFF the map is
> changed
> >> > so
> >> > infrequently AND it is immutable then you can use invokedynamic to
> treat
> >> > the
> >>
> >> Does Remi's solution require the that map be immutable? Perhaps not.
> >>
> >
> > No, but it does not introduce any orderings plain load does not have.
>
> It seems to me that the code contains enough synchronizations to
> guarantee safe publication of `value`.
>
> >
> >> > map reference as constant and deoptimize when the map changes as
> >> > described
> >>
> >> It's not a given that the cost of this solution is lower than the
> >> simple `volatile` solution in this specific application.
> >>
> >
> > I would not use it before benchmarking it first (might be hard in a
> system
> > where map access is not the bottleneck) but accessing the map reference
> > should translate to plain load, so it is not more expensive than
> volatile or
> > atomic operations. This is assuming that:
> > - switch point invalidation is implemented as push (JVM safepoint and
> > deoptimization) and not pull (checking switch point state before every
> > reference load).
> > - map mutation is very infrequent (cost of a single safepoint per
> mutation
> > against cost paid on each access).
>
> How much havoc the deoptimization will trigger throughout the VM? Does
> it seriously impact the performance on the spot? Would the application
> choke every 5 minutes?
>
>
Depends on the application, but it might be already chocking doing STW
minor GC every few seconds. Is deoptimization that much more expensive?
Either way benchmarking it on production grade traffic it the way to go.

>
> >>
> >> > by Remi:
> >> >
> >> >
> >> >
> http://weblogs.java.net/blog/forax/archive/2011/12/17/jsr-292-goodness-almost-static-final-field
> >> >
> >> >
> >> >
> >> > On Mon, Dec 2, 2013 at 2:07 AM, Vitaly Davidovich <vitalyd at gmail.com>
> >> > wrote:
> >> >>
> >> >> Yes, prior loads can't move past lazySet either, AFAIK.  Although for
> >> >> this
> >> >> example I think all that's important is the storestore portion.
> >> >>
> >> >> Sent from my phone
> >> >>
> >> >> On Dec 1, 2013 2:58 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:
> >> >>>
> >> >>> From: Vitaly Davidovich
> >> >>>
> >> >>> > AtomicReference.lazySet is the way to go here - on x86 this is
> just
> >> >>> > normal mov instruction with compiler barrier only (StoreStore).  .
> >> >>>
> >> >>> You hopefully meant StoreStore | LoadStore .  Otherwise we have a
> very
> >> >>> subtle but serious problem.  (See
> >> >>>
> http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/no_write_fences.html
> >> >>> for a
> >> >>> C++ discussion from a few years ago.)
> >> >>>
> >> >>> Hans
> >> >>
> >> >>
> >> >> _______________________________________________
> >> >> Concurrency-interest mailing list
> >> >> Concurrency-interest at cs.oswego.edu
> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>
> >> >
> >> >
> >> >
> >> > --
> >> > Tomasz Kowalczewski
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >
> >
> >
> >
> > --
> > Tomasz Kowalczewski
>



-- 
Tomasz Kowalczewski
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131202/78beecde/attachment-0001.html>

From taras.tielkes at gmail.com  Mon Dec  2 14:22:39 2013
From: taras.tielkes at gmail.com (Taras Tielkes)
Date: Mon, 2 Dec 2013 20:22:39 +0100
Subject: [concurrency-interest] Semaphore with queue limit
Message-ID: <CA+R7V7_c2BPtTQtEZmm6pontrreXt2XeMrbP7shCkWZci+Hn5w@mail.gmail.com>

Hi,

In a system handling concurrent external requests, I'd like to limit the
concurrency level of an internal component. In addition to FIFO semantics,
I'd like to put a bound on the time spent waiting for a permit to propagate
the call to the internal component.

A Semaphore in fair mode, using tryAcquire(timeout) seems to satisfy these
requirements.

However, in addition, I'd like to also put a bound in the queue of this
semaphore.
If 100 threads are either holding a permit, or waiting to acquire one, I'd
like to pro-actively reject thread 101.

Is there something in j.u.c. that would satisfy this use case? The best I
can come up with is an additional "external" non-fair semaphore (with a
larger permit set) that gets acquired before attempting to acquire a permit
from the "internal" fair one.

Thanks in advance,
-tt
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131202/dc44971b/attachment.html>

From cheremin at gmail.com  Mon Dec  2 14:32:25 2013
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Mon, 2 Dec 2013 23:32:25 +0400
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529C68C1.2040100@cs.oswego.edu>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
Message-ID: <CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>

Well, I do not see any data race _on volatiles_ here. I see race condition
on volatile .value, yes -- but it is pretty legal (and unavoidable, I
suppose) to have race conditions even with volatiles involved. The only
data race I see is around read-write of (non-volatile) AtomicInteger's
reference -- which is unrelated to AtomicInteger's content. I mean, I could
not see any noticable difference between the case discussed, and just any
other case there volatile is _incorrectly_ used to "synchronize" data
accesses -- it could still be data race on non-volatile fields, even if
volatile fields are also used somewhere around. Yes, get 0 from .value is
unexpected -- but there are many unexpected things in memory models. It is
noway more unexpected then to see default values in fields of any other
object which is unsafely published. I think everybody who passed through
broken atomicity of constructor call could easy see the chance to read
[.value=0] in the case discussed.

"Data race is pure evil" was the motto of this list all time I was reading
it. Why do we may want to introduce another example of benign race?
Wouldn't it be just another source of confusion for newcomers?




2013/12/2 Doug Lea <dl at cs.oswego.edu>

> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>
>> Doug, could you explain why it is so important to have this kind of safe
>> publication for volatile? I mean, could we just go with .value=0 through
>> data
>> race to be allowed result, as current model (seem to) imply? It seems to
>> be a
>> dr-case anyway, why we need special handling of it?
>>
>
> The main reason is that it is highly irregular and unexpected
> by programmers. Except in this case, volatiles definitionally cannot
> be subject to data races. Dealing with it requires cleverness,
> complexity, and/or error-proneness that isn't even required for
> correctness on current JVMs. We have several constructions
> in j.u.c that work around problems by using explicit ordered
> writes in constructors, redundant-looking null-checks, and so
> on. If we are going to repair the JMM anyway, this is a clear
> candidate for reconsideration.
>
> -Doug
>
>
>
>
>> Ruslan
>>
>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>>
>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>> optimizations to avoid zeroing memory is an implementation detail and
>>>> thus cannot be relied upon from JMM standpoint, which I think you're
>>>> saying.
>>>>
>>>> The other issue is that even if we determine that volatiles don't get
>>>> this treatment, if JVM is already ensuring it, it's not going to be
>>>> practical to change it and risk hard to debug problems creeping in.  May
>>>> as well update the spec now ...
>>>>
>>>
>>> Right. To summarize:
>>>
>>> * Programmers do not expect that even though final fields are
>>> specifically
>>> publication-safe, volatile fields are not always so.
>>>
>>> * For various implementation reasons, JVMs arrange that volatile fields
>>> are
>>> publication safe anyway, at least in cases we know about.
>>>
>>> * Actually updating the JMM/JLS to mandate this is not easy (no small
>>> tweak
>>> that I know applies). But now is a good time to be considering a full
>>> revision for JDK9.
>>>
>>> * In the mean time, it would make sense to further test and validate JVMs
>>> as meeting this likely future spec.
>>>
>>> -Doug
>>>
>>> _______________________________________________ Concurrency-interest
>>> mailing list Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131202/cbfc0be1/attachment.html>

From vitalyd at gmail.com  Mon Dec  2 14:33:57 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 2 Dec 2013 14:33:57 -0500
Subject: [concurrency-interest] Single writer multiple readers no
 barriers -- safe ?
In-Reply-To: <CANTKXY=FqATKEOzEfe_smyJKfYbFLUieVGqAj9K=tM2-brD0KQ@mail.gmail.com>
References: <CAHbGfh1-5txgrnPn3V1Ee5yY261Mg8_iaaaWAVJkSVo9wKTL8Q@mail.gmail.com>
	<CAHjP37EtmdQCCoBXpbktUr2q-E6KuKGO38r+Gkd8WONuWQsW=w@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D50EBAA@G9W0725.americas.hpqcorp.net>
	<CAHjP37HAzdGEeT1+mDwqrkZwg7v6YFnd8_CGfgFii3B0FbdPfg@mail.gmail.com>
	<CANTKXYmC9-cA=4jctJFPPU5rE3SZ=sB3OoaRJHj6EPZKsR-eHQ@mail.gmail.com>
	<CACuKZqGdFLA6pJVbBaB0oPxg3hAfi=Gi1rLG7+vZ299VyoKTHg@mail.gmail.com>
	<CANTKXYnY6cQaje-NcQ413tC3ZTODJSEvUvQU5cktEgL8yfEG8Q@mail.gmail.com>
	<CACuKZqEaZvVTotBpcEN3hENu=C63fosjx6BHp+AAKgKPmchLNQ@mail.gmail.com>
	<CANTKXY=FqATKEOzEfe_smyJKfYbFLUieVGqAj9K=tM2-brD0KQ@mail.gmail.com>
Message-ID: <CAHjP37FJKsMnWbns9BKFL0ZBzeK52K0G80pRJj3ry=DQdAM0qA@mail.gmail.com>

Problem with deopt is you have to warm up the method again.  Also, if JIT
sees too many deopts, it may stop compiling that method completely.  I'd
just stick with ordered operations.

Sent from my phone
On Dec 2, 2013 2:10 PM, "Tomasz Kowalczewski" <tomasz.kowalczewski at gmail.com>
wrote:

>
>
>
> On Mon, Dec 2, 2013 at 8:05 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>
>> On Mon, Dec 2, 2013 at 12:57 PM, Tomasz Kowalczewski
>> <tomasz.kowalczewski at gmail.com> wrote:
>> > On Mon, Dec 2, 2013 at 7:12 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>> >>
>> >> On Mon, Dec 2, 2013 at 3:02 AM, Tomasz Kowalczewski
>> >> <tomasz.kowalczewski at gmail.com> wrote:
>> >> > Hi all,
>> >> >
>> >> > I believe I am posting here for the first time and am certainly not
>> an
>> >> > expert on concurrency, but still would like to suggest (and stand
>> >> > corrected
>> >> > if necessary) a possible solution to OP question. IFF the map is
>> changed
>> >> > so
>> >> > infrequently AND it is immutable then you can use invokedynamic to
>> treat
>> >> > the
>> >>
>> >> Does Remi's solution require the that map be immutable? Perhaps not.
>> >>
>> >
>> > No, but it does not introduce any orderings plain load does not have.
>>
>> It seems to me that the code contains enough synchronizations to
>> guarantee safe publication of `value`.
>>
>> >
>> >> > map reference as constant and deoptimize when the map changes as
>> >> > described
>> >>
>> >> It's not a given that the cost of this solution is lower than the
>> >> simple `volatile` solution in this specific application.
>> >>
>> >
>> > I would not use it before benchmarking it first (might be hard in a
>> system
>> > where map access is not the bottleneck) but accessing the map reference
>> > should translate to plain load, so it is not more expensive than
>> volatile or
>> > atomic operations. This is assuming that:
>> > - switch point invalidation is implemented as push (JVM safepoint and
>> > deoptimization) and not pull (checking switch point state before every
>> > reference load).
>> > - map mutation is very infrequent (cost of a single safepoint per
>> mutation
>> > against cost paid on each access).
>>
>> How much havoc the deoptimization will trigger throughout the VM? Does
>> it seriously impact the performance on the spot? Would the application
>> choke every 5 minutes?
>>
>>
> Depends on the application, but it might be already chocking doing STW
> minor GC every few seconds. Is deoptimization that much more expensive?
> Either way benchmarking it on production grade traffic it the way to go.
>
> >
>> >>
>> >> > by Remi:
>> >> >
>> >> >
>> >> >
>> http://weblogs.java.net/blog/forax/archive/2011/12/17/jsr-292-goodness-almost-static-final-field
>> >> >
>> >> >
>> >> >
>> >> > On Mon, Dec 2, 2013 at 2:07 AM, Vitaly Davidovich <vitalyd at gmail.com
>> >
>> >> > wrote:
>> >> >>
>> >> >> Yes, prior loads can't move past lazySet either, AFAIK.  Although
>> for
>> >> >> this
>> >> >> example I think all that's important is the storestore portion.
>> >> >>
>> >> >> Sent from my phone
>> >> >>
>> >> >> On Dec 1, 2013 2:58 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:
>> >> >>>
>> >> >>> From: Vitaly Davidovich
>> >> >>>
>> >> >>> > AtomicReference.lazySet is the way to go here - on x86 this is
>> just
>> >> >>> > normal mov instruction with compiler barrier only (StoreStore).
>>  .
>> >> >>>
>> >> >>> You hopefully meant StoreStore | LoadStore .  Otherwise we have a
>> very
>> >> >>> subtle but serious problem.  (See
>> >> >>>
>> http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/no_write_fences.html
>> >> >>> for a
>> >> >>> C++ discussion from a few years ago.)
>> >> >>>
>> >> >>> Hans
>> >> >>
>> >> >>
>> >> >> _______________________________________________
>> >> >> Concurrency-interest mailing list
>> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >>
>> >> >
>> >> >
>> >> >
>> >> > --
>> >> > Tomasz Kowalczewski
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >
>> >
>> >
>> >
>> > --
>> > Tomasz Kowalczewski
>>
>
>
>
> --
> Tomasz Kowalczewski
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131202/46e018e0/attachment.html>

From heinz at javaspecialists.eu  Mon Dec  2 15:15:41 2013
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Mon, 02 Dec 2013 22:15:41 +0200
Subject: [concurrency-interest] StampedLock Article
Message-ID: <529CEA6D.9070301@javaspecialists.eu>

For those of you interested in the Java 8 StampedLock construct here is 
my first article on the subject.  I plan to write another two on this 
new synchronizer, based on a bunch of talks I've given and research I've 
done on the performance and use cases.

http://www.javaspecialists.eu/archive/Issue215.html

Regards

Heinz
-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Oracle Java Champion 2005-2013
JavaOne Rock Star Speaker 2012
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz


From oleksandr.otenko at oracle.com  Mon Dec  2 15:17:08 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Mon, 02 Dec 2013 20:17:08 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
Message-ID: <529CEAC4.7080409@oracle.com>

I think it is pretty simple.

If you always mean a store-store barrier /after/ the last volatile store 
in the constructor, then add that barrier into constructor semantics, 
like it's done with the final fields.

It makes sense to /not/ add it to the semantics, if you can come up with 
enough examples where you want that barrier to be eliminated.

Alex

On 02/12/2013 19:32, Ruslan Cheremin wrote:
> Well, I do not see any data race _on volatiles_ here. I see race 
> condition on volatile .value, yes -- but it is pretty legal (and 
> unavoidable, I suppose) to have race conditions even with volatiles 
> involved. The only data race I see is around read-write of 
> (non-volatile) AtomicInteger's reference -- which is unrelated to 
> AtomicInteger's content. I mean, I could not see any noticable 
> difference between the case discussed, and just any other case there 
> volatile is _incorrectly_ used to "synchronize" data accesses -- it 
> could still be data race on non-volatile fields, even if volatile 
> fields are also used somewhere around. Yes, get 0 from .value is 
> unexpected -- but there are many unexpected things in memory models. 
> It is noway more unexpected then to see default values in fields of 
> any other object which is unsafely published. I think everybody who 
> passed through broken atomicity of constructor call could easy see the 
> chance to read [.value=0] in the case discussed.
>
> "Data race is pure evil" was the motto of this list all time I was 
> reading it. Why do we may want to introduce another example of benign 
> race? Wouldn't it be just another source of confusion for newcomers?
>
>
>
>
> 2013/12/2 Doug Lea <dl at cs.oswego.edu <mailto:dl at cs.oswego.edu>>
>
>     On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>
>         Doug, could you explain why it is so important to have this
>         kind of safe
>         publication for volatile? I mean, could we just go with
>         .value=0 through data
>         race to be allowed result, as current model (seem to) imply?
>         It seems to be a
>         dr-case anyway, why we need special handling of it?
>
>
>     The main reason is that it is highly irregular and unexpected
>     by programmers. Except in this case, volatiles definitionally cannot
>     be subject to data races. Dealing with it requires cleverness,
>     complexity, and/or error-proneness that isn't even required for
>     correctness on current JVMs. We have several constructions
>     in j.u.c that work around problems by using explicit ordered
>     writes in constructors, redundant-looking null-checks, and so
>     on. If we are going to repair the JMM anyway, this is a clear
>     candidate for reconsideration.
>
>     -Doug
>
>
>
>
>         Ruslan
>
>             27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu
>             <mailto:dl at cs.oswego.edu>> ???????(?):
>
>                 On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But
>                 either way,
>                 optimizations to avoid zeroing memory is an
>                 implementation detail and
>                 thus cannot be relied upon from JMM standpoint, which
>                 I think you're
>                 saying.
>
>                 The other issue is that even if we determine that
>                 volatiles don't get
>                 this treatment, if JVM is already ensuring it, it's
>                 not going to be
>                 practical to change it and risk hard to debug problems
>                 creeping in.  May
>                 as well update the spec now ...
>
>
>             Right. To summarize:
>
>             * Programmers do not expect that even though final fields
>             are specifically
>             publication-safe, volatile fields are not always so.
>
>             * For various implementation reasons, JVMs arrange that
>             volatile fields are
>             publication safe anyway, at least in cases we know about.
>
>             * Actually updating the JMM/JLS to mandate this is not
>             easy (no small tweak
>             that I know applies). But now is a good time to be
>             considering a full
>             revision for JDK9.
>
>             * In the mean time, it would make sense to further test
>             and validate JVMs
>             as meeting this likely future spec.
>
>             -Doug
>
>             _______________________________________________
>             Concurrency-interest
>             mailing list Concurrency-interest at cs.oswego.edu
>             <mailto:Concurrency-interest at cs.oswego.edu>
>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131202/226b942c/attachment.html>

From ariel at weisberg.ws  Mon Dec  2 15:21:10 2013
From: ariel at weisberg.ws (Ariel Weisberg)
Date: Mon, 02 Dec 2013 15:21:10 -0500
Subject: [concurrency-interest] Semaphore with queue limit
In-Reply-To: <CA+R7V7_c2BPtTQtEZmm6pontrreXt2XeMrbP7shCkWZci+Hn5w@mail.gmail.com>
References: <CA+R7V7_c2BPtTQtEZmm6pontrreXt2XeMrbP7shCkWZci+Hn5w@mail.gmail.com>
Message-ID: <1386015670.3890.54612889.797E9A5D@webmail.messagingengine.com>

Hi,



Unless task size for each permit/request is pretty small I would use
two semaphores as you described.



Alternatively a bounded queue for passing requests to the internal
component would do this for you. Populate the queue with some form of
future and have the threads wait on the futures.



Regards,

Ariel





On Mon, Dec 2, 2013, at 02:22 PM, Taras Tielkes wrote:

Hi,

In a system handling concurrent external requests, I'd like to limit
the concurrency level of an internal component. In addition to FIFO
semantics, I'd like to put a bound on the time spent waiting for a
permit to propagate the call to the internal component.

A Semaphore in fair mode, using tryAcquire(timeout) seems to satisfy
these requirements.

However, in addition, I'd like to also put a bound in the queue of this
semaphore.
If 100 threads are either holding a permit, or waiting to acquire one,
I'd like to pro-actively reject thread 101.

Is there something in j.u.c. that would satisfy this use case? The best
I can come up with is an additional "external" non-fair semaphore (with
a larger permit set) that gets acquired before attempting to acquire a
permit from the "internal" fair one.

Thanks in advance,
-tt


_______________________________________________

Concurrency-interest mailing list

[1]Concurrency-interest at cs.oswego.edu

[2]http://cs.oswego.edu/mailman/listinfo/concurrency-interest

References

1. mailto:Concurrency-interest at cs.oswego.edu
2. http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131202/cf41b77f/attachment.html>

From ariel at weisberg.ws  Mon Dec  2 16:16:00 2013
From: ariel at weisberg.ws (Ariel Weisberg)
Date: Mon, 02 Dec 2013 16:16:00 -0500
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <529CEA6D.9070301@javaspecialists.eu>
References: <529CEA6D.9070301@javaspecialists.eu>
Message-ID: <1386018960.23958.54626153.09547351@webmail.messagingengine.com>

Hi,

Thanks for writing this up. I have been wondering what the use case for
StampedLock is and where it can perform better.

After reading your post I am still not sure when I should use the
upgrade/optimistic features of stamped lock in place of CASing immutable
objects (maybe for expensive to copy things?). What effect does
performing optimistic reads have WRT to bouncing around cache lines that
are needed on the processor that currently holds the write lock?

I can also see the optimistic read failing for any complex set of
objects requiring invariant to be maintained for safe access (array out
of bounds etc).

I am also not clear on how it is universally better for plain locking or
pessimistic locking. I'll admit I didn't know about the issue with
locking in the try block so that is a definite improvement and nice to
bring in along with the new features.

Rambling a bit on my own personal usage of locking.

In practice I don't use ReentrantLock yet because the cases where I use
locking aren't performance critical so I end up using synchronized and
with biased locking this might actually be close to free. Most other
cases it is CASing immutable objects or publishing via thread safe maps
or using a single writer thread to process updates.

I can think of two performance sensitive pieces of code I work on that
use locking. One is an NIO framework that enforces many restrictions on
send that would be difficult to make absolute guarantees about without
locking. The other is a transaction scheduler that really shouldn't use
locking and would probably benefit from ReentrantLock, but that is
really just papering over the fact that it should be single writer.

To a large degree I see locking as a fallback for the stuff you really
don't care about in which case the choice of lock doesn't seem that
important. If you care you should be writing thread per core event based
code with event threads not sharing state (other then long lived
immutable state). Java and Guava's excellent primitives make this much
easier then it otherwise might be.

Regards,
Ariel

On Mon, Dec 2, 2013, at 03:15 PM, Dr Heinz M. Kabutz wrote:
> For those of you interested in the Java 8 StampedLock construct here is 
> my first article on the subject.  I plan to write another two on this 
> new synchronizer, based on a bunch of talks I've given and research I've 
> done on the performance and use cases.
> 
> http://www.javaspecialists.eu/archive/Issue215.html
> 
> Regards
> 
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Oracle Java Champion 2005-2013
> JavaOne Rock Star Speaker 2012
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From nathan.reynolds at oracle.com  Mon Dec  2 17:02:53 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 02 Dec 2013 15:02:53 -0700
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <1386018960.23958.54626153.09547351@webmail.messagingengine.com>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
Message-ID: <529D038D.2000908@oracle.com>


-Nathan

On 12/2/2013 2:16 PM, Ariel Weisberg wrote:
> Hi,
>
> Thanks for writing this up. I have been wondering what the use case for
> StampedLock is and where it can perform better.
>
> After reading your post I am still not sure when I should use the
> upgrade/optimistic features of stamped lock in place of CASing immutable
> objects (maybe for expensive to copy things?). What effect does
> performing optimistic reads have WRT to bouncing around cache lines that
> are needed on the processor that currently holds the write lock?
>
> I can also see the optimistic read failing for any complex set of
> objects requiring invariant to be maintained for safe access (array out
> of bounds etc).
>
> I am also not clear on how it is universally better for plain locking or
> pessimistic locking. I'll admit I didn't know about the issue with
> locking in the try block so that is a definite improvement and nice to
> bring in along with the new features.
A while back, I sent an email suggesting we add lock() default methods 
to the Lock interface.  These methods would help eliminate problems such 
as locking in the try block.  It would also reduce the amount of 
cookie-cutter code needed for explicit locks and make explicit locks a 
little safer to use like synchronized blocks.

m_lock.lock({
/code inside a lambda/
});
>
> Rambling a bit on my own personal usage of locking.
>
> In practice I don't use ReentrantLock yet because the cases where I use
> locking aren't performance critical so I end up using synchronized and
> with biased locking this might actually be close to free. Most other
> cases it is CASing immutable objects or publishing via thread safe maps
> or using a single writer thread to process updates.
>
> I can think of two performance sensitive pieces of code I work on that
> use locking. One is an NIO framework that enforces many restrictions on
> send that would be difficult to make absolute guarantees about without
> locking. The other is a transaction scheduler that really shouldn't use
> locking and would probably benefit from ReentrantLock, but that is
> really just papering over the fact that it should be single writer.
>
> To a large degree I see locking as a fallback for the stuff you really
> don't care about in which case the choice of lock doesn't seem that
> important. If you care you should be writing thread per core event based
> code with event threads not sharing state (other then long lived
> immutable state). Java and Guava's excellent primitives make this much
> easier then it otherwise might be.
>
> Regards,
> Ariel
>
> On Mon, Dec 2, 2013, at 03:15 PM, Dr Heinz M. Kabutz wrote:
>> For those of you interested in the Java 8 StampedLock construct here is
>> my first article on the subject.  I plan to write another two on this
>> new synchronizer, based on a bunch of talks I've given and research I've
>> done on the performance and use cases.
>>
>> http://www.javaspecialists.eu/archive/Issue215.html
>>
>> Regards
>>
>> Heinz
>> -- 
>> Dr Heinz M. Kabutz (PhD CompSci)
>> Author of "The Java(tm) Specialists' Newsletter"
>> Oracle Java Champion 2005-2013
>> JavaOne Rock Star Speaker 2012
>> http://www.javaspecialists.eu
>> Tel: +30 69 75 595 262
>> Skype: kabutz
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131202/bb8060e3/attachment-0001.html>

From vitalyd at gmail.com  Mon Dec  2 21:31:16 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 2 Dec 2013 21:31:16 -0500
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <1386018960.23958.54626153.09547351@webmail.messagingengine.com>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
Message-ID: <CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>

Right, it's a bit unclear on what a good case for this lock is.  I'm
guessing the advantage is if you use the optimistic version - that avoids
any expensive stores and doesn't block writers - for tiny read code
sections on locks that are read-mostly.  Otherwise, seems like it may not
perform all that well (e.g. validate() missing in cache because another
core wrote to the lock in the meantime).

Builtin synchronizer (I.e synchronized keyword) for small/cheap code
sections that don't contend seems decent enough.  Biased locking +
(adaptive) spinning should, in theory, be good enough for these cases.

Also, one other thing synchronized has going for it is it handles async
aborts of threads (I.e. thread.stop()).  I know stop() is deprecated and
all, but you never know.  Using locks with try/finally won't cause the lock
to be released if thread is aborted after the lock but before try block
enters.  In .NET, they actually modified the corresponding API to set an
out parameter if lock was successfully taken (you execute this inside try
block) and you check that in finally block before unlocking.  There's also
an API to let CLR know that code is executing a critical region, which can
cause abort to be raised only after section is exited.

Sent from my phone
On Dec 2, 2013 4:26 PM, "Ariel Weisberg" <ariel at weisberg.ws> wrote:

> Hi,
>
> Thanks for writing this up. I have been wondering what the use case for
> StampedLock is and where it can perform better.
>
> After reading your post I am still not sure when I should use the
> upgrade/optimistic features of stamped lock in place of CASing immutable
> objects (maybe for expensive to copy things?). What effect does
> performing optimistic reads have WRT to bouncing around cache lines that
> are needed on the processor that currently holds the write lock?
>
> I can also see the optimistic read failing for any complex set of
> objects requiring invariant to be maintained for safe access (array out
> of bounds etc).
>
> I am also not clear on how it is universally better for plain locking or
> pessimistic locking. I'll admit I didn't know about the issue with
> locking in the try block so that is a definite improvement and nice to
> bring in along with the new features.
>
> Rambling a bit on my own personal usage of locking.
>
> In practice I don't use ReentrantLock yet because the cases where I use
> locking aren't performance critical so I end up using synchronized and
> with biased locking this might actually be close to free. Most other
> cases it is CASing immutable objects or publishing via thread safe maps
> or using a single writer thread to process updates.
>
> I can think of two performance sensitive pieces of code I work on that
> use locking. One is an NIO framework that enforces many restrictions on
> send that would be difficult to make absolute guarantees about without
> locking. The other is a transaction scheduler that really shouldn't use
> locking and would probably benefit from ReentrantLock, but that is
> really just papering over the fact that it should be single writer.
>
> To a large degree I see locking as a fallback for the stuff you really
> don't care about in which case the choice of lock doesn't seem that
> important. If you care you should be writing thread per core event based
> code with event threads not sharing state (other then long lived
> immutable state). Java and Guava's excellent primitives make this much
> easier then it otherwise might be.
>
> Regards,
> Ariel
>
> On Mon, Dec 2, 2013, at 03:15 PM, Dr Heinz M. Kabutz wrote:
> > For those of you interested in the Java 8 StampedLock construct here is
> > my first article on the subject.  I plan to write another two on this
> > new synchronizer, based on a bunch of talks I've given and research I've
> > done on the performance and use cases.
> >
> > http://www.javaspecialists.eu/archive/Issue215.html
> >
> > Regards
> >
> > Heinz
> > --
> > Dr Heinz M. Kabutz (PhD CompSci)
> > Author of "The Java(tm) Specialists' Newsletter"
> > Oracle Java Champion 2005-2013
> > JavaOne Rock Star Speaker 2012
> > http://www.javaspecialists.eu
> > Tel: +30 69 75 595 262
> > Skype: kabutz
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131202/8061f44d/attachment.html>

From cheremin at gmail.com  Tue Dec  3 00:54:55 2013
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Tue, 3 Dec 2013 09:54:55 +0400
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529CEAC4.7080409@oracle.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
Message-ID: <CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>

I'm about why "always mean storestore after volatile store in constructor".
It is not only efficiency which is important for MM, but also simplicity
and consistency. If constructors are special methods, not just plain
<init>, then we should add this kind of atomicity to all constructors
(which, as I was reading here, could be inefficient on some platforms). But
if constructors are just plain methods, it looks strange to have special
implicit semantics for constructors with volatiles inside.


2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>

>  I think it is pretty simple.
>
> If you always mean a store-store barrier *after* the last volatile store
> in the constructor, then add that barrier into constructor semantics, like
> it's done with the final fields.
>
> It makes sense to *not* add it to the semantics, if you can come up with
> enough examples where you want that barrier to be eliminated.
>
> Alex
>
>
> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>
> Well, I do not see any data race _on volatiles_ here. I see race condition
> on volatile .value, yes -- but it is pretty legal (and unavoidable, I
> suppose) to have race conditions even with volatiles involved. The only
> data race I see is around read-write of (non-volatile) AtomicInteger's
> reference -- which is unrelated to AtomicInteger's content. I mean, I could
> not see any noticable difference between the case discussed, and just any
> other case there volatile is _incorrectly_ used to "synchronize" data
> accesses -- it could still be data race on non-volatile fields, even if
> volatile fields are also used somewhere around. Yes, get 0 from .value is
> unexpected -- but there are many unexpected things in memory models. It is
> noway more unexpected then to see default values in fields of any other
> object which is unsafely published. I think everybody who passed through
> broken atomicity of constructor call could easy see the chance to read
> [.value=0] in the case discussed.
>
>  "Data race is pure evil" was the motto of this list all time I was
> reading it. Why do we may want to introduce another example of benign race?
> Wouldn't it be just another source of confusion for newcomers?
>
>
>
>
> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>
>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>
>>> Doug, could you explain why it is so important to have this kind of safe
>>> publication for volatile? I mean, could we just go with .value=0 through
>>> data
>>> race to be allowed result, as current model (seem to) imply? It seems to
>>> be a
>>> dr-case anyway, why we need special handling of it?
>>>
>>
>>  The main reason is that it is highly irregular and unexpected
>> by programmers. Except in this case, volatiles definitionally cannot
>> be subject to data races. Dealing with it requires cleverness,
>> complexity, and/or error-proneness that isn't even required for
>> correctness on current JVMs. We have several constructions
>> in j.u.c that work around problems by using explicit ordered
>> writes in constructors, redundant-looking null-checks, and so
>> on. If we are going to repair the JMM anyway, this is a clear
>> candidate for reconsideration.
>>
>> -Doug
>>
>>
>>
>>
>>> Ruslan
>>>
>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>>>
>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>> optimizations to avoid zeroing memory is an implementation detail and
>>>>> thus cannot be relied upon from JMM standpoint, which I think you're
>>>>> saying.
>>>>>
>>>>> The other issue is that even if we determine that volatiles don't get
>>>>> this treatment, if JVM is already ensuring it, it's not going to be
>>>>> practical to change it and risk hard to debug problems creeping in.
>>>>>  May
>>>>> as well update the spec now ...
>>>>>
>>>>
>>>> Right. To summarize:
>>>>
>>>> * Programmers do not expect that even though final fields are
>>>> specifically
>>>> publication-safe, volatile fields are not always so.
>>>>
>>>> * For various implementation reasons, JVMs arrange that volatile fields
>>>> are
>>>> publication safe anyway, at least in cases we know about.
>>>>
>>>> * Actually updating the JMM/JLS to mandate this is not easy (no small
>>>> tweak
>>>> that I know applies). But now is a good time to be considering a full
>>>> revision for JDK9.
>>>>
>>>> * In the mean time, it would make sense to further test and validate
>>>> JVMs
>>>> as meeting this likely future spec.
>>>>
>>>> -Doug
>>>>
>>>> _______________________________________________ Concurrency-interest
>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>>
>>
>>
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/a85f1f44/attachment.html>

From oleksandr.otenko at oracle.com  Tue Dec  3 06:46:17 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 11:46:17 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
Message-ID: <529DC489.2070205@oracle.com>

Constructors /are/ special methods. They are the first method calls in 
any history of the object. This means a different treatment of volatile 
accesses to the fields of the instance being created is possible - 
certain barriers can be eliminated, because the loads can be proven to 
not synchronize with anyone. For the sake of the argument, it is 
possible to proceed with weak treatment of volatile stores, too, but you 
need a good reason to permit subsequent calls to observe the initial 
state of the volatile fields; whereas any volatile load in any other 
method always synchronizes with a volatile store of some other method 
call, without the final field semantics we cannot assume that.

However, if we assume final field semantics, there is only one barrier 
needed - a store-store after the last volatile field store. This 
eliminates all barriers for any other volatile field initialization, and 
eliminates a full barrier needed otherwise (got to place a dummy 
volatile load after the last volatile store to make sure the semantics 
are stronger than final-field) - think of removing a mfence or similar 
from each such constructor on x86.

(there will still be gotchas for cases when volatile field 
initialization occurs after a volatile load of something outside the 
same instance; but the main purpose is to eliminate barriers when the 
volatile fields are just initialized into some instance-specific values)


Alex


On 03/12/2013 05:54, Ruslan Cheremin wrote:
> I'm about why "always mean storestore after volatile store in 
> constructor". It is not only efficiency which is important for MM, but 
> also simplicity and consistency. If constructors are special methods, 
> not just plain <init>, then we should add this kind of atomicity to 
> all constructors (which, as I was reading here, could be inefficient 
> on some platforms). But if constructors are just plain methods, it 
> looks strange to have special implicit semantics for constructors with 
> volatiles inside.
>
>
> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com 
> <mailto:oleksandr.otenko at oracle.com>>
>
>     I think it is pretty simple.
>
>     If you always mean a store-store barrier /after/ the last volatile
>     store in the constructor, then add that barrier into constructor
>     semantics, like it's done with the final fields.
>
>     It makes sense to /not/ add it to the semantics, if you can come
>     up with enough examples where you want that barrier to be eliminated.
>
>     Alex
>
>
>     On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>     Well, I do not see any data race _on volatiles_ here. I see race
>>     condition on volatile .value, yes -- but it is pretty legal (and
>>     unavoidable, I suppose) to have race conditions even with
>>     volatiles involved. The only data race I see is around read-write
>>     of (non-volatile) AtomicInteger's reference -- which is unrelated
>>     to AtomicInteger's content. I mean, I could not see any noticable
>>     difference between the case discussed, and just any other case
>>     there volatile is _incorrectly_ used to "synchronize" data
>>     accesses -- it could still be data race on non-volatile fields,
>>     even if volatile fields are also used somewhere around. Yes, get
>>     0 from .value is unexpected -- but there are many unexpected
>>     things in memory models. It is noway more unexpected then to see
>>     default values in fields of any other object which is unsafely
>>     published. I think everybody who passed through broken atomicity
>>     of constructor call could easy see the chance to read [.value=0]
>>     in the case discussed.
>>
>>     "Data race is pure evil" was the motto of this list all time I
>>     was reading it. Why do we may want to introduce another example
>>     of benign race? Wouldn't it be just another source of confusion
>>     for newcomers?
>>
>>
>>
>>
>>     2013/12/2 Doug Lea <dl at cs.oswego.edu <mailto:dl at cs.oswego.edu>>
>>
>>         On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>
>>             Doug, could you explain why it is so important to have
>>             this kind of safe
>>             publication for volatile? I mean, could we just go with
>>             .value=0 through data
>>             race to be allowed result, as current model (seem to)
>>             imply? It seems to be a
>>             dr-case anyway, why we need special handling of it?
>>
>>
>>         The main reason is that it is highly irregular and unexpected
>>         by programmers. Except in this case, volatiles definitionally
>>         cannot
>>         be subject to data races. Dealing with it requires cleverness,
>>         complexity, and/or error-proneness that isn't even required for
>>         correctness on current JVMs. We have several constructions
>>         in j.u.c that work around problems by using explicit ordered
>>         writes in constructors, redundant-looking null-checks, and so
>>         on. If we are going to repair the JMM anyway, this is a clear
>>         candidate for reconsideration.
>>
>>         -Doug
>>
>>
>>
>>
>>             Ruslan
>>
>>                 27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu
>>                 <mailto:dl at cs.oswego.edu>> ???????(?):
>>
>>                     On 11/27/2013 02:06 PM, Vitaly Davidovich wrote:
>>                     But either way,
>>                     optimizations to avoid zeroing memory is an
>>                     implementation detail and
>>                     thus cannot be relied upon from JMM standpoint,
>>                     which I think you're
>>                     saying.
>>
>>                     The other issue is that even if we determine that
>>                     volatiles don't get
>>                     this treatment, if JVM is already ensuring it,
>>                     it's not going to be
>>                     practical to change it and risk hard to debug
>>                     problems creeping in.  May
>>                     as well update the spec now ...
>>
>>
>>                 Right. To summarize:
>>
>>                 * Programmers do not expect that even though final
>>                 fields are specifically
>>                 publication-safe, volatile fields are not always so.
>>
>>                 * For various implementation reasons, JVMs arrange
>>                 that volatile fields are
>>                 publication safe anyway, at least in cases we know about.
>>
>>                 * Actually updating the JMM/JLS to mandate this is
>>                 not easy (no small tweak
>>                 that I know applies). But now is a good time to be
>>                 considering a full
>>                 revision for JDK9.
>>
>>                 * In the mean time, it would make sense to further
>>                 test and validate JVMs
>>                 as meeting this likely future spec.
>>
>>                 -Doug
>>
>>                 _______________________________________________
>>                 Concurrency-interest
>>                 mailing list Concurrency-interest at cs.oswego.edu
>>                 <mailto:Concurrency-interest at cs.oswego.edu>
>>                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>>
>>
>>
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/f6bd1de2/attachment-0001.html>

From dl at cs.oswego.edu  Tue Dec  3 07:29:11 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 03 Dec 2013 07:29:11 -0500
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
Message-ID: <529DCE97.9050302@cs.oswego.edu>

On 12/02/2013 09:31 PM, Vitaly Davidovich wrote:
> Right, it's a bit unclear on what a good case for this lock is.  I'm guessing
> the advantage is if you use the optimistic version - that avoids any expensive
> stores and doesn't block writers - for tiny read code sections on locks that are
> read-mostly.  Otherwise, seems like it may not perform all that well (e.g.
> validate() missing in cache because another core wrote to the lock in the meantime).
>
> Builtin synchronizer (I.e synchronized keyword) for small/cheap code sections
> that don't contend seems decent enough.  Biased locking + (adaptive) spinning
> should, in theory, be good enough for these cases.

Please measure. Sometimes biased locking is fine, sometimes much less
than fine. As a rule of thumb, if you expect contention not to be rare,
consider using a j.u.c Lock. And unless you need reentrancy, StampedLock
is often the best choice of these in terms of performance and features.
I expect that Heinz's future installments will spell some of this out
for many use cases, but ... please measure.

>
> Also, one other thing synchronized has going for it is it handles async aborts
> of threads (I.e. thread.stop()).  I know stop() is deprecated and all, but you
> never know.

But you do know! As of JDK8, Thread.stop is really gone.
It is the first deprecated method to have actually been
de-implemented. It now just throws UnsupportedOperationException.

-Doug



From robert.j.saulnier at gmail.com  Tue Dec  3 08:05:26 2013
From: robert.j.saulnier at gmail.com (Robert J. Saulnier)
Date: Tue, 3 Dec 2013 09:05:26 -0400
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <529DCE97.9050302@cs.oswego.edu>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
Message-ID: <CAJ8S3uwTDkq6PGPVN3GQEb21x_849hWZPe12e1-gdmTpqK9q-Q@mail.gmail.com>

Hi,

Thread.stop() still has its old behavior in build 117; it doesn't throw an
UnsupportedOperationException.


On Tue, Dec 3, 2013 at 8:29 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 12/02/2013 09:31 PM, Vitaly Davidovich wrote:
>
>> Right, it's a bit unclear on what a good case for this lock is.  I'm
>> guessing
>> the advantage is if you use the optimistic version - that avoids any
>> expensive
>> stores and doesn't block writers - for tiny read code sections on locks
>> that are
>> read-mostly.  Otherwise, seems like it may not perform all that well (e.g.
>> validate() missing in cache because another core wrote to the lock in the
>> meantime).
>>
>> Builtin synchronizer (I.e synchronized keyword) for small/cheap code
>> sections
>> that don't contend seems decent enough.  Biased locking + (adaptive)
>> spinning
>> should, in theory, be good enough for these cases.
>>
>
> Please measure. Sometimes biased locking is fine, sometimes much less
> than fine. As a rule of thumb, if you expect contention not to be rare,
> consider using a j.u.c Lock. And unless you need reentrancy, StampedLock
> is often the best choice of these in terms of performance and features.
> I expect that Heinz's future installments will spell some of this out
> for many use cases, but ... please measure.
>
>
>
>> Also, one other thing synchronized has going for it is it handles async
>> aborts
>> of threads (I.e. thread.stop()).  I know stop() is deprecated and all,
>> but you
>> never know.
>>
>
> But you do know! As of JDK8, Thread.stop is really gone.
> It is the first deprecated method to have actually been
> de-implemented. It now just throws UnsupportedOperationException.
>
> -Doug
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/97e486e5/attachment.html>

From vitalyd at gmail.com  Tue Dec  3 08:57:38 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 08:57:38 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529DC489.2070205@oracle.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
Message-ID: <CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>

For compilation/codegen purposes ctors *are* just methods - they can be
inlined, code optimized, etc; that's the reason we have the final field
guarantees.

A couple of potential reasons not to add volatile to the spec:
1) perhaps some JVMs don't currently already give them final field semantics
2) this whole thing comes into play for unsafe publication only (I.e. data
race), which is discouraged.

Sent from my phone
On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  Constructors *are* special methods. They are the first method calls in
> any history of the object. This means a different treatment of volatile
> accesses to the fields of the instance being created is possible - certain
> barriers can be eliminated, because the loads can be proven to not
> synchronize with anyone. For the sake of the argument, it is possible to
> proceed with weak treatment of volatile stores, too, but you need a good
> reason to permit subsequent calls to observe the initial state of the
> volatile fields; whereas any volatile load in any other method always
> synchronizes with a volatile store of some other method call, without the
> final field semantics we cannot assume that.
>
> However, if we assume final field semantics, there is only one barrier
> needed - a store-store after the last volatile field store. This eliminates
> all barriers for any other volatile field initialization, and eliminates a
> full barrier needed otherwise (got to place a dummy volatile load after the
> last volatile store to make sure the semantics are stronger than
> final-field) - think of removing a mfence or similar from each such
> constructor on x86.
>
> (there will still be gotchas for cases when volatile field initialization
> occurs after a volatile load of something outside the same instance; but
> the main purpose is to eliminate barriers when the volatile fields are just
> initialized into some instance-specific values)
>
>
> Alex
>
>
> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>
> I'm about why "always mean storestore after volatile store in
> constructor". It is not only efficiency which is important for MM, but also
> simplicity and consistency. If constructors are special methods, not just
> plain <init>, then we should add this kind of atomicity to all constructors
> (which, as I was reading here, could be inefficient on some platforms). But
> if constructors are just plain methods, it looks strange to have special
> implicit semantics for constructors with volatiles inside.
>
>
> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>
>>  I think it is pretty simple.
>>
>> If you always mean a store-store barrier *after* the last volatile store
>> in the constructor, then add that barrier into constructor semantics, like
>> it's done with the final fields.
>>
>> It makes sense to *not* add it to the semantics, if you can come up with
>> enough examples where you want that barrier to be eliminated.
>>
>> Alex
>>
>>
>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>
>> Well, I do not see any data race _on volatiles_ here. I see race
>> condition on volatile .value, yes -- but it is pretty legal (and
>> unavoidable, I suppose) to have race conditions even with volatiles
>> involved. The only data race I see is around read-write of (non-volatile)
>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>> I mean, I could not see any noticable difference between the case
>> discussed, and just any other case there volatile is _incorrectly_ used to
>> "synchronize" data accesses -- it could still be data race on non-volatile
>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>> from .value is unexpected -- but there are many unexpected things in memory
>> models. It is noway more unexpected then to see default values in fields of
>> any other object which is unsafely published. I think everybody who passed
>> through broken atomicity of constructor call could easy see the chance to
>> read [.value=0] in the case discussed.
>>
>>  "Data race is pure evil" was the motto of this list all time I was
>> reading it. Why do we may want to introduce another example of benign race?
>> Wouldn't it be just another source of confusion for newcomers?
>>
>>
>>
>>
>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>
>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>
>>>> Doug, could you explain why it is so important to have this kind of safe
>>>> publication for volatile? I mean, could we just go with .value=0
>>>> through data
>>>> race to be allowed result, as current model (seem to) imply? It seems
>>>> to be a
>>>> dr-case anyway, why we need special handling of it?
>>>>
>>>
>>>  The main reason is that it is highly irregular and unexpected
>>> by programmers. Except in this case, volatiles definitionally cannot
>>> be subject to data races. Dealing with it requires cleverness,
>>> complexity, and/or error-proneness that isn't even required for
>>> correctness on current JVMs. We have several constructions
>>> in j.u.c that work around problems by using explicit ordered
>>> writes in constructors, redundant-looking null-checks, and so
>>> on. If we are going to repair the JMM anyway, this is a clear
>>> candidate for reconsideration.
>>>
>>> -Doug
>>>
>>>
>>>
>>>
>>>> Ruslan
>>>>
>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>>>>
>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>> optimizations to avoid zeroing memory is an implementation detail and
>>>>>> thus cannot be relied upon from JMM standpoint, which I think you're
>>>>>> saying.
>>>>>>
>>>>>> The other issue is that even if we determine that volatiles don't get
>>>>>> this treatment, if JVM is already ensuring it, it's not going to be
>>>>>> practical to change it and risk hard to debug problems creeping in.
>>>>>>  May
>>>>>> as well update the spec now ...
>>>>>>
>>>>>
>>>>> Right. To summarize:
>>>>>
>>>>> * Programmers do not expect that even though final fields are
>>>>> specifically
>>>>> publication-safe, volatile fields are not always so.
>>>>>
>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>> fields are
>>>>> publication safe anyway, at least in cases we know about.
>>>>>
>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no small
>>>>> tweak
>>>>> that I know applies). But now is a good time to be considering a full
>>>>> revision for JDK9.
>>>>>
>>>>> * In the mean time, it would make sense to further test and validate
>>>>> JVMs
>>>>> as meeting this likely future spec.
>>>>>
>>>>> -Doug
>>>>>
>>>>> _______________________________________________ Concurrency-interest
>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>>
>>>
>>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/ace8fe33/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  3 09:03:55 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 09:03:55 -0500
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <529DCE97.9050302@cs.oswego.edu>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
Message-ID: <CAHjP37HYvgEQBtPzC0bdXpmzwgN_rj-gXO3+QDjGvz-HBs4s7g@mail.gmail.com>

Doug,

Of course measurement is needed, but I think it's important for people to
have a decent mental model upfront so they can at least reason about which
lock is more likely to be suitable.

How does StampedLock compare with SequenceLock for short mostly read
scenarios? I'm sure you've done testing on these things - what scenarios
have you seen them be clear winners?

Sent from my phone
On Dec 3, 2013 7:39 AM, "Doug Lea" <dl at cs.oswego.edu> wrote:

> On 12/02/2013 09:31 PM, Vitaly Davidovich wrote:
>
>> Right, it's a bit unclear on what a good case for this lock is.  I'm
>> guessing
>> the advantage is if you use the optimistic version - that avoids any
>> expensive
>> stores and doesn't block writers - for tiny read code sections on locks
>> that are
>> read-mostly.  Otherwise, seems like it may not perform all that well (e.g.
>> validate() missing in cache because another core wrote to the lock in the
>> meantime).
>>
>> Builtin synchronizer (I.e synchronized keyword) for small/cheap code
>> sections
>> that don't contend seems decent enough.  Biased locking + (adaptive)
>> spinning
>> should, in theory, be good enough for these cases.
>>
>
> Please measure. Sometimes biased locking is fine, sometimes much less
> than fine. As a rule of thumb, if you expect contention not to be rare,
> consider using a j.u.c Lock. And unless you need reentrancy, StampedLock
> is often the best choice of these in terms of performance and features.
> I expect that Heinz's future installments will spell some of this out
> for many use cases, but ... please measure.
>
>
>> Also, one other thing synchronized has going for it is it handles async
>> aborts
>> of threads (I.e. thread.stop()).  I know stop() is deprecated and all,
>> but you
>> never know.
>>
>
> But you do know! As of JDK8, Thread.stop is really gone.
> It is the first deprecated method to have actually been
> de-implemented. It now just throws UnsupportedOperationException.
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/f01127cc/attachment.html>

From heinz at javaspecialists.eu  Tue Dec  3 09:31:49 2013
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Tue, 03 Dec 2013 16:31:49 +0200
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <529DCE97.9050302@cs.oswego.edu>
References: <529CEA6D.9070301@javaspecialists.eu>	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
Message-ID: <529DEB55.7080203@javaspecialists.eu>

Doug Lea wrote:
> On 12/02/2013 09:31 PM, Vitaly Davidovich wrote:
>> Right, it's a bit unclear on what a good case for this lock is.  I'm 
>> guessing
>> the advantage is if you use the optimistic version - that avoids any 
>> expensive
>> stores and doesn't block writers - for tiny read code sections on 
>> locks that are
>> read-mostly.  Otherwise, seems like it may not perform all that well 
>> (e.g.
>> validate() missing in cache because another core wrote to the lock in 
>> the meantime).
>>
>> Builtin synchronizer (I.e synchronized keyword) for small/cheap code 
>> sections
>> that don't contend seems decent enough.  Biased locking + (adaptive) 
>> spinning
>> should, in theory, be good enough for these cases.
>
> Please measure. Sometimes biased locking is fine, sometimes much less
> than fine. As a rule of thumb, if you expect contention not to be rare,
> consider using a j.u.c Lock. And unless you need reentrancy, StampedLock
> is often the best choice of these in terms of performance and features.
> I expect that Heinz's future installments will spell some of this out
> for many use cases, but ... please measure.
I did some measurements of StampedLock vs ReentrantReadWriteLock and SL 
showed better performance and also did not suffer from the same 
starvation issues as RRWL.  Martin Thompson also mentioned a discussion 
we had on Crete in his blog: 
http://mechanical-sympathy.blogspot.gr/2013/08/lock-based-vs-lock-free-concurrent.html

I still need to verify his findings.  My cursory tests showed that in 
some cases, SL is better than Lock-Free immutable and in other cases, 
plain old synchronized beats them both.  All depends how you test this.
>>
>> Also, one other thing synchronized has going for it is it handles 
>> async aborts
>> of threads (I.e. thread.stop()).  I know stop() is deprecated and 
>> all, but you
>> never know.
>
> But you do know! As of JDK8, Thread.stop is really gone.
> It is the first deprecated method to have actually been
> de-implemented. It now just throws UnsupportedOperationException.
>
I think you're thinking of the Thread.stop(Throwable) method which has 
unfortunately been removed in Java 8.

From vitalyd at gmail.com  Tue Dec  3 09:58:18 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 09:58:18 -0500
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <529DEB55.7080203@javaspecialists.eu>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
	<529DEB55.7080203@javaspecialists.eu>
Message-ID: <CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>

So lock free may become a problem for extremely contended blocks - lock
free, assuming it's the basic CAS loop impl, may cause delays in such cases
as losing threads will continue spinning, tying up cpu resources and
generating coherence traffic.  In this case, using a lock can be a net win.

Also, perhaps the lock free implementation generates lots of garbage,
placing load on the GC.  Otherwise, lock free should be a net win majority
of the time.

A proper Spinlock may be a good addition to the j.u.c toolbox as well.

Sent from my phone
On Dec 3, 2013 9:36 AM, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
wrote:

> Doug Lea wrote:
>
>> On 12/02/2013 09:31 PM, Vitaly Davidovich wrote:
>>
>>> Right, it's a bit unclear on what a good case for this lock is.  I'm
>>> guessing
>>> the advantage is if you use the optimistic version - that avoids any
>>> expensive
>>> stores and doesn't block writers - for tiny read code sections on locks
>>> that are
>>> read-mostly.  Otherwise, seems like it may not perform all that well
>>> (e.g.
>>> validate() missing in cache because another core wrote to the lock in
>>> the meantime).
>>>
>>> Builtin synchronizer (I.e synchronized keyword) for small/cheap code
>>> sections
>>> that don't contend seems decent enough.  Biased locking + (adaptive)
>>> spinning
>>> should, in theory, be good enough for these cases.
>>>
>>
>> Please measure. Sometimes biased locking is fine, sometimes much less
>> than fine. As a rule of thumb, if you expect contention not to be rare,
>> consider using a j.u.c Lock. And unless you need reentrancy, StampedLock
>> is often the best choice of these in terms of performance and features.
>> I expect that Heinz's future installments will spell some of this out
>> for many use cases, but ... please measure.
>>
> I did some measurements of StampedLock vs ReentrantReadWriteLock and SL
> showed better performance and also did not suffer from the same starvation
> issues as RRWL.  Martin Thompson also mentioned a discussion we had on
> Crete in his blog: http://mechanical-sympathy.blogspot.gr/2013/08/lock-
> based-vs-lock-free-concurrent.html
>
> I still need to verify his findings.  My cursory tests showed that in some
> cases, SL is better than Lock-Free immutable and in other cases, plain old
> synchronized beats them both.  All depends how you test this.
>
>>
>>> Also, one other thing synchronized has going for it is it handles async
>>> aborts
>>> of threads (I.e. thread.stop()).  I know stop() is deprecated and all,
>>> but you
>>> never know.
>>>
>>
>> But you do know! As of JDK8, Thread.stop is really gone.
>> It is the first deprecated method to have actually been
>> de-implemented. It now just throws UnsupportedOperationException.
>>
>>  I think you're thinking of the Thread.stop(Throwable) method which has
> unfortunately been removed in Java 8.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/14217c8d/attachment.html>

From oleksandr.otenko at oracle.com  Tue Dec  3 10:02:54 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 15:02:54 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
Message-ID: <529DF29E.6070702@oracle.com>

I understand, but you can't insist on viewing ctors as "just methods" 
for all purposes.

(2) publication is unsafe unless you get a volatile load after the last 
volatile store in the constructor. Besides, the initial value of the 
field may not even be one of the valid values, so it is not even just 
about a data race.


Alex


On 03/12/2013 13:57, Vitaly Davidovich wrote:
>
> For compilation/codegen purposes ctors *are* just methods - they can 
> be inlined, code optimized, etc; that's the reason we have the final 
> field guarantees.
>
> A couple of potential reasons not to add volatile to the spec:
> 1) perhaps some JVMs don't currently already give them final field 
> semantics
> 2) this whole thing comes into play for unsafe publication only (I.e. 
> data race), which is discouraged.
>
> Sent from my phone
>
> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     Constructors /are/ special methods. They are the first method
>     calls in any history of the object. This means a different
>     treatment of volatile accesses to the fields of the instance being
>     created is possible - certain barriers can be eliminated, because
>     the loads can be proven to not synchronize with anyone. For the
>     sake of the argument, it is possible to proceed with weak
>     treatment of volatile stores, too, but you need a good reason to
>     permit subsequent calls to observe the initial state of the
>     volatile fields; whereas any volatile load in any other method
>     always synchronizes with a volatile store of some other method
>     call, without the final field semantics we cannot assume that.
>
>     However, if we assume final field semantics, there is only one
>     barrier needed - a store-store after the last volatile field
>     store. This eliminates all barriers for any other volatile field
>     initialization, and eliminates a full barrier needed otherwise
>     (got to place a dummy volatile load after the last volatile store
>     to make sure the semantics are stronger than final-field) - think
>     of removing a mfence or similar from each such constructor on x86.
>
>     (there will still be gotchas for cases when volatile field
>     initialization occurs after a volatile load of something outside
>     the same instance; but the main purpose is to eliminate barriers
>     when the volatile fields are just initialized into some
>     instance-specific values)
>
>
>     Alex
>
>
>     On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>     I'm about why "always mean storestore after volatile store in
>>     constructor". It is not only efficiency which is important for
>>     MM, but also simplicity and consistency. If constructors are
>>     special methods, not just plain <init>, then we should add this
>>     kind of atomicity to all constructors (which, as I was reading
>>     here, could be inefficient on some platforms). But if
>>     constructors are just plain methods, it looks strange to have
>>     special implicit semantics for constructors with volatiles inside.
>>
>>
>>     2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>>
>>
>>         I think it is pretty simple.
>>
>>         If you always mean a store-store barrier /after/ the last
>>         volatile store in the constructor, then add that barrier into
>>         constructor semantics, like it's done with the final fields.
>>
>>         It makes sense to /not/ add it to the semantics, if you can
>>         come up with enough examples where you want that barrier to
>>         be eliminated.
>>
>>         Alex
>>
>>
>>         On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>         Well, I do not see any data race _on volatiles_ here. I see
>>>         race condition on volatile .value, yes -- but it is pretty
>>>         legal (and unavoidable, I suppose) to have race conditions
>>>         even with volatiles involved. The only data race I see is
>>>         around read-write of (non-volatile) AtomicInteger's
>>>         reference -- which is unrelated to AtomicInteger's content.
>>>         I mean, I could not see any noticable difference between the
>>>         case discussed, and just any other case there volatile is
>>>         _incorrectly_ used to "synchronize" data accesses -- it
>>>         could still be data race on non-volatile fields, even if
>>>         volatile fields are also used somewhere around. Yes, get 0
>>>         from .value is unexpected -- but there are many unexpected
>>>         things in memory models. It is noway more unexpected then to
>>>         see default values in fields of any other object which is
>>>         unsafely published. I think everybody who passed through
>>>         broken atomicity of constructor call could easy see the
>>>         chance to read [.value=0] in the case discussed.
>>>
>>>         "Data race is pure evil" was the motto of this list all time
>>>         I was reading it. Why do we may want to introduce another
>>>         example of benign race? Wouldn't it be just another source
>>>         of confusion for newcomers?
>>>
>>>
>>>
>>>
>>>         2013/12/2 Doug Lea <dl at cs.oswego.edu <mailto:dl at cs.oswego.edu>>
>>>
>>>             On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>
>>>                 Doug, could you explain why it is so important to
>>>                 have this kind of safe
>>>                 publication for volatile? I mean, could we just go
>>>                 with .value=0 through data
>>>                 race to be allowed result, as current model (seem
>>>                 to) imply? It seems to be a
>>>                 dr-case anyway, why we need special handling of it?
>>>
>>>
>>>             The main reason is that it is highly irregular and
>>>             unexpected
>>>             by programmers. Except in this case, volatiles
>>>             definitionally cannot
>>>             be subject to data races. Dealing with it requires
>>>             cleverness,
>>>             complexity, and/or error-proneness that isn't even
>>>             required for
>>>             correctness on current JVMs. We have several constructions
>>>             in j.u.c that work around problems by using explicit ordered
>>>             writes in constructors, redundant-looking null-checks,
>>>             and so
>>>             on. If we are going to repair the JMM anyway, this is a
>>>             clear
>>>             candidate for reconsideration.
>>>
>>>             -Doug
>>>
>>>
>>>
>>>
>>>                 Ruslan
>>>
>>>                     27 ????. 2013 ?., ? 23:26, Doug Lea
>>>                     <dl at cs.oswego.edu <mailto:dl at cs.oswego.edu>>
>>>                     ???????(?):
>>>
>>>                         On 11/27/2013 02:06 PM, Vitaly Davidovich
>>>                         wrote: But either way,
>>>                         optimizations to avoid zeroing memory is an
>>>                         implementation detail and
>>>                         thus cannot be relied upon from JMM
>>>                         standpoint, which I think you're
>>>                         saying.
>>>
>>>                         The other issue is that even if we determine
>>>                         that volatiles don't get
>>>                         this treatment, if JVM is already ensuring
>>>                         it, it's not going to be
>>>                         practical to change it and risk hard to
>>>                         debug problems creeping in.  May
>>>                         as well update the spec now ...
>>>
>>>
>>>                     Right. To summarize:
>>>
>>>                     * Programmers do not expect that even though
>>>                     final fields are specifically
>>>                     publication-safe, volatile fields are not always so.
>>>
>>>                     * For various implementation reasons, JVMs
>>>                     arrange that volatile fields are
>>>                     publication safe anyway, at least in cases we
>>>                     know about.
>>>
>>>                     * Actually updating the JMM/JLS to mandate this
>>>                     is not easy (no small tweak
>>>                     that I know applies). But now is a good time to
>>>                     be considering a full
>>>                     revision for JDK9.
>>>
>>>                     * In the mean time, it would make sense to
>>>                     further test and validate JVMs
>>>                     as meeting this likely future spec.
>>>
>>>                     -Doug
>>>
>>>                     _______________________________________________
>>>                     Concurrency-interest
>>>                     mailing list Concurrency-interest at cs.oswego.edu
>>>                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>         _______________________________________________
>>>         Concurrency-interest mailing list
>>>         Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>         _______________________________________________
>>         Concurrency-interest mailing list
>>         Concurrency-interest at cs.oswego.edu
>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/0cc6b9c0/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  3 10:08:30 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 10:08:30 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529DF29E.6070702@oracle.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
Message-ID: <CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>

Initial value of the field must be the "zero" value of that type, that's a
language spec and must be guaranteed irrespective of volatile or not.

Sent from my phone
On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  I understand, but you can't insist on viewing ctors as "just methods" for
> all purposes.
>
> (2) publication is unsafe unless you get a volatile load after the last
> volatile store in the constructor. Besides, the initial value of the field
> may not even be one of the valid values, so it is not even just about a
> data race.
>
>
> Alex
>
>
> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>
> For compilation/codegen purposes ctors *are* just methods - they can be
> inlined, code optimized, etc; that's the reason we have the final field
> guarantees.
>
> A couple of potential reasons not to add volatile to the spec:
> 1) perhaps some JVMs don't currently already give them final field
> semantics
> 2) this whole thing comes into play for unsafe publication only (I.e. data
> race), which is discouraged.
>
> Sent from my phone
> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  Constructors *are* special methods. They are the first method calls in
>> any history of the object. This means a different treatment of volatile
>> accesses to the fields of the instance being created is possible - certain
>> barriers can be eliminated, because the loads can be proven to not
>> synchronize with anyone. For the sake of the argument, it is possible to
>> proceed with weak treatment of volatile stores, too, but you need a good
>> reason to permit subsequent calls to observe the initial state of the
>> volatile fields; whereas any volatile load in any other method always
>> synchronizes with a volatile store of some other method call, without the
>> final field semantics we cannot assume that.
>>
>> However, if we assume final field semantics, there is only one barrier
>> needed - a store-store after the last volatile field store. This eliminates
>> all barriers for any other volatile field initialization, and eliminates a
>> full barrier needed otherwise (got to place a dummy volatile load after the
>> last volatile store to make sure the semantics are stronger than
>> final-field) - think of removing a mfence or similar from each such
>> constructor on x86.
>>
>> (there will still be gotchas for cases when volatile field initialization
>> occurs after a volatile load of something outside the same instance; but
>> the main purpose is to eliminate barriers when the volatile fields are just
>> initialized into some instance-specific values)
>>
>>
>> Alex
>>
>>
>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>
>> I'm about why "always mean storestore after volatile store in
>> constructor". It is not only efficiency which is important for MM, but also
>> simplicity and consistency. If constructors are special methods, not just
>> plain <init>, then we should add this kind of atomicity to all constructors
>> (which, as I was reading here, could be inefficient on some platforms). But
>> if constructors are just plain methods, it looks strange to have special
>> implicit semantics for constructors with volatiles inside.
>>
>>
>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>
>>>  I think it is pretty simple.
>>>
>>> If you always mean a store-store barrier *after* the last volatile
>>> store in the constructor, then add that barrier into constructor semantics,
>>> like it's done with the final fields.
>>>
>>> It makes sense to *not* add it to the semantics, if you can come up
>>> with enough examples where you want that barrier to be eliminated.
>>>
>>> Alex
>>>
>>>
>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>
>>> Well, I do not see any data race _on volatiles_ here. I see race
>>> condition on volatile .value, yes -- but it is pretty legal (and
>>> unavoidable, I suppose) to have race conditions even with volatiles
>>> involved. The only data race I see is around read-write of (non-volatile)
>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>> I mean, I could not see any noticable difference between the case
>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>> from .value is unexpected -- but there are many unexpected things in memory
>>> models. It is noway more unexpected then to see default values in fields of
>>> any other object which is unsafely published. I think everybody who passed
>>> through broken atomicity of constructor call could easy see the chance to
>>> read [.value=0] in the case discussed.
>>>
>>>  "Data race is pure evil" was the motto of this list all time I was
>>> reading it. Why do we may want to introduce another example of benign race?
>>> Wouldn't it be just another source of confusion for newcomers?
>>>
>>>
>>>
>>>
>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>
>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>
>>>>> Doug, could you explain why it is so important to have this kind of
>>>>> safe
>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>> through data
>>>>> race to be allowed result, as current model (seem to) imply? It seems
>>>>> to be a
>>>>> dr-case anyway, why we need special handling of it?
>>>>>
>>>>
>>>>  The main reason is that it is highly irregular and unexpected
>>>> by programmers. Except in this case, volatiles definitionally cannot
>>>> be subject to data races. Dealing with it requires cleverness,
>>>> complexity, and/or error-proneness that isn't even required for
>>>> correctness on current JVMs. We have several constructions
>>>> in j.u.c that work around problems by using explicit ordered
>>>> writes in constructors, redundant-looking null-checks, and so
>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>> candidate for reconsideration.
>>>>
>>>> -Doug
>>>>
>>>>
>>>>
>>>>
>>>>> Ruslan
>>>>>
>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>>>>>
>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>> optimizations to avoid zeroing memory is an implementation detail and
>>>>>>> thus cannot be relied upon from JMM standpoint, which I think you're
>>>>>>> saying.
>>>>>>>
>>>>>>> The other issue is that even if we determine that volatiles don't get
>>>>>>> this treatment, if JVM is already ensuring it, it's not going to be
>>>>>>> practical to change it and risk hard to debug problems creeping in.
>>>>>>>  May
>>>>>>> as well update the spec now ...
>>>>>>>
>>>>>>
>>>>>> Right. To summarize:
>>>>>>
>>>>>> * Programmers do not expect that even though final fields are
>>>>>> specifically
>>>>>> publication-safe, volatile fields are not always so.
>>>>>>
>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>> fields are
>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>
>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no small
>>>>>> tweak
>>>>>> that I know applies). But now is a good time to be considering a full
>>>>>> revision for JDK9.
>>>>>>
>>>>>> * In the mean time, it would make sense to further test and validate
>>>>>> JVMs
>>>>>> as meeting this likely future spec.
>>>>>>
>>>>>> -Doug
>>>>>>
>>>>>> _______________________________________________ Concurrency-interest
>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>
>>>>>
>>>>
>>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/a263fd87/attachment-0001.html>

From nathan.reynolds at oracle.com  Tue Dec  3 11:04:47 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 03 Dec 2013 09:04:47 -0700
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
References: <5295E24C.40608@oracle.com>
	<5295EFFA.5090701@oracle.com>	<5295F85A.40500@cs.oswego.edu>	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>	<52963CEB.5070703@cs.oswego.edu>	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>	<52964752.3020104@cs.oswego.edu>	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>	<529C68C1.2040100@cs.oswego.edu>	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>	<529CEAC4.7080409@oracle.com>	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>	<529DC489.2070205@oracle.com>	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
Message-ID: <529E011F.6060902@oracle.com>

Yes, the initial value of the field must be zero/null.  However, this 
could be a violation of the semantics of the class.

Take for instance a field which is an enum.  The field will be 
initialized to null, but this could be a violation of the semantics of 
how the field is used.  The field could be required to be one of the 
enum values.  Anything unexpected and the rest of the class's code can't 
handle the situation.

The constructor can be viewed as taking a raw uninitialized instance and 
preparing it to take a state that is expected and valid.  Even if the 
fields are zero/null, this is not an initialized state with respect to 
the class.  The state transition from invalid to valid can be very risky 
from a concurrency perspective and in some cases can only be done by a 
single thread.  Some constructors need the guarantee that only a 
single-thread is executing on the object at the time.  Many other 
constructors don't care since synchronization, if needed at all, must be 
taken care of outside of the class.

Consider ConcurrentLinkedList which sets up the head and tail fields in 
the constructor.  These fields are volatiles.  Initially these fields 
are set to null.  The constructor transitions the instance from an 
illegal state (i.e. zero/null) into an expected state using multiple 
steps.  The constructor must do this without any other methods being 
invoked on the instance by other threads. In this case, we could add 
logic to the rest of the methods in ConcurrentLinkedList which would 
detect a partially constructed object and then deal with it.  It would 
make the code very difficult, very error prone and less performant.  In 
other cases, it would be difficult to detect a partially constructed 
object and perhaps impossible for multiple threads to concurrently bring 
the object into a valid state.

We need to a way for the code to state if the constructor requires 
single-threaded access.  Final field semantics is one way.  The question 
of this email is if volatile stores should be a way that tells the 
compiler that this constructor requires single-threaded access to the 
object.

My position is yes.  There are cases where there are no final fields 
naturally occurring in the class yet there are plenty of volatile 
variables.  This requires the programmer to introduce one which wastes 
space.  There are cases where there are no final or volatile fields 
naturally occurring in the class.  Yet, the rest of the methods are 
synchronized and need the constructor to have single-threaded access.

On the other hand, having final field (and potentially volatile stores) 
force the compiler to guarantee single-threaded access to the object is 
very subtle.  It would be better if the guarantee was more explicit in 
the code (e.g. adding the synchronized keyword to the constructor).

-Nathan

On 12/3/2013 8:08 AM, Vitaly Davidovich wrote:
>
> Initial value of the field must be the "zero" value of that type, 
> that's a language spec and must be guaranteed irrespective of volatile 
> or not.
>
> Sent from my phone
>
> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     I understand, but you can't insist on viewing ctors as "just
>     methods" for all purposes.
>
>     (2) publication is unsafe unless you get a volatile load after the
>     last volatile store in the constructor. Besides, the initial value
>     of the field may not even be one of the valid values, so it is not
>     even just about a data race.
>
>
>     Alex
>
>
>     On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>
>>     For compilation/codegen purposes ctors *are* just methods - they
>>     can be inlined, code optimized, etc; that's the reason we have
>>     the final field guarantees.
>>
>>     A couple of potential reasons not to add volatile to the spec:
>>     1) perhaps some JVMs don't currently already give them final
>>     field semantics
>>     2) this whole thing comes into play for unsafe publication only
>>     (I.e. data race), which is discouraged.
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 6:51 AM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         Constructors /are/ special methods. They are the first method
>>         calls in any history of the object. This means a different
>>         treatment of volatile accesses to the fields of the instance
>>         being created is possible - certain barriers can be
>>         eliminated, because the loads can be proven to not
>>         synchronize with anyone. For the sake of the argument, it is
>>         possible to proceed with weak treatment of volatile stores,
>>         too, but you need a good reason to permit subsequent calls to
>>         observe the initial state of the volatile fields; whereas any
>>         volatile load in any other method always synchronizes with a
>>         volatile store of some other method call, without the final
>>         field semantics we cannot assume that.
>>
>>         However, if we assume final field semantics, there is only
>>         one barrier needed - a store-store after the last volatile
>>         field store. This eliminates all barriers for any other
>>         volatile field initialization, and eliminates a full barrier
>>         needed otherwise (got to place a dummy volatile load after
>>         the last volatile store to make sure the semantics are
>>         stronger than final-field) - think of removing a mfence or
>>         similar from each such constructor on x86.
>>
>>         (there will still be gotchas for cases when volatile field
>>         initialization occurs after a volatile load of something
>>         outside the same instance; but the main purpose is to
>>         eliminate barriers when the volatile fields are just
>>         initialized into some instance-specific values)
>>
>>
>>         Alex
>>
>>
>>         On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>         I'm about why "always mean storestore after volatile store
>>>         in constructor". It is not only efficiency which is
>>>         important for MM, but also simplicity and consistency. If
>>>         constructors are special methods, not just plain <init>,
>>>         then we should add this kind of atomicity to all
>>>         constructors (which, as I was reading here, could be
>>>         inefficient on some platforms). But if constructors are just
>>>         plain methods, it looks strange to have special implicit
>>>         semantics for constructors with volatiles inside.
>>>
>>>
>>>         2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>>
>>>
>>>             I think it is pretty simple.
>>>
>>>             If you always mean a store-store barrier /after/ the
>>>             last volatile store in the constructor, then add that
>>>             barrier into constructor semantics, like it's done with
>>>             the final fields.
>>>
>>>             It makes sense to /not/ add it to the semantics, if you
>>>             can come up with enough examples where you want that
>>>             barrier to be eliminated.
>>>
>>>             Alex
>>>
>>>
>>>             On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>             Well, I do not see any data race _on volatiles_ here. I
>>>>             see race condition on volatile .value, yes -- but it is
>>>>             pretty legal (and unavoidable, I suppose) to have race
>>>>             conditions even with volatiles involved. The only data
>>>>             race I see is around read-write of (non-volatile)
>>>>             AtomicInteger's reference -- which is unrelated to
>>>>             AtomicInteger's content. I mean, I could not see any
>>>>             noticable difference between the case discussed, and
>>>>             just any other case there volatile is _incorrectly_
>>>>             used to "synchronize" data accesses -- it could still
>>>>             be data race on non-volatile fields, even if volatile
>>>>             fields are also used somewhere around. Yes, get 0 from
>>>>             .value is unexpected -- but there are many unexpected
>>>>             things in memory models. It is noway more unexpected
>>>>             then to see default values in fields of any other
>>>>             object which is unsafely published. I think everybody
>>>>             who passed through broken atomicity of constructor call
>>>>             could easy see the chance to read [.value=0] in the
>>>>             case discussed.
>>>>
>>>>             "Data race is pure evil" was the motto of this list all
>>>>             time I was reading it. Why do we may want to introduce
>>>>             another example of benign race? Wouldn't it be just
>>>>             another source of confusion for newcomers?
>>>>
>>>>
>>>>
>>>>
>>>>             2013/12/2 Doug Lea <dl at cs.oswego.edu
>>>>             <mailto:dl at cs.oswego.edu>>
>>>>
>>>>                 On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>
>>>>                     Doug, could you explain why it is so important
>>>>                     to have this kind of safe
>>>>                     publication for volatile? I mean, could we just
>>>>                     go with .value=0 through data
>>>>                     race to be allowed result, as current model
>>>>                     (seem to) imply? It seems to be a
>>>>                     dr-case anyway, why we need special handling of it?
>>>>
>>>>
>>>>                 The main reason is that it is highly irregular and
>>>>                 unexpected
>>>>                 by programmers. Except in this case, volatiles
>>>>                 definitionally cannot
>>>>                 be subject to data races. Dealing with it requires
>>>>                 cleverness,
>>>>                 complexity, and/or error-proneness that isn't even
>>>>                 required for
>>>>                 correctness on current JVMs. We have several
>>>>                 constructions
>>>>                 in j.u.c that work around problems by using
>>>>                 explicit ordered
>>>>                 writes in constructors, redundant-looking
>>>>                 null-checks, and so
>>>>                 on. If we are going to repair the JMM anyway, this
>>>>                 is a clear
>>>>                 candidate for reconsideration.
>>>>
>>>>                 -Doug
>>>>
>>>>
>>>>
>>>>
>>>>                     Ruslan
>>>>
>>>>                         27 ????. 2013 ?., ? 23:26, Doug Lea
>>>>                         <dl at cs.oswego.edu
>>>>                         <mailto:dl at cs.oswego.edu>> ???????(?):
>>>>
>>>>                             On 11/27/2013 02:06 PM, Vitaly
>>>>                             Davidovich wrote: But either way,
>>>>                             optimizations to avoid zeroing memory
>>>>                             is an implementation detail and
>>>>                             thus cannot be relied upon from JMM
>>>>                             standpoint, which I think you're
>>>>                             saying.
>>>>
>>>>                             The other issue is that even if we
>>>>                             determine that volatiles don't get
>>>>                             this treatment, if JVM is already
>>>>                             ensuring it, it's not going to be
>>>>                             practical to change it and risk hard to
>>>>                             debug problems creeping in.  May
>>>>                             as well update the spec now ...
>>>>
>>>>
>>>>                         Right. To summarize:
>>>>
>>>>                         * Programmers do not expect that even
>>>>                         though final fields are specifically
>>>>                         publication-safe, volatile fields are not
>>>>                         always so.
>>>>
>>>>                         * For various implementation reasons, JVMs
>>>>                         arrange that volatile fields are
>>>>                         publication safe anyway, at least in cases
>>>>                         we know about.
>>>>
>>>>                         * Actually updating the JMM/JLS to mandate
>>>>                         this is not easy (no small tweak
>>>>                         that I know applies). But now is a good
>>>>                         time to be considering a full
>>>>                         revision for JDK9.
>>>>
>>>>                         * In the mean time, it would make sense to
>>>>                         further test and validate JVMs
>>>>                         as meeting this likely future spec.
>>>>
>>>>                         -Doug
>>>>
>>>>                         _______________________________________________
>>>>                         Concurrency-interest
>>>>                         mailing list
>>>>                         Concurrency-interest at cs.oswego.edu
>>>>                         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>
>>>>
>>>>
>>>>
>>>>
>>>>             _______________________________________________
>>>>             Concurrency-interest mailing list
>>>>             Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>>             _______________________________________________
>>>             Concurrency-interest mailing list
>>>             Concurrency-interest at cs.oswego.edu
>>>             <mailto:Concurrency-interest at cs.oswego.edu>
>>>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>>
>>         _______________________________________________
>>         Concurrency-interest mailing list
>>         Concurrency-interest at cs.oswego.edu
>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/0a9c9ec8/attachment-0001.html>

From oleksandr.otenko at oracle.com  Tue Dec  3 11:13:46 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 16:13:46 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
Message-ID: <529E033A.90903@oracle.com>

Yes, but I mean that the code assumes the value to always be non-null - 
eg a sentinel entry of the list is created at construction time. Without 
the construction-time guarantee you'd need to test for null everywhere.

I think the same applies in other constructors - if you write the 
initialization of the volatile, you imply that's "the least" "possible" 
value, the value representing the initial state of the concurrent 
algorithm - the initial value guaranteed by Java spec may not represent 
any valid state of the concurrent algorithm, let alone the initial state.

That's why this really boils down to "find the broad cases where you do 
want to permit unsafe publication of the initial values of the volatiles".


(unlike the non-volatile fields. Don't treat them as "not thread safe" - 
instead, treat them as "assume as made thread-safe by means outside the 
class specification", hence no requirement for "safe publication" there)


Alex


On 03/12/2013 15:08, Vitaly Davidovich wrote:
>
> Initial value of the field must be the "zero" value of that type, 
> that's a language spec and must be guaranteed irrespective of volatile 
> or not.
>
> Sent from my phone
>
> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     I understand, but you can't insist on viewing ctors as "just
>     methods" for all purposes.
>
>     (2) publication is unsafe unless you get a volatile load after the
>     last volatile store in the constructor. Besides, the initial value
>     of the field may not even be one of the valid values, so it is not
>     even just about a data race.
>
>
>     Alex
>
>
>     On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>
>>     For compilation/codegen purposes ctors *are* just methods - they
>>     can be inlined, code optimized, etc; that's the reason we have
>>     the final field guarantees.
>>
>>     A couple of potential reasons not to add volatile to the spec:
>>     1) perhaps some JVMs don't currently already give them final
>>     field semantics
>>     2) this whole thing comes into play for unsafe publication only
>>     (I.e. data race), which is discouraged.
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 6:51 AM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         Constructors /are/ special methods. They are the first method
>>         calls in any history of the object. This means a different
>>         treatment of volatile accesses to the fields of the instance
>>         being created is possible - certain barriers can be
>>         eliminated, because the loads can be proven to not
>>         synchronize with anyone. For the sake of the argument, it is
>>         possible to proceed with weak treatment of volatile stores,
>>         too, but you need a good reason to permit subsequent calls to
>>         observe the initial state of the volatile fields; whereas any
>>         volatile load in any other method always synchronizes with a
>>         volatile store of some other method call, without the final
>>         field semantics we cannot assume that.
>>
>>         However, if we assume final field semantics, there is only
>>         one barrier needed - a store-store after the last volatile
>>         field store. This eliminates all barriers for any other
>>         volatile field initialization, and eliminates a full barrier
>>         needed otherwise (got to place a dummy volatile load after
>>         the last volatile store to make sure the semantics are
>>         stronger than final-field) - think of removing a mfence or
>>         similar from each such constructor on x86.
>>
>>         (there will still be gotchas for cases when volatile field
>>         initialization occurs after a volatile load of something
>>         outside the same instance; but the main purpose is to
>>         eliminate barriers when the volatile fields are just
>>         initialized into some instance-specific values)
>>
>>
>>         Alex
>>
>>
>>         On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>         I'm about why "always mean storestore after volatile store
>>>         in constructor". It is not only efficiency which is
>>>         important for MM, but also simplicity and consistency. If
>>>         constructors are special methods, not just plain <init>,
>>>         then we should add this kind of atomicity to all
>>>         constructors (which, as I was reading here, could be
>>>         inefficient on some platforms). But if constructors are just
>>>         plain methods, it looks strange to have special implicit
>>>         semantics for constructors with volatiles inside.
>>>
>>>
>>>         2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>>
>>>
>>>             I think it is pretty simple.
>>>
>>>             If you always mean a store-store barrier /after/ the
>>>             last volatile store in the constructor, then add that
>>>             barrier into constructor semantics, like it's done with
>>>             the final fields.
>>>
>>>             It makes sense to /not/ add it to the semantics, if you
>>>             can come up with enough examples where you want that
>>>             barrier to be eliminated.
>>>
>>>             Alex
>>>
>>>
>>>             On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>             Well, I do not see any data race _on volatiles_ here. I
>>>>             see race condition on volatile .value, yes -- but it is
>>>>             pretty legal (and unavoidable, I suppose) to have race
>>>>             conditions even with volatiles involved. The only data
>>>>             race I see is around read-write of (non-volatile)
>>>>             AtomicInteger's reference -- which is unrelated to
>>>>             AtomicInteger's content. I mean, I could not see any
>>>>             noticable difference between the case discussed, and
>>>>             just any other case there volatile is _incorrectly_
>>>>             used to "synchronize" data accesses -- it could still
>>>>             be data race on non-volatile fields, even if volatile
>>>>             fields are also used somewhere around. Yes, get 0 from
>>>>             .value is unexpected -- but there are many unexpected
>>>>             things in memory models. It is noway more unexpected
>>>>             then to see default values in fields of any other
>>>>             object which is unsafely published. I think everybody
>>>>             who passed through broken atomicity of constructor call
>>>>             could easy see the chance to read [.value=0] in the
>>>>             case discussed.
>>>>
>>>>             "Data race is pure evil" was the motto of this list all
>>>>             time I was reading it. Why do we may want to introduce
>>>>             another example of benign race? Wouldn't it be just
>>>>             another source of confusion for newcomers?
>>>>
>>>>
>>>>
>>>>
>>>>             2013/12/2 Doug Lea <dl at cs.oswego.edu
>>>>             <mailto:dl at cs.oswego.edu>>
>>>>
>>>>                 On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>
>>>>                     Doug, could you explain why it is so important
>>>>                     to have this kind of safe
>>>>                     publication for volatile? I mean, could we just
>>>>                     go with .value=0 through data
>>>>                     race to be allowed result, as current model
>>>>                     (seem to) imply? It seems to be a
>>>>                     dr-case anyway, why we need special handling of it?
>>>>
>>>>
>>>>                 The main reason is that it is highly irregular and
>>>>                 unexpected
>>>>                 by programmers. Except in this case, volatiles
>>>>                 definitionally cannot
>>>>                 be subject to data races. Dealing with it requires
>>>>                 cleverness,
>>>>                 complexity, and/or error-proneness that isn't even
>>>>                 required for
>>>>                 correctness on current JVMs. We have several
>>>>                 constructions
>>>>                 in j.u.c that work around problems by using
>>>>                 explicit ordered
>>>>                 writes in constructors, redundant-looking
>>>>                 null-checks, and so
>>>>                 on. If we are going to repair the JMM anyway, this
>>>>                 is a clear
>>>>                 candidate for reconsideration.
>>>>
>>>>                 -Doug
>>>>
>>>>
>>>>
>>>>
>>>>                     Ruslan
>>>>
>>>>                         27 ????. 2013 ?., ? 23:26, Doug Lea
>>>>                         <dl at cs.oswego.edu
>>>>                         <mailto:dl at cs.oswego.edu>> ???????(?):
>>>>
>>>>                             On 11/27/2013 02:06 PM, Vitaly
>>>>                             Davidovich wrote: But either way,
>>>>                             optimizations to avoid zeroing memory
>>>>                             is an implementation detail and
>>>>                             thus cannot be relied upon from JMM
>>>>                             standpoint, which I think you're
>>>>                             saying.
>>>>
>>>>                             The other issue is that even if we
>>>>                             determine that volatiles don't get
>>>>                             this treatment, if JVM is already
>>>>                             ensuring it, it's not going to be
>>>>                             practical to change it and risk hard to
>>>>                             debug problems creeping in.  May
>>>>                             as well update the spec now ...
>>>>
>>>>
>>>>                         Right. To summarize:
>>>>
>>>>                         * Programmers do not expect that even
>>>>                         though final fields are specifically
>>>>                         publication-safe, volatile fields are not
>>>>                         always so.
>>>>
>>>>                         * For various implementation reasons, JVMs
>>>>                         arrange that volatile fields are
>>>>                         publication safe anyway, at least in cases
>>>>                         we know about.
>>>>
>>>>                         * Actually updating the JMM/JLS to mandate
>>>>                         this is not easy (no small tweak
>>>>                         that I know applies). But now is a good
>>>>                         time to be considering a full
>>>>                         revision for JDK9.
>>>>
>>>>                         * In the mean time, it would make sense to
>>>>                         further test and validate JVMs
>>>>                         as meeting this likely future spec.
>>>>
>>>>                         -Doug
>>>>
>>>>                         _______________________________________________
>>>>                         Concurrency-interest
>>>>                         mailing list
>>>>                         Concurrency-interest at cs.oswego.edu
>>>>                         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>
>>>>
>>>>
>>>>
>>>>
>>>>             _______________________________________________
>>>>             Concurrency-interest mailing list
>>>>             Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>>             _______________________________________________
>>>             Concurrency-interest mailing list
>>>             Concurrency-interest at cs.oswego.edu
>>>             <mailto:Concurrency-interest at cs.oswego.edu>
>>>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>>
>>         _______________________________________________
>>         Concurrency-interest mailing list
>>         Concurrency-interest at cs.oswego.edu
>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/77779d70/attachment-0001.html>

From heinz at javaspecialists.eu  Tue Dec  3 11:14:21 2013
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Tue, 03 Dec 2013 18:14:21 +0200
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
References: <529CEA6D.9070301@javaspecialists.eu>	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>	<529DCE97.9050302@cs.oswego.edu>	<529DEB55.7080203@javaspecialists.eu>
	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
Message-ID: <529E035D.2050504@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/0c09c88c/attachment.html>

From nathan.reynolds at oracle.com  Tue Dec  3 11:27:25 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 03 Dec 2013 09:27:25 -0700
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
References: <529CEA6D.9070301@javaspecialists.eu>	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>	<529DCE97.9050302@cs.oswego.edu>	<529DEB55.7080203@javaspecialists.eu>
	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
Message-ID: <529E066D.9020008@oracle.com>

In one C++ case, we have a read-write lock in which writes are very 
rare.  Having multiple threads execute CAS to update the number of 
readers holding the lock has been a source of contention.  A stamped 
lock would be great except that writes must have exclusivity otherwise 
the readers will throw weird exceptions due to examining inconsistent state.

In another Java case, I tried to make the code lock-free by using a 
concurrent data structure and CAS loops.  Unfortunately, the code path 
is so much longer that it takes more time to execute than to have a 
shorter code path and wait on a lock.  The lock contention isn't high 
enough to warrant the change.  I am waiting for more concurrent server 
processors to finally tip the balance and justify the change.

-Nathan

On 12/3/2013 7:58 AM, Vitaly Davidovich wrote:
>
> So lock free may become a problem for extremely contended blocks - 
> lock free, assuming it's the basic CAS loop impl, may cause delays in 
> such cases as losing threads will continue spinning, tying up cpu 
> resources and generating coherence traffic.  In this case, using a 
> lock can be a net win.
>
> Also, perhaps the lock free implementation generates lots of garbage, 
> placing load on the GC.  Otherwise, lock free should be a net win 
> majority of the time.
>
> A proper Spinlock may be a good addition to the j.u.c toolbox as well.
>
> Sent from my phone
>
> On Dec 3, 2013 9:36 AM, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu 
> <mailto:heinz at javaspecialists.eu>> wrote:
>
>     Doug Lea wrote:
>
>         On 12/02/2013 09:31 PM, Vitaly Davidovich wrote:
>
>             Right, it's a bit unclear on what a good case for this
>             lock is.  I'm guessing
>             the advantage is if you use the optimistic version - that
>             avoids any expensive
>             stores and doesn't block writers - for tiny read code
>             sections on locks that are
>             read-mostly.  Otherwise, seems like it may not perform all
>             that well (e.g.
>             validate() missing in cache because another core wrote to
>             the lock in the meantime).
>
>             Builtin synchronizer (I.e synchronized keyword) for
>             small/cheap code sections
>             that don't contend seems decent enough.  Biased locking +
>             (adaptive) spinning
>             should, in theory, be good enough for these cases.
>
>
>         Please measure. Sometimes biased locking is fine, sometimes
>         much less
>         than fine. As a rule of thumb, if you expect contention not to
>         be rare,
>         consider using a j.u.c Lock. And unless you need reentrancy,
>         StampedLock
>         is often the best choice of these in terms of performance and
>         features.
>         I expect that Heinz's future installments will spell some of
>         this out
>         for many use cases, but ... please measure.
>
>     I did some measurements of StampedLock vs ReentrantReadWriteLock
>     and SL showed better performance and also did not suffer from the
>     same starvation issues as RRWL.  Martin Thompson also mentioned a
>     discussion we had on Crete in his blog:
>     http://mechanical-sympathy.blogspot.gr/2013/08/lock-based-vs-lock-free-concurrent.html
>
>     I still need to verify his findings.  My cursory tests showed that
>     in some cases, SL is better than Lock-Free immutable and in other
>     cases, plain old synchronized beats them both.  All depends how
>     you test this.
>
>
>             Also, one other thing synchronized has going for it is it
>             handles async aborts
>             of threads (I.e. thread.stop()).  I know stop() is
>             deprecated and all, but you
>             never know.
>
>
>         But you do know! As of JDK8, Thread.stop is really gone.
>         It is the first deprecated method to have actually been
>         de-implemented. It now just throws UnsupportedOperationException.
>
>     I think you're thinking of the Thread.stop(Throwable) method which
>     has unfortunately been removed in Java 8.
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/026cf86c/attachment.html>

From vitalyd at gmail.com  Tue Dec  3 12:14:05 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 12:14:05 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E033A.90903@oracle.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
Message-ID: <CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>

But this is only if you publish unsafely, as mentioned before.  If you
publish this class properly, you don't get races on the volatile.   Final
fields are supposed to support immutable classes, where although not
preferrable, publishing racily is plausible (for performance).  For
read/write volatiles, it's not compelling on the surface.

Sent from my phone
On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  Yes, but I mean that the code assumes the value to always be non-null -
> eg a sentinel entry of the list is created at construction time. Without
> the construction-time guarantee you'd need to test for null everywhere.
>
> I think the same applies in other constructors - if you write the
> initialization of the volatile, you imply that's "the least" "possible"
> value, the value representing the initial state of the concurrent algorithm
> - the initial value guaranteed by Java spec may not represent any valid
> state of the concurrent algorithm, let alone the initial state.
>
> That's why this really boils down to "find the broad cases where you do
> want to permit unsafe publication of the initial values of the volatiles".
>
>
> (unlike the non-volatile fields. Don't treat them as "not thread safe" -
> instead, treat them as "assume as made thread-safe by means outside the
> class specification", hence no requirement for "safe publication" there)
>
>
> Alex
>
>
> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>
> Initial value of the field must be the "zero" value of that type, that's a
> language spec and must be guaranteed irrespective of volatile or not.
>
> Sent from my phone
> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  I understand, but you can't insist on viewing ctors as "just methods"
>> for all purposes.
>>
>> (2) publication is unsafe unless you get a volatile load after the last
>> volatile store in the constructor. Besides, the initial value of the field
>> may not even be one of the valid values, so it is not even just about a
>> data race.
>>
>>
>> Alex
>>
>>
>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>
>> For compilation/codegen purposes ctors *are* just methods - they can be
>> inlined, code optimized, etc; that's the reason we have the final field
>> guarantees.
>>
>> A couple of potential reasons not to add volatile to the spec:
>> 1) perhaps some JVMs don't currently already give them final field
>> semantics
>> 2) this whole thing comes into play for unsafe publication only (I.e.
>> data race), which is discouraged.
>>
>> Sent from my phone
>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  Constructors *are* special methods. They are the first method calls in
>>> any history of the object. This means a different treatment of volatile
>>> accesses to the fields of the instance being created is possible - certain
>>> barriers can be eliminated, because the loads can be proven to not
>>> synchronize with anyone. For the sake of the argument, it is possible to
>>> proceed with weak treatment of volatile stores, too, but you need a good
>>> reason to permit subsequent calls to observe the initial state of the
>>> volatile fields; whereas any volatile load in any other method always
>>> synchronizes with a volatile store of some other method call, without the
>>> final field semantics we cannot assume that.
>>>
>>> However, if we assume final field semantics, there is only one barrier
>>> needed - a store-store after the last volatile field store. This eliminates
>>> all barriers for any other volatile field initialization, and eliminates a
>>> full barrier needed otherwise (got to place a dummy volatile load after the
>>> last volatile store to make sure the semantics are stronger than
>>> final-field) - think of removing a mfence or similar from each such
>>> constructor on x86.
>>>
>>> (there will still be gotchas for cases when volatile field
>>> initialization occurs after a volatile load of something outside the same
>>> instance; but the main purpose is to eliminate barriers when the volatile
>>> fields are just initialized into some instance-specific values)
>>>
>>>
>>> Alex
>>>
>>>
>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>
>>> I'm about why "always mean storestore after volatile store in
>>> constructor". It is not only efficiency which is important for MM, but also
>>> simplicity and consistency. If constructors are special methods, not just
>>> plain <init>, then we should add this kind of atomicity to all constructors
>>> (which, as I was reading here, could be inefficient on some platforms). But
>>> if constructors are just plain methods, it looks strange to have special
>>> implicit semantics for constructors with volatiles inside.
>>>
>>>
>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>
>>>>  I think it is pretty simple.
>>>>
>>>> If you always mean a store-store barrier *after* the last volatile
>>>> store in the constructor, then add that barrier into constructor semantics,
>>>> like it's done with the final fields.
>>>>
>>>> It makes sense to *not* add it to the semantics, if you can come up
>>>> with enough examples where you want that barrier to be eliminated.
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>
>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>> I mean, I could not see any noticable difference between the case
>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>> models. It is noway more unexpected then to see default values in fields of
>>>> any other object which is unsafely published. I think everybody who passed
>>>> through broken atomicity of constructor call could easy see the chance to
>>>> read [.value=0] in the case discussed.
>>>>
>>>>  "Data race is pure evil" was the motto of this list all time I was
>>>> reading it. Why do we may want to introduce another example of benign race?
>>>> Wouldn't it be just another source of confusion for newcomers?
>>>>
>>>>
>>>>
>>>>
>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>
>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>
>>>>>> Doug, could you explain why it is so important to have this kind of
>>>>>> safe
>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>> through data
>>>>>> race to be allowed result, as current model (seem to) imply? It seems
>>>>>> to be a
>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>
>>>>>
>>>>>  The main reason is that it is highly irregular and unexpected
>>>>> by programmers. Except in this case, volatiles definitionally cannot
>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>> complexity, and/or error-proneness that isn't even required for
>>>>> correctness on current JVMs. We have several constructions
>>>>> in j.u.c that work around problems by using explicit ordered
>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>> candidate for reconsideration.
>>>>>
>>>>> -Doug
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>> Ruslan
>>>>>>
>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>>>>>>
>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>>> optimizations to avoid zeroing memory is an implementation detail
>>>>>>>> and
>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think you're
>>>>>>>> saying.
>>>>>>>>
>>>>>>>> The other issue is that even if we determine that volatiles don't
>>>>>>>> get
>>>>>>>> this treatment, if JVM is already ensuring it, it's not going to be
>>>>>>>> practical to change it and risk hard to debug problems creeping in.
>>>>>>>>  May
>>>>>>>> as well update the spec now ...
>>>>>>>>
>>>>>>>
>>>>>>> Right. To summarize:
>>>>>>>
>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>> specifically
>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>
>>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>>> fields are
>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>
>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
>>>>>>> small tweak
>>>>>>> that I know applies). But now is a good time to be considering a full
>>>>>>> revision for JDK9.
>>>>>>>
>>>>>>> * In the mean time, it would make sense to further test and validate
>>>>>>> JVMs
>>>>>>> as meeting this likely future spec.
>>>>>>>
>>>>>>> -Doug
>>>>>>>
>>>>>>> _______________________________________________ Concurrency-interest
>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/5cd7fe23/attachment-0001.html>

From oleksandr.otenko at oracle.com  Tue Dec  3 12:20:52 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 17:20:52 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
Message-ID: <529E12F4.5070501@oracle.com>

Hmmm.... I thought it is clear no one argues about the "/*if*/ you 
publish safely" part. The question I am wondering about is whether you 
can find a case where publishing the reference to the instance unsafely 
is /intended/.

Alex

On 03/12/2013 17:14, Vitaly Davidovich wrote:
>
> But this is only if you publish unsafely, as mentioned before.  If you 
> publish this class properly, you don't get races on the volatile.   
> Final fields are supposed to support immutable classes, where although 
> not preferrable, publishing racily is plausible (for performance).  
> For read/write volatiles, it's not compelling on the surface.
>
> Sent from my phone
>
> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     Yes, but I mean that the code assumes the value to always be
>     non-null - eg a sentinel entry of the list is created at
>     construction time. Without the construction-time guarantee you'd
>     need to test for null everywhere.
>
>     I think the same applies in other constructors - if you write the
>     initialization of the volatile, you imply that's "the least"
>     "possible" value, the value representing the initial state of the
>     concurrent algorithm - the initial value guaranteed by Java spec
>     may not represent any valid state of the concurrent algorithm, let
>     alone the initial state.
>
>     That's why this really boils down to "find the broad cases where
>     you do want to permit unsafe publication of the initial values of
>     the volatiles".
>
>
>     (unlike the non-volatile fields. Don't treat them as "not thread
>     safe" - instead, treat them as "assume as made thread-safe by
>     means outside the class specification", hence no requirement for
>     "safe publication" there)
>
>
>     Alex
>
>
>     On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>
>>     Initial value of the field must be the "zero" value of that type,
>>     that's a language spec and must be guaranteed irrespective of
>>     volatile or not.
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 10:03 AM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         I understand, but you can't insist on viewing ctors as "just
>>         methods" for all purposes.
>>
>>         (2) publication is unsafe unless you get a volatile load
>>         after the last volatile store in the constructor. Besides,
>>         the initial value of the field may not even be one of the
>>         valid values, so it is not even just about a data race.
>>
>>
>>         Alex
>>
>>
>>         On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>
>>>         For compilation/codegen purposes ctors *are* just methods -
>>>         they can be inlined, code optimized, etc; that's the reason
>>>         we have the final field guarantees.
>>>
>>>         A couple of potential reasons not to add volatile to the spec:
>>>         1) perhaps some JVMs don't currently already give them final
>>>         field semantics
>>>         2) this whole thing comes into play for unsafe publication
>>>         only (I.e. data race), which is discouraged.
>>>
>>>         Sent from my phone
>>>
>>>         On Dec 3, 2013 6:51 AM, "Oleksandr Otenko"
>>>         <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>
>>>             Constructors /are/ special methods. They are the first
>>>             method calls in any history of the object. This means a
>>>             different treatment of volatile accesses to the fields
>>>             of the instance being created is possible - certain
>>>             barriers can be eliminated, because the loads can be
>>>             proven to not synchronize with anyone. For the sake of
>>>             the argument, it is possible to proceed with weak
>>>             treatment of volatile stores, too, but you need a good
>>>             reason to permit subsequent calls to observe the initial
>>>             state of the volatile fields; whereas any volatile load
>>>             in any other method always synchronizes with a volatile
>>>             store of some other method call, without the final field
>>>             semantics we cannot assume that.
>>>
>>>             However, if we assume final field semantics, there is
>>>             only one barrier needed - a store-store after the last
>>>             volatile field store. This eliminates all barriers for
>>>             any other volatile field initialization, and eliminates
>>>             a full barrier needed otherwise (got to place a dummy
>>>             volatile load after the last volatile store to make sure
>>>             the semantics are stronger than final-field) - think of
>>>             removing a mfence or similar from each such constructor
>>>             on x86.
>>>
>>>             (there will still be gotchas for cases when volatile
>>>             field initialization occurs after a volatile load of
>>>             something outside the same instance; but the main
>>>             purpose is to eliminate barriers when the volatile
>>>             fields are just initialized into some instance-specific
>>>             values)
>>>
>>>
>>>             Alex
>>>
>>>
>>>             On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>             I'm about why "always mean storestore after volatile
>>>>             store in constructor". It is not only efficiency which
>>>>             is important for MM, but also simplicity and
>>>>             consistency. If constructors are special methods, not
>>>>             just plain <init>, then we should add this kind of
>>>>             atomicity to all constructors (which, as I was reading
>>>>             here, could be inefficient on some platforms). But if
>>>>             constructors are just plain methods, it looks strange
>>>>             to have special implicit semantics for constructors
>>>>             with volatiles inside.
>>>>
>>>>
>>>>             2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com
>>>>             <mailto:oleksandr.otenko at oracle.com>>
>>>>
>>>>                 I think it is pretty simple.
>>>>
>>>>                 If you always mean a store-store barrier /after/
>>>>                 the last volatile store in the constructor, then
>>>>                 add that barrier into constructor semantics, like
>>>>                 it's done with the final fields.
>>>>
>>>>                 It makes sense to /not/ add it to the semantics, if
>>>>                 you can come up with enough examples where you want
>>>>                 that barrier to be eliminated.
>>>>
>>>>                 Alex
>>>>
>>>>
>>>>                 On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>                 Well, I do not see any data race _on volatiles_
>>>>>                 here. I see race condition on volatile .value, yes
>>>>>                 -- but it is pretty legal (and unavoidable, I
>>>>>                 suppose) to have race conditions even with
>>>>>                 volatiles involved. The only data race I see is
>>>>>                 around read-write of (non-volatile)
>>>>>                 AtomicInteger's reference -- which is unrelated to
>>>>>                 AtomicInteger's content. I mean, I could not see
>>>>>                 any noticable difference between the case
>>>>>                 discussed, and just any other case there volatile
>>>>>                 is _incorrectly_ used to "synchronize" data
>>>>>                 accesses -- it could still be data race on
>>>>>                 non-volatile fields, even if volatile fields are
>>>>>                 also used somewhere around. Yes, get 0 from .value
>>>>>                 is unexpected -- but there are many unexpected
>>>>>                 things in memory models. It is noway more
>>>>>                 unexpected then to see default values in fields of
>>>>>                 any other object which is unsafely published. I
>>>>>                 think everybody who passed through broken
>>>>>                 atomicity of constructor call could easy see the
>>>>>                 chance to read [.value=0] in the case discussed.
>>>>>
>>>>>                 "Data race is pure evil" was the motto of this
>>>>>                 list all time I was reading it. Why do we may want
>>>>>                 to introduce another example of benign race?
>>>>>                 Wouldn't it be just another source of confusion
>>>>>                 for newcomers?
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>                 2013/12/2 Doug Lea <dl at cs.oswego.edu
>>>>>                 <mailto:dl at cs.oswego.edu>>
>>>>>
>>>>>                     On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>
>>>>>                         Doug, could you explain why it is so
>>>>>                         important to have this kind of safe
>>>>>                         publication for volatile? I mean, could we
>>>>>                         just go with .value=0 through data
>>>>>                         race to be allowed result, as current
>>>>>                         model (seem to) imply? It seems to be a
>>>>>                         dr-case anyway, why we need special
>>>>>                         handling of it?
>>>>>
>>>>>
>>>>>                     The main reason is that it is highly irregular
>>>>>                     and unexpected
>>>>>                     by programmers. Except in this case, volatiles
>>>>>                     definitionally cannot
>>>>>                     be subject to data races. Dealing with it
>>>>>                     requires cleverness,
>>>>>                     complexity, and/or error-proneness that isn't
>>>>>                     even required for
>>>>>                     correctness on current JVMs. We have several
>>>>>                     constructions
>>>>>                     in j.u.c that work around problems by using
>>>>>                     explicit ordered
>>>>>                     writes in constructors, redundant-looking
>>>>>                     null-checks, and so
>>>>>                     on. If we are going to repair the JMM anyway,
>>>>>                     this is a clear
>>>>>                     candidate for reconsideration.
>>>>>
>>>>>                     -Doug
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>                         Ruslan
>>>>>
>>>>>                             27 ????. 2013 ?., ? 23:26, Doug Lea
>>>>>                             <dl at cs.oswego.edu
>>>>>                             <mailto:dl at cs.oswego.edu>> ???????(?):
>>>>>
>>>>>                                 On 11/27/2013 02:06 PM, Vitaly
>>>>>                                 Davidovich wrote: But either way,
>>>>>                                 optimizations to avoid zeroing
>>>>>                                 memory is an implementation detail and
>>>>>                                 thus cannot be relied upon from
>>>>>                                 JMM standpoint, which I think you're
>>>>>                                 saying.
>>>>>
>>>>>                                 The other issue is that even if we
>>>>>                                 determine that volatiles don't get
>>>>>                                 this treatment, if JVM is already
>>>>>                                 ensuring it, it's not going to be
>>>>>                                 practical to change it and risk
>>>>>                                 hard to debug problems creeping
>>>>>                                 in.  May
>>>>>                                 as well update the spec now ...
>>>>>
>>>>>
>>>>>                             Right. To summarize:
>>>>>
>>>>>                             * Programmers do not expect that even
>>>>>                             though final fields are specifically
>>>>>                             publication-safe, volatile fields are
>>>>>                             not always so.
>>>>>
>>>>>                             * For various implementation reasons,
>>>>>                             JVMs arrange that volatile fields are
>>>>>                             publication safe anyway, at least in
>>>>>                             cases we know about.
>>>>>
>>>>>                             * Actually updating the JMM/JLS to
>>>>>                             mandate this is not easy (no small tweak
>>>>>                             that I know applies). But now is a
>>>>>                             good time to be considering a full
>>>>>                             revision for JDK9.
>>>>>
>>>>>                             * In the mean time, it would make
>>>>>                             sense to further test and validate JVMs
>>>>>                             as meeting this likely future spec.
>>>>>
>>>>>                             -Doug
>>>>>
>>>>>                             _______________________________________________
>>>>>                             Concurrency-interest
>>>>>                             mailing list
>>>>>                             Concurrency-interest at cs.oswego.edu
>>>>>                             <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>                             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>                 _______________________________________________
>>>>>                 Concurrency-interest mailing list
>>>>>                 Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>                 _______________________________________________
>>>>                 Concurrency-interest mailing list
>>>>                 Concurrency-interest at cs.oswego.edu
>>>>                 <mailto:Concurrency-interest at cs.oswego.edu>
>>>>                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>>
>>>             _______________________________________________
>>>             Concurrency-interest mailing list
>>>             Concurrency-interest at cs.oswego.edu
>>>             <mailto:Concurrency-interest at cs.oswego.edu>
>>>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/5d4f6d87/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  3 12:21:43 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 12:21:43 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E011F.6060902@oracle.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E011F.6060902@oracle.com>
Message-ID: <CAHjP37HFcjSZx6ZR2HWgKLcqbzkqD925ho3v01BTXAu9PomC=w@mail.gmail.com>

The ctor is single threaded already, it's the publishing of the constructed
instance that could be a problem.  Someone writing a class constructor
doesn't know how it's going to be published, so burden is on caller to
publish it properly.  You can have a factory method that then publishes
safely, if one wants (or a bunch of other ways).  Otherwise, ctor is no
different than regular method; I can have ctor like this that doesn't
actually do anything other than call a chain of methods:
A(){
init1 ();
init 2();
...
}
This won't work for final fields because they need to be set in ctor.  For
volatiles, it's just code, whether inline with constructor or otherwise.

Sent from my phone
On Dec 3, 2013 11:10 AM, "Nathan Reynolds" <nathan.reynolds at oracle.com>
wrote:

>  Yes, the initial value of the field must be zero/null.  However, this
> could be a violation of the semantics of the class.
>
> Take for instance a field which is an enum.  The field will be initialized
> to null, but this could be a violation of the semantics of how the field is
> used.  The field could be required to be one of the enum values.  Anything
> unexpected and the rest of the class's code can't handle the situation.
>
> The constructor can be viewed as taking a raw uninitialized instance and
> preparing it to take a state that is expected and valid.  Even if the
> fields are zero/null, this is not an initialized state with respect to the
> class.  The state transition from invalid to valid can be very risky from a
> concurrency perspective and in some cases can only be done by a single
> thread.  Some constructors need the guarantee that only a single-thread is
> executing on the object at the time.  Many other constructors don't care
> since synchronization, if needed at all, must be taken care of outside of
> the class.
>
> Consider ConcurrentLinkedList which sets up the head and tail fields in
> the constructor.  These fields are volatiles.  Initially these fields are
> set to null.  The constructor transitions the instance from an illegal
> state (i.e. zero/null) into an expected state using multiple steps.  The
> constructor must do this without any other methods being invoked on the
> instance by other threads.  In this case, we could add logic to the rest of
> the methods in ConcurrentLinkedList which would detect a partially
> constructed object and then deal with it.  It would make the code very
> difficult, very error prone and less performant.  In other cases, it would
> be difficult to detect a partially constructed object and perhaps
> impossible for multiple threads to concurrently bring the object into a
> valid state.
>
> We need to a way for the code to state if the constructor requires
> single-threaded access.  Final field semantics is one way.  The question of
> this email is if volatile stores should be a way that tells the compiler
> that this constructor requires single-threaded access to the object.
>
> My position is yes.  There are cases where there are no final fields
> naturally occurring in the class yet there are plenty of volatile
> variables.  This requires the programmer to introduce one which wastes
> space.  There are cases where there are no final or volatile fields
> naturally occurring in the class.  Yet, the rest of the methods are
> synchronized and need the constructor to have single-threaded access.
>
> On the other hand, having final field (and potentially volatile stores)
> force the compiler to guarantee single-threaded access to the object is
> very subtle.  It would be better if the guarantee was more explicit in the
> code (e.g. adding the synchronized keyword to the constructor).
>
> -Nathan
>
> On 12/3/2013 8:08 AM, Vitaly Davidovich wrote:
>
> Initial value of the field must be the "zero" value of that type, that's a
> language spec and must be guaranteed irrespective of volatile or not.
>
> Sent from my phone
> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  I understand, but you can't insist on viewing ctors as "just methods"
>> for all purposes.
>>
>> (2) publication is unsafe unless you get a volatile load after the last
>> volatile store in the constructor. Besides, the initial value of the field
>> may not even be one of the valid values, so it is not even just about a
>> data race.
>>
>>
>> Alex
>>
>>
>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>
>> For compilation/codegen purposes ctors *are* just methods - they can be
>> inlined, code optimized, etc; that's the reason we have the final field
>> guarantees.
>>
>> A couple of potential reasons not to add volatile to the spec:
>> 1) perhaps some JVMs don't currently already give them final field
>> semantics
>> 2) this whole thing comes into play for unsafe publication only (I.e.
>> data race), which is discouraged.
>>
>> Sent from my phone
>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  Constructors *are* special methods. They are the first method calls in
>>> any history of the object. This means a different treatment of volatile
>>> accesses to the fields of the instance being created is possible - certain
>>> barriers can be eliminated, because the loads can be proven to not
>>> synchronize with anyone. For the sake of the argument, it is possible to
>>> proceed with weak treatment of volatile stores, too, but you need a good
>>> reason to permit subsequent calls to observe the initial state of the
>>> volatile fields; whereas any volatile load in any other method always
>>> synchronizes with a volatile store of some other method call, without the
>>> final field semantics we cannot assume that.
>>>
>>> However, if we assume final field semantics, there is only one barrier
>>> needed - a store-store after the last volatile field store. This eliminates
>>> all barriers for any other volatile field initialization, and eliminates a
>>> full barrier needed otherwise (got to place a dummy volatile load after the
>>> last volatile store to make sure the semantics are stronger than
>>> final-field) - think of removing a mfence or similar from each such
>>> constructor on x86.
>>>
>>> (there will still be gotchas for cases when volatile field
>>> initialization occurs after a volatile load of something outside the same
>>> instance; but the main purpose is to eliminate barriers when the volatile
>>> fields are just initialized into some instance-specific values)
>>>
>>>
>>> Alex
>>>
>>>
>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>
>>> I'm about why "always mean storestore after volatile store in
>>> constructor". It is not only efficiency which is important for MM, but also
>>> simplicity and consistency. If constructors are special methods, not just
>>> plain <init>, then we should add this kind of atomicity to all constructors
>>> (which, as I was reading here, could be inefficient on some platforms). But
>>> if constructors are just plain methods, it looks strange to have special
>>> implicit semantics for constructors with volatiles inside.
>>>
>>>
>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>
>>>>  I think it is pretty simple.
>>>>
>>>> If you always mean a store-store barrier *after* the last volatile
>>>> store in the constructor, then add that barrier into constructor semantics,
>>>> like it's done with the final fields.
>>>>
>>>> It makes sense to *not* add it to the semantics, if you can come up
>>>> with enough examples where you want that barrier to be eliminated.
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>
>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>> I mean, I could not see any noticable difference between the case
>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>> models. It is noway more unexpected then to see default values in fields of
>>>> any other object which is unsafely published. I think everybody who passed
>>>> through broken atomicity of constructor call could easy see the chance to
>>>> read [.value=0] in the case discussed.
>>>>
>>>>  "Data race is pure evil" was the motto of this list all time I was
>>>> reading it. Why do we may want to introduce another example of benign race?
>>>> Wouldn't it be just another source of confusion for newcomers?
>>>>
>>>>
>>>>
>>>>
>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>
>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>
>>>>>> Doug, could you explain why it is so important to have this kind of
>>>>>> safe
>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>> through data
>>>>>> race to be allowed result, as current model (seem to) imply? It seems
>>>>>> to be a
>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>
>>>>>
>>>>>  The main reason is that it is highly irregular and unexpected
>>>>> by programmers. Except in this case, volatiles definitionally cannot
>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>> complexity, and/or error-proneness that isn't even required for
>>>>> correctness on current JVMs. We have several constructions
>>>>> in j.u.c that work around problems by using explicit ordered
>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>> candidate for reconsideration.
>>>>>
>>>>> -Doug
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>> Ruslan
>>>>>>
>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>>>>>>
>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>>> optimizations to avoid zeroing memory is an implementation detail
>>>>>>>> and
>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think you're
>>>>>>>> saying.
>>>>>>>>
>>>>>>>> The other issue is that even if we determine that volatiles don't
>>>>>>>> get
>>>>>>>> this treatment, if JVM is already ensuring it, it's not going to be
>>>>>>>> practical to change it and risk hard to debug problems creeping in.
>>>>>>>>  May
>>>>>>>> as well update the spec now ...
>>>>>>>>
>>>>>>>
>>>>>>> Right. To summarize:
>>>>>>>
>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>> specifically
>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>
>>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>>> fields are
>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>
>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
>>>>>>> small tweak
>>>>>>> that I know applies). But now is a good time to be considering a full
>>>>>>> revision for JDK9.
>>>>>>>
>>>>>>> * In the mean time, it would make sense to further test and validate
>>>>>>> JVMs
>>>>>>> as meeting this likely future spec.
>>>>>>>
>>>>>>> -Doug
>>>>>>>
>>>>>>> _______________________________________________ Concurrency-interest
>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/a5d5f6b7/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  3 12:23:54 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 12:23:54 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E12F4.5070501@oracle.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
Message-ID: <CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>

I'm confident most code that publishes objects shared across threads does
it safely.  Otherwise we're saying majority of code uses data races?

Sent from my phone
On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  Hmmm.... I thought it is clear no one argues about the "*if* you publish
> safely" part. The question I am wondering about is whether you can find a
> case where publishing the reference to the instance unsafely is *intended*
> .
>
> Alex
>
> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>
> But this is only if you publish unsafely, as mentioned before.  If you
> publish this class properly, you don't get races on the volatile.   Final
> fields are supposed to support immutable classes, where although not
> preferrable, publishing racily is plausible (for performance).  For
> read/write volatiles, it's not compelling on the surface.
>
> Sent from my phone
> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  Yes, but I mean that the code assumes the value to always be non-null -
>> eg a sentinel entry of the list is created at construction time. Without
>> the construction-time guarantee you'd need to test for null everywhere.
>>
>> I think the same applies in other constructors - if you write the
>> initialization of the volatile, you imply that's "the least" "possible"
>> value, the value representing the initial state of the concurrent algorithm
>> - the initial value guaranteed by Java spec may not represent any valid
>> state of the concurrent algorithm, let alone the initial state.
>>
>> That's why this really boils down to "find the broad cases where you do
>> want to permit unsafe publication of the initial values of the volatiles".
>>
>>
>> (unlike the non-volatile fields. Don't treat them as "not thread safe" -
>> instead, treat them as "assume as made thread-safe by means outside the
>> class specification", hence no requirement for "safe publication" there)
>>
>>
>> Alex
>>
>>
>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>
>> Initial value of the field must be the "zero" value of that type, that's
>> a language spec and must be guaranteed irrespective of volatile or not.
>>
>> Sent from my phone
>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  I understand, but you can't insist on viewing ctors as "just methods"
>>> for all purposes.
>>>
>>> (2) publication is unsafe unless you get a volatile load after the last
>>> volatile store in the constructor. Besides, the initial value of the field
>>> may not even be one of the valid values, so it is not even just about a
>>> data race.
>>>
>>>
>>> Alex
>>>
>>>
>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>
>>> For compilation/codegen purposes ctors *are* just methods - they can be
>>> inlined, code optimized, etc; that's the reason we have the final field
>>> guarantees.
>>>
>>> A couple of potential reasons not to add volatile to the spec:
>>> 1) perhaps some JVMs don't currently already give them final field
>>> semantics
>>> 2) this whole thing comes into play for unsafe publication only (I.e.
>>> data race), which is discouraged.
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>
>>>>  Constructors *are* special methods. They are the first method calls
>>>> in any history of the object. This means a different treatment of volatile
>>>> accesses to the fields of the instance being created is possible - certain
>>>> barriers can be eliminated, because the loads can be proven to not
>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>> reason to permit subsequent calls to observe the initial state of the
>>>> volatile fields; whereas any volatile load in any other method always
>>>> synchronizes with a volatile store of some other method call, without the
>>>> final field semantics we cannot assume that.
>>>>
>>>> However, if we assume final field semantics, there is only one barrier
>>>> needed - a store-store after the last volatile field store. This eliminates
>>>> all barriers for any other volatile field initialization, and eliminates a
>>>> full barrier needed otherwise (got to place a dummy volatile load after the
>>>> last volatile store to make sure the semantics are stronger than
>>>> final-field) - think of removing a mfence or similar from each such
>>>> constructor on x86.
>>>>
>>>> (there will still be gotchas for cases when volatile field
>>>> initialization occurs after a volatile load of something outside the same
>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>> fields are just initialized into some instance-specific values)
>>>>
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>
>>>> I'm about why "always mean storestore after volatile store in
>>>> constructor". It is not only efficiency which is important for MM, but also
>>>> simplicity and consistency. If constructors are special methods, not just
>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>> if constructors are just plain methods, it looks strange to have special
>>>> implicit semantics for constructors with volatiles inside.
>>>>
>>>>
>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>
>>>>>  I think it is pretty simple.
>>>>>
>>>>> If you always mean a store-store barrier *after* the last volatile
>>>>> store in the constructor, then add that barrier into constructor semantics,
>>>>> like it's done with the final fields.
>>>>>
>>>>> It makes sense to *not* add it to the semantics, if you can come up
>>>>> with enough examples where you want that barrier to be eliminated.
>>>>>
>>>>> Alex
>>>>>
>>>>>
>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>
>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>> I mean, I could not see any noticable difference between the case
>>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>> any other object which is unsafely published. I think everybody who passed
>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>> read [.value=0] in the case discussed.
>>>>>
>>>>>  "Data race is pure evil" was the motto of this list all time I was
>>>>> reading it. Why do we may want to introduce another example of benign race?
>>>>> Wouldn't it be just another source of confusion for newcomers?
>>>>>
>>>>>
>>>>>
>>>>>
>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>
>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>
>>>>>>> Doug, could you explain why it is so important to have this kind of
>>>>>>> safe
>>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>>> through data
>>>>>>> race to be allowed result, as current model (seem to) imply? It
>>>>>>> seems to be a
>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>
>>>>>>
>>>>>>  The main reason is that it is highly irregular and unexpected
>>>>>> by programmers. Except in this case, volatiles definitionally cannot
>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>> correctness on current JVMs. We have several constructions
>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>> candidate for reconsideration.
>>>>>>
>>>>>> -Doug
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>> Ruslan
>>>>>>>
>>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>>>>>>>
>>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>>>> optimizations to avoid zeroing memory is an implementation detail
>>>>>>>>> and
>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think
>>>>>>>>> you're
>>>>>>>>> saying.
>>>>>>>>>
>>>>>>>>> The other issue is that even if we determine that volatiles don't
>>>>>>>>> get
>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going to be
>>>>>>>>> practical to change it and risk hard to debug problems creeping
>>>>>>>>> in.  May
>>>>>>>>> as well update the spec now ...
>>>>>>>>>
>>>>>>>>
>>>>>>>> Right. To summarize:
>>>>>>>>
>>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>>> specifically
>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>
>>>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>>>> fields are
>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>
>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
>>>>>>>> small tweak
>>>>>>>> that I know applies). But now is a good time to be considering a
>>>>>>>> full
>>>>>>>> revision for JDK9.
>>>>>>>>
>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>> validate JVMs
>>>>>>>> as meeting this likely future spec.
>>>>>>>>
>>>>>>>> -Doug
>>>>>>>>
>>>>>>>> _______________________________________________ Concurrency-interest
>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/b89582d3/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  3 12:29:55 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 12:29:55 -0500
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <529E066D.9020008@oracle.com>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
	<529DEB55.7080203@javaspecialists.eu>
	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
	<529E066D.9020008@oracle.com>
Message-ID: <CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>

Well, CAS guarantees somebody makes some progress.  On a very loaded
system, this is good (obviously) since otherwise a thread holding a lengthy
lock section can get context switched out or have high latency due to,
e.g., cache miss, and then nobody makes progress.  So yeah, on highly
concurrent hardware, CAS should be a net win for throughput over locks.

Sent from my phone
On Dec 3, 2013 11:31 AM, "Nathan Reynolds" <nathan.reynolds at oracle.com>
wrote:

>  In one C++ case, we have a read-write lock in which writes are very
> rare.  Having multiple threads execute CAS to update the number of readers
> holding the lock has been a source of contention.  A stamped lock would be
> great except that writes must have exclusivity otherwise the readers will
> throw weird exceptions due to examining inconsistent state.
>
> In another Java case, I tried to make the code lock-free by using a
> concurrent data structure and CAS loops.  Unfortunately, the code path is
> so much longer that it takes more time to execute than to have a shorter
> code path and wait on a lock.  The lock contention isn't high enough to
> warrant the change.  I am waiting for more concurrent server processors to
> finally tip the balance and justify the change.
>
> -Nathan
>
> On 12/3/2013 7:58 AM, Vitaly Davidovich wrote:
>
> So lock free may become a problem for extremely contended blocks - lock
> free, assuming it's the basic CAS loop impl, may cause delays in such cases
> as losing threads will continue spinning, tying up cpu resources and
> generating coherence traffic.  In this case, using a lock can be a net win.
>
> Also, perhaps the lock free implementation generates lots of garbage,
> placing load on the GC.  Otherwise, lock free should be a net win majority
> of the time.
>
> A proper Spinlock may be a good addition to the j.u.c toolbox as well.
>
> Sent from my phone
> On Dec 3, 2013 9:36 AM, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
> wrote:
>
>> Doug Lea wrote:
>>
>>> On 12/02/2013 09:31 PM, Vitaly Davidovich wrote:
>>>
>>>> Right, it's a bit unclear on what a good case for this lock is.  I'm
>>>> guessing
>>>> the advantage is if you use the optimistic version - that avoids any
>>>> expensive
>>>> stores and doesn't block writers - for tiny read code sections on locks
>>>> that are
>>>> read-mostly.  Otherwise, seems like it may not perform all that well
>>>> (e.g.
>>>> validate() missing in cache because another core wrote to the lock in
>>>> the meantime).
>>>>
>>>> Builtin synchronizer (I.e synchronized keyword) for small/cheap code
>>>> sections
>>>> that don't contend seems decent enough.  Biased locking + (adaptive)
>>>> spinning
>>>> should, in theory, be good enough for these cases.
>>>>
>>>
>>> Please measure. Sometimes biased locking is fine, sometimes much less
>>> than fine. As a rule of thumb, if you expect contention not to be rare,
>>> consider using a j.u.c Lock. And unless you need reentrancy, StampedLock
>>> is often the best choice of these in terms of performance and features.
>>> I expect that Heinz's future installments will spell some of this out
>>> for many use cases, but ... please measure.
>>>
>> I did some measurements of StampedLock vs ReentrantReadWriteLock and SL
>> showed better performance and also did not suffer from the same starvation
>> issues as RRWL.  Martin Thompson also mentioned a discussion we had on
>> Crete in his blog:
>> http://mechanical-sympathy.blogspot.gr/2013/08/lock-based-vs-lock-free-concurrent.html
>>
>> I still need to verify his findings.  My cursory tests showed that in
>> some cases, SL is better than Lock-Free immutable and in other cases, plain
>> old synchronized beats them both.  All depends how you test this.
>>
>>>
>>>> Also, one other thing synchronized has going for it is it handles async
>>>> aborts
>>>> of threads (I.e. thread.stop()).  I know stop() is deprecated and all,
>>>> but you
>>>> never know.
>>>>
>>>
>>> But you do know! As of JDK8, Thread.stop is really gone.
>>> It is the first deprecated method to have actually been
>>> de-implemented. It now just throws UnsupportedOperationException.
>>>
>>>  I think you're thinking of the Thread.stop(Throwable) method which has
>> unfortunately been removed in Java 8.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/4c5504fe/attachment.html>

From oleksandr.otenko at oracle.com  Tue Dec  3 12:41:53 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 17:41:53 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
Message-ID: <529E17E1.5030006@oracle.com>

No, this is a completely opposite view. The question is:

do you as the implementor of the concurrent algorithm ever intend the 
constructor design to be such that relies on the protocol that the 
caller chooses to publish the reference?

(Do you ever intend to /*not*/ specify a no-op volatile load after the 
last volatile store in the constructor?)


Alex


On 03/12/2013 17:23, Vitaly Davidovich wrote:
>
> I'm confident most code that publishes objects shared across threads 
> does it safely.  Otherwise we're saying majority of code uses data races?
>
> Sent from my phone
>
> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     Hmmm.... I thought it is clear no one argues about the "/*if*/ you
>     publish safely" part. The question I am wondering about is whether
>     you can find a case where publishing the reference to the instance
>     unsafely is /intended/.
>
>     Alex
>
>     On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>
>>     But this is only if you publish unsafely, as mentioned before. 
>>     If you publish this class properly, you don't get races on the
>>     volatile.   Final fields are supposed to support immutable
>>     classes, where although not preferrable, publishing racily is
>>     plausible (for performance).  For read/write volatiles, it's not
>>     compelling on the surface.
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 11:18 AM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         Yes, but I mean that the code assumes the value to always be
>>         non-null - eg a sentinel entry of the list is created at
>>         construction time. Without the construction-time guarantee
>>         you'd need to test for null everywhere.
>>
>>         I think the same applies in other constructors - if you write
>>         the initialization of the volatile, you imply that's "the
>>         least" "possible" value, the value representing the initial
>>         state of the concurrent algorithm - the initial value
>>         guaranteed by Java spec may not represent any valid state of
>>         the concurrent algorithm, let alone the initial state.
>>
>>         That's why this really boils down to "find the broad cases
>>         where you do want to permit unsafe publication of the initial
>>         values of the volatiles".
>>
>>
>>         (unlike the non-volatile fields. Don't treat them as "not
>>         thread safe" - instead, treat them as "assume as made
>>         thread-safe by means outside the class specification", hence
>>         no requirement for "safe publication" there)
>>
>>
>>         Alex
>>
>>
>>         On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>
>>>         Initial value of the field must be the "zero" value of that
>>>         type, that's a language spec and must be guaranteed
>>>         irrespective of volatile or not.
>>>
>>>         Sent from my phone
>>>
>>>         On Dec 3, 2013 10:03 AM, "Oleksandr Otenko"
>>>         <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>
>>>             I understand, but you can't insist on viewing ctors as
>>>             "just methods" for all purposes.
>>>
>>>             (2) publication is unsafe unless you get a volatile load
>>>             after the last volatile store in the constructor.
>>>             Besides, the initial value of the field may not even be
>>>             one of the valid values, so it is not even just about a
>>>             data race.
>>>
>>>
>>>             Alex
>>>
>>>
>>>             On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>
>>>>             For compilation/codegen purposes ctors *are* just
>>>>             methods - they can be inlined, code optimized, etc;
>>>>             that's the reason we have the final field guarantees.
>>>>
>>>>             A couple of potential reasons not to add volatile to
>>>>             the spec:
>>>>             1) perhaps some JVMs don't currently already give them
>>>>             final field semantics
>>>>             2) this whole thing comes into play for unsafe
>>>>             publication only (I.e. data race), which is discouraged.
>>>>
>>>>             Sent from my phone
>>>>
>>>>             On Dec 3, 2013 6:51 AM, "Oleksandr Otenko"
>>>>             <oleksandr.otenko at oracle.com
>>>>             <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>
>>>>                 Constructors /are/ special methods. They are the
>>>>                 first method calls in any history of the object.
>>>>                 This means a different treatment of volatile
>>>>                 accesses to the fields of the instance being
>>>>                 created is possible - certain barriers can be
>>>>                 eliminated, because the loads can be proven to not
>>>>                 synchronize with anyone. For the sake of the
>>>>                 argument, it is possible to proceed with weak
>>>>                 treatment of volatile stores, too, but you need a
>>>>                 good reason to permit subsequent calls to observe
>>>>                 the initial state of the volatile fields; whereas
>>>>                 any volatile load in any other method always
>>>>                 synchronizes with a volatile store of some other
>>>>                 method call, without the final field semantics we
>>>>                 cannot assume that.
>>>>
>>>>                 However, if we assume final field semantics, there
>>>>                 is only one barrier needed - a store-store after
>>>>                 the last volatile field store. This eliminates all
>>>>                 barriers for any other volatile field
>>>>                 initialization, and eliminates a full barrier
>>>>                 needed otherwise (got to place a dummy volatile
>>>>                 load after the last volatile store to make sure the
>>>>                 semantics are stronger than final-field) - think of
>>>>                 removing a mfence or similar from each such
>>>>                 constructor on x86.
>>>>
>>>>                 (there will still be gotchas for cases when
>>>>                 volatile field initialization occurs after a
>>>>                 volatile load of something outside the same
>>>>                 instance; but the main purpose is to eliminate
>>>>                 barriers when the volatile fields are just
>>>>                 initialized into some instance-specific values)
>>>>
>>>>
>>>>                 Alex
>>>>
>>>>
>>>>                 On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>                 I'm about why "always mean storestore after
>>>>>                 volatile store in constructor". It is not only
>>>>>                 efficiency which is important for MM, but also
>>>>>                 simplicity and consistency. If constructors are
>>>>>                 special methods, not just plain <init>, then we
>>>>>                 should add this kind of atomicity to all
>>>>>                 constructors (which, as I was reading here, could
>>>>>                 be inefficient on some platforms). But if
>>>>>                 constructors are just plain methods, it looks
>>>>>                 strange to have special implicit semantics for
>>>>>                 constructors with volatiles inside.
>>>>>
>>>>>
>>>>>                 2013/12/3 Oleksandr Otenko
>>>>>                 <oleksandr.otenko at oracle.com
>>>>>                 <mailto:oleksandr.otenko at oracle.com>>
>>>>>
>>>>>                     I think it is pretty simple.
>>>>>
>>>>>                     If you always mean a store-store barrier
>>>>>                     /after/ the last volatile store in the
>>>>>                     constructor, then add that barrier into
>>>>>                     constructor semantics, like it's done with the
>>>>>                     final fields.
>>>>>
>>>>>                     It makes sense to /not/ add it to the
>>>>>                     semantics, if you can come up with enough
>>>>>                     examples where you want that barrier to be
>>>>>                     eliminated.
>>>>>
>>>>>                     Alex
>>>>>
>>>>>
>>>>>                     On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>                     Well, I do not see any data race _on
>>>>>>                     volatiles_ here. I see race condition on
>>>>>>                     volatile .value, yes -- but it is pretty
>>>>>>                     legal (and unavoidable, I suppose) to have
>>>>>>                     race conditions even with volatiles involved.
>>>>>>                     The only data race I see is around read-write
>>>>>>                     of (non-volatile) AtomicInteger's reference
>>>>>>                     -- which is unrelated to AtomicInteger's
>>>>>>                     content. I mean, I could not see any
>>>>>>                     noticable difference between the case
>>>>>>                     discussed, and just any other case there
>>>>>>                     volatile is _incorrectly_ used to
>>>>>>                     "synchronize" data accesses -- it could still
>>>>>>                     be data race on non-volatile fields, even if
>>>>>>                     volatile fields are also used somewhere
>>>>>>                     around. Yes, get 0 from .value is unexpected
>>>>>>                     -- but there are many unexpected things in
>>>>>>                     memory models. It is noway more unexpected
>>>>>>                     then to see default values in fields of any
>>>>>>                     other object which is unsafely published. I
>>>>>>                     think everybody who passed through broken
>>>>>>                     atomicity of constructor call could easy see
>>>>>>                     the chance to read [.value=0] in the case
>>>>>>                     discussed.
>>>>>>
>>>>>>                     "Data race is pure evil" was the motto of
>>>>>>                     this list all time I was reading it. Why do
>>>>>>                     we may want to introduce another example of
>>>>>>                     benign race? Wouldn't it be just another
>>>>>>                     source of confusion for newcomers?
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>                     2013/12/2 Doug Lea <dl at cs.oswego.edu
>>>>>>                     <mailto:dl at cs.oswego.edu>>
>>>>>>
>>>>>>                         On 12/02/2013 03:57 AM, Cheremin Ruslan
>>>>>>                         wrote:
>>>>>>
>>>>>>                             Doug, could you explain why it is so
>>>>>>                             important to have this kind of safe
>>>>>>                             publication for volatile? I mean,
>>>>>>                             could we just go with .value=0
>>>>>>                             through data
>>>>>>                             race to be allowed result, as current
>>>>>>                             model (seem to) imply? It seems to be a
>>>>>>                             dr-case anyway, why we need special
>>>>>>                             handling of it?
>>>>>>
>>>>>>
>>>>>>                         The main reason is that it is highly
>>>>>>                         irregular and unexpected
>>>>>>                         by programmers. Except in this case,
>>>>>>                         volatiles definitionally cannot
>>>>>>                         be subject to data races. Dealing with it
>>>>>>                         requires cleverness,
>>>>>>                         complexity, and/or error-proneness that
>>>>>>                         isn't even required for
>>>>>>                         correctness on current JVMs. We have
>>>>>>                         several constructions
>>>>>>                         in j.u.c that work around problems by
>>>>>>                         using explicit ordered
>>>>>>                         writes in constructors, redundant-looking
>>>>>>                         null-checks, and so
>>>>>>                         on. If we are going to repair the JMM
>>>>>>                         anyway, this is a clear
>>>>>>                         candidate for reconsideration.
>>>>>>
>>>>>>                         -Doug
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>                             Ruslan
>>>>>>
>>>>>>                                 27 ????. 2013 ?., ? 23:26, Doug
>>>>>>                                 Lea <dl at cs.oswego.edu
>>>>>>                                 <mailto:dl at cs.oswego.edu>>
>>>>>>                                 ???????(?):
>>>>>>
>>>>>>                                     On 11/27/2013 02:06 PM,
>>>>>>                                     Vitaly Davidovich wrote: But
>>>>>>                                     either way,
>>>>>>                                     optimizations to avoid
>>>>>>                                     zeroing memory is an
>>>>>>                                     implementation detail and
>>>>>>                                     thus cannot be relied upon
>>>>>>                                     from JMM standpoint, which I
>>>>>>                                     think you're
>>>>>>                                     saying.
>>>>>>
>>>>>>                                     The other issue is that even
>>>>>>                                     if we determine that
>>>>>>                                     volatiles don't get
>>>>>>                                     this treatment, if JVM is
>>>>>>                                     already ensuring it, it's not
>>>>>>                                     going to be
>>>>>>                                     practical to change it and
>>>>>>                                     risk hard to debug problems
>>>>>>                                     creeping in.  May
>>>>>>                                     as well update the spec now ...
>>>>>>
>>>>>>
>>>>>>                                 Right. To summarize:
>>>>>>
>>>>>>                                 * Programmers do not expect that
>>>>>>                                 even though final fields are
>>>>>>                                 specifically
>>>>>>                                 publication-safe, volatile fields
>>>>>>                                 are not always so.
>>>>>>
>>>>>>                                 * For various implementation
>>>>>>                                 reasons, JVMs arrange that
>>>>>>                                 volatile fields are
>>>>>>                                 publication safe anyway, at least
>>>>>>                                 in cases we know about.
>>>>>>
>>>>>>                                 * Actually updating the JMM/JLS
>>>>>>                                 to mandate this is not easy (no
>>>>>>                                 small tweak
>>>>>>                                 that I know applies). But now is
>>>>>>                                 a good time to be considering a full
>>>>>>                                 revision for JDK9.
>>>>>>
>>>>>>                                 * In the mean time, it would make
>>>>>>                                 sense to further test and
>>>>>>                                 validate JVMs
>>>>>>                                 as meeting this likely future spec.
>>>>>>
>>>>>>                                 -Doug
>>>>>>
>>>>>>                                 _______________________________________________
>>>>>>                                 Concurrency-interest
>>>>>>                                 mailing list
>>>>>>                                 Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>                                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>                     _______________________________________________
>>>>>>                     Concurrency-interest mailing list
>>>>>>                     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>>                     _______________________________________________
>>>>>                     Concurrency-interest mailing list
>>>>>                     Concurrency-interest at cs.oswego.edu
>>>>>                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>>
>>>>                 _______________________________________________
>>>>                 Concurrency-interest mailing list
>>>>                 Concurrency-interest at cs.oswego.edu
>>>>                 <mailto:Concurrency-interest at cs.oswego.edu>
>>>>                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>
>>
>>         _______________________________________________
>>         Concurrency-interest mailing list
>>         Concurrency-interest at cs.oswego.edu
>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/6512c652/attachment-0001.html>

From zhong.j.yu at gmail.com  Tue Dec  3 12:46:41 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Tue, 3 Dec 2013 11:46:41 -0600
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <52964752.3020104@cs.oswego.edu>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
Message-ID: <CACuKZqGUAVd08tqdtFAa+RETQS-NayS-U8BUKFjmOs4BiAa+qA@mail.gmail.com>

This reminds me of a previous thread:

Stephen Colebourne raised the question of how to impose final field
semantics on fields that cannot be marked as `final`. [1]

He asked whether the problem can be solved by introducing volatile
read/write in constructor. [2]

David Holmes said no. [3]

Then Doug Lea said it's ok to just mark the fields as `volatile` [4].

Stephen adopts Doug's idea. [5] [6]

Doug's idea is incorrect per letter of the spec, but of course he
knows way more than that.

[1] http://cs.oswego.edu/pipermail/concurrency-interest/2011-June/007976.html
[2] http://cs.oswego.edu/pipermail/concurrency-interest/2011-June/007982.html
[3] http://cs.oswego.edu/pipermail/concurrency-interest/2011-June/007998.html
[4] http://cs.oswego.edu/pipermail/concurrency-interest/2011-June/008002.html
[5] http://cs.oswego.edu/pipermail/concurrency-interest/2011-June/008006.html
[6] https://github.com/JodaOrg/joda-time/blob/master/src/main/java/org/joda/time/base/BaseDateTime.java


On Wed, Nov 27, 2013 at 1:26 PM, Doug Lea <dl at cs.oswego.edu> wrote:
> On 11/27/2013 02:06 PM, Vitaly Davidovich wrote:
>>
>> But either
>> way, optimizations to avoid zeroing memory is an implementation detail and
>> thus
>> cannot be relied upon from JMM standpoint, which I think you're saying.
>>
>> The other issue is that even if we determine that volatiles don't get this
>> treatment, if JVM is already ensuring it, it's not going to be practical
>> to
>> change it and risk hard to debug problems creeping in.  May as well update
>> the
>> spec now ...
>
>
> Right. To summarize:
>
> * Programmers do not expect that even though final fields are specifically
> publication-safe, volatile fields are not always so.
>
> * For various implementation reasons, JVMs arrange that
> volatile fields are publication safe anyway, at least in
> cases we know about.
>
> * Actually updating the JMM/JLS to mandate this is not easy
> (no small tweak that I know applies). But now is a good time
> to be considering a full revision for JDK9.
>
> * In the mean time, it would make sense to further test
> and validate JVMs as meeting this likely future spec.
>
>
> -Doug
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From zhong.j.yu at gmail.com  Tue Dec  3 12:53:17 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Tue, 3 Dec 2013 11:53:17 -0600
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E011F.6060902@oracle.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E011F.6060902@oracle.com>
Message-ID: <CACuKZqF4xOEeDBz9_tqD+1X3J1pOny3Kn2a21KsX+z_F9-XC4w@mail.gmail.com>

I think Nathan's explanation is right on. It's just programmer's
intuition that initialization code should happen before all other
accesses to the object.

Some programmers also have the habit of explicit zeroing fields:

    class Foo
        int x = 0;

not realizing that there are two writes here, and the 2nd write could
be reordered to a later time which interferes with other reads/writes
and causes bugs (at least in theory). This is just too surprising.

Zhong Yu


On Tue, Dec 3, 2013 at 10:04 AM, Nathan Reynolds
<nathan.reynolds at oracle.com> wrote:
> Yes, the initial value of the field must be zero/null.  However, this could
> be a violation of the semantics of the class.
>
> Take for instance a field which is an enum.  The field will be initialized
> to null, but this could be a violation of the semantics of how the field is
> used.  The field could be required to be one of the enum values.  Anything
> unexpected and the rest of the class's code can't handle the situation.
>
> The constructor can be viewed as taking a raw uninitialized instance and
> preparing it to take a state that is expected and valid.  Even if the fields
> are zero/null, this is not an initialized state with respect to the class.
> The state transition from invalid to valid can be very risky from a
> concurrency perspective and in some cases can only be done by a single
> thread.  Some constructors need the guarantee that only a single-thread is
> executing on the object at the time.  Many other constructors don't care
> since synchronization, if needed at all, must be taken care of outside of
> the class.
>
> Consider ConcurrentLinkedList which sets up the head and tail fields in the
> constructor.  These fields are volatiles.  Initially these fields are set to
> null.  The constructor transitions the instance from an illegal state (i.e.
> zero/null) into an expected state using multiple steps.  The constructor
> must do this without any other methods being invoked on the instance by
> other threads.  In this case, we could add logic to the rest of the methods
> in ConcurrentLinkedList which would detect a partially constructed object
> and then deal with it.  It would make the code very difficult, very error
> prone and less performant.  In other cases, it would be difficult to detect
> a partially constructed object and perhaps impossible for multiple threads
> to concurrently bring the object into a valid state.
>
> We need to a way for the code to state if the constructor requires
> single-threaded access.  Final field semantics is one way.  The question of
> this email is if volatile stores should be a way that tells the compiler
> that this constructor requires single-threaded access to the object.
>
> My position is yes.  There are cases where there are no final fields
> naturally occurring in the class yet there are plenty of volatile variables.
> This requires the programmer to introduce one which wastes space.  There are
> cases where there are no final or volatile fields naturally occurring in the
> class.  Yet, the rest of the methods are synchronized and need the
> constructor to have single-threaded access.
>
> On the other hand, having final field (and potentially volatile stores)
> force the compiler to guarantee single-threaded access to the object is very
> subtle.  It would be better if the guarantee was more explicit in the code
> (e.g. adding the synchronized keyword to the constructor).
>
> -Nathan
>
> On 12/3/2013 8:08 AM, Vitaly Davidovich wrote:
>
> Initial value of the field must be the "zero" value of that type, that's a
> language spec and must be guaranteed irrespective of volatile or not.
>
> Sent from my phone
>
> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>>
>> I understand, but you can't insist on viewing ctors as "just methods" for
>> all purposes.
>>
>> (2) publication is unsafe unless you get a volatile load after the last
>> volatile store in the constructor. Besides, the initial value of the field
>> may not even be one of the valid values, so it is not even just about a data
>> race.
>>
>>
>> Alex
>>
>>
>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>
>> For compilation/codegen purposes ctors *are* just methods - they can be
>> inlined, code optimized, etc; that's the reason we have the final field
>> guarantees.
>>
>> A couple of potential reasons not to add volatile to the spec:
>> 1) perhaps some JVMs don't currently already give them final field
>> semantics
>> 2) this whole thing comes into play for unsafe publication only (I.e. data
>> race), which is discouraged.
>>
>> Sent from my phone
>>
>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>>
>>> Constructors are special methods. They are the first method calls in any
>>> history of the object. This means a different treatment of volatile accesses
>>> to the fields of the instance being created is possible - certain barriers
>>> can be eliminated, because the loads can be proven to not synchronize with
>>> anyone. For the sake of the argument, it is possible to proceed with weak
>>> treatment of volatile stores, too, but you need a good reason to permit
>>> subsequent calls to observe the initial state of the volatile fields;
>>> whereas any volatile load in any other method always synchronizes with a
>>> volatile store of some other method call, without the final field semantics
>>> we cannot assume that.
>>>
>>> However, if we assume final field semantics, there is only one barrier
>>> needed - a store-store after the last volatile field store. This eliminates
>>> all barriers for any other volatile field initialization, and eliminates a
>>> full barrier needed otherwise (got to place a dummy volatile load after the
>>> last volatile store to make sure the semantics are stronger than
>>> final-field) - think of removing a mfence or similar from each such
>>> constructor on x86.
>>>
>>> (there will still be gotchas for cases when volatile field initialization
>>> occurs after a volatile load of something outside the same instance; but the
>>> main purpose is to eliminate barriers when the volatile fields are just
>>> initialized into some instance-specific values)
>>>
>>>
>>> Alex
>>>
>>>
>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>
>>> I'm about why "always mean storestore after volatile store in
>>> constructor". It is not only efficiency which is important for MM, but also
>>> simplicity and consistency. If constructors are special methods, not just
>>> plain <init>, then we should add this kind of atomicity to all constructors
>>> (which, as I was reading here, could be inefficient on some platforms). But
>>> if constructors are just plain methods, it looks strange to have special
>>> implicit semantics for constructors with volatiles inside.
>>>
>>>
>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>
>>>> I think it is pretty simple.
>>>>
>>>> If you always mean a store-store barrier after the last volatile store
>>>> in the constructor, then add that barrier into constructor semantics, like
>>>> it's done with the final fields.
>>>>
>>>> It makes sense to not add it to the semantics, if you can come up with
>>>> enough examples where you want that barrier to be eliminated.
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>
>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>> I mean, I could not see any noticable difference between the case discussed,
>>>> and just any other case there volatile is _incorrectly_ used to
>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>> models. It is noway more unexpected then to see default values in fields of
>>>> any other object which is unsafely published. I think everybody who passed
>>>> through broken atomicity of constructor call could easy see the chance to
>>>> read [.value=0] in the case discussed.
>>>>
>>>> "Data race is pure evil" was the motto of this list all time I was
>>>> reading it. Why do we may want to introduce another example of benign race?
>>>> Wouldn't it be just another source of confusion for newcomers?
>>>>
>>>>
>>>>
>>>>
>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>
>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>
>>>>>> Doug, could you explain why it is so important to have this kind of
>>>>>> safe
>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>> through data
>>>>>> race to be allowed result, as current model (seem to) imply? It seems
>>>>>> to be a
>>>>>> dr-case anyway, why we need special handling of it?
>>>>>
>>>>>
>>>>> The main reason is that it is highly irregular and unexpected
>>>>> by programmers. Except in this case, volatiles definitionally cannot
>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>> complexity, and/or error-proneness that isn't even required for
>>>>> correctness on current JVMs. We have several constructions
>>>>> in j.u.c that work around problems by using explicit ordered
>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>> candidate for reconsideration.
>>>>>
>>>>> -Doug
>>>>>
>>>>>
>>>>>
>>>>>>
>>>>>> Ruslan
>>>>>>
>>>>>>> 27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>>>>>>
>>>>>>>> On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>>> optimizations to avoid zeroing memory is an implementation detail
>>>>>>>> and
>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think you're
>>>>>>>> saying.
>>>>>>>>
>>>>>>>> The other issue is that even if we determine that volatiles don't
>>>>>>>> get
>>>>>>>> this treatment, if JVM is already ensuring it, it's not going to be
>>>>>>>> practical to change it and risk hard to debug problems creeping in.
>>>>>>>> May
>>>>>>>> as well update the spec now ...
>>>>>>>
>>>>>>>
>>>>>>> Right. To summarize:
>>>>>>>
>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>> specifically
>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>
>>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>>> fields are
>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>
>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no small
>>>>>>> tweak
>>>>>>> that I know applies). But now is a good time to be considering a full
>>>>>>> revision for JDK9.
>>>>>>>
>>>>>>> * In the mean time, it would make sense to further test and validate
>>>>>>> JVMs
>>>>>>> as meeting this likely future spec.
>>>>>>>
>>>>>>> -Doug
>>>>>>>
>>>>>>> _______________________________________________ Concurrency-interest
>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From vitalyd at gmail.com  Tue Dec  3 12:53:21 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 12:53:21 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E17E1.5030006@oracle.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
Message-ID: <CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>

Not sure that's the right view either.  The one thing the author does not
control is how instances of their class are passed around.  User of the
class has more context - it may actually be ok that volatiles aren't fenced
here because they're already ensuring some way that it's fine, including
the possibility that the instance isn't even shared at all.  As long as
people know the behavior of the language/platform, they should be expected
to make an educated decision on their own.

Look, if performance didn't matter, you could just blindly say that all
constructors have a freeze action, regardless of final fields or volatile.
That's not the case, of course.  Java and JDK have tools available to
publish safely, so people doing multithreading have the ability to do the
right thing.  At the end of the day, exposing concurrency to devs will lead
to bugs, even beside the issues described here.

Sent from my phone
On Dec 3, 2013 12:42 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  No, this is a completely opposite view. The question is:
>
> do you as the implementor of the concurrent algorithm ever intend the
> constructor design to be such that relies on the protocol that the caller
> chooses to publish the reference?
>
> (Do you ever intend to *not* specify a no-op volatile load after the last
> volatile store in the constructor?)
>
>
> Alex
>
>
> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>
> I'm confident most code that publishes objects shared across threads does
> it safely.  Otherwise we're saying majority of code uses data races?
>
> Sent from my phone
> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  Hmmm.... I thought it is clear no one argues about the "*if* you
>> publish safely" part. The question I am wondering about is whether you can
>> find a case where publishing the reference to the instance unsafely is
>> *intended*.
>>
>> Alex
>>
>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>
>> But this is only if you publish unsafely, as mentioned before.  If you
>> publish this class properly, you don't get races on the volatile.   Final
>> fields are supposed to support immutable classes, where although not
>> preferrable, publishing racily is plausible (for performance).  For
>> read/write volatiles, it's not compelling on the surface.
>>
>> Sent from my phone
>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  Yes, but I mean that the code assumes the value to always be non-null -
>>> eg a sentinel entry of the list is created at construction time. Without
>>> the construction-time guarantee you'd need to test for null everywhere.
>>>
>>> I think the same applies in other constructors - if you write the
>>> initialization of the volatile, you imply that's "the least" "possible"
>>> value, the value representing the initial state of the concurrent algorithm
>>> - the initial value guaranteed by Java spec may not represent any valid
>>> state of the concurrent algorithm, let alone the initial state.
>>>
>>> That's why this really boils down to "find the broad cases where you do
>>> want to permit unsafe publication of the initial values of the volatiles".
>>>
>>>
>>> (unlike the non-volatile fields. Don't treat them as "not thread safe" -
>>> instead, treat them as "assume as made thread-safe by means outside the
>>> class specification", hence no requirement for "safe publication" there)
>>>
>>>
>>> Alex
>>>
>>>
>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>
>>> Initial value of the field must be the "zero" value of that type, that's
>>> a language spec and must be guaranteed irrespective of volatile or not.
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>
>>>>  I understand, but you can't insist on viewing ctors as "just methods"
>>>> for all purposes.
>>>>
>>>> (2) publication is unsafe unless you get a volatile load after the last
>>>> volatile store in the constructor. Besides, the initial value of the field
>>>> may not even be one of the valid values, so it is not even just about a
>>>> data race.
>>>>
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>
>>>> For compilation/codegen purposes ctors *are* just methods - they can be
>>>> inlined, code optimized, etc; that's the reason we have the final field
>>>> guarantees.
>>>>
>>>> A couple of potential reasons not to add volatile to the spec:
>>>> 1) perhaps some JVMs don't currently already give them final field
>>>> semantics
>>>> 2) this whole thing comes into play for unsafe publication only (I.e.
>>>> data race), which is discouraged.
>>>>
>>>> Sent from my phone
>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>>> wrote:
>>>>
>>>>>  Constructors *are* special methods. They are the first method calls
>>>>> in any history of the object. This means a different treatment of volatile
>>>>> accesses to the fields of the instance being created is possible - certain
>>>>> barriers can be eliminated, because the loads can be proven to not
>>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>>> reason to permit subsequent calls to observe the initial state of the
>>>>> volatile fields; whereas any volatile load in any other method always
>>>>> synchronizes with a volatile store of some other method call, without the
>>>>> final field semantics we cannot assume that.
>>>>>
>>>>> However, if we assume final field semantics, there is only one barrier
>>>>> needed - a store-store after the last volatile field store. This eliminates
>>>>> all barriers for any other volatile field initialization, and eliminates a
>>>>> full barrier needed otherwise (got to place a dummy volatile load after the
>>>>> last volatile store to make sure the semantics are stronger than
>>>>> final-field) - think of removing a mfence or similar from each such
>>>>> constructor on x86.
>>>>>
>>>>> (there will still be gotchas for cases when volatile field
>>>>> initialization occurs after a volatile load of something outside the same
>>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>>> fields are just initialized into some instance-specific values)
>>>>>
>>>>>
>>>>> Alex
>>>>>
>>>>>
>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>
>>>>> I'm about why "always mean storestore after volatile store in
>>>>> constructor". It is not only efficiency which is important for MM, but also
>>>>> simplicity and consistency. If constructors are special methods, not just
>>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>>> if constructors are just plain methods, it looks strange to have special
>>>>> implicit semantics for constructors with volatiles inside.
>>>>>
>>>>>
>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>>
>>>>>>  I think it is pretty simple.
>>>>>>
>>>>>> If you always mean a store-store barrier *after* the last volatile
>>>>>> store in the constructor, then add that barrier into constructor semantics,
>>>>>> like it's done with the final fields.
>>>>>>
>>>>>> It makes sense to *not* add it to the semantics, if you can come up
>>>>>> with enough examples where you want that barrier to be eliminated.
>>>>>>
>>>>>> Alex
>>>>>>
>>>>>>
>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>
>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>>> I mean, I could not see any noticable difference between the case
>>>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>>> any other object which is unsafely published. I think everybody who passed
>>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>>> read [.value=0] in the case discussed.
>>>>>>
>>>>>>  "Data race is pure evil" was the motto of this list all time I was
>>>>>> reading it. Why do we may want to introduce another example of benign race?
>>>>>> Wouldn't it be just another source of confusion for newcomers?
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>>
>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>>
>>>>>>>> Doug, could you explain why it is so important to have this kind of
>>>>>>>> safe
>>>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>>>> through data
>>>>>>>> race to be allowed result, as current model (seem to) imply? It
>>>>>>>> seems to be a
>>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>>
>>>>>>>
>>>>>>>  The main reason is that it is highly irregular and unexpected
>>>>>>> by programmers. Except in this case, volatiles definitionally cannot
>>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>>> correctness on current JVMs. We have several constructions
>>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>>> candidate for reconsideration.
>>>>>>>
>>>>>>> -Doug
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>> Ruslan
>>>>>>>>
>>>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>>>>>>>>
>>>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>>>>> optimizations to avoid zeroing memory is an implementation detail
>>>>>>>>>> and
>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think
>>>>>>>>>> you're
>>>>>>>>>> saying.
>>>>>>>>>>
>>>>>>>>>> The other issue is that even if we determine that volatiles don't
>>>>>>>>>> get
>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going to
>>>>>>>>>> be
>>>>>>>>>> practical to change it and risk hard to debug problems creeping
>>>>>>>>>> in.  May
>>>>>>>>>> as well update the spec now ...
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>> Right. To summarize:
>>>>>>>>>
>>>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>>>> specifically
>>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>>
>>>>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>>>>> fields are
>>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>>
>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
>>>>>>>>> small tweak
>>>>>>>>> that I know applies). But now is a good time to be considering a
>>>>>>>>> full
>>>>>>>>> revision for JDK9.
>>>>>>>>>
>>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>>> validate JVMs
>>>>>>>>> as meeting this likely future spec.
>>>>>>>>>
>>>>>>>>> -Doug
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest
>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/1fa24558/attachment-0001.html>

From cheremin at gmail.com  Tue Dec  3 12:56:39 2013
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Tue, 3 Dec 2013 21:56:39 +0400
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E17E1.5030006@oracle.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
Message-ID: <CAOwENi+7ROc+bQ1b5yPdYzBR6a9gNLBKyQV2MwYBvpnrsbe24g@mail.gmail.com>

I may ask you the complimentary question: do you want publication via data
race to be widely adopted since ctors are safe against it? Do you really
hope such practice would not go farther only publication, and would not
lead to assumption "data race is generally not dangerous"?


As about ctors: I bet if you ask 100 java programmers about the difference
between
  sharedRef = new A();
  sharedRef.init(42);
and
  sharedRef = new A(42);

90 of them say second is just shortcut for first.



2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>

>  No, this is a completely opposite view. The question is:
>
> do you as the implementor of the concurrent algorithm ever intend the
> constructor design to be such that relies on the protocol that the caller
> chooses to publish the reference?
>
> (Do you ever intend to *not* specify a no-op volatile load after the last
> volatile store in the constructor?)
>
>
> Alex
>
>
>
> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>
> I'm confident most code that publishes objects shared across threads does
> it safely.  Otherwise we're saying majority of code uses data races?
>
> Sent from my phone
> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  Hmmm.... I thought it is clear no one argues about the "*if* you
>> publish safely" part. The question I am wondering about is whether you can
>> find a case where publishing the reference to the instance unsafely is
>> *intended*.
>>
>> Alex
>>
>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>
>> But this is only if you publish unsafely, as mentioned before.  If you
>> publish this class properly, you don't get races on the volatile.   Final
>> fields are supposed to support immutable classes, where although not
>> preferrable, publishing racily is plausible (for performance).  For
>> read/write volatiles, it's not compelling on the surface.
>>
>> Sent from my phone
>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  Yes, but I mean that the code assumes the value to always be non-null -
>>> eg a sentinel entry of the list is created at construction time. Without
>>> the construction-time guarantee you'd need to test for null everywhere.
>>>
>>> I think the same applies in other constructors - if you write the
>>> initialization of the volatile, you imply that's "the least" "possible"
>>> value, the value representing the initial state of the concurrent algorithm
>>> - the initial value guaranteed by Java spec may not represent any valid
>>> state of the concurrent algorithm, let alone the initial state.
>>>
>>> That's why this really boils down to "find the broad cases where you do
>>> want to permit unsafe publication of the initial values of the volatiles".
>>>
>>>
>>> (unlike the non-volatile fields. Don't treat them as "not thread safe" -
>>> instead, treat them as "assume as made thread-safe by means outside the
>>> class specification", hence no requirement for "safe publication" there)
>>>
>>>
>>> Alex
>>>
>>>
>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>
>>> Initial value of the field must be the "zero" value of that type, that's
>>> a language spec and must be guaranteed irrespective of volatile or not.
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>
>>>>  I understand, but you can't insist on viewing ctors as "just methods"
>>>> for all purposes.
>>>>
>>>> (2) publication is unsafe unless you get a volatile load after the last
>>>> volatile store in the constructor. Besides, the initial value of the field
>>>> may not even be one of the valid values, so it is not even just about a
>>>> data race.
>>>>
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>
>>>> For compilation/codegen purposes ctors *are* just methods - they can be
>>>> inlined, code optimized, etc; that's the reason we have the final field
>>>> guarantees.
>>>>
>>>> A couple of potential reasons not to add volatile to the spec:
>>>> 1) perhaps some JVMs don't currently already give them final field
>>>> semantics
>>>> 2) this whole thing comes into play for unsafe publication only (I.e.
>>>> data race), which is discouraged.
>>>>
>>>> Sent from my phone
>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>>> wrote:
>>>>
>>>>>  Constructors *are* special methods. They are the first method calls
>>>>> in any history of the object. This means a different treatment of volatile
>>>>> accesses to the fields of the instance being created is possible - certain
>>>>> barriers can be eliminated, because the loads can be proven to not
>>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>>> reason to permit subsequent calls to observe the initial state of the
>>>>> volatile fields; whereas any volatile load in any other method always
>>>>> synchronizes with a volatile store of some other method call, without the
>>>>> final field semantics we cannot assume that.
>>>>>
>>>>> However, if we assume final field semantics, there is only one barrier
>>>>> needed - a store-store after the last volatile field store. This eliminates
>>>>> all barriers for any other volatile field initialization, and eliminates a
>>>>> full barrier needed otherwise (got to place a dummy volatile load after the
>>>>> last volatile store to make sure the semantics are stronger than
>>>>> final-field) - think of removing a mfence or similar from each such
>>>>> constructor on x86.
>>>>>
>>>>> (there will still be gotchas for cases when volatile field
>>>>> initialization occurs after a volatile load of something outside the same
>>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>>> fields are just initialized into some instance-specific values)
>>>>>
>>>>>
>>>>> Alex
>>>>>
>>>>>
>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>
>>>>> I'm about why "always mean storestore after volatile store in
>>>>> constructor". It is not only efficiency which is important for MM, but also
>>>>> simplicity and consistency. If constructors are special methods, not just
>>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>>> if constructors are just plain methods, it looks strange to have special
>>>>> implicit semantics for constructors with volatiles inside.
>>>>>
>>>>>
>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>>
>>>>>>  I think it is pretty simple.
>>>>>>
>>>>>> If you always mean a store-store barrier *after* the last volatile
>>>>>> store in the constructor, then add that barrier into constructor semantics,
>>>>>> like it's done with the final fields.
>>>>>>
>>>>>> It makes sense to *not* add it to the semantics, if you can come up
>>>>>> with enough examples where you want that barrier to be eliminated.
>>>>>>
>>>>>> Alex
>>>>>>
>>>>>>
>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>
>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>>> I mean, I could not see any noticable difference between the case
>>>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>>> any other object which is unsafely published. I think everybody who passed
>>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>>> read [.value=0] in the case discussed.
>>>>>>
>>>>>>  "Data race is pure evil" was the motto of this list all time I was
>>>>>> reading it. Why do we may want to introduce another example of benign race?
>>>>>> Wouldn't it be just another source of confusion for newcomers?
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>>
>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>>
>>>>>>>> Doug, could you explain why it is so important to have this kind of
>>>>>>>> safe
>>>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>>>> through data
>>>>>>>> race to be allowed result, as current model (seem to) imply? It
>>>>>>>> seems to be a
>>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>>
>>>>>>>
>>>>>>>  The main reason is that it is highly irregular and unexpected
>>>>>>> by programmers. Except in this case, volatiles definitionally cannot
>>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>>> correctness on current JVMs. We have several constructions
>>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>>> candidate for reconsideration.
>>>>>>>
>>>>>>> -Doug
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>> Ruslan
>>>>>>>>
>>>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>>>>>>>>
>>>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>>>>> optimizations to avoid zeroing memory is an implementation detail
>>>>>>>>>> and
>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think
>>>>>>>>>> you're
>>>>>>>>>> saying.
>>>>>>>>>>
>>>>>>>>>> The other issue is that even if we determine that volatiles don't
>>>>>>>>>> get
>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going to
>>>>>>>>>> be
>>>>>>>>>> practical to change it and risk hard to debug problems creeping
>>>>>>>>>> in.  May
>>>>>>>>>> as well update the spec now ...
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>> Right. To summarize:
>>>>>>>>>
>>>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>>>> specifically
>>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>>
>>>>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>>>>> fields are
>>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>>
>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
>>>>>>>>> small tweak
>>>>>>>>> that I know applies). But now is a good time to be considering a
>>>>>>>>> full
>>>>>>>>> revision for JDK9.
>>>>>>>>>
>>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>>> validate JVMs
>>>>>>>>> as meeting this likely future spec.
>>>>>>>>>
>>>>>>>>> -Doug
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest
>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/e5c4a108/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  3 12:57:14 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 12:57:14 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CACuKZqGUAVd08tqdtFAa+RETQS-NayS-U8BUKFjmOs4BiAa+qA@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<CACuKZqGUAVd08tqdtFAa+RETQS-NayS-U8BUKFjmOs4BiAa+qA@mail.gmail.com>
Message-ID: <CAHjP37FqjtqW038zWaK6fxxPgp4TGEHmfjTSMZ9w5fDEtqMU6g@mail.gmail.com>

Well, this just reinforces the idea that volatile fields don't make sense
for these fine-grained control cases.  It's not the field that's volatile,
but access to it that needs certain order, and that order may vary.  I
understand the desire to keep the model simpler for users, but that's
really what it boils down to.

If we had c++11 atomics or a fence api, people can fine tune their stuff
accordingly instead of piggybacking on volatile/final.

Sent from my phone
On Dec 3, 2013 12:46 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:

> This reminds me of a previous thread:
>
> Stephen Colebourne raised the question of how to impose final field
> semantics on fields that cannot be marked as `final`. [1]
>
> He asked whether the problem can be solved by introducing volatile
> read/write in constructor. [2]
>
> David Holmes said no. [3]
>
> Then Doug Lea said it's ok to just mark the fields as `volatile` [4].
>
> Stephen adopts Doug's idea. [5] [6]
>
> Doug's idea is incorrect per letter of the spec, but of course he
> knows way more than that.
>
> [1]
> http://cs.oswego.edu/pipermail/concurrency-interest/2011-June/007976.html
> [2]
> http://cs.oswego.edu/pipermail/concurrency-interest/2011-June/007982.html
> [3]
> http://cs.oswego.edu/pipermail/concurrency-interest/2011-June/007998.html
> [4]
> http://cs.oswego.edu/pipermail/concurrency-interest/2011-June/008002.html
> [5]
> http://cs.oswego.edu/pipermail/concurrency-interest/2011-June/008006.html
> [6]
> https://github.com/JodaOrg/joda-time/blob/master/src/main/java/org/joda/time/base/BaseDateTime.java
>
>
> On Wed, Nov 27, 2013 at 1:26 PM, Doug Lea <dl at cs.oswego.edu> wrote:
> > On 11/27/2013 02:06 PM, Vitaly Davidovich wrote:
> >>
> >> But either
> >> way, optimizations to avoid zeroing memory is an implementation detail
> and
> >> thus
> >> cannot be relied upon from JMM standpoint, which I think you're saying.
> >>
> >> The other issue is that even if we determine that volatiles don't get
> this
> >> treatment, if JVM is already ensuring it, it's not going to be practical
> >> to
> >> change it and risk hard to debug problems creeping in.  May as well
> update
> >> the
> >> spec now ...
> >
> >
> > Right. To summarize:
> >
> > * Programmers do not expect that even though final fields are
> specifically
> > publication-safe, volatile fields are not always so.
> >
> > * For various implementation reasons, JVMs arrange that
> > volatile fields are publication safe anyway, at least in
> > cases we know about.
> >
> > * Actually updating the JMM/JLS to mandate this is not easy
> > (no small tweak that I know applies). But now is a good time
> > to be considering a full revision for JDK9.
> >
> > * In the mean time, it would make sense to further test
> > and validate JVMs as meeting this likely future spec.
> >
> >
> > -Doug
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/9e32b457/attachment.html>

From oleksandr.otenko at oracle.com  Tue Dec  3 13:04:56 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 18:04:56 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
References: <5295E24C.40608@oracle.com>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
Message-ID: <529E1D48.5020500@oracle.com>

Sure.

f=42;

already imposes the cost of store-store barrier.

f=42;
f=42;

does the same thing. In a constructor, eliminate the first barrier, 
because the order of writes to the unreachable instance is not 
important, and the second store. This no longer is the question of 
performance, because it is the same. It is the question of correctness 
for free.

Alex

On 03/12/2013 17:53, Vitaly Davidovich wrote:
>
> Not sure that's the right view either.  The one thing the author does 
> not control is how instances of their class are passed around.  User 
> of the class has more context - it may actually be ok that volatiles 
> aren't fenced here because they're already ensuring some way that it's 
> fine, including the possibility that the instance isn't even shared at 
> all.  As long as people know the behavior of the language/platform, 
> they should be expected to make an educated decision on their own.
>
> Look, if performance didn't matter, you could just blindly say that 
> all constructors have a freeze action, regardless of final fields or 
> volatile.  That's not the case, of course.  Java and JDK have tools 
> available to publish safely, so people doing multithreading have the 
> ability to do the right thing.  At the end of the day, exposing 
> concurrency to devs will lead to bugs, even beside the issues 
> described here.
>
> Sent from my phone
>
> On Dec 3, 2013 12:42 PM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     No, this is a completely opposite view. The question is:
>
>     do you as the implementor of the concurrent algorithm ever intend
>     the constructor design to be such that relies on the protocol that
>     the caller chooses to publish the reference?
>
>     (Do you ever intend to /*not*/ specify a no-op volatile load after
>     the last volatile store in the constructor?)
>
>
>     Alex
>
>
>     On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>
>>     I'm confident most code that publishes objects shared across
>>     threads does it safely.  Otherwise we're saying majority of code
>>     uses data races?
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 12:21 PM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         Hmmm.... I thought it is clear no one argues about the
>>         "/*if*/ you publish safely" part. The question I am wondering
>>         about is whether you can find a case where publishing the
>>         reference to the instance unsafely is /intended/.
>>
>>         Alex
>>
>>         On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>
>>>         But this is only if you publish unsafely, as mentioned
>>>         before.  If you publish this class properly, you don't get
>>>         races on the volatile.   Final fields are supposed to
>>>         support immutable classes, where although not preferrable,
>>>         publishing racily is plausible (for performance).  For
>>>         read/write volatiles, it's not compelling on the surface.
>>>
>>>         Sent from my phone
>>>
>>>         On Dec 3, 2013 11:18 AM, "Oleksandr Otenko"
>>>         <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>
>>>             Yes, but I mean that the code assumes the value to
>>>             always be non-null - eg a sentinel entry of the list is
>>>             created at construction time. Without the
>>>             construction-time guarantee you'd need to test for null
>>>             everywhere.
>>>
>>>             I think the same applies in other constructors - if you
>>>             write the initialization of the volatile, you imply
>>>             that's "the least" "possible" value, the value
>>>             representing the initial state of the concurrent
>>>             algorithm - the initial value guaranteed by Java spec
>>>             may not represent any valid state of the concurrent
>>>             algorithm, let alone the initial state.
>>>
>>>             That's why this really boils down to "find the broad
>>>             cases where you do want to permit unsafe publication of
>>>             the initial values of the volatiles".
>>>
>>>
>>>             (unlike the non-volatile fields. Don't treat them as
>>>             "not thread safe" - instead, treat them as "assume as
>>>             made thread-safe by means outside the class
>>>             specification", hence no requirement for "safe
>>>             publication" there)
>>>
>>>
>>>             Alex
>>>
>>>
>>>             On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>
>>>>             Initial value of the field must be the "zero" value of
>>>>             that type, that's a language spec and must be
>>>>             guaranteed irrespective of volatile or not.
>>>>
>>>>             Sent from my phone
>>>>
>>>>             On Dec 3, 2013 10:03 AM, "Oleksandr Otenko"
>>>>             <oleksandr.otenko at oracle.com
>>>>             <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>
>>>>                 I understand, but you can't insist on viewing ctors
>>>>                 as "just methods" for all purposes.
>>>>
>>>>                 (2) publication is unsafe unless you get a volatile
>>>>                 load after the last volatile store in the
>>>>                 constructor. Besides, the initial value of the
>>>>                 field may not even be one of the valid values, so
>>>>                 it is not even just about a data race.
>>>>
>>>>
>>>>                 Alex
>>>>
>>>>
>>>>                 On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>
>>>>>                 For compilation/codegen purposes ctors *are* just
>>>>>                 methods - they can be inlined, code optimized,
>>>>>                 etc; that's the reason we have the final field
>>>>>                 guarantees.
>>>>>
>>>>>                 A couple of potential reasons not to add volatile
>>>>>                 to the spec:
>>>>>                 1) perhaps some JVMs don't currently already give
>>>>>                 them final field semantics
>>>>>                 2) this whole thing comes into play for unsafe
>>>>>                 publication only (I.e. data race), which is
>>>>>                 discouraged.
>>>>>
>>>>>                 Sent from my phone
>>>>>
>>>>>                 On Dec 3, 2013 6:51 AM, "Oleksandr Otenko"
>>>>>                 <oleksandr.otenko at oracle.com
>>>>>                 <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>
>>>>>                     Constructors /are/ special methods. They are
>>>>>                     the first method calls in any history of the
>>>>>                     object. This means a different treatment of
>>>>>                     volatile accesses to the fields of the
>>>>>                     instance being created is possible - certain
>>>>>                     barriers can be eliminated, because the loads
>>>>>                     can be proven to not synchronize with anyone.
>>>>>                     For the sake of the argument, it is possible
>>>>>                     to proceed with weak treatment of volatile
>>>>>                     stores, too, but you need a good reason to
>>>>>                     permit subsequent calls to observe the initial
>>>>>                     state of the volatile fields; whereas any
>>>>>                     volatile load in any other method always
>>>>>                     synchronizes with a volatile store of some
>>>>>                     other method call, without the final field
>>>>>                     semantics we cannot assume that.
>>>>>
>>>>>                     However, if we assume final field semantics,
>>>>>                     there is only one barrier needed - a
>>>>>                     store-store after the last volatile field
>>>>>                     store. This eliminates all barriers for any
>>>>>                     other volatile field initialization, and
>>>>>                     eliminates a full barrier needed otherwise
>>>>>                     (got to place a dummy volatile load after the
>>>>>                     last volatile store to make sure the semantics
>>>>>                     are stronger than final-field) - think of
>>>>>                     removing a mfence or similar from each such
>>>>>                     constructor on x86.
>>>>>
>>>>>                     (there will still be gotchas for cases when
>>>>>                     volatile field initialization occurs after a
>>>>>                     volatile load of something outside the same
>>>>>                     instance; but the main purpose is to eliminate
>>>>>                     barriers when the volatile fields are just
>>>>>                     initialized into some instance-specific values)
>>>>>
>>>>>
>>>>>                     Alex
>>>>>
>>>>>
>>>>>                     On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>                     I'm about why "always mean storestore after
>>>>>>                     volatile store in constructor". It is not
>>>>>>                     only efficiency which is important for MM,
>>>>>>                     but also simplicity and consistency. If
>>>>>>                     constructors are special methods, not just
>>>>>>                     plain <init>, then we should add this kind of
>>>>>>                     atomicity to all constructors (which, as I
>>>>>>                     was reading here, could be inefficient on
>>>>>>                     some platforms). But if constructors are just
>>>>>>                     plain methods, it looks strange to have
>>>>>>                     special implicit semantics for constructors
>>>>>>                     with volatiles inside.
>>>>>>
>>>>>>
>>>>>>                     2013/12/3 Oleksandr Otenko
>>>>>>                     <oleksandr.otenko at oracle.com
>>>>>>                     <mailto:oleksandr.otenko at oracle.com>>
>>>>>>
>>>>>>                         I think it is pretty simple.
>>>>>>
>>>>>>                         If you always mean a store-store barrier
>>>>>>                         /after/ the last volatile store in the
>>>>>>                         constructor, then add that barrier into
>>>>>>                         constructor semantics, like it's done
>>>>>>                         with the final fields.
>>>>>>
>>>>>>                         It makes sense to /not/ add it to the
>>>>>>                         semantics, if you can come up with enough
>>>>>>                         examples where you want that barrier to
>>>>>>                         be eliminated.
>>>>>>
>>>>>>                         Alex
>>>>>>
>>>>>>
>>>>>>                         On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>>                         Well, I do not see any data race _on
>>>>>>>                         volatiles_ here. I see race condition on
>>>>>>>                         volatile .value, yes -- but it is pretty
>>>>>>>                         legal (and unavoidable, I suppose) to
>>>>>>>                         have race conditions even with volatiles
>>>>>>>                         involved. The only data race I see is
>>>>>>>                         around read-write of (non-volatile)
>>>>>>>                         AtomicInteger's reference -- which is
>>>>>>>                         unrelated to AtomicInteger's content. I
>>>>>>>                         mean, I could not see any noticable
>>>>>>>                         difference between the case discussed,
>>>>>>>                         and just any other case there volatile
>>>>>>>                         is _incorrectly_ used to "synchronize"
>>>>>>>                         data accesses -- it could still be data
>>>>>>>                         race on non-volatile fields, even if
>>>>>>>                         volatile fields are also used somewhere
>>>>>>>                         around. Yes, get 0 from .value is
>>>>>>>                         unexpected -- but there are many
>>>>>>>                         unexpected things in memory models. It
>>>>>>>                         is noway more unexpected then to see
>>>>>>>                         default values in fields of any other
>>>>>>>                         object which is unsafely published. I
>>>>>>>                         think everybody who passed through
>>>>>>>                         broken atomicity of constructor call
>>>>>>>                         could easy see the chance to read
>>>>>>>                         [.value=0] in the case discussed.
>>>>>>>
>>>>>>>                         "Data race is pure evil" was the motto
>>>>>>>                         of this list all time I was reading it.
>>>>>>>                         Why do we may want to introduce another
>>>>>>>                         example of benign race? Wouldn't it be
>>>>>>>                         just another source of confusion for
>>>>>>>                         newcomers?
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>                         2013/12/2 Doug Lea <dl at cs.oswego.edu
>>>>>>>                         <mailto:dl at cs.oswego.edu>>
>>>>>>>
>>>>>>>                             On 12/02/2013 03:57 AM, Cheremin
>>>>>>>                             Ruslan wrote:
>>>>>>>
>>>>>>>                                 Doug, could you explain why it
>>>>>>>                                 is so important to have this
>>>>>>>                                 kind of safe
>>>>>>>                                 publication for volatile? I
>>>>>>>                                 mean, could we just go with
>>>>>>>                                 .value=0 through data
>>>>>>>                                 race to be allowed result, as
>>>>>>>                                 current model (seem to) imply?
>>>>>>>                                 It seems to be a
>>>>>>>                                 dr-case anyway, why we need
>>>>>>>                                 special handling of it?
>>>>>>>
>>>>>>>
>>>>>>>                             The main reason is that it is highly
>>>>>>>                             irregular and unexpected
>>>>>>>                             by programmers. Except in this case,
>>>>>>>                             volatiles definitionally cannot
>>>>>>>                             be subject to data races. Dealing
>>>>>>>                             with it requires cleverness,
>>>>>>>                             complexity, and/or error-proneness
>>>>>>>                             that isn't even required for
>>>>>>>                             correctness on current JVMs. We have
>>>>>>>                             several constructions
>>>>>>>                             in j.u.c that work around problems
>>>>>>>                             by using explicit ordered
>>>>>>>                             writes in constructors,
>>>>>>>                             redundant-looking null-checks, and so
>>>>>>>                             on. If we are going to repair the
>>>>>>>                             JMM anyway, this is a clear
>>>>>>>                             candidate for reconsideration.
>>>>>>>
>>>>>>>                             -Doug
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>                                 Ruslan
>>>>>>>
>>>>>>>                                     27 ????. 2013 ?., ? 23:26,
>>>>>>>                                     Doug Lea <dl at cs.oswego.edu
>>>>>>>                                     <mailto:dl at cs.oswego.edu>>
>>>>>>>                                     ???????(?):
>>>>>>>
>>>>>>>                                         On 11/27/2013 02:06 PM,
>>>>>>>                                         Vitaly Davidovich wrote:
>>>>>>>                                         But either way,
>>>>>>>                                         optimizations to avoid
>>>>>>>                                         zeroing memory is an
>>>>>>>                                         implementation detail and
>>>>>>>                                         thus cannot be relied
>>>>>>>                                         upon from JMM
>>>>>>>                                         standpoint, which I
>>>>>>>                                         think you're
>>>>>>>                                         saying.
>>>>>>>
>>>>>>>                                         The other issue is that
>>>>>>>                                         even if we determine
>>>>>>>                                         that volatiles don't get
>>>>>>>                                         this treatment, if JVM
>>>>>>>                                         is already ensuring it,
>>>>>>>                                         it's not going to be
>>>>>>>                                         practical to change it
>>>>>>>                                         and risk hard to debug
>>>>>>>                                         problems creeping in.  May
>>>>>>>                                         as well update the spec
>>>>>>>                                         now ...
>>>>>>>
>>>>>>>
>>>>>>>                                     Right. To summarize:
>>>>>>>
>>>>>>>                                     * Programmers do not expect
>>>>>>>                                     that even though final
>>>>>>>                                     fields are specifically
>>>>>>>                                     publication-safe, volatile
>>>>>>>                                     fields are not always so.
>>>>>>>
>>>>>>>                                     * For various implementation
>>>>>>>                                     reasons, JVMs arrange that
>>>>>>>                                     volatile fields are
>>>>>>>                                     publication safe anyway, at
>>>>>>>                                     least in cases we know about.
>>>>>>>
>>>>>>>                                     * Actually updating the
>>>>>>>                                     JMM/JLS to mandate this is
>>>>>>>                                     not easy (no small tweak
>>>>>>>                                     that I know applies). But
>>>>>>>                                     now is a good time to be
>>>>>>>                                     considering a full
>>>>>>>                                     revision for JDK9.
>>>>>>>
>>>>>>>                                     * In the mean time, it would
>>>>>>>                                     make sense to further test
>>>>>>>                                     and validate JVMs
>>>>>>>                                     as meeting this likely
>>>>>>>                                     future spec.
>>>>>>>
>>>>>>>                                     -Doug
>>>>>>>
>>>>>>>                                     _______________________________________________
>>>>>>>                                     Concurrency-interest
>>>>>>>                                     mailing list
>>>>>>>                                     Concurrency-interest at cs.oswego.edu
>>>>>>>                                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>                                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>                         _______________________________________________
>>>>>>>                         Concurrency-interest mailing list
>>>>>>>                         Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>>                         _______________________________________________
>>>>>>                         Concurrency-interest mailing list
>>>>>>                         Concurrency-interest at cs.oswego.edu
>>>>>>                         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>>                     _______________________________________________
>>>>>                     Concurrency-interest mailing list
>>>>>                     Concurrency-interest at cs.oswego.edu
>>>>>                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>
>>>
>>>             _______________________________________________
>>>             Concurrency-interest mailing list
>>>             Concurrency-interest at cs.oswego.edu
>>>             <mailto:Concurrency-interest at cs.oswego.edu>
>>>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/8525b4bd/attachment-0001.html>

From heinz at javaspecialists.eu  Tue Dec  3 13:07:01 2013
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Tue, 03 Dec 2013 20:07:01 +0200
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>
References: <529CEA6D.9070301@javaspecialists.eu>	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>	<529DCE97.9050302@cs.oswego.edu>	<529DEB55.7080203@javaspecialists.eu>	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>	<529E066D.9020008@oracle.com>
	<CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>
Message-ID: <529E1DC5.2080605@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/df302f28/attachment.html>

From zhong.j.yu at gmail.com  Tue Dec  3 13:09:42 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Tue, 3 Dec 2013 12:09:42 -0600
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAOwENi+7ROc+bQ1b5yPdYzBR6a9gNLBKyQV2MwYBvpnrsbe24g@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAOwENi+7ROc+bQ1b5yPdYzBR6a9gNLBKyQV2MwYBvpnrsbe24g@mail.gmail.com>
Message-ID: <CACuKZqGUXoxGTfLvNwEnzxOwKyiSSXeAwqqQ4xQLttCdTJL9xw@mail.gmail.com>

Note that majority of Java programmers are taught that immutability is
a good thing, that they should mark all fields as final whenever
possible. If that teaching is correct, obviously the language would be
even better if it extends final field semantics to all fields. If that
teaching is incorrect, Joshua Bloch should recall his books:)

On Tue, Dec 3, 2013 at 11:56 AM, Ruslan Cheremin <cheremin at gmail.com> wrote:
> I may ask you the complimentary question: do you want publication via data
> race to be widely adopted since ctors are safe against it? Do you really
> hope such practice would not go farther only publication, and would not lead
> to assumption "data race is generally not dangerous"?
>
>
> As about ctors: I bet if you ask 100 java programmers about the difference
> between
>   sharedRef = new A();
>   sharedRef.init(42);
> and
>   sharedRef = new A(42);
>
> 90 of them say second is just shortcut for first.
>
>
>
> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>
>> No, this is a completely opposite view. The question is:
>>
>> do you as the implementor of the concurrent algorithm ever intend the
>> constructor design to be such that relies on the protocol that the caller
>> chooses to publish the reference?
>>
>> (Do you ever intend to not specify a no-op volatile load after the last
>> volatile store in the constructor?)
>>
>>
>> Alex
>>
>>
>>
>> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>
>> I'm confident most code that publishes objects shared across threads does
>> it safely.  Otherwise we're saying majority of code uses data races?
>>
>> Sent from my phone
>>
>> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>>
>>> Hmmm.... I thought it is clear no one argues about the "if you publish
>>> safely" part. The question I am wondering about is whether you can find a
>>> case where publishing the reference to the instance unsafely is intended.
>>>
>>> Alex
>>>
>>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>
>>> But this is only if you publish unsafely, as mentioned before.  If you
>>> publish this class properly, you don't get races on the volatile.   Final
>>> fields are supposed to support immutable classes, where although not
>>> preferrable, publishing racily is plausible (for performance).  For
>>> read/write volatiles, it's not compelling on the surface.
>>>
>>> Sent from my phone
>>>
>>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>>
>>>> Yes, but I mean that the code assumes the value to always be non-null -
>>>> eg a sentinel entry of the list is created at construction time. Without the
>>>> construction-time guarantee you'd need to test for null everywhere.
>>>>
>>>> I think the same applies in other constructors - if you write the
>>>> initialization of the volatile, you imply that's "the least" "possible"
>>>> value, the value representing the initial state of the concurrent algorithm
>>>> - the initial value guaranteed by Java spec may not represent any valid
>>>> state of the concurrent algorithm, let alone the initial state.
>>>>
>>>> That's why this really boils down to "find the broad cases where you do
>>>> want to permit unsafe publication of the initial values of the volatiles".
>>>>
>>>>
>>>> (unlike the non-volatile fields. Don't treat them as "not thread safe" -
>>>> instead, treat them as "assume as made thread-safe by means outside the
>>>> class specification", hence no requirement for "safe publication" there)
>>>>
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>
>>>> Initial value of the field must be the "zero" value of that type, that's
>>>> a language spec and must be guaranteed irrespective of volatile or not.
>>>>
>>>> Sent from my phone
>>>>
>>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko"
>>>> <oleksandr.otenko at oracle.com> wrote:
>>>>>
>>>>> I understand, but you can't insist on viewing ctors as "just methods"
>>>>> for all purposes.
>>>>>
>>>>> (2) publication is unsafe unless you get a volatile load after the last
>>>>> volatile store in the constructor. Besides, the initial value of the field
>>>>> may not even be one of the valid values, so it is not even just about a data
>>>>> race.
>>>>>
>>>>>
>>>>> Alex
>>>>>
>>>>>
>>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>
>>>>> For compilation/codegen purposes ctors *are* just methods - they can be
>>>>> inlined, code optimized, etc; that's the reason we have the final field
>>>>> guarantees.
>>>>>
>>>>> A couple of potential reasons not to add volatile to the spec:
>>>>> 1) perhaps some JVMs don't currently already give them final field
>>>>> semantics
>>>>> 2) this whole thing comes into play for unsafe publication only (I.e.
>>>>> data race), which is discouraged.
>>>>>
>>>>> Sent from my phone
>>>>>
>>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko"
>>>>> <oleksandr.otenko at oracle.com> wrote:
>>>>>>
>>>>>> Constructors are special methods. They are the first method calls in
>>>>>> any history of the object. This means a different treatment of volatile
>>>>>> accesses to the fields of the instance being created is possible - certain
>>>>>> barriers can be eliminated, because the loads can be proven to not
>>>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>>>> reason to permit subsequent calls to observe the initial state of the
>>>>>> volatile fields; whereas any volatile load in any other method always
>>>>>> synchronizes with a volatile store of some other method call, without the
>>>>>> final field semantics we cannot assume that.
>>>>>>
>>>>>> However, if we assume final field semantics, there is only one barrier
>>>>>> needed - a store-store after the last volatile field store. This eliminates
>>>>>> all barriers for any other volatile field initialization, and eliminates a
>>>>>> full barrier needed otherwise (got to place a dummy volatile load after the
>>>>>> last volatile store to make sure the semantics are stronger than
>>>>>> final-field) - think of removing a mfence or similar from each such
>>>>>> constructor on x86.
>>>>>>
>>>>>> (there will still be gotchas for cases when volatile field
>>>>>> initialization occurs after a volatile load of something outside the same
>>>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>>>> fields are just initialized into some instance-specific values)
>>>>>>
>>>>>>
>>>>>> Alex
>>>>>>
>>>>>>
>>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>
>>>>>> I'm about why "always mean storestore after volatile store in
>>>>>> constructor". It is not only efficiency which is important for MM, but also
>>>>>> simplicity and consistency. If constructors are special methods, not just
>>>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>>>> if constructors are just plain methods, it looks strange to have special
>>>>>> implicit semantics for constructors with volatiles inside.
>>>>>>
>>>>>>
>>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>>>>
>>>>>>> I think it is pretty simple.
>>>>>>>
>>>>>>> If you always mean a store-store barrier after the last volatile
>>>>>>> store in the constructor, then add that barrier into constructor semantics,
>>>>>>> like it's done with the final fields.
>>>>>>>
>>>>>>> It makes sense to not add it to the semantics, if you can come up
>>>>>>> with enough examples where you want that barrier to be eliminated.
>>>>>>>
>>>>>>> Alex
>>>>>>>
>>>>>>>
>>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>>
>>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>>>> I mean, I could not see any noticable difference between the case discussed,
>>>>>>> and just any other case there volatile is _incorrectly_ used to
>>>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>>>> any other object which is unsafely published. I think everybody who passed
>>>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>>>> read [.value=0] in the case discussed.
>>>>>>>
>>>>>>> "Data race is pure evil" was the motto of this list all time I was
>>>>>>> reading it. Why do we may want to introduce another example of benign race?
>>>>>>> Wouldn't it be just another source of confusion for newcomers?
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>>>>
>>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>>>>
>>>>>>>>> Doug, could you explain why it is so important to have this kind of
>>>>>>>>> safe
>>>>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>>>>> through data
>>>>>>>>> race to be allowed result, as current model (seem to) imply? It
>>>>>>>>> seems to be a
>>>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>>
>>>>>>>>
>>>>>>>> The main reason is that it is highly irregular and unexpected
>>>>>>>> by programmers. Except in this case, volatiles definitionally cannot
>>>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>>>> correctness on current JVMs. We have several constructions
>>>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>>>> candidate for reconsideration.
>>>>>>>>
>>>>>>>> -Doug
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>>
>>>>>>>>> Ruslan
>>>>>>>>>
>>>>>>>>>> 27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>>>>>>>>>
>>>>>>>>>>> On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>>>>>> optimizations to avoid zeroing memory is an implementation detail
>>>>>>>>>>> and
>>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think
>>>>>>>>>>> you're
>>>>>>>>>>> saying.
>>>>>>>>>>>
>>>>>>>>>>> The other issue is that even if we determine that volatiles don't
>>>>>>>>>>> get
>>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going to
>>>>>>>>>>> be
>>>>>>>>>>> practical to change it and risk hard to debug problems creeping
>>>>>>>>>>> in.  May
>>>>>>>>>>> as well update the spec now ...
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> Right. To summarize:
>>>>>>>>>>
>>>>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>>>>> specifically
>>>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>>>
>>>>>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>>>>>> fields are
>>>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>>>
>>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
>>>>>>>>>> small tweak
>>>>>>>>>> that I know applies). But now is a good time to be considering a
>>>>>>>>>> full
>>>>>>>>>> revision for JDK9.
>>>>>>>>>>
>>>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>>>> validate JVMs
>>>>>>>>>> as meeting this likely future spec.
>>>>>>>>>>
>>>>>>>>>> -Doug
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest
>>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From cheremin at gmail.com  Tue Dec  3 13:11:38 2013
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Tue, 3 Dec 2013 22:11:38 +0400
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
Message-ID: <CAOwENi+pZ_VEXhqQOypHc6oyS60tphbsSOxnDxmwbVGCLw2_wA@mail.gmail.com>

>At the end of the day, exposing concurrency to devs will lead to bugs

There are many places where I would like to cite it :)

Personally, I would not reject some method to make constructor thread-safe
without finals or lazySet mess. But I'd prefer such method to be
a) explicit in intention
b) consistent with overall MM. Final fields semantics is not very good in
this -- special HB which is not transitive close with ordinary HB made me
nervious a little. But here at least I see the important reason for the
complexity -- final fields semantics actually define immutability in java.
I do not think thread-safe ctors worth this level of complexity.


2013/12/3 Vitaly Davidovich <vitalyd at gmail.com>

> Not sure that's the right view either.  The one thing the author does not
> control is how instances of their class are passed around.  User of the
> class has more context - it may actually be ok that volatiles aren't fenced
> here because they're already ensuring some way that it's fine, including
> the possibility that the instance isn't even shared at all.  As long as
> people know the behavior of the language/platform, they should be expected
> to make an educated decision on their own.
>
> Look, if performance didn't matter, you could just blindly say that all
> constructors have a freeze action, regardless of final fields or volatile.
> That's not the case, of course.  Java and JDK have tools available to
> publish safely, so people doing multithreading have the ability to do the
> right thing.  At the end of the day, exposing concurrency to devs will lead
> to bugs, even beside the issues described here.
>
> Sent from my phone
> On Dec 3, 2013 12:42 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  No, this is a completely opposite view. The question is:
>>
>> do you as the implementor of the concurrent algorithm ever intend the
>> constructor design to be such that relies on the protocol that the caller
>> chooses to publish the reference?
>>
>> (Do you ever intend to *not* specify a no-op volatile load after the
>> last volatile store in the constructor?)
>>
>>
>> Alex
>>
>>
>> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>
>> I'm confident most code that publishes objects shared across threads does
>> it safely.  Otherwise we're saying majority of code uses data races?
>>
>> Sent from my phone
>> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  Hmmm.... I thought it is clear no one argues about the "*if* you
>>> publish safely" part. The question I am wondering about is whether you can
>>> find a case where publishing the reference to the instance unsafely is
>>> *intended*.
>>>
>>> Alex
>>>
>>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>
>>> But this is only if you publish unsafely, as mentioned before.  If you
>>> publish this class properly, you don't get races on the volatile.   Final
>>> fields are supposed to support immutable classes, where although not
>>> preferrable, publishing racily is plausible (for performance).  For
>>> read/write volatiles, it's not compelling on the surface.
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>
>>>>  Yes, but I mean that the code assumes the value to always be non-null
>>>> - eg a sentinel entry of the list is created at construction time. Without
>>>> the construction-time guarantee you'd need to test for null everywhere.
>>>>
>>>> I think the same applies in other constructors - if you write the
>>>> initialization of the volatile, you imply that's "the least" "possible"
>>>> value, the value representing the initial state of the concurrent algorithm
>>>> - the initial value guaranteed by Java spec may not represent any valid
>>>> state of the concurrent algorithm, let alone the initial state.
>>>>
>>>> That's why this really boils down to "find the broad cases where you do
>>>> want to permit unsafe publication of the initial values of the volatiles".
>>>>
>>>>
>>>> (unlike the non-volatile fields. Don't treat them as "not thread safe"
>>>> - instead, treat them as "assume as made thread-safe by means outside the
>>>> class specification", hence no requirement for "safe publication" there)
>>>>
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>
>>>> Initial value of the field must be the "zero" value of that type,
>>>> that's a language spec and must be guaranteed irrespective of volatile or
>>>> not.
>>>>
>>>> Sent from my phone
>>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <
>>>> oleksandr.otenko at oracle.com> wrote:
>>>>
>>>>>  I understand, but you can't insist on viewing ctors as "just methods"
>>>>> for all purposes.
>>>>>
>>>>> (2) publication is unsafe unless you get a volatile load after the
>>>>> last volatile store in the constructor. Besides, the initial value of the
>>>>> field may not even be one of the valid values, so it is not even just about
>>>>> a data race.
>>>>>
>>>>>
>>>>> Alex
>>>>>
>>>>>
>>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>
>>>>> For compilation/codegen purposes ctors *are* just methods - they can
>>>>> be inlined, code optimized, etc; that's the reason we have the final field
>>>>> guarantees.
>>>>>
>>>>> A couple of potential reasons not to add volatile to the spec:
>>>>> 1) perhaps some JVMs don't currently already give them final field
>>>>> semantics
>>>>> 2) this whole thing comes into play for unsafe publication only (I.e.
>>>>> data race), which is discouraged.
>>>>>
>>>>> Sent from my phone
>>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <
>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>
>>>>>>  Constructors *are* special methods. They are the first method calls
>>>>>> in any history of the object. This means a different treatment of volatile
>>>>>> accesses to the fields of the instance being created is possible - certain
>>>>>> barriers can be eliminated, because the loads can be proven to not
>>>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>>>> reason to permit subsequent calls to observe the initial state of the
>>>>>> volatile fields; whereas any volatile load in any other method always
>>>>>> synchronizes with a volatile store of some other method call, without the
>>>>>> final field semantics we cannot assume that.
>>>>>>
>>>>>> However, if we assume final field semantics, there is only one
>>>>>> barrier needed - a store-store after the last volatile field store. This
>>>>>> eliminates all barriers for any other volatile field initialization, and
>>>>>> eliminates a full barrier needed otherwise (got to place a dummy volatile
>>>>>> load after the last volatile store to make sure the semantics are stronger
>>>>>> than final-field) - think of removing a mfence or similar from each such
>>>>>> constructor on x86.
>>>>>>
>>>>>> (there will still be gotchas for cases when volatile field
>>>>>> initialization occurs after a volatile load of something outside the same
>>>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>>>> fields are just initialized into some instance-specific values)
>>>>>>
>>>>>>
>>>>>> Alex
>>>>>>
>>>>>>
>>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>
>>>>>> I'm about why "always mean storestore after volatile store in
>>>>>> constructor". It is not only efficiency which is important for MM, but also
>>>>>> simplicity and consistency. If constructors are special methods, not just
>>>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>>>> if constructors are just plain methods, it looks strange to have special
>>>>>> implicit semantics for constructors with volatiles inside.
>>>>>>
>>>>>>
>>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>>>
>>>>>>>  I think it is pretty simple.
>>>>>>>
>>>>>>> If you always mean a store-store barrier *after* the last volatile
>>>>>>> store in the constructor, then add that barrier into constructor semantics,
>>>>>>> like it's done with the final fields.
>>>>>>>
>>>>>>> It makes sense to *not* add it to the semantics, if you can come up
>>>>>>> with enough examples where you want that barrier to be eliminated.
>>>>>>>
>>>>>>> Alex
>>>>>>>
>>>>>>>
>>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>>
>>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>>>> I mean, I could not see any noticable difference between the case
>>>>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>>>> any other object which is unsafely published. I think everybody who passed
>>>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>>>> read [.value=0] in the case discussed.
>>>>>>>
>>>>>>>  "Data race is pure evil" was the motto of this list all time I was
>>>>>>> reading it. Why do we may want to introduce another example of benign race?
>>>>>>> Wouldn't it be just another source of confusion for newcomers?
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>>>
>>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>>>
>>>>>>>>> Doug, could you explain why it is so important to have this kind
>>>>>>>>> of safe
>>>>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>>>>> through data
>>>>>>>>> race to be allowed result, as current model (seem to) imply? It
>>>>>>>>> seems to be a
>>>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>>>
>>>>>>>>
>>>>>>>>  The main reason is that it is highly irregular and unexpected
>>>>>>>> by programmers. Except in this case, volatiles definitionally cannot
>>>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>>>> correctness on current JVMs. We have several constructions
>>>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>>>> candidate for reconsideration.
>>>>>>>>
>>>>>>>> -Doug
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>> Ruslan
>>>>>>>>>
>>>>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>> ???????(?):
>>>>>>>>>>
>>>>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>>>>>> optimizations to avoid zeroing memory is an implementation
>>>>>>>>>>> detail and
>>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think
>>>>>>>>>>> you're
>>>>>>>>>>> saying.
>>>>>>>>>>>
>>>>>>>>>>> The other issue is that even if we determine that volatiles
>>>>>>>>>>> don't get
>>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going to
>>>>>>>>>>> be
>>>>>>>>>>> practical to change it and risk hard to debug problems creeping
>>>>>>>>>>> in.  May
>>>>>>>>>>> as well update the spec now ...
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> Right. To summarize:
>>>>>>>>>>
>>>>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>>>>> specifically
>>>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>>>
>>>>>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>>>>>> fields are
>>>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>>>
>>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
>>>>>>>>>> small tweak
>>>>>>>>>> that I know applies). But now is a good time to be considering a
>>>>>>>>>> full
>>>>>>>>>> revision for JDK9.
>>>>>>>>>>
>>>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>>>> validate JVMs
>>>>>>>>>> as meeting this likely future spec.
>>>>>>>>>>
>>>>>>>>>> -Doug
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest
>>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/e95008d9/attachment-0001.html>

From oleksandr.otenko at oracle.com  Tue Dec  3 13:18:31 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 18:18:31 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAOwENi+7ROc+bQ1b5yPdYzBR6a9gNLBKyQV2MwYBvpnrsbe24g@mail.gmail.com>
References: <5295E24C.40608@oracle.com>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAOwENi+7ROc+bQ1b5yPdYzBR6a9gNLBKyQV2MwYBvpnrsbe24g@mail.gmail.com>
Message-ID: <529E2077.7060805@oracle.com>

No, I want the initialization of a concurrent tree with 1 million nodes 
in it to be cheap.

Since per topic starter the JVMs already do this, just write it down as 
the law.

Alex


On 03/12/2013 17:56, Ruslan Cheremin wrote:
> I may ask you the complimentary question: do you want publication via 
> data race to be widely adopted since ctors are safe against it? Do you 
> really hope such practice would not go farther only publication, and 
> would not lead to assumption "data race is generally not dangerous"?
>
>
> As about ctors: I bet if you ask 100 java programmers about the 
> difference between
>   sharedRef = new A();
>   sharedRef.init(42);
> and
>   sharedRef = new A(42);
>
> 90 of them say second is just shortcut for first.
>
>
>
> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com 
> <mailto:oleksandr.otenko at oracle.com>>
>
>     No, this is a completely opposite view. The question is:
>
>     do you as the implementor of the concurrent algorithm ever intend
>     the constructor design to be such that relies on the protocol that
>     the caller chooses to publish the reference?
>
>     (Do you ever intend to /*not*/ specify a no-op volatile load after
>     the last volatile store in the constructor?)
>
>
>     Alex
>
>
>
>     On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>
>>     I'm confident most code that publishes objects shared across
>>     threads does it safely. Otherwise we're saying majority of code
>>     uses data races?
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 12:21 PM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         Hmmm.... I thought it is clear no one argues about the
>>         "/*if*/ you publish safely" part. The question I am wondering
>>         about is whether you can find a case where publishing the
>>         reference to the instance unsafely is /intended/.
>>
>>         Alex
>>
>>         On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>
>>>         But this is only if you publish unsafely, as mentioned
>>>         before.  If you publish this class properly, you don't get
>>>         races on the volatile.   Final fields are supposed to
>>>         support immutable classes, where although not preferrable,
>>>         publishing racily is plausible (for performance). For
>>>         read/write volatiles, it's not compelling on the surface.
>>>
>>>         Sent from my phone
>>>
>>>         On Dec 3, 2013 11:18 AM, "Oleksandr Otenko"
>>>         <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>
>>>             Yes, but I mean that the code assumes the value to
>>>             always be non-null - eg a sentinel entry of the list is
>>>             created at construction time. Without the
>>>             construction-time guarantee you'd need to test for null
>>>             everywhere.
>>>
>>>             I think the same applies in other constructors - if you
>>>             write the initialization of the volatile, you imply
>>>             that's "the least" "possible" value, the value
>>>             representing the initial state of the concurrent
>>>             algorithm - the initial value guaranteed by Java spec
>>>             may not represent any valid state of the concurrent
>>>             algorithm, let alone the initial state.
>>>
>>>             That's why this really boils down to "find the broad
>>>             cases where you do want to permit unsafe publication of
>>>             the initial values of the volatiles".
>>>
>>>
>>>             (unlike the non-volatile fields. Don't treat them as
>>>             "not thread safe" - instead, treat them as "assume as
>>>             made thread-safe by means outside the class
>>>             specification", hence no requirement for "safe
>>>             publication" there)
>>>
>>>
>>>             Alex
>>>
>>>
>>>             On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>
>>>>             Initial value of the field must be the "zero" value of
>>>>             that type, that's a language spec and must be
>>>>             guaranteed irrespective of volatile or not.
>>>>
>>>>             Sent from my phone
>>>>
>>>>             On Dec 3, 2013 10:03 AM, "Oleksandr Otenko"
>>>>             <oleksandr.otenko at oracle.com
>>>>             <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>
>>>>                 I understand, but you can't insist on viewing ctors
>>>>                 as "just methods" for all purposes.
>>>>
>>>>                 (2) publication is unsafe unless you get a volatile
>>>>                 load after the last volatile store in the
>>>>                 constructor. Besides, the initial value of the
>>>>                 field may not even be one of the valid values, so
>>>>                 it is not even just about a data race.
>>>>
>>>>
>>>>                 Alex
>>>>
>>>>
>>>>                 On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>
>>>>>                 For compilation/codegen purposes ctors *are* just
>>>>>                 methods - they can be inlined, code optimized,
>>>>>                 etc; that's the reason we have the final field
>>>>>                 guarantees.
>>>>>
>>>>>                 A couple of potential reasons not to add volatile
>>>>>                 to the spec:
>>>>>                 1) perhaps some JVMs don't currently already give
>>>>>                 them final field semantics
>>>>>                 2) this whole thing comes into play for unsafe
>>>>>                 publication only (I.e. data race), which is
>>>>>                 discouraged.
>>>>>
>>>>>                 Sent from my phone
>>>>>
>>>>>                 On Dec 3, 2013 6:51 AM, "Oleksandr Otenko"
>>>>>                 <oleksandr.otenko at oracle.com
>>>>>                 <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>
>>>>>                     Constructors /are/ special methods. They are
>>>>>                     the first method calls in any history of the
>>>>>                     object. This means a different treatment of
>>>>>                     volatile accesses to the fields of the
>>>>>                     instance being created is possible - certain
>>>>>                     barriers can be eliminated, because the loads
>>>>>                     can be proven to not synchronize with anyone.
>>>>>                     For the sake of the argument, it is possible
>>>>>                     to proceed with weak treatment of volatile
>>>>>                     stores, too, but you need a good reason to
>>>>>                     permit subsequent calls to observe the initial
>>>>>                     state of the volatile fields; whereas any
>>>>>                     volatile load in any other method always
>>>>>                     synchronizes with a volatile store of some
>>>>>                     other method call, without the final field
>>>>>                     semantics we cannot assume that.
>>>>>
>>>>>                     However, if we assume final field semantics,
>>>>>                     there is only one barrier needed - a
>>>>>                     store-store after the last volatile field
>>>>>                     store. This eliminates all barriers for any
>>>>>                     other volatile field initialization, and
>>>>>                     eliminates a full barrier needed otherwise
>>>>>                     (got to place a dummy volatile load after the
>>>>>                     last volatile store to make sure the semantics
>>>>>                     are stronger than final-field) - think of
>>>>>                     removing a mfence or similar from each such
>>>>>                     constructor on x86.
>>>>>
>>>>>                     (there will still be gotchas for cases when
>>>>>                     volatile field initialization occurs after a
>>>>>                     volatile load of something outside the same
>>>>>                     instance; but the main purpose is to eliminate
>>>>>                     barriers when the volatile fields are just
>>>>>                     initialized into some instance-specific values)
>>>>>
>>>>>
>>>>>                     Alex
>>>>>
>>>>>
>>>>>                     On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>                     I'm about why "always mean storestore after
>>>>>>                     volatile store in constructor". It is not
>>>>>>                     only efficiency which is important for MM,
>>>>>>                     but also simplicity and consistency. If
>>>>>>                     constructors are special methods, not just
>>>>>>                     plain <init>, then we should add this kind of
>>>>>>                     atomicity to all constructors (which, as I
>>>>>>                     was reading here, could be inefficient on
>>>>>>                     some platforms). But if constructors are just
>>>>>>                     plain methods, it looks strange to have
>>>>>>                     special implicit semantics for constructors
>>>>>>                     with volatiles inside.
>>>>>>
>>>>>>
>>>>>>                     2013/12/3 Oleksandr Otenko
>>>>>>                     <oleksandr.otenko at oracle.com
>>>>>>                     <mailto:oleksandr.otenko at oracle.com>>
>>>>>>
>>>>>>                         I think it is pretty simple.
>>>>>>
>>>>>>                         If you always mean a store-store barrier
>>>>>>                         /after/ the last volatile store in the
>>>>>>                         constructor, then add that barrier into
>>>>>>                         constructor semantics, like it's done
>>>>>>                         with the final fields.
>>>>>>
>>>>>>                         It makes sense to /not/ add it to the
>>>>>>                         semantics, if you can come up with enough
>>>>>>                         examples where you want that barrier to
>>>>>>                         be eliminated.
>>>>>>
>>>>>>                         Alex
>>>>>>
>>>>>>
>>>>>>                         On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>>                         Well, I do not see any data race _on
>>>>>>>                         volatiles_ here. I see race condition on
>>>>>>>                         volatile .value, yes -- but it is pretty
>>>>>>>                         legal (and unavoidable, I suppose) to
>>>>>>>                         have race conditions even with volatiles
>>>>>>>                         involved. The only data race I see is
>>>>>>>                         around read-write of (non-volatile)
>>>>>>>                         AtomicInteger's reference -- which is
>>>>>>>                         unrelated to AtomicInteger's content. I
>>>>>>>                         mean, I could not see any noticable
>>>>>>>                         difference between the case discussed,
>>>>>>>                         and just any other case there volatile
>>>>>>>                         is _incorrectly_ used to "synchronize"
>>>>>>>                         data accesses -- it could still be data
>>>>>>>                         race on non-volatile fields, even if
>>>>>>>                         volatile fields are also used somewhere
>>>>>>>                         around. Yes, get 0 from .value is
>>>>>>>                         unexpected -- but there are many
>>>>>>>                         unexpected things in memory models. It
>>>>>>>                         is noway more unexpected then to see
>>>>>>>                         default values in fields of any other
>>>>>>>                         object which is unsafely published. I
>>>>>>>                         think everybody who passed through
>>>>>>>                         broken atomicity of constructor call
>>>>>>>                         could easy see the chance to read
>>>>>>>                         [.value=0] in the case discussed.
>>>>>>>
>>>>>>>                         "Data race is pure evil" was the motto
>>>>>>>                         of this list all time I was reading it.
>>>>>>>                         Why do we may want to introduce another
>>>>>>>                         example of benign race? Wouldn't it be
>>>>>>>                         just another source of confusion for
>>>>>>>                         newcomers?
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>                         2013/12/2 Doug Lea <dl at cs.oswego.edu
>>>>>>>                         <mailto:dl at cs.oswego.edu>>
>>>>>>>
>>>>>>>                             On 12/02/2013 03:57 AM, Cheremin
>>>>>>>                             Ruslan wrote:
>>>>>>>
>>>>>>>                                 Doug, could you explain why it
>>>>>>>                                 is so important to have this
>>>>>>>                                 kind of safe
>>>>>>>                                 publication for volatile? I
>>>>>>>                                 mean, could we just go with
>>>>>>>                                 .value=0 through data
>>>>>>>                                 race to be allowed result, as
>>>>>>>                                 current model (seem to) imply?
>>>>>>>                                 It seems to be a
>>>>>>>                                 dr-case anyway, why we need
>>>>>>>                                 special handling of it?
>>>>>>>
>>>>>>>
>>>>>>>                             The main reason is that it is highly
>>>>>>>                             irregular and unexpected
>>>>>>>                             by programmers. Except in this case,
>>>>>>>                             volatiles definitionally cannot
>>>>>>>                             be subject to data races. Dealing
>>>>>>>                             with it requires cleverness,
>>>>>>>                             complexity, and/or error-proneness
>>>>>>>                             that isn't even required for
>>>>>>>                             correctness on current JVMs. We have
>>>>>>>                             several constructions
>>>>>>>                             in j.u.c that work around problems
>>>>>>>                             by using explicit ordered
>>>>>>>                             writes in constructors,
>>>>>>>                             redundant-looking null-checks, and so
>>>>>>>                             on. If we are going to repair the
>>>>>>>                             JMM anyway, this is a clear
>>>>>>>                             candidate for reconsideration.
>>>>>>>
>>>>>>>                             -Doug
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>                                 Ruslan
>>>>>>>
>>>>>>>                                     27 ????. 2013 ?., ? 23:26,
>>>>>>>                                     Doug Lea <dl at cs.oswego.edu
>>>>>>>                                     <mailto:dl at cs.oswego.edu>>
>>>>>>>                                     ???????(?):
>>>>>>>
>>>>>>>                                         On 11/27/2013 02:06 PM,
>>>>>>>                                         Vitaly Davidovich wrote:
>>>>>>>                                         But either way,
>>>>>>>                                         optimizations to avoid
>>>>>>>                                         zeroing memory is an
>>>>>>>                                         implementation detail and
>>>>>>>                                         thus cannot be relied
>>>>>>>                                         upon from JMM
>>>>>>>                                         standpoint, which I
>>>>>>>                                         think you're
>>>>>>>                                         saying.
>>>>>>>
>>>>>>>                                         The other issue is that
>>>>>>>                                         even if we determine
>>>>>>>                                         that volatiles don't get
>>>>>>>                                         this treatment, if JVM
>>>>>>>                                         is already ensuring it,
>>>>>>>                                         it's not going to be
>>>>>>>                                         practical to change it
>>>>>>>                                         and risk hard to debug
>>>>>>>                                         problems creeping in.  May
>>>>>>>                                         as well update the spec
>>>>>>>                                         now ...
>>>>>>>
>>>>>>>
>>>>>>>                                     Right. To summarize:
>>>>>>>
>>>>>>>                                     * Programmers do not expect
>>>>>>>                                     that even though final
>>>>>>>                                     fields are specifically
>>>>>>>                                     publication-safe, volatile
>>>>>>>                                     fields are not always so.
>>>>>>>
>>>>>>>                                     * For various implementation
>>>>>>>                                     reasons, JVMs arrange that
>>>>>>>                                     volatile fields are
>>>>>>>                                     publication safe anyway, at
>>>>>>>                                     least in cases we know about.
>>>>>>>
>>>>>>>                                     * Actually updating the
>>>>>>>                                     JMM/JLS to mandate this is
>>>>>>>                                     not easy (no small tweak
>>>>>>>                                     that I know applies). But
>>>>>>>                                     now is a good time to be
>>>>>>>                                     considering a full
>>>>>>>                                     revision for JDK9.
>>>>>>>
>>>>>>>                                     * In the mean time, it would
>>>>>>>                                     make sense to further test
>>>>>>>                                     and validate JVMs
>>>>>>>                                     as meeting this likely
>>>>>>>                                     future spec.
>>>>>>>
>>>>>>>                                     -Doug
>>>>>>>
>>>>>>>                                     _______________________________________________
>>>>>>>                                     Concurrency-interest
>>>>>>>                                     mailing list
>>>>>>>                                     Concurrency-interest at cs.oswego.edu
>>>>>>>                                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>                                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>                         _______________________________________________
>>>>>>>                         Concurrency-interest mailing list
>>>>>>>                         Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>>                         _______________________________________________
>>>>>>                         Concurrency-interest mailing list
>>>>>>                         Concurrency-interest at cs.oswego.edu
>>>>>>                         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>>                     _______________________________________________
>>>>>                     Concurrency-interest mailing list
>>>>>                     Concurrency-interest at cs.oswego.edu
>>>>>                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>
>>>
>>>             _______________________________________________
>>>             Concurrency-interest mailing list
>>>             Concurrency-interest at cs.oswego.edu
>>>             <mailto:Concurrency-interest at cs.oswego.edu>
>>>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/77d3895b/attachment-0001.html>

From cheremin at gmail.com  Tue Dec  3 13:21:29 2013
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Tue, 3 Dec 2013 22:21:29 +0400
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CACuKZqGUXoxGTfLvNwEnzxOwKyiSSXeAwqqQ4xQLttCdTJL9xw@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAOwENi+7ROc+bQ1b5yPdYzBR6a9gNLBKyQV2MwYBvpnrsbe24g@mail.gmail.com>
	<CACuKZqGUXoxGTfLvNwEnzxOwKyiSSXeAwqqQ4xQLttCdTJL9xw@mail.gmail.com>
Message-ID: <CAOwENiJVDXHkbLDLDpnOnYRBedFYxdOgujFef1PywaFSGtp=Qg@mail.gmail.com>

But immutability is good not because it is thread-safe, but because it is
immutability -- no state, no transitions, you know, like you're in Eden, or
in Clojure :) Thread safety is just one of consequences of having no state,
and special semantics for final fields in java just stamp this expectable
property. Making ctors "atomic" not supply you with even 1% of what
immutability gives. But (I'm afraid, but not sure) it requires complexity
in formal model comparable with final fields definition. What is why I do
not think it worth it. If it could be injected simply and naturally,
without another "HB which is not transitive with ordinary HB, and not
transitive with final-fields-HB..." -- may be it worth it.


2013/12/3 Zhong Yu <zhong.j.yu at gmail.com>

> Note that majority of Java programmers are taught that immutability is
> a good thing, that they should mark all fields as final whenever
> possible. If that teaching is correct, obviously the language would be
> even better if it extends final field semantics to all fields. If that
> teaching is incorrect, Joshua Bloch should recall his books:)
>
> On Tue, Dec 3, 2013 at 11:56 AM, Ruslan Cheremin <cheremin at gmail.com>
> wrote:
> > I may ask you the complimentary question: do you want publication via
> data
> > race to be widely adopted since ctors are safe against it? Do you really
> > hope such practice would not go farther only publication, and would not
> lead
> > to assumption "data race is generally not dangerous"?
> >
> >
> > As about ctors: I bet if you ask 100 java programmers about the
> difference
> > between
> >   sharedRef = new A();
> >   sharedRef.init(42);
> > and
> >   sharedRef = new A(42);
> >
> > 90 of them say second is just shortcut for first.
> >
> >
> >
> > 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
> >>
> >> No, this is a completely opposite view. The question is:
> >>
> >> do you as the implementor of the concurrent algorithm ever intend the
> >> constructor design to be such that relies on the protocol that the
> caller
> >> chooses to publish the reference?
> >>
> >> (Do you ever intend to not specify a no-op volatile load after the last
> >> volatile store in the constructor?)
> >>
> >>
> >> Alex
> >>
> >>
> >>
> >> On 03/12/2013 17:23, Vitaly Davidovich wrote:
> >>
> >> I'm confident most code that publishes objects shared across threads
> does
> >> it safely.  Otherwise we're saying majority of code uses data races?
> >>
> >> Sent from my phone
> >>
> >> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <
> oleksandr.otenko at oracle.com>
> >> wrote:
> >>>
> >>> Hmmm.... I thought it is clear no one argues about the "if you publish
> >>> safely" part. The question I am wondering about is whether you can
> find a
> >>> case where publishing the reference to the instance unsafely is
> intended.
> >>>
> >>> Alex
> >>>
> >>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
> >>>
> >>> But this is only if you publish unsafely, as mentioned before.  If you
> >>> publish this class properly, you don't get races on the volatile.
> Final
> >>> fields are supposed to support immutable classes, where although not
> >>> preferrable, publishing racily is plausible (for performance).  For
> >>> read/write volatiles, it's not compelling on the surface.
> >>>
> >>> Sent from my phone
> >>>
> >>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <
> oleksandr.otenko at oracle.com>
> >>> wrote:
> >>>>
> >>>> Yes, but I mean that the code assumes the value to always be non-null
> -
> >>>> eg a sentinel entry of the list is created at construction time.
> Without the
> >>>> construction-time guarantee you'd need to test for null everywhere.
> >>>>
> >>>> I think the same applies in other constructors - if you write the
> >>>> initialization of the volatile, you imply that's "the least"
> "possible"
> >>>> value, the value representing the initial state of the concurrent
> algorithm
> >>>> - the initial value guaranteed by Java spec may not represent any
> valid
> >>>> state of the concurrent algorithm, let alone the initial state.
> >>>>
> >>>> That's why this really boils down to "find the broad cases where you
> do
> >>>> want to permit unsafe publication of the initial values of the
> volatiles".
> >>>>
> >>>>
> >>>> (unlike the non-volatile fields. Don't treat them as "not thread
> safe" -
> >>>> instead, treat them as "assume as made thread-safe by means outside
> the
> >>>> class specification", hence no requirement for "safe publication"
> there)
> >>>>
> >>>>
> >>>> Alex
> >>>>
> >>>>
> >>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
> >>>>
> >>>> Initial value of the field must be the "zero" value of that type,
> that's
> >>>> a language spec and must be guaranteed irrespective of volatile or
> not.
> >>>>
> >>>> Sent from my phone
> >>>>
> >>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko"
> >>>> <oleksandr.otenko at oracle.com> wrote:
> >>>>>
> >>>>> I understand, but you can't insist on viewing ctors as "just methods"
> >>>>> for all purposes.
> >>>>>
> >>>>> (2) publication is unsafe unless you get a volatile load after the
> last
> >>>>> volatile store in the constructor. Besides, the initial value of the
> field
> >>>>> may not even be one of the valid values, so it is not even just
> about a data
> >>>>> race.
> >>>>>
> >>>>>
> >>>>> Alex
> >>>>>
> >>>>>
> >>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
> >>>>>
> >>>>> For compilation/codegen purposes ctors *are* just methods - they can
> be
> >>>>> inlined, code optimized, etc; that's the reason we have the final
> field
> >>>>> guarantees.
> >>>>>
> >>>>> A couple of potential reasons not to add volatile to the spec:
> >>>>> 1) perhaps some JVMs don't currently already give them final field
> >>>>> semantics
> >>>>> 2) this whole thing comes into play for unsafe publication only (I.e.
> >>>>> data race), which is discouraged.
> >>>>>
> >>>>> Sent from my phone
> >>>>>
> >>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko"
> >>>>> <oleksandr.otenko at oracle.com> wrote:
> >>>>>>
> >>>>>> Constructors are special methods. They are the first method calls in
> >>>>>> any history of the object. This means a different treatment of
> volatile
> >>>>>> accesses to the fields of the instance being created is possible -
> certain
> >>>>>> barriers can be eliminated, because the loads can be proven to not
> >>>>>> synchronize with anyone. For the sake of the argument, it is
> possible to
> >>>>>> proceed with weak treatment of volatile stores, too, but you need a
> good
> >>>>>> reason to permit subsequent calls to observe the initial state of
> the
> >>>>>> volatile fields; whereas any volatile load in any other method
> always
> >>>>>> synchronizes with a volatile store of some other method call,
> without the
> >>>>>> final field semantics we cannot assume that.
> >>>>>>
> >>>>>> However, if we assume final field semantics, there is only one
> barrier
> >>>>>> needed - a store-store after the last volatile field store. This
> eliminates
> >>>>>> all barriers for any other volatile field initialization, and
> eliminates a
> >>>>>> full barrier needed otherwise (got to place a dummy volatile load
> after the
> >>>>>> last volatile store to make sure the semantics are stronger than
> >>>>>> final-field) - think of removing a mfence or similar from each such
> >>>>>> constructor on x86.
> >>>>>>
> >>>>>> (there will still be gotchas for cases when volatile field
> >>>>>> initialization occurs after a volatile load of something outside
> the same
> >>>>>> instance; but the main purpose is to eliminate barriers when the
> volatile
> >>>>>> fields are just initialized into some instance-specific values)
> >>>>>>
> >>>>>>
> >>>>>> Alex
> >>>>>>
> >>>>>>
> >>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
> >>>>>>
> >>>>>> I'm about why "always mean storestore after volatile store in
> >>>>>> constructor". It is not only efficiency which is important for MM,
> but also
> >>>>>> simplicity and consistency. If constructors are special methods,
> not just
> >>>>>> plain <init>, then we should add this kind of atomicity to all
> constructors
> >>>>>> (which, as I was reading here, could be inefficient on some
> platforms). But
> >>>>>> if constructors are just plain methods, it looks strange to have
> special
> >>>>>> implicit semantics for constructors with volatiles inside.
> >>>>>>
> >>>>>>
> >>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
> >>>>>>>
> >>>>>>> I think it is pretty simple.
> >>>>>>>
> >>>>>>> If you always mean a store-store barrier after the last volatile
> >>>>>>> store in the constructor, then add that barrier into constructor
> semantics,
> >>>>>>> like it's done with the final fields.
> >>>>>>>
> >>>>>>> It makes sense to not add it to the semantics, if you can come up
> >>>>>>> with enough examples where you want that barrier to be eliminated.
> >>>>>>>
> >>>>>>> Alex
> >>>>>>>
> >>>>>>>
> >>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
> >>>>>>>
> >>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
> >>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
> >>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
> >>>>>>> involved. The only data race I see is around read-write of
> (non-volatile)
> >>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's
> content.
> >>>>>>> I mean, I could not see any noticable difference between the case
> discussed,
> >>>>>>> and just any other case there volatile is _incorrectly_ used to
> >>>>>>> "synchronize" data accesses -- it could still be data race on
> non-volatile
> >>>>>>> fields, even if volatile fields are also used somewhere around.
> Yes, get 0
> >>>>>>> from .value is unexpected -- but there are many unexpected things
> in memory
> >>>>>>> models. It is noway more unexpected then to see default values in
> fields of
> >>>>>>> any other object which is unsafely published. I think everybody
> who passed
> >>>>>>> through broken atomicity of constructor call could easy see the
> chance to
> >>>>>>> read [.value=0] in the case discussed.
> >>>>>>>
> >>>>>>> "Data race is pure evil" was the motto of this list all time I was
> >>>>>>> reading it. Why do we may want to introduce another example of
> benign race?
> >>>>>>> Wouldn't it be just another source of confusion for newcomers?
> >>>>>>>
> >>>>>>>
> >>>>>>>
> >>>>>>>
> >>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
> >>>>>>>>
> >>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
> >>>>>>>>>
> >>>>>>>>> Doug, could you explain why it is so important to have this kind
> of
> >>>>>>>>> safe
> >>>>>>>>> publication for volatile? I mean, could we just go with .value=0
> >>>>>>>>> through data
> >>>>>>>>> race to be allowed result, as current model (seem to) imply? It
> >>>>>>>>> seems to be a
> >>>>>>>>> dr-case anyway, why we need special handling of it?
> >>>>>>>>
> >>>>>>>>
> >>>>>>>> The main reason is that it is highly irregular and unexpected
> >>>>>>>> by programmers. Except in this case, volatiles definitionally
> cannot
> >>>>>>>> be subject to data races. Dealing with it requires cleverness,
> >>>>>>>> complexity, and/or error-proneness that isn't even required for
> >>>>>>>> correctness on current JVMs. We have several constructions
> >>>>>>>> in j.u.c that work around problems by using explicit ordered
> >>>>>>>> writes in constructors, redundant-looking null-checks, and so
> >>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
> >>>>>>>> candidate for reconsideration.
> >>>>>>>>
> >>>>>>>> -Doug
> >>>>>>>>
> >>>>>>>>
> >>>>>>>>
> >>>>>>>>>
> >>>>>>>>> Ruslan
> >>>>>>>>>
> >>>>>>>>>> 27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu>
> ???????(?):
> >>>>>>>>>>
> >>>>>>>>>>> On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either
> way,
> >>>>>>>>>>> optimizations to avoid zeroing memory is an implementation
> detail
> >>>>>>>>>>> and
> >>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think
> >>>>>>>>>>> you're
> >>>>>>>>>>> saying.
> >>>>>>>>>>>
> >>>>>>>>>>> The other issue is that even if we determine that volatiles
> don't
> >>>>>>>>>>> get
> >>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going
> to
> >>>>>>>>>>> be
> >>>>>>>>>>> practical to change it and risk hard to debug problems creeping
> >>>>>>>>>>> in.  May
> >>>>>>>>>>> as well update the spec now ...
> >>>>>>>>>>
> >>>>>>>>>>
> >>>>>>>>>> Right. To summarize:
> >>>>>>>>>>
> >>>>>>>>>> * Programmers do not expect that even though final fields are
> >>>>>>>>>> specifically
> >>>>>>>>>> publication-safe, volatile fields are not always so.
> >>>>>>>>>>
> >>>>>>>>>> * For various implementation reasons, JVMs arrange that volatile
> >>>>>>>>>> fields are
> >>>>>>>>>> publication safe anyway, at least in cases we know about.
> >>>>>>>>>>
> >>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
> >>>>>>>>>> small tweak
> >>>>>>>>>> that I know applies). But now is a good time to be considering a
> >>>>>>>>>> full
> >>>>>>>>>> revision for JDK9.
> >>>>>>>>>>
> >>>>>>>>>> * In the mean time, it would make sense to further test and
> >>>>>>>>>> validate JVMs
> >>>>>>>>>> as meeting this likely future spec.
> >>>>>>>>>>
> >>>>>>>>>> -Doug
> >>>>>>>>>>
> >>>>>>>>>> _______________________________________________
> >>>>>>>>>> Concurrency-interest
> >>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
> >>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>>>>>>
> >>>>>>>>>
> >>>>>>>>
> >>>>>>>>
> >>>>>>>
> >>>>>>>
> >>>>>>>
> >>>>>>> _______________________________________________
> >>>>>>> Concurrency-interest mailing list
> >>>>>>> Concurrency-interest at cs.oswego.edu
> >>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>>>>
> >>>>>>>
> >>>>>>>
> >>>>>>> _______________________________________________
> >>>>>>> Concurrency-interest mailing list
> >>>>>>> Concurrency-interest at cs.oswego.edu
> >>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>>>>
> >>>>>>
> >>>>>>
> >>>>>>
> >>>>>> _______________________________________________
> >>>>>> Concurrency-interest mailing list
> >>>>>> Concurrency-interest at cs.oswego.edu
> >>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>>>
> >>>>>
> >>>>
> >>>>
> >>>> _______________________________________________
> >>>> Concurrency-interest mailing list
> >>>> Concurrency-interest at cs.oswego.edu
> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>
> >>>
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/c4a9aaa3/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  3 13:34:42 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 13:34:42 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E1D48.5020500@oracle.com>
References: <5295E24C.40608@oracle.com>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
Message-ID: <CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>

For volatiles, you'd need load-store as well though.

Sent from my phone
On Dec 3, 2013 1:05 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  Sure.
>
> f=42;
>
> already imposes the cost of store-store barrier.
>
> f=42;
> f=42;
>
> does the same thing. In a constructor, eliminate the first barrier,
> because the order of writes to the unreachable instance is not important,
> and the second store. This no longer is the question of performance,
> because it is the same. It is the question of correctness for free.
>
> Alex
>
> On 03/12/2013 17:53, Vitaly Davidovich wrote:
>
> Not sure that's the right view either.  The one thing the author does not
> control is how instances of their class are passed around.  User of the
> class has more context - it may actually be ok that volatiles aren't fenced
> here because they're already ensuring some way that it's fine, including
> the possibility that the instance isn't even shared at all.  As long as
> people know the behavior of the language/platform, they should be expected
> to make an educated decision on their own.
>
> Look, if performance didn't matter, you could just blindly say that all
> constructors have a freeze action, regardless of final fields or volatile.
> That's not the case, of course.  Java and JDK have tools available to
> publish safely, so people doing multithreading have the ability to do the
> right thing.  At the end of the day, exposing concurrency to devs will lead
> to bugs, even beside the issues described here.
>
> Sent from my phone
> On Dec 3, 2013 12:42 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  No, this is a completely opposite view. The question is:
>>
>> do you as the implementor of the concurrent algorithm ever intend the
>> constructor design to be such that relies on the protocol that the caller
>> chooses to publish the reference?
>>
>> (Do you ever intend to *not* specify a no-op volatile load after the
>> last volatile store in the constructor?)
>>
>>
>> Alex
>>
>>
>> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>
>> I'm confident most code that publishes objects shared across threads does
>> it safely.  Otherwise we're saying majority of code uses data races?
>>
>> Sent from my phone
>> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  Hmmm.... I thought it is clear no one argues about the "*if* you
>>> publish safely" part. The question I am wondering about is whether you can
>>> find a case where publishing the reference to the instance unsafely is
>>> *intended*.
>>>
>>> Alex
>>>
>>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>
>>> But this is only if you publish unsafely, as mentioned before.  If you
>>> publish this class properly, you don't get races on the volatile.   Final
>>> fields are supposed to support immutable classes, where although not
>>> preferrable, publishing racily is plausible (for performance).  For
>>> read/write volatiles, it's not compelling on the surface.
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>
>>>>  Yes, but I mean that the code assumes the value to always be non-null
>>>> - eg a sentinel entry of the list is created at construction time. Without
>>>> the construction-time guarantee you'd need to test for null everywhere.
>>>>
>>>> I think the same applies in other constructors - if you write the
>>>> initialization of the volatile, you imply that's "the least" "possible"
>>>> value, the value representing the initial state of the concurrent algorithm
>>>> - the initial value guaranteed by Java spec may not represent any valid
>>>> state of the concurrent algorithm, let alone the initial state.
>>>>
>>>> That's why this really boils down to "find the broad cases where you do
>>>> want to permit unsafe publication of the initial values of the volatiles".
>>>>
>>>>
>>>> (unlike the non-volatile fields. Don't treat them as "not thread safe"
>>>> - instead, treat them as "assume as made thread-safe by means outside the
>>>> class specification", hence no requirement for "safe publication" there)
>>>>
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>
>>>> Initial value of the field must be the "zero" value of that type,
>>>> that's a language spec and must be guaranteed irrespective of volatile or
>>>> not.
>>>>
>>>> Sent from my phone
>>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <
>>>> oleksandr.otenko at oracle.com> wrote:
>>>>
>>>>>  I understand, but you can't insist on viewing ctors as "just methods"
>>>>> for all purposes.
>>>>>
>>>>> (2) publication is unsafe unless you get a volatile load after the
>>>>> last volatile store in the constructor. Besides, the initial value of the
>>>>> field may not even be one of the valid values, so it is not even just about
>>>>> a data race.
>>>>>
>>>>>
>>>>> Alex
>>>>>
>>>>>
>>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>
>>>>> For compilation/codegen purposes ctors *are* just methods - they can
>>>>> be inlined, code optimized, etc; that's the reason we have the final field
>>>>> guarantees.
>>>>>
>>>>> A couple of potential reasons not to add volatile to the spec:
>>>>> 1) perhaps some JVMs don't currently already give them final field
>>>>> semantics
>>>>> 2) this whole thing comes into play for unsafe publication only (I.e.
>>>>> data race), which is discouraged.
>>>>>
>>>>> Sent from my phone
>>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <
>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>
>>>>>>  Constructors *are* special methods. They are the first method calls
>>>>>> in any history of the object. This means a different treatment of volatile
>>>>>> accesses to the fields of the instance being created is possible - certain
>>>>>> barriers can be eliminated, because the loads can be proven to not
>>>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>>>> reason to permit subsequent calls to observe the initial state of the
>>>>>> volatile fields; whereas any volatile load in any other method always
>>>>>> synchronizes with a volatile store of some other method call, without the
>>>>>> final field semantics we cannot assume that.
>>>>>>
>>>>>> However, if we assume final field semantics, there is only one
>>>>>> barrier needed - a store-store after the last volatile field store. This
>>>>>> eliminates all barriers for any other volatile field initialization, and
>>>>>> eliminates a full barrier needed otherwise (got to place a dummy volatile
>>>>>> load after the last volatile store to make sure the semantics are stronger
>>>>>> than final-field) - think of removing a mfence or similar from each such
>>>>>> constructor on x86.
>>>>>>
>>>>>> (there will still be gotchas for cases when volatile field
>>>>>> initialization occurs after a volatile load of something outside the same
>>>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>>>> fields are just initialized into some instance-specific values)
>>>>>>
>>>>>>
>>>>>> Alex
>>>>>>
>>>>>>
>>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>
>>>>>> I'm about why "always mean storestore after volatile store in
>>>>>> constructor". It is not only efficiency which is important for MM, but also
>>>>>> simplicity and consistency. If constructors are special methods, not just
>>>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>>>> if constructors are just plain methods, it looks strange to have special
>>>>>> implicit semantics for constructors with volatiles inside.
>>>>>>
>>>>>>
>>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>>>
>>>>>>>  I think it is pretty simple.
>>>>>>>
>>>>>>> If you always mean a store-store barrier *after* the last volatile
>>>>>>> store in the constructor, then add that barrier into constructor semantics,
>>>>>>> like it's done with the final fields.
>>>>>>>
>>>>>>> It makes sense to *not* add it to the semantics, if you can come up
>>>>>>> with enough examples where you want that barrier to be eliminated.
>>>>>>>
>>>>>>> Alex
>>>>>>>
>>>>>>>
>>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>>
>>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>>>> I mean, I could not see any noticable difference between the case
>>>>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>>>> any other object which is unsafely published. I think everybody who passed
>>>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>>>> read [.value=0] in the case discussed.
>>>>>>>
>>>>>>>  "Data race is pure evil" was the motto of this list all time I was
>>>>>>> reading it. Why do we may want to introduce another example of benign race?
>>>>>>> Wouldn't it be just another source of confusion for newcomers?
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>>>
>>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>>>
>>>>>>>>> Doug, could you explain why it is so important to have this kind
>>>>>>>>> of safe
>>>>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>>>>> through data
>>>>>>>>> race to be allowed result, as current model (seem to) imply? It
>>>>>>>>> seems to be a
>>>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>>>
>>>>>>>>
>>>>>>>>  The main reason is that it is highly irregular and unexpected
>>>>>>>> by programmers. Except in this case, volatiles definitionally cannot
>>>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>>>> correctness on current JVMs. We have several constructions
>>>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>>>> candidate for reconsideration.
>>>>>>>>
>>>>>>>> -Doug
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>> Ruslan
>>>>>>>>>
>>>>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>> ???????(?):
>>>>>>>>>>
>>>>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>>>>>> optimizations to avoid zeroing memory is an implementation
>>>>>>>>>>> detail and
>>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think
>>>>>>>>>>> you're
>>>>>>>>>>> saying.
>>>>>>>>>>>
>>>>>>>>>>> The other issue is that even if we determine that volatiles
>>>>>>>>>>> don't get
>>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going to
>>>>>>>>>>> be
>>>>>>>>>>> practical to change it and risk hard to debug problems creeping
>>>>>>>>>>> in.  May
>>>>>>>>>>> as well update the spec now ...
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> Right. To summarize:
>>>>>>>>>>
>>>>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>>>>> specifically
>>>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>>>
>>>>>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>>>>>> fields are
>>>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>>>
>>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
>>>>>>>>>> small tweak
>>>>>>>>>> that I know applies). But now is a good time to be considering a
>>>>>>>>>> full
>>>>>>>>>> revision for JDK9.
>>>>>>>>>>
>>>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>>>> validate JVMs
>>>>>>>>>> as meeting this likely future spec.
>>>>>>>>>>
>>>>>>>>>> -Doug
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest
>>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/65d315ad/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  3 13:36:12 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 13:36:12 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E2077.7060805@oracle.com>
References: <5295E24C.40608@oracle.com>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAOwENi+7ROc+bQ1b5yPdYzBR6a9gNLBKyQV2MwYBvpnrsbe24g@mail.gmail.com>
	<529E2077.7060805@oracle.com>
Message-ID: <CAHjP37FhA5Sw9CiOc=nfpX1fJWNfK4j7bNXpj0dzPLEYevoKvg@mail.gmail.com>

No, the reason this thread started is because PPC port was failing the
torture tests because they weren't doing anything for volatiles, which if
you stick to spec, is correct.  We don't know what other VMs/ports also
don't do anything.

Sent from my phone
On Dec 3, 2013 1:18 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  No, I want the initialization of a concurrent tree with 1 million nodes
> in it to be cheap.
>
> Since per topic starter the JVMs already do this, just write it down as
> the law.
>
> Alex
>
>
> On 03/12/2013 17:56, Ruslan Cheremin wrote:
>
> I may ask you the complimentary question: do you want publication via data
> race to be widely adopted since ctors are safe against it? Do you really
> hope such practice would not go farther only publication, and would not
> lead to assumption "data race is generally not dangerous"?
>
>
>  As about ctors: I bet if you ask 100 java programmers about the
> difference between
>   sharedRef = new A();
>   sharedRef.init(42);
> and
>   sharedRef = new A(42);
>
>  90 of them say second is just shortcut for first.
>
>
>
> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>
>>  No, this is a completely opposite view. The question is:
>>
>> do you as the implementor of the concurrent algorithm ever intend the
>> constructor design to be such that relies on the protocol that the caller
>> chooses to publish the reference?
>>
>> (Do you ever intend to *not* specify a no-op volatile load after the
>> last volatile store in the constructor?)
>>
>>
>> Alex
>>
>>
>>
>> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>
>> I'm confident most code that publishes objects shared across threads does
>> it safely.  Otherwise we're saying majority of code uses data races?
>>
>> Sent from my phone
>> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  Hmmm.... I thought it is clear no one argues about the "*if* you
>>> publish safely" part. The question I am wondering about is whether you can
>>> find a case where publishing the reference to the instance unsafely is
>>> *intended*.
>>>
>>> Alex
>>>
>>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>
>>> But this is only if you publish unsafely, as mentioned before.  If you
>>> publish this class properly, you don't get races on the volatile.   Final
>>> fields are supposed to support immutable classes, where although not
>>> preferrable, publishing racily is plausible (for performance).  For
>>> read/write volatiles, it's not compelling on the surface.
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>
>>>>  Yes, but I mean that the code assumes the value to always be non-null
>>>> - eg a sentinel entry of the list is created at construction time. Without
>>>> the construction-time guarantee you'd need to test for null everywhere.
>>>>
>>>> I think the same applies in other constructors - if you write the
>>>> initialization of the volatile, you imply that's "the least" "possible"
>>>> value, the value representing the initial state of the concurrent algorithm
>>>> - the initial value guaranteed by Java spec may not represent any valid
>>>> state of the concurrent algorithm, let alone the initial state.
>>>>
>>>> That's why this really boils down to "find the broad cases where you do
>>>> want to permit unsafe publication of the initial values of the volatiles".
>>>>
>>>>
>>>> (unlike the non-volatile fields. Don't treat them as "not thread safe"
>>>> - instead, treat them as "assume as made thread-safe by means outside the
>>>> class specification", hence no requirement for "safe publication" there)
>>>>
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>
>>>> Initial value of the field must be the "zero" value of that type,
>>>> that's a language spec and must be guaranteed irrespective of volatile or
>>>> not.
>>>>
>>>> Sent from my phone
>>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <
>>>> oleksandr.otenko at oracle.com> wrote:
>>>>
>>>>>  I understand, but you can't insist on viewing ctors as "just methods"
>>>>> for all purposes.
>>>>>
>>>>> (2) publication is unsafe unless you get a volatile load after the
>>>>> last volatile store in the constructor. Besides, the initial value of the
>>>>> field may not even be one of the valid values, so it is not even just about
>>>>> a data race.
>>>>>
>>>>>
>>>>> Alex
>>>>>
>>>>>
>>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>
>>>>> For compilation/codegen purposes ctors *are* just methods - they can
>>>>> be inlined, code optimized, etc; that's the reason we have the final field
>>>>> guarantees.
>>>>>
>>>>> A couple of potential reasons not to add volatile to the spec:
>>>>> 1) perhaps some JVMs don't currently already give them final field
>>>>> semantics
>>>>> 2) this whole thing comes into play for unsafe publication only (I.e.
>>>>> data race), which is discouraged.
>>>>>
>>>>> Sent from my phone
>>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <
>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>
>>>>>>  Constructors *are* special methods. They are the first method calls
>>>>>> in any history of the object. This means a different treatment of volatile
>>>>>> accesses to the fields of the instance being created is possible - certain
>>>>>> barriers can be eliminated, because the loads can be proven to not
>>>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>>>> reason to permit subsequent calls to observe the initial state of the
>>>>>> volatile fields; whereas any volatile load in any other method always
>>>>>> synchronizes with a volatile store of some other method call, without the
>>>>>> final field semantics we cannot assume that.
>>>>>>
>>>>>> However, if we assume final field semantics, there is only one
>>>>>> barrier needed - a store-store after the last volatile field store. This
>>>>>> eliminates all barriers for any other volatile field initialization, and
>>>>>> eliminates a full barrier needed otherwise (got to place a dummy volatile
>>>>>> load after the last volatile store to make sure the semantics are stronger
>>>>>> than final-field) - think of removing a mfence or similar from each such
>>>>>> constructor on x86.
>>>>>>
>>>>>> (there will still be gotchas for cases when volatile field
>>>>>> initialization occurs after a volatile load of something outside the same
>>>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>>>> fields are just initialized into some instance-specific values)
>>>>>>
>>>>>>
>>>>>> Alex
>>>>>>
>>>>>>
>>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>
>>>>>> I'm about why "always mean storestore after volatile store in
>>>>>> constructor". It is not only efficiency which is important for MM, but also
>>>>>> simplicity and consistency. If constructors are special methods, not just
>>>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>>>> if constructors are just plain methods, it looks strange to have special
>>>>>> implicit semantics for constructors with volatiles inside.
>>>>>>
>>>>>>
>>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>>>
>>>>>>>  I think it is pretty simple.
>>>>>>>
>>>>>>> If you always mean a store-store barrier *after* the last volatile
>>>>>>> store in the constructor, then add that barrier into constructor semantics,
>>>>>>> like it's done with the final fields.
>>>>>>>
>>>>>>> It makes sense to *not* add it to the semantics, if you can come up
>>>>>>> with enough examples where you want that barrier to be eliminated.
>>>>>>>
>>>>>>> Alex
>>>>>>>
>>>>>>>
>>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>>
>>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>>>> I mean, I could not see any noticable difference between the case
>>>>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>>>> any other object which is unsafely published. I think everybody who passed
>>>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>>>> read [.value=0] in the case discussed.
>>>>>>>
>>>>>>>  "Data race is pure evil" was the motto of this list all time I was
>>>>>>> reading it. Why do we may want to introduce another example of benign race?
>>>>>>> Wouldn't it be just another source of confusion for newcomers?
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>>>
>>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>>>
>>>>>>>>> Doug, could you explain why it is so important to have this kind
>>>>>>>>> of safe
>>>>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>>>>> through data
>>>>>>>>> race to be allowed result, as current model (seem to) imply? It
>>>>>>>>> seems to be a
>>>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>>>
>>>>>>>>
>>>>>>>>  The main reason is that it is highly irregular and unexpected
>>>>>>>> by programmers. Except in this case, volatiles definitionally cannot
>>>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>>>> correctness on current JVMs. We have several constructions
>>>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>>>> candidate for reconsideration.
>>>>>>>>
>>>>>>>> -Doug
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>> Ruslan
>>>>>>>>>
>>>>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>> ???????(?):
>>>>>>>>>>
>>>>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>>>>>> optimizations to avoid zeroing memory is an implementation
>>>>>>>>>>> detail and
>>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think
>>>>>>>>>>> you're
>>>>>>>>>>> saying.
>>>>>>>>>>>
>>>>>>>>>>> The other issue is that even if we determine that volatiles
>>>>>>>>>>> don't get
>>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going to
>>>>>>>>>>> be
>>>>>>>>>>> practical to change it and risk hard to debug problems creeping
>>>>>>>>>>> in.  May
>>>>>>>>>>> as well update the spec now ...
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> Right. To summarize:
>>>>>>>>>>
>>>>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>>>>> specifically
>>>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>>>
>>>>>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>>>>>> fields are
>>>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>>>
>>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
>>>>>>>>>> small tweak
>>>>>>>>>> that I know applies). But now is a good time to be considering a
>>>>>>>>>> full
>>>>>>>>>> revision for JDK9.
>>>>>>>>>>
>>>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>>>> validate JVMs
>>>>>>>>>> as meeting this likely future spec.
>>>>>>>>>>
>>>>>>>>>> -Doug
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest
>>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/5d1102f9/attachment-0001.html>

From oleksandr.otenko at oracle.com  Tue Dec  3 13:44:09 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 18:44:09 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
References: <5295E24C.40608@oracle.com>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
Message-ID: <529E2679.6080204@oracle.com>

I don't think you'd need it in a constructor.

You can't read the fields until the reference to the instance is stored. 
If you can stop reordering that store with the last volatile store, 
publication is safe.

Alex

On 03/12/2013 18:34, Vitaly Davidovich wrote:
>
> For volatiles, you'd need load-store as well though.
>
> Sent from my phone
>
> On Dec 3, 2013 1:05 PM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     Sure.
>
>     f=42;
>
>     already imposes the cost of store-store barrier.
>
>     f=42;
>     f=42;
>
>     does the same thing. In a constructor, eliminate the first
>     barrier, because the order of writes to the unreachable instance
>     is not important, and the second store. This no longer is the
>     question of performance, because it is the same. It is the
>     question of correctness for free.
>
>     Alex
>
>     On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>
>>     Not sure that's the right view either.  The one thing the author
>>     does not control is how instances of their class are passed
>>     around.  User of the class has more context - it may actually be
>>     ok that volatiles aren't fenced here because they're already
>>     ensuring some way that it's fine, including the possibility that
>>     the instance isn't even shared at all.  As long as people know
>>     the behavior of the language/platform, they should be expected to
>>     make an educated decision on their own.
>>
>>     Look, if performance didn't matter, you could just blindly say
>>     that all constructors have a freeze action, regardless of final
>>     fields or volatile.  That's not the case, of course.  Java and
>>     JDK have tools available to publish safely, so people doing
>>     multithreading have the ability to do the right thing. At the end
>>     of the day, exposing concurrency to devs will lead to bugs, even
>>     beside the issues described here.
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 12:42 PM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         No, this is a completely opposite view. The question is:
>>
>>         do you as the implementor of the concurrent algorithm ever
>>         intend the constructor design to be such that relies on the
>>         protocol that the caller chooses to publish the reference?
>>
>>         (Do you ever intend to /*not*/ specify a no-op volatile load
>>         after the last volatile store in the constructor?)
>>
>>
>>         Alex
>>
>>
>>         On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>>
>>>         I'm confident most code that publishes objects shared across
>>>         threads does it safely.  Otherwise we're saying majority of
>>>         code uses data races?
>>>
>>>         Sent from my phone
>>>
>>>         On Dec 3, 2013 12:21 PM, "Oleksandr Otenko"
>>>         <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>
>>>             Hmmm.... I thought it is clear no one argues about the
>>>             "/*if*/ you publish safely" part. The question I am
>>>             wondering about is whether you can find a case where
>>>             publishing the reference to the instance unsafely is
>>>             /intended/.
>>>
>>>             Alex
>>>
>>>             On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>>
>>>>             But this is only if you publish unsafely, as mentioned
>>>>             before. If you publish this class properly, you don't
>>>>             get races on the volatile.   Final fields are supposed
>>>>             to support immutable classes, where although not
>>>>             preferrable, publishing racily is plausible (for
>>>>             performance).  For read/write volatiles, it's not
>>>>             compelling on the surface.
>>>>
>>>>             Sent from my phone
>>>>
>>>>             On Dec 3, 2013 11:18 AM, "Oleksandr Otenko"
>>>>             <oleksandr.otenko at oracle.com
>>>>             <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>
>>>>                 Yes, but I mean that the code assumes the value to
>>>>                 always be non-null - eg a sentinel entry of the
>>>>                 list is created at construction time. Without the
>>>>                 construction-time guarantee you'd need to test for
>>>>                 null everywhere.
>>>>
>>>>                 I think the same applies in other constructors - if
>>>>                 you write the initialization of the volatile, you
>>>>                 imply that's "the least" "possible" value, the
>>>>                 value representing the initial state of the
>>>>                 concurrent algorithm - the initial value guaranteed
>>>>                 by Java spec may not represent any valid state of
>>>>                 the concurrent algorithm, let alone the initial state.
>>>>
>>>>                 That's why this really boils down to "find the
>>>>                 broad cases where you do want to permit unsafe
>>>>                 publication of the initial values of the volatiles".
>>>>
>>>>
>>>>                 (unlike the non-volatile fields. Don't treat them
>>>>                 as "not thread safe" - instead, treat them as
>>>>                 "assume as made thread-safe by means outside the
>>>>                 class specification", hence no requirement for
>>>>                 "safe publication" there)
>>>>
>>>>
>>>>                 Alex
>>>>
>>>>
>>>>                 On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>>
>>>>>                 Initial value of the field must be the "zero"
>>>>>                 value of that type, that's a language spec and
>>>>>                 must be guaranteed irrespective of volatile or not.
>>>>>
>>>>>                 Sent from my phone
>>>>>
>>>>>                 On Dec 3, 2013 10:03 AM, "Oleksandr Otenko"
>>>>>                 <oleksandr.otenko at oracle.com
>>>>>                 <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>
>>>>>                     I understand, but you can't insist on viewing
>>>>>                     ctors as "just methods" for all purposes.
>>>>>
>>>>>                     (2) publication is unsafe unless you get a
>>>>>                     volatile load after the last volatile store in
>>>>>                     the constructor. Besides, the initial value of
>>>>>                     the field may not even be one of the valid
>>>>>                     values, so it is not even just about a data race.
>>>>>
>>>>>
>>>>>                     Alex
>>>>>
>>>>>
>>>>>                     On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>>
>>>>>>                     For compilation/codegen purposes ctors *are*
>>>>>>                     just methods - they can be inlined, code
>>>>>>                     optimized, etc; that's the reason we have the
>>>>>>                     final field guarantees.
>>>>>>
>>>>>>                     A couple of potential reasons not to add
>>>>>>                     volatile to the spec:
>>>>>>                     1) perhaps some JVMs don't currently already
>>>>>>                     give them final field semantics
>>>>>>                     2) this whole thing comes into play for
>>>>>>                     unsafe publication only (I.e. data race),
>>>>>>                     which is discouraged.
>>>>>>
>>>>>>                     Sent from my phone
>>>>>>
>>>>>>                     On Dec 3, 2013 6:51 AM, "Oleksandr Otenko"
>>>>>>                     <oleksandr.otenko at oracle.com
>>>>>>                     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>
>>>>>>                         Constructors /are/ special methods. They
>>>>>>                         are the first method calls in any history
>>>>>>                         of the object. This means a different
>>>>>>                         treatment of volatile accesses to the
>>>>>>                         fields of the instance being created is
>>>>>>                         possible - certain barriers can be
>>>>>>                         eliminated, because the loads can be
>>>>>>                         proven to not synchronize with anyone.
>>>>>>                         For the sake of the argument, it is
>>>>>>                         possible to proceed with weak treatment
>>>>>>                         of volatile stores, too, but you need a
>>>>>>                         good reason to permit subsequent calls to
>>>>>>                         observe the initial state of the volatile
>>>>>>                         fields; whereas any volatile load in any
>>>>>>                         other method always synchronizes with a
>>>>>>                         volatile store of some other method call,
>>>>>>                         without the final field semantics we
>>>>>>                         cannot assume that.
>>>>>>
>>>>>>                         However, if we assume final field
>>>>>>                         semantics, there is only one barrier
>>>>>>                         needed - a store-store after the last
>>>>>>                         volatile field store. This eliminates all
>>>>>>                         barriers for any other volatile field
>>>>>>                         initialization, and eliminates a full
>>>>>>                         barrier needed otherwise (got to place a
>>>>>>                         dummy volatile load after the last
>>>>>>                         volatile store to make sure the semantics
>>>>>>                         are stronger than final-field) - think of
>>>>>>                         removing a mfence or similar from each
>>>>>>                         such constructor on x86.
>>>>>>
>>>>>>                         (there will still be gotchas for cases
>>>>>>                         when volatile field initialization occurs
>>>>>>                         after a volatile load of something
>>>>>>                         outside the same instance; but the main
>>>>>>                         purpose is to eliminate barriers when the
>>>>>>                         volatile fields are just initialized into
>>>>>>                         some instance-specific values)
>>>>>>
>>>>>>
>>>>>>                         Alex
>>>>>>
>>>>>>
>>>>>>                         On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>>                         I'm about why "always mean storestore
>>>>>>>                         after volatile store in constructor". It
>>>>>>>                         is not only efficiency which is
>>>>>>>                         important for MM, but also simplicity
>>>>>>>                         and consistency. If constructors are
>>>>>>>                         special methods, not just plain <init>,
>>>>>>>                         then we should add this kind of
>>>>>>>                         atomicity to all constructors (which, as
>>>>>>>                         I was reading here, could be inefficient
>>>>>>>                         on some platforms). But if constructors
>>>>>>>                         are just plain methods, it looks strange
>>>>>>>                         to have special implicit semantics for
>>>>>>>                         constructors with volatiles inside.
>>>>>>>
>>>>>>>
>>>>>>>                         2013/12/3 Oleksandr Otenko
>>>>>>>                         <oleksandr.otenko at oracle.com
>>>>>>>                         <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>
>>>>>>>                             I think it is pretty simple.
>>>>>>>
>>>>>>>                             If you always mean a store-store
>>>>>>>                             barrier /after/ the last volatile
>>>>>>>                             store in the constructor, then add
>>>>>>>                             that barrier into constructor
>>>>>>>                             semantics, like it's done with the
>>>>>>>                             final fields.
>>>>>>>
>>>>>>>                             It makes sense to /not/ add it to
>>>>>>>                             the semantics, if you can come up
>>>>>>>                             with enough examples where you want
>>>>>>>                             that barrier to be eliminated.
>>>>>>>
>>>>>>>                             Alex
>>>>>>>
>>>>>>>
>>>>>>>                             On 02/12/2013 19:32, Ruslan Cheremin
>>>>>>>                             wrote:
>>>>>>>>                             Well, I do not see any data race
>>>>>>>>                             _on volatiles_ here. I see race
>>>>>>>>                             condition on volatile .value, yes
>>>>>>>>                             -- but it is pretty legal (and
>>>>>>>>                             unavoidable, I suppose) to have
>>>>>>>>                             race conditions even with volatiles
>>>>>>>>                             involved. The only data race I see
>>>>>>>>                             is around read-write of
>>>>>>>>                             (non-volatile) AtomicInteger's
>>>>>>>>                             reference -- which is unrelated to
>>>>>>>>                             AtomicInteger's content. I mean, I
>>>>>>>>                             could not see any noticable
>>>>>>>>                             difference between the case
>>>>>>>>                             discussed, and just any other case
>>>>>>>>                             there volatile is _incorrectly_
>>>>>>>>                             used to "synchronize" data accesses
>>>>>>>>                             -- it could still be data race on
>>>>>>>>                             non-volatile fields, even if
>>>>>>>>                             volatile fields are also used
>>>>>>>>                             somewhere around. Yes, get 0 from
>>>>>>>>                             .value is unexpected -- but there
>>>>>>>>                             are many unexpected things in
>>>>>>>>                             memory models. It is noway more
>>>>>>>>                             unexpected then to see default
>>>>>>>>                             values in fields of any other
>>>>>>>>                             object which is unsafely published.
>>>>>>>>                             I think everybody who passed
>>>>>>>>                             through broken atomicity of
>>>>>>>>                             constructor call could easy see the
>>>>>>>>                             chance to read [.value=0] in the
>>>>>>>>                             case discussed.
>>>>>>>>
>>>>>>>>                             "Data race is pure evil" was the
>>>>>>>>                             motto of this list all time I was
>>>>>>>>                             reading it. Why do we may want to
>>>>>>>>                             introduce another example of benign
>>>>>>>>                             race? Wouldn't it be just another
>>>>>>>>                             source of confusion for newcomers?
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>                             2013/12/2 Doug Lea
>>>>>>>>                             <dl at cs.oswego.edu
>>>>>>>>                             <mailto:dl at cs.oswego.edu>>
>>>>>>>>
>>>>>>>>                                 On 12/02/2013 03:57 AM,
>>>>>>>>                                 Cheremin Ruslan wrote:
>>>>>>>>
>>>>>>>>                                     Doug, could you explain why
>>>>>>>>                                     it is so important to have
>>>>>>>>                                     this kind of safe
>>>>>>>>                                     publication for volatile? I
>>>>>>>>                                     mean, could we just go with
>>>>>>>>                                     .value=0 through data
>>>>>>>>                                     race to be allowed result,
>>>>>>>>                                     as current model (seem to)
>>>>>>>>                                     imply? It seems to be a
>>>>>>>>                                     dr-case anyway, why we need
>>>>>>>>                                     special handling of it?
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 The main reason is that it is
>>>>>>>>                                 highly irregular and unexpected
>>>>>>>>                                 by programmers. Except in this
>>>>>>>>                                 case, volatiles definitionally
>>>>>>>>                                 cannot
>>>>>>>>                                 be subject to data races.
>>>>>>>>                                 Dealing with it requires
>>>>>>>>                                 cleverness,
>>>>>>>>                                 complexity, and/or
>>>>>>>>                                 error-proneness that isn't even
>>>>>>>>                                 required for
>>>>>>>>                                 correctness on current JVMs. We
>>>>>>>>                                 have several constructions
>>>>>>>>                                 in j.u.c that work around
>>>>>>>>                                 problems by using explicit ordered
>>>>>>>>                                 writes in constructors,
>>>>>>>>                                 redundant-looking null-checks,
>>>>>>>>                                 and so
>>>>>>>>                                 on. If we are going to repair
>>>>>>>>                                 the JMM anyway, this is a clear
>>>>>>>>                                 candidate for reconsideration.
>>>>>>>>
>>>>>>>>                                 -Doug
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>                                     Ruslan
>>>>>>>>
>>>>>>>>                                         27 ????. 2013 ?., ?
>>>>>>>>                                         23:26, Doug Lea
>>>>>>>>                                         <dl at cs.oswego.edu
>>>>>>>>                                         <mailto:dl at cs.oswego.edu>>
>>>>>>>>                                         ???????(?):
>>>>>>>>
>>>>>>>>                                             On 11/27/2013 02:06
>>>>>>>>                                             PM, Vitaly
>>>>>>>>                                             Davidovich wrote:
>>>>>>>>                                             But either way,
>>>>>>>>                                             optimizations to
>>>>>>>>                                             avoid zeroing
>>>>>>>>                                             memory is an
>>>>>>>>                                             implementation
>>>>>>>>                                             detail and
>>>>>>>>                                             thus cannot be
>>>>>>>>                                             relied upon from
>>>>>>>>                                             JMM standpoint,
>>>>>>>>                                             which I think you're
>>>>>>>>                                             saying.
>>>>>>>>
>>>>>>>>                                             The other issue is
>>>>>>>>                                             that even if we
>>>>>>>>                                             determine that
>>>>>>>>                                             volatiles don't get
>>>>>>>>                                             this treatment, if
>>>>>>>>                                             JVM is already
>>>>>>>>                                             ensuring it, it's
>>>>>>>>                                             not going to be
>>>>>>>>                                             practical to change
>>>>>>>>                                             it and risk hard to
>>>>>>>>                                             debug problems
>>>>>>>>                                             creeping in.  May
>>>>>>>>                                             as well update the
>>>>>>>>                                             spec now ...
>>>>>>>>
>>>>>>>>
>>>>>>>>                                         Right. To summarize:
>>>>>>>>
>>>>>>>>                                         * Programmers do not
>>>>>>>>                                         expect that even though
>>>>>>>>                                         final fields are
>>>>>>>>                                         specifically
>>>>>>>>                                         publication-safe,
>>>>>>>>                                         volatile fields are not
>>>>>>>>                                         always so.
>>>>>>>>
>>>>>>>>                                         * For various
>>>>>>>>                                         implementation reasons,
>>>>>>>>                                         JVMs arrange that
>>>>>>>>                                         volatile fields are
>>>>>>>>                                         publication safe
>>>>>>>>                                         anyway, at least in
>>>>>>>>                                         cases we know about.
>>>>>>>>
>>>>>>>>                                         * Actually updating the
>>>>>>>>                                         JMM/JLS to mandate this
>>>>>>>>                                         is not easy (no small tweak
>>>>>>>>                                         that I know applies).
>>>>>>>>                                         But now is a good time
>>>>>>>>                                         to be considering a full
>>>>>>>>                                         revision for JDK9.
>>>>>>>>
>>>>>>>>                                         * In the mean time, it
>>>>>>>>                                         would make sense to
>>>>>>>>                                         further test and
>>>>>>>>                                         validate JVMs
>>>>>>>>                                         as meeting this likely
>>>>>>>>                                         future spec.
>>>>>>>>
>>>>>>>>                                         -Doug
>>>>>>>>
>>>>>>>>                                         _______________________________________________
>>>>>>>>                                         Concurrency-interest
>>>>>>>>                                         mailing list
>>>>>>>>                                         Concurrency-interest at cs.oswego.edu
>>>>>>>>                                         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>                                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>                             _______________________________________________
>>>>>>>>                             Concurrency-interest mailing list
>>>>>>>>                             Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>                             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>>                             _______________________________________________
>>>>>>>                             Concurrency-interest mailing list
>>>>>>>                             Concurrency-interest at cs.oswego.edu
>>>>>>>                             <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>                             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>>                         _______________________________________________
>>>>>>                         Concurrency-interest mailing list
>>>>>>                         Concurrency-interest at cs.oswego.edu
>>>>>>                         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>
>>>>
>>>>
>>>>                 _______________________________________________
>>>>                 Concurrency-interest mailing list
>>>>                 Concurrency-interest at cs.oswego.edu
>>>>                 <mailto:Concurrency-interest at cs.oswego.edu>
>>>>                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/bfd18d53/attachment-0001.html>

From zhong.j.yu at gmail.com  Tue Dec  3 13:44:28 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Tue, 3 Dec 2013 12:44:28 -0600
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAOwENiJVDXHkbLDLDpnOnYRBedFYxdOgujFef1PywaFSGtp=Qg@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAOwENi+7ROc+bQ1b5yPdYzBR6a9gNLBKyQV2MwYBvpnrsbe24g@mail.gmail.com>
	<CACuKZqGUXoxGTfLvNwEnzxOwKyiSSXeAwqqQ4xQLttCdTJL9xw@mail.gmail.com>
	<CAOwENiJVDXHkbLDLDpnOnYRBedFYxdOgujFef1PywaFSGtp=Qg@mail.gmail.com>
Message-ID: <CACuKZqFkVt30s7skdT62VKVidhS7j6-pdgU8WpMzATFy6cAokw@mail.gmail.com>

I understanding of the word "immutability", when it's used in the wild
by java programmers, is that it does not simply mean that fields
cannot be written outside constructors; actually it means something
much stronger, which is all threads much observe the same state of an
object, not matter what.

Such strong requirement is apparently an overkill for most classes.
Unfortunately it seems to be the mainstream belief in java community.




On Tue, Dec 3, 2013 at 12:21 PM, Ruslan Cheremin <cheremin at gmail.com> wrote:
> But immutability is good not because it is thread-safe, but because it is
> immutability -- no state, no transitions, you know, like you're in Eden, or
> in Clojure :) Thread safety is just one of consequences of having no state,
> and special semantics for final fields in java just stamp this expectable
> property. Making ctors "atomic" not supply you with even 1% of what
> immutability gives. But (I'm afraid, but not sure) it requires complexity in
> formal model comparable with final fields definition. What is why I do not
> think it worth it. If it could be injected simply and naturally, without
> another "HB which is not transitive with ordinary HB, and not transitive
> with final-fields-HB..." -- may be it worth it.
>
>
> 2013/12/3 Zhong Yu <zhong.j.yu at gmail.com>
>>
>> Note that majority of Java programmers are taught that immutability is
>> a good thing, that they should mark all fields as final whenever
>> possible. If that teaching is correct, obviously the language would be
>> even better if it extends final field semantics to all fields. If that
>> teaching is incorrect, Joshua Bloch should recall his books:)
>>
>> On Tue, Dec 3, 2013 at 11:56 AM, Ruslan Cheremin <cheremin at gmail.com>
>> wrote:
>> > I may ask you the complimentary question: do you want publication via
>> > data
>> > race to be widely adopted since ctors are safe against it? Do you really
>> > hope such practice would not go farther only publication, and would not
>> > lead
>> > to assumption "data race is generally not dangerous"?
>> >
>> >
>> > As about ctors: I bet if you ask 100 java programmers about the
>> > difference
>> > between
>> >   sharedRef = new A();
>> >   sharedRef.init(42);
>> > and
>> >   sharedRef = new A(42);
>> >
>> > 90 of them say second is just shortcut for first.
>> >
>> >
>> >
>> > 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>> >>
>> >> No, this is a completely opposite view. The question is:
>> >>
>> >> do you as the implementor of the concurrent algorithm ever intend the
>> >> constructor design to be such that relies on the protocol that the
>> >> caller
>> >> chooses to publish the reference?
>> >>
>> >> (Do you ever intend to not specify a no-op volatile load after the last
>> >> volatile store in the constructor?)
>> >>
>> >>
>> >> Alex
>> >>
>> >>
>> >>
>> >> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>> >>
>> >> I'm confident most code that publishes objects shared across threads
>> >> does
>> >> it safely.  Otherwise we're saying majority of code uses data races?
>> >>
>> >> Sent from my phone
>> >>
>> >> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko"
>> >> <oleksandr.otenko at oracle.com>
>> >> wrote:
>> >>>
>> >>> Hmmm.... I thought it is clear no one argues about the "if you publish
>> >>> safely" part. The question I am wondering about is whether you can
>> >>> find a
>> >>> case where publishing the reference to the instance unsafely is
>> >>> intended.
>> >>>
>> >>> Alex
>> >>>
>> >>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>> >>>
>> >>> But this is only if you publish unsafely, as mentioned before.  If you
>> >>> publish this class properly, you don't get races on the volatile.
>> >>> Final
>> >>> fields are supposed to support immutable classes, where although not
>> >>> preferrable, publishing racily is plausible (for performance).  For
>> >>> read/write volatiles, it's not compelling on the surface.
>> >>>
>> >>> Sent from my phone
>> >>>
>> >>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko"
>> >>> <oleksandr.otenko at oracle.com>
>> >>> wrote:
>> >>>>
>> >>>> Yes, but I mean that the code assumes the value to always be non-null
>> >>>> -
>> >>>> eg a sentinel entry of the list is created at construction time.
>> >>>> Without the
>> >>>> construction-time guarantee you'd need to test for null everywhere.
>> >>>>
>> >>>> I think the same applies in other constructors - if you write the
>> >>>> initialization of the volatile, you imply that's "the least"
>> >>>> "possible"
>> >>>> value, the value representing the initial state of the concurrent
>> >>>> algorithm
>> >>>> - the initial value guaranteed by Java spec may not represent any
>> >>>> valid
>> >>>> state of the concurrent algorithm, let alone the initial state.
>> >>>>
>> >>>> That's why this really boils down to "find the broad cases where you
>> >>>> do
>> >>>> want to permit unsafe publication of the initial values of the
>> >>>> volatiles".
>> >>>>
>> >>>>
>> >>>> (unlike the non-volatile fields. Don't treat them as "not thread
>> >>>> safe" -
>> >>>> instead, treat them as "assume as made thread-safe by means outside
>> >>>> the
>> >>>> class specification", hence no requirement for "safe publication"
>> >>>> there)
>> >>>>
>> >>>>
>> >>>> Alex
>> >>>>
>> >>>>
>> >>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>> >>>>
>> >>>> Initial value of the field must be the "zero" value of that type,
>> >>>> that's
>> >>>> a language spec and must be guaranteed irrespective of volatile or
>> >>>> not.
>> >>>>
>> >>>> Sent from my phone
>> >>>>
>> >>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko"
>> >>>> <oleksandr.otenko at oracle.com> wrote:
>> >>>>>
>> >>>>> I understand, but you can't insist on viewing ctors as "just
>> >>>>> methods"
>> >>>>> for all purposes.
>> >>>>>
>> >>>>> (2) publication is unsafe unless you get a volatile load after the
>> >>>>> last
>> >>>>> volatile store in the constructor. Besides, the initial value of the
>> >>>>> field
>> >>>>> may not even be one of the valid values, so it is not even just
>> >>>>> about a data
>> >>>>> race.
>> >>>>>
>> >>>>>
>> >>>>> Alex
>> >>>>>
>> >>>>>
>> >>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>> >>>>>
>> >>>>> For compilation/codegen purposes ctors *are* just methods - they can
>> >>>>> be
>> >>>>> inlined, code optimized, etc; that's the reason we have the final
>> >>>>> field
>> >>>>> guarantees.
>> >>>>>
>> >>>>> A couple of potential reasons not to add volatile to the spec:
>> >>>>> 1) perhaps some JVMs don't currently already give them final field
>> >>>>> semantics
>> >>>>> 2) this whole thing comes into play for unsafe publication only
>> >>>>> (I.e.
>> >>>>> data race), which is discouraged.
>> >>>>>
>> >>>>> Sent from my phone
>> >>>>>
>> >>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko"
>> >>>>> <oleksandr.otenko at oracle.com> wrote:
>> >>>>>>
>> >>>>>> Constructors are special methods. They are the first method calls
>> >>>>>> in
>> >>>>>> any history of the object. This means a different treatment of
>> >>>>>> volatile
>> >>>>>> accesses to the fields of the instance being created is possible -
>> >>>>>> certain
>> >>>>>> barriers can be eliminated, because the loads can be proven to not
>> >>>>>> synchronize with anyone. For the sake of the argument, it is
>> >>>>>> possible to
>> >>>>>> proceed with weak treatment of volatile stores, too, but you need a
>> >>>>>> good
>> >>>>>> reason to permit subsequent calls to observe the initial state of
>> >>>>>> the
>> >>>>>> volatile fields; whereas any volatile load in any other method
>> >>>>>> always
>> >>>>>> synchronizes with a volatile store of some other method call,
>> >>>>>> without the
>> >>>>>> final field semantics we cannot assume that.
>> >>>>>>
>> >>>>>> However, if we assume final field semantics, there is only one
>> >>>>>> barrier
>> >>>>>> needed - a store-store after the last volatile field store. This
>> >>>>>> eliminates
>> >>>>>> all barriers for any other volatile field initialization, and
>> >>>>>> eliminates a
>> >>>>>> full barrier needed otherwise (got to place a dummy volatile load
>> >>>>>> after the
>> >>>>>> last volatile store to make sure the semantics are stronger than
>> >>>>>> final-field) - think of removing a mfence or similar from each such
>> >>>>>> constructor on x86.
>> >>>>>>
>> >>>>>> (there will still be gotchas for cases when volatile field
>> >>>>>> initialization occurs after a volatile load of something outside
>> >>>>>> the same
>> >>>>>> instance; but the main purpose is to eliminate barriers when the
>> >>>>>> volatile
>> >>>>>> fields are just initialized into some instance-specific values)
>> >>>>>>
>> >>>>>>
>> >>>>>> Alex
>> >>>>>>
>> >>>>>>
>> >>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>> >>>>>>
>> >>>>>> I'm about why "always mean storestore after volatile store in
>> >>>>>> constructor". It is not only efficiency which is important for MM,
>> >>>>>> but also
>> >>>>>> simplicity and consistency. If constructors are special methods,
>> >>>>>> not just
>> >>>>>> plain <init>, then we should add this kind of atomicity to all
>> >>>>>> constructors
>> >>>>>> (which, as I was reading here, could be inefficient on some
>> >>>>>> platforms). But
>> >>>>>> if constructors are just plain methods, it looks strange to have
>> >>>>>> special
>> >>>>>> implicit semantics for constructors with volatiles inside.
>> >>>>>>
>> >>>>>>
>> >>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>> >>>>>>>
>> >>>>>>> I think it is pretty simple.
>> >>>>>>>
>> >>>>>>> If you always mean a store-store barrier after the last volatile
>> >>>>>>> store in the constructor, then add that barrier into constructor
>> >>>>>>> semantics,
>> >>>>>>> like it's done with the final fields.
>> >>>>>>>
>> >>>>>>> It makes sense to not add it to the semantics, if you can come up
>> >>>>>>> with enough examples where you want that barrier to be eliminated.
>> >>>>>>>
>> >>>>>>> Alex
>> >>>>>>>
>> >>>>>>>
>> >>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>> >>>>>>>
>> >>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>> >>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>> >>>>>>> unavoidable, I suppose) to have race conditions even with
>> >>>>>>> volatiles
>> >>>>>>> involved. The only data race I see is around read-write of
>> >>>>>>> (non-volatile)
>> >>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's
>> >>>>>>> content.
>> >>>>>>> I mean, I could not see any noticable difference between the case
>> >>>>>>> discussed,
>> >>>>>>> and just any other case there volatile is _incorrectly_ used to
>> >>>>>>> "synchronize" data accesses -- it could still be data race on
>> >>>>>>> non-volatile
>> >>>>>>> fields, even if volatile fields are also used somewhere around.
>> >>>>>>> Yes, get 0
>> >>>>>>> from .value is unexpected -- but there are many unexpected things
>> >>>>>>> in memory
>> >>>>>>> models. It is noway more unexpected then to see default values in
>> >>>>>>> fields of
>> >>>>>>> any other object which is unsafely published. I think everybody
>> >>>>>>> who passed
>> >>>>>>> through broken atomicity of constructor call could easy see the
>> >>>>>>> chance to
>> >>>>>>> read [.value=0] in the case discussed.
>> >>>>>>>
>> >>>>>>> "Data race is pure evil" was the motto of this list all time I was
>> >>>>>>> reading it. Why do we may want to introduce another example of
>> >>>>>>> benign race?
>> >>>>>>> Wouldn't it be just another source of confusion for newcomers?
>> >>>>>>>
>> >>>>>>>
>> >>>>>>>
>> >>>>>>>
>> >>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>> >>>>>>>>
>> >>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>> >>>>>>>>>
>> >>>>>>>>> Doug, could you explain why it is so important to have this kind
>> >>>>>>>>> of
>> >>>>>>>>> safe
>> >>>>>>>>> publication for volatile? I mean, could we just go with .value=0
>> >>>>>>>>> through data
>> >>>>>>>>> race to be allowed result, as current model (seem to) imply? It
>> >>>>>>>>> seems to be a
>> >>>>>>>>> dr-case anyway, why we need special handling of it?
>> >>>>>>>>
>> >>>>>>>>
>> >>>>>>>> The main reason is that it is highly irregular and unexpected
>> >>>>>>>> by programmers. Except in this case, volatiles definitionally
>> >>>>>>>> cannot
>> >>>>>>>> be subject to data races. Dealing with it requires cleverness,
>> >>>>>>>> complexity, and/or error-proneness that isn't even required for
>> >>>>>>>> correctness on current JVMs. We have several constructions
>> >>>>>>>> in j.u.c that work around problems by using explicit ordered
>> >>>>>>>> writes in constructors, redundant-looking null-checks, and so
>> >>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>> >>>>>>>> candidate for reconsideration.
>> >>>>>>>>
>> >>>>>>>> -Doug
>> >>>>>>>>
>> >>>>>>>>
>> >>>>>>>>
>> >>>>>>>>>
>> >>>>>>>>> Ruslan
>> >>>>>>>>>
>> >>>>>>>>>> 27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu>
>> >>>>>>>>>> ???????(?):
>> >>>>>>>>>>
>> >>>>>>>>>>> On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either
>> >>>>>>>>>>> way,
>> >>>>>>>>>>> optimizations to avoid zeroing memory is an implementation
>> >>>>>>>>>>> detail
>> >>>>>>>>>>> and
>> >>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think
>> >>>>>>>>>>> you're
>> >>>>>>>>>>> saying.
>> >>>>>>>>>>>
>> >>>>>>>>>>> The other issue is that even if we determine that volatiles
>> >>>>>>>>>>> don't
>> >>>>>>>>>>> get
>> >>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going
>> >>>>>>>>>>> to
>> >>>>>>>>>>> be
>> >>>>>>>>>>> practical to change it and risk hard to debug problems
>> >>>>>>>>>>> creeping
>> >>>>>>>>>>> in.  May
>> >>>>>>>>>>> as well update the spec now ...
>> >>>>>>>>>>
>> >>>>>>>>>>
>> >>>>>>>>>> Right. To summarize:
>> >>>>>>>>>>
>> >>>>>>>>>> * Programmers do not expect that even though final fields are
>> >>>>>>>>>> specifically
>> >>>>>>>>>> publication-safe, volatile fields are not always so.
>> >>>>>>>>>>
>> >>>>>>>>>> * For various implementation reasons, JVMs arrange that
>> >>>>>>>>>> volatile
>> >>>>>>>>>> fields are
>> >>>>>>>>>> publication safe anyway, at least in cases we know about.
>> >>>>>>>>>>
>> >>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
>> >>>>>>>>>> small tweak
>> >>>>>>>>>> that I know applies). But now is a good time to be considering
>> >>>>>>>>>> a
>> >>>>>>>>>> full
>> >>>>>>>>>> revision for JDK9.
>> >>>>>>>>>>
>> >>>>>>>>>> * In the mean time, it would make sense to further test and
>> >>>>>>>>>> validate JVMs
>> >>>>>>>>>> as meeting this likely future spec.
>> >>>>>>>>>>
>> >>>>>>>>>> -Doug
>> >>>>>>>>>>
>> >>>>>>>>>> _______________________________________________
>> >>>>>>>>>> Concurrency-interest
>> >>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>> >>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>>>>>>>
>> >>>>>>>>>
>> >>>>>>>>
>> >>>>>>>>
>> >>>>>>>
>> >>>>>>>
>> >>>>>>>
>> >>>>>>> _______________________________________________
>> >>>>>>> Concurrency-interest mailing list
>> >>>>>>> Concurrency-interest at cs.oswego.edu
>> >>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>>>>>
>> >>>>>>>
>> >>>>>>>
>> >>>>>>> _______________________________________________
>> >>>>>>> Concurrency-interest mailing list
>> >>>>>>> Concurrency-interest at cs.oswego.edu
>> >>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>>>>>
>> >>>>>>
>> >>>>>>
>> >>>>>>
>> >>>>>> _______________________________________________
>> >>>>>> Concurrency-interest mailing list
>> >>>>>> Concurrency-interest at cs.oswego.edu
>> >>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>>>>
>> >>>>>
>> >>>>
>> >>>>
>> >>>> _______________________________________________
>> >>>> Concurrency-interest mailing list
>> >>>> Concurrency-interest at cs.oswego.edu
>> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>>
>> >>>
>> >>
>> >>
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>
>


From vitalyd at gmail.com  Tue Dec  3 13:51:21 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 13:51:21 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E2679.6080204@oracle.com>
References: <5295E24C.40608@oracle.com>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
Message-ID: <CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>

You would - since volatile can be modified and read many times in ctor, you
need to ensure all loads are done before the store and before ctor exits -
you need to ensure value of the volatile is the final one at the end of the
ctor sequence.  Otherwise, the loads can move after the store.  Basically,
you need lazySet() now and not plain storestore.

Sent from my phone
On Dec 3, 2013 1:44 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  I don't think you'd need it in a constructor.
>
> You can't read the fields until the reference to the instance is stored.
> If you can stop reordering that store with the last volatile store,
> publication is safe.
>
> Alex
>
> On 03/12/2013 18:34, Vitaly Davidovich wrote:
>
> For volatiles, you'd need load-store as well though.
>
> Sent from my phone
> On Dec 3, 2013 1:05 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  Sure.
>>
>> f=42;
>>
>> already imposes the cost of store-store barrier.
>>
>> f=42;
>> f=42;
>>
>> does the same thing. In a constructor, eliminate the first barrier,
>> because the order of writes to the unreachable instance is not important,
>> and the second store. This no longer is the question of performance,
>> because it is the same. It is the question of correctness for free.
>>
>> Alex
>>
>> On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>
>> Not sure that's the right view either.  The one thing the author does not
>> control is how instances of their class are passed around.  User of the
>> class has more context - it may actually be ok that volatiles aren't fenced
>> here because they're already ensuring some way that it's fine, including
>> the possibility that the instance isn't even shared at all.  As long as
>> people know the behavior of the language/platform, they should be expected
>> to make an educated decision on their own.
>>
>> Look, if performance didn't matter, you could just blindly say that all
>> constructors have a freeze action, regardless of final fields or volatile.
>> That's not the case, of course.  Java and JDK have tools available to
>> publish safely, so people doing multithreading have the ability to do the
>> right thing.  At the end of the day, exposing concurrency to devs will lead
>> to bugs, even beside the issues described here.
>>
>> Sent from my phone
>> On Dec 3, 2013 12:42 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  No, this is a completely opposite view. The question is:
>>>
>>> do you as the implementor of the concurrent algorithm ever intend the
>>> constructor design to be such that relies on the protocol that the caller
>>> chooses to publish the reference?
>>>
>>> (Do you ever intend to *not* specify a no-op volatile load after the
>>> last volatile store in the constructor?)
>>>
>>>
>>> Alex
>>>
>>>
>>> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>>
>>> I'm confident most code that publishes objects shared across threads
>>> does it safely.  Otherwise we're saying majority of code uses data races?
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>
>>>>  Hmmm.... I thought it is clear no one argues about the "*if* you
>>>> publish safely" part. The question I am wondering about is whether you can
>>>> find a case where publishing the reference to the instance unsafely is
>>>> *intended*.
>>>>
>>>> Alex
>>>>
>>>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>>
>>>> But this is only if you publish unsafely, as mentioned before.  If you
>>>> publish this class properly, you don't get races on the volatile.   Final
>>>> fields are supposed to support immutable classes, where although not
>>>> preferrable, publishing racily is plausible (for performance).  For
>>>> read/write volatiles, it's not compelling on the surface.
>>>>
>>>> Sent from my phone
>>>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <
>>>> oleksandr.otenko at oracle.com> wrote:
>>>>
>>>>>  Yes, but I mean that the code assumes the value to always be non-null
>>>>> - eg a sentinel entry of the list is created at construction time. Without
>>>>> the construction-time guarantee you'd need to test for null everywhere.
>>>>>
>>>>> I think the same applies in other constructors - if you write the
>>>>> initialization of the volatile, you imply that's "the least" "possible"
>>>>> value, the value representing the initial state of the concurrent algorithm
>>>>> - the initial value guaranteed by Java spec may not represent any valid
>>>>> state of the concurrent algorithm, let alone the initial state.
>>>>>
>>>>> That's why this really boils down to "find the broad cases where you
>>>>> do want to permit unsafe publication of the initial values of the
>>>>> volatiles".
>>>>>
>>>>>
>>>>> (unlike the non-volatile fields. Don't treat them as "not thread safe"
>>>>> - instead, treat them as "assume as made thread-safe by means outside the
>>>>> class specification", hence no requirement for "safe publication" there)
>>>>>
>>>>>
>>>>> Alex
>>>>>
>>>>>
>>>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>>
>>>>> Initial value of the field must be the "zero" value of that type,
>>>>> that's a language spec and must be guaranteed irrespective of volatile or
>>>>> not.
>>>>>
>>>>> Sent from my phone
>>>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <
>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>
>>>>>>  I understand, but you can't insist on viewing ctors as "just
>>>>>> methods" for all purposes.
>>>>>>
>>>>>> (2) publication is unsafe unless you get a volatile load after the
>>>>>> last volatile store in the constructor. Besides, the initial value of the
>>>>>> field may not even be one of the valid values, so it is not even just about
>>>>>> a data race.
>>>>>>
>>>>>>
>>>>>> Alex
>>>>>>
>>>>>>
>>>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>>
>>>>>> For compilation/codegen purposes ctors *are* just methods - they can
>>>>>> be inlined, code optimized, etc; that's the reason we have the final field
>>>>>> guarantees.
>>>>>>
>>>>>> A couple of potential reasons not to add volatile to the spec:
>>>>>> 1) perhaps some JVMs don't currently already give them final field
>>>>>> semantics
>>>>>> 2) this whole thing comes into play for unsafe publication only (I.e.
>>>>>> data race), which is discouraged.
>>>>>>
>>>>>> Sent from my phone
>>>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <
>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>
>>>>>>>  Constructors *are* special methods. They are the first method
>>>>>>> calls in any history of the object. This means a different treatment of
>>>>>>> volatile accesses to the fields of the instance being created is possible -
>>>>>>> certain barriers can be eliminated, because the loads can be proven to not
>>>>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>>>>> reason to permit subsequent calls to observe the initial state of the
>>>>>>> volatile fields; whereas any volatile load in any other method always
>>>>>>> synchronizes with a volatile store of some other method call, without the
>>>>>>> final field semantics we cannot assume that.
>>>>>>>
>>>>>>> However, if we assume final field semantics, there is only one
>>>>>>> barrier needed - a store-store after the last volatile field store. This
>>>>>>> eliminates all barriers for any other volatile field initialization, and
>>>>>>> eliminates a full barrier needed otherwise (got to place a dummy volatile
>>>>>>> load after the last volatile store to make sure the semantics are stronger
>>>>>>> than final-field) - think of removing a mfence or similar from each such
>>>>>>> constructor on x86.
>>>>>>>
>>>>>>> (there will still be gotchas for cases when volatile field
>>>>>>> initialization occurs after a volatile load of something outside the same
>>>>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>>>>> fields are just initialized into some instance-specific values)
>>>>>>>
>>>>>>>
>>>>>>> Alex
>>>>>>>
>>>>>>>
>>>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>>
>>>>>>> I'm about why "always mean storestore after volatile store in
>>>>>>> constructor". It is not only efficiency which is important for MM, but also
>>>>>>> simplicity and consistency. If constructors are special methods, not just
>>>>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>>>>> if constructors are just plain methods, it looks strange to have special
>>>>>>> implicit semantics for constructors with volatiles inside.
>>>>>>>
>>>>>>>
>>>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>>>>
>>>>>>>>  I think it is pretty simple.
>>>>>>>>
>>>>>>>> If you always mean a store-store barrier *after* the last volatile
>>>>>>>> store in the constructor, then add that barrier into constructor semantics,
>>>>>>>> like it's done with the final fields.
>>>>>>>>
>>>>>>>> It makes sense to *not* add it to the semantics, if you can come
>>>>>>>> up with enough examples where you want that barrier to be eliminated.
>>>>>>>>
>>>>>>>> Alex
>>>>>>>>
>>>>>>>>
>>>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>>>
>>>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>>>>> I mean, I could not see any noticable difference between the case
>>>>>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>>>>> any other object which is unsafely published. I think everybody who passed
>>>>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>>>>> read [.value=0] in the case discussed.
>>>>>>>>
>>>>>>>>  "Data race is pure evil" was the motto of this list all time I
>>>>>>>> was reading it. Why do we may want to introduce another example of benign
>>>>>>>> race? Wouldn't it be just another source of confusion for newcomers?
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>>>>
>>>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>>>>
>>>>>>>>>> Doug, could you explain why it is so important to have this kind
>>>>>>>>>> of safe
>>>>>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>>>>>> through data
>>>>>>>>>> race to be allowed result, as current model (seem to) imply? It
>>>>>>>>>> seems to be a
>>>>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>>  The main reason is that it is highly irregular and unexpected
>>>>>>>>> by programmers. Except in this case, volatiles definitionally
>>>>>>>>> cannot
>>>>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>>>>> correctness on current JVMs. We have several constructions
>>>>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>>>>> candidate for reconsideration.
>>>>>>>>>
>>>>>>>>> -Doug
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>> Ruslan
>>>>>>>>>>
>>>>>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>>> ???????(?):
>>>>>>>>>>>
>>>>>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>>>>>>> optimizations to avoid zeroing memory is an implementation
>>>>>>>>>>>> detail and
>>>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think
>>>>>>>>>>>> you're
>>>>>>>>>>>> saying.
>>>>>>>>>>>>
>>>>>>>>>>>> The other issue is that even if we determine that volatiles
>>>>>>>>>>>> don't get
>>>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going
>>>>>>>>>>>> to be
>>>>>>>>>>>> practical to change it and risk hard to debug problems creeping
>>>>>>>>>>>> in.  May
>>>>>>>>>>>> as well update the spec now ...
>>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> Right. To summarize:
>>>>>>>>>>>
>>>>>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>>>>>> specifically
>>>>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>>>>
>>>>>>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>>>>>>> fields are
>>>>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>>>>
>>>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
>>>>>>>>>>> small tweak
>>>>>>>>>>> that I know applies). But now is a good time to be considering a
>>>>>>>>>>> full
>>>>>>>>>>> revision for JDK9.
>>>>>>>>>>>
>>>>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>>>>> validate JVMs
>>>>>>>>>>> as meeting this likely future spec.
>>>>>>>>>>>
>>>>>>>>>>> -Doug
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> Concurrency-interest
>>>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/e1f2cdce/attachment-0001.html>

From oleksandr.otenko at oracle.com  Tue Dec  3 13:57:00 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 18:57:00 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
References: <5295E24C.40608@oracle.com>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
Message-ID: <529E297C.4070401@oracle.com>

You'd need load-store after loading externally observable values with or 
without the proposed changes, but we aren't eliminating those, are we? I 
thought you meant we need new barriers.

Alex

On 03/12/2013 18:51, Vitaly Davidovich wrote:
>
> You would - since volatile can be modified and read many times in 
> ctor, you need to ensure all loads are done before the store and 
> before ctor exits - you need to ensure value of the volatile is the 
> final one at the end of the ctor sequence. Otherwise, the loads can 
> move after the store.  Basically, you need lazySet() now and not plain 
> storestore.
>
> Sent from my phone
>
> On Dec 3, 2013 1:44 PM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     I don't think you'd need it in a constructor.
>
>     You can't read the fields until the reference to the instance is
>     stored. If you can stop reordering that store with the last
>     volatile store, publication is safe.
>
>     Alex
>
>     On 03/12/2013 18:34, Vitaly Davidovich wrote:
>>
>>     For volatiles, you'd need load-store as well though.
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 1:05 PM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         Sure.
>>
>>         f=42;
>>
>>         already imposes the cost of store-store barrier.
>>
>>         f=42;
>>         f=42;
>>
>>         does the same thing. In a constructor, eliminate the first
>>         barrier, because the order of writes to the unreachable
>>         instance is not important, and the second store. This no
>>         longer is the question of performance, because it is the
>>         same. It is the question of correctness for free.
>>
>>         Alex
>>
>>         On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>>
>>>         Not sure that's the right view either.  The one thing the
>>>         author does not control is how instances of their class are
>>>         passed around.  User of the class has more context - it may
>>>         actually be ok that volatiles aren't fenced here because
>>>         they're already ensuring some way that it's fine, including
>>>         the possibility that the instance isn't even shared at all. 
>>>         As long as people know the behavior of the
>>>         language/platform, they should be expected to make an
>>>         educated decision on their own.
>>>
>>>         Look, if performance didn't matter, you could just blindly
>>>         say that all constructors have a freeze action, regardless
>>>         of final fields or volatile.  That's not the case, of
>>>         course. Java and JDK have tools available to publish safely,
>>>         so people doing multithreading have the ability to do the
>>>         right thing.  At the end of the day, exposing concurrency to
>>>         devs will lead to bugs, even beside the issues described here.
>>>
>>>         Sent from my phone
>>>
>>>         On Dec 3, 2013 12:42 PM, "Oleksandr Otenko"
>>>         <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>
>>>             No, this is a completely opposite view. The question is:
>>>
>>>             do you as the implementor of the concurrent algorithm
>>>             ever intend the constructor design to be such that
>>>             relies on the protocol that the caller chooses to
>>>             publish the reference?
>>>
>>>             (Do you ever intend to /*not*/ specify a no-op volatile
>>>             load after the last volatile store in the constructor?)
>>>
>>>
>>>             Alex
>>>
>>>
>>>             On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>>>
>>>>             I'm confident most code that publishes objects shared
>>>>             across threads does it safely.  Otherwise we're saying
>>>>             majority of code uses data races?
>>>>
>>>>             Sent from my phone
>>>>
>>>>             On Dec 3, 2013 12:21 PM, "Oleksandr Otenko"
>>>>             <oleksandr.otenko at oracle.com
>>>>             <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>
>>>>                 Hmmm.... I thought it is clear no one argues about
>>>>                 the "/*if*/ you publish safely" part. The question
>>>>                 I am wondering about is whether you can find a case
>>>>                 where publishing the reference to the instance
>>>>                 unsafely is /intended/.
>>>>
>>>>                 Alex
>>>>
>>>>                 On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>>>
>>>>>                 But this is only if you publish unsafely, as
>>>>>                 mentioned before.  If you publish this class
>>>>>                 properly, you don't get races on the volatile.  
>>>>>                 Final fields are supposed to support immutable
>>>>>                 classes, where although not preferrable,
>>>>>                 publishing racily is plausible (for performance).
>>>>>                 For read/write volatiles, it's not compelling on
>>>>>                 the surface.
>>>>>
>>>>>                 Sent from my phone
>>>>>
>>>>>                 On Dec 3, 2013 11:18 AM, "Oleksandr Otenko"
>>>>>                 <oleksandr.otenko at oracle.com
>>>>>                 <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>
>>>>>                     Yes, but I mean that the code assumes the
>>>>>                     value to always be non-null - eg a sentinel
>>>>>                     entry of the list is created at construction
>>>>>                     time. Without the construction-time guarantee
>>>>>                     you'd need to test for null everywhere.
>>>>>
>>>>>                     I think the same applies in other constructors
>>>>>                     - if you write the initialization of the
>>>>>                     volatile, you imply that's "the least"
>>>>>                     "possible" value, the value representing the
>>>>>                     initial state of the concurrent algorithm -
>>>>>                     the initial value guaranteed by Java spec may
>>>>>                     not represent any valid state of the
>>>>>                     concurrent algorithm, let alone the initial state.
>>>>>
>>>>>                     That's why this really boils down to "find the
>>>>>                     broad cases where you do want to permit unsafe
>>>>>                     publication of the initial values of the
>>>>>                     volatiles".
>>>>>
>>>>>
>>>>>                     (unlike the non-volatile fields. Don't treat
>>>>>                     them as "not thread safe" - instead, treat
>>>>>                     them as "assume as made thread-safe by means
>>>>>                     outside the class specification", hence no
>>>>>                     requirement for "safe publication" there)
>>>>>
>>>>>
>>>>>                     Alex
>>>>>
>>>>>
>>>>>                     On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>>>
>>>>>>                     Initial value of the field must be the "zero"
>>>>>>                     value of that type, that's a language spec
>>>>>>                     and must be guaranteed irrespective of
>>>>>>                     volatile or not.
>>>>>>
>>>>>>                     Sent from my phone
>>>>>>
>>>>>>                     On Dec 3, 2013 10:03 AM, "Oleksandr Otenko"
>>>>>>                     <oleksandr.otenko at oracle.com
>>>>>>                     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>
>>>>>>                         I understand, but you can't insist on
>>>>>>                         viewing ctors as "just methods" for all
>>>>>>                         purposes.
>>>>>>
>>>>>>                         (2) publication is unsafe unless you get
>>>>>>                         a volatile load after the last volatile
>>>>>>                         store in the constructor. Besides, the
>>>>>>                         initial value of the field may not even
>>>>>>                         be one of the valid values, so it is not
>>>>>>                         even just about a data race.
>>>>>>
>>>>>>
>>>>>>                         Alex
>>>>>>
>>>>>>
>>>>>>                         On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>>>
>>>>>>>                         For compilation/codegen purposes ctors
>>>>>>>                         *are* just methods - they can be
>>>>>>>                         inlined, code optimized, etc; that's the
>>>>>>>                         reason we have the final field guarantees.
>>>>>>>
>>>>>>>                         A couple of potential reasons not to add
>>>>>>>                         volatile to the spec:
>>>>>>>                         1) perhaps some JVMs don't currently
>>>>>>>                         already give them final field semantics
>>>>>>>                         2) this whole thing comes into play for
>>>>>>>                         unsafe publication only (I.e. data
>>>>>>>                         race), which is discouraged.
>>>>>>>
>>>>>>>                         Sent from my phone
>>>>>>>
>>>>>>>                         On Dec 3, 2013 6:51 AM, "Oleksandr
>>>>>>>                         Otenko" <oleksandr.otenko at oracle.com
>>>>>>>                         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>>
>>>>>>>                             Constructors /are/ special methods.
>>>>>>>                             They are the first method calls in
>>>>>>>                             any history of the object. This
>>>>>>>                             means a different treatment of
>>>>>>>                             volatile accesses to the fields of
>>>>>>>                             the instance being created is
>>>>>>>                             possible - certain barriers can be
>>>>>>>                             eliminated, because the loads can be
>>>>>>>                             proven to not synchronize with
>>>>>>>                             anyone. For the sake of the
>>>>>>>                             argument, it is possible to proceed
>>>>>>>                             with weak treatment of volatile
>>>>>>>                             stores, too, but you need a good
>>>>>>>                             reason to permit subsequent calls to
>>>>>>>                             observe the initial state of the
>>>>>>>                             volatile fields; whereas any
>>>>>>>                             volatile load in any other method
>>>>>>>                             always synchronizes with a volatile
>>>>>>>                             store of some other method call,
>>>>>>>                             without the final field semantics we
>>>>>>>                             cannot assume that.
>>>>>>>
>>>>>>>                             However, if we assume final field
>>>>>>>                             semantics, there is only one barrier
>>>>>>>                             needed - a store-store after the
>>>>>>>                             last volatile field store. This
>>>>>>>                             eliminates all barriers for any
>>>>>>>                             other volatile field initialization,
>>>>>>>                             and eliminates a full barrier needed
>>>>>>>                             otherwise (got to place a dummy
>>>>>>>                             volatile load after the last
>>>>>>>                             volatile store to make sure the
>>>>>>>                             semantics are stronger than
>>>>>>>                             final-field) - think of removing a
>>>>>>>                             mfence or similar from each such
>>>>>>>                             constructor on x86.
>>>>>>>
>>>>>>>                             (there will still be gotchas for
>>>>>>>                             cases when volatile field
>>>>>>>                             initialization occurs after a
>>>>>>>                             volatile load of something outside
>>>>>>>                             the same instance; but the main
>>>>>>>                             purpose is to eliminate barriers
>>>>>>>                             when the volatile fields are just
>>>>>>>                             initialized into some
>>>>>>>                             instance-specific values)
>>>>>>>
>>>>>>>
>>>>>>>                             Alex
>>>>>>>
>>>>>>>
>>>>>>>                             On 03/12/2013 05:54, Ruslan Cheremin
>>>>>>>                             wrote:
>>>>>>>>                             I'm about why "always mean
>>>>>>>>                             storestore after volatile store in
>>>>>>>>                             constructor". It is not only
>>>>>>>>                             efficiency which is important for
>>>>>>>>                             MM, but also simplicity and
>>>>>>>>                             consistency. If constructors are
>>>>>>>>                             special methods, not just plain
>>>>>>>>                             <init>, then we should add this
>>>>>>>>                             kind of atomicity to all
>>>>>>>>                             constructors (which, as I was
>>>>>>>>                             reading here, could be inefficient
>>>>>>>>                             on some platforms). But if
>>>>>>>>                             constructors are just plain
>>>>>>>>                             methods, it looks strange to have
>>>>>>>>                             special implicit semantics for
>>>>>>>>                             constructors with volatiles inside.
>>>>>>>>
>>>>>>>>
>>>>>>>>                             2013/12/3 Oleksandr Otenko
>>>>>>>>                             <oleksandr.otenko at oracle.com
>>>>>>>>                             <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>
>>>>>>>>                                 I think it is pretty simple.
>>>>>>>>
>>>>>>>>                                 If you always mean a
>>>>>>>>                                 store-store barrier /after/ the
>>>>>>>>                                 last volatile store in the
>>>>>>>>                                 constructor, then add that
>>>>>>>>                                 barrier into constructor
>>>>>>>>                                 semantics, like it's done with
>>>>>>>>                                 the final fields.
>>>>>>>>
>>>>>>>>                                 It makes sense to /not/ add it
>>>>>>>>                                 to the semantics, if you can
>>>>>>>>                                 come up with enough examples
>>>>>>>>                                 where you want that barrier to
>>>>>>>>                                 be eliminated.
>>>>>>>>
>>>>>>>>                                 Alex
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 On 02/12/2013 19:32, Ruslan
>>>>>>>>                                 Cheremin wrote:
>>>>>>>>>                                 Well, I do not see any data
>>>>>>>>>                                 race _on volatiles_ here. I
>>>>>>>>>                                 see race condition on volatile
>>>>>>>>>                                 .value, yes -- but it is
>>>>>>>>>                                 pretty legal (and unavoidable,
>>>>>>>>>                                 I suppose) to have race
>>>>>>>>>                                 conditions even with volatiles
>>>>>>>>>                                 involved. The only data race I
>>>>>>>>>                                 see is around read-write of
>>>>>>>>>                                 (non-volatile) AtomicInteger's
>>>>>>>>>                                 reference -- which is
>>>>>>>>>                                 unrelated to AtomicInteger's
>>>>>>>>>                                 content. I mean, I could not
>>>>>>>>>                                 see any noticable difference
>>>>>>>>>                                 between the case discussed,
>>>>>>>>>                                 and just any other case there
>>>>>>>>>                                 volatile is _incorrectly_ used
>>>>>>>>>                                 to "synchronize" data accesses
>>>>>>>>>                                 -- it could still be data race
>>>>>>>>>                                 on non-volatile fields, even
>>>>>>>>>                                 if volatile fields are also
>>>>>>>>>                                 used somewhere around. Yes,
>>>>>>>>>                                 get 0 from .value is
>>>>>>>>>                                 unexpected -- but there are
>>>>>>>>>                                 many unexpected things in
>>>>>>>>>                                 memory models. It is noway
>>>>>>>>>                                 more unexpected then to see
>>>>>>>>>                                 default values in fields of
>>>>>>>>>                                 any other object which is
>>>>>>>>>                                 unsafely published. I think
>>>>>>>>>                                 everybody who passed through
>>>>>>>>>                                 broken atomicity of
>>>>>>>>>                                 constructor call could easy
>>>>>>>>>                                 see the chance to read
>>>>>>>>>                                 [.value=0] in the case discussed.
>>>>>>>>>
>>>>>>>>>                                 "Data race is pure evil" was
>>>>>>>>>                                 the motto of this list all
>>>>>>>>>                                 time I was reading it. Why do
>>>>>>>>>                                 we may want to introduce
>>>>>>>>>                                 another example of benign
>>>>>>>>>                                 race? Wouldn't it be just
>>>>>>>>>                                 another source of confusion
>>>>>>>>>                                 for newcomers?
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                 2013/12/2 Doug Lea
>>>>>>>>>                                 <dl at cs.oswego.edu
>>>>>>>>>                                 <mailto:dl at cs.oswego.edu>>
>>>>>>>>>
>>>>>>>>>                                     On 12/02/2013 03:57 AM,
>>>>>>>>>                                     Cheremin Ruslan wrote:
>>>>>>>>>
>>>>>>>>>                                         Doug, could you
>>>>>>>>>                                         explain why it is so
>>>>>>>>>                                         important to have this
>>>>>>>>>                                         kind of safe
>>>>>>>>>                                         publication for
>>>>>>>>>                                         volatile? I mean,
>>>>>>>>>                                         could we just go with
>>>>>>>>>                                         .value=0 through data
>>>>>>>>>                                         race to be allowed
>>>>>>>>>                                         result, as current
>>>>>>>>>                                         model (seem to) imply?
>>>>>>>>>                                         It seems to be a
>>>>>>>>>                                         dr-case anyway, why we
>>>>>>>>>                                         need special handling
>>>>>>>>>                                         of it?
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     The main reason is that it
>>>>>>>>>                                     is highly irregular and
>>>>>>>>>                                     unexpected
>>>>>>>>>                                     by programmers. Except in
>>>>>>>>>                                     this case, volatiles
>>>>>>>>>                                     definitionally cannot
>>>>>>>>>                                     be subject to data races.
>>>>>>>>>                                     Dealing with it requires
>>>>>>>>>                                     cleverness,
>>>>>>>>>                                     complexity, and/or
>>>>>>>>>                                     error-proneness that isn't
>>>>>>>>>                                     even required for
>>>>>>>>>                                     correctness on current
>>>>>>>>>                                     JVMs. We have several
>>>>>>>>>                                     constructions
>>>>>>>>>                                     in j.u.c that work around
>>>>>>>>>                                     problems by using explicit
>>>>>>>>>                                     ordered
>>>>>>>>>                                     writes in constructors,
>>>>>>>>>                                     redundant-looking
>>>>>>>>>                                     null-checks, and so
>>>>>>>>>                                     on. If we are going to
>>>>>>>>>                                     repair the JMM anyway,
>>>>>>>>>                                     this is a clear
>>>>>>>>>                                     candidate for reconsideration.
>>>>>>>>>
>>>>>>>>>                                     -Doug
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                         Ruslan
>>>>>>>>>
>>>>>>>>>                                             27 ????. 2013 ?.,
>>>>>>>>>                                             ? 23:26, Doug Lea
>>>>>>>>>                                             <dl at cs.oswego.edu
>>>>>>>>>                                             <mailto:dl at cs.oswego.edu>>
>>>>>>>>>                                             ???????(?):
>>>>>>>>>
>>>>>>>>>                                                 On 11/27/2013
>>>>>>>>>                                                 02:06 PM,
>>>>>>>>>                                                 Vitaly
>>>>>>>>>                                                 Davidovich
>>>>>>>>>                                                 wrote: But
>>>>>>>>>                                                 either way,
>>>>>>>>>                                                 optimizations
>>>>>>>>>                                                 to avoid
>>>>>>>>>                                                 zeroing memory
>>>>>>>>>                                                 is an
>>>>>>>>>                                                 implementation
>>>>>>>>>                                                 detail and
>>>>>>>>>                                                 thus cannot be
>>>>>>>>>                                                 relied upon
>>>>>>>>>                                                 from JMM
>>>>>>>>>                                                 standpoint,
>>>>>>>>>                                                 which I think
>>>>>>>>>                                                 you're
>>>>>>>>>                                                 saying.
>>>>>>>>>
>>>>>>>>>                                                 The other
>>>>>>>>>                                                 issue is that
>>>>>>>>>                                                 even if we
>>>>>>>>>                                                 determine that
>>>>>>>>>                                                 volatiles
>>>>>>>>>                                                 don't get
>>>>>>>>>                                                 this
>>>>>>>>>                                                 treatment, if
>>>>>>>>>                                                 JVM is already
>>>>>>>>>                                                 ensuring it,
>>>>>>>>>                                                 it's not going
>>>>>>>>>                                                 to be
>>>>>>>>>                                                 practical to
>>>>>>>>>                                                 change it and
>>>>>>>>>                                                 risk hard to
>>>>>>>>>                                                 debug problems
>>>>>>>>>                                                 creeping in.  May
>>>>>>>>>                                                 as well update
>>>>>>>>>                                                 the spec now ...
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                             Right. To summarize:
>>>>>>>>>
>>>>>>>>>                                             * Programmers do
>>>>>>>>>                                             not expect that
>>>>>>>>>                                             even though final
>>>>>>>>>                                             fields are
>>>>>>>>>                                             specifically
>>>>>>>>>                                             publication-safe,
>>>>>>>>>                                             volatile fields
>>>>>>>>>                                             are not always so.
>>>>>>>>>
>>>>>>>>>                                             * For various
>>>>>>>>>                                             implementation
>>>>>>>>>                                             reasons, JVMs
>>>>>>>>>                                             arrange that
>>>>>>>>>                                             volatile fields are
>>>>>>>>>                                             publication safe
>>>>>>>>>                                             anyway, at least
>>>>>>>>>                                             in cases we know
>>>>>>>>>                                             about.
>>>>>>>>>
>>>>>>>>>                                             * Actually
>>>>>>>>>                                             updating the
>>>>>>>>>                                             JMM/JLS to mandate
>>>>>>>>>                                             this is not easy
>>>>>>>>>                                             (no small tweak
>>>>>>>>>                                             that I know
>>>>>>>>>                                             applies). But now
>>>>>>>>>                                             is a good time to
>>>>>>>>>                                             be considering a full
>>>>>>>>>                                             revision for JDK9.
>>>>>>>>>
>>>>>>>>>                                             * In the mean
>>>>>>>>>                                             time, it would
>>>>>>>>>                                             make sense to
>>>>>>>>>                                             further test and
>>>>>>>>>                                             validate JVMs
>>>>>>>>>                                             as meeting this
>>>>>>>>>                                             likely future spec.
>>>>>>>>>
>>>>>>>>>                                             -Doug
>>>>>>>>>
>>>>>>>>>                                             _______________________________________________
>>>>>>>>>                                             Concurrency-interest
>>>>>>>>>                                             mailing list
>>>>>>>>>                                             Concurrency-interest at cs.oswego.edu
>>>>>>>>>                                             <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>                                             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                 _______________________________________________
>>>>>>>>>                                 Concurrency-interest mailing list
>>>>>>>>>                                 Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>                                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 _______________________________________________
>>>>>>>>                                 Concurrency-interest mailing list
>>>>>>>>                                 Concurrency-interest at cs.oswego.edu
>>>>>>>>                                 <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>                                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>                             _______________________________________________
>>>>>>>                             Concurrency-interest mailing list
>>>>>>>                             Concurrency-interest at cs.oswego.edu
>>>>>>>                             <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>                             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>>                     _______________________________________________
>>>>>                     Concurrency-interest mailing list
>>>>>                     Concurrency-interest at cs.oswego.edu
>>>>>                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/270eb85b/attachment-0001.html>

From cheremin at gmail.com  Tue Dec  3 14:15:38 2013
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Tue, 3 Dec 2013 23:15:38 +0400
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CACuKZqFkVt30s7skdT62VKVidhS7j6-pdgU8WpMzATFy6cAokw@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAOwENi+7ROc+bQ1b5yPdYzBR6a9gNLBKyQV2MwYBvpnrsbe24g@mail.gmail.com>
	<CACuKZqGUXoxGTfLvNwEnzxOwKyiSSXeAwqqQ4xQLttCdTJL9xw@mail.gmail.com>
	<CAOwENiJVDXHkbLDLDpnOnYRBedFYxdOgujFef1PywaFSGtp=Qg@mail.gmail.com>
	<CACuKZqFkVt30s7skdT62VKVidhS7j6-pdgU8WpMzATFy6cAokw@mail.gmail.com>
Message-ID: <CAOwENiJzXe8vWZPZbkX6iFSqA+ywVzbn70BpqjuOR0QSoeXzWQ@mail.gmail.com>

>From my point of view, immutability without consistent view from all
threads is much less usable. It is concurrency there unexpected state
transitions become real pain. And you could bypass the overkill -- just not
use final but incapsulation to provide read-only view of object -- final is
for something you can't reach by incapslation and you need language support
for it.


2013/12/3 Zhong Yu <zhong.j.yu at gmail.com>

> I understanding of the word "immutability", when it's used in the wild
> by java programmers, is that it does not simply mean that fields
> cannot be written outside constructors; actually it means something
> much stronger, which is all threads much observe the same state of an
> object, not matter what.
>
> Such strong requirement is apparently an overkill for most classes.
> Unfortunately it seems to be the mainstream belief in java community.
>
>
>
>
> On Tue, Dec 3, 2013 at 12:21 PM, Ruslan Cheremin <cheremin at gmail.com>
> wrote:
> > But immutability is good not because it is thread-safe, but because it is
> > immutability -- no state, no transitions, you know, like you're in Eden,
> or
> > in Clojure :) Thread safety is just one of consequences of having no
> state,
> > and special semantics for final fields in java just stamp this expectable
> > property. Making ctors "atomic" not supply you with even 1% of what
> > immutability gives. But (I'm afraid, but not sure) it requires
> complexity in
> > formal model comparable with final fields definition. What is why I do
> not
> > think it worth it. If it could be injected simply and naturally, without
> > another "HB which is not transitive with ordinary HB, and not transitive
> > with final-fields-HB..." -- may be it worth it.
> >
> >
> > 2013/12/3 Zhong Yu <zhong.j.yu at gmail.com>
> >>
> >> Note that majority of Java programmers are taught that immutability is
> >> a good thing, that they should mark all fields as final whenever
> >> possible. If that teaching is correct, obviously the language would be
> >> even better if it extends final field semantics to all fields. If that
> >> teaching is incorrect, Joshua Bloch should recall his books:)
> >>
> >> On Tue, Dec 3, 2013 at 11:56 AM, Ruslan Cheremin <cheremin at gmail.com>
> >> wrote:
> >> > I may ask you the complimentary question: do you want publication via
> >> > data
> >> > race to be widely adopted since ctors are safe against it? Do you
> really
> >> > hope such practice would not go farther only publication, and would
> not
> >> > lead
> >> > to assumption "data race is generally not dangerous"?
> >> >
> >> >
> >> > As about ctors: I bet if you ask 100 java programmers about the
> >> > difference
> >> > between
> >> >   sharedRef = new A();
> >> >   sharedRef.init(42);
> >> > and
> >> >   sharedRef = new A(42);
> >> >
> >> > 90 of them say second is just shortcut for first.
> >> >
> >> >
> >> >
> >> > 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
> >> >>
> >> >> No, this is a completely opposite view. The question is:
> >> >>
> >> >> do you as the implementor of the concurrent algorithm ever intend the
> >> >> constructor design to be such that relies on the protocol that the
> >> >> caller
> >> >> chooses to publish the reference?
> >> >>
> >> >> (Do you ever intend to not specify a no-op volatile load after the
> last
> >> >> volatile store in the constructor?)
> >> >>
> >> >>
> >> >> Alex
> >> >>
> >> >>
> >> >>
> >> >> On 03/12/2013 17:23, Vitaly Davidovich wrote:
> >> >>
> >> >> I'm confident most code that publishes objects shared across threads
> >> >> does
> >> >> it safely.  Otherwise we're saying majority of code uses data races?
> >> >>
> >> >> Sent from my phone
> >> >>
> >> >> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko"
> >> >> <oleksandr.otenko at oracle.com>
> >> >> wrote:
> >> >>>
> >> >>> Hmmm.... I thought it is clear no one argues about the "if you
> publish
> >> >>> safely" part. The question I am wondering about is whether you can
> >> >>> find a
> >> >>> case where publishing the reference to the instance unsafely is
> >> >>> intended.
> >> >>>
> >> >>> Alex
> >> >>>
> >> >>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
> >> >>>
> >> >>> But this is only if you publish unsafely, as mentioned before.  If
> you
> >> >>> publish this class properly, you don't get races on the volatile.
> >> >>> Final
> >> >>> fields are supposed to support immutable classes, where although not
> >> >>> preferrable, publishing racily is plausible (for performance).  For
> >> >>> read/write volatiles, it's not compelling on the surface.
> >> >>>
> >> >>> Sent from my phone
> >> >>>
> >> >>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko"
> >> >>> <oleksandr.otenko at oracle.com>
> >> >>> wrote:
> >> >>>>
> >> >>>> Yes, but I mean that the code assumes the value to always be
> non-null
> >> >>>> -
> >> >>>> eg a sentinel entry of the list is created at construction time.
> >> >>>> Without the
> >> >>>> construction-time guarantee you'd need to test for null everywhere.
> >> >>>>
> >> >>>> I think the same applies in other constructors - if you write the
> >> >>>> initialization of the volatile, you imply that's "the least"
> >> >>>> "possible"
> >> >>>> value, the value representing the initial state of the concurrent
> >> >>>> algorithm
> >> >>>> - the initial value guaranteed by Java spec may not represent any
> >> >>>> valid
> >> >>>> state of the concurrent algorithm, let alone the initial state.
> >> >>>>
> >> >>>> That's why this really boils down to "find the broad cases where
> you
> >> >>>> do
> >> >>>> want to permit unsafe publication of the initial values of the
> >> >>>> volatiles".
> >> >>>>
> >> >>>>
> >> >>>> (unlike the non-volatile fields. Don't treat them as "not thread
> >> >>>> safe" -
> >> >>>> instead, treat them as "assume as made thread-safe by means outside
> >> >>>> the
> >> >>>> class specification", hence no requirement for "safe publication"
> >> >>>> there)
> >> >>>>
> >> >>>>
> >> >>>> Alex
> >> >>>>
> >> >>>>
> >> >>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
> >> >>>>
> >> >>>> Initial value of the field must be the "zero" value of that type,
> >> >>>> that's
> >> >>>> a language spec and must be guaranteed irrespective of volatile or
> >> >>>> not.
> >> >>>>
> >> >>>> Sent from my phone
> >> >>>>
> >> >>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko"
> >> >>>> <oleksandr.otenko at oracle.com> wrote:
> >> >>>>>
> >> >>>>> I understand, but you can't insist on viewing ctors as "just
> >> >>>>> methods"
> >> >>>>> for all purposes.
> >> >>>>>
> >> >>>>> (2) publication is unsafe unless you get a volatile load after the
> >> >>>>> last
> >> >>>>> volatile store in the constructor. Besides, the initial value of
> the
> >> >>>>> field
> >> >>>>> may not even be one of the valid values, so it is not even just
> >> >>>>> about a data
> >> >>>>> race.
> >> >>>>>
> >> >>>>>
> >> >>>>> Alex
> >> >>>>>
> >> >>>>>
> >> >>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
> >> >>>>>
> >> >>>>> For compilation/codegen purposes ctors *are* just methods - they
> can
> >> >>>>> be
> >> >>>>> inlined, code optimized, etc; that's the reason we have the final
> >> >>>>> field
> >> >>>>> guarantees.
> >> >>>>>
> >> >>>>> A couple of potential reasons not to add volatile to the spec:
> >> >>>>> 1) perhaps some JVMs don't currently already give them final field
> >> >>>>> semantics
> >> >>>>> 2) this whole thing comes into play for unsafe publication only
> >> >>>>> (I.e.
> >> >>>>> data race), which is discouraged.
> >> >>>>>
> >> >>>>> Sent from my phone
> >> >>>>>
> >> >>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko"
> >> >>>>> <oleksandr.otenko at oracle.com> wrote:
> >> >>>>>>
> >> >>>>>> Constructors are special methods. They are the first method calls
> >> >>>>>> in
> >> >>>>>> any history of the object. This means a different treatment of
> >> >>>>>> volatile
> >> >>>>>> accesses to the fields of the instance being created is possible
> -
> >> >>>>>> certain
> >> >>>>>> barriers can be eliminated, because the loads can be proven to
> not
> >> >>>>>> synchronize with anyone. For the sake of the argument, it is
> >> >>>>>> possible to
> >> >>>>>> proceed with weak treatment of volatile stores, too, but you
> need a
> >> >>>>>> good
> >> >>>>>> reason to permit subsequent calls to observe the initial state of
> >> >>>>>> the
> >> >>>>>> volatile fields; whereas any volatile load in any other method
> >> >>>>>> always
> >> >>>>>> synchronizes with a volatile store of some other method call,
> >> >>>>>> without the
> >> >>>>>> final field semantics we cannot assume that.
> >> >>>>>>
> >> >>>>>> However, if we assume final field semantics, there is only one
> >> >>>>>> barrier
> >> >>>>>> needed - a store-store after the last volatile field store. This
> >> >>>>>> eliminates
> >> >>>>>> all barriers for any other volatile field initialization, and
> >> >>>>>> eliminates a
> >> >>>>>> full barrier needed otherwise (got to place a dummy volatile load
> >> >>>>>> after the
> >> >>>>>> last volatile store to make sure the semantics are stronger than
> >> >>>>>> final-field) - think of removing a mfence or similar from each
> such
> >> >>>>>> constructor on x86.
> >> >>>>>>
> >> >>>>>> (there will still be gotchas for cases when volatile field
> >> >>>>>> initialization occurs after a volatile load of something outside
> >> >>>>>> the same
> >> >>>>>> instance; but the main purpose is to eliminate barriers when the
> >> >>>>>> volatile
> >> >>>>>> fields are just initialized into some instance-specific values)
> >> >>>>>>
> >> >>>>>>
> >> >>>>>> Alex
> >> >>>>>>
> >> >>>>>>
> >> >>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
> >> >>>>>>
> >> >>>>>> I'm about why "always mean storestore after volatile store in
> >> >>>>>> constructor". It is not only efficiency which is important for
> MM,
> >> >>>>>> but also
> >> >>>>>> simplicity and consistency. If constructors are special methods,
> >> >>>>>> not just
> >> >>>>>> plain <init>, then we should add this kind of atomicity to all
> >> >>>>>> constructors
> >> >>>>>> (which, as I was reading here, could be inefficient on some
> >> >>>>>> platforms). But
> >> >>>>>> if constructors are just plain methods, it looks strange to have
> >> >>>>>> special
> >> >>>>>> implicit semantics for constructors with volatiles inside.
> >> >>>>>>
> >> >>>>>>
> >> >>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
> >> >>>>>>>
> >> >>>>>>> I think it is pretty simple.
> >> >>>>>>>
> >> >>>>>>> If you always mean a store-store barrier after the last volatile
> >> >>>>>>> store in the constructor, then add that barrier into constructor
> >> >>>>>>> semantics,
> >> >>>>>>> like it's done with the final fields.
> >> >>>>>>>
> >> >>>>>>> It makes sense to not add it to the semantics, if you can come
> up
> >> >>>>>>> with enough examples where you want that barrier to be
> eliminated.
> >> >>>>>>>
> >> >>>>>>> Alex
> >> >>>>>>>
> >> >>>>>>>
> >> >>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
> >> >>>>>>>
> >> >>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
> >> >>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
> >> >>>>>>> unavoidable, I suppose) to have race conditions even with
> >> >>>>>>> volatiles
> >> >>>>>>> involved. The only data race I see is around read-write of
> >> >>>>>>> (non-volatile)
> >> >>>>>>> AtomicInteger's reference -- which is unrelated to
> AtomicInteger's
> >> >>>>>>> content.
> >> >>>>>>> I mean, I could not see any noticable difference between the
> case
> >> >>>>>>> discussed,
> >> >>>>>>> and just any other case there volatile is _incorrectly_ used to
> >> >>>>>>> "synchronize" data accesses -- it could still be data race on
> >> >>>>>>> non-volatile
> >> >>>>>>> fields, even if volatile fields are also used somewhere around.
> >> >>>>>>> Yes, get 0
> >> >>>>>>> from .value is unexpected -- but there are many unexpected
> things
> >> >>>>>>> in memory
> >> >>>>>>> models. It is noway more unexpected then to see default values
> in
> >> >>>>>>> fields of
> >> >>>>>>> any other object which is unsafely published. I think everybody
> >> >>>>>>> who passed
> >> >>>>>>> through broken atomicity of constructor call could easy see the
> >> >>>>>>> chance to
> >> >>>>>>> read [.value=0] in the case discussed.
> >> >>>>>>>
> >> >>>>>>> "Data race is pure evil" was the motto of this list all time I
> was
> >> >>>>>>> reading it. Why do we may want to introduce another example of
> >> >>>>>>> benign race?
> >> >>>>>>> Wouldn't it be just another source of confusion for newcomers?
> >> >>>>>>>
> >> >>>>>>>
> >> >>>>>>>
> >> >>>>>>>
> >> >>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
> >> >>>>>>>>
> >> >>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
> >> >>>>>>>>>
> >> >>>>>>>>> Doug, could you explain why it is so important to have this
> kind
> >> >>>>>>>>> of
> >> >>>>>>>>> safe
> >> >>>>>>>>> publication for volatile? I mean, could we just go with
> .value=0
> >> >>>>>>>>> through data
> >> >>>>>>>>> race to be allowed result, as current model (seem to) imply?
> It
> >> >>>>>>>>> seems to be a
> >> >>>>>>>>> dr-case anyway, why we need special handling of it?
> >> >>>>>>>>
> >> >>>>>>>>
> >> >>>>>>>> The main reason is that it is highly irregular and unexpected
> >> >>>>>>>> by programmers. Except in this case, volatiles definitionally
> >> >>>>>>>> cannot
> >> >>>>>>>> be subject to data races. Dealing with it requires cleverness,
> >> >>>>>>>> complexity, and/or error-proneness that isn't even required for
> >> >>>>>>>> correctness on current JVMs. We have several constructions
> >> >>>>>>>> in j.u.c that work around problems by using explicit ordered
> >> >>>>>>>> writes in constructors, redundant-looking null-checks, and so
> >> >>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
> >> >>>>>>>> candidate for reconsideration.
> >> >>>>>>>>
> >> >>>>>>>> -Doug
> >> >>>>>>>>
> >> >>>>>>>>
> >> >>>>>>>>
> >> >>>>>>>>>
> >> >>>>>>>>> Ruslan
> >> >>>>>>>>>
> >> >>>>>>>>>> 27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu>
> >> >>>>>>>>>> ???????(?):
> >> >>>>>>>>>>
> >> >>>>>>>>>>> On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either
> >> >>>>>>>>>>> way,
> >> >>>>>>>>>>> optimizations to avoid zeroing memory is an implementation
> >> >>>>>>>>>>> detail
> >> >>>>>>>>>>> and
> >> >>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I
> think
> >> >>>>>>>>>>> you're
> >> >>>>>>>>>>> saying.
> >> >>>>>>>>>>>
> >> >>>>>>>>>>> The other issue is that even if we determine that volatiles
> >> >>>>>>>>>>> don't
> >> >>>>>>>>>>> get
> >> >>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not
> going
> >> >>>>>>>>>>> to
> >> >>>>>>>>>>> be
> >> >>>>>>>>>>> practical to change it and risk hard to debug problems
> >> >>>>>>>>>>> creeping
> >> >>>>>>>>>>> in.  May
> >> >>>>>>>>>>> as well update the spec now ...
> >> >>>>>>>>>>
> >> >>>>>>>>>>
> >> >>>>>>>>>> Right. To summarize:
> >> >>>>>>>>>>
> >> >>>>>>>>>> * Programmers do not expect that even though final fields are
> >> >>>>>>>>>> specifically
> >> >>>>>>>>>> publication-safe, volatile fields are not always so.
> >> >>>>>>>>>>
> >> >>>>>>>>>> * For various implementation reasons, JVMs arrange that
> >> >>>>>>>>>> volatile
> >> >>>>>>>>>> fields are
> >> >>>>>>>>>> publication safe anyway, at least in cases we know about.
> >> >>>>>>>>>>
> >> >>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy
> (no
> >> >>>>>>>>>> small tweak
> >> >>>>>>>>>> that I know applies). But now is a good time to be
> considering
> >> >>>>>>>>>> a
> >> >>>>>>>>>> full
> >> >>>>>>>>>> revision for JDK9.
> >> >>>>>>>>>>
> >> >>>>>>>>>> * In the mean time, it would make sense to further test and
> >> >>>>>>>>>> validate JVMs
> >> >>>>>>>>>> as meeting this likely future spec.
> >> >>>>>>>>>>
> >> >>>>>>>>>> -Doug
> >> >>>>>>>>>>
> >> >>>>>>>>>> _______________________________________________
> >> >>>>>>>>>> Concurrency-interest
> >> >>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
> >> >>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>>>>>>>>
> >> >>>>>>>>>
> >> >>>>>>>>
> >> >>>>>>>>
> >> >>>>>>>
> >> >>>>>>>
> >> >>>>>>>
> >> >>>>>>> _______________________________________________
> >> >>>>>>> Concurrency-interest mailing list
> >> >>>>>>> Concurrency-interest at cs.oswego.edu
> >> >>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>>>>>>
> >> >>>>>>>
> >> >>>>>>>
> >> >>>>>>> _______________________________________________
> >> >>>>>>> Concurrency-interest mailing list
> >> >>>>>>> Concurrency-interest at cs.oswego.edu
> >> >>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>>>>>>
> >> >>>>>>
> >> >>>>>>
> >> >>>>>>
> >> >>>>>> _______________________________________________
> >> >>>>>> Concurrency-interest mailing list
> >> >>>>>> Concurrency-interest at cs.oswego.edu
> >> >>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>>>>>
> >> >>>>>
> >> >>>>
> >> >>>>
> >> >>>> _______________________________________________
> >> >>>> Concurrency-interest mailing list
> >> >>>> Concurrency-interest at cs.oswego.edu
> >> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>>>
> >> >>>
> >> >>
> >> >>
> >> >> _______________________________________________
> >> >> Concurrency-interest mailing list
> >> >> Concurrency-interest at cs.oswego.edu
> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>
> >> >
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/cc0fb347/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  3 14:21:30 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 14:21:30 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E297C.4070401@oracle.com>
References: <5295E24C.40608@oracle.com>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
	<529E297C.4070401@oracle.com>
Message-ID: <CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>

So to play devil's advocate, why not make all ctors behave the same way?
Afterall, people may still publish classes with no final or volatile fields
unsafely, and run into problems.  One can argue that most people expect
that upon constructor exit, all memory ops are complete.  Why only add
volatile to the mix? So that concurrency authors can attempt at
safeguarding their class from unsafe publication by a user who doesn't know
any better? Is that really worth the overhead required? Said user can still
shoot themselves in other ways.  At some point, the burden should be on
devs to know the platform, its promises/guarantees, and available tools to
add their own extra guarantees.

Again, we're talking about data race publishing here - this is not the norm
or encouraged practice.  Why bend over backwards to accommodate it?

Sent from my phone
On Dec 3, 2013 1:57 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  You'd need load-store after loading externally observable values with or
> without the proposed changes, but we aren't eliminating those, are we? I
> thought you meant we need new barriers.
>
> Alex
>
> On 03/12/2013 18:51, Vitaly Davidovich wrote:
>
> You would - since volatile can be modified and read many times in ctor,
> you need to ensure all loads are done before the store and before ctor
> exits - you need to ensure value of the volatile is the final one at the
> end of the ctor sequence.  Otherwise, the loads can move after the store.
> Basically, you need lazySet() now and not plain storestore.
>
> Sent from my phone
> On Dec 3, 2013 1:44 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  I don't think you'd need it in a constructor.
>>
>> You can't read the fields until the reference to the instance is stored.
>> If you can stop reordering that store with the last volatile store,
>> publication is safe.
>>
>> Alex
>>
>> On 03/12/2013 18:34, Vitaly Davidovich wrote:
>>
>> For volatiles, you'd need load-store as well though.
>>
>> Sent from my phone
>> On Dec 3, 2013 1:05 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  Sure.
>>>
>>> f=42;
>>>
>>> already imposes the cost of store-store barrier.
>>>
>>> f=42;
>>> f=42;
>>>
>>> does the same thing. In a constructor, eliminate the first barrier,
>>> because the order of writes to the unreachable instance is not important,
>>> and the second store. This no longer is the question of performance,
>>> because it is the same. It is the question of correctness for free.
>>>
>>> Alex
>>>
>>> On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>>
>>> Not sure that's the right view either.  The one thing the author does
>>> not control is how instances of their class are passed around.  User of the
>>> class has more context - it may actually be ok that volatiles aren't fenced
>>> here because they're already ensuring some way that it's fine, including
>>> the possibility that the instance isn't even shared at all.  As long as
>>> people know the behavior of the language/platform, they should be expected
>>> to make an educated decision on their own.
>>>
>>> Look, if performance didn't matter, you could just blindly say that all
>>> constructors have a freeze action, regardless of final fields or volatile.
>>> That's not the case, of course.  Java and JDK have tools available to
>>> publish safely, so people doing multithreading have the ability to do the
>>> right thing.  At the end of the day, exposing concurrency to devs will lead
>>> to bugs, even beside the issues described here.
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 12:42 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>
>>>>  No, this is a completely opposite view. The question is:
>>>>
>>>> do you as the implementor of the concurrent algorithm ever intend the
>>>> constructor design to be such that relies on the protocol that the caller
>>>> chooses to publish the reference?
>>>>
>>>> (Do you ever intend to *not* specify a no-op volatile load after the
>>>> last volatile store in the constructor?)
>>>>
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>>>
>>>> I'm confident most code that publishes objects shared across threads
>>>> does it safely.  Otherwise we're saying majority of code uses data races?
>>>>
>>>> Sent from my phone
>>>> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <
>>>> oleksandr.otenko at oracle.com> wrote:
>>>>
>>>>>  Hmmm.... I thought it is clear no one argues about the "*if* you
>>>>> publish safely" part. The question I am wondering about is whether you can
>>>>> find a case where publishing the reference to the instance unsafely is
>>>>> *intended*.
>>>>>
>>>>> Alex
>>>>>
>>>>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>>>
>>>>> But this is only if you publish unsafely, as mentioned before.  If you
>>>>> publish this class properly, you don't get races on the volatile.   Final
>>>>> fields are supposed to support immutable classes, where although not
>>>>> preferrable, publishing racily is plausible (for performance).  For
>>>>> read/write volatiles, it's not compelling on the surface.
>>>>>
>>>>> Sent from my phone
>>>>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <
>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>
>>>>>>  Yes, but I mean that the code assumes the value to always be
>>>>>> non-null - eg a sentinel entry of the list is created at construction time.
>>>>>> Without the construction-time guarantee you'd need to test for null
>>>>>> everywhere.
>>>>>>
>>>>>> I think the same applies in other constructors - if you write the
>>>>>> initialization of the volatile, you imply that's "the least" "possible"
>>>>>> value, the value representing the initial state of the concurrent algorithm
>>>>>> - the initial value guaranteed by Java spec may not represent any valid
>>>>>> state of the concurrent algorithm, let alone the initial state.
>>>>>>
>>>>>> That's why this really boils down to "find the broad cases where you
>>>>>> do want to permit unsafe publication of the initial values of the
>>>>>> volatiles".
>>>>>>
>>>>>>
>>>>>> (unlike the non-volatile fields. Don't treat them as "not thread
>>>>>> safe" - instead, treat them as "assume as made thread-safe by means outside
>>>>>> the class specification", hence no requirement for "safe publication" there)
>>>>>>
>>>>>>
>>>>>> Alex
>>>>>>
>>>>>>
>>>>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>>>
>>>>>> Initial value of the field must be the "zero" value of that type,
>>>>>> that's a language spec and must be guaranteed irrespective of volatile or
>>>>>> not.
>>>>>>
>>>>>> Sent from my phone
>>>>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <
>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>
>>>>>>>  I understand, but you can't insist on viewing ctors as "just
>>>>>>> methods" for all purposes.
>>>>>>>
>>>>>>> (2) publication is unsafe unless you get a volatile load after the
>>>>>>> last volatile store in the constructor. Besides, the initial value of the
>>>>>>> field may not even be one of the valid values, so it is not even just about
>>>>>>> a data race.
>>>>>>>
>>>>>>>
>>>>>>> Alex
>>>>>>>
>>>>>>>
>>>>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>>>
>>>>>>> For compilation/codegen purposes ctors *are* just methods - they can
>>>>>>> be inlined, code optimized, etc; that's the reason we have the final field
>>>>>>> guarantees.
>>>>>>>
>>>>>>> A couple of potential reasons not to add volatile to the spec:
>>>>>>> 1) perhaps some JVMs don't currently already give them final field
>>>>>>> semantics
>>>>>>> 2) this whole thing comes into play for unsafe publication only
>>>>>>> (I.e. data race), which is discouraged.
>>>>>>>
>>>>>>> Sent from my phone
>>>>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <
>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>
>>>>>>>>  Constructors *are* special methods. They are the first method
>>>>>>>> calls in any history of the object. This means a different treatment of
>>>>>>>> volatile accesses to the fields of the instance being created is possible -
>>>>>>>> certain barriers can be eliminated, because the loads can be proven to not
>>>>>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>>>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>>>>>> reason to permit subsequent calls to observe the initial state of the
>>>>>>>> volatile fields; whereas any volatile load in any other method always
>>>>>>>> synchronizes with a volatile store of some other method call, without the
>>>>>>>> final field semantics we cannot assume that.
>>>>>>>>
>>>>>>>> However, if we assume final field semantics, there is only one
>>>>>>>> barrier needed - a store-store after the last volatile field store. This
>>>>>>>> eliminates all barriers for any other volatile field initialization, and
>>>>>>>> eliminates a full barrier needed otherwise (got to place a dummy volatile
>>>>>>>> load after the last volatile store to make sure the semantics are stronger
>>>>>>>> than final-field) - think of removing a mfence or similar from each such
>>>>>>>> constructor on x86.
>>>>>>>>
>>>>>>>> (there will still be gotchas for cases when volatile field
>>>>>>>> initialization occurs after a volatile load of something outside the same
>>>>>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>>>>>> fields are just initialized into some instance-specific values)
>>>>>>>>
>>>>>>>>
>>>>>>>> Alex
>>>>>>>>
>>>>>>>>
>>>>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>>>
>>>>>>>> I'm about why "always mean storestore after volatile store in
>>>>>>>> constructor". It is not only efficiency which is important for MM, but also
>>>>>>>> simplicity and consistency. If constructors are special methods, not just
>>>>>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>>>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>>>>>> if constructors are just plain methods, it looks strange to have special
>>>>>>>> implicit semantics for constructors with volatiles inside.
>>>>>>>>
>>>>>>>>
>>>>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>>>>>
>>>>>>>>>  I think it is pretty simple.
>>>>>>>>>
>>>>>>>>> If you always mean a store-store barrier *after* the last
>>>>>>>>> volatile store in the constructor, then add that barrier into constructor
>>>>>>>>> semantics, like it's done with the final fields.
>>>>>>>>>
>>>>>>>>> It makes sense to *not* add it to the semantics, if you can come
>>>>>>>>> up with enough examples where you want that barrier to be eliminated.
>>>>>>>>>
>>>>>>>>> Alex
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>>>>
>>>>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>>>>>> I mean, I could not see any noticable difference between the case
>>>>>>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>>>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>>>>>> any other object which is unsafely published. I think everybody who passed
>>>>>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>>>>>> read [.value=0] in the case discussed.
>>>>>>>>>
>>>>>>>>>  "Data race is pure evil" was the motto of this list all time I
>>>>>>>>> was reading it. Why do we may want to introduce another example of benign
>>>>>>>>> race? Wouldn't it be just another source of confusion for newcomers?
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>
>>>>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>>>>>
>>>>>>>>>>> Doug, could you explain why it is so important to have this kind
>>>>>>>>>>> of safe
>>>>>>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>>>>>>> through data
>>>>>>>>>>> race to be allowed result, as current model (seem to) imply? It
>>>>>>>>>>> seems to be a
>>>>>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>  The main reason is that it is highly irregular and unexpected
>>>>>>>>>> by programmers. Except in this case, volatiles definitionally
>>>>>>>>>> cannot
>>>>>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>>>>>> correctness on current JVMs. We have several constructions
>>>>>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>>>>>> candidate for reconsideration.
>>>>>>>>>>
>>>>>>>>>> -Doug
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>> Ruslan
>>>>>>>>>>>
>>>>>>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>>>> ???????(?):
>>>>>>>>>>>>
>>>>>>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either
>>>>>>>>>>>>> way,
>>>>>>>>>>>>> optimizations to avoid zeroing memory is an implementation
>>>>>>>>>>>>> detail and
>>>>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think
>>>>>>>>>>>>> you're
>>>>>>>>>>>>> saying.
>>>>>>>>>>>>>
>>>>>>>>>>>>> The other issue is that even if we determine that volatiles
>>>>>>>>>>>>> don't get
>>>>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going
>>>>>>>>>>>>> to be
>>>>>>>>>>>>> practical to change it and risk hard to debug problems
>>>>>>>>>>>>> creeping in.  May
>>>>>>>>>>>>> as well update the spec now ...
>>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> Right. To summarize:
>>>>>>>>>>>>
>>>>>>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>>>>>>> specifically
>>>>>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>>>>>
>>>>>>>>>>>> * For various implementation reasons, JVMs arrange that
>>>>>>>>>>>> volatile fields are
>>>>>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>>>>>
>>>>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no
>>>>>>>>>>>> small tweak
>>>>>>>>>>>> that I know applies). But now is a good time to be considering
>>>>>>>>>>>> a full
>>>>>>>>>>>> revision for JDK9.
>>>>>>>>>>>>
>>>>>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>>>>>> validate JVMs
>>>>>>>>>>>> as meeting this likely future spec.
>>>>>>>>>>>>
>>>>>>>>>>>> -Doug
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> Concurrency-interest
>>>>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/79fb6993/attachment-0001.html>

From nathan.reynolds at oracle.com  Tue Dec  3 14:31:54 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 03 Dec 2013 12:31:54 -0700
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CACuKZqF4xOEeDBz9_tqD+1X3J1pOny3Kn2a21KsX+z_F9-XC4w@mail.gmail.com>
References: <5295E24C.40608@oracle.com>	<5295EFFA.5090701@oracle.com>	<5295F85A.40500@cs.oswego.edu>	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>	<52963CEB.5070703@cs.oswego.edu>	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>	<52964752.3020104@cs.oswego.edu>	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>	<529C68C1.2040100@cs.oswego.edu>	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>	<529CEAC4.7080409@oracle.com>	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>	<529DC489.2070205@oracle.com>	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>	<529DF29E.6070702@oracle.com>	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>	<529E011F.6060902@oracle.com>
	<CACuKZqF4xOEeDBz9_tqD+1X3J1pOny3Kn2a21KsX+z_F9-XC4w@mail.gmail.com>
Message-ID: <529E31AA.20503@oracle.com>

JRockit will elide the first write if it can prove that the second write 
will happen in the constructor before the "this" pointer is leaked.  I 
don't know if HotSpot does this.

-Nathan

On 12/3/2013 10:53 AM, Zhong Yu wrote:
> I think Nathan's explanation is right on. It's just programmer's
> intuition that initialization code should happen before all other
> accesses to the object.
>
> Some programmers also have the habit of explicit zeroing fields:
>
>      class Foo
>          int x = 0;
>
> not realizing that there are two writes here, and the 2nd write could
> be reordered to a later time which interferes with other reads/writes
> and causes bugs (at least in theory). This is just too surprising.
>
> Zhong Yu
>
>
> On Tue, Dec 3, 2013 at 10:04 AM, Nathan Reynolds
> <nathan.reynolds at oracle.com> wrote:
>> Yes, the initial value of the field must be zero/null.  However, this could
>> be a violation of the semantics of the class.
>>
>> Take for instance a field which is an enum.  The field will be initialized
>> to null, but this could be a violation of the semantics of how the field is
>> used.  The field could be required to be one of the enum values.  Anything
>> unexpected and the rest of the class's code can't handle the situation.
>>
>> The constructor can be viewed as taking a raw uninitialized instance and
>> preparing it to take a state that is expected and valid.  Even if the fields
>> are zero/null, this is not an initialized state with respect to the class.
>> The state transition from invalid to valid can be very risky from a
>> concurrency perspective and in some cases can only be done by a single
>> thread.  Some constructors need the guarantee that only a single-thread is
>> executing on the object at the time.  Many other constructors don't care
>> since synchronization, if needed at all, must be taken care of outside of
>> the class.
>>
>> Consider ConcurrentLinkedList which sets up the head and tail fields in the
>> constructor.  These fields are volatiles.  Initially these fields are set to
>> null.  The constructor transitions the instance from an illegal state (i.e.
>> zero/null) into an expected state using multiple steps.  The constructor
>> must do this without any other methods being invoked on the instance by
>> other threads.  In this case, we could add logic to the rest of the methods
>> in ConcurrentLinkedList which would detect a partially constructed object
>> and then deal with it.  It would make the code very difficult, very error
>> prone and less performant.  In other cases, it would be difficult to detect
>> a partially constructed object and perhaps impossible for multiple threads
>> to concurrently bring the object into a valid state.
>>
>> We need to a way for the code to state if the constructor requires
>> single-threaded access.  Final field semantics is one way.  The question of
>> this email is if volatile stores should be a way that tells the compiler
>> that this constructor requires single-threaded access to the object.
>>
>> My position is yes.  There are cases where there are no final fields
>> naturally occurring in the class yet there are plenty of volatile variables.
>> This requires the programmer to introduce one which wastes space.  There are
>> cases where there are no final or volatile fields naturally occurring in the
>> class.  Yet, the rest of the methods are synchronized and need the
>> constructor to have single-threaded access.
>>
>> On the other hand, having final field (and potentially volatile stores)
>> force the compiler to guarantee single-threaded access to the object is very
>> subtle.  It would be better if the guarantee was more explicit in the code
>> (e.g. adding the synchronized keyword to the constructor).
>>
>> -Nathan
>>
>> On 12/3/2013 8:08 AM, Vitaly Davidovich wrote:
>>
>> Initial value of the field must be the "zero" value of that type, that's a
>> language spec and must be guaranteed irrespective of volatile or not.
>>
>> Sent from my phone
>>
>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>> I understand, but you can't insist on viewing ctors as "just methods" for
>>> all purposes.
>>>
>>> (2) publication is unsafe unless you get a volatile load after the last
>>> volatile store in the constructor. Besides, the initial value of the field
>>> may not even be one of the valid values, so it is not even just about a data
>>> race.
>>>
>>>
>>> Alex
>>>
>>>
>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>
>>> For compilation/codegen purposes ctors *are* just methods - they can be
>>> inlined, code optimized, etc; that's the reason we have the final field
>>> guarantees.
>>>
>>> A couple of potential reasons not to add volatile to the spec:
>>> 1) perhaps some JVMs don't currently already give them final field
>>> semantics
>>> 2) this whole thing comes into play for unsafe publication only (I.e. data
>>> race), which is discouraged.
>>>
>>> Sent from my phone
>>>
>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>> Constructors are special methods. They are the first method calls in any
>>>> history of the object. This means a different treatment of volatile accesses
>>>> to the fields of the instance being created is possible - certain barriers
>>>> can be eliminated, because the loads can be proven to not synchronize with
>>>> anyone. For the sake of the argument, it is possible to proceed with weak
>>>> treatment of volatile stores, too, but you need a good reason to permit
>>>> subsequent calls to observe the initial state of the volatile fields;
>>>> whereas any volatile load in any other method always synchronizes with a
>>>> volatile store of some other method call, without the final field semantics
>>>> we cannot assume that.
>>>>
>>>> However, if we assume final field semantics, there is only one barrier
>>>> needed - a store-store after the last volatile field store. This eliminates
>>>> all barriers for any other volatile field initialization, and eliminates a
>>>> full barrier needed otherwise (got to place a dummy volatile load after the
>>>> last volatile store to make sure the semantics are stronger than
>>>> final-field) - think of removing a mfence or similar from each such
>>>> constructor on x86.
>>>>
>>>> (there will still be gotchas for cases when volatile field initialization
>>>> occurs after a volatile load of something outside the same instance; but the
>>>> main purpose is to eliminate barriers when the volatile fields are just
>>>> initialized into some instance-specific values)
>>>>
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>
>>>> I'm about why "always mean storestore after volatile store in
>>>> constructor". It is not only efficiency which is important for MM, but also
>>>> simplicity and consistency. If constructors are special methods, not just
>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>> if constructors are just plain methods, it looks strange to have special
>>>> implicit semantics for constructors with volatiles inside.
>>>>
>>>>
>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>> I think it is pretty simple.
>>>>>
>>>>> If you always mean a store-store barrier after the last volatile store
>>>>> in the constructor, then add that barrier into constructor semantics, like
>>>>> it's done with the final fields.
>>>>>
>>>>> It makes sense to not add it to the semantics, if you can come up with
>>>>> enough examples where you want that barrier to be eliminated.
>>>>>
>>>>> Alex
>>>>>
>>>>>
>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>
>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>> I mean, I could not see any noticable difference between the case discussed,
>>>>> and just any other case there volatile is _incorrectly_ used to
>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>> any other object which is unsafely published. I think everybody who passed
>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>> read [.value=0] in the case discussed.
>>>>>
>>>>> "Data race is pure evil" was the motto of this list all time I was
>>>>> reading it. Why do we may want to introduce another example of benign race?
>>>>> Wouldn't it be just another source of confusion for newcomers?
>>>>>
>>>>>
>>>>>
>>>>>
>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>> Doug, could you explain why it is so important to have this kind of
>>>>>>> safe
>>>>>>> publication for volatile? I mean, could we just go with .value=0
>>>>>>> through data
>>>>>>> race to be allowed result, as current model (seem to) imply? It seems
>>>>>>> to be a
>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>> The main reason is that it is highly irregular and unexpected
>>>>>> by programmers. Except in this case, volatiles definitionally cannot
>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>> correctness on current JVMs. We have several constructions
>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>> candidate for reconsideration.
>>>>>>
>>>>>> -Doug
>>>>>>
>>>>>>
>>>>>>
>>>>>>> Ruslan
>>>>>>>
>>>>>>>> 27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu> ???????(?):
>>>>>>>>
>>>>>>>>> On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either way,
>>>>>>>>> optimizations to avoid zeroing memory is an implementation detail
>>>>>>>>> and
>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think you're
>>>>>>>>> saying.
>>>>>>>>>
>>>>>>>>> The other issue is that even if we determine that volatiles don't
>>>>>>>>> get
>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going to be
>>>>>>>>> practical to change it and risk hard to debug problems creeping in.
>>>>>>>>> May
>>>>>>>>> as well update the spec now ...
>>>>>>>> Right. To summarize:
>>>>>>>>
>>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>>> specifically
>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>
>>>>>>>> * For various implementation reasons, JVMs arrange that volatile
>>>>>>>> fields are
>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>
>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy (no small
>>>>>>>> tweak
>>>>>>>> that I know applies). But now is a good time to be considering a full
>>>>>>>> revision for JDK9.
>>>>>>>>
>>>>>>>> * In the mean time, it would make sense to further test and validate
>>>>>>>> JVMs
>>>>>>>> as meeting this likely future spec.
>>>>>>>>
>>>>>>>> -Doug
>>>>>>>>
>>>>>>>> _______________________________________________ Concurrency-interest
>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/9e8edb8e/attachment-0001.html>

From oleksandr.otenko at oracle.com  Tue Dec  3 14:47:51 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 19:47:51 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>
References: <5295E24C.40608@oracle.com>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
	<529E297C.4070401@oracle.com>
	<CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gm!
	ail.com>
Message-ID: <529E3567.8020108@oracle.com>

This topic loops here.

The other ctors don't have the barriers, so adding them costs.

The ctors with volatiles already have the barriers, so order them in a 
way that offers more safety. You already mentioned the circus with 
lazySet that is needed otherwise. Since we all agree that's the safe way 
to do it, and we don't advocate unsafe publishing, why not imply lazySet 
then.

Alex


On 03/12/2013 19:21, Vitaly Davidovich wrote:
>
> So to play devil's advocate, why not make all ctors behave the same 
> way? Afterall, people may still publish classes with no final or 
> volatile fields unsafely, and run into problems.  One can argue that 
> most people expect that upon constructor exit, all memory ops are 
> complete.  Why only add volatile to the mix? So that concurrency 
> authors can attempt at safeguarding their class from unsafe 
> publication by a user who doesn't know any better? Is that really 
> worth the overhead required? Said user can still shoot themselves in 
> other ways. At some point, the burden should be on devs to know the 
> platform, its promises/guarantees, and available tools to add their 
> own extra guarantees.
>
> Again, we're talking about data race publishing here - this is not the 
> norm or encouraged practice.  Why bend over backwards to accommodate it?
>
> Sent from my phone
>
> On Dec 3, 2013 1:57 PM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     You'd need load-store after loading externally observable values
>     with or without the proposed changes, but we aren't eliminating
>     those, are we? I thought you meant we need new barriers.
>
>     Alex
>
>     On 03/12/2013 18:51, Vitaly Davidovich wrote:
>>
>>     You would - since volatile can be modified and read many times in
>>     ctor, you need to ensure all loads are done before the store and
>>     before ctor exits - you need to ensure value of the volatile is
>>     the final one at the end of the ctor sequence.  Otherwise, the
>>     loads can move after the store.  Basically, you need lazySet()
>>     now and not plain storestore.
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 1:44 PM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         I don't think you'd need it in a constructor.
>>
>>         You can't read the fields until the reference to the instance
>>         is stored. If you can stop reordering that store with the
>>         last volatile store, publication is safe.
>>
>>         Alex
>>
>>         On 03/12/2013 18:34, Vitaly Davidovich wrote:
>>>
>>>         For volatiles, you'd need load-store as well though.
>>>
>>>         Sent from my phone
>>>
>>>         On Dec 3, 2013 1:05 PM, "Oleksandr Otenko"
>>>         <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>
>>>             Sure.
>>>
>>>             f=42;
>>>
>>>             already imposes the cost of store-store barrier.
>>>
>>>             f=42;
>>>             f=42;
>>>
>>>             does the same thing. In a constructor, eliminate the
>>>             first barrier, because the order of writes to the
>>>             unreachable instance is not important, and the second
>>>             store. This no longer is the question of performance,
>>>             because it is the same. It is the question of
>>>             correctness for free.
>>>
>>>             Alex
>>>
>>>             On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>>>
>>>>             Not sure that's the right view either.  The one thing
>>>>             the author does not control is how instances of their
>>>>             class are passed around.  User of the class has more
>>>>             context - it may actually be ok that volatiles aren't
>>>>             fenced here because they're already ensuring some way
>>>>             that it's fine, including the possibility that the
>>>>             instance isn't even shared at all.  As long as people
>>>>             know the behavior of the language/platform, they should
>>>>             be expected to make an educated decision on their own.
>>>>
>>>>             Look, if performance didn't matter, you could just
>>>>             blindly say that all constructors have a freeze action,
>>>>             regardless of final fields or volatile. That's not the
>>>>             case, of course.  Java and JDK have tools available to
>>>>             publish safely, so people doing multithreading have the
>>>>             ability to do the right thing. At the end of the day,
>>>>             exposing concurrency to devs will lead to bugs, even
>>>>             beside the issues described here.
>>>>
>>>>             Sent from my phone
>>>>
>>>>             On Dec 3, 2013 12:42 PM, "Oleksandr Otenko"
>>>>             <oleksandr.otenko at oracle.com
>>>>             <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>
>>>>                 No, this is a completely opposite view. The
>>>>                 question is:
>>>>
>>>>                 do you as the implementor of the concurrent
>>>>                 algorithm ever intend the constructor design to be
>>>>                 such that relies on the protocol that the caller
>>>>                 chooses to publish the reference?
>>>>
>>>>                 (Do you ever intend to /*not*/ specify a no-op
>>>>                 volatile load after the last volatile store in the
>>>>                 constructor?)
>>>>
>>>>
>>>>                 Alex
>>>>
>>>>
>>>>                 On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>>>>
>>>>>                 I'm confident most code that publishes objects
>>>>>                 shared across threads does it safely.  Otherwise
>>>>>                 we're saying majority of code uses data races?
>>>>>
>>>>>                 Sent from my phone
>>>>>
>>>>>                 On Dec 3, 2013 12:21 PM, "Oleksandr Otenko"
>>>>>                 <oleksandr.otenko at oracle.com
>>>>>                 <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>
>>>>>                     Hmmm.... I thought it is clear no one argues
>>>>>                     about the "/*if*/ you publish safely" part.
>>>>>                     The question I am wondering about is whether
>>>>>                     you can find a case where publishing the
>>>>>                     reference to the instance unsafely is /intended/.
>>>>>
>>>>>                     Alex
>>>>>
>>>>>                     On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>>>>
>>>>>>                     But this is only if you publish unsafely, as
>>>>>>                     mentioned before.  If you publish this class
>>>>>>                     properly, you don't get races on the
>>>>>>                     volatile.   Final fields are supposed to
>>>>>>                     support immutable classes, where although not
>>>>>>                     preferrable, publishing racily is plausible
>>>>>>                     (for performance).  For read/write volatiles,
>>>>>>                     it's not compelling on the surface.
>>>>>>
>>>>>>                     Sent from my phone
>>>>>>
>>>>>>                     On Dec 3, 2013 11:18 AM, "Oleksandr Otenko"
>>>>>>                     <oleksandr.otenko at oracle.com
>>>>>>                     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>
>>>>>>                         Yes, but I mean that the code assumes the
>>>>>>                         value to always be non-null - eg a
>>>>>>                         sentinel entry of the list is created at
>>>>>>                         construction time. Without the
>>>>>>                         construction-time guarantee you'd need to
>>>>>>                         test for null everywhere.
>>>>>>
>>>>>>                         I think the same applies in other
>>>>>>                         constructors - if you write the
>>>>>>                         initialization of the volatile, you imply
>>>>>>                         that's "the least" "possible" value, the
>>>>>>                         value representing the initial state of
>>>>>>                         the concurrent algorithm - the initial
>>>>>>                         value guaranteed by Java spec may not
>>>>>>                         represent any valid state of the
>>>>>>                         concurrent algorithm, let alone the
>>>>>>                         initial state.
>>>>>>
>>>>>>                         That's why this really boils down to
>>>>>>                         "find the broad cases where you do want
>>>>>>                         to permit unsafe publication of the
>>>>>>                         initial values of the volatiles".
>>>>>>
>>>>>>
>>>>>>                         (unlike the non-volatile fields. Don't
>>>>>>                         treat them as "not thread safe" -
>>>>>>                         instead, treat them as "assume as made
>>>>>>                         thread-safe by means outside the class
>>>>>>                         specification", hence no requirement for
>>>>>>                         "safe publication" there)
>>>>>>
>>>>>>
>>>>>>                         Alex
>>>>>>
>>>>>>
>>>>>>                         On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>>>>
>>>>>>>                         Initial value of the field must be the
>>>>>>>                         "zero" value of that type, that's a
>>>>>>>                         language spec and must be guaranteed
>>>>>>>                         irrespective of volatile or not.
>>>>>>>
>>>>>>>                         Sent from my phone
>>>>>>>
>>>>>>>                         On Dec 3, 2013 10:03 AM, "Oleksandr
>>>>>>>                         Otenko" <oleksandr.otenko at oracle.com
>>>>>>>                         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>>
>>>>>>>                             I understand, but you can't insist
>>>>>>>                             on viewing ctors as "just methods"
>>>>>>>                             for all purposes.
>>>>>>>
>>>>>>>                             (2) publication is unsafe unless you
>>>>>>>                             get a volatile load after the last
>>>>>>>                             volatile store in the constructor.
>>>>>>>                             Besides, the initial value of the
>>>>>>>                             field may not even be one of the
>>>>>>>                             valid values, so it is not even just
>>>>>>>                             about a data race.
>>>>>>>
>>>>>>>
>>>>>>>                             Alex
>>>>>>>
>>>>>>>
>>>>>>>                             On 03/12/2013 13:57, Vitaly
>>>>>>>                             Davidovich wrote:
>>>>>>>>
>>>>>>>>                             For compilation/codegen purposes
>>>>>>>>                             ctors *are* just methods - they can
>>>>>>>>                             be inlined, code optimized, etc;
>>>>>>>>                             that's the reason we have the final
>>>>>>>>                             field guarantees.
>>>>>>>>
>>>>>>>>                             A couple of potential reasons not
>>>>>>>>                             to add volatile to the spec:
>>>>>>>>                             1) perhaps some JVMs don't
>>>>>>>>                             currently already give them final
>>>>>>>>                             field semantics
>>>>>>>>                             2) this whole thing comes into play
>>>>>>>>                             for unsafe publication only (I.e.
>>>>>>>>                             data race), which is discouraged.
>>>>>>>>
>>>>>>>>                             Sent from my phone
>>>>>>>>
>>>>>>>>                             On Dec 3, 2013 6:51 AM, "Oleksandr
>>>>>>>>                             Otenko"
>>>>>>>>                             <oleksandr.otenko at oracle.com
>>>>>>>>                             <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>                             wrote:
>>>>>>>>
>>>>>>>>                                 Constructors /are/ special
>>>>>>>>                                 methods. They are the first
>>>>>>>>                                 method calls in any history of
>>>>>>>>                                 the object. This means a
>>>>>>>>                                 different treatment of volatile
>>>>>>>>                                 accesses to the fields of the
>>>>>>>>                                 instance being created is
>>>>>>>>                                 possible - certain barriers can
>>>>>>>>                                 be eliminated, because the
>>>>>>>>                                 loads can be proven to not
>>>>>>>>                                 synchronize with anyone. For
>>>>>>>>                                 the sake of the argument, it is
>>>>>>>>                                 possible to proceed with weak
>>>>>>>>                                 treatment of volatile stores,
>>>>>>>>                                 too, but you need a good reason
>>>>>>>>                                 to permit subsequent calls to
>>>>>>>>                                 observe the initial state of
>>>>>>>>                                 the volatile fields; whereas
>>>>>>>>                                 any volatile load in any other
>>>>>>>>                                 method always synchronizes with
>>>>>>>>                                 a volatile store of some other
>>>>>>>>                                 method call, without the final
>>>>>>>>                                 field semantics we cannot
>>>>>>>>                                 assume that.
>>>>>>>>
>>>>>>>>                                 However, if we assume final
>>>>>>>>                                 field semantics, there is only
>>>>>>>>                                 one barrier needed - a
>>>>>>>>                                 store-store after the last
>>>>>>>>                                 volatile field store. This
>>>>>>>>                                 eliminates all barriers for any
>>>>>>>>                                 other volatile field
>>>>>>>>                                 initialization, and eliminates
>>>>>>>>                                 a full barrier needed otherwise
>>>>>>>>                                 (got to place a dummy volatile
>>>>>>>>                                 load after the last volatile
>>>>>>>>                                 store to make sure the
>>>>>>>>                                 semantics are stronger than
>>>>>>>>                                 final-field) - think of
>>>>>>>>                                 removing a mfence or similar
>>>>>>>>                                 from each such constructor on x86.
>>>>>>>>
>>>>>>>>                                 (there will still be gotchas
>>>>>>>>                                 for cases when volatile field
>>>>>>>>                                 initialization occurs after a
>>>>>>>>                                 volatile load of something
>>>>>>>>                                 outside the same instance; but
>>>>>>>>                                 the main purpose is to
>>>>>>>>                                 eliminate barriers when the
>>>>>>>>                                 volatile fields are just
>>>>>>>>                                 initialized into some
>>>>>>>>                                 instance-specific values)
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 Alex
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 On 03/12/2013 05:54, Ruslan
>>>>>>>>                                 Cheremin wrote:
>>>>>>>>>                                 I'm about why "always mean
>>>>>>>>>                                 storestore after volatile
>>>>>>>>>                                 store in constructor". It is
>>>>>>>>>                                 not only efficiency which is
>>>>>>>>>                                 important for MM, but also
>>>>>>>>>                                 simplicity and consistency. If
>>>>>>>>>                                 constructors are special
>>>>>>>>>                                 methods, not just plain
>>>>>>>>>                                 <init>, then we should add
>>>>>>>>>                                 this kind of atomicity to all
>>>>>>>>>                                 constructors (which, as I was
>>>>>>>>>                                 reading here, could be
>>>>>>>>>                                 inefficient on some
>>>>>>>>>                                 platforms). But if
>>>>>>>>>                                 constructors are just plain
>>>>>>>>>                                 methods, it looks strange to
>>>>>>>>>                                 have special implicit
>>>>>>>>>                                 semantics for constructors
>>>>>>>>>                                 with volatiles inside.
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                 2013/12/3 Oleksandr Otenko
>>>>>>>>>                                 <oleksandr.otenko at oracle.com
>>>>>>>>>                                 <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>
>>>>>>>>>                                     I think it is pretty simple.
>>>>>>>>>
>>>>>>>>>                                     If you always mean a
>>>>>>>>>                                     store-store barrier
>>>>>>>>>                                     /after/ the last volatile
>>>>>>>>>                                     store in the constructor,
>>>>>>>>>                                     then add that barrier into
>>>>>>>>>                                     constructor semantics,
>>>>>>>>>                                     like it's done with the
>>>>>>>>>                                     final fields.
>>>>>>>>>
>>>>>>>>>                                     It makes sense to /not/
>>>>>>>>>                                     add it to the semantics,
>>>>>>>>>                                     if you can come up with
>>>>>>>>>                                     enough examples where you
>>>>>>>>>                                     want that barrier to be
>>>>>>>>>                                     eliminated.
>>>>>>>>>
>>>>>>>>>                                     Alex
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     On 02/12/2013 19:32,
>>>>>>>>>                                     Ruslan Cheremin wrote:
>>>>>>>>>>                                     Well, I do not see any
>>>>>>>>>>                                     data race _on volatiles_
>>>>>>>>>>                                     here. I see race
>>>>>>>>>>                                     condition on volatile
>>>>>>>>>>                                     .value, yes -- but it is
>>>>>>>>>>                                     pretty legal (and
>>>>>>>>>>                                     unavoidable, I suppose)
>>>>>>>>>>                                     to have race conditions
>>>>>>>>>>                                     even with volatiles
>>>>>>>>>>                                     involved. The only data
>>>>>>>>>>                                     race I see is around
>>>>>>>>>>                                     read-write of
>>>>>>>>>>                                     (non-volatile)
>>>>>>>>>>                                     AtomicInteger's reference
>>>>>>>>>>                                     -- which is unrelated to
>>>>>>>>>>                                     AtomicInteger's content.
>>>>>>>>>>                                     I mean, I could not see
>>>>>>>>>>                                     any noticable difference
>>>>>>>>>>                                     between the case
>>>>>>>>>>                                     discussed, and just any
>>>>>>>>>>                                     other case there volatile
>>>>>>>>>>                                     is _incorrectly_ used to
>>>>>>>>>>                                     "synchronize" data
>>>>>>>>>>                                     accesses -- it could
>>>>>>>>>>                                     still be data race on
>>>>>>>>>>                                     non-volatile fields, even
>>>>>>>>>>                                     if volatile fields are
>>>>>>>>>>                                     also used somewhere
>>>>>>>>>>                                     around. Yes, get 0 from
>>>>>>>>>>                                     .value is unexpected --
>>>>>>>>>>                                     but there are many
>>>>>>>>>>                                     unexpected things in
>>>>>>>>>>                                     memory models. It is
>>>>>>>>>>                                     noway more unexpected
>>>>>>>>>>                                     then to see default
>>>>>>>>>>                                     values in fields of any
>>>>>>>>>>                                     other object which is
>>>>>>>>>>                                     unsafely published. I
>>>>>>>>>>                                     think everybody who
>>>>>>>>>>                                     passed through broken
>>>>>>>>>>                                     atomicity of constructor
>>>>>>>>>>                                     call could easy see the
>>>>>>>>>>                                     chance to read [.value=0]
>>>>>>>>>>                                     in the case discussed.
>>>>>>>>>>
>>>>>>>>>>                                     "Data race is pure evil"
>>>>>>>>>>                                     was the motto of this
>>>>>>>>>>                                     list all time I was
>>>>>>>>>>                                     reading it. Why do we may
>>>>>>>>>>                                     want to introduce another
>>>>>>>>>>                                     example of benign race?
>>>>>>>>>>                                     Wouldn't it be just
>>>>>>>>>>                                     another source of
>>>>>>>>>>                                     confusion for newcomers?
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                     2013/12/2 Doug Lea
>>>>>>>>>>                                     <dl at cs.oswego.edu
>>>>>>>>>>                                     <mailto:dl at cs.oswego.edu>>
>>>>>>>>>>
>>>>>>>>>>                                         On 12/02/2013 03:57
>>>>>>>>>>                                         AM, Cheremin Ruslan
>>>>>>>>>>                                         wrote:
>>>>>>>>>>
>>>>>>>>>>                                             Doug, could you
>>>>>>>>>>                                             explain why it is
>>>>>>>>>>                                             so important to
>>>>>>>>>>                                             have this kind of
>>>>>>>>>>                                             safe
>>>>>>>>>>                                             publication for
>>>>>>>>>>                                             volatile? I mean,
>>>>>>>>>>                                             could we just go
>>>>>>>>>>                                             with .value=0
>>>>>>>>>>                                             through data
>>>>>>>>>>                                             race to be
>>>>>>>>>>                                             allowed result,
>>>>>>>>>>                                             as current model
>>>>>>>>>>                                             (seem to) imply?
>>>>>>>>>>                                             It seems to be a
>>>>>>>>>>                                             dr-case anyway,
>>>>>>>>>>                                             why we need
>>>>>>>>>>                                             special handling
>>>>>>>>>>                                             of it?
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         The main reason is
>>>>>>>>>>                                         that it is highly
>>>>>>>>>>                                         irregular and unexpected
>>>>>>>>>>                                         by programmers.
>>>>>>>>>>                                         Except in this case,
>>>>>>>>>>                                         volatiles
>>>>>>>>>>                                         definitionally cannot
>>>>>>>>>>                                         be subject to data
>>>>>>>>>>                                         races. Dealing with
>>>>>>>>>>                                         it requires cleverness,
>>>>>>>>>>                                         complexity, and/or
>>>>>>>>>>                                         error-proneness that
>>>>>>>>>>                                         isn't even required for
>>>>>>>>>>                                         correctness on
>>>>>>>>>>                                         current JVMs. We have
>>>>>>>>>>                                         several constructions
>>>>>>>>>>                                         in j.u.c that work
>>>>>>>>>>                                         around problems by
>>>>>>>>>>                                         using explicit ordered
>>>>>>>>>>                                         writes in
>>>>>>>>>>                                         constructors,
>>>>>>>>>>                                         redundant-looking
>>>>>>>>>>                                         null-checks, and so
>>>>>>>>>>                                         on. If we are going
>>>>>>>>>>                                         to repair the JMM
>>>>>>>>>>                                         anyway, this is a clear
>>>>>>>>>>                                         candidate for
>>>>>>>>>>                                         reconsideration.
>>>>>>>>>>
>>>>>>>>>>                                         -Doug
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                             Ruslan
>>>>>>>>>>
>>>>>>>>>>                                                 27 ????. 2013
>>>>>>>>>>                                                 ?., ? 23:26,
>>>>>>>>>>                                                 Doug Lea
>>>>>>>>>>                                                 <dl at cs.oswego.edu
>>>>>>>>>>                                                 <mailto:dl at cs.oswego.edu>>
>>>>>>>>>>                                                 ???????(?):
>>>>>>>>>>
>>>>>>>>>>                                                     On
>>>>>>>>>>                                                     11/27/2013 02:06
>>>>>>>>>>                                                     PM,
>>>>>>>>>>                                                     Vitaly
>>>>>>>>>>                                                     Davidovich wrote:
>>>>>>>>>>                                                     But
>>>>>>>>>>                                                     either way,
>>>>>>>>>>                                                     optimizations
>>>>>>>>>>                                                     to avoid
>>>>>>>>>>                                                     zeroing
>>>>>>>>>>                                                     memory is
>>>>>>>>>>                                                     an
>>>>>>>>>>                                                     implementation
>>>>>>>>>>                                                     detail and
>>>>>>>>>>                                                     thus
>>>>>>>>>>                                                     cannot be
>>>>>>>>>>                                                     relied
>>>>>>>>>>                                                     upon from
>>>>>>>>>>                                                     JMM
>>>>>>>>>>                                                     standpoint,
>>>>>>>>>>                                                     which I
>>>>>>>>>>                                                     think you're
>>>>>>>>>>                                                     saying.
>>>>>>>>>>
>>>>>>>>>>                                                     The other
>>>>>>>>>>                                                     issue is
>>>>>>>>>>                                                     that even
>>>>>>>>>>                                                     if we
>>>>>>>>>>                                                     determine
>>>>>>>>>>                                                     that
>>>>>>>>>>                                                     volatiles
>>>>>>>>>>                                                     don't get
>>>>>>>>>>                                                     this
>>>>>>>>>>                                                     treatment, if
>>>>>>>>>>                                                     JVM is
>>>>>>>>>>                                                     already
>>>>>>>>>>                                                     ensuring
>>>>>>>>>>                                                     it, it's
>>>>>>>>>>                                                     not going
>>>>>>>>>>                                                     to be
>>>>>>>>>>                                                     practical
>>>>>>>>>>                                                     to change
>>>>>>>>>>                                                     it and
>>>>>>>>>>                                                     risk hard
>>>>>>>>>>                                                     to debug
>>>>>>>>>>                                                     problems
>>>>>>>>>>                                                     creeping
>>>>>>>>>>                                                     in.  May
>>>>>>>>>>                                                     as well
>>>>>>>>>>                                                     update
>>>>>>>>>>                                                     the spec
>>>>>>>>>>                                                     now ...
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                                 Right. To
>>>>>>>>>>                                                 summarize:
>>>>>>>>>>
>>>>>>>>>>                                                 * Programmers
>>>>>>>>>>                                                 do not expect
>>>>>>>>>>                                                 that even
>>>>>>>>>>                                                 though final
>>>>>>>>>>                                                 fields are
>>>>>>>>>>                                                 specifically
>>>>>>>>>>                                                 publication-safe,
>>>>>>>>>>                                                 volatile
>>>>>>>>>>                                                 fields are
>>>>>>>>>>                                                 not always so.
>>>>>>>>>>
>>>>>>>>>>                                                 * For various
>>>>>>>>>>                                                 implementation reasons,
>>>>>>>>>>                                                 JVMs arrange
>>>>>>>>>>                                                 that volatile
>>>>>>>>>>                                                 fields are
>>>>>>>>>>                                                 publication
>>>>>>>>>>                                                 safe anyway,
>>>>>>>>>>                                                 at least in
>>>>>>>>>>                                                 cases we know
>>>>>>>>>>                                                 about.
>>>>>>>>>>
>>>>>>>>>>                                                 * Actually
>>>>>>>>>>                                                 updating the
>>>>>>>>>>                                                 JMM/JLS to
>>>>>>>>>>                                                 mandate this
>>>>>>>>>>                                                 is not easy
>>>>>>>>>>                                                 (no small tweak
>>>>>>>>>>                                                 that I know
>>>>>>>>>>                                                 applies). But
>>>>>>>>>>                                                 now is a good
>>>>>>>>>>                                                 time to be
>>>>>>>>>>                                                 considering a
>>>>>>>>>>                                                 full
>>>>>>>>>>                                                 revision for
>>>>>>>>>>                                                 JDK9.
>>>>>>>>>>
>>>>>>>>>>                                                 * In the mean
>>>>>>>>>>                                                 time, it
>>>>>>>>>>                                                 would make
>>>>>>>>>>                                                 sense to
>>>>>>>>>>                                                 further test
>>>>>>>>>>                                                 and validate JVMs
>>>>>>>>>>                                                 as meeting
>>>>>>>>>>                                                 this likely
>>>>>>>>>>                                                 future spec.
>>>>>>>>>>
>>>>>>>>>>                                                 -Doug
>>>>>>>>>>
>>>>>>>>>>                                                 _______________________________________________
>>>>>>>>>>                                                 Concurrency-interest
>>>>>>>>>>                                                 mailing list
>>>>>>>>>>                                                 Concurrency-interest at cs.oswego.edu
>>>>>>>>>>                                                 <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>                                                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                     _______________________________________________
>>>>>>>>>>                                     Concurrency-interest mailing list
>>>>>>>>>>                                     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>                                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     _______________________________________________
>>>>>>>>>                                     Concurrency-interest
>>>>>>>>>                                     mailing list
>>>>>>>>>                                     Concurrency-interest at cs.oswego.edu
>>>>>>>>>                                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>                                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 _______________________________________________
>>>>>>>>                                 Concurrency-interest mailing list
>>>>>>>>                                 Concurrency-interest at cs.oswego.edu
>>>>>>>>                                 <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>                                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>>                         _______________________________________________
>>>>>>                         Concurrency-interest mailing list
>>>>>>                         Concurrency-interest at cs.oswego.edu
>>>>>>                         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>
>>>>
>>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/13191283/attachment-0001.html>

From raould at gmail.com  Tue Dec  3 15:04:23 2013
From: raould at gmail.com (Raoul Duke)
Date: Tue, 3 Dec 2013 12:04:23 -0800
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E31AA.20503@oracle.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E011F.6060902@oracle.com>
	<CACuKZqF4xOEeDBz9_tqD+1X3J1pOny3Kn2a21KsX+z_F9-XC4w@mail.gmail.com>
	<529E31AA.20503@oracle.com>
Message-ID: <CAJ7XQb7dF2bCTdYxp8=o3Ly=RbAtj_EpyQ_EO2jJUTb+gZUu0A@mail.gmail.com>

> It would be better if the guarantee was more explicit in the code

word.

From raould at gmail.com  Tue Dec  3 15:05:01 2013
From: raould at gmail.com (Raoul Duke)
Date: Tue, 3 Dec 2013 12:05:01 -0800
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAJ7XQb7dF2bCTdYxp8=o3Ly=RbAtj_EpyQ_EO2jJUTb+gZUu0A@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<CAHjP37GLPJs1Ue0R6mVR55bUYJc1GGgz1a0vyiZs7QctAj-GkA@mail.gmail.com>
	<52964752.3020104@cs.oswego.edu>
	<C205DE08-6D87-47D2-9E78-ED0C69C8287E@gmail.com>
	<529C68C1.2040100@cs.oswego.edu>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E011F.6060902@oracle.com>
	<CACuKZqF4xOEeDBz9_tqD+1X3J1pOny3Kn2a21KsX+z_F9-XC4w@mail.gmail.com>
	<529E31AA.20503@oracle.com>
	<CAJ7XQb7dF2bCTdYxp8=o3Ly=RbAtj_EpyQ_EO2jJUTb+gZUu0A@mail.gmail.com>
Message-ID: <CAJ7XQb4XnNjLCD8Q7O-YoyMS2e=cFXT=uqzoQNyi2rfhGS5eiQ@mail.gmail.com>

On Tue, Dec 3, 2013 at 12:04 PM, Raoul Duke <raould at gmail.com> wrote:
>> It would be better if the guarantee was more explicit in the code
> word.

argh. chopped the quote :-(
> It would be better if the guarantee was more explicit in the code (e.g. adding the synchronized keyword to the constructor).

From vitalyd at gmail.com  Tue Dec  3 15:18:15 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 15:18:15 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E3567.8020108@oracle.com>
References: <5295E24C.40608@oracle.com>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
	<529E297C.4070401@oracle.com>
	<CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>
	<529E3567.8020108@oracle.com>
Message-ID: <CAHjP37GA9dQQd0Ds=zMCXTJMO4OHhr983MjcxUST07aSu6pi2A@mail.gmail.com>

Well, PPC guys didn't have the extra barriers for volatiles in constructors
either (for storestore), as mentioned.  For them, this will be new
barriers.  What does one tell them? Either we're "fixing" publishing or
we're doing this because the cost is no greater - which is it for someone
like PPC?

Sent from my phone
On Dec 3, 2013 2:48 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  This topic loops here.
>
> The other ctors don't have the barriers, so adding them costs.
>
> The ctors with volatiles already have the barriers, so order them in a way
> that offers more safety. You already mentioned the circus with lazySet that
> is needed otherwise. Since we all agree that's the safe way to do it, and
> we don't advocate unsafe publishing, why not imply lazySet then.
>
> Alex
>
>
> On 03/12/2013 19:21, Vitaly Davidovich wrote:
>
> So to play devil's advocate, why not make all ctors behave the same way?
> Afterall, people may still publish classes with no final or volatile fields
> unsafely, and run into problems.  One can argue that most people expect
> that upon constructor exit, all memory ops are complete.  Why only add
> volatile to the mix? So that concurrency authors can attempt at
> safeguarding their class from unsafe publication by a user who doesn't know
> any better? Is that really worth the overhead required? Said user can still
> shoot themselves in other ways.  At some point, the burden should be on
> devs to know the platform, its promises/guarantees, and available tools to
> add their own extra guarantees.
>
> Again, we're talking about data race publishing here - this is not the
> norm or encouraged practice.  Why bend over backwards to accommodate it?
>
> Sent from my phone
> On Dec 3, 2013 1:57 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  You'd need load-store after loading externally observable values with or
>> without the proposed changes, but we aren't eliminating those, are we? I
>> thought you meant we need new barriers.
>>
>> Alex
>>
>> On 03/12/2013 18:51, Vitaly Davidovich wrote:
>>
>> You would - since volatile can be modified and read many times in ctor,
>> you need to ensure all loads are done before the store and before ctor
>> exits - you need to ensure value of the volatile is the final one at the
>> end of the ctor sequence.  Otherwise, the loads can move after the store.
>> Basically, you need lazySet() now and not plain storestore.
>>
>> Sent from my phone
>> On Dec 3, 2013 1:44 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  I don't think you'd need it in a constructor.
>>>
>>> You can't read the fields until the reference to the instance is stored.
>>> If you can stop reordering that store with the last volatile store,
>>> publication is safe.
>>>
>>> Alex
>>>
>>> On 03/12/2013 18:34, Vitaly Davidovich wrote:
>>>
>>> For volatiles, you'd need load-store as well though.
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 1:05 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>
>>>>  Sure.
>>>>
>>>> f=42;
>>>>
>>>> already imposes the cost of store-store barrier.
>>>>
>>>> f=42;
>>>> f=42;
>>>>
>>>> does the same thing. In a constructor, eliminate the first barrier,
>>>> because the order of writes to the unreachable instance is not important,
>>>> and the second store. This no longer is the question of performance,
>>>> because it is the same. It is the question of correctness for free.
>>>>
>>>> Alex
>>>>
>>>> On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>>>
>>>> Not sure that's the right view either.  The one thing the author does
>>>> not control is how instances of their class are passed around.  User of the
>>>> class has more context - it may actually be ok that volatiles aren't fenced
>>>> here because they're already ensuring some way that it's fine, including
>>>> the possibility that the instance isn't even shared at all.  As long as
>>>> people know the behavior of the language/platform, they should be expected
>>>> to make an educated decision on their own.
>>>>
>>>> Look, if performance didn't matter, you could just blindly say that all
>>>> constructors have a freeze action, regardless of final fields or volatile.
>>>> That's not the case, of course.  Java and JDK have tools available to
>>>> publish safely, so people doing multithreading have the ability to do the
>>>> right thing.  At the end of the day, exposing concurrency to devs will lead
>>>> to bugs, even beside the issues described here.
>>>>
>>>> Sent from my phone
>>>> On Dec 3, 2013 12:42 PM, "Oleksandr Otenko" <
>>>> oleksandr.otenko at oracle.com> wrote:
>>>>
>>>>>  No, this is a completely opposite view. The question is:
>>>>>
>>>>> do you as the implementor of the concurrent algorithm ever intend the
>>>>> constructor design to be such that relies on the protocol that the caller
>>>>> chooses to publish the reference?
>>>>>
>>>>> (Do you ever intend to *not* specify a no-op volatile load after the
>>>>> last volatile store in the constructor?)
>>>>>
>>>>>
>>>>> Alex
>>>>>
>>>>>
>>>>> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>>>>
>>>>> I'm confident most code that publishes objects shared across threads
>>>>> does it safely.  Otherwise we're saying majority of code uses data races?
>>>>>
>>>>> Sent from my phone
>>>>> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <
>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>
>>>>>>  Hmmm.... I thought it is clear no one argues about the "*if* you
>>>>>> publish safely" part. The question I am wondering about is whether you can
>>>>>> find a case where publishing the reference to the instance unsafely is
>>>>>> *intended*.
>>>>>>
>>>>>> Alex
>>>>>>
>>>>>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>>>>
>>>>>> But this is only if you publish unsafely, as mentioned before.  If
>>>>>> you publish this class properly, you don't get races on the volatile.
>>>>>> Final fields are supposed to support immutable classes, where although not
>>>>>> preferrable, publishing racily is plausible (for performance).  For
>>>>>> read/write volatiles, it's not compelling on the surface.
>>>>>>
>>>>>> Sent from my phone
>>>>>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <
>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>
>>>>>>>  Yes, but I mean that the code assumes the value to always be
>>>>>>> non-null - eg a sentinel entry of the list is created at construction time.
>>>>>>> Without the construction-time guarantee you'd need to test for null
>>>>>>> everywhere.
>>>>>>>
>>>>>>> I think the same applies in other constructors - if you write the
>>>>>>> initialization of the volatile, you imply that's "the least" "possible"
>>>>>>> value, the value representing the initial state of the concurrent algorithm
>>>>>>> - the initial value guaranteed by Java spec may not represent any valid
>>>>>>> state of the concurrent algorithm, let alone the initial state.
>>>>>>>
>>>>>>> That's why this really boils down to "find the broad cases where you
>>>>>>> do want to permit unsafe publication of the initial values of the
>>>>>>> volatiles".
>>>>>>>
>>>>>>>
>>>>>>> (unlike the non-volatile fields. Don't treat them as "not thread
>>>>>>> safe" - instead, treat them as "assume as made thread-safe by means outside
>>>>>>> the class specification", hence no requirement for "safe publication" there)
>>>>>>>
>>>>>>>
>>>>>>> Alex
>>>>>>>
>>>>>>>
>>>>>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>>>>
>>>>>>> Initial value of the field must be the "zero" value of that type,
>>>>>>> that's a language spec and must be guaranteed irrespective of volatile or
>>>>>>> not.
>>>>>>>
>>>>>>> Sent from my phone
>>>>>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <
>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>
>>>>>>>>  I understand, but you can't insist on viewing ctors as "just
>>>>>>>> methods" for all purposes.
>>>>>>>>
>>>>>>>> (2) publication is unsafe unless you get a volatile load after the
>>>>>>>> last volatile store in the constructor. Besides, the initial value of the
>>>>>>>> field may not even be one of the valid values, so it is not even just about
>>>>>>>> a data race.
>>>>>>>>
>>>>>>>>
>>>>>>>> Alex
>>>>>>>>
>>>>>>>>
>>>>>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>>>>
>>>>>>>> For compilation/codegen purposes ctors *are* just methods - they
>>>>>>>> can be inlined, code optimized, etc; that's the reason we have the final
>>>>>>>> field guarantees.
>>>>>>>>
>>>>>>>> A couple of potential reasons not to add volatile to the spec:
>>>>>>>> 1) perhaps some JVMs don't currently already give them final field
>>>>>>>> semantics
>>>>>>>> 2) this whole thing comes into play for unsafe publication only
>>>>>>>> (I.e. data race), which is discouraged.
>>>>>>>>
>>>>>>>> Sent from my phone
>>>>>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <
>>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>>
>>>>>>>>>  Constructors *are* special methods. They are the first method
>>>>>>>>> calls in any history of the object. This means a different treatment of
>>>>>>>>> volatile accesses to the fields of the instance being created is possible -
>>>>>>>>> certain barriers can be eliminated, because the loads can be proven to not
>>>>>>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>>>>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>>>>>>> reason to permit subsequent calls to observe the initial state of the
>>>>>>>>> volatile fields; whereas any volatile load in any other method always
>>>>>>>>> synchronizes with a volatile store of some other method call, without the
>>>>>>>>> final field semantics we cannot assume that.
>>>>>>>>>
>>>>>>>>> However, if we assume final field semantics, there is only one
>>>>>>>>> barrier needed - a store-store after the last volatile field store. This
>>>>>>>>> eliminates all barriers for any other volatile field initialization, and
>>>>>>>>> eliminates a full barrier needed otherwise (got to place a dummy volatile
>>>>>>>>> load after the last volatile store to make sure the semantics are stronger
>>>>>>>>> than final-field) - think of removing a mfence or similar from each such
>>>>>>>>> constructor on x86.
>>>>>>>>>
>>>>>>>>> (there will still be gotchas for cases when volatile field
>>>>>>>>> initialization occurs after a volatile load of something outside the same
>>>>>>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>>>>>>> fields are just initialized into some instance-specific values)
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> Alex
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>>>>
>>>>>>>>> I'm about why "always mean storestore after volatile store in
>>>>>>>>> constructor". It is not only efficiency which is important for MM, but also
>>>>>>>>> simplicity and consistency. If constructors are special methods, not just
>>>>>>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>>>>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>>>>>>> if constructors are just plain methods, it looks strange to have special
>>>>>>>>> implicit semantics for constructors with volatiles inside.
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>>>>>>
>>>>>>>>>>  I think it is pretty simple.
>>>>>>>>>>
>>>>>>>>>> If you always mean a store-store barrier *after* the last
>>>>>>>>>> volatile store in the constructor, then add that barrier into constructor
>>>>>>>>>> semantics, like it's done with the final fields.
>>>>>>>>>>
>>>>>>>>>> It makes sense to *not* add it to the semantics, if you can come
>>>>>>>>>> up with enough examples where you want that barrier to be eliminated.
>>>>>>>>>>
>>>>>>>>>> Alex
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>>>>>
>>>>>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>>>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>>>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>>>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>>>>>>> I mean, I could not see any noticable difference between the case
>>>>>>>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>>>>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>>>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>>>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>>>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>>>>>>> any other object which is unsafely published. I think everybody who passed
>>>>>>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>>>>>>> read [.value=0] in the case discussed.
>>>>>>>>>>
>>>>>>>>>>  "Data race is pure evil" was the motto of this list all time I
>>>>>>>>>> was reading it. Why do we may want to introduce another example of benign
>>>>>>>>>> race? Wouldn't it be just another source of confusion for newcomers?
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>>
>>>>>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>>>>>>
>>>>>>>>>>>> Doug, could you explain why it is so important to have this
>>>>>>>>>>>> kind of safe
>>>>>>>>>>>> publication for volatile? I mean, could we just go with
>>>>>>>>>>>> .value=0 through data
>>>>>>>>>>>> race to be allowed result, as current model (seem to) imply? It
>>>>>>>>>>>> seems to be a
>>>>>>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>  The main reason is that it is highly irregular and unexpected
>>>>>>>>>>> by programmers. Except in this case, volatiles definitionally
>>>>>>>>>>> cannot
>>>>>>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>>>>>>> correctness on current JVMs. We have several constructions
>>>>>>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>>>>>>> candidate for reconsideration.
>>>>>>>>>>>
>>>>>>>>>>> -Doug
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>> Ruslan
>>>>>>>>>>>>
>>>>>>>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>>>>> ???????(?):
>>>>>>>>>>>>>
>>>>>>>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either
>>>>>>>>>>>>>> way,
>>>>>>>>>>>>>> optimizations to avoid zeroing memory is an implementation
>>>>>>>>>>>>>> detail and
>>>>>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I think
>>>>>>>>>>>>>> you're
>>>>>>>>>>>>>> saying.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> The other issue is that even if we determine that volatiles
>>>>>>>>>>>>>> don't get
>>>>>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not going
>>>>>>>>>>>>>> to be
>>>>>>>>>>>>>> practical to change it and risk hard to debug problems
>>>>>>>>>>>>>> creeping in.  May
>>>>>>>>>>>>>> as well update the spec now ...
>>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>> Right. To summarize:
>>>>>>>>>>>>>
>>>>>>>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>>>>>>>> specifically
>>>>>>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>>>>>>
>>>>>>>>>>>>> * For various implementation reasons, JVMs arrange that
>>>>>>>>>>>>> volatile fields are
>>>>>>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>>>>>>
>>>>>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy
>>>>>>>>>>>>> (no small tweak
>>>>>>>>>>>>> that I know applies). But now is a good time to be considering
>>>>>>>>>>>>> a full
>>>>>>>>>>>>> revision for JDK9.
>>>>>>>>>>>>>
>>>>>>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>>>>>>> validate JVMs
>>>>>>>>>>>>> as meeting this likely future spec.
>>>>>>>>>>>>>
>>>>>>>>>>>>> -Doug
>>>>>>>>>>>>>
>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>> Concurrency-interest
>>>>>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/5748e512/attachment-0001.html>

From raould at gmail.com  Tue Dec  3 15:24:55 2013
From: raould at gmail.com (Raoul Duke)
Date: Tue, 3 Dec 2013 12:24:55 -0800
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37GA9dQQd0Ds=zMCXTJMO4OHhr983MjcxUST07aSu6pi2A@mail.gmail.com>
References: <5295E24C.40608@oracle.com>
	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>
	<529CEAC4.7080409@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
	<529E297C.4070401@oracle.com>
	<CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>
	<529E3567.8020108@oracle.com>
	<CAHjP37GA9dQQd0Ds=zMCXTJMO4OHhr983MjcxUST07aSu6pi2A@mail.gmail.com>
Message-ID: <CAJ7XQb7zWnvfsqnsNf32NP18b55-BYEWJbghhCRnwjiLaxnbhg@mail.gmail.com>

On Tue, Dec 3, 2013 at 12:18 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> Well, PPC guys didn't have the extra barriers for volatiles in constructors
> either (for storestore), as mentioned.  For them, this will be new barriers.
> What does one tell them? Either we're "fixing" publishing or we're doing
> this because the cost is no greater - which is it for someone like PPC?

iiuc it sounded like the spec itself didn't say enough, so the PPC
implementation wasn't even 'wrong' according to the docs.

is the intention to fix the spec somehow as well?

thanks.

From hans.boehm at hp.com  Tue Dec  3 15:49:44 2013
From: hans.boehm at hp.com (Boehm, Hans)
Date: Tue, 3 Dec 2013 20:49:44 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <52963CEB.5070703@cs.oswego.edu>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD23D5107EB@G9W0725.americas.hpqcorp.net>

> From: Doug Lea
> 
> Sorry for mis-remembering why I had treated this issue as basically
> settled:
> Unless a JVM always pre-zeros memory (which usually not a good option),
> then
> even if not explicitly initialized, volatile fields must be zeroed
> in the constructor body, with a release fence before publication.
Is there a general argument for that claim about pre-zeroing?  My expectation would have been that it's reasonable to pre-zero, so long as you do it in chunks small enough that the zeros are unlikely to leave the faster parts of the cache hierarchy between zeroing and use.  It seems to be a trade-off between fences and some, ideally small, risk of additional cache misses.

I have a couple of other concerns about this discussion:

1. Nobody has mentioned that in the other thread of the original example, the one that does r1 = a.f, the loads of a and a.f are not currently ordered.  Once you add the required wait for a non-null a, that also matters.  I expect that is in fact guaranteed by all current Java implementations, but it requires a spec change.  And I think there are many plausible (and implausible) variants of that change, with substantive differences.

2. Along the same lines, and in agreement with some later posts, I still don't fully understand the rationale for providing such guarantees for volatile fields.  There is a general rule that when I construct an object, I shouldn't use it until I've finished constructing/initializing it.  That also generally applies to the built-in types.  And I think it applies to concurrent containers, even if other operations are allowed to race.  We seem to be adding a special short-cut by guaranteeing that, with safe publication, if I see a non-null pointer to the object, then I can safely conclude it has been initialized, even if there is no real happens-before relationship.  But presumably if I see a flag that was set after the initialization, no such guarantee exists?  It's not at all clear to me that this simplifies our story.

IIRC, the current final field rules were developed primarily to provide some security guarantees.  It is possible to build immutable types that look immutable, even to a malicious client.  That argument doesn't apply to objects with volatile fields.

Hans



From oleksandr.otenko at oracle.com  Tue Dec  3 15:56:22 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 20:56:22 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37GA9dQQd0Ds=zMCXTJMO4OHhr983MjcxUST07aSu6pi2A@mail.gmail.com>
References: <5295E24C.40608@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
	<529E297C.4070401@oracle.com>
	<CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>
	<529E3567.8020108@oracle.com>
	<CAHjP37GA9dQQd0Ds=zMCXTJMO4OHhr983MjcxUST07aSu6pi2A@mail.gm!
	ail.com>
Message-ID: <529E4576.4070406@oracle.com>

What do you mean - new barriers?

Store-store must occur after the last store preceding the volatile store 
in program order. If they didn't have it, they've got the bug to fix. If 
they do have the store-store, then they are correct w.r.t. what the spec 
says, and it is a matter of opinion of whether the spec needs fixing. I 
see the spec will be safer and better, if it gets fixed as proposed, but 
I see the point why people oppose it.

Alex

On 03/12/2013 20:18, Vitaly Davidovich wrote:
>
> Well, PPC guys didn't have the extra barriers for volatiles in 
> constructors either (for storestore), as mentioned.  For them, this 
> will be new barriers.  What does one tell them? Either we're "fixing" 
> publishing or we're doing this because the cost is no greater - which 
> is it for someone like PPC?
>
> Sent from my phone
>
> On Dec 3, 2013 2:48 PM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     This topic loops here.
>
>     The other ctors don't have the barriers, so adding them costs.
>
>     The ctors with volatiles already have the barriers, so order them
>     in a way that offers more safety. You already mentioned the circus
>     with lazySet that is needed otherwise. Since we all agree that's
>     the safe way to do it, and we don't advocate unsafe publishing,
>     why not imply lazySet then.
>
>     Alex
>
>
>     On 03/12/2013 19:21, Vitaly Davidovich wrote:
>>
>>     So to play devil's advocate, why not make all ctors behave the
>>     same way? Afterall, people may still publish classes with no
>>     final or volatile fields unsafely, and run into problems.  One
>>     can argue that most people expect that upon constructor exit, all
>>     memory ops are complete.  Why only add volatile to the mix? So
>>     that concurrency authors can attempt at safeguarding their class
>>     from unsafe publication by a user who doesn't know any better? Is
>>     that really worth the overhead required? Said user can still
>>     shoot themselves in other ways.  At some point, the burden should
>>     be on devs to know the platform, its promises/guarantees, and
>>     available tools to add their own extra guarantees.
>>
>>     Again, we're talking about data race publishing here - this is
>>     not the norm or encouraged practice.  Why bend over backwards to
>>     accommodate it?
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 1:57 PM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         You'd need load-store after loading externally observable
>>         values with or without the proposed changes, but we aren't
>>         eliminating those, are we? I thought you meant we need new
>>         barriers.
>>
>>         Alex
>>
>>         On 03/12/2013 18:51, Vitaly Davidovich wrote:
>>>
>>>         You would - since volatile can be modified and read many
>>>         times in ctor, you need to ensure all loads are done before
>>>         the store and before ctor exits - you need to ensure value
>>>         of the volatile is the final one at the end of the ctor
>>>         sequence.  Otherwise, the loads can move after the store. 
>>>         Basically, you need lazySet() now and not plain storestore.
>>>
>>>         Sent from my phone
>>>
>>>         On Dec 3, 2013 1:44 PM, "Oleksandr Otenko"
>>>         <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>
>>>             I don't think you'd need it in a constructor.
>>>
>>>             You can't read the fields until the reference to the
>>>             instance is stored. If you can stop reordering that
>>>             store with the last volatile store, publication is safe.
>>>
>>>             Alex
>>>
>>>             On 03/12/2013 18:34, Vitaly Davidovich wrote:
>>>>
>>>>             For volatiles, you'd need load-store as well though.
>>>>
>>>>             Sent from my phone
>>>>
>>>>             On Dec 3, 2013 1:05 PM, "Oleksandr Otenko"
>>>>             <oleksandr.otenko at oracle.com
>>>>             <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>
>>>>                 Sure.
>>>>
>>>>                 f=42;
>>>>
>>>>                 already imposes the cost of store-store barrier.
>>>>
>>>>                 f=42;
>>>>                 f=42;
>>>>
>>>>                 does the same thing. In a constructor, eliminate
>>>>                 the first barrier, because the order of writes to
>>>>                 the unreachable instance is not important, and the
>>>>                 second store. This no longer is the question of
>>>>                 performance, because it is the same. It is the
>>>>                 question of correctness for free.
>>>>
>>>>                 Alex
>>>>
>>>>                 On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>>>>
>>>>>                 Not sure that's the right view either.  The one
>>>>>                 thing the author does not control is how instances
>>>>>                 of their class are passed around. User of the
>>>>>                 class has more context - it may actually be ok
>>>>>                 that volatiles aren't fenced here because they're
>>>>>                 already ensuring some way that it's fine,
>>>>>                 including the possibility that the instance isn't
>>>>>                 even shared at all.  As long as people know the
>>>>>                 behavior of the language/platform, they should be
>>>>>                 expected to make an educated decision on their own.
>>>>>
>>>>>                 Look, if performance didn't matter, you could just
>>>>>                 blindly say that all constructors have a freeze
>>>>>                 action, regardless of final fields or volatile. 
>>>>>                 That's not the case, of course.  Java and JDK have
>>>>>                 tools available to publish safely, so people doing
>>>>>                 multithreading have the ability to do the right
>>>>>                 thing.  At the end of the day, exposing
>>>>>                 concurrency to devs will lead to bugs, even beside
>>>>>                 the issues described here.
>>>>>
>>>>>                 Sent from my phone
>>>>>
>>>>>                 On Dec 3, 2013 12:42 PM, "Oleksandr Otenko"
>>>>>                 <oleksandr.otenko at oracle.com
>>>>>                 <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>
>>>>>                     No, this is a completely opposite view. The
>>>>>                     question is:
>>>>>
>>>>>                     do you as the implementor of the concurrent
>>>>>                     algorithm ever intend the constructor design
>>>>>                     to be such that relies on the protocol that
>>>>>                     the caller chooses to publish the reference?
>>>>>
>>>>>                     (Do you ever intend to /*not*/ specify a no-op
>>>>>                     volatile load after the last volatile store in
>>>>>                     the constructor?)
>>>>>
>>>>>
>>>>>                     Alex
>>>>>
>>>>>
>>>>>                     On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>>>>>
>>>>>>                     I'm confident most code that publishes
>>>>>>                     objects shared across threads does it safely.
>>>>>>                     Otherwise we're saying majority of code uses
>>>>>>                     data races?
>>>>>>
>>>>>>                     Sent from my phone
>>>>>>
>>>>>>                     On Dec 3, 2013 12:21 PM, "Oleksandr Otenko"
>>>>>>                     <oleksandr.otenko at oracle.com
>>>>>>                     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>
>>>>>>                         Hmmm.... I thought it is clear no one
>>>>>>                         argues about the "/*if*/ you publish
>>>>>>                         safely" part. The question I am wondering
>>>>>>                         about is whether you can find a case
>>>>>>                         where publishing the reference to the
>>>>>>                         instance unsafely is /intended/.
>>>>>>
>>>>>>                         Alex
>>>>>>
>>>>>>                         On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>>>>>
>>>>>>>                         But this is only if you publish
>>>>>>>                         unsafely, as mentioned before.  If you
>>>>>>>                         publish this class properly, you don't
>>>>>>>                         get races on the volatile. Final fields
>>>>>>>                         are supposed to support immutable
>>>>>>>                         classes, where although not preferrable,
>>>>>>>                         publishing racily is plausible (for
>>>>>>>                         performance). For read/write volatiles,
>>>>>>>                         it's not compelling on the surface.
>>>>>>>
>>>>>>>                         Sent from my phone
>>>>>>>
>>>>>>>                         On Dec 3, 2013 11:18 AM, "Oleksandr
>>>>>>>                         Otenko" <oleksandr.otenko at oracle.com
>>>>>>>                         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>>
>>>>>>>                             Yes, but I mean that the code
>>>>>>>                             assumes the value to always be
>>>>>>>                             non-null - eg a sentinel entry of
>>>>>>>                             the list is created at construction
>>>>>>>                             time. Without the construction-time
>>>>>>>                             guarantee you'd need to test for
>>>>>>>                             null everywhere.
>>>>>>>
>>>>>>>                             I think the same applies in other
>>>>>>>                             constructors - if you write the
>>>>>>>                             initialization of the volatile, you
>>>>>>>                             imply that's "the least" "possible"
>>>>>>>                             value, the value representing the
>>>>>>>                             initial state of the concurrent
>>>>>>>                             algorithm - the initial value
>>>>>>>                             guaranteed by Java spec may not
>>>>>>>                             represent any valid state of the
>>>>>>>                             concurrent algorithm, let alone the
>>>>>>>                             initial state.
>>>>>>>
>>>>>>>                             That's why this really boils down to
>>>>>>>                             "find the broad cases where you do
>>>>>>>                             want to permit unsafe publication of
>>>>>>>                             the initial values of the volatiles".
>>>>>>>
>>>>>>>
>>>>>>>                             (unlike the non-volatile fields.
>>>>>>>                             Don't treat them as "not thread
>>>>>>>                             safe" - instead, treat them as
>>>>>>>                             "assume as made thread-safe by means
>>>>>>>                             outside the class specification",
>>>>>>>                             hence no requirement for "safe
>>>>>>>                             publication" there)
>>>>>>>
>>>>>>>
>>>>>>>                             Alex
>>>>>>>
>>>>>>>
>>>>>>>                             On 03/12/2013 15:08, Vitaly
>>>>>>>                             Davidovich wrote:
>>>>>>>>
>>>>>>>>                             Initial value of the field must be
>>>>>>>>                             the "zero" value of that type,
>>>>>>>>                             that's a language spec and must be
>>>>>>>>                             guaranteed irrespective of volatile
>>>>>>>>                             or not.
>>>>>>>>
>>>>>>>>                             Sent from my phone
>>>>>>>>
>>>>>>>>                             On Dec 3, 2013 10:03 AM, "Oleksandr
>>>>>>>>                             Otenko"
>>>>>>>>                             <oleksandr.otenko at oracle.com
>>>>>>>>                             <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>                             wrote:
>>>>>>>>
>>>>>>>>                                 I understand, but you can't
>>>>>>>>                                 insist on viewing ctors as
>>>>>>>>                                 "just methods" for all purposes.
>>>>>>>>
>>>>>>>>                                 (2) publication is unsafe
>>>>>>>>                                 unless you get a volatile load
>>>>>>>>                                 after the last volatile store
>>>>>>>>                                 in the constructor. Besides,
>>>>>>>>                                 the initial value of the field
>>>>>>>>                                 may not even be one of the
>>>>>>>>                                 valid values, so it is not even
>>>>>>>>                                 just about a data race.
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 Alex
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 On 03/12/2013 13:57, Vitaly
>>>>>>>>                                 Davidovich wrote:
>>>>>>>>>
>>>>>>>>>                                 For compilation/codegen
>>>>>>>>>                                 purposes ctors *are* just
>>>>>>>>>                                 methods - they can be inlined,
>>>>>>>>>                                 code optimized, etc; that's
>>>>>>>>>                                 the reason we have the final
>>>>>>>>>                                 field guarantees.
>>>>>>>>>
>>>>>>>>>                                 A couple of potential reasons
>>>>>>>>>                                 not to add volatile to the spec:
>>>>>>>>>                                 1) perhaps some JVMs don't
>>>>>>>>>                                 currently already give them
>>>>>>>>>                                 final field semantics
>>>>>>>>>                                 2) this whole thing comes into
>>>>>>>>>                                 play for unsafe publication
>>>>>>>>>                                 only (I.e. data race), which
>>>>>>>>>                                 is discouraged.
>>>>>>>>>
>>>>>>>>>                                 Sent from my phone
>>>>>>>>>
>>>>>>>>>                                 On Dec 3, 2013 6:51 AM,
>>>>>>>>>                                 "Oleksandr Otenko"
>>>>>>>>>                                 <oleksandr.otenko at oracle.com
>>>>>>>>>                                 <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>                                 wrote:
>>>>>>>>>
>>>>>>>>>                                     Constructors /are/ special
>>>>>>>>>                                     methods. They are the
>>>>>>>>>                                     first method calls in any
>>>>>>>>>                                     history of the object.
>>>>>>>>>                                     This means a different
>>>>>>>>>                                     treatment of volatile
>>>>>>>>>                                     accesses to the fields of
>>>>>>>>>                                     the instance being created
>>>>>>>>>                                     is possible - certain
>>>>>>>>>                                     barriers can be
>>>>>>>>>                                     eliminated, because the
>>>>>>>>>                                     loads can be proven to not
>>>>>>>>>                                     synchronize with anyone.
>>>>>>>>>                                     For the sake of the
>>>>>>>>>                                     argument, it is possible
>>>>>>>>>                                     to proceed with weak
>>>>>>>>>                                     treatment of volatile
>>>>>>>>>                                     stores, too, but you need
>>>>>>>>>                                     a good reason to permit
>>>>>>>>>                                     subsequent calls to
>>>>>>>>>                                     observe the initial state
>>>>>>>>>                                     of the volatile fields;
>>>>>>>>>                                     whereas any volatile load
>>>>>>>>>                                     in any other method always
>>>>>>>>>                                     synchronizes with a
>>>>>>>>>                                     volatile store of some
>>>>>>>>>                                     other method call, without
>>>>>>>>>                                     the final field semantics
>>>>>>>>>                                     we cannot assume that.
>>>>>>>>>
>>>>>>>>>                                     However, if we assume
>>>>>>>>>                                     final field semantics,
>>>>>>>>>                                     there is only one barrier
>>>>>>>>>                                     needed - a store-store
>>>>>>>>>                                     after the last volatile
>>>>>>>>>                                     field store. This
>>>>>>>>>                                     eliminates all barriers
>>>>>>>>>                                     for any other volatile
>>>>>>>>>                                     field initialization, and
>>>>>>>>>                                     eliminates a full barrier
>>>>>>>>>                                     needed otherwise (got to
>>>>>>>>>                                     place a dummy volatile
>>>>>>>>>                                     load after the last
>>>>>>>>>                                     volatile store to make
>>>>>>>>>                                     sure the semantics are
>>>>>>>>>                                     stronger than final-field)
>>>>>>>>>                                     - think of removing a
>>>>>>>>>                                     mfence or similar from
>>>>>>>>>                                     each such constructor on x86.
>>>>>>>>>
>>>>>>>>>                                     (there will still be
>>>>>>>>>                                     gotchas for cases when
>>>>>>>>>                                     volatile field
>>>>>>>>>                                     initialization occurs
>>>>>>>>>                                     after a volatile load of
>>>>>>>>>                                     something outside the same
>>>>>>>>>                                     instance; but the main
>>>>>>>>>                                     purpose is to eliminate
>>>>>>>>>                                     barriers when the volatile
>>>>>>>>>                                     fields are just
>>>>>>>>>                                     initialized into some
>>>>>>>>>                                     instance-specific values)
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     Alex
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     On 03/12/2013 05:54,
>>>>>>>>>                                     Ruslan Cheremin wrote:
>>>>>>>>>>                                     I'm about why "always
>>>>>>>>>>                                     mean storestore after
>>>>>>>>>>                                     volatile store in
>>>>>>>>>>                                     constructor". It is not
>>>>>>>>>>                                     only efficiency which is
>>>>>>>>>>                                     important for MM, but
>>>>>>>>>>                                     also simplicity and
>>>>>>>>>>                                     consistency. If
>>>>>>>>>>                                     constructors are special
>>>>>>>>>>                                     methods, not just plain
>>>>>>>>>>                                     <init>, then we should
>>>>>>>>>>                                     add this kind of
>>>>>>>>>>                                     atomicity to all
>>>>>>>>>>                                     constructors (which, as I
>>>>>>>>>>                                     was reading here, could
>>>>>>>>>>                                     be inefficient on some
>>>>>>>>>>                                     platforms). But if
>>>>>>>>>>                                     constructors are just
>>>>>>>>>>                                     plain methods, it looks
>>>>>>>>>>                                     strange to have special
>>>>>>>>>>                                     implicit semantics for
>>>>>>>>>>                                     constructors with
>>>>>>>>>>                                     volatiles inside.
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                     2013/12/3 Oleksandr
>>>>>>>>>>                                     Otenko
>>>>>>>>>>                                     <oleksandr.otenko at oracle.com
>>>>>>>>>>                                     <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>>
>>>>>>>>>>                                         I think it is pretty
>>>>>>>>>>                                         simple.
>>>>>>>>>>
>>>>>>>>>>                                         If you always mean a
>>>>>>>>>>                                         store-store barrier
>>>>>>>>>>                                         /after/ the last
>>>>>>>>>>                                         volatile store in the
>>>>>>>>>>                                         constructor, then add
>>>>>>>>>>                                         that barrier into
>>>>>>>>>>                                         constructor
>>>>>>>>>>                                         semantics, like it's
>>>>>>>>>>                                         done with the final
>>>>>>>>>>                                         fields.
>>>>>>>>>>
>>>>>>>>>>                                         It makes sense to
>>>>>>>>>>                                         /not/ add it to the
>>>>>>>>>>                                         semantics, if you can
>>>>>>>>>>                                         come up with enough
>>>>>>>>>>                                         examples where you
>>>>>>>>>>                                         want that barrier to
>>>>>>>>>>                                         be eliminated.
>>>>>>>>>>
>>>>>>>>>>                                         Alex
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         On 02/12/2013 19:32,
>>>>>>>>>>                                         Ruslan Cheremin wrote:
>>>>>>>>>>>                                         Well, I do not see
>>>>>>>>>>>                                         any data race _on
>>>>>>>>>>>                                         volatiles_ here. I
>>>>>>>>>>>                                         see race condition
>>>>>>>>>>>                                         on volatile .value,
>>>>>>>>>>>                                         yes -- but it is
>>>>>>>>>>>                                         pretty legal (and
>>>>>>>>>>>                                         unavoidable, I
>>>>>>>>>>>                                         suppose) to have
>>>>>>>>>>>                                         race conditions even
>>>>>>>>>>>                                         with volatiles
>>>>>>>>>>>                                         involved. The only
>>>>>>>>>>>                                         data race I see is
>>>>>>>>>>>                                         around read-write of
>>>>>>>>>>>                                         (non-volatile)
>>>>>>>>>>>                                         AtomicInteger's
>>>>>>>>>>>                                         reference -- which
>>>>>>>>>>>                                         is unrelated to
>>>>>>>>>>>                                         AtomicInteger's
>>>>>>>>>>>                                         content. I mean, I
>>>>>>>>>>>                                         could not see any
>>>>>>>>>>>                                         noticable difference
>>>>>>>>>>>                                         between the case
>>>>>>>>>>>                                         discussed, and just
>>>>>>>>>>>                                         any other case there
>>>>>>>>>>>                                         volatile is
>>>>>>>>>>>                                         _incorrectly_ used
>>>>>>>>>>>                                         to "synchronize"
>>>>>>>>>>>                                         data accesses -- it
>>>>>>>>>>>                                         could still be data
>>>>>>>>>>>                                         race on non-volatile
>>>>>>>>>>>                                         fields, even if
>>>>>>>>>>>                                         volatile fields are
>>>>>>>>>>>                                         also used somewhere
>>>>>>>>>>>                                         around. Yes, get 0
>>>>>>>>>>>                                         from .value is
>>>>>>>>>>>                                         unexpected -- but
>>>>>>>>>>>                                         there are many
>>>>>>>>>>>                                         unexpected things in
>>>>>>>>>>>                                         memory models. It is
>>>>>>>>>>>                                         noway more
>>>>>>>>>>>                                         unexpected then to
>>>>>>>>>>>                                         see default values
>>>>>>>>>>>                                         in fields of any
>>>>>>>>>>>                                         other object which
>>>>>>>>>>>                                         is unsafely
>>>>>>>>>>>                                         published. I think
>>>>>>>>>>>                                         everybody who passed
>>>>>>>>>>>                                         through broken
>>>>>>>>>>>                                         atomicity of
>>>>>>>>>>>                                         constructor call
>>>>>>>>>>>                                         could easy see the
>>>>>>>>>>>                                         chance to read
>>>>>>>>>>>                                         [.value=0] in the
>>>>>>>>>>>                                         case discussed.
>>>>>>>>>>>
>>>>>>>>>>>                                         "Data race is pure
>>>>>>>>>>>                                         evil" was the motto
>>>>>>>>>>>                                         of this list all
>>>>>>>>>>>                                         time I was reading
>>>>>>>>>>>                                         it. Why do we may
>>>>>>>>>>>                                         want to introduce
>>>>>>>>>>>                                         another example of
>>>>>>>>>>>                                         benign race?
>>>>>>>>>>>                                         Wouldn't it be just
>>>>>>>>>>>                                         another source of
>>>>>>>>>>>                                         confusion for newcomers?
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                         2013/12/2 Doug Lea
>>>>>>>>>>>                                         <dl at cs.oswego.edu
>>>>>>>>>>>                                         <mailto:dl at cs.oswego.edu>>
>>>>>>>>>>>
>>>>>>>>>>>                                             On 12/02/2013
>>>>>>>>>>>                                             03:57 AM,
>>>>>>>>>>>                                             Cheremin Ruslan
>>>>>>>>>>>                                             wrote:
>>>>>>>>>>>
>>>>>>>>>>>                                                 Doug, could
>>>>>>>>>>>                                                 you explain
>>>>>>>>>>>                                                 why it is so
>>>>>>>>>>>                                                 important to
>>>>>>>>>>>                                                 have this
>>>>>>>>>>>                                                 kind of safe
>>>>>>>>>>>                                                 publication
>>>>>>>>>>>                                                 for
>>>>>>>>>>>                                                 volatile? I
>>>>>>>>>>>                                                 mean, could
>>>>>>>>>>>                                                 we just go
>>>>>>>>>>>                                                 with
>>>>>>>>>>>                                                 .value=0
>>>>>>>>>>>                                                 through data
>>>>>>>>>>>                                                 race to be
>>>>>>>>>>>                                                 allowed
>>>>>>>>>>>                                                 result, as
>>>>>>>>>>>                                                 current
>>>>>>>>>>>                                                 model (seem
>>>>>>>>>>>                                                 to) imply?
>>>>>>>>>>>                                                 It seems to be a
>>>>>>>>>>>                                                 dr-case
>>>>>>>>>>>                                                 anyway, why
>>>>>>>>>>>                                                 we need
>>>>>>>>>>>                                                 special
>>>>>>>>>>>                                                 handling of it?
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                             The main reason
>>>>>>>>>>>                                             is that it is
>>>>>>>>>>>                                             highly irregular
>>>>>>>>>>>                                             and unexpected
>>>>>>>>>>>                                             by programmers.
>>>>>>>>>>>                                             Except in this
>>>>>>>>>>>                                             case, volatiles
>>>>>>>>>>>                                             definitionally
>>>>>>>>>>>                                             cannot
>>>>>>>>>>>                                             be subject to
>>>>>>>>>>>                                             data races.
>>>>>>>>>>>                                             Dealing with it
>>>>>>>>>>>                                             requires cleverness,
>>>>>>>>>>>                                             complexity,
>>>>>>>>>>>                                             and/or
>>>>>>>>>>>                                             error-proneness
>>>>>>>>>>>                                             that isn't even
>>>>>>>>>>>                                             required for
>>>>>>>>>>>                                             correctness on
>>>>>>>>>>>                                             current JVMs. We
>>>>>>>>>>>                                             have several
>>>>>>>>>>>                                             constructions
>>>>>>>>>>>                                             in j.u.c that
>>>>>>>>>>>                                             work around
>>>>>>>>>>>                                             problems by
>>>>>>>>>>>                                             using explicit
>>>>>>>>>>>                                             ordered
>>>>>>>>>>>                                             writes in
>>>>>>>>>>>                                             constructors,
>>>>>>>>>>>                                             redundant-looking null-checks,
>>>>>>>>>>>                                             and so
>>>>>>>>>>>                                             on. If we are
>>>>>>>>>>>                                             going to repair
>>>>>>>>>>>                                             the JMM anyway,
>>>>>>>>>>>                                             this is a clear
>>>>>>>>>>>                                             candidate for
>>>>>>>>>>>                                             reconsideration.
>>>>>>>>>>>
>>>>>>>>>>>                                             -Doug
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                                 Ruslan
>>>>>>>>>>>
>>>>>>>>>>>                                                     27 ????.
>>>>>>>>>>>                                                     2013 ?.,
>>>>>>>>>>>                                                     ? 23:26,
>>>>>>>>>>>                                                     Doug Lea
>>>>>>>>>>>                                                     <dl at cs.oswego.edu
>>>>>>>>>>>                                                     <mailto:dl at cs.oswego.edu>>
>>>>>>>>>>>                                                     ???????(?):
>>>>>>>>>>>
>>>>>>>>>>>                                                         On
>>>>>>>>>>>                                                         11/27/2013
>>>>>>>>>>>                                                         02:06 PM,
>>>>>>>>>>>                                                         Vitaly
>>>>>>>>>>>                                                         Davidovich
>>>>>>>>>>>                                                         wrote:
>>>>>>>>>>>                                                         But
>>>>>>>>>>>                                                         either
>>>>>>>>>>>                                                         way,
>>>>>>>>>>>                                                         optimizations
>>>>>>>>>>>                                                         to
>>>>>>>>>>>                                                         avoid zeroing
>>>>>>>>>>>                                                         memory
>>>>>>>>>>>                                                         is
>>>>>>>>>>>                                                         an
>>>>>>>>>>>                                                         implementation
>>>>>>>>>>>                                                         detail
>>>>>>>>>>>                                                         and
>>>>>>>>>>>                                                         thus
>>>>>>>>>>>                                                         cannot
>>>>>>>>>>>                                                         be
>>>>>>>>>>>                                                         relied
>>>>>>>>>>>                                                         upon
>>>>>>>>>>>                                                         from
>>>>>>>>>>>                                                         JMM
>>>>>>>>>>>                                                         standpoint,
>>>>>>>>>>>                                                         which I
>>>>>>>>>>>                                                         think you're
>>>>>>>>>>>                                                         saying.
>>>>>>>>>>>
>>>>>>>>>>>                                                         The
>>>>>>>>>>>                                                         other issue
>>>>>>>>>>>                                                         is
>>>>>>>>>>>                                                         that
>>>>>>>>>>>                                                         even
>>>>>>>>>>>                                                         if
>>>>>>>>>>>                                                         we
>>>>>>>>>>>                                                         determine
>>>>>>>>>>>                                                         that
>>>>>>>>>>>                                                         volatiles
>>>>>>>>>>>                                                         don't get
>>>>>>>>>>>                                                         this
>>>>>>>>>>>                                                         treatment,
>>>>>>>>>>>                                                         if
>>>>>>>>>>>                                                         JVM
>>>>>>>>>>>                                                         is
>>>>>>>>>>>                                                         already
>>>>>>>>>>>                                                         ensuring
>>>>>>>>>>>                                                         it,
>>>>>>>>>>>                                                         it's
>>>>>>>>>>>                                                         not
>>>>>>>>>>>                                                         going to
>>>>>>>>>>>                                                         be
>>>>>>>>>>>                                                         practical
>>>>>>>>>>>                                                         to
>>>>>>>>>>>                                                         change
>>>>>>>>>>>                                                         it
>>>>>>>>>>>                                                         and
>>>>>>>>>>>                                                         risk
>>>>>>>>>>>                                                         hard
>>>>>>>>>>>                                                         to
>>>>>>>>>>>                                                         debug problems
>>>>>>>>>>>                                                         creeping
>>>>>>>>>>>                                                         in.  May
>>>>>>>>>>>                                                         as
>>>>>>>>>>>                                                         well
>>>>>>>>>>>                                                         update
>>>>>>>>>>>                                                         the
>>>>>>>>>>>                                                         spec
>>>>>>>>>>>                                                         now ...
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                                     Right.
>>>>>>>>>>>                                                     To
>>>>>>>>>>>                                                     summarize:
>>>>>>>>>>>
>>>>>>>>>>>                                                     *
>>>>>>>>>>>                                                     Programmers
>>>>>>>>>>>                                                     do not
>>>>>>>>>>>                                                     expect
>>>>>>>>>>>                                                     that
>>>>>>>>>>>                                                     even
>>>>>>>>>>>                                                     though
>>>>>>>>>>>                                                     final
>>>>>>>>>>>                                                     fields
>>>>>>>>>>>                                                     are
>>>>>>>>>>>                                                     specifically
>>>>>>>>>>>                                                     publication-safe,
>>>>>>>>>>>                                                     volatile
>>>>>>>>>>>                                                     fields
>>>>>>>>>>>                                                     are not
>>>>>>>>>>>                                                     always so.
>>>>>>>>>>>
>>>>>>>>>>>                                                     * For
>>>>>>>>>>>                                                     various
>>>>>>>>>>>                                                     implementation
>>>>>>>>>>>                                                     reasons,
>>>>>>>>>>>                                                     JVMs
>>>>>>>>>>>                                                     arrange
>>>>>>>>>>>                                                     that
>>>>>>>>>>>                                                     volatile
>>>>>>>>>>>                                                     fields are
>>>>>>>>>>>                                                     publication
>>>>>>>>>>>                                                     safe
>>>>>>>>>>>                                                     anyway,
>>>>>>>>>>>                                                     at least
>>>>>>>>>>>                                                     in cases
>>>>>>>>>>>                                                     we know
>>>>>>>>>>>                                                     about.
>>>>>>>>>>>
>>>>>>>>>>>                                                     *
>>>>>>>>>>>                                                     Actually
>>>>>>>>>>>                                                     updating
>>>>>>>>>>>                                                     the
>>>>>>>>>>>                                                     JMM/JLS
>>>>>>>>>>>                                                     to
>>>>>>>>>>>                                                     mandate
>>>>>>>>>>>                                                     this is
>>>>>>>>>>>                                                     not easy
>>>>>>>>>>>                                                     (no
>>>>>>>>>>>                                                     small tweak
>>>>>>>>>>>                                                     that I
>>>>>>>>>>>                                                     know
>>>>>>>>>>>                                                     applies). But
>>>>>>>>>>>                                                     now is a
>>>>>>>>>>>                                                     good
>>>>>>>>>>>                                                     time to
>>>>>>>>>>>                                                     be
>>>>>>>>>>>                                                     considering
>>>>>>>>>>>                                                     a full
>>>>>>>>>>>                                                     revision
>>>>>>>>>>>                                                     for JDK9.
>>>>>>>>>>>
>>>>>>>>>>>                                                     * In the
>>>>>>>>>>>                                                     mean
>>>>>>>>>>>                                                     time, it
>>>>>>>>>>>                                                     would
>>>>>>>>>>>                                                     make
>>>>>>>>>>>                                                     sense to
>>>>>>>>>>>                                                     further
>>>>>>>>>>>                                                     test and
>>>>>>>>>>>                                                     validate
>>>>>>>>>>>                                                     JVMs
>>>>>>>>>>>                                                     as
>>>>>>>>>>>                                                     meeting
>>>>>>>>>>>                                                     this
>>>>>>>>>>>                                                     likely
>>>>>>>>>>>                                                     future spec.
>>>>>>>>>>>
>>>>>>>>>>>                                                     -Doug
>>>>>>>>>>>
>>>>>>>>>>>                                                     _______________________________________________
>>>>>>>>>>>                                                     Concurrency-interest
>>>>>>>>>>>                                                     mailing
>>>>>>>>>>>                                                     list
>>>>>>>>>>>                                                     Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>                                                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>                                                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                         _______________________________________________
>>>>>>>>>>>                                         Concurrency-interest mailing list
>>>>>>>>>>>                                         Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>                                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         _______________________________________________
>>>>>>>>>>                                         Concurrency-interest
>>>>>>>>>>                                         mailing list
>>>>>>>>>>                                         Concurrency-interest at cs.oswego.edu
>>>>>>>>>>                                         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>                                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     _______________________________________________
>>>>>>>>>                                     Concurrency-interest
>>>>>>>>>                                     mailing list
>>>>>>>>>                                     Concurrency-interest at cs.oswego.edu
>>>>>>>>>                                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>                                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>                             _______________________________________________
>>>>>>>                             Concurrency-interest mailing list
>>>>>>>                             Concurrency-interest at cs.oswego.edu
>>>>>>>                             <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>                             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>
>>>>>
>>>>
>>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/b6fdb433/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  3 16:00:32 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 16:00:32 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E4576.4070406@oracle.com>
References: <5295E24C.40608@oracle.com>
	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>
	<529DC489.2070205@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
	<529E297C.4070401@oracle.com>
	<CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>
	<529E3567.8020108@oracle.com>
	<CAHjP37GA9dQQd0Ds=zMCXTJMO4OHhr983MjcxUST07aSu6pi2A@mail.gmail.com>
	<529E4576.4070406@oracle.com>
Message-ID: <CAHjP37Ewhz_BUwoG2b3ZE0pUU2STd_+UH+XS3S_H4SPeZn51jQ@mail.gmail.com>

No, they don't have the storestore between ctor exit and assignment to a
field.  Volatile stores allow subsequent stores to reorder.

Sent from my phone
On Dec 3, 2013 3:56 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  What do you mean - new barriers?
>
> Store-store must occur after the last store preceding the volatile store
> in program order. If they didn't have it, they've got the bug to fix. If
> they do have the store-store, then they are correct w.r.t. what the spec
> says, and it is a matter of opinion of whether the spec needs fixing. I see
> the spec will be safer and better, if it gets fixed as proposed, but I see
> the point why people oppose it.
>
> Alex
>
> On 03/12/2013 20:18, Vitaly Davidovich wrote:
>
> Well, PPC guys didn't have the extra barriers for volatiles in
> constructors either (for storestore), as mentioned.  For them, this will be
> new barriers.  What does one tell them? Either we're "fixing" publishing or
> we're doing this because the cost is no greater - which is it for someone
> like PPC?
>
> Sent from my phone
> On Dec 3, 2013 2:48 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  This topic loops here.
>>
>> The other ctors don't have the barriers, so adding them costs.
>>
>> The ctors with volatiles already have the barriers, so order them in a
>> way that offers more safety. You already mentioned the circus with lazySet
>> that is needed otherwise. Since we all agree that's the safe way to do it,
>> and we don't advocate unsafe publishing, why not imply lazySet then.
>>
>> Alex
>>
>>
>> On 03/12/2013 19:21, Vitaly Davidovich wrote:
>>
>> So to play devil's advocate, why not make all ctors behave the same way?
>> Afterall, people may still publish classes with no final or volatile fields
>> unsafely, and run into problems.  One can argue that most people expect
>> that upon constructor exit, all memory ops are complete.  Why only add
>> volatile to the mix? So that concurrency authors can attempt at
>> safeguarding their class from unsafe publication by a user who doesn't know
>> any better? Is that really worth the overhead required? Said user can still
>> shoot themselves in other ways.  At some point, the burden should be on
>> devs to know the platform, its promises/guarantees, and available tools to
>> add their own extra guarantees.
>>
>> Again, we're talking about data race publishing here - this is not the
>> norm or encouraged practice.  Why bend over backwards to accommodate it?
>>
>> Sent from my phone
>> On Dec 3, 2013 1:57 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  You'd need load-store after loading externally observable values with
>>> or without the proposed changes, but we aren't eliminating those, are we? I
>>> thought you meant we need new barriers.
>>>
>>> Alex
>>>
>>> On 03/12/2013 18:51, Vitaly Davidovich wrote:
>>>
>>> You would - since volatile can be modified and read many times in ctor,
>>> you need to ensure all loads are done before the store and before ctor
>>> exits - you need to ensure value of the volatile is the final one at the
>>> end of the ctor sequence.  Otherwise, the loads can move after the store.
>>> Basically, you need lazySet() now and not plain storestore.
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 1:44 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>
>>>>  I don't think you'd need it in a constructor.
>>>>
>>>> You can't read the fields until the reference to the instance is
>>>> stored. If you can stop reordering that store with the last volatile store,
>>>> publication is safe.
>>>>
>>>> Alex
>>>>
>>>> On 03/12/2013 18:34, Vitaly Davidovich wrote:
>>>>
>>>> For volatiles, you'd need load-store as well though.
>>>>
>>>> Sent from my phone
>>>> On Dec 3, 2013 1:05 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>>> wrote:
>>>>
>>>>>  Sure.
>>>>>
>>>>> f=42;
>>>>>
>>>>> already imposes the cost of store-store barrier.
>>>>>
>>>>> f=42;
>>>>> f=42;
>>>>>
>>>>> does the same thing. In a constructor, eliminate the first barrier,
>>>>> because the order of writes to the unreachable instance is not important,
>>>>> and the second store. This no longer is the question of performance,
>>>>> because it is the same. It is the question of correctness for free.
>>>>>
>>>>> Alex
>>>>>
>>>>> On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>>>>
>>>>> Not sure that's the right view either.  The one thing the author does
>>>>> not control is how instances of their class are passed around.  User of the
>>>>> class has more context - it may actually be ok that volatiles aren't fenced
>>>>> here because they're already ensuring some way that it's fine, including
>>>>> the possibility that the instance isn't even shared at all.  As long as
>>>>> people know the behavior of the language/platform, they should be expected
>>>>> to make an educated decision on their own.
>>>>>
>>>>> Look, if performance didn't matter, you could just blindly say that
>>>>> all constructors have a freeze action, regardless of final fields or
>>>>> volatile.  That's not the case, of course.  Java and JDK have tools
>>>>> available to publish safely, so people doing multithreading have the
>>>>> ability to do the right thing.  At the end of the day, exposing concurrency
>>>>> to devs will lead to bugs, even beside the issues described here.
>>>>>
>>>>> Sent from my phone
>>>>> On Dec 3, 2013 12:42 PM, "Oleksandr Otenko" <
>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>
>>>>>>  No, this is a completely opposite view. The question is:
>>>>>>
>>>>>> do you as the implementor of the concurrent algorithm ever intend the
>>>>>> constructor design to be such that relies on the protocol that the caller
>>>>>> chooses to publish the reference?
>>>>>>
>>>>>> (Do you ever intend to *not* specify a no-op volatile load after the
>>>>>> last volatile store in the constructor?)
>>>>>>
>>>>>>
>>>>>> Alex
>>>>>>
>>>>>>
>>>>>> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>>>>>
>>>>>> I'm confident most code that publishes objects shared across threads
>>>>>> does it safely.  Otherwise we're saying majority of code uses data races?
>>>>>>
>>>>>> Sent from my phone
>>>>>> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <
>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>
>>>>>>>  Hmmm.... I thought it is clear no one argues about the "*if* you
>>>>>>> publish safely" part. The question I am wondering about is whether you can
>>>>>>> find a case where publishing the reference to the instance unsafely is
>>>>>>> *intended*.
>>>>>>>
>>>>>>> Alex
>>>>>>>
>>>>>>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>>>>>
>>>>>>> But this is only if you publish unsafely, as mentioned before.  If
>>>>>>> you publish this class properly, you don't get races on the volatile.
>>>>>>> Final fields are supposed to support immutable classes, where although not
>>>>>>> preferrable, publishing racily is plausible (for performance).  For
>>>>>>> read/write volatiles, it's not compelling on the surface.
>>>>>>>
>>>>>>> Sent from my phone
>>>>>>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <
>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>
>>>>>>>>  Yes, but I mean that the code assumes the value to always be
>>>>>>>> non-null - eg a sentinel entry of the list is created at construction time.
>>>>>>>> Without the construction-time guarantee you'd need to test for null
>>>>>>>> everywhere.
>>>>>>>>
>>>>>>>> I think the same applies in other constructors - if you write the
>>>>>>>> initialization of the volatile, you imply that's "the least" "possible"
>>>>>>>> value, the value representing the initial state of the concurrent algorithm
>>>>>>>> - the initial value guaranteed by Java spec may not represent any valid
>>>>>>>> state of the concurrent algorithm, let alone the initial state.
>>>>>>>>
>>>>>>>> That's why this really boils down to "find the broad cases where
>>>>>>>> you do want to permit unsafe publication of the initial values of the
>>>>>>>> volatiles".
>>>>>>>>
>>>>>>>>
>>>>>>>> (unlike the non-volatile fields. Don't treat them as "not thread
>>>>>>>> safe" - instead, treat them as "assume as made thread-safe by means outside
>>>>>>>> the class specification", hence no requirement for "safe publication" there)
>>>>>>>>
>>>>>>>>
>>>>>>>> Alex
>>>>>>>>
>>>>>>>>
>>>>>>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>>>>>
>>>>>>>> Initial value of the field must be the "zero" value of that type,
>>>>>>>> that's a language spec and must be guaranteed irrespective of volatile or
>>>>>>>> not.
>>>>>>>>
>>>>>>>> Sent from my phone
>>>>>>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <
>>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>>
>>>>>>>>>  I understand, but you can't insist on viewing ctors as "just
>>>>>>>>> methods" for all purposes.
>>>>>>>>>
>>>>>>>>> (2) publication is unsafe unless you get a volatile load after the
>>>>>>>>> last volatile store in the constructor. Besides, the initial value of the
>>>>>>>>> field may not even be one of the valid values, so it is not even just about
>>>>>>>>> a data race.
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> Alex
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>>>>>
>>>>>>>>> For compilation/codegen purposes ctors *are* just methods - they
>>>>>>>>> can be inlined, code optimized, etc; that's the reason we have the final
>>>>>>>>> field guarantees.
>>>>>>>>>
>>>>>>>>> A couple of potential reasons not to add volatile to the spec:
>>>>>>>>> 1) perhaps some JVMs don't currently already give them final field
>>>>>>>>> semantics
>>>>>>>>> 2) this whole thing comes into play for unsafe publication only
>>>>>>>>> (I.e. data race), which is discouraged.
>>>>>>>>>
>>>>>>>>> Sent from my phone
>>>>>>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <
>>>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>>>
>>>>>>>>>>  Constructors *are* special methods. They are the first method
>>>>>>>>>> calls in any history of the object. This means a different treatment of
>>>>>>>>>> volatile accesses to the fields of the instance being created is possible -
>>>>>>>>>> certain barriers can be eliminated, because the loads can be proven to not
>>>>>>>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>>>>>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>>>>>>>> reason to permit subsequent calls to observe the initial state of the
>>>>>>>>>> volatile fields; whereas any volatile load in any other method always
>>>>>>>>>> synchronizes with a volatile store of some other method call, without the
>>>>>>>>>> final field semantics we cannot assume that.
>>>>>>>>>>
>>>>>>>>>> However, if we assume final field semantics, there is only one
>>>>>>>>>> barrier needed - a store-store after the last volatile field store. This
>>>>>>>>>> eliminates all barriers for any other volatile field initialization, and
>>>>>>>>>> eliminates a full barrier needed otherwise (got to place a dummy volatile
>>>>>>>>>> load after the last volatile store to make sure the semantics are stronger
>>>>>>>>>> than final-field) - think of removing a mfence or similar from each such
>>>>>>>>>> constructor on x86.
>>>>>>>>>>
>>>>>>>>>> (there will still be gotchas for cases when volatile field
>>>>>>>>>> initialization occurs after a volatile load of something outside the same
>>>>>>>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>>>>>>>> fields are just initialized into some instance-specific values)
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> Alex
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>>>>>
>>>>>>>>>> I'm about why "always mean storestore after volatile store in
>>>>>>>>>> constructor". It is not only efficiency which is important for MM, but also
>>>>>>>>>> simplicity and consistency. If constructors are special methods, not just
>>>>>>>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>>>>>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>>>>>>>> if constructors are just plain methods, it looks strange to have special
>>>>>>>>>> implicit semantics for constructors with volatiles inside.
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>>>>>>>
>>>>>>>>>>>  I think it is pretty simple.
>>>>>>>>>>>
>>>>>>>>>>> If you always mean a store-store barrier *after* the last
>>>>>>>>>>> volatile store in the constructor, then add that barrier into constructor
>>>>>>>>>>> semantics, like it's done with the final fields.
>>>>>>>>>>>
>>>>>>>>>>> It makes sense to *not* add it to the semantics, if you can
>>>>>>>>>>> come up with enough examples where you want that barrier to be eliminated.
>>>>>>>>>>>
>>>>>>>>>>> Alex
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>>>>>>
>>>>>>>>>>> Well, I do not see any data race _on volatiles_ here. I see race
>>>>>>>>>>> condition on volatile .value, yes -- but it is pretty legal (and
>>>>>>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>>>>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>>>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>>>>>>>> I mean, I could not see any noticable difference between the case
>>>>>>>>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>>>>>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>>>>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>>>>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>>>>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>>>>>>>> any other object which is unsafely published. I think everybody who passed
>>>>>>>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>>>>>>>> read [.value=0] in the case discussed.
>>>>>>>>>>>
>>>>>>>>>>>  "Data race is pure evil" was the motto of this list all time I
>>>>>>>>>>> was reading it. Why do we may want to introduce another example of benign
>>>>>>>>>>> race? Wouldn't it be just another source of confusion for newcomers?
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>>>
>>>>>>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>>>>>>>
>>>>>>>>>>>>> Doug, could you explain why it is so important to have this
>>>>>>>>>>>>> kind of safe
>>>>>>>>>>>>> publication for volatile? I mean, could we just go with
>>>>>>>>>>>>> .value=0 through data
>>>>>>>>>>>>> race to be allowed result, as current model (seem to) imply?
>>>>>>>>>>>>> It seems to be a
>>>>>>>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>  The main reason is that it is highly irregular and unexpected
>>>>>>>>>>>> by programmers. Except in this case, volatiles definitionally
>>>>>>>>>>>> cannot
>>>>>>>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>>>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>>>>>>>> correctness on current JVMs. We have several constructions
>>>>>>>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>>>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>>>>>>>> candidate for reconsideration.
>>>>>>>>>>>>
>>>>>>>>>>>> -Doug
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>> Ruslan
>>>>>>>>>>>>>
>>>>>>>>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>>>>>> ???????(?):
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either
>>>>>>>>>>>>>>> way,
>>>>>>>>>>>>>>> optimizations to avoid zeroing memory is an implementation
>>>>>>>>>>>>>>> detail and
>>>>>>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I
>>>>>>>>>>>>>>> think you're
>>>>>>>>>>>>>>> saying.
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> The other issue is that even if we determine that volatiles
>>>>>>>>>>>>>>> don't get
>>>>>>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not
>>>>>>>>>>>>>>> going to be
>>>>>>>>>>>>>>> practical to change it and risk hard to debug problems
>>>>>>>>>>>>>>> creeping in.  May
>>>>>>>>>>>>>>> as well update the spec now ...
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> Right. To summarize:
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> * Programmers do not expect that even though final fields are
>>>>>>>>>>>>>> specifically
>>>>>>>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> * For various implementation reasons, JVMs arrange that
>>>>>>>>>>>>>> volatile fields are
>>>>>>>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy
>>>>>>>>>>>>>> (no small tweak
>>>>>>>>>>>>>> that I know applies). But now is a good time to be
>>>>>>>>>>>>>> considering a full
>>>>>>>>>>>>>> revision for JDK9.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>>>>>>>> validate JVMs
>>>>>>>>>>>>>> as meeting this likely future spec.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> -Doug
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>>> Concurrency-interest
>>>>>>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/36fd2805/attachment-0001.html>

From oleksandr.otenko at oracle.com  Tue Dec  3 16:02:08 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 21:02:08 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37Ewhz_BUwoG2b3ZE0pUU2STd_+UH+XS3S_H4SPeZn51jQ@mail.gmail.com>
References: <5295E24C.40608@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
	<529E297C.4070401@oracle.com>
	<CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>
	<529E3567.8020108@oracle.com>
	<CAHjP37GA9dQQd0Ds=zMCXTJMO4OHhr983MjcxUST07aSu6pi2A@mail.gmail.com>
	<529E4576.4070406@oracle.com>
	<CAHjP37Ewhz_BUwoG2b3ZE0pUU2STd_+UH+XS3S_H4SPeZn51jQ@mail.gm!
	ail.com>
Message-ID: <529E46D0.8080903@oracle.com>

Yes, they do allow the reorder, so the point here is to move the 
store-store barrier to after the volatile store - it is not doing 
anything before the volatile store anyway.

Alex

On 03/12/2013 21:00, Vitaly Davidovich wrote:
>
> No, they don't have the storestore between ctor exit and assignment to 
> a field.  Volatile stores allow subsequent stores to reorder.
>
> Sent from my phone
>
> On Dec 3, 2013 3:56 PM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     What do you mean - new barriers?
>
>     Store-store must occur after the last store preceding the volatile
>     store in program order. If they didn't have it, they've got the
>     bug to fix. If they do have the store-store, then they are correct
>     w.r.t. what the spec says, and it is a matter of opinion of
>     whether the spec needs fixing. I see the spec will be safer and
>     better, if it gets fixed as proposed, but I see the point why
>     people oppose it.
>
>     Alex
>
>     On 03/12/2013 20:18, Vitaly Davidovich wrote:
>>
>>     Well, PPC guys didn't have the extra barriers for volatiles in
>>     constructors either (for storestore), as mentioned.  For them,
>>     this will be new barriers. What does one tell them? Either we're
>>     "fixing" publishing or we're doing this because the cost is no
>>     greater - which is it for someone like PPC?
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 2:48 PM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         This topic loops here.
>>
>>         The other ctors don't have the barriers, so adding them costs.
>>
>>         The ctors with volatiles already have the barriers, so order
>>         them in a way that offers more safety. You already mentioned
>>         the circus with lazySet that is needed otherwise. Since we
>>         all agree that's the safe way to do it, and we don't advocate
>>         unsafe publishing, why not imply lazySet then.
>>
>>         Alex
>>
>>
>>         On 03/12/2013 19:21, Vitaly Davidovich wrote:
>>>
>>>         So to play devil's advocate, why not make all ctors behave
>>>         the same way? Afterall, people may still publish classes
>>>         with no final or volatile fields unsafely, and run into
>>>         problems.  One can argue that most people expect that upon
>>>         constructor exit, all memory ops are complete.  Why only add
>>>         volatile to the mix? So that concurrency authors can attempt
>>>         at safeguarding their class from unsafe publication by a
>>>         user who doesn't know any better? Is that really worth the
>>>         overhead required? Said user can still shoot themselves in
>>>         other ways.  At some point, the burden should be on devs to
>>>         know the platform, its promises/guarantees, and available
>>>         tools to add their own extra guarantees.
>>>
>>>         Again, we're talking about data race publishing here - this
>>>         is not the norm or encouraged practice.  Why bend over
>>>         backwards to accommodate it?
>>>
>>>         Sent from my phone
>>>
>>>         On Dec 3, 2013 1:57 PM, "Oleksandr Otenko"
>>>         <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>
>>>             You'd need load-store after loading externally
>>>             observable values with or without the proposed changes,
>>>             but we aren't eliminating those, are we? I thought you
>>>             meant we need new barriers.
>>>
>>>             Alex
>>>
>>>             On 03/12/2013 18:51, Vitaly Davidovich wrote:
>>>>
>>>>             You would - since volatile can be modified and read
>>>>             many times in ctor, you need to ensure all loads are
>>>>             done before the store and before ctor exits - you need
>>>>             to ensure value of the volatile is the final one at the
>>>>             end of the ctor sequence.  Otherwise, the loads can
>>>>             move after the store.  Basically, you need lazySet()
>>>>             now and not plain storestore.
>>>>
>>>>             Sent from my phone
>>>>
>>>>             On Dec 3, 2013 1:44 PM, "Oleksandr Otenko"
>>>>             <oleksandr.otenko at oracle.com
>>>>             <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>
>>>>                 I don't think you'd need it in a constructor.
>>>>
>>>>                 You can't read the fields until the reference to
>>>>                 the instance is stored. If you can stop reordering
>>>>                 that store with the last volatile store,
>>>>                 publication is safe.
>>>>
>>>>                 Alex
>>>>
>>>>                 On 03/12/2013 18:34, Vitaly Davidovich wrote:
>>>>>
>>>>>                 For volatiles, you'd need load-store as well though.
>>>>>
>>>>>                 Sent from my phone
>>>>>
>>>>>                 On Dec 3, 2013 1:05 PM, "Oleksandr Otenko"
>>>>>                 <oleksandr.otenko at oracle.com
>>>>>                 <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>
>>>>>                     Sure.
>>>>>
>>>>>                     f=42;
>>>>>
>>>>>                     already imposes the cost of store-store barrier.
>>>>>
>>>>>                     f=42;
>>>>>                     f=42;
>>>>>
>>>>>                     does the same thing. In a constructor,
>>>>>                     eliminate the first barrier, because the order
>>>>>                     of writes to the unreachable instance is not
>>>>>                     important, and the second store. This no
>>>>>                     longer is the question of performance, because
>>>>>                     it is the same. It is the question of
>>>>>                     correctness for free.
>>>>>
>>>>>                     Alex
>>>>>
>>>>>                     On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>>>>>
>>>>>>                     Not sure that's the right view either.  The
>>>>>>                     one thing the author does not control is how
>>>>>>                     instances of their class are passed around. 
>>>>>>                     User of the class has more context - it may
>>>>>>                     actually be ok that volatiles aren't fenced
>>>>>>                     here because they're already ensuring some
>>>>>>                     way that it's fine, including the possibility
>>>>>>                     that the instance isn't even shared at all. 
>>>>>>                     As long as people know the behavior of the
>>>>>>                     language/platform, they should be expected to
>>>>>>                     make an educated decision on their own.
>>>>>>
>>>>>>                     Look, if performance didn't matter, you could
>>>>>>                     just blindly say that all constructors have a
>>>>>>                     freeze action, regardless of final fields or
>>>>>>                     volatile. That's not the case, of course. 
>>>>>>                     Java and JDK have tools available to publish
>>>>>>                     safely, so people doing multithreading have
>>>>>>                     the ability to do the right thing.  At the
>>>>>>                     end of the day, exposing concurrency to devs
>>>>>>                     will lead to bugs, even beside the issues
>>>>>>                     described here.
>>>>>>
>>>>>>                     Sent from my phone
>>>>>>
>>>>>>                     On Dec 3, 2013 12:42 PM, "Oleksandr Otenko"
>>>>>>                     <oleksandr.otenko at oracle.com
>>>>>>                     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>
>>>>>>                         No, this is a completely opposite view.
>>>>>>                         The question is:
>>>>>>
>>>>>>                         do you as the implementor of the
>>>>>>                         concurrent algorithm ever intend the
>>>>>>                         constructor design to be such that relies
>>>>>>                         on the protocol that the caller chooses
>>>>>>                         to publish the reference?
>>>>>>
>>>>>>                         (Do you ever intend to /*not*/ specify a
>>>>>>                         no-op volatile load after the last
>>>>>>                         volatile store in the constructor?)
>>>>>>
>>>>>>
>>>>>>                         Alex
>>>>>>
>>>>>>
>>>>>>                         On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>>>>>>
>>>>>>>                         I'm confident most code that publishes
>>>>>>>                         objects shared across threads does it
>>>>>>>                         safely. Otherwise we're saying majority
>>>>>>>                         of code uses data races?
>>>>>>>
>>>>>>>                         Sent from my phone
>>>>>>>
>>>>>>>                         On Dec 3, 2013 12:21 PM, "Oleksandr
>>>>>>>                         Otenko" <oleksandr.otenko at oracle.com
>>>>>>>                         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>>
>>>>>>>                             Hmmm.... I thought it is clear no
>>>>>>>                             one argues about the "/*if*/ you
>>>>>>>                             publish safely" part. The question I
>>>>>>>                             am wondering about is whether you
>>>>>>>                             can find a case where publishing the
>>>>>>>                             reference to the instance unsafely
>>>>>>>                             is /intended/.
>>>>>>>
>>>>>>>                             Alex
>>>>>>>
>>>>>>>                             On 03/12/2013 17:14, Vitaly
>>>>>>>                             Davidovich wrote:
>>>>>>>>
>>>>>>>>                             But this is only if you publish
>>>>>>>>                             unsafely, as mentioned before.  If
>>>>>>>>                             you publish this class properly,
>>>>>>>>                             you don't get races on the
>>>>>>>>                             volatile. Final fields are supposed
>>>>>>>>                             to support immutable classes, where
>>>>>>>>                             although not preferrable,
>>>>>>>>                             publishing racily is plausible (for
>>>>>>>>                             performance). For read/write
>>>>>>>>                             volatiles, it's not compelling on
>>>>>>>>                             the surface.
>>>>>>>>
>>>>>>>>                             Sent from my phone
>>>>>>>>
>>>>>>>>                             On Dec 3, 2013 11:18 AM, "Oleksandr
>>>>>>>>                             Otenko"
>>>>>>>>                             <oleksandr.otenko at oracle.com
>>>>>>>>                             <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>                             wrote:
>>>>>>>>
>>>>>>>>                                 Yes, but I mean that the code
>>>>>>>>                                 assumes the value to always be
>>>>>>>>                                 non-null - eg a sentinel entry
>>>>>>>>                                 of the list is created at
>>>>>>>>                                 construction time. Without the
>>>>>>>>                                 construction-time guarantee
>>>>>>>>                                 you'd need to test for null
>>>>>>>>                                 everywhere.
>>>>>>>>
>>>>>>>>                                 I think the same applies in
>>>>>>>>                                 other constructors - if you
>>>>>>>>                                 write the initialization of the
>>>>>>>>                                 volatile, you imply that's "the
>>>>>>>>                                 least" "possible" value, the
>>>>>>>>                                 value representing the initial
>>>>>>>>                                 state of the concurrent
>>>>>>>>                                 algorithm - the initial value
>>>>>>>>                                 guaranteed by Java spec may not
>>>>>>>>                                 represent any valid state of
>>>>>>>>                                 the concurrent algorithm, let
>>>>>>>>                                 alone the initial state.
>>>>>>>>
>>>>>>>>                                 That's why this really boils
>>>>>>>>                                 down to "find the broad cases
>>>>>>>>                                 where you do want to permit
>>>>>>>>                                 unsafe publication of the
>>>>>>>>                                 initial values of the volatiles".
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 (unlike the non-volatile
>>>>>>>>                                 fields. Don't treat them as
>>>>>>>>                                 "not thread safe" - instead,
>>>>>>>>                                 treat them as "assume as made
>>>>>>>>                                 thread-safe by means outside
>>>>>>>>                                 the class specification", hence
>>>>>>>>                                 no requirement for "safe
>>>>>>>>                                 publication" there)
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 Alex
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 On 03/12/2013 15:08, Vitaly
>>>>>>>>                                 Davidovich wrote:
>>>>>>>>>
>>>>>>>>>                                 Initial value of the field
>>>>>>>>>                                 must be the "zero" value of
>>>>>>>>>                                 that type, that's a language
>>>>>>>>>                                 spec and must be guaranteed
>>>>>>>>>                                 irrespective of volatile or not.
>>>>>>>>>
>>>>>>>>>                                 Sent from my phone
>>>>>>>>>
>>>>>>>>>                                 On Dec 3, 2013 10:03 AM,
>>>>>>>>>                                 "Oleksandr Otenko"
>>>>>>>>>                                 <oleksandr.otenko at oracle.com
>>>>>>>>>                                 <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>                                 wrote:
>>>>>>>>>
>>>>>>>>>                                     I understand, but you
>>>>>>>>>                                     can't insist on viewing
>>>>>>>>>                                     ctors as "just methods"
>>>>>>>>>                                     for all purposes.
>>>>>>>>>
>>>>>>>>>                                     (2) publication is unsafe
>>>>>>>>>                                     unless you get a volatile
>>>>>>>>>                                     load after the last
>>>>>>>>>                                     volatile store in the
>>>>>>>>>                                     constructor. Besides, the
>>>>>>>>>                                     initial value of the field
>>>>>>>>>                                     may not even be one of the
>>>>>>>>>                                     valid values, so it is not
>>>>>>>>>                                     even just about a data race.
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     Alex
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     On 03/12/2013 13:57,
>>>>>>>>>                                     Vitaly Davidovich wrote:
>>>>>>>>>>
>>>>>>>>>>                                     For compilation/codegen
>>>>>>>>>>                                     purposes ctors *are* just
>>>>>>>>>>                                     methods - they can be
>>>>>>>>>>                                     inlined, code optimized,
>>>>>>>>>>                                     etc; that's the reason we
>>>>>>>>>>                                     have the final field
>>>>>>>>>>                                     guarantees.
>>>>>>>>>>
>>>>>>>>>>                                     A couple of potential
>>>>>>>>>>                                     reasons not to add
>>>>>>>>>>                                     volatile to the spec:
>>>>>>>>>>                                     1) perhaps some JVMs
>>>>>>>>>>                                     don't currently already
>>>>>>>>>>                                     give them final field
>>>>>>>>>>                                     semantics
>>>>>>>>>>                                     2) this whole thing comes
>>>>>>>>>>                                     into play for unsafe
>>>>>>>>>>                                     publication only (I.e.
>>>>>>>>>>                                     data race), which is
>>>>>>>>>>                                     discouraged.
>>>>>>>>>>
>>>>>>>>>>                                     Sent from my phone
>>>>>>>>>>
>>>>>>>>>>                                     On Dec 3, 2013 6:51 AM,
>>>>>>>>>>                                     "Oleksandr Otenko"
>>>>>>>>>>                                     <oleksandr.otenko at oracle.com
>>>>>>>>>>                                     <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>>                                     wrote:
>>>>>>>>>>
>>>>>>>>>>                                         Constructors /are/
>>>>>>>>>>                                         special methods. They
>>>>>>>>>>                                         are the first method
>>>>>>>>>>                                         calls in any history
>>>>>>>>>>                                         of the object. This
>>>>>>>>>>                                         means a different
>>>>>>>>>>                                         treatment of volatile
>>>>>>>>>>                                         accesses to the
>>>>>>>>>>                                         fields of the
>>>>>>>>>>                                         instance being
>>>>>>>>>>                                         created is possible -
>>>>>>>>>>                                         certain barriers can
>>>>>>>>>>                                         be eliminated,
>>>>>>>>>>                                         because the loads can
>>>>>>>>>>                                         be proven to not
>>>>>>>>>>                                         synchronize with
>>>>>>>>>>                                         anyone. For the sake
>>>>>>>>>>                                         of the argument, it
>>>>>>>>>>                                         is possible to
>>>>>>>>>>                                         proceed with weak
>>>>>>>>>>                                         treatment of volatile
>>>>>>>>>>                                         stores, too, but you
>>>>>>>>>>                                         need a good reason to
>>>>>>>>>>                                         permit subsequent
>>>>>>>>>>                                         calls to observe the
>>>>>>>>>>                                         initial state of the
>>>>>>>>>>                                         volatile fields;
>>>>>>>>>>                                         whereas any volatile
>>>>>>>>>>                                         load in any other
>>>>>>>>>>                                         method always
>>>>>>>>>>                                         synchronizes with a
>>>>>>>>>>                                         volatile store of
>>>>>>>>>>                                         some other method
>>>>>>>>>>                                         call, without the
>>>>>>>>>>                                         final field semantics
>>>>>>>>>>                                         we cannot assume that.
>>>>>>>>>>
>>>>>>>>>>                                         However, if we assume
>>>>>>>>>>                                         final field
>>>>>>>>>>                                         semantics, there is
>>>>>>>>>>                                         only one barrier
>>>>>>>>>>                                         needed - a
>>>>>>>>>>                                         store-store after the
>>>>>>>>>>                                         last volatile field
>>>>>>>>>>                                         store. This
>>>>>>>>>>                                         eliminates all
>>>>>>>>>>                                         barriers for any
>>>>>>>>>>                                         other volatile field
>>>>>>>>>>                                         initialization, and
>>>>>>>>>>                                         eliminates a full
>>>>>>>>>>                                         barrier needed
>>>>>>>>>>                                         otherwise (got to
>>>>>>>>>>                                         place a dummy
>>>>>>>>>>                                         volatile load after
>>>>>>>>>>                                         the last volatile
>>>>>>>>>>                                         store to make sure
>>>>>>>>>>                                         the semantics are
>>>>>>>>>>                                         stronger than
>>>>>>>>>>                                         final-field) - think
>>>>>>>>>>                                         of removing a mfence
>>>>>>>>>>                                         or similar from each
>>>>>>>>>>                                         such constructor on x86.
>>>>>>>>>>
>>>>>>>>>>                                         (there will still be
>>>>>>>>>>                                         gotchas for cases
>>>>>>>>>>                                         when volatile field
>>>>>>>>>>                                         initialization occurs
>>>>>>>>>>                                         after a volatile load
>>>>>>>>>>                                         of something outside
>>>>>>>>>>                                         the same instance;
>>>>>>>>>>                                         but the main purpose
>>>>>>>>>>                                         is to eliminate
>>>>>>>>>>                                         barriers when the
>>>>>>>>>>                                         volatile fields are
>>>>>>>>>>                                         just initialized into
>>>>>>>>>>                                         some
>>>>>>>>>>                                         instance-specific values)
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         Alex
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         On 03/12/2013 05:54,
>>>>>>>>>>                                         Ruslan Cheremin wrote:
>>>>>>>>>>>                                         I'm about why
>>>>>>>>>>>                                         "always mean
>>>>>>>>>>>                                         storestore after
>>>>>>>>>>>                                         volatile store in
>>>>>>>>>>>                                         constructor". It is
>>>>>>>>>>>                                         not only efficiency
>>>>>>>>>>>                                         which is important
>>>>>>>>>>>                                         for MM, but also
>>>>>>>>>>>                                         simplicity and
>>>>>>>>>>>                                         consistency. If
>>>>>>>>>>>                                         constructors are
>>>>>>>>>>>                                         special methods, not
>>>>>>>>>>>                                         just plain <init>,
>>>>>>>>>>>                                         then we should add
>>>>>>>>>>>                                         this kind of
>>>>>>>>>>>                                         atomicity to all
>>>>>>>>>>>                                         constructors (which,
>>>>>>>>>>>                                         as I was reading
>>>>>>>>>>>                                         here, could be
>>>>>>>>>>>                                         inefficient on some
>>>>>>>>>>>                                         platforms). But if
>>>>>>>>>>>                                         constructors are
>>>>>>>>>>>                                         just plain methods,
>>>>>>>>>>>                                         it looks strange to
>>>>>>>>>>>                                         have special
>>>>>>>>>>>                                         implicit semantics
>>>>>>>>>>>                                         for constructors
>>>>>>>>>>>                                         with volatiles inside.
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                         2013/12/3 Oleksandr
>>>>>>>>>>>                                         Otenko
>>>>>>>>>>>                                         <oleksandr.otenko at oracle.com
>>>>>>>>>>>                                         <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>>>
>>>>>>>>>>>                                             I think it is
>>>>>>>>>>>                                             pretty simple.
>>>>>>>>>>>
>>>>>>>>>>>                                             If you always
>>>>>>>>>>>                                             mean a
>>>>>>>>>>>                                             store-store
>>>>>>>>>>>                                             barrier /after/
>>>>>>>>>>>                                             the last
>>>>>>>>>>>                                             volatile store
>>>>>>>>>>>                                             in the
>>>>>>>>>>>                                             constructor,
>>>>>>>>>>>                                             then add that
>>>>>>>>>>>                                             barrier into
>>>>>>>>>>>                                             constructor
>>>>>>>>>>>                                             semantics, like
>>>>>>>>>>>                                             it's done with
>>>>>>>>>>>                                             the final fields.
>>>>>>>>>>>
>>>>>>>>>>>                                             It makes sense
>>>>>>>>>>>                                             to /not/ add it
>>>>>>>>>>>                                             to the
>>>>>>>>>>>                                             semantics, if
>>>>>>>>>>>                                             you can come up
>>>>>>>>>>>                                             with enough
>>>>>>>>>>>                                             examples where
>>>>>>>>>>>                                             you want that
>>>>>>>>>>>                                             barrier to be
>>>>>>>>>>>                                             eliminated.
>>>>>>>>>>>
>>>>>>>>>>>                                             Alex
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                             On 02/12/2013
>>>>>>>>>>>                                             19:32, Ruslan
>>>>>>>>>>>                                             Cheremin wrote:
>>>>>>>>>>>>                                             Well, I do not
>>>>>>>>>>>>                                             see any data
>>>>>>>>>>>>                                             race _on
>>>>>>>>>>>>                                             volatiles_
>>>>>>>>>>>>                                             here. I see
>>>>>>>>>>>>                                             race condition
>>>>>>>>>>>>                                             on volatile
>>>>>>>>>>>>                                             .value, yes --
>>>>>>>>>>>>                                             but it is
>>>>>>>>>>>>                                             pretty legal
>>>>>>>>>>>>                                             (and
>>>>>>>>>>>>                                             unavoidable, I
>>>>>>>>>>>>                                             suppose) to
>>>>>>>>>>>>                                             have race
>>>>>>>>>>>>                                             conditions even
>>>>>>>>>>>>                                             with volatiles
>>>>>>>>>>>>                                             involved. The
>>>>>>>>>>>>                                             only data race
>>>>>>>>>>>>                                             I see is around
>>>>>>>>>>>>                                             read-write of
>>>>>>>>>>>>                                             (non-volatile)
>>>>>>>>>>>>                                             AtomicInteger's
>>>>>>>>>>>>                                             reference --
>>>>>>>>>>>>                                             which is
>>>>>>>>>>>>                                             unrelated to
>>>>>>>>>>>>                                             AtomicInteger's
>>>>>>>>>>>>                                             content. I
>>>>>>>>>>>>                                             mean, I could
>>>>>>>>>>>>                                             not see any
>>>>>>>>>>>>                                             noticable
>>>>>>>>>>>>                                             difference
>>>>>>>>>>>>                                             between the
>>>>>>>>>>>>                                             case discussed,
>>>>>>>>>>>>                                             and just any
>>>>>>>>>>>>                                             other case
>>>>>>>>>>>>                                             there volatile
>>>>>>>>>>>>                                             is
>>>>>>>>>>>>                                             _incorrectly_
>>>>>>>>>>>>                                             used to
>>>>>>>>>>>>                                             "synchronize"
>>>>>>>>>>>>                                             data accesses
>>>>>>>>>>>>                                             -- it could
>>>>>>>>>>>>                                             still be data
>>>>>>>>>>>>                                             race on
>>>>>>>>>>>>                                             non-volatile
>>>>>>>>>>>>                                             fields, even if
>>>>>>>>>>>>                                             volatile fields
>>>>>>>>>>>>                                             are also used
>>>>>>>>>>>>                                             somewhere
>>>>>>>>>>>>                                             around. Yes,
>>>>>>>>>>>>                                             get 0 from
>>>>>>>>>>>>                                             .value is
>>>>>>>>>>>>                                             unexpected --
>>>>>>>>>>>>                                             but there are
>>>>>>>>>>>>                                             many unexpected
>>>>>>>>>>>>                                             things in
>>>>>>>>>>>>                                             memory models.
>>>>>>>>>>>>                                             It is noway
>>>>>>>>>>>>                                             more unexpected
>>>>>>>>>>>>                                             then to see
>>>>>>>>>>>>                                             default values
>>>>>>>>>>>>                                             in fields of
>>>>>>>>>>>>                                             any other
>>>>>>>>>>>>                                             object which is
>>>>>>>>>>>>                                             unsafely
>>>>>>>>>>>>                                             published. I
>>>>>>>>>>>>                                             think everybody
>>>>>>>>>>>>                                             who passed
>>>>>>>>>>>>                                             through broken
>>>>>>>>>>>>                                             atomicity of
>>>>>>>>>>>>                                             constructor
>>>>>>>>>>>>                                             call could easy
>>>>>>>>>>>>                                             see the chance
>>>>>>>>>>>>                                             to read
>>>>>>>>>>>>                                             [.value=0] in
>>>>>>>>>>>>                                             the case
>>>>>>>>>>>>                                             discussed.
>>>>>>>>>>>>
>>>>>>>>>>>>                                             "Data race is
>>>>>>>>>>>>                                             pure evil" was
>>>>>>>>>>>>                                             the motto of
>>>>>>>>>>>>                                             this list all
>>>>>>>>>>>>                                             time I was
>>>>>>>>>>>>                                             reading it. Why
>>>>>>>>>>>>                                             do we may want
>>>>>>>>>>>>                                             to introduce
>>>>>>>>>>>>                                             another example
>>>>>>>>>>>>                                             of benign race?
>>>>>>>>>>>>                                             Wouldn't it be
>>>>>>>>>>>>                                             just another
>>>>>>>>>>>>                                             source of
>>>>>>>>>>>>                                             confusion for
>>>>>>>>>>>>                                             newcomers?
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                             2013/12/2 Doug
>>>>>>>>>>>>                                             Lea
>>>>>>>>>>>>                                             <dl at cs.oswego.edu
>>>>>>>>>>>>                                             <mailto:dl at cs.oswego.edu>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 On
>>>>>>>>>>>>                                                 12/02/2013
>>>>>>>>>>>>                                                 03:57 AM,
>>>>>>>>>>>>                                                 Cheremin
>>>>>>>>>>>>                                                 Ruslan wrote:
>>>>>>>>>>>>
>>>>>>>>>>>>                                                     Doug,
>>>>>>>>>>>>                                                     could
>>>>>>>>>>>>                                                     you
>>>>>>>>>>>>                                                     explain
>>>>>>>>>>>>                                                     why it
>>>>>>>>>>>>                                                     is so
>>>>>>>>>>>>                                                     important
>>>>>>>>>>>>                                                     to have
>>>>>>>>>>>>                                                     this
>>>>>>>>>>>>                                                     kind of
>>>>>>>>>>>>                                                     safe
>>>>>>>>>>>>                                                     publication
>>>>>>>>>>>>                                                     for
>>>>>>>>>>>>                                                     volatile?
>>>>>>>>>>>>                                                     I mean,
>>>>>>>>>>>>                                                     could
>>>>>>>>>>>>                                                     we just
>>>>>>>>>>>>                                                     go with
>>>>>>>>>>>>                                                     .value=0 through
>>>>>>>>>>>>                                                     data
>>>>>>>>>>>>                                                     race to
>>>>>>>>>>>>                                                     be
>>>>>>>>>>>>                                                     allowed
>>>>>>>>>>>>                                                     result,
>>>>>>>>>>>>                                                     as
>>>>>>>>>>>>                                                     current
>>>>>>>>>>>>                                                     model
>>>>>>>>>>>>                                                     (seem
>>>>>>>>>>>>                                                     to)
>>>>>>>>>>>>                                                     imply?
>>>>>>>>>>>>                                                     It
>>>>>>>>>>>>                                                     seems
>>>>>>>>>>>>                                                     to be a
>>>>>>>>>>>>                                                     dr-case
>>>>>>>>>>>>                                                     anyway,
>>>>>>>>>>>>                                                     why we
>>>>>>>>>>>>                                                     need
>>>>>>>>>>>>                                                     special
>>>>>>>>>>>>                                                     handling of
>>>>>>>>>>>>                                                     it?
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 The main
>>>>>>>>>>>>                                                 reason is
>>>>>>>>>>>>                                                 that it is
>>>>>>>>>>>>                                                 highly
>>>>>>>>>>>>                                                 irregular
>>>>>>>>>>>>                                                 and unexpected
>>>>>>>>>>>>                                                 by
>>>>>>>>>>>>                                                 programmers. Except
>>>>>>>>>>>>                                                 in this
>>>>>>>>>>>>                                                 case,
>>>>>>>>>>>>                                                 volatiles
>>>>>>>>>>>>                                                 definitionally
>>>>>>>>>>>>                                                 cannot
>>>>>>>>>>>>                                                 be subject
>>>>>>>>>>>>                                                 to data
>>>>>>>>>>>>                                                 races.
>>>>>>>>>>>>                                                 Dealing
>>>>>>>>>>>>                                                 with it
>>>>>>>>>>>>                                                 requires
>>>>>>>>>>>>                                                 cleverness,
>>>>>>>>>>>>                                                 complexity,
>>>>>>>>>>>>                                                 and/or
>>>>>>>>>>>>                                                 error-proneness
>>>>>>>>>>>>                                                 that isn't
>>>>>>>>>>>>                                                 even
>>>>>>>>>>>>                                                 required for
>>>>>>>>>>>>                                                 correctness
>>>>>>>>>>>>                                                 on current
>>>>>>>>>>>>                                                 JVMs. We
>>>>>>>>>>>>                                                 have
>>>>>>>>>>>>                                                 several
>>>>>>>>>>>>                                                 constructions
>>>>>>>>>>>>                                                 in j.u.c
>>>>>>>>>>>>                                                 that work
>>>>>>>>>>>>                                                 around
>>>>>>>>>>>>                                                 problems by
>>>>>>>>>>>>                                                 using
>>>>>>>>>>>>                                                 explicit
>>>>>>>>>>>>                                                 ordered
>>>>>>>>>>>>                                                 writes in
>>>>>>>>>>>>                                                 constructors,
>>>>>>>>>>>>                                                 redundant-looking
>>>>>>>>>>>>                                                 null-checks, and
>>>>>>>>>>>>                                                 so
>>>>>>>>>>>>                                                 on. If we
>>>>>>>>>>>>                                                 are going
>>>>>>>>>>>>                                                 to repair
>>>>>>>>>>>>                                                 the JMM
>>>>>>>>>>>>                                                 anyway,
>>>>>>>>>>>>                                                 this is a clear
>>>>>>>>>>>>                                                 candidate
>>>>>>>>>>>>                                                 for
>>>>>>>>>>>>                                                 reconsideration.
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 -Doug
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                                     Ruslan
>>>>>>>>>>>>
>>>>>>>>>>>>                                                         27
>>>>>>>>>>>>                                                         ????.
>>>>>>>>>>>>                                                         2013 ?.,
>>>>>>>>>>>>                                                         ?
>>>>>>>>>>>>                                                         23:26,
>>>>>>>>>>>>                                                         Doug Lea
>>>>>>>>>>>>                                                         <dl at cs.oswego.edu
>>>>>>>>>>>>                                                         <mailto:dl at cs.oswego.edu>>
>>>>>>>>>>>>                                                         ???????(?):
>>>>>>>>>>>>
>>>>>>>>>>>>                                                             On
>>>>>>>>>>>>                                                             11/27/2013
>>>>>>>>>>>>                                                             02:06
>>>>>>>>>>>>                                                             PM,
>>>>>>>>>>>>                                                             Vitaly
>>>>>>>>>>>>                                                             Davidovich
>>>>>>>>>>>>                                                             wrote:
>>>>>>>>>>>>                                                             But
>>>>>>>>>>>>                                                             either
>>>>>>>>>>>>                                                             way,
>>>>>>>>>>>>                                                             optimizations
>>>>>>>>>>>>                                                             to
>>>>>>>>>>>>                                                             avoid
>>>>>>>>>>>>                                                             zeroing
>>>>>>>>>>>>                                                             memory
>>>>>>>>>>>>                                                             is
>>>>>>>>>>>>                                                             an
>>>>>>>>>>>>                                                             implementation
>>>>>>>>>>>>                                                             detail
>>>>>>>>>>>>                                                             and
>>>>>>>>>>>>                                                             thus
>>>>>>>>>>>>                                                             cannot
>>>>>>>>>>>>                                                             be
>>>>>>>>>>>>                                                             relied
>>>>>>>>>>>>                                                             upon
>>>>>>>>>>>>                                                             from
>>>>>>>>>>>>                                                             JMM
>>>>>>>>>>>>                                                             standpoint,
>>>>>>>>>>>>                                                             which
>>>>>>>>>>>>                                                             I
>>>>>>>>>>>>                                                             think
>>>>>>>>>>>>                                                             you're
>>>>>>>>>>>>                                                             saying.
>>>>>>>>>>>>
>>>>>>>>>>>>                                                             The
>>>>>>>>>>>>                                                             other
>>>>>>>>>>>>                                                             issue
>>>>>>>>>>>>                                                             is
>>>>>>>>>>>>                                                             that
>>>>>>>>>>>>                                                             even
>>>>>>>>>>>>                                                             if
>>>>>>>>>>>>                                                             we
>>>>>>>>>>>>                                                             determine
>>>>>>>>>>>>                                                             that
>>>>>>>>>>>>                                                             volatiles
>>>>>>>>>>>>                                                             don't
>>>>>>>>>>>>                                                             get
>>>>>>>>>>>>                                                             this
>>>>>>>>>>>>                                                             treatment,
>>>>>>>>>>>>                                                             if
>>>>>>>>>>>>                                                             JVM
>>>>>>>>>>>>                                                             is
>>>>>>>>>>>>                                                             already
>>>>>>>>>>>>                                                             ensuring
>>>>>>>>>>>>                                                             it,
>>>>>>>>>>>>                                                             it's
>>>>>>>>>>>>                                                             not
>>>>>>>>>>>>                                                             going
>>>>>>>>>>>>                                                             to
>>>>>>>>>>>>                                                             be
>>>>>>>>>>>>                                                             practical
>>>>>>>>>>>>                                                             to
>>>>>>>>>>>>                                                             change
>>>>>>>>>>>>                                                             it
>>>>>>>>>>>>                                                             and
>>>>>>>>>>>>                                                             risk
>>>>>>>>>>>>                                                             hard
>>>>>>>>>>>>                                                             to
>>>>>>>>>>>>                                                             debug
>>>>>>>>>>>>                                                             problems
>>>>>>>>>>>>                                                             creeping
>>>>>>>>>>>>                                                             in.
>>>>>>>>>>>>                                                              May
>>>>>>>>>>>>                                                             as
>>>>>>>>>>>>                                                             well
>>>>>>>>>>>>                                                             update
>>>>>>>>>>>>                                                             the
>>>>>>>>>>>>                                                             spec
>>>>>>>>>>>>                                                             now
>>>>>>>>>>>>                                                             ...
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                                         Right.
>>>>>>>>>>>>                                                         To
>>>>>>>>>>>>                                                         summarize:
>>>>>>>>>>>>
>>>>>>>>>>>>                                                         *
>>>>>>>>>>>>                                                         Programmers
>>>>>>>>>>>>                                                         do
>>>>>>>>>>>>                                                         not
>>>>>>>>>>>>                                                         expect
>>>>>>>>>>>>                                                         that even
>>>>>>>>>>>>                                                         though
>>>>>>>>>>>>                                                         final
>>>>>>>>>>>>                                                         fields
>>>>>>>>>>>>                                                         are
>>>>>>>>>>>>                                                         specifically
>>>>>>>>>>>>                                                         publication-safe,
>>>>>>>>>>>>                                                         volatile
>>>>>>>>>>>>                                                         fields
>>>>>>>>>>>>                                                         are
>>>>>>>>>>>>                                                         not
>>>>>>>>>>>>                                                         always
>>>>>>>>>>>>                                                         so.
>>>>>>>>>>>>
>>>>>>>>>>>>                                                         *
>>>>>>>>>>>>                                                         For
>>>>>>>>>>>>                                                         various
>>>>>>>>>>>>                                                         implementation
>>>>>>>>>>>>                                                         reasons,
>>>>>>>>>>>>                                                         JVMs arrange
>>>>>>>>>>>>                                                         that volatile
>>>>>>>>>>>>                                                         fields
>>>>>>>>>>>>                                                         are
>>>>>>>>>>>>                                                         publication
>>>>>>>>>>>>                                                         safe anyway,
>>>>>>>>>>>>                                                         at
>>>>>>>>>>>>                                                         least
>>>>>>>>>>>>                                                         in
>>>>>>>>>>>>                                                         cases
>>>>>>>>>>>>                                                         we
>>>>>>>>>>>>                                                         know about.
>>>>>>>>>>>>
>>>>>>>>>>>>                                                         *
>>>>>>>>>>>>                                                         Actually
>>>>>>>>>>>>                                                         updating
>>>>>>>>>>>>                                                         the
>>>>>>>>>>>>                                                         JMM/JLS
>>>>>>>>>>>>                                                         to
>>>>>>>>>>>>                                                         mandate
>>>>>>>>>>>>                                                         this is
>>>>>>>>>>>>                                                         not
>>>>>>>>>>>>                                                         easy (no
>>>>>>>>>>>>                                                         small
>>>>>>>>>>>>                                                         tweak
>>>>>>>>>>>>                                                         that I
>>>>>>>>>>>>                                                         know applies).
>>>>>>>>>>>>                                                         But
>>>>>>>>>>>>                                                         now
>>>>>>>>>>>>                                                         is
>>>>>>>>>>>>                                                         a
>>>>>>>>>>>>                                                         good time
>>>>>>>>>>>>                                                         to
>>>>>>>>>>>>                                                         be
>>>>>>>>>>>>                                                         considering
>>>>>>>>>>>>                                                         a full
>>>>>>>>>>>>                                                         revision
>>>>>>>>>>>>                                                         for
>>>>>>>>>>>>                                                         JDK9.
>>>>>>>>>>>>
>>>>>>>>>>>>                                                         *
>>>>>>>>>>>>                                                         In
>>>>>>>>>>>>                                                         the
>>>>>>>>>>>>                                                         mean time,
>>>>>>>>>>>>                                                         it
>>>>>>>>>>>>                                                         would
>>>>>>>>>>>>                                                         make sense
>>>>>>>>>>>>                                                         to
>>>>>>>>>>>>                                                         further
>>>>>>>>>>>>                                                         test and
>>>>>>>>>>>>                                                         validate
>>>>>>>>>>>>                                                         JVMs
>>>>>>>>>>>>                                                         as
>>>>>>>>>>>>                                                         meeting
>>>>>>>>>>>>                                                         this likely
>>>>>>>>>>>>                                                         future
>>>>>>>>>>>>                                                         spec.
>>>>>>>>>>>>
>>>>>>>>>>>>                                                         -Doug
>>>>>>>>>>>>
>>>>>>>>>>>>                                                         _______________________________________________
>>>>>>>>>>>>                                                         Concurrency-interest
>>>>>>>>>>>>                                                         mailing
>>>>>>>>>>>>                                                         list Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>>                                                         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>>                                                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                             _______________________________________________
>>>>>>>>>>>>                                             Concurrency-interest mailing list
>>>>>>>>>>>>                                             Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>>                                             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                             _______________________________________________
>>>>>>>>>>>                                             Concurrency-interest
>>>>>>>>>>>                                             mailing list
>>>>>>>>>>>                                             Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>                                             <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>                                             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         _______________________________________________
>>>>>>>>>>                                         Concurrency-interest
>>>>>>>>>>                                         mailing list
>>>>>>>>>>                                         Concurrency-interest at cs.oswego.edu
>>>>>>>>>>                                         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>                                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 _______________________________________________
>>>>>>>>                                 Concurrency-interest mailing list
>>>>>>>>                                 Concurrency-interest at cs.oswego.edu
>>>>>>>>                                 <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>                                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>>
>>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/86386a43/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  3 16:15:08 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 16:15:08 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E46D0.8080903@oracle.com>
References: <5295E24C.40608@oracle.com>
	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>
	<529DF29E.6070702@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
	<529E297C.4070401@oracle.com>
	<CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>
	<529E3567.8020108@oracle.com>
	<CAHjP37GA9dQQd0Ds=zMCXTJMO4OHhr983MjcxUST07aSu6pi2A@mail.gmail.com>
	<529E4576.4070406@oracle.com>
	<CAHjP37Ewhz_BUwoG2b3ZE0pUU2STd_+UH+XS3S_H4SPeZn51jQ@mail.gmail.com>
	<529E46D0.8080903@oracle.com>
Message-ID: <CAHjP37Gh95ZyOBxmfoJoNCru+=WtbpUNw+eDSJw2-Mt-gPTDYA@mail.gmail.com>

My point is this storestore doesn't exist on PPC today because there's no
need based on spec.  There will be a need if spec is updated - this is a
new barrier as it's not there otherwise; compiler or cpu is free to move
assignment of ref before the volatile store, and now you need to preclude
that.  If you had a volatile store with no subsequent volatile load or
store, then no barrier is technically needed.  In practice, at least
hotspot, always emits a fence after volatile store, but that need not be
the case for others.

Sent from my phone
On Dec 3, 2013 4:02 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  Yes, they do allow the reorder, so the point here is to move the
> store-store barrier to after the volatile store - it is not doing anything
> before the volatile store anyway.
>
> Alex
>
> On 03/12/2013 21:00, Vitaly Davidovich wrote:
>
> No, they don't have the storestore between ctor exit and assignment to a
> field.  Volatile stores allow subsequent stores to reorder.
>
> Sent from my phone
> On Dec 3, 2013 3:56 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  What do you mean - new barriers?
>>
>> Store-store must occur after the last store preceding the volatile store
>> in program order. If they didn't have it, they've got the bug to fix. If
>> they do have the store-store, then they are correct w.r.t. what the spec
>> says, and it is a matter of opinion of whether the spec needs fixing. I see
>> the spec will be safer and better, if it gets fixed as proposed, but I see
>> the point why people oppose it.
>>
>> Alex
>>
>> On 03/12/2013 20:18, Vitaly Davidovich wrote:
>>
>> Well, PPC guys didn't have the extra barriers for volatiles in
>> constructors either (for storestore), as mentioned.  For them, this will be
>> new barriers.  What does one tell them? Either we're "fixing" publishing or
>> we're doing this because the cost is no greater - which is it for someone
>> like PPC?
>>
>> Sent from my phone
>> On Dec 3, 2013 2:48 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  This topic loops here.
>>>
>>> The other ctors don't have the barriers, so adding them costs.
>>>
>>> The ctors with volatiles already have the barriers, so order them in a
>>> way that offers more safety. You already mentioned the circus with lazySet
>>> that is needed otherwise. Since we all agree that's the safe way to do it,
>>> and we don't advocate unsafe publishing, why not imply lazySet then.
>>>
>>> Alex
>>>
>>>
>>> On 03/12/2013 19:21, Vitaly Davidovich wrote:
>>>
>>> So to play devil's advocate, why not make all ctors behave the same way?
>>> Afterall, people may still publish classes with no final or volatile fields
>>> unsafely, and run into problems.  One can argue that most people expect
>>> that upon constructor exit, all memory ops are complete.  Why only add
>>> volatile to the mix? So that concurrency authors can attempt at
>>> safeguarding their class from unsafe publication by a user who doesn't know
>>> any better? Is that really worth the overhead required? Said user can still
>>> shoot themselves in other ways.  At some point, the burden should be on
>>> devs to know the platform, its promises/guarantees, and available tools to
>>> add their own extra guarantees.
>>>
>>> Again, we're talking about data race publishing here - this is not the
>>> norm or encouraged practice.  Why bend over backwards to accommodate it?
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 1:57 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>
>>>>  You'd need load-store after loading externally observable values with
>>>> or without the proposed changes, but we aren't eliminating those, are we? I
>>>> thought you meant we need new barriers.
>>>>
>>>> Alex
>>>>
>>>> On 03/12/2013 18:51, Vitaly Davidovich wrote:
>>>>
>>>> You would - since volatile can be modified and read many times in ctor,
>>>> you need to ensure all loads are done before the store and before ctor
>>>> exits - you need to ensure value of the volatile is the final one at the
>>>> end of the ctor sequence.  Otherwise, the loads can move after the store.
>>>> Basically, you need lazySet() now and not plain storestore.
>>>>
>>>> Sent from my phone
>>>> On Dec 3, 2013 1:44 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>>> wrote:
>>>>
>>>>>  I don't think you'd need it in a constructor.
>>>>>
>>>>> You can't read the fields until the reference to the instance is
>>>>> stored. If you can stop reordering that store with the last volatile store,
>>>>> publication is safe.
>>>>>
>>>>> Alex
>>>>>
>>>>> On 03/12/2013 18:34, Vitaly Davidovich wrote:
>>>>>
>>>>> For volatiles, you'd need load-store as well though.
>>>>>
>>>>> Sent from my phone
>>>>> On Dec 3, 2013 1:05 PM, "Oleksandr Otenko" <
>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>
>>>>>>  Sure.
>>>>>>
>>>>>> f=42;
>>>>>>
>>>>>> already imposes the cost of store-store barrier.
>>>>>>
>>>>>> f=42;
>>>>>> f=42;
>>>>>>
>>>>>> does the same thing. In a constructor, eliminate the first barrier,
>>>>>> because the order of writes to the unreachable instance is not important,
>>>>>> and the second store. This no longer is the question of performance,
>>>>>> because it is the same. It is the question of correctness for free.
>>>>>>
>>>>>> Alex
>>>>>>
>>>>>> On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>>>>>
>>>>>> Not sure that's the right view either.  The one thing the author does
>>>>>> not control is how instances of their class are passed around.  User of the
>>>>>> class has more context - it may actually be ok that volatiles aren't fenced
>>>>>> here because they're already ensuring some way that it's fine, including
>>>>>> the possibility that the instance isn't even shared at all.  As long as
>>>>>> people know the behavior of the language/platform, they should be expected
>>>>>> to make an educated decision on their own.
>>>>>>
>>>>>> Look, if performance didn't matter, you could just blindly say that
>>>>>> all constructors have a freeze action, regardless of final fields or
>>>>>> volatile.  That's not the case, of course.  Java and JDK have tools
>>>>>> available to publish safely, so people doing multithreading have the
>>>>>> ability to do the right thing.  At the end of the day, exposing concurrency
>>>>>> to devs will lead to bugs, even beside the issues described here.
>>>>>>
>>>>>> Sent from my phone
>>>>>> On Dec 3, 2013 12:42 PM, "Oleksandr Otenko" <
>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>
>>>>>>>  No, this is a completely opposite view. The question is:
>>>>>>>
>>>>>>> do you as the implementor of the concurrent algorithm ever intend
>>>>>>> the constructor design to be such that relies on the protocol that the
>>>>>>> caller chooses to publish the reference?
>>>>>>>
>>>>>>> (Do you ever intend to *not* specify a no-op volatile load after
>>>>>>> the last volatile store in the constructor?)
>>>>>>>
>>>>>>>
>>>>>>> Alex
>>>>>>>
>>>>>>>
>>>>>>> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>>>>>>
>>>>>>> I'm confident most code that publishes objects shared across threads
>>>>>>> does it safely.  Otherwise we're saying majority of code uses data races?
>>>>>>>
>>>>>>> Sent from my phone
>>>>>>> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <
>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>
>>>>>>>>  Hmmm.... I thought it is clear no one argues about the "*if* you
>>>>>>>> publish safely" part. The question I am wondering about is whether you can
>>>>>>>> find a case where publishing the reference to the instance unsafely is
>>>>>>>> *intended*.
>>>>>>>>
>>>>>>>> Alex
>>>>>>>>
>>>>>>>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>>>>>>
>>>>>>>> But this is only if you publish unsafely, as mentioned before.  If
>>>>>>>> you publish this class properly, you don't get races on the volatile.
>>>>>>>> Final fields are supposed to support immutable classes, where although not
>>>>>>>> preferrable, publishing racily is plausible (for performance).  For
>>>>>>>> read/write volatiles, it's not compelling on the surface.
>>>>>>>>
>>>>>>>> Sent from my phone
>>>>>>>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <
>>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>>
>>>>>>>>>  Yes, but I mean that the code assumes the value to always be
>>>>>>>>> non-null - eg a sentinel entry of the list is created at construction time.
>>>>>>>>> Without the construction-time guarantee you'd need to test for null
>>>>>>>>> everywhere.
>>>>>>>>>
>>>>>>>>> I think the same applies in other constructors - if you write the
>>>>>>>>> initialization of the volatile, you imply that's "the least" "possible"
>>>>>>>>> value, the value representing the initial state of the concurrent algorithm
>>>>>>>>> - the initial value guaranteed by Java spec may not represent any valid
>>>>>>>>> state of the concurrent algorithm, let alone the initial state.
>>>>>>>>>
>>>>>>>>> That's why this really boils down to "find the broad cases where
>>>>>>>>> you do want to permit unsafe publication of the initial values of the
>>>>>>>>> volatiles".
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> (unlike the non-volatile fields. Don't treat them as "not thread
>>>>>>>>> safe" - instead, treat them as "assume as made thread-safe by means outside
>>>>>>>>> the class specification", hence no requirement for "safe publication" there)
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> Alex
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>>>>>>
>>>>>>>>> Initial value of the field must be the "zero" value of that type,
>>>>>>>>> that's a language spec and must be guaranteed irrespective of volatile or
>>>>>>>>> not.
>>>>>>>>>
>>>>>>>>> Sent from my phone
>>>>>>>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <
>>>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>>>
>>>>>>>>>>  I understand, but you can't insist on viewing ctors as "just
>>>>>>>>>> methods" for all purposes.
>>>>>>>>>>
>>>>>>>>>> (2) publication is unsafe unless you get a volatile load after
>>>>>>>>>> the last volatile store in the constructor. Besides, the initial value of
>>>>>>>>>> the field may not even be one of the valid values, so it is not even just
>>>>>>>>>> about a data race.
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> Alex
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>>>>>>
>>>>>>>>>> For compilation/codegen purposes ctors *are* just methods - they
>>>>>>>>>> can be inlined, code optimized, etc; that's the reason we have the final
>>>>>>>>>> field guarantees.
>>>>>>>>>>
>>>>>>>>>> A couple of potential reasons not to add volatile to the spec:
>>>>>>>>>> 1) perhaps some JVMs don't currently already give them final
>>>>>>>>>> field semantics
>>>>>>>>>> 2) this whole thing comes into play for unsafe publication only
>>>>>>>>>> (I.e. data race), which is discouraged.
>>>>>>>>>>
>>>>>>>>>> Sent from my phone
>>>>>>>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <
>>>>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>>>>
>>>>>>>>>>>  Constructors *are* special methods. They are the first method
>>>>>>>>>>> calls in any history of the object. This means a different treatment of
>>>>>>>>>>> volatile accesses to the fields of the instance being created is possible -
>>>>>>>>>>> certain barriers can be eliminated, because the loads can be proven to not
>>>>>>>>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>>>>>>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>>>>>>>>> reason to permit subsequent calls to observe the initial state of the
>>>>>>>>>>> volatile fields; whereas any volatile load in any other method always
>>>>>>>>>>> synchronizes with a volatile store of some other method call, without the
>>>>>>>>>>> final field semantics we cannot assume that.
>>>>>>>>>>>
>>>>>>>>>>> However, if we assume final field semantics, there is only one
>>>>>>>>>>> barrier needed - a store-store after the last volatile field store. This
>>>>>>>>>>> eliminates all barriers for any other volatile field initialization, and
>>>>>>>>>>> eliminates a full barrier needed otherwise (got to place a dummy volatile
>>>>>>>>>>> load after the last volatile store to make sure the semantics are stronger
>>>>>>>>>>> than final-field) - think of removing a mfence or similar from each such
>>>>>>>>>>> constructor on x86.
>>>>>>>>>>>
>>>>>>>>>>> (there will still be gotchas for cases when volatile field
>>>>>>>>>>> initialization occurs after a volatile load of something outside the same
>>>>>>>>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>>>>>>>>> fields are just initialized into some instance-specific values)
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> Alex
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>>>>>>
>>>>>>>>>>> I'm about why "always mean storestore after volatile store in
>>>>>>>>>>> constructor". It is not only efficiency which is important for MM, but also
>>>>>>>>>>> simplicity and consistency. If constructors are special methods, not just
>>>>>>>>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>>>>>>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>>>>>>>>> if constructors are just plain methods, it looks strange to have special
>>>>>>>>>>> implicit semantics for constructors with volatiles inside.
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>>>>>>>>
>>>>>>>>>>>>  I think it is pretty simple.
>>>>>>>>>>>>
>>>>>>>>>>>> If you always mean a store-store barrier *after* the last
>>>>>>>>>>>> volatile store in the constructor, then add that barrier into constructor
>>>>>>>>>>>> semantics, like it's done with the final fields.
>>>>>>>>>>>>
>>>>>>>>>>>> It makes sense to *not* add it to the semantics, if you can
>>>>>>>>>>>> come up with enough examples where you want that barrier to be eliminated.
>>>>>>>>>>>>
>>>>>>>>>>>> Alex
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>>>>>>>
>>>>>>>>>>>> Well, I do not see any data race _on volatiles_ here. I see
>>>>>>>>>>>> race condition on volatile .value, yes -- but it is pretty legal (and
>>>>>>>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>>>>>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>>>>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>>>>>>>>> I mean, I could not see any noticable difference between the case
>>>>>>>>>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>>>>>>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>>>>>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>>>>>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>>>>>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>>>>>>>>> any other object which is unsafely published. I think everybody who passed
>>>>>>>>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>>>>>>>>> read [.value=0] in the case discussed.
>>>>>>>>>>>>
>>>>>>>>>>>>  "Data race is pure evil" was the motto of this list all time
>>>>>>>>>>>> I was reading it. Why do we may want to introduce another example of benign
>>>>>>>>>>>> race? Wouldn't it be just another source of confusion for newcomers?
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>>>>
>>>>>>>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>>>>>>>>
>>>>>>>>>>>>>> Doug, could you explain why it is so important to have this
>>>>>>>>>>>>>> kind of safe
>>>>>>>>>>>>>> publication for volatile? I mean, could we just go with
>>>>>>>>>>>>>> .value=0 through data
>>>>>>>>>>>>>> race to be allowed result, as current model (seem to) imply?
>>>>>>>>>>>>>> It seems to be a
>>>>>>>>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>  The main reason is that it is highly irregular and unexpected
>>>>>>>>>>>>> by programmers. Except in this case, volatiles definitionally
>>>>>>>>>>>>> cannot
>>>>>>>>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>>>>>>>>> complexity, and/or error-proneness that isn't even required for
>>>>>>>>>>>>> correctness on current JVMs. We have several constructions
>>>>>>>>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>>>>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>>>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>>>>>>>>> candidate for reconsideration.
>>>>>>>>>>>>>
>>>>>>>>>>>>> -Doug
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>> Ruslan
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>>>>>>> ???????(?):
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But either
>>>>>>>>>>>>>>>> way,
>>>>>>>>>>>>>>>> optimizations to avoid zeroing memory is an implementation
>>>>>>>>>>>>>>>> detail and
>>>>>>>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I
>>>>>>>>>>>>>>>> think you're
>>>>>>>>>>>>>>>> saying.
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> The other issue is that even if we determine that volatiles
>>>>>>>>>>>>>>>> don't get
>>>>>>>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not
>>>>>>>>>>>>>>>> going to be
>>>>>>>>>>>>>>>> practical to change it and risk hard to debug problems
>>>>>>>>>>>>>>>> creeping in.  May
>>>>>>>>>>>>>>>> as well update the spec now ...
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> Right. To summarize:
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> * Programmers do not expect that even though final fields
>>>>>>>>>>>>>>> are specifically
>>>>>>>>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> * For various implementation reasons, JVMs arrange that
>>>>>>>>>>>>>>> volatile fields are
>>>>>>>>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy
>>>>>>>>>>>>>>> (no small tweak
>>>>>>>>>>>>>>> that I know applies). But now is a good time to be
>>>>>>>>>>>>>>> considering a full
>>>>>>>>>>>>>>> revision for JDK9.
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>>>>>>>>> validate JVMs
>>>>>>>>>>>>>>> as meeting this likely future spec.
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> -Doug
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>>>> Concurrency-interest
>>>>>>>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/5af56ab8/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  3 16:30:56 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 16:30:56 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD23D5107EB@G9W0725.americas.hpqcorp.net>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D5107EB@G9W0725.americas.hpqcorp.net>
Message-ID: <CAHjP37EDO0BC=tR195X19F9UgBkkcVWS_r-2wj3nuBRivhLevg@mail.gmail.com>

Hans,

For #1 are you talking about reliance on cpu respecting data and control
dependent loads and that otherwise the null checking load would need an
acquire fence? The only one I know of that doesn't respect data dependency
is alpha, but it's irrelevant.  Is there something else that's actually
relevant? I'm guessing that if hotspot ran on archs where that's not the
case, the VM itself would probably not work, never mind java code.

Sent from my phone
On Dec 3, 2013 3:51 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:

> > From: Doug Lea
> >
> > Sorry for mis-remembering why I had treated this issue as basically
> > settled:
> > Unless a JVM always pre-zeros memory (which usually not a good option),
> > then
> > even if not explicitly initialized, volatile fields must be zeroed
> > in the constructor body, with a release fence before publication.
> Is there a general argument for that claim about pre-zeroing?  My
> expectation would have been that it's reasonable to pre-zero, so long as
> you do it in chunks small enough that the zeros are unlikely to leave the
> faster parts of the cache hierarchy between zeroing and use.  It seems to
> be a trade-off between fences and some, ideally small, risk of additional
> cache misses.
>
> I have a couple of other concerns about this discussion:
>
> 1. Nobody has mentioned that in the other thread of the original example,
> the one that does r1 = a.f, the loads of a and a.f are not currently
> ordered.  Once you add the required wait for a non-null a, that also
> matters.  I expect that is in fact guaranteed by all current Java
> implementations, but it requires a spec change.  And I think there are many
> plausible (and implausible) variants of that change, with substantive
> differences.
>
> 2. Along the same lines, and in agreement with some later posts, I still
> don't fully understand the rationale for providing such guarantees for
> volatile fields.  There is a general rule that when I construct an object,
> I shouldn't use it until I've finished constructing/initializing it.  That
> also generally applies to the built-in types.  And I think it applies to
> concurrent containers, even if other operations are allowed to race.  We
> seem to be adding a special short-cut by guaranteeing that, with safe
> publication, if I see a non-null pointer to the object, then I can safely
> conclude it has been initialized, even if there is no real happens-before
> relationship.  But presumably if I see a flag that was set after the
> initialization, no such guarantee exists?  It's not at all clear to me that
> this simplifies our story.
>
> IIRC, the current final field rules were developed primarily to provide
> some security guarantees.  It is possible to build immutable types that
> look immutable, even to a malicious client.  That argument doesn't apply to
> objects with volatile fields.
>
> Hans
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/e2fba70d/attachment.html>

From gergg at cox.net  Tue Dec  3 16:38:56 2013
From: gergg at cox.net (Gregg Wonderly)
Date: Tue, 3 Dec 2013 15:38:56 -0600
Subject: [concurrency-interest] Volatile stores in constructors,
	disallowed to see the default value
In-Reply-To: <x8sk1m01002hR0p018smq4>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu> <x8sk1m01002hR0p018smq4>
Message-ID: <C740791B-1B66-434B-A740-21E2A5DBB07A@cox.net>


On Dec 3, 2013, at 2:49 PM, Boehm, Hans <hans.boehm at hp.com> wrote:

>> From: Doug Lea
>> 
>> Sorry for mis-remembering why I had treated this issue as basically
>> settled:
>> Unless a JVM always pre-zeros memory (which usually not a good option),
>> then
>> even if not explicitly initialized, volatile fields must be zeroed
>> in the constructor body, with a release fence before publication.
> Is there a general argument for that claim about pre-zeroing?  My expectation would have been that it's reasonable to pre-zero, so long as you do it in chunks small enough that the zeros are unlikely to leave the faster parts of the cache hierarchy between zeroing and use.  It seems to be a trade-off between fences and some, ideally small, risk of additional cache misses.
> 
> I have a couple of other concerns about this discussion:
> 
> 1. Nobody has mentioned that in the other thread of the original example, the one that does r1 = a.f, the loads of a and a.f are not currently ordered.  Once you add the required wait for a non-null a, that also matters.  I expect that is in fact guaranteed by all current Java implementations, but it requires a spec change.  And I think there are many plausible (and implausible) variants of that change, with substantive differences.
> 
> 2. Along the same lines, and in agreement with some later posts, I still don't fully understand the rationale for providing such guarantees for volatile fields.  There is a general rule that when I construct an object, I shouldn't use it until I've finished constructing/initializing it.  That also generally applies to the built-in types.  And I think it applies to concurrent containers, even if other operations are allowed to race.  We seem to be adding a special short-cut by guaranteeing that, with safe publication, if I see a non-null pointer to the object, then I can safely conclude it has been initialized, even if there is no real happens-before relationship.  But presumably if I see a flag that was set after the initialization, no such guarantee exists?  It's not at all clear to me that this simplifies our story.

There is absolutely awesome benefits from the applications getting a NullPointerException for using an initialized field, rather seeing a ?pointer? to garbage.  It?s possible then to conclude, much more readily that the value was not initialized correctly.  Otherwise, the developer is going to have no earthly idea why the JVM crashed with an internal error due to an errant memory access right?

Gregg Wonderly

From oleksandr.otenko at oracle.com  Tue Dec  3 16:51:33 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 21:51:33 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37Gh95ZyOBxmfoJoNCru+=WtbpUNw+eDSJw2-Mt-gPTDYA@mail.gmail.com>
References: <5295E24C.40608@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
	<529E297C.4070401@oracle.com>
	<CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>
	<529E3567.8020108@oracle.com>
	<CAHjP37GA9dQQd0Ds=zMCXTJMO4OHhr983MjcxUST07aSu6pi2A@mail.gmail.com>
	<529E4576.4070406@oracle.com>
	<CAHjP37Ewhz_BUwoG2b3ZE0pUU2STd_+UH+XS3S_H4SPeZn51jQ@mail.gmail.com>
	<529E46D0.8080903@oracle.com>
	<CAHjP37Gh95ZyOBxmfoJoNCru+=WtbpUNw+eDSJw2-Mt-gPTDYA@mail.gm!
	ail.com>
Message-ID: <529E5265.5060003@oracle.com>

Look, at this level it is clear and doesn't shed more light.

But consider this:

f=42;
	f=42;
f=42;


This gets translated into:

load-store
store-store
store f, 42
	load-store
store-store
store f,42
store-store
store f,42


When done in constructor, this is optimizable (using the current spec!) 
into:

load-store
store-store
store f, 42
	load-store
store f,42
store-store


(no field can be observed before the reference to the instance is loaded 
the first time (see section "Data Dependency and Barriers" of the 
cookbook), so store-store before the first store f,42 can be removed, 
because the second store-store, which we keep, guarantees the reference 
to the instance cannot be published before the first store f,42;

in these circumstances two stores to f will not be distinguishable from 
one store to f, so we eliminate the second store

load-store may not be needed, too - depending what is done in the 
constructor)


In this sense, both pieces translate into the same number of 
instructions and barriers, we aren't talking about an additional 
barrier, just the same kind of barrier in a different place.

So, as a writer of the constructor, given that the perf cost is the 
same, and assuming everyone always done this deep optimization, when 
would you */not/* want to write f=42; f=42; instead of just one f=42;? I 
maintain that writing f=42; f=42; is safer, and enforcing it at JVM 
level without having to write it is good.


Alex


On 03/12/2013 21:15, Vitaly Davidovich wrote:
>
> My point is this storestore doesn't exist on PPC today because there's 
> no need based on spec.  There will be a need if spec is updated - this 
> is a new barrier as it's not there otherwise; compiler or cpu is free 
> to move assignment of ref before the volatile store, and now you need 
> to preclude that.  If you had a volatile store with no subsequent 
> volatile load or store, then no barrier is technically needed.  In 
> practice, at least hotspot, always emits a fence after volatile store, 
> but that need not be the case for others.
>
> Sent from my phone
>
> On Dec 3, 2013 4:02 PM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     Yes, they do allow the reorder, so the point here is to move the
>     store-store barrier to after the volatile store - it is not doing
>     anything before the volatile store anyway.
>
>     Alex
>
>     On 03/12/2013 21:00, Vitaly Davidovich wrote:
>>
>>     No, they don't have the storestore between ctor exit and
>>     assignment to a field.  Volatile stores allow subsequent stores
>>     to reorder.
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 3:56 PM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         What do you mean - new barriers?
>>
>>         Store-store must occur after the last store preceding the
>>         volatile store in program order. If they didn't have it,
>>         they've got the bug to fix. If they do have the store-store,
>>         then they are correct w.r.t. what the spec says, and it is a
>>         matter of opinion of whether the spec needs fixing. I see the
>>         spec will be safer and better, if it gets fixed as proposed,
>>         but I see the point why people oppose it.
>>
>>         Alex
>>
>>         On 03/12/2013 20:18, Vitaly Davidovich wrote:
>>>
>>>         Well, PPC guys didn't have the extra barriers for volatiles
>>>         in constructors either (for storestore), as mentioned.  For
>>>         them, this will be new barriers.  What does one tell them?
>>>         Either we're "fixing" publishing or we're doing this because
>>>         the cost is no greater - which is it for someone like PPC?
>>>
>>>         Sent from my phone
>>>
>>>         On Dec 3, 2013 2:48 PM, "Oleksandr Otenko"
>>>         <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>
>>>             This topic loops here.
>>>
>>>             The other ctors don't have the barriers, so adding them
>>>             costs.
>>>
>>>             The ctors with volatiles already have the barriers, so
>>>             order them in a way that offers more safety. You already
>>>             mentioned the circus with lazySet that is needed
>>>             otherwise. Since we all agree that's the safe way to do
>>>             it, and we don't advocate unsafe publishing, why not
>>>             imply lazySet then.
>>>
>>>             Alex
>>>
>>>
>>>             On 03/12/2013 19:21, Vitaly Davidovich wrote:
>>>>
>>>>             So to play devil's advocate, why not make all ctors
>>>>             behave the same way? Afterall, people may still publish
>>>>             classes with no final or volatile fields unsafely, and
>>>>             run into problems.  One can argue that most people
>>>>             expect that upon constructor exit, all memory ops are
>>>>             complete.  Why only add volatile to the mix? So that
>>>>             concurrency authors can attempt at safeguarding their
>>>>             class from unsafe publication by a user who doesn't
>>>>             know any better? Is that really worth the overhead
>>>>             required? Said user can still shoot themselves in other
>>>>             ways. At some point, the burden should be on devs to
>>>>             know the platform, its promises/guarantees, and
>>>>             available tools to add their own extra guarantees.
>>>>
>>>>             Again, we're talking about data race publishing here -
>>>>             this is not the norm or encouraged practice.  Why bend
>>>>             over backwards to accommodate it?
>>>>
>>>>             Sent from my phone
>>>>
>>>>             On Dec 3, 2013 1:57 PM, "Oleksandr Otenko"
>>>>             <oleksandr.otenko at oracle.com
>>>>             <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>
>>>>                 You'd need load-store after loading externally
>>>>                 observable values with or without the proposed
>>>>                 changes, but we aren't eliminating those, are we? I
>>>>                 thought you meant we need new barriers.
>>>>
>>>>                 Alex
>>>>
>>>>                 On 03/12/2013 18:51, Vitaly Davidovich wrote:
>>>>>
>>>>>                 You would - since volatile can be modified and
>>>>>                 read many times in ctor, you need to ensure all
>>>>>                 loads are done before the store and before ctor
>>>>>                 exits - you need to ensure value of the volatile
>>>>>                 is the final one at the end of the ctor sequence. 
>>>>>                 Otherwise, the loads can move after the store.
>>>>>                 Basically, you need lazySet() now and not plain
>>>>>                 storestore.
>>>>>
>>>>>                 Sent from my phone
>>>>>
>>>>>                 On Dec 3, 2013 1:44 PM, "Oleksandr Otenko"
>>>>>                 <oleksandr.otenko at oracle.com
>>>>>                 <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>
>>>>>                     I don't think you'd need it in a constructor.
>>>>>
>>>>>                     You can't read the fields until the reference
>>>>>                     to the instance is stored. If you can stop
>>>>>                     reordering that store with the last volatile
>>>>>                     store, publication is safe.
>>>>>
>>>>>                     Alex
>>>>>
>>>>>                     On 03/12/2013 18:34, Vitaly Davidovich wrote:
>>>>>>
>>>>>>                     For volatiles, you'd need load-store as well
>>>>>>                     though.
>>>>>>
>>>>>>                     Sent from my phone
>>>>>>
>>>>>>                     On Dec 3, 2013 1:05 PM, "Oleksandr Otenko"
>>>>>>                     <oleksandr.otenko at oracle.com
>>>>>>                     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>
>>>>>>                         Sure.
>>>>>>
>>>>>>                         f=42;
>>>>>>
>>>>>>                         already imposes the cost of store-store
>>>>>>                         barrier.
>>>>>>
>>>>>>                         f=42;
>>>>>>                         f=42;
>>>>>>
>>>>>>                         does the same thing. In a constructor,
>>>>>>                         eliminate the first barrier, because the
>>>>>>                         order of writes to the unreachable
>>>>>>                         instance is not important, and the second
>>>>>>                         store. This no longer is the question of
>>>>>>                         performance, because it is the same. It
>>>>>>                         is the question of correctness for free.
>>>>>>
>>>>>>                         Alex
>>>>>>
>>>>>>                         On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>>>>>>
>>>>>>>                         Not sure that's the right view either. 
>>>>>>>                         The one thing the author does not
>>>>>>>                         control is how instances of their class
>>>>>>>                         are passed around.  User of the class
>>>>>>>                         has more context - it may actually be ok
>>>>>>>                         that volatiles aren't fenced here
>>>>>>>                         because they're already ensuring some
>>>>>>>                         way that it's fine, including the
>>>>>>>                         possibility that the instance isn't even
>>>>>>>                         shared at all. As long as people know
>>>>>>>                         the behavior of the language/platform,
>>>>>>>                         they should be expected to make an
>>>>>>>                         educated decision on their own.
>>>>>>>
>>>>>>>                         Look, if performance didn't matter, you
>>>>>>>                         could just blindly say that all
>>>>>>>                         constructors have a freeze action,
>>>>>>>                         regardless of final fields or volatile.
>>>>>>>                         That's not the case, of course.  Java
>>>>>>>                         and JDK have tools available to publish
>>>>>>>                         safely, so people doing multithreading
>>>>>>>                         have the ability to do the right thing. 
>>>>>>>                         At the end of the day, exposing
>>>>>>>                         concurrency to devs will lead to bugs,
>>>>>>>                         even beside the issues described here.
>>>>>>>
>>>>>>>                         Sent from my phone
>>>>>>>
>>>>>>>                         On Dec 3, 2013 12:42 PM, "Oleksandr
>>>>>>>                         Otenko" <oleksandr.otenko at oracle.com
>>>>>>>                         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>>
>>>>>>>                             No, this is a completely opposite
>>>>>>>                             view. The question is:
>>>>>>>
>>>>>>>                             do you as the implementor of the
>>>>>>>                             concurrent algorithm ever intend the
>>>>>>>                             constructor design to be such that
>>>>>>>                             relies on the protocol that the
>>>>>>>                             caller chooses to publish the reference?
>>>>>>>
>>>>>>>                             (Do you ever intend to /*not*/
>>>>>>>                             specify a no-op volatile load after
>>>>>>>                             the last volatile store in the
>>>>>>>                             constructor?)
>>>>>>>
>>>>>>>
>>>>>>>                             Alex
>>>>>>>
>>>>>>>
>>>>>>>                             On 03/12/2013 17:23, Vitaly
>>>>>>>                             Davidovich wrote:
>>>>>>>>
>>>>>>>>                             I'm confident most code that
>>>>>>>>                             publishes objects shared across
>>>>>>>>                             threads does it safely. Otherwise
>>>>>>>>                             we're saying majority of code uses
>>>>>>>>                             data races?
>>>>>>>>
>>>>>>>>                             Sent from my phone
>>>>>>>>
>>>>>>>>                             On Dec 3, 2013 12:21 PM, "Oleksandr
>>>>>>>>                             Otenko"
>>>>>>>>                             <oleksandr.otenko at oracle.com
>>>>>>>>                             <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>                             wrote:
>>>>>>>>
>>>>>>>>                                 Hmmm.... I thought it is clear
>>>>>>>>                                 no one argues about the "/*if*/
>>>>>>>>                                 you publish safely" part. The
>>>>>>>>                                 question I am wondering about
>>>>>>>>                                 is whether you can find a case
>>>>>>>>                                 where publishing the reference
>>>>>>>>                                 to the instance unsafely is
>>>>>>>>                                 /intended/.
>>>>>>>>
>>>>>>>>                                 Alex
>>>>>>>>
>>>>>>>>                                 On 03/12/2013 17:14, Vitaly
>>>>>>>>                                 Davidovich wrote:
>>>>>>>>>
>>>>>>>>>                                 But this is only if you
>>>>>>>>>                                 publish unsafely, as mentioned
>>>>>>>>>                                 before.  If you publish this
>>>>>>>>>                                 class properly, you don't get
>>>>>>>>>                                 races on the volatile. Final
>>>>>>>>>                                 fields are supposed to support
>>>>>>>>>                                 immutable classes, where
>>>>>>>>>                                 although not preferrable,
>>>>>>>>>                                 publishing racily is plausible
>>>>>>>>>                                 (for performance). For
>>>>>>>>>                                 read/write volatiles, it's not
>>>>>>>>>                                 compelling on the surface.
>>>>>>>>>
>>>>>>>>>                                 Sent from my phone
>>>>>>>>>
>>>>>>>>>                                 On Dec 3, 2013 11:18 AM,
>>>>>>>>>                                 "Oleksandr Otenko"
>>>>>>>>>                                 <oleksandr.otenko at oracle.com
>>>>>>>>>                                 <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>                                 wrote:
>>>>>>>>>
>>>>>>>>>                                     Yes, but I mean that the
>>>>>>>>>                                     code assumes the value to
>>>>>>>>>                                     always be non-null - eg a
>>>>>>>>>                                     sentinel entry of the list
>>>>>>>>>                                     is created at construction
>>>>>>>>>                                     time. Without the
>>>>>>>>>                                     construction-time
>>>>>>>>>                                     guarantee you'd need to
>>>>>>>>>                                     test for null everywhere.
>>>>>>>>>
>>>>>>>>>                                     I think the same applies
>>>>>>>>>                                     in other constructors - if
>>>>>>>>>                                     you write the
>>>>>>>>>                                     initialization of the
>>>>>>>>>                                     volatile, you imply that's
>>>>>>>>>                                     "the least" "possible"
>>>>>>>>>                                     value, the value
>>>>>>>>>                                     representing the initial
>>>>>>>>>                                     state of the concurrent
>>>>>>>>>                                     algorithm - the initial
>>>>>>>>>                                     value guaranteed by Java
>>>>>>>>>                                     spec may not represent any
>>>>>>>>>                                     valid state of the
>>>>>>>>>                                     concurrent algorithm, let
>>>>>>>>>                                     alone the initial state.
>>>>>>>>>
>>>>>>>>>                                     That's why this really
>>>>>>>>>                                     boils down to "find the
>>>>>>>>>                                     broad cases where you do
>>>>>>>>>                                     want to permit unsafe
>>>>>>>>>                                     publication of the initial
>>>>>>>>>                                     values of the volatiles".
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     (unlike the non-volatile
>>>>>>>>>                                     fields. Don't treat them
>>>>>>>>>                                     as "not thread safe" -
>>>>>>>>>                                     instead, treat them as
>>>>>>>>>                                     "assume as made
>>>>>>>>>                                     thread-safe by means
>>>>>>>>>                                     outside the class
>>>>>>>>>                                     specification", hence no
>>>>>>>>>                                     requirement for "safe
>>>>>>>>>                                     publication" there)
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     Alex
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     On 03/12/2013 15:08,
>>>>>>>>>                                     Vitaly Davidovich wrote:
>>>>>>>>>>
>>>>>>>>>>                                     Initial value of the
>>>>>>>>>>                                     field must be the "zero"
>>>>>>>>>>                                     value of that type,
>>>>>>>>>>                                     that's a language spec
>>>>>>>>>>                                     and must be guaranteed
>>>>>>>>>>                                     irrespective of volatile
>>>>>>>>>>                                     or not.
>>>>>>>>>>
>>>>>>>>>>                                     Sent from my phone
>>>>>>>>>>
>>>>>>>>>>                                     On Dec 3, 2013 10:03 AM,
>>>>>>>>>>                                     "Oleksandr Otenko"
>>>>>>>>>>                                     <oleksandr.otenko at oracle.com
>>>>>>>>>>                                     <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>>                                     wrote:
>>>>>>>>>>
>>>>>>>>>>                                         I understand, but you
>>>>>>>>>>                                         can't insist on
>>>>>>>>>>                                         viewing ctors as
>>>>>>>>>>                                         "just methods" for
>>>>>>>>>>                                         all purposes.
>>>>>>>>>>
>>>>>>>>>>                                         (2) publication is
>>>>>>>>>>                                         unsafe unless you get
>>>>>>>>>>                                         a volatile load after
>>>>>>>>>>                                         the last volatile
>>>>>>>>>>                                         store in the
>>>>>>>>>>                                         constructor. Besides,
>>>>>>>>>>                                         the initial value of
>>>>>>>>>>                                         the field may not
>>>>>>>>>>                                         even be one of the
>>>>>>>>>>                                         valid values, so it
>>>>>>>>>>                                         is not even just
>>>>>>>>>>                                         about a data race.
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         Alex
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         On 03/12/2013 13:57,
>>>>>>>>>>                                         Vitaly Davidovich wrote:
>>>>>>>>>>>
>>>>>>>>>>>                                         For
>>>>>>>>>>>                                         compilation/codegen
>>>>>>>>>>>                                         purposes ctors *are*
>>>>>>>>>>>                                         just methods - they
>>>>>>>>>>>                                         can be inlined, code
>>>>>>>>>>>                                         optimized, etc;
>>>>>>>>>>>                                         that's the reason we
>>>>>>>>>>>                                         have the final field
>>>>>>>>>>>                                         guarantees.
>>>>>>>>>>>
>>>>>>>>>>>                                         A couple of
>>>>>>>>>>>                                         potential reasons
>>>>>>>>>>>                                         not to add volatile
>>>>>>>>>>>                                         to the spec:
>>>>>>>>>>>                                         1) perhaps some JVMs
>>>>>>>>>>>                                         don't currently
>>>>>>>>>>>                                         already give them
>>>>>>>>>>>                                         final field semantics
>>>>>>>>>>>                                         2) this whole thing
>>>>>>>>>>>                                         comes into play for
>>>>>>>>>>>                                         unsafe publication
>>>>>>>>>>>                                         only (I.e. data
>>>>>>>>>>>                                         race), which is
>>>>>>>>>>>                                         discouraged.
>>>>>>>>>>>
>>>>>>>>>>>                                         Sent from my phone
>>>>>>>>>>>
>>>>>>>>>>>                                         On Dec 3, 2013 6:51
>>>>>>>>>>>                                         AM, "Oleksandr
>>>>>>>>>>>                                         Otenko"
>>>>>>>>>>>                                         <oleksandr.otenko at oracle.com
>>>>>>>>>>>                                         <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>>>                                         wrote:
>>>>>>>>>>>
>>>>>>>>>>>                                             Constructors
>>>>>>>>>>>                                             /are/ special
>>>>>>>>>>>                                             methods. They
>>>>>>>>>>>                                             are the first
>>>>>>>>>>>                                             method calls in
>>>>>>>>>>>                                             any history of
>>>>>>>>>>>                                             the object. This
>>>>>>>>>>>                                             means a
>>>>>>>>>>>                                             different
>>>>>>>>>>>                                             treatment of
>>>>>>>>>>>                                             volatile
>>>>>>>>>>>                                             accesses to the
>>>>>>>>>>>                                             fields of the
>>>>>>>>>>>                                             instance being
>>>>>>>>>>>                                             created is
>>>>>>>>>>>                                             possible -
>>>>>>>>>>>                                             certain barriers
>>>>>>>>>>>                                             can be
>>>>>>>>>>>                                             eliminated,
>>>>>>>>>>>                                             because the
>>>>>>>>>>>                                             loads can be
>>>>>>>>>>>                                             proven to not
>>>>>>>>>>>                                             synchronize with
>>>>>>>>>>>                                             anyone. For the
>>>>>>>>>>>                                             sake of the
>>>>>>>>>>>                                             argument, it is
>>>>>>>>>>>                                             possible to
>>>>>>>>>>>                                             proceed with
>>>>>>>>>>>                                             weak treatment
>>>>>>>>>>>                                             of volatile
>>>>>>>>>>>                                             stores, too, but
>>>>>>>>>>>                                             you need a good
>>>>>>>>>>>                                             reason to permit
>>>>>>>>>>>                                             subsequent calls
>>>>>>>>>>>                                             to observe the
>>>>>>>>>>>                                             initial state of
>>>>>>>>>>>                                             the volatile
>>>>>>>>>>>                                             fields; whereas
>>>>>>>>>>>                                             any volatile
>>>>>>>>>>>                                             load in any
>>>>>>>>>>>                                             other method
>>>>>>>>>>>                                             always
>>>>>>>>>>>                                             synchronizes
>>>>>>>>>>>                                             with a volatile
>>>>>>>>>>>                                             store of some
>>>>>>>>>>>                                             other method
>>>>>>>>>>>                                             call, without
>>>>>>>>>>>                                             the final field
>>>>>>>>>>>                                             semantics we
>>>>>>>>>>>                                             cannot assume that.
>>>>>>>>>>>
>>>>>>>>>>>                                             However, if we
>>>>>>>>>>>                                             assume final
>>>>>>>>>>>                                             field semantics,
>>>>>>>>>>>                                             there is only
>>>>>>>>>>>                                             one barrier
>>>>>>>>>>>                                             needed - a
>>>>>>>>>>>                                             store-store
>>>>>>>>>>>                                             after the last
>>>>>>>>>>>                                             volatile field
>>>>>>>>>>>                                             store. This
>>>>>>>>>>>                                             eliminates all
>>>>>>>>>>>                                             barriers for any
>>>>>>>>>>>                                             other volatile
>>>>>>>>>>>                                             field
>>>>>>>>>>>                                             initialization,
>>>>>>>>>>>                                             and eliminates a
>>>>>>>>>>>                                             full barrier
>>>>>>>>>>>                                             needed otherwise
>>>>>>>>>>>                                             (got to place a
>>>>>>>>>>>                                             dummy volatile
>>>>>>>>>>>                                             load after the
>>>>>>>>>>>                                             last volatile
>>>>>>>>>>>                                             store to make
>>>>>>>>>>>                                             sure the
>>>>>>>>>>>                                             semantics are
>>>>>>>>>>>                                             stronger than
>>>>>>>>>>>                                             final-field) -
>>>>>>>>>>>                                             think of
>>>>>>>>>>>                                             removing a
>>>>>>>>>>>                                             mfence or
>>>>>>>>>>>                                             similar from
>>>>>>>>>>>                                             each such
>>>>>>>>>>>                                             constructor on x86.
>>>>>>>>>>>
>>>>>>>>>>>                                             (there will
>>>>>>>>>>>                                             still be gotchas
>>>>>>>>>>>                                             for cases when
>>>>>>>>>>>                                             volatile field
>>>>>>>>>>>                                             initialization
>>>>>>>>>>>                                             occurs after a
>>>>>>>>>>>                                             volatile load of
>>>>>>>>>>>                                             something
>>>>>>>>>>>                                             outside the same
>>>>>>>>>>>                                             instance; but
>>>>>>>>>>>                                             the main purpose
>>>>>>>>>>>                                             is to eliminate
>>>>>>>>>>>                                             barriers when
>>>>>>>>>>>                                             the volatile
>>>>>>>>>>>                                             fields are just
>>>>>>>>>>>                                             initialized into
>>>>>>>>>>>                                             some
>>>>>>>>>>>                                             instance-specific values)
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                             Alex
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                             On 03/12/2013
>>>>>>>>>>>                                             05:54, Ruslan
>>>>>>>>>>>                                             Cheremin wrote:
>>>>>>>>>>>>                                             I'm about why
>>>>>>>>>>>>                                             "always mean
>>>>>>>>>>>>                                             storestore
>>>>>>>>>>>>                                             after volatile
>>>>>>>>>>>>                                             store in
>>>>>>>>>>>>                                             constructor".
>>>>>>>>>>>>                                             It is not only
>>>>>>>>>>>>                                             efficiency
>>>>>>>>>>>>                                             which is
>>>>>>>>>>>>                                             important for
>>>>>>>>>>>>                                             MM, but also
>>>>>>>>>>>>                                             simplicity and
>>>>>>>>>>>>                                             consistency. If
>>>>>>>>>>>>                                             constructors
>>>>>>>>>>>>                                             are special
>>>>>>>>>>>>                                             methods, not
>>>>>>>>>>>>                                             just plain
>>>>>>>>>>>>                                             <init>, then we
>>>>>>>>>>>>                                             should add this
>>>>>>>>>>>>                                             kind of
>>>>>>>>>>>>                                             atomicity to
>>>>>>>>>>>>                                             all
>>>>>>>>>>>>                                             constructors
>>>>>>>>>>>>                                             (which, as I
>>>>>>>>>>>>                                             was reading
>>>>>>>>>>>>                                             here, could be
>>>>>>>>>>>>                                             inefficient on
>>>>>>>>>>>>                                             some
>>>>>>>>>>>>                                             platforms). But
>>>>>>>>>>>>                                             if constructors
>>>>>>>>>>>>                                             are just plain
>>>>>>>>>>>>                                             methods, it
>>>>>>>>>>>>                                             looks strange
>>>>>>>>>>>>                                             to have special
>>>>>>>>>>>>                                             implicit
>>>>>>>>>>>>                                             semantics for
>>>>>>>>>>>>                                             constructors
>>>>>>>>>>>>                                             with volatiles
>>>>>>>>>>>>                                             inside.
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                             2013/12/3
>>>>>>>>>>>>                                             Oleksandr
>>>>>>>>>>>>                                             Otenko
>>>>>>>>>>>>                                             <oleksandr.otenko at oracle.com
>>>>>>>>>>>>                                             <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 I think it
>>>>>>>>>>>>                                                 is pretty
>>>>>>>>>>>>                                                 simple.
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 If you
>>>>>>>>>>>>                                                 always mean
>>>>>>>>>>>>                                                 a
>>>>>>>>>>>>                                                 store-store
>>>>>>>>>>>>                                                 barrier
>>>>>>>>>>>>                                                 /after/ the
>>>>>>>>>>>>                                                 last
>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>                                                 store in
>>>>>>>>>>>>                                                 the
>>>>>>>>>>>>                                                 constructor, then
>>>>>>>>>>>>                                                 add that
>>>>>>>>>>>>                                                 barrier
>>>>>>>>>>>>                                                 into
>>>>>>>>>>>>                                                 constructor
>>>>>>>>>>>>                                                 semantics,
>>>>>>>>>>>>                                                 like it's
>>>>>>>>>>>>                                                 done with
>>>>>>>>>>>>                                                 the final
>>>>>>>>>>>>                                                 fields.
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 It makes
>>>>>>>>>>>>                                                 sense to
>>>>>>>>>>>>                                                 /not/ add
>>>>>>>>>>>>                                                 it to the
>>>>>>>>>>>>                                                 semantics,
>>>>>>>>>>>>                                                 if you can
>>>>>>>>>>>>                                                 come up
>>>>>>>>>>>>                                                 with enough
>>>>>>>>>>>>                                                 examples
>>>>>>>>>>>>                                                 where you
>>>>>>>>>>>>                                                 want that
>>>>>>>>>>>>                                                 barrier to
>>>>>>>>>>>>                                                 be eliminated.
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 Alex
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 On
>>>>>>>>>>>>                                                 02/12/2013
>>>>>>>>>>>>                                                 19:32,
>>>>>>>>>>>>                                                 Ruslan
>>>>>>>>>>>>                                                 Cheremin wrote:
>>>>>>>>>>>>>                                                 Well, I do
>>>>>>>>>>>>>                                                 not see
>>>>>>>>>>>>>                                                 any data
>>>>>>>>>>>>>                                                 race _on
>>>>>>>>>>>>>                                                 volatiles_
>>>>>>>>>>>>>                                                 here. I
>>>>>>>>>>>>>                                                 see race
>>>>>>>>>>>>>                                                 condition
>>>>>>>>>>>>>                                                 on
>>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>>                                                 .value,
>>>>>>>>>>>>>                                                 yes -- but
>>>>>>>>>>>>>                                                 it is
>>>>>>>>>>>>>                                                 pretty
>>>>>>>>>>>>>                                                 legal (and
>>>>>>>>>>>>>                                                 unavoidable,
>>>>>>>>>>>>>                                                 I suppose)
>>>>>>>>>>>>>                                                 to have
>>>>>>>>>>>>>                                                 race
>>>>>>>>>>>>>                                                 conditions
>>>>>>>>>>>>>                                                 even with
>>>>>>>>>>>>>                                                 volatiles
>>>>>>>>>>>>>                                                 involved.
>>>>>>>>>>>>>                                                 The only
>>>>>>>>>>>>>                                                 data race
>>>>>>>>>>>>>                                                 I see is
>>>>>>>>>>>>>                                                 around
>>>>>>>>>>>>>                                                 read-write
>>>>>>>>>>>>>                                                 of
>>>>>>>>>>>>>                                                 (non-volatile)
>>>>>>>>>>>>>                                                 AtomicInteger's
>>>>>>>>>>>>>                                                 reference
>>>>>>>>>>>>>                                                 -- which
>>>>>>>>>>>>>                                                 is
>>>>>>>>>>>>>                                                 unrelated
>>>>>>>>>>>>>                                                 to
>>>>>>>>>>>>>                                                 AtomicInteger's
>>>>>>>>>>>>>                                                 content. I
>>>>>>>>>>>>>                                                 mean, I
>>>>>>>>>>>>>                                                 could not
>>>>>>>>>>>>>                                                 see any
>>>>>>>>>>>>>                                                 noticable
>>>>>>>>>>>>>                                                 difference
>>>>>>>>>>>>>                                                 between
>>>>>>>>>>>>>                                                 the case
>>>>>>>>>>>>>                                                 discussed,
>>>>>>>>>>>>>                                                 and just
>>>>>>>>>>>>>                                                 any other
>>>>>>>>>>>>>                                                 case there
>>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>>                                                 is
>>>>>>>>>>>>>                                                 _incorrectly_
>>>>>>>>>>>>>                                                 used to
>>>>>>>>>>>>>                                                 "synchronize"
>>>>>>>>>>>>>                                                 data
>>>>>>>>>>>>>                                                 accesses
>>>>>>>>>>>>>                                                 -- it
>>>>>>>>>>>>>                                                 could
>>>>>>>>>>>>>                                                 still be
>>>>>>>>>>>>>                                                 data race
>>>>>>>>>>>>>                                                 on
>>>>>>>>>>>>>                                                 non-volatile
>>>>>>>>>>>>>                                                 fields,
>>>>>>>>>>>>>                                                 even if
>>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>>                                                 fields are
>>>>>>>>>>>>>                                                 also used
>>>>>>>>>>>>>                                                 somewhere
>>>>>>>>>>>>>                                                 around.
>>>>>>>>>>>>>                                                 Yes, get 0
>>>>>>>>>>>>>                                                 from
>>>>>>>>>>>>>                                                 .value is
>>>>>>>>>>>>>                                                 unexpected
>>>>>>>>>>>>>                                                 -- but
>>>>>>>>>>>>>                                                 there are
>>>>>>>>>>>>>                                                 many
>>>>>>>>>>>>>                                                 unexpected
>>>>>>>>>>>>>                                                 things in
>>>>>>>>>>>>>                                                 memory
>>>>>>>>>>>>>                                                 models. It
>>>>>>>>>>>>>                                                 is noway
>>>>>>>>>>>>>                                                 more
>>>>>>>>>>>>>                                                 unexpected
>>>>>>>>>>>>>                                                 then to
>>>>>>>>>>>>>                                                 see
>>>>>>>>>>>>>                                                 default
>>>>>>>>>>>>>                                                 values in
>>>>>>>>>>>>>                                                 fields of
>>>>>>>>>>>>>                                                 any other
>>>>>>>>>>>>>                                                 object
>>>>>>>>>>>>>                                                 which is
>>>>>>>>>>>>>                                                 unsafely
>>>>>>>>>>>>>                                                 published.
>>>>>>>>>>>>>                                                 I think
>>>>>>>>>>>>>                                                 everybody
>>>>>>>>>>>>>                                                 who passed
>>>>>>>>>>>>>                                                 through
>>>>>>>>>>>>>                                                 broken
>>>>>>>>>>>>>                                                 atomicity
>>>>>>>>>>>>>                                                 of
>>>>>>>>>>>>>                                                 constructor call
>>>>>>>>>>>>>                                                 could easy
>>>>>>>>>>>>>                                                 see the
>>>>>>>>>>>>>                                                 chance to
>>>>>>>>>>>>>                                                 read
>>>>>>>>>>>>>                                                 [.value=0]
>>>>>>>>>>>>>                                                 in the
>>>>>>>>>>>>>                                                 case
>>>>>>>>>>>>>                                                 discussed.
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                 "Data race
>>>>>>>>>>>>>                                                 is pure
>>>>>>>>>>>>>                                                 evil" was
>>>>>>>>>>>>>                                                 the motto
>>>>>>>>>>>>>                                                 of this
>>>>>>>>>>>>>                                                 list all
>>>>>>>>>>>>>                                                 time I was
>>>>>>>>>>>>>                                                 reading
>>>>>>>>>>>>>                                                 it. Why do
>>>>>>>>>>>>>                                                 we may
>>>>>>>>>>>>>                                                 want to
>>>>>>>>>>>>>                                                 introduce
>>>>>>>>>>>>>                                                 another
>>>>>>>>>>>>>                                                 example of
>>>>>>>>>>>>>                                                 benign
>>>>>>>>>>>>>                                                 race?
>>>>>>>>>>>>>                                                 Wouldn't
>>>>>>>>>>>>>                                                 it be just
>>>>>>>>>>>>>                                                 another
>>>>>>>>>>>>>                                                 source of
>>>>>>>>>>>>>                                                 confusion
>>>>>>>>>>>>>                                                 for newcomers?
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                 2013/12/2
>>>>>>>>>>>>>                                                 Doug Lea
>>>>>>>>>>>>>                                                 <dl at cs.oswego.edu
>>>>>>>>>>>>>                                                 <mailto:dl at cs.oswego.edu>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                     On
>>>>>>>>>>>>>                                                     12/02/2013
>>>>>>>>>>>>>                                                     03:57
>>>>>>>>>>>>>                                                     AM,
>>>>>>>>>>>>>                                                     Cheremin
>>>>>>>>>>>>>                                                     Ruslan
>>>>>>>>>>>>>                                                     wrote:
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                         Doug,
>>>>>>>>>>>>>                                                         could
>>>>>>>>>>>>>                                                         you explain
>>>>>>>>>>>>>                                                         why it
>>>>>>>>>>>>>                                                         is
>>>>>>>>>>>>>                                                         so
>>>>>>>>>>>>>                                                         important
>>>>>>>>>>>>>                                                         to
>>>>>>>>>>>>>                                                         have
>>>>>>>>>>>>>                                                         this
>>>>>>>>>>>>>                                                         kind
>>>>>>>>>>>>>                                                         of
>>>>>>>>>>>>>                                                         safe
>>>>>>>>>>>>>                                                         publication
>>>>>>>>>>>>>                                                         for volatile?
>>>>>>>>>>>>>                                                         I
>>>>>>>>>>>>>                                                         mean,
>>>>>>>>>>>>>                                                         could
>>>>>>>>>>>>>                                                         we
>>>>>>>>>>>>>                                                         just
>>>>>>>>>>>>>                                                         go
>>>>>>>>>>>>>                                                         with
>>>>>>>>>>>>>                                                         .value=0
>>>>>>>>>>>>>                                                         through
>>>>>>>>>>>>>                                                         data
>>>>>>>>>>>>>                                                         race
>>>>>>>>>>>>>                                                         to
>>>>>>>>>>>>>                                                         be
>>>>>>>>>>>>>                                                         allowed
>>>>>>>>>>>>>                                                         result,
>>>>>>>>>>>>>                                                         as
>>>>>>>>>>>>>                                                         current
>>>>>>>>>>>>>                                                         model
>>>>>>>>>>>>>                                                         (seem
>>>>>>>>>>>>>                                                         to) imply?
>>>>>>>>>>>>>                                                         It
>>>>>>>>>>>>>                                                         seems
>>>>>>>>>>>>>                                                         to
>>>>>>>>>>>>>                                                         be a
>>>>>>>>>>>>>                                                         dr-case
>>>>>>>>>>>>>                                                         anyway,
>>>>>>>>>>>>>                                                         why we
>>>>>>>>>>>>>                                                         need
>>>>>>>>>>>>>                                                         special
>>>>>>>>>>>>>                                                         handling
>>>>>>>>>>>>>                                                         of it?
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                     The
>>>>>>>>>>>>>                                                     main
>>>>>>>>>>>>>                                                     reason
>>>>>>>>>>>>>                                                     is
>>>>>>>>>>>>>                                                     that
>>>>>>>>>>>>>                                                     it is
>>>>>>>>>>>>>                                                     highly
>>>>>>>>>>>>>                                                     irregular
>>>>>>>>>>>>>                                                     and
>>>>>>>>>>>>>                                                     unexpected
>>>>>>>>>>>>>                                                     by
>>>>>>>>>>>>>                                                     programmers.
>>>>>>>>>>>>>                                                     Except
>>>>>>>>>>>>>                                                     in
>>>>>>>>>>>>>                                                     this
>>>>>>>>>>>>>                                                     case,
>>>>>>>>>>>>>                                                     volatiles
>>>>>>>>>>>>>                                                     definitionally
>>>>>>>>>>>>>                                                     cannot
>>>>>>>>>>>>>                                                     be
>>>>>>>>>>>>>                                                     subject to
>>>>>>>>>>>>>                                                     data
>>>>>>>>>>>>>                                                     races.
>>>>>>>>>>>>>                                                     Dealing with
>>>>>>>>>>>>>                                                     it
>>>>>>>>>>>>>                                                     requires
>>>>>>>>>>>>>                                                     cleverness,
>>>>>>>>>>>>>                                                     complexity,
>>>>>>>>>>>>>                                                     and/or
>>>>>>>>>>>>>                                                     error-proneness
>>>>>>>>>>>>>                                                     that
>>>>>>>>>>>>>                                                     isn't
>>>>>>>>>>>>>                                                     even
>>>>>>>>>>>>>                                                     required
>>>>>>>>>>>>>                                                     for
>>>>>>>>>>>>>                                                     correctness
>>>>>>>>>>>>>                                                     on
>>>>>>>>>>>>>                                                     current JVMs.
>>>>>>>>>>>>>                                                     We
>>>>>>>>>>>>>                                                     have
>>>>>>>>>>>>>                                                     several constructions
>>>>>>>>>>>>>                                                     in
>>>>>>>>>>>>>                                                     j.u.c
>>>>>>>>>>>>>                                                     that
>>>>>>>>>>>>>                                                     work
>>>>>>>>>>>>>                                                     around
>>>>>>>>>>>>>                                                     problems
>>>>>>>>>>>>>                                                     by
>>>>>>>>>>>>>                                                     using
>>>>>>>>>>>>>                                                     explicit
>>>>>>>>>>>>>                                                     ordered
>>>>>>>>>>>>>                                                     writes
>>>>>>>>>>>>>                                                     in
>>>>>>>>>>>>>                                                     constructors,
>>>>>>>>>>>>>                                                     redundant-looking
>>>>>>>>>>>>>                                                     null-checks,
>>>>>>>>>>>>>                                                     and so
>>>>>>>>>>>>>                                                     on. If
>>>>>>>>>>>>>                                                     we are
>>>>>>>>>>>>>                                                     going
>>>>>>>>>>>>>                                                     to
>>>>>>>>>>>>>                                                     repair
>>>>>>>>>>>>>                                                     the
>>>>>>>>>>>>>                                                     JMM
>>>>>>>>>>>>>                                                     anyway, this
>>>>>>>>>>>>>                                                     is a clear
>>>>>>>>>>>>>                                                     candidate
>>>>>>>>>>>>>                                                     for
>>>>>>>>>>>>>                                                     reconsideration.
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                     -Doug
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                         Ruslan
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                             27
>>>>>>>>>>>>>                                                             ????.
>>>>>>>>>>>>>                                                             2013
>>>>>>>>>>>>>                                                             ?.,
>>>>>>>>>>>>>                                                             ? 23:26,
>>>>>>>>>>>>>                                                             Doug
>>>>>>>>>>>>>                                                             Lea
>>>>>>>>>>>>>                                                             <dl at cs.oswego.edu
>>>>>>>>>>>>>                                                             <mailto:dl at cs.oswego.edu>>
>>>>>>>>>>>>>                                                             ???????(?):
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                                 On
>>>>>>>>>>>>>                                                                 11/27/2013
>>>>>>>>>>>>>                                                                 02:06
>>>>>>>>>>>>>                                                                 PM,
>>>>>>>>>>>>>                                                                 Vitaly
>>>>>>>>>>>>>                                                                 Davidovich
>>>>>>>>>>>>>                                                                 wrote:
>>>>>>>>>>>>>                                                                 But
>>>>>>>>>>>>>                                                                 either
>>>>>>>>>>>>>                                                                 way,
>>>>>>>>>>>>>                                                                 optimizations
>>>>>>>>>>>>>                                                                 to
>>>>>>>>>>>>>                                                                 avoid
>>>>>>>>>>>>>                                                                 zeroing
>>>>>>>>>>>>>                                                                 memory
>>>>>>>>>>>>>                                                                 is
>>>>>>>>>>>>>                                                                 an
>>>>>>>>>>>>>                                                                 implementation
>>>>>>>>>>>>>                                                                 detail
>>>>>>>>>>>>>                                                                 and
>>>>>>>>>>>>>                                                                 thus
>>>>>>>>>>>>>                                                                 cannot
>>>>>>>>>>>>>                                                                 be
>>>>>>>>>>>>>                                                                 relied
>>>>>>>>>>>>>                                                                 upon
>>>>>>>>>>>>>                                                                 from
>>>>>>>>>>>>>                                                                 JMM
>>>>>>>>>>>>>                                                                 standpoint,
>>>>>>>>>>>>>                                                                 which
>>>>>>>>>>>>>                                                                 I think
>>>>>>>>>>>>>                                                                 you're
>>>>>>>>>>>>>                                                                 saying.
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                                 The
>>>>>>>>>>>>>                                                                 other
>>>>>>>>>>>>>                                                                 issue
>>>>>>>>>>>>>                                                                 is
>>>>>>>>>>>>>                                                                 that
>>>>>>>>>>>>>                                                                 even
>>>>>>>>>>>>>                                                                 if
>>>>>>>>>>>>>                                                                 we
>>>>>>>>>>>>>                                                                 determine
>>>>>>>>>>>>>                                                                 that
>>>>>>>>>>>>>                                                                 volatiles
>>>>>>>>>>>>>                                                                 don't
>>>>>>>>>>>>>                                                                 get
>>>>>>>>>>>>>                                                                 this
>>>>>>>>>>>>>                                                                 treatment,
>>>>>>>>>>>>>                                                                 if
>>>>>>>>>>>>>                                                                 JVM
>>>>>>>>>>>>>                                                                 is
>>>>>>>>>>>>>                                                                 already
>>>>>>>>>>>>>                                                                 ensuring
>>>>>>>>>>>>>                                                                 it,
>>>>>>>>>>>>>                                                                 it's
>>>>>>>>>>>>>                                                                 not
>>>>>>>>>>>>>                                                                 going
>>>>>>>>>>>>>                                                                 to
>>>>>>>>>>>>>                                                                 be
>>>>>>>>>>>>>                                                                 practical
>>>>>>>>>>>>>                                                                 to
>>>>>>>>>>>>>                                                                 change
>>>>>>>>>>>>>                                                                 it
>>>>>>>>>>>>>                                                                 and
>>>>>>>>>>>>>                                                                 risk
>>>>>>>>>>>>>                                                                 hard
>>>>>>>>>>>>>                                                                 to
>>>>>>>>>>>>>                                                                 debug
>>>>>>>>>>>>>                                                                 problems
>>>>>>>>>>>>>                                                                 creeping
>>>>>>>>>>>>>                                                                 in.
>>>>>>>>>>>>>                                                                  May
>>>>>>>>>>>>>                                                                 as
>>>>>>>>>>>>>                                                                 well
>>>>>>>>>>>>>                                                                 update
>>>>>>>>>>>>>                                                                 the
>>>>>>>>>>>>>                                                                 spec
>>>>>>>>>>>>>                                                                 now
>>>>>>>>>>>>>                                                                 ...
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                             Right.
>>>>>>>>>>>>>                                                             To
>>>>>>>>>>>>>                                                             summarize:
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                             * Programmers
>>>>>>>>>>>>>                                                             do
>>>>>>>>>>>>>                                                             not
>>>>>>>>>>>>>                                                             expect
>>>>>>>>>>>>>                                                             that
>>>>>>>>>>>>>                                                             even
>>>>>>>>>>>>>                                                             though
>>>>>>>>>>>>>                                                             final
>>>>>>>>>>>>>                                                             fields
>>>>>>>>>>>>>                                                             are
>>>>>>>>>>>>>                                                             specifically
>>>>>>>>>>>>>                                                             publication-safe,
>>>>>>>>>>>>>                                                             volatile
>>>>>>>>>>>>>                                                             fields
>>>>>>>>>>>>>                                                             are
>>>>>>>>>>>>>                                                             not
>>>>>>>>>>>>>                                                             always
>>>>>>>>>>>>>                                                             so.
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                             * For
>>>>>>>>>>>>>                                                             various
>>>>>>>>>>>>>                                                             implementation
>>>>>>>>>>>>>                                                             reasons,
>>>>>>>>>>>>>                                                             JVMs
>>>>>>>>>>>>>                                                             arrange
>>>>>>>>>>>>>                                                             that
>>>>>>>>>>>>>                                                             volatile
>>>>>>>>>>>>>                                                             fields
>>>>>>>>>>>>>                                                             are
>>>>>>>>>>>>>                                                             publication
>>>>>>>>>>>>>                                                             safe
>>>>>>>>>>>>>                                                             anyway,
>>>>>>>>>>>>>                                                             at
>>>>>>>>>>>>>                                                             least
>>>>>>>>>>>>>                                                             in
>>>>>>>>>>>>>                                                             cases
>>>>>>>>>>>>>                                                             we
>>>>>>>>>>>>>                                                             know
>>>>>>>>>>>>>                                                             about.
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                             * Actually
>>>>>>>>>>>>>                                                             updating
>>>>>>>>>>>>>                                                             the
>>>>>>>>>>>>>                                                             JMM/JLS
>>>>>>>>>>>>>                                                             to
>>>>>>>>>>>>>                                                             mandate
>>>>>>>>>>>>>                                                             this
>>>>>>>>>>>>>                                                             is
>>>>>>>>>>>>>                                                             not
>>>>>>>>>>>>>                                                             easy
>>>>>>>>>>>>>                                                             (no
>>>>>>>>>>>>>                                                             small
>>>>>>>>>>>>>                                                             tweak
>>>>>>>>>>>>>                                                             that
>>>>>>>>>>>>>                                                             I know
>>>>>>>>>>>>>                                                             applies).
>>>>>>>>>>>>>                                                             But
>>>>>>>>>>>>>                                                             now
>>>>>>>>>>>>>                                                             is
>>>>>>>>>>>>>                                                             a good
>>>>>>>>>>>>>                                                             time
>>>>>>>>>>>>>                                                             to
>>>>>>>>>>>>>                                                             be
>>>>>>>>>>>>>                                                             considering
>>>>>>>>>>>>>                                                             a full
>>>>>>>>>>>>>                                                             revision
>>>>>>>>>>>>>                                                             for
>>>>>>>>>>>>>                                                             JDK9.
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                             * In
>>>>>>>>>>>>>                                                             the
>>>>>>>>>>>>>                                                             mean
>>>>>>>>>>>>>                                                             time,
>>>>>>>>>>>>>                                                             it
>>>>>>>>>>>>>                                                             would
>>>>>>>>>>>>>                                                             make
>>>>>>>>>>>>>                                                             sense
>>>>>>>>>>>>>                                                             to
>>>>>>>>>>>>>                                                             further
>>>>>>>>>>>>>                                                             test
>>>>>>>>>>>>>                                                             and
>>>>>>>>>>>>>                                                             validate
>>>>>>>>>>>>>                                                             JVMs
>>>>>>>>>>>>>                                                             as
>>>>>>>>>>>>>                                                             meeting
>>>>>>>>>>>>>                                                             this
>>>>>>>>>>>>>                                                             likely
>>>>>>>>>>>>>                                                             future
>>>>>>>>>>>>>                                                             spec.
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                             -Doug
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                             _______________________________________________
>>>>>>>>>>>>>                                                             Concurrency-interest
>>>>>>>>>>>>>                                                             mailing
>>>>>>>>>>>>>                                                             list
>>>>>>>>>>>>>                                                             Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>>>                                                             <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>>>                                                             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                 _______________________________________________
>>>>>>>>>>>>>                                                 Concurrency-interest mailing list
>>>>>>>>>>>>>                                                 Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>>>                                                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 _______________________________________________
>>>>>>>>>>>>                                                 Concurrency-interest
>>>>>>>>>>>>                                                 mailing list
>>>>>>>>>>>>                                                 Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>>                                                 <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>>                                                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                             _______________________________________________
>>>>>>>>>>>                                             Concurrency-interest
>>>>>>>>>>>                                             mailing list
>>>>>>>>>>>                                             Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>                                             <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>                                             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     _______________________________________________
>>>>>>>>>                                     Concurrency-interest
>>>>>>>>>                                     mailing list
>>>>>>>>>                                     Concurrency-interest at cs.oswego.edu
>>>>>>>>>                                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>                                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>>
>>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/07ec0bdd/attachment-0001.html>

From oleksandr.otenko at oracle.com  Tue Dec  3 16:57:42 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 03 Dec 2013 21:57:42 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD23D5107EB@G9W0725.americas.hpqcorp.net>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D5107EB@G9W0725.americas.hpqcorp.net>
Message-ID: <529E53D6.90802@oracle.com>

On 03/12/2013 20:49, Boehm, Hans wrote:
>> From: Doug Lea
>>
>> Sorry for mis-remembering why I had treated this issue as basically
>> settled:
>> Unless a JVM always pre-zeros memory (which usually not a good option),
>> then
>> even if not explicitly initialized, volatile fields must be zeroed
>> in the constructor body, with a release fence before publication.
> Is there a general argument for that claim about pre-zeroing?  My expectation would have been that it's reasonable to pre-zero, so long as you do it in chunks small enough that the zeros are unlikely to leave the faster parts of the cache hierarchy between zeroing and use.  It seems to be a trade-off between fences and some, ideally small, risk of additional cache misses.
>
> I have a couple of other concerns about this discussion:
>
> 1. Nobody has mentioned that in the other thread of the original example, the one that does r1 = a.f, the loads of a and a.f are not currently ordered.  Once you add the required wait for a non-null a, that also matters.

Doesn't Data Dependency section cover this case? a must be loaded before 
a.f, and a load-load barrier must be inserted. Given that we are talking 
about object creation, the other thread is bound to load a before first use.

Also, the wait for non-null a is a test artifact. The real case may be:
x = a.next; // non-volatile field initialized prior to initialization of 
some volatile field - proven to be non-null
r1 = x.f; // load volatile f

Alex


>   I expect that is in fact guaranteed by all current Java implementations, but it requires a spec change.  And I think there are many plausible (and implausible) variants of that change, with substantive differences.
>
> 2. Along the same lines, and in agreement with some later posts, I still don't fully understand the rationale for providing such guarantees for volatile fields.  There is a general rule that when I construct an object, I shouldn't use it until I've finished constructing/initializing it.  That also generally applies to the built-in types.  And I think it applies to concurrent containers, even if other operations are allowed to race.  We seem to be adding a special short-cut by guaranteeing that, with safe publication, if I see a non-null pointer to the object, then I can safely conclude it has been initialized, even if there is no real happens-before relationship.  But presumably if I see a flag that was set after the initialization, no such guarantee exists?  It's not at all clear to me that this simplifies our story.
>
> IIRC, the current final field rules were developed primarily to provide some security guarantees.  It is possible to build immutable types that look immutable, even to a malicious client.  That argument doesn't apply to objects with volatile fields.
>
> Hans
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From taras.tielkes at gmail.com  Tue Dec  3 17:02:37 2013
From: taras.tielkes at gmail.com (Taras Tielkes)
Date: Tue, 3 Dec 2013 23:02:37 +0100
Subject: [concurrency-interest] Semaphore with queue limit
In-Reply-To: <1386015670.3890.54612889.797E9A5D@webmail.messagingengine.com>
References: <CA+R7V7_c2BPtTQtEZmm6pontrreXt2XeMrbP7shCkWZci+Hn5w@mail.gmail.com>
	<1386015670.3890.54612889.797E9A5D@webmail.messagingengine.com>
Message-ID: <CA+R7V78arsE9DFr5FxcHO52Xd=Jez7z4utc7oNbbO6OD_=SsOA@mail.gmail.com>

Hi,
I considered using a bounded queue, especially since in the future this
component might require request prioritization.
However, focusing on the current use cases, the double Semaphore approach
seemed an easy solution.

In addition, retaining the "same thread throughout the stack" design
property (is there a proper name for this?) seemed quite valuable (for
traceability as well as thread context propagation).
I was wondering if simply using a guard based on semaphore.getQueueLength()
would suffice, but was somewhat put off by the JavaDoc ("This method is
designed for use in monitoring of the system state, not for synchronization
control").

Kind regards,
-tt



On Mon, Dec 2, 2013 at 9:21 PM, Ariel Weisberg <ariel at weisberg.ws> wrote:

>  Hi,
>
> Unless task size for each permit/request is pretty small I would use two
> semaphores as you described.
>
> Alternatively a bounded queue for passing requests to the internal
> component would do this for you. Populate the queue with some form of
> future and have the threads wait on the futures.
>
> Regards,
> Ariel
>
>
> On Mon, Dec 2, 2013, at 02:22 PM, Taras Tielkes wrote:
>
> Hi,
>
> In a system handling concurrent external requests, I'd like to limit the
> concurrency level of an internal component. In addition to FIFO semantics,
> I'd like to put a bound on the time spent waiting for a permit to propagate
> the call to the internal component.
>
> A Semaphore in fair mode, using tryAcquire(timeout) seems to satisfy these
> requirements.
>
> However, in addition, I'd like to also put a bound in the queue of this
> semaphore.
> If 100 threads are either holding a permit, or waiting to acquire one, I'd
> like to pro-actively reject thread 101.
>
> Is there something in j.u.c. that would satisfy this use case? The best I
> can come up with is an additional "external" non-fair semaphore (with a
> larger permit set) that gets acquired before attempting to acquire a permit
> from the "internal" fair one.
>
> Thanks in advance,
> -tt
>
>
>  *_______________________________________________*
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/80ed1f8b/attachment.html>

From ariel at weisberg.ws  Tue Dec  3 17:22:33 2013
From: ariel at weisberg.ws (Ariel Weisberg)
Date: Tue, 03 Dec 2013 17:22:33 -0500
Subject: [concurrency-interest] Semaphore with queue limit
In-Reply-To: <CA+R7V78arsE9DFr5FxcHO52Xd=Jez7z4utc7oNbbO6OD_=SsOA@mail.gmail.com>
References: <CA+R7V7_c2BPtTQtEZmm6pontrreXt2XeMrbP7shCkWZci+Hn5w@mail.gmail.com>
	<1386015670.3890.54612889.797E9A5D@webmail.messagingengine.com>
	<CA+R7V78arsE9DFr5FxcHO52Xd=Jez7z4utc7oNbbO6OD_=SsOA@mail.gmail.com>
Message-ID: <1386109353.21372.55149373.5EB02FB9@webmail.messagingengine.com>

Hi,



Getting the queue length of the semaphore involves traversing a linked
list and counting the number of nodes so it won't be particularly fast.
My guess is that using the counter embedded in another semaphore will
be faster. In the common case where the system isn't falling behind you
will never touch the second semaphore since a permit will always be
available, and if it is falling behind performance won't be a big
concern because the values in both semaphores will be always be in the
shared state and you can shed load as fast as you need to.



Ariel



On Tue, Dec 3, 2013, at 05:02 PM, Taras Tielkes wrote:

Hi,
I considered using a bounded queue, especially since in the future this
component might require request prioritization.
However, focusing on the current use cases, the double Semaphore
approach seemed an easy solution.

In addition, retaining the "same thread throughout the stack" design
property (is there a proper name for this?) seemed quite valuable (for
traceability as well as thread context propagation).
I was wondering if simply using a guard based on
semaphore.getQueueLength() would suffice, but was somewhat put off by
the JavaDoc ("This method is designed for use in monitoring of the
system state, not for synchronization control").

Kind regards,
-tt



On Mon, Dec 2, 2013 at 9:21 PM, Ariel Weisberg <[1]ariel at weisberg.ws>
wrote:

Hi,

Unless task size for each permit/request is pretty small I would use
two semaphores as you described.

Alternatively a bounded queue for passing requests to the internal
component would do this for you. Populate the queue with some form of
future and have the threads wait on the futures.

Regards,
Ariel


On Mon, Dec 2, 2013, at 02:22 PM, Taras Tielkes wrote:

Hi,

In a system handling concurrent external requests, I'd like to limit
the concurrency level of an internal component. In addition to FIFO
semantics, I'd like to put a bound on the time spent waiting for a
permit to propagate the call to the internal component.

A Semaphore in fair mode, using tryAcquire(timeout) seems to satisfy
these requirements.

However, in addition, I'd like to also put a bound in the queue of this
semaphore.
If 100 threads are either holding a permit, or waiting to acquire one,
I'd like to pro-actively reject thread 101.

Is there something in j.u.c. that would satisfy this use case? The best
I can come up with is an additional "external" non-fair semaphore (with
a larger permit set) that gets acquired before attempting to acquire a
permit from the "internal" fair one.

Thanks in advance,
-tt


_______________________________________________

Concurrency-interest mailing list

[2]Concurrency-interest at cs.oswego.edu

[3]http://cs.oswego.edu/mailman/listinfo/concurrency-interest



_______________________________________________

Concurrency-interest mailing list

[4]Concurrency-interest at cs.oswego.edu

[5]http://cs.oswego.edu/mailman/listinfo/concurrency-interest




_______________________________________________

Concurrency-interest mailing list

[6]Concurrency-interest at cs.oswego.edu

[7]http://cs.oswego.edu/mailman/listinfo/concurrency-interest

References

1. mailto:ariel at weisberg.ws
2. mailto:Concurrency-interest at cs.oswego.edu
3. http://cs.oswego.edu/mailman/listinfo/concurrency-interest
4. mailto:Concurrency-interest at cs.oswego.edu
5. http://cs.oswego.edu/mailman/listinfo/concurrency-interest
6. mailto:Concurrency-interest at cs.oswego.edu
7. http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/5daffe0f/attachment.html>

From vitalyd at gmail.com  Tue Dec  3 18:41:54 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 3 Dec 2013 18:41:54 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E5265.5060003@oracle.com>
References: <5295E24C.40608@oracle.com>
	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>
	<529E033A.90903@oracle.com>
	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>
	<529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
	<529E297C.4070401@oracle.com>
	<CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>
	<529E3567.8020108@oracle.com>
	<CAHjP37GA9dQQd0Ds=zMCXTJMO4OHhr983MjcxUST07aSu6pi2A@mail.gmail.com>
	<529E4576.4070406@oracle.com>
	<CAHjP37Ewhz_BUwoG2b3ZE0pUU2STd_+UH+XS3S_H4SPeZn51jQ@mail.gmail.com>
	<529E46D0.8080903@oracle.com>
	<CAHjP37Gh95ZyOBxmfoJoNCru+=WtbpUNw+eDSJw2-Mt-gPTDYA@mail.gmail.com>
	<529E5265.5060003@oracle.com>
Message-ID: <CAHjP37Hi9pRMibPRKpbfYsJNQvqgwxSR6pV+gyvuyeP+pZmk_w@mail.gmail.com>

What is f here? Final or volatile field? If that's meant to represent
volatile, then I'm saying if there's no subsequent volatile load or store,
there's no fence at all (in theory).  If there's no previous volatile load,
there's no preceding load-store either.  I don't know why you're putting
those fences in your example.

Sent from my phone
On Dec 3, 2013 4:51 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  Look, at this level it is clear and doesn't shed more light.
>
> But consider this:
>
>   f=42;
>  f=42;
> f=42;
>
> This gets translated into:
>
>   load-store
> store-store
> store f, 42
>  load-store
> store-store
> store f,42
> store-store
> store f,42
>
> When done in constructor, this is optimizable (using the current spec!)
> into:
>
>   load-store
> store-store
> store f, 42
>  load-store
> store f,42
> store-store
>
> (no field can be observed before the reference to the instance is loaded
> the first time (see section "Data Dependency and Barriers" of the
> cookbook), so store-store before the first store f,42 can be removed,
> because the second store-store, which we keep, guarantees the reference to
> the instance cannot be published before the first store f,42;
>
> in these circumstances two stores to f will not be distinguishable from
> one store to f, so we eliminate the second store
>
> load-store may not be needed, too - depending what is done in the
> constructor)
>
>
> In this sense, both pieces translate into the same number of instructions
> and barriers, we aren't talking about an additional barrier, just the same
> kind of barrier in a different place.
>
> So, as a writer of the constructor, given that the perf cost is the same,
> and assuming everyone always done this deep optimization, when would you
> *not* want to write f=42; f=42; instead of just one f=42;? I maintain
> that writing f=42; f=42; is safer, and enforcing it at JVM level without
> having to write it is good.
>
>
> Alex
>
>
> On 03/12/2013 21:15, Vitaly Davidovich wrote:
>
> My point is this storestore doesn't exist on PPC today because there's no
> need based on spec.  There will be a need if spec is updated - this is a
> new barrier as it's not there otherwise; compiler or cpu is free to move
> assignment of ref before the volatile store, and now you need to preclude
> that.  If you had a volatile store with no subsequent volatile load or
> store, then no barrier is technically needed.  In practice, at least
> hotspot, always emits a fence after volatile store, but that need not be
> the case for others.
>
> Sent from my phone
> On Dec 3, 2013 4:02 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
> wrote:
>
>>  Yes, they do allow the reorder, so the point here is to move the
>> store-store barrier to after the volatile store - it is not doing anything
>> before the volatile store anyway.
>>
>> Alex
>>
>> On 03/12/2013 21:00, Vitaly Davidovich wrote:
>>
>> No, they don't have the storestore between ctor exit and assignment to a
>> field.  Volatile stores allow subsequent stores to reorder.
>>
>> Sent from my phone
>> On Dec 3, 2013 3:56 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>> wrote:
>>
>>>  What do you mean - new barriers?
>>>
>>> Store-store must occur after the last store preceding the volatile store
>>> in program order. If they didn't have it, they've got the bug to fix. If
>>> they do have the store-store, then they are correct w.r.t. what the spec
>>> says, and it is a matter of opinion of whether the spec needs fixing. I see
>>> the spec will be safer and better, if it gets fixed as proposed, but I see
>>> the point why people oppose it.
>>>
>>> Alex
>>>
>>> On 03/12/2013 20:18, Vitaly Davidovich wrote:
>>>
>>> Well, PPC guys didn't have the extra barriers for volatiles in
>>> constructors either (for storestore), as mentioned.  For them, this will be
>>> new barriers.  What does one tell them? Either we're "fixing" publishing or
>>> we're doing this because the cost is no greater - which is it for someone
>>> like PPC?
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 2:48 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>> wrote:
>>>
>>>>  This topic loops here.
>>>>
>>>> The other ctors don't have the barriers, so adding them costs.
>>>>
>>>> The ctors with volatiles already have the barriers, so order them in a
>>>> way that offers more safety. You already mentioned the circus with lazySet
>>>> that is needed otherwise. Since we all agree that's the safe way to do it,
>>>> and we don't advocate unsafe publishing, why not imply lazySet then.
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 03/12/2013 19:21, Vitaly Davidovich wrote:
>>>>
>>>> So to play devil's advocate, why not make all ctors behave the same
>>>> way? Afterall, people may still publish classes with no final or volatile
>>>> fields unsafely, and run into problems.  One can argue that most people
>>>> expect that upon constructor exit, all memory ops are complete.  Why only
>>>> add volatile to the mix? So that concurrency authors can attempt at
>>>> safeguarding their class from unsafe publication by a user who doesn't know
>>>> any better? Is that really worth the overhead required? Said user can still
>>>> shoot themselves in other ways.  At some point, the burden should be on
>>>> devs to know the platform, its promises/guarantees, and available tools to
>>>> add their own extra guarantees.
>>>>
>>>> Again, we're talking about data race publishing here - this is not the
>>>> norm or encouraged practice.  Why bend over backwards to accommodate it?
>>>>
>>>> Sent from my phone
>>>> On Dec 3, 2013 1:57 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
>>>> wrote:
>>>>
>>>>>  You'd need load-store after loading externally observable values with
>>>>> or without the proposed changes, but we aren't eliminating those, are we? I
>>>>> thought you meant we need new barriers.
>>>>>
>>>>> Alex
>>>>>
>>>>> On 03/12/2013 18:51, Vitaly Davidovich wrote:
>>>>>
>>>>> You would - since volatile can be modified and read many times in
>>>>> ctor, you need to ensure all loads are done before the store and before
>>>>> ctor exits - you need to ensure value of the volatile is the final one at
>>>>> the end of the ctor sequence.  Otherwise, the loads can move after the
>>>>> store.  Basically, you need lazySet() now and not plain storestore.
>>>>>
>>>>> Sent from my phone
>>>>> On Dec 3, 2013 1:44 PM, "Oleksandr Otenko" <
>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>
>>>>>>  I don't think you'd need it in a constructor.
>>>>>>
>>>>>> You can't read the fields until the reference to the instance is
>>>>>> stored. If you can stop reordering that store with the last volatile store,
>>>>>> publication is safe.
>>>>>>
>>>>>> Alex
>>>>>>
>>>>>> On 03/12/2013 18:34, Vitaly Davidovich wrote:
>>>>>>
>>>>>> For volatiles, you'd need load-store as well though.
>>>>>>
>>>>>> Sent from my phone
>>>>>> On Dec 3, 2013 1:05 PM, "Oleksandr Otenko" <
>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>
>>>>>>>  Sure.
>>>>>>>
>>>>>>> f=42;
>>>>>>>
>>>>>>> already imposes the cost of store-store barrier.
>>>>>>>
>>>>>>> f=42;
>>>>>>> f=42;
>>>>>>>
>>>>>>> does the same thing. In a constructor, eliminate the first barrier,
>>>>>>> because the order of writes to the unreachable instance is not important,
>>>>>>> and the second store. This no longer is the question of performance,
>>>>>>> because it is the same. It is the question of correctness for free.
>>>>>>>
>>>>>>> Alex
>>>>>>>
>>>>>>> On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>>>>>>
>>>>>>> Not sure that's the right view either.  The one thing the author
>>>>>>> does not control is how instances of their class are passed around.  User
>>>>>>> of the class has more context - it may actually be ok that volatiles aren't
>>>>>>> fenced here because they're already ensuring some way that it's fine,
>>>>>>> including the possibility that the instance isn't even shared at all.  As
>>>>>>> long as people know the behavior of the language/platform, they should be
>>>>>>> expected to make an educated decision on their own.
>>>>>>>
>>>>>>> Look, if performance didn't matter, you could just blindly say that
>>>>>>> all constructors have a freeze action, regardless of final fields or
>>>>>>> volatile.  That's not the case, of course.  Java and JDK have tools
>>>>>>> available to publish safely, so people doing multithreading have the
>>>>>>> ability to do the right thing.  At the end of the day, exposing concurrency
>>>>>>> to devs will lead to bugs, even beside the issues described here.
>>>>>>>
>>>>>>> Sent from my phone
>>>>>>> On Dec 3, 2013 12:42 PM, "Oleksandr Otenko" <
>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>
>>>>>>>>  No, this is a completely opposite view. The question is:
>>>>>>>>
>>>>>>>> do you as the implementor of the concurrent algorithm ever intend
>>>>>>>> the constructor design to be such that relies on the protocol that the
>>>>>>>> caller chooses to publish the reference?
>>>>>>>>
>>>>>>>> (Do you ever intend to *not* specify a no-op volatile load after
>>>>>>>> the last volatile store in the constructor?)
>>>>>>>>
>>>>>>>>
>>>>>>>> Alex
>>>>>>>>
>>>>>>>>
>>>>>>>> On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>>>>>>>
>>>>>>>> I'm confident most code that publishes objects shared across
>>>>>>>> threads does it safely.  Otherwise we're saying majority of code uses data
>>>>>>>> races?
>>>>>>>>
>>>>>>>> Sent from my phone
>>>>>>>> On Dec 3, 2013 12:21 PM, "Oleksandr Otenko" <
>>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>>
>>>>>>>>>  Hmmm.... I thought it is clear no one argues about the "*if* you
>>>>>>>>> publish safely" part. The question I am wondering about is whether you can
>>>>>>>>> find a case where publishing the reference to the instance unsafely is
>>>>>>>>> *intended*.
>>>>>>>>>
>>>>>>>>> Alex
>>>>>>>>>
>>>>>>>>> On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>>>>>>>
>>>>>>>>> But this is only if you publish unsafely, as mentioned before.  If
>>>>>>>>> you publish this class properly, you don't get races on the volatile.
>>>>>>>>> Final fields are supposed to support immutable classes, where although not
>>>>>>>>> preferrable, publishing racily is plausible (for performance).  For
>>>>>>>>> read/write volatiles, it's not compelling on the surface.
>>>>>>>>>
>>>>>>>>> Sent from my phone
>>>>>>>>> On Dec 3, 2013 11:18 AM, "Oleksandr Otenko" <
>>>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>>>
>>>>>>>>>>  Yes, but I mean that the code assumes the value to always be
>>>>>>>>>> non-null - eg a sentinel entry of the list is created at construction time.
>>>>>>>>>> Without the construction-time guarantee you'd need to test for null
>>>>>>>>>> everywhere.
>>>>>>>>>>
>>>>>>>>>> I think the same applies in other constructors - if you write the
>>>>>>>>>> initialization of the volatile, you imply that's "the least" "possible"
>>>>>>>>>> value, the value representing the initial state of the concurrent algorithm
>>>>>>>>>> - the initial value guaranteed by Java spec may not represent any valid
>>>>>>>>>> state of the concurrent algorithm, let alone the initial state.
>>>>>>>>>>
>>>>>>>>>> That's why this really boils down to "find the broad cases where
>>>>>>>>>> you do want to permit unsafe publication of the initial values of the
>>>>>>>>>> volatiles".
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> (unlike the non-volatile fields. Don't treat them as "not thread
>>>>>>>>>> safe" - instead, treat them as "assume as made thread-safe by means outside
>>>>>>>>>> the class specification", hence no requirement for "safe publication" there)
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> Alex
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>>>>>>>
>>>>>>>>>> Initial value of the field must be the "zero" value of that type,
>>>>>>>>>> that's a language spec and must be guaranteed irrespective of volatile or
>>>>>>>>>> not.
>>>>>>>>>>
>>>>>>>>>> Sent from my phone
>>>>>>>>>> On Dec 3, 2013 10:03 AM, "Oleksandr Otenko" <
>>>>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>>>>
>>>>>>>>>>>  I understand, but you can't insist on viewing ctors as "just
>>>>>>>>>>> methods" for all purposes.
>>>>>>>>>>>
>>>>>>>>>>> (2) publication is unsafe unless you get a volatile load after
>>>>>>>>>>> the last volatile store in the constructor. Besides, the initial value of
>>>>>>>>>>> the field may not even be one of the valid values, so it is not even just
>>>>>>>>>>> about a data race.
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> Alex
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> On 03/12/2013 13:57, Vitaly Davidovich wrote:
>>>>>>>>>>>
>>>>>>>>>>> For compilation/codegen purposes ctors *are* just methods - they
>>>>>>>>>>> can be inlined, code optimized, etc; that's the reason we have the final
>>>>>>>>>>> field guarantees.
>>>>>>>>>>>
>>>>>>>>>>> A couple of potential reasons not to add volatile to the spec:
>>>>>>>>>>> 1) perhaps some JVMs don't currently already give them final
>>>>>>>>>>> field semantics
>>>>>>>>>>> 2) this whole thing comes into play for unsafe publication only
>>>>>>>>>>> (I.e. data race), which is discouraged.
>>>>>>>>>>>
>>>>>>>>>>> Sent from my phone
>>>>>>>>>>> On Dec 3, 2013 6:51 AM, "Oleksandr Otenko" <
>>>>>>>>>>> oleksandr.otenko at oracle.com> wrote:
>>>>>>>>>>>
>>>>>>>>>>>>  Constructors *are* special methods. They are the first method
>>>>>>>>>>>> calls in any history of the object. This means a different treatment of
>>>>>>>>>>>> volatile accesses to the fields of the instance being created is possible -
>>>>>>>>>>>> certain barriers can be eliminated, because the loads can be proven to not
>>>>>>>>>>>> synchronize with anyone. For the sake of the argument, it is possible to
>>>>>>>>>>>> proceed with weak treatment of volatile stores, too, but you need a good
>>>>>>>>>>>> reason to permit subsequent calls to observe the initial state of the
>>>>>>>>>>>> volatile fields; whereas any volatile load in any other method always
>>>>>>>>>>>> synchronizes with a volatile store of some other method call, without the
>>>>>>>>>>>> final field semantics we cannot assume that.
>>>>>>>>>>>>
>>>>>>>>>>>> However, if we assume final field semantics, there is only one
>>>>>>>>>>>> barrier needed - a store-store after the last volatile field store. This
>>>>>>>>>>>> eliminates all barriers for any other volatile field initialization, and
>>>>>>>>>>>> eliminates a full barrier needed otherwise (got to place a dummy volatile
>>>>>>>>>>>> load after the last volatile store to make sure the semantics are stronger
>>>>>>>>>>>> than final-field) - think of removing a mfence or similar from each such
>>>>>>>>>>>> constructor on x86.
>>>>>>>>>>>>
>>>>>>>>>>>> (there will still be gotchas for cases when volatile field
>>>>>>>>>>>> initialization occurs after a volatile load of something outside the same
>>>>>>>>>>>> instance; but the main purpose is to eliminate barriers when the volatile
>>>>>>>>>>>> fields are just initialized into some instance-specific values)
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> Alex
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> On 03/12/2013 05:54, Ruslan Cheremin wrote:
>>>>>>>>>>>>
>>>>>>>>>>>> I'm about why "always mean storestore after volatile store in
>>>>>>>>>>>> constructor". It is not only efficiency which is important for MM, but also
>>>>>>>>>>>> simplicity and consistency. If constructors are special methods, not just
>>>>>>>>>>>> plain <init>, then we should add this kind of atomicity to all constructors
>>>>>>>>>>>> (which, as I was reading here, could be inefficient on some platforms). But
>>>>>>>>>>>> if constructors are just plain methods, it looks strange to have special
>>>>>>>>>>>> implicit semantics for constructors with volatiles inside.
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> 2013/12/3 Oleksandr Otenko <oleksandr.otenko at oracle.com>
>>>>>>>>>>>>
>>>>>>>>>>>>>  I think it is pretty simple.
>>>>>>>>>>>>>
>>>>>>>>>>>>> If you always mean a store-store barrier *after* the last
>>>>>>>>>>>>> volatile store in the constructor, then add that barrier into constructor
>>>>>>>>>>>>> semantics, like it's done with the final fields.
>>>>>>>>>>>>>
>>>>>>>>>>>>> It makes sense to *not* add it to the semantics, if you can
>>>>>>>>>>>>> come up with enough examples where you want that barrier to be eliminated.
>>>>>>>>>>>>>
>>>>>>>>>>>>> Alex
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>> On 02/12/2013 19:32, Ruslan Cheremin wrote:
>>>>>>>>>>>>>
>>>>>>>>>>>>> Well, I do not see any data race _on volatiles_ here. I see
>>>>>>>>>>>>> race condition on volatile .value, yes -- but it is pretty legal (and
>>>>>>>>>>>>> unavoidable, I suppose) to have race conditions even with volatiles
>>>>>>>>>>>>> involved. The only data race I see is around read-write of (non-volatile)
>>>>>>>>>>>>> AtomicInteger's reference -- which is unrelated to AtomicInteger's content.
>>>>>>>>>>>>> I mean, I could not see any noticable difference between the case
>>>>>>>>>>>>> discussed, and just any other case there volatile is _incorrectly_ used to
>>>>>>>>>>>>> "synchronize" data accesses -- it could still be data race on non-volatile
>>>>>>>>>>>>> fields, even if volatile fields are also used somewhere around. Yes, get 0
>>>>>>>>>>>>> from .value is unexpected -- but there are many unexpected things in memory
>>>>>>>>>>>>> models. It is noway more unexpected then to see default values in fields of
>>>>>>>>>>>>> any other object which is unsafely published. I think everybody who passed
>>>>>>>>>>>>> through broken atomicity of constructor call could easy see the chance to
>>>>>>>>>>>>> read [.value=0] in the case discussed.
>>>>>>>>>>>>>
>>>>>>>>>>>>>  "Data race is pure evil" was the motto of this list all time
>>>>>>>>>>>>> I was reading it. Why do we may want to introduce another example of benign
>>>>>>>>>>>>> race? Wouldn't it be just another source of confusion for newcomers?
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>> 2013/12/2 Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>>>>>
>>>>>>>>>>>>>> On 12/02/2013 03:57 AM, Cheremin Ruslan wrote:
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> Doug, could you explain why it is so important to have this
>>>>>>>>>>>>>>> kind of safe
>>>>>>>>>>>>>>> publication for volatile? I mean, could we just go with
>>>>>>>>>>>>>>> .value=0 through data
>>>>>>>>>>>>>>> race to be allowed result, as current model (seem to) imply?
>>>>>>>>>>>>>>> It seems to be a
>>>>>>>>>>>>>>> dr-case anyway, why we need special handling of it?
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>  The main reason is that it is highly irregular and unexpected
>>>>>>>>>>>>>> by programmers. Except in this case, volatiles definitionally
>>>>>>>>>>>>>> cannot
>>>>>>>>>>>>>> be subject to data races. Dealing with it requires cleverness,
>>>>>>>>>>>>>> complexity, and/or error-proneness that isn't even required
>>>>>>>>>>>>>> for
>>>>>>>>>>>>>> correctness on current JVMs. We have several constructions
>>>>>>>>>>>>>> in j.u.c that work around problems by using explicit ordered
>>>>>>>>>>>>>> writes in constructors, redundant-looking null-checks, and so
>>>>>>>>>>>>>> on. If we are going to repair the JMM anyway, this is a clear
>>>>>>>>>>>>>> candidate for reconsideration.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> -Doug
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> Ruslan
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>  27 ????. 2013 ?., ? 23:26, Doug Lea <dl at cs.oswego.edu>
>>>>>>>>>>>>>>>> ???????(?):
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>  On 11/27/2013 02:06 PM, Vitaly Davidovich wrote: But
>>>>>>>>>>>>>>>>> either way,
>>>>>>>>>>>>>>>>> optimizations to avoid zeroing memory is an implementation
>>>>>>>>>>>>>>>>> detail and
>>>>>>>>>>>>>>>>> thus cannot be relied upon from JMM standpoint, which I
>>>>>>>>>>>>>>>>> think you're
>>>>>>>>>>>>>>>>> saying.
>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>> The other issue is that even if we determine that
>>>>>>>>>>>>>>>>> volatiles don't get
>>>>>>>>>>>>>>>>> this treatment, if JVM is already ensuring it, it's not
>>>>>>>>>>>>>>>>> going to be
>>>>>>>>>>>>>>>>> practical to change it and risk hard to debug problems
>>>>>>>>>>>>>>>>> creeping in.  May
>>>>>>>>>>>>>>>>> as well update the spec now ...
>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> Right. To summarize:
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> * Programmers do not expect that even though final fields
>>>>>>>>>>>>>>>> are specifically
>>>>>>>>>>>>>>>> publication-safe, volatile fields are not always so.
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> * For various implementation reasons, JVMs arrange that
>>>>>>>>>>>>>>>> volatile fields are
>>>>>>>>>>>>>>>> publication safe anyway, at least in cases we know about.
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> * Actually updating the JMM/JLS to mandate this is not easy
>>>>>>>>>>>>>>>> (no small tweak
>>>>>>>>>>>>>>>> that I know applies). But now is a good time to be
>>>>>>>>>>>>>>>> considering a full
>>>>>>>>>>>>>>>> revision for JDK9.
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> * In the mean time, it would make sense to further test and
>>>>>>>>>>>>>>>> validate JVMs
>>>>>>>>>>>>>>>> as meeting this likely future spec.
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> -Doug
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>>>>> Concurrency-interest
>>>>>>>>>>>>>>>> mailing list Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131203/61122fb0/attachment-0001.html>

From dl at cs.oswego.edu  Tue Dec  3 19:38:13 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 03 Dec 2013 19:38:13 -0500
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD23D5107EB@G9W0725.americas.hpqcorp.net>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D5107EB@G9W0725.americas.hpqcorp.net>
Message-ID: <529E7975.4060305@cs.oswego.edu>

On 12/03/2013 03:49 PM, Boehm, Hans wrote:
>> From: Doug Lea
>>
>> Unless a JVM always pre-zeros memory (which usually not a good
>> option), then even if not explicitly initialized, volatile fields must be
>> zeroed in the constructor body, with a release fence before publication.
> Is there a general argument for that claim about pre-zeroing?  My expectation
> would have been that it's reasonable to pre-zero, so long as you do it in
> chunks small enough that the zeros are unlikely to leave the faster parts of
> the cache hierarchy between zeroing and use.  It seems to be a trade-off
> between fences and some, ideally small, risk of additional cache misses.

See Xi Yang's thesis and OOPSLA11 paper
(http://www.cs.utexas.edu/~jbsartor/OOPSLA2011Zero-submit.pdf)
for some fairly extensive analysis, that's also partially
reflected in some hotspot techniques. There are a bunch of variants
using non-temporal stores, that also end up requiring
some sort of release fence.

>
> 1. Nobody has mentioned that in the other thread of the original example, the
> one that does r1 = a.f, the loads of a and a.f are not currently ordered.
> Once you add the required wait for a non-null a, that also matters.  I expect
> that is in fact guaranteed by all current Java implementations, but it
> requires a spec change.

Right.

>
> 2. Along the same lines, and in agreement with some later posts, I still
> don't fully understand the rationale for providing such guarantees for
> volatile fields.  There is a general rule that when I construct an object, I
> shouldn't use it until I've finished constructing/initializing it.

Yes. Among the exceptions to the general rule are designs/frameworks
(including several involving dependency injection) where you
have to hand off an only-partially-stable object, and there is
no way out of this problem short of using fences (which I know
how much you love!) and/or reconsideration of rules that would
enforce something that is already done (with possible exceptions)
anyway. Given that no one expects the weakened volatile write
loophole within constructors, it seems to be the right thing to do.

-Doug


From dl at cs.oswego.edu  Tue Dec  3 20:14:06 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 03 Dec 2013 20:14:06 -0500
Subject: [concurrency-interest] Fork and and timed get
In-Reply-To: <CAJp3eRDk-DxT5Q347inDMDdQ6WLZ9aaBVWuaM5b5ARskx=aKSQ@mail.gmail.com>
References: <CAHUekz1GrJTcWrBNPtYabZhYroKiOgJAE6drYTPycpUJAEaLJw@mail.gmail.com>
	<CA+kOe0-H50YwmT-JPQe97NAxLVmeL21TFcmxB8HeT16LN4ZnyQ@mail.gmail.com>
	<CAJp3eRBJz3Tx=C3O0cne2kE2LZvLgM8iMaf=dERpVthLj2yrZw@mail.gmail.com>
	<52964197.5010801@cs.oswego.edu>
	<CAJp3eRDk-DxT5Q347inDMDdQ6WLZ9aaBVWuaM5b5ARskx=aKSQ@mail.gmail.com>
Message-ID: <529E81DE.902@cs.oswego.edu>

On 11/28/2013 10:24 AM, Romain Colle wrote:
>
> Agreed. However, I'd really like the thread management to be handled by the
> pool, exactly the way it is done today after trying to help the task in get():
> tryCompensate() / set SIGNAL / wait / incrementActiveCount().
> This is in fact doing exactly the managed block that Viktor suggested.
>
> Basically what I need is a version of get(long, TimeUnit) that simply does not
> try to help :-)
>

Even after sitting on this in background mode for a few days,
I'm not sure what to do. It's in general not an unreasonable
thing to want, but if it were included in ForkJoin{Task,Pool} proper,
then each time you call it, you are "wasting" a thread that is
guaranteed to block (as opposed to reasonable usages of ManagedBlocker
etc where you expect occasional transient blocking). Which
is no better than creating your own heavier-weight thread
to wait it out and then using a timed thread.join. Which,
all things considered, might be approximately the best internal
implementation strategy as well.

-Doug


From viktor.klang at gmail.com  Tue Dec  3 21:53:21 2013
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 4 Dec 2013 02:53:21 +0000
Subject: [concurrency-interest] Fork and and timed get
In-Reply-To: <529E81DE.902@cs.oswego.edu>
References: <CAHUekz1GrJTcWrBNPtYabZhYroKiOgJAE6drYTPycpUJAEaLJw@mail.gmail.com>
	<CA+kOe0-H50YwmT-JPQe97NAxLVmeL21TFcmxB8HeT16LN4ZnyQ@mail.gmail.com>
	<CAJp3eRBJz3Tx=C3O0cne2kE2LZvLgM8iMaf=dERpVthLj2yrZw@mail.gmail.com>
	<52964197.5010801@cs.oswego.edu>
	<CAJp3eRDk-DxT5Q347inDMDdQ6WLZ9aaBVWuaM5b5ARskx=aKSQ@mail.gmail.com>
	<529E81DE.902@cs.oswego.edu>
Message-ID: <CANPzfU_4E3jsn7F+2VSN_Z3sKG7qtEWj2WWDbUtDq5mh88Ve2Q@mail.gmail.com>

Perhaps the right suggestion is _not_ to block and use CompletableFuture
instead?


On Wed, Dec 4, 2013 at 1:14 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 11/28/2013 10:24 AM, Romain Colle wrote:
>
>>
>> Agreed. However, I'd really like the thread management to be handled by
>> the
>> pool, exactly the way it is done today after trying to help the task in
>> get():
>> tryCompensate() / set SIGNAL / wait / incrementActiveCount().
>> This is in fact doing exactly the managed block that Viktor suggested.
>>
>> Basically what I need is a version of get(long, TimeUnit) that simply
>> does not
>> try to help :-)
>>
>>
> Even after sitting on this in background mode for a few days,
> I'm not sure what to do. It's in general not an unreasonable
> thing to want, but if it were included in ForkJoin{Task,Pool} proper,
> then each time you call it, you are "wasting" a thread that is
> guaranteed to block (as opposed to reasonable usages of ManagedBlocker
> etc where you expect occasional transient blocking). Which
> is no better than creating your own heavier-weight thread
> to wait it out and then using a timed thread.join. Which,
> all things considered, might be approximately the best internal
> implementation strategy as well.
>
>
> -Doug
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Cheers,
?

*Viktor Klang*
*Director of Engineering*
Typesafe <http://www.typesafe.com/>

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131204/0dd1f337/attachment.html>

From dragonsinth at gmail.com  Wed Dec  4 07:47:17 2013
From: dragonsinth at gmail.com (Scott Blum)
Date: Wed, 4 Dec 2013 07:47:17 -0500
Subject: [concurrency-interest] Semaphore with queue limit
In-Reply-To: <CA+R7V78arsE9DFr5FxcHO52Xd=Jez7z4utc7oNbbO6OD_=SsOA@mail.gmail.com>
References: <CA+R7V7_c2BPtTQtEZmm6pontrreXt2XeMrbP7shCkWZci+Hn5w@mail.gmail.com>
	<1386015670.3890.54612889.797E9A5D@webmail.messagingengine.com>
	<CA+R7V78arsE9DFr5FxcHO52Xd=Jez7z4utc7oNbbO6OD_=SsOA@mail.gmail.com>
Message-ID: <CALuNCpjT1NAey5VeO16jju+Fmi2vA2ciutOufOkgUCx4E956Ww@mail.gmail.com>

On Tue, Dec 3, 2013 at 5:02 PM, Taras Tielkes <taras.tielkes at gmail.com>wrote:

> I was wondering if simply using a guard based on
> semaphore.getQueueLength() would suffice, but was somewhat put off by the
> JavaDoc ("This method is designed for use in monitoring of the system
> state, not for synchronization control").
>

You should be put off. :)  To use the queue length for synchronization
control, Semaphore would need to implement something like
"acquireIfQueueLengthLessThan(n)".  You don't want to do this:

if (semaphore.getQueueLength() < 100) {
  // anything can happen here!
  semaphore.acquire();
}

You can't rely on the queue length at the time you call acquire having much
to do with what the queue length was when you checked it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131204/b67bb957/attachment.html>

From oleksandr.otenko at oracle.com  Wed Dec  4 07:57:04 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Wed, 04 Dec 2013 12:57:04 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37Hi9pRMibPRKpbfYsJNQvqgwxSR6pV+gyvuyeP+pZmk_w@mail.gmail.com>
References: <5295E24C.40608@oracle.com> <529E12F4.5070501@oracle.com>
	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>
	<529E17E1.5030006@oracle.com>
	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>
	<529E1D48.5020500@oracle.com>
	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>
	<529E2679.6080204@oracle.com>
	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>
	<529E297C.4070401@oracle.com>
	<CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>
	<529E3567.8020108@oracle.com>
	<CAHjP37GA9dQQd0Ds=zMCXTJMO4OHhr983MjcxUST07aSu6pi2A@mail.gmail.com>
	<529E4576.4070406@oracle.com>
	<CAHjP37Ewhz_BUwoG2b3ZE0pUU2STd_+UH+XS3S_H4SPeZn51jQ@mail.gmail.com>
	<529E46D0.8080903@oracle.com>
	<CAHjP37Gh95ZyOBxmfoJoNCru+=WtbpUNw+eDSJw2-Mt-gPTDYA@mail.gmail.com>
	<529E5265.5060003@oracle.com>
	<CAHjP37Hi9pRMibPRKpbfYsJNQvqgwxSR6pV+gyvuyeP+pZmk_w@mail.gmail.com>
Message-ID: <529F26A0.5020801@oracle.com>

Previously you complained that I didn't mention load-store. I dropped 
them because it doesn't matter here. I added it here because you complained.

I don't know what point you are making this time.


Alex


On 03/12/2013 23:41, Vitaly Davidovich wrote:
>
> What is f here? Final or volatile field? If that's meant to represent 
> volatile, then I'm saying if there's no subsequent volatile load or 
> store, there's no fence at all (in theory).  If there's no previous 
> volatile load, there's no preceding load-store either.  I don't know 
> why you're putting those fences in your example.
>
> Sent from my phone
>
> On Dec 3, 2013 4:51 PM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     Look, at this level it is clear and doesn't shed more light.
>
>     But consider this:
>
>     f=42;
>     	f=42;
>     f=42;
>
>
>     This gets translated into:
>
>     load-store
>     store-store
>     store f, 42
>     	load-store
>     store-store
>     store f,42
>     store-store
>     store f,42
>
>
>     When done in constructor, this is optimizable (using the current
>     spec!) into:
>
>     load-store
>     store-store
>     store f, 42
>     	load-store
>     store f,42
>     store-store
>
>
>     (no field can be observed before the reference to the instance is
>     loaded the first time (see section "Data Dependency and Barriers"
>     of the cookbook), so store-store before the first store f,42 can
>     be removed, because the second store-store, which we keep,
>     guarantees the reference to the instance cannot be published
>     before the first store f,42;
>
>     in these circumstances two stores to f will not be distinguishable
>     from one store to f, so we eliminate the second store
>
>     load-store may not be needed, too - depending what is done in the
>     constructor)
>
>
>     In this sense, both pieces translate into the same number of
>     instructions and barriers, we aren't talking about an additional
>     barrier, just the same kind of barrier in a different place.
>
>     So, as a writer of the constructor, given that the perf cost is
>     the same, and assuming everyone always done this deep
>     optimization, when would you */not/* want to write f=42; f=42;
>     instead of just one f=42;? I maintain that writing f=42; f=42; is
>     safer, and enforcing it at JVM level without having to write it is
>     good.
>
>
>     Alex
>
>
>     On 03/12/2013 21:15, Vitaly Davidovich wrote:
>>
>>     My point is this storestore doesn't exist on PPC today because
>>     there's no need based on spec.  There will be a need if spec is
>>     updated - this is a new barrier as it's not there otherwise;
>>     compiler or cpu is free to move assignment of ref before the
>>     volatile store, and now you need to preclude that.  If you had a
>>     volatile store with no subsequent volatile load or store, then no
>>     barrier is technically needed.  In practice, at least hotspot,
>>     always emits a fence after volatile store, but that need not be
>>     the case for others.
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 4:02 PM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         Yes, they do allow the reorder, so the point here is to move
>>         the store-store barrier to after the volatile store - it is
>>         not doing anything before the volatile store anyway.
>>
>>         Alex
>>
>>         On 03/12/2013 21:00, Vitaly Davidovich wrote:
>>>
>>>         No, they don't have the storestore between ctor exit and
>>>         assignment to a field. Volatile stores allow subsequent
>>>         stores to reorder.
>>>
>>>         Sent from my phone
>>>
>>>         On Dec 3, 2013 3:56 PM, "Oleksandr Otenko"
>>>         <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>
>>>             What do you mean - new barriers?
>>>
>>>             Store-store must occur after the last store preceding
>>>             the volatile store in program order. If they didn't have
>>>             it, they've got the bug to fix. If they do have the
>>>             store-store, then they are correct w.r.t. what the spec
>>>             says, and it is a matter of opinion of whether the spec
>>>             needs fixing. I see the spec will be safer and better,
>>>             if it gets fixed as proposed, but I see the point why
>>>             people oppose it.
>>>
>>>             Alex
>>>
>>>             On 03/12/2013 20:18, Vitaly Davidovich wrote:
>>>>
>>>>             Well, PPC guys didn't have the extra barriers for
>>>>             volatiles in constructors either (for storestore), as
>>>>             mentioned.  For them, this will be new barriers.  What
>>>>             does one tell them? Either we're "fixing" publishing or
>>>>             we're doing this because the cost is no greater - which
>>>>             is it for someone like PPC?
>>>>
>>>>             Sent from my phone
>>>>
>>>>             On Dec 3, 2013 2:48 PM, "Oleksandr Otenko"
>>>>             <oleksandr.otenko at oracle.com
>>>>             <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>
>>>>                 This topic loops here.
>>>>
>>>>                 The other ctors don't have the barriers, so adding
>>>>                 them costs.
>>>>
>>>>                 The ctors with volatiles already have the barriers,
>>>>                 so order them in a way that offers more safety. You
>>>>                 already mentioned the circus with lazySet that is
>>>>                 needed otherwise. Since we all agree that's the
>>>>                 safe way to do it, and we don't advocate unsafe
>>>>                 publishing, why not imply lazySet then.
>>>>
>>>>                 Alex
>>>>
>>>>
>>>>                 On 03/12/2013 19:21, Vitaly Davidovich wrote:
>>>>>
>>>>>                 So to play devil's advocate, why not make all
>>>>>                 ctors behave the same way? Afterall, people may
>>>>>                 still publish classes with no final or volatile
>>>>>                 fields unsafely, and run into problems.  One can
>>>>>                 argue that most people expect that upon
>>>>>                 constructor exit, all memory ops are complete. 
>>>>>                 Why only add volatile to the mix? So that
>>>>>                 concurrency authors can attempt at safeguarding
>>>>>                 their class from unsafe publication by a user who
>>>>>                 doesn't know any better? Is that really worth the
>>>>>                 overhead required? Said user can still shoot
>>>>>                 themselves in other ways. At some point, the
>>>>>                 burden should be on devs to know the platform, its
>>>>>                 promises/guarantees, and available tools to add
>>>>>                 their own extra guarantees.
>>>>>
>>>>>                 Again, we're talking about data race publishing
>>>>>                 here - this is not the norm or encouraged
>>>>>                 practice.  Why bend over backwards to accommodate it?
>>>>>
>>>>>                 Sent from my phone
>>>>>
>>>>>                 On Dec 3, 2013 1:57 PM, "Oleksandr Otenko"
>>>>>                 <oleksandr.otenko at oracle.com
>>>>>                 <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>
>>>>>                     You'd need load-store after loading externally
>>>>>                     observable values with or without the proposed
>>>>>                     changes, but we aren't eliminating those, are
>>>>>                     we? I thought you meant we need new barriers.
>>>>>
>>>>>                     Alex
>>>>>
>>>>>                     On 03/12/2013 18:51, Vitaly Davidovich wrote:
>>>>>>
>>>>>>                     You would - since volatile can be modified
>>>>>>                     and read many times in ctor, you need to
>>>>>>                     ensure all loads are done before the store
>>>>>>                     and before ctor exits - you need to ensure
>>>>>>                     value of the volatile is the final one at the
>>>>>>                     end of the ctor sequence. Otherwise, the
>>>>>>                     loads can move after the store. Basically,
>>>>>>                     you need lazySet() now and not plain storestore.
>>>>>>
>>>>>>                     Sent from my phone
>>>>>>
>>>>>>                     On Dec 3, 2013 1:44 PM, "Oleksandr Otenko"
>>>>>>                     <oleksandr.otenko at oracle.com
>>>>>>                     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>
>>>>>>                         I don't think you'd need it in a constructor.
>>>>>>
>>>>>>                         You can't read the fields until the
>>>>>>                         reference to the instance is stored. If
>>>>>>                         you can stop reordering that store with
>>>>>>                         the last volatile store, publication is safe.
>>>>>>
>>>>>>                         Alex
>>>>>>
>>>>>>                         On 03/12/2013 18:34, Vitaly Davidovich wrote:
>>>>>>>
>>>>>>>                         For volatiles, you'd need load-store as
>>>>>>>                         well though.
>>>>>>>
>>>>>>>                         Sent from my phone
>>>>>>>
>>>>>>>                         On Dec 3, 2013 1:05 PM, "Oleksandr
>>>>>>>                         Otenko" <oleksandr.otenko at oracle.com
>>>>>>>                         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>>
>>>>>>>                             Sure.
>>>>>>>
>>>>>>>                             f=42;
>>>>>>>
>>>>>>>                             already imposes the cost of
>>>>>>>                             store-store barrier.
>>>>>>>
>>>>>>>                             f=42;
>>>>>>>                             f=42;
>>>>>>>
>>>>>>>                             does the same thing. In a
>>>>>>>                             constructor, eliminate the first
>>>>>>>                             barrier, because the order of writes
>>>>>>>                             to the unreachable instance is not
>>>>>>>                             important, and the second store.
>>>>>>>                             This no longer is the question of
>>>>>>>                             performance, because it is the same.
>>>>>>>                             It is the question of correctness
>>>>>>>                             for free.
>>>>>>>
>>>>>>>                             Alex
>>>>>>>
>>>>>>>                             On 03/12/2013 17:53, Vitaly
>>>>>>>                             Davidovich wrote:
>>>>>>>>
>>>>>>>>                             Not sure that's the right view
>>>>>>>>                             either.  The one thing the author
>>>>>>>>                             does not control is how instances
>>>>>>>>                             of their class are passed around. 
>>>>>>>>                             User of the class has more context
>>>>>>>>                             - it may actually be ok that
>>>>>>>>                             volatiles aren't fenced here
>>>>>>>>                             because they're already ensuring
>>>>>>>>                             some way that it's fine, including
>>>>>>>>                             the possibility that the instance
>>>>>>>>                             isn't even shared at all.  As long
>>>>>>>>                             as people know the behavior of the
>>>>>>>>                             language/platform, they should be
>>>>>>>>                             expected to make an educated
>>>>>>>>                             decision on their own.
>>>>>>>>
>>>>>>>>                             Look, if performance didn't matter,
>>>>>>>>                             you could just blindly say that all
>>>>>>>>                             constructors have a freeze action,
>>>>>>>>                             regardless of final fields or
>>>>>>>>                             volatile. That's not the case, of
>>>>>>>>                             course.  Java and JDK have tools
>>>>>>>>                             available to publish safely, so
>>>>>>>>                             people doing multithreading have
>>>>>>>>                             the ability to do the right thing. 
>>>>>>>>                             At the end of the day, exposing
>>>>>>>>                             concurrency to devs will lead to
>>>>>>>>                             bugs, even beside the issues
>>>>>>>>                             described here.
>>>>>>>>
>>>>>>>>                             Sent from my phone
>>>>>>>>
>>>>>>>>                             On Dec 3, 2013 12:42 PM, "Oleksandr
>>>>>>>>                             Otenko"
>>>>>>>>                             <oleksandr.otenko at oracle.com
>>>>>>>>                             <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>                             wrote:
>>>>>>>>
>>>>>>>>                                 No, this is a completely
>>>>>>>>                                 opposite view. The question is:
>>>>>>>>
>>>>>>>>                                 do you as the implementor of
>>>>>>>>                                 the concurrent algorithm ever
>>>>>>>>                                 intend the constructor design
>>>>>>>>                                 to be such that relies on the
>>>>>>>>                                 protocol that the caller
>>>>>>>>                                 chooses to publish the reference?
>>>>>>>>
>>>>>>>>                                 (Do you ever intend to /*not*/
>>>>>>>>                                 specify a no-op volatile load
>>>>>>>>                                 after the last volatile store
>>>>>>>>                                 in the constructor?)
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 Alex
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 On 03/12/2013 17:23, Vitaly
>>>>>>>>                                 Davidovich wrote:
>>>>>>>>>
>>>>>>>>>                                 I'm confident most code that
>>>>>>>>>                                 publishes objects shared
>>>>>>>>>                                 across threads does it safely.
>>>>>>>>>                                 Otherwise we're saying
>>>>>>>>>                                 majority of code uses data races?
>>>>>>>>>
>>>>>>>>>                                 Sent from my phone
>>>>>>>>>
>>>>>>>>>                                 On Dec 3, 2013 12:21 PM,
>>>>>>>>>                                 "Oleksandr Otenko"
>>>>>>>>>                                 <oleksandr.otenko at oracle.com
>>>>>>>>>                                 <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>                                 wrote:
>>>>>>>>>
>>>>>>>>>                                     Hmmm.... I thought it is
>>>>>>>>>                                     clear no one argues about
>>>>>>>>>                                     the "/*if*/ you publish
>>>>>>>>>                                     safely" part. The question
>>>>>>>>>                                     I am wondering about is
>>>>>>>>>                                     whether you can find a
>>>>>>>>>                                     case where publishing the
>>>>>>>>>                                     reference to the instance
>>>>>>>>>                                     unsafely is /intended/.
>>>>>>>>>
>>>>>>>>>                                     Alex
>>>>>>>>>
>>>>>>>>>                                     On 03/12/2013 17:14,
>>>>>>>>>                                     Vitaly Davidovich wrote:
>>>>>>>>>>
>>>>>>>>>>                                     But this is only if you
>>>>>>>>>>                                     publish unsafely, as
>>>>>>>>>>                                     mentioned before.  If you
>>>>>>>>>>                                     publish this class
>>>>>>>>>>                                     properly, you don't get
>>>>>>>>>>                                     races on the volatile.
>>>>>>>>>>                                     Final fields are supposed
>>>>>>>>>>                                     to support immutable
>>>>>>>>>>                                     classes, where although
>>>>>>>>>>                                     not preferrable,
>>>>>>>>>>                                     publishing racily is
>>>>>>>>>>                                     plausible (for
>>>>>>>>>>                                     performance). For
>>>>>>>>>>                                     read/write volatiles,
>>>>>>>>>>                                     it's not compelling on
>>>>>>>>>>                                     the surface.
>>>>>>>>>>
>>>>>>>>>>                                     Sent from my phone
>>>>>>>>>>
>>>>>>>>>>                                     On Dec 3, 2013 11:18 AM,
>>>>>>>>>>                                     "Oleksandr Otenko"
>>>>>>>>>>                                     <oleksandr.otenko at oracle.com
>>>>>>>>>>                                     <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>>                                     wrote:
>>>>>>>>>>
>>>>>>>>>>                                         Yes, but I mean that
>>>>>>>>>>                                         the code assumes the
>>>>>>>>>>                                         value to always be
>>>>>>>>>>                                         non-null - eg a
>>>>>>>>>>                                         sentinel entry of the
>>>>>>>>>>                                         list is created at
>>>>>>>>>>                                         construction time.
>>>>>>>>>>                                         Without the
>>>>>>>>>>                                         construction-time
>>>>>>>>>>                                         guarantee you'd need
>>>>>>>>>>                                         to test for null
>>>>>>>>>>                                         everywhere.
>>>>>>>>>>
>>>>>>>>>>                                         I think the same
>>>>>>>>>>                                         applies in other
>>>>>>>>>>                                         constructors - if you
>>>>>>>>>>                                         write the
>>>>>>>>>>                                         initialization of the
>>>>>>>>>>                                         volatile, you imply
>>>>>>>>>>                                         that's "the least"
>>>>>>>>>>                                         "possible" value, the
>>>>>>>>>>                                         value representing
>>>>>>>>>>                                         the initial state of
>>>>>>>>>>                                         the concurrent
>>>>>>>>>>                                         algorithm - the
>>>>>>>>>>                                         initial value
>>>>>>>>>>                                         guaranteed by Java
>>>>>>>>>>                                         spec may not
>>>>>>>>>>                                         represent any valid
>>>>>>>>>>                                         state of the
>>>>>>>>>>                                         concurrent algorithm,
>>>>>>>>>>                                         let alone the initial
>>>>>>>>>>                                         state.
>>>>>>>>>>
>>>>>>>>>>                                         That's why this
>>>>>>>>>>                                         really boils down to
>>>>>>>>>>                                         "find the broad cases
>>>>>>>>>>                                         where you do want to
>>>>>>>>>>                                         permit unsafe
>>>>>>>>>>                                         publication of the
>>>>>>>>>>                                         initial values of the
>>>>>>>>>>                                         volatiles".
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         (unlike the
>>>>>>>>>>                                         non-volatile fields.
>>>>>>>>>>                                         Don't treat them as
>>>>>>>>>>                                         "not thread safe" -
>>>>>>>>>>                                         instead, treat them
>>>>>>>>>>                                         as "assume as made
>>>>>>>>>>                                         thread-safe by means
>>>>>>>>>>                                         outside the class
>>>>>>>>>>                                         specification", hence
>>>>>>>>>>                                         no requirement for
>>>>>>>>>>                                         "safe publication" there)
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         Alex
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         On 03/12/2013 15:08,
>>>>>>>>>>                                         Vitaly Davidovich wrote:
>>>>>>>>>>>
>>>>>>>>>>>                                         Initial value of the
>>>>>>>>>>>                                         field must be the
>>>>>>>>>>>                                         "zero" value of that
>>>>>>>>>>>                                         type, that's a
>>>>>>>>>>>                                         language spec and
>>>>>>>>>>>                                         must be guaranteed
>>>>>>>>>>>                                         irrespective of
>>>>>>>>>>>                                         volatile or not.
>>>>>>>>>>>
>>>>>>>>>>>                                         Sent from my phone
>>>>>>>>>>>
>>>>>>>>>>>                                         On Dec 3, 2013 10:03
>>>>>>>>>>>                                         AM, "Oleksandr
>>>>>>>>>>>                                         Otenko"
>>>>>>>>>>>                                         <oleksandr.otenko at oracle.com
>>>>>>>>>>>                                         <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>>>                                         wrote:
>>>>>>>>>>>
>>>>>>>>>>>                                             I understand,
>>>>>>>>>>>                                             but you can't
>>>>>>>>>>>                                             insist on
>>>>>>>>>>>                                             viewing ctors as
>>>>>>>>>>>                                             "just methods"
>>>>>>>>>>>                                             for all purposes.
>>>>>>>>>>>
>>>>>>>>>>>                                             (2) publication
>>>>>>>>>>>                                             is unsafe unless
>>>>>>>>>>>                                             you get a
>>>>>>>>>>>                                             volatile load
>>>>>>>>>>>                                             after the last
>>>>>>>>>>>                                             volatile store
>>>>>>>>>>>                                             in the
>>>>>>>>>>>                                             constructor.
>>>>>>>>>>>                                             Besides, the
>>>>>>>>>>>                                             initial value of
>>>>>>>>>>>                                             the field may
>>>>>>>>>>>                                             not even be one
>>>>>>>>>>>                                             of the valid
>>>>>>>>>>>                                             values, so it is
>>>>>>>>>>>                                             not even just
>>>>>>>>>>>                                             about a data race.
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                             Alex
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>                                             On 03/12/2013
>>>>>>>>>>>                                             13:57, Vitaly
>>>>>>>>>>>                                             Davidovich wrote:
>>>>>>>>>>>>
>>>>>>>>>>>>                                             For
>>>>>>>>>>>>                                             compilation/codegen
>>>>>>>>>>>>                                             purposes ctors
>>>>>>>>>>>>                                             *are* just
>>>>>>>>>>>>                                             methods - they
>>>>>>>>>>>>                                             can be inlined,
>>>>>>>>>>>>                                             code optimized,
>>>>>>>>>>>>                                             etc; that's the
>>>>>>>>>>>>                                             reason we have
>>>>>>>>>>>>                                             the final field
>>>>>>>>>>>>                                             guarantees.
>>>>>>>>>>>>
>>>>>>>>>>>>                                             A couple of
>>>>>>>>>>>>                                             potential
>>>>>>>>>>>>                                             reasons not to
>>>>>>>>>>>>                                             add volatile to
>>>>>>>>>>>>                                             the spec:
>>>>>>>>>>>>                                             1) perhaps some
>>>>>>>>>>>>                                             JVMs don't
>>>>>>>>>>>>                                             currently
>>>>>>>>>>>>                                             already give
>>>>>>>>>>>>                                             them final
>>>>>>>>>>>>                                             field semantics
>>>>>>>>>>>>                                             2) this whole
>>>>>>>>>>>>                                             thing comes
>>>>>>>>>>>>                                             into play for
>>>>>>>>>>>>                                             unsafe
>>>>>>>>>>>>                                             publication
>>>>>>>>>>>>                                             only (I.e. data
>>>>>>>>>>>>                                             race), which is
>>>>>>>>>>>>                                             discouraged.
>>>>>>>>>>>>
>>>>>>>>>>>>                                             Sent from my phone
>>>>>>>>>>>>
>>>>>>>>>>>>                                             On Dec 3, 2013
>>>>>>>>>>>>                                             6:51 AM,
>>>>>>>>>>>>                                             "Oleksandr
>>>>>>>>>>>>                                             Otenko"
>>>>>>>>>>>>                                             <oleksandr.otenko at oracle.com
>>>>>>>>>>>>                                             <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>>>>                                             wrote:
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 Constructors /are/
>>>>>>>>>>>>                                                 special
>>>>>>>>>>>>                                                 methods.
>>>>>>>>>>>>                                                 They are
>>>>>>>>>>>>                                                 the first
>>>>>>>>>>>>                                                 method
>>>>>>>>>>>>                                                 calls in
>>>>>>>>>>>>                                                 any history
>>>>>>>>>>>>                                                 of the
>>>>>>>>>>>>                                                 object.
>>>>>>>>>>>>                                                 This means
>>>>>>>>>>>>                                                 a different
>>>>>>>>>>>>                                                 treatment
>>>>>>>>>>>>                                                 of volatile
>>>>>>>>>>>>                                                 accesses to
>>>>>>>>>>>>                                                 the fields
>>>>>>>>>>>>                                                 of the
>>>>>>>>>>>>                                                 instance
>>>>>>>>>>>>                                                 being
>>>>>>>>>>>>                                                 created is
>>>>>>>>>>>>                                                 possible -
>>>>>>>>>>>>                                                 certain
>>>>>>>>>>>>                                                 barriers
>>>>>>>>>>>>                                                 can be
>>>>>>>>>>>>                                                 eliminated,
>>>>>>>>>>>>                                                 because the
>>>>>>>>>>>>                                                 loads can
>>>>>>>>>>>>                                                 be proven
>>>>>>>>>>>>                                                 to not
>>>>>>>>>>>>                                                 synchronize
>>>>>>>>>>>>                                                 with
>>>>>>>>>>>>                                                 anyone. For
>>>>>>>>>>>>                                                 the sake of
>>>>>>>>>>>>                                                 the
>>>>>>>>>>>>                                                 argument,
>>>>>>>>>>>>                                                 it is
>>>>>>>>>>>>                                                 possible to
>>>>>>>>>>>>                                                 proceed
>>>>>>>>>>>>                                                 with weak
>>>>>>>>>>>>                                                 treatment
>>>>>>>>>>>>                                                 of volatile
>>>>>>>>>>>>                                                 stores,
>>>>>>>>>>>>                                                 too, but
>>>>>>>>>>>>                                                 you need a
>>>>>>>>>>>>                                                 good reason
>>>>>>>>>>>>                                                 to permit
>>>>>>>>>>>>                                                 subsequent
>>>>>>>>>>>>                                                 calls to
>>>>>>>>>>>>                                                 observe the
>>>>>>>>>>>>                                                 initial
>>>>>>>>>>>>                                                 state of
>>>>>>>>>>>>                                                 the
>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>                                                 fields;
>>>>>>>>>>>>                                                 whereas any
>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>                                                 load in any
>>>>>>>>>>>>                                                 other
>>>>>>>>>>>>                                                 method
>>>>>>>>>>>>                                                 always
>>>>>>>>>>>>                                                 synchronizes with
>>>>>>>>>>>>                                                 a volatile
>>>>>>>>>>>>                                                 store of
>>>>>>>>>>>>                                                 some other
>>>>>>>>>>>>                                                 method
>>>>>>>>>>>>                                                 call,
>>>>>>>>>>>>                                                 without the
>>>>>>>>>>>>                                                 final field
>>>>>>>>>>>>                                                 semantics
>>>>>>>>>>>>                                                 we cannot
>>>>>>>>>>>>                                                 assume that.
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 However, if
>>>>>>>>>>>>                                                 we assume
>>>>>>>>>>>>                                                 final field
>>>>>>>>>>>>                                                 semantics,
>>>>>>>>>>>>                                                 there is
>>>>>>>>>>>>                                                 only one
>>>>>>>>>>>>                                                 barrier
>>>>>>>>>>>>                                                 needed - a
>>>>>>>>>>>>                                                 store-store
>>>>>>>>>>>>                                                 after the
>>>>>>>>>>>>                                                 last
>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>                                                 field
>>>>>>>>>>>>                                                 store. This
>>>>>>>>>>>>                                                 eliminates
>>>>>>>>>>>>                                                 all
>>>>>>>>>>>>                                                 barriers
>>>>>>>>>>>>                                                 for any
>>>>>>>>>>>>                                                 other
>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>                                                 field
>>>>>>>>>>>>                                                 initialization,
>>>>>>>>>>>>                                                 and
>>>>>>>>>>>>                                                 eliminates
>>>>>>>>>>>>                                                 a full
>>>>>>>>>>>>                                                 barrier
>>>>>>>>>>>>                                                 needed
>>>>>>>>>>>>                                                 otherwise
>>>>>>>>>>>>                                                 (got to
>>>>>>>>>>>>                                                 place a
>>>>>>>>>>>>                                                 dummy
>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>                                                 load after
>>>>>>>>>>>>                                                 the last
>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>                                                 store to
>>>>>>>>>>>>                                                 make sure
>>>>>>>>>>>>                                                 the
>>>>>>>>>>>>                                                 semantics
>>>>>>>>>>>>                                                 are
>>>>>>>>>>>>                                                 stronger
>>>>>>>>>>>>                                                 than
>>>>>>>>>>>>                                                 final-field) -
>>>>>>>>>>>>                                                 think of
>>>>>>>>>>>>                                                 removing a
>>>>>>>>>>>>                                                 mfence or
>>>>>>>>>>>>                                                 similar
>>>>>>>>>>>>                                                 from each
>>>>>>>>>>>>                                                 such
>>>>>>>>>>>>                                                 constructor
>>>>>>>>>>>>                                                 on x86.
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 (there will
>>>>>>>>>>>>                                                 still be
>>>>>>>>>>>>                                                 gotchas for
>>>>>>>>>>>>                                                 cases when
>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>                                                 field
>>>>>>>>>>>>                                                 initialization
>>>>>>>>>>>>                                                 occurs
>>>>>>>>>>>>                                                 after a
>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>                                                 load of
>>>>>>>>>>>>                                                 something
>>>>>>>>>>>>                                                 outside the
>>>>>>>>>>>>                                                 same
>>>>>>>>>>>>                                                 instance;
>>>>>>>>>>>>                                                 but the
>>>>>>>>>>>>                                                 main
>>>>>>>>>>>>                                                 purpose is
>>>>>>>>>>>>                                                 to
>>>>>>>>>>>>                                                 eliminate
>>>>>>>>>>>>                                                 barriers
>>>>>>>>>>>>                                                 when the
>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>                                                 fields are
>>>>>>>>>>>>                                                 just
>>>>>>>>>>>>                                                 initialized
>>>>>>>>>>>>                                                 into some
>>>>>>>>>>>>                                                 instance-specific
>>>>>>>>>>>>                                                 values)
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 Alex
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 On
>>>>>>>>>>>>                                                 03/12/2013
>>>>>>>>>>>>                                                 05:54,
>>>>>>>>>>>>                                                 Ruslan
>>>>>>>>>>>>                                                 Cheremin wrote:
>>>>>>>>>>>>>                                                 I'm about
>>>>>>>>>>>>>                                                 why
>>>>>>>>>>>>>                                                 "always
>>>>>>>>>>>>>                                                 mean
>>>>>>>>>>>>>                                                 storestore
>>>>>>>>>>>>>                                                 after
>>>>>>>>>>>>>                                                 volatile
>>>>>>>>>>>>>                                                 store in
>>>>>>>>>>>>>                                                 constructor".
>>>>>>>>>>>>>                                                 It is not
>>>>>>>>>>>>>                                                 only
>>>>>>>>>>>>>                                                 efficiency
>>>>>>>>>>>>>                                                 which is
>>>>>>>>>>>>>                                                 important
>>>>>>>>>>>>>                                                 for MM,
>>>>>>>>>>>>>                                                 but also
>>>>>>>>>>>>>                                                 simplicity
>>>>>>>>>>>>>                                                 and
>>>>>>>>>>>>>                                                 consistency.
>>>>>>>>>>>>>                                                 If
>>>>>>>>>>>>>                                                 constructors
>>>>>>>>>>>>>                                                 are
>>>>>>>>>>>>>                                                 special
>>>>>>>>>>>>>                                                 methods,
>>>>>>>>>>>>>                                                 not just
>>>>>>>>>>>>>                                                 plain
>>>>>>>>>>>>>                                                 <init>,
>>>>>>>>>>>>>                                                 then we
>>>>>>>>>>>>>                                                 should add
>>>>>>>>>>>>>                                                 this kind
>>>>>>>>>>>>>                                                 of
>>>>>>>>>>>>>                                                 atomicity
>>>>>>>>>>>>>                                                 to all
>>>>>>>>>>>>>                                                 constructors
>>>>>>>>>>>>>                                                 (which, as
>>>>>>>>>>>>>                                                 I was
>>>>>>>>>>>>>                                                 reading
>>>>>>>>>>>>>                                                 here,
>>>>>>>>>>>>>                                                 could be
>>>>>>>>>>>>>                                                 inefficient on
>>>>>>>>>>>>>                                                 some
>>>>>>>>>>>>>                                                 platforms). But
>>>>>>>>>>>>>                                                 if
>>>>>>>>>>>>>                                                 constructors
>>>>>>>>>>>>>                                                 are just
>>>>>>>>>>>>>                                                 plain
>>>>>>>>>>>>>                                                 methods,
>>>>>>>>>>>>>                                                 it looks
>>>>>>>>>>>>>                                                 strange to
>>>>>>>>>>>>>                                                 have
>>>>>>>>>>>>>                                                 special
>>>>>>>>>>>>>                                                 implicit
>>>>>>>>>>>>>                                                 semantics
>>>>>>>>>>>>>                                                 for
>>>>>>>>>>>>>                                                 constructors
>>>>>>>>>>>>>                                                 with
>>>>>>>>>>>>>                                                 volatiles
>>>>>>>>>>>>>                                                 inside.
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                 2013/12/3
>>>>>>>>>>>>>                                                 Oleksandr
>>>>>>>>>>>>>                                                 Otenko
>>>>>>>>>>>>>                                                 <oleksandr.otenko at oracle.com
>>>>>>>>>>>>>                                                 <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                     I
>>>>>>>>>>>>>                                                     think
>>>>>>>>>>>>>                                                     it is
>>>>>>>>>>>>>                                                     pretty
>>>>>>>>>>>>>                                                     simple.
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                     If you
>>>>>>>>>>>>>                                                     always
>>>>>>>>>>>>>                                                     mean a
>>>>>>>>>>>>>                                                     store-store
>>>>>>>>>>>>>                                                     barrier /after/
>>>>>>>>>>>>>                                                     the
>>>>>>>>>>>>>                                                     last
>>>>>>>>>>>>>                                                     volatile
>>>>>>>>>>>>>                                                     store
>>>>>>>>>>>>>                                                     in the
>>>>>>>>>>>>>                                                     constructor,
>>>>>>>>>>>>>                                                     then
>>>>>>>>>>>>>                                                     add
>>>>>>>>>>>>>                                                     that
>>>>>>>>>>>>>                                                     barrier into
>>>>>>>>>>>>>                                                     constructor
>>>>>>>>>>>>>                                                     semantics,
>>>>>>>>>>>>>                                                     like
>>>>>>>>>>>>>                                                     it's
>>>>>>>>>>>>>                                                     done
>>>>>>>>>>>>>                                                     with
>>>>>>>>>>>>>                                                     the
>>>>>>>>>>>>>                                                     final
>>>>>>>>>>>>>                                                     fields.
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                     It
>>>>>>>>>>>>>                                                     makes
>>>>>>>>>>>>>                                                     sense
>>>>>>>>>>>>>                                                     to
>>>>>>>>>>>>>                                                     /not/
>>>>>>>>>>>>>                                                     add it
>>>>>>>>>>>>>                                                     to the
>>>>>>>>>>>>>                                                     semantics,
>>>>>>>>>>>>>                                                     if you
>>>>>>>>>>>>>                                                     can
>>>>>>>>>>>>>                                                     come
>>>>>>>>>>>>>                                                     up
>>>>>>>>>>>>>                                                     with
>>>>>>>>>>>>>                                                     enough
>>>>>>>>>>>>>                                                     examples
>>>>>>>>>>>>>                                                     where
>>>>>>>>>>>>>                                                     you
>>>>>>>>>>>>>                                                     want
>>>>>>>>>>>>>                                                     that
>>>>>>>>>>>>>                                                     barrier to
>>>>>>>>>>>>>                                                     be
>>>>>>>>>>>>>                                                     eliminated.
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                     Alex
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                     On
>>>>>>>>>>>>>                                                     02/12/2013
>>>>>>>>>>>>>                                                     19:32,
>>>>>>>>>>>>>                                                     Ruslan
>>>>>>>>>>>>>                                                     Cheremin
>>>>>>>>>>>>>                                                     wrote:
>>>>>>>>>>>>>>                                                     Well,
>>>>>>>>>>>>>>                                                     I do
>>>>>>>>>>>>>>                                                     not
>>>>>>>>>>>>>>                                                     see
>>>>>>>>>>>>>>                                                     any
>>>>>>>>>>>>>>                                                     data
>>>>>>>>>>>>>>                                                     race
>>>>>>>>>>>>>>                                                     _on
>>>>>>>>>>>>>>                                                     volatiles_
>>>>>>>>>>>>>>                                                     here.
>>>>>>>>>>>>>>                                                     I see
>>>>>>>>>>>>>>                                                     race
>>>>>>>>>>>>>>                                                     condition
>>>>>>>>>>>>>>                                                     on
>>>>>>>>>>>>>>                                                     volatile
>>>>>>>>>>>>>>                                                     .value,
>>>>>>>>>>>>>>                                                     yes
>>>>>>>>>>>>>>                                                     --
>>>>>>>>>>>>>>                                                     but
>>>>>>>>>>>>>>                                                     it is
>>>>>>>>>>>>>>                                                     pretty legal
>>>>>>>>>>>>>>                                                     (and
>>>>>>>>>>>>>>                                                     unavoidable,
>>>>>>>>>>>>>>                                                     I
>>>>>>>>>>>>>>                                                     suppose)
>>>>>>>>>>>>>>                                                     to
>>>>>>>>>>>>>>                                                     have
>>>>>>>>>>>>>>                                                     race
>>>>>>>>>>>>>>                                                     conditions
>>>>>>>>>>>>>>                                                     even
>>>>>>>>>>>>>>                                                     with
>>>>>>>>>>>>>>                                                     volatiles
>>>>>>>>>>>>>>                                                     involved.
>>>>>>>>>>>>>>                                                     The
>>>>>>>>>>>>>>                                                     only
>>>>>>>>>>>>>>                                                     data
>>>>>>>>>>>>>>                                                     race
>>>>>>>>>>>>>>                                                     I see
>>>>>>>>>>>>>>                                                     is
>>>>>>>>>>>>>>                                                     around read-write
>>>>>>>>>>>>>>                                                     of
>>>>>>>>>>>>>>                                                     (non-volatile)
>>>>>>>>>>>>>>                                                     AtomicInteger's
>>>>>>>>>>>>>>                                                     reference
>>>>>>>>>>>>>>                                                     --
>>>>>>>>>>>>>>                                                     which
>>>>>>>>>>>>>>                                                     is
>>>>>>>>>>>>>>                                                     unrelated
>>>>>>>>>>>>>>                                                     to
>>>>>>>>>>>>>>                                                     AtomicInteger's
>>>>>>>>>>>>>>                                                     content.
>>>>>>>>>>>>>>                                                     I
>>>>>>>>>>>>>>                                                     mean,
>>>>>>>>>>>>>>                                                     I
>>>>>>>>>>>>>>                                                     could
>>>>>>>>>>>>>>                                                     not
>>>>>>>>>>>>>>                                                     see
>>>>>>>>>>>>>>                                                     any
>>>>>>>>>>>>>>                                                     noticable
>>>>>>>>>>>>>>                                                     difference
>>>>>>>>>>>>>>                                                     between
>>>>>>>>>>>>>>                                                     the
>>>>>>>>>>>>>>                                                     case
>>>>>>>>>>>>>>                                                     discussed,
>>>>>>>>>>>>>>                                                     and
>>>>>>>>>>>>>>                                                     just
>>>>>>>>>>>>>>                                                     any
>>>>>>>>>>>>>>                                                     other
>>>>>>>>>>>>>>                                                     case
>>>>>>>>>>>>>>                                                     there
>>>>>>>>>>>>>>                                                     volatile
>>>>>>>>>>>>>>                                                     is
>>>>>>>>>>>>>>                                                     _incorrectly_
>>>>>>>>>>>>>>                                                     used
>>>>>>>>>>>>>>                                                     to
>>>>>>>>>>>>>>                                                     "synchronize"
>>>>>>>>>>>>>>                                                     data
>>>>>>>>>>>>>>                                                     accesses
>>>>>>>>>>>>>>                                                     -- it
>>>>>>>>>>>>>>                                                     could
>>>>>>>>>>>>>>                                                     still
>>>>>>>>>>>>>>                                                     be
>>>>>>>>>>>>>>                                                     data
>>>>>>>>>>>>>>                                                     race
>>>>>>>>>>>>>>                                                     on
>>>>>>>>>>>>>>                                                     non-volatile
>>>>>>>>>>>>>>                                                     fields,
>>>>>>>>>>>>>>                                                     even
>>>>>>>>>>>>>>                                                     if
>>>>>>>>>>>>>>                                                     volatile
>>>>>>>>>>>>>>                                                     fields are
>>>>>>>>>>>>>>                                                     also
>>>>>>>>>>>>>>                                                     used
>>>>>>>>>>>>>>                                                     somewhere
>>>>>>>>>>>>>>                                                     around.
>>>>>>>>>>>>>>                                                     Yes,
>>>>>>>>>>>>>>                                                     get 0
>>>>>>>>>>>>>>                                                     from
>>>>>>>>>>>>>>                                                     .value is
>>>>>>>>>>>>>>                                                     unexpected
>>>>>>>>>>>>>>                                                     --
>>>>>>>>>>>>>>                                                     but
>>>>>>>>>>>>>>                                                     there
>>>>>>>>>>>>>>                                                     are
>>>>>>>>>>>>>>                                                     many
>>>>>>>>>>>>>>                                                     unexpected
>>>>>>>>>>>>>>                                                     things in
>>>>>>>>>>>>>>                                                     memory models.
>>>>>>>>>>>>>>                                                     It is
>>>>>>>>>>>>>>                                                     noway
>>>>>>>>>>>>>>                                                     more
>>>>>>>>>>>>>>                                                     unexpected
>>>>>>>>>>>>>>                                                     then
>>>>>>>>>>>>>>                                                     to
>>>>>>>>>>>>>>                                                     see
>>>>>>>>>>>>>>                                                     default
>>>>>>>>>>>>>>                                                     values in
>>>>>>>>>>>>>>                                                     fields of
>>>>>>>>>>>>>>                                                     any
>>>>>>>>>>>>>>                                                     other
>>>>>>>>>>>>>>                                                     object which
>>>>>>>>>>>>>>                                                     is
>>>>>>>>>>>>>>                                                     unsafely
>>>>>>>>>>>>>>                                                     published.
>>>>>>>>>>>>>>                                                     I
>>>>>>>>>>>>>>                                                     think
>>>>>>>>>>>>>>                                                     everybody
>>>>>>>>>>>>>>                                                     who
>>>>>>>>>>>>>>                                                     passed through
>>>>>>>>>>>>>>                                                     broken atomicity
>>>>>>>>>>>>>>                                                     of
>>>>>>>>>>>>>>                                                     constructor
>>>>>>>>>>>>>>                                                     call
>>>>>>>>>>>>>>                                                     could
>>>>>>>>>>>>>>                                                     easy
>>>>>>>>>>>>>>                                                     see
>>>>>>>>>>>>>>                                                     the
>>>>>>>>>>>>>>                                                     chance to
>>>>>>>>>>>>>>                                                     read
>>>>>>>>>>>>>>                                                     [.value=0]
>>>>>>>>>>>>>>                                                     in
>>>>>>>>>>>>>>                                                     the
>>>>>>>>>>>>>>                                                     case
>>>>>>>>>>>>>>                                                     discussed.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                     "Data
>>>>>>>>>>>>>>                                                     race
>>>>>>>>>>>>>>                                                     is
>>>>>>>>>>>>>>                                                     pure
>>>>>>>>>>>>>>                                                     evil"
>>>>>>>>>>>>>>                                                     was
>>>>>>>>>>>>>>                                                     the
>>>>>>>>>>>>>>                                                     motto
>>>>>>>>>>>>>>                                                     of
>>>>>>>>>>>>>>                                                     this
>>>>>>>>>>>>>>                                                     list
>>>>>>>>>>>>>>                                                     all
>>>>>>>>>>>>>>                                                     time
>>>>>>>>>>>>>>                                                     I was
>>>>>>>>>>>>>>                                                     reading
>>>>>>>>>>>>>>                                                     it.
>>>>>>>>>>>>>>                                                     Why
>>>>>>>>>>>>>>                                                     do we
>>>>>>>>>>>>>>                                                     may
>>>>>>>>>>>>>>                                                     want
>>>>>>>>>>>>>>                                                     to
>>>>>>>>>>>>>>                                                     introduce
>>>>>>>>>>>>>>                                                     another
>>>>>>>>>>>>>>                                                     example
>>>>>>>>>>>>>>                                                     of
>>>>>>>>>>>>>>                                                     benign race?
>>>>>>>>>>>>>>                                                     Wouldn't
>>>>>>>>>>>>>>                                                     it be
>>>>>>>>>>>>>>                                                     just
>>>>>>>>>>>>>>                                                     another
>>>>>>>>>>>>>>                                                     source of
>>>>>>>>>>>>>>                                                     confusion
>>>>>>>>>>>>>>                                                     for
>>>>>>>>>>>>>>                                                     newcomers?
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                     2013/12/2
>>>>>>>>>>>>>>                                                     Doug
>>>>>>>>>>>>>>                                                     Lea
>>>>>>>>>>>>>>                                                     <dl at cs.oswego.edu
>>>>>>>>>>>>>>                                                     <mailto:dl at cs.oswego.edu>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                         On 12/02/2013
>>>>>>>>>>>>>>                                                         03:57
>>>>>>>>>>>>>>                                                         AM,
>>>>>>>>>>>>>>                                                         Cheremin
>>>>>>>>>>>>>>                                                         Ruslan
>>>>>>>>>>>>>>                                                         wrote:
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                             Doug,
>>>>>>>>>>>>>>                                                             could
>>>>>>>>>>>>>>                                                             you
>>>>>>>>>>>>>>                                                             explain
>>>>>>>>>>>>>>                                                             why
>>>>>>>>>>>>>>                                                             it
>>>>>>>>>>>>>>                                                             is
>>>>>>>>>>>>>>                                                             so
>>>>>>>>>>>>>>                                                             important
>>>>>>>>>>>>>>                                                             to
>>>>>>>>>>>>>>                                                             have
>>>>>>>>>>>>>>                                                             this
>>>>>>>>>>>>>>                                                             kind
>>>>>>>>>>>>>>                                                             of
>>>>>>>>>>>>>>                                                             safe
>>>>>>>>>>>>>>                                                             publication
>>>>>>>>>>>>>>                                                             for
>>>>>>>>>>>>>>                                                             volatile?
>>>>>>>>>>>>>>                                                             I mean,
>>>>>>>>>>>>>>                                                             could
>>>>>>>>>>>>>>                                                             we
>>>>>>>>>>>>>>                                                             just
>>>>>>>>>>>>>>                                                             go
>>>>>>>>>>>>>>                                                             with
>>>>>>>>>>>>>>                                                             .value=0
>>>>>>>>>>>>>>                                                             through
>>>>>>>>>>>>>>                                                             data
>>>>>>>>>>>>>>                                                             race
>>>>>>>>>>>>>>                                                             to
>>>>>>>>>>>>>>                                                             be
>>>>>>>>>>>>>>                                                             allowed
>>>>>>>>>>>>>>                                                             result,
>>>>>>>>>>>>>>                                                             as
>>>>>>>>>>>>>>                                                             current
>>>>>>>>>>>>>>                                                             model
>>>>>>>>>>>>>>                                                             (seem
>>>>>>>>>>>>>>                                                             to)
>>>>>>>>>>>>>>                                                             imply?
>>>>>>>>>>>>>>                                                             It
>>>>>>>>>>>>>>                                                             seems
>>>>>>>>>>>>>>                                                             to
>>>>>>>>>>>>>>                                                             be
>>>>>>>>>>>>>>                                                             a
>>>>>>>>>>>>>>                                                             dr-case
>>>>>>>>>>>>>>                                                             anyway,
>>>>>>>>>>>>>>                                                             why
>>>>>>>>>>>>>>                                                             we
>>>>>>>>>>>>>>                                                             need
>>>>>>>>>>>>>>                                                             special
>>>>>>>>>>>>>>                                                             handling
>>>>>>>>>>>>>>                                                             of
>>>>>>>>>>>>>>                                                             it?
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                         The
>>>>>>>>>>>>>>                                                         main
>>>>>>>>>>>>>>                                                         reason
>>>>>>>>>>>>>>                                                         is that
>>>>>>>>>>>>>>                                                         it is
>>>>>>>>>>>>>>                                                         highly
>>>>>>>>>>>>>>                                                         irregular
>>>>>>>>>>>>>>                                                         and
>>>>>>>>>>>>>>                                                         unexpected
>>>>>>>>>>>>>>                                                         by programmers.
>>>>>>>>>>>>>>                                                         Except
>>>>>>>>>>>>>>                                                         in this
>>>>>>>>>>>>>>                                                         case,
>>>>>>>>>>>>>>                                                         volatiles
>>>>>>>>>>>>>>                                                         definitionally
>>>>>>>>>>>>>>                                                         cannot
>>>>>>>>>>>>>>                                                         be subject
>>>>>>>>>>>>>>                                                         to data
>>>>>>>>>>>>>>                                                         races.
>>>>>>>>>>>>>>                                                         Dealing
>>>>>>>>>>>>>>                                                         with
>>>>>>>>>>>>>>                                                         it requires
>>>>>>>>>>>>>>                                                         cleverness,
>>>>>>>>>>>>>>                                                         complexity,
>>>>>>>>>>>>>>                                                         and/or
>>>>>>>>>>>>>>                                                         error-proneness
>>>>>>>>>>>>>>                                                         that
>>>>>>>>>>>>>>                                                         isn't
>>>>>>>>>>>>>>                                                         even
>>>>>>>>>>>>>>                                                         required
>>>>>>>>>>>>>>                                                         for
>>>>>>>>>>>>>>                                                         correctness
>>>>>>>>>>>>>>                                                         on current
>>>>>>>>>>>>>>                                                         JVMs.
>>>>>>>>>>>>>>                                                         We have
>>>>>>>>>>>>>>                                                         several
>>>>>>>>>>>>>>                                                         constructions
>>>>>>>>>>>>>>                                                         in j.u.c
>>>>>>>>>>>>>>                                                         that
>>>>>>>>>>>>>>                                                         work
>>>>>>>>>>>>>>                                                         around
>>>>>>>>>>>>>>                                                         problems
>>>>>>>>>>>>>>                                                         by using
>>>>>>>>>>>>>>                                                         explicit
>>>>>>>>>>>>>>                                                         ordered
>>>>>>>>>>>>>>                                                         writes
>>>>>>>>>>>>>>                                                         in constructors,
>>>>>>>>>>>>>>                                                         redundant-looking
>>>>>>>>>>>>>>                                                         null-checks,
>>>>>>>>>>>>>>                                                         and
>>>>>>>>>>>>>>                                                         so
>>>>>>>>>>>>>>                                                         on.
>>>>>>>>>>>>>>                                                         If we
>>>>>>>>>>>>>>                                                         are
>>>>>>>>>>>>>>                                                         going
>>>>>>>>>>>>>>                                                         to repair
>>>>>>>>>>>>>>                                                         the
>>>>>>>>>>>>>>                                                         JMM
>>>>>>>>>>>>>>                                                         anyway,
>>>>>>>>>>>>>>                                                         this
>>>>>>>>>>>>>>                                                         is a
>>>>>>>>>>>>>>                                                         clear
>>>>>>>>>>>>>>                                                         candidate
>>>>>>>>>>>>>>                                                         for
>>>>>>>>>>>>>>                                                         reconsideration.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                         -Doug
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                             Ruslan
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                                 27
>>>>>>>>>>>>>>                                                                 ????.
>>>>>>>>>>>>>>                                                                 2013
>>>>>>>>>>>>>>                                                                 ?.,
>>>>>>>>>>>>>>                                                                 ? 23:26,
>>>>>>>>>>>>>>                                                                 Doug
>>>>>>>>>>>>>>                                                                 Lea
>>>>>>>>>>>>>>                                                                 <dl at cs.oswego.edu
>>>>>>>>>>>>>>                                                                 <mailto:dl at cs.oswego.edu>>
>>>>>>>>>>>>>>                                                                 ???????(?):
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                                     On
>>>>>>>>>>>>>>                                                                     11/27/2013
>>>>>>>>>>>>>>                                                                     02:06
>>>>>>>>>>>>>>                                                                     PM,
>>>>>>>>>>>>>>                                                                     Vitaly
>>>>>>>>>>>>>>                                                                     Davidovich
>>>>>>>>>>>>>>                                                                     wrote:
>>>>>>>>>>>>>>                                                                     But
>>>>>>>>>>>>>>                                                                     either
>>>>>>>>>>>>>>                                                                     way,
>>>>>>>>>>>>>>                                                                     optimizations
>>>>>>>>>>>>>>                                                                     to
>>>>>>>>>>>>>>                                                                     avoid
>>>>>>>>>>>>>>                                                                     zeroing
>>>>>>>>>>>>>>                                                                     memory
>>>>>>>>>>>>>>                                                                     is
>>>>>>>>>>>>>>                                                                     an
>>>>>>>>>>>>>>                                                                     implementation
>>>>>>>>>>>>>>                                                                     detail
>>>>>>>>>>>>>>                                                                     and
>>>>>>>>>>>>>>                                                                     thus
>>>>>>>>>>>>>>                                                                     cannot
>>>>>>>>>>>>>>                                                                     be
>>>>>>>>>>>>>>                                                                     relied
>>>>>>>>>>>>>>                                                                     upon
>>>>>>>>>>>>>>                                                                     from
>>>>>>>>>>>>>>                                                                     JMM
>>>>>>>>>>>>>>                                                                     standpoint,
>>>>>>>>>>>>>>                                                                     which
>>>>>>>>>>>>>>                                                                     I think
>>>>>>>>>>>>>>                                                                     you're
>>>>>>>>>>>>>>                                                                     saying.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                                     The
>>>>>>>>>>>>>>                                                                     other
>>>>>>>>>>>>>>                                                                     issue
>>>>>>>>>>>>>>                                                                     is
>>>>>>>>>>>>>>                                                                     that
>>>>>>>>>>>>>>                                                                     even
>>>>>>>>>>>>>>                                                                     if
>>>>>>>>>>>>>>                                                                     we
>>>>>>>>>>>>>>                                                                     determine
>>>>>>>>>>>>>>                                                                     that
>>>>>>>>>>>>>>                                                                     volatiles
>>>>>>>>>>>>>>                                                                     don't
>>>>>>>>>>>>>>                                                                     get
>>>>>>>>>>>>>>                                                                     this
>>>>>>>>>>>>>>                                                                     treatment,
>>>>>>>>>>>>>>                                                                     if
>>>>>>>>>>>>>>                                                                     JVM
>>>>>>>>>>>>>>                                                                     is
>>>>>>>>>>>>>>                                                                     already
>>>>>>>>>>>>>>                                                                     ensuring
>>>>>>>>>>>>>>                                                                     it,
>>>>>>>>>>>>>>                                                                     it's
>>>>>>>>>>>>>>                                                                     not
>>>>>>>>>>>>>>                                                                     going
>>>>>>>>>>>>>>                                                                     to
>>>>>>>>>>>>>>                                                                     be
>>>>>>>>>>>>>>                                                                     practical
>>>>>>>>>>>>>>                                                                     to
>>>>>>>>>>>>>>                                                                     change
>>>>>>>>>>>>>>                                                                     it
>>>>>>>>>>>>>>                                                                     and
>>>>>>>>>>>>>>                                                                     risk
>>>>>>>>>>>>>>                                                                     hard
>>>>>>>>>>>>>>                                                                     to
>>>>>>>>>>>>>>                                                                     debug
>>>>>>>>>>>>>>                                                                     problems
>>>>>>>>>>>>>>                                                                     creeping
>>>>>>>>>>>>>>                                                                     in.
>>>>>>>>>>>>>>                                                                      May
>>>>>>>>>>>>>>                                                                     as
>>>>>>>>>>>>>>                                                                     well
>>>>>>>>>>>>>>                                                                     update
>>>>>>>>>>>>>>                                                                     the
>>>>>>>>>>>>>>                                                                     spec
>>>>>>>>>>>>>>                                                                     now
>>>>>>>>>>>>>>                                                                     ...
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                                 Right.
>>>>>>>>>>>>>>                                                                 To
>>>>>>>>>>>>>>                                                                 summarize:
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                                 * Programmers
>>>>>>>>>>>>>>                                                                 do
>>>>>>>>>>>>>>                                                                 not
>>>>>>>>>>>>>>                                                                 expect
>>>>>>>>>>>>>>                                                                 that
>>>>>>>>>>>>>>                                                                 even
>>>>>>>>>>>>>>                                                                 though
>>>>>>>>>>>>>>                                                                 final
>>>>>>>>>>>>>>                                                                 fields
>>>>>>>>>>>>>>                                                                 are
>>>>>>>>>>>>>>                                                                 specifically
>>>>>>>>>>>>>>                                                                 publication-safe,
>>>>>>>>>>>>>>                                                                 volatile
>>>>>>>>>>>>>>                                                                 fields
>>>>>>>>>>>>>>                                                                 are
>>>>>>>>>>>>>>                                                                 not
>>>>>>>>>>>>>>                                                                 always
>>>>>>>>>>>>>>                                                                 so.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                                 * For
>>>>>>>>>>>>>>                                                                 various
>>>>>>>>>>>>>>                                                                 implementation
>>>>>>>>>>>>>>                                                                 reasons,
>>>>>>>>>>>>>>                                                                 JVMs
>>>>>>>>>>>>>>                                                                 arrange
>>>>>>>>>>>>>>                                                                 that
>>>>>>>>>>>>>>                                                                 volatile
>>>>>>>>>>>>>>                                                                 fields
>>>>>>>>>>>>>>                                                                 are
>>>>>>>>>>>>>>                                                                 publication
>>>>>>>>>>>>>>                                                                 safe
>>>>>>>>>>>>>>                                                                 anyway,
>>>>>>>>>>>>>>                                                                 at
>>>>>>>>>>>>>>                                                                 least
>>>>>>>>>>>>>>                                                                 in
>>>>>>>>>>>>>>                                                                 cases
>>>>>>>>>>>>>>                                                                 we
>>>>>>>>>>>>>>                                                                 know
>>>>>>>>>>>>>>                                                                 about.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                                 * Actually
>>>>>>>>>>>>>>                                                                 updating
>>>>>>>>>>>>>>                                                                 the
>>>>>>>>>>>>>>                                                                 JMM/JLS
>>>>>>>>>>>>>>                                                                 to
>>>>>>>>>>>>>>                                                                 mandate
>>>>>>>>>>>>>>                                                                 this
>>>>>>>>>>>>>>                                                                 is
>>>>>>>>>>>>>>                                                                 not
>>>>>>>>>>>>>>                                                                 easy
>>>>>>>>>>>>>>                                                                 (no
>>>>>>>>>>>>>>                                                                 small
>>>>>>>>>>>>>>                                                                 tweak
>>>>>>>>>>>>>>                                                                 that
>>>>>>>>>>>>>>                                                                 I know
>>>>>>>>>>>>>>                                                                 applies).
>>>>>>>>>>>>>>                                                                 But
>>>>>>>>>>>>>>                                                                 now
>>>>>>>>>>>>>>                                                                 is
>>>>>>>>>>>>>>                                                                 a good
>>>>>>>>>>>>>>                                                                 time
>>>>>>>>>>>>>>                                                                 to
>>>>>>>>>>>>>>                                                                 be
>>>>>>>>>>>>>>                                                                 considering
>>>>>>>>>>>>>>                                                                 a full
>>>>>>>>>>>>>>                                                                 revision
>>>>>>>>>>>>>>                                                                 for
>>>>>>>>>>>>>>                                                                 JDK9.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                                 * In
>>>>>>>>>>>>>>                                                                 the
>>>>>>>>>>>>>>                                                                 mean
>>>>>>>>>>>>>>                                                                 time,
>>>>>>>>>>>>>>                                                                 it
>>>>>>>>>>>>>>                                                                 would
>>>>>>>>>>>>>>                                                                 make
>>>>>>>>>>>>>>                                                                 sense
>>>>>>>>>>>>>>                                                                 to
>>>>>>>>>>>>>>                                                                 further
>>>>>>>>>>>>>>                                                                 test
>>>>>>>>>>>>>>                                                                 and
>>>>>>>>>>>>>>                                                                 validate
>>>>>>>>>>>>>>                                                                 JVMs
>>>>>>>>>>>>>>                                                                 as
>>>>>>>>>>>>>>                                                                 meeting
>>>>>>>>>>>>>>                                                                 this
>>>>>>>>>>>>>>                                                                 likely
>>>>>>>>>>>>>>                                                                 future
>>>>>>>>>>>>>>                                                                 spec.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                                 -Doug
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                                 _______________________________________________
>>>>>>>>>>>>>>                                                                 Concurrency-interest
>>>>>>>>>>>>>>                                                                 mailing
>>>>>>>>>>>>>>                                                                 list
>>>>>>>>>>>>>>                                                                 Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>>>>                                                                 <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>>>>                                                                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>                                                     _______________________________________________
>>>>>>>>>>>>>>                                                     Concurrency-interest mailing list
>>>>>>>>>>>>>>                                                     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>>>>                                                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>                                                     _______________________________________________
>>>>>>>>>>>>>                                                     Concurrency-interest
>>>>>>>>>>>>>                                                     mailing list
>>>>>>>>>>>>>                                                     Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>>>                                                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>>>                                                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>                                                 _______________________________________________
>>>>>>>>>>>>                                                 Concurrency-interest
>>>>>>>>>>>>                                                 mailing list
>>>>>>>>>>>>                                                 Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>>                                                 <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>>>                                                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         _______________________________________________
>>>>>>>>>>                                         Concurrency-interest
>>>>>>>>>>                                         mailing list
>>>>>>>>>>                                         Concurrency-interest at cs.oswego.edu
>>>>>>>>>>                                         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>                                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>>
>>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131204/7276ae94/attachment-0001.html>

From hans.boehm at hp.com  Thu Dec  5 00:36:40 2013
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu, 5 Dec 2013 05:36:40 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37EDO0BC=tR195X19F9UgBkkcVWS_r-2wj3nuBRivhLevg@mail.gmail.com>
References: <5295E24C.40608@oracle.com>	<5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D5107EB@G9W0725.americas.hpqcorp.net>
	<CAHjP37EDO0BC=tR195X19F9UgBkkcVWS_r-2wj3nuBRivhLevg@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD23D5122F6@G9W0725.americas.hpqcorp.net>

Correct.  (Note that for a purely data-race-free programming model, as in C or C++, ordering for data-dependent operations essentially doesn't matter.  There may be some other architectures like GPUs that don't enforce it, but I don't know of anyone who plans to run Java on those.)

Compilers could also speculate in a way that violates the data dependence.  (If you have a good guess for a, load both a and guessed a.f simultaneously, avoiding a load latency, then check, which is cheap.)  I don't think anyone does that either.

But your spec does have to be precise about which data dependencies are preserved; compilers, unlike hardware, routinely break some kinds of dependencies.  There is no data dependence between the two statements in

tmp = i;
tmp2 = a[i*n];

if the compiler can deduce that n is zero (possibly because it inlined this code into a context where that is always true).  Thus this needs to be restricted to only cases that are analogous to the final field ones, not arbitrary "dependencies".

Hans

From: Vitaly Davidovich [mailto:vitalyd at gmail.com]
Sent: Tuesday, December 03, 2013 1:31 PM
To: Boehm, Hans
Cc: concurrency-interest at cs.oswego.edu; Doug Lea
Subject: RE: [concurrency-interest] Volatile stores in constructors, disallowed to see the default value


Hans,

For #1 are you talking about reliance on cpu respecting data and control dependent loads and that otherwise the null checking load would need an acquire fence? The only one I know of that doesn't respect data dependency is alpha, but it's irrelevant.  Is there something else that's actually relevant? I'm guessing that if hotspot ran on archs where that's not the case, the VM itself would probably not work, never mind java code.

Sent from my phone
On Dec 3, 2013 3:51 PM, "Boehm, Hans" <hans.boehm at hp.com<mailto:hans.boehm at hp.com>> wrote:
> From: Doug Lea
>
> Sorry for mis-remembering why I had treated this issue as basically
> settled:
> Unless a JVM always pre-zeros memory (which usually not a good option),
> then
> even if not explicitly initialized, volatile fields must be zeroed
> in the constructor body, with a release fence before publication.
Is there a general argument for that claim about pre-zeroing?  My expectation would have been that it's reasonable to pre-zero, so long as you do it in chunks small enough that the zeros are unlikely to leave the faster parts of the cache hierarchy between zeroing and use.  It seems to be a trade-off between fences and some, ideally small, risk of additional cache misses.

I have a couple of other concerns about this discussion:

1. Nobody has mentioned that in the other thread of the original example, the one that does r1 = a.f, the loads of a and a.f are not currently ordered.  Once you add the required wait for a non-null a, that also matters.  I expect that is in fact guaranteed by all current Java implementations, but it requires a spec change.  And I think there are many plausible (and implausible) variants of that change, with substantive differences.

2. Along the same lines, and in agreement with some later posts, I still don't fully understand the rationale for providing such guarantees for volatile fields.  There is a general rule that when I construct an object, I shouldn't use it until I've finished constructing/initializing it.  That also generally applies to the built-in types.  And I think it applies to concurrent containers, even if other operations are allowed to race.  We seem to be adding a special short-cut by guaranteeing that, with safe publication, if I see a non-null pointer to the object, then I can safely conclude it has been initialized, even if there is no real happens-before relationship.  But presumably if I see a flag that was set after the initialization, no such guarantee exists?  It's not at all clear to me that this simplifies our story.

IIRC, the current final field rules were developed primarily to provide some security guarantees.  It is possible to build immutable types that look immutable, even to a malicious client.  That argument doesn't apply to objects with volatile fields.

Hans
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131205/17687984/attachment.html>

From hans.boehm at hp.com  Thu Dec  5 01:02:49 2013
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu, 5 Dec 2013 06:02:49 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <C740791B-1B66-434B-A740-21E2A5DBB07A@cox.net>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu> <x8sk1m01002hR0p018smq4>
	<C740791B-1B66-434B-A740-21E2A5DBB07A@cox.net>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD23D51232A@G9W0725.americas.hpqcorp.net>

> From: Gregg Wonderly [mailto:gergg at cox.net]
> 
> On Dec 3, 2013, at 2:49 PM, Boehm, Hans <hans.boehm at hp.com> wrote:
> >
> > 2. Along the same lines, and in agreement with some later posts, I
> still don't fully understand the rationale for providing such
> guarantees for volatile fields.  There is a general rule that when I
> construct an object, I shouldn't use it until I've finished
> constructing/initializing it.  That also generally applies to the
> built-in types.  And I think it applies to concurrent containers, even
> if other operations are allowed to race.  We seem to be adding a
> special short-cut by guaranteeing that, with safe publication, if I see
> a non-null pointer to the object, then I can safely conclude it has
> been initialized, even if there is no real happens-before relationship.
> But presumably if I see a flag that was set after the initialization,
> no such guarantee exists?  It's not at all clear to me that this
> simplifies our story.
> 
> There is absolutely awesome benefits from the applications getting a
> NullPointerException for using an initialized field, rather seeing a
> "pointer" to garbage.  It's possible then to conclude, much more
> readily that the value was not initialized correctly.  Otherwise, the
> developer is going to have no earthly idea why the JVM crashed with an
> internal error due to an errant memory access right?
I don't think this fundamentally changes anything along those lines,
at least not in the general case.  If I run a library constructor in parallel
with a method m on that same library-defined object, m may fail to behave
reasonably, even if the underlying language implementation were 100%
sequentially consistent.  And I think there is no reasonable way to avoid that.
I would expect that this generally wouldn't result in a JVM internal error,
though the library can behave arbitrarily badly, including generating
a stack overflow or the like.  I don't think this change effects any of that,
since it doesn't introduce additional happens-before relationships.
If I communicate a newly constructed object via a data race to a second
thread, and it invokes m, the code is still broken unless you understand m's implementation.
And I think it further complicates the job of race detectors by making it
harder to tell buggy code from really tricky correct code.

Hans

> 
> Gregg Wonderly



From hans.boehm at hp.com  Thu Dec  5 01:15:22 2013
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu, 5 Dec 2013 06:15:22 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <529E53D6.90802@oracle.com>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D5107EB@G9W0725.americas.hpqcorp.net>
	<529E53D6.90802@oracle.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD23D51234F@G9W0725.americas.hpqcorp.net>

> From: Oleksandr Otenko [mailto:oleksandr.otenko at oracle.com]
> > 1. Nobody has mentioned that in the other thread of the original
> example, the one that does r1 = a.f, the loads of a and a.f are not
> currently ordered.  Once you add the required wait for a non-null a,
> that also matters.
> 
> Doesn't Data Dependency section cover this case? a must be loaded
> before
> a.f, and a load-load barrier must be inserted. Given that we are
> talking
> about object creation, the other thread is bound to load a before first
> use.
Almost certainly.  The implementation could conceivably remember optimized
code from the lat run, which includes a predicted value for a, and then
speculate that it's the same this time.  There are probably scenarios in
which this is profitable, but I'll grant you it's not likely to happen.
> 
> Also, the wait for non-null a is a test artifact. The real case may be:
> x = a.next; // non-volatile field initialized prior to initialization
> of
> some volatile field - proven to be non-null
> r1 = x.f; // load volatile f
I think I'm missing the code context here.  How would this code work correctly without sometimes generating a npe on a at the first statement?  What's to prevent this from running before the thread that initializes a?

Hans
> 
> Alex
> 
> 
> >   I expect that is in fact guaranteed by all current Java
> implementations, but it requires a spec change.  And I think there are
> many plausible (and implausible) variants of that change, with
> substantive differences.
> >
> > 2. Along the same lines, and in agreement with some later posts, I
> still don't fully understand the rationale for providing such
> guarantees for volatile fields.  There is a general rule that when I
> construct an object, I shouldn't use it until I've finished
> constructing/initializing it.  That also generally applies to the
> built-in types.  And I think it applies to concurrent containers, even
> if other operations are allowed to race.  We seem to be adding a
> special short-cut by guaranteeing that, with safe publication, if I see
> a non-null pointer to the object, then I can safely conclude it has
> been initialized, even if there is no real happens-before relationship.
> But presumably if I see a flag that was set after the initialization,
> no such guarantee exists?  It's not at all clear to me that this
> simplifies our story.
> >
> > IIRC, the current final field rules were developed primarily to
> provide some security guarantees.  It is possible to build immutable
> types that look immutable, even to a malicious client.  That argument
> doesn't apply to objects with volatile fields.
> >
> > Hans
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From howard.lovatt at gmail.com  Thu Dec  5 01:17:56 2013
From: howard.lovatt at gmail.com (Howard Lovatt)
Date: Thu, 5 Dec 2013 17:17:56 +1100
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <529E1DC5.2080605@javaspecialists.eu>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
	<529DEB55.7080203@javaspecialists.eu>
	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
	<529E066D.9020008@oracle.com>
	<CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>
	<529E1DC5.2080605@javaspecialists.eu>
Message-ID: <CACR_FB5vC70Utw_prWKMrmuOkZJN+369EaAaREDD6_Lt4=16rA@mail.gmail.com>

Hi Heinz,

For your Point example I use something like:

class Coordinate {

  final long x, y;

  Coordinate(long x, long y) {

    this.x = x;

    this.y = y;

  }

}


class Point {

  volatile Coordinate position;

  Point(long x, long y) {

    position = new Coordinate(x, y);

  }

  synchronized void move(long x, long y) {

    position = new Coordinate(position.x + x, position.y + y);

  }

  Coordinate get() {

    return position;

  }

}


It is a bit of a combination of a couple of techniques that you mentioned,
it is easy to program, and in my testing works well. Of cause it is only
good if there are more reads than writes.

Cheers,


 -- Howard.


On 4 December 2013 05:07, Dr Heinz M. Kabutz <heinz at javaspecialists.eu>wrote:

>  Yeah, "should", but also not always.  As the number of retries
> increases, it can happen that the ReentrantLock beats CAS.  And then on
> some hardware, CAS can also be quite expensive.
>
> Regards
>
> Heinz
> --
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Oracle Java Champion 2005-2013
> JavaOne Rock Star Speaker 2012http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
>
>
> Vitaly Davidovich wrote:
>
> Well, CAS guarantees somebody makes some progress.  On a very loaded
> system, this is good (obviously) since otherwise a thread holding a lengthy
> lock section can get context switched out or have high latency due to,
> e.g., cache miss, and then nobody makes progress.  So yeah, on highly
> concurrent hardware, CAS should be a net win for throughput over locks.
>
> Sent from my phone
> On Dec 3, 2013 11:31 AM, "Nathan Reynolds" <nathan.reynolds at oracle.com>
> wrote:
>
>>  In one C++ case, we have a read-write lock in which writes are very
>> rare.  Having multiple threads execute CAS to update the number of readers
>> holding the lock has been a source of contention.  A stamped lock would be
>> great except that writes must have exclusivity otherwise the readers will
>> throw weird exceptions due to examining inconsistent state.
>>
>> In another Java case, I tried to make the code lock-free by using a
>> concurrent data structure and CAS loops.  Unfortunately, the code path is
>> so much longer that it takes more time to execute than to have a shorter
>> code path and wait on a lock.  The lock contention isn't high enough to
>> warrant the change.  I am waiting for more concurrent server processors to
>> finally tip the balance and justify the change.
>>
>> -Nathan
>>
>> On 12/3/2013 7:58 AM, Vitaly Davidovich wrote:
>>
>> So lock free may become a problem for extremely contended blocks - lock
>> free, assuming it's the basic CAS loop impl, may cause delays in such cases
>> as losing threads will continue spinning, tying up cpu resources and
>> generating coherence traffic.  In this case, using a lock can be a net win.
>>
>> Also, perhaps the lock free implementation generates lots of garbage,
>> placing load on the GC.  Otherwise, lock free should be a net win majority
>> of the time.
>>
>> A proper Spinlock may be a good addition to the j.u.c toolbox as well.
>>
>> Sent from my phone
>> On Dec 3, 2013 9:36 AM, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
>> wrote:
>>
>>> Doug Lea wrote:
>>>
>>>> On 12/02/2013 09:31 PM, Vitaly Davidovich wrote:
>>>>
>>>>> Right, it's a bit unclear on what a good case for this lock is.  I'm
>>>>> guessing
>>>>> the advantage is if you use the optimistic version - that avoids any
>>>>> expensive
>>>>> stores and doesn't block writers - for tiny read code sections on
>>>>> locks that are
>>>>> read-mostly.  Otherwise, seems like it may not perform all that well
>>>>> (e.g.
>>>>> validate() missing in cache because another core wrote to the lock in
>>>>> the meantime).
>>>>>
>>>>> Builtin synchronizer (I.e synchronized keyword) for small/cheap code
>>>>> sections
>>>>> that don't contend seems decent enough.  Biased locking + (adaptive)
>>>>> spinning
>>>>> should, in theory, be good enough for these cases.
>>>>>
>>>>
>>>> Please measure. Sometimes biased locking is fine, sometimes much less
>>>> than fine. As a rule of thumb, if you expect contention not to be rare,
>>>> consider using a j.u.c Lock. And unless you need reentrancy, StampedLock
>>>> is often the best choice of these in terms of performance and features.
>>>> I expect that Heinz's future installments will spell some of this out
>>>> for many use cases, but ... please measure.
>>>>
>>> I did some measurements of StampedLock vs ReentrantReadWriteLock and SL
>>> showed better performance and also did not suffer from the same starvation
>>> issues as RRWL.  Martin Thompson also mentioned a discussion we had on
>>> Crete in his blog:
>>> http://mechanical-sympathy.blogspot.gr/2013/08/lock-based-vs-lock-free-concurrent.html
>>>
>>> I still need to verify his findings.  My cursory tests showed that in
>>> some cases, SL is better than Lock-Free immutable and in other cases, plain
>>> old synchronized beats them both.  All depends how you test this.
>>>
>>>>
>>>>> Also, one other thing synchronized has going for it is it handles
>>>>> async aborts
>>>>> of threads (I.e. thread.stop()).  I know stop() is deprecated and all,
>>>>> but you
>>>>> never know.
>>>>>
>>>>
>>>> But you do know! As of JDK8, Thread.stop is really gone.
>>>> It is the first deprecated method to have actually been
>>>> de-implemented. It now just throws UnsupportedOperationException.
>>>>
>>>>  I think you're thinking of the Thread.stop(Throwable) method which has
>>> unfortunately been removed in Java 8.
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>  ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
  -- Howard.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131205/d18e3016/attachment-0001.html>

From peter.firmstone at zeus.net.au  Thu Dec  5 06:28:03 2013
From: peter.firmstone at zeus.net.au (Peter Firmstone)
Date: Thu, 05 Dec 2013 21:28:03 +1000
Subject: [concurrency-interest] Volatile stores in constructors,
	disallowed to see the default	value
Message-ID: <1386242883.11683.4.camel@Nokia-N900>

With utmost respect and please forgive my ignorance, in regard to dependency injection frameworks that share or mutate partially constructed objects, wouldn't it be better for frameworks or client code to be refactored to utilise safe publication or be thread confined?  Volatiles could be treated similarly to final fields in constructors.  

Can we keep it simpler, it's hard enough trying to explain to other programmers why visibility, safe publication and construction are important?   Concurrency programming competency in the wider  community is still lacking and complexity is causing significant issues for collaboration.

Newer dependency injection frameworks use constructor based injectors to take advantage of safe construction, final fields and immutability.  Your concurrent utilities and collections are a godsend.

Our project uses standard constructor signatures called using reflection, client code interacts using only interfaces.

Thanks & regards,

Peter.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131205/d3dcab4d/attachment.html>

From heinz at javaspecialists.eu  Thu Dec  5 09:19:03 2013
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Thu, 05 Dec 2013 16:19:03 +0200
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <CACR_FB5vC70Utw_prWKMrmuOkZJN+369EaAaREDD6_Lt4=16rA@mail.gmail.com>
References: <529CEA6D.9070301@javaspecialists.eu>	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>	<529DCE97.9050302@cs.oswego.edu>	<529DEB55.7080203@javaspecialists.eu>	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>	<529E066D.9020008@oracle.com>	<CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>	<529E1DC5.2080605@javaspecialists.eu>
	<CACR_FB5vC70Utw_prWKMrmuOkZJN+369EaAaREDD6_Lt4=16rA@mail.gmail.com>
Message-ID: <52A08B57.4000408@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131205/d775de42/attachment.html>

From oleksandr.otenko at oracle.com  Thu Dec  5 13:20:35 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Thu, 05 Dec 2013 18:20:35 +0000
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD23D51234F@G9W0725.americas.hpqcorp.net>
References: <5295E24C.40608@oracle.com> <5295EFFA.5090701@oracle.com>
	<5295F85A.40500@cs.oswego.edu>
	<CAHjP37HjObC1K3Ef+w9Ore+NXt2dofYurzYpFKLLPgia6EbYwg@mail.gmail.com>
	<52963CEB.5070703@cs.oswego.edu>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D5107EB@G9W0725.americas.hpqcorp.net>
	<529E53D6.90802@oracle.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD23D51234F@G9W0725.americas.hpqcorp.net>
Message-ID: <52A0C3F3.8090401@oracle.com>

On 05/12/2013 06:15, Boehm, Hans wrote:
>> From: Oleksandr Otenko [mailto:oleksandr.otenko at oracle.com]
>>> 1. Nobody has mentioned that in the other thread of the original
>> example, the one that does r1 = a.f, the loads of a and a.f are not
>> currently ordered.  Once you add the required wait for a non-null a,
>> that also matters.
>>
>> Doesn't Data Dependency section cover this case? a must be loaded
>> before
>> a.f, and a load-load barrier must be inserted. Given that we are
>> talking
>> about object creation, the other thread is bound to load a before first
>> use.
> Almost certainly.  The implementation could conceivably remember optimized
> code from the lat run, which includes a predicted value for a, and then
> speculate that it's the same this time.  There are probably scenarios in
> which this is profitable, but I'll grant you it's not likely to happen.
Interesting point. I never thought memory model extends across 
executions of the same program and can reference a instance that only 
existed in the "previous life".


>> Also, the wait for non-null a is a test artifact. The real case may be:
>> x = a.next; // non-volatile field initialized prior to initialization
>> of
>> some volatile field - proven to be non-null
>> r1 = x.f; // load volatile f
> I think I'm missing the code context here.  How would this code work correctly without sometimes generating a npe on a at the first statement?  What's to prevent this from running before the thread that initializes a?
I think NPE is not enough of a argument. I may have synchronization that 
ensures a is not null, but I may have no synchronization ensuring what 
exactly value of a or a.next we are looking at now.

ok, more concrete example: a pool of Nodes

Node head = new Node(null); // can't borrow head, but that's ok

void addFree() {
   head = new Node(head);
}

Node borrowNew() {
   Node h=head;
   Node r;
   while((r=h.next) != null) {
     if (h.cas(r, r.next)) return r;
     h=head;
   }

   return new Node(null);
}

So, head is never null. New nodes added to the linked list by a single 
thread (you can think of this as a thread that managed to acquire a 
Writer lock). Node.next has to be volatile, but only consumers compete 
between each other. h=head in the loop follows a volatile load of 
h.next, so it is never hoisted even if h.cas() has a shortcut avoiding a 
full barrier on failure.

I should never see r==null, if the pool is non-empty (has nodes linked 
to the head). Currently, this can only be achieved by lazySet of head 
(or making head volatile), but this is a unnecessary complication.


Alex


>
> Hans
>> Alex
>>
>>
>>>    I expect that is in fact guaranteed by all current Java
>> implementations, but it requires a spec change.  And I think there are
>> many plausible (and implausible) variants of that change, with
>> substantive differences.
>>> 2. Along the same lines, and in agreement with some later posts, I
>> still don't fully understand the rationale for providing such
>> guarantees for volatile fields.  There is a general rule that when I
>> construct an object, I shouldn't use it until I've finished
>> constructing/initializing it.  That also generally applies to the
>> built-in types.  And I think it applies to concurrent containers, even
>> if other operations are allowed to race.  We seem to be adding a
>> special short-cut by guaranteeing that, with safe publication, if I see
>> a non-null pointer to the object, then I can safely conclude it has
>> been initialized, even if there is no real happens-before relationship.
>> But presumably if I see a flag that was set after the initialization,
>> no such guarantee exists?  It's not at all clear to me that this
>> simplifies our story.
>>> IIRC, the current final field rules were developed primarily to
>> provide some security guarantees.  It is possible to build immutable
>> types that look immutable, even to a malicious client.  That argument
>> doesn't apply to objects with volatile fields.
>>> Hans
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From howard.lovatt at gmail.com  Thu Dec  5 15:06:38 2013
From: howard.lovatt at gmail.com (Howard Lovatt)
Date: Fri, 6 Dec 2013 07:06:38 +1100
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <52A08B57.4000408@javaspecialists.eu>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
	<529DEB55.7080203@javaspecialists.eu>
	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
	<529E066D.9020008@oracle.com>
	<CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>
	<529E1DC5.2080605@javaspecialists.eu>
	<CACR_FB5vC70Utw_prWKMrmuOkZJN+369EaAaREDD6_Lt4=16rA@mail.gmail.com>
	<52A08B57.4000408@javaspecialists.eu>
Message-ID: <A690EDD8-1BCA-4AEF-A7C6-B8182C698A87@gmail.com>

Hi Heinz,

Yes I would write distanceFromOrigin like you did; though you have a typo, it is current.x and .y not position. The key part of this method is that you have to read position into a local like you did because you can only read position once in a read-only method. 

For moveIfAt, I would just make the method synchronized and leave position as a volatile:
> public synchronized boolean moveIfAt(int oldX, int oldY, int newX, int newY) {
>             if (position.x == oldX && position.y == oldY) {
>                  position = new Coordinate(newX, newY);
>                  return true;
>             }
>             return false;
>   }

I haven't found the Atomic classes to perform as well as using volatile and synchronized and the programming is not as clear. Though I have also found benchmarking concurrent code very hard and I am therefore not confident of my timing results :(

Looking forward to the next two instalments - really interesting article. 

Cheers,

 -- Howard. 

Sent from my iPad

> On 6 Dec 2013, at 1:19 am, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu> wrote:
> 
> Hi Howard,
> 
> yes, you could do that.  So the distanceFromOrigin() would look something like this:
> 
>   public double distanceFromOrigin() {
>     Coordinate current = position;
>     return Math.hypot(position.x, position.y);
>   }
> 
> And then moveIfAt() would need a CAS, thus you might want to use an AtomicReference instead or an AtomicReferenceFieldUpdater (or Unsafe of course ;-))
> 
>   public boolean moveIfAt(int oldX, int oldY,
>                                        int newX, int newY) {
>     
>       while(true) {
>             Coordinate current = position;
>             Coordinate next;
>             if (current.x == oldX && current.y == oldY) {
>                  next = new Coordinate(newX, newY);
>                  if (positionSetter.compareAndSet(current, next)) return true;
>             } else {
>                  return false;
>             }
>        }
>   }
> 
> That will be one of the topics of the second part of my StampedLock series.  The third will be comparing the various approaches in terms of performance.
> Regards
> 
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Oracle Java Champion 2005-2013
> JavaOne Rock Star Speaker 2012
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
> 
> 
> Howard Lovatt wrote:
>> 
>> Hi Heinz,
>> 
>> For your Point example I use something like:
>> 
>> class Coordinate {
>> 
>>   final long x, y;
>> 
>>   Coordinate(long x, long y) {
>> 
>>     this.x = x;
>> 
>>     this.y = y;
>> 
>>   }
>> 
>> }
>> 
>> 
>> class Point {
>> 
>>   volatile Coordinate position;
>> 
>>   Point(long x, long y) {
>> 
>>     position = new Coordinate(x, y);
>> 
>>   }
>> 
>>   synchronized void move(long x, long y) {
>> 
>>     position = new Coordinate(position.x + x, position.y + y);
>> 
>>   }
>> 
>>   Coordinate get() {
>> 
>>     return position;
>> 
>>   }
>> 
>> }
>> 
>> 
>> It is a bit of a combination of a couple of techniques that you mentioned, it is easy to program, and in my testing works well. Of cause it is only good if there are more reads than writes.
>> 
>> Cheers,
>> 
>> 
>>  -- Howard.
>> 
>> 
>> 
>>> On 4 December 2013 05:07, Dr Heinz M. Kabutz <heinz at javaspecialists.eu> wrote:
>>> Yeah, "should", but also not always.  As the number of retries increases, it can happen that the ReentrantLock beats CAS.  And then on some hardware, CAS can also be quite expensive.
>>> 
>>> Regards
>>> 
>>> Heinz
>>> -- 
>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> Author of "The Java(tm) Specialists' Newsletter"
>>> Oracle Java Champion 2005-2013
>>> JavaOne Rock Star Speaker 2012
>>> http://www.javaspecialists.eu
>>> Tel: +30 69 75 595 262
>>> Skype: kabutz
>>>     
>>> 
>>> 
>>> Vitaly Davidovich wrote:
>>>> 
>>>> Well, CAS guarantees somebody makes some progress.  On a very loaded system, this is good (obviously) since otherwise a thread holding a lengthy lock section can get context switched out or have high latency due to, e.g., cache miss, and then nobody makes progress.  So yeah, on highly concurrent hardware, CAS should be a net win for throughput over locks.
>>>> 
>>>> Sent from my phone
>>>> 
>>>>> On Dec 3, 2013 11:31 AM, "Nathan Reynolds" <nathan.reynolds at oracle.com> wrote:
>>>>> In one C++ case, we have a read-write lock in which writes are very rare.  Having multiple threads execute CAS to update the number of readers holding the lock has been a source of contention.  A stamped lock would be great except that writes must have exclusivity otherwise the readers will throw weird exceptions due to examining inconsistent state.
>>>>> 
>>>>> In another Java case, I tried to make the code lock-free by using a concurrent data structure and CAS loops.  Unfortunately, the code path is so much longer that it takes more time to execute than to have a shorter code path and wait on a lock.  The lock contention isn't high enough to warrant the change.  I am waiting for more concurrent server processors to finally tip the balance and justify the change.
>>>>> -Nathan
>>>>> On 12/3/2013 7:58 AM, Vitaly Davidovich wrote:
>>>>>> So lock free may become a problem for extremely contended blocks - lock free, assuming it's the basic CAS loop impl, may cause delays in such cases as losing threads will continue spinning, tying up cpu resources and generating coherence traffic.  In this case, using a lock can be a net win.
>>>>>> 
>>>>>> Also, perhaps the lock free implementation generates lots of garbage, placing load on the GC.  Otherwise, lock free should be a net win majority of the time.
>>>>>> 
>>>>>> A proper Spinlock may be a good addition to the j.u.c toolbox as well.
>>>>>> 
>>>>>> Sent from my phone
>>>>>> 
>>>>>> On Dec 3, 2013 9:36 AM, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu> wrote:
>>>>>>> Doug Lea wrote:
>>>>>>>>> On 12/02/2013 09:31 PM, Vitaly Davidovich wrote:
>>>>>>>>> Right, it's a bit unclear on what a good case for this lock is.  I'm guessing
>>>>>>>>> the advantage is if you use the optimistic version - that avoids any expensive
>>>>>>>>> stores and doesn't block writers - for tiny read code sections on locks that are
>>>>>>>>> read-mostly.  Otherwise, seems like it may not perform all that well (e.g.
>>>>>>>>> validate() missing in cache because another core wrote to the lock in the meantime).
>>>>>>>>> 
>>>>>>>>> Builtin synchronizer (I.e synchronized keyword) for small/cheap code sections
>>>>>>>>> that don't contend seems decent enough.  Biased locking + (adaptive) spinning
>>>>>>>>> should, in theory, be good enough for these cases.
>>>>>>>> 
>>>>>>>> Please measure. Sometimes biased locking is fine, sometimes much less
>>>>>>>> than fine. As a rule of thumb, if you expect contention not to be rare,
>>>>>>>> consider using a j.u.c Lock. And unless you need reentrancy, StampedLock
>>>>>>>> is often the best choice of these in terms of performance and features.
>>>>>>>> I expect that Heinz's future installments will spell some of this out
>>>>>>>> for many use cases, but ... please measure.
>>>>>>> I did some measurements of StampedLock vs ReentrantReadWriteLock and SL showed better performance and also did not suffer from the same starvation issues as RRWL.  Martin Thompson also mentioned a discussion we had on Crete in his blog: http://mechanical-sympathy.blogspot.gr/2013/08/lock-based-vs-lock-free-concurrent.html
>>>>>>> 
>>>>>>> I still need to verify his findings.  My cursory tests showed that in some cases, SL is better than Lock-Free immutable and in other cases, plain old synchronized beats them both.  All depends how you test this.
>>>>>>>>> 
>>>>>>>>> Also, one other thing synchronized has going for it is it handles async aborts
>>>>>>>>> of threads (I.e. thread.stop()).  I know stop() is deprecated and all, but you
>>>>>>>>> never know.
>>>>>>>> 
>>>>>>>> But you do know! As of JDK8, Thread.stop is really gone.
>>>>>>>> It is the first deprecated method to have actually been
>>>>>>>> de-implemented. It now just throws UnsupportedOperationException.
>>>>>>>> 
>>>>>>> I think you're thinking of the Thread.stop(Throwable) method which has unfortunately been removed in Java 8.
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>> 
>>>>>> 
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>       
>>>>> 
>>>>> 
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> 
>>>> 
>>>> 
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>   
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> 
>> 
>> 
>> 
>> -- 
>>   -- Howard.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131206/db462a37/attachment-0001.html>

From heinz at javaspecialists.eu  Thu Dec  5 15:15:32 2013
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Thu, 05 Dec 2013 22:15:32 +0200
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <A690EDD8-1BCA-4AEF-A7C6-B8182C698A87@gmail.com>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
	<529DEB55.7080203@javaspecialists.eu>
	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
	<529E066D.9020008@oracle.com>
	<CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>
	<529E1DC5.2080605@javaspecialists.eu>
	<CACR_FB5vC70Utw_prWKMrmuOkZJN+369EaAaREDD6_Lt4=16rA@mail.gmail.com>
	<52A08B57.4000408@javaspecialists.eu>
	<A690EDD8-1BCA-4AEF-A7C6-B8182C698A87@gmail.com>
Message-ID: <52A0DEE4.7020509@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131205/2d11a5bb/attachment.html>

From howard.lovatt at gmail.com  Thu Dec  5 16:34:32 2013
From: howard.lovatt at gmail.com (Howard Lovatt)
Date: Fri, 6 Dec 2013 08:34:32 +1100
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <52A0DEE4.7020509@javaspecialists.eu>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
	<529DEB55.7080203@javaspecialists.eu>
	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
	<529E066D.9020008@oracle.com>
	<CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>
	<529E1DC5.2080605@javaspecialists.eu>
	<CACR_FB5vC70Utw_prWKMrmuOkZJN+369EaAaREDD6_Lt4=16rA@mail.gmail.com>
	<52A08B57.4000408@javaspecialists.eu>
	<A690EDD8-1BCA-4AEF-A7C6-B8182C698A87@gmail.com>
	<52A0DEE4.7020509@javaspecialists.eu>
Message-ID: <68AA05B1-48E4-4AE1-AA22-A19D8BC039DE@gmail.com>

Hi Heinz,

Interested to see your results and also see how you do the benchmarking since as I said I some difficulty with getting good results. 

Cheers,

 -- Howard. 

Sent from my iPad

> On 6 Dec 2013, at 7:15 am, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu> wrote:
> 
> Yes, sorry for my typo.  Tim Peierls pointed it out privately, but I thought it insufficiently important to send an update :-)  I'm sure most readers got the idea.
> 
> When I run my performance tests, I will include your version into the mix.  From my very basic initial tests a few months ago, it did seem that synchronizing that particular method actually outperformed the other approaches.  But I need to verify my test and do a bit more work there.  Maybe during the Christmas break I'll get a chance to do that.
> Regards
> 
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Oracle Java Champion 2005-2013
> JavaOne Rock Star Speaker 2012
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
> 
> 
> Howard Lovatt wrote:
>> 
>> Hi Heinz,
>> 
>> Yes I would write distanceFromOrigin like you did; though you have a typo, it is current.x and .y not position. The key part of this method is that you have to read position into a local like you did because you can only read position once in a read-only method. 
>> 
>> For moveIfAt, I would just make the method synchronized and leave position as a volatile:
>>> public synchronized boolean moveIfAt(int oldX, int oldY, int newX, int newY) {
>>>             if (position.x == oldX && position.y == oldY) {
>>>                  position = new Coordinate(newX, newY);
>>>                  return true;
>>>             }
>>>             return false;
>>>   }
>> 
>> I haven't found the Atomic classes to perform as well as using volatile and synchronized and the programming is not as clear. Though I have also found benchmarking concurrent code very hard and I am therefore not confident of my timing results :(
>> 
>> Looking forward to the next two instalments - really interesting article. 
>> 
>> Cheers,
>> 
>>  -- Howard. 
>> 
>> Sent from my iPad
>> 
>> On 6 Dec 2013, at 1:19 am, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu> wrote:
>> 
>>> Hi Howard,
>>> 
>>> yes, you could do that.  So the distanceFromOrigin() would look something like this:
>>> 
>>>   public double distanceFromOrigin() {
>>>     Coordinate current = position;
>>>     return Math.hypot(position.x, position.y);
>>>   }
>>> 
>>> And then moveIfAt() would need a CAS, thus you might want to use an AtomicReference instead or an AtomicReferenceFieldUpdater (or Unsafe of course ;-))
>>> 
>>>   public boolean moveIfAt(int oldX, int oldY,
>>>                                        int newX, int newY) {
>>>     
>>>       while(true) {
>>>             Coordinate current = position;
>>>             Coordinate next;
>>>             if (current.x == oldX && current.y == oldY) {
>>>                  next = new Coordinate(newX, newY);
>>>                  if (positionSetter.compareAndSet(current, next)) return true;
>>>             } else {
>>>                  return false;
>>>             }
>>>        }
>>>   }
>>> 
>>> That will be one of the topics of the second part of my StampedLock series.  The third will be comparing the various approaches in terms of performance.
>>> Regards
>>> 
>>> Heinz
>>> -- 
>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> Author of "The Java(tm) Specialists' Newsletter"
>>> Oracle Java Champion 2005-2013
>>> JavaOne Rock Star Speaker 2012
>>> http://www.javaspecialists.eu
>>> Tel: +30 69 75 595 262
>>> Skype: kabutz
>>>     
>>> 
>>> 
>>> Howard Lovatt wrote:
>>>> 
>>>> Hi Heinz,
>>>> 
>>>> For your Point example I use something like:
>>>> 
>>>> class Coordinate {
>>>> 
>>>>   final long x, y;
>>>> 
>>>>   Coordinate(long x, long y) {
>>>> 
>>>>     this.x = x;
>>>> 
>>>>     this.y = y;
>>>> 
>>>>   }
>>>> 
>>>> }
>>>> 
>>>> 
>>>> class Point {
>>>> 
>>>>   volatile Coordinate position;
>>>> 
>>>>   Point(long x, long y) {
>>>> 
>>>>     position = new Coordinate(x, y);
>>>> 
>>>>   }
>>>> 
>>>>   synchronized void move(long x, long y) {
>>>> 
>>>>     position = new Coordinate(position.x + x, position.y + y);
>>>> 
>>>>   }
>>>> 
>>>>   Coordinate get() {
>>>> 
>>>>     return position;
>>>> 
>>>>   }
>>>> 
>>>> }
>>>> 
>>>> 
>>>> It is a bit of a combination of a couple of techniques that you mentioned, it is easy to program, and in my testing works well. Of cause it is only good if there are more reads than writes.
>>>> 
>>>> Cheers,
>>>> 
>>>> 
>>>>  -- Howard.
>>>> 
>>>> 
>>>> 
>>>>> On 4 December 2013 05:07, Dr Heinz M. Kabutz <heinz at javaspecialists.eu> wrote:
>>>>> Yeah, "should", but also not always.  As the number of retries increases, it can happen that the ReentrantLock beats CAS.  And then on some hardware, CAS can also be quite expensive.
>>>>> 
>>>>> Regards
>>>>> 
>>>>> Heinz
>>>>> -- 
>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>> Oracle Java Champion 2005-2013
>>>>> JavaOne Rock Star Speaker 2012
>>>>> http://www.javaspecialists.eu
>>>>> Tel: +30 69 75 595 262
>>>>> Skype: kabutz
>>>>>     
>>>>> 
>>>>> 
>>>>> Vitaly Davidovich wrote:
>>>>>> 
>>>>>> Well, CAS guarantees somebody makes some progress.  On a very loaded system, this is good (obviously) since otherwise a thread holding a lengthy lock section can get context switched out or have high latency due to, e.g., cache miss, and then nobody makes progress.  So yeah, on highly concurrent hardware, CAS should be a net win for throughput over locks.
>>>>>> 
>>>>>> Sent from my phone
>>>>>> 
>>>>>>> On Dec 3, 2013 11:31 AM, "Nathan Reynolds" <nathan.reynolds at oracle.com> wrote:
>>>>>>> In one C++ case, we have a read-write lock in which writes are very rare.  Having multiple threads execute CAS to update the number of readers holding the lock has been a source of contention.  A stamped lock would be great except that writes must have exclusivity otherwise the readers will throw weird exceptions due to examining inconsistent state.
>>>>>>> 
>>>>>>> In another Java case, I tried to make the code lock-free by using a concurrent data structure and CAS loops.  Unfortunately, the code path is so much longer that it takes more time to execute than to have a shorter code path and wait on a lock.  The lock contention isn't high enough to warrant the change.  I am waiting for more concurrent server processors to finally tip the balance and justify the change.
>>>>>>> -Nathan
>>>>>>> On 12/3/2013 7:58 AM, Vitaly Davidovich wrote:
>>>>>>>> So lock free may become a problem for extremely contended blocks - lock free, assuming it's the basic CAS loop impl, may cause delays in such cases as losing threads will continue spinning, tying up cpu resources and generating coherence traffic.  In this case, using a lock can be a net win.
>>>>>>>> 
>>>>>>>> Also, perhaps the lock free implementation generates lots of garbage, placing load on the GC.  Otherwise, lock free should be a net win majority of the time.
>>>>>>>> 
>>>>>>>> A proper Spinlock may be a good addition to the j.u.c toolbox as well.
>>>>>>>> 
>>>>>>>> Sent from my phone
>>>>>>>> 
>>>>>>>> On Dec 3, 2013 9:36 AM, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu> wrote:
>>>>>>>>> Doug Lea wrote:
>>>>>>>>>>> On 12/02/2013 09:31 PM, Vitaly Davidovich wrote:
>>>>>>>>>>> Right, it's a bit unclear on what a good case for this lock is.  I'm guessing
>>>>>>>>>>> the advantage is if you use the optimistic version - that avoids any expensive
>>>>>>>>>>> stores and doesn't block writers - for tiny read code sections on locks that are
>>>>>>>>>>> read-mostly.  Otherwise, seems like it may not perform all that well (e.g.
>>>>>>>>>>> validate() missing in cache because another core wrote to the lock in the meantime).
>>>>>>>>>>> 
>>>>>>>>>>> Builtin synchronizer (I.e synchronized keyword) for small/cheap code sections
>>>>>>>>>>> that don't contend seems decent enough.  Biased locking + (adaptive) spinning
>>>>>>>>>>> should, in theory, be good enough for these cases.
>>>>>>>>>> 
>>>>>>>>>> Please measure. Sometimes biased locking is fine, sometimes much less
>>>>>>>>>> than fine. As a rule of thumb, if you expect contention not to be rare,
>>>>>>>>>> consider using a j.u.c Lock. And unless you need reentrancy, StampedLock
>>>>>>>>>> is often the best choice of these in terms of performance and features.
>>>>>>>>>> I expect that Heinz's future installments will spell some of this out
>>>>>>>>>> for many use cases, but ... please measure.
>>>>>>>>> I did some measurements of StampedLock vs ReentrantReadWriteLock and SL showed better performance and also did not suffer from the same starvation issues as RRWL.  Martin Thompson also mentioned a discussion we had on Crete in his blog: http://mechanical-sympathy.blogspot.gr/2013/08/lock-based-vs-lock-free-concurrent.html
>>>>>>>>> 
>>>>>>>>> I still need to verify his findings.  My cursory tests showed that in some cases, SL is better than Lock-Free immutable and in other cases, plain old synchronized beats them both.  All depends how you test this.
>>>>>>>>>>> 
>>>>>>>>>>> Also, one other thing synchronized has going for it is it handles async aborts
>>>>>>>>>>> of threads (I.e. thread.stop()).  I know stop() is deprecated and all, but you
>>>>>>>>>>> never know.
>>>>>>>>>> 
>>>>>>>>>> But you do know! As of JDK8, Thread.stop is really gone.
>>>>>>>>>> It is the first deprecated method to have actually been
>>>>>>>>>> de-implemented. It now just throws UnsupportedOperationException.
>>>>>>>>> I think you're thinking of the Thread.stop(Throwable) method which has unfortunately been removed in Java 8.
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>> 
>>>>>>>> 
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>       
>>>>>>> 
>>>>>>> 
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>> 
>>>>>> 
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>   
>>>>> 
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> 
>>>> 
>>>> 
>>>> -- 
>>>>   -- Howard.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131206/f5e7ecbd/attachment-0001.html>

From peter.levart at gmail.com  Sun Dec  8 11:14:12 2013
From: peter.levart at gmail.com (Peter Levart)
Date: Sun, 08 Dec 2013 17:14:12 +0100
Subject: [concurrency-interest] Volatile stores in constructors,
 disallowed to see the default value
In-Reply-To: <CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>
References: <5295E24C.40608@oracle.com>	<CAOwENiLLYzeqj6YO3OPDnV-=F2iVBL+GZ8gwLqCJi2gJQ-BWEQ@mail.gmail.com>	<529CEAC4.7080409@oracle.com>	<CAOwENiKj4H-Qd3CWT-Um_9_c7vv5gynRCN8ZKH-uMtM_b-AAww@mail.gmail.com>	<529DC489.2070205@oracle.com>	<CAHjP37H6drNSxFpDLMCTctNfpReHkrYqfX9mWkHKs8ehMAPQ2Q@mail.gmail.com>	<529DF29E.6070702@oracle.com>	<CAHjP37F7mWCjOzPTvp2wRvbNabs+8+w=ufaB608GStW9PBa8Lw@mail.gmail.com>	<529E033A.90903@oracle.com>	<CAHjP37Go6b_s_jM58Gy-7G78AMd-Z5kYTQMZyrjBWTPwp6G-Gg@mail.gmail.com>	<529E12F4.5070501@oracle.com>	<CAHjP37Hh3PHsSzBrRwq8vE8oGdhCj1ze446EFH0b4DdAiRevmA@mail.gmail.com>	<529E17E1.5030006@oracle.com>	<CAHjP37F52DrMmk2a-_dLNeyvTLCbtGqznjBRnh5y9vExhGxugw@mail.gmail.com>	<529E1D48.5020500@oracle.com>	<CAHjP37HgYM59auSwjALLb19o-XpJ1QdZW-3SW=+9rCVooBBGUQ@mail.gmail.com>	<529E2679.6080204@oracle.com>	<CAHjP37FrWKZ_0yNROCUydnuDnon2Z5GX94qTnvVsD3+MbF2MEQ@mail.gmail.com>	<529E297C.4070401@oracle.com>
	<CAHjP37F8EhN0h7rQhAdHRbVrOGJWASNaEP+a+1o=VfY+ATjhjw@mail.gmail.com>
Message-ID: <52A49AD4.2000804@gmail.com>


On 12/03/2013 08:21 PM, Vitaly Davidovich wrote:
>
> So to play devil's advocate, why not make all ctors behave the same 
> way? Afterall, people may still publish classes with no final or 
> volatile fields unsafely, and run into problems.  One can argue that 
> most people expect that upon constructor exit, all memory ops are 
> complete.  Why only add volatile to the mix? So that concurrency 
> authors can attempt at safeguarding their class from unsafe 
> publication by a user who doesn't know any better? Is that really 
> worth the overhead required? Said user can still shoot themselves in 
> other ways. At some point, the burden should be on devs to know the 
> platform, its promises/guarantees, and available tools to add their 
> own extra guarantees.
>
> Again, we're talking about data race publishing here - this is not the 
> norm or encouraged practice.  Why bend over backwards to accommodate it?
>

Sometimes unsafe publishing is not just accidental slip of a programmer, 
but a carefully thought-out action of an attacker, for example. The 
programmer of a security-sensitive class has to be extra careful not to 
expose a weakness which could be exploited by unsafe publication. And 
all she has  at her hand currently is final fields. The problem with 
final fields is that they can only be set once. Sometimes this does not 
fit with the desired functionality. See for example the following 
discussion:

http://mail.openjdk.java.net/pipermail/core-libs-dev/2013-December/023686.html

...and the awkward workaround needed to fix the problem. Alright, the 
best solution for the problem was suggested by Mandy Chung - use 
doPrivileged - but what if in some other situation no alternative 
solution was applicable or if it was even more awkward than the presented?

Regards, Peter

> Sent from my phone
>
> On Dec 3, 2013 1:57 PM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     You'd need load-store after loading externally observable values
>     with or without the proposed changes, but we aren't eliminating
>     those, are we? I thought you meant we need new barriers.
>
>     Alex
>
>     On 03/12/2013 18:51, Vitaly Davidovich wrote:
>>
>>     You would - since volatile can be modified and read many times in
>>     ctor, you need to ensure all loads are done before the store and
>>     before ctor exits - you need to ensure value of the volatile is
>>     the final one at the end of the ctor sequence.  Otherwise, the
>>     loads can move after the store.  Basically, you need lazySet()
>>     now and not plain storestore.
>>
>>     Sent from my phone
>>
>>     On Dec 3, 2013 1:44 PM, "Oleksandr Otenko"
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         I don't think you'd need it in a constructor.
>>
>>         You can't read the fields until the reference to the instance
>>         is stored. If you can stop reordering that store with the
>>         last volatile store, publication is safe.
>>
>>         Alex
>>
>>         On 03/12/2013 18:34, Vitaly Davidovich wrote:
>>>
>>>         For volatiles, you'd need load-store as well though.
>>>
>>>         Sent from my phone
>>>
>>>         On Dec 3, 2013 1:05 PM, "Oleksandr Otenko"
>>>         <oleksandr.otenko at oracle.com
>>>         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>
>>>             Sure.
>>>
>>>             f=42;
>>>
>>>             already imposes the cost of store-store barrier.
>>>
>>>             f=42;
>>>             f=42;
>>>
>>>             does the same thing. In a constructor, eliminate the
>>>             first barrier, because the order of writes to the
>>>             unreachable instance is not important, and the second
>>>             store. This no longer is the question of performance,
>>>             because it is the same. It is the question of
>>>             correctness for free.
>>>
>>>             Alex
>>>
>>>             On 03/12/2013 17:53, Vitaly Davidovich wrote:
>>>>
>>>>             Not sure that's the right view either.  The one thing
>>>>             the author does not control is how instances of their
>>>>             class are passed around.  User of the class has more
>>>>             context - it may actually be ok that volatiles aren't
>>>>             fenced here because they're already ensuring some way
>>>>             that it's fine, including the possibility that the
>>>>             instance isn't even shared at all.  As long as people
>>>>             know the behavior of the language/platform, they should
>>>>             be expected to make an educated decision on their own.
>>>>
>>>>             Look, if performance didn't matter, you could just
>>>>             blindly say that all constructors have a freeze action,
>>>>             regardless of final fields or volatile. That's not the
>>>>             case, of course.  Java and JDK have tools available to
>>>>             publish safely, so people doing multithreading have the
>>>>             ability to do the right thing. At the end of the day,
>>>>             exposing concurrency to devs will lead to bugs, even
>>>>             beside the issues described here.
>>>>
>>>>             Sent from my phone
>>>>
>>>>             On Dec 3, 2013 12:42 PM, "Oleksandr Otenko"
>>>>             <oleksandr.otenko at oracle.com
>>>>             <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>
>>>>                 No, this is a completely opposite view. The
>>>>                 question is:
>>>>
>>>>                 do you as the implementor of the concurrent
>>>>                 algorithm ever intend the constructor design to be
>>>>                 such that relies on the protocol that the caller
>>>>                 chooses to publish the reference?
>>>>
>>>>                 (Do you ever intend to /*not*/ specify a no-op
>>>>                 volatile load after the last volatile store in the
>>>>                 constructor?)
>>>>
>>>>
>>>>                 Alex
>>>>
>>>>
>>>>                 On 03/12/2013 17:23, Vitaly Davidovich wrote:
>>>>>
>>>>>                 I'm confident most code that publishes objects
>>>>>                 shared across threads does it safely.  Otherwise
>>>>>                 we're saying majority of code uses data races?
>>>>>
>>>>>                 Sent from my phone
>>>>>
>>>>>                 On Dec 3, 2013 12:21 PM, "Oleksandr Otenko"
>>>>>                 <oleksandr.otenko at oracle.com
>>>>>                 <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>
>>>>>                     Hmmm.... I thought it is clear no one argues
>>>>>                     about the "/*if*/ you publish safely" part.
>>>>>                     The question I am wondering about is whether
>>>>>                     you can find a case where publishing the
>>>>>                     reference to the instance unsafely is /intended/.
>>>>>
>>>>>                     Alex
>>>>>
>>>>>                     On 03/12/2013 17:14, Vitaly Davidovich wrote:
>>>>>>
>>>>>>                     But this is only if you publish unsafely, as
>>>>>>                     mentioned before.  If you publish this class
>>>>>>                     properly, you don't get races on the
>>>>>>                     volatile.   Final fields are supposed to
>>>>>>                     support immutable classes, where although not
>>>>>>                     preferrable, publishing racily is plausible
>>>>>>                     (for performance).  For read/write volatiles,
>>>>>>                     it's not compelling on the surface.
>>>>>>
>>>>>>                     Sent from my phone
>>>>>>
>>>>>>                     On Dec 3, 2013 11:18 AM, "Oleksandr Otenko"
>>>>>>                     <oleksandr.otenko at oracle.com
>>>>>>                     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>
>>>>>>                         Yes, but I mean that the code assumes the
>>>>>>                         value to always be non-null - eg a
>>>>>>                         sentinel entry of the list is created at
>>>>>>                         construction time. Without the
>>>>>>                         construction-time guarantee you'd need to
>>>>>>                         test for null everywhere.
>>>>>>
>>>>>>                         I think the same applies in other
>>>>>>                         constructors - if you write the
>>>>>>                         initialization of the volatile, you imply
>>>>>>                         that's "the least" "possible" value, the
>>>>>>                         value representing the initial state of
>>>>>>                         the concurrent algorithm - the initial
>>>>>>                         value guaranteed by Java spec may not
>>>>>>                         represent any valid state of the
>>>>>>                         concurrent algorithm, let alone the
>>>>>>                         initial state.
>>>>>>
>>>>>>                         That's why this really boils down to
>>>>>>                         "find the broad cases where you do want
>>>>>>                         to permit unsafe publication of the
>>>>>>                         initial values of the volatiles".
>>>>>>
>>>>>>
>>>>>>                         (unlike the non-volatile fields. Don't
>>>>>>                         treat them as "not thread safe" -
>>>>>>                         instead, treat them as "assume as made
>>>>>>                         thread-safe by means outside the class
>>>>>>                         specification", hence no requirement for
>>>>>>                         "safe publication" there)
>>>>>>
>>>>>>
>>>>>>                         Alex
>>>>>>
>>>>>>
>>>>>>                         On 03/12/2013 15:08, Vitaly Davidovich wrote:
>>>>>>>
>>>>>>>                         Initial value of the field must be the
>>>>>>>                         "zero" value of that type, that's a
>>>>>>>                         language spec and must be guaranteed
>>>>>>>                         irrespective of volatile or not.
>>>>>>>
>>>>>>>                         Sent from my phone
>>>>>>>
>>>>>>>                         On Dec 3, 2013 10:03 AM, "Oleksandr
>>>>>>>                         Otenko" <oleksandr.otenko at oracle.com
>>>>>>>                         <mailto:oleksandr.otenko at oracle.com>> wrote:
>>>>>>>
>>>>>>>                             I understand, but you can't insist
>>>>>>>                             on viewing ctors as "just methods"
>>>>>>>                             for all purposes.
>>>>>>>
>>>>>>>                             (2) publication is unsafe unless you
>>>>>>>                             get a volatile load after the last
>>>>>>>                             volatile store in the constructor.
>>>>>>>                             Besides, the initial value of the
>>>>>>>                             field may not even be one of the
>>>>>>>                             valid values, so it is not even just
>>>>>>>                             about a data race.
>>>>>>>
>>>>>>>
>>>>>>>                             Alex
>>>>>>>
>>>>>>>
>>>>>>>                             On 03/12/2013 13:57, Vitaly
>>>>>>>                             Davidovich wrote:
>>>>>>>>
>>>>>>>>                             For compilation/codegen purposes
>>>>>>>>                             ctors *are* just methods - they can
>>>>>>>>                             be inlined, code optimized, etc;
>>>>>>>>                             that's the reason we have the final
>>>>>>>>                             field guarantees.
>>>>>>>>
>>>>>>>>                             A couple of potential reasons not
>>>>>>>>                             to add volatile to the spec:
>>>>>>>>                             1) perhaps some JVMs don't
>>>>>>>>                             currently already give them final
>>>>>>>>                             field semantics
>>>>>>>>                             2) this whole thing comes into play
>>>>>>>>                             for unsafe publication only (I.e.
>>>>>>>>                             data race), which is discouraged.
>>>>>>>>
>>>>>>>>                             Sent from my phone
>>>>>>>>
>>>>>>>>                             On Dec 3, 2013 6:51 AM, "Oleksandr
>>>>>>>>                             Otenko"
>>>>>>>>                             <oleksandr.otenko at oracle.com
>>>>>>>>                             <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>                             wrote:
>>>>>>>>
>>>>>>>>                                 Constructors /are/ special
>>>>>>>>                                 methods. They are the first
>>>>>>>>                                 method calls in any history of
>>>>>>>>                                 the object. This means a
>>>>>>>>                                 different treatment of volatile
>>>>>>>>                                 accesses to the fields of the
>>>>>>>>                                 instance being created is
>>>>>>>>                                 possible - certain barriers can
>>>>>>>>                                 be eliminated, because the
>>>>>>>>                                 loads can be proven to not
>>>>>>>>                                 synchronize with anyone. For
>>>>>>>>                                 the sake of the argument, it is
>>>>>>>>                                 possible to proceed with weak
>>>>>>>>                                 treatment of volatile stores,
>>>>>>>>                                 too, but you need a good reason
>>>>>>>>                                 to permit subsequent calls to
>>>>>>>>                                 observe the initial state of
>>>>>>>>                                 the volatile fields; whereas
>>>>>>>>                                 any volatile load in any other
>>>>>>>>                                 method always synchronizes with
>>>>>>>>                                 a volatile store of some other
>>>>>>>>                                 method call, without the final
>>>>>>>>                                 field semantics we cannot
>>>>>>>>                                 assume that.
>>>>>>>>
>>>>>>>>                                 However, if we assume final
>>>>>>>>                                 field semantics, there is only
>>>>>>>>                                 one barrier needed - a
>>>>>>>>                                 store-store after the last
>>>>>>>>                                 volatile field store. This
>>>>>>>>                                 eliminates all barriers for any
>>>>>>>>                                 other volatile field
>>>>>>>>                                 initialization, and eliminates
>>>>>>>>                                 a full barrier needed otherwise
>>>>>>>>                                 (got to place a dummy volatile
>>>>>>>>                                 load after the last volatile
>>>>>>>>                                 store to make sure the
>>>>>>>>                                 semantics are stronger than
>>>>>>>>                                 final-field) - think of
>>>>>>>>                                 removing a mfence or similar
>>>>>>>>                                 from each such constructor on x86.
>>>>>>>>
>>>>>>>>                                 (there will still be gotchas
>>>>>>>>                                 for cases when volatile field
>>>>>>>>                                 initialization occurs after a
>>>>>>>>                                 volatile load of something
>>>>>>>>                                 outside the same instance; but
>>>>>>>>                                 the main purpose is to
>>>>>>>>                                 eliminate barriers when the
>>>>>>>>                                 volatile fields are just
>>>>>>>>                                 initialized into some
>>>>>>>>                                 instance-specific values)
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 Alex
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 On 03/12/2013 05:54, Ruslan
>>>>>>>>                                 Cheremin wrote:
>>>>>>>>>                                 I'm about why "always mean
>>>>>>>>>                                 storestore after volatile
>>>>>>>>>                                 store in constructor". It is
>>>>>>>>>                                 not only efficiency which is
>>>>>>>>>                                 important for MM, but also
>>>>>>>>>                                 simplicity and consistency. If
>>>>>>>>>                                 constructors are special
>>>>>>>>>                                 methods, not just plain
>>>>>>>>>                                 <init>, then we should add
>>>>>>>>>                                 this kind of atomicity to all
>>>>>>>>>                                 constructors (which, as I was
>>>>>>>>>                                 reading here, could be
>>>>>>>>>                                 inefficient on some
>>>>>>>>>                                 platforms). But if
>>>>>>>>>                                 constructors are just plain
>>>>>>>>>                                 methods, it looks strange to
>>>>>>>>>                                 have special implicit
>>>>>>>>>                                 semantics for constructors
>>>>>>>>>                                 with volatiles inside.
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                 2013/12/3 Oleksandr Otenko
>>>>>>>>>                                 <oleksandr.otenko at oracle.com
>>>>>>>>>                                 <mailto:oleksandr.otenko at oracle.com>>
>>>>>>>>>
>>>>>>>>>                                     I think it is pretty simple.
>>>>>>>>>
>>>>>>>>>                                     If you always mean a
>>>>>>>>>                                     store-store barrier
>>>>>>>>>                                     /after/ the last volatile
>>>>>>>>>                                     store in the constructor,
>>>>>>>>>                                     then add that barrier into
>>>>>>>>>                                     constructor semantics,
>>>>>>>>>                                     like it's done with the
>>>>>>>>>                                     final fields.
>>>>>>>>>
>>>>>>>>>                                     It makes sense to /not/
>>>>>>>>>                                     add it to the semantics,
>>>>>>>>>                                     if you can come up with
>>>>>>>>>                                     enough examples where you
>>>>>>>>>                                     want that barrier to be
>>>>>>>>>                                     eliminated.
>>>>>>>>>
>>>>>>>>>                                     Alex
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     On 02/12/2013 19:32,
>>>>>>>>>                                     Ruslan Cheremin wrote:
>>>>>>>>>>                                     Well, I do not see any
>>>>>>>>>>                                     data race _on volatiles_
>>>>>>>>>>                                     here. I see race
>>>>>>>>>>                                     condition on volatile
>>>>>>>>>>                                     .value, yes -- but it is
>>>>>>>>>>                                     pretty legal (and
>>>>>>>>>>                                     unavoidable, I suppose)
>>>>>>>>>>                                     to have race conditions
>>>>>>>>>>                                     even with volatiles
>>>>>>>>>>                                     involved. The only data
>>>>>>>>>>                                     race I see is around
>>>>>>>>>>                                     read-write of
>>>>>>>>>>                                     (non-volatile)
>>>>>>>>>>                                     AtomicInteger's reference
>>>>>>>>>>                                     -- which is unrelated to
>>>>>>>>>>                                     AtomicInteger's content.
>>>>>>>>>>                                     I mean, I could not see
>>>>>>>>>>                                     any noticable difference
>>>>>>>>>>                                     between the case
>>>>>>>>>>                                     discussed, and just any
>>>>>>>>>>                                     other case there volatile
>>>>>>>>>>                                     is _incorrectly_ used to
>>>>>>>>>>                                     "synchronize" data
>>>>>>>>>>                                     accesses -- it could
>>>>>>>>>>                                     still be data race on
>>>>>>>>>>                                     non-volatile fields, even
>>>>>>>>>>                                     if volatile fields are
>>>>>>>>>>                                     also used somewhere
>>>>>>>>>>                                     around. Yes, get 0 from
>>>>>>>>>>                                     .value is unexpected --
>>>>>>>>>>                                     but there are many
>>>>>>>>>>                                     unexpected things in
>>>>>>>>>>                                     memory models. It is
>>>>>>>>>>                                     noway more unexpected
>>>>>>>>>>                                     then to see default
>>>>>>>>>>                                     values in fields of any
>>>>>>>>>>                                     other object which is
>>>>>>>>>>                                     unsafely published. I
>>>>>>>>>>                                     think everybody who
>>>>>>>>>>                                     passed through broken
>>>>>>>>>>                                     atomicity of constructor
>>>>>>>>>>                                     call could easy see the
>>>>>>>>>>                                     chance to read [.value=0]
>>>>>>>>>>                                     in the case discussed.
>>>>>>>>>>
>>>>>>>>>>                                     "Data race is pure evil"
>>>>>>>>>>                                     was the motto of this
>>>>>>>>>>                                     list all time I was
>>>>>>>>>>                                     reading it. Why do we may
>>>>>>>>>>                                     want to introduce another
>>>>>>>>>>                                     example of benign race?
>>>>>>>>>>                                     Wouldn't it be just
>>>>>>>>>>                                     another source of
>>>>>>>>>>                                     confusion for newcomers?
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                     2013/12/2 Doug Lea
>>>>>>>>>>                                     <dl at cs.oswego.edu
>>>>>>>>>>                                     <mailto:dl at cs.oswego.edu>>
>>>>>>>>>>
>>>>>>>>>>                                         On 12/02/2013 03:57
>>>>>>>>>>                                         AM, Cheremin Ruslan
>>>>>>>>>>                                         wrote:
>>>>>>>>>>
>>>>>>>>>>                                             Doug, could you
>>>>>>>>>>                                             explain why it is
>>>>>>>>>>                                             so important to
>>>>>>>>>>                                             have this kind of
>>>>>>>>>>                                             safe
>>>>>>>>>>                                             publication for
>>>>>>>>>>                                             volatile? I mean,
>>>>>>>>>>                                             could we just go
>>>>>>>>>>                                             with .value=0
>>>>>>>>>>                                             through data
>>>>>>>>>>                                             race to be
>>>>>>>>>>                                             allowed result,
>>>>>>>>>>                                             as current model
>>>>>>>>>>                                             (seem to) imply?
>>>>>>>>>>                                             It seems to be a
>>>>>>>>>>                                             dr-case anyway,
>>>>>>>>>>                                             why we need
>>>>>>>>>>                                             special handling
>>>>>>>>>>                                             of it?
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                         The main reason is
>>>>>>>>>>                                         that it is highly
>>>>>>>>>>                                         irregular and unexpected
>>>>>>>>>>                                         by programmers.
>>>>>>>>>>                                         Except in this case,
>>>>>>>>>>                                         volatiles
>>>>>>>>>>                                         definitionally cannot
>>>>>>>>>>                                         be subject to data
>>>>>>>>>>                                         races. Dealing with
>>>>>>>>>>                                         it requires cleverness,
>>>>>>>>>>                                         complexity, and/or
>>>>>>>>>>                                         error-proneness that
>>>>>>>>>>                                         isn't even required for
>>>>>>>>>>                                         correctness on
>>>>>>>>>>                                         current JVMs. We have
>>>>>>>>>>                                         several constructions
>>>>>>>>>>                                         in j.u.c that work
>>>>>>>>>>                                         around problems by
>>>>>>>>>>                                         using explicit ordered
>>>>>>>>>>                                         writes in
>>>>>>>>>>                                         constructors,
>>>>>>>>>>                                         redundant-looking
>>>>>>>>>>                                         null-checks, and so
>>>>>>>>>>                                         on. If we are going
>>>>>>>>>>                                         to repair the JMM
>>>>>>>>>>                                         anyway, this is a clear
>>>>>>>>>>                                         candidate for
>>>>>>>>>>                                         reconsideration.
>>>>>>>>>>
>>>>>>>>>>                                         -Doug
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                             Ruslan
>>>>>>>>>>
>>>>>>>>>>                                                 27 ????. 2013
>>>>>>>>>>                                                 ?., ? 23:26,
>>>>>>>>>>                                                 Doug Lea
>>>>>>>>>>                                                 <dl at cs.oswego.edu
>>>>>>>>>>                                                 <mailto:dl at cs.oswego.edu>>
>>>>>>>>>>                                                 ???????(?):
>>>>>>>>>>
>>>>>>>>>>                                                     On
>>>>>>>>>>                                                     11/27/2013 02:06
>>>>>>>>>>                                                     PM,
>>>>>>>>>>                                                     Vitaly
>>>>>>>>>>                                                     Davidovich wrote:
>>>>>>>>>>                                                     But
>>>>>>>>>>                                                     either way,
>>>>>>>>>>                                                     optimizations
>>>>>>>>>>                                                     to avoid
>>>>>>>>>>                                                     zeroing
>>>>>>>>>>                                                     memory is
>>>>>>>>>>                                                     an
>>>>>>>>>>                                                     implementation
>>>>>>>>>>                                                     detail and
>>>>>>>>>>                                                     thus
>>>>>>>>>>                                                     cannot be
>>>>>>>>>>                                                     relied
>>>>>>>>>>                                                     upon from
>>>>>>>>>>                                                     JMM
>>>>>>>>>>                                                     standpoint,
>>>>>>>>>>                                                     which I
>>>>>>>>>>                                                     think you're
>>>>>>>>>>                                                     saying.
>>>>>>>>>>
>>>>>>>>>>                                                     The other
>>>>>>>>>>                                                     issue is
>>>>>>>>>>                                                     that even
>>>>>>>>>>                                                     if we
>>>>>>>>>>                                                     determine
>>>>>>>>>>                                                     that
>>>>>>>>>>                                                     volatiles
>>>>>>>>>>                                                     don't get
>>>>>>>>>>                                                     this
>>>>>>>>>>                                                     treatment, if
>>>>>>>>>>                                                     JVM is
>>>>>>>>>>                                                     already
>>>>>>>>>>                                                     ensuring
>>>>>>>>>>                                                     it, it's
>>>>>>>>>>                                                     not going
>>>>>>>>>>                                                     to be
>>>>>>>>>>                                                     practical
>>>>>>>>>>                                                     to change
>>>>>>>>>>                                                     it and
>>>>>>>>>>                                                     risk hard
>>>>>>>>>>                                                     to debug
>>>>>>>>>>                                                     problems
>>>>>>>>>>                                                     creeping
>>>>>>>>>>                                                     in.  May
>>>>>>>>>>                                                     as well
>>>>>>>>>>                                                     update
>>>>>>>>>>                                                     the spec
>>>>>>>>>>                                                     now ...
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                                 Right. To
>>>>>>>>>>                                                 summarize:
>>>>>>>>>>
>>>>>>>>>>                                                 * Programmers
>>>>>>>>>>                                                 do not expect
>>>>>>>>>>                                                 that even
>>>>>>>>>>                                                 though final
>>>>>>>>>>                                                 fields are
>>>>>>>>>>                                                 specifically
>>>>>>>>>>                                                 publication-safe,
>>>>>>>>>>                                                 volatile
>>>>>>>>>>                                                 fields are
>>>>>>>>>>                                                 not always so.
>>>>>>>>>>
>>>>>>>>>>                                                 * For various
>>>>>>>>>>                                                 implementation reasons,
>>>>>>>>>>                                                 JVMs arrange
>>>>>>>>>>                                                 that volatile
>>>>>>>>>>                                                 fields are
>>>>>>>>>>                                                 publication
>>>>>>>>>>                                                 safe anyway,
>>>>>>>>>>                                                 at least in
>>>>>>>>>>                                                 cases we know
>>>>>>>>>>                                                 about.
>>>>>>>>>>
>>>>>>>>>>                                                 * Actually
>>>>>>>>>>                                                 updating the
>>>>>>>>>>                                                 JMM/JLS to
>>>>>>>>>>                                                 mandate this
>>>>>>>>>>                                                 is not easy
>>>>>>>>>>                                                 (no small tweak
>>>>>>>>>>                                                 that I know
>>>>>>>>>>                                                 applies). But
>>>>>>>>>>                                                 now is a good
>>>>>>>>>>                                                 time to be
>>>>>>>>>>                                                 considering a
>>>>>>>>>>                                                 full
>>>>>>>>>>                                                 revision for
>>>>>>>>>>                                                 JDK9.
>>>>>>>>>>
>>>>>>>>>>                                                 * In the mean
>>>>>>>>>>                                                 time, it
>>>>>>>>>>                                                 would make
>>>>>>>>>>                                                 sense to
>>>>>>>>>>                                                 further test
>>>>>>>>>>                                                 and validate JVMs
>>>>>>>>>>                                                 as meeting
>>>>>>>>>>                                                 this likely
>>>>>>>>>>                                                 future spec.
>>>>>>>>>>
>>>>>>>>>>                                                 -Doug
>>>>>>>>>>
>>>>>>>>>>                                                 _______________________________________________
>>>>>>>>>>                                                 Concurrency-interest
>>>>>>>>>>                                                 mailing list
>>>>>>>>>>                                                 Concurrency-interest at cs.oswego.edu
>>>>>>>>>>                                                 <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>                                                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>                                     _______________________________________________
>>>>>>>>>>                                     Concurrency-interest mailing list
>>>>>>>>>>                                     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>>                                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>                                     _______________________________________________
>>>>>>>>>                                     Concurrency-interest
>>>>>>>>>                                     mailing list
>>>>>>>>>                                     Concurrency-interest at cs.oswego.edu
>>>>>>>>>                                     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>                                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>                                 _______________________________________________
>>>>>>>>                                 Concurrency-interest mailing list
>>>>>>>>                                 Concurrency-interest at cs.oswego.edu
>>>>>>>>                                 <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>                                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>>                         _______________________________________________
>>>>>>                         Concurrency-interest mailing list
>>>>>>                         Concurrency-interest at cs.oswego.edu
>>>>>>                         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>                         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>
>>>>
>>>
>>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131208/805aad15/attachment-0001.html>

From bhorowit at gmail.com  Mon Dec  9 19:52:45 2013
From: bhorowit at gmail.com (Ben Horowitz)
Date: Mon, 9 Dec 2013 16:52:45 -0800
Subject: [concurrency-interest] Composite BlockingQueue
Message-ID: <CAM1tkGXMQV_OGeJVWtFk=GL0ZJZmPw_FBoXuLhbFiu8jSnjEtA@mail.gmail.com>

Hi concurrency-interest,

I may need to use/write a BlockingQueue that is the composite of several
blocking queues Q1, ..., Qn.

The idea would be that the blocking remove operations would round-robin
their requests to the underlying queues Q1, ..., Qn, defaulting to a
non-empty queue if the queue selected by round-robin is empty and some
queue is non-empty.

I'd rather not reinvent the wheel. Has anyone done this before? Is the
result publicly available?

Thanks,
Ben
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131209/2671db0c/attachment.html>

From viktor.klang at gmail.com  Mon Dec  9 20:04:06 2013
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Tue, 10 Dec 2013 03:04:06 +0200
Subject: [concurrency-interest] Composite BlockingQueue
In-Reply-To: <CAM1tkGXMQV_OGeJVWtFk=GL0ZJZmPw_FBoXuLhbFiu8jSnjEtA@mail.gmail.com>
References: <CAM1tkGXMQV_OGeJVWtFk=GL0ZJZmPw_FBoXuLhbFiu8jSnjEtA@mail.gmail.com>
Message-ID: <CANPzfU-QHu7XQ7z=Vvf32xDA50+q5SeihmG4-EDQWje8wdDZAw@mail.gmail.com>

Hi Ben,

admittedly it is 3am here, so take my opinion with a pinch of salt, but
what you propose does not make sense to me so let me ask you this: Are you
expecting to have parallel gets/puts to the inner queues?

Cheers,
?


On Tue, Dec 10, 2013 at 2:52 AM, Ben Horowitz <bhorowit at gmail.com> wrote:

> Hi concurrency-interest,
>
> I may need to use/write a BlockingQueue that is the composite of several
> blocking queues Q1, ..., Qn.
>
> The idea would be that the blocking remove operations would round-robin
> their requests to the underlying queues Q1, ..., Qn, defaulting to a
> non-empty queue if the queue selected by round-robin is empty and some
> queue is non-empty.
>
> I'd rather not reinvent the wheel. Has anyone done this before? Is the
> result publicly available?
>
> Thanks,
> Ben
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Cheers,
?

*Viktor Klang*
*Director of Engineering*
Typesafe <http://www.typesafe.com/>

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131210/82a4ebe9/attachment.html>

From oleksandr.otenko at oracle.com  Tue Dec 10 06:26:25 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 10 Dec 2013 11:26:25 +0000
Subject: [concurrency-interest] Composite BlockingQueue
In-Reply-To: <CAM1tkGXMQV_OGeJVWtFk=GL0ZJZmPw_FBoXuLhbFiu8jSnjEtA@mail.gmail.com>
References: <CAM1tkGXMQV_OGeJVWtFk=GL0ZJZmPw_FBoXuLhbFiu8jSnjEtA@mail.gmail.com>
Message-ID: <52A6FA61.6040506@oracle.com>

This has been done before.

http://blogs.oracle.com/dave/resource/spaa11-multiset.pdf - this is a 
"almost-FIFO" queue (for obvious reason, it is not fully FIFO)

At the time of writing that article we also had a FIFO queue, but we 
kept the results private. Similar designs were published later.


Alex


On 10/12/2013 00:52, Ben Horowitz wrote:
> Hi concurrency-interest,
>
> I may need to use/write a BlockingQueue that is the composite of 
> several blocking queues Q1, ..., Qn.
>
> The idea would be that the blocking remove operations would 
> round-robin their requests to the underlying queues Q1, ..., Qn, 
> defaulting to a non-empty queue if the queue selected by round-robin 
> is empty and some queue is non-empty.
>
> I'd rather not reinvent the wheel. Has anyone done this before? Is the 
> result publicly available?
>
> Thanks,
> Ben


From valentin.male.kovalenko at gmail.com  Tue Dec 10 12:28:10 2013
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Tue, 10 Dec 2013 21:28:10 +0400
Subject: [concurrency-interest] Composite BlockingQueue
Message-ID: <CAO-wXwLBV6MQVE5sAxhA=MWryMnc11eYRzkRZWR8fVxrUZpBbQ@mail.gmail.com>

Ben Horowitz wrote
>>http://blogs.oracle.com/dave/resource/spaa11-multiset.pdf - this is a
>>"almost-FIFO" queue (for obvious reason, it is not fully FIFO)

Ben, have you considered Disruptor (
http://lmax-exchange.github.io/disruptor/) instead of creating a new
improvement to Doug Lea's ArrayBlockingQueue? If yes, then why it didn't
satisfy your requirements? If no, then why "no"? :)

On Tue, Dec 10, 2013 at 9:00 PM, <concurrency-interest-request at cs.oswego.edu
> wrote:

> Send Concurrency-interest mailing list submissions to
>         concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
>         concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
>         concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>    1. Composite BlockingQueue (Ben Horowitz)
>    2. Re: Composite BlockingQueue (?iktor ?lang)
>    3. Re: Composite BlockingQueue (Oleksandr Otenko)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 9 Dec 2013 16:52:45 -0800
> From: Ben Horowitz <bhorowit at gmail.com>
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Composite BlockingQueue
> Message-ID:
>         <CAM1tkGXMQV_OGeJVWtFk=
> GL0ZJZmPw_FBoXuLhbFiu8jSnjEtA at mail.gmail.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Hi concurrency-interest,
>
> I may need to use/write a BlockingQueue that is the composite of several
> blocking queues Q1, ..., Qn.
>
> The idea would be that the blocking remove operations would round-robin
> their requests to the underlying queues Q1, ..., Qn, defaulting to a
> non-empty queue if the queue selected by round-robin is empty and some
> queue is non-empty.
>
> I'd rather not reinvent the wheel. Has anyone done this before? Is the
> result publicly available?
>
> Thanks,
> Ben
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131209/2671db0c/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 2
> Date: Tue, 10 Dec 2013 03:04:06 +0200
> From: ?iktor ?lang <viktor.klang at gmail.com>
> To: Ben Horowitz <bhorowit at gmail.com>
> Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Composite BlockingQueue
> Message-ID:
>         <CANPzfU-QHu7XQ7z=
> Vvf32xDA50+q5SeihmG4-EDQWje8wdDZAw at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Hi Ben,
>
> admittedly it is 3am here, so take my opinion with a pinch of salt, but
> what you propose does not make sense to me so let me ask you this: Are you
> expecting to have parallel gets/puts to the inner queues?
>
> Cheers,
> ?
>
>
> On Tue, Dec 10, 2013 at 2:52 AM, Ben Horowitz <bhorowit at gmail.com> wrote:
>
> > Hi concurrency-interest,
> >
> > I may need to use/write a BlockingQueue that is the composite of several
> > blocking queues Q1, ..., Qn.
> >
> > The idea would be that the blocking remove operations would round-robin
> > their requests to the underlying queues Q1, ..., Qn, defaulting to a
> > non-empty queue if the queue selected by round-robin is empty and some
> > queue is non-empty.
> >
> > I'd rather not reinvent the wheel. Has anyone done this before? Is the
> > result publicly available?
> >
> > Thanks,
> > Ben
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
>
> --
> Cheers,
> ?
>
> *Viktor Klang*
> *Director of Engineering*
> Typesafe <http://www.typesafe.com/>
>
> Twitter: @viktorklang
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131210/82a4ebe9/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 3
> Date: Tue, 10 Dec 2013 11:26:25 +0000
> From: Oleksandr Otenko <oleksandr.otenko at oracle.com>
> To: Ben Horowitz <bhorowit at gmail.com>
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Composite BlockingQueue
> Message-ID: <52A6FA61.6040506 at oracle.com>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> This has been done before.
>
> http://blogs.oracle.com/dave/resource/spaa11-multiset.pdf - this is a
> "almost-FIFO" queue (for obvious reason, it is not fully FIFO)
>
> At the time of writing that article we also had a FIFO queue, but we
> kept the results private. Similar designs were published later.
>
>
> Alex
>
>
> On 10/12/2013 00:52, Ben Horowitz wrote:
> > Hi concurrency-interest,
> >
> > I may need to use/write a BlockingQueue that is the composite of
> > several blocking queues Q1, ..., Qn.
> >
> > The idea would be that the blocking remove operations would
> > round-robin their requests to the underlying queues Q1, ..., Qn,
> > defaulting to a non-empty queue if the queue selected by round-robin
> > is empty and some queue is non-empty.
> >
> > I'd rather not reinvent the wheel. Has anyone done this before? Is the
> > result publicly available?
> >
> > Thanks,
> > Ben
>
>
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 107, Issue 46
> *****************************************************
>



-- 
Homo homini lupus est.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131210/05f58162/attachment.html>

From david at walend.net  Tue Dec 10 14:27:36 2013
From: david at walend.net (David Walend)
Date: Tue, 10 Dec 2013 14:27:36 -0500
Subject: [concurrency-interest] Composite BlockingQueue
In-Reply-To: <mailman.1.1386694800.19754.concurrency-interest@cs.oswego.edu>
References: <mailman.1.1386694800.19754.concurrency-interest@cs.oswego.edu>
Message-ID: <F8B828E1-10F6-4558-9DAA-2A3B24BF6617@walend.net>

Ben,

I've had some success with a single PriorityBlockingQueue, a custom Comparator, and a time stamp (low res -- System.currentTimeMillis()). 

You could do it with a a more elaborate stamper that keeps count of where messages came from originally, depending on how far from that round-robin ideal you can deviate. If you haven't enqueued (or delivered) an item from one source in a while, give items from that source a higher priority when they enter the queue. 

The code is from my misspent youth: https://java.net/projects/somnifugijms/sources/svn/content/trunk/source/somnifugi/net/walend/somnifugi/juc/MessageComparator.java?rev=287 

I had to do some crazier things (queues of marked atomic references) to support message selectors for that project. You're much better off stuffing the complexity in a comparator if you can get away with it.

Dave

On Dec 10, 2013, at 12:00 PM, concurrency-interest-request at cs.oswego.edu wrote:

> Date: Mon, 9 Dec 2013 16:52:45 -0800
> From: Ben Horowitz <bhorowit at gmail.com>
> 
> I may need to use/write a BlockingQueue that is the composite of several
> blocking queues Q1, ..., Qn.
> 
> The idea would be that the blocking remove operations would round-robin
> their requests to the underlying queues Q1, ..., Qn, defaulting to a
> non-empty queue if the queue selected by round-robin is empty and some
> queue is non-empty.
> 
> I'd rather not reinvent the wheel. Has anyone done this before? Is the
> result publicly available?
> 
> Thanks,
> Ben



From amitava.biswas at gmail.com  Tue Dec 10 14:37:19 2013
From: amitava.biswas at gmail.com (amitava_rkv)
Date: Tue, 10 Dec 2013 11:37:19 -0800 (PST)
Subject: [concurrency-interest] Memory visibility semantics of jni c native
 data when synchronized externally in java
Message-ID: <1386704238803-10427.post@n7.nabble.com>

HI, Basically we have a native method in java which is invoked through jni .
THe java wrapper code is synchronizing on a java object before calling the
native method. Inside the native method we have a pre-allocated array of c
structures , which is getting resized through realloc .This array of c
structures stays outside the jvm heap. Question is if i have another thread
which is synchronizing in java on the same java object and calling another
native method through jni , is it guaranteed that it will see a consistent
view of the re allocated array of c structures . Assuming the c structure
fields are not volatile .. Basically will the memory visibility semantics of
Java synchronized block percolate to native allocated data if it is not part
of the jvm heap . I am asking for redhat 4 and jdk1.6_30 64 bit.



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Memory-visibility-semantics-of-jni-c-native-data-when-synchronized-externally-in-java-tp10427.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From ariel at weisberg.ws  Tue Dec 10 14:57:58 2013
From: ariel at weisberg.ws (Ariel Weisberg)
Date: Tue, 10 Dec 2013 14:57:58 -0500
Subject: [concurrency-interest] Memory visibility semantics of jni c
 native data when synchronized externally in java
In-Reply-To: <1386704238803-10427.post@n7.nabble.com>
References: <1386704238803-10427.post@n7.nabble.com>
Message-ID: <1386705478.26229.57974385.5F430B36@webmail.messagingengine.com>

Hi,

I could be wrong, but the Java memory model should encapsulate stores
performed inside JNI calls.

http://gee.cs.oswego.edu/dl/jmm/cookbook.html

"Calls to and returns from JNI routines may require barriers, although
this seems to be a quality of implementation issue."

You should get the proper ordering and memory barriers unless there is
some caveat I have never heard of.

Regards,
Ariel

On Tue, Dec 10, 2013, at 02:37 PM, amitava_rkv wrote:
> HI, Basically we have a native method in java which is invoked through
> jni .
> THe java wrapper code is synchronizing on a java object before calling
> the
> native method. Inside the native method we have a pre-allocated array of
> c
> structures , which is getting resized through realloc .This array of c
> structures stays outside the jvm heap. Question is if i have another
> thread
> which is synchronizing in java on the same java object and calling
> another
> native method through jni , is it guaranteed that it will see a
> consistent
> view of the re allocated array of c structures . Assuming the c structure
> fields are not volatile .. Basically will the memory visibility semantics
> of
> Java synchronized block percolate to native allocated data if it is not
> part
> of the jvm heap . I am asking for redhat 4 and jdk1.6_30 64 bit.
> 
> 
> 
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/Memory-visibility-semantics-of-jni-c-native-data-when-synchronized-externally-in-java-tp10427.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From valentin.male.kovalenko at gmail.com  Tue Dec 10 17:09:22 2013
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Wed, 11 Dec 2013 02:09:22 +0400
Subject: [concurrency-interest] Composite BlockingQueue
Message-ID: <CAO-wXw+HqUEX_x0oR-Mbk+hcpDLtOz=4HWZq7JmFhk_V0nnenA@mail.gmail.com>

>>http://blogs.oracle.com/dave/resource/spaa11-multiset.pdf - this is a
>>"almost-FIFO" queue (for obvious reason, it is not fully FIFO)

Oleksandr, sorry for double post and for erroneously calling you Ben.
I want to ask in addition to my previous question - may be Concurrent
Blocking
Multiset is used in ForkJoinPool as a submission queue? (according to
Aleksey Shipilev's FJPool presentation a similar construction is used for
externally submitted tasks)

-- 
Homo homini lupus est.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131211/cc5e12d0/attachment-0001.html>

From oleksandr.otenko at oracle.com  Tue Dec 10 17:39:16 2013
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 10 Dec 2013 22:39:16 +0000
Subject: [concurrency-interest] Composite BlockingQueue
In-Reply-To: <CAO-wXw+HqUEX_x0oR-Mbk+hcpDLtOz=4HWZq7JmFhk_V0nnenA@mail.gmail.com>
References: <CAO-wXw+HqUEX_x0oR-Mbk+hcpDLtOz=4HWZq7JmFhk_V0nnenA@mail.gmail.com>
Message-ID: <52A79814.6040300@oracle.com>

It can be used as a queue. The multiset only doesn't guarantee full FIFO 
order. The advantage of the construct is the ability to compose 
arbitrary queue designs.

And if your other question is also directed at me, then no, we didn't 
use or compare to Disruptor. I am pretty sure it wasn't publicly 
available yet.


Alex


On 10/12/2013 22:09, Valentin Kovalenko wrote:
> >>http://blogs.oracle.com/dave/resource/spaa11-multiset.pdf - this is a
> >>"almost-FIFO" queue (for obvious reason, it is not fully FIFO)
>
> Oleksandr, sorry for double post and for erroneously calling you Ben.
> I want to ask in addition to my previous question - may be Concurrent 
> Blocking
> Multiset is used in ForkJoinPool as a submission queue? (according to 
> Aleksey Shipilev's FJPool presentation a similar construction is used 
> for externally submitted tasks)
>
> -- 
> Homo homini lupus est.
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131210/2b116e6d/attachment.html>

From valentin.male.kovalenko at gmail.com  Tue Dec 10 18:09:30 2013
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Wed, 11 Dec 2013 03:09:30 +0400
Subject: [concurrency-interest] Composite BlockingQueue
Message-ID: <CAO-wXwKCnpfjA28XG7ndv61txxV8u_adycQQeMzh98uf15Nv5A@mail.gmail.com>

>>It can be used as a queue. The multiset only doesn't guarantee full FIFO
order
Yes, I understand this. But multiset (if BlockingQueue is used underneath)
guarantees that any element that was put in it will eventually be taken out
no matter how many new elements producers produce. So it seems to satisfy
requirements of FJPool submission queue, because neither FJPool, nor
Executor/ExecutorService guarantees FIFO.

>>no, we didn't use or compare to Disruptor. I am pretty sure it wasn't
publicly available yet.
ok, thanks!

On Wed, Dec 11, 2013 at 2:39 AM, Oleksandr Otenko <
oleksandr.otenko at oracle.com> wrote:

>  It can be used as a queue. The multiset only doesn't guarantee full FIFO
> order. The advantage of the construct is the ability to compose arbitrary
> queue designs.
>
> And if your other question is also directed at me, then no, we didn't use
> or compare to Disruptor. I am pretty sure it wasn't publicly available yet.
>
>
> Alex
>
>
>
> On 10/12/2013 22:09, Valentin Kovalenko wrote:
>
>  >>http://blogs.oracle.com/dave/resource/spaa11-multiset.pdf - this is a
> >>"almost-FIFO" queue (for obvious reason, it is not fully FIFO)
>
>  Oleksandr, sorry for double post and for erroneously calling you Ben.
> I want to ask in addition to my previous question - may be Concurrent
> Blocking
> Multiset is used in ForkJoinPool as a submission queue? (according to
> Aleksey Shipilev's FJPool presentation a similar construction is used for
> externally submitted tasks)
>
>  --
> Homo homini lupus est.
>
>
>


-- 
Homo homini lupus est.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131211/b7e909c3/attachment.html>

From hans.boehm at hp.com  Tue Dec 10 18:38:45 2013
From: hans.boehm at hp.com (Boehm, Hans)
Date: Tue, 10 Dec 2013 23:38:45 +0000
Subject: [concurrency-interest] Memory visibility semantics of jni c
 native data when synchronized externally in java
In-Reply-To: <1386705478.26229.57974385.5F430B36@webmail.messagingengine.com>
References: <1386704238803-10427.post@n7.nabble.com>
	<1386705478.26229.57974385.5F430B36@webmail.messagingengine.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD23D521E7C@G9W0725.americas.hpqcorp.net>

In general, this seems to require that Java and native code use somewhat compatible conventions for enforcing the respective memory model rules.  I'm not sure that this is true on all architectures, but on x86, it should be.

If you are seeing failures in this area, I would check if realloc() uses MOVNTx to do the copy (likely for large objects), and fails to include a trailing fence of some sort (hopefully unlikely).  That could cause this case to fail, but it could probably also cause a pure C application to fail, and hence seems unlikely.  Unfortunately, as far as I know, the requirement for any function using MOVNTx include such a fence is not written down in any ABI documentation.  In my opinion, it needs to be, but last time I made that suggestion, I don't think it went anywhere.

Hans

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Ariel Weisberg
> Sent: Tuesday, December 10, 2013 11:58 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Memory visibility semantics of jni
> c native data when synchronized externally in java
> 
> Hi,
> 
> I could be wrong, but the Java memory model should encapsulate stores
> performed inside JNI calls.
> 
> http://gee.cs.oswego.edu/dl/jmm/cookbook.html
> 
> "Calls to and returns from JNI routines may require barriers, although
> this seems to be a quality of implementation issue."
> 
> You should get the proper ordering and memory barriers unless there is
> some caveat I have never heard of.
> 
> Regards,
> Ariel
> 
> On Tue, Dec 10, 2013, at 02:37 PM, amitava_rkv wrote:
> > HI, Basically we have a native method in java which is invoked
> through
> > jni .
> > THe java wrapper code is synchronizing on a java object before
> calling
> > the
> > native method. Inside the native method we have a pre-allocated array
> of
> > c
> > structures , which is getting resized through realloc .This array of
> c
> > structures stays outside the jvm heap. Question is if i have another
> > thread
> > which is synchronizing in java on the same java object and calling
> > another
> > native method through jni , is it guaranteed that it will see a
> > consistent
> > view of the re allocated array of c structures . Assuming the c
> structure
> > fields are not volatile .. Basically will the memory visibility
> semantics
> > of
> > Java synchronized block percolate to native allocated data if it is
> not
> > part
> > of the jvm heap . I am asking for redhat 4 and jdk1.6_30 64 bit.
> >
> >
> >
> > --
> > View this message in context:
> > http://jsr166-concurrency.10961.n7.nabble.com/Memory-visibility-
> semantics-of-jni-c-native-data-when-synchronized-externally-in-java-
> tp10427.html
> > Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From davidcholmes at aapt.net.au  Fri Dec 13 19:42:01 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 14 Dec 2013 10:42:01 +1000
Subject: [concurrency-interest] Memory visibility semantics of jni c
	native data when synchronized externally in java
In-Reply-To: <1386704238803-10427.post@n7.nabble.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEBJKDAA.davidcholmes@aapt.net.au>

There is nothing in the spec, as far as I can recall, that specifically
covers this case. However in practice for JVMs where the Java heap is the
same kind of memory as the C-Heap then it will work as desired. In theory it
would be possible to use different kinds of memory for the two and thus use
"barriers" specific to one but not the other. But the JDK on mainstream
platforms should not have a problem with this.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
> amitava_rkv
> Sent: Wednesday, 11 December 2013 5:37 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Memory visibility semantics of jni c
> native data when synchronized externally in java
>
>
> HI, Basically we have a native method in java which is invoked
> through jni .
> THe java wrapper code is synchronizing on a java object before calling the
> native method. Inside the native method we have a pre-allocated array of c
> structures , which is getting resized through realloc .This array of c
> structures stays outside the jvm heap. Question is if i have
> another thread
> which is synchronizing in java on the same java object and calling another
> native method through jni , is it guaranteed that it will see a consistent
> view of the re allocated array of c structures . Assuming the c structure
> fields are not volatile .. Basically will the memory visibility
> semantics of
> Java synchronized block percolate to native allocated data if it
> is not part
> of the jvm heap . I am asking for redhat 4 and jdk1.6_30 64 bit.
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/Memory-visibility-se
mantics-of-jni-c-native-data-when-synchronized-externally-in-java-tp10427.ht
ml
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From cheremin at gmail.com  Sat Dec 14 05:30:55 2013
From: cheremin at gmail.com (Cheremin Ruslan)
Date: Sat, 14 Dec 2013 14:30:55 +0400
Subject: [concurrency-interest] Memory visibility semantics of jni c
	native data when synchronized externally in java
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEBJKDAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCOEBJKDAA.davidcholmes@aapt.net.au>
Message-ID: <FDE94790-5E4E-44E7-A9F4-9CC4A61054C5@gmail.com>

I heard of specific kind of instructions like SSE or similar, which may require additional barriers (like lfence) if used. Could it be the jvm itself does not use such instructions, while C-compiler does, and this lead to gap in memory semantics?

??????

> 14 ???. 2013 ?., ? 4:42, "David Holmes" <davidcholmes at aapt.net.au> ???????(?):
> 
> There is nothing in the spec, as far as I can recall, that specifically
> covers this case. However in practice for JVMs where the Java heap is the
> same kind of memory as the C-Heap then it will work as desired. In theory it
> would be possible to use different kinds of memory for the two and thus use
> "barriers" specific to one but not the other. But the JDK on mainstream
> platforms should not have a problem with this.
> 
> David
> 
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
>> amitava_rkv
>> Sent: Wednesday, 11 December 2013 5:37 AM
>> To: concurrency-interest at cs.oswego.edu
>> Subject: [concurrency-interest] Memory visibility semantics of jni c
>> native data when synchronized externally in java
>> 
>> 
>> HI, Basically we have a native method in java which is invoked
>> through jni .
>> THe java wrapper code is synchronizing on a java object before calling the
>> native method. Inside the native method we have a pre-allocated array of c
>> structures , which is getting resized through realloc .This array of c
>> structures stays outside the jvm heap. Question is if i have
>> another thread
>> which is synchronizing in java on the same java object and calling another
>> native method through jni , is it guaranteed that it will see a consistent
>> view of the re allocated array of c structures . Assuming the c structure
>> fields are not volatile .. Basically will the memory visibility
>> semantics of
>> Java synchronized block percolate to native allocated data if it
>> is not part
>> of the jvm heap . I am asking for redhat 4 and jdk1.6_30 64 bit.
>> 
>> 
>> 
>> --
>> View this message in context:
>> http://jsr166-concurrency.10961.n7.nabble.com/Memory-visibility-se
> mantics-of-jni-c-native-data-when-synchronized-externally-in-java-tp10427.ht
> ml
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From davidcholmes at aapt.net.au  Sat Dec 14 06:58:23 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 14 Dec 2013 21:58:23 +1000
Subject: [concurrency-interest] Memory visibility semantics of jni
	cnative data when synchronized externally in java
In-Reply-To: <FDE94790-5E4E-44E7-A9F4-9CC4A61054C5@gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEBLKDAA.davidcholmes@aapt.net.au>

I can't check the details at the moment but I think you will find that
monitor exit uses the strongest form of barrier available ie full fence.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
> Cheremin Ruslan
> Sent: Saturday, 14 December 2013 8:31 PM
> To: dholmes at ieee.org
> Cc: <concurrency-interest at cs.oswego.edu>; amitava_rkv
> Subject: Re: [concurrency-interest] Memory visibility semantics
> of jni cnative data when synchronized externally in java
>
>
> I heard of specific kind of instructions like SSE or similar,
> which may require additional barriers (like lfence) if used.
> Could it be the jvm itself does not use such instructions, while
> C-compiler does, and this lead to gap in memory semantics?
>
> ??????
>
> > 14 ???. 2013 ?., ? 4:42, "David Holmes"
> <davidcholmes at aapt.net.au> ???????(?):
> >
> > There is nothing in the spec, as far as I can recall, that specifically
> > covers this case. However in practice for JVMs where the Java
> heap is the
> > same kind of memory as the C-Heap then it will work as desired.
> In theory it
> > would be possible to use different kinds of memory for the two
> and thus use
> > "barriers" specific to one but not the other. But the JDK on mainstream
> > platforms should not have a problem with this.
> >
> > David
> >
> >> -----Original Message-----
> >> From: concurrency-interest-bounces at cs.oswego.edu
> >> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
> >> amitava_rkv
> >> Sent: Wednesday, 11 December 2013 5:37 AM
> >> To: concurrency-interest at cs.oswego.edu
> >> Subject: [concurrency-interest] Memory visibility semantics of jni c
> >> native data when synchronized externally in java
> >>
> >>
> >> HI, Basically we have a native method in java which is invoked
> >> through jni .
> >> THe java wrapper code is synchronizing on a java object before
> calling the
> >> native method. Inside the native method we have a
> pre-allocated array of c
> >> structures , which is getting resized through realloc .This array of c
> >> structures stays outside the jvm heap. Question is if i have
> >> another thread
> >> which is synchronizing in java on the same java object and
> calling another
> >> native method through jni , is it guaranteed that it will see
> a consistent
> >> view of the re allocated array of c structures . Assuming the
> c structure
> >> fields are not volatile .. Basically will the memory visibility
> >> semantics of
> >> Java synchronized block percolate to native allocated data if it
> >> is not part
> >> of the jvm heap . I am asking for redhat 4 and jdk1.6_30 64 bit.
> >>
> >>
> >>
> >> --
> >> View this message in context:
> >> http://jsr166-concurrency.10961.n7.nabble.com/Memory-visibility-se
> >
> mantics-of-jni-c-native-data-when-synchronized-externally-in-java-
> tp10427.ht
> > ml
> > Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From amitava.biswas at gmail.com  Sat Dec 14 10:02:56 2013
From: amitava.biswas at gmail.com (amitava_rkv)
Date: Sat, 14 Dec 2013 07:02:56 -0800 (PST)
Subject: [concurrency-interest] Memory visibility semantics of jni
 cnative data when synchronized externally in java
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEBLKDAA.davidcholmes@aapt.net.au>
References: <1386704238803-10427.post@n7.nabble.com>
	<NFBBKALFDCPFIDBNKAPCOEBJKDAA.davidcholmes@aapt.net.au>
	<FDE94790-5E4E-44E7-A9F4-9CC4A61054C5@gmail.com>
	<NFBBKALFDCPFIDBNKAPCOEBLKDAA.davidcholmes@aapt.net.au>
Message-ID: <1387033376525-10437.post@n7.nabble.com>

Thank you everyone for your very insightful replies . I wanted to know that
if the jni is writing to memory mapped files in the context of the above
question , is it possible for readers to see inconsistent view of memory
mapped file inspite of synchronization at the java layer.



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Memory-visibility-semantics-of-jni-c-native-data-when-synchronized-externally-in-java-tp10427p10437.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From nathan.reynolds at oracle.com  Mon Dec 16 12:55:13 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 16 Dec 2013 10:55:13 -0700
Subject: [concurrency-interest] Memory visibility semantics of jni
 cnative data when synchronized externally in java
In-Reply-To: <1387033376525-10437.post@n7.nabble.com>
References: <1386704238803-10427.post@n7.nabble.com>	<NFBBKALFDCPFIDBNKAPCOEBJKDAA.davidcholmes@aapt.net.au>	<FDE94790-5E4E-44E7-A9F4-9CC4A61054C5@gmail.com>	<NFBBKALFDCPFIDBNKAPCOEBLKDAA.davidcholmes@aapt.net.au>
	<1387033376525-10437.post@n7.nabble.com>
Message-ID: <52AF3E81.5090904@oracle.com>

If the readers are in the same JVM as the writers and are going through 
the same lock, then they may or may not see an inconsistent view of 
memory.  The previous conversation suggests that they will not see an 
inconsistent view of memory.

However, if the readers are in another process, then they could see an 
inconsistent view of memory since they won't be going through the same 
lock instance.  In this case, you need to create a lock that both 
processes can acquire and release.

-Nathan

On 12/14/2013 8:02 AM, amitava_rkv wrote:
> Thank you everyone for your very insightful replies . I wanted to know that
> if the jni is writing to memory mapped files in the context of the above
> question , is it possible for readers to see inconsistent view of memory
> mapped file inspite of synchronization at the java layer.
>
>
>
> --
> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Memory-visibility-semantics-of-jni-c-native-data-when-synchronized-externally-in-java-tp10427p10437.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131216/bbd22ee2/attachment.html>

From amitava.biswas at gmail.com  Mon Dec 16 20:11:05 2013
From: amitava.biswas at gmail.com (amitava_rkv)
Date: Mon, 16 Dec 2013 17:11:05 -0800 (PST)
Subject: [concurrency-interest] Memory visibility semantics of jni
 cnative data when synchronized externally in java
In-Reply-To: <52AF3E81.5090904@oracle.com>
References: <1386704238803-10427.post@n7.nabble.com>
	<NFBBKALFDCPFIDBNKAPCOEBJKDAA.davidcholmes@aapt.net.au>
	<FDE94790-5E4E-44E7-A9F4-9CC4A61054C5@gmail.com>
	<NFBBKALFDCPFIDBNKAPCOEBLKDAA.davidcholmes@aapt.net.au>
	<1387033376525-10437.post@n7.nabble.com>
	<52AF3E81.5090904@oracle.com>
Message-ID: <1387242665894-10439.post@n7.nabble.com>

Thanks Nathan, i am interested in the former case. Could you explain why it
might see inconsistent ? is it because memory of memory mapped files might
be write combining memory type ?  Actually we have a 2 year old native linux
library which apparently hasnt been compiled with -pthread option and we see
that it is doing non-volatile write using memcpy to a memory mapped file .
is it possible it is doing wc write ? how do i verify that ? we are guess
the reader is seeing an inconsistent view 



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Memory-visibility-semantics-of-jni-c-native-data-when-synchronized-externally-in-java-tp10427p10439.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From aaron.grunthal at infinite-source.de  Tue Dec 17 08:43:27 2013
From: aaron.grunthal at infinite-source.de (Aaron Grunthal)
Date: Tue, 17 Dec 2013 14:43:27 +0100
Subject: [concurrency-interest] Memory visibility semantics of jni
 cnative data when synchronized externally in java
In-Reply-To: <52AF3E81.5090904@oracle.com>
References: <1386704238803-10427.post@n7.nabble.com>	<NFBBKALFDCPFIDBNKAPCOEBJKDAA.davidcholmes@aapt.net.au>	<FDE94790-5E4E-44E7-A9F4-9CC4A61054C5@gmail.com>	<NFBBKALFDCPFIDBNKAPCOEBLKDAA.davidcholmes@aapt.net.au>	<1387033376525-10437.post@n7.nabble.com>
	<52AF3E81.5090904@oracle.com>
Message-ID: <52B054FF.4050607@infinite-source.de>

On 16.12.2013 18:55, Nathan Reynolds wrote:
>
> However, if the readers are in another process, then they could see an
> inconsistent view of memory since they won't be going through the same
> lock instance.

Couldn't a combination of a) atomic operations on the mapped memory via 
Unsafe to spinlock and b) file range locks for blocking be used to 
provide the same ordering across processes?
At least on linux, I don't know what windows does with file locks and mmap.

- Aaron

From david.dice at gmail.com  Tue Dec 17 11:41:40 2013
From: david.dice at gmail.com (David Dice)
Date: Tue, 17 Dec 2013 11:41:40 -0500
Subject: [concurrency-interest] Memory visibility semantics of jni c
 native data when synchronized externally in java
Message-ID: <CANbRUcisQXoc+jeCCE3=5s3zfTTWVAxpYga2VYiDUnbWf9=tUw@mail.gmail.com>

Following up with some additional discussion regarding SSE/AVX x86
instructions ...

Lets start with a trivial case where code in some critical section zeroes a
shared global variable with MOVNTI (non-temporal store) and then release a
lock.  Lets further say we implement unlock() by a normal store into a
lock-word, possibly followed by a store-load barrier and a load to check
for the existence of any threads that might need to be woken up.  (This is
actually the pattern I used for HotSpot's JNI monitor exit path for x86 and
SPARC.   The "synchronized" unlock path for the inflated case also starts
with a store that releases the lock.   This idiom appears in plenty of
other lock implementations as well).     MOVNTI is weakly ordered with
respect to other normal TSO loads and stores.   Critically, if we have a
store via MOVNTI followed in program order by a normal store, that normal
store can appear in memory visibility order _before the MOVNTI store.
 Thus, it's possible that some other thread could see the lock has been
dropped and acquire it, all before the stores in the critical section by
way of MOVNTI are visible.  Obviously, that's undesirable and constitutes a
lock safety-exclusion violation.

Historically, unlock() implemented in this fashion --  by a store that
first clears the lock-word -- long predates the weakened SSE/AVX
instructions.   By convention, new code that used instructions such as
MOVNTI had to respect those preexisting locks by ensuring an SFENCE
appeared after the last MOVNTI and before the store in the unlock.   You
can see this in the evolution of x86  libc memset/bzero/memcpy operations,
where the implementations switched to using SSE/AVX instructions, followed
by some hasty patches to retrofit and insert trailing SFENCE instructions
after the reordering concern became more widely known.  (I've not looked
recently, but I don't think the "PS" processor-specific ABI documents give
much guidance on this topic.   Perhaps the new C++11 spec offers some
advice?).

The MOVNTI-then-unlock example above is just one example in a family of
issues.   In C++ you need to be concerned about architectural reordering vs
C++11 atomic<> and in Java you need to be wary of reordering over unsafe
operators or volatile accesses.   In Java I think you'd also want to make
sure there's an SFENCE between any weakly ordered accesses emitted by the
JIT and subsequent egress from managed code via JNI.

For pure Java code, the key invariant is that if the JIT emits weakly
ordered memory access instructions, then it needs to conservatively emit
trailing SFENCE instructions.   (It'd be good if the JIT folks could
confirm they adhere to this convention).   For native code, most of the
glibc/libc library functions now seen to have the trailing SFENCE.  And if
you emit code yourself, use your own assembly language code or inline asm,
then it's up to you to follow the conventions.

There are similar lines of argument regarding LFENCE, although weakly
ordered loads in a critical section are a somewhat easier case.   Ignoring
biased locking, all lock acquisition is via an atomic RMW instruction such
as LOCK:CMPXCHG or XCHG.  Those atomics have bidirectional fence semantics,
so weakly ordered loads in a critical section can't reorder above (before)
the acquisition of the lock.    Still, there are places where LFENCE would
likely be needed.  (Getting back to biased locking, acquiring a promiscuous
lock via biased locking requires revocation, and revocation has full fences
in the victim's path, so that's safe as well).

As an aside, the appearance of SFENCE or LFENCE in code that doesn't use
SSE/AVX is highly diagnostic of misunderstanding the x86 memory model.

I believe that with the right switches, gcc will transform normal C/C+ code
and in some cases, as an optimization, emit SSE/AVI instructions on its own
volition without provocation, and if so, do we happen to know if it will
also emit SFENCE/LFENCE to bracket the code in question?

Dave Dice
https://blogs.oracle.com/dave/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131217/0828cb78/attachment.html>

From nathan.reynolds at oracle.com  Tue Dec 17 16:03:15 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 17 Dec 2013 14:03:15 -0700
Subject: [concurrency-interest] Memory visibility semantics of jni
 cnative data when synchronized externally in java
In-Reply-To: <52B054FF.4050607@infinite-source.de>
References: <1386704238803-10427.post@n7.nabble.com>	<NFBBKALFDCPFIDBNKAPCOEBJKDAA.davidcholmes@aapt.net.au>	<FDE94790-5E4E-44E7-A9F4-9CC4A61054C5@gmail.com>	<NFBBKALFDCPFIDBNKAPCOEBLKDAA.davidcholmes@aapt.net.au>	<1387033376525-10437.post@n7.nabble.com>	<52AF3E81.5090904@oracle.com>
	<52B054FF.4050607@infinite-source.de>
Message-ID: <52B0BC13.8020504@oracle.com>

Either of those would work.  In fact, any locking scheme where all 
processes can acquire/release the same lock instance will work.  On 
Windows, you have the option of creating a named mutex and then having 
all processes use that mutex.  I am not sure if Linux and other OSes 
have such a mechanism.

-Nathan

On 12/17/2013 6:43 AM, Aaron Grunthal wrote:
> On 16.12.2013 18:55, Nathan Reynolds wrote:
>>
>> However, if the readers are in another process, then they could see an
>> inconsistent view of memory since they won't be going through the same
>> lock instance.
>
> Couldn't a combination of a) atomic operations on the mapped memory 
> via Unsafe to spinlock and b) file range locks for blocking be used to 
> provide the same ordering across processes?
> At least on linux, I don't know what windows does with file locks and 
> mmap.
>
> - Aaron
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131217/293970b5/attachment.html>

From nathan.reynolds at oracle.com  Tue Dec 17 16:10:36 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 17 Dec 2013 14:10:36 -0700
Subject: [concurrency-interest] Memory visibility semantics of jni
 cnative data when synchronized externally in java
In-Reply-To: <1387242665894-10439.post@n7.nabble.com>
References: <1386704238803-10427.post@n7.nabble.com>	<NFBBKALFDCPFIDBNKAPCOEBJKDAA.davidcholmes@aapt.net.au>	<FDE94790-5E4E-44E7-A9F4-9CC4A61054C5@gmail.com>	<NFBBKALFDCPFIDBNKAPCOEBLKDAA.davidcholmes@aapt.net.au>	<1387033376525-10437.post@n7.nabble.com>	<52AF3E81.5090904@oracle.com>
	<1387242665894-10439.post@n7.nabble.com>
Message-ID: <52B0BDCC.2030808@oracle.com>

 > Could you explain why it might see inconsistent ?

I think the easiest way is to say "happens-before".  You need to create 
happens-before relationships between the various processes.  Without 
that happens-before, the state can be seen as inconsistent.

 > is it because memory of memory mapped files might be write combining 
memory type?

As far as I am aware, memory mapped files look like regular blocks of 
memory.  The only difference is that the OS will copy the contents of 
the memory to/from disk.  The OS will do this because of paging, the 
memory mapping is closed, the process calls a method to flush the memory 
blocks, etc.

I haven't thought about this very much, but I don't think the type of 
memory matters.  I think what matters is that you setup a 
"happens-before" relationship.  That relationship will ensure the memory 
will be consistent.

-Nathan

On 12/16/2013 6:11 PM, amitava_rkv wrote:
> Thanks Nathan, i am interested in the former case. Could you explain why it
> might see inconsistent ? is it because memory of memory mapped files might
> be write combining memory type ?  Actually we have a 2 year old native linux
> library which apparently hasnt been compiled with -pthread option and we see
> that it is doing non-volatile write using memcpy to a memory mapped file .
> is it possible it is doing wc write ? how do i verify that ? we are guess
> the reader is seeing an inconsistent view
>
>
>
> --
> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Memory-visibility-semantics-of-jni-c-native-data-when-synchronized-externally-in-java-tp10427p10439.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131217/780d8ef5/attachment.html>

From davidcholmes at aapt.net.au  Tue Dec 17 19:57:08 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 18 Dec 2013 10:57:08 +1000
Subject: [concurrency-interest] Memory visibility semantics of jni c
	native data when synchronized externally in java
In-Reply-To: <CANbRUcisQXoc+jeCCE3=5s3zfTTWVAxpYga2VYiDUnbWf9=tUw@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOECNKDAA.davidcholmes@aapt.net.au>

Hi Dave,

Thanks for all the detailed info! FWIW grepping the hotspot codebase yields
no use of sfence (there is lfence but it is unused - may have previoously
been used for fast JNI accessors) but there is also no movnti that I can
see. The use of SSE seems very limited, not that I know much about it.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of David Dice
  Sent: Wednesday, 18 December 2013 2:42 AM
  To: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Memory visibility semantics of jni c
native data when synchronized externally in java




  Following up with some additional discussion regarding SSE/AVX x86
instructions ...


  Lets start with a trivial case where code in some critical section zeroes
a shared global variable with MOVNTI (non-temporal store) and then release a
lock.  Lets further say we implement unlock() by a normal store into a
lock-word, possibly followed by a store-load barrier and a load to check for
the existence of any threads that might need to be woken up.  (This is
actually the pattern I used for HotSpot's JNI monitor exit path for x86 and
SPARC.   The "synchronized" unlock path for the inflated case also starts
with a store that releases the lock.   This idiom appears in plenty of other
lock implementations as well).     MOVNTI is weakly ordered with respect to
other normal TSO loads and stores.   Critically, if we have a store via
MOVNTI followed in program order by a normal store, that normal store can
appear in memory visibility order _before the MOVNTI store.  Thus, it's
possible that some other thread could see the lock has been dropped and
acquire it, all before the stores in the critical section by way of MOVNTI
are visible.  Obviously, that's undesirable and constitutes a lock
safety-exclusion violation.


  Historically, unlock() implemented in this fashion --  by a store that
first clears the lock-word -- long predates the weakened SSE/AVX
instructions.   By convention, new code that used instructions such as
MOVNTI had to respect those preexisting locks by ensuring an SFENCE appeared
after the last MOVNTI and before the store in the unlock.   You can see this
in the evolution of x86  libc memset/bzero/memcpy operations, where the
implementations switched to using SSE/AVX instructions, followed by some
hasty patches to retrofit and insert trailing SFENCE instructions after the
reordering concern became more widely known.  (I've not looked recently, but
I don't think the "PS" processor-specific ABI documents give much guidance
on this topic.   Perhaps the new C++11 spec offers some advice?).


  The MOVNTI-then-unlock example above is just one example in a family of
issues.   In C++ you need to be concerned about architectural reordering vs
C++11 atomic<> and in Java you need to be wary of reordering over unsafe
operators or volatile accesses.   In Java I think you'd also want to make
sure there's an SFENCE between any weakly ordered accesses emitted by the
JIT and subsequent egress from managed code via JNI.


  For pure Java code, the key invariant is that if the JIT emits weakly
ordered memory access instructions, then it needs to conservatively emit
trailing SFENCE instructions.   (It'd be good if the JIT folks could confirm
they adhere to this convention).   For native code, most of the glibc/libc
library functions now seen to have the trailing SFENCE.  And if you emit
code yourself, use your own assembly language code or inline asm, then it's
up to you to follow the conventions.


  There are similar lines of argument regarding LFENCE, although weakly
ordered loads in a critical section are a somewhat easier case.   Ignoring
biased locking, all lock acquisition is via an atomic RMW instruction such
as LOCK:CMPXCHG or XCHG.  Those atomics have bidirectional fence semantics,
so weakly ordered loads in a critical section can't reorder above (before)
the acquisition of the lock.    Still, there are places where LFENCE would
likely be needed.  (Getting back to biased locking, acquiring a promiscuous
lock via biased locking requires revocation, and revocation has full fences
in the victim's path, so that's safe as well).


  As an aside, the appearance of SFENCE or LFENCE in code that doesn't use
SSE/AVX is highly diagnostic of misunderstanding the x86 memory model.


  I believe that with the right switches, gcc will transform normal C/C+
code and in some cases, as an optimization, emit SSE/AVI instructions on its
own volition without provocation, and if so, do we happen to know if it will
also emit SFENCE/LFENCE to bracket the code in question?



  Dave Dice
  https://blogs.oracle.com/dave/




-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131218/5db1ded7/attachment.html>

From hans.boehm at hp.com  Wed Dec 18 02:12:41 2013
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 18 Dec 2013 07:12:41 +0000
Subject: [concurrency-interest] Memory visibility semantics of jni
 cnative data when synchronized externally in java
In-Reply-To: <1387242665894-10439.post@n7.nabble.com>
References: <1386704238803-10427.post@n7.nabble.com>
	<NFBBKALFDCPFIDBNKAPCOEBJKDAA.davidcholmes@aapt.net.au>
	<FDE94790-5E4E-44E7-A9F4-9CC4A61054C5@gmail.com>
	<NFBBKALFDCPFIDBNKAPCOEBLKDAA.davidcholmes@aapt.net.au>
	<1387033376525-10437.post@n7.nabble.com>	<52AF3E81.5090904@oracle.com>
	<1387242665894-10439.post@n7.nabble.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD23D52DD8A@G4W3214.americas.hpqcorp.net>

The question seems to be whether the memcpy implementation uses the MOVNTx instructions without a subsequent SFENCE, MFENCE, or the like.  I would disassemble it in a debugger.  I don't know of a way to use a WC mapping in a Linux executable.  MOVNTx seems to be as close as you can get.

Hans

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of amitava_rkv
> Sent: Monday, December 16, 2013 5:11 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Memory visibility semantics of jni cnative
> data when synchronized externally in java
> 
> Thanks Nathan, i am interested in the former case. Could you explain why it
> might see inconsistent ? is it because memory of memory mapped files might
> be write combining memory type ?  Actually we have a 2 year old native linux
> library which apparently hasnt been compiled with -pthread option and we
> see that it is doing non-volatile write using memcpy to a memory mapped file
> .
> is it possible it is doing wc write ? how do i verify that ? we are guess the
> reader is seeing an inconsistent view
> 
> 
> 
> --
> View this message in context: http://jsr166-
> concurrency.10961.n7.nabble.com/Memory-visibility-semantics-of-jni-c-
> native-data-when-synchronized-externally-in-java-tp10427p10439.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From hans.boehm at hp.com  Wed Dec 18 02:13:22 2013
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 18 Dec 2013 07:13:22 +0000
Subject: [concurrency-interest] Memory visibility semantics of jni
	c	native data when synchronized externally in java
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOECNKDAA.davidcholmes@aapt.net.au>
References: <CANbRUcisQXoc+jeCCE3=5s3zfTTWVAxpYga2VYiDUnbWf9=tUw@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCOECNKDAA.davidcholmes@aapt.net.au>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD23D52DD9D@G4W3214.americas.hpqcorp.net>

This is all consistent with my understanding.

I hadn't thought about the load/MOVNTDQA issue.  Based on just the Intel spec, I can't determine what fences are required, and whether it can also be reordered with a trailing store, or just a preceding load.  If someone can quote a manual that clarifies this, it would be appreciated.  As far as I'm concerned, for now,  if you want to actually use the instruction, you get to figure out what it does and add suitable fences.

I believe that the convention in which code containing MOVNTx adds the fences, as opposed to having synchronization primitives add fences, is the only reasonable one.  Otherwise volatile/atomic<T> accesses would have to add additional fences for both loads and stores, and uncontended locking would slow down appreciably.  But, like Dave, I haven't found this stated anywhere.

Hans

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David Holmes
Sent: Tuesday, December 17, 2013 4:57 PM
To: David Dice; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Memory visibility semantics of jni c native data when synchronized externally in java

Hi Dave,

Thanks for all the detailed info! FWIW grepping the hotspot codebase yields no use of sfence (there is lfence but it is unused - may have previoously been used for fast JNI accessors) but there is also no movnti that I can see. The use of SSE seems very limited, not that I know much about it.

David
-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of David Dice
Sent: Wednesday, 18 December 2013 2:42 AM
To: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Memory visibility semantics of jni c native data when synchronized externally in java

Following up with some additional discussion regarding SSE/AVX x86 instructions ...

Lets start with a trivial case where code in some critical section zeroes a shared global variable with MOVNTI (non-temporal store) and then release a lock.  Lets further say we implement unlock() by a normal store into a lock-word, possibly followed by a store-load barrier and a load to check for the existence of any threads that might need to be woken up.  (This is actually the pattern I used for HotSpot's JNI monitor exit path for x86 and SPARC.   The "synchronized" unlock path for the inflated case also starts with a store that releases the lock.   This idiom appears in plenty of other lock implementations as well).     MOVNTI is weakly ordered with respect to other normal TSO loads and stores.   Critically, if we have a store via MOVNTI followed in program order by a normal store, that normal store can appear in memory visibility order _before the MOVNTI store.  Thus, it's possible that some other thread could see the lock has been dropped and acquire it, all before the stores in the critical section by way of MOVNTI are visible.  Obviously, that's undesirable and constitutes a lock safety-exclusion violation.

Historically, unlock() implemented in this fashion --  by a store that first clears the lock-word -- long predates the weakened SSE/AVX instructions.   By convention, new code that used instructions such as MOVNTI had to respect those preexisting locks by ensuring an SFENCE appeared after the last MOVNTI and before the store in the unlock.   You can see this in the evolution of x86  libc memset/bzero/memcpy operations, where the implementations switched to using SSE/AVX instructions, followed by some hasty patches to retrofit and insert trailing SFENCE instructions after the reordering concern became more widely known.  (I've not looked recently, but I don't think the "PS" processor-specific ABI documents give much guidance on this topic.   Perhaps the new C++11 spec offers some advice?).

The MOVNTI-then-unlock example above is just one example in a family of issues.   In C++ you need to be concerned about architectural reordering vs C++11 atomic<> and in Java you need to be wary of reordering over unsafe operators or volatile accesses.   In Java I think you'd also want to make sure there's an SFENCE between any weakly ordered accesses emitted by the JIT and subsequent egress from managed code via JNI.

For pure Java code, the key invariant is that if the JIT emits weakly ordered memory access instructions, then it needs to conservatively emit trailing SFENCE instructions.   (It'd be good if the JIT folks could confirm they adhere to this convention).   For native code, most of the glibc/libc library functions now seen to have the trailing SFENCE.  And if you emit code yourself, use your own assembly language code or inline asm, then it's up to you to follow the conventions.

There are similar lines of argument regarding LFENCE, although weakly ordered loads in a critical section are a somewhat easier case.   Ignoring biased locking, all lock acquisition is via an atomic RMW instruction such as LOCK:CMPXCHG or XCHG.  Those atomics have bidirectional fence semantics, so weakly ordered loads in a critical section can't reorder above (before) the acquisition of the lock.    Still, there are places where LFENCE would likely be needed.  (Getting back to biased locking, acquiring a promiscuous lock via biased locking requires revocation, and revocation has full fences in the victim's path, so that's safe as well).

As an aside, the appearance of SFENCE or LFENCE in code that doesn't use SSE/AVX is highly diagnostic of misunderstanding the x86 memory model.

I believe that with the right switches, gcc will transform normal C/C+ code and in some cases, as an optimization, emit SSE/AVI instructions on its own volition without provocation, and if so, do we happen to know if it will also emit SFENCE/LFENCE to bracket the code in question?

Dave Dice
https://blogs.oracle.com/dave/


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131218/376c81c2/attachment.html>

From dl at cs.oswego.edu  Thu Dec 19 07:04:08 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 19 Dec 2013 07:04:08 -0500
Subject: [concurrency-interest] New default for ForkJoinPool.commonPool on
	systems with SecurityManagers
Message-ID: <52B2E0B8.3040708@cs.oswego.edu>

[Cross-posting on core-libs-dev and concurrency-interest.]

The ForkJoinPool common pool is used in JDK8 for
all parallel Stream operations, parallel sorting, etc.
When designing this, we knew that in some managed environments,
administrators might want to limit or disable parallelism,
so we support a way to do so using system property
java.util.concurrent.ForkJoinPool.common.parallelism.

But we hadn't provided a way to allow only "innocuous" parallelism;
performed by worker threads that are happy to help sort
data etc, but cannot do anything (like open a file) that
needs a Permission. We allowed people to create a special
ForkJoinWorkerThreadFactory and use for the default via property
java.util.concurrent.ForkJoinPool.common.threadFactory.
But it is not at all easy for people running Java EE and other
managed platforms to define a suitable factory.

So we added an extra-conservative safe-out-of-the-box default:
If not already overridden by system properties,
and a SecurityManager is present, the default is now
to use instances of an internal (non-public)
InnocuousForkJoinWorkerThread class. Each worker
has no Permssions set, is not a member of any user-defined
ThreadGroup, and erases all ThreadLocals after running
any externally-submitted task.

Thanks especially to Chris Hegarty and Alan Bateman for helping
to figure out what "innocuous" should entail.

Even though it is running very late in the release process,
this seems like such a good idea that we hope to get it
in for JDK8. The internal mechanics to  support this currently
require  quite a lot of encapsulation breakage.
Someday we might want to try to generalize the idea of
innocuous threads in a way that could be more tastefully supported.

This is currently committed in 166 CVS, and Chris Hegarty will
soon put out a webrev for OpenJDK.

This support was also added to the jsr166e version so people can
also experiment with it even if not yet able to use JDK8.
Although I believe that this will only work if jsr166e.jar
is in bootclasspath.

Also note that extra-paranoid and/or mean-spirited
administrators can still disable all parallelism.

-Doug



From howard.lovatt at gmail.com  Sun Dec 22 23:12:15 2013
From: howard.lovatt at gmail.com (Howard Lovatt)
Date: Mon, 23 Dec 2013 15:12:15 +1100
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <52B15962.5080206@javaspecialists.eu>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
	<529DEB55.7080203@javaspecialists.eu>
	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
	<529E066D.9020008@oracle.com>
	<CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>
	<529E1DC5.2080605@javaspecialists.eu>
	<CACR_FB5vC70Utw_prWKMrmuOkZJN+369EaAaREDD6_Lt4=16rA@mail.gmail.com>
	<52A08B57.4000408@javaspecialists.eu>
	<A690EDD8-1BCA-4AEF-A7C6-B8182C698A87@gmail.com>
	<52A0DEE4.7020509@javaspecialists.eu>
	<68AA05B1-48E4-4AE1-AA22-A19D8BC039DE@gmail.com>
	<52A0F225.1090109@javaspecialists.eu>
	<CACR_FB7zBzSpAhsSTshumR6EEp91+tnyurCaZmwep2FB0Q+=CQ@mail.gmail.com>
	<52B15962.5080206@javaspecialists.eu>
Message-ID: <CACR_FB6nUTHAvnP-bXcf+yCS1hbf+EgWPt8fCukOML-iwMBKXw@mail.gmail.com>

Hi Heinz,

Thanks for the critique of the code; agree with all your points. I have
updated the code to include your points, added some more implementations,
and for a bit of fun 'streamified' the code (see below). The results I get
are:

ImmutablePoint took LongSummaryStatistics{count=5, sum=267, min=44,
average=53.400000, max=86} ms, magnitude = 1000000.0
ModCountPoint took LongSummaryStatistics{count=5, sum=6658, min=1292,
average=1331.600000, max=1381} ms, magnitude = 7071067.811865475
SynchronizedPoint took LongSummaryStatistics{count=5, sum=9282, min=1824,
average=1856.400000, max=1905} ms, magnitude = 7071067.811865475
DoubleCheckedPoint took LongSummaryStatistics{count=5, sum=9545, min=1831,
average=1909.000000, max=1996} ms, magnitude = 7071067.811865475
StampedPoint took LongSummaryStatistics{count=5, sum=3328, min=656,
average=665.600000, max=680} ms, magnitude = 7071067.811865475
CopyOnWritePoint took LongSummaryStatistics{count=5, sum=3463, min=681,
average=692.600000, max=702} ms, magnitude = 7071067.811865475

Running on a 4 core MacBook Pro with hyperthreading under OSX with Java:

java version "1.8.0-ea"
Java(TM) SE Runtime Environment (build 1.8.0-ea-b106)
Java HotSpot(TM) 64-Bit Server VM (build 25.0-b48, mixed mode)

The test uses two threads, one that moves the point in the X direction and
the other in Y, that each write then read, to check the move was correct,
with contention possible on all the reads and writes. Using the average
times Immutable is the best implementation then some way behind Stamped and
just behind this CopyOnWrite. Therefore I tentatively conclude that for
small data structures use Immutable if you can and if not either Stamped or
CopyOnWrite (CopyOnWrite is easier to write than Stamped). I 'tentatively'
conclude because I have found benchmarking concurrent stuff tricky!

Comments/Suggestions?

Seasons greetings,

 -- Howard.

PS Note Immutable gives a different final magnitude because it returns a
new point for each move wheres as all the other implementations return
themselves and therefore the final magnitude for these is the result of all
the X and Y moves (number of individual moves * 1/Sqrt(2)). For Immutable
the result is from just either the X or the Y moves (depending on random
which one completes first) and is therefore the number of individual moves.

=================================================================================

package threadsafepoint;

import java.util.ArrayList;
import java.util.List;
import java.util.LongSummaryStatistics;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.StampedLock;
import java.util.function.DoubleSupplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import java.util.function.Function;
import java.util.stream.DoubleStream;

/**
 * Comparison of thread safety techniques (example from
www.javaspecialists.eu/archive/Issue215.html).
 *
 * @author Howard Lovatt
 * @version 2 Incorporated Heinz's comments (18/12/13), 'streamified',
extra implementations
 */
public class ThreadSafePoint {

  interface Point {
    double distanceFromOrigin();
    Point move(int deltaX, int deltaY);
  }

  static class ImmutablePoint implements Point {
    public final int x;
    public final int y;
    public ImmutablePoint() {
      this(0, 0);
    }
    public ImmutablePoint(final int x, final int y) {
      this.x = x;
      this.y = y;
    }
    @Override public double distanceFromOrigin() {
      return Math.hypot(x, y);
    }
    @Override public Point move(final int deltaX, final int deltaY) {
      return new ImmutablePoint(x + deltaX, y + deltaY);
    }
  }

  static class CopyOnWritePoint implements Point {
    private volatile ImmutablePoint current = new ImmutablePoint(0, 0);
    @Override public double distanceFromOrigin() {
      return current.distanceFromOrigin();
    }
    @Override public synchronized Point move(final int deltaX, final int
deltaY) {
      current = new ImmutablePoint(current.x + deltaX, current.y + deltaY);
      return this;
    }
  }

  static class StampedPoint implements Point { // Effectively Heinz's code
    private static final int retries = 3;
    private int x = 0;
    private int y = 0;
    private final StampedLock lock = new StampedLock();
    @Override public double distanceFromOrigin() {
      int localX;
      int localY;
      out:
      {
        // try a few times to do an optimistic read
        for (int i = 0; i < retries; i++) {
          final long stamp = lock.tryOptimisticRead();
          localX = x;
          localY = y;
          if (lock.validate(stamp)) {
            break out;
          }
        }
        // pessimistic read
        final long stamp = lock.readLock();
        try {
          localX = x;
          localY = y;
        } finally {
          lock.unlockRead(stamp);
        }
      }
      return Math.hypot(localX, localY);
    }
    @Override public Point move(final int deltaX, final int deltaY) {
      final long stamp = lock.writeLock();
      try {
        x += deltaX;
        y += deltaY;
      } finally {
        lock.unlockWrite(stamp);
      }
      return this;
    }
  }

  static class SynchronizedPoint implements Point {
    private int x = 0;
    private int y = 0;
    @Override public synchronized double distanceFromOrigin() {
      return Math.hypot(x, y);
    }
    @Override public synchronized Point move(final int deltaX, final int
deltaY) {
      x += deltaX;
      y += deltaY;
      return this;
    }
  }

  static class DoubleCheckedPoint extends SynchronizedPoint {
    private static final int retries = 1_000_000;
    private volatile boolean locked = false;
    public synchronized double maybeDistanceFromOrigin() {
      if (locked) { // 2nd check
        return -1;
      }
      locked = true;
      final double distance = super.distanceFromOrigin();
      locked = false;
      return distance;
    }
    @Override public double distanceFromOrigin() {
      for (int i = 0; i < retries; i++) {
        if (!locked) { // 1st check
          final double distance = maybeDistanceFromOrigin();
          if (distance >= 0) {
            return distance;
          }
        }
      }
      return super.distanceFromOrigin();
    }
    public synchronized boolean maybeMove(final int deltaX, final int
deltaY) {
      if (locked) { // 2nd check
        return false;
      }
      locked = true;
      super.move(deltaX, deltaY);
      locked = false;
      return true;
    }
    @Override public Point move(final int deltaX, final int deltaY) {
      for (int i = 0; i < retries; i++) {
        if (!locked) { // 1st check
          if (maybeMove(deltaX, deltaY)) {
            return this;
          }
        }
      }
      super.move(deltaX, deltaY);
      return this;
    }
  }

  static class ModCountPoint implements Point { // Very similer in design
to StampedPoint!
    private static final int retries = 10;
    private final AtomicInteger modCount = new AtomicInteger();
    private int x = 0;
    private int y = 0;
    @Override public double distanceFromOrigin() {
      for (int i = 0; i < retries; i++) {
        final int startCount = modCount.get();
        final double distance = Math.hypot(x, y);
        if (startCount == modCount.get()) {
          return distance;
        }
      }
      synchronized (this) {
        return Math.hypot(x, y);
      }
    }
    @Override public synchronized Point move(final int deltaX, final int
deltaY) {
      modCount.incrementAndGet();
      x += deltaX;
      y += deltaY;
      return this;
    }
  }

  private static final int times = 1_000_000;

  private static void checkMagnitude(final Point point, final double...
oldHolder) {
    final double old = oldHolder[0];
    if (old < 0) {
      return; // already failed
    }
    final double current = point.distanceFromOrigin();
    oldHolder[0] = current > old ? current : -1; // test for failure
  }

  private static double testMove(final Point point, final int deltaX, final
int deltaY) {
    final double[] old = {0}; // Need to use a side-effect because you can
only view one item at a time in a stream
    final Point[] current = {point};
    IntStream.range(0, times).forEach((notUsed) -> {
      current[0] = current[0].move(deltaX, deltaY);
      checkMagnitude(current[0], old);
    });
    return old[0];
  }

  private static class TimeAndTest {
    final boolean failed;
    final long time;
    final double magnitude;
    TimeAndTest(final long time, final double... magnitudes) {
      failed = DoubleStream.of(magnitudes)
              .anyMatch((magnitude) -> magnitude < 0);
      this.time = time;
      magnitude = DoubleStream.of(magnitudes)
              .max()
              .orElse(-1);
    }
  }

  private static TimeAndTest timeAndTest(final Point point) {
    System.gc();
    System.gc();
    final long start = System.currentTimeMillis();
    final double[] magnitudes = Stream.<DoubleSupplier>of(() ->
testMove(point, 1, 0), () -> testMove(point, 0, 1))
            .parallel()
            .mapToDouble((magnitudeSupplier) ->
magnitudeSupplier.getAsDouble())
            .toArray(); // Need an array because of multiple traversals
    return new TimeAndTest(System.currentTimeMillis() - start, magnitudes);
  }

  private static void conditionallyAdd(final Point point, final
List<TimeAndTest> timeAndTests) {
    final TimeAndTest timeAndTest = timeAndTest(point);
    if (!timeAndTest.failed) {
      timeAndTests.add(timeAndTest);
    }
  }

  private static void printResults(final Point point, final
List<TimeAndTest> timeAndTests) {
    final String name = point.getClass().getSimpleName();
    final LongSummaryStatistics timeStats = timeAndTests.stream()
            .collect(Collectors.summarizingLong((timeAndTest) ->
timeAndTest.time));
    final double magnitude = timeAndTests.stream()
            .mapToDouble((timeAndTest) -> timeAndTest.magnitude)
            .max()
            .orElse(-1);
    System.out.println(name + " took " + timeStats + " ms, magnitude = " +
magnitude);
  }

  private static void compare(final int repeats, final Point... points) {
    final Map<Point, List<TimeAndTest>> results = Stream.of(points) // Use
List instead of Stream.Builder because want multiple traversals
            .collect(Collectors.toMap(Function.identity(), (notUsed) -> new
ArrayList<TimeAndTest>()));
    IntStream.range(0, repeats)
            .forEach((notUsed) ->
results.forEach(ThreadSafePoint::conditionallyAdd));
    results.forEach(ThreadSafePoint::printResults);
  }

  public static void main(final String... notUsed) {
    compare(5,
            new ImmutablePoint(),
            new CopyOnWritePoint(),
            new StampedPoint(),
            new SynchronizedPoint(),
            new DoubleCheckedPoint(),
            new ModCountPoint());
  }

}


On 18 December 2013 19:14, Dr Heinz M. Kabutz <heinz at javaspecialists.eu>wrote:

>  Hi Howard,
>
> may I ask what hardware you are running this on?  I ran my tests on an
> 8-core machine (no hyperthreading).  It looks like there will be three
> active threads in your experiment.  Two calling "move" and the third
> waiting for the other two to finish.  I would probably use something like
> the CountDownLatch or the Phaser to wait until the other two is done.
>
> You need to repeat the experiment a few times in order to make sure that
> the results are reliable.  I would recommend doing every experiment 30
> times in a row.
>
> Now, having a look at your results, I would like to make a prediction,
> which I will test after I send you this email.  I think that escape
> analysis is eliminating the ImmutablePoint result.  Since it never escapes
> from the caller methods, the entire call to move() can be eliminated.  This
> would explain why it is so much faster.  One way to test this is to run the
> test with -XX:-DoEscapeAnalysis.
>
> Also, remember that the ImmutablePoint would have to be stored somewhere.
> The field would probably have to be volatile or an AtomicReference.  This
> is also not seen in the test.
>
> The StampedLock does not perform particularly well with writing.  It
> usually beats the ReentrantReadWriteLock, but not by much.  Where it shines
> is in the optimistic read "lock", which you are not testing here.  The
> ImmutablePoint in your experiment would beat the socks off the StampedLock,
> because it could simply return the values without any memory barriers.
>
> Regards
>
> Heinz
> --
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Oracle Java Champion 2005-2013
> JavaOne Rock Star Speaker 2012http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
>
>
> Howard Lovatt wrote:
>
> Finally got round to testing the stamped locked myself, code below.
> Results are:
>
>  ImmutablePoint took 73 ms, magnitude = 0.0, correct = true
> SynchronizedPoint took 1316 ms, magnitude = 1.414213562373095E7, correct =
> true
> StampedPoint took 2020 ms, magnitude = 1.414213562373095E7, correct = true
>
>  As I have said previously I am unsure if my testing so these results
> might be rubbish! Assuming the results are OK then unless you really need
> two threads sharing a value then using the immutable form is much better.
> Of the two lock schemes using synchronized is somewhat quicker.
>
>  Code is:
>
>  package threadsafepoint;
>
>  import java.util.concurrent.ExecutionException;
> import java.util.concurrent.ExecutorService;
> import java.util.concurrent.Executors;
> import java.util.concurrent.Future;
> import java.util.concurrent.TimeUnit;
> import java.util.concurrent.atomic.AtomicLong;
> import java.util.concurrent.locks.StampedLock;
>
>  /**
>  * Comparison of thread safety techniques (example from
> www.javaspecialists.eu/archive/Issue215.html).
>  *
>  * @author Howard Lovatt
>  */
> public class ThreadSafePoint {
>
>   interface Point {
>     double magnitude();
>     Point move(int deltaX, int deltaY);
>   }
>
>   static class ImmutablePoint implements Point {
>     public final int x;
>     public final int y;
>     public ImmutablePoint() {
>       this(0, 0);
>     }
>     public ImmutablePoint(final int x, final int y) {
>       this.x = x;
>       this.y = y;
>     }
>     @Override public double magnitude() {
>       return Math.hypot(x, y);
>     }
>     @Override public Point move(final int deltaX, final int deltaY) {
>       return new ImmutablePoint(x + deltaX, y + deltaY);
>     }
>   }
>
>   static class SynchronizedPoint implements Point {
>     private volatile ImmutablePoint current;
>     public SynchronizedPoint() {
>       current = new ImmutablePoint(0, 0);
>     }
>     @Override public double magnitude() {
>       return current.magnitude();
>     }
>     @Override public synchronized Point move(final int deltaX, final int
> deltaY) {
>       current = new ImmutablePoint(current.x + deltaX, current.y + deltaY);
>       return current;
>     }
>   }
>
>   static final int retries = 3;
>
>   static class StampedPoint implements Point {
>     private int x = 0;
>     private int y = 0;
>     private final StampedLock lock = new StampedLock();
>     @Override public double magnitude() {
>       int localX;
>       int localY;
>       out:
>       {
>         // try a few times to do an optimistic read
>         for (int i = 0; i < retries; i++) {
>           final long stamp = lock.tryOptimisticRead();
>           localX = x;
>           localY = y;
>           if (lock.validate(stamp)) {
>             break out;
>           }
>         }
>         // pessimistic read
>         final long stamp = lock.readLock();
>         try {
>           localX = x;
>           localY = y;
>         } finally {
>           lock.unlockRead(stamp);
>         }
>       }
>       return Math.hypot(localX, localY);
>     }
>     @Override public Point move(final int deltaX, final int deltaY) {
>       final long stamp = lock.writeLock();
>       try {
>         x += deltaX;
>         y += deltaY;
>       } finally {
>         lock.unlockWrite(stamp);
>       }
>       return this;
>     }
>   }
>
>   private static final int times = 10_000_000;
>
>   private static final AtomicLong poison = new AtomicLong();
>
>   private static void time(final Point implementation) throws
> InterruptedException, ExecutionException {
>     final ExecutorService pool = Executors.newCachedThreadPool();
>     final long start = System.currentTimeMillis();
>     final Future<Boolean> correct = pool.submit(() -> {
>       double oldMagnitude = 0;
>       while (poison.get() < 2) {
>         final double currentMagnitude = implementation.magnitude();
>         if (oldMagnitude > currentMagnitude) {
>           return false;
>         }
>         oldMagnitude = currentMagnitude;
>       }
>       return true;
>     });
>     pool.submit(() -> {
>       for (int i = 0; i < times; i++) {
>         implementation.move(1, 0);
>       }
>       poison.incrementAndGet();
>     });
>     pool.submit(() -> {
>       for (int i = 0; i < times; i++) {
>         implementation.move(0, 1);
>       }
>       poison.incrementAndGet();
>     });
>     pool.shutdown();
>     final boolean ok = pool.awaitTermination(10, TimeUnit.SECONDS);
>     final long finish = System.currentTimeMillis();
>     System.out.print(implementation.getClass().getSimpleName() + " ");
>     if (!ok) {
>       System.out.println("did not terminate");
>       pool.shutdownNow();
>       return;
>     }
>     System.out.println("took " + (finish - start) + " ms, magnitude = " +
> implementation.magnitude() + ", correct = " + correct.get());
>   }
>
>   public static void main(final String... notUsed) throws
> InterruptedException, ExecutionException {
>     time(new ImmutablePoint());
>     time(new SynchronizedPoint());
>     time(new StampedPoint());
>   }
>
> }
>
>
> On 6 December 2013 08:37, Dr Heinz M. Kabutz <heinz at javaspecialists.eu>wrote:
>
>>  Hi Howard,
>>
>> I will keep you in the loop when I do the experiments.  I did some nice
>> performance tests towards the end of last year when StampedLock was first
>> released.  Getting good results is really hard and it takes a lot of
>> analysis afterwards to make sure that things are what you expect.  An extra
>> set of eyes would be immensely useful.
>>
>> Regards
>>
>> Heinz
>> --
>> Dr Heinz M. Kabutz (PhD CompSci)
>> Author of "The Java(tm) Specialists' Newsletter"
>> Oracle Java Champion 2005-2013
>> JavaOne Rock Star Speaker 2012http://www.javaspecialists.eu
>> Tel: +30 69 75 595 262
>> Skype: kabutz
>>
>>
>>
>>
>> Howard Lovatt wrote:
>>
>> Hi Heinz,
>>
>>  Interested to see your results and also see how you do the benchmarking
>> since as I said I some difficulty with getting good results.
>>
>>  Cheers,
>>
>>   -- Howard.
>>
>> Sent from my iPad
>>
>> On 6 Dec 2013, at 7:15 am, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
>> wrote:
>>
>>   Yes, sorry for my typo.  Tim Peierls pointed it out privately, but I
>> thought it insufficiently important to send an update :-)  I'm sure most
>> readers got the idea.
>>
>> When I run my performance tests, I will include your version into the
>> mix.  From my very basic initial tests a few months ago, it did seem that
>> synchronizing that particular method actually outperformed the other
>> approaches.  But I need to verify my test and do a bit more work there.
>> Maybe during the Christmas break I'll get a chance to do that.
>>
>> Regards
>>
>> Heinz
>> --
>> Dr Heinz M. Kabutz (PhD CompSci)
>> Author of "The Java(tm) Specialists' Newsletter"
>> Oracle Java Champion 2005-2013
>> JavaOne Rock Star Speaker 2012http://www.javaspecialists.eu
>> Tel: +30 69 75 595 262
>> Skype: kabutz
>>
>>
>>
>>
>> Howard Lovatt wrote:
>>
>> Hi Heinz,
>>
>>  Yes I would write distanceFromOrigin like you did; though you have a
>> typo, it is current.x and .y not position. The key part of this method is
>> that you have to read position into a local like you did because you can
>> only read position once in a read-only method.
>>
>>  For moveIfAt, I would just make the method synchronized and leave
>> position as a volatile:
>>
>> public synchronized boolean moveIfAt(int oldX, int oldY, int newX, int
>> newY) {
>>
>>             if (position.x == oldX && position.y == oldY) {
>>                  position = new Coordinate(newX, newY);
>>                  return true;
>>             }
>>             return false;
>>   }
>>
>>
>>  I haven't found the Atomic classes to perform as well as using volatile
>> and synchronized and the programming is not as clear. Though I have also
>> found benchmarking concurrent code very hard and I am therefore not
>> confident of my timing results :(
>>
>>  Looking forward to the next two instalments - really interesting
>> article.
>>
>>  Cheers,
>>
>>   -- Howard.
>>
>> Sent from my iPad
>>
>> On 6 Dec 2013, at 1:19 am, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
>> wrote:
>>
>>   Hi Howard,
>>
>> yes, you could do that.  So the distanceFromOrigin() would look something
>> like this:
>>
>>   public double distanceFromOrigin() {
>>     Coordinate current = position;
>>     return Math.hypot(position.x, position.y);
>>   }
>>
>> And then moveIfAt() would need a CAS, thus you might want to use an
>> AtomicReference instead or an AtomicReferenceFieldUpdater (or Unsafe of
>> course ;-))
>>
>>   public boolean moveIfAt(int oldX, int oldY,
>>                                        int newX, int newY) {
>>
>>       while(true) {
>>             Coordinate current = position;
>>             Coordinate next;
>>             if (current.x == oldX && current.y == oldY) {
>>                  next = new Coordinate(newX, newY);
>>                  if (positionSetter.compareAndSet(current, next)) return
>> true;
>>             } else {
>>                  return false;
>>             }
>>        }
>>   }
>>
>> That will be one of the topics of the second part of my StampedLock
>> series.  The third will be comparing the various approaches in terms of
>> performance.
>>
>> Regards
>>
>> Heinz
>> --
>> Dr Heinz M. Kabutz (PhD CompSci)
>> Author of "The Java(tm) Specialists' Newsletter"
>> Oracle Java Champion 2005-2013
>> JavaOne Rock Star Speaker 2012http://www.javaspecialists.eu
>> Tel: +30 69 75 595 262
>> Skype: kabutz
>>
>>
>>
>>
>> Howard Lovatt wrote:
>>
>> Hi Heinz,
>>
>>  For your Point example I use something like:
>>
>>  class Coordinate {
>>
>>   final long x, y;
>>
>>   Coordinate(long x, long y) {
>>
>>     this.x = x;
>>
>>     this.y = y;
>>
>>   }
>>
>> }
>>
>>
>>  class Point {
>>
>>   volatile Coordinate position;
>>
>>   Point(long x, long y) {
>>
>>     position = new Coordinate(x, y);
>>
>>   }
>>
>>   synchronized void move(long x, long y) {
>>
>>     position = new Coordinate(position.x + x, position.y + y);
>>
>>   }
>>
>>   Coordinate get() {
>>
>>     return position;
>>
>>   }
>>
>> }
>>
>>
>>  It is a bit of a combination of a couple of techniques that you
>> mentioned, it is easy to program, and in my testing works well. Of cause it
>> is only good if there are more reads than writes.
>>
>> Cheers,
>>
>>
>>   -- Howard.
>>
>>
>> On 4 December 2013 05:07, Dr Heinz M. Kabutz <heinz at javaspecialists.eu>wrote:
>>
>>> Yeah, "should", but also not always.  As the number of retries
>>> increases, it can happen that the ReentrantLock beats CAS.  And then on
>>> some hardware, CAS can also be quite expensive.
>>>
>>> Regards
>>>
>>> Heinz
>>> --
>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> Author of "The Java(tm) Specialists' Newsletter"
>>> Oracle Java Champion 2005-2013
>>> JavaOne Rock Star Speaker 2012http://www.javaspecialists.eu
>>> Tel: +30 69 75 595 262
>>> Skype: kabutz
>>>
>>>
>>>
>>>
>>>  Vitaly Davidovich wrote:
>>>
>>>  Well, CAS guarantees somebody makes some progress.  On a very loaded
>>> system, this is good (obviously) since otherwise a thread holding a lengthy
>>> lock section can get context switched out or have high latency due to,
>>> e.g., cache miss, and then nobody makes progress.  So yeah, on highly
>>> concurrent hardware, CAS should be a net win for throughput over locks.
>>>
>>> Sent from my phone
>>> On Dec 3, 2013 11:31 AM, "Nathan Reynolds" <nathan.reynolds at oracle.com>
>>> wrote:
>>>
>>>>  In one C++ case, we have a read-write lock in which writes are very
>>>> rare.  Having multiple threads execute CAS to update the number of readers
>>>> holding the lock has been a source of contention.  A stamped lock would be
>>>> great except that writes must have exclusivity otherwise the readers will
>>>> throw weird exceptions due to examining inconsistent state.
>>>>
>>>> In another Java case, I tried to make the code lock-free by using a
>>>> concurrent data structure and CAS loops.  Unfortunately, the code path is
>>>> so much longer that it takes more time to execute than to have a shorter
>>>> code path and wait on a lock.  The lock contention isn't high enough to
>>>> warrant the change.  I am waiting for more concurrent server processors to
>>>> finally tip the balance and justify the change.
>>>>
>>>> -Nathan
>>>>
>>>> On 12/3/2013 7:58 AM, Vitaly Davidovich wrote:
>>>>
>>>> So lock free may become a problem for extremely contended blocks - lock
>>>> free, assuming it's the basic CAS loop impl, may cause delays in such cases
>>>> as losing threads will continue spinning, tying up cpu resources and
>>>> generating coherence traffic.  In this case, using a lock can be a net win.
>>>>
>>>> Also, perhaps the lock free implementation generates lots of garbage,
>>>> placing load on the GC.  Otherwise, lock free should be a net win majority
>>>> of the time.
>>>>
>>>> A proper Spinlock may be a good addition to the j.u.c toolbox as well.
>>>>
>>>> Sent from my phone
>>>> On Dec 3, 2013 9:36 AM, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
>>>> wrote:
>>>>
>>>>> Doug Lea wrote:
>>>>>
>>>>>> On 12/02/2013 09:31 PM, Vitaly Davidovich wrote:
>>>>>>
>>>>>>> Right, it's a bit unclear on what a good case for this lock is.  I'm
>>>>>>> guessing
>>>>>>> the advantage is if you use the optimistic version - that avoids any
>>>>>>> expensive
>>>>>>> stores and doesn't block writers - for tiny read code sections on
>>>>>>> locks that are
>>>>>>> read-mostly.  Otherwise, seems like it may not perform all that well
>>>>>>> (e.g.
>>>>>>> validate() missing in cache because another core wrote to the lock
>>>>>>> in the meantime).
>>>>>>>
>>>>>>> Builtin synchronizer (I.e synchronized keyword) for small/cheap code
>>>>>>> sections
>>>>>>> that don't contend seems decent enough.  Biased locking + (adaptive)
>>>>>>> spinning
>>>>>>> should, in theory, be good enough for these cases.
>>>>>>>
>>>>>>
>>>>>> Please measure. Sometimes biased locking is fine, sometimes much less
>>>>>> than fine. As a rule of thumb, if you expect contention not to be
>>>>>> rare,
>>>>>> consider using a j.u.c Lock. And unless you need reentrancy,
>>>>>> StampedLock
>>>>>> is often the best choice of these in terms of performance and
>>>>>> features.
>>>>>> I expect that Heinz's future installments will spell some of this out
>>>>>> for many use cases, but ... please measure.
>>>>>>
>>>>> I did some measurements of StampedLock vs ReentrantReadWriteLock and
>>>>> SL showed better performance and also did not suffer from the same
>>>>> starvation issues as RRWL.  Martin Thompson also mentioned a discussion we
>>>>> had on Crete in his blog:
>>>>> http://mechanical-sympathy.blogspot.gr/2013/08/lock-based-vs-lock-free-concurrent.html
>>>>>
>>>>> I still need to verify his findings.  My cursory tests showed that in
>>>>> some cases, SL is better than Lock-Free immutable and in other cases, plain
>>>>> old synchronized beats them both.  All depends how you test this.
>>>>>
>>>>>>
>>>>>>> Also, one other thing synchronized has going for it is it handles
>>>>>>> async aborts
>>>>>>> of threads (I.e. thread.stop()).  I know stop() is deprecated and
>>>>>>> all, but you
>>>>>>> never know.
>>>>>>>
>>>>>>
>>>>>> But you do know! As of JDK8, Thread.stop is really gone.
>>>>>> It is the first deprecated method to have actually been
>>>>>> de-implemented. It now just throws UnsupportedOperationException.
>>>>>>
>>>>>>  I think you're thinking of the Thread.stop(Throwable) method which
>>>>> has unfortunately been removed in Java 8.
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>   ------------------------------
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>>
>>  --
>>   -- Howard.
>>
>>
>
>
>  --
>   -- Howard.
>
>


-- 
  -- Howard.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131223/bc1df0cf/attachment-0001.html>

From aaron.grunthal at infinite-source.de  Mon Dec 23 07:51:34 2013
From: aaron.grunthal at infinite-source.de (Aaron Grunthal)
Date: Mon, 23 Dec 2013 13:51:34 +0100
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <CACR_FB6nUTHAvnP-bXcf+yCS1hbf+EgWPt8fCukOML-iwMBKXw@mail.gmail.com>
References: <529CEA6D.9070301@javaspecialists.eu>	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>	<529DCE97.9050302@cs.oswego.edu>	<529DEB55.7080203@javaspecialists.eu>	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>	<529E066D.9020008@oracle.com>	<CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>	<529E1DC5.2080605@javaspecialists.eu>	<CACR_FB5vC70Utw_prWKMrmuOkZJN+369EaAaREDD6_Lt4=16rA@mail.gmail.com>	<52A08B57.4000408@javaspecialists.eu>	<A690EDD8-1BCA-4AEF-A7C6-B8182C698A87@gmail.com>	<52A0DEE4.7020509@javaspecialists.eu>	<68AA05B1-48E4-4AE1-AA22-A19D8BC039DE@gmail.com>	<52A0F225.1090109@javaspecialists.eu>	<CACR_FB7zBzSpAhsSTshumR6EEp91+tnyurCaZmwep2FB0Q+=CQ@mail.gmail.com>	<52B15962.5080206@javaspecialists.eu>
	<CACR_FB6nUTHAvnP-bXcf+yCS1hbf+EgWPt8fCukOML-iwMBKXw@mail.gmail.com>
Message-ID: <52B831D6.2080401@infinite-source.de>

On 23.12.2013 05:12, Howard Lovatt wrote:

> The test uses two threads

Lock performance depends a lot on contention and number of threads 
involved. It's likely that those performance figures will change as you 
add more threads or alter the balance between reads and writes. Reducing 
it to a single scenario is probably not very informative. Especially 
considering that stamped lock seems to be designed for scenarios where 
reads outweigh writes.

- Aaron

From d.sannella at contemplateltd.com  Mon Dec 23 10:00:36 2013
From: d.sannella at contemplateltd.com (Don Sannella)
Date: Mon, 23 Dec 2013 15:00:36 +0000
Subject: [concurrency-interest] ThreadSafe static analysis tool for Java
 concurrency: free trials available
Message-ID: <52B85014.60809@contemplateltd.com>

Contemplate, an Edinburgh University spin-out company, has developed an 
advanced static analysis tool, ThreadSafe, that specifically targets 
Java concurrency defects and includes some dedicated treatment for 
java.util.concurrent.  It handles enterprise-scale Java codebases and 
includes integration with Eclipse and SonarQube.

I wrote to the list in April to look for people who would be willing to 
try out ThreadSafe and give feedback.  Thanks to everybody who participated!

We have moved on and are now offering ThreadSafe 1.2 for sale in 
single-user and enterprise versions.  You can get a free trial by 
filling out a simple webform at:

http://www.contemplateltd.com/try-buy/request-a-trial

I encourage you to give it a spin.  I'm still very interested in any 
feedback.  Even more: if you like it, please spread the word!

More information on Contemplate's website: www.contemplateltd.com

Regards,

Don Sannella

----------------------------------------------------------------------
Prof. Donald Sannella, Laboratory for Foundations of Computer Science,
School of Informatics, University of Edinburgh, Edinburgh EH8 9AB, UK
http://homepages.inf.ed.ac.uk/dts  dts at inf.ed.ac.uk  +44 131 650 5184

and

---------------------------------------------------------
Don Sannella                d.sannella at contemplateltd.com
Contemplate Ltd                    www.contemplateltd.com
Appleton Tower, 11 Crichton Street, Edinburgh EH8 9LE, UK
tel +44 7939 132117  fax +44 131 6503474  skype dsannella

From howard.lovatt at gmail.com  Mon Dec 23 14:13:09 2013
From: howard.lovatt at gmail.com (Howard Lovatt)
Date: Tue, 24 Dec 2013 06:13:09 +1100
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <52B831D6.2080401@infinite-source.de>
References: <529CEA6D.9070301@javaspecialists.eu>
	<1386018960.23958.54626153.09547351@webmail.messagingengine.com>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
	<529DEB55.7080203@javaspecialists.eu>
	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
	<529E066D.9020008@oracle.com>
	<CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>
	<529E1DC5.2080605@javaspecialists.eu>
	<CACR_FB5vC70Utw_prWKMrmuOkZJN+369EaAaREDD6_Lt4=16rA@mail.gmail.com>
	<52A08B57.4000408@javaspecialists.eu>
	<A690EDD8-1BCA-4AEF-A7C6-B8182C698A87@gmail.com>
	<52A0DEE4.7020509@javaspecialists.eu>
	<68AA05B1-48E4-4AE1-AA22-A19D8BC039DE@gmail.com>
	<52A0F225.1090109@javaspecialists.eu>
	<CACR_FB7zBzSpAhsSTshumR6EEp91+tnyurCaZmwep2FB0Q+=CQ@mail.gmail.com>
	<52B15962.5080206@javaspecialists.eu>
	<CACR_FB6nUTHAvnP-bXcf+yCS1hbf+EgWPt8fCukOML-iwMBKXw@mail.gmail.com>
	<52B831D6.2080401@infinite-source.de>
Message-ID: <25DD53CE-8389-42C2-8E78-6E79C597A825@gmail.com>

You make a good point and it is one of the areas that I worry about, along with problem size, computation per contention, processor architecture, number of cores, and JVMs. The problem I have is that it is impractical to test every combination of problem size, computation length, number of threads, and balance of read and write on numerous processor types with different core counts and different JVMs. I would find it easier if there was an approximate computation model that provided some guidance and cut down the number of combinations. But I guess such a model doesn't exist :(

Sent from my iPad

> On 23 Dec 2013, at 11:51 pm, Aaron Grunthal <aaron.grunthal at infinite-source.de> wrote:
> 
>> On 23.12.2013 05:12, Howard Lovatt wrote:
>> 
>> The test uses two threads
> 
> Lock performance depends a lot on contention and number of threads involved. It's likely that those performance figures will change as you add more threads or alter the balance between reads and writes. Reducing it to a single scenario is probably not very informative. Especially considering that stamped lock seems to be designed for scenarios where reads outweigh writes.
> 
> - Aaron
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From heinz at javaspecialists.eu  Sun Dec 22 02:06:08 2013
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Sun, 22 Dec 2013 09:06:08 +0200
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <25DD53CE-8389-42C2-8E78-6E79C597A825@gmail.com>
References: <529CEA6D.9070301@javaspecialists.eu>	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>	<529DCE97.9050302@cs.oswego.edu>	<529DEB55.7080203@javaspecialists.eu>	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>	<529E066D.9020008@oracle.com>	<CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>	<529E1DC5.2080605@javaspecialists.eu>	<CACR_FB5vC70Utw_prWKMrmuOkZJN+369EaAaREDD6_Lt4=16rA@mail.gmail.com>	<52A08B57.4000408@javaspecialists.eu>	<A690EDD8-1BCA-4AEF-A7C6-B8182C698A87@gmail.com>	<52A0DEE4.7020509@javaspecialists.eu>	<68AA05B1-48E4-4AE1-AA22-A19D8BC039DE@gmail.com>	<52A0F225.1090109@javaspecialists.eu>	<CACR_FB7zBzSpAhsSTshumR6EEp91+tnyurCaZmwep2FB0Q+=CQ@mail.gmail.com>	<52B15962.5080206@javaspecialists.eu>	<CACR_FB6nUTHAvnP-bXcf+yCS1hbf+EgWPt8fCukOML-iwMBKXw@mail.gmail.com>	<52B831D6.2080401@infinite-source.de>
	<25DD53CE-8389-42C2-8E78-6E79C597A825@gmail.com>
Message-ID: <52B68F60.4090504@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131222/b0b47f6e/attachment.html>

From howard.lovatt at gmail.com  Tue Dec 24 07:21:39 2013
From: howard.lovatt at gmail.com (Howard Lovatt)
Date: Tue, 24 Dec 2013 23:21:39 +1100
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <52B68F60.4090504@javaspecialists.eu>
References: <529CEA6D.9070301@javaspecialists.eu>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
	<529DEB55.7080203@javaspecialists.eu>
	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
	<529E066D.9020008@oracle.com>
	<CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>
	<529E1DC5.2080605@javaspecialists.eu>
	<CACR_FB5vC70Utw_prWKMrmuOkZJN+369EaAaREDD6_Lt4=16rA@mail.gmail.com>
	<52A08B57.4000408@javaspecialists.eu>
	<A690EDD8-1BCA-4AEF-A7C6-B8182C698A87@gmail.com>
	<52A0DEE4.7020509@javaspecialists.eu>
	<68AA05B1-48E4-4AE1-AA22-A19D8BC039DE@gmail.com>
	<52A0F225.1090109@javaspecialists.eu>
	<CACR_FB7zBzSpAhsSTshumR6EEp91+tnyurCaZmwep2FB0Q+=CQ@mail.gmail.com>
	<52B15962.5080206@javaspecialists.eu>
	<CACR_FB6nUTHAvnP-bXcf+yCS1hbf+EgWPt8fCukOML-iwMBKXw@mail.gmail.com>
	<52B831D6.2080401@infinite-source.de>
	<25DD53CE-8389-42C2-8E78-6E79C597A825@gmail.com>
	<52B68F60.4090504@javaspecialists.eu>
Message-ID: <360F7535-BF1E-4B77-BB50-9C69944BD5E2@gmail.com>

Hi Heinz,

Sure - I agree with all your points. It would be interesting to see how you benchmark the different implementations. As I have repeatedly said, I am not happy with my benchmarking. 

A couple of more detailed points:

1. I haven't noticed any difference between using an Executor and a parallel Stream and the coding for a parallel Stream is simpler. But you are right, potentially a dedicated Thread, an Executor, and a parallel Stream could all give different results. 

2. To use an immutable you have to structure the application differently, e.g. Interested parties register as Listeners. Therefore Immutable and the others are not directly comparable. 

Seasons greetings,

 -- Howard. 

Sent from my iPad

> On 22 Dec 2013, at 6:06 pm, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu> wrote:
> 
> Hi Howard & Aaron,
> 
> Indeed, it takes a lot of time and energy to test this type of construct for performance, maybe a couple of weeks of hard work.  And even then, one is always left with the niggling suspicion that one has missed an important side-effect.
> 
> Just some examples:
> 
> 1. I doubt that your system will be throttled on GC stop-the-world.  Object creation could be a bottleneck though.  Thus one way to reduce the wait times would be to decrease the max memory for the test.  You would then also not need the call to explicit GC.
> 
> 2. When you use polymorphism, the method calls for the first subclass can be inlined.  Once the second subclass is loaded, it uses a simple if-else.  It is slower than with one, but not as bad as three.  etc.  Here are two articles that describe this: http://www.javaspecialists.eu/archive/Issue157.html and http://www.javaspecialists.eu/archive/Issue158.html In your code, you put the ImmutablePoint first, which gives it an advantage over the others.
> 
> 3. I would still argue that your ImmutablePoint is not a valid implementation to compare against, since the resulting Point object is only stored in an unshared array wrapper held in a local variable.  It would need to be stored somewhere else, such as a volatile field or probably an AtomicReference.  This NonblockingPoint would be a better approach (although using Unsafe with a volatile reference could improve performance a bit):
> 
>   static class NonblockingPoint implements Point {
>     private final AtomicReference<int[]> xy = new AtomicReference<>(new int[2]);
>     @Override public double distanceFromOrigin() {
>       int[] xy = this.xy.get();
>       return Math.hypot(xy[0], xy[1]);
>     }
>     @Override public void move(int deltaX, int deltaY) {
>       int[] current, next;
>       do {
>         current = xy.get();
>         next = new int[] { current[0] + deltaX, current[1] + deltaY };
>       } while(!xy.compareAndSet(current, next));
>     }
>   }
> 
> 
> And a bunch of other things.  I personally would keep the code as basic as possible and shy away from Streams.  Firstly, it could introduce some hidden performance bottlenecks and secondly, it prevents you from comparing to Java7 (StampedLock is backported to Java7).
> Regards
> 
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Oracle Java Champion 2005-2013
> JavaOne Rock Star Speaker 2012
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
> 
> 
> Howard Lovatt wrote:
>> 
>> You make a good point and it is one of the areas that I worry about, along with problem size, computation per contention, processor architecture, number of cores, and JVMs. The problem I have is that it is impractical to test every combination of problem size, computation length, number of threads, and balance of read and write on numerous processor types with different core counts and different JVMs. I would find it easier if there was an approximate computation model that provided some guidance and cut down the number of combinations. But I guess such a model doesn't exist :(
>> 
>> Sent from my iPad
>> 
>>   
>>>> On 23 Dec 2013, at 11:51 pm, Aaron Grunthal <aaron.grunthal at infinite-source.de> wrote:
>>>> 
>>>>     
>>>> On 23.12.2013 05:12, Howard Lovatt wrote:
>>>> 
>>>> The test uses two threads
>>>>       
>>> Lock performance depends a lot on contention and number of threads involved. It's likely that those performance figures will change as you add more threads or alter the balance between reads and writes. Reducing it to a single scenario is probably not very informative. Especially considering that stamped lock seems to be designed for scenarios where reads outweigh writes.
>>> 
>>> - Aaron
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>     
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131224/aada1970/attachment.html>

From bahri.gencsoy at gmail.com  Wed Dec 25 04:55:32 2013
From: bahri.gencsoy at gmail.com (=?UTF-8?Q?Bahri_Gen=C3=A7soy?=)
Date: Wed, 25 Dec 2013 11:55:32 +0200
Subject: [concurrency-interest] LongAdder sumThenReset() race under high load
Message-ID: <CAC6L7U_nbhhPZ5bMw6Nq0PuzFtUW0WqOcDvYJs8pJJeAQfMiwQ@mail.gmail.com>

First post here, I felt obliged to post these findings.

I guess LongAdder.sumThenReset() operation will cause to lose some updates
under high load. I ran following unit test against LongAdder implementation
from Doug Lea's repository (v1.14) and Striped64 (v1.8):

    @Test
    public void longAdderSumThenResetTestUnderHighLoad() throws
InterruptedException {
        final LongAdder longAdder = new LongAdder();
        final CountDownLatch startLatch = new CountDownLatch(1);
        final CountDownLatch endLatch = new CountDownLatch(32);
        for (int threadNo = 0; threadNo < 32; threadNo++) {
            new Thread() {
                public void run() {
                    Uninterruptibles.awaitUninterruptibly(startLatch);
                    for (int i = 0; i < 50000000; i++) {
                        longAdder.add(1);
                    }
                    endLatch.countDown();
                }
            }.start();
        }
        final AtomicLong moved = new AtomicLong();
        new Thread() {
            public void run() {
                do {
                    moved.addAndGet(longAdder.sumThenReset());
                    System.out.println(moved);
                } while (!Uninterruptibles.awaitUninterruptibly(endLatch,
1, TimeUnit.SECONDS));
            }
        }.start();
        startLatch.countDown();
        endLatch.await();
        System.out.println("Threads finished");
        moved.addAndGet(longAdder.sumThenReset());
        assertEquals(1600000000, moved.longValue());
    }

What I am trying to do is to periodically move value in LongAdder to an
AtomicInteger. This test fails on my machine with a value of ~20 mismatch.
I guess increments are lost during sumThenReset() call.

Maybe this is the expected behavior, documentation says "If there are
updates concurrent with this method, the returned value is *not* guaranteed
to be the final value occurring before the reset.", but
my interpretation of this statement was that raced updates would be
reflected to the next sum operation. IMHO, if this behavior is expected,
LongAdder cannot be used on mission critical operations, my use case was
to periodically refund unused quotas.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131225/51979966/attachment.html>

From pramalhe at gmail.com  Wed Dec 25 07:44:55 2013
From: pramalhe at gmail.com (Pedro Ramalhete)
Date: Wed, 25 Dec 2013 13:44:55 +0100
Subject: [concurrency-interest] Left-Right - A new concurrency control
	technique
Message-ID: <CAAApjO21nDTbVJhmjU0F+dTgjn5NuQeq3qC1w=hXRJZLZ0idyA@mail.gmail.com>

Hello,

We are pleased to announce a new concurrency control technique which we
named "Left-Right" and that allows Wait-Free Populations Oblivious read
operations. The easiest way to explain what it is, is to say that it's a
"kind of" Reader-Writer Lock that doesn't block for Readers, which makes it
ideal for low-latency and real-time deployment scenarios:
http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/leftright-extended.pdf

In case you missed it above, this means that you can have one Writer and
multiple Readers executing simultaneously, and unlike optimistic read
locks, you don't have to worry about atomicity, or memory management, or
invariants.

Similarly to a Reader-Writer lock, it can be applied to any
(non-thread-safe) data structure and enable it to be used in a
multi-threaded application, where it will be Blocking for Writers, and
Wait-Free for Readers. It can be implemented in Java, Scala, C11, or C++1x.
Sample source code can be seen here:
http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/LRScalableTreeSet.java
http://sourceforge.net/projects/ccfreaks/files/java/src/com/concurrencyfreaks/leftright/LRScalableGuard.java

Its two main innovations are, the usage of two instances, and the new
concurrency control algorithm whose novel state machine gives wait-free
guarantees for read operations.


There is another technique which also uses two instances but requires 3
locks, which perhaps has already been discovered, that we named "Double
Instance Locking" and it is much easier to understand and implement, but it
is only Lock-Free for read operations:
http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/DoubleInstanceLocking.pptx
http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/DoubleInstanceLockGuard.java
http://concurrencyfreaks.com/2013/11/double-instance-locking.html

We would like to hear expert's comments on it   ;)

Merry Christmas,
Pedro & Andreia
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131225/54bc113d/attachment.html>

From pramalhe at gmail.com  Wed Dec 25 18:03:23 2013
From: pramalhe at gmail.com (Pedro Ramalhete)
Date: Thu, 26 Dec 2013 00:03:23 +0100
Subject: [concurrency-interest] LongAdder sumThenReset() race under high
	load
Message-ID: <CAAApjO1OxBs3=9L6F_+k6C9dwU8JbhPizAXXMsisKSXdRyVnpA@mail.gmail.com>

Hi Bahri,

I believe that what you are observing is the expected behavior for
LongAdder.
You can try to implement another function that resets each Cell using a
compareAndSet(), in order to obtain the behavior you want. Something like
this might do the trick:

   public long sumThenResetCAS() {
        Cell[] as = cells; Cell a;
        long sum = 0;
        while (true) {
            final long tsum = base;
            if (casBase(tsum, 0L)) {
                sum += tsum;
                break;
            }
        }
        if (as != null) {
            for (int i = 0; i < as.length; ++i) {
                if ((a = as[i]) != null) {
                    while (true) {
                        final long tsum = a.get();
                        if (a.compareAndSet(tsum, 0L)) {
                            sum += tsum;
                            break;
                        }
                    }
                }
            }
        }
        return sum;
    }

Notice that this technique will be (much) slower than
LongAdder.sumThenReset()

Thanks,
Pedro
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131226/66c70615/attachment.html>

From davidcholmes at aapt.net.au  Wed Dec 25 19:07:38 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 26 Dec 2013 10:07:38 +1000
Subject: [concurrency-interest] Left-Right - A new concurrency
	controltechnique
In-Reply-To: <CAAApjO21nDTbVJhmjU0F+dTgjn5NuQeq3qC1w=hXRJZLZ0idyA@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEEPKDAA.davidcholmes@aapt.net.au>

Hi Pedro,

Without reading the paper yet (it is Xmas after all! :) ) it sounds like a
typical multi-state based implementation: each writer atomically replaces
the current state object with a new state object. Readers simply grab the
current state object and can use its content regardless of whether writers
have made further updates. As you say readers need never block, however
there is a greater potential for accessing stale data and the memory
requirements are at least 2x and potentially much higher.

I'll add the paper to my New Year's reading list :)

Cheers,
David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Pedro
Ramalhete
  Sent: Wednesday, 25 December 2013 10:45 PM
  To: concurrency-interest
  Cc: Andreia Craveiro Ramalhete
  Subject: [concurrency-interest] Left-Right - A new concurrency
controltechnique


  Hello,

  We are pleased to announce a new concurrency control technique which we
named "Left-Right" and that allows Wait-Free Populations Oblivious read
operations. The easiest way to explain what it is, is to say that it's a
"kind of" Reader-Writer Lock that doesn't block for Readers, which makes it
ideal for low-latency and real-time deployment scenarios:
  http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/leftright-
extended.pdf

  In case you missed it above, this means that you can have one Writer and
multiple Readers executing simultaneously, and unlike optimistic read locks,
you don't have to worry about atomicity, or memory management, or
invariants.

  Similarly to a Reader-Writer lock, it can be applied to any
(non-thread-safe) data structure and enable it to be used in a
multi-threaded application, where it will be Blocking for Writers, and
Wait-Free for Readers. It can be implemented in Java, Scala, C11, or C++1x.
  Sample source code can be seen here:
  http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/LRScalable
TreeSet.java
  http://sourceforge.net/projects/ccfreaks/files/java/src/com/concurrencyfre
aks/leftright/LRScalableGuard.java

  Its two main innovations are, the usage of two instances, and the new
concurrency control algorithm whose novel state machine gives wait-free
guarantees for read operations.


  There is another technique which also uses two instances but requires 3
locks, which perhaps has already been discovered, that we named "Double
Instance Locking" and it is much easier to understand and implement, but it
is only Lock-Free for read operations:
  http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/Doubl
eInstanceLocking.pptx
  http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/Doubl
eInstanceLockGuard.java
  http://concurrencyfreaks.com/2013/11/double-instance-locking.html

  We would like to hear expert's comments on it   ;)

  Merry Christmas,
  Pedro & Andreia
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131226/d64473ca/attachment.html>

From hjohn at xs4all.nl  Thu Dec 26 05:53:04 2013
From: hjohn at xs4all.nl (John Hendrikx)
Date: Thu, 26 Dec 2013 11:53:04 +0100
Subject: [concurrency-interest] Solution for running several tasks serially
	on multiple executors
Message-ID: <52BC0A90.3000600@xs4all.nl>

Hi List,

I have a use case which I'd like to use the concurrency package for, but 
cannot find a solution for without writing some support code of my own.

Basically, I need to run a few hundred to a few thousand independent  
tasks, which can complete in any order.  I use a ThreadPoolExecutor for 
this.  Some of these tasks can block for several seconds, while others 
will complete in just a few milliseconds.  Inevitably, the blocking 
tasks will dominate the worker threads, and short running tasks get 
delayed, leaving my system not as responsive as desired -- I'd prefer 
the short running tasks to be prioritized over the long running ones.

Most of these tasks however generally will run fast, except if there is 
a cache miss (say a database is missing an entry, and it needs to be 
fetched from the web).  Most tasks therefore do something like:

1) Check database, if present, return result and exit
2) Do some web requests, store result in database, return result and exit

So, my thinking was, I reserve a ThreadPoolExecutor for "fast" task 
steps, and one for the "slow" task steps.  Therefore I split up the 
tasks into two or more steps -- of course, while the main tasks can run 
in any order, the steps of one task must run serially.

I created a helper class that allows me to break up these tasks into 
multiple steps, where each step is a Runnable + Executor.  So for example:

new TaskStep(FAST_EXECUTOR, new CheckDatabaseRunnable());
new TaskStep(SLOW_EXECUTOR, new CheckWebRunnable());

The helper class will take these steps, wrap the Runnable with a small 
piece of logic that will run the next step (but only if the first step 
didn't deliver results), and then just starts the first TaskStep.

Crucial is that the "fast" step actually exits and releases the thread 
it ran on without waiting for the "slow" step to complete (which I think 
rules out the ForkJoinPool solution as threads are joined there) -- the 
whole point is to keep the "fast" ThreadPoolExecutor fast without its 
threads ending up waiting for web requests to complete, blocking 
unrelated tasks that might be serviced fast from the cache.  Giving the 
"fast" pool a few thousand threads to work with didn't appeal to me (I 
read that most VM's are limited to a few thousand to tens of thousands 
of threads, and I'd like to stay far away from such limitations).

The above example can be extended further and I've added more Executors 
now that for example throttle certain task steps -- some web API's limit 
how fast requests are allowed and so I figured, I could just let an 
Executor handle the throttling completely transparently by delaying task 
steps according to their specifications.  Basically, the tasks now can 
have multiple steps, each step being associated with an Executor, and a 
single task can therefore hop between Executors several times before 
completing (while all steps are still executed serially).  When 
sequential steps run on the same executor, the system even runs the next 
step "inline" instead of queueing it up with the same executor:

   public void execute(Runnable command) {
     if(threadFactoryWrapper.isOurThread(Thread.currentThread())) {
       command.run();
     }
     else {
       executor.execute(command);
     }
   }

Anyway, I found this an interesting use case, and I was hoping the 
concurrency package could help me with it (and it has ofcourse).  It 
just seemed to me that something like this could already be part of it 
(ForkJoinPool has some similarities with this case I think) and I'm just 
missing something.

--John



From pramalhe at gmail.com  Thu Dec 26 07:06:49 2013
From: pramalhe at gmail.com (Pedro Ramalhete)
Date: Thu, 26 Dec 2013 13:06:49 +0100
Subject: [concurrency-interest] Left-Right - A new concurrency
	controltechnique
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEEPKDAA.davidcholmes@aapt.net.au>
References: <CAAApjO21nDTbVJhmjU0F+dTgjn5NuQeq3qC1w=hXRJZLZ0idyA@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEEPKDAA.davidcholmes@aapt.net.au>
Message-ID: <CAAApjO0_mADuahObqfeHAKi+EE70YVrNFVipi4LXSeEZsRhjdQ@mail.gmail.com>

Hi David,

If I'm not mistaken, what you describe is the Copy-On-Write technique (COW)
used in Java's CopyOnWriteArrayList, CopyOnWriteArraySet, and on Scala's
immutable
data structures: ImmutableMap, ImmutableSet, ImmutableList.

The Left-Right is something else altogether.
Although both the COW and the Left-Right (LR) are Wait-Free for read
operations,
the LR is always Blocking for mutations (write operations) while the COW
can
be made Lock-Free. Unlike the COW, the LR doesn't allocate a new object for
every mutation, there are always two (and only two) objects in use. This
means
the LR doesn't need a garbage collector, which is why we were able to
easily
implement it in C++11.

Performance wise, if there are many write operations, the LR will be at
least
twice as slow as the COW, but if there are many more reads than writes,
the LR technique will be much faster than the COW or Immutable data
structures,
because on the COW technique a new object is created for every mutation,
which
can cause many cache-misses on the read operations.


Thanks for taking the time. Looking forward to your comments!

Happy Holidays,
Pedro



On Thu, Dec 26, 2013 at 1:07 AM, David Holmes <davidcholmes at aapt.net.au>wrote:

>  Hi Pedro,
>
> Without reading the paper yet (it is Xmas after all! :) ) it sounds like a
> typical multi-state based implementation: each writer atomically replaces
> the current state object with a new state object. Readers simply grab the
> current state object and can use its content regardless of whether writers
> have made further updates. As you say readers need never block, however
> there is a greater potential for accessing stale data and the memory
> requirements are at least 2x and potentially much higher.
>
> I'll add the paper to my New Year's reading list :)
>
> Cheers,
> David Holmes
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Pedro Ramalhete
> *Sent:* Wednesday, 25 December 2013 10:45 PM
> *To:* concurrency-interest
> *Cc:* Andreia Craveiro Ramalhete
> *Subject:* [concurrency-interest] Left-Right - A new concurrency
> controltechnique
>
> Hello,
>
> We are pleased to announce a new concurrency control technique which we
> named "Left-Right" and that allows Wait-Free Populations Oblivious read
> operations. The easiest way to explain what it is, is to say that it's a
> "kind of" Reader-Writer Lock that doesn't block for Readers, which makes it
> ideal for low-latency and real-time deployment scenarios:
>
> http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/leftright-extended.pdf
>
> In case you missed it above, this means that you can have one Writer and
> multiple Readers executing simultaneously, and unlike optimistic read
> locks, you don't have to worry about atomicity, or memory management, or
> invariants.
>
> Similarly to a Reader-Writer lock, it can be applied to any
> (non-thread-safe) data structure and enable it to be used in a
> multi-threaded application, where it will be Blocking for Writers, and
> Wait-Free for Readers. It can be implemented in Java, Scala, C11, or C++1x.
> Sample source code can be seen here:
>
> http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/LRScalableTreeSet.java
>
> http://sourceforge.net/projects/ccfreaks/files/java/src/com/concurrencyfreaks/leftright/LRScalableGuard.java
>
> Its two main innovations are, the usage of two instances, and the new
> concurrency control algorithm whose novel state machine gives wait-free
> guarantees for read operations.
>
>
> There is another technique which also uses two instances but requires 3
> locks, which perhaps has already been discovered, that we named "Double
> Instance Locking" and it is much easier to understand and implement, but it
> is only Lock-Free for read operations:
>
> http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/DoubleInstanceLocking.pptx
>
> http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/DoubleInstanceLockGuard.java
> http://concurrencyfreaks.com/2013/11/double-instance-locking.html
>
> We would like to hear expert's comments on it   ;)
>
> Merry Christmas,
> Pedro & Andreia
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131226/4e103a61/attachment-0001.html>

From dl at cs.oswego.edu  Thu Dec 26 08:55:55 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 26 Dec 2013 08:55:55 -0500
Subject: [concurrency-interest] LongAdder sumThenReset() race under high
 load
In-Reply-To: <CAC6L7U_nbhhPZ5bMw6Nq0PuzFtUW0WqOcDvYJs8pJJeAQfMiwQ@mail.gmail.com>
References: <CAC6L7U_nbhhPZ5bMw6Nq0PuzFtUW0WqOcDvYJs8pJJeAQfMiwQ@mail.gmail.com>
Message-ID: <52BC356B.6070503@cs.oswego.edu>

On 12/25/2013 04:55 AM, Bahri Gen?soy wrote:

> I guess LongAdder.sumThenReset() operation will cause to lose some updates under
> high load.

Yes. I thought the specs were pretty clear. Pasting those for
reset (which are referenced in sumThenReset):

"Resets variables maintaining the sum to zero. This method may be a useful 
alternative to creating a new adder, but is only effective if there are no 
concurrent updates. Because this method is intrinsically racy, it should only be 
used when it is known that no threads are concurrently updating."

Any suggestions about improving this wording that could help avoid
other people being surprised would be welcome.

-Doug






From dl at cs.oswego.edu  Thu Dec 26 09:27:13 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 26 Dec 2013 09:27:13 -0500
Subject: [concurrency-interest] Left-Right - A new concurrency control
 technique
In-Reply-To: <CAAApjO21nDTbVJhmjU0F+dTgjn5NuQeq3qC1w=hXRJZLZ0idyA@mail.gmail.com>
References: <CAAApjO21nDTbVJhmjU0F+dTgjn5NuQeq3qC1w=hXRJZLZ0idyA@mail.gmail.com>
Message-ID: <52BC3CC1.1030106@cs.oswego.edu>

On 12/25/2013 07:44 AM, Pedro Ramalhete wrote:

> We are pleased to announce a new concurrency control technique which we
> named "Left-Right" and that allows Wait-Free Populations Oblivious read
> operations.

http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/leftright-extended.pdf

Thanks for posting this. As you say, keeping exactly two versions/copies
looks like an attractive middle-ground between COW and mutable structures.
It's still not completely clear when this middle ground is the best option.
The basic idea is also seen in iterative structured parallelism; for
example, switching between two grids on even/odd parallel sweeps in
relaxation designs. One possible application you might look into
is to help avoid unbounded copying in some of the JDK8 Stream
Collector operations.

-Doug


From nathan.reynolds at oracle.com  Thu Dec 26 13:22:11 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Thu, 26 Dec 2013 11:22:11 -0700
Subject: [concurrency-interest] Solution for running several tasks
 serially on multiple executors
In-Reply-To: <52BC0A90.3000600@xs4all.nl>
References: <52BC0A90.3000600@xs4all.nl>
Message-ID: <52BC73D3.40602@oracle.com>

To avoid using a lot of threads on the web requests, I would recommend 
using non-blocking I/O.  So, step 2 would be the following...

2a) Send some web requests
2b) Receive web response, store result in database, return result and exit

This way step 2a and 2b are very fast.  A single helper thread does a 
select() call on all of the sockets that are waiting for web responses.  
As responses come back, the helper thread creates a job for 2b and 
submits it to the pool.  The thread that picks up the job will read the 
socket and finish the processing.

If all steps were made non-blocking, you can probably limit the number 
of threads to the number of logical cores on the machine. If you use 
fewer threads, then you wouldn't be able to use the full compute power 
of the box.  If you use more threads, then threads will sit in the OS 
scheduler's run queue waiting for a logical core.

Another way of looking at this... Every blocking operation requires 
adding and "wasting" 1 more thread.

Many APIs don't have non-blocking alternatives.  I have wondered if it 
would be worth the effort to introduce new non-blocking APIs.

Recently, someone posted to this group a library which implements 
light-weight threads.  Blocking operations cause the stack to be saved 
and the light-weight thread to context switch off and another thread to 
context switch on.  This seems like a great solution.  It allows for 
writing code without having to worry about blocking.  It allows for 
running the bare minimum number of threads.  Unfortunately, it can't be 
used everywhere.  Some servers have call stacks 100s of methods deep 
with a blocking operation at the top.  It would be very painful to save 
and restore the entire stack.

-Nathan

On 12/26/2013 3:53 AM, John Hendrikx wrote:
> Hi List,
>
> I have a use case which I'd like to use the concurrency package for, 
> but cannot find a solution for without writing some support code of my 
> own.
>
> Basically, I need to run a few hundred to a few thousand independent  
> tasks, which can complete in any order.  I use a ThreadPoolExecutor 
> for this.  Some of these tasks can block for several seconds, while 
> others will complete in just a few milliseconds.  Inevitably, the 
> blocking tasks will dominate the worker threads, and short running 
> tasks get delayed, leaving my system not as responsive as desired -- 
> I'd prefer the short running tasks to be prioritized over the long 
> running ones.
>
> Most of these tasks however generally will run fast, except if there 
> is a cache miss (say a database is missing an entry, and it needs to 
> be fetched from the web).  Most tasks therefore do something like:
>
> 1) Check database, if present, return result and exit
> 2) Do some web requests, store result in database, return result and exit
>
> So, my thinking was, I reserve a ThreadPoolExecutor for "fast" task 
> steps, and one for the "slow" task steps.  Therefore I split up the 
> tasks into two or more steps -- of course, while the main tasks can 
> run in any order, the steps of one task must run serially.
>
> I created a helper class that allows me to break up these tasks into 
> multiple steps, where each step is a Runnable + Executor.  So for 
> example:
>
> new TaskStep(FAST_EXECUTOR, new CheckDatabaseRunnable());
> new TaskStep(SLOW_EXECUTOR, new CheckWebRunnable());
>
> The helper class will take these steps, wrap the Runnable with a small 
> piece of logic that will run the next step (but only if the first step 
> didn't deliver results), and then just starts the first TaskStep.
>
> Crucial is that the "fast" step actually exits and releases the thread 
> it ran on without waiting for the "slow" step to complete (which I 
> think rules out the ForkJoinPool solution as threads are joined there) 
> -- the whole point is to keep the "fast" ThreadPoolExecutor fast 
> without its threads ending up waiting for web requests to complete, 
> blocking unrelated tasks that might be serviced fast from the cache.  
> Giving the "fast" pool a few thousand threads to work with didn't 
> appeal to me (I read that most VM's are limited to a few thousand to 
> tens of thousands of threads, and I'd like to stay far away from such 
> limitations).
>
> The above example can be extended further and I've added more 
> Executors now that for example throttle certain task steps -- some web 
> API's limit how fast requests are allowed and so I figured, I could 
> just let an Executor handle the throttling completely transparently by 
> delaying task steps according to their specifications.  Basically, the 
> tasks now can have multiple steps, each step being associated with an 
> Executor, and a single task can therefore hop between Executors 
> several times before completing (while all steps are still executed 
> serially).  When sequential steps run on the same executor, the system 
> even runs the next step "inline" instead of queueing it up with the 
> same executor:
>
>   public void execute(Runnable command) {
>     if(threadFactoryWrapper.isOurThread(Thread.currentThread())) {
>       command.run();
>     }
>     else {
>       executor.execute(command);
>     }
>   }
>
> Anyway, I found this an interesting use case, and I was hoping the 
> concurrency package could help me with it (and it has ofcourse). It 
> just seemed to me that something like this could already be part of it 
> (ForkJoinPool has some similarities with this case I think) and I'm 
> just missing something.
>
> --John
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131226/ab704247/attachment.html>

From davidcholmes at aapt.net.au  Thu Dec 26 18:23:39 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 27 Dec 2013 09:23:39 +1000
Subject: [concurrency-interest] Left-Right - A new
	concurrencycontroltechnique
In-Reply-To: <CAAApjO0_mADuahObqfeHAKi+EE70YVrNFVipi4LXSeEZsRhjdQ@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEFBKDAA.davidcholmes@aapt.net.au>

Hi Pedro,

I wasn't specifically referring to copy-on-write, but for data structures
with a dynamic state representation (lists etc) COW is a simple  multi-state
technique. I'm now intriqued as to how you can only have two "objects" in
play for such dynamic data structures.

I look forward to reading the paper.

David

  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Pedro
Ramalhete
  Sent: Thursday, 26 December 2013 10:07 PM
  To: dholmes at ieee.org
  Cc: concurrency-interest; Andreia Craveiro Ramalhete
  Subject: Re: [concurrency-interest] Left-Right - A new
concurrencycontroltechnique



  Hi David,

  If I'm not mistaken, what you describe is the Copy-On-Write technique
(COW)
  used in Java's CopyOnWriteArrayList, CopyOnWriteArraySet, and on Scala's
immutable
  data structures: ImmutableMap, ImmutableSet, ImmutableList.

  The Left-Right is something else altogether.
  Although both the COW and the Left-Right (LR) are Wait-Free for read
operations,
  the LR is always Blocking for mutations (write operations) while the COW
can
  be made Lock-Free. Unlike the COW, the LR doesn't allocate a new object
for
  every mutation, there are always two (and only two) objects in use. This
means
  the LR doesn't need a garbage collector, which is why we were able to
easily
  implement it in C++11.

  Performance wise, if there are many write operations, the LR will be at
least
  twice as slow as the COW, but if there are many more reads than writes,
  the LR technique will be much faster than the COW or Immutable data
structures,
  because on the COW technique a new object is created for every mutation,
which
  can cause many cache-misses on the read operations.


  Thanks for taking the time. Looking forward to your comments!

  Happy Holidays,
  Pedro





  On Thu, Dec 26, 2013 at 1:07 AM, David Holmes <davidcholmes at aapt.net.au>
wrote:

    Hi Pedro,

    Without reading the paper yet (it is Xmas after all! :) ) it sounds like
a typical multi-state based implementation: each writer atomically replaces
the current state object with a new state object. Readers simply grab the
current state object and can use its content regardless of whether writers
have made further updates. As you say readers need never block, however
there is a greater potential for accessing stale data and the memory
requirements are at least 2x and potentially much higher.

    I'll add the paper to my New Year's reading list :)

    Cheers,
    David Holmes
      -----Original Message-----
      From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Pedro
Ramalhete
      Sent: Wednesday, 25 December 2013 10:45 PM
      To: concurrency-interest
      Cc: Andreia Craveiro Ramalhete
      Subject: [concurrency-interest] Left-Right - A new concurrency
controltechnique


      Hello,

      We are pleased to announce a new concurrency control technique which
we named "Left-Right" and that allows Wait-Free Populations Oblivious read
operations. The easiest way to explain what it is, is to say that it's a
"kind of" Reader-Writer Lock that doesn't block for Readers, which makes it
ideal for low-latency and real-time deployment scenarios:
      http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/leftri
ght-extended.pdf

      In case you missed it above, this means that you can have one Writer
and multiple Readers executing simultaneously, and unlike optimistic read
locks, you don't have to worry about atomicity, or memory management, or
invariants.

      Similarly to a Reader-Writer lock, it can be applied to any
(non-thread-safe) data structure and enable it to be used in a
multi-threaded application, where it will be Blocking for Writers, and
Wait-Free for Readers. It can be implemented in Java, Scala, C11, or C++1x.
      Sample source code can be seen here:
      http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/LRScal
ableTreeSet.java
      http://sourceforge.net/projects/ccfreaks/files/java/src/com/concurrenc
yfreaks/leftright/LRScalableGuard.java

      Its two main innovations are, the usage of two instances, and the new
concurrency control algorithm whose novel state machine gives wait-free
guarantees for read operations.


      There is another technique which also uses two instances but requires
3 locks, which perhaps has already been discovered, that we named "Double
Instance Locking" and it is much easier to understand and implement, but it
is only Lock-Free for read operations:
      http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/D
oubleInstanceLocking.pptx
      http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/D
oubleInstanceLockGuard.java
      http://concurrencyfreaks.com/2013/11/double-instance-locking.html

      We would like to hear expert's comments on it   ;)

      Merry Christmas,
      Pedro & Andreia


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131227/186317bd/attachment-0001.html>

From howard.lovatt at gmail.com  Sat Dec 28 04:28:09 2013
From: howard.lovatt at gmail.com (Howard Lovatt)
Date: Sat, 28 Dec 2013 20:28:09 +1100
Subject: [concurrency-interest] StampedLock Article
In-Reply-To: <360F7535-BF1E-4B77-BB50-9C69944BD5E2@gmail.com>
References: <529CEA6D.9070301@javaspecialists.eu>
	<CAHjP37F=eMvgZfk3y6FufNftzGbR4vbXnT176HKBt=P6t5xdgQ@mail.gmail.com>
	<529DCE97.9050302@cs.oswego.edu>
	<529DEB55.7080203@javaspecialists.eu>
	<CAHjP37HXkE3SKjYcRORkQqdTcF4TYOjHm40OLJPVhdOXZmp=yg@mail.gmail.com>
	<529E066D.9020008@oracle.com>
	<CAHjP37H2aL9oaFQDOFkJs25j5+1=h5SsuXLc76tMf0xX7zAJcQ@mail.gmail.com>
	<529E1DC5.2080605@javaspecialists.eu>
	<CACR_FB5vC70Utw_prWKMrmuOkZJN+369EaAaREDD6_Lt4=16rA@mail.gmail.com>
	<52A08B57.4000408@javaspecialists.eu>
	<A690EDD8-1BCA-4AEF-A7C6-B8182C698A87@gmail.com>
	<52A0DEE4.7020509@javaspecialists.eu>
	<68AA05B1-48E4-4AE1-AA22-A19D8BC039DE@gmail.com>
	<52A0F225.1090109@javaspecialists.eu>
	<CACR_FB7zBzSpAhsSTshumR6EEp91+tnyurCaZmwep2FB0Q+=CQ@mail.gmail.com>
	<52B15962.5080206@javaspecialists.eu>
	<CACR_FB6nUTHAvnP-bXcf+yCS1hbf+EgWPt8fCukOML-iwMBKXw@mail.gmail.com>
	<52B831D6.2080401@infinite-source.de>
	<25DD53CE-8389-42C2-8E78-6E79C597A825@gmail.com>
	<52B68F60.4090504@javaspecialists.eu>
	<360F7535-BF1E-4B77-BB50-9C69944BD5E2@gmail.com>
Message-ID: <CACR_FB4nH9--b2fFA4Qw7E0qqaLuSEKKvwGWKU4-QmmHOnHxeQ@mail.gmail.com>

Hi Heinz,

Have updated the tests to incorporates most of your comments (22/12/13),
added a version of Pedro Ramalhete's left-right technique (25/12/13), added
test for more threads, and added tests for larger data sets.

The new results on my 4-core MacBook with JDK8 build 106 are:

threads = 2
dimensions = 32
ImmutablePoint took LongSummaryStatistics{count=5, sum=57, min=7,
average=11.400000, max=28} ms, distance = 10000.0
StampedPoint took LongSummaryStatistics{count=5, sum=72, min=11,
average=14.400000, max=26} ms, distance = 100000.0
CopyOnWritePoint took LongSummaryStatistics{count=5, sum=88, min=10,
average=17.600000, max=41} ms, distance = 100000.0
ModCountPoint took LongSummaryStatistics{count=5, sum=96, min=12,
average=19.200000, max=45} ms, distance = 100000.0
SynchronizedPoint took LongSummaryStatistics{count=5, sum=106, min=16,
average=21.200000, max=39} ms, distance = 100000.0
AlternateCopiesPoint took LongSummaryStatistics{count=5, sum=129, min=18,
average=25.800000, max=55} ms, distance = 100000.0
AtomicReferencePoint took LongSummaryStatistics{count=5, sum=164, min=11,
average=32.800000, max=106} ms, distance = 100000.0
threads = 2
dimensions = 512
ImmutablePoint took LongSummaryStatistics{count=5, sum=349, min=68,
average=69.800000, max=77} ms, distance = 10000.0
CopyOnWritePoint took LongSummaryStatistics{count=5, sum=515, min=100,
average=103.000000, max=110} ms, distance = 100000.0
StampedPoint took LongSummaryStatistics{count=5, sum=558, min=108,
average=111.600000, max=121} ms, distance = 100000.0
ModCountPoint took LongSummaryStatistics{count=5, sum=575, min=112,
average=115.000000, max=120} ms, distance = 100000.0
AtomicReferencePoint took LongSummaryStatistics{count=5, sum=621, min=119,
average=124.200000, max=128} ms, distance = 100000.0
SynchronizedPoint took LongSummaryStatistics{count=5, sum=733, min=142,
average=146.600000, max=151} ms, distance = 100000.0
AlternateCopiesPoint took LongSummaryStatistics{count=5, sum=935, min=184,
average=187.000000, max=190} ms, distance = 100000.0
threads = 2
dimensions = 8192
ImmutablePoint took LongSummaryStatistics{count=5, sum=5666, min=1115,
average=1133.200000, max=1161} ms, distance = 10000.0
ModCountPoint took LongSummaryStatistics{count=5, sum=8674, min=1692,
average=1734.800000, max=1770} ms, distance = 100000.0
CopyOnWritePoint took LongSummaryStatistics{count=5, sum=8748, min=1601,
average=1749.600000, max=1805} ms, distance = 100000.0
StampedPoint took LongSummaryStatistics{count=5, sum=9051, min=1784,
average=1810.200000, max=1898} ms, distance = 100000.0
AtomicReferencePoint took LongSummaryStatistics{count=5, sum=9949,
min=1882, average=1989.800000, max=2109} ms, distance = 100000.0
SynchronizedPoint took LongSummaryStatistics{count=5, sum=10736, min=2037,
average=2147.200000, max=2246} ms, distance = 100000.0
AlternateCopiesPoint took LongSummaryStatistics{count=5, sum=15724,
min=3110, average=3144.800000, max=3214} ms, distance = 100000.0
threads = 4
dimensions = 32
ImmutablePoint took LongSummaryStatistics{count=5, sum=58, min=11,
average=11.600000, max=12} ms, distance = 10000.0
AtomicReferencePoint took LongSummaryStatistics{count=5, sum=144, min=26,
average=28.800000, max=35} ms, distance = 200000.0
CopyOnWritePoint took LongSummaryStatistics{count=5, sum=147, min=26,
average=29.400000, max=32} ms, distance = 200000.0
ModCountPoint took LongSummaryStatistics{count=5, sum=164, min=31,
average=32.800000, max=35} ms, distance = 200000.0
SynchronizedPoint took LongSummaryStatistics{count=5, sum=206, min=40,
average=41.200000, max=42} ms, distance = 200000.0
AlternateCopiesPoint took LongSummaryStatistics{count=5, sum=216, min=39,
average=43.200000, max=54} ms, distance = 200000.0
StampedPoint took LongSummaryStatistics{count=5, sum=230, min=41,
average=46.000000, max=51} ms, distance = 200000.0
threads = 4
dimensions = 512
ImmutablePoint took LongSummaryStatistics{count=5, sum=527, min=96,
average=105.400000, max=117} ms, distance = 10000.0
CopyOnWritePoint took LongSummaryStatistics{count=5, sum=1189, min=206,
average=237.800000, max=261} ms, distance = 200000.0
StampedPoint took LongSummaryStatistics{count=5, sum=1460, min=281,
average=292.000000, max=305} ms, distance = 200000.0
AtomicReferencePoint took LongSummaryStatistics{count=5, sum=1532, min=281,
average=306.400000, max=329} ms, distance = 200000.0
SynchronizedPoint took LongSummaryStatistics{count=5, sum=1642, min=319,
average=328.400000, max=341} ms, distance = 200000.0
ModCountPoint took LongSummaryStatistics{count=5, sum=1732, min=310,
average=346.400000, max=371} ms, distance = 200000.0
AlternateCopiesPoint took LongSummaryStatistics{count=5, sum=2135, min=388,
average=427.000000, max=451} ms, distance = 200000.0
threads = 4
dimensions = 8192
ImmutablePoint took LongSummaryStatistics{count=5, sum=9580, min=1695,
average=1916.000000, max=2074} ms, distance = 10000.0
StampedPoint took LongSummaryStatistics{count=5, sum=18757, min=3555,
average=3751.400000, max=4013} ms, distance = 200000.0
CopyOnWritePoint took LongSummaryStatistics{count=5, sum=20065, min=3604,
average=4013.000000, max=4364} ms, distance = 200000.0
SynchronizedPoint took LongSummaryStatistics{count=5, sum=23181, min=4333,
average=4636.200000, max=4964} ms, distance = 200000.0
ModCountPoint took LongSummaryStatistics{count=5, sum=23898, min=4138,
average=4779.600000, max=5312} ms, distance = 200000.0
AtomicReferencePoint took LongSummaryStatistics{count=5, sum=27209,
min=4845, average=5441.800000, max=6061} ms, distance = 200000.0
AlternateCopiesPoint took LongSummaryStatistics{count=5, sum=35364,
min=6762, average=7072.800000, max=7455} ms, distance = 200000.0
threads = 8
dimensions = 32
ImmutablePoint took LongSummaryStatistics{count=5, sum=107, min=20,
average=21.400000, max=23} ms, distance = 10000.0
CopyOnWritePoint took LongSummaryStatistics{count=5, sum=430, min=71,
average=86.000000, max=94} ms, distance = 400000.0
ModCountPoint took LongSummaryStatistics{count=5, sum=480, min=80,
average=96.000000, max=102} ms, distance = 400000.0
AtomicReferencePoint took LongSummaryStatistics{count=5, sum=525, min=95,
average=105.000000, max=110} ms, distance = 400000.0
SynchronizedPoint took LongSummaryStatistics{count=5, sum=588, min=111,
average=117.600000, max=121} ms, distance = 400000.0
AlternateCopiesPoint took LongSummaryStatistics{count=5, sum=666, min=121,
average=133.200000, max=144} ms, distance = 400000.0
StampedPoint took LongSummaryStatistics{count=5, sum=749, min=144,
average=149.800000, max=158} ms, distance = 400000.0
threads = 8
dimensions = 512
ImmutablePoint took LongSummaryStatistics{count=5, sum=912, min=176,
average=182.400000, max=189} ms, distance = 10000.0
CopyOnWritePoint took LongSummaryStatistics{count=5, sum=2811, min=539,
average=562.200000, max=609} ms, distance = 400000.0
StampedPoint took LongSummaryStatistics{count=5, sum=3888, min=754,
average=777.600000, max=833} ms, distance = 400000.0
SynchronizedPoint took LongSummaryStatistics{count=5, sum=4233, min=815,
average=846.600000, max=885} ms, distance = 400000.0
ModCountPoint took LongSummaryStatistics{count=5, sum=4389, min=849,
average=877.800000, max=943} ms, distance = 400000.0
AlternateCopiesPoint took LongSummaryStatistics{count=5, sum=5536,
min=1077, average=1107.200000, max=1170} ms, distance = 400000.0
AtomicReferencePoint took LongSummaryStatistics{count=5, sum=5972,
min=1168, average=1194.400000, max=1285} ms, distance = 400000.0
threads = 8
dimensions = 8192
ImmutablePoint took LongSummaryStatistics{count=5, sum=16762, min=3237,
average=3352.400000, max=3497} ms, distance = 10000.0
StampedPoint took LongSummaryStatistics{count=5, sum=39913, min=7804,
average=7982.600000, max=8123} ms, distance = 400000.0
CopyOnWritePoint took LongSummaryStatistics{count=5, sum=43813, min=8611,
average=8762.600000, max=8982} ms, distance = 400000.0
SynchronizedPoint took LongSummaryStatistics{count=5, sum=50976, min=9741,
average=10195.200000, max=10798} ms, distance = 400000.0
ModCountPoint took LongSummaryStatistics{count=5, sum=53161, min=10493,
average=10632.200000, max=10796} ms, distance = 400000.0
AlternateCopiesPoint took LongSummaryStatistics{count=5, sum=73980,
min=14594, average=14796.000000, max=14966} ms, distance = 400000.0
AtomicReferencePoint took LongSummaryStatistics{count=5, sum=96645,
min=18994, average=19329.000000, max=19831} ms, distance = 400000.0
Summary
ImmutablePoint scored 54 points
CopyOnWritePoint scored 40 points
StampedPoint scored 30 points
ModCountPoint scored 25 points
SynchronizedPoint scored 19 points
AtomicReferencePoint scored 16 points
AlternateCopiesPoint scored 5 points
BUILD SUCCESSFUL (total time: 10 minutes 54 seconds)

As you can see Immutable and CopyOnWrite both do well.

Same caveat as before for Immutable, doesn't behave like other
implementations and to use this technique you need to restructure your code.

Code below.

Cheers,

 -- Howard.

==========================================================================================

package threadsafepoint;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.LongSummaryStatistics;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.StampedLock;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import java.util.function.Function;
import java.util.stream.DoubleStream;

/**
 * Comparison of thread safety techniques (example from
www.javaspecialists.eu/archive/Issue215.html).
 *
 * @author Howard Lovatt
 * @version 1 18/12/13
 * @version 2 23/12/13: Incorporated Heinz's comments (18/12/13),
'streamified', & extra implementations
 * @version 3 28/12/13: Incorporates most of Heinz's comments (22/12/13),
added a version of Pedro Ramalhete's
 *   left-right technique (25/12/13), added test for more threads, and
added tests for larger data sets
 */
public class ThreadSafePoint {

  interface Point {
    double distanceFromOrigin();
    Point move(int[] deltas);
    int dimensions();
    static double distanceFromOrigin(final int[] ordinates) {
      return Math.sqrt(
              IntStream.of(ordinates)
                      .unordered()
                      .mapToDouble((ordinate) -> (double)ordinate *
(double)ordinate)
                      .sum());
    }
    static int[] move(final int[] ordinates, final int[] deltas) {
      IntStream.range(0, ordinates.length)
              .unordered()
              .forEach((i) -> ordinates[i] += deltas[i]);
      return ordinates;
    }
  }

  static class ImmutablePoint implements Point {
    private final int[] ordinates;
    public ImmutablePoint(final int dimensions) {
      this(new int[dimensions]);
    }
    public ImmutablePoint(final int[] ordinates) {
      this.ordinates = ordinates;
    }
    @Override public double distanceFromOrigin() {
      return Point.distanceFromOrigin(ordinates);
    }
    @Override public Point move(final int[] deltas) {
      return new ImmutablePoint(Point.move(ordinates.clone(), deltas));
    }
    @Override public int dimensions() {
      return ordinates.length;
    }
  }

  static class CopyOnWritePoint implements Point {
    private volatile Point current;
    public CopyOnWritePoint(final int dimensions) {
      current = new ImmutablePoint(dimensions);
    }
    @Override public double distanceFromOrigin() {
      return current.distanceFromOrigin();
    }
    @Override public synchronized Point move(final int[] deltas) {
      current = current.move(deltas);
      return this;
    }
    @Override public int dimensions() {
      return current.dimensions();
    }
  }

  static class StampedPoint implements Point { // Effectively Heinz's code
    private static final int retries = 3;
    private int[] ordinates;
    private final StampedLock lock = new StampedLock();
    public StampedPoint(final int dimensions) {
      ordinates = new int[dimensions];
    }
    @Override public double distanceFromOrigin() {
      int[] localOrdinates;
      out:
      {
        // try a few times to do an optimistic read
        for (int i = 0; i < retries; i++) {
          final long stamp = lock.tryOptimisticRead();
          localOrdinates = ordinates;
          if (lock.validate(stamp)) {
            break out;
          }
        }
        // pessimistic read
        final long stamp = lock.readLock();
        try {
          localOrdinates = ordinates;
        } finally {
          lock.unlockRead(stamp);
        }
      }
      return Point.distanceFromOrigin(localOrdinates);
    }
    @Override public Point move(final int[] deltas) {
      final long stamp = lock.writeLock();
      try {
        ordinates = Point.move(ordinates, deltas);
      } finally {
        lock.unlockWrite(stamp);
      }
      return this;
    }
    @Override public int dimensions() {
      return ordinates.length;
    }
  }

  static class SynchronizedPoint implements Point {
    private int[] ordinates;
    public SynchronizedPoint(final int dimensions) {
      ordinates = new int[dimensions];
    }
    @Override public synchronized double distanceFromOrigin() {
      return Point.distanceFromOrigin(ordinates);
    }
    @Override public synchronized Point move(final int[] deltas) {
      ordinates = Point.move(ordinates, deltas);
      return this;
    }
    @Override public int dimensions() {
      return ordinates.length;
    }
  }

  static class ModCountPoint implements Point { // Very similer in design
to StampedPoint!
    private static final int retries = 10;
    private final AtomicInteger modCount = new AtomicInteger();
    private int[] ordinates;
    public ModCountPoint(final int dimensions) {
      ordinates = new int[dimensions];
    }
    @Override public double distanceFromOrigin() {
      for (int i = 0; i < retries; i++) {
        final int startCount = modCount.get();
        final double distance = Point.distanceFromOrigin(ordinates);
        if (startCount == modCount.get()) {
          return distance;
        }
      }
      synchronized (this) {
        return Point.distanceFromOrigin(ordinates);
      }
    }
    @Override public synchronized Point move(final int[] deltas) {
      modCount.incrementAndGet();
      ordinates = Point.move(ordinates, deltas);
      return this;
    }
    @Override public int dimensions() {
      return ordinates.length;
    }
  }

  static class AlternateCopiesPoint implements Point { // Similar to Pedro
Ramalhete's left-right technique (25/12/13)
    private volatile int[] read;
    private int[] write;

    public AlternateCopiesPoint(final int dimensions) {
      read = new int[dimensions];
      write = new int[dimensions];
    }
    @Override public double distanceFromOrigin() {
      return Point.distanceFromOrigin(read);
    }

    @Override public synchronized Point move(final int[] deltas) {
      final int[] copyOfRead = read;
      final int[] copyOfWrite = write;
      read = Point.move(copyOfWrite, deltas);
      write = Point.move(copyOfRead, deltas);
      return this;
    }
    @Override public int dimensions() {
      return read.length;
    }
  }

  static class AtomicReferencePoint implements Point { // Essentially
Heinz's NonBlockingPoint (22/12/13)
    private final AtomicReference<int[]> ordinates;
    public AtomicReferencePoint(final int dimensions) {
      ordinates = new AtomicReference<int[]>(new int[dimensions]);
    }
    @Override public double distanceFromOrigin() {
      return Point.distanceFromOrigin(ordinates.get());
    }
    @Override public Point move(final int[] deltas) {
      int[] expected;
      int[] updated;
      do {
        expected = ordinates.get();
        updated = Point.move(expected.clone(), deltas);
      } while(!ordinates.compareAndSet(expected, updated));
      return this;
    }
    @Override public int dimensions() {
      return ordinates.get().length;
    }
  }

  private static final int times = 10_000;

  private static void checkMagnitude(final Point point, final double...
oldHolder) {
    final double old = oldHolder[0];
    if (old < 0) {
      return; // already failed
    }
    final double current = point.distanceFromOrigin();
    oldHolder[0] = current > old ? current : -1; // test for failure
  }

  private static double testMove(final Point point, final int[] deltas) {
    final double[] old = {0}; // Need to use a side-effect because you can
only view one item at a time in a stream
    final Point[] current = {point};
    IntStream.range(0, times).forEach((notUsed) -> {
      current[0] = current[0].move(deltas);
      checkMagnitude(current[0], old);
    });
    return old[0];
  }

  private static class TimeAndTest {
    final boolean failed;
    final long time;
    final double maxDistance;
    TimeAndTest(final long time, final double... distances) {
      failed = DoubleStream.of(distances)
              .unordered()
              .anyMatch((distance) -> distance < 0);
      this.time = time;
      maxDistance = DoubleStream.of(distances)
              .unordered()
              .max()
              .orElse(-1);
    }
  }

  private static TimeAndTest timeAndTest(final int threads, final Point
point) {
    System.gc();
    System.gc();
    final long start = System.currentTimeMillis();
    final int[] deltas = new int[point.dimensions()];
    deltas[0] = 1;
    final double[] distances = IntStream.range(0, threads)
            .unordered()
            .parallel()
            .mapToDouble((notUsed) -> testMove(point, deltas))
            .toArray(); // Need an array because of multiple traversals
    return new TimeAndTest(System.currentTimeMillis() - start, distances);
  }

  private static BiConsumer<Point, List<TimeAndTest>>
conditionallyAdd(final int threads) {
    return (point, timeAndTests) -> {
      final TimeAndTest timeAndTest = timeAndTest(threads, point);
      if (!timeAndTest.failed) {
        timeAndTests.add(timeAndTest);
      }
    };
  }

  private static Consumer<Entry<Point, List<TimeAndTest>>>
printForAPoint(final Map<Class<?>, Integer> scores, final int[]
currentScore) {
    return (pointAndTests) -> {
      currentScore[0]--;
      scores.merge(pointAndTests.getKey().getClass(), currentScore[0],
Integer::sum);
      final String name = pointAndTests.getKey().getClass().getSimpleName();
      final LongSummaryStatistics timeStats =
pointAndTests.getValue().stream()
              .collect(Collectors.summarizingLong((timeAndTest) ->
timeAndTest.time));
      final double distance = pointAndTests.getValue().stream()
              .mapToDouble((timeAndTest) -> timeAndTest.maxDistance)
              .max()
              .orElse(-1);
      System.out.println("\t\t" + name + " took " + timeStats + " ms,
distance = " + distance);
    };
  }

  private static long sumTimes(final Entry<Point, List<TimeAndTest>>
pointAndTests) {
    return pointAndTests.getValue().stream()
            .unordered()
            .mapToLong((timeAndTests) -> timeAndTests.time)
            .sum();
  }

  private static int compareResults(final Entry<Point, List<TimeAndTest>>
left, final Entry<Point, List<TimeAndTest>> right) {
    final long difference = sumTimes(left) - sumTimes(right);
    return difference < 0 ? -1 : difference == 0 ? 0 : 1;
  }

  private static void printForRepeats(final Map<Class<?>, Integer> scores,
final int repeats, final int threads, final Point... points) {
    final int[] currentScore = {points.length};
    final Map<Point, List<TimeAndTest>> results = Stream.of(points) // Use
List instead of Stream.Builder because want multiple traversals
            .collect(Collectors.toMap(Function.identity(), (notUsed) -> new
ArrayList<TimeAndTest>()));
    IntStream.range(0, repeats)
            .forEach((notUsed) ->
results.forEach(ThreadSafePoint.conditionallyAdd(threads)));
    results.entrySet().stream()
            .sorted(ThreadSafePoint::compareResults)
            .forEach(ThreadSafePoint.printForAPoint(scores, currentScore));
  }

  private static void printForRepeatsAndDimensions(
          final Map<Class<?>, Integer> scores,
          final int repeats,
          final int threads,
          final Point... points) {
    System.out.println("\tdimensions = " + points[0].dimensions());
    printForRepeats(scores, repeats, threads, points);
  }

  private static void printForRepeatsDimensionsAndThreads(
          final Map<Class<?>, Integer> scores,
          final int repeats,
          final int threads,
          final Point... points) {
    System.out.println("threads = " + threads);
    printForRepeatsAndDimensions(scores, repeats, threads, points);
  }

  public static void main(final String... notUsed) {
    final Map<Class<?>, Integer> scores = new HashMap<>();
    IntStream.of(2, 4, 8) // List of thread numberss (contention)
            .forEach((threads) -> IntStream.of(32, 512, 8192) // List of
dimension numberss (problem sizes)
                    .forEach((dimensions) ->
printForRepeatsDimensionsAndThreads(
                            scores, // Keep a tally of ranking
                            5, // Number of runs to average over
                            threads, // Number of threads
                            new ImmutablePoint(dimensions), // dimensions
sets the problem size
                            new CopyOnWritePoint(dimensions),
                            new StampedPoint(dimensions),
                            new SynchronizedPoint(dimensions),
                            new ModCountPoint(dimensions),
                            new AlternateCopiesPoint(dimensions),
                            new AtomicReferencePoint(dimensions))));
    System.out.println("Summary");
    scores.entrySet().stream()
          .sorted((left, right) -> right.getValue() - left.getValue())
          .forEach((pointAndScore) -> System.out.println(
                  "\t"
                  + pointAndScore.getKey().getSimpleName()
                  + " scored "
                  + pointAndScore.getValue()
                  + " points"));
  }

}


On 24 December 2013 23:21, Howard Lovatt <howard.lovatt at gmail.com> wrote:

> Hi Heinz,
>
> Sure - I agree with all your points. It would be interesting to see how
> you benchmark the different implementations. As I have repeatedly said, I
> am not happy with my benchmarking.
>
> A couple of more detailed points:
>
> 1. I haven't noticed any difference between using an Executor and a
> parallel Stream and the coding for a parallel Stream is simpler. But you
> are right, potentially a dedicated Thread, an Executor, and a parallel
> Stream could all give different results.
>
> 2. To use an immutable you have to structure the application differently,
> e.g. Interested parties register as Listeners. Therefore Immutable and the
> others are not directly comparable.
>
> Seasons greetings,
>
>  -- Howard.
>
> Sent from my iPad
>
> On 22 Dec 2013, at 6:06 pm, "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
> wrote:
>
> Hi Howard & Aaron,
>
> Indeed, it takes a lot of time and energy to test this type of construct
> for performance, maybe a couple of weeks of hard work.  And even then, one
> is always left with the niggling suspicion that one has missed an important
> side-effect.
>
> Just some examples:
>
> 1. I doubt that your system will be throttled on GC stop-the-world.
> Object creation could be a bottleneck though.  Thus one way to reduce the
> wait times would be to decrease the max memory for the test.  You would
> then also not need the call to explicit GC.
>
> 2. When you use polymorphism, the method calls for the first subclass can
> be inlined.  Once the second subclass is loaded, it uses a simple if-else.
> It is slower than with one, but not as bad as three.  etc.  Here are two
> articles that describe this:
> http://www.javaspecialists.eu/archive/Issue157.html and
> http://www.javaspecialists.eu/archive/Issue158.html In your code, you put
> the ImmutablePoint first, which gives it an advantage over the others.
>
> 3. I would still argue that your ImmutablePoint is not a valid
> implementation to compare against, since the resulting Point object is only
> stored in an unshared array wrapper held in a local variable.  It would
> need to be stored somewhere else, such as a volatile field or probably an
> AtomicReference.  This NonblockingPoint would be a better approach
> (although using Unsafe with a volatile reference could improve performance
> a bit):
>
>   static class NonblockingPoint implements Point {
>     private final AtomicReference<int[]> xy = new AtomicReference<>(new
> int[2]);
>     @Override public double distanceFromOrigin() {
>       int[] xy = this.xy.get();
>       return Math.hypot(xy[0], xy[1]);
>     }
>     @Override public void move(int deltaX, int deltaY) {
>       int[] current, next;
>       do {
>         current = xy.get();
>         next = new int[] { current[0] + deltaX, current[1] + deltaY };
>       } while(!xy.compareAndSet(current, next));
>     }
>   }
>
>
> And a bunch of other things.  I personally would keep the code as basic as
> possible and shy away from Streams.  Firstly, it could introduce some
> hidden performance bottlenecks and secondly, it prevents you from comparing
> to Java7 (StampedLock is backported to Java7).
>
> Regards
>
> Heinz
> --
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Oracle Java Champion 2005-2013
> JavaOne Rock Star Speaker 2012http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
>
>
> Howard Lovatt wrote:
>
> You make a good point and it is one of the areas that I worry about, along with problem size, computation per contention, processor architecture, number of cores, and JVMs. The problem I have is that it is impractical to test every combination of problem size, computation length, number of threads, and balance of read and write on numerous processor types with different core counts and different JVMs. I would find it easier if there was an approximate computation model that provided some guidance and cut down the number of combinations. But I guess such a model doesn't exist :(
>
> Sent from my iPad
>
>
>
>  On 23 Dec 2013, at 11:51 pm, Aaron Grunthal <aaron.grunthal at infinite-source.de> <aaron.grunthal at infinite-source.de> wrote:
>
>
>
>  On 23.12.2013 05:12, Howard Lovatt wrote:
>
> The test uses two threads
>
>
>  Lock performance depends a lot on contention and number of threads involved. It's likely that those performance figures will change as you add more threads or alter the balance between reads and writes. Reducing it to a single scenario is probably not very informative. Especially considering that stamped lock seems to be designed for scenarios where reads outweigh writes.
>
> - Aaron
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>  _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
  -- Howard.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131228/0c79b972/attachment-0001.html>

From howard.lovatt at gmail.com  Sat Dec 28 04:42:03 2013
From: howard.lovatt at gmail.com (Howard Lovatt)
Date: Sat, 28 Dec 2013 20:42:03 +1100
Subject: [concurrency-interest] Left-Right - A new concurrency control
	technique
In-Reply-To: <CAAApjO21nDTbVJhmjU0F+dTgjn5NuQeq3qC1w=hXRJZLZ0idyA@mail.gmail.com>
References: <CAAApjO21nDTbVJhmjU0F+dTgjn5NuQeq3qC1w=hXRJZLZ0idyA@mail.gmail.com>
Message-ID: <CACR_FB71Xc02y6tAGnCr5MucDDNA5EReU5O4ONt-BL5rYT5fxw@mail.gmail.com>

Hi Pedro,

I think implemented a version of your left-right concept here:

http://cs.oswego.edu/pipermail/concurrency-interest/2013-December/012140.html

It didn't do as well in my tests as yours. This could be because I got it
wrong! Or because my tests have the same number of reads as writes.

To add to Brian Goetz's comments re. scientific programming. It is
certainly a common technique to re-use the storage in a left-right fashion
as you describe (though the terminology is different), e.g. image
processing and finite difference. However the input set is purely read and
the output purely written, therefore there are no concurrent conflicts and
no need to perform the calculation twice. Thus for this type of
manipulation a left-right type approach works very well. A left-right type
of approach with pure read and pure write buffers that are swapped is also
the approach GPUs are often programmed to use.

Anyway, interested in what you think?

Cheers,

 -- Howard.


On 25 December 2013 23:44, Pedro Ramalhete <pramalhe at gmail.com> wrote:

> Hello,
>
> We are pleased to announce a new concurrency control technique which we
> named "Left-Right" and that allows Wait-Free Populations Oblivious read
> operations. The easiest way to explain what it is, is to say that it's a
> "kind of" Reader-Writer Lock that doesn't block for Readers, which makes it
> ideal for low-latency and real-time deployment scenarios:
>
> http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/leftright-extended.pdf
>
> In case you missed it above, this means that you can have one Writer and
> multiple Readers executing simultaneously, and unlike optimistic read
> locks, you don't have to worry about atomicity, or memory management, or
> invariants.
>
> Similarly to a Reader-Writer lock, it can be applied to any
> (non-thread-safe) data structure and enable it to be used in a
> multi-threaded application, where it will be Blocking for Writers, and
> Wait-Free for Readers. It can be implemented in Java, Scala, C11, or C++1x.
> Sample source code can be seen here:
>
> http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/LRScalableTreeSet.java
>
> http://sourceforge.net/projects/ccfreaks/files/java/src/com/concurrencyfreaks/leftright/LRScalableGuard.java
>
> Its two main innovations are, the usage of two instances, and the new
> concurrency control algorithm whose novel state machine gives wait-free
> guarantees for read operations.
>
>
> There is another technique which also uses two instances but requires 3
> locks, which perhaps has already been discovered, that we named "Double
> Instance Locking" and it is much easier to understand and implement, but it
> is only Lock-Free for read operations:
>
> http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/DoubleInstanceLocking.pptx
>
> http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/DoubleInstanceLockGuard.java
> http://concurrencyfreaks.com/2013/11/double-instance-locking.html
>
> We would like to hear expert's comments on it   ;)
>
> Merry Christmas,
> Pedro & Andreia
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
  -- Howard.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131228/a6108e55/attachment.html>

From pramalhe at gmail.com  Sat Dec 28 05:43:31 2013
From: pramalhe at gmail.com (Pedro Ramalhete)
Date: Sat, 28 Dec 2013 11:43:31 +0100
Subject: [concurrency-interest] Left-Right - A new concurrency control
	technique
In-Reply-To: <CACR_FB71Xc02y6tAGnCr5MucDDNA5EReU5O4ONt-BL5rYT5fxw@mail.gmail.com>
References: <CAAApjO21nDTbVJhmjU0F+dTgjn5NuQeq3qC1w=hXRJZLZ0idyA@mail.gmail.com>
	<CACR_FB71Xc02y6tAGnCr5MucDDNA5EReU5O4ONt-BL5rYT5fxw@mail.gmail.com>
Message-ID: <CAAApjO3xxAG1WNFu1EtLRXscBMxkVdvT8fj2VuurAnTVSsmuZg@mail.gmail.com>

Hi Howard,

The implementation you show is not the Left-Right technique. You can
download it from here:
http://sourceforge.net/projects/ccfreaks/files/java/src/com/concurrencyfreaks/leftright/LRScalableGuard.java/download

Anyways, if you have about the same number of read and write operations,
the LR will not be interesting to you. The LR gives good results when there
are a lot more reads than writes, or with dedicated threads doing only
reads, or if you care about the latency of the reads.

Thanks,
Pedro


On Sat, Dec 28, 2013 at 10:42 AM, Howard Lovatt <howard.lovatt at gmail.com>wrote:

> Hi Pedro,
>
> I think implemented a version of your left-right concept here:
>
>
> http://cs.oswego.edu/pipermail/concurrency-interest/2013-December/012140.html
>
> It didn't do as well in my tests as yours. This could be because I got it
> wrong! Or because my tests have the same number of reads as writes.
>
> To add to Brian Goetz's comments re. scientific programming. It is
> certainly a common technique to re-use the storage in a left-right fashion
> as you describe (though the terminology is different), e.g. image
> processing and finite difference. However the input set is purely read and
> the output purely written, therefore there are no concurrent conflicts and
> no need to perform the calculation twice. Thus for this type of
> manipulation a left-right type approach works very well. A left-right type
> of approach with pure read and pure write buffers that are swapped is also
> the approach GPUs are often programmed to use.
>
> Anyway, interested in what you think?
>
> Cheers,
>
>  -- Howard.
>
>
> On 25 December 2013 23:44, Pedro Ramalhete <pramalhe at gmail.com> wrote:
>
>> Hello,
>>
>> We are pleased to announce a new concurrency control technique which we
>> named "Left-Right" and that allows Wait-Free Populations Oblivious read
>> operations. The easiest way to explain what it is, is to say that it's a
>> "kind of" Reader-Writer Lock that doesn't block for Readers, which makes it
>> ideal for low-latency and real-time deployment scenarios:
>>
>> http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/leftright-extended.pdf
>>
>> In case you missed it above, this means that you can have one Writer and
>> multiple Readers executing simultaneously, and unlike optimistic read
>> locks, you don't have to worry about atomicity, or memory management, or
>> invariants.
>>
>> Similarly to a Reader-Writer lock, it can be applied to any
>> (non-thread-safe) data structure and enable it to be used in a
>> multi-threaded application, where it will be Blocking for Writers, and
>> Wait-Free for Readers. It can be implemented in Java, Scala, C11, or C++1x.
>> Sample source code can be seen here:
>>
>> http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/LRScalableTreeSet.java
>>
>> http://sourceforge.net/projects/ccfreaks/files/java/src/com/concurrencyfreaks/leftright/LRScalableGuard.java
>>
>> Its two main innovations are, the usage of two instances, and the new
>> concurrency control algorithm whose novel state machine gives wait-free
>> guarantees for read operations.
>>
>>
>> There is another technique which also uses two instances but requires 3
>> locks, which perhaps has already been discovered, that we named "Double
>> Instance Locking" and it is much easier to understand and implement, but it
>> is only Lock-Free for read operations:
>>
>> http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/DoubleInstanceLocking.pptx
>>
>> http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/DoubleInstanceLockGuard.java
>> http://concurrencyfreaks.com/2013/11/double-instance-locking.html
>>
>> We would like to hear expert's comments on it   ;)
>>
>> Merry Christmas,
>> Pedro & Andreia
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> --
>   -- Howard.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131228/b9a016b4/attachment.html>

From hjohn at xs4all.nl  Sat Dec 28 06:34:27 2013
From: hjohn at xs4all.nl (John Hendrikx)
Date: Sat, 28 Dec 2013 12:34:27 +0100
Subject: [concurrency-interest] Solution for running several tasks
 serially on multiple executors
In-Reply-To: <52BC73D3.40602@oracle.com>
References: <52BC0A90.3000600@xs4all.nl> <52BC73D3.40602@oracle.com>
Message-ID: <52BEB743.2020500@xs4all.nl>

Non-blocking API's would solve a lot of these problems I'd have to 
agree.  I'll look into how complicated things get when using 
non-blocking JDBC / HTTP requests / File I/O... my current solution 
however is not working badly either, where each Task is split up into 
several sub-steps, each with an associated Executor.  Although it breaks 
up the workflow somewhat (which can be annoying when previous results 
are needed in later steps), I think it may be less drastic than 
rewriting these steps to use non-blocking I/O.  I'm fine with Threads 
blocking, as long as they're blocking on something related (ie, Database 
threads can block when waiting on the Database, but I don't want 
Database threads blocked because there's many outstanding Web requests.. 
and vice versa).  Currently I reserve 5 threads for Database access, 5 
threads for File I/O, and two threads for each Web API (with a web API 
dependent rate limiter).  Each set has its own Executor.

I also thought about light-weight threads myself (ie, calling back into 
somekind of scheduler to run something else without returning from the 
current task), but I think it will cause problems with unrelated tasks 
blocking each other for no reason -- also controlling the execution 
order will be almost impossible.  Stack size could also be problematic, 
but I suppose that's still better than spawning a new Thread.

--John

On 26/12/2013 19:22, Nathan Reynolds wrote:
> To avoid using a lot of threads on the web requests, I would recommend 
> using non-blocking I/O.  So, step 2 would be the following...
>
> 2a) Send some web requests
> 2b) Receive web response, store result in database, return result and exit
>
> This way step 2a and 2b are very fast.  A single helper thread does a 
> select() call on all of the sockets that are waiting for web 
> responses.  As responses come back, the helper thread creates a job 
> for 2b and submits it to the pool.  The thread that picks up the job 
> will read the socket and finish the processing.
>
> If all steps were made non-blocking, you can probably limit the number 
> of threads to the number of logical cores on the machine.  If you use 
> fewer threads, then you wouldn't be able to use the full compute power 
> of the box.  If you use more threads, then threads will sit in the OS 
> scheduler's run queue waiting for a logical core.
>
> Another way of looking at this... Every blocking operation requires 
> adding and "wasting" 1 more thread.
>
> Many APIs don't have non-blocking alternatives.  I have wondered if it 
> would be worth the effort to introduce new non-blocking APIs.
>
> Recently, someone posted to this group a library which implements 
> light-weight threads.  Blocking operations cause the stack to be saved 
> and the light-weight thread to context switch off and another thread 
> to context switch on.  This seems like a great solution.  It allows 
> for writing code without having to worry about blocking.  It allows 
> for running the bare minimum number of threads.  Unfortunately, it 
> can't be used everywhere.  Some servers have call stacks 100s of 
> methods deep with a blocking operation at the top.  It would be very 
> painful to save and restore the entire stack.
> -Nathan
> On 12/26/2013 3:53 AM, John Hendrikx wrote:
>> Hi List,
>>
>> I have a use case which I'd like to use the concurrency package for, 
>> but cannot find a solution for without writing some support code of 
>> my own.
>>
>> Basically, I need to run a few hundred to a few thousand independent  
>> tasks, which can complete in any order.  I use a ThreadPoolExecutor 
>> for this.  Some of these tasks can block for several seconds, while 
>> others will complete in just a few milliseconds.  Inevitably, the 
>> blocking tasks will dominate the worker threads, and short running 
>> tasks get delayed, leaving my system not as responsive as desired -- 
>> I'd prefer the short running tasks to be prioritized over the long 
>> running ones.
>>
>> Most of these tasks however generally will run fast, except if there 
>> is a cache miss (say a database is missing an entry, and it needs to 
>> be fetched from the web).  Most tasks therefore do something like:
>>
>> 1) Check database, if present, return result and exit
>> 2) Do some web requests, store result in database, return result and 
>> exit
>>
>> So, my thinking was, I reserve a ThreadPoolExecutor for "fast" task 
>> steps, and one for the "slow" task steps.  Therefore I split up the 
>> tasks into two or more steps -- of course, while the main tasks can 
>> run in any order, the steps of one task must run serially.
>>
>> I created a helper class that allows me to break up these tasks into 
>> multiple steps, where each step is a Runnable + Executor.  So for 
>> example:
>>
>> new TaskStep(FAST_EXECUTOR, new CheckDatabaseRunnable());
>> new TaskStep(SLOW_EXECUTOR, new CheckWebRunnable());
>>
>> The helper class will take these steps, wrap the Runnable with a 
>> small piece of logic that will run the next step (but only if the 
>> first step didn't deliver results), and then just starts the first 
>> TaskStep.
>>
>> Crucial is that the "fast" step actually exits and releases the 
>> thread it ran on without waiting for the "slow" step to complete 
>> (which I think rules out the ForkJoinPool solution as threads are 
>> joined there) -- the whole point is to keep the "fast" 
>> ThreadPoolExecutor fast without its threads ending up waiting for web 
>> requests to complete, blocking unrelated tasks that might be serviced 
>> fast from the cache.  Giving the "fast" pool a few thousand threads 
>> to work with didn't appeal to me (I read that most VM's are limited 
>> to a few thousand to tens of thousands of threads, and I'd like to 
>> stay far away from such limitations).
>>
>> The above example can be extended further and I've added more 
>> Executors now that for example throttle certain task steps -- some 
>> web API's limit how fast requests are allowed and so I figured, I 
>> could just let an Executor handle the throttling completely 
>> transparently by delaying task steps according to their 
>> specifications.  Basically, the tasks now can have multiple steps, 
>> each step being associated with an Executor, and a single task can 
>> therefore hop between Executors several times before completing 
>> (while all steps are still executed serially).  When sequential steps 
>> run on the same executor, the system even runs the next step "inline" 
>> instead of queueing it up with the same executor:
>>
>>   public void execute(Runnable command) {
>>     if(threadFactoryWrapper.isOurThread(Thread.currentThread())) {
>>       command.run();
>>     }
>>     else {
>>       executor.execute(command);
>>     }
>>   }
>>
>> Anyway, I found this an interesting use case, and I was hoping the 
>> concurrency package could help me with it (and it has ofcourse).  It 
>> just seemed to me that something like this could already be part of 
>> it (ForkJoinPool has some similarities with this case I think) and 
>> I'm just missing something.
>>
>> --John
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131228/0d48b1fd/attachment-0001.html>

From alexei.kaigorodov at gmail.com  Sat Dec 28 08:49:56 2013
From: alexei.kaigorodov at gmail.com (Alexei Kaigorodov)
Date: Sat, 28 Dec 2013 13:49:56 +0000 (UTC)
Subject: [concurrency-interest] Solution for running several tasks
	serially on multiple executors
References: <52BC0A90.3000600@xs4all.nl> <52BC73D3.40602@oracle.com>
Message-ID: <loom.20131228T143634-887@post.gmane.org>

Nathan Reynolds <nathan.reynolds <at> oracle.com> writes:

>       Many APIs don't have non-blocking alternatives.  I have wondered
>       if it would be worth the effort to introduce new non-blocking
>       APIs.
Yes it would! And it should have some theoretical foundation. I believe it
must be colored Petry nets, which closely corresponds to lazy evaluations.
The idea is simple: unit of work (transition) starts computing when all its
arguments (places) are ready - what can be more intuitive, understandable,
easy to implement, and parallel?  
I experimented with such API and found it simplifies asynchronous
programming, including NIO-like networking.
Such an API should include:
- basic transition class, which implements Runnable, and is submitted to a
threadpool when its inputs are ready
- several kinds of places to hold arguments - token counters (holders of
non-coloured tokens), collections for coloured tokens (mainly, bounded and
unbounded queues).
In this paradigm, AsynchronousSocketChannel is a transition with single
input place which accepts ByteBuffers and single output place where
ByteBuffers after IO operation are put.
AsynchronousServerSocketChannel is a transition with single input token
counter (number of opened connections), which issues
AsynchronousSocketChannels to its output. When AsynchronousSocketChannels is
closed, connection counter is increased.

>       Recently, someone posted to this group a library which implements
>       light-weight threads.  Blocking operations cause the stack to be
>       saved and the light-weight thread to context switch off and
>       another thread to context switch on.  This seems like a great
>       solution.  It allows for writing code without having to worry
>       about blocking.  It allows for running the bare minimum number of
>       threads.  Unfortunately, it can't be used everywhere.  Some
>       servers have call stacks 100s of methods deep with a blocking
>       operation at the top.  It would be very painful to save and
>       restore the entire stack.-Nathan
Yes, light-weight threads are not universal solution, so
non/blocking/asynchronous API is worth the effort.

On 12/26/2013 3:53 AM, John Hendrikx wrote:
>       Basically, the tasks now can have multiple steps,
>       each step being associated with an Executor, and a single task can
>       therefore hop between Executors several times before completing
>       (while all steps are still executed serially).
Exactly.
Implement each step as class Task extends Runnable which holds a reference
to its executor. Wrap "executor.execute(task)" call in a  Task.execute()
method. Moreover, wrap the call to Task.execute() with methods which just
accept input information and decide which next step to start, if any.

>? When sequential
>       steps run on the same executor, the system even runs the next step
>       "inline" instead of queueing it up with the same executor
Dangerous premature optimization. Postpone it to the time everything works.

--Alexei


From peter.levart at gmail.com  Sat Dec 28 19:28:38 2013
From: peter.levart at gmail.com (Peter Levart)
Date: Sun, 29 Dec 2013 01:28:38 +0100
Subject: [concurrency-interest] Left-Right - A new concurrency control
 technique
In-Reply-To: <CAAApjO21nDTbVJhmjU0F+dTgjn5NuQeq3qC1w=hXRJZLZ0idyA@mail.gmail.com>
References: <CAAApjO21nDTbVJhmjU0F+dTgjn5NuQeq3qC1w=hXRJZLZ0idyA@mail.gmail.com>
Message-ID: <52BF6CB6.3040103@gmail.com>

Hello Pedro,

This is a very interesting article. I immediately jumped into 
implementing the basic algorithm myself, but using a slightly different 
coding approach, and, since these are the days of JDK 8, using 
functional interfaces which play nicely with lambdas:

http://cr.openjdk.java.net/~plevart/misc/LeftRight/LeftRight.java

I tried to leverage j.u.c.LongAdder here to implement "readIndaicator" - 
the alternative for "Algorithms 2, 3 and 5" described in paper. But as 
you've written in paper, using a counter for that purpose, it has to be 
sequentially consistent, which you've showed, is not the case for LongAdder:

http://concurrencyfreaks.blogspot.com/2013/09/longadder-is-not-sequentially-consistent.html

LongAdder is not sequentially consistent if used with different 
modification operations - for example using LongAdder.increment() for 
"arrive" and LongAdder.decrement() for "depart" operations, combined 
with LongAdder.sum() == 0L to implement "isEmpty". But you also showed 
that LongAdder is sequentialy consistent if only a single kind of 
modifications are applied to it. For example, only using inclrement() to 
modify, and sum() to read. So I thought using two LongAdders - one for 
ingress, the other for egress, and reading their sum()s in correct order 
(first egress sum, then ingress sum) and comparing them for equality 
would do the job. Am I right?

Regards, Peter

On 12/25/2013 01:44 PM, Pedro Ramalhete wrote:
> Hello,
>
> We are pleased to announce a new concurrency control technique which 
> we named "Left-Right" and that allows Wait-Free Populations Oblivious 
> read operations. The easiest way to explain what it is, is to say that 
> it's a "kind of" Reader-Writer Lock that doesn't block for Readers, 
> which makes it ideal for low-latency and real-time deployment scenarios:
> http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/leftright-extended.pdf
>
> In case you missed it above, this means that you can have one Writer 
> and multiple Readers executing simultaneously, and unlike optimistic 
> read locks, you don't have to worry about atomicity, or memory 
> management, or invariants.
>
> Similarly to a Reader-Writer lock, it can be applied to any 
> (non-thread-safe) data structure and enable it to be used in a 
> multi-threaded application, where it will be Blocking for Writers, and 
> Wait-Free for Readers. It can be implemented in Java, Scala, C11, or 
> C++1x.
> Sample source code can be seen here:
> http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/LRScalableTreeSet.java
> http://sourceforge.net/projects/ccfreaks/files/java/src/com/concurrencyfreaks/leftright/LRScalableGuard.java
>
> Its two main innovations are, the usage of two instances, and the new 
> concurrency control algorithm whose novel state machine gives 
> wait-free guarantees for read operations.
>
>
> There is another technique which also uses two instances but requires 
> 3 locks, which perhaps has already been discovered, that we named 
> "Double Instance Locking" and it is much easier to understand and 
> implement, but it is only Lock-Free for read operations:
> http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/DoubleInstanceLocking.pptx
> http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/DoubleInstanceLockGuard.java
> http://concurrencyfreaks.com/2013/11/double-instance-locking.html
>
> We would like to hear expert's comments on it   ;)
>
> Merry Christmas,
> Pedro & Andreia
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131229/2025ecbc/attachment.html>

From viktor.klang at gmail.com  Mon Dec 30 08:37:29 2013
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Mon, 30 Dec 2013 14:37:29 +0100
Subject: [concurrency-interest] Solution for running several tasks
 serially on multiple executors
In-Reply-To: <loom.20131228T143634-887@post.gmane.org>
References: <52BC0A90.3000600@xs4all.nl> <52BC73D3.40602@oracle.com>
	<loom.20131228T143634-887@post.gmane.org>
Message-ID: <CANPzfU93Pjv-8N9R1YbwB8QHjubw9NwPrwTGixbk5xOJWNNmUg@mail.gmail.com>

For Java9 to have sane async APIs and SPIs would be fabulous.
On Dec 28, 2013 8:59 PM, "Alexei Kaigorodov" <alexei.kaigorodov at gmail.com>
wrote:

> Nathan Reynolds <nathan.reynolds <at> oracle.com> writes:
>
> >       Many APIs don't have non-blocking alternatives.  I have wondered
> >       if it would be worth the effort to introduce new non-blocking
> >       APIs.
> Yes it would! And it should have some theoretical foundation. I believe it
> must be colored Petry nets, which closely corresponds to lazy evaluations.
> The idea is simple: unit of work (transition) starts computing when all its
> arguments (places) are ready - what can be more intuitive, understandable,
> easy to implement, and parallel?
> I experimented with such API and found it simplifies asynchronous
> programming, including NIO-like networking.
> Such an API should include:
> - basic transition class, which implements Runnable, and is submitted to a
> threadpool when its inputs are ready
> - several kinds of places to hold arguments - token counters (holders of
> non-coloured tokens), collections for coloured tokens (mainly, bounded and
> unbounded queues).
> In this paradigm, AsynchronousSocketChannel is a transition with single
> input place which accepts ByteBuffers and single output place where
> ByteBuffers after IO operation are put.
> AsynchronousServerSocketChannel is a transition with single input token
> counter (number of opened connections), which issues
> AsynchronousSocketChannels to its output. When AsynchronousSocketChannels
> is
> closed, connection counter is increased.
>
> >       Recently, someone posted to this group a library which implements
> >       light-weight threads.  Blocking operations cause the stack to be
> >       saved and the light-weight thread to context switch off and
> >       another thread to context switch on.  This seems like a great
> >       solution.  It allows for writing code without having to worry
> >       about blocking.  It allows for running the bare minimum number of
> >       threads.  Unfortunately, it can't be used everywhere.  Some
> >       servers have call stacks 100s of methods deep with a blocking
> >       operation at the top.  It would be very painful to save and
> >       restore the entire stack.-Nathan
> Yes, light-weight threads are not universal solution, so
> non/blocking/asynchronous API is worth the effort.
>
> On 12/26/2013 3:53 AM, John Hendrikx wrote:
> >       Basically, the tasks now can have multiple steps,
> >       each step being associated with an Executor, and a single task can
> >       therefore hop between Executors several times before completing
> >       (while all steps are still executed serially).
> Exactly.
> Implement each step as class Task extends Runnable which holds a reference
> to its executor. Wrap "executor.execute(task)" call in a  Task.execute()
> method. Moreover, wrap the call to Task.execute() with methods which just
> accept input information and decide which next step to start, if any.
>
> >  When sequential
> >       steps run on the same executor, the system even runs the next step
> >       "inline" instead of queueing it up with the same executor
> Dangerous premature optimization. Postpone it to the time everything works.
>
> --Alexei
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131230/972a3f28/attachment.html>

From ron.pressler at gmail.com  Mon Dec 30 13:52:28 2013
From: ron.pressler at gmail.com (Ron Pressler)
Date: Mon, 30 Dec 2013 20:52:28 +0200
Subject: [concurrency-interest] Solution for running several tasks
 serially on multiple executors
In-Reply-To: <52BC73D3.40602@oracle.com>
References: <52BC0A90.3000600@xs4all.nl> <52BC73D3.40602@oracle.com>
Message-ID: <CABg6-qgKFin6JCH80nkwHz8vdRi9i4ip8qiyta0a1Xadeh+Vhg@mail.gmail.com>

On Thu, Dec 26, 2013 at 8:22 PM, Nathan Reynolds <nathan.reynolds at oracle.com
> wrote:
...

>  To avoid using a lot of threads on the web requests, I would recommend
> using non-blocking I/O.  So, step 2 would be the following...
>
> Many APIs don't have non-blocking alternatives.  I have wondered if it
> would be worth the effort to introduce new non-blocking APIs.
>

Yes. :)


>
> Recently, someone posted to this group a library which implements
> light-weight threads.  Blocking operations cause the stack to be saved and
> the light-weight thread to context switch off and another thread to context
> switch on.  This seems like a great solution.  It allows for writing code
> without having to worry about blocking.  It allows for running the bare
> minimum number of threads.  Unfortunately, it can't be used everywhere.
> Some servers have call stacks 100s of methods deep with a blocking
> operation at the top.  It would be very painful to save and restore the
> entire stack.
>
> -Nathan
>
> That would be me. Asynchronous APIs would be beneficial in any case
because our library <https://github.com/puniverse/quasar> basically lets
you turn async calls into fiber-blocking calls (by making the callback
unpark the blocked fiber). If those aren't available (e.g. JDBC) there's
not much to work with rather than re-invert control by running the
thread-blocking operation in a thread pool.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131230/26693222/attachment.html>

From andrew_nuss at yahoo.com  Tue Dec 31 13:38:03 2013
From: andrew_nuss at yahoo.com (Andy Nuss)
Date: Tue, 31 Dec 2013 10:38:03 -0800 (PST)
Subject: [concurrency-interest] newbie question on starting a thread
	anonymous runnable and memory publishing
Message-ID: <1388515083.44089.YahooMailNeo@web141105.mail.bf1.yahoo.com>

Hi,

Lets say I have a class with lots of non-volatile members.? In some function, I change some of these members, and then do:

new Thread(new Runnable() {
??? public void run ()
??? {
??????? ... access the members of the enclosing class at the moment of the start() call

??? }

}).start();

Is the run function guaranteed to see the latest values of the non-volatile members of the enclosing class as they were when the start() call happens?

My guess is yes, based on an answer that I saw previously.


Andy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131231/c9f69552/attachment.html>

From vitalyd at gmail.com  Tue Dec 31 14:27:43 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 31 Dec 2013 14:27:43 -0500
Subject: [concurrency-interest] newbie question on starting a thread
 anonymous runnable and memory publishing
In-Reply-To: <1388515083.44089.YahooMailNeo@web141105.mail.bf1.yahoo.com>
References: <1388515083.44089.YahooMailNeo@web141105.mail.bf1.yahoo.com>
Message-ID: <CAHjP37EGm-Mih492uMJ2jEa7q12HpmWbNrSzA+jOyZGj00HH6Q@mail.gmail.com>

Yes - Thread.start() is a synchronizing action (creates a happens-before
edge with code inside the runnable that thread runs).

Sent from my phone
On Dec 31, 2013 2:00 PM, "Andy Nuss" <andrew_nuss at yahoo.com> wrote:

> Hi,
>
> Lets say I have a class with lots of non-volatile members.  In some
> function, I change some of these members, and then do:
>
> new Thread(new Runnable() {
>     public void run ()
>     {
>         ... access the members of the enclosing class at the moment of the
> start() call
>     }
> }).start();
>
> Is the run function guaranteed to see the latest values of the
> non-volatile members of the enclosing class as they were when the start()
> call happens?
>
> My guess is yes, based on an answer that I saw previously.
>
> Andy
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131231/585a61c7/attachment.html>

From pramalhe at gmail.com  Tue Dec 31 16:15:57 2013
From: pramalhe at gmail.com (Pedro Ramalhete)
Date: Tue, 31 Dec 2013 22:15:57 +0100
Subject: [concurrency-interest] Left-Right - A new concurrency control
	technique
In-Reply-To: <52BF6CB6.3040103@gmail.com>
References: <CAAApjO21nDTbVJhmjU0F+dTgjn5NuQeq3qC1w=hXRJZLZ0idyA@mail.gmail.com>
	<52BF6CB6.3040103@gmail.com>
Message-ID: <CAAApjO3JzZV46BDp1cL5ZoDZH8PXt7VOXHZW3dxSB=f-jOeQdw@mail.gmail.com>

Hi Peter,

We were unable to compile your code, even using the latest stable
netbeans-lambda, so we couldn't test it or benchmark it.

Yes, you are right, the usage of LongAdders is a valid implementation of
the
readIndicator. The ingress/egress pattern is described in the paper
"NUMA Aware Reader-Writer Locks" and we implemented it using LongAdders
on our own rwlock LongAdderRWLock.
To avoid using 4 LongAdder instances, Andreia suggests using the same trick
she discovered for LongAdderExtRWLock, that uses 2 instances instead of 4:
http://concurrencyfreaks.blogspot.fr/2013/09/scalable-rw-lock-with-single-longadder.html
Notice that LongAdder.increment() is not wait-free, (I would say it is
lock-free but I'm not completely sure), and by using LongAdder you are
losing the wait-free progress guarantee provided by the Left-Right
technique.


Performance wise, Andreia has done a (non-functional) implementation of
the Left-Right with a single LongAdder per counter, and on our benchmark
it has similar performance, except for 0.1% writes, where it is surpassed
by the Left-Right with the "scalable readindicator" that is shown in the
paper, which uses a CLQ and an array.


Besides the compilation failure, there is one issue in your implementation.
The order of calling exists.sum() and enters.sum() must always be "exists"
first (egress counter) and then "enters" (ingress counter).
In EnterExistCounter, on the function isEmtpty(), the implementation is
"exits.sum() == enters.sum()" and although I'm not sure of Java's
expression
evaluation rules for this case, I would assume that there is no guarantee
on which one will be evaluated first, thus causing a bug if enters.sum()
happens to be executed before exists.sum().


Thanks,
Pedro


On Sun, Dec 29, 2013 at 1:28 AM, Peter Levart <peter.levart at gmail.com>wrote:

>  Hello Pedro,
>
> This is a very interesting article. I immediately jumped into implementing
> the basic algorithm myself, but using a slightly different coding approach,
> and, since these are the days of JDK 8, using functional interfaces which
> play nicely with lambdas:
>
> http://cr.openjdk.java.net/~plevart/misc/LeftRight/LeftRight.java
>
> I tried to leverage j.u.c.LongAdder here to implement "readIndaicator" -
> the alternative for "Algorithms 2, 3 and 5" described in paper. But as
> you've written in paper, using a counter for that purpose, it has to be
> sequentially consistent, which you've showed, is not the case for LongAdder:
>
>
> http://concurrencyfreaks.blogspot.com/2013/09/longadder-is-not-sequentially-consistent.html
>
> LongAdder is not sequentially consistent if used with different
> modification operations - for example using LongAdder.increment() for
> "arrive" and LongAdder.decrement() for "depart" operations, combined with
> LongAdder.sum() == 0L to implement "isEmpty". But you also showed that
> LongAdder is sequentialy consistent if only a single kind of modifications
> are applied to it. For example, only using inclrement() to modify, and
> sum() to read. So I thought using two LongAdders - one for ingress, the
> other for egress, and reading their sum()s in correct order (first egress
> sum, then ingress sum) and comparing them for equality would do the job. Am
> I right?
>
> Regards, Peter
>
>
> On 12/25/2013 01:44 PM, Pedro Ramalhete wrote:
>
> Hello,
>
> We are pleased to announce a new concurrency control technique which we
> named "Left-Right" and that allows Wait-Free Populations Oblivious read
> operations. The easiest way to explain what it is, is to say that it's a
> "kind of" Reader-Writer Lock that doesn't block for Readers, which makes it
> ideal for low-latency and real-time deployment scenarios:
>
> http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/leftright-extended.pdf
>
> In case you missed it above, this means that you can have one Writer and
> multiple Readers executing simultaneously, and unlike optimistic read
> locks, you don't have to worry about atomicity, or memory management, or
> invariants.
>
> Similarly to a Reader-Writer lock, it can be applied to any
> (non-thread-safe) data structure and enable it to be used in a
> multi-threaded application, where it will be Blocking for Writers, and
> Wait-Free for Readers. It can be implemented in Java, Scala, C11, or C++1x.
> Sample source code can be seen here:
>
> http://sourceforge.net/projects/ccfreaks/files/papers/LeftRight/LRScalableTreeSet.java
>
> http://sourceforge.net/projects/ccfreaks/files/java/src/com/concurrencyfreaks/leftright/LRScalableGuard.java
>
> Its two main innovations are, the usage of two instances, and the new
> concurrency control algorithm whose novel state machine gives wait-free
> guarantees for read operations.
>
>
> There is another technique which also uses two instances but requires 3
> locks, which perhaps has already been discovered, that we named "Double
> Instance Locking" and it is much easier to understand and implement, but it
> is only Lock-Free for read operations:
>
> http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/DoubleInstanceLocking.pptx
>
> http://sourceforge.net/projects/ccfreaks/files/papers/DoubleInstance/DoubleInstanceLockGuard.java
> http://concurrencyfreaks.com/2013/11/double-instance-locking.html
>
> We would like to hear expert's comments on it   ;)
>
> Merry Christmas,
> Pedro & Andreia
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20131231/69a2f8d5/attachment-0001.html>

