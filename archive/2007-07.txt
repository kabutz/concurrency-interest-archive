From unmesh_joshi at hotmail.com  Tue Jul  3 06:08:36 2007
From: unmesh_joshi at hotmail.com (Unmesh joshi)
Date: Tue, 03 Jul 2007 10:08:36 +0000
Subject: [concurrency-interest] Util.concurrent locks and dynamic compilation
In-Reply-To: <mailman.1.1182960000.1937.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <BAY140-F345B6CDC2393C79B443A79EF0C0@phx.gbl>

Hi,

While reading about dynamic compilation, I was little confused about how a 
code using util.concurrent lock object or code for Lock claases themselves 
be dynamically compiled?
Does dynamic compiler need to know that vm code its compiling to machine 
language is accessing a lock object or is itself a lock object? Or at VM 
level, it doent matter if its a lock object or not?
It probably just needs to know about when to use compareAndSwap and how to 
order actions around that?

Thanks,
Unmesh

_________________________________________________________________
Millions of profiles with photos. Search now @ Shaadi.com 
http://ss1.richmedia.in/recurl.asp?pid=108


From geoffrey.wiseman at gmail.com  Tue Jul  3 18:51:37 2007
From: geoffrey.wiseman at gmail.com (Geoffrey Wiseman)
Date: Tue, 3 Jul 2007 18:51:37 -0400
Subject: [concurrency-interest] InfoQ Article on jsr166y
In-Reply-To: <467FB563.4010500@cs.oswego.edu>
References: <835d522e0706242107r1f99a3d1rf452e481dbb3a7a6@mail.gmail.com>
	<467FB563.4010500@cs.oswego.edu>
Message-ID: <835d522e0707031551w2709d7fap466c9b6ed74229de@mail.gmail.com>

On 6/25/07, Doug Lea <dl at cs.oswego.edu> wrote:
>
> We hope the forkjoin package makes it. Big (32+) multicores will be


[snip]

FYI, the new item's been published.  Since it wasn't time-sensitive, it got
pushed back slightly for a few things that were:
http://www.infoq.com/news/2007/07/concurrency-java-se-7

  - Geoffrey
-- 
Geoffrey Wiseman
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070703/8d82d4e8/attachment.html 

From raghuram.nidagal at gmail.com  Sat Jul  7 11:47:33 2007
From: raghuram.nidagal at gmail.com (raghuram nidagal)
Date: Sat, 7 Jul 2007 21:17:33 +0530
Subject: [concurrency-interest] Question on locks
Message-ID: <7874b1f60707070847l317f57a1s31f9383ab5e7c713@mail.gmail.com>

Hi,
We have a requirement where we want to lock based on certain keys. The code
is something like this

class Lock {

}
class LockManager {

private ConcurrentHashMap cacheLock=new ConcurrentHashMap();
public Object getLock(Object key){
Object o=cacheLock.get(key);
if(o==null){
o=new Lock();
Object tmp=cacheLock.putIfAbsent(key,o);
if(tmp!=null)
o=tmp;
}
return o;
}
}

The code where the lock is used is something like this
synchronized(lockManager.getLock(key1)){
//some code
synchronized(lockManager.getLock(key2)){
///
}
}

We need this since we have certain requirements where threads should lock on
key1 and key2,
but we dont want to use these key objects as locks since they might be used
in
other parts of the application and we dont want unforseen synchronization
issues.

I wanted to know if
a) having an empty implementation as in the Lock class implementation above
is wrong.
Will it cause some unexpected synchronization behaviour ?
b) Instead of this approach, is there any benefit if I create and store a
ReentrantLock
object in the LockManager

Thanks in advance
Raghu
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070707/74f33e2c/attachment.html 

From raghuram.nidagal at gmail.com  Mon Jul  9 10:41:15 2007
From: raghuram.nidagal at gmail.com (raghuram nidagal)
Date: Mon, 9 Jul 2007 20:11:15 +0530
Subject: [concurrency-interest] Question on locks
In-Reply-To: <5c8321dc0707090712q52ae3523ice02cc38b5a9369d@mail.gmail.com>
References: <7874b1f60707070847l317f57a1s31f9383ab5e7c713@mail.gmail.com>
	<5c8321dc0707090712q52ae3523ice02cc38b5a9369d@mail.gmail.com>
Message-ID: <7874b1f60707090741l147f9bc6x62a242ce78a434a6@mail.gmail.com>

Thanks Dominik,
You are right that the Lock class does not hold information about the key.
However, my key actually maps to an entry in a ConcurrentHashMap. The value
(Lock object) is supposed to be unique for every unique key. This I assume
is taken care of in the Map's get method which will return null if there is
no entry for a given key and the null check tells me that I have to create a
new object. I think I dont need to write a Lock class for this and could
very well do it by creating a new object.
Since cacheLock is a ConcurrentHashMap I believe the following code should
work ?

public Object getLock(Object key){
Object o=cacheLock.get(key);
if(o==null){
o=new Object();
Object tmp=cacheLock.putIfAbsent(key,o);
if(tmp!=null)
o=tmp;
}
return o;
}


On 7/9/07, Dominik Klimczak <dominik.klimczak at gmail.com> wrote:
>
> And your Lock class doesn't hold information about the key, so your
> getLock method will always return new object. So it is wrong.
> Try something like this:
>
>     class LockWrapper<E> {
>         private final E key;
>
>         public LockWrapper(E key) {
>             this.key = key;
>         }
>
>         @Override
>         public boolean equals(Object obj) {
>             if (obj instanceof LockWrapper) {
>                 final LockWrapper other = (LockWrapper) obj;
>                 return this.key.equals(other.key);
>             }
>             return false;
>         }
>
>         @Override
>         public int hashCode() {
>             return key.hashCode();
>         }
>
>         public E getKey() {
>             return key;
>         }
>     }
>
> Dominik Klimczak
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070709/d7622360/attachment.html 

From rob.griffin at quest.com  Mon Jul  9 21:13:12 2007
From: rob.griffin at quest.com (Rob Griffin)
Date: Tue, 10 Jul 2007 11:13:12 +1000
Subject: [concurrency-interest] Illegal IllegalMonitorStateException
Message-ID: <0BAEFFA7AFADFD4497F50DD093687E07043D9D49@melmbxw01.prod.quest.corp>

Hello,

We are getting this intermittent exception in our application

java.lang.IllegalMonitorStateException: current thread not owner

      at java.lang.Object.notify(Native Method)
      at
com.quest.adk.threads.queues.QueueManager.removeFromQueue(QueueManager.j
ava:257)

	......


This seems reasonable until we look at the code that throws the
exception:

    synchronized (namedQueues) {
       namedQueues.notify();  // <---- thrown here
    }

And we also get it in another place as well:

     synchronized(transactions) {
         transactions.notifyAll();  // <-- and here!
     }

In both cases the variables are never changed by the code once they are
initialized, so it is not possible for then to reference different
objects between one statement and the next.  

We are using 1.5 on Windows.

java version "1.5.0_10"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_10-b03)
Java HotSpot(TM) Server VM (build 1.5.0_10-b03, mixed mode)

Anyone seen anything like this? This has just started happening in a
mature application and we have been using this version of Java for many
months. We do have some native code called via JNI but if it was running
amok I would have expected random errors. I have checked the release
notes for 1.5.0._12 and there is no mention of
IllegalMonitorStateException. As well we are approaching a release for
our product and feel uneasy about changing JVM versions at this late
stage. 


Regards,
 
Rob Griffin
Quest Software
www.quest.com



From rob.griffin at quest.com  Mon Jul  9 22:30:30 2007
From: rob.griffin at quest.com (Rob Griffin)
Date: Tue, 10 Jul 2007 12:30:30 +1000
Subject: [concurrency-interest] Illegal IllegalMonitorStateException
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGELOHHAA.dcholmes@optusnet.com.au>
References: <0BAEFFA7AFADFD4497F50DD093687E07043D9D49@melmbxw01.prod.quest.corp>
	<NFBBKALFDCPFIDBNKAPCGELOHHAA.dcholmes@optusnet.com.au>
Message-ID: <0BAEFFA7AFADFD4497F50DD093687E07043D9E03@melmbxw01.prod.quest.corp>

David,

There have been many changes in the application, but none in this area
recently. What we have been doing is improving the throughput of the
application and stressing it more; which will have resulted in more
calls to this code. As you suggest our next step is to add some debug
code around the area and try update 12. 

Thanks,

Rob Griffin. 


-----Original Message-----
From: David Holmes [mailto:dcholmes at optusnet.com.au] 
Sent: Tuesday, 10 July 2007 12:02 PM
To: Rob Griffin
Subject: RE: [concurrency-interest] Illegal IllegalMonitorStateException

Hi Rob,

Can you think of anything in the VM or application that has changed
recently? Something must have changed for this to suddenly appear -
perhaps
running on a different machine or an upgraded one?

Can you easily reproduce this? If so can you add try/catch around the
notify() calls to trap the IllegalMonitorStateException and verify the
identity of the object that is being synchronized upon. You could also
try
generating a stack-dump while the program is in that state to see if the
apparent owner of the object monitor (if any) is visible. Attaching
jconsole
might also shed some light.

Could you reproduce with 5.0u12 ?

I couldn't find any known issues in this area.

Without a reproducible test case it will be very difficult to track this
down.

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Rob
> Griffin
> Sent: Tuesday, 10 July 2007 11:13 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Illegal IllegalMonitorStateException
>
>
> Hello,
>
> We are getting this intermittent exception in our application
>
> java.lang.IllegalMonitorStateException: current thread not owner
>
>       at java.lang.Object.notify(Native Method)
>       at
>
com.quest.adk.threads.queues.QueueManager.removeFromQueue(QueueManager.j
> ava:257)
>
> 	......
>
>
> This seems reasonable until we look at the code that throws the
> exception:
>
>     synchronized (namedQueues) {
>        namedQueues.notify();  // <---- thrown here
>     }
>
> And we also get it in another place as well:
>
>      synchronized(transactions) {
>          transactions.notifyAll();  // <-- and here!
>      }
>
> In both cases the variables are never changed by the code once they
are
> initialized, so it is not possible for then to reference different
> objects between one statement and the next.
>
> We are using 1.5 on Windows.
>
> java version "1.5.0_10"
> Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_10-b03)
> Java HotSpot(TM) Server VM (build 1.5.0_10-b03, mixed mode)
>
> Anyone seen anything like this? This has just started happening in a
> mature application and we have been using this version of Java for
many
> months. We do have some native code called via JNI but if it was
running
> amok I would have expected random errors. I have checked the release
> notes for 1.5.0._12 and there is no mention of
> IllegalMonitorStateException. As well we are approaching a release for
> our product and feel uneasy about changing JVM versions at this late
> stage.
>
>
> Regards,
>
> Rob Griffin
> Quest Software
> www.quest.com
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest




From rob.griffin at quest.com  Mon Jul  9 22:59:45 2007
From: rob.griffin at quest.com (Rob Griffin)
Date: Tue, 10 Jul 2007 12:59:45 +1000
Subject: [concurrency-interest] Illegal IllegalMonitorStateException
In-Reply-To: <ca53c8f80707091948r2c6401f1n8fb96b67251d265b@mail.gmail.com>
References: <0BAEFFA7AFADFD4497F50DD093687E07043D9D49@melmbxw01.prod.quest.corp>
	<ca53c8f80707091948r2c6401f1n8fb96b67251d265b@mail.gmail.com>
Message-ID: <0BAEFFA7AFADFD4497F50DD093687E07043D9E2B@melmbxw01.prod.quest.corp>

Hanson,

This is the only wait in the class:

            synchronized (namedQueues) {
              try {
                namedQueues.wait(5000);
              } catch (InterruptedException ie) {
                // Can safely ignore this
              }
            }
            if (isInterrupted() || isStopped())
              break;

The code works 99.99999% of the time. In fact we have had only one
instance of each place failing. It's not a coding bug on our part.

Regards,

Rob Griffin.
Quest Software.

-----Original Message-----
From: Hanson Char [mailto:hanson.char at gmail.com] 
Sent: Tuesday, 10 July 2007 12:48 PM
To: Rob Griffin
Subject: Re: [concurrency-interest] Illegal IllegalMonitorStateException

wait and notify need be synchronized on the same object, or you will
get this exception.

You showed the code on notify/notifyAll, but you need to show the
respective wait to pin point the mismatch error.

Hanson

On 7/9/07, Rob Griffin <rob.griffin at quest.com> wrote:
> Hello,
>
> We are getting this intermittent exception in our application
>
> java.lang.IllegalMonitorStateException: current thread not owner
>
>       at java.lang.Object.notify(Native Method)
>       at
>
com.quest.adk.threads.queues.QueueManager.removeFromQueue(QueueManager.j
> ava:257)
>
>         ......
>
>
> This seems reasonable until we look at the code that throws the
> exception:
>
>     synchronized (namedQueues) {
>        namedQueues.notify();  // <---- thrown here
>     }
>
> And we also get it in another place as well:
>
>      synchronized(transactions) {
>          transactions.notifyAll();  // <-- and here!
>      }
>
> In both cases the variables are never changed by the code once they
are
> initialized, so it is not possible for then to reference different
> objects between one statement and the next.
>
> We are using 1.5 on Windows.
>
> java version "1.5.0_10"
> Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_10-b03)
> Java HotSpot(TM) Server VM (build 1.5.0_10-b03, mixed mode)
>
> Anyone seen anything like this? This has just started happening in a
> mature application and we have been using this version of Java for
many
> months. We do have some native code called via JNI but if it was
running
> amok I would have expected random errors. I have checked the release
> notes for 1.5.0._12 and there is no mention of
> IllegalMonitorStateException. As well we are approaching a release for
> our product and feel uneasy about changing JVM versions at this late
> stage.
>
>
> Regards,
>
> Rob Griffin
> Quest Software
> www.quest.com
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>



From dcholmes at optusnet.com.au  Mon Jul  9 23:23:09 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 10 Jul 2007 13:23:09 +1000
Subject: [concurrency-interest] Illegal IllegalMonitorStateException
In-Reply-To: <0BAEFFA7AFADFD4497F50DD093687E07043D9E2B@melmbxw01.prod.quest.corp>
Message-ID: <NFBBKALFDCPFIDBNKAPCOELOHHAA.dcholmes@optusnet.com.au>

Rob,

Just an aside from your current problem but I noticed in your code snippet:

>             synchronized (namedQueues) {
>               try {
>                 namedQueues.wait(5000);
>               } catch (InterruptedException ie) {
>                 // Can safely ignore this
>               }
>             }
>             if (isInterrupted() || isStopped())
>               break;

The "Can safely ignore this" seems wrong. If the InterruptedException is
thrown then isInterrupted() will return false, so you will fail to "break"
on interrupt.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Rob
> Griffin
> Sent: Tuesday, 10 July 2007 1:00 PM
> To: Concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Illegal IllegalMonitorStateException
>
>
> Hanson,
>
> This is the only wait in the class:
>
>             synchronized (namedQueues) {
>               try {
>                 namedQueues.wait(5000);
>               } catch (InterruptedException ie) {
>                 // Can safely ignore this
>               }
>             }
>             if (isInterrupted() || isStopped())
>               break;
>
> The code works 99.99999% of the time. In fact we have had only one
> instance of each place failing. It's not a coding bug on our part.
>
> Regards,
>
> Rob Griffin.
> Quest Software.
>
> -----Original Message-----
> From: Hanson Char [mailto:hanson.char at gmail.com]
> Sent: Tuesday, 10 July 2007 12:48 PM
> To: Rob Griffin
> Subject: Re: [concurrency-interest] Illegal IllegalMonitorStateException
>
> wait and notify need be synchronized on the same object, or you will
> get this exception.
>
> You showed the code on notify/notifyAll, but you need to show the
> respective wait to pin point the mismatch error.
>
> Hanson
>
> On 7/9/07, Rob Griffin <rob.griffin at quest.com> wrote:
> > Hello,
> >
> > We are getting this intermittent exception in our application
> >
> > java.lang.IllegalMonitorStateException: current thread not owner
> >
> >       at java.lang.Object.notify(Native Method)
> >       at
> >
> com.quest.adk.threads.queues.QueueManager.removeFromQueue(QueueManager.j
> > ava:257)
> >
> >         ......
> >
> >
> > This seems reasonable until we look at the code that throws the
> > exception:
> >
> >     synchronized (namedQueues) {
> >        namedQueues.notify();  // <---- thrown here
> >     }
> >
> > And we also get it in another place as well:
> >
> >      synchronized(transactions) {
> >          transactions.notifyAll();  // <-- and here!
> >      }
> >
> > In both cases the variables are never changed by the code once they
> are
> > initialized, so it is not possible for then to reference different
> > objects between one statement and the next.
> >
> > We are using 1.5 on Windows.
> >
> > java version "1.5.0_10"
> > Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_10-b03)
> > Java HotSpot(TM) Server VM (build 1.5.0_10-b03, mixed mode)
> >
> > Anyone seen anything like this? This has just started happening in a
> > mature application and we have been using this version of Java for
> many
> > months. We do have some native code called via JNI but if it was
> running
> > amok I would have expected random errors. I have checked the release
> > notes for 1.5.0._12 and there is no mention of
> > IllegalMonitorStateException. As well we are approaching a release for
> > our product and feel uneasy about changing JVM versions at this late
> > stage.
> >
> >
> > Regards,
> >
> > Rob Griffin
> > Quest Software
> > www.quest.com
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From rob.griffin at quest.com  Tue Jul 10 02:06:00 2007
From: rob.griffin at quest.com (Rob Griffin)
Date: Tue, 10 Jul 2007 16:06:00 +1000
Subject: [concurrency-interest] Illegal IllegalMonitorStateException
In-Reply-To: <A2167F6D-0919-460A-8DB2-C6667DB9C693@bellsouth.net>
References: <0BAEFFA7AFADFD4497F50DD093687E07043D9D49@melmbxw01.prod.quest.corp>
	<A2167F6D-0919-460A-8DB2-C6667DB9C693@bellsouth.net>
Message-ID: <0BAEFFA7AFADFD4497F50DD093687E07043D9F52@melmbxw01.prod.quest.corp>

Dave,

I've made them final now but a search through the code shows no
assignments to these variables other than the initial ones. They are not
being altered. 

As for you other observation; yes we realize this but the code is quite
old. We are intending to go to Java 6 for the next release and rewrite a
fair proportion of this stuff to use the concurrent packages. We have a
few reinvented wheels in this application that we would like to replace
with nice shiny new round ones.

Rob Griffin.    

-----Original Message-----
From: Dave Griffith [mailto:dgriffith at bellsouth.net] 
Sent: Tuesday, 10 July 2007 2:10 PM
To: Rob Griffin
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Illegal IllegalMonitorStateException

If the "namedQueues" and "transactions" variables aren't final, they  
should be.  If they can't be final, it most likely means they are  
being altered, and there's your problem.  Once you do that, I'm  
pretty sure your problem will go away (unless there's a VM bug I'm  
unaware of, which is certainly possible).  Note that it's not enough  
to say "the variable is never modified".  Marking fields final has  
very specific Java memory model implications, beyond the naive  
semantics.

Beyond that, it looks like you've got a pattern that could be better  
solved by using an Executor class, rather than creating your own  
QueueManager.  No need to reinvent the wheel, especially if you  
aren't sure you can make it round.

--Dave Griffith



On Jul 9, 2007, at 9:13 PM, Rob Griffin wrote:

> Hello,
>
> We are getting this intermittent exception in our application
>
> java.lang.IllegalMonitorStateException: current thread not owner
>
>       at java.lang.Object.notify(Native Method)
>       at
> com.quest.adk.threads.queues.QueueManager.removeFromQueue 
> (QueueManager.j
> ava:257)
>
> 	......
>
>
> This seems reasonable until we look at the code that throws the
> exception:
>
>     synchronized (namedQueues) {
>        namedQueues.notify();  // <---- thrown here
>     }
>
> And we also get it in another place as well:
>
>      synchronized(transactions) {
>          transactions.notifyAll();  // <-- and here!
>      }
>
> In both cases the variables are never changed by the code once they  
> are
> initialized, so it is not possible for then to reference different
> objects between one statement and the next.
>
> We are using 1.5 on Windows.
>
> java version "1.5.0_10"
> Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_10-b03)
> Java HotSpot(TM) Server VM (build 1.5.0_10-b03, mixed mode)
>
> Anyone seen anything like this? This has just started happening in a
> mature application and we have been using this version of Java for  
> many
> months. We do have some native code called via JNI but if it was  
> running
> amok I would have expected random errors. I have checked the release
> notes for 1.5.0._12 and there is no mention of
> IllegalMonitorStateException. As well we are approaching a release for
> our product and feel uneasy about changing JVM versions at this late
> stage.
>
>
> Regards,
>
> Rob Griffin
> Quest Software
> www.quest.com
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>




From dawid.kurzyniec at gmail.com  Tue Jul 10 16:41:01 2007
From: dawid.kurzyniec at gmail.com (Dawid Kurzyniec)
Date: Tue, 10 Jul 2007 13:41:01 -0700
Subject: [concurrency-interest] Question on locks
In-Reply-To: <7874b1f60707070847l317f57a1s31f9383ab5e7c713@mail.gmail.com>
References: <7874b1f60707070847l317f57a1s31f9383ab5e7c713@mail.gmail.com>
Message-ID: <3cbaca580707101341h6d8a0ab2hfb81998916d5dca3@mail.gmail.com>

On 7/7/07, raghuram nidagal <raghuram.nidagal at gmail.com> wrote:
>
>
> Hi,
> We have a requirement where we want to lock based on certain keys. The code
> is something like this
>
> class Lock {
>
> }
> class LockManager {
>
> private ConcurrentHashMap cacheLock=new ConcurrentHashMap();
> public Object getLock(Object key){
> Object o=cacheLock.get(key);
> if(o==null){
> o=new Lock();
> Object tmp=cacheLock.putIfAbsent(key,o);
> if(tmp!=null)
> o=tmp;
> }
> return o;
> }
> }
>
> The code where the lock is used is something like this
> synchronized(lockManager.getLock(key1)){
> //some code
> synchronized(lockManager.getLock(key2)){
> ///
> }
> }
>
> We need this since we have certain requirements where threads should lock on
> key1 and key2,
> but we dont want to use these key objects as locks since they might be used
> in
> other parts of the application and we dont want unforseen synchronization
> issues.
> (...)

One potential issue with this approach is that it is prone to garbage
retention, since your locks are never removed from the lock manager,
even if you stop using a particular key. (If you're using a bounded
set of keys, this will not be a problem).

One possible solution is:

http://dcl.mathcs.emory.edu/cgi-bin/viewvc.cgi/software/harness2/trunk/util/src/edu/emory/mathcs/util/concurrent/ReentrantNamedLock.java?revision=2416&view=markup

The class there is called a "Named" lock, suggesting that your keys
must be strings, but actually you can use any key object that
implements the equals() contract to define lock identity.

Example usage:

ReentrantNamedLock r = new ReentrantNamedLock(key);
...
r.lock();
try { ... }
finally { r.unlock(); }

And you get mutual exclusion between locks constructed with equal
keys. The implementation lazily removes locks for unused keys from the
memory through standard garbage collection mechanisms.

Regards,
Dawid

From raghuram.nidagal at gmail.com  Wed Jul 11 12:45:42 2007
From: raghuram.nidagal at gmail.com (raghuram nidagal)
Date: Wed, 11 Jul 2007 22:15:42 +0530
Subject: [concurrency-interest] Question on locks
In-Reply-To: <3cbaca580707101341h6d8a0ab2hfb81998916d5dca3@mail.gmail.com>
References: <7874b1f60707070847l317f57a1s31f9383ab5e7c713@mail.gmail.com>
	<3cbaca580707101341h6d8a0ab2hfb81998916d5dca3@mail.gmail.com>
Message-ID: <7874b1f60707110945x5a411c9dmebdcb07b5c672722@mail.gmail.com>

Thanks Dawid. You are right that there is a potential memory issue here.
However, the set of keys is bounded so to that extent we are safe.

On 7/11/07, Dawid Kurzyniec <dawid.kurzyniec at gmail.com> wrote:
>
> On 7/7/07, raghuram nidagal <raghuram.nidagal at gmail.com> wrote:
> >
> >
> > Hi,
> > We have a requirement where we want to lock based on certain keys. The
> code
> > is something like this
> >
> > class Lock {
> >
> > }
> > class LockManager {
> >
> > private ConcurrentHashMap cacheLock=new ConcurrentHashMap();
> > public Object getLock(Object key){
> > Object o=cacheLock.get(key);
> > if(o==null){
> > o=new Lock();
> > Object tmp=cacheLock.putIfAbsent(key,o);
> > if(tmp!=null)
> > o=tmp;
> > }
> > return o;
> > }
> > }
> >
> > The code where the lock is used is something like this
> > synchronized(lockManager.getLock(key1)){
> > //some code
> > synchronized(lockManager.getLock(key2)){
> > ///
> > }
> > }
> >
> > We need this since we have certain requirements where threads should
> lock on
> > key1 and key2,
> > but we dont want to use these key objects as locks since they might be
> used
> > in
> > other parts of the application and we dont want unforseen
> synchronization
> > issues.
> > (...)
>
> One potential issue with this approach is that it is prone to garbage
> retention, since your locks are never removed from the lock manager,
> even if you stop using a particular key. (If you're using a bounded
> set of keys, this will not be a problem).
>
> One possible solution is:
>
>
> http://dcl.mathcs.emory.edu/cgi-bin/viewvc.cgi/software/harness2/trunk/util/src/edu/emory/mathcs/util/concurrent/ReentrantNamedLock.java?revision=2416&view=markup
>
> The class there is called a "Named" lock, suggesting that your keys
> must be strings, but actually you can use any key object that
> implements the equals() contract to define lock identity.
>
> Example usage:
>
> ReentrantNamedLock r = new ReentrantNamedLock(key);
> ...
> r.lock();
> try { ... }
> finally { r.unlock(); }
>
> And you get mutual exclusion between locks constructed with equal
> keys. The implementation lazily removes locks for unused keys from the
> memory through standard garbage collection mechanisms.
>
> Regards,
> Dawid
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070711/eb29c93d/attachment.html 

From kgraham00 at gmail.com  Mon Jul 16 11:53:06 2007
From: kgraham00 at gmail.com (Kevin Graham)
Date: Mon, 16 Jul 2007 10:53:06 -0500
Subject: [concurrency-interest] backport: Memory leak on
	BlockingQueue.poll(long, TimeUnit), plus workaround
Message-ID: <2a304c9a0707160853j108d48e8m1edb3eed8c3609a6@mail.gmail.com>

I'm experiencing a small memory leak on my consumer when my producer is
idle.  Each call to the poll method instantiates a new
edu.emory.mathcs.backport.java.util.concurrent.helpers.WaitQueue$WaitNode.
So if the poll method is given a 1 second timeout within a loop, then every
second a new WaitQueue$WaitNode is instantiated.  The garbage collector
finds each instance reachable.  As soon as a producer offers a single Object
to the queue, the instances will be cleaned up on the next garbage
collection run.

I wrote some code and can clearly see this using JProbe:

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import edu.emory.mathcs.backport.java.util.concurrent.BlockingQueue;
import edu.emory.mathcs.backport.java.util.concurrent.ExecutorService;
import edu.emory.mathcs.backport.java.util.concurrent.Executors;
import edu.emory.mathcs.backport.java.util.concurrent.PriorityBlockingQueue;
import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;

public class Main {

    BlockingQueue queue = new PriorityBlockingQueue();

    public static void main(String[] args) throws IOException {

        Main m = new Main();

        ExecutorService executorService = Executors.newCachedThreadPool();

        BufferedReader reader = new BufferedReader(new InputStreamReader(
System.in));

        printPrompt();

        String cmd = null;

        while((cmd = reader.readLine()) != null) {

            if(cmd.equals("help") || cmd.equals("?")) {
                System.out.println("startconsumer - Start a consumer.  The
Consumer polls until an object is put into the queue.");
                System.out.println("startproducer - Start a producer.  The
Producer offers an object to the queue.");
                System.out.println("quit - Stops the program.");
            }//if(cmd.equals("help") || cmd.equals("?"))
            else if(cmd.equals("startconsumer")) {
                executorService.execute(m.new Consumer());
            }//else if(cmd.equals("startconsumer"))
            else if(cmd.equals("startproducer")) {
                executorService.execute(m.new Producer());
            }//else if(cmd.equals("startproducer"))
            else if(cmd.equals("quit")) {
                System.exit(0);
            }//else if(cmd.equals("quit"))
            else {
                System.out.println("Command not known");
            }//else

            printPrompt();

        }//while((cmd = reader.readLine()) != null)
    }//public static void main(String[] args) throws IOException

    public static void printPrompt() {

        System.out.print(">");

    }//public static void printPrompt()

    class Consumer implements Runnable {

        public void run() {
            boolean found = false;

            while(!found) {
                Object o = null;
                try {
                    o = queue.poll(1,TimeUnit.SECONDS);
                }//try
                catch(InterruptedException e) {
                    Thread.currentThread().interrupt();
                }//catch(InterruptedException e)
                found = o != null;
            }//while(!found)

            System.out.println("Consumer poll complete.");
        }//public void run()

    }//class Consumer implements Runnable

    class Producer implements Runnable {

        public void run() {
            queue.offer(new Comparable() {
                public int compareTo(Object o) { return 0; }
            });
            System.out.println("Producer offer complete.");
        }//public void run()
    }//class Producer implements Runnable
}//public class Main


So, my workaround schedules a repeating task that offers a "dummy task" into
each queue that may idle for a prolonged period of time.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070716/2df65264/attachment.html 

From dcholmes at optusnet.com.au  Mon Jul 16 17:45:54 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 17 Jul 2007 07:45:54 +1000
Subject: [concurrency-interest] backport: Memory leak
	onBlockingQueue.poll(long, TimeUnit), plus workaround
In-Reply-To: <2a304c9a0707160853j108d48e8m1edb3eed8c3609a6@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIENDHHAA.dcholmes@optusnet.com.au>

Kevin,

The "leak" with timed BlockingQueue.poll is a known issue. It was fixed in
the JDK for Java 6 (and may have been back ported to one of the 5.0
updates). I don't know what the status of the backport is in that regard.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Kevin Graham
  Sent: Tuesday, 17 July 2007 1:53 AM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] backport: Memory leak
onBlockingQueue.poll(long, TimeUnit), plus workaround


  I'm experiencing a small memory leak on my consumer when my producer is
idle.  Each call to the poll method instantiates a new
edu.emory.mathcs.backport.java.util.concurrent.helpers.WaitQueue$WaitNode.
So if the poll method is given a 1 second timeout within a loop, then every
second a new WaitQueue$WaitNode is instantiated.  The garbage collector
finds each instance reachable.  As soon as a producer offers a single Object
to the queue, the instances will be cleaned up on the next garbage
collection run.

  I wrote some code and can clearly see this using JProbe:

  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;

  import edu.emory.mathcs.backport.java.util.concurrent.BlockingQueue ;
  import edu.emory.mathcs.backport.java.util.concurrent.ExecutorService;
  import edu.emory.mathcs.backport.java.util.concurrent.Executors;
  import
edu.emory.mathcs.backport.java.util.concurrent.PriorityBlockingQueue ;
  import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;

  public class Main {

      BlockingQueue queue = new PriorityBlockingQueue();

      public static void main(String[] args) throws IOException {

          Main m = new Main();

          ExecutorService executorService = Executors.newCachedThreadPool();

          BufferedReader reader = new BufferedReader(new
InputStreamReader( System.in));

          printPrompt();

          String cmd = null;

          while((cmd = reader.readLine()) != null) {

              if( cmd.equals("help") || cmd.equals("?")) {
                  System.out.println("startconsumer - Start a consumer.  The
Consumer polls until an object is put into the queue.");
                  System.out.println("startproducer - Start a producer.  The
Producer offers an object to the queue.");
                  System.out.println("quit - Stops the program.");
              }//if(cmd.equals ("help") || cmd.equals("?"))
              else if(cmd.equals("startconsumer")) {
                  executorService.execute(m.new Consumer());
              }//else if(cmd.equals("startconsumer"))
              else if(cmd.equals("startproducer")) {
                  executorService.execute(m.new Producer());
              }//else if(cmd.equals("startproducer"))
              else if(cmd.equals ("quit")) {
                  System.exit(0);
              }//else if(cmd.equals("quit"))
              else {
                  System.out.println("Command not known");
              }//else

              printPrompt();

          }//while((cmd = reader.readLine()) != null)
      }//public static void main(String[] args) throws IOException

      public static void printPrompt() {

          System.out.print(">");

      }//public static void printPrompt()

      class Consumer implements Runnable {

          public void run() {
              boolean found = false;

              while(!found) {
                  Object o = null;
                  try {
                      o = queue.poll(1,TimeUnit.SECONDS);
                  }//try
                  catch(InterruptedException e) {
                      Thread.currentThread().interrupt();
                  }//catch(InterruptedException e)
                  found = o != null;
              }//while(!found)

              System.out.println ("Consumer poll complete.");
          }//public void run()

      }//class Consumer implements Runnable

      class Producer implements Runnable {

          public void run() {
              queue.offer(new Comparable() {
                  public int compareTo(Object o) { return 0; }
              });
              System.out.println("Producer offer complete.");
          }//public void run()
      }//class Producer implements Runnable
  }//public class Main


  So, my workaround schedules a repeating task that offers a "dummy task"
into each queue that may idle for a prolonged period of time.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070717/9ec443a4/attachment.html 

From oliver at zeigermann.de  Thu Jul 19 09:37:51 2007
From: oliver at zeigermann.de (Oliver Zeigermann)
Date: Thu, 19 Jul 2007 15:37:51 +0200
Subject: [concurrency-interest] Transferring locks between two threads:
	Possible?
Message-ID: <9da4f4520707190637u1748843dl8ba0dc8179d759f3@mail.gmail.com>

Hi experts!

Is is possible to transfer locks (possibly of type
java.util.concurrent.locks.ReentrantLock) held by one thread to
another?

Background is the question whether it is possible to implement
concurrent data structures as resources of the the XA protocol. This
protocol requires that its participants can suspend work for one
thread and resume the work on another thread. This would require
transfer of locks between threads.

Is that possible?

Thanks in advance and cheers

Oliver

From tim at peierls.net  Thu Jul 19 10:01:50 2007
From: tim at peierls.net (Tim Peierls)
Date: Thu, 19 Jul 2007 10:01:50 -0400
Subject: [concurrency-interest] Transferring locks between two threads:
	Possible?
In-Reply-To: <9da4f4520707190637u1748843dl8ba0dc8179d759f3@mail.gmail.com>
References: <9da4f4520707190637u1748843dl8ba0dc8179d759f3@mail.gmail.com>
Message-ID: <63b4e4050707190701p66de1f55wa7365b3a68be3bde@mail.gmail.com>

Would the Mutex example in AQS:


http://java.sun.com/javase/6/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html

meet your needs if you removed the calls to setExclusiveOwnerThread?

--tim

On 7/19/07, Oliver Zeigermann <oliver at zeigermann.de> wrote:
>
> Hi experts!
>
> Is is possible to transfer locks (possibly of type
> java.util.concurrent.locks.ReentrantLock) held by one thread to
> another?
>
> Background is the question whether it is possible to implement
> concurrent data structures as resources of the the XA protocol. This
> protocol requires that its participants can suspend work for one
> thread and resume the work on another thread. This would require
> transfer of locks between threads.
>
> Is that possible?
>
> Thanks in advance and cheers
>
> Oliver
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070719/5fb4018b/attachment.html 

From tim at peierls.net  Thu Jul 19 10:07:45 2007
From: tim at peierls.net (Tim Peierls)
Date: Thu, 19 Jul 2007 10:07:45 -0400
Subject: [concurrency-interest] Transferring locks between two threads:
	Possible?
In-Reply-To: <63b4e4050707190701p66de1f55wa7365b3a68be3bde@mail.gmail.com>
References: <9da4f4520707190637u1748843dl8ba0dc8179d759f3@mail.gmail.com>
	<63b4e4050707190701p66de1f55wa7365b3a68be3bde@mail.gmail.com>
Message-ID: <63b4e4050707190707o8df2f4em12d272b0e1b9d783@mail.gmail.com>

Whoops, no I guess it won't with isHeldExclusively returning true. But a
variant of this AQS impl might be what you want.

On 7/19/07, Tim Peierls <tim at peierls.net> wrote:
>
> Would the Mutex example in AQS:
>
>   http://java.sun.com/javase/6/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html
>
>
> meet your needs if you removed the calls to setExclusiveOwnerThread?
>
> --tim
>
> On 7/19/07, Oliver Zeigermann < oliver at zeigermann.de> wrote:
> >
> > Hi experts!
> >
> > Is is possible to transfer locks (possibly of type
> > java.util.concurrent.locks.ReentrantLock) held by one thread to
> > another?
> >
> > Background is the question whether it is possible to implement
> > concurrent data structures as resources of the the XA protocol. This
> > protocol requires that its participants can suspend work for one
> > thread and resume the work on another thread. This would require
> > transfer of locks between threads.
> >
> > Is that possible?
> >
> > Thanks in advance and cheers
> >
> > Oliver
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070719/80977c00/attachment.html 

From alarmnummer at gmail.com  Thu Jul 19 10:27:30 2007
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Thu, 19 Jul 2007 16:27:30 +0200
Subject: [concurrency-interest] Transferring locks between two threads:
	Possible?
In-Reply-To: <9da4f4520707190637u1748843dl8ba0dc8179d759f3@mail.gmail.com>
References: <9da4f4520707190637u1748843dl8ba0dc8179d759f3@mail.gmail.com>
Message-ID: <1466c1d60707190727rc5177b1g20009c04900222ec@mail.gmail.com>

Hi Oliver,

You could use a binary semaphore for this situation. With a semaphore
you are allowed to do a down in one thread, and an up in another. You
have to watch out for recursive locks because they will lead to
deadlocks. And you also need to watch out for too many ups.

example:

class Lock{
	Sempahore s = new Semaphore(1);	
	
	void acquire(){
		s.down();
	}

	void release(){
		s.up();
	}
}


On 7/19/07, Oliver Zeigermann <oliver at zeigermann.de> wrote:
> Hi experts!
>
> Is is possible to transfer locks (possibly of type
> java.util.concurrent.locks.ReentrantLock) held by one thread to
> another?
>
> Background is the question whether it is possible to implement
> concurrent data structures as resources of the the XA protocol. This
> protocol requires that its participants can suspend work for one
> thread and resume the work on another thread. This would require
> transfer of locks between threads.
>
> Is that possible?
>
> Thanks in advance and cheers
>
> Oliver
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From tim at peierls.net  Thu Jul 19 10:56:39 2007
From: tim at peierls.net (Tim Peierls)
Date: Thu, 19 Jul 2007 10:56:39 -0400
Subject: [concurrency-interest] Transferring locks between two threads:
	Possible?
In-Reply-To: <1466c1d60707190727rc5177b1g20009c04900222ec@mail.gmail.com>
References: <9da4f4520707190637u1748843dl8ba0dc8179d759f3@mail.gmail.com>
	<1466c1d60707190727rc5177b1g20009c04900222ec@mail.gmail.com>
Message-ID: <63b4e4050707190756q656f4cabyf6743a2ea8f43b80@mail.gmail.com>

Or, as Peter says, you could do the simple thing and avoid AQS. :-)

As it stands, Peter's example doesn't implement j.u.c.locks.Lock -- and it
would need a little work to provide Conditions and such, but it's a much
simpler approach than what I suggested. Forget I said it.

--tim

On 7/19/07, Peter Veentjer <alarmnummer at gmail.com> wrote:
>
> Hi Oliver,
>
> You could use a binary semaphore for this situation. With a semaphore
> you are allowed to do a down in one thread, and an up in another. You
> have to watch out for recursive locks because they will lead to
> deadlocks. And you also need to watch out for too many ups.
>
> example:
>
> class Lock{
>         Sempahore s = new Semaphore(1);
>
>         void acquire(){
>                 s.down();
>         }
>
>         void release(){
>                 s.up();
>         }
> }
>
>
> On 7/19/07, Oliver Zeigermann <oliver at zeigermann.de> wrote:
> > Hi experts!
> >
> > Is is possible to transfer locks (possibly of type
> > java.util.concurrent.locks.ReentrantLock) held by one thread to
> > another?
> >
> > Background is the question whether it is possible to implement
> > concurrent data structures as resources of the the XA protocol. This
> > protocol requires that its participants can suspend work for one
> > thread and resume the work on another thread. This would require
> > transfer of locks between threads.
> >
> > Is that possible?
> >
> > Thanks in advance and cheers
> >
> > Oliver
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070719/60cce4a3/attachment.html 

From oliver at zeigermann.de  Thu Jul 19 11:44:00 2007
From: oliver at zeigermann.de (Oliver Zeigermann)
Date: Thu, 19 Jul 2007 17:44:00 +0200
Subject: [concurrency-interest] Transferring locks between two threads:
	Possible?
In-Reply-To: <63b4e4050707190756q656f4cabyf6743a2ea8f43b80@mail.gmail.com>
References: <9da4f4520707190637u1748843dl8ba0dc8179d759f3@mail.gmail.com>
	<1466c1d60707190727rc5177b1g20009c04900222ec@mail.gmail.com>
	<63b4e4050707190756q656f4cabyf6743a2ea8f43b80@mail.gmail.com>
Message-ID: <9da4f4520707190844w2c6b60dcpdba97bb529f168c1@mail.gmail.com>

Hi Peter and Tim!

Thanks for the quick responses :) That makes sense to me.

What I would like to know as well: Is there any way to force the
existing Lock implementation ReentrantReadWriteLock to behave like
this?

Thanks a lot and cheers

Oliver

2007/7/19, Tim Peierls <tim at peierls.net>:
> Or, as Peter says, you could do the simple thing and avoid AQS. :-)
>
> As it stands, Peter's example doesn't implement j.u.c.locks.Lock -- and it
> would need a little work to provide Conditions and such, but it's a much
> simpler approach than what I suggested. Forget I said it.
>
> --tim
>
>
> On 7/19/07, Peter Veentjer <alarmnummer at gmail.com> wrote:
> >
> > Hi Oliver,
> >
> > You could use a binary semaphore for this situation. With a semaphore
> > you are allowed to do a down in one thread, and an up in another. You
> > have to watch out for recursive locks because they will lead to
> > deadlocks. And you also need to watch out for too many ups.
> >
> > example:
> >
> > class Lock{
> >         Sempahore s = new Semaphore(1);
> >
> >         void acquire(){
> >                 s.down();
> >         }
> >
> >         void release(){
> >                 s.up();
> >         }
> > }
> >
> >
> > On 7/19/07, Oliver Zeigermann <oliver at zeigermann.de> wrote:
> > > Hi experts!
> > >
> > > Is is possible to transfer locks (possibly of type
> > > java.util.concurrent.locks.ReentrantLock) held by one
> thread to
> > > another?
> > >
> > > Background is the question whether it is possible to implement
> > > concurrent data structures as resources of the the XA protocol. This
> > > protocol requires that its participants can suspend work for one
> > > thread and resume the work on another thread. This would require
> > > transfer of locks between threads.
> > >
> > > Is that possible?
> > >
> > > Thanks in advance and cheers
> > >
> > > Oliver
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>

From tim at peierls.net  Thu Jul 19 11:48:32 2007
From: tim at peierls.net (Tim Peierls)
Date: Thu, 19 Jul 2007 11:48:32 -0400
Subject: [concurrency-interest] Transferring locks between two threads:
	Possible?
In-Reply-To: <9da4f4520707190844w2c6b60dcpdba97bb529f168c1@mail.gmail.com>
References: <9da4f4520707190637u1748843dl8ba0dc8179d759f3@mail.gmail.com>
	<1466c1d60707190727rc5177b1g20009c04900222ec@mail.gmail.com>
	<63b4e4050707190756q656f4cabyf6743a2ea8f43b80@mail.gmail.com>
	<9da4f4520707190844w2c6b60dcpdba97bb529f168c1@mail.gmail.com>
Message-ID: <63b4e4050707190848k26d6c6f4i79872b0b4a21cc1b@mail.gmail.com>

No, because the exclusivity in RRWL depends on a thread owner.

--tim

On 7/19/07, Oliver Zeigermann <oliver at zeigermann.de> wrote:
>
> Hi Peter and Tim!
>
> Thanks for the quick responses :) That makes sense to me.
>
> What I would like to know as well: Is there any way to force the
> existing Lock implementation ReentrantReadWriteLock to behave like
> this?
>
> Thanks a lot and cheers
>
> Oliver
>
> 2007/7/19, Tim Peierls <tim at peierls.net>:
> > Or, as Peter says, you could do the simple thing and avoid AQS. :-)
> >
> > As it stands, Peter's example doesn't implement j.u.c.locks.Lock -- and
> it
> > would need a little work to provide Conditions and such, but it's a much
> > simpler approach than what I suggested. Forget I said it.
> >
> > --tim
> >
> >
> > On 7/19/07, Peter Veentjer <alarmnummer at gmail.com> wrote:
> > >
> > > Hi Oliver,
> > >
> > > You could use a binary semaphore for this situation. With a semaphore
> > > you are allowed to do a down in one thread, and an up in another. You
> > > have to watch out for recursive locks because they will lead to
> > > deadlocks. And you also need to watch out for too many ups.
> > >
> > > example:
> > >
> > > class Lock{
> > >         Sempahore s = new Semaphore(1);
> > >
> > >         void acquire(){
> > >                 s.down();
> > >         }
> > >
> > >         void release(){
> > >                 s.up();
> > >         }
> > > }
> > >
> > >
> > > On 7/19/07, Oliver Zeigermann <oliver at zeigermann.de> wrote:
> > > > Hi experts!
> > > >
> > > > Is is possible to transfer locks (possibly of type
> > > > java.util.concurrent.locks.ReentrantLock) held by one
> > thread to
> > > > another?
> > > >
> > > > Background is the question whether it is possible to implement
> > > > concurrent data structures as resources of the the XA protocol. This
> > > > protocol requires that its participants can suspend work for one
> > > > thread and resume the work on another thread. This would require
> > > > transfer of locks between threads.
> > > >
> > > > Is that possible?
> > > >
> > > > Thanks in advance and cheers
> > > >
> > > > Oliver
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > >
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > >
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070719/a6928fa9/attachment-0001.html 

From richard.zschech at mnetcorporation.com  Thu Jul 19 20:07:45 2007
From: richard.zschech at mnetcorporation.com (Richard Zschech)
Date: Fri, 20 Jul 2007 09:37:45 +0930
Subject: [concurrency-interest] Transferring locks between two threads:
 Possible?
In-Reply-To: <63b4e4050707190848k26d6c6f4i79872b0b4a21cc1b@mail.gmail.com>
References: <9da4f4520707190637u1748843dl8ba0dc8179d759f3@mail.gmail.com>
	<1466c1d60707190727rc5177b1g20009c04900222ec@mail.gmail.com>
	<63b4e4050707190756q656f4cabyf6743a2ea8f43b80@mail.gmail.com>
	<9da4f4520707190844w2c6b60dcpdba97bb529f168c1@mail.gmail.com>
	<63b4e4050707190848k26d6c6f4i79872b0b4a21cc1b@mail.gmail.com>
Message-ID: <469FFCD1.6090000@mnetcorporation.com>

This sounds a bit like what I was asking for back on 26 July 2003:

http://72.14.253.104/search?q=cache%3Ahttp%3A%2F%2Fosdir.com%2Fml%2Fjava.jsr.166-concurrency%2F2003-07%2Fmsg00017.html
http://72.14.253.104/search?q=cache%3Ahttp%3A%2F%2Fosdir.com%2Fml%2Fjava.jsr.166-concurrency%2F2003-07%2Fmsg00018.html

and it came up again 4 November 2003 see the lock manager thread:

http://72.14.253.104/search?q=cache:hnYo-PQBgvoJ:osdir.com/ml/java.jsr.166-concurrency/2003-11/index.html

 From Richard.


Tim Peierls wrote:
> No, because the exclusivity in RRWL depends on a thread owner.
>
> --tim
>
> On 7/19/07, *Oliver Zeigermann* <oliver at zeigermann.de 
> <mailto:oliver at zeigermann.de>> wrote:
>
>     Hi Peter and Tim!
>
>     Thanks for the quick responses :) That makes sense to me.
>
>     What I would like to know as well: Is there any way to force the
>     existing Lock implementation ReentrantReadWriteLock to behave like
>     this?
>
>     Thanks a lot and cheers
>
>     Oliver
>
>     2007/7/19, Tim Peierls < tim at peierls.net <mailto:tim at peierls.net>>:
>     > Or, as Peter says, you could do the simple thing and avoid AQS. :-)
>     >
>     > As it stands, Peter's example doesn't implement j.u.c.locks.Lock
>     -- and it
>     > would need a little work to provide Conditions and such, but
>     it's a much
>     > simpler approach than what I suggested. Forget I said it.
>     >
>     > --tim
>     >
>     >
>     > On 7/19/07, Peter Veentjer < alarmnummer at gmail.com
>     <mailto:alarmnummer at gmail.com>> wrote:
>     > >
>     > > Hi Oliver,
>     > >
>     > > You could use a binary semaphore for this situation. With a
>     semaphore
>     > > you are allowed to do a down in one thread, and an up in
>     another. You
>     > > have to watch out for recursive locks because they will lead to
>     > > deadlocks. And you also need to watch out for too many ups.
>     > >
>     > > example:
>     > >
>     > > class Lock{
>     > >         Sempahore s = new Semaphore(1);
>     > >
>     > >         void acquire(){
>     > >                 s.down();
>     > >         }
>     > >
>     > >         void release(){
>     > >                 s.up();
>     > >         }
>     > > }
>     > >
>     > >
>     > > On 7/19/07, Oliver Zeigermann <oliver at zeigermann.de
>     <mailto:oliver at zeigermann.de>> wrote:
>     > > > Hi experts!
>     > > >
>     > > > Is is possible to transfer locks (possibly of type
>     > > > java.util.concurrent.locks.ReentrantLock) held by one
>     > thread to
>     > > > another?
>     > > >
>     > > > Background is the question whether it is possible to implement
>     > > > concurrent data structures as resources of the the XA
>     protocol. This
>     > > > protocol requires that its participants can suspend work for
>     one
>     > > > thread and resume the work on another thread. This would require
>     > > > transfer of locks between threads.
>     > > >
>     > > > Is that possible?
>     > > >
>     > > > Thanks in advance and cheers
>     > > >
>     > > > Oliver
>     > > > _______________________________________________
>     > > > Concurrency-interest mailing list
>     > > > Concurrency-interest at altair.cs.oswego.edu
>     <mailto:Concurrency-interest at altair.cs.oswego.edu>
>     > > >
>     > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>     > > >
>     > > _______________________________________________
>     > > Concurrency-interest mailing list
>     > > Concurrency-interest at altair.cs.oswego.edu
>     <mailto:Concurrency-interest at altair.cs.oswego.edu>
>     > >
>     > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>     > >
>     >
>     >
>
>
> ------------------------------------------------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>   


-- 
Richard Zschech
Systems Integrator
m.Net Corporation Ltd

Level 2, 8 Leigh Street Adelaide 5000 South Australia

+61 8 8210 2046


From dcholmes at optusnet.com.au  Thu Jul 19 21:55:45 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 20 Jul 2007 11:55:45 +1000
Subject: [concurrency-interest] Transferring locks between two
	threads:Possible?
In-Reply-To: <9da4f4520707190637u1748843dl8ba0dc8179d759f3@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEOBHHAA.dcholmes@optusnet.com.au>

Oliver,

As noted the Lock interface does not support any transfer of lock ownership
and hence neither do any of the concrete implementations.

A synchronizer used as a "capability" or "token" (such as a binary
semaphore) is more suited for transferring - as it has no owner concept and
so a transfer is merely an agreed protocol amongst the users.

It is possible to define a "token" that has a concept of owner, but then the
transfer operation must be explicit.

The transfer protocol must also be carefully established and is most easily
done at the application level using some form of "handshake" between the
current and intended owner. Otherwise things can get rather "hairy" -
imagine an API that supported giveOwnershipTo(Thread newOwner) , if the
newOwner isn't aware it has gained ownership then it won't know that it
needs to release the "token".

What is this XA protocol that you are referring to? I always hear alarms
bells when I see "suspend" and "resume" being mentioned :)

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Oliver
> Zeigermann
> Sent: Thursday, 19 July 2007 11:38 PM
> To: concurrency-interest
> Subject: [concurrency-interest] Transferring locks between two
> threads:Possible?
>
>
> Hi experts!
>
> Is is possible to transfer locks (possibly of type
> java.util.concurrent.locks.ReentrantLock) held by one thread to
> another?
>
> Background is the question whether it is possible to implement
> concurrent data structures as resources of the the XA protocol. This
> protocol requires that its participants can suspend work for one
> thread and resume the work on another thread. This would require
> transfer of locks between threads.
>
> Is that possible?
>
> Thanks in advance and cheers
>
> Oliver
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From oliver at zeigermann.de  Fri Jul 20 11:53:19 2007
From: oliver at zeigermann.de (Oliver Zeigermann)
Date: Fri, 20 Jul 2007 17:53:19 +0200
Subject: [concurrency-interest] Transferring locks between two
	threads:Possible?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEOBHHAA.dcholmes@optusnet.com.au>
References: <9da4f4520707190637u1748843dl8ba0dc8179d759f3@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEOBHHAA.dcholmes@optusnet.com.au>
Message-ID: <9da4f4520707200853h5aed8196x72ee7d8ca6f1223d@mail.gmail.com>

Hi David!

Thanks for clarifying that!

The XA protocol is something really obscure and old, but the basis for JTA:

http://java.sun.com/products/jta/
http://www.subbu.org/articles/jts/JTS.html

It handles 2PC transactions.

This is what the user sees:

http://java.sun.com/products/jta/javadocs-1.0.1/javax/transaction/UserTransaction.html

This is what you have to implement in order to participate in a 2PC transaction:

http://java.sun.com/products/jta/javadocs-1.0.1/javax/transaction/xa/XAResource.html

which includes suspend and resume hidden behind the start() and end()
methods (pretty silly). The idea is to start work with one worker
thread and later continue with another one. Somehow reminds me of
continuations.

Locks could somehow be associated to the Xid:

http://java.sun.com/products/jta/javadocs-1.0.1/javax/transaction/xa/Xid.html

All that is implemented in every application server like JBoss,
Weblogic and Websphere. Having an xa implementation would thus allow
you to participate in 2PC transactions in a scenario manager by these
servers.

Anyway, the bottom line seems to be: If I want such a Lock
implementation I will have to write it myself. Not sure whether am up
to that task, though ;)

Cheers
Oliver

2007/7/20, David Holmes <dcholmes at optusnet.com.au>:
> Oliver,
>
> As noted the Lock interface does not support any transfer of lock ownership
> and hence neither do any of the concrete implementations.
>
> A synchronizer used as a "capability" or "token" (such as a binary
> semaphore) is more suited for transferring - as it has no owner concept and
> so a transfer is merely an agreed protocol amongst the users.
>
> It is possible to define a "token" that has a concept of owner, but then the
> transfer operation must be explicit.
>
> The transfer protocol must also be carefully established and is most easily
> done at the application level using some form of "handshake" between the
> current and intended owner. Otherwise things can get rather "hairy" -
> imagine an API that supported giveOwnershipTo(Thread newOwner) , if the
> newOwner isn't aware it has gained ownership then it won't know that it
> needs to release the "token".
>
> What is this XA protocol that you are referring to? I always hear alarms
> bells when I see "suspend" and "resume" being mentioned :)
>
> Cheers,
> David Holmes
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Oliver
> > Zeigermann
> > Sent: Thursday, 19 July 2007 11:38 PM
> > To: concurrency-interest
> > Subject: [concurrency-interest] Transferring locks between two
> > threads:Possible?
> >
> >
> > Hi experts!
> >
> > Is is possible to transfer locks (possibly of type
> > java.util.concurrent.locks.ReentrantLock) held by one thread to
> > another?
> >
> > Background is the question whether it is possible to implement
> > concurrent data structures as resources of the the XA protocol. This
> > protocol requires that its participants can suspend work for one
> > thread and resume the work on another thread. This would require
> > transfer of locks between threads.
> >
> > Is that possible?
> >
> > Thanks in advance and cheers
> >
> > Oliver
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From elihusmails at gmail.com  Tue Jul 24 09:51:21 2007
From: elihusmails at gmail.com (Mark Webb)
Date: Tue, 24 Jul 2007 09:51:21 -0400
Subject: [concurrency-interest] CopyOnWriteMap
Message-ID: <9f066ee90707240651v72ad9089i22f3895a1b6e13e3@mail.gmail.com>

I am looking to find an implementation of a CopyOnWriteMap.  It seems that
everything I have found only deals with lists.  Is there anything in the JDK
pipeline that would support such a class?

Thanks.

-- 
..Cheers
Mark
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070724/4cfdcc4c/attachment.html 

From amine.chadly at gmail.com  Fri Jul 27 16:42:32 2007
From: amine.chadly at gmail.com (Amine Chadly)
Date: Fri, 27 Jul 2007 22:42:32 +0200
Subject: [concurrency-interest] backport : release but don't awake behaviour
	?
Message-ID: <977c1d000707271342l5dd8a99qc2d25ab9c10d1741@mail.gmail.com>

Hi everybody,
We have been using the java backport jar without any trouble at all
for a long while... but recently we have put the program through
stress tests, and we have started to face some strange behaviour...
our application would freeze after a while...
I can 'hear' you thinking that there is absolutely nothing strange
about this... it does sound like a classical deadlock situation...
that's exactly what I thought, and I did get a java core with the
usual kill -3.
But then, when I read it, I have the feeling that there is no deadlock
at all... just sleeping threads that have not been awaked when the
owner of the resource they want has released it. It kinda seems
simalar to the troubles faced on the Linux 2.6.3-7 kernel for SMP as
they are described on the rebobustness page...
Can anyone infirm or confirm this analysis with the java core attachment ?
I tried to keep it small and cut it to the most interesting parts, let
me know if some additionnal information could prove useful.
All locks have been used in this simple way :
lock.lock();
try {
  work;
  work;
} finally {
  lock.unlock();
}
I will try to stress it with the tool bundled with the developer
distribution on monday (no more access to the test machine until
then), but wanted to see if anyone had an idea beforehand...
Thanks for reading ^^
-- 
  Amine Chadly
-------------- next part --------------
NULL           ------------------------------------------------------------------------
0SECTION       TITLE subcomponent dump routine
NULL           ===============================
1TISIGINFO     signal 3 received 
1TIDATETIME    Date:                 2007/07/27 at 17:00:01
1TIFILENAME    Javacore filename:    /tmp/javacore3399890.1185548401.txt
NULL           ------------------------------------------------------------------------
0SECTION       XHPI subcomponent dump routine
NULL           ==============================
1XHTIME        Fri Jul 27 17:00:01 2007
1XHSIGRECV     SIGQUIT received at 0x0 in <unknown>.
1XHFULLVERSION J2RE 1.4.2 IBM AIX build ca142-20050929a (SR3)
NULL           
1XHCURRENTTHD  Current Thread Details
NULL           ----------------------
2XHCURRSYSTHD      "Signal dispatcher" sys_thread_t:0x4AC68820
3XHNATIVESTACK       Native Stack
NULL                 ------------
3XHSTACKLINEERR      unavailable - stack address not valid
1XHOPENV       Operating Environment
NULL           ---------------------
2XHHOSTNAME    Host             : -------
2XHOSLEVEL     OS Level         : AIX 5.2.0.0
2XHCPUS        Processors -
3XHCPUARCH       Architecture   : POWER_PC (impl: unknown, ver: unknown)
3XHNUMCPUS       How Many       : 32
3XHCPUSENABLED   Enabled        : 6
NULL           
1XHUSERLIMITS  User Limits (in bytes except for NOFILE and NPROC) -
NULL           -----------
2XHUSERLIMIT   RLIMIT_FSIZE   : infinity
2XHUSERLIMIT   RLIMIT_DATA    : 2147483645
2XHUSERLIMIT   RLIMIT_STACK   : 2147483646
2XHUSERLIMIT   RLIMIT_CORE    : 1073741312
2XHUSERLIMIT   RLIMIT_NOFILE  : 2000
2XHLIMIT       NPROC(max)     : 512
NULL           
1XHPAGESPACES  Page Space (in blocks) -
NULL           ----------
2XHPAGESPACE     /dev/hd6: size=524288, free=519229
2XHPAGESPACE     /dev/paging00: size=524288, free=519954
NULL           
1XHSIGHANDLERS JVM Signal Handlers
NULL           -------------------
2XHSIGHANDLER  SIGINT         : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGQUIT        : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGILL         : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGTRAP        : JITSigTrapHandler (libjitc.a)
2XHSIGHANDLER  SIGABRT        : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGEMT         : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGFPE         : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGBUS         : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGSEGV        : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGSYS         : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGTERM        : intrDispatchMD (libhpi.a)
NULL           
1XHSIGHANDLERS Chained Signal Handlers
NULL           -----------------------
2XHSIGHANDLER  SIGHUP         : ignored
2XHSIGHANDLER  SIGINT         : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGQUIT        : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGILL         : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGTRAP        : JITSigTrapHandler (libjitc.a)
2XHSIGHANDLER  SIGABRT        : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGEMT         : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGFPE         : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGBUS         : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGSEGV        : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGSYS         : intrDispatchMD (libhpi.a)
2XHSIGHANDLER  SIGPIPE        : ignored
2XHSIGHANDLER  SIGTERM        : intrDispatchMD (libhpi.a)
NULL           
NULL           
1XHLOADEDLIBS  Loaded Libraries (sizes in bytes)
0SECTION       LK subcomponent dump routine
NULL           ============================
NULL           
1LKPOOLINFO    Monitor pool info:
2LKPOOLINIT      Initial monitor count: 32
2LKPOOLEXPNUM    Minimum number of free monitors before expansion: 5
2LKPOOLEXPBY     Pool will next be expanded by: 36
2LKPOOLTOTAL     Current total number of monitors: 72
2LKPOOLFREE      Current number of free monitors: 6
NULL           
1LKMONPOOLDUMP Monitor Pool Dump (flat & inflated object-monitors):
2LKMONINUSE      sys_mon_t:0x3001EAB8 infl_mon_t: 0x3001E528:
3LKMONOBJECT       java.lang.ref.Reference$Lock at 30140610/30140618: <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "Reference Handler" (0x4AC72E20)
2LKMONINUSE      sys_mon_t:0x3001EB68 infl_mon_t: 0x3001E554:
3LKMONOBJECT       java.lang.ref.ReferenceQueue$Lock at 30140348/30140350: <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "Finalizer" (0x4AD831A0)
2LKMONINUSE      sys_mon_t:0x3001EC18 infl_mon_t: 0x3001E580:
3LKMONOBJECT       java.util.TaskQueue at 310B6C38/310B6C40: <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "Thread-4" (0x4CD798A0)
2LKMONINUSE      sys_mon_t:0x3001ED78 infl_mon_t: 0x3001E5D8:
3LKMONOBJECT       java.util.ArrayList at 31110B40/31110B48: <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "SOE_F/com.inetpsa.cdn.commun.Message at 787e746d" (0x4CE2BD20)
2LKMONINUSE      sys_mon_t:0x3001EE28 infl_mon_t: 0x3001E604:
3LKMONOBJECT       java.util.TaskQueue at 377310A0/377310A8: <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "Thread-9" (0x4D2976A0)
2LKMONINUSE      sys_mon_t:0x4DBD2118 infl_mon_t: 0x4DBD173C:
3LKMONOBJECT       edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock at 32776D78/32776: <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "6" (0x4D75E520)
3LKWAITNOTIFY            "10" (0x4DB2DD20)
2LKMONINUSE      sys_mon_t:0x4DBD21C8 infl_mon_t: 0x4DBD1768:
3LKMONOBJECT       edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock at 3276E0D8/3276E: <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "8" (0x4D7691A0)
2LKMONINUSE      sys_mon_t:0x4DBD2328 infl_mon_t: 0x4DBD17C0:
3LKMONOBJECT       edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock at 32776D68/3277: <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "5" (0x4D75AF20)
2LKMONINUSE      sys_mon_t:0x4DBD2488 infl_mon_t: 0x4DBD1818:
3LKMONOBJECT       edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock at 32775368/32775: <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "1" (0x4CD038A0)
3LKWAITNOTIFY            "9" (0x4DAA6420)
2LKMONINUSE      sys_mon_t:0x4DBD2538 infl_mon_t: 0x4DBD1844:
3LKMONOBJECT       edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock at 32772258/32772: <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "4" (0x4CCD1B20)
2LKMONINUSE      sys_mon_t:0x4DBD25E8 infl_mon_t: 0x4DBD1870:
3LKMONOBJECT       edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock at 32772A18/3277: <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "3" (0x4CCAE5A0)
3LKWAITNOTIFY            "7" (0x4D761420)
2LKMONINUSE      sys_mon_t:0x4DBD2AB8 infl_mon_t: 0x4DBD19A4:
3LKMONOBJECT       edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock at 32775358/3277: <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "2" (0x4CC809A0)
NULL           
1LKREGMONDUMP  JVM System Monitor Dump (registered monitors):
2LKREGMON          JITC CHA lock (0x3006C088): <unowned>
2LKREGMON          JITC MB UPDATE lock (0x4BEAB0E8): <unowned>
2LKREGMON          JITC Global_Compile lock (0x4BEAB038): <unowned>
2LKREGMON          Integer lock access-lock (0x3006BED8): <unowned>
2LKREGMON          Free Class Loader Cache Entry lock (0x30060F88): <unowned>
2LKREGMON          IO lock (0x30060ED8): <unowned>
2LKREGMON          Evacuation Region lock (0x30060D78): <unowned>
2LKREGMON          Heap Promotion lock (0x30060CC8): <unowned>
2LKREGMON          Sleep lock (0x30060C18): <unowned>
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "FournisseurConnexion/executeur" (0x4D4016A0)
3LKWAITNOTIFY            "Thread-10" (0x4D408420)
2LKREGMON          Method trace lock (0x30060B68): <unowned>
2LKREGMON          Heap lock (0x300608A8): owner "Signal dispatcher" (0x4AC68820), entry count 1
2LKREGMON          Monitor Cache lock (0x30060748): owner "Signal dispatcher" (0x4AC68820), entry count 1
2LKREGMON          JNI Pinning lock (0x30060958): <unowned>
2LKREGMON          JNI Global Reference lock (0x300607F8): <unowned>
2LKREGMON          Classloader lock (0x30060AB8): <unowned>
2LKREGMON          Binclass lock (0x30060698): <unowned>
2LKREGMON          Thread queue lock (0x30015478): owner "Signal dispatcher" (0x4AC68820), entry count 1
3LKNOTIFYQ            Waiting to be notified:
3LKWAITNOTIFY            "Thread-2" (0x30015120)
2LKREGMON          Monitor Registry lock (0x30060A08): owner "Signal dispatcher" (0x4AC68820), entry count 1
2LKREGMON          System Heap lock (0x30020358): <unowned>
2LKREGMON          ACS Heap lock (0x30020408): <unowned>
2LKREGMON          PAM lock (0x300204B8): <unowned>
2LKREGMON          Intern String Table lock (0x30020568): <unowned>
2LKREGMON          Classloader lock (0x30020618): <unowned>
2LKREGMON          JIT Byte Code lock (0x300206C8): <unowned>
2LKREGMON          JIT Global Compile lock (0x30020778): <unowned>
2LKREGMON          JIT BINCLASS lock (0x30020828): <unowned>
2LKREGMON          JIT Debug lock (0x300208D8): <unowned>
2LKREGMON          JIT Log lock (0x30020988): <unowned>
2LKREGMON          JITmemT 1 lock (0x30020A38): <unowned>
2LKREGMON          JITspaceT 1 lock (0x30020AE8): <unowned>
2LKREGMON          JITcodeT 1 lock (0x30020B98): <unowned>
2LKREGMON          JITnccbT 1 lock (0x30020C48): <unowned>
2LKREGMON          JIT Invoke Interface Cache lock (0x30020CF8): <unowned>
2LKREGMON          JIT Class Map lock (0x30020DA8): <unowned>
2LKREGMON          JIT Code lock (0x30020E58): <unowned>
2LKREGMON          JITmblkT 1 lock (0x30020F08): <unowned>
2LKREGMON          JIT MB Update lock (0x30020FB8): <unowned>
2LKREGMON          Permanent Variable subpool lock (0x30021068): <unowned>
2LKREGMON          Intern String Buckets subpool lock (0x30021118): <unowned>
2LKREGMON          UTF8 Cache subpool lock (0x300211C8): <unowned>
2LKREGMON          Namespace Cache subpool lock (0x30021278): <unowned>
2LKREGMON          Class Storage subpool lock (0x30021328): <unowned>
2LKREGMON          CL Tables subpool lock (0x300213D8): <unowned>
2LKREGMON          JIT General subpool lock (0x30021488): <unowned>
NULL           
1LKFLATMONDUMP Thread identifiers (as used in flat monitors):
2LKFLATMON         ident 0x1E "10" (0x4DB2DD20) ee 0x4DB2DB00
2LKFLATMON         ident 0x1D "9" (0x4DAA6420) ee 0x4DAA6200
2LKFLATMON         ident 0x1C "8" (0x4D7691A0) ee 0x4D768F80
2LKFLATMON         ident 0x1B "7" (0x4D761420) ee 0x4D761200
2LKFLATMON         ident 0x1A "6" (0x4D75E520) ee 0x4D75E300
2LKFLATMON         ident 0x19 "5" (0x4D75AF20) ee 0x4D75AD00
2LKFLATMON         ident 0x18 "4" (0x4CCD1B20) ee 0x4CCD1900
2LKFLATMON         ident 0x17 "3" (0x4CCAE5A0) ee 0x4CCAE380
2LKFLATMON         ident 0x16 "2" (0x4CC809A0) ee 0x4CC80780
2LKFLATMON         ident 0x0E "1" (0x4CD038A0) ee 0x4CD03680
2LKFLATMON         ident 0x15 "Thread-10" (0x4D408420) ee 0x4D408200
2LKFLATMON         ident 0x14 "FournisseurConnexion/executeur" (0x4D4016A0) ee 0x4D401480
2LKFLATMON         ident 0x13 "Thread-9" (0x4D2976A0) ee 0x4D297480
2LKFLATMON         ident 0x12 "SOE_F/com.inetpsa.cdn.commun.Message at 787e746d" (0x4CE2BD20) ee 0x4CE2BB00
2LKFLATMON         ident 0x11 "SOR_F/com.inetpsa.cdn.commun.Message at 787e746d" (0x4CE287A0) ee 0x4CE28580
2LKFLATMON         ident 0x10 "Thread-5" (0x4CE17420) ee 0x4CE17200
2LKFLATMON         ident 0x0F "Thread-4" (0x4CD798A0) ee 0x4CD79680
2LKFLATMON         ident 0x02 "Thread-2" (0x30015120) ee 0x30014F00
2LKFLATMON         ident 0x0D "Thread-1" (0x4CB65920) ee 0x4CB65700
2LKFLATMON         ident 0x0B "GC Helper Reconfiguration Thread" (0x4B0B21A0) ee 0x4B0B1F80
2LKFLATMON         ident 0x05 "Finalizer" (0x4AD831A0) ee 0x4AD82F80
2LKFLATMON         ident 0x04 "Reference Handler" (0x4AC72E20) ee 0x4AC72C00
2LKFLATMON         ident 0x03 "Signal dispatcher" (0x4AC68820) ee 0x4AC68600
NULL           
1LKOBJMONDUMP  Java Object Monitor Dump (flat & inflated object-monitors):
2LKINFLATEDMON     java.lang.ref.ReferenceQueue$Lock at 30140348/30140350
3LKINFLDETAILS         locknflags 80000200 Monitor inflated infl_mon 0x3001E554
2LKINFLATEDMON     java.lang.ref.Reference$Lock at 30140610/30140618
3LKINFLDETAILS         locknflags 80000100 Monitor inflated infl_mon 0x3001E528
2LKFLATLOCKED      java.net.PlainSocketImpl at 30F6A4F0/30F6A4F8
3LKFLATDETAILS         locknflags 000D0000 Flat locked by thread ident 0x0D, entry count 1
2LKINFLATEDMON     java.util.TaskQueue at 310B6C38/310B6C40
3LKINFLDETAILS         locknflags 80000300 Monitor inflated infl_mon 0x3001E580
2LKFLATLOCKED      java.net.PlainSocketImpl at 310E83E8/310E83F0
3LKFLATDETAILS         locknflags 00100000 Flat locked by thread ident 0x10, entry count 1
2LKINFLATEDMON     java.util.ArrayList at 31110B40/31110B48
3LKINFLDETAILS         locknflags 80000500 Monitor inflated infl_mon 0x3001E5D8
2LKINFLATEDMON     edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock at 3276E0D8/3276E
3LKINFLDETAILS         locknflags 80003900 Monitor inflated infl_mon 0x4DBD1768
2LKINFLATEDMON     edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock at 32772258/32772
3LKINFLDETAILS         locknflags 80003E00 Monitor inflated infl_mon 0x4DBD1844
2LKINFLATEDMON     edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock at 32772A18/3277
3LKINFLDETAILS         locknflags 80003F00 Monitor inflated infl_mon 0x4DBD1870
2LKINFLATEDMON     edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock at 32775358/3277
3LKINFLDETAILS         locknflags 80004600 Monitor inflated infl_mon 0x4DBD19A4
2LKINFLATEDMON     edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock at 32775368/32775
3LKINFLDETAILS         locknflags 80003D00 Monitor inflated infl_mon 0x4DBD1818
2LKINFLATEDMON     edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock at 32776D68/3277
3LKINFLDETAILS         locknflags 80003B00 Monitor inflated infl_mon 0x4DBD17C0
2LKINFLATEDMON     edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock at 32776D78/32776
3LKINFLDETAILS         locknflags 80003800 Monitor inflated infl_mon 0x4DBD173C
2LKINFLATEDMON     java.util.TaskQueue at 377310A0/377310A8
3LKINFLDETAILS         locknflags 80000600 Monitor inflated infl_mon 0x3001E604
NULL           ------------------------------------------------------------------------

From dcholmes at optusnet.com.au  Fri Jul 27 23:33:12 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sat, 28 Jul 2007 13:33:12 +1000
Subject: [concurrency-interest] backport : release but don't awake
	behaviour?
In-Reply-To: <977c1d000707271342l5dd8a99qc2d25ab9c10d1741@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEPIHHAA.dcholmes@optusnet.com.au>

Your analysis seems correct. All threads are waiting for something. Whether
the issue is a lost notification bug or the failure of some other expected
event I can't say.

If you suspect lost notifications (ie failed wakeups) can you inspect the
state that the blocked threads are waiting on?

David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Amine
> Chadly
> Sent: Saturday, 28 July 2007 6:43 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] backport : release but don't awake
> behaviour?
>
>
> Hi everybody,
> We have been using the java backport jar without any trouble at all
> for a long while... but recently we have put the program through
> stress tests, and we have started to face some strange behaviour...
> our application would freeze after a while...
> I can 'hear' you thinking that there is absolutely nothing strange
> about this... it does sound like a classical deadlock situation...
> that's exactly what I thought, and I did get a java core with the
> usual kill -3.
> But then, when I read it, I have the feeling that there is no deadlock
> at all... just sleeping threads that have not been awaked when the
> owner of the resource they want has released it. It kinda seems
> simalar to the troubles faced on the Linux 2.6.3-7 kernel for SMP as
> they are described on the rebobustness page...
> Can anyone infirm or confirm this analysis with the java core attachment ?
> I tried to keep it small and cut it to the most interesting parts, let
> me know if some additionnal information could prove useful.
> All locks have been used in this simple way :
> lock.lock();
> try {
>   work;
>   work;
> } finally {
>   lock.unlock();
> }
> I will try to stress it with the tool bundled with the developer
> distribution on monday (no more access to the test machine until
> then), but wanted to see if anyone had an idea beforehand...
> Thanks for reading ^^
> --
>   Amine Chadly
>


From holger at wizards.de  Tue Jul 31 02:12:36 2007
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Tue, 31 Jul 2007 08:12:36 +0200
Subject: [concurrency-interest] Clarification of fair ReentrantLock behaviour
Message-ID: <46AED2D4.5000600@wizards.de>

Hi,

For a test case I need to enqueue multiple threads in guaranteed order;
the idea is to have the test acquire a fair ReentrantLock, start all
threads in the required order (letting them run into the lock), and then
unlock the accessed resource so that the first worker can go about its
business. All threads need to be pre-started to avoid timing
irregularities, and ordering is important since some of the threads will
cancel themselves, or be canceled, at various points in time.

Now one thing that confuses me a bit is the description of the scheduling
behaviour guarantees. Quote:
"..Note however, that fairness of locks does not guarantee fairness of
thread scheduling. Thus, one of many threads using a fair lock may obtain
it multiple times in succession while other active threads are not
progressing and not currently holding the lock."

I would not expect the fair lock to have any effect on thread scheduling,
but what I do expect is that it provides at least a basic ordering
guarantee: the exact order of blocking. As far as I'm concerned blocked
threads can wake up and jump around in the background all they want as
long as they only acquire the lock in order. Looking at the implementation
I see that fair lock uses an enqueueing mechanism for waiting threads,
therefore I think the basic ordering is always done. Is this actually
true, and the last part of the quoted paragraph simply means that threads
can be woken up & spin while waiting for the lock?

Thanks
Holger

From dcholmes at optusnet.com.au  Tue Jul 31 02:34:33 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 31 Jul 2007 16:34:33 +1000
Subject: [concurrency-interest] Clarification of fair ReentrantLock
	behaviour
In-Reply-To: <46AED2D4.5000600@wizards.de>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEPPHHAA.dcholmes@optusnet.com.au>

Holger,

The fair ReentrantLock will wakeup the oldest waiting thread whenever the
lock is released and prevents barging - provided lock() is used, not
tryLock. So if your code guarantees the order in which the threads block on
the lock, then the lock will preserve that order.

The comment re scheduling guarantees was just a caveat that you need more
than a fair lock to get predictable scheduling order.

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Holger
> Hoffstatte
> Sent: Tuesday, 31 July 2007 4:13 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Clarification of fair ReentrantLock
> behaviour
>
>
> Hi,
>
> For a test case I need to enqueue multiple threads in guaranteed order;
> the idea is to have the test acquire a fair ReentrantLock, start all
> threads in the required order (letting them run into the lock), and then
> unlock the accessed resource so that the first worker can go about its
> business. All threads need to be pre-started to avoid timing
> irregularities, and ordering is important since some of the threads will
> cancel themselves, or be canceled, at various points in time.
>
> Now one thing that confuses me a bit is the description of the scheduling
> behaviour guarantees. Quote:
> "..Note however, that fairness of locks does not guarantee fairness of
> thread scheduling. Thus, one of many threads using a fair lock may obtain
> it multiple times in succession while other active threads are not
> progressing and not currently holding the lock."
>
> I would not expect the fair lock to have any effect on thread scheduling,
> but what I do expect is that it provides at least a basic ordering
> guarantee: the exact order of blocking. As far as I'm concerned blocked
> threads can wake up and jump around in the background all they want as
> long as they only acquire the lock in order. Looking at the implementation
> I see that fair lock uses an enqueueing mechanism for waiting threads,
> therefore I think the basic ordering is always done. Is this actually
> true, and the last part of the quoted paragraph simply means that threads
> can be woken up & spin while waiting for the lock?
>
> Thanks
> Holger
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


