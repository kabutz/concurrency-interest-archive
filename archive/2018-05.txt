From ionutb83 at yahoo.com  Fri May  4 03:53:53 2018
From: ionutb83 at yahoo.com (Ionut)
Date: Fri, 4 May 2018 07:53:53 +0000 (UTC)
Subject: [concurrency-interest] Contended Locking Behavior
In-Reply-To: <141139054.2434386.1525096657283@mail.yahoo.com>
References: <141139054.2434386.1525096657283.ref@mail.yahoo.com>
 <141139054.2434386.1525096657283@mail.yahoo.com>
Message-ID: <790363208.555737.1525420433049@mail.yahoo.com>

 Hello All,
  Sorry for spam, any thoughts on this?
ThanksIonut
    On Monday, April 30, 2018, 4:57:43 PM GMT+3, Ionut Balosin <ionutbalosin at yahoo.com> wrote:  
 
 Hello All,

      I play with a stress test regarding contented locks in JDK 9.0.4 and I have observed below behavior which I would like to double check with you in order to correct my understanding:

- under a "relatively small - medium" contention (i.e. up to 64 threads accessing same lock) default locking scheme inside HotSpot JVM (-XX:+UseBiasedLocking -XX:-UseHeavyMonitors) seems to behave faster than using heavy monitors
- starting with higher number of threads (i.e. 64 threads in my test) enabling heavy monitors (-XX:-UseBiasedLocking -XX:+UseHeavyMonitors)  performs better

To sum up: my findings are that heavy monitors brings performance under really high contention however in cases where there are relatively small number of threads default locking scheme seems more beneficial (whatever high or small means ... probably it might be subject to hardware architecture)

My config: CPU: Intel Core i7 6700HQ / OS: Ubuntu x64 16.10

Can you confirm/infirm this?

Thanks
Ionut

  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180504/96abaf5c/attachment.html>

From kasperni at gmail.com  Wed May 23 19:40:13 2018
From: kasperni at gmail.com (Kasper Nielsen)
Date: Thu, 24 May 2018 01:40:13 +0200
Subject: [concurrency-interest] ConcurrentHashMap and Unsafe usage
Message-ID: <CAPs6153vz0_2xJoz0z4HARDvd2wXSa5CbLpbUM=NzCPPYQ46WA@mail.gmail.com>

Hi,

Now that most of the concurrent data structures in j.u.c have transitioned
to using VarHandle.
I was wondering why ConcurrentHashMap still uses Unsafe for its variables?

Cheers
  Kasper
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180524/93f312a2/attachment.html>

From dl at cs.oswego.edu  Wed May 23 19:56:02 2018
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 23 May 2018 19:56:02 -0400
Subject: [concurrency-interest] ConcurrentHashMap and Unsafe usage
In-Reply-To: <CAPs6153vz0_2xJoz0z4HARDvd2wXSa5CbLpbUM=NzCPPYQ46WA@mail.gmail.com>
References: <CAPs6153vz0_2xJoz0z4HARDvd2wXSa5CbLpbUM=NzCPPYQ46WA@mail.gmail.com>
Message-ID: <1e035d5b-e32f-3c1b-59b7-870ab083a0ac@cs.oswego.edu>

On 05/23/2018 07:40 PM, Kasper Nielsen via Concurrency-interest wrote:
> Hi,
> 
> Now that most of the concurrent data structures in j.u.c have
> transitioned to using VarHandle.
> I was wondering why ConcurrentHashMap still uses Unsafe for its variables?
> 

Bootstrapping. The VM code to compile VarHandles relies on
ConcurrentHashMap. People have looked into somehow changing this, but
nothing seems better than just allowing this to continue.

-Doug


From paul.sandoz at oracle.com  Wed May 23 21:13:08 2018
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Wed, 23 May 2018 18:13:08 -0700
Subject: [concurrency-interest] ConcurrentHashMap and Unsafe usage
In-Reply-To: <1e035d5b-e32f-3c1b-59b7-870ab083a0ac@cs.oswego.edu>
References: <CAPs6153vz0_2xJoz0z4HARDvd2wXSa5CbLpbUM=NzCPPYQ46WA@mail.gmail.com>
 <1e035d5b-e32f-3c1b-59b7-870ab083a0ac@cs.oswego.edu>
Message-ID: <92F47E88-4DF5-4EBE-A25F-8D1AF73C31CF@oracle.com>



> On May 23, 2018, at 4:56 PM, Doug Lea via Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
> 
> On 05/23/2018 07:40 PM, Kasper Nielsen via Concurrency-interest wrote:
>> Hi,
>> 
>> Now that most of the concurrent data structures in j.u.c have
>> transitioned to using VarHandle.
>> I was wondering why ConcurrentHashMap still uses Unsafe for its variables?
>> 
> 
> Bootstrapping. The VM code to compile VarHandles relies on
> ConcurrentHashMap. People have looked into somehow changing this, but
> nothing seems better than just allowing this to continue.
> 

Right. It seems possible and we have looked into it and other areas like in ThreadLocalRandom [*], but priority wise (for me at least) it always got bumped down in the priority queue of stuff to do.
 
Paul.

[*] One the challenge is to tease apart CMH usage from some areas of the java.lang.invoke implementation and replace with something similar but more focused. Another is to make VarHandle allocations lazy (e.g. if we could ldc a VarHandle and express that in the Java language and byte code, we can already do the latter with constant dynamic).

From martinrb at google.com  Wed May 30 13:36:36 2018
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 30 May 2018 10:36:36 -0700
Subject: [concurrency-interest] Durations in existing JDK APIs
In-Reply-To: <CAB3z6AjVdR5STouvSB2ukzkzf1OBnRDt3=e5K+u_DWvOH0R_6g@mail.gmail.com>
References: <CAB3z6AiFY7dnVH7BRtFuGzF4=G5kgkqezpP+NDS-NRTukA1DKA@mail.gmail.com>
 <CAB3z6Ai4pN4ga3V6ZeU=zZJAF23uopTEiJMknRROSqLuGKU4=Q@mail.gmail.com>
 <CAB3z6AjVdR5STouvSB2ukzkzf1OBnRDt3=e5K+u_DWvOH0R_6g@mail.gmail.com>
Message-ID: <CA+kOe08D+0RYqKyu2KJzOp5gHidbTPEt54FNkp0HQPu56BzJtQ@mail.gmail.com>

Obvious progress would seem to be more conversion methods.  Conversion code
tends to be annoying/errorprone because of having to deal with overflow.

Stephen/Doug: is there any reason we didn't add conversions between
Duration and TimeUnit when we added conversions to ChronoUnit?

Here's a strawman:

    /**
     * Converts the given time duration to this unit.
     *
     * @param duration the time duration
     * @return the converted duration in this unit,
     * or {@code Long.MIN_VALUE} if conversion would negatively overflow,
     * or {@code Long.MAX_VALUE} if it would positively overflow.
     */
    public long convert(Duration duration) {
        long s = convert(duration.getSeconds(), SECONDS);
        if (s == Long.MIN_VALUE) return s;
        long n = convert(duration.getNano(), NANOSECONDS);
        assert n >= 0 && n < 1_000_000_000;
        return (s + n < s) ? Long.MAX_VALUE : s + n;
    }
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180530/8b94bcb5/attachment.html>

From dl at cs.oswego.edu  Wed May 30 14:32:46 2018
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 30 May 2018 14:32:46 -0400
Subject: [concurrency-interest] Durations in existing JDK APIs
In-Reply-To: <CA+kOe08D+0RYqKyu2KJzOp5gHidbTPEt54FNkp0HQPu56BzJtQ@mail.gmail.com>
References: <CAB3z6AiFY7dnVH7BRtFuGzF4=G5kgkqezpP+NDS-NRTukA1DKA@mail.gmail.com>
 <CAB3z6Ai4pN4ga3V6ZeU=zZJAF23uopTEiJMknRROSqLuGKU4=Q@mail.gmail.com>
 <CAB3z6AjVdR5STouvSB2ukzkzf1OBnRDt3=e5K+u_DWvOH0R_6g@mail.gmail.com>
 <CA+kOe08D+0RYqKyu2KJzOp5gHidbTPEt54FNkp0HQPu56BzJtQ@mail.gmail.com>
Message-ID: <1236a3de-dd83-b2f6-c9e2-c80ee4603203@cs.oswego.edu>


Kurt's initial post did not make it to concurrency-interest. At this
point, it is probably least confusing if interested readers who aren't
on core-libs-dev follow this on archives:
http://mail.openjdk.java.net/mailman/listinfo/core-libs-dev

On 05/30/2018 01:36 PM, Martin Buchholz wrote:
> Obvious progress would seem to be more conversion methods.  Conversion code
> tends to be annoying/errorprone because of having to deal with overflow.
> 
> Stephen/Doug: is there any reason we didn't add conversions between
> Duration and TimeUnit when we added conversions to ChronoUnit?

No. I agree that we should have at least this one.

The original rationale for designing j.u.c.TimeUnit using the Flyweight
pattern was to to reduce allocation and GC-related overhead and timing
jitter for methods that otherwise may operate on the order of
nanoseconds. But there are many cases in which this is not much of a
concern (plus JVMs can now sometimes optimize), so people should be
given a choice. It would be a lot of tedious work (and aggregate code
bulk) to retrofit every time-related j.u.c method though, and it's not
clear where to compromise. But at least adding converters should not be
controversial.

-Doug


> 
> Here's a strawman:
> 
>     /**
>      * Converts the given time duration to this unit.
>      *
>      * @param duration the time duration
>      * @return the converted duration in this unit,
>      * or {@code Long.MIN_VALUE} if conversion would negatively overflow,
>      * or {@code Long.MAX_VALUE} if it would positively overflow.
>      */
>     public long convert(Duration duration) {
>         long s = convert(duration.getSeconds(), SECONDS);
>         if (s == Long.MIN_VALUE) return s;
>         long n = convert(duration.getNano(), NANOSECONDS);
>         assert n >= 0 && n < 1_000_000_000;
>         return (s + n < s) ? Long.MAX_VALUE : s + n;
>     }
> 


From martinrb at google.com  Wed May 30 20:19:05 2018
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 30 May 2018 17:19:05 -0700
Subject: [concurrency-interest] Durations in existing JDK APIs
In-Reply-To: <1236a3de-dd83-b2f6-c9e2-c80ee4603203@cs.oswego.edu>
References: <CAB3z6AiFY7dnVH7BRtFuGzF4=G5kgkqezpP+NDS-NRTukA1DKA@mail.gmail.com>
 <CAB3z6Ai4pN4ga3V6ZeU=zZJAF23uopTEiJMknRROSqLuGKU4=Q@mail.gmail.com>
 <CAB3z6AjVdR5STouvSB2ukzkzf1OBnRDt3=e5K+u_DWvOH0R_6g@mail.gmail.com>
 <CA+kOe08D+0RYqKyu2KJzOp5gHidbTPEt54FNkp0HQPu56BzJtQ@mail.gmail.com>
 <1236a3de-dd83-b2f6-c9e2-c80ee4603203@cs.oswego.edu>
Message-ID: <CA+kOe0-3PGAUHeTSAZw3LZ8nOZBvh6uob1sTbjVvADOBuM8ovw@mail.gmail.com>

v.0.2 has both conversion methods in TimeUnit.  The unexpected weirdness is
that convert(Duration) saturates while toDuration throws
ArithmeticException, but both seem author-culture-consistent.  Perhaps
TimeUnit#toDuration doesn't provide enough value in view of the existing
Duration.of and TimeUnit#toChronoUnit.  And most of the time you'd expect
to convert from Duration to long, just before calling a TimeUnit based
method.

    /**
     * Converts the given time duration to this unit.
     *
     * @param duration the time duration
     * @return the converted duration in this unit,
     * or {@code Long.MIN_VALUE} if conversion would negatively overflow,
     * or {@code Long.MAX_VALUE} if it would positively overflow.
     * @throws NullPointerException if {@code duration} is null
     */
    public long convert(Duration duration) {
        long s = convert(duration.getSeconds(), SECONDS);
        if (s == Long.MIN_VALUE) return s;
        long n = convert(duration.getNano(), NANOSECONDS);
        assert n >= 0 && n < 1_000_000_000;
        return (s + n < s) ? Long.MAX_VALUE : s + n;
    }

    /**
     * Converts the given time duration in this unit to a Duration.
     *
     * @param duration the time duration
     * @return the time duration represented as a Duration
     * @throws ArithmeticException if the duration cannot be represented
     * as a Duration due to numeric overflow
     */
    public Duration toDuration(long duration) {
        return Duration.of(duration, toChronoUnit());
    }
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180530/c9e6be6b/attachment.html>

From gergg at cox.net  Wed May 30 22:43:21 2018
From: gergg at cox.net (Gregg Wonderly)
Date: Wed, 30 May 2018 21:43:21 -0500
Subject: [concurrency-interest] Durations in existing JDK APIs
In-Reply-To: <soKl1x02E02hR0p01oKoq0>
References: <CAB3z6AiFY7dnVH7BRtFuGzF4=G5kgkqezpP+NDS-NRTukA1DKA@mail.gmail.com>
 <CAB3z6Ai4pN4ga3V6ZeU=zZJAF23uopTEiJMknRROSqLuGKU4=Q@mail.gmail.com>
 <CAB3z6AjVdR5STouvSB2ukzkzf1OBnRDt3=e5K+u_DWvOH0R_6g@mail.gmail.com>
 <CA+kOe08D+0RYqKyu2KJzOp5gHidbTPEt54FNkp0HQPu56BzJtQ@mail.gmail.com>
 <1236a3de-dd83-b2f6-c9e2-c80ee4603203@cs.oswego.edu> <soKl1x02E02hR0p01oKoq0>
Message-ID: <4EA2D618-56CD-4981-8A57-C9351553D428@cox.net>

I am not sure I understand this implementation, but isn’t 

>        long s = convert(duration.getSeconds(), SECONDS);

needing to actually be

>        long s = convert(duration.getSeconds(), NANOSECONDS);

so that s+n is in a common unit of measure?

Gregg

> On May 30, 2018, at 7:19 PM, Martin Buchholz via Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
> 
> v.0.2 has both conversion methods in TimeUnit.  The unexpected weirdness is that convert(Duration) saturates while toDuration throws ArithmeticException, but both seem author-culture-consistent.  Perhaps TimeUnit#toDuration doesn't provide enough value in view of the existing Duration.of and TimeUnit#toChronoUnit.  And most of the time you'd expect to convert from Duration to long, just before calling a TimeUnit based method.
> 
>     /**
>      * Converts the given time duration to this unit.
>      *
>      * @param duration the time duration
>      * @return the converted duration in this unit,
>      * or {@code Long.MIN_VALUE} if conversion would negatively overflow,
>      * or {@code Long.MAX_VALUE} if it would positively overflow.
>      * @throws NullPointerException if {@code duration} is null
>      */
>     public long convert(Duration duration) {
>         long s = convert(duration.getSeconds(), SECONDS);
>         if (s == Long.MIN_VALUE) return s;
>         long n = convert(duration.getNano(), NANOSECONDS);
>         assert n >= 0 && n < 1_000_000_000;
>         return (s + n < s) ? Long.MAX_VALUE : s + n;
>     }
> 
>     /**
>      * Converts the given time duration in this unit to a Duration.
>      *
>      * @param duration the time duration
>      * @return the time duration represented as a Duration
>      * @throws ArithmeticException if the duration cannot be represented
>      * as a Duration due to numeric overflow
>      */
>     public Duration toDuration(long duration) {
>         return Duration.of(duration, toChronoUnit());
>     }
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From martinrb at google.com  Thu May 31 01:03:23 2018
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 30 May 2018 22:03:23 -0700
Subject: [concurrency-interest] Durations in existing JDK APIs
In-Reply-To: <4EA2D618-56CD-4981-8A57-C9351553D428@cox.net>
References: <CAB3z6AiFY7dnVH7BRtFuGzF4=G5kgkqezpP+NDS-NRTukA1DKA@mail.gmail.com>
 <CAB3z6Ai4pN4ga3V6ZeU=zZJAF23uopTEiJMknRROSqLuGKU4=Q@mail.gmail.com>
 <CAB3z6AjVdR5STouvSB2ukzkzf1OBnRDt3=e5K+u_DWvOH0R_6g@mail.gmail.com>
 <CA+kOe08D+0RYqKyu2KJzOp5gHidbTPEt54FNkp0HQPu56BzJtQ@mail.gmail.com>
 <1236a3de-dd83-b2f6-c9e2-c80ee4603203@cs.oswego.edu>
 <4EA2D618-56CD-4981-8A57-C9351553D428@cox.net>
Message-ID: <CA+kOe0-jo8_0MdBU_WWuwshiha14eLOfSWCskm0uHf0455KTzA@mail.gmail.com>

On Wed, May 30, 2018 at 7:43 PM, Gregg Wonderly <gergg at cox.net> wrote:

> I am not sure I understand this implementation, but isn’t
>
> >        long s = convert(duration.getSeconds(), SECONDS);
>
> needing to actually be
>
> >        long s = convert(duration.getSeconds(), NANOSECONDS);
>
> so that s+n is in a common unit of measure?
>

I haven't actually run this code yet, but from looking at the javadoc both
calls to convert give something in "this" unit, so they should agree?
You could write a test to check our understanding?  Hmmm ... alright ...
here's a passing test:


    /**
     * tests for conversion between TimeUnit and Duration
     */
    public void testDuration() throws Exception {
        ThreadLocalRandom rnd = ThreadLocalRandom.current();
        long n = rnd.nextLong();
        assertEquals(n, NANOSECONDS.convert(Duration.ofNanos(n)));
        assertEquals(n, MILLISECONDS.convert(Duration.ofMillis(n)));
        assertEquals(n, SECONDS.convert(Duration.ofSeconds(n)));
        assertEquals(n /= 60, MINUTES.convert(Duration.ofMinutes(n)));
        assertEquals(n /= 60, HOURS.convert(Duration.ofHours(n)));
        assertEquals(n /= 24, DAYS.convert(Duration.ofDays(n)));
    }
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180530/7d0deb69/attachment-0001.html>

From shevek at anarres.org  Thu May 31 01:07:09 2018
From: shevek at anarres.org (Shevek)
Date: Wed, 30 May 2018 22:07:09 -0700
Subject: [concurrency-interest] Unsynchronized lazy conditions
Message-ID: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>

Hi,

I'd like to issue a warning message a relatively low number of times in 
a multi-threaded application. My code is this:

class Foo {
   private boolean warned;

   public void run() {
     if (!warned) {
        LOG.warn("Warning");
        warned = true;
     }
   }
}

This is the only access to the variable 'warned', the value change is 
deliberately unsynchronized, and monotonic. Am I right to believe that:

* The first call WILL issue a warning.
* Any thread will issue the warning AT MOST once.
* Some (later) threads may not issue the warning, if the updated value 
is flushed to the heap and they load it?

Is there a better way to do this without sacrificing performance? Is 
this what the mysterious AtomicBoolean.lazySet, or even 
weakCompareAndSet is about?

This is right in the middle of something very concurrent which runs for 
a long time, so reducing overhead is far more important than 
occasionally issuing too many warnings.

Thank you.

S.

From peter.levart at gmail.com  Thu May 31 02:06:47 2018
From: peter.levart at gmail.com (Peter Levart)
Date: Thu, 31 May 2018 08:06:47 +0200
Subject: [concurrency-interest] Durations in existing JDK APIs
In-Reply-To: <CA+kOe08D+0RYqKyu2KJzOp5gHidbTPEt54FNkp0HQPu56BzJtQ@mail.gmail.com>
References: <CAB3z6AiFY7dnVH7BRtFuGzF4=G5kgkqezpP+NDS-NRTukA1DKA@mail.gmail.com>
 <CAB3z6Ai4pN4ga3V6ZeU=zZJAF23uopTEiJMknRROSqLuGKU4=Q@mail.gmail.com>
 <CAB3z6AjVdR5STouvSB2ukzkzf1OBnRDt3=e5K+u_DWvOH0R_6g@mail.gmail.com>
 <CA+kOe08D+0RYqKyu2KJzOp5gHidbTPEt54FNkp0HQPu56BzJtQ@mail.gmail.com>
Message-ID: <c7ead06e-ab0d-6851-2566-4166a73d0d3d@gmail.com>

Just thinking loud...

On 05/30/18 19:36, Martin Buchholz wrote:
> Obvious progress would seem to be more conversion methods.  Conversion code
> tends to be annoying/errorprone because of having to deal with overflow.
>
> Stephen/Doug: is there any reason we didn't add conversions between
> Duration and TimeUnit when we added conversions to ChronoUnit?
>
> Here's a strawman:
>
>      /**
>       * Converts the given time duration to this unit.
>       *
>       * @param duration the time duration
>       * @return the converted duration in this unit,
>       * or {@code Long.MIN_VALUE} if conversion would negatively overflow,
>       * or {@code Long.MAX_VALUE} if it would positively overflow.
>       */
>      public long convert(Duration duration) {
>          long s = convert(duration.getSeconds(), SECONDS);
>          if (s == Long.MIN_VALUE) return s;
>          long n = convert(duration.getNano(), NANOSECONDS);
>          assert n >= 0 && n < 1_000_000_000;
>          return (s + n < s) ? Long.MAX_VALUE : s + n;
>      }

Duration object has a big range (Long.MIN_VALUE ... Long.MAX_VALUE 
seconds) and a nanosecond precision. Both can not always be expressed as 
a pair of (TimeUnit, long) which are the usual parameter(s) of some 
methods. Above API proposal leaves the decision which TimeUnit to choose 
for conversion to the programmer. Would a pair of methods on Duration 
that return a TimeUnit and a long make sense here? The Duration could 
choose TimeUnit so that returned (TimeUnit, long) pair would be as 
precise as possible and still not overflow (like a floating point)...

Peter

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/a8137f6a/attachment.html>

From martinrb at google.com  Thu May 31 03:13:05 2018
From: martinrb at google.com (Martin Buchholz)
Date: Thu, 31 May 2018 00:13:05 -0700
Subject: [concurrency-interest] Durations in existing JDK APIs
In-Reply-To: <c7ead06e-ab0d-6851-2566-4166a73d0d3d@gmail.com>
References: <CAB3z6AiFY7dnVH7BRtFuGzF4=G5kgkqezpP+NDS-NRTukA1DKA@mail.gmail.com>
 <CAB3z6Ai4pN4ga3V6ZeU=zZJAF23uopTEiJMknRROSqLuGKU4=Q@mail.gmail.com>
 <CAB3z6AjVdR5STouvSB2ukzkzf1OBnRDt3=e5K+u_DWvOH0R_6g@mail.gmail.com>
 <CA+kOe08D+0RYqKyu2KJzOp5gHidbTPEt54FNkp0HQPu56BzJtQ@mail.gmail.com>
 <c7ead06e-ab0d-6851-2566-4166a73d0d3d@gmail.com>
Message-ID: <CA+kOe09ocG6SRKROvU4-YS_8-Pu9OwROrGN5DmzXRDC7NMzrzg@mail.gmail.com>

In j.u.concurrent the APIs bottom out in something that just takes a long
nanos, like LockSupport.parkNanos, so there's no advantage to converting to
TimeUnit-based durations greater than 292 years.  And returning multiple
values in Java remains clumsy.

On Wed, May 30, 2018 at 11:06 PM, Peter Levart <peter.levart at gmail.com>
wrote:

> Just thinking loud...
>
>
> On 05/30/18 19:36, Martin Buchholz wrote:
>
> Obvious progress would seem to be more conversion methods.  Conversion code
> tends to be annoying/errorprone because of having to deal with overflow.
>
> Stephen/Doug: is there any reason we didn't add conversions between
> Duration and TimeUnit when we added conversions to ChronoUnit?
>
> Here's a strawman:
>
>     /**
>      * Converts the given time duration to this unit.
>      *
>      * @param duration the time duration
>      * @return the converted duration in this unit,
>      * or {@code Long.MIN_VALUE} if conversion would negatively overflow,
>      * or {@code Long.MAX_VALUE} if it would positively overflow.
>      */
>     public long convert(Duration duration) {
>         long s = convert(duration.getSeconds(), SECONDS);
>         if (s == Long.MIN_VALUE) return s;
>         long n = convert(duration.getNano(), NANOSECONDS);
>         assert n >= 0 && n < 1_000_000_000;
>         return (s + n < s) ? Long.MAX_VALUE : s + n;
>     }
>
>
> Duration object has a big range (Long.MIN_VALUE ... Long.MAX_VALUE
> seconds) and a nanosecond precision. Both can not always be expressed as a
> pair of (TimeUnit, long) which are the usual parameter(s) of some methods.
> Above API proposal leaves the decision which TimeUnit to choose for
> conversion to the programmer. Would a pair of methods on Duration that
> return a TimeUnit and a long make sense here? The Duration could choose
> TimeUnit so that returned (TimeUnit, long) pair would be as precise as
> possible and still not overflow (like a floating point)...
>
> Peter
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/305b9bfc/attachment.html>

From scolebourne at joda.org  Thu May 31 03:32:42 2018
From: scolebourne at joda.org (Stephen Colebourne)
Date: Thu, 31 May 2018 08:32:42 +0100
Subject: [concurrency-interest] Durations in existing JDK APIs
In-Reply-To: <CA+kOe0-3PGAUHeTSAZw3LZ8nOZBvh6uob1sTbjVvADOBuM8ovw@mail.gmail.com>
References: <CAB3z6AiFY7dnVH7BRtFuGzF4=G5kgkqezpP+NDS-NRTukA1DKA@mail.gmail.com>
 <CAB3z6Ai4pN4ga3V6ZeU=zZJAF23uopTEiJMknRROSqLuGKU4=Q@mail.gmail.com>
 <CAB3z6AjVdR5STouvSB2ukzkzf1OBnRDt3=e5K+u_DWvOH0R_6g@mail.gmail.com>
 <CA+kOe08D+0RYqKyu2KJzOp5gHidbTPEt54FNkp0HQPu56BzJtQ@mail.gmail.com>
 <1236a3de-dd83-b2f6-c9e2-c80ee4603203@cs.oswego.edu>
 <CA+kOe0-3PGAUHeTSAZw3LZ8nOZBvh6uob1sTbjVvADOBuM8ovw@mail.gmail.com>
Message-ID: <CACzrW9B0jdvm7YKG77LG1Bjs9EEaJOTaj64dsUgwo32br5wRKQ@mail.gmail.com>

I'm not convinced TimeUnit::toDuration(long amount) has enough value.
We don't have a similar method on ChronoUnit

Duration.of(amount, timeUnit.toChronoUnit()) seems sufficient. Maybe
document this in the convert(Duration) method?

Stephen


On 31 May 2018 at 01:19, Martin Buchholz <martinrb at google.com> wrote:
> v.0.2 has both conversion methods in TimeUnit.  The unexpected weirdness is
> that convert(Duration) saturates while toDuration throws
> ArithmeticException, but both seem author-culture-consistent.  Perhaps
> TimeUnit#toDuration doesn't provide enough value in view of the existing
> Duration.of and TimeUnit#toChronoUnit.  And most of the time you'd expect to
> convert from Duration to long, just before calling a TimeUnit based method.
>
>     /**
>      * Converts the given time duration to this unit.
>      *
>      * @param duration the time duration
>      * @return the converted duration in this unit,
>      * or {@code Long.MIN_VALUE} if conversion would negatively overflow,
>      * or {@code Long.MAX_VALUE} if it would positively overflow.
>      * @throws NullPointerException if {@code duration} is null
>      */
>     public long convert(Duration duration) {
>         long s = convert(duration.getSeconds(), SECONDS);
>         if (s == Long.MIN_VALUE) return s;
>         long n = convert(duration.getNano(), NANOSECONDS);
>         assert n >= 0 && n < 1_000_000_000;
>         return (s + n < s) ? Long.MAX_VALUE : s + n;
>     }
>
>     /**
>      * Converts the given time duration in this unit to a Duration.
>      *
>      * @param duration the time duration
>      * @return the time duration represented as a Duration
>      * @throws ArithmeticException if the duration cannot be represented
>      * as a Duration due to numeric overflow
>      */
>     public Duration toDuration(long duration) {
>         return Duration.of(duration, toChronoUnit());
>     }
>

From shade at redhat.com  Thu May 31 03:51:18 2018
From: shade at redhat.com (Aleksey Shipilev)
Date: Thu, 31 May 2018 09:51:18 +0200
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
Message-ID: <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>

On 05/31/2018 07:07 AM, Shevek via Concurrency-interest wrote:
> Hi,
> 
> I'd like to issue a warning message a relatively low number of times in a multi-threaded
> application. My code is this:
> 
> class Foo {
>   private boolean warned;
> 
>   public void run() {
>     if (!warned) {
>        LOG.warn("Warning");
>        warned = true;
>     }
>   }
> }
> 
> This is the only access to the variable 'warned', the value change is deliberately unsynchronized,
> and monotonic. Am I right to believe that:
> 
> * The first call WILL issue a warning.

Yes.

> * Any thread will issue the warning AT MOST once.

Yes, I think so. It encroaches on darker corners of JMM, but it still does what you want, methinks.

> * Some (later) threads may not issue the warning, if the updated value is flushed to the heap and
> they load it?

Yes, except that "flushed to heap" part: that one is an implementation detail.


> Is there a better way to do this without sacrificing performance? Is this what the mysterious
> AtomicBoolean.lazySet, or even weakCompareAndSet is about?

The classic way to do this is to do test and test-and-set:

class Foo {
   private final AtomicBoolean warned;

   public void run() {
     if (!warned.get() && warned.compareAndSet(false, true)) {
       LOG.warn("Warning");
     }
   }
}

This gives you global only-once property, without sacrificing performance.

There are options how do you represent "warned". I'd start with AtomicBoolean, and then switched to
AtomicIntegerFieldUpdater over volatile field, or VarHandle if footprint became a problem. With
VarHandles, you can even mix the modes: make the first "test" in plain mode, and then do the CAS, if
first volatile check is too costly. But all of this is red herring until there is a pressing need.
One-off guards are doable with just AtomicBoolean.

-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/920eeac5/attachment-0001.sig>

From viktor.klang at gmail.com  Thu May 31 05:22:28 2018
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 31 May 2018 11:22:28 +0200
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
Message-ID: <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>

Aleksey's suggestion(s) is/are definitely cleaner than mine:

Depending on performance requirements the following might be cheaper,
of course assuming you can type-wise hide the AtomicBoolean inheritance
from consumer code:

class Foo extends AtomicBoolean { // No indirection due to the allocation
of AtomicBoolean
   public void run() {
     if (!get() && !getAndSet(true)) { // LOCK XCHG instead of LOCK CMPXCHG
       LOG.warn("Warning");
     }
   }
}

On Thu, May 31, 2018 at 9:51 AM, Aleksey Shipilev via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> On 05/31/2018 07:07 AM, Shevek via Concurrency-interest wrote:
> > Hi,
> >
> > I'd like to issue a warning message a relatively low number of times in
> a multi-threaded
> > application. My code is this:
> >
> > class Foo {
> >   private boolean warned;
> >
> >   public void run() {
> >     if (!warned) {
> >        LOG.warn("Warning");
> >        warned = true;
> >     }
> >   }
> > }
> >
> > This is the only access to the variable 'warned', the value change is
> deliberately unsynchronized,
> > and monotonic. Am I right to believe that:
> >
> > * The first call WILL issue a warning.
>
> Yes.
>
> > * Any thread will issue the warning AT MOST once.
>
> Yes, I think so. It encroaches on darker corners of JMM, but it still does
> what you want, methinks.
>
> > * Some (later) threads may not issue the warning, if the updated value
> is flushed to the heap and
> > they load it?
>
> Yes, except that "flushed to heap" part: that one is an implementation
> detail.
>
>
> > Is there a better way to do this without sacrificing performance? Is
> this what the mysterious
> > AtomicBoolean.lazySet, or even weakCompareAndSet is about?
>
> The classic way to do this is to do test and test-and-set:
>
> class Foo {
>    private final AtomicBoolean warned;
>
>    public void run() {
>      if (!warned.get() && warned.compareAndSet(false, true)) {
>        LOG.warn("Warning");
>      }
>    }
> }
>
> This gives you global only-once property, without sacrificing performance.
>
> There are options how do you represent "warned". I'd start with
> AtomicBoolean, and then switched to
> AtomicIntegerFieldUpdater over volatile field, or VarHandle if footprint
> became a problem. With
> VarHandles, you can even mix the modes: make the first "test" in plain
> mode, and then do the CAS, if
> first volatile check is too costly. But all of this is red herring until
> there is a pressing need.
> One-off guards are doable with just AtomicBoolean.
>
> -Aleksey
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/f29ab400/attachment.html>

From shade at redhat.com  Thu May 31 05:26:03 2018
From: shade at redhat.com (Aleksey Shipilev)
Date: Thu, 31 May 2018 11:26:03 +0200
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
Message-ID: <2ef199dd-db1d-f3c3-544a-d3f0da70a0b2@redhat.com>

On 05/31/2018 11:22 AM, Viktor Klang wrote:
> Aleksey's suggestion(s) is/are definitely cleaner than mine:
> 
> Depending on performance requirements the following might be cheaper,
> of course assuming you can type-wise hide the AtomicBoolean inheritance from consumer code:
> 
> class Foo extends AtomicBoolean { // No indirection due to the allocation of AtomicBoolean
>    public void run() {
>      if (!get() && !getAndSet(true)) { // LOCK XCHG instead of LOCK CMPXCHG
>        LOG.warn("Warning");
>      }
>    }
> }

Or that. I don't think we care about getAndSet vs compareAndSet all that much, since it is one-off
thing. The important thing is the first fast-path check.

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/dc59255b/attachment.sig>

From novitools.novi at web.de  Thu May 31 05:31:27 2018
From: novitools.novi at web.de (Novi)
Date: Thu, 31 May 2018 11:31:27 +0200
Subject: [concurrency-interest] thread safety of java.lang.reflect.Field
Message-ID: <op.zjvgquu3wcnyyd@novi-pc>

Hello,

I wonder if instances of java.lang.reflect.Field can be shared between
multiple threads as long as the accessibility flag is either not modified
or modified exactly once prior to a safe publication of the field
instances.

In other words, is it legal to cache instances of j.l.r.Field between
multiple threads?

Best Regards,
Novi


PS: The Bean Validation reference implementation Hibernate Validator seems
to cache instances of j.l.r.Field across threads. However, I couldn't find  
any
clue in the Java API documentation whether such a usage is supported or
not.

From viktor.klang at gmail.com  Thu May 31 05:51:14 2018
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 31 May 2018 11:51:14 +0200
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <2ef199dd-db1d-f3c3-544a-d3f0da70a0b2@redhat.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <2ef199dd-db1d-f3c3-544a-d3f0da70a0b2@redhat.com>
Message-ID: <CANPzfU-ja5U1t04iNC=KZare6ijeb7a=HevJzf2Z0RvbBMHFtw@mail.gmail.com>

On Thu, May 31, 2018 at 11:26 AM, Aleksey Shipilev <shade at redhat.com> wrote:

> On 05/31/2018 11:22 AM, Viktor Klang wrote:
> > Aleksey's suggestion(s) is/are definitely cleaner than mine:
> >
> > Depending on performance requirements the following might be cheaper,
> > of course assuming you can type-wise hide the AtomicBoolean inheritance
> from consumer code:
> >
> > class Foo extends AtomicBoolean { // No indirection due to the
> allocation of AtomicBoolean
> >    public void run() {
> >      if (!get() && !getAndSet(true)) { // LOCK XCHG instead of LOCK
> CMPXCHG
> >        LOG.warn("Warning");
> >      }
> >    }
> > }
>
> Or that. I don't think we care about getAndSet vs compareAndSet all that
> much, since it is one-off
> thing. The important thing is the first fast-path check.
>

Agreed. The difference in the first case is most likely eclipsed by the
cost of the logging call. And contention for the first invocation is likely
non-existant.


>
> Thanks,
> -Aleksey
>
>


-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/e59eeda0/attachment-0001.html>

From oleksandr.otenko at gmail.com  Thu May 31 05:58:24 2018
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 31 May 2018 10:58:24 +0100
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
Message-ID: <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>

The original requirement was it’s ok to sometimes log Warning several times. All this hacky atomicity is unnecessary. Just declare private volatile boolean warned, and leave the rest of the code as is.

Alex

> On 31 May 2018, at 10:22, Viktor Klang via Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
> 
> Aleksey's suggestion(s) is/are definitely cleaner than mine:
> 
> Depending on performance requirements the following might be cheaper,
> of course assuming you can type-wise hide the AtomicBoolean inheritance from consumer code:
> 
> class Foo extends AtomicBoolean { // No indirection due to the allocation of AtomicBoolean
>    public void run() {
>      if (!get() && !getAndSet(true)) { // LOCK XCHG instead of LOCK CMPXCHG
>        LOG.warn("Warning");
>      }
>    }
> }
> 
> On Thu, May 31, 2018 at 9:51 AM, Aleksey Shipilev via Concurrency-interest <concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>> wrote:
> On 05/31/2018 07:07 AM, Shevek via Concurrency-interest wrote:
> > Hi,
> > 
> > I'd like to issue a warning message a relatively low number of times in a multi-threaded
> > application. My code is this:
> > 
> > class Foo {
> >   private boolean warned;
> > 
> >   public void run() {
> >     if (!warned) {
> >        LOG.warn("Warning");
> >        warned = true;
> >     }
> >   }
> > }
> > 
> > This is the only access to the variable 'warned', the value change is deliberately unsynchronized,
> > and monotonic. Am I right to believe that:
> > 
> > * The first call WILL issue a warning.
> 
> Yes.
> 
> > * Any thread will issue the warning AT MOST once.
> 
> Yes, I think so. It encroaches on darker corners of JMM, but it still does what you want, methinks.
> 
> > * Some (later) threads may not issue the warning, if the updated value is flushed to the heap and
> > they load it?
> 
> Yes, except that "flushed to heap" part: that one is an implementation detail.
> 
> 
> > Is there a better way to do this without sacrificing performance? Is this what the mysterious
> > AtomicBoolean.lazySet, or even weakCompareAndSet is about?
> 
> The classic way to do this is to do test and test-and-set:
> 
> class Foo {
>    private final AtomicBoolean warned;
> 
>    public void run() {
>      if (!warned.get() && warned.compareAndSet(false, true)) {
>        LOG.warn("Warning");
>      }
>    }
> }
> 
> This gives you global only-once property, without sacrificing performance.
> 
> There are options how do you represent "warned". I'd start with AtomicBoolean, and then switched to
> AtomicIntegerFieldUpdater over volatile field, or VarHandle if footprint became a problem. With
> VarHandles, you can even mix the modes: make the first "test" in plain mode, and then do the CAS, if
> first volatile check is too costly. But all of this is red herring until there is a pressing need.
> One-off guards are doable with just AtomicBoolean.
> 
> -Aleksey
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 
> 
> 
> -- 
> Cheers,
> √
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/9833ad95/attachment.html>

From viktor.klang at gmail.com  Thu May 31 06:03:22 2018
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 31 May 2018 12:03:22 +0200
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
Message-ID: <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>

Or leave the field un-volatile and introduce a release fence before the
logging call?

On Thu, May 31, 2018 at 11:58 AM, Alex Otenko <oleksandr.otenko at gmail.com>
wrote:

> The original requirement was it’s ok to sometimes log Warning several
> times. All this hacky atomicity is unnecessary. Just declare private
> volatile boolean warned, and leave the rest of the code as is.
>
> Alex
>
>
> On 31 May 2018, at 10:22, Viktor Klang via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
>
> Aleksey's suggestion(s) is/are definitely cleaner than mine:
>
> Depending on performance requirements the following might be cheaper,
> of course assuming you can type-wise hide the AtomicBoolean inheritance
> from consumer code:
>
> class Foo extends AtomicBoolean { // No indirection due to the allocation
> of AtomicBoolean
>    public void run() {
>      if (!get() && !getAndSet(true)) { // LOCK XCHG instead of LOCK CMPXCHG
>        LOG.warn("Warning");
>      }
>    }
> }
>
> On Thu, May 31, 2018 at 9:51 AM, Aleksey Shipilev via Concurrency-interest
> <concurrency-interest at cs.oswego.edu> wrote:
>
>> On 05/31/2018 07:07 AM, Shevek via Concurrency-interest wrote:
>> > Hi,
>> >
>> > I'd like to issue a warning message a relatively low number of times in
>> a multi-threaded
>> > application. My code is this:
>> >
>> > class Foo {
>> >   private boolean warned;
>> >
>> >   public void run() {
>> >     if (!warned) {
>> >        LOG.warn("Warning");
>> >        warned = true;
>> >     }
>> >   }
>> > }
>> >
>> > This is the only access to the variable 'warned', the value change is
>> deliberately unsynchronized,
>> > and monotonic. Am I right to believe that:
>> >
>> > * The first call WILL issue a warning.
>>
>> Yes.
>>
>> > * Any thread will issue the warning AT MOST once.
>>
>> Yes, I think so. It encroaches on darker corners of JMM, but it still
>> does what you want, methinks.
>>
>> > * Some (later) threads may not issue the warning, if the updated value
>> is flushed to the heap and
>> > they load it?
>>
>> Yes, except that "flushed to heap" part: that one is an implementation
>> detail.
>>
>>
>> > Is there a better way to do this without sacrificing performance? Is
>> this what the mysterious
>> > AtomicBoolean.lazySet, or even weakCompareAndSet is about?
>>
>> The classic way to do this is to do test and test-and-set:
>>
>> class Foo {
>>    private final AtomicBoolean warned;
>>
>>    public void run() {
>>      if (!warned.get() && warned.compareAndSet(false, true)) {
>>        LOG.warn("Warning");
>>      }
>>    }
>> }
>>
>> This gives you global only-once property, without sacrificing performance.
>>
>> There are options how do you represent "warned". I'd start with
>> AtomicBoolean, and then switched to
>> AtomicIntegerFieldUpdater over volatile field, or VarHandle if footprint
>> became a problem. With
>> VarHandles, you can even mix the modes: make the first "test" in plain
>> mode, and then do the CAS, if
>> first volatile check is too costly. But all of this is red herring until
>> there is a pressing need.
>> One-off guards are doable with just AtomicBoolean.
>>
>> -Aleksey
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> --
> Cheers,
> √
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>


-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/489e0ce3/attachment.html>

From oleksandr.otenko at gmail.com  Thu May 31 06:05:38 2018
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 31 May 2018 11:05:38 +0100
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
Message-ID: <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>

Who cares to optimize the instruction that is going to be executed approximately once?

Alex

> On 31 May 2018, at 11:03, Viktor Klang <viktor.klang at gmail.com> wrote:
> 
> Or leave the field un-volatile and introduce a release fence before the logging call?
> 
> On Thu, May 31, 2018 at 11:58 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
> The original requirement was it’s ok to sometimes log Warning several times. All this hacky atomicity is unnecessary. Just declare private volatile boolean warned, and leave the rest of the code as is.
> 
> Alex
> 
> 
>> On 31 May 2018, at 10:22, Viktor Klang via Concurrency-interest <concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>> wrote:
>> 
>> Aleksey's suggestion(s) is/are definitely cleaner than mine:
>> 
>> Depending on performance requirements the following might be cheaper,
>> of course assuming you can type-wise hide the AtomicBoolean inheritance from consumer code:
>> 
>> class Foo extends AtomicBoolean { // No indirection due to the allocation of AtomicBoolean
>>    public void run() {
>>      if (!get() && !getAndSet(true)) { // LOCK XCHG instead of LOCK CMPXCHG
>>        LOG.warn("Warning");
>>      }
>>    }
>> }
>> 
>> On Thu, May 31, 2018 at 9:51 AM, Aleksey Shipilev via Concurrency-interest <concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>> wrote:
>> On 05/31/2018 07:07 AM, Shevek via Concurrency-interest wrote:
>> > Hi,
>> > 
>> > I'd like to issue a warning message a relatively low number of times in a multi-threaded
>> > application. My code is this:
>> > 
>> > class Foo {
>> >   private boolean warned;
>> > 
>> >   public void run() {
>> >     if (!warned) {
>> >        LOG.warn("Warning");
>> >        warned = true;
>> >     }
>> >   }
>> > }
>> > 
>> > This is the only access to the variable 'warned', the value change is deliberately unsynchronized,
>> > and monotonic. Am I right to believe that:
>> > 
>> > * The first call WILL issue a warning.
>> 
>> Yes.
>> 
>> > * Any thread will issue the warning AT MOST once.
>> 
>> Yes, I think so. It encroaches on darker corners of JMM, but it still does what you want, methinks.
>> 
>> > * Some (later) threads may not issue the warning, if the updated value is flushed to the heap and
>> > they load it?
>> 
>> Yes, except that "flushed to heap" part: that one is an implementation detail.
>> 
>> 
>> > Is there a better way to do this without sacrificing performance? Is this what the mysterious
>> > AtomicBoolean.lazySet, or even weakCompareAndSet is about?
>> 
>> The classic way to do this is to do test and test-and-set:
>> 
>> class Foo {
>>    private final AtomicBoolean warned;
>> 
>>    public void run() {
>>      if (!warned.get() && warned.compareAndSet(false, true)) {
>>        LOG.warn("Warning");
>>      }
>>    }
>> }
>> 
>> This gives you global only-once property, without sacrificing performance.
>> 
>> There are options how do you represent "warned". I'd start with AtomicBoolean, and then switched to
>> AtomicIntegerFieldUpdater over volatile field, or VarHandle if footprint became a problem. With
>> VarHandles, you can even mix the modes: make the first "test" in plain mode, and then do the CAS, if
>> first volatile check is too costly. But all of this is red herring until there is a pressing need.
>> One-off guards are doable with just AtomicBoolean.
>> 
>> -Aleksey
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>> 
>> 
>> 
>> 
>> -- 
>> Cheers,
>> √
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 
> 
> 
> -- 
> Cheers,
> √

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/7bfb91a4/attachment-0001.html>

From viktor.klang at gmail.com  Thu May 31 06:10:40 2018
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 31 May 2018 12:10:40 +0200
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
 <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
Message-ID: <CANPzfU_BFSRY=17r1ZR6k=oK9ris=HUfnc3_XpjV_rpyjuwATg@mail.gmail.com>

The OP?

On Thu, May 31, 2018 at 12:05 PM, Alex Otenko <oleksandr.otenko at gmail.com>
wrote:

> Who cares to optimize the instruction that is going to be executed
> approximately once?
>
> Alex
>
> On 31 May 2018, at 11:03, Viktor Klang <viktor.klang at gmail.com> wrote:
>
> Or leave the field un-volatile and introduce a release fence before the
> logging call?
>
> On Thu, May 31, 2018 at 11:58 AM, Alex Otenko <oleksandr.otenko at gmail.com>
> wrote:
>
>> The original requirement was it’s ok to sometimes log Warning several
>> times. All this hacky atomicity is unnecessary. Just declare private
>> volatile boolean warned, and leave the rest of the code as is.
>>
>> Alex
>>
>>
>> On 31 May 2018, at 10:22, Viktor Klang via Concurrency-interest <
>> concurrency-interest at cs.oswego.edu> wrote:
>>
>> Aleksey's suggestion(s) is/are definitely cleaner than mine:
>>
>> Depending on performance requirements the following might be cheaper,
>> of course assuming you can type-wise hide the AtomicBoolean inheritance
>> from consumer code:
>>
>> class Foo extends AtomicBoolean { // No indirection due to the allocation
>> of AtomicBoolean
>>    public void run() {
>>      if (!get() && !getAndSet(true)) { // LOCK XCHG instead of LOCK
>> CMPXCHG
>>        LOG.warn("Warning");
>>      }
>>    }
>> }
>>
>> On Thu, May 31, 2018 at 9:51 AM, Aleksey Shipilev via
>> Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
>>
>>> On 05/31/2018 07:07 AM, Shevek via Concurrency-interest wrote:
>>> > Hi,
>>> >
>>> > I'd like to issue a warning message a relatively low number of times
>>> in a multi-threaded
>>> > application. My code is this:
>>> >
>>> > class Foo {
>>> >   private boolean warned;
>>> >
>>> >   public void run() {
>>> >     if (!warned) {
>>> >        LOG.warn("Warning");
>>> >        warned = true;
>>> >     }
>>> >   }
>>> > }
>>> >
>>> > This is the only access to the variable 'warned', the value change is
>>> deliberately unsynchronized,
>>> > and monotonic. Am I right to believe that:
>>> >
>>> > * The first call WILL issue a warning.
>>>
>>> Yes.
>>>
>>> > * Any thread will issue the warning AT MOST once.
>>>
>>> Yes, I think so. It encroaches on darker corners of JMM, but it still
>>> does what you want, methinks.
>>>
>>> > * Some (later) threads may not issue the warning, if the updated value
>>> is flushed to the heap and
>>> > they load it?
>>>
>>> Yes, except that "flushed to heap" part: that one is an implementation
>>> detail.
>>>
>>>
>>> > Is there a better way to do this without sacrificing performance? Is
>>> this what the mysterious
>>> > AtomicBoolean.lazySet, or even weakCompareAndSet is about?
>>>
>>> The classic way to do this is to do test and test-and-set:
>>>
>>> class Foo {
>>>    private final AtomicBoolean warned;
>>>
>>>    public void run() {
>>>      if (!warned.get() && warned.compareAndSet(false, true)) {
>>>        LOG.warn("Warning");
>>>      }
>>>    }
>>> }
>>>
>>> This gives you global only-once property, without sacrificing
>>> performance.
>>>
>>> There are options how do you represent "warned". I'd start with
>>> AtomicBoolean, and then switched to
>>> AtomicIntegerFieldUpdater over volatile field, or VarHandle if footprint
>>> became a problem. With
>>> VarHandles, you can even mix the modes: make the first "test" in plain
>>> mode, and then do the CAS, if
>>> first volatile check is too costly. But all of this is red herring until
>>> there is a pressing need.
>>> One-off guards are doable with just AtomicBoolean.
>>>
>>> -Aleksey
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>>
>> --
>> Cheers,
>> √
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>
>
> --
> Cheers,
> √
>
>
>


-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/50398fd4/attachment.html>

From oleksandr.otenko at gmail.com  Thu May 31 06:13:22 2018
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 31 May 2018 11:13:22 +0100
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <CANPzfU_BFSRY=17r1ZR6k=oK9ris=HUfnc3_XpjV_rpyjuwATg@mail.gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
 <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
 <CANPzfU_BFSRY=17r1ZR6k=oK9ris=HUfnc3_XpjV_rpyjuwATg@mail.gmail.com>
Message-ID: <1DB1F5E1-DC5F-459B-92D5-E1E290AF0474@gmail.com>

The OP’s concern was the use of “normal” variable and guarantees of eventually observing stuff.

In your case just adding a release fence won’t do. Without an acquire fence before the load the fencing effort is futile.

Alex

> On 31 May 2018, at 11:10, Viktor Klang <viktor.klang at gmail.com> wrote:
> 
> The OP?
> 
> On Thu, May 31, 2018 at 12:05 PM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
> Who cares to optimize the instruction that is going to be executed approximately once?
> 
> Alex
> 
>> On 31 May 2018, at 11:03, Viktor Klang <viktor.klang at gmail.com <mailto:viktor.klang at gmail.com>> wrote:
>> 
>> Or leave the field un-volatile and introduce a release fence before the logging call?
>> 
>> On Thu, May 31, 2018 at 11:58 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
>> The original requirement was it’s ok to sometimes log Warning several times. All this hacky atomicity is unnecessary. Just declare private volatile boolean warned, and leave the rest of the code as is.
>> 
>> Alex
>> 
>> 
>>> On 31 May 2018, at 10:22, Viktor Klang via Concurrency-interest <concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>> wrote:
>>> 
>>> Aleksey's suggestion(s) is/are definitely cleaner than mine:
>>> 
>>> Depending on performance requirements the following might be cheaper,
>>> of course assuming you can type-wise hide the AtomicBoolean inheritance from consumer code:
>>> 
>>> class Foo extends AtomicBoolean { // No indirection due to the allocation of AtomicBoolean
>>>    public void run() {
>>>      if (!get() && !getAndSet(true)) { // LOCK XCHG instead of LOCK CMPXCHG
>>>        LOG.warn("Warning");
>>>      }
>>>    }
>>> }
>>> 
>>> On Thu, May 31, 2018 at 9:51 AM, Aleksey Shipilev via Concurrency-interest <concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>> wrote:
>>> On 05/31/2018 07:07 AM, Shevek via Concurrency-interest wrote:
>>> > Hi,
>>> > 
>>> > I'd like to issue a warning message a relatively low number of times in a multi-threaded
>>> > application. My code is this:
>>> > 
>>> > class Foo {
>>> >   private boolean warned;
>>> > 
>>> >   public void run() {
>>> >     if (!warned) {
>>> >        LOG.warn("Warning");
>>> >        warned = true;
>>> >     }
>>> >   }
>>> > }
>>> > 
>>> > This is the only access to the variable 'warned', the value change is deliberately unsynchronized,
>>> > and monotonic. Am I right to believe that:
>>> > 
>>> > * The first call WILL issue a warning.
>>> 
>>> Yes.
>>> 
>>> > * Any thread will issue the warning AT MOST once.
>>> 
>>> Yes, I think so. It encroaches on darker corners of JMM, but it still does what you want, methinks.
>>> 
>>> > * Some (later) threads may not issue the warning, if the updated value is flushed to the heap and
>>> > they load it?
>>> 
>>> Yes, except that "flushed to heap" part: that one is an implementation detail.
>>> 
>>> 
>>> > Is there a better way to do this without sacrificing performance? Is this what the mysterious
>>> > AtomicBoolean.lazySet, or even weakCompareAndSet is about?
>>> 
>>> The classic way to do this is to do test and test-and-set:
>>> 
>>> class Foo {
>>>    private final AtomicBoolean warned;
>>> 
>>>    public void run() {
>>>      if (!warned.get() && warned.compareAndSet(false, true)) {
>>>        LOG.warn("Warning");
>>>      }
>>>    }
>>> }
>>> 
>>> This gives you global only-once property, without sacrificing performance.
>>> 
>>> There are options how do you represent "warned". I'd start with AtomicBoolean, and then switched to
>>> AtomicIntegerFieldUpdater over volatile field, or VarHandle if footprint became a problem. With
>>> VarHandles, you can even mix the modes: make the first "test" in plain mode, and then do the CAS, if
>>> first volatile check is too costly. But all of this is red herring until there is a pressing need.
>>> One-off guards are doable with just AtomicBoolean.
>>> 
>>> -Aleksey
>>> 
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>> 
>>> 
>>> 
>>> 
>>> -- 
>>> Cheers,
>>> √
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>> 
>> 
>> 
>> 
>> -- 
>> Cheers,
>> √
> 
> 
> 
> 
> -- 
> Cheers,
> √

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/535b1134/attachment-0001.html>

From shade at redhat.com  Thu May 31 06:15:12 2018
From: shade at redhat.com (Aleksey Shipilev)
Date: Thu, 31 May 2018 12:15:12 +0200
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
 <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
Message-ID: <2ff1c10f-5d35-9db5-5533-6c861ab08a19@redhat.com>

I think Viktor wants to avoid volatile read on the fast path. Assuming that even matters, we can do
this with VarHandle doing the plain fastpath read, and then CAS to get exactly-once semantics.
Since, as you say, that thing would be executed approximately once, there is no loss in doing the
right thing, while we are at it.

E.g. (sketching):

class Foo {
  static final VH = <varhandle-over-x>
  boolean x;

  public void run() {
    if (!VH.get(this) // non-volatile fast-path
           && VH.compareAndSet(this, false, true)) {
      LOG.warn(...);
    }
  }
}

But I tend to think this is an overkill, and the plain field is good enough already. Make it
volatile if unsure.

-Aleksey

On 05/31/2018 12:05 PM, Alex Otenko wrote:
> Who cares to optimize the instruction that is going to be executed approximately once?
> 
> Alex
> 
>> On 31 May 2018, at 11:03, Viktor Klang <viktor.klang at gmail.com <mailto:viktor.klang at gmail.com>> wrote:
>>
>> Or leave the field un-volatile and introduce a release fence before the logging call?
>>
>> On Thu, May 31, 2018 at 11:58 AM, Alex Otenko <oleksandr.otenko at gmail.com
>> <mailto:oleksandr.otenko at gmail.com>> wrote:
>>
>>     The original requirement was it’s ok to sometimes log Warning several times. All this hacky
>>     atomicity is unnecessary. Just declare private volatile boolean warned, and leave the rest of
>>     the code as is.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/31a7bc33/attachment.sig>

From viktor.klang at gmail.com  Thu May 31 06:16:48 2018
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 31 May 2018 12:16:48 +0200
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <2ff1c10f-5d35-9db5-5533-6c861ab08a19@redhat.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
 <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
 <2ff1c10f-5d35-9db5-5533-6c861ab08a19@redhat.com>
Message-ID: <CANPzfU__2nDOF=iyaCexETkiSk_aQUkNZsYFr0kzmzPJ_VEYtw@mail.gmail.com>

+1

On Thu, May 31, 2018 at 12:15 PM, Aleksey Shipilev <shade at redhat.com> wrote:

> I think Viktor wants to avoid volatile read on the fast path. Assuming
> that even matters, we can do
> this with VarHandle doing the plain fastpath read, and then CAS to get
> exactly-once semantics.
> Since, as you say, that thing would be executed approximately once, there
> is no loss in doing the
> right thing, while we are at it.
>
> E.g. (sketching):
>
> class Foo {
>   static final VH = <varhandle-over-x>
>   boolean x;
>
>   public void run() {
>     if (!VH.get(this) // non-volatile fast-path
>            && VH.compareAndSet(this, false, true)) {
>       LOG.warn(...);
>     }
>   }
> }
>
> But I tend to think this is an overkill, and the plain field is good
> enough already. Make it
> volatile if unsure.
>
> -Aleksey
>
> On 05/31/2018 12:05 PM, Alex Otenko wrote:
> > Who cares to optimize the instruction that is going to be executed
> approximately once?
> >
> > Alex
> >
> >> On 31 May 2018, at 11:03, Viktor Klang <viktor.klang at gmail.com <mailto:
> viktor.klang at gmail.com>> wrote:
> >>
> >> Or leave the field un-volatile and introduce a release fence before the
> logging call?
> >>
> >> On Thu, May 31, 2018 at 11:58 AM, Alex Otenko <
> oleksandr.otenko at gmail.com
> >> <mailto:oleksandr.otenko at gmail.com>> wrote:
> >>
> >>     The original requirement was it’s ok to sometimes log Warning
> several times. All this hacky
> >>     atomicity is unnecessary. Just declare private volatile boolean
> warned, and leave the rest of
> >>     the code as is.
>
>


-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/a0ffa65e/attachment.html>

From oleksandr.otenko at gmail.com  Thu May 31 06:19:49 2018
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 31 May 2018 11:19:49 +0100
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <2ff1c10f-5d35-9db5-5533-6c861ab08a19@redhat.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
 <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
 <2ff1c10f-5d35-9db5-5533-6c861ab08a19@redhat.com>
Message-ID: <83B37766-759F-43FE-858B-F55365C30B58@gmail.com>

I don’t get this advice.

Do the simple thing, declare it volatile. Optimize further (learning curve + operational subtleties) when that is not fast enough. (VH.get cannot be different from volatile load on x86, can it?..)

Alex

> On 31 May 2018, at 11:15, Aleksey Shipilev <shade at redhat.com> wrote:
> 
> I think Viktor wants to avoid volatile read on the fast path. Assuming that even matters, we can do
> this with VarHandle doing the plain fastpath read, and then CAS to get exactly-once semantics.
> Since, as you say, that thing would be executed approximately once, there is no loss in doing the
> right thing, while we are at it.
> 
> E.g. (sketching):
> 
> class Foo {
>  static final VH = <varhandle-over-x>
>  boolean x;
> 
>  public void run() {
>    if (!VH.get(this) // non-volatile fast-path
>           && VH.compareAndSet(this, false, true)) {
>      LOG.warn(...);
>    }
>  }
> }
> 
> But I tend to think this is an overkill, and the plain field is good enough already. Make it
> volatile if unsure.
> 
> -Aleksey
> 
> On 05/31/2018 12:05 PM, Alex Otenko wrote:
>> Who cares to optimize the instruction that is going to be executed approximately once?
>> 
>> Alex
>> 
>>> On 31 May 2018, at 11:03, Viktor Klang <viktor.klang at gmail.com <mailto:viktor.klang at gmail.com>> wrote:
>>> 
>>> Or leave the field un-volatile and introduce a release fence before the logging call?
>>> 
>>> On Thu, May 31, 2018 at 11:58 AM, Alex Otenko <oleksandr.otenko at gmail.com
>>> <mailto:oleksandr.otenko at gmail.com>> wrote:
>>> 
>>>    The original requirement was it’s ok to sometimes log Warning several times. All this hacky
>>>    atomicity is unnecessary. Just declare private volatile boolean warned, and leave the rest of
>>>    the code as is.
> 


From shade at redhat.com  Thu May 31 06:27:35 2018
From: shade at redhat.com (Aleksey Shipilev)
Date: Thu, 31 May 2018 12:27:35 +0200
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <83B37766-759F-43FE-858B-F55365C30B58@gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
 <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
 <2ff1c10f-5d35-9db5-5533-6c861ab08a19@redhat.com>
 <83B37766-759F-43FE-858B-F55365C30B58@gmail.com>
Message-ID: <26624fd9-8910-a085-56c4-cd4e8cecb33f@redhat.com>

On 05/31/2018 12:19 PM, Alex Otenko wrote:
> I don’t get this advice. Do the simple thing, declare it volatile. Optimize further (learning
> curve + operational subtleties) when that is not fast enough.
My original reply was about that: what OP has does appear to work.

It does not mean OP should use it, though, instead of doing the idiomatic shape: do AtomicX, gain
CAS capability, have fast-path test, on slow-path do CAS to perform the action exactly once.
Optimize from that, if you prove that idiom is not working for you.


> (VH.get cannot be different from volatile load on x86, can it?..)

Of course it can, it is the magic of VarHandles: use-site, not declaration-site memory semantics. So
you can have volatile field and do non-volatile read over it, or you can have non-volatile field and
do volatile read or CAS over it.


-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/d658b65f/attachment-0001.sig>

From oleksandr.otenko at gmail.com  Thu May 31 06:32:23 2018
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 31 May 2018 11:32:23 +0100
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <26624fd9-8910-a085-56c4-cd4e8cecb33f@redhat.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
 <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
 <2ff1c10f-5d35-9db5-5533-6c861ab08a19@redhat.com>
 <83B37766-759F-43FE-858B-F55365C30B58@gmail.com>
 <26624fd9-8910-a085-56c4-cd4e8cecb33f@redhat.com>
Message-ID: <C7A38D5A-318E-43B9-AA54-AA42718DADD5@gmail.com>


> On 31 May 2018, at 11:27, Aleksey Shipilev <shade at redhat.com> wrote:
> 
> On 05/31/2018 12:19 PM, Alex Otenko wrote:
>> I don’t get this advice. Do the simple thing, declare it volatile. Optimize further (learning
>> curve + operational subtleties) when that is not fast enough.
> My original reply was about that: what OP has does appear to work.
> 
> It does not mean OP should use it, though, instead of doing the idiomatic shape: do AtomicX, gain
> CAS capability, have fast-path test, on slow-path do CAS to perform the action exactly once.
> Optimize from that, if you prove that idiom is not working for you.
> 
> 
>> (VH.get cannot be different from volatile load on x86, can it?..)
> 
> Of course it can,

By what means? If VH.get guarantees observing cache-coherent value, how can it do that observing faster than volatile load on x86?


Alex

> it is the magic of VarHandles: use-site, not declaration-site memory semantics.
> So
> you can have volatile field and do non-volatile read over it, or you can have non-volatile field and
> do volatile read or CAS over it.
> 
> 
> -Aleksey
> 


From shade at redhat.com  Thu May 31 06:37:57 2018
From: shade at redhat.com (Aleksey Shipilev)
Date: Thu, 31 May 2018 12:37:57 +0200
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <C7A38D5A-318E-43B9-AA54-AA42718DADD5@gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
 <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
 <2ff1c10f-5d35-9db5-5533-6c861ab08a19@redhat.com>
 <83B37766-759F-43FE-858B-F55365C30B58@gmail.com>
 <26624fd9-8910-a085-56c4-cd4e8cecb33f@redhat.com>
 <C7A38D5A-318E-43B9-AA54-AA42718DADD5@gmail.com>
Message-ID: <2c86df22-4e35-9148-20ec-852a0677d822@redhat.com>

On 05/31/2018 12:32 PM, Alex Otenko wrote:
>>> (VH.get cannot be different from volatile load on x86, can it?..)
>> 
>> Of course it can,
> 
> By what means? If VH.get guarantees observing cache-coherent value, how can it do that observing
> faster than volatile load on x86?

Because there is more to the performance story than just observing the values. For example, having
the non-volatile access on fast-path means you can optimize the code around it better. What makes
VarHandles magical is that we can make the decision on what memory semantics we want for each
particular use. (Pretty like the internal-jdk-class-that-must-not-be-named).

-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/e021354f/attachment.sig>

From oleksandr.otenko at gmail.com  Thu May 31 06:43:17 2018
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 31 May 2018 11:43:17 +0100
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <2c86df22-4e35-9148-20ec-852a0677d822@redhat.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
 <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
 <2ff1c10f-5d35-9db5-5533-6c861ab08a19@redhat.com>
 <83B37766-759F-43FE-858B-F55365C30B58@gmail.com>
 <26624fd9-8910-a085-56c4-cd4e8cecb33f@redhat.com>
 <C7A38D5A-318E-43B9-AA54-AA42718DADD5@gmail.com>
 <2c86df22-4e35-9148-20ec-852a0677d822@redhat.com>
Message-ID: <A10C57C5-6EC7-4974-AB12-573298C890BE@gmail.com>

Ah, yes, I see the point. Volatile load would cause other loads to also occur, and not reorderable.

Alex

> On 31 May 2018, at 11:37, Aleksey Shipilev <shade at redhat.com> wrote:
> 
> On 05/31/2018 12:32 PM, Alex Otenko wrote:
>>>> (VH.get cannot be different from volatile load on x86, can it?..)
>>> 
>>> Of course it can,
>> 
>> By what means? If VH.get guarantees observing cache-coherent value, how can it do that observing
>> faster than volatile load on x86?
> 
> Because there is more to the performance story than just observing the values. For example, having
> the non-volatile access on fast-path means you can optimize the code around it better. What makes
> VarHandles magical is that we can make the decision on what memory semantics we want for each
> particular use. (Pretty like the internal-jdk-class-that-must-not-be-named).
> 
> -Aleksey
> 


From me at yawk.at  Thu May 31 07:21:36 2018
From: me at yawk.at (Jonas Konrad)
Date: Thu, 31 May 2018 13:21:36 +0200
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <C7A38D5A-318E-43B9-AA54-AA42718DADD5@gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
 <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
 <2ff1c10f-5d35-9db5-5533-6c861ab08a19@redhat.com>
 <83B37766-759F-43FE-858B-F55365C30B58@gmail.com>
 <26624fd9-8910-a085-56c4-cd4e8cecb33f@redhat.com>
 <C7A38D5A-318E-43B9-AA54-AA42718DADD5@gmail.com>
Message-ID: <e966a776-0d94-3542-5823-2faa663424e1@yawk.at>

But it doesn't? It's just a normal, non-volatile read. Or is this the 
same on x86?

- Jonas

On 05/31/2018 12:32 PM, Alex Otenko via Concurrency-interest wrote:
> 
>> On 31 May 2018, at 11:27, Aleksey Shipilev <shade at redhat.com> wrote:
>>
>> On 05/31/2018 12:19 PM, Alex Otenko wrote:
>>> I don’t get this advice. Do the simple thing, declare it volatile. Optimize further (learning
>>> curve + operational subtleties) when that is not fast enough.
>> My original reply was about that: what OP has does appear to work.
>>
>> It does not mean OP should use it, though, instead of doing the idiomatic shape: do AtomicX, gain
>> CAS capability, have fast-path test, on slow-path do CAS to perform the action exactly once.
>> Optimize from that, if you prove that idiom is not working for you.
>>
>>
>>> (VH.get cannot be different from volatile load on x86, can it?..)
>>
>> Of course it can,
> 
> By what means? If VH.get guarantees observing cache-coherent value, how can it do that observing faster than volatile load on x86?
> 
> 
> Alex
> 
>> it is the magic of VarHandles: use-site, not declaration-site memory semantics.
>> So
>> you can have volatile field and do non-volatile read over it, or you can have non-volatile field and
>> do volatile read or CAS over it.
>>
>>
>> -Aleksey
>>
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From nathanila at gmail.com  Thu May 31 08:11:00 2018
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 31 May 2018 06:11:00 -0600
Subject: [concurrency-interest] thread safety of java.lang.reflect.Field
In-Reply-To: <op.zjvgquu3wcnyyd@novi-pc>
References: <op.zjvgquu3wcnyyd@novi-pc>
Message-ID: <751f58c9-0b76-af79-adcb-0642caae9a30@gmail.com>

I usually cache Fields in private static final fields in the class that 
I use the Fields.  I have not had any trouble with multiple threads 
using Fields concurrently.  One caution is that if two threads execute 
the statement below concurrently on the same "obj", then one of the 
increments could be lost.  In other words, one still has to be mindful 
of concurrent access to the object's fields.

s_field.setInt(obj, s_field.getInt(obj) + 1);

-Nathan

On 5/31/2018 3:31 AM, Novi via Concurrency-interest wrote:
> Hello,
>
> I wonder if instances of java.lang.reflect.Field can be shared between
> multiple threads as long as the accessibility flag is either not modified
> or modified exactly once prior to a safe publication of the field
> instances.
>
> In other words, is it legal to cache instances of j.l.r.Field between
> multiple threads?
>
> Best Regards,
> Novi
>
>
> PS: The Bean Validation reference implementation Hibernate Validator 
> seems
> to cache instances of j.l.r.Field across threads. However, I couldn't 
> find any
> clue in the Java API documentation whether such a usage is supported or
> not.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-- 
-Nathan


From oleksandr.otenko at gmail.com  Thu May 31 08:13:05 2018
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 31 May 2018 13:13:05 +0100
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <e966a776-0d94-3542-5823-2faa663424e1@yawk.at>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
 <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
 <2ff1c10f-5d35-9db5-5533-6c861ab08a19@redhat.com>
 <83B37766-759F-43FE-858B-F55365C30B58@gmail.com>
 <26624fd9-8910-a085-56c4-cd4e8cecb33f@redhat.com>
 <C7A38D5A-318E-43B9-AA54-AA42718DADD5@gmail.com>
 <e966a776-0d94-3542-5823-2faa663424e1@yawk.at>
Message-ID: <E12EB33D-768E-4064-8873-E8F3D8594EE7@gmail.com>

On x86 all reads are totally ordered with respect to each other, and stores never go ahead of reads. So all reads have the same semantics as volatile reads on x86 - once the Java code is translated to the actual instructions, that is. The JVM is free to not translate some reads appearing in Java code into the actual instructions, as is permitted by the JMM.


Volatile reads also have implications on what the JVM can do to the rest of the code. Aleksey is being a bit mysterious about what exactly can be done, but what he is getting at, is something like:

* Once you declare a read as volatile, you also force the JVM to materialize all reads that are after it in program order (can’t use the values still in registers anymore), and forces the JVM to not reorder stores ahead of the volatile read.

* If you are able to tell the JVM that it’s ok to reorder and what not, that all that you need is for that one read to not be eliminated, then you allow for all other code movement and optimizations to occur.


Alex

> On 31 May 2018, at 12:21, Jonas Konrad via Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
> 
> But it doesn't? It's just a normal, non-volatile read. Or is this the same on x86?
> 
> - Jonas
> 
> On 05/31/2018 12:32 PM, Alex Otenko via Concurrency-interest wrote:
>>> On 31 May 2018, at 11:27, Aleksey Shipilev <shade at redhat.com> wrote:
>>> 
>>> On 05/31/2018 12:19 PM, Alex Otenko wrote:
>>>> I don’t get this advice. Do the simple thing, declare it volatile. Optimize further (learning
>>>> curve + operational subtleties) when that is not fast enough.
>>> My original reply was about that: what OP has does appear to work.
>>> 
>>> It does not mean OP should use it, though, instead of doing the idiomatic shape: do AtomicX, gain
>>> CAS capability, have fast-path test, on slow-path do CAS to perform the action exactly once.
>>> Optimize from that, if you prove that idiom is not working for you.
>>> 
>>> 
>>>> (VH.get cannot be different from volatile load on x86, can it?..)
>>> 
>>> Of course it can,
>> By what means? If VH.get guarantees observing cache-coherent value, how can it do that observing faster than volatile load on x86?
>> Alex
>>> it is the magic of VarHandles: use-site, not declaration-site memory semantics.
>>> So
>>> you can have volatile field and do non-volatile read over it, or you can have non-volatile field and
>>> do volatile read or CAS over it.
>>> 
>>> 
>>> -Aleksey
>>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From oleksandr.otenko at gmail.com  Thu May 31 09:00:48 2018
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 31 May 2018 14:00:48 +0100
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <E12EB33D-768E-4064-8873-E8F3D8594EE7@gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <24389be8-7624-824f-95b3-8b15ca8489c3@redhat.com>
 <CANPzfU-=dvYYx-bV6M9NUzCd=P=EWK0DNYA9POzytUv1tpcpsw@mail.gmail.com>
 <6917A53B-914E-46A3-A77B-E72CBA25DBC4@gmail.com>
 <CANPzfU9wpajaaOex2LcROtE69b_3nP1oRbgfhjM3y6Nb1tXspg@mail.gmail.com>
 <A7B6E842-D3D0-412B-9E51-714F727B5EFB@gmail.com>
 <2ff1c10f-5d35-9db5-5533-6c861ab08a19@redhat.com>
 <83B37766-759F-43FE-858B-F55365C30B58@gmail.com>
 <26624fd9-8910-a085-56c4-cd4e8cecb33f@redhat.com>
 <C7A38D5A-318E-43B9-AA54-AA42718DADD5@gmail.com>
 <e966a776-0d94-3542-5823-2faa663424e1@yawk.at>
 <E12EB33D-768E-4064-8873-E8F3D8594EE7@gmail.com>
Message-ID: <A09C21B8-BEF8-48AC-A14F-C190C3C6CAF1@gmail.com>

Actually, “totally ordered” is the wrong word for reads here. “totally ordered” would imply other CPUs agree on the order of reads, too. But it is just “not reordered by a single CPU”.

Still, the instructions for “normal” reads don’t differ from the instructions for “volatile”.

Alex

> On 31 May 2018, at 13:13, Alex Otenko <oleksandr.otenko at gmail.com> wrote:
> 
> On x86 all reads are totally ordered with respect to each other, and stores never go ahead of reads. So all reads have the same semantics as volatile reads on x86 - once the Java code is translated to the actual instructions, that is. The JVM is free to not translate some reads appearing in Java code into the actual instructions, as is permitted by the JMM.
> 
> 
> Volatile reads also have implications on what the JVM can do to the rest of the code. Aleksey is being a bit mysterious about what exactly can be done, but what he is getting at, is something like:
> 
> * Once you declare a read as volatile, you also force the JVM to materialize all reads that are after it in program order (can’t use the values still in registers anymore), and forces the JVM to not reorder stores ahead of the volatile read.
> 
> * If you are able to tell the JVM that it’s ok to reorder and what not, that all that you need is for that one read to not be eliminated, then you allow for all other code movement and optimizations to occur.
> 
> 
> Alex
> 
>> On 31 May 2018, at 12:21, Jonas Konrad via Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
>> 
>> But it doesn't? It's just a normal, non-volatile read. Or is this the same on x86?
>> 
>> - Jonas
>> 
>> On 05/31/2018 12:32 PM, Alex Otenko via Concurrency-interest wrote:
>>>> On 31 May 2018, at 11:27, Aleksey Shipilev <shade at redhat.com> wrote:
>>>> 
>>>> On 05/31/2018 12:19 PM, Alex Otenko wrote:
>>>>> I don’t get this advice. Do the simple thing, declare it volatile. Optimize further (learning
>>>>> curve + operational subtleties) when that is not fast enough.
>>>> My original reply was about that: what OP has does appear to work.
>>>> 
>>>> It does not mean OP should use it, though, instead of doing the idiomatic shape: do AtomicX, gain
>>>> CAS capability, have fast-path test, on slow-path do CAS to perform the action exactly once.
>>>> Optimize from that, if you prove that idiom is not working for you.
>>>> 
>>>> 
>>>>> (VH.get cannot be different from volatile load on x86, can it?..)
>>>> 
>>>> Of course it can,
>>> By what means? If VH.get guarantees observing cache-coherent value, how can it do that observing faster than volatile load on x86?
>>> Alex
>>>> it is the magic of VarHandles: use-site, not declaration-site memory semantics.
>>>> So
>>>> you can have volatile field and do non-volatile read over it, or you can have non-volatile field and
>>>> do volatile read or CAS over it.
>>>> 
>>>> 
>>>> -Aleksey
>>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From novitools.novi at web.de  Thu May 31 10:35:08 2018
From: novitools.novi at web.de (Novi)
Date: Thu, 31 May 2018 16:35:08 +0200
Subject: [concurrency-interest] thread safety of java.lang.reflect.Field
In-Reply-To: <751f58c9-0b76-af79-adcb-0642caae9a30@gmail.com>
References: <op.zjvgquu3wcnyyd@novi-pc>
 <751f58c9-0b76-af79-adcb-0642caae9a30@gmail.com>
Message-ID: <op.zjvusukuwcnyyd@novi-pc>

> I have not had any trouble with multiple threads using Fields  
> concurrently.

Neither do I but that is no guarantee for correctness.
(Compare for example this reflection related issue:
https://bugs.openjdk.java.net/browse/JDK-8062771)


> In other words, one still has to be mindful of concurrent access to the  
> object's fields.

That is true but it is not what I meant to ask.


Assuming that j.l.r.Field is thread safe in the current OpenJDK version,  
is this
merely an implementation detail or something that is guaranteed in future
and/or other JVM implementations?

-Novi


Am 31.05.2018, 14:11 Uhr, schrieb Nathan and Ila Reynolds via
Concurrency-interest <concurrency-interest at cs.oswego.edu>:

> I usually cache Fields in private static final fields in the class that  
> I use the Fields.  I have not had any trouble with multiple threads  
> using Fields concurrently.  One caution is that if two threads execute  
> the statement below concurrently on the same "obj", then one of the  
> increments could be lost.  In other words, one still has to be mindful  
> of concurrent access to the object's fields.
>
> s_field.setInt(obj, s_field.getInt(obj) + 1);
>
> -Nathan
>
> On 5/31/2018 3:31 AM, Novi via Concurrency-interest wrote:
>> Hello,
>>
>> I wonder if instances of java.lang.reflect.Field can be shared between
>> multiple threads as long as the accessibility flag is either not  
>> modified
>> or modified exactly once prior to a safe publication of the field
>> instances.
>>
>> In other words, is it legal to cache instances of j.l.r.Field between
>> multiple threads?
>>
>> Best Regards,
>> Novi
>>
>>
>> PS: The Bean Validation reference implementation Hibernate Validator  
>> seems
>> to cache instances of j.l.r.Field across threads. However, I couldn't  
>> find any
>> clue in the Java API documentation whether such a usage is supported or
>> not.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From me at yawk.at  Thu May 31 14:33:02 2018
From: me at yawk.at (Jonas Konrad)
Date: Thu, 31 May 2018 20:33:02 +0200
Subject: [concurrency-interest] thread safety of java.lang.reflect.Field
In-Reply-To: <op.zjvusukuwcnyyd@novi-pc>
References: <op.zjvgquu3wcnyyd@novi-pc>
 <751f58c9-0b76-af79-adcb-0642caae9a30@gmail.com> <op.zjvusukuwcnyyd@novi-pc>
Message-ID: <2bf32c19-899e-9a35-e999-497135e15f5e@yawk.at>

I can't speak for the standard, but caching Fields instances in static 
fields is *very* common so it's unlikely they would ever change the 
current behavior (it being safe to use).

If you are still concerned about correctness, VarHandle is specified to 
be "immutable and have no visible state" so that would be safe to share 
across threads.

- Jonas

On 2018-05-31 16:35, Novi via Concurrency-interest wrote:
>> I have not had any trouble with multiple threads using Fields 
>> concurrently.
> 
> Neither do I but that is no guarantee for correctness.
> (Compare for example this reflection related issue:
> https://bugs.openjdk.java.net/browse/JDK-8062771)
> 
> 
>> In other words, one still has to be mindful of concurrent access to 
>> the object's fields.
> 
> That is true but it is not what I meant to ask.
> 
> 
> Assuming that j.l.r.Field is thread safe in the current OpenJDK version, 
> is this
> merely an implementation detail or something that is guaranteed in future
> and/or other JVM implementations?
> 
> -Novi
> 
> 
> Am 31.05.2018, 14:11 Uhr, schrieb Nathan and Ila Reynolds via
> Concurrency-interest <concurrency-interest at cs.oswego.edu>:
> 
>> I usually cache Fields in private static final fields in the class 
>> that I use the Fields.  I have not had any trouble with multiple 
>> threads using Fields concurrently.  One caution is that if two threads 
>> execute the statement below concurrently on the same "obj", then one 
>> of the increments could be lost.  In other words, one still has to be 
>> mindful of concurrent access to the object's fields.
>>
>> s_field.setInt(obj, s_field.getInt(obj) + 1);
>>
>> -Nathan
>>
>> On 5/31/2018 3:31 AM, Novi via Concurrency-interest wrote:
>>> Hello,
>>>
>>> I wonder if instances of java.lang.reflect.Field can be shared between
>>> multiple threads as long as the accessibility flag is either not 
>>> modified
>>> or modified exactly once prior to a safe publication of the field
>>> instances.
>>>
>>> In other words, is it legal to cache instances of j.l.r.Field between
>>> multiple threads?
>>>
>>> Best Regards,
>>> Novi
>>>
>>>
>>> PS: The Bean Validation reference implementation Hibernate Validator 
>>> seems
>>> to cache instances of j.l.r.Field across threads. However, I couldn't 
>>> find any
>>> clue in the Java API documentation whether such a usage is supported or
>>> not.
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From notcarl at google.com  Thu May 31 16:06:30 2018
From: notcarl at google.com (Carl Mastrangelo)
Date: Thu, 31 May 2018 13:06:30 -0700
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
Message-ID: <CAAcqB+s=bz4EKK1HN7t+8egh8sYJ_nOqjCQU+fjkATZu_0EcPg@mail.gmail.com>

At the cost of about 500 bytes of class size, you could do the trick in
Effective Java:

class Foo {
   private static class Logged {
     static void log() {}

      static {
         LOG.warn("Warning");
      }
   }

   public void run() {
     Logged.log();
   }
}

On Wed, May 30, 2018 at 10:17 PM Shevek via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> Hi,
>
> I'd like to issue a warning message a relatively low number of times in
> a multi-threaded application. My code is this:
>
> class Foo {
>    private boolean warned;
>
>    public void run() {
>      if (!warned) {
>         LOG.warn("Warning");
>         warned = true;
>      }
>    }
> }
>
> This is the only access to the variable 'warned', the value change is
> deliberately unsynchronized, and monotonic. Am I right to believe that:
>
> * The first call WILL issue a warning.
> * Any thread will issue the warning AT MOST once.
> * Some (later) threads may not issue the warning, if the updated value
> is flushed to the heap and they load it?
>
> Is there a better way to do this without sacrificing performance? Is
> this what the mysterious AtomicBoolean.lazySet, or even
> weakCompareAndSet is about?
>
> This is right in the middle of something very concurrent which runs for
> a long time, so reducing overhead is far more important than
> occasionally issuing too many warnings.
>
> Thank you.
>
> S.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/33c9717e/attachment.html>

From shevek at anarres.org  Thu May 31 16:10:48 2018
From: shevek at anarres.org (Shevek)
Date: Thu, 31 May 2018 13:10:48 -0700
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <CAAcqB+s=bz4EKK1HN7t+8egh8sYJ_nOqjCQU+fjkATZu_0EcPg@mail.gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <CAAcqB+s=bz4EKK1HN7t+8egh8sYJ_nOqjCQU+fjkATZu_0EcPg@mail.gmail.com>
Message-ID: <aac27b38-fdf2-90cc-115c-ade9b565227b@anarres.org>

I know there's a guarantee that the JVM _will_ call this when desired. 
Is there also a guarantee that the JVM will _not_ call this i.e. there 
is no spurious class or opportunistic initialization? I think that's 
harder to promise.

On 05/31/2018 01:06 PM, Carl Mastrangelo wrote:
> At the cost of about 500 bytes of class size, you could do the trick in 
> Effective Java:
> 
> class Foo {
>     private static class Logged {
>       static void log() {}
>        static {
> LOG.warn("Warning");
>        }
>     }
> 
>     public void run() {
> Logged.log();
>     }
> }
> 
> On Wed, May 30, 2018 at 10:17 PM Shevek via Concurrency-interest 
> <concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>> wrote:
> 
>     Hi,
> 
>     I'd like to issue a warning message a relatively low number of times in
>     a multi-threaded application. My code is this:
> 
>     class Foo {
>         private boolean warned;
> 
>         public void run() {
>           if (!warned) {
>              LOG.warn("Warning");
>              warned = true;
>           }
>         }
>     }
> 
>     This is the only access to the variable 'warned', the value change is
>     deliberately unsynchronized, and monotonic. Am I right to believe that:
> 
>     * The first call WILL issue a warning.
>     * Any thread will issue the warning AT MOST once.
>     * Some (later) threads may not issue the warning, if the updated value
>     is flushed to the heap and they load it?
> 
>     Is there a better way to do this without sacrificing performance? Is
>     this what the mysterious AtomicBoolean.lazySet, or even
>     weakCompareAndSet is about?
> 
>     This is right in the middle of something very concurrent which runs for
>     a long time, so reducing overhead is far more important than
>     occasionally issuing too many warnings.
> 
>     Thank you.
> 
>     S.
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From notcarl at google.com  Thu May 31 16:16:49 2018
From: notcarl at google.com (Carl Mastrangelo)
Date: Thu, 31 May 2018 13:16:49 -0700
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <aac27b38-fdf2-90cc-115c-ade9b565227b@anarres.org>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <CAAcqB+s=bz4EKK1HN7t+8egh8sYJ_nOqjCQU+fjkATZu_0EcPg@mail.gmail.com>
 <aac27b38-fdf2-90cc-115c-ade9b565227b@anarres.org>
Message-ID: <CAAcqB+v5iSPqWcHJWBFit0r_YmcYgD2wa7iPgjdNtN+YYcmrGA@mail.gmail.com>

As I understand it, class loading is lazy and this will do the right
thing.  It *may* get garbage collected if not referenced (and maybe log
twice), but that can be worked around.  The pattern is very common for
singletons.

On Thu, May 31, 2018 at 1:10 PM Shevek <shevek at anarres.org> wrote:

> I know there's a guarantee that the JVM _will_ call this when desired.
> Is there also a guarantee that the JVM will _not_ call this i.e. there
> is no spurious class or opportunistic initialization? I think that's
> harder to promise.
>
> On 05/31/2018 01:06 PM, Carl Mastrangelo wrote:
> > At the cost of about 500 bytes of class size, you could do the trick in
> > Effective Java:
> >
> > class Foo {
> >     private static class Logged {
> >       static void log() {}
> >        static {
> > LOG.warn("Warning");
> >        }
> >     }
> >
> >     public void run() {
> > Logged.log();
> >     }
> > }
> >
> > On Wed, May 30, 2018 at 10:17 PM Shevek via Concurrency-interest
> > <concurrency-interest at cs.oswego.edu
> > <mailto:concurrency-interest at cs.oswego.edu>> wrote:
> >
> >     Hi,
> >
> >     I'd like to issue a warning message a relatively low number of times
> in
> >     a multi-threaded application. My code is this:
> >
> >     class Foo {
> >         private boolean warned;
> >
> >         public void run() {
> >           if (!warned) {
> >              LOG.warn("Warning");
> >              warned = true;
> >           }
> >         }
> >     }
> >
> >     This is the only access to the variable 'warned', the value change is
> >     deliberately unsynchronized, and monotonic. Am I right to believe
> that:
> >
> >     * The first call WILL issue a warning.
> >     * Any thread will issue the warning AT MOST once.
> >     * Some (later) threads may not issue the warning, if the updated
> value
> >     is flushed to the heap and they load it?
> >
> >     Is there a better way to do this without sacrificing performance? Is
> >     this what the mysterious AtomicBoolean.lazySet, or even
> >     weakCompareAndSet is about?
> >
> >     This is right in the middle of something very concurrent which runs
> for
> >     a long time, so reducing overhead is far more important than
> >     occasionally issuing too many warnings.
> >
> >     Thank you.
> >
> >     S.
> >     _______________________________________________
> >     Concurrency-interest mailing list
> >     Concurrency-interest at cs.oswego.edu
> >     <mailto:Concurrency-interest at cs.oswego.edu>
> >     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/94bd5ade/attachment-0001.html>

From forax at univ-mlv.fr  Thu May 31 16:42:52 2018
From: forax at univ-mlv.fr (Remi Forax)
Date: Thu, 31 May 2018 22:42:52 +0200 (CEST)
Subject: [concurrency-interest] thread safety of java.lang.reflect.Field
In-Reply-To: <2bf32c19-899e-9a35-e999-497135e15f5e@yawk.at>
References: <op.zjvgquu3wcnyyd@novi-pc>
 <751f58c9-0b76-af79-adcb-0642caae9a30@gmail.com> <op.zjvusukuwcnyyd@novi-pc>
 <2bf32c19-899e-9a35-e999-497135e15f5e@yawk.at>
Message-ID: <1527583139.1976614.1527799372550.JavaMail.zimbra@u-pem.fr>

----- Mail original -----
> De: "concurrency-interest" <concurrency-interest at cs.oswego.edu>
> À: "concurrency-interest" <concurrency-interest at cs.oswego.edu>
> Envoyé: Jeudi 31 Mai 2018 20:33:02
> Objet: Re: [concurrency-interest] thread safety of java.lang.reflect.Field

> I can't speak for the standard, but caching Fields instances in static
> fields is *very* common so it's unlikely they would ever change the
> current behavior (it being safe to use).
> 
> If you are still concerned about correctness, VarHandle is specified to
> be "immutable and have no visible state" so that would be safe to share
> across threads.

I suppose you means MethodHandle, VarHandle are specialized method handles (almost*) for the different semantics when accessing a field.

* VarHandle are not MethodHandle because when you access a field, you can not throw checked exceptions (invoking a method handle throws Throwable).

> 
> - Jonas

Rémi


> 
> On 2018-05-31 16:35, Novi via Concurrency-interest wrote:
>>> I have not had any trouble with multiple threads using Fields
>>> concurrently.
>> 
>> Neither do I but that is no guarantee for correctness.
>> (Compare for example this reflection related issue:
>> https://bugs.openjdk.java.net/browse/JDK-8062771)
>> 
>> 
>>> In other words, one still has to be mindful of concurrent access to
>>> the object's fields.
>> 
>> That is true but it is not what I meant to ask.
>> 
>> 
>> Assuming that j.l.r.Field is thread safe in the current OpenJDK version,
>> is this
>> merely an implementation detail or something that is guaranteed in future
>> and/or other JVM implementations?
>> 
>> -Novi
>> 
>> 
>> Am 31.05.2018, 14:11 Uhr, schrieb Nathan and Ila Reynolds via
>> Concurrency-interest <concurrency-interest at cs.oswego.edu>:
>> 
>>> I usually cache Fields in private static final fields in the class
>>> that I use the Fields.  I have not had any trouble with multiple
>>> threads using Fields concurrently.  One caution is that if two threads
>>> execute the statement below concurrently on the same "obj", then one
>>> of the increments could be lost.  In other words, one still has to be
>>> mindful of concurrent access to the object's fields.
>>>
>>> s_field.setInt(obj, s_field.getInt(obj) + 1);
>>>
>>> -Nathan
>>>
>>> On 5/31/2018 3:31 AM, Novi via Concurrency-interest wrote:
>>>> Hello,
>>>>
>>>> I wonder if instances of java.lang.reflect.Field can be shared between
>>>> multiple threads as long as the accessibility flag is either not
>>>> modified
>>>> or modified exactly once prior to a safe publication of the field
>>>> instances.
>>>>
>>>> In other words, is it legal to cache instances of j.l.r.Field between
>>>> multiple threads?
>>>>
>>>> Best Regards,
>>>> Novi
>>>>
>>>>
>>>> PS: The Bean Validation reference implementation Hibernate Validator
>>>> seems
>>>> to cache instances of j.l.r.Field across threads. However, I couldn't
>>>> find any
>>>> clue in the Java API documentation whether such a usage is supported or
>>>> not.
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From yankee.sierra at gmail.com  Thu May 31 17:42:51 2018
From: yankee.sierra at gmail.com (Yuval Shavit)
Date: Thu, 31 May 2018 17:42:51 -0400
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <CAAcqB+v5iSPqWcHJWBFit0r_YmcYgD2wa7iPgjdNtN+YYcmrGA@mail.gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <CAAcqB+s=bz4EKK1HN7t+8egh8sYJ_nOqjCQU+fjkATZu_0EcPg@mail.gmail.com>
 <aac27b38-fdf2-90cc-115c-ade9b565227b@anarres.org>
 <CAAcqB+v5iSPqWcHJWBFit0r_YmcYgD2wa7iPgjdNtN+YYcmrGA@mail.gmail.com>
Message-ID: <CAE+h5-Ba_R8aVb-VQdE1EvHQzbwsESTWmgaaMRAfGssKZmihCg@mail.gmail.com>

JLS 12.4.1 says: "A class or interface type T will be initialized
immediately before the first occurrence of any one of the following."

They don't define "immediately," but I think it's reasonable to assume that
it's more or less in line with people's intuition about lazy loading.

On Thu, May 31, 2018 at 4:16 PM, Carl Mastrangelo via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> As I understand it, class loading is lazy and this will do the right
> thing.  It *may* get garbage collected if not referenced (and maybe log
> twice), but that can be worked around.  The pattern is very common for
> singletons.
>
> On Thu, May 31, 2018 at 1:10 PM Shevek <shevek at anarres.org> wrote:
>
>> I know there's a guarantee that the JVM _will_ call this when desired.
>> Is there also a guarantee that the JVM will _not_ call this i.e. there
>> is no spurious class or opportunistic initialization? I think that's
>> harder to promise.
>>
>> On 05/31/2018 01:06 PM, Carl Mastrangelo wrote:
>> > At the cost of about 500 bytes of class size, you could do the trick in
>> > Effective Java:
>> >
>> > class Foo {
>> >     private static class Logged {
>> >       static void log() {}
>> >        static {
>> > LOG.warn("Warning");
>> >        }
>> >     }
>> >
>> >     public void run() {
>> > Logged.log();
>> >     }
>> > }
>> >
>> > On Wed, May 30, 2018 at 10:17 PM Shevek via Concurrency-interest
>> > <concurrency-interest at cs.oswego.edu
>> > <mailto:concurrency-interest at cs.oswego.edu>> wrote:
>> >
>> >     Hi,
>> >
>> >     I'd like to issue a warning message a relatively low number of
>> times in
>> >     a multi-threaded application. My code is this:
>> >
>> >     class Foo {
>> >         private boolean warned;
>> >
>> >         public void run() {
>> >           if (!warned) {
>> >              LOG.warn("Warning");
>> >              warned = true;
>> >           }
>> >         }
>> >     }
>> >
>> >     This is the only access to the variable 'warned', the value change
>> is
>> >     deliberately unsynchronized, and monotonic. Am I right to believe
>> that:
>> >
>> >     * The first call WILL issue a warning.
>> >     * Any thread will issue the warning AT MOST once.
>> >     * Some (later) threads may not issue the warning, if the updated
>> value
>> >     is flushed to the heap and they load it?
>> >
>> >     Is there a better way to do this without sacrificing performance? Is
>> >     this what the mysterious AtomicBoolean.lazySet, or even
>> >     weakCompareAndSet is about?
>> >
>> >     This is right in the middle of something very concurrent which runs
>> for
>> >     a long time, so reducing overhead is far more important than
>> >     occasionally issuing too many warnings.
>> >
>> >     Thank you.
>> >
>> >     S.
>> >     _______________________________________________
>> >     Concurrency-interest mailing list
>> >     Concurrency-interest at cs.oswego.edu
>> >     <mailto:Concurrency-interest at cs.oswego.edu>
>> >     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/20cb8c19/attachment.html>

From shevek at anarres.org  Thu May 31 18:49:13 2018
From: shevek at anarres.org (Shevek)
Date: Thu, 31 May 2018 15:49:13 -0700
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <CAE+h5-Ba_R8aVb-VQdE1EvHQzbwsESTWmgaaMRAfGssKZmihCg@mail.gmail.com>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <CAAcqB+s=bz4EKK1HN7t+8egh8sYJ_nOqjCQU+fjkATZu_0EcPg@mail.gmail.com>
 <aac27b38-fdf2-90cc-115c-ade9b565227b@anarres.org>
 <CAAcqB+v5iSPqWcHJWBFit0r_YmcYgD2wa7iPgjdNtN+YYcmrGA@mail.gmail.com>
 <CAE+h5-Ba_R8aVb-VQdE1EvHQzbwsESTWmgaaMRAfGssKZmihCg@mail.gmail.com>
Message-ID: <65be1de2-f106-20c2-9534-98c90084c69d@anarres.org>

My question is the converse: It does NOT say "will not be initialized 
UNLESS." That makes the Effective Java trick less useful for this case: 
I don't mind more than one call to log() when at least one is allowed, 
but if the guard condition never passes, I mustn't have spurious calls.

On 05/31/2018 02:42 PM, Yuval Shavit wrote:
> JLS 12.4.1 says: "A class or interface typeTwill be initialized 
> immediately before the first occurrence of any one of the following."
> 
> They don't define "immediately," but I think it's reasonable to assume 
> that it's more or less in line with people's intuition about lazy loading.
> 
> On Thu, May 31, 2018 at 4:16 PM, Carl Mastrangelo via 
> Concurrency-interest <concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>> wrote:
> 
>     As I understand it, class loading is lazy and this will do the right
>     thing.  It *may* get garbage collected if not referenced (and maybe
>     log twice), but that can be worked around.  The pattern is very
>     common for singletons.
> 
>     On Thu, May 31, 2018 at 1:10 PM Shevek <shevek at anarres.org
>     <mailto:shevek at anarres.org>> wrote:
> 
>         I know there's a guarantee that the JVM _will_ call this when
>         desired.
>         Is there also a guarantee that the JVM will _not_ call this i.e.
>         there
>         is no spurious class or opportunistic initialization? I think
>         that's
>         harder to promise.
> 
>         On 05/31/2018 01:06 PM, Carl Mastrangelo wrote:
>          > At the cost of about 500 bytes of class size, you could do
>         the trick in
>          > Effective Java:
>          >
>          > class Foo {
>          >     private static class Logged {
>          >       static void log() {}
>          >        static {
>          > LOG.warn("Warning");
>          >        }
>          >     }
>          >
>          >     public void run() {
>          > Logged.log();
>          >     }
>          > }
>          >
>          > On Wed, May 30, 2018 at 10:17 PM Shevek via Concurrency-interest
>          > <concurrency-interest at cs.oswego.edu
>         <mailto:concurrency-interest at cs.oswego.edu>
>          > <mailto:concurrency-interest at cs.oswego.edu
>         <mailto:concurrency-interest at cs.oswego.edu>>> wrote:
>          >
>          >     Hi,
>          >
>          >     I'd like to issue a warning message a relatively low
>         number of times in
>          >     a multi-threaded application. My code is this:
>          >
>          >     class Foo {
>          >         private boolean warned;
>          >
>          >         public void run() {
>          >           if (!warned) {
>          >              LOG.warn("Warning");
>          >              warned = true;
>          >           }
>          >         }
>          >     }
>          >
>          >     This is the only access to the variable 'warned', the
>         value change is
>          >     deliberately unsynchronized, and monotonic. Am I right to
>         believe that:
>          >
>          >     * The first call WILL issue a warning.
>          >     * Any thread will issue the warning AT MOST once.
>          >     * Some (later) threads may not issue the warning, if the
>         updated value
>          >     is flushed to the heap and they load it?
>          >
>          >     Is there a better way to do this without sacrificing
>         performance? Is
>          >     this what the mysterious AtomicBoolean.lazySet, or even
>          >     weakCompareAndSet is about?
>          >
>          >     This is right in the middle of something very concurrent
>         which runs for
>          >     a long time, so reducing overhead is far more important than
>          >     occasionally issuing too many warnings.
>          >
>          >     Thank you.
>          >
>          >     S.
>          >     _______________________________________________
>          >     Concurrency-interest mailing list
>          > Concurrency-interest at cs.oswego.edu
>         <mailto:Concurrency-interest at cs.oswego.edu>
>          >     <mailto:Concurrency-interest at cs.oswego.edu
>         <mailto:Concurrency-interest at cs.oswego.edu>>
>          > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>          >
> 
> 
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 

From davidcholmes at aapt.net.au  Thu May 31 18:55:46 2018
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 1 Jun 2018 08:55:46 +1000
Subject: [concurrency-interest] thread safety of java.lang.reflect.Field
In-Reply-To: <op.zjvgquu3wcnyyd@novi-pc>
References: <op.zjvgquu3wcnyyd@novi-pc>
Message-ID: <039101d3f932$834b2f60$89e18e20$@aapt.net.au>

The java.lang.reflect classes are not specified to be thread-safe. They probably should be specified that way but they aren't.

The implementation is quite complex in places and it is hard to determine whether they are thread-safe in practice. I can see some initialization race conditions with caching of field state (like getGenericInfo()) that theoretically could expose default rather than actual values.

David

> -----Original Message-----
> From: Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu> On Behalf Of Novi via Concurrency-interest
> Sent: Thursday, May 31, 2018 7:31 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] thread safety of java.lang.reflect.Field
> 
> Hello,
> 
> I wonder if instances of java.lang.reflect.Field can be shared between multiple threads as long as the accessibility flag is either not
> modified or modified exactly once prior to a safe publication of the field instances.
> 
> In other words, is it legal to cache instances of j.l.r.Field between multiple threads?
> 
> Best Regards,
> Novi
> 
> 
> PS: The Bean Validation reference implementation Hibernate Validator seems to cache instances of j.l.r.Field across threads.
> However, I couldn't find any clue in the Java API documentation whether such a usage is supported or not.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From notcarl at google.com  Thu May 31 19:16:46 2018
From: notcarl at google.com (Carl Mastrangelo)
Date: Thu, 31 May 2018 16:16:46 -0700
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <65be1de2-f106-20c2-9534-98c90084c69d@anarres.org>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <CAAcqB+s=bz4EKK1HN7t+8egh8sYJ_nOqjCQU+fjkATZu_0EcPg@mail.gmail.com>
 <aac27b38-fdf2-90cc-115c-ade9b565227b@anarres.org>
 <CAAcqB+v5iSPqWcHJWBFit0r_YmcYgD2wa7iPgjdNtN+YYcmrGA@mail.gmail.com>
 <CAE+h5-Ba_R8aVb-VQdE1EvHQzbwsESTWmgaaMRAfGssKZmihCg@mail.gmail.com>
 <65be1de2-f106-20c2-9534-98c90084c69d@anarres.org>
Message-ID: <CAAcqB+urDb2f5vfCnrE9AGP=TmmrRFL044SwSHdQgV+rJKzD6w@mail.gmail.com>

That was the thing I was trying to indicate.  Because class initialization
can have side effects, it would be unsafe for the JVM to eagerly load class
files.

On Thu, May 31, 2018 at 3:49 PM Shevek <shevek at anarres.org> wrote:

> My question is the converse: It does NOT say "will not be initialized
> UNLESS." That makes the Effective Java trick less useful for this case:
> I don't mind more than one call to log() when at least one is allowed,
> but if the guard condition never passes, I mustn't have spurious calls.
>
> On 05/31/2018 02:42 PM, Yuval Shavit wrote:
> > JLS 12.4.1 says: "A class or interface typeTwill be initialized
> > immediately before the first occurrence of any one of the following."
> >
> > They don't define "immediately," but I think it's reasonable to assume
> > that it's more or less in line with people's intuition about lazy
> loading.
> >
> > On Thu, May 31, 2018 at 4:16 PM, Carl Mastrangelo via
> > Concurrency-interest <concurrency-interest at cs.oswego.edu
> > <mailto:concurrency-interest at cs.oswego.edu>> wrote:
> >
> >     As I understand it, class loading is lazy and this will do the right
> >     thing.  It *may* get garbage collected if not referenced (and maybe
> >     log twice), but that can be worked around.  The pattern is very
> >     common for singletons.
> >
> >     On Thu, May 31, 2018 at 1:10 PM Shevek <shevek at anarres.org
> >     <mailto:shevek at anarres.org>> wrote:
> >
> >         I know there's a guarantee that the JVM _will_ call this when
> >         desired.
> >         Is there also a guarantee that the JVM will _not_ call this i.e.
> >         there
> >         is no spurious class or opportunistic initialization? I think
> >         that's
> >         harder to promise.
> >
> >         On 05/31/2018 01:06 PM, Carl Mastrangelo wrote:
> >          > At the cost of about 500 bytes of class size, you could do
> >         the trick in
> >          > Effective Java:
> >          >
> >          > class Foo {
> >          >     private static class Logged {
> >          >       static void log() {}
> >          >        static {
> >          > LOG.warn("Warning");
> >          >        }
> >          >     }
> >          >
> >          >     public void run() {
> >          > Logged.log();
> >          >     }
> >          > }
> >          >
> >          > On Wed, May 30, 2018 at 10:17 PM Shevek via
> Concurrency-interest
> >          > <concurrency-interest at cs.oswego.edu
> >         <mailto:concurrency-interest at cs.oswego.edu>
> >          > <mailto:concurrency-interest at cs.oswego.edu
> >         <mailto:concurrency-interest at cs.oswego.edu>>> wrote:
> >          >
> >          >     Hi,
> >          >
> >          >     I'd like to issue a warning message a relatively low
> >         number of times in
> >          >     a multi-threaded application. My code is this:
> >          >
> >          >     class Foo {
> >          >         private boolean warned;
> >          >
> >          >         public void run() {
> >          >           if (!warned) {
> >          >              LOG.warn("Warning");
> >          >              warned = true;
> >          >           }
> >          >         }
> >          >     }
> >          >
> >          >     This is the only access to the variable 'warned', the
> >         value change is
> >          >     deliberately unsynchronized, and monotonic. Am I right to
> >         believe that:
> >          >
> >          >     * The first call WILL issue a warning.
> >          >     * Any thread will issue the warning AT MOST once.
> >          >     * Some (later) threads may not issue the warning, if the
> >         updated value
> >          >     is flushed to the heap and they load it?
> >          >
> >          >     Is there a better way to do this without sacrificing
> >         performance? Is
> >          >     this what the mysterious AtomicBoolean.lazySet, or even
> >          >     weakCompareAndSet is about?
> >          >
> >          >     This is right in the middle of something very concurrent
> >         which runs for
> >          >     a long time, so reducing overhead is far more important
> than
> >          >     occasionally issuing too many warnings.
> >          >
> >          >     Thank you.
> >          >
> >          >     S.
> >          >     _______________________________________________
> >          >     Concurrency-interest mailing list
> >          > Concurrency-interest at cs.oswego.edu
> >         <mailto:Concurrency-interest at cs.oswego.edu>
> >          >     <mailto:Concurrency-interest at cs.oswego.edu
> >         <mailto:Concurrency-interest at cs.oswego.edu>>
> >          > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> >          >
> >
> >
> >     _______________________________________________
> >     Concurrency-interest mailing list
> >     Concurrency-interest at cs.oswego.edu
> >     <mailto:Concurrency-interest at cs.oswego.edu>
> >     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/829115a1/attachment.html>

From davidcholmes at aapt.net.au  Thu May 31 20:33:31 2018
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 1 Jun 2018 10:33:31 +1000
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <65be1de2-f106-20c2-9534-98c90084c69d@anarres.org>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <CAAcqB+s=bz4EKK1HN7t+8egh8sYJ_nOqjCQU+fjkATZu_0EcPg@mail.gmail.com>
 <aac27b38-fdf2-90cc-115c-ade9b565227b@anarres.org>
 <CAAcqB+v5iSPqWcHJWBFit0r_YmcYgD2wa7iPgjdNtN+YYcmrGA@mail.gmail.com>
 <CAE+h5-Ba_R8aVb-VQdE1EvHQzbwsESTWmgaaMRAfGssKZmihCg@mail.gmail.com>
 <65be1de2-f106-20c2-9534-98c90084c69d@anarres.org>
Message-ID: <03a201d3f940$2b3827c0$81a87740$@aapt.net.au>

Classloading can be lazy or eager. Class initialization is very precise.

David

> -----Original Message-----
> From: Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu> On Behalf Of Shevek via Concurrency-interest
> Sent: Friday, June 1, 2018 8:49 AM
> To: Yuval Shavit <yankee.sierra at gmail.com>; Carl Mastrangelo <notcarl at google.com>
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Unsynchronized lazy conditions
> 
> My question is the converse: It does NOT say "will not be initialized UNLESS." That makes the Effective Java trick less useful for this
> case:
> I don't mind more than one call to log() when at least one is allowed, but if the guard condition never passes, I mustn't have spurious
> calls.
> 
> On 05/31/2018 02:42 PM, Yuval Shavit wrote:
> > JLS 12.4.1 says: "A class or interface typeTwill be initialized
> > immediately before the first occurrence of any one of the following."
> >
> > They don't define "immediately," but I think it's reasonable to assume
> > that it's more or less in line with people's intuition about lazy loading.
> >
> > On Thu, May 31, 2018 at 4:16 PM, Carl Mastrangelo via
> > Concurrency-interest <concurrency-interest at cs.oswego.edu
> > <mailto:concurrency-interest at cs.oswego.edu>> wrote:
> >
> >     As I understand it, class loading is lazy and this will do the right
> >     thing.  It *may* get garbage collected if not referenced (and maybe
> >     log twice), but that can be worked around.  The pattern is very
> >     common for singletons.
> >
> >     On Thu, May 31, 2018 at 1:10 PM Shevek <shevek at anarres.org
> >     <mailto:shevek at anarres.org>> wrote:
> >
> >         I know there's a guarantee that the JVM _will_ call this when
> >         desired.
> >         Is there also a guarantee that the JVM will _not_ call this i.e.
> >         there
> >         is no spurious class or opportunistic initialization? I think
> >         that's
> >         harder to promise.
> >
> >         On 05/31/2018 01:06 PM, Carl Mastrangelo wrote:
> >          > At the cost of about 500 bytes of class size, you could do
> >         the trick in
> >          > Effective Java:
> >          >
> >          > class Foo {
> >          >     private static class Logged {
> >          >       static void log() {}
> >          >        static {
> >          > LOG.warn("Warning");
> >          >        }
> >          >     }
> >          >
> >          >     public void run() {
> >          > Logged.log();
> >          >     }
> >          > }
> >          >
> >          > On Wed, May 30, 2018 at 10:17 PM Shevek via Concurrency-interest
> >          > <concurrency-interest at cs.oswego.edu
> >         <mailto:concurrency-interest at cs.oswego.edu>
> >          > <mailto:concurrency-interest at cs.oswego.edu
> >         <mailto:concurrency-interest at cs.oswego.edu>>> wrote:
> >          >
> >          >     Hi,
> >          >
> >          >     I'd like to issue a warning message a relatively low
> >         number of times in
> >          >     a multi-threaded application. My code is this:
> >          >
> >          >     class Foo {
> >          >         private boolean warned;
> >          >
> >          >         public void run() {
> >          >           if (!warned) {
> >          >              LOG.warn("Warning");
> >          >              warned = true;
> >          >           }
> >          >         }
> >          >     }
> >          >
> >          >     This is the only access to the variable 'warned', the
> >         value change is
> >          >     deliberately unsynchronized, and monotonic. Am I right to
> >         believe that:
> >          >
> >          >     * The first call WILL issue a warning.
> >          >     * Any thread will issue the warning AT MOST once.
> >          >     * Some (later) threads may not issue the warning, if the
> >         updated value
> >          >     is flushed to the heap and they load it?
> >          >
> >          >     Is there a better way to do this without sacrificing
> >         performance? Is
> >          >     this what the mysterious AtomicBoolean.lazySet, or even
> >          >     weakCompareAndSet is about?
> >          >
> >          >     This is right in the middle of something very concurrent
> >         which runs for
> >          >     a long time, so reducing overhead is far more important than
> >          >     occasionally issuing too many warnings.
> >          >
> >          >     Thank you.
> >          >
> >          >     S.
> >          >     _______________________________________________
> >          >     Concurrency-interest mailing list
> >          > Concurrency-interest at cs.oswego.edu
> >         <mailto:Concurrency-interest at cs.oswego.edu>
> >          >     <mailto:Concurrency-interest at cs.oswego.edu
> >         <mailto:Concurrency-interest at cs.oswego.edu>>
> >          > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> >          >
> >
> >
> >     _______________________________________________
> >     Concurrency-interest mailing list
> >     Concurrency-interest at cs.oswego.edu
> >     <mailto:Concurrency-interest at cs.oswego.edu>
> >     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> >
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From yankee.sierra at gmail.com  Thu May 31 23:13:19 2018
From: yankee.sierra at gmail.com (Yuval Shavit)
Date: Thu, 31 May 2018 23:13:19 -0400
Subject: [concurrency-interest] Unsynchronized lazy conditions
In-Reply-To: <03a201d3f940$2b3827c0$81a87740$@aapt.net.au>
References: <630cefff-433f-4c1d-e336-221a38121a98@anarres.org>
 <CAAcqB+s=bz4EKK1HN7t+8egh8sYJ_nOqjCQU+fjkATZu_0EcPg@mail.gmail.com>
 <aac27b38-fdf2-90cc-115c-ade9b565227b@anarres.org>
 <CAAcqB+v5iSPqWcHJWBFit0r_YmcYgD2wa7iPgjdNtN+YYcmrGA@mail.gmail.com>
 <CAE+h5-Ba_R8aVb-VQdE1EvHQzbwsESTWmgaaMRAfGssKZmihCg@mail.gmail.com>
 <65be1de2-f106-20c2-9534-98c90084c69d@anarres.org>
 <03a201d3f940$2b3827c0$81a87740$@aapt.net.au>
Message-ID: <CAE+h5-BrGMuVkR+9iXqFxt4nXDapX=xZbmPs+d_JqmiCBjkJCA@mail.gmail.com>

I think the key word is "immediately." If the initialization happened far
before (ie, that converse case you mentioned), then it wouldn't be
immediately before.

On Thu, May 31, 2018, 8:33 PM David Holmes <davidcholmes at aapt.net.au> wrote:

> Classloading can be lazy or eager. Class initialization is very precise.
>
> David
>
> > -----Original Message-----
> > From: Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu>
> On Behalf Of Shevek via Concurrency-interest
> > Sent: Friday, June 1, 2018 8:49 AM
> > To: Yuval Shavit <yankee.sierra at gmail.com>; Carl Mastrangelo <
> notcarl at google.com>
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Unsynchronized lazy conditions
> >
> > My question is the converse: It does NOT say "will not be initialized
> UNLESS." That makes the Effective Java trick less useful for this
> > case:
> > I don't mind more than one call to log() when at least one is allowed,
> but if the guard condition never passes, I mustn't have spurious
> > calls.
> >
> > On 05/31/2018 02:42 PM, Yuval Shavit wrote:
> > > JLS 12.4.1 says: "A class or interface typeTwill be initialized
> > > immediately before the first occurrence of any one of the following."
> > >
> > > They don't define "immediately," but I think it's reasonable to assume
> > > that it's more or less in line with people's intuition about lazy
> loading.
> > >
> > > On Thu, May 31, 2018 at 4:16 PM, Carl Mastrangelo via
> > > Concurrency-interest <concurrency-interest at cs.oswego.edu
> > > <mailto:concurrency-interest at cs.oswego.edu>> wrote:
> > >
> > >     As I understand it, class loading is lazy and this will do the
> right
> > >     thing.  It *may* get garbage collected if not referenced (and maybe
> > >     log twice), but that can be worked around.  The pattern is very
> > >     common for singletons.
> > >
> > >     On Thu, May 31, 2018 at 1:10 PM Shevek <shevek at anarres.org
> > >     <mailto:shevek at anarres.org>> wrote:
> > >
> > >         I know there's a guarantee that the JVM _will_ call this when
> > >         desired.
> > >         Is there also a guarantee that the JVM will _not_ call this
> i.e.
> > >         there
> > >         is no spurious class or opportunistic initialization? I think
> > >         that's
> > >         harder to promise.
> > >
> > >         On 05/31/2018 01:06 PM, Carl Mastrangelo wrote:
> > >          > At the cost of about 500 bytes of class size, you could do
> > >         the trick in
> > >          > Effective Java:
> > >          >
> > >          > class Foo {
> > >          >     private static class Logged {
> > >          >       static void log() {}
> > >          >        static {
> > >          > LOG.warn("Warning");
> > >          >        }
> > >          >     }
> > >          >
> > >          >     public void run() {
> > >          > Logged.log();
> > >          >     }
> > >          > }
> > >          >
> > >          > On Wed, May 30, 2018 at 10:17 PM Shevek via
> Concurrency-interest
> > >          > <concurrency-interest at cs.oswego.edu
> > >         <mailto:concurrency-interest at cs.oswego.edu>
> > >          > <mailto:concurrency-interest at cs.oswego.edu
> > >         <mailto:concurrency-interest at cs.oswego.edu>>> wrote:
> > >          >
> > >          >     Hi,
> > >          >
> > >          >     I'd like to issue a warning message a relatively low
> > >         number of times in
> > >          >     a multi-threaded application. My code is this:
> > >          >
> > >          >     class Foo {
> > >          >         private boolean warned;
> > >          >
> > >          >         public void run() {
> > >          >           if (!warned) {
> > >          >              LOG.warn("Warning");
> > >          >              warned = true;
> > >          >           }
> > >          >         }
> > >          >     }
> > >          >
> > >          >     This is the only access to the variable 'warned', the
> > >         value change is
> > >          >     deliberately unsynchronized, and monotonic. Am I right
> to
> > >         believe that:
> > >          >
> > >          >     * The first call WILL issue a warning.
> > >          >     * Any thread will issue the warning AT MOST once.
> > >          >     * Some (later) threads may not issue the warning, if the
> > >         updated value
> > >          >     is flushed to the heap and they load it?
> > >          >
> > >          >     Is there a better way to do this without sacrificing
> > >         performance? Is
> > >          >     this what the mysterious AtomicBoolean.lazySet, or even
> > >          >     weakCompareAndSet is about?
> > >          >
> > >          >     This is right in the middle of something very concurrent
> > >         which runs for
> > >          >     a long time, so reducing overhead is far more important
> than
> > >          >     occasionally issuing too many warnings.
> > >          >
> > >          >     Thank you.
> > >          >
> > >          >     S.
> > >          >     _______________________________________________
> > >          >     Concurrency-interest mailing list
> > >          > Concurrency-interest at cs.oswego.edu
> > >         <mailto:Concurrency-interest at cs.oswego.edu>
> > >          >     <mailto:Concurrency-interest at cs.oswego.edu
> > >         <mailto:Concurrency-interest at cs.oswego.edu>>
> > >          > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> > >          >
> > >
> > >
> > >     _______________________________________________
> > >     Concurrency-interest mailing list
> > >     Concurrency-interest at cs.oswego.edu
> > >     <mailto:Concurrency-interest at cs.oswego.edu>
> > >     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> > >
> > >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180531/63c104c8/attachment-0001.html>

