From akarnokd at gmail.com  Wed Aug  2 08:32:16 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Wed, 2 Aug 2017 14:32:16 +0200
Subject: [concurrency-interest] Flow JavaDoc example not updated to forbid
	request(0)
Message-ID: <CAAWwtm8_Kx=qpWeesLESd24sdgKS1L6M-QyybGrFs6Bh2HcpAQ@mail.gmail.com>

Hi,

Java 9 b180:

In java.util.concurrent.Flow lines 88-92, n == 0 is ignored but it should
be signalling the same IllegalArgumentException the n < 0 does (as it was
discussed on the Reactive-Streams issue list).

The same mistake is present in the JSR166 CVS:
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/Flow.java?revision=1.31&view=markup

(I guess JDK 9 being in release-candidate will not permit such nicety
javadoc changes, oh well.)

-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170802/c4c822e2/attachment.html>

From aph at redhat.com  Fri Aug  4 13:18:43 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 4 Aug 2017 18:18:43 +0100
Subject: [concurrency-interest] Programming language-independent memory
	models
Message-ID: <b0be9ec7-74cd-eee3-2778-5f20a550f373@redhat.com>

Do such things exist?  Java and C++ have their own, which are mostly
compatible but not quite.  Any language implemented in C++ will
necessarily implement the C++ memory model, which (perhaps)
unfortunately implies that if it executes any data races the whole
program becomes undefined.  A programming language interpreter written
in C++ could get around that by using atomic types for everything, but
that's rather unpleasant.  The Java memory model is somewhat more sane
than that, and might provide a better base.

Defining a memory model is a substantial task.  It would be nice, from
a blue sky point of view, to be able to pull a memory model off the
shelf and say "Language X uses the Y memory model" and leave it at
that, pausing only to describe Programming Languages X's mapping from
its own operators to those of the Y memory model.  I'll grant that
this is difficult, because programming language semantics play a large
part in the way a language uses memory.  However, that's surely easier
than starting with nothing.

I'm wondering if, in the wonderful world of polyglot systems and
applications, there has been any work in this area.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From aph at redhat.com  Fri Aug  4 13:54:35 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 4 Aug 2017 18:54:35 +0100
Subject: [concurrency-interest] Programming language-independent memory
 models
In-Reply-To: <CACeCrouaS27ikVMmm26dLfsw5zubS9TK6zxBrxPNSOmzQzCyKg@mail.gmail.com>
References: <b0be9ec7-74cd-eee3-2778-5f20a550f373@redhat.com>
 <CACeCrouaS27ikVMmm26dLfsw5zubS9TK6zxBrxPNSOmzQzCyKg@mail.gmail.com>
Message-ID: <7c381b6c-3911-1b8b-5bfc-bfd1b53042ca@redhat.com>

On 04/08/17 18:32, JF Bastien wrote:
> CPUs each have a memory model, formalized or not. x86, ARM and POWER each
> have formalizations.
> Defined mappings have been written from C++ to them too:
> https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html

Yes, thanks.  We implemented HotSpot on AArch64, so I am familiar with
how that processor works, and I used Peter Sewell's mappings for inspiration.

> We're currently in the process of defining a formal memory model for
> JavaScript and WebAssembly:
> 
> https://github.com/tc39/ecmascript_sharedmem/issues/88
> 
> This is different from other language memory models because it's meant as a
> compilation target, closer to a virtual ISA (compilers target them) than
> something programmers use directly.

That's useful, thanks.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From dl at cs.oswego.edu  Fri Aug  4 19:05:54 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 4 Aug 2017 19:05:54 -0400
Subject: [concurrency-interest] Flow JavaDoc example not updated to
 forbid request(0)
In-Reply-To: <CAAWwtm8_Kx=qpWeesLESd24sdgKS1L6M-QyybGrFs6Bh2HcpAQ@mail.gmail.com>
References: <CAAWwtm8_Kx=qpWeesLESd24sdgKS1L6M-QyybGrFs6Bh2HcpAQ@mail.gmail.com>
Message-ID: <f8c013fc-bca3-4971-7ac3-c9afc060abc3@cs.oswego.edu>

On 08/02/2017 08:32 AM, Dávid Karnok wrote:

> In java.util.concurrent.Flow lines 88-92, n == 0 is ignored but it
> should be signalling the same IllegalArgumentException the n < 0 does

Thanks! Sorry that no one spotted this.

> 
> (I guess JDK 9 being in release-candidate will not permit such nicety
> javadoc changes, oh well.)
> 

Probably not, but there will be the usual periodic update releases.

-Doug




From boehm at acm.org  Sat Aug  5 01:04:23 2017
From: boehm at acm.org (Hans Boehm)
Date: Fri, 4 Aug 2017 22:04:23 -0700
Subject: [concurrency-interest] Programming language-independent memory
	models
In-Reply-To: <b0be9ec7-74cd-eee3-2778-5f20a550f373@redhat.com>
References: <b0be9ec7-74cd-eee3-2778-5f20a550f373@redhat.com>
Message-ID: <CAPUmR1YaYOFyFA0gvg9s3ntJWLrNf7h9nzXF9P6V5m23W+GU-g@mail.gmail.com>

The problem is that there are actually semi-rational reasons for the
differences between the C++ and Java memory models. And we tried to make
the two as similar as possible were such reasons didn't exist.

Java wanted to avoid undefined behavior (for the core language) at pretty
much all costs. The costs unfortunately include:

- Fences in object constructors
- New (for C++) optimization constraints, e.g. the inability to
rematerialize spilled registers from globals
- Serious definitional problems with out-of-thin-air results for basically
every program (as opposed to just memory_order_relaxed accesses in C++)

These were probably reasonable tradeoffs for Java, especially at the time.
But I don't think they would fly for C or C++.

I'm not sure that using memory_order_relaxed in a Java interpreter is that
much of an issue, given that JIT-compiled code would still benefit from the
weaker Java semantics. For the few cases for which this is seriously
suboptimal, e.g. long accesses on mips32, you could resort to assembly code.

On Fri, Aug 4, 2017 at 10:18 AM, Andrew Haley <aph at redhat.com> wrote:

> Do such things exist?  Java and C++ have their own, which are mostly
> compatible but not quite.  Any language implemented in C++ will
> necessarily implement the C++ memory model, which (perhaps)
> unfortunately implies that if it executes any data races the whole
> program becomes undefined.  A programming language interpreter written
> in C++ could get around that by using atomic types for everything, but
> that's rather unpleasant.  The Java memory model is somewhat more sane
> than that, and might provide a better base.
>
> Defining a memory model is a substantial task.  It would be nice, from
> a blue sky point of view, to be able to pull a memory model off the
> shelf and say "Language X uses the Y memory model" and leave it at
> that, pausing only to describe Programming Languages X's mapping from
> its own operators to those of the Y memory model.  I'll grant that
> this is difficult, because programming language semantics play a large
> part in the way a language uses memory.  However, that's surely easier
> than starting with nothing.
>
> I'm wondering if, in the wonderful world of polyglot systems and
> applications, there has been any work in this area.
>
> --
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170804/1e562839/attachment.html>

From aph at redhat.com  Mon Aug  7 04:46:31 2017
From: aph at redhat.com (Andrew Haley)
Date: Mon, 7 Aug 2017 09:46:31 +0100
Subject: [concurrency-interest] Programming language-independent memory
 models
In-Reply-To: <CAPUmR1YaYOFyFA0gvg9s3ntJWLrNf7h9nzXF9P6V5m23W+GU-g@mail.gmail.com>
References: <b0be9ec7-74cd-eee3-2778-5f20a550f373@redhat.com>
 <CAPUmR1YaYOFyFA0gvg9s3ntJWLrNf7h9nzXF9P6V5m23W+GU-g@mail.gmail.com>
Message-ID: <9e4138d5-f1bf-7d31-5adf-c3c0b77f56e7@redhat.com>

On 05/08/17 06:04, Hans Boehm wrote:
> The problem is that there are actually semi-rational reasons for the
> differences between the C++ and Java memory models. And we tried to make
> the two as similar as possible were such reasons didn't exist.
> 
> Java wanted to avoid undefined behavior (for the core language) at
> pretty much all costs. The costs unfortunately include:
> 
> - Fences in object constructors
> - New (for C++) optimization constraints, e.g. the inability to
> rematerialize spilled registers from globals

Really?  I didn't realize that was a change, and I suspect that
compilers still do it.

> - Serious definitional problems with out-of-thin-air results for
> basically every program (as opposed to just memory_order_relaxed
> accesses in C++)
> 
> These were probably reasonable tradeoffs for Java, especially at the time.
> But I don't think they would fly for C or C++.

OK, thanks for that explanation.  But there are many languages around,
and many of them allow multiple threads, and many of those allow
concurrent access to shared state.  There is no way that language
designers are going to be able to put in the amount of work needed to
define a memory model for their language.  If they run on x86 they'll
usually be fine, of course!  Perhaps what they need is some kind of
boilerplate for a language memory model.

> I'm not sure that using memory_order_relaxed in a Java interpreter is that
> much of an issue, given that JIT-compiled code would still benefit from the
> weaker Java semantics. For the few cases for which this is seriously
> suboptimal, e.g. long accesses on mips32, you could resort to assembly code.

That makes sense.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From boehm at acm.org  Tue Aug  8 15:10:11 2017
From: boehm at acm.org (Hans Boehm)
Date: Tue, 8 Aug 2017 12:10:11 -0700
Subject: [concurrency-interest] Programming language-independent memory
	models
In-Reply-To: <9e4138d5-f1bf-7d31-5adf-c3c0b77f56e7@redhat.com>
References: <b0be9ec7-74cd-eee3-2778-5f20a550f373@redhat.com>
 <CAPUmR1YaYOFyFA0gvg9s3ntJWLrNf7h9nzXF9P6V5m23W+GU-g@mail.gmail.com>
 <9e4138d5-f1bf-7d31-5adf-c3c0b77f56e7@redhat.com>
Message-ID: <CAPUmR1ZTJ9PKW7CBOfbHRAJrOqj0YvscN65NZB+XbfSJN+OG7Q@mail.gmail.com>

On Mon, Aug 7, 2017 at 1:46 AM, Andrew Haley <aph at redhat.com> wrote:
>
> On 05/08/17 06:04, Hans Boehm wrote:
> > The problem is that there are actually semi-rational reasons for the
> > differences between the C++ and Java memory models. And we tried to make
> > the two as similar as possible were such reasons didn't exist.
> >
> > Java wanted to avoid undefined behavior (for the core language) at
> > pretty much all costs. The costs unfortunately include:
> >
> > - Fences in object constructors
> > - New (for C++) optimization constraints, e.g. the inability to
> > rematerialize spilled registers from globals
>
> Really?  I didn't realize that was a change, and I suspect that
> compilers still do it.
Just to be clear: Java does not allow rematerializing spilled registers from
globals. C++ does. AFAIK compilers generally follow the language-
appropriate rules.

>
> > - Serious definitional problems with out-of-thin-air results for
> > basically every program (as opposed to just memory_order_relaxed
> > accesses in C++)
> >
> > These were probably reasonable tradeoffs for Java, especially at the
time.
> > But I don't think they would fly for C or C++.
>
> OK, thanks for that explanation.  But there are many languages around,
> and many of them allow multiple threads, and many of those allow
> concurrent access to shared state.  There is no way that language
> designers are going to be able to put in the amount of work needed to
> define a memory model for their language.  If they run on x86 they'll
> usually be fine, of course!  Perhaps what they need is some kind of
> boilerplate for a language memory model.

IMHO, the closest we have that is actually solid and understandable
is the basic DRF model, with undefined semantics for data races.
e.g. sections 2+3 from http://dl.acm.org/citation.cfm?id=1375581.1375591 .
This was never actually that expensive on x86, and it seems to be getting
more affordable on ARM as well. But my impression is that it'll never fly
on a GPU.

We know how to correctly add acquire/release atomics, though that
mixed model becomes far more complicated and unintuitive.

But almost everyone seems to feel the need to throw in some kind
of relaxed atomics or defined behavior for data races, at which point
things get flaky, and a universal design seems unlikely to me.

>
> > I'm not sure that using memory_order_relaxed in a Java interpreter is
that
> > much of an issue, given that JIT-compiled code would still benefit from
the
> > weaker Java semantics. For the few cases for which this is seriously
> > suboptimal, e.g. long accesses on mips32, you could resort to assembly
code.
>
> That makes sense.
>
> --
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170808/12ef50ec/attachment.html>

From martinrb at google.com  Tue Aug  8 21:36:36 2017
From: martinrb at google.com (Martin Buchholz)
Date: Tue, 8 Aug 2017 18:36:36 -0700
Subject: [concurrency-interest] Adding toString methods for task objects?
Message-ID: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>

My colleague Charles Munger suggests adding toString methods to various
task classes in j.u.c.  Obviously this makes it easier to debug large
programs that have gone wrong.  But it obviously also is a behavior change
that has the potential for trouble, even when everyone is behaving nicely,
since toString may have the effect of generating an unbounded output.  I
almost started down this road myself a few years ago but chickened out.
What do you think?

Index: Executors.java
===================================================================
RCS file:
/export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/Executors.java,v
retrieving revision 1.97
diff -u -U 10 -r1.97 Executors.java
--- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
+++ Executors.java 9 Aug 2017 01:34:25 -0000
@@ -478,20 +478,24 @@
         private final Runnable task;
         private final T result;
         RunnableAdapter(Runnable task, T result) {
             this.task = task;
             this.result = result;
         }
         public T call() {
             task.run();
             return result;
         }
+        public String toString() {
+            return super.toString()
+                + "[task=[" + task + "], result=[" + result + "]]";
+        }
     }

     /**
      * A callable that runs under established access control settings.
      */
     private static final class PrivilegedCallable<T> implements
Callable<T> {
         final Callable<T> task;
         final AccessControlContext acc;

         PrivilegedCallable(Callable<T> task) {
@@ -504,20 +508,24 @@
                 return AccessController.doPrivileged(
                     new PrivilegedExceptionAction<T>() {
                         public T run() throws Exception {
                             return task.call();
                         }
                     }, acc);
             } catch (PrivilegedActionException e) {
                 throw e.getException();
             }
         }
+
+        public String toString() {
+            return super.toString() + "[task=[" + task + "]]";
+        }
     }

     /**
      * A callable that runs under established access control settings and
      * current ClassLoader.
      */
     private static final class PrivilegedCallableUsingCurrentClassLoader<T>
             implements Callable<T> {
         final Callable<T> task;
         final AccessControlContext acc;
@@ -556,20 +564,24 @@
                                 } finally {
                                     t.setContextClassLoader(cl);
                                 }
                             }
                         }
                     }, acc);
             } catch (PrivilegedActionException e) {
                 throw e.getException();
             }
         }
+
+        public String toString() {
+            return super.toString() + "[task=[" + task + "]]";
+        }
     }

     /**
      * The default thread factory.
      */
     private static class DefaultThreadFactory implements ThreadFactory {
         private static final AtomicInteger poolNumber = new
AtomicInteger(1);
         private final ThreadGroup group;
         private final AtomicInteger threadNumber = new AtomicInteger(1);
         private final String namePrefix;
Index: ForkJoinTask.java
===================================================================
RCS file:
/export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/ForkJoinTask.java,v
retrieving revision 1.115
diff -u -U 10 -r1.115 ForkJoinTask.java
--- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
+++ ForkJoinTask.java 9 Aug 2017 01:34:25 -0000
@@ -1339,37 +1339,43 @@
         T result;
         AdaptedRunnable(Runnable runnable, T result) {
             if (runnable == null) throw new NullPointerException();
             this.runnable = runnable;
             this.result = result; // OK to set this even before completion
         }
         public final T getRawResult() { return result; }
         public final void setRawResult(T v) { result = v; }
         public final boolean exec() { runnable.run(); return true; }
         public final void run() { invoke(); }
+        public String toString() {
+            return super.toString() + "[task=[" + runnable + "], result=["
+ result + "]]";
+        }
         private static final long serialVersionUID = 5232453952276885070L;
     }

     /**
      * Adapter for Runnables without results.
      */
     static final class AdaptedRunnableAction extends ForkJoinTask<Void>
         implements RunnableFuture<Void> {
         final Runnable runnable;
         AdaptedRunnableAction(Runnable runnable) {
             if (runnable == null) throw new NullPointerException();
             this.runnable = runnable;
         }
         public final Void getRawResult() { return null; }
         public final void setRawResult(Void v) { }
         public final boolean exec() { runnable.run(); return true; }
         public final void run() { invoke(); }
+        public String toString() {
+            return super.toString() + "[task=[" + runnable + "]]";
+        }
         private static final long serialVersionUID = 5232453952276885070L;
     }

     /**
      * Adapter for Runnables in which failure forces worker exception.
      */
     static final class RunnableExecuteAction extends ForkJoinTask<Void> {
         final Runnable runnable;
         RunnableExecuteAction(Runnable runnable) {
             if (runnable == null) throw new NullPointerException();
@@ -1402,20 +1408,23 @@
                 result = callable.call();
                 return true;
             } catch (RuntimeException rex) {
                 throw rex;
             } catch (Exception ex) {
                 throw new RuntimeException(ex);
             }
         }
         public final void run() { invoke(); }
         private static final long serialVersionUID = 2838392045355241008L;
+        public String toString() {
+            return super.toString() + "[task=[" + callable + "]]";
+        }
     }

     /**
      * Returns a new {@code ForkJoinTask} that performs the {@code run}
      * method of the given {@code Runnable} as its action, and returns
      * a null result upon {@link #join}.
      *
      * @param runnable the runnable action
      * @return the task
      */
Index: FutureTask.java
===================================================================
RCS file:
/export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/FutureTask.java,v
retrieving revision 1.118
diff -u -U 10 -r1.118 FutureTask.java
--- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
+++ FutureTask.java 9 Aug 2017 01:34:25 -0000
@@ -444,20 +444,49 @@
                             continue retry;
                     }
                     else if (!WAITERS.compareAndSet(this, q, s))
                         continue retry;
                 }
                 break;
             }
         }
     }

+    public String toString() {
+        String start = super.toString() + "[status=";
+        try {
+            switch (state) {
+            case NEW:
+            case COMPLETING:
+                final Callable<?> callable = this.callable;
+                if (callable != null) {
+                    return start + "PENDING, task=[" + callable + "]]";
+                } else {
+                    return start + "PENDING]";
+                }
+            case NORMAL:
+                return start + "SUCCESS, result=[" + outcome + "]]";
+            case EXCEPTIONAL:
+                return start + "FAILURE, cause=[" + outcome + "]]";
+            case CANCELLED:
+            case INTERRUPTING:
+            case INTERRUPTED:
+                return start + "CANCELLED]";
+            default:
+                throw new IllegalStateException();
+            }
+        } catch (RuntimeException thrownFromToString) {
+            return start + "UNKNOWN, cause=["
+                + thrownFromToString.getClass() + "]";
+        }
+    }
+
     // VarHandle mechanics
     private static final VarHandle STATE;
     private static final VarHandle RUNNER;
     private static final VarHandle WAITERS;
     static {
         try {
             MethodHandles.Lookup l = MethodHandles.lookup();
             STATE = l.findVarHandle(FutureTask.class, "state", int.class);
             RUNNER = l.findVarHandle(FutureTask.class, "runner",
Thread.class);
             WAITERS = l.findVarHandle(FutureTask.class, "waiters",
WaitNode.class);
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170808/1a354d89/attachment-0001.html>

From joe.bowbeer at gmail.com  Tue Aug  8 21:58:06 2017
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 8 Aug 2017 18:58:06 -0700
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
Message-ID: <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>

​I would consider this to be an API change. For example, according to the
current javadoc, FutureTask's toString method is inherited from Object.

Practically speaking, I'd be concerned about unexpected and unwanted
changes to the output/log statements of programs that have up until now
been working fine. In addition to generating a lot of output that may be
unwanted, this may also generate exceptions. For example,
PrivilegedCallable.toString calls the toString method of the wrapped
Callable, which may never have been called previously (bam!), and therefore
might throw an exception. Or, the toString method of the wrapped callable
may have been designed to be called in a different context.

If any of the state the toString implementations are accessing is not
thread-safe, I'd also be concerned about that.

If tasks need toString implementations, I prefer to write them.​

However, I think it would be OK to introduce new convenience methods:
debugString()

On Tue, Aug 8, 2017 at 6:36 PM, Martin Buchholz <martinrb at google.com> wrote:

> My colleague Charles Munger suggests adding toString methods to various
> task classes in j.u.c.  Obviously this makes it easier to debug large
> programs that have gone wrong.  But it obviously also is a behavior change
> that has the potential for trouble, even when everyone is behaving nicely,
> since toString may have the effect of generating an unbounded output.  I
> almost started down this road myself a few years ago but chickened out.
> What do you think?
>
> Index: Executors.java
> ===================================================================
> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/
> concurrent/Executors.java,v
> retrieving revision 1.97
> diff -u -U 10 -r1.97 Executors.java
> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
> +++ Executors.java 9 Aug 2017 01:34:25 -0000
> @@ -478,20 +478,24 @@
>          private final Runnable task;
>          private final T result;
>          RunnableAdapter(Runnable task, T result) {
>              this.task = task;
>              this.result = result;
>          }
>          public T call() {
>              task.run();
>              return result;
>          }
> +        public String toString() {
> +            return super.toString()
> +                + "[task=[" + task + "], result=[" + result + "]]";
> +        }
>      }
>
>      /**
>       * A callable that runs under established access control settings.
>       */
>      private static final class PrivilegedCallable<T> implements
> Callable<T> {
>          final Callable<T> task;
>          final AccessControlContext acc;
>
>          PrivilegedCallable(Callable<T> task) {
> @@ -504,20 +508,24 @@
>                  return AccessController.doPrivileged(
>                      new PrivilegedExceptionAction<T>() {
>                          public T run() throws Exception {
>                              return task.call();
>                          }
>                      }, acc);
>              } catch (PrivilegedActionException e) {
>                  throw e.getException();
>              }
>          }
> +
> +        public String toString() {
> +            return super.toString() + "[task=[" + task + "]]";
> +        }
>      }
>
>      /**
>       * A callable that runs under established access control settings and
>       * current ClassLoader.
>       */
>      private static final class PrivilegedCallableUsingCurrent
> ClassLoader<T>
>              implements Callable<T> {
>          final Callable<T> task;
>          final AccessControlContext acc;
> @@ -556,20 +564,24 @@
>                                  } finally {
>                                      t.setContextClassLoader(cl);
>                                  }
>                              }
>                          }
>                      }, acc);
>              } catch (PrivilegedActionException e) {
>                  throw e.getException();
>              }
>          }
> +
> +        public String toString() {
> +            return super.toString() + "[task=[" + task + "]]";
> +        }
>      }
>
>      /**
>       * The default thread factory.
>       */
>      private static class DefaultThreadFactory implements ThreadFactory {
>          private static final AtomicInteger poolNumber = new
> AtomicInteger(1);
>          private final ThreadGroup group;
>          private final AtomicInteger threadNumber = new AtomicInteger(1);
>          private final String namePrefix;
> Index: ForkJoinTask.java
> ===================================================================
> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/
> concurrent/ForkJoinTask.java,v
> retrieving revision 1.115
> diff -u -U 10 -r1.115 ForkJoinTask.java
> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
> +++ ForkJoinTask.java 9 Aug 2017 01:34:25 -0000
> @@ -1339,37 +1339,43 @@
>          T result;
>          AdaptedRunnable(Runnable runnable, T result) {
>              if (runnable == null) throw new NullPointerException();
>              this.runnable = runnable;
>              this.result = result; // OK to set this even before completion
>          }
>          public final T getRawResult() { return result; }
>          public final void setRawResult(T v) { result = v; }
>          public final boolean exec() { runnable.run(); return true; }
>          public final void run() { invoke(); }
> +        public String toString() {
> +            return super.toString() + "[task=[" + runnable + "],
> result=[" + result + "]]";
> +        }
>          private static final long serialVersionUID = 5232453952276885070L;
>      }
>
>      /**
>       * Adapter for Runnables without results.
>       */
>      static final class AdaptedRunnableAction extends ForkJoinTask<Void>
>          implements RunnableFuture<Void> {
>          final Runnable runnable;
>          AdaptedRunnableAction(Runnable runnable) {
>              if (runnable == null) throw new NullPointerException();
>              this.runnable = runnable;
>          }
>          public final Void getRawResult() { return null; }
>          public final void setRawResult(Void v) { }
>          public final boolean exec() { runnable.run(); return true; }
>          public final void run() { invoke(); }
> +        public String toString() {
> +            return super.toString() + "[task=[" + runnable + "]]";
> +        }
>          private static final long serialVersionUID = 5232453952276885070L;
>      }
>
>      /**
>       * Adapter for Runnables in which failure forces worker exception.
>       */
>      static final class RunnableExecuteAction extends ForkJoinTask<Void> {
>          final Runnable runnable;
>          RunnableExecuteAction(Runnable runnable) {
>              if (runnable == null) throw new NullPointerException();
> @@ -1402,20 +1408,23 @@
>                  result = callable.call();
>                  return true;
>              } catch (RuntimeException rex) {
>                  throw rex;
>              } catch (Exception ex) {
>                  throw new RuntimeException(ex);
>              }
>          }
>          public final void run() { invoke(); }
>          private static final long serialVersionUID = 2838392045355241008L;
> +        public String toString() {
> +            return super.toString() + "[task=[" + callable + "]]";
> +        }
>      }
>
>      /**
>       * Returns a new {@code ForkJoinTask} that performs the {@code run}
>       * method of the given {@code Runnable} as its action, and returns
>       * a null result upon {@link #join}.
>       *
>       * @param runnable the runnable action
>       * @return the task
>       */
> Index: FutureTask.java
> ===================================================================
> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/
> concurrent/FutureTask.java,v
> retrieving revision 1.118
> diff -u -U 10 -r1.118 FutureTask.java
> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
> +++ FutureTask.java 9 Aug 2017 01:34:25 -0000
> @@ -444,20 +444,49 @@
>                              continue retry;
>                      }
>                      else if (!WAITERS.compareAndSet(this, q, s))
>                          continue retry;
>                  }
>                  break;
>              }
>          }
>      }
>
> +    public String toString() {
> +        String start = super.toString() + "[status=";
> +        try {
> +            switch (state) {
> +            case NEW:
> +            case COMPLETING:
> +                final Callable<?> callable = this.callable;
> +                if (callable != null) {
> +                    return start + "PENDING, task=[" + callable + "]]";
> +                } else {
> +                    return start + "PENDING]";
> +                }
> +            case NORMAL:
> +                return start + "SUCCESS, result=[" + outcome + "]]";
> +            case EXCEPTIONAL:
> +                return start + "FAILURE, cause=[" + outcome + "]]";
> +            case CANCELLED:
> +            case INTERRUPTING:
> +            case INTERRUPTED:
> +                return start + "CANCELLED]";
> +            default:
> +                throw new IllegalStateException();
> +            }
> +        } catch (RuntimeException thrownFromToString) {
> +            return start + "UNKNOWN, cause=["
> +                + thrownFromToString.getClass() + "]";
> +        }
> +    }
> +
>      // VarHandle mechanics
>      private static final VarHandle STATE;
>      private static final VarHandle RUNNER;
>      private static final VarHandle WAITERS;
>      static {
>          try {
>              MethodHandles.Lookup l = MethodHandles.lookup();
>              STATE = l.findVarHandle(FutureTask.class, "state",
> int.class);
>              RUNNER = l.findVarHandle(FutureTask.class, "runner",
> Thread.class);
>              WAITERS = l.findVarHandle(FutureTask.class, "waiters",
> WaitNode.class);
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170808/0ca6ac73/attachment-0001.html>

From akarnokd at gmail.com  Wed Aug  9 04:17:17 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Wed, 9 Aug 2017 10:17:17 +0200
Subject: [concurrency-interest] Does factoring out VarHandle-based
	manipulations cause performance penalties?
Message-ID: <CAAWwtm-tVsrr92cx=6AocHP3F-vzVaouiROhoBAJmMMfCJ_kUg@mail.gmail.com>

In my codebase, targeting Java 9, I often have to perform the same set of
atomic operations on fields of various classes, for example, a deferred
cancellation of Flow.Subscriptions:

Flow.Subscription upstream;
static final VarHandle UPSTREAM;

@Override
public void cancel() {
    Flow.Subscription a = (Flow.Subscription)UPSTREAM.getAcquire(this);
    if (a != CancelledSubscription.INSTANCE) {
        a = (Flow.Subscription)UPSTREAM.getAndSet(this,
CancelledSubscription.INSTANCE);
        if (a != null && a != CancelledSubscription.INSTANCE) {
            a.cancel();
        }
    }
}

Refactored into:

final class SubscriptionHelper {

    public static void cancel(Object target, VarHandle handle) {
        Flow.Subscription a = (Flow.Subscription)handle.getAcquire(target);
        if (a != CancelledSubscription.INSTANCE) {
            a = (Flow.Subscription)handle.getAndSet(target,
CancelledSubscription.INSTANCE);
            if (a != null && a != CancelledSubscription.INSTANCE) {
                a.cancel();
            }
        }
    }
}

@Override
public void cancel() {
    SubscriptionHelper.cancel(this, UPSTREAM);
}


I'd think JIT can and will inline SubscriptionHelper.cancel to all its use
sites, but the fact that the cancel method no longer has "this" but an
arbitrary target Object, my concern is that the optimizations may not
happen.

I haven't noticed any performance penalties so far but I remember Aleksey
Shipilev mentioning somewhere, some time ago, a warning about such
out-of-context VarHandle uses.

-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170809/0f60407f/attachment.html>

From shade at redhat.com  Wed Aug  9 04:25:04 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Wed, 9 Aug 2017 10:25:04 +0200
Subject: [concurrency-interest] Does factoring out VarHandle-based
 manipulations cause performance penalties?
In-Reply-To: <CAAWwtm-tVsrr92cx=6AocHP3F-vzVaouiROhoBAJmMMfCJ_kUg@mail.gmail.com>
References: <CAAWwtm-tVsrr92cx=6AocHP3F-vzVaouiROhoBAJmMMfCJ_kUg@mail.gmail.com>
Message-ID: <398e327a-e508-b415-af14-50f70716e788@redhat.com>

On 08/09/2017 10:17 AM, Dávid Karnok wrote:
> In my codebase, targeting Java 9, I often have to perform the same set of atomic operations on
> fields of various classes, for example, a deferred cancellation of Flow.Subscriptions:
> 
> Flow.Subscription upstream;
> static final VarHandle UPSTREAM;
> 
> @Override
> public void cancel() {
>     Flow.Subscription a = (Flow.Subscription)UPSTREAM.getAcquire(this);
>     if (a != CancelledSubscription.INSTANCE) {
>         a = (Flow.Subscription)UPSTREAM.getAndSet(this, CancelledSubscription.INSTANCE);
>         if (a != null && a != CancelledSubscription.INSTANCE) {
>             a.cancel();
>         }
>     }
> }
> 
> Refactored into:
> 
> final class SubscriptionHelper {
> 
>     public static void cancel(Object target, VarHandle handle) {
>         Flow.Subscription a = (Flow.Subscription)handle.getAcquire(target);
>         if (a != CancelledSubscription.INSTANCE) {
>             a = (Flow.Subscription)handle.getAndSet(target, CancelledSubscription.INSTANCE);
>             if (a != null && a != CancelledSubscription.INSTANCE) {
>                 a.cancel();
>             }
>         }
>     }
> }
> 
> @Override
> public void cancel() {
>     SubscriptionHelper.cancel(this, UPSTREAM);
> }
> 
> 
> I'd think JIT can and will inline SubscriptionHelper.cancel to all its use sites, but the fact that
> the cancel method no longer has "this" but an arbitrary target Object, my concern is that the
> optimizations may not happen.
> 
> I haven't noticed any performance penalties so far but I remember Aleksey Shipilev mentioning
> somewhere, some time ago, a warning about such out-of-context VarHandle uses.

Like with Unsafe, like with Atomic*FieldUpdaters, like with *Handles in general, the compiler's
ability to optimize is dependent on constant propagation. Putting the VarHandle to static final
field helps that a lot, with the same mechanism as putting OFFSET for Unsafe accesses helps
performance.

It your case above, making VarHandle a method parameter is performance-risky move, but it is
mitigated by the use-site that loads it from the static final field anyway. Thus, if method is
inlined, you get the same benefits. The concern for "Object" and "this" is not valid there, I think,
because inlining propagates type information too.

Thanks,
-Aleksey


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170809/60176085/attachment.sig>

From shade at redhat.com  Wed Aug  9 04:30:22 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Wed, 9 Aug 2017 10:30:22 +0200
Subject: [concurrency-interest] Does factoring out VarHandle-based
 manipulations cause performance penalties?
In-Reply-To: <398e327a-e508-b415-af14-50f70716e788@redhat.com>
References: <CAAWwtm-tVsrr92cx=6AocHP3F-vzVaouiROhoBAJmMMfCJ_kUg@mail.gmail.com>
 <398e327a-e508-b415-af14-50f70716e788@redhat.com>
Message-ID: <ceddbe60-fdf9-5f00-7757-f0a63791457d@redhat.com>

On 08/09/2017 10:25 AM, Aleksey Shipilev wrote:
> On 08/09/2017 10:17 AM, Dávid Karnok wrote:
>> In my codebase, targeting Java 9, I often have to perform the same set of atomic operations on
>> fields of various classes, for example, a deferred cancellation of Flow.Subscriptions:
>>
>> Flow.Subscription upstream;
>> static final VarHandle UPSTREAM;
>>
>> @Override
>> public void cancel() {
>>     Flow.Subscription a = (Flow.Subscription)UPSTREAM.getAcquire(this);
>>     if (a != CancelledSubscription.INSTANCE) {
>>         a = (Flow.Subscription)UPSTREAM.getAndSet(this, CancelledSubscription.INSTANCE);
>>         if (a != null && a != CancelledSubscription.INSTANCE) {
>>             a.cancel();
>>         }
>>     }
>> }
>>
>> Refactored into:
>>
>> final class SubscriptionHelper {
>>
>>     public static void cancel(Object target, VarHandle handle) {
>>         Flow.Subscription a = (Flow.Subscription)handle.getAcquire(target);
>>         if (a != CancelledSubscription.INSTANCE) {
>>             a = (Flow.Subscription)handle.getAndSet(target, CancelledSubscription.INSTANCE);
>>             if (a != null && a != CancelledSubscription.INSTANCE) {
>>                 a.cancel();
>>             }
>>         }
>>     }
>> }
>>
>> @Override
>> public void cancel() {
>>     SubscriptionHelper.cancel(this, UPSTREAM);
>> }
>>
>>
>> I'd think JIT can and will inline SubscriptionHelper.cancel to all its use sites, but the fact that
>> the cancel method no longer has "this" but an arbitrary target Object, my concern is that the
>> optimizations may not happen.
>>
>> I haven't noticed any performance penalties so far but I remember Aleksey Shipilev mentioning
>> somewhere, some time ago, a warning about such out-of-context VarHandle uses.
> 
> Like with Unsafe, like with Atomic*FieldUpdaters, like with *Handles in general, the compiler's
> ability to optimize is dependent on constant propagation. Putting the VarHandle to static final
> field helps that a lot, with the same mechanism as putting OFFSET for Unsafe accesses helps
> performance.
> 
> It your case above, making VarHandle a method parameter is performance-risky move, but it is
> mitigated by the use-site that loads it from the static final field anyway. Thus, if method is
> inlined, you get the same benefits. The concern for "Object" and "this" is not valid there, I think,
> because inlining propagates type information too.

I should have mentioned that at least in Hotspot, there is a real problem with type *profile*
pollution, because the type profile is context-agnostic, and bound to the concrete bytecode index.
So if SubscriptionHelper.cancel gets called with different "targets", *and* optimization depends on
profile, the inlining would not help to untangle that knot. Pretty sure the static type propagation
works fine there, but do test.

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170809/ff8f9eff/attachment.sig>

From aph at redhat.com  Wed Aug  9 05:54:00 2017
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Aug 2017 10:54:00 +0100
Subject: [concurrency-interest] Programming language-independent memory
 models
In-Reply-To: <CAPUmR1ZTJ9PKW7CBOfbHRAJrOqj0YvscN65NZB+XbfSJN+OG7Q@mail.gmail.com>
References: <b0be9ec7-74cd-eee3-2778-5f20a550f373@redhat.com>
 <CAPUmR1YaYOFyFA0gvg9s3ntJWLrNf7h9nzXF9P6V5m23W+GU-g@mail.gmail.com>
 <9e4138d5-f1bf-7d31-5adf-c3c0b77f56e7@redhat.com>
 <CAPUmR1ZTJ9PKW7CBOfbHRAJrOqj0YvscN65NZB+XbfSJN+OG7Q@mail.gmail.com>
Message-ID: <9705f449-d2f7-504c-efd9-8fd1d7e6cc5f@redhat.com>

On 08/08/17 20:10, Hans Boehm wrote:
> IMHO, the closest we have that is actually solid and understandable
> is the basic DRF model, with undefined semantics for data races.
> e.g. sections 2+3 from http://dl.acm.org/citation.cfm?id=1375581.1375591 .
> This was never actually that expensive on x86, and it seems to be getting
> more affordable on ARM as well. But my impression is that it'll never fly
> on a GPU.
> 
> We know how to correctly add acquire/release atomics, though that
> mixed model becomes far more complicated and unintuitive.
> 
> But almost everyone seems to feel the need to throw in some kind
> of relaxed atomics or defined behavior for data races, at which point
> things get flaky, and a universal design seems unlikely to me.

Mmm, okay.  I was guessing that might be the situation, and it's very
useful to have it confirmed.  I'm sure that undefined behaviour (in
the unconstrained sense) for data races isn't going to be acceptable
for most programming languages.  The problem is, I suppose, that
specifying exactly what may occur in the presence of data races is
necessarily dependent on the semantics of each programming language.

There are some opportunities for research here.

Thanks.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From aph at redhat.com  Wed Aug  9 05:56:41 2017
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Aug 2017 10:56:41 +0100
Subject: [concurrency-interest] Programming language-independent memory
 models
In-Reply-To: <9705f449-d2f7-504c-efd9-8fd1d7e6cc5f@redhat.com>
References: <b0be9ec7-74cd-eee3-2778-5f20a550f373@redhat.com>
 <CAPUmR1YaYOFyFA0gvg9s3ntJWLrNf7h9nzXF9P6V5m23W+GU-g@mail.gmail.com>
 <9e4138d5-f1bf-7d31-5adf-c3c0b77f56e7@redhat.com>
 <CAPUmR1ZTJ9PKW7CBOfbHRAJrOqj0YvscN65NZB+XbfSJN+OG7Q@mail.gmail.com>
 <9705f449-d2f7-504c-efd9-8fd1d7e6cc5f@redhat.com>
Message-ID: <5eb3d218-d414-98fa-1463-edee536b6fda@redhat.com>

On 09/08/17 10:54, Andrew Haley wrote:
> On 08/08/17 20:10, Hans Boehm wrote:
>> IMHO, the closest we have that is actually solid and understandable
>> is the basic DRF model, with undefined semantics for data races.
>> e.g. sections 2+3 from http://dl.acm.org/citation.cfm?id=1375581.1375591 .

Also at www.hpl.hp.com/techreports/2008/HPL-2008-56.pdf

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From akarnokd at gmail.com  Wed Aug  9 07:20:31 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Wed, 9 Aug 2017 13:20:31 +0200
Subject: [concurrency-interest] Does factoring out VarHandle-based
 manipulations cause performance penalties?
In-Reply-To: <ceddbe60-fdf9-5f00-7757-f0a63791457d@redhat.com>
References: <CAAWwtm-tVsrr92cx=6AocHP3F-vzVaouiROhoBAJmMMfCJ_kUg@mail.gmail.com>
 <398e327a-e508-b415-af14-50f70716e788@redhat.com>
 <ceddbe60-fdf9-5f00-7757-f0a63791457d@redhat.com>
Message-ID: <CAAWwtm-c3K15T4+5qtMYDoVQCm=CZqLfeK4Trc807-0p2TpMZA@mail.gmail.com>

Thanks Aleksey!

I did a benchmark and VarHandles seem to work fine compared to
AtomicReferences (assuming that I measured the right setup):

Benchmark                     Mode  Cnt          Score         Error  Units
VarHandleCostPerf.baseline1  thrpt    5  159276715,278 ± 3571493,763  ops/s
VarHandleCostPerf.bench1     thrpt    5  162339382,232 ±  763533,693  ops/s
VarHandleCostPerf.baseline2  thrpt    5   72675096,238 ± 1262485,061  ops/s
VarHandleCostPerf.bench2     thrpt    5   84963708,660 ±  596244,817  ops/s
VarHandleCostPerf.baseline3  thrpt    5   38747819,413 ± 1513177,407  ops/s
VarHandleCostPerf.bench3     thrpt    5   47328852,938 ±  157493,140  ops/s
VarHandleCostPerf.baseline4  thrpt    5   38047055,938 ±  316562,325  ops/s
VarHandleCostPerf.bench4     thrpt    5   38053864,102 ±  180163,924  ops/s
VarHandleCostPerf.baseline5  thrpt    5   30075092,319 ±  151191,006  ops/s
VarHandleCostPerf.bench5     thrpt    5   29819608,499 ± 1088452,474  ops/s
VarHandleCostPerf.baseline6  thrpt    5   24924283,770 ±  214311,889  ops/s
VarHandleCostPerf.bench6     thrpt    5   24872577,980 ±  390354,651  ops/s
VarHandleCostPerf.baseline7  thrpt    5   21210169,977 ±  282669,696  ops/s
VarHandleCostPerf.bench7     thrpt    5   21083601,549 ±  424591,111  ops/s

Code:
https://gist.github.com/akarnokd/64430b072e7f042a8be8b1e476efb383

Run:
i7 4790, Windows 7 x64, Java 9b181, JMH 1.19

2017-08-09 10:30 GMT+02:00 Aleksey Shipilev <shade at redhat.com>:

> On 08/09/2017 10:25 AM, Aleksey Shipilev wrote:
> > On 08/09/2017 10:17 AM, Dávid Karnok wrote:
> >> In my codebase, targeting Java 9, I often have to perform the same set
> of atomic operations on
> >> fields of various classes, for example, a deferred cancellation of
> Flow.Subscriptions:
> >>
> >> Flow.Subscription upstream;
> >> static final VarHandle UPSTREAM;
> >>
> >> @Override
> >> public void cancel() {
> >>     Flow.Subscription a = (Flow.Subscription)UPSTREAM.getAcquire(this);
> >>     if (a != CancelledSubscription.INSTANCE) {
> >>         a = (Flow.Subscription)UPSTREAM.getAndSet(this,
> CancelledSubscription.INSTANCE);
> >>         if (a != null && a != CancelledSubscription.INSTANCE) {
> >>             a.cancel();
> >>         }
> >>     }
> >> }
> >>
> >> Refactored into:
> >>
> >> final class SubscriptionHelper {
> >>
> >>     public static void cancel(Object target, VarHandle handle) {
> >>         Flow.Subscription a = (Flow.Subscription)handle.
> getAcquire(target);
> >>         if (a != CancelledSubscription.INSTANCE) {
> >>             a = (Flow.Subscription)handle.getAndSet(target,
> CancelledSubscription.INSTANCE);
> >>             if (a != null && a != CancelledSubscription.INSTANCE) {
> >>                 a.cancel();
> >>             }
> >>         }
> >>     }
> >> }
> >>
> >> @Override
> >> public void cancel() {
> >>     SubscriptionHelper.cancel(this, UPSTREAM);
> >> }
> >>
> >>
> >> I'd think JIT can and will inline SubscriptionHelper.cancel to all its
> use sites, but the fact that
> >> the cancel method no longer has "this" but an arbitrary target Object,
> my concern is that the
> >> optimizations may not happen.
> >>
> >> I haven't noticed any performance penalties so far but I remember
> Aleksey Shipilev mentioning
> >> somewhere, some time ago, a warning about such out-of-context VarHandle
> uses.
> >
> > Like with Unsafe, like with Atomic*FieldUpdaters, like with *Handles in
> general, the compiler's
> > ability to optimize is dependent on constant propagation. Putting the
> VarHandle to static final
> > field helps that a lot, with the same mechanism as putting OFFSET for
> Unsafe accesses helps
> > performance.
> >
> > It your case above, making VarHandle a method parameter is
> performance-risky move, but it is
> > mitigated by the use-site that loads it from the static final field
> anyway. Thus, if method is
> > inlined, you get the same benefits. The concern for "Object" and "this"
> is not valid there, I think,
> > because inlining propagates type information too.
>
> I should have mentioned that at least in Hotspot, there is a real problem
> with type *profile*
> pollution, because the type profile is context-agnostic, and bound to the
> concrete bytecode index.
> So if SubscriptionHelper.cancel gets called with different "targets",
> *and* optimization depends on
> profile, the inlining would not help to untangle that knot. Pretty sure
> the static type propagation
> works fine there, but do test.
>
> Thanks,
> -Aleksey
>
>


-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170809/8aa7f780/attachment.html>

From shade at redhat.com  Wed Aug  9 07:34:52 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Wed, 9 Aug 2017 13:34:52 +0200
Subject: [concurrency-interest] Does factoring out VarHandle-based
 manipulations cause performance penalties?
In-Reply-To: <CAAWwtm-c3K15T4+5qtMYDoVQCm=CZqLfeK4Trc807-0p2TpMZA@mail.gmail.com>
References: <CAAWwtm-tVsrr92cx=6AocHP3F-vzVaouiROhoBAJmMMfCJ_kUg@mail.gmail.com>
 <398e327a-e508-b415-af14-50f70716e788@redhat.com>
 <ceddbe60-fdf9-5f00-7757-f0a63791457d@redhat.com>
 <CAAWwtm-c3K15T4+5qtMYDoVQCm=CZqLfeK4Trc807-0p2TpMZA@mail.gmail.com>
Message-ID: <33012f39-06e0-5e1c-8ba0-b352925eb11f@redhat.com>

On 08/09/2017 01:20 PM, Dávid Karnok wrote:
> Thanks Aleksey!
> 
> I did a benchmark and VarHandles seem to work fine compared to AtomicReferences (assuming that I
> measured the right setup):
> 
> Benchmark                     Mode  Cnt          Score         Error  Units
> VarHandleCostPerf.baseline1  thrpt    5  159276715,278 ± 3571493,763  ops/s
> VarHandleCostPerf.bench1     thrpt    5  162339382,232 ±  763533,693  ops/s

> VarHandleCostPerf.baseline2  thrpt    5   72675096,238 ± 1262485,061  ops/s
> VarHandleCostPerf.bench2     thrpt    5   84963708,660 ±  596244,817  ops/s

> VarHandleCostPerf.baseline3  thrpt    5   38747819,413 ± 1513177,407  ops/s
> VarHandleCostPerf.bench3     thrpt    5   47328852,938 ±  157493,140  ops/s

> VarHandleCostPerf.baseline4  thrpt    5   38047055,938 ±  316562,325  ops/s
> VarHandleCostPerf.bench4     thrpt    5   38053864,102 ±  180163,924  ops/s

> VarHandleCostPerf.baseline5  thrpt    5   30075092,319 ±  151191,006  ops/s
> VarHandleCostPerf.bench5     thrpt    5   29819608,499 ± 1088452,474  ops/s

> VarHandleCostPerf.baseline6  thrpt    5   24924283,770 ±  214311,889  ops/s
> VarHandleCostPerf.bench6     thrpt    5   24872577,980 ±  390354,651  ops/s

> VarHandleCostPerf.baseline7  thrpt    5   21210169,977 ±  282669,696  ops/s
> VarHandleCostPerf.bench7     thrpt    5   21083601,549 ±  424591,111  ops/s

Pro-tip: measuring this in AverageTime with ns/op is much more readable.

It seems *2 and *3 wins for VarHandles, I wonder why is that. I guess that is because the
AtomicReference instances you have in the tests are actually different classes ("{  }" yields the
anonymous subclass), which explains this somewhat.

AtomicReferences also keep the value one dereference away, but your test would not show that, given
very low cache footprint. AtomicReferenceFieldUpdater seems to be the better baseline, or whatever
you use right now in Rx*?

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170809/8c0f3ec3/attachment.sig>

From akarnokd at gmail.com  Wed Aug  9 07:48:30 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Wed, 9 Aug 2017 13:48:30 +0200
Subject: [concurrency-interest] Does factoring out VarHandle-based
 manipulations cause performance penalties?
In-Reply-To: <33012f39-06e0-5e1c-8ba0-b352925eb11f@redhat.com>
References: <CAAWwtm-tVsrr92cx=6AocHP3F-vzVaouiROhoBAJmMMfCJ_kUg@mail.gmail.com>
 <398e327a-e508-b415-af14-50f70716e788@redhat.com>
 <ceddbe60-fdf9-5f00-7757-f0a63791457d@redhat.com>
 <CAAWwtm-c3K15T4+5qtMYDoVQCm=CZqLfeK4Trc807-0p2TpMZA@mail.gmail.com>
 <33012f39-06e0-5e1c-8ba0-b352925eb11f@redhat.com>
Message-ID: <CAAWwtm98Y7qb77-f-CnRyj6zBV3vfFoFGB3mfZmc3Mst1W2J2g@mail.gmail.com>

Indeed, the { } are deliberate to simulate different subclasses that build
upon AtomicReference. RxJava v1..3 use Atomic* classes (limit by Java 6 &
Android) and RxJava 4 (I'm experimenting with) will use VarHandles.

2017-08-09 13:34 GMT+02:00 Aleksey Shipilev <shade at redhat.com>:

> On 08/09/2017 01:20 PM, Dávid Karnok wrote:
> > Thanks Aleksey!
> >
> > I did a benchmark and VarHandles seem to work fine compared to
> AtomicReferences (assuming that I
> > measured the right setup):
> >
> > Benchmark                     Mode  Cnt          Score         Error
> Units
> > VarHandleCostPerf.baseline1  thrpt    5 159276715,278 ± 3571493,763
> ops/s
> > VarHandleCostPerf.bench1     thrpt    5 162339382,232 ±  763533,693
> ops/s
>
> > VarHandleCostPerf.baseline2  thrpt    5   72675096,238 ± 1262485,061
> ops/s
> > VarHandleCostPerf.bench2     thrpt    5   84963708,660 ±  596244,817
> ops/s
>
> > VarHandleCostPerf.baseline3  thrpt    5   38747819,413 ± 1513177,407
> ops/s
> > VarHandleCostPerf.bench3     thrpt    5   47328852,938 ±  157493,140
> ops/s
>
> > VarHandleCostPerf.baseline4  thrpt    5   38047055,938 ±  316562,325
> ops/s
> > VarHandleCostPerf.bench4     thrpt    5   38053864,102 ±  180163,924
> ops/s
>
> > VarHandleCostPerf.baseline5  thrpt    5   30075092,319 ±  151191,006
> ops/s
> > VarHandleCostPerf.bench5     thrpt    5   29819608,499 ± 1088452,474
> ops/s
>
> > VarHandleCostPerf.baseline6  thrpt    5   24924283,770 ±  214311,889
> ops/s
> > VarHandleCostPerf.bench6     thrpt    5   24872577,980 ±  390354,651
> ops/s
>
> > VarHandleCostPerf.baseline7  thrpt    5   21210169,977 ±  282669,696
> ops/s
> > VarHandleCostPerf.bench7     thrpt    5   21083601,549 ±  424591,111
> ops/s
>
> Pro-tip: measuring this in AverageTime with ns/op is much more readable.
>
> It seems *2 and *3 wins for VarHandles, I wonder why is that. I guess that
> is because the
> AtomicReference instances you have in the tests are actually different
> classes ("{  }" yields the
> anonymous subclass), which explains this somewhat.
>
> AtomicReferences also keep the value one dereference away, but your test
> would not show that, given
> very low cache footprint. AtomicReferenceFieldUpdater seems to be the
> better baseline, or whatever
> you use right now in Rx*?
>
> Thanks,
> -Aleksey
>
>


-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170809/3e384535/attachment-0001.html>

From joe.bowbeer at gmail.com  Wed Aug  9 13:10:32 2017
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 09 Aug 2017 17:10:32 +0000
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CAHktk4g6XaP--9QTn5BORDqD43Th3ag0XtJsbe+fQhtPoKCLxw@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
 <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
 <CAHktk4g6XaP--9QTn5BORDqD43Th3ag0XtJsbe+fQhtPoKCLxw@mail.gmail.com>
Message-ID: <CAHzJPEpgWQR8wyarTj_thU9tSEqz8cpoMtFqmK+Q+WD0XoATMA@mail.gmail.com>

RunnableAdapter is an interesting case. I'd have most of the same concerns
as before, to a slightly less extent. This would not be an API change,
however.

The style adopted by Java so far has been that j.u.c. objects don't by
default reveal their internal state. It has been up to devs to opt in,
based on their particular needs, and some devs rightly or wrongly rely on
the format inherited from Object.

If Guava or other libraries want to enhance this, that can be their value
added.

By the way, adding to my previous list of concerns, I'd also be concerned
about leaking PI in log messages. This is related to my concern about the
wrapped toString impl. being designed for use in a different context.

On Wed, Aug 9, 2017 at 9:19 AM Charles Munger <clm at google.com> wrote:

> I added similar toString implementations to guava's Future implementations:
>
> https://github.com/google/guava/commit/304c634d977127085b49f174fd1aafefd09b2bf5
>
> The attraction of toString on common Future implementations is that
> propagating toString throughout a graph of transformed Futures lets you see
> what a task is doing before it completes, either in a TimeoutException
> message or the toString of LockSupport.getBlocker.
>
> Do you feel that adding toString to RunnableAdapter (and similar classes,
> that are only exposed in public API as interfaces) would also constitute an
> API change?
>
> On Tue, Aug 8, 2017 at 6:58 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
>
>> ​I would consider this to be an API change. For example, according to the
>> current javadoc, FutureTask's toString method is inherited from Object.
>>
>> Practically speaking, I'd be concerned about unexpected and unwanted
>> changes to the output/log statements of programs that have up until now
>> been working fine. In addition to generating a lot of output that may be
>> unwanted, this may also generate exceptions. For example,
>> PrivilegedCallable.toString calls the toString method of the wrapped
>> Callable, which may never have been called previously (bam!), and therefore
>> might throw an exception. Or, the toString method of the wrapped callable
>> may have been designed to be called in a different context.
>>
>> If any of the state the toString implementations are accessing is not
>> thread-safe, I'd also be concerned about that.
>>
>> If tasks need toString implementations, I prefer to write them.​
>>
>> However, I think it would be OK to introduce new convenience methods:
>> debugString()
>>
>> On Tue, Aug 8, 2017 at 6:36 PM, Martin Buchholz <martinrb at google.com>
>> wrote:
>>
>>> My colleague Charles Munger suggests adding toString methods to various
>>> task classes in j.u.c.  Obviously this makes it easier to debug large
>>> programs that have gone wrong.  But it obviously also is a behavior change
>>> that has the potential for trouble, even when everyone is behaving nicely,
>>> since toString may have the effect of generating an unbounded output.  I
>>> almost started down this road myself a few years ago but chickened out.
>>> What do you think?
>>>
>>> Index: Executors.java
>>> ===================================================================
>>> RCS file:
>>> /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/Executors.java,v
>>> retrieving revision 1.97
>>> diff -u -U 10 -r1.97 Executors.java
>>> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
>>> +++ Executors.java 9 Aug 2017 01:34:25 -0000
>>> @@ -478,20 +478,24 @@
>>>          private final Runnable task;
>>>          private final T result;
>>>          RunnableAdapter(Runnable task, T result) {
>>>              this.task = task;
>>>              this.result = result;
>>>          }
>>>          public T call() {
>>>              task.run();
>>>              return result;
>>>          }
>>> +        public String toString() {
>>> +            return super.toString()
>>> +                + "[task=[" + task + "], result=[" + result + "]]";
>>> +        }
>>>      }
>>>
>>>      /**
>>>       * A callable that runs under established access control settings.
>>>       */
>>>      private static final class PrivilegedCallable<T> implements
>>> Callable<T> {
>>>          final Callable<T> task;
>>>          final AccessControlContext acc;
>>>
>>>          PrivilegedCallable(Callable<T> task) {
>>> @@ -504,20 +508,24 @@
>>>                  return AccessController.doPrivileged(
>>>                      new PrivilegedExceptionAction<T>() {
>>>                          public T run() throws Exception {
>>>                              return task.call();
>>>                          }
>>>                      }, acc);
>>>              } catch (PrivilegedActionException e) {
>>>                  throw e.getException();
>>>              }
>>>          }
>>> +
>>> +        public String toString() {
>>> +            return super.toString() + "[task=[" + task + "]]";
>>> +        }
>>>      }
>>>
>>>      /**
>>>       * A callable that runs under established access control settings
>>> and
>>>       * current ClassLoader.
>>>       */
>>>      private static final class
>>> PrivilegedCallableUsingCurrentClassLoader<T>
>>>              implements Callable<T> {
>>>          final Callable<T> task;
>>>          final AccessControlContext acc;
>>> @@ -556,20 +564,24 @@
>>>                                  } finally {
>>>                                      t.setContextClassLoader(cl);
>>>                                  }
>>>                              }
>>>                          }
>>>                      }, acc);
>>>              } catch (PrivilegedActionException e) {
>>>                  throw e.getException();
>>>              }
>>>          }
>>> +
>>> +        public String toString() {
>>> +            return super.toString() + "[task=[" + task + "]]";
>>> +        }
>>>      }
>>>
>>>      /**
>>>       * The default thread factory.
>>>       */
>>>      private static class DefaultThreadFactory implements ThreadFactory {
>>>          private static final AtomicInteger poolNumber = new
>>> AtomicInteger(1);
>>>          private final ThreadGroup group;
>>>          private final AtomicInteger threadNumber = new AtomicInteger(1);
>>>          private final String namePrefix;
>>> Index: ForkJoinTask.java
>>> ===================================================================
>>> RCS file:
>>> /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/ForkJoinTask.java,v
>>> retrieving revision 1.115
>>> diff -u -U 10 -r1.115 ForkJoinTask.java
>>> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
>>> +++ ForkJoinTask.java 9 Aug 2017 01:34:25 -0000
>>> @@ -1339,37 +1339,43 @@
>>>          T result;
>>>          AdaptedRunnable(Runnable runnable, T result) {
>>>              if (runnable == null) throw new NullPointerException();
>>>              this.runnable = runnable;
>>>              this.result = result; // OK to set this even before
>>> completion
>>>          }
>>>          public final T getRawResult() { return result; }
>>>          public final void setRawResult(T v) { result = v; }
>>>          public final boolean exec() { runnable.run(); return true; }
>>>          public final void run() { invoke(); }
>>> +        public String toString() {
>>> +            return super.toString() + "[task=[" + runnable + "],
>>> result=[" + result + "]]";
>>> +        }
>>>          private static final long serialVersionUID =
>>> 5232453952276885070L;
>>>      }
>>>
>>>      /**
>>>       * Adapter for Runnables without results.
>>>       */
>>>      static final class AdaptedRunnableAction extends ForkJoinTask<Void>
>>>          implements RunnableFuture<Void> {
>>>          final Runnable runnable;
>>>          AdaptedRunnableAction(Runnable runnable) {
>>>              if (runnable == null) throw new NullPointerException();
>>>              this.runnable = runnable;
>>>          }
>>>          public final Void getRawResult() { return null; }
>>>          public final void setRawResult(Void v) { }
>>>          public final boolean exec() { runnable.run(); return true; }
>>>          public final void run() { invoke(); }
>>> +        public String toString() {
>>> +            return super.toString() + "[task=[" + runnable + "]]";
>>> +        }
>>>          private static final long serialVersionUID =
>>> 5232453952276885070L;
>>>      }
>>>
>>>      /**
>>>       * Adapter for Runnables in which failure forces worker exception.
>>>       */
>>>      static final class RunnableExecuteAction extends ForkJoinTask<Void>
>>> {
>>>          final Runnable runnable;
>>>          RunnableExecuteAction(Runnable runnable) {
>>>              if (runnable == null) throw new NullPointerException();
>>> @@ -1402,20 +1408,23 @@
>>>                  result = callable.call();
>>>                  return true;
>>>              } catch (RuntimeException rex) {
>>>                  throw rex;
>>>              } catch (Exception ex) {
>>>                  throw new RuntimeException(ex);
>>>              }
>>>          }
>>>          public final void run() { invoke(); }
>>>          private static final long serialVersionUID =
>>> 2838392045355241008L;
>>> +        public String toString() {
>>> +            return super.toString() + "[task=[" + callable + "]]";
>>> +        }
>>>      }
>>>
>>>      /**
>>>       * Returns a new {@code ForkJoinTask} that performs the {@code run}
>>>       * method of the given {@code Runnable} as its action, and returns
>>>       * a null result upon {@link #join}.
>>>       *
>>>       * @param runnable the runnable action
>>>       * @return the task
>>>       */
>>> Index: FutureTask.java
>>> ===================================================================
>>> RCS file:
>>> /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/FutureTask.java,v
>>> retrieving revision 1.118
>>> diff -u -U 10 -r1.118 FutureTask.java
>>> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
>>> +++ FutureTask.java 9 Aug 2017 01:34:25 -0000
>>> @@ -444,20 +444,49 @@
>>>                              continue retry;
>>>                      }
>>>                      else if (!WAITERS.compareAndSet(this, q, s))
>>>                          continue retry;
>>>                  }
>>>                  break;
>>>              }
>>>          }
>>>      }
>>>
>>> +    public String toString() {
>>> +        String start = super.toString() + "[status=";
>>> +        try {
>>> +            switch (state) {
>>> +            case NEW:
>>> +            case COMPLETING:
>>> +                final Callable<?> callable = this.callable;
>>> +                if (callable != null) {
>>> +                    return start + "PENDING, task=[" + callable + "]]";
>>> +                } else {
>>> +                    return start + "PENDING]";
>>> +                }
>>> +            case NORMAL:
>>> +                return start + "SUCCESS, result=[" + outcome + "]]";
>>> +            case EXCEPTIONAL:
>>> +                return start + "FAILURE, cause=[" + outcome + "]]";
>>> +            case CANCELLED:
>>> +            case INTERRUPTING:
>>> +            case INTERRUPTED:
>>> +                return start + "CANCELLED]";
>>> +            default:
>>> +                throw new IllegalStateException();
>>> +            }
>>> +        } catch (RuntimeException thrownFromToString) {
>>> +            return start + "UNKNOWN, cause=["
>>> +                + thrownFromToString.getClass() + "]";
>>> +        }
>>> +    }
>>> +
>>>      // VarHandle mechanics
>>>      private static final VarHandle STATE;
>>>      private static final VarHandle RUNNER;
>>>      private static final VarHandle WAITERS;
>>>      static {
>>>          try {
>>>              MethodHandles.Lookup l = MethodHandles.lookup();
>>>              STATE = l.findVarHandle(FutureTask.class, "state",
>>> int.class);
>>>              RUNNER = l.findVarHandle(FutureTask.class, "runner",
>>> Thread.class);
>>>              WAITERS = l.findVarHandle(FutureTask.class, "waiters",
>>> WaitNode.class);
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170809/7f1146e3/attachment-0001.html>

From ben.manes at gmail.com  Wed Aug  9 13:29:54 2017
From: ben.manes at gmail.com (Benjamin Manes)
Date: Wed, 9 Aug 2017 10:29:54 -0700
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CAHzJPEpgWQR8wyarTj_thU9tSEqz8cpoMtFqmK+Q+WD0XoATMA@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
 <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
 <CAHktk4g6XaP--9QTn5BORDqD43Th3ag0XtJsbe+fQhtPoKCLxw@mail.gmail.com>
 <CAHzJPEpgWQR8wyarTj_thU9tSEqz8cpoMtFqmK+Q+WD0XoATMA@mail.gmail.com>
Message-ID: <CAGu0=MOeVhowQ9kFgoVRiukmzBpinVZa5AOFcsxUiCkSTDe_JA@mail.gmail.com>

I would be comfortable with a toString() showing the task's class and other
high level state of owned fields, but not if calling foreign code like the
value's toString(). However, I can't think of a case where this would have
significantly helpful when debugging, so I am neutral between minimal or no
changes.

On Wed, Aug 9, 2017 at 10:10 AM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> RunnableAdapter is an interesting case. I'd have most of the same concerns
> as before, to a slightly less extent. This would not be an API change,
> however.
>
> The style adopted by Java so far has been that j.u.c. objects don't by
> default reveal their internal state. It has been up to devs to opt in,
> based on their particular needs, and some devs rightly or wrongly rely on
> the format inherited from Object.
>
> If Guava or other libraries want to enhance this, that can be their value
> added.
>
> By the way, adding to my previous list of concerns, I'd also be concerned
> about leaking PI in log messages. This is related to my concern about the
> wrapped toString impl. being designed for use in a different context.
>
> On Wed, Aug 9, 2017 at 9:19 AM Charles Munger <clm at google.com> wrote:
>
>> I added similar toString implementations to guava's Future
>> implementations:
>> https://github.com/google/guava/commit/304c634d977127085b49f174fd1aaf
>> efd09b2bf5
>>
>> The attraction of toString on common Future implementations is that
>> propagating toString throughout a graph of transformed Futures lets you see
>> what a task is doing before it completes, either in a TimeoutException
>> message or the toString of LockSupport.getBlocker.
>>
>> Do you feel that adding toString to RunnableAdapter (and similar classes,
>> that are only exposed in public API as interfaces) would also constitute an
>> API change?
>>
>> On Tue, Aug 8, 2017 at 6:58 PM, Joe Bowbeer <joe.bowbeer at gmail.com>
>> wrote:
>>
>>> ​I would consider this to be an API change. For example, according to
>>> the current javadoc, FutureTask's toString method is inherited from Object.
>>>
>>> Practically speaking, I'd be concerned about unexpected and unwanted
>>> changes to the output/log statements of programs that have up until now
>>> been working fine. In addition to generating a lot of output that may be
>>> unwanted, this may also generate exceptions. For example,
>>> PrivilegedCallable.toString calls the toString method of the wrapped
>>> Callable, which may never have been called previously (bam!), and therefore
>>> might throw an exception. Or, the toString method of the wrapped callable
>>> may have been designed to be called in a different context.
>>>
>>> If any of the state the toString implementations are accessing is not
>>> thread-safe, I'd also be concerned about that.
>>>
>>> If tasks need toString implementations, I prefer to write them.​
>>>
>>> However, I think it would be OK to introduce new convenience methods:
>>> debugString()
>>>
>>> On Tue, Aug 8, 2017 at 6:36 PM, Martin Buchholz <martinrb at google.com>
>>> wrote:
>>>
>>>> My colleague Charles Munger suggests adding toString methods to various
>>>> task classes in j.u.c.  Obviously this makes it easier to debug large
>>>> programs that have gone wrong.  But it obviously also is a behavior change
>>>> that has the potential for trouble, even when everyone is behaving nicely,
>>>> since toString may have the effect of generating an unbounded output.  I
>>>> almost started down this road myself a few years ago but chickened out.
>>>> What do you think?
>>>>
>>>> Index: Executors.java
>>>> ===================================================================
>>>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/
>>>> concurrent/Executors.java,v
>>>> retrieving revision 1.97
>>>> diff -u -U 10 -r1.97 Executors.java
>>>> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
>>>> +++ Executors.java 9 Aug 2017 01:34:25 -0000
>>>> @@ -478,20 +478,24 @@
>>>>          private final Runnable task;
>>>>          private final T result;
>>>>          RunnableAdapter(Runnable task, T result) {
>>>>              this.task = task;
>>>>              this.result = result;
>>>>          }
>>>>          public T call() {
>>>>              task.run();
>>>>              return result;
>>>>          }
>>>> +        public String toString() {
>>>> +            return super.toString()
>>>> +                + "[task=[" + task + "], result=[" + result + "]]";
>>>> +        }
>>>>      }
>>>>
>>>>      /**
>>>>       * A callable that runs under established access control settings.
>>>>       */
>>>>      private static final class PrivilegedCallable<T> implements
>>>> Callable<T> {
>>>>          final Callable<T> task;
>>>>          final AccessControlContext acc;
>>>>
>>>>          PrivilegedCallable(Callable<T> task) {
>>>> @@ -504,20 +508,24 @@
>>>>                  return AccessController.doPrivileged(
>>>>                      new PrivilegedExceptionAction<T>() {
>>>>                          public T run() throws Exception {
>>>>                              return task.call();
>>>>                          }
>>>>                      }, acc);
>>>>              } catch (PrivilegedActionException e) {
>>>>                  throw e.getException();
>>>>              }
>>>>          }
>>>> +
>>>> +        public String toString() {
>>>> +            return super.toString() + "[task=[" + task + "]]";
>>>> +        }
>>>>      }
>>>>
>>>>      /**
>>>>       * A callable that runs under established access control settings
>>>> and
>>>>       * current ClassLoader.
>>>>       */
>>>>      private static final class PrivilegedCallableUsingCurrent
>>>> ClassLoader<T>
>>>>              implements Callable<T> {
>>>>          final Callable<T> task;
>>>>          final AccessControlContext acc;
>>>> @@ -556,20 +564,24 @@
>>>>                                  } finally {
>>>>                                      t.setContextClassLoader(cl);
>>>>                                  }
>>>>                              }
>>>>                          }
>>>>                      }, acc);
>>>>              } catch (PrivilegedActionException e) {
>>>>                  throw e.getException();
>>>>              }
>>>>          }
>>>> +
>>>> +        public String toString() {
>>>> +            return super.toString() + "[task=[" + task + "]]";
>>>> +        }
>>>>      }
>>>>
>>>>      /**
>>>>       * The default thread factory.
>>>>       */
>>>>      private static class DefaultThreadFactory implements ThreadFactory
>>>> {
>>>>          private static final AtomicInteger poolNumber = new
>>>> AtomicInteger(1);
>>>>          private final ThreadGroup group;
>>>>          private final AtomicInteger threadNumber = new
>>>> AtomicInteger(1);
>>>>          private final String namePrefix;
>>>> Index: ForkJoinTask.java
>>>> ===================================================================
>>>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/
>>>> concurrent/ForkJoinTask.java,v
>>>> retrieving revision 1.115
>>>> diff -u -U 10 -r1.115 ForkJoinTask.java
>>>> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
>>>> +++ ForkJoinTask.java 9 Aug 2017 01:34:25 -0000
>>>> @@ -1339,37 +1339,43 @@
>>>>          T result;
>>>>          AdaptedRunnable(Runnable runnable, T result) {
>>>>              if (runnable == null) throw new NullPointerException();
>>>>              this.runnable = runnable;
>>>>              this.result = result; // OK to set this even before
>>>> completion
>>>>          }
>>>>          public final T getRawResult() { return result; }
>>>>          public final void setRawResult(T v) { result = v; }
>>>>          public final boolean exec() { runnable.run(); return true; }
>>>>          public final void run() { invoke(); }
>>>> +        public String toString() {
>>>> +            return super.toString() + "[task=[" + runnable + "],
>>>> result=[" + result + "]]";
>>>> +        }
>>>>          private static final long serialVersionUID =
>>>> 5232453952276885070L;
>>>>      }
>>>>
>>>>      /**
>>>>       * Adapter for Runnables without results.
>>>>       */
>>>>      static final class AdaptedRunnableAction extends ForkJoinTask<Void>
>>>>          implements RunnableFuture<Void> {
>>>>          final Runnable runnable;
>>>>          AdaptedRunnableAction(Runnable runnable) {
>>>>              if (runnable == null) throw new NullPointerException();
>>>>              this.runnable = runnable;
>>>>          }
>>>>          public final Void getRawResult() { return null; }
>>>>          public final void setRawResult(Void v) { }
>>>>          public final boolean exec() { runnable.run(); return true; }
>>>>          public final void run() { invoke(); }
>>>> +        public String toString() {
>>>> +            return super.toString() + "[task=[" + runnable + "]]";
>>>> +        }
>>>>          private static final long serialVersionUID =
>>>> 5232453952276885070L;
>>>>      }
>>>>
>>>>      /**
>>>>       * Adapter for Runnables in which failure forces worker exception.
>>>>       */
>>>>      static final class RunnableExecuteAction extends
>>>> ForkJoinTask<Void> {
>>>>          final Runnable runnable;
>>>>          RunnableExecuteAction(Runnable runnable) {
>>>>              if (runnable == null) throw new NullPointerException();
>>>> @@ -1402,20 +1408,23 @@
>>>>                  result = callable.call();
>>>>                  return true;
>>>>              } catch (RuntimeException rex) {
>>>>                  throw rex;
>>>>              } catch (Exception ex) {
>>>>                  throw new RuntimeException(ex);
>>>>              }
>>>>          }
>>>>          public final void run() { invoke(); }
>>>>          private static final long serialVersionUID =
>>>> 2838392045355241008L;
>>>> +        public String toString() {
>>>> +            return super.toString() + "[task=[" + callable + "]]";
>>>> +        }
>>>>      }
>>>>
>>>>      /**
>>>>       * Returns a new {@code ForkJoinTask} that performs the {@code run}
>>>>       * method of the given {@code Runnable} as its action, and returns
>>>>       * a null result upon {@link #join}.
>>>>       *
>>>>       * @param runnable the runnable action
>>>>       * @return the task
>>>>       */
>>>> Index: FutureTask.java
>>>> ===================================================================
>>>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/
>>>> concurrent/FutureTask.java,v
>>>> retrieving revision 1.118
>>>> diff -u -U 10 -r1.118 FutureTask.java
>>>> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
>>>> +++ FutureTask.java 9 Aug 2017 01:34:25 -0000
>>>> @@ -444,20 +444,49 @@
>>>>                              continue retry;
>>>>                      }
>>>>                      else if (!WAITERS.compareAndSet(this, q, s))
>>>>                          continue retry;
>>>>                  }
>>>>                  break;
>>>>              }
>>>>          }
>>>>      }
>>>>
>>>> +    public String toString() {
>>>> +        String start = super.toString() + "[status=";
>>>> +        try {
>>>> +            switch (state) {
>>>> +            case NEW:
>>>> +            case COMPLETING:
>>>> +                final Callable<?> callable = this.callable;
>>>> +                if (callable != null) {
>>>> +                    return start + "PENDING, task=[" + callable + "]]";
>>>> +                } else {
>>>> +                    return start + "PENDING]";
>>>> +                }
>>>> +            case NORMAL:
>>>> +                return start + "SUCCESS, result=[" + outcome + "]]";
>>>> +            case EXCEPTIONAL:
>>>> +                return start + "FAILURE, cause=[" + outcome + "]]";
>>>> +            case CANCELLED:
>>>> +            case INTERRUPTING:
>>>> +            case INTERRUPTED:
>>>> +                return start + "CANCELLED]";
>>>> +            default:
>>>> +                throw new IllegalStateException();
>>>> +            }
>>>> +        } catch (RuntimeException thrownFromToString) {
>>>> +            return start + "UNKNOWN, cause=["
>>>> +                + thrownFromToString.getClass() + "]";
>>>> +        }
>>>> +    }
>>>> +
>>>>      // VarHandle mechanics
>>>>      private static final VarHandle STATE;
>>>>      private static final VarHandle RUNNER;
>>>>      private static final VarHandle WAITERS;
>>>>      static {
>>>>          try {
>>>>              MethodHandles.Lookup l = MethodHandles.lookup();
>>>>              STATE = l.findVarHandle(FutureTask.class, "state",
>>>> int.class);
>>>>              RUNNER = l.findVarHandle(FutureTask.class, "runner",
>>>> Thread.class);
>>>>              WAITERS = l.findVarHandle(FutureTask.class, "waiters",
>>>> WaitNode.class);
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170809/11f999a3/attachment-0001.html>

From paul.sandoz at oracle.com  Wed Aug  9 13:31:33 2017
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Wed, 9 Aug 2017 10:31:33 -0700
Subject: [concurrency-interest] Does factoring out VarHandle-based
	manipulations cause performance penalties?
In-Reply-To: <ceddbe60-fdf9-5f00-7757-f0a63791457d@redhat.com>
References: <CAAWwtm-tVsrr92cx=6AocHP3F-vzVaouiROhoBAJmMMfCJ_kUg@mail.gmail.com>
 <398e327a-e508-b415-af14-50f70716e788@redhat.com>
 <ceddbe60-fdf9-5f00-7757-f0a63791457d@redhat.com>
Message-ID: <CCE25931-E477-4455-8710-295AB1E736DF@oracle.com>


> On 9 Aug 2017, at 01:30, Aleksey Shipilev <shade at redhat.com> wrote:
>> 
>> Like with Unsafe, like with Atomic*FieldUpdaters, like with *Handles in general, the compiler's
>> ability to optimize is dependent on constant propagation. Putting the VarHandle to static final
>> field helps that a lot, with the same mechanism as putting OFFSET for Unsafe accesses helps
>> performance.
>> 
>> It your case above, making VarHandle a method parameter is performance-risky move, but it is
>> mitigated by the use-site that loads it from the static final field anyway. Thus, if method is
>> inlined, you get the same benefits. The concern for "Object" and "this" is not valid there, I think,
>> because inlining propagates type information too.
> 
> I should have mentioned that at least in Hotspot, there is a real problem with type *profile*
> pollution, because the type profile is context-agnostic, and bound to the concrete bytecode index.
> So if SubscriptionHelper.cancel gets called with different "targets", *and* optimization depends on
> profile, the inlining would not help to untangle that knot. Pretty sure the static type propagation
> works fine there, but do test.
> 

I am a little fuzzy on the details of type profile pollution but… in this use-case the target Object and the VarHandle are intimately related, the target will be upcast to Object by the common method then downcast by the VH, so as long as the JIT can track that, it should fold away the downcast when inlining.

Great to see VarHandles working out here. This adds weight to the decision to use MethodHandle.invoke semantics rather than the more restrictive MethodHandle.invokeExact semantics, the latter of which makes such reuse harder.

Paul.

> Thanks,
> -Aleksey
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 841 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170809/d8ff8928/attachment.sig>

From martinrb at google.com  Wed Aug  9 14:20:26 2017
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 9 Aug 2017 11:20:26 -0700
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
 <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
Message-ID: <CA+kOe0-3uE0Makz=rd4-ysBUmbQHn89fWn+OD2TOiX8F48F23g@mail.gmail.com>

Josh says, """Item 10: Always override toString"""

toString says """“a concise but informative representation that is easy for
a person to read”""

which also suggests we don't allow unbounded recursion calling toString of
result objects.

I don't think it's a spec change.  Yes, readers of the javadoc can see that
e.g. FutureTask does not currently override Object.toString(), but I don't
think that's a promise to not do so in a future release.  Tightening the
spec of public classes might push existing subclasses out of compliance, so
maybe use @implSpec.

There does not seem to be a common idiom of adding a debugString method to
core library classes.
In any case, one can only do this with public classes like FutureTask, not
hidden ones.

For adapter wrappers like RunnableAdapter that simply convert e.g. Runnable
to Callable, it seems very reasonable for toString() to *also* "wrap" the
toString() of the adapted Runnable.

I'm generally supportive of doing something here, as long as we avoid
calling toString on unknown result objects - OTOH calling toString on
nested task objects seems alright.


On Tue, Aug 8, 2017 at 6:58 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> ​I would consider this to be an API change. For example, according to the
> current javadoc, FutureTask's toString method is inherited from Object.
>
> Practically speaking, I'd be concerned about unexpected and unwanted
> changes to the output/log statements of programs that have up until now
> been working fine. In addition to generating a lot of output that may be
> unwanted, this may also generate exceptions. For example,
> PrivilegedCallable.toString calls the toString method of the wrapped
> Callable, which may never have been called previously (bam!), and therefore
> might throw an exception. Or, the toString method of the wrapped callable
> may have been designed to be called in a different context.
>
> If any of the state the toString implementations are accessing is not
> thread-safe, I'd also be concerned about that.
>
> If tasks need toString implementations, I prefer to write them.​
>
> However, I think it would be OK to introduce new convenience methods:
> debugString()
>
> On Tue, Aug 8, 2017 at 6:36 PM, Martin Buchholz <martinrb at google.com>
> wrote:
>
>> My colleague Charles Munger suggests adding toString methods to various
>> task classes in j.u.c.  Obviously this makes it easier to debug large
>> programs that have gone wrong.  But it obviously also is a behavior change
>> that has the potential for trouble, even when everyone is behaving nicely,
>> since toString may have the effect of generating an unbounded output.  I
>> almost started down this road myself a few years ago but chickened out.
>> What do you think?
>>
>> Index: Executors.java
>> ===================================================================
>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>> ent/Executors.java,v
>> retrieving revision 1.97
>> diff -u -U 10 -r1.97 Executors.java
>> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
>> +++ Executors.java 9 Aug 2017 01:34:25 -0000
>> @@ -478,20 +478,24 @@
>>          private final Runnable task;
>>          private final T result;
>>          RunnableAdapter(Runnable task, T result) {
>>              this.task = task;
>>              this.result = result;
>>          }
>>          public T call() {
>>              task.run();
>>              return result;
>>          }
>> +        public String toString() {
>> +            return super.toString()
>> +                + "[task=[" + task + "], result=[" + result + "]]";
>> +        }
>>      }
>>
>>      /**
>>       * A callable that runs under established access control settings.
>>       */
>>      private static final class PrivilegedCallable<T> implements
>> Callable<T> {
>>          final Callable<T> task;
>>          final AccessControlContext acc;
>>
>>          PrivilegedCallable(Callable<T> task) {
>> @@ -504,20 +508,24 @@
>>                  return AccessController.doPrivileged(
>>                      new PrivilegedExceptionAction<T>() {
>>                          public T run() throws Exception {
>>                              return task.call();
>>                          }
>>                      }, acc);
>>              } catch (PrivilegedActionException e) {
>>                  throw e.getException();
>>              }
>>          }
>> +
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + task + "]]";
>> +        }
>>      }
>>
>>      /**
>>       * A callable that runs under established access control settings and
>>       * current ClassLoader.
>>       */
>>      private static final class PrivilegedCallableUsingCurrent
>> ClassLoader<T>
>>              implements Callable<T> {
>>          final Callable<T> task;
>>          final AccessControlContext acc;
>> @@ -556,20 +564,24 @@
>>                                  } finally {
>>                                      t.setContextClassLoader(cl);
>>                                  }
>>                              }
>>                          }
>>                      }, acc);
>>              } catch (PrivilegedActionException e) {
>>                  throw e.getException();
>>              }
>>          }
>> +
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + task + "]]";
>> +        }
>>      }
>>
>>      /**
>>       * The default thread factory.
>>       */
>>      private static class DefaultThreadFactory implements ThreadFactory {
>>          private static final AtomicInteger poolNumber = new
>> AtomicInteger(1);
>>          private final ThreadGroup group;
>>          private final AtomicInteger threadNumber = new AtomicInteger(1);
>>          private final String namePrefix;
>> Index: ForkJoinTask.java
>> ===================================================================
>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>> ent/ForkJoinTask.java,v
>> retrieving revision 1.115
>> diff -u -U 10 -r1.115 ForkJoinTask.java
>> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
>> +++ ForkJoinTask.java 9 Aug 2017 01:34:25 -0000
>> @@ -1339,37 +1339,43 @@
>>          T result;
>>          AdaptedRunnable(Runnable runnable, T result) {
>>              if (runnable == null) throw new NullPointerException();
>>              this.runnable = runnable;
>>              this.result = result; // OK to set this even before
>> completion
>>          }
>>          public final T getRawResult() { return result; }
>>          public final void setRawResult(T v) { result = v; }
>>          public final boolean exec() { runnable.run(); return true; }
>>          public final void run() { invoke(); }
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + runnable + "],
>> result=[" + result + "]]";
>> +        }
>>          private static final long serialVersionUID =
>> 5232453952276885070L;
>>      }
>>
>>      /**
>>       * Adapter for Runnables without results.
>>       */
>>      static final class AdaptedRunnableAction extends ForkJoinTask<Void>
>>          implements RunnableFuture<Void> {
>>          final Runnable runnable;
>>          AdaptedRunnableAction(Runnable runnable) {
>>              if (runnable == null) throw new NullPointerException();
>>              this.runnable = runnable;
>>          }
>>          public final Void getRawResult() { return null; }
>>          public final void setRawResult(Void v) { }
>>          public final boolean exec() { runnable.run(); return true; }
>>          public final void run() { invoke(); }
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + runnable + "]]";
>> +        }
>>          private static final long serialVersionUID =
>> 5232453952276885070L;
>>      }
>>
>>      /**
>>       * Adapter for Runnables in which failure forces worker exception.
>>       */
>>      static final class RunnableExecuteAction extends ForkJoinTask<Void> {
>>          final Runnable runnable;
>>          RunnableExecuteAction(Runnable runnable) {
>>              if (runnable == null) throw new NullPointerException();
>> @@ -1402,20 +1408,23 @@
>>                  result = callable.call();
>>                  return true;
>>              } catch (RuntimeException rex) {
>>                  throw rex;
>>              } catch (Exception ex) {
>>                  throw new RuntimeException(ex);
>>              }
>>          }
>>          public final void run() { invoke(); }
>>          private static final long serialVersionUID =
>> 2838392045355241008L;
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + callable + "]]";
>> +        }
>>      }
>>
>>      /**
>>       * Returns a new {@code ForkJoinTask} that performs the {@code run}
>>       * method of the given {@code Runnable} as its action, and returns
>>       * a null result upon {@link #join}.
>>       *
>>       * @param runnable the runnable action
>>       * @return the task
>>       */
>> Index: FutureTask.java
>> ===================================================================
>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>> ent/FutureTask.java,v
>> retrieving revision 1.118
>> diff -u -U 10 -r1.118 FutureTask.java
>> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
>> +++ FutureTask.java 9 Aug 2017 01:34:25 -0000
>> @@ -444,20 +444,49 @@
>>                              continue retry;
>>                      }
>>                      else if (!WAITERS.compareAndSet(this, q, s))
>>                          continue retry;
>>                  }
>>                  break;
>>              }
>>          }
>>      }
>>
>> +    public String toString() {
>> +        String start = super.toString() + "[status=";
>> +        try {
>> +            switch (state) {
>> +            case NEW:
>> +            case COMPLETING:
>> +                final Callable<?> callable = this.callable;
>> +                if (callable != null) {
>> +                    return start + "PENDING, task=[" + callable + "]]";
>> +                } else {
>> +                    return start + "PENDING]";
>> +                }
>> +            case NORMAL:
>> +                return start + "SUCCESS, result=[" + outcome + "]]";
>> +            case EXCEPTIONAL:
>> +                return start + "FAILURE, cause=[" + outcome + "]]";
>> +            case CANCELLED:
>> +            case INTERRUPTING:
>> +            case INTERRUPTED:
>> +                return start + "CANCELLED]";
>> +            default:
>> +                throw new IllegalStateException();
>> +            }
>> +        } catch (RuntimeException thrownFromToString) {
>> +            return start + "UNKNOWN, cause=["
>> +                + thrownFromToString.getClass() + "]";
>> +        }
>> +    }
>> +
>>      // VarHandle mechanics
>>      private static final VarHandle STATE;
>>      private static final VarHandle RUNNER;
>>      private static final VarHandle WAITERS;
>>      static {
>>          try {
>>              MethodHandles.Lookup l = MethodHandles.lookup();
>>              STATE = l.findVarHandle(FutureTask.class, "state",
>> int.class);
>>              RUNNER = l.findVarHandle(FutureTask.class, "runner",
>> Thread.class);
>>              WAITERS = l.findVarHandle(FutureTask.class, "waiters",
>> WaitNode.class);
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170809/ace25df2/attachment-0001.html>

From stuart.monteith at linaro.org  Thu Aug 10 04:42:02 2017
From: stuart.monteith at linaro.org (Stuart Monteith)
Date: Thu, 10 Aug 2017 09:42:02 +0100
Subject: [concurrency-interest] Programming language-independent memory
	models
In-Reply-To: <5eb3d218-d414-98fa-1463-edee536b6fda@redhat.com>
References: <b0be9ec7-74cd-eee3-2778-5f20a550f373@redhat.com>
 <CAPUmR1YaYOFyFA0gvg9s3ntJWLrNf7h9nzXF9P6V5m23W+GU-g@mail.gmail.com>
 <9e4138d5-f1bf-7d31-5adf-c3c0b77f56e7@redhat.com>
 <CAPUmR1ZTJ9PKW7CBOfbHRAJrOqj0YvscN65NZB+XbfSJN+OG7Q@mail.gmail.com>
 <9705f449-d2f7-504c-efd9-8fd1d7e6cc5f@redhat.com>
 <5eb3d218-d414-98fa-1463-edee536b6fda@redhat.com>
Message-ID: <CAEGA6kbMAMNtz7xEHQUEECT6KpfmqWGbyyv1a9DHf1PxwfgzTQ@mail.gmail.com>

Hello,
  We sort of already have a programming language independent memory
model, which is the Java memory model applied on to the other
languages the JVM can host. Furthermore, with Graal, is there more
scope now for there to be issues with ported languages?

BR,
  Stuart


On 9 August 2017 at 10:56, Andrew Haley <aph at redhat.com> wrote:
> On 09/08/17 10:54, Andrew Haley wrote:
>> On 08/08/17 20:10, Hans Boehm wrote:
>>> IMHO, the closest we have that is actually solid and understandable
>>> is the basic DRF model, with undefined semantics for data races.
>>> e.g. sections 2+3 from http://dl.acm.org/citation.cfm?id=1375581.1375591 .
>
> Also at www.hpl.hp.com/techreports/2008/HPL-2008-56.pdf
>
> --
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From aph at redhat.com  Thu Aug 10 06:03:56 2017
From: aph at redhat.com (Andrew Haley)
Date: Thu, 10 Aug 2017 11:03:56 +0100
Subject: [concurrency-interest] Programming language-independent memory
 models
In-Reply-To: <CAEGA6kbMAMNtz7xEHQUEECT6KpfmqWGbyyv1a9DHf1PxwfgzTQ@mail.gmail.com>
References: <b0be9ec7-74cd-eee3-2778-5f20a550f373@redhat.com>
 <CAPUmR1YaYOFyFA0gvg9s3ntJWLrNf7h9nzXF9P6V5m23W+GU-g@mail.gmail.com>
 <9e4138d5-f1bf-7d31-5adf-c3c0b77f56e7@redhat.com>
 <CAPUmR1ZTJ9PKW7CBOfbHRAJrOqj0YvscN65NZB+XbfSJN+OG7Q@mail.gmail.com>
 <9705f449-d2f7-504c-efd9-8fd1d7e6cc5f@redhat.com>
 <5eb3d218-d414-98fa-1463-edee536b6fda@redhat.com>
 <CAEGA6kbMAMNtz7xEHQUEECT6KpfmqWGbyyv1a9DHf1PxwfgzTQ@mail.gmail.com>
Message-ID: <2c3b4d9a-3a2d-6ab6-24f4-499a4ef39c55@redhat.com>

On 10/08/17 09:42, Stuart Monteith wrote:
> Hello,
>   We sort of already have a programming language independent memory
> model, which is the Java memory model applied on to the other
> languages the JVM can host.

Sort of, I suppose, but it depends on how the language is mapped on
to bytecode.  It's a start.

> Furthermore, with Graal, is there more
> scope now for there to be issues with ported languages?

That's up to the people using Graal to run other languages.  Graal
follows the JMM in its middle end (or at least doesn't transform
conforming code into non-conforming code) but front ends don't have to
do so.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From nathanila at gmail.com  Thu Aug 10 07:51:12 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 10 Aug 2017 05:51:12 -0600
Subject: [concurrency-interest] Min and Max for Atomics
Message-ID: <7730f7ab-c48b-9ae7-5aa3-4e5accf28557@gmail.com>

Have the following methods been considered to be added to their 
respective classes?  Perhaps, there are other Atomic classes where these 
should be added.  Perhaps, VarHandles should have these added (assume I 
know nothing about VarHandles).

The advantage of these methods is that they avoid cache invalidation and 
a fence if there is no update.  This is kind of related to the previous 
discussion about getAndUpdate() and updateAndGet().

I am proposing these methods since I have written this code a few 
times.  Until these methods are implemented in the JDK, perhaps I should 
write an atomic utility class.

AtomicInteger

public int max(int value)
{
    int expect;

    while (true)
    {
       expect = get();

       if (expect >= value)
          return expect;

       if (compareAndSet(expect, value))
          return expect;
    }
}

public int min(int value);
{
    int expect;

    while (true)
    {
       expect = get();

       if (expect <= value)
          return expect;

       if (compareAndSet(expect, value))
          return expect;
    }
}

AtomicLong
public long max(long value);
public long min(long value);


-- -Nathan

From martinrb at google.com  Thu Aug 10 09:29:18 2017
From: martinrb at google.com (Martin Buchholz)
Date: Thu, 10 Aug 2017 06:29:18 -0700
Subject: [concurrency-interest] Programming language-independent memory
	models
In-Reply-To: <b0be9ec7-74cd-eee3-2778-5f20a550f373@redhat.com>
References: <b0be9ec7-74cd-eee3-2778-5f20a550f373@redhat.com>
Message-ID: <CA+kOe0_9qPhq7C56e0Hx1kJsYQAG_W4teWz1VkT+=bqD5Xf_Yw@mail.gmail.com>

On Fri, Aug 4, 2017 at 10:18 AM, Andrew Haley <aph at redhat.com> wrote:

> Any language implemented in C++ will
> necessarily implement the C++ memory model, which (perhaps)
> unfortunately implies that if it executes any data races the whole
> program becomes undefined.  A programming language interpreter written
> in C++ could get around that by using atomic types for everything, but
> that's rather unpleasant.


I continue to have a mental model where every ordinary java field maps to a
relaxed atomic in C++ (disregarding the weird non-atomicity of long and
double), so a C++ interpreter for Java that used C++ atomics pervasively
seems very natural to me.  No C++ undefined behavior!  Java race detectors
can still detect concurrent accesses without happens-before, but there is
never a data race in the C++ sense.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170810/593faa57/attachment.html>

From nathanila at gmail.com  Thu Aug 10 13:35:50 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 10 Aug 2017 11:35:50 -0600
Subject: [concurrency-interest] Min and Max for Atomics
In-Reply-To: <14ce29b0-7f5b-9894-8f4d-0c89ab68be3f@yawk.at>
References: <7730f7ab-c48b-9ae7-5aa3-4e5accf28557@gmail.com>
 <14ce29b0-7f5b-9894-8f4d-0c89ab68be3f@yawk.at>
Message-ID: <3032a170-109f-e553-73ce-3b5d8bd42910@gmail.com>

Yes, I get the same behavior, but I will have to pay for a cache 
invalidation, CAS and a memory fence with each call.  For example, if I 
am tracking a high-water mark then at the beginning the updates should 
be very often and then taper off to nothing.  Thus, over time the cost 
is reduced to a load from cache or RAM.

-Nathan

On 8/10/2017 10:15 AM, Jonas Konrad wrote:
> Note that you can achieve the same behaviour using updateAndGet(i -> 
> Math.max(i, newVal)), at the cost of one CAS even on keeping the 
> current value.
>
> Looking at it, the shortcut prev == next could be taken in 
> updateAndGet too. Maybe it can't because you need the HB semantics of 
> compareAndSet?
>
> - Jonas Konrad
>
>
> On 08/10/2017 01:51 PM, Nathan and Ila Reynolds wrote:
>> Have the following methods been considered to be added to their 
>> respective classes?  Perhaps, there are other Atomic classes where 
>> these should be added.  Perhaps, VarHandles should have these added 
>> (assume I know nothing about VarHandles).
>>
>> The advantage of these methods is that they avoid cache invalidation 
>> and a fence if there is no update.  This is kind of related to the 
>> previous discussion about getAndUpdate() and updateAndGet().
>>
>> I am proposing these methods since I have written this code a few 
>> times.  Until these methods are implemented in the JDK, perhaps I 
>> should write an atomic utility class.
>>
>> AtomicInteger
>>
>> public int max(int value)
>> {
>>     int expect;
>>
>>     while (true)
>>     {
>>        expect = get();
>>
>>        if (expect >= value)
>>           return expect;
>>
>>        if (compareAndSet(expect, value))
>>           return expect;
>>     }
>> }
>>
>> public int min(int value);
>> {
>>     int expect;
>>
>>     while (true)
>>     {
>>        expect = get();
>>
>>        if (expect <= value)
>>           return expect;
>>
>>        if (compareAndSet(expect, value))
>>           return expect;
>>     }
>> }
>>
>> AtomicLong
>> public long max(long value);
>> public long min(long value);
>>
>>
>> -- -Nathan
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-- 
-Nathan


From aph at redhat.com  Thu Aug 10 13:56:58 2017
From: aph at redhat.com (Andrew Haley)
Date: Thu, 10 Aug 2017 18:56:58 +0100
Subject: [concurrency-interest] Min and Max for Atomics
In-Reply-To: <3032a170-109f-e553-73ce-3b5d8bd42910@gmail.com>
References: <7730f7ab-c48b-9ae7-5aa3-4e5accf28557@gmail.com>
 <14ce29b0-7f5b-9894-8f4d-0c89ab68be3f@yawk.at>
 <3032a170-109f-e553-73ce-3b5d8bd42910@gmail.com>
Message-ID: <02244124-8e4e-50ab-fc32-803afd74d742@redhat.com>

On 10/08/17 18:35, Nathan and Ila Reynolds wrote:
> Yes, I get the same behavior, but I will have to pay for a cache 
> invalidation, CAS and a memory fence with each call.  For example, if I 
> am tracking a high-water mark then at the beginning the updates should 
> be very often and then taper off to nothing.  Thus, over time the cost 
> is reduced to a load from cache or RAM.

What is this cache invalidation of which you speak?  After the
AtomicReference.updateAndGet() discussion last time around, it was
clear enough that no such thing was necessary.  And besides that,
the message is clear: use a VarHandle for such things.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From bronee at gmail.com  Thu Aug 10 14:18:23 2017
From: bronee at gmail.com (Brian S O'Neill)
Date: Thu, 10 Aug 2017 11:18:23 -0700
Subject: [concurrency-interest] Min and Max for Atomics
In-Reply-To: <7730f7ab-c48b-9ae7-5aa3-4e5accf28557@gmail.com>
References: <7730f7ab-c48b-9ae7-5aa3-4e5accf28557@gmail.com>
Message-ID: <7c2e698f-f454-9f64-4249-c7ca18cd063d@gmail.com>

Why should these functions be built into the VarHandle class? Are there 
any machine-specific instructions that can be targeted? If the 
implementation of these methods would always match your suggestion, then 
I don't see any reason why the VarHandle class should have them. 
Complicating further would be all the various permutations. Should this 
use acquire/release semantics? Weak? Volatile? Opaque?

On 2017-08-10 04:51 AM, Nathan and Ila Reynolds wrote:
> Have the following methods been considered to be added to their 
> respective classes?  Perhaps, there are other Atomic classes where these 
> should be added.  Perhaps, VarHandles should have these added (assume I 
> know nothing about VarHandles).
> 
> The advantage of these methods is that they avoid cache invalidation and 
> a fence if there is no update.  This is kind of related to the previous 
> discussion about getAndUpdate() and updateAndGet().
> 
> I am proposing these methods since I have written this code a few 
> times.  Until these methods are implemented in the JDK, perhaps I should 
> write an atomic utility class.
> 
> AtomicInteger
> 
> public int max(int value)
> {
>     int expect;
> 
>     while (true)
>     {
>        expect = get();
> 
>        if (expect >= value)
>           return expect;
> 
>        if (compareAndSet(expect, value))
>           return expect;
>     }
> }
> 
> public int min(int value);
> {
>     int expect;
> 
>     while (true)
>     {
>        expect = get();
> 
>        if (expect <= value)
>           return expect;
> 
>        if (compareAndSet(expect, value))
>           return expect;
>     }
> }
> 
> AtomicLong
> public long max(long value);
> public long min(long value);
> 
> 
> -- -Nathan
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From nathanila at gmail.com  Thu Aug 10 14:29:43 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 10 Aug 2017 12:29:43 -0600
Subject: [concurrency-interest] Min and Max for Atomics
In-Reply-To: <02244124-8e4e-50ab-fc32-803afd74d742@redhat.com>
References: <7730f7ab-c48b-9ae7-5aa3-4e5accf28557@gmail.com>
 <14ce29b0-7f5b-9894-8f4d-0c89ab68be3f@yawk.at>
 <3032a170-109f-e553-73ce-3b5d8bd42910@gmail.com>
 <02244124-8e4e-50ab-fc32-803afd74d742@redhat.com>
Message-ID: <855c4fea-53d8-c4b7-5d09-15842a032464@gmail.com>

See the https://en.wikipedia.org/wiki/MESI_protocol

Every time a core writes to a cache line (normal or atomic), it has to 
own the cache line in the exclusive state.  If the cache line is not 
already in the exclusive state, then the core has to send an 
invalidation message to all other caches in all other cores in the 
entire system.  This could mean going to another chip or even 7 other 
chips.  This invalidation message removes the cache line from all other 
cores.  The invalidating core can stall for a long time if the cache 
line is heavily contended.  This looks like 100% CPU usage but very 
sluggish progress.

I am very aware of this problem because I had to figure out that this 
was what was happening and then optimize some C++ code.  The interesting 
part of this story is that as Intel produced 4 newer chips over a period 
of 4 years, I had to revisit the code and improve the optimization.  I 
tried using a ThreadLocal variable but as the thread migrated to 
different cores, then the core had to migrate the cache line via cache 
invalidation.  I finally came up with an optimization which no longer 
suffers from this problem.  The final solution was to assign a cache 
line (i.e. variable) to 1 core.  In other words, it was a CoreLocal 
variable, if you will.  This reduced the cache invalidations and I have 
not had to revisit this code for 6 years.

So, updateAndGet() suffers from cache invalidation even if a write is 
not necessary.  It also suffers from CAS latency and a memory fence.  I 
realize that in some cases, this is exactly what one would want to pay 
for.  In my case, the updates are not frequent enough to warrant the cost.

-Nathan

On 8/10/2017 11:56 AM, Andrew Haley wrote:
> On 10/08/17 18:35, Nathan and Ila Reynolds wrote:
>> Yes, I get the same behavior, but I will have to pay for a cache
>> invalidation, CAS and a memory fence with each call.  For example, if I
>> am tracking a high-water mark then at the beginning the updates should
>> be very often and then taper off to nothing.  Thus, over time the cost
>> is reduced to a load from cache or RAM.
> What is this cache invalidation of which you speak?  After the
> AtomicReference.updateAndGet() discussion last time around, it was
> clear enough that no such thing was necessary.  And besides that,
> the message is clear: use a VarHandle for such things.
>

-- 
-Nathan


From nathanila at gmail.com  Thu Aug 10 14:31:11 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 10 Aug 2017 12:31:11 -0600
Subject: [concurrency-interest] Min and Max for Atomics
In-Reply-To: <7c2e698f-f454-9f64-4249-c7ca18cd063d@gmail.com>
References: <7730f7ab-c48b-9ae7-5aa3-4e5accf28557@gmail.com>
 <7c2e698f-f454-9f64-4249-c7ca18cd063d@gmail.com>
Message-ID: <701f79c8-23c4-e21a-bf3a-2699c33d9360@gmail.com>

Hmm... you raise a good point for VarHandle.  I speak from a position of 
knowing very little about VarHandle.  Perhaps, this logic is better in a 
utility class which accepts a VarHandle and the value.

-Nathan

On 8/10/2017 12:18 PM, Brian S O'Neill wrote:
> Why should these functions be built into the VarHandle class? Are 
> there any machine-specific instructions that can be targeted? If the 
> implementation of these methods would always match your suggestion, 
> then I don't see any reason why the VarHandle class should have them. 
> Complicating further would be all the various permutations. Should 
> this use acquire/release semantics? Weak? Volatile? Opaque?
>
> On 2017-08-10 04:51 AM, Nathan and Ila Reynolds wrote:
>> Have the following methods been considered to be added to their 
>> respective classes?  Perhaps, there are other Atomic classes where 
>> these should be added.  Perhaps, VarHandles should have these added 
>> (assume I know nothing about VarHandles).
>>
>> The advantage of these methods is that they avoid cache invalidation 
>> and a fence if there is no update.  This is kind of related to the 
>> previous discussion about getAndUpdate() and updateAndGet().
>>
>> I am proposing these methods since I have written this code a few 
>> times.  Until these methods are implemented in the JDK, perhaps I 
>> should write an atomic utility class.
>>
>> AtomicInteger
>>
>> public int max(int value)
>> {
>>     int expect;
>>
>>     while (true)
>>     {
>>        expect = get();
>>
>>        if (expect >= value)
>>           return expect;
>>
>>        if (compareAndSet(expect, value))
>>           return expect;
>>     }
>> }
>>
>> public int min(int value);
>> {
>>     int expect;
>>
>>     while (true)
>>     {
>>        expect = get();
>>
>>        if (expect <= value)
>>           return expect;
>>
>>        if (compareAndSet(expect, value))
>>           return expect;
>>     }
>> }
>>
>> AtomicLong
>> public long max(long value);
>> public long min(long value);
>>
>>
>> -- -Nathan
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-- 
-Nathan


From aph at redhat.com  Thu Aug 10 14:54:39 2017
From: aph at redhat.com (Andrew Haley)
Date: Thu, 10 Aug 2017 19:54:39 +0100
Subject: [concurrency-interest] Min and Max for Atomics
In-Reply-To: <855c4fea-53d8-c4b7-5d09-15842a032464@gmail.com>
References: <7730f7ab-c48b-9ae7-5aa3-4e5accf28557@gmail.com>
 <14ce29b0-7f5b-9894-8f4d-0c89ab68be3f@yawk.at>
 <3032a170-109f-e553-73ce-3b5d8bd42910@gmail.com>
 <02244124-8e4e-50ab-fc32-803afd74d742@redhat.com>
 <855c4fea-53d8-c4b7-5d09-15842a032464@gmail.com>
Message-ID: <dd411066-68f4-06ef-a4f3-973696df48c3@redhat.com>

On 10/08/17 19:29, Nathan and Ila Reynolds wrote:
> Every time a core writes to a cache line (normal or atomic), it has to 
> own the cache line in the exclusive state.  If the cache line is not 
> already in the exclusive state, then the core has to send an 
> invalidation message to all other caches in all other cores in the 
> entire system.  This could mean going to another chip or even 7 other 
> chips.  This invalidation message removes the cache line from all other 
> cores.  The invalidating core can stall for a long time if the cache 
> line is heavily contended.  This looks like 100% CPU usage but very 
> sluggish progress.

Oh, I see: you're complaining about the cache line being written and
ping-ponging between all the cores, generating a lot of bus traffic.
Fair enough.  However, it seems to me that your need is fairly specialized
and you've solved it easily enough with a trivial method.

> So, updateAndGet() suffers from cache invalidation even if a write is
> not necessary.  It also suffers from CAS latency and a memory fence.

In theory VarHandles will get you better behaviour, but in practice
HotSpot doesn't yet have the accelerators needed to make this stuff
work without the fences.  It's on my list of things to do.  Mind you,
if you're using x86, the ability to do without the synchronization
won't help much because x86 is TSO anyway.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From nathanila at gmail.com  Thu Aug 10 15:24:07 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 10 Aug 2017 13:24:07 -0600
Subject: [concurrency-interest] Min and Max for Atomics
In-Reply-To: <dd411066-68f4-06ef-a4f3-973696df48c3@redhat.com>
References: <7730f7ab-c48b-9ae7-5aa3-4e5accf28557@gmail.com>
 <14ce29b0-7f5b-9894-8f4d-0c89ab68be3f@yawk.at>
 <3032a170-109f-e553-73ce-3b5d8bd42910@gmail.com>
 <02244124-8e4e-50ab-fc32-803afd74d742@redhat.com>
 <855c4fea-53d8-c4b7-5d09-15842a032464@gmail.com>
 <dd411066-68f4-06ef-a4f3-973696df48c3@redhat.com>
Message-ID: <d9e2d3ea-f83f-4ace-205a-23e7ae414ccd@gmail.com>

 > However, it seems to me that your need is fairly specialized and 
you've solved it easily enough with a trivial method.

Yes, I raise this request because I have written this kind of logic 
several times.  Perhaps, I should just put it in a utility class.

-Nathan

On 8/10/2017 12:54 PM, Andrew Haley wrote:
> On 10/08/17 19:29, Nathan and Ila Reynolds wrote:
>> Every time a core writes to a cache line (normal or atomic), it has to
>> own the cache line in the exclusive state.  If the cache line is not
>> already in the exclusive state, then the core has to send an
>> invalidation message to all other caches in all other cores in the
>> entire system.  This could mean going to another chip or even 7 other
>> chips.  This invalidation message removes the cache line from all other
>> cores.  The invalidating core can stall for a long time if the cache
>> line is heavily contended.  This looks like 100% CPU usage but very
>> sluggish progress.
> Oh, I see: you're complaining about the cache line being written and
> ping-ponging between all the cores, generating a lot of bus traffic.
> Fair enough.  However, it seems to me that your need is fairly specialized
> and you've solved it easily enough with a trivial method.
>
>> So, updateAndGet() suffers from cache invalidation even if a write is
>> not necessary.  It also suffers from CAS latency and a memory fence.
> In theory VarHandles will get you better behaviour, but in practice
> HotSpot doesn't yet have the accelerators needed to make this stuff
> work without the fences.  It's on my list of things to do.  Mind you,
> if you're using x86, the ability to do without the synchronization
> won't help much because x86 is TSO anyway.
>

-- 
-Nathan


From joe.bowbeer at gmail.com  Fri Aug 11 13:09:48 2017
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri, 11 Aug 2017 17:09:48 +0000
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CAHktk4jTJ=3B0Xgwt+h6-58LGdQqdZa7zin5ZC7B2G41qbMiNw@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
 <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
 <CAHktk4g6XaP--9QTn5BORDqD43Th3ag0XtJsbe+fQhtPoKCLxw@mail.gmail.com>
 <CAHzJPEpgWQR8wyarTj_thU9tSEqz8cpoMtFqmK+Q+WD0XoATMA@mail.gmail.com>
 <CAGu0=MOeVhowQ9kFgoVRiukmzBpinVZa5AOFcsxUiCkSTDe_JA@mail.gmail.com>
 <CAHktk4jTJ=3B0Xgwt+h6-58LGdQqdZa7zin5ZC7B2G41qbMiNw@mail.gmail.com>
Message-ID: <CAHzJPEpJ52Xdf0Rcsf_9b3go=g66DFarBXn20swrWLWr7u3s+A@mail.gmail.com>

Yes, that minimal enhancement seems safe and efficient.

On Wed, Aug 9, 2017 at 10:55 AM Charles Munger <clm at google.com> wrote:

> How about starting by adding the following toString method to the adapter
> classes:
>
> @Override
> public String toString() {
>    return super.toString() + "[" + task.getClass().getName() + '@' +
> Integer.toHexString(System.identityHashCode(task)) + "]";
> }
>
> That produces bounded output size, exposes no PII, doesn't risk an
> exception or thread safety issues, and still provides enhanced debugging
> output. In fact, for nearly all implementations of Runnable and Callable,
> the class name and identity hash is all the useful output that someone
> needs.
>
> On Wed, Aug 9, 2017 at 10:29 AM, Benjamin Manes <ben.manes at gmail.com>
> wrote:
>
>> I would be comfortable with a toString() showing the task's class and
>> other high level state of owned fields, but not if calling foreign code
>> like the value's toString(). However, I can't think of a case where this
>> would have significantly helpful when debugging, so I am neutral between
>> minimal or no changes.
>>
>> On Wed, Aug 9, 2017 at 10:10 AM, Joe Bowbeer <joe.bowbeer at gmail.com>
>> wrote:
>>
>>> RunnableAdapter is an interesting case. I'd have most of the same
>>> concerns as before, to a slightly less extent. This would not be an API
>>> change, however.
>>>
>>> The style adopted by Java so far has been that j.u.c. objects don't by
>>> default reveal their internal state. It has been up to devs to opt in,
>>> based on their particular needs, and some devs rightly or wrongly rely on
>>> the format inherited from Object.
>>>
>>> If Guava or other libraries want to enhance this, that can be their
>>> value added.
>>>
>>> By the way, adding to my previous list of concerns, I'd also be
>>> concerned about leaking PI in log messages. This is related to my concern
>>> about the wrapped toString impl. being designed for use in a different
>>> context.
>>>
>>> On Wed, Aug 9, 2017 at 9:19 AM Charles Munger <clm at google.com> wrote:
>>>
>>>> I added similar toString implementations to guava's Future
>>>> implementations:
>>>>
>>>> https://github.com/google/guava/commit/304c634d977127085b49f174fd1aafefd09b2bf5
>>>>
>>>> The attraction of toString on common Future implementations is that
>>>> propagating toString throughout a graph of transformed Futures lets you see
>>>> what a task is doing before it completes, either in a TimeoutException
>>>> message or the toString of LockSupport.getBlocker.
>>>>
>>>> Do you feel that adding toString to RunnableAdapter (and similar
>>>> classes, that are only exposed in public API as interfaces) would also
>>>> constitute an API change?
>>>>
>>>> On Tue, Aug 8, 2017 at 6:58 PM, Joe Bowbeer <joe.bowbeer at gmail.com>
>>>> wrote:
>>>>
>>>>> ​I would consider this to be an API change. For example, according to
>>>>> the current javadoc, FutureTask's toString method is inherited from Object.
>>>>>
>>>>> Practically speaking, I'd be concerned about unexpected and unwanted
>>>>> changes to the output/log statements of programs that have up until now
>>>>> been working fine. In addition to generating a lot of output that may be
>>>>> unwanted, this may also generate exceptions. For example,
>>>>> PrivilegedCallable.toString calls the toString method of the wrapped
>>>>> Callable, which may never have been called previously (bam!), and therefore
>>>>> might throw an exception. Or, the toString method of the wrapped callable
>>>>> may have been designed to be called in a different context.
>>>>>
>>>>> If any of the state the toString implementations are accessing is not
>>>>> thread-safe, I'd also be concerned about that.
>>>>>
>>>>> If tasks need toString implementations, I prefer to write them.​
>>>>>
>>>>> However, I think it would be OK to introduce new convenience methods:
>>>>> debugString()
>>>>>
>>>>> On Tue, Aug 8, 2017 at 6:36 PM, Martin Buchholz <martinrb at google.com>
>>>>> wrote:
>>>>>
>>>>>> My colleague Charles Munger suggests adding toString methods to
>>>>>> various task classes in j.u.c.  Obviously this makes it easier to debug
>>>>>> large programs that have gone wrong.  But it obviously also is a behavior
>>>>>> change that has the potential for trouble, even when everyone is behaving
>>>>>> nicely, since toString may have the effect of generating an unbounded
>>>>>> output.  I almost started down this road myself a few years ago but
>>>>>> chickened out.  What do you think?
>>>>>>
>>>>>> Index: Executors.java
>>>>>> ===================================================================
>>>>>> RCS file:
>>>>>> /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/Executors.java,v
>>>>>> retrieving revision 1.97
>>>>>> diff -u -U 10 -r1.97 Executors.java
>>>>>> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
>>>>>> +++ Executors.java 9 Aug 2017 01:34:25 -0000
>>>>>> @@ -478,20 +478,24 @@
>>>>>>          private final Runnable task;
>>>>>>          private final T result;
>>>>>>          RunnableAdapter(Runnable task, T result) {
>>>>>>              this.task = task;
>>>>>>              this.result = result;
>>>>>>          }
>>>>>>          public T call() {
>>>>>>              task.run();
>>>>>>              return result;
>>>>>>          }
>>>>>> +        public String toString() {
>>>>>> +            return super.toString()
>>>>>> +                + "[task=[" + task + "], result=[" + result + "]]";
>>>>>> +        }
>>>>>>      }
>>>>>>
>>>>>>      /**
>>>>>>       * A callable that runs under established access control
>>>>>> settings.
>>>>>>       */
>>>>>>      private static final class PrivilegedCallable<T> implements
>>>>>> Callable<T> {
>>>>>>          final Callable<T> task;
>>>>>>          final AccessControlContext acc;
>>>>>>
>>>>>>          PrivilegedCallable(Callable<T> task) {
>>>>>> @@ -504,20 +508,24 @@
>>>>>>                  return AccessController.doPrivileged(
>>>>>>                      new PrivilegedExceptionAction<T>() {
>>>>>>                          public T run() throws Exception {
>>>>>>                              return task.call();
>>>>>>                          }
>>>>>>                      }, acc);
>>>>>>              } catch (PrivilegedActionException e) {
>>>>>>                  throw e.getException();
>>>>>>              }
>>>>>>          }
>>>>>> +
>>>>>> +        public String toString() {
>>>>>> +            return super.toString() + "[task=[" + task + "]]";
>>>>>> +        }
>>>>>>      }
>>>>>>
>>>>>>      /**
>>>>>>       * A callable that runs under established access control
>>>>>> settings and
>>>>>>       * current ClassLoader.
>>>>>>       */
>>>>>>      private static final class
>>>>>> PrivilegedCallableUsingCurrentClassLoader<T>
>>>>>>              implements Callable<T> {
>>>>>>          final Callable<T> task;
>>>>>>          final AccessControlContext acc;
>>>>>> @@ -556,20 +564,24 @@
>>>>>>                                  } finally {
>>>>>>                                      t.setContextClassLoader(cl);
>>>>>>                                  }
>>>>>>                              }
>>>>>>                          }
>>>>>>                      }, acc);
>>>>>>              } catch (PrivilegedActionException e) {
>>>>>>                  throw e.getException();
>>>>>>              }
>>>>>>          }
>>>>>> +
>>>>>> +        public String toString() {
>>>>>> +            return super.toString() + "[task=[" + task + "]]";
>>>>>> +        }
>>>>>>      }
>>>>>>
>>>>>>      /**
>>>>>>       * The default thread factory.
>>>>>>       */
>>>>>>      private static class DefaultThreadFactory implements
>>>>>> ThreadFactory {
>>>>>>          private static final AtomicInteger poolNumber = new
>>>>>> AtomicInteger(1);
>>>>>>          private final ThreadGroup group;
>>>>>>          private final AtomicInteger threadNumber = new
>>>>>> AtomicInteger(1);
>>>>>>          private final String namePrefix;
>>>>>> Index: ForkJoinTask.java
>>>>>> ===================================================================
>>>>>> RCS file:
>>>>>> /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/ForkJoinTask.java,v
>>>>>> retrieving revision 1.115
>>>>>> diff -u -U 10 -r1.115 ForkJoinTask.java
>>>>>> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
>>>>>> +++ ForkJoinTask.java 9 Aug 2017 01:34:25 -0000
>>>>>> @@ -1339,37 +1339,43 @@
>>>>>>          T result;
>>>>>>          AdaptedRunnable(Runnable runnable, T result) {
>>>>>>              if (runnable == null) throw new NullPointerException();
>>>>>>              this.runnable = runnable;
>>>>>>              this.result = result; // OK to set this even before
>>>>>> completion
>>>>>>          }
>>>>>>          public final T getRawResult() { return result; }
>>>>>>          public final void setRawResult(T v) { result = v; }
>>>>>>          public final boolean exec() { runnable.run(); return true; }
>>>>>>          public final void run() { invoke(); }
>>>>>> +        public String toString() {
>>>>>> +            return super.toString() + "[task=[" + runnable + "],
>>>>>> result=[" + result + "]]";
>>>>>> +        }
>>>>>>          private static final long serialVersionUID =
>>>>>> 5232453952276885070L;
>>>>>>      }
>>>>>>
>>>>>>      /**
>>>>>>       * Adapter for Runnables without results.
>>>>>>       */
>>>>>>      static final class AdaptedRunnableAction extends
>>>>>> ForkJoinTask<Void>
>>>>>>          implements RunnableFuture<Void> {
>>>>>>          final Runnable runnable;
>>>>>>          AdaptedRunnableAction(Runnable runnable) {
>>>>>>              if (runnable == null) throw new NullPointerException();
>>>>>>              this.runnable = runnable;
>>>>>>          }
>>>>>>          public final Void getRawResult() { return null; }
>>>>>>          public final void setRawResult(Void v) { }
>>>>>>          public final boolean exec() { runnable.run(); return true; }
>>>>>>          public final void run() { invoke(); }
>>>>>> +        public String toString() {
>>>>>> +            return super.toString() + "[task=[" + runnable + "]]";
>>>>>> +        }
>>>>>>          private static final long serialVersionUID =
>>>>>> 5232453952276885070L;
>>>>>>      }
>>>>>>
>>>>>>      /**
>>>>>>       * Adapter for Runnables in which failure forces worker
>>>>>> exception.
>>>>>>       */
>>>>>>      static final class RunnableExecuteAction extends
>>>>>> ForkJoinTask<Void> {
>>>>>>          final Runnable runnable;
>>>>>>          RunnableExecuteAction(Runnable runnable) {
>>>>>>              if (runnable == null) throw new NullPointerException();
>>>>>> @@ -1402,20 +1408,23 @@
>>>>>>                  result = callable.call();
>>>>>>                  return true;
>>>>>>              } catch (RuntimeException rex) {
>>>>>>                  throw rex;
>>>>>>              } catch (Exception ex) {
>>>>>>                  throw new RuntimeException(ex);
>>>>>>              }
>>>>>>          }
>>>>>>          public final void run() { invoke(); }
>>>>>>          private static final long serialVersionUID =
>>>>>> 2838392045355241008L;
>>>>>> +        public String toString() {
>>>>>> +            return super.toString() + "[task=[" + callable + "]]";
>>>>>> +        }
>>>>>>      }
>>>>>>
>>>>>>      /**
>>>>>>       * Returns a new {@code ForkJoinTask} that performs the {@code
>>>>>> run}
>>>>>>       * method of the given {@code Runnable} as its action, and
>>>>>> returns
>>>>>>       * a null result upon {@link #join}.
>>>>>>       *
>>>>>>       * @param runnable the runnable action
>>>>>>       * @return the task
>>>>>>       */
>>>>>> Index: FutureTask.java
>>>>>> ===================================================================
>>>>>> RCS file:
>>>>>> /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/FutureTask.java,v
>>>>>> retrieving revision 1.118
>>>>>> diff -u -U 10 -r1.118 FutureTask.java
>>>>>> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
>>>>>> +++ FutureTask.java 9 Aug 2017 01:34:25 -0000
>>>>>> @@ -444,20 +444,49 @@
>>>>>>                              continue retry;
>>>>>>                      }
>>>>>>                      else if (!WAITERS.compareAndSet(this, q, s))
>>>>>>                          continue retry;
>>>>>>                  }
>>>>>>                  break;
>>>>>>              }
>>>>>>          }
>>>>>>      }
>>>>>>
>>>>>> +    public String toString() {
>>>>>> +        String start = super.toString() + "[status=";
>>>>>> +        try {
>>>>>> +            switch (state) {
>>>>>> +            case NEW:
>>>>>> +            case COMPLETING:
>>>>>> +                final Callable<?> callable = this.callable;
>>>>>> +                if (callable != null) {
>>>>>> +                    return start + "PENDING, task=[" + callable +
>>>>>> "]]";
>>>>>> +                } else {
>>>>>> +                    return start + "PENDING]";
>>>>>> +                }
>>>>>> +            case NORMAL:
>>>>>> +                return start + "SUCCESS, result=[" + outcome + "]]";
>>>>>> +            case EXCEPTIONAL:
>>>>>> +                return start + "FAILURE, cause=[" + outcome + "]]";
>>>>>> +            case CANCELLED:
>>>>>> +            case INTERRUPTING:
>>>>>> +            case INTERRUPTED:
>>>>>> +                return start + "CANCELLED]";
>>>>>> +            default:
>>>>>> +                throw new IllegalStateException();
>>>>>> +            }
>>>>>> +        } catch (RuntimeException thrownFromToString) {
>>>>>> +            return start + "UNKNOWN, cause=["
>>>>>> +                + thrownFromToString.getClass() + "]";
>>>>>> +        }
>>>>>> +    }
>>>>>> +
>>>>>>      // VarHandle mechanics
>>>>>>      private static final VarHandle STATE;
>>>>>>      private static final VarHandle RUNNER;
>>>>>>      private static final VarHandle WAITERS;
>>>>>>      static {
>>>>>>          try {
>>>>>>              MethodHandles.Lookup l = MethodHandles.lookup();
>>>>>>              STATE = l.findVarHandle(FutureTask.class, "state",
>>>>>> int.class);
>>>>>>              RUNNER = l.findVarHandle(FutureTask.class, "runner",
>>>>>> Thread.class);
>>>>>>              WAITERS = l.findVarHandle(FutureTask.class, "waiters",
>>>>>> WaitNode.class);
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170811/aef284c9/attachment-0001.html>

From martinrb at google.com  Fri Aug 11 19:16:19 2017
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 11 Aug 2017 16:16:19 -0700
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CAHzJPEpJ52Xdf0Rcsf_9b3go=g66DFarBXn20swrWLWr7u3s+A@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
 <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
 <CAHktk4g6XaP--9QTn5BORDqD43Th3ag0XtJsbe+fQhtPoKCLxw@mail.gmail.com>
 <CAHzJPEpgWQR8wyarTj_thU9tSEqz8cpoMtFqmK+Q+WD0XoATMA@mail.gmail.com>
 <CAGu0=MOeVhowQ9kFgoVRiukmzBpinVZa5AOFcsxUiCkSTDe_JA@mail.gmail.com>
 <CAHktk4jTJ=3B0Xgwt+h6-58LGdQqdZa7zin5ZC7B2G41qbMiNw@mail.gmail.com>
 <CAHzJPEpJ52Xdf0Rcsf_9b3go=g66DFarBXn20swrWLWr7u3s+A@mail.gmail.com>
Message-ID: <CA+kOe09HHF+u4LvXn5FP2j02CvJn4T_KU0awTCZWh9-AweJy2w@mail.gmail.com>

I propose the variant below, which is generally useful and assumes that
calling toString on tasks and exceptions is safe, but calling toString on
results is not.  If y'all are happy with that, we can add docs (for
FutureTask.toString) and tests.

Index: Executors.java
===================================================================
RCS file:
/export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/Executors.java,v
retrieving revision 1.97
diff -u -r1.97 Executors.java
--- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
+++ Executors.java 11 Aug 2017 23:12:14 -0000
@@ -485,6 +485,9 @@
             task.run();
             return result;
         }
+        public String toString() {
+            return super.toString() + "[wrapped task = " + task + "]";
+        }
     }

     /**
@@ -511,6 +514,10 @@
                 throw e.getException();
             }
         }
+
+        public String toString() {
+            return super.toString() + "[wrapped task = " + task + "]";
+        }
     }

     /**
@@ -563,6 +570,10 @@
                 throw e.getException();
             }
         }
+
+        public String toString() {
+            return super.toString() + "[wrapped task = " + task + "]";
+        }
     }

     /**
Index: ForkJoinTask.java
===================================================================
RCS file:
/export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/ForkJoinTask.java,v
retrieving revision 1.115
diff -u -r1.115 ForkJoinTask.java
--- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
+++ ForkJoinTask.java 11 Aug 2017 23:12:14 -0000
@@ -1346,6 +1346,9 @@
         public final void setRawResult(T v) { result = v; }
         public final boolean exec() { runnable.run(); return true; }
         public final void run() { invoke(); }
+        public String toString() {
+            return super.toString() + "[wrapped task = " + runnable + "]";
+        }
         private static final long serialVersionUID = 5232453952276885070L;
     }

@@ -1363,6 +1366,9 @@
         public final void setRawResult(Void v) { }
         public final boolean exec() { runnable.run(); return true; }
         public final void run() { invoke(); }
+        public String toString() {
+            return super.toString() + "[wrapped task = " + runnable + "]";
+        }
         private static final long serialVersionUID = 5232453952276885070L;
     }

@@ -1409,6 +1415,9 @@
         }
         public final void run() { invoke(); }
         private static final long serialVersionUID = 2838392045355241008L;
+        public String toString() {
+            return super.toString() + "[wrapped task = " + callable + "]";
+        }
     }

     /**
Index: FutureTask.java
===================================================================
RCS file:
/export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/FutureTask.java,v
retrieving revision 1.118
diff -u -r1.118 FutureTask.java
--- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
+++ FutureTask.java 11 Aug 2017 23:12:14 -0000
@@ -451,6 +451,27 @@
         }
     }

+    public String toString() {
+        final String status;
+        switch (state) {
+        case NORMAL:
+            status = "[completed normally]";
+            break;
+        case EXCEPTIONAL:
+            status = "[completed exceptionally: " + outcome + "]";
+            break;
+        case CANCELLED:
+            status = "[cancelled]";
+            break;
+        default:
+            final Callable<?> callable = this.callable;
+            status = (callable == null)
+                ? "[incomplete]"
+                : "[incomplete, task = " + callable + "]";
+        }
+        return super.toString() + status;
+    }
+
     // VarHandle mechanics
     private static final VarHandle STATE;
     private static final VarHandle RUNNER;


On Fri, Aug 11, 2017 at 10:09 AM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> Yes, that minimal enhancement seems safe and efficient.
>
> On Wed, Aug 9, 2017 at 10:55 AM Charles Munger <clm at google.com> wrote:
>
>> How about starting by adding the following toString method to the adapter
>> classes:
>>
>> @Override
>> public String toString() {
>>    return super.toString() + "[" + task.getClass().getName() + '@' +
>> Integer.toHexString(System.identityHashCode(task)) + "]";
>> }
>>
>> That produces bounded output size, exposes no PII, doesn't risk an
>> exception or thread safety issues, and still provides enhanced debugging
>> output. In fact, for nearly all implementations of Runnable and Callable,
>> the class name and identity hash is all the useful output that someone
>> needs.
>>
>> On Wed, Aug 9, 2017 at 10:29 AM, Benjamin Manes <ben.manes at gmail.com>
>> wrote:
>>
>>> I would be comfortable with a toString() showing the task's class and
>>> other high level state of owned fields, but not if calling foreign code
>>> like the value's toString(). However, I can't think of a case where this
>>> would have significantly helpful when debugging, so I am neutral between
>>> minimal or no changes.
>>>
>>> On Wed, Aug 9, 2017 at 10:10 AM, Joe Bowbeer <joe.bowbeer at gmail.com>
>>> wrote:
>>>
>>>> RunnableAdapter is an interesting case. I'd have most of the same
>>>> concerns as before, to a slightly less extent. This would not be an API
>>>> change, however.
>>>>
>>>> The style adopted by Java so far has been that j.u.c. objects don't by
>>>> default reveal their internal state. It has been up to devs to opt in,
>>>> based on their particular needs, and some devs rightly or wrongly rely on
>>>> the format inherited from Object.
>>>>
>>>> If Guava or other libraries want to enhance this, that can be their
>>>> value added.
>>>>
>>>> By the way, adding to my previous list of concerns, I'd also be
>>>> concerned about leaking PI in log messages. This is related to my concern
>>>> about the wrapped toString impl. being designed for use in a different
>>>> context.
>>>>
>>>> On Wed, Aug 9, 2017 at 9:19 AM Charles Munger <clm at google.com> wrote:
>>>>
>>>>> I added similar toString implementations to guava's Future
>>>>> implementations:
>>>>> https://github.com/google/guava/commit/304c634d977127085b49f174fd1aaf
>>>>> efd09b2bf5
>>>>>
>>>>> The attraction of toString on common Future implementations is that
>>>>> propagating toString throughout a graph of transformed Futures lets you see
>>>>> what a task is doing before it completes, either in a TimeoutException
>>>>> message or the toString of LockSupport.getBlocker.
>>>>>
>>>>> Do you feel that adding toString to RunnableAdapter (and similar
>>>>> classes, that are only exposed in public API as interfaces) would also
>>>>> constitute an API change?
>>>>>
>>>>> On Tue, Aug 8, 2017 at 6:58 PM, Joe Bowbeer <joe.bowbeer at gmail.com>
>>>>> wrote:
>>>>>
>>>>>> ​I would consider this to be an API change. For example, according to
>>>>>> the current javadoc, FutureTask's toString method is inherited from Object.
>>>>>>
>>>>>> Practically speaking, I'd be concerned about unexpected and unwanted
>>>>>> changes to the output/log statements of programs that have up until now
>>>>>> been working fine. In addition to generating a lot of output that may be
>>>>>> unwanted, this may also generate exceptions. For example,
>>>>>> PrivilegedCallable.toString calls the toString method of the wrapped
>>>>>> Callable, which may never have been called previously (bam!), and therefore
>>>>>> might throw an exception. Or, the toString method of the wrapped callable
>>>>>> may have been designed to be called in a different context.
>>>>>>
>>>>>> If any of the state the toString implementations are accessing is not
>>>>>> thread-safe, I'd also be concerned about that.
>>>>>>
>>>>>> If tasks need toString implementations, I prefer to write them.​
>>>>>>
>>>>>> However, I think it would be OK to introduce new convenience methods:
>>>>>> debugString()
>>>>>>
>>>>>> On Tue, Aug 8, 2017 at 6:36 PM, Martin Buchholz <martinrb at google.com>
>>>>>> wrote:
>>>>>>
>>>>>>> My colleague Charles Munger suggests adding toString methods to
>>>>>>> various task classes in j.u.c.  Obviously this makes it easier to debug
>>>>>>> large programs that have gone wrong.  But it obviously also is a behavior
>>>>>>> change that has the potential for trouble, even when everyone is behaving
>>>>>>> nicely, since toString may have the effect of generating an unbounded
>>>>>>> output.  I almost started down this road myself a few years ago but
>>>>>>> chickened out.  What do you think?
>>>>>>>
>>>>>>> Index: Executors.java
>>>>>>> ===================================================================
>>>>>>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/
>>>>>>> concurrent/Executors.java,v
>>>>>>> retrieving revision 1.97
>>>>>>> diff -u -U 10 -r1.97 Executors.java
>>>>>>> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
>>>>>>> +++ Executors.java 9 Aug 2017 01:34:25 -0000
>>>>>>> @@ -478,20 +478,24 @@
>>>>>>>          private final Runnable task;
>>>>>>>          private final T result;
>>>>>>>          RunnableAdapter(Runnable task, T result) {
>>>>>>>              this.task = task;
>>>>>>>              this.result = result;
>>>>>>>          }
>>>>>>>          public T call() {
>>>>>>>              task.run();
>>>>>>>              return result;
>>>>>>>          }
>>>>>>> +        public String toString() {
>>>>>>> +            return super.toString()
>>>>>>> +                + "[task=[" + task + "], result=[" + result + "]]";
>>>>>>> +        }
>>>>>>>      }
>>>>>>>
>>>>>>>      /**
>>>>>>>       * A callable that runs under established access control
>>>>>>> settings.
>>>>>>>       */
>>>>>>>      private static final class PrivilegedCallable<T> implements
>>>>>>> Callable<T> {
>>>>>>>          final Callable<T> task;
>>>>>>>          final AccessControlContext acc;
>>>>>>>
>>>>>>>          PrivilegedCallable(Callable<T> task) {
>>>>>>> @@ -504,20 +508,24 @@
>>>>>>>                  return AccessController.doPrivileged(
>>>>>>>                      new PrivilegedExceptionAction<T>() {
>>>>>>>                          public T run() throws Exception {
>>>>>>>                              return task.call();
>>>>>>>                          }
>>>>>>>                      }, acc);
>>>>>>>              } catch (PrivilegedActionException e) {
>>>>>>>                  throw e.getException();
>>>>>>>              }
>>>>>>>          }
>>>>>>> +
>>>>>>> +        public String toString() {
>>>>>>> +            return super.toString() + "[task=[" + task + "]]";
>>>>>>> +        }
>>>>>>>      }
>>>>>>>
>>>>>>>      /**
>>>>>>>       * A callable that runs under established access control
>>>>>>> settings and
>>>>>>>       * current ClassLoader.
>>>>>>>       */
>>>>>>>      private static final class PrivilegedCallableUsingCurrent
>>>>>>> ClassLoader<T>
>>>>>>>              implements Callable<T> {
>>>>>>>          final Callable<T> task;
>>>>>>>          final AccessControlContext acc;
>>>>>>> @@ -556,20 +564,24 @@
>>>>>>>                                  } finally {
>>>>>>>                                      t.setContextClassLoader(cl);
>>>>>>>                                  }
>>>>>>>                              }
>>>>>>>                          }
>>>>>>>                      }, acc);
>>>>>>>              } catch (PrivilegedActionException e) {
>>>>>>>                  throw e.getException();
>>>>>>>              }
>>>>>>>          }
>>>>>>> +
>>>>>>> +        public String toString() {
>>>>>>> +            return super.toString() + "[task=[" + task + "]]";
>>>>>>> +        }
>>>>>>>      }
>>>>>>>
>>>>>>>      /**
>>>>>>>       * The default thread factory.
>>>>>>>       */
>>>>>>>      private static class DefaultThreadFactory implements
>>>>>>> ThreadFactory {
>>>>>>>          private static final AtomicInteger poolNumber = new
>>>>>>> AtomicInteger(1);
>>>>>>>          private final ThreadGroup group;
>>>>>>>          private final AtomicInteger threadNumber = new
>>>>>>> AtomicInteger(1);
>>>>>>>          private final String namePrefix;
>>>>>>> Index: ForkJoinTask.java
>>>>>>> ===================================================================
>>>>>>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/
>>>>>>> concurrent/ForkJoinTask.java,v
>>>>>>> retrieving revision 1.115
>>>>>>> diff -u -U 10 -r1.115 ForkJoinTask.java
>>>>>>> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
>>>>>>> +++ ForkJoinTask.java 9 Aug 2017 01:34:25 -0000
>>>>>>> @@ -1339,37 +1339,43 @@
>>>>>>>          T result;
>>>>>>>          AdaptedRunnable(Runnable runnable, T result) {
>>>>>>>              if (runnable == null) throw new NullPointerException();
>>>>>>>              this.runnable = runnable;
>>>>>>>              this.result = result; // OK to set this even before
>>>>>>> completion
>>>>>>>          }
>>>>>>>          public final T getRawResult() { return result; }
>>>>>>>          public final void setRawResult(T v) { result = v; }
>>>>>>>          public final boolean exec() { runnable.run(); return true; }
>>>>>>>          public final void run() { invoke(); }
>>>>>>> +        public String toString() {
>>>>>>> +            return super.toString() + "[task=[" + runnable + "],
>>>>>>> result=[" + result + "]]";
>>>>>>> +        }
>>>>>>>          private static final long serialVersionUID =
>>>>>>> 5232453952276885070L;
>>>>>>>      }
>>>>>>>
>>>>>>>      /**
>>>>>>>       * Adapter for Runnables without results.
>>>>>>>       */
>>>>>>>      static final class AdaptedRunnableAction extends
>>>>>>> ForkJoinTask<Void>
>>>>>>>          implements RunnableFuture<Void> {
>>>>>>>          final Runnable runnable;
>>>>>>>          AdaptedRunnableAction(Runnable runnable) {
>>>>>>>              if (runnable == null) throw new NullPointerException();
>>>>>>>              this.runnable = runnable;
>>>>>>>          }
>>>>>>>          public final Void getRawResult() { return null; }
>>>>>>>          public final void setRawResult(Void v) { }
>>>>>>>          public final boolean exec() { runnable.run(); return true; }
>>>>>>>          public final void run() { invoke(); }
>>>>>>> +        public String toString() {
>>>>>>> +            return super.toString() + "[task=[" + runnable + "]]";
>>>>>>> +        }
>>>>>>>          private static final long serialVersionUID =
>>>>>>> 5232453952276885070L;
>>>>>>>      }
>>>>>>>
>>>>>>>      /**
>>>>>>>       * Adapter for Runnables in which failure forces worker
>>>>>>> exception.
>>>>>>>       */
>>>>>>>      static final class RunnableExecuteAction extends
>>>>>>> ForkJoinTask<Void> {
>>>>>>>          final Runnable runnable;
>>>>>>>          RunnableExecuteAction(Runnable runnable) {
>>>>>>>              if (runnable == null) throw new NullPointerException();
>>>>>>> @@ -1402,20 +1408,23 @@
>>>>>>>                  result = callable.call();
>>>>>>>                  return true;
>>>>>>>              } catch (RuntimeException rex) {
>>>>>>>                  throw rex;
>>>>>>>              } catch (Exception ex) {
>>>>>>>                  throw new RuntimeException(ex);
>>>>>>>              }
>>>>>>>          }
>>>>>>>          public final void run() { invoke(); }
>>>>>>>          private static final long serialVersionUID =
>>>>>>> 2838392045355241008L;
>>>>>>> +        public String toString() {
>>>>>>> +            return super.toString() + "[task=[" + callable + "]]";
>>>>>>> +        }
>>>>>>>      }
>>>>>>>
>>>>>>>      /**
>>>>>>>       * Returns a new {@code ForkJoinTask} that performs the {@code
>>>>>>> run}
>>>>>>>       * method of the given {@code Runnable} as its action, and
>>>>>>> returns
>>>>>>>       * a null result upon {@link #join}.
>>>>>>>       *
>>>>>>>       * @param runnable the runnable action
>>>>>>>       * @return the task
>>>>>>>       */
>>>>>>> Index: FutureTask.java
>>>>>>> ===================================================================
>>>>>>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/
>>>>>>> concurrent/FutureTask.java,v
>>>>>>> retrieving revision 1.118
>>>>>>> diff -u -U 10 -r1.118 FutureTask.java
>>>>>>> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
>>>>>>> +++ FutureTask.java 9 Aug 2017 01:34:25 -0000
>>>>>>> @@ -444,20 +444,49 @@
>>>>>>>                              continue retry;
>>>>>>>                      }
>>>>>>>                      else if (!WAITERS.compareAndSet(this, q, s))
>>>>>>>                          continue retry;
>>>>>>>                  }
>>>>>>>                  break;
>>>>>>>              }
>>>>>>>          }
>>>>>>>      }
>>>>>>>
>>>>>>> +    public String toString() {
>>>>>>> +        String start = super.toString() + "[status=";
>>>>>>> +        try {
>>>>>>> +            switch (state) {
>>>>>>> +            case NEW:
>>>>>>> +            case COMPLETING:
>>>>>>> +                final Callable<?> callable = this.callable;
>>>>>>> +                if (callable != null) {
>>>>>>> +                    return start + "PENDING, task=[" + callable +
>>>>>>> "]]";
>>>>>>> +                } else {
>>>>>>> +                    return start + "PENDING]";
>>>>>>> +                }
>>>>>>> +            case NORMAL:
>>>>>>> +                return start + "SUCCESS, result=[" + outcome + "]]";
>>>>>>> +            case EXCEPTIONAL:
>>>>>>> +                return start + "FAILURE, cause=[" + outcome + "]]";
>>>>>>> +            case CANCELLED:
>>>>>>> +            case INTERRUPTING:
>>>>>>> +            case INTERRUPTED:
>>>>>>> +                return start + "CANCELLED]";
>>>>>>> +            default:
>>>>>>> +                throw new IllegalStateException();
>>>>>>> +            }
>>>>>>> +        } catch (RuntimeException thrownFromToString) {
>>>>>>> +            return start + "UNKNOWN, cause=["
>>>>>>> +                + thrownFromToString.getClass() + "]";
>>>>>>> +        }
>>>>>>> +    }
>>>>>>> +
>>>>>>>      // VarHandle mechanics
>>>>>>>      private static final VarHandle STATE;
>>>>>>>      private static final VarHandle RUNNER;
>>>>>>>      private static final VarHandle WAITERS;
>>>>>>>      static {
>>>>>>>          try {
>>>>>>>              MethodHandles.Lookup l = MethodHandles.lookup();
>>>>>>>              STATE = l.findVarHandle(FutureTask.class, "state",
>>>>>>> int.class);
>>>>>>>              RUNNER = l.findVarHandle(FutureTask.class, "runner",
>>>>>>> Thread.class);
>>>>>>>              WAITERS = l.findVarHandle(FutureTask.class, "waiters",
>>>>>>> WaitNode.class);
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170811/7ff77747/attachment-0001.html>

From joe.bowbeer at gmail.com  Fri Aug 11 19:31:14 2017
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri, 11 Aug 2017 16:31:14 -0700
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CA+kOe09HHF+u4LvXn5FP2j02CvJn4T_KU0awTCZWh9-AweJy2w@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
 <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
 <CAHktk4g6XaP--9QTn5BORDqD43Th3ag0XtJsbe+fQhtPoKCLxw@mail.gmail.com>
 <CAHzJPEpgWQR8wyarTj_thU9tSEqz8cpoMtFqmK+Q+WD0XoATMA@mail.gmail.com>
 <CAGu0=MOeVhowQ9kFgoVRiukmzBpinVZa5AOFcsxUiCkSTDe_JA@mail.gmail.com>
 <CAHktk4jTJ=3B0Xgwt+h6-58LGdQqdZa7zin5ZC7B2G41qbMiNw@mail.gmail.com>
 <CAHzJPEpJ52Xdf0Rcsf_9b3go=g66DFarBXn20swrWLWr7u3s+A@mail.gmail.com>
 <CA+kOe09HHF+u4LvXn5FP2j02CvJn4T_KU0awTCZWh9-AweJy2w@mail.gmail.com>
Message-ID: <CAHzJPErRU0rDAMbdk2rTO5QB-QSKc8bUuZT0R+N8h2ZnDHWHjw@mail.gmail.com>

I would not assume that calling toString is safe or desirable, for the
various reasons I listed.

These toString implementations have not existed for a dozen years, yet
their lack of existence has never been mentioned on this list (right?), so
I would err on the side of caution.

On Aug 11, 2017 4:16 PM, "Martin Buchholz" <martinrb at google.com> wrote:

> I propose the variant below, which is generally useful and assumes that
> calling toString on tasks and exceptions is safe, but calling toString on
> results is not.  If y'all are happy with that, we can add docs (for
> FutureTask.toString) and tests.
>
> Index: Executors.java
> ===================================================================
> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/
> concurrent/Executors.java,v
> retrieving revision 1.97
> diff -u -r1.97 Executors.java
> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
> +++ Executors.java 11 Aug 2017 23:12:14 -0000
> @@ -485,6 +485,9 @@
>              task.run();
>              return result;
>          }
> +        public String toString() {
> +            return super.toString() + "[wrapped task = " + task + "]";
> +        }
>      }
>
>      /**
> @@ -511,6 +514,10 @@
>                  throw e.getException();
>              }
>          }
> +
> +        public String toString() {
> +            return super.toString() + "[wrapped task = " + task + "]";
> +        }
>      }
>
>      /**
> @@ -563,6 +570,10 @@
>                  throw e.getException();
>              }
>          }
> +
> +        public String toString() {
> +            return super.toString() + "[wrapped task = " + task + "]";
> +        }
>      }
>
>      /**
> Index: ForkJoinTask.java
> ===================================================================
> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/
> concurrent/ForkJoinTask.java,v
> retrieving revision 1.115
> diff -u -r1.115 ForkJoinTask.java
> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
> +++ ForkJoinTask.java 11 Aug 2017 23:12:14 -0000
> @@ -1346,6 +1346,9 @@
>          public final void setRawResult(T v) { result = v; }
>          public final boolean exec() { runnable.run(); return true; }
>          public final void run() { invoke(); }
> +        public String toString() {
> +            return super.toString() + "[wrapped task = " + runnable + "]";
> +        }
>          private static final long serialVersionUID = 5232453952276885070L;
>      }
>
> @@ -1363,6 +1366,9 @@
>          public final void setRawResult(Void v) { }
>          public final boolean exec() { runnable.run(); return true; }
>          public final void run() { invoke(); }
> +        public String toString() {
> +            return super.toString() + "[wrapped task = " + runnable + "]";
> +        }
>          private static final long serialVersionUID = 5232453952276885070L;
>      }
>
> @@ -1409,6 +1415,9 @@
>          }
>          public final void run() { invoke(); }
>          private static final long serialVersionUID = 2838392045355241008L;
> +        public String toString() {
> +            return super.toString() + "[wrapped task = " + callable + "]";
> +        }
>      }
>
>      /**
> Index: FutureTask.java
> ===================================================================
> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/
> concurrent/FutureTask.java,v
> retrieving revision 1.118
> diff -u -r1.118 FutureTask.java
> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
> +++ FutureTask.java 11 Aug 2017 23:12:14 -0000
> @@ -451,6 +451,27 @@
>          }
>      }
>
> +    public String toString() {
> +        final String status;
> +        switch (state) {
> +        case NORMAL:
> +            status = "[completed normally]";
> +            break;
> +        case EXCEPTIONAL:
> +            status = "[completed exceptionally: " + outcome + "]";
> +            break;
> +        case CANCELLED:
> +            status = "[cancelled]";
> +            break;
> +        default:
> +            final Callable<?> callable = this.callable;
> +            status = (callable == null)
> +                ? "[incomplete]"
> +                : "[incomplete, task = " + callable + "]";
> +        }
> +        return super.toString() + status;
> +    }
> +
>      // VarHandle mechanics
>      private static final VarHandle STATE;
>      private static final VarHandle RUNNER;
>
>
> On Fri, Aug 11, 2017 at 10:09 AM, Joe Bowbeer <joe.bowbeer at gmail.com>
> wrote:
>
>> Yes, that minimal enhancement seems safe and efficient.
>>
>> On Wed, Aug 9, 2017 at 10:55 AM Charles Munger <clm at google.com> wrote:
>>
>>> How about starting by adding the following toString method to the
>>> adapter classes:
>>>
>>> @Override
>>> public String toString() {
>>>    return super.toString() + "[" + task.getClass().getName() + '@' +
>>> Integer.toHexString(System.identityHashCode(task)) + "]";
>>> }
>>>
>>> That produces bounded output size, exposes no PII, doesn't risk an
>>> exception or thread safety issues, and still provides enhanced debugging
>>> output. In fact, for nearly all implementations of Runnable and Callable,
>>> the class name and identity hash is all the useful output that someone
>>> needs.
>>>
>>> On Wed, Aug 9, 2017 at 10:29 AM, Benjamin Manes <ben.manes at gmail.com>
>>> wrote:
>>>
>>>> I would be comfortable with a toString() showing the task's class and
>>>> other high level state of owned fields, but not if calling foreign code
>>>> like the value's toString(). However, I can't think of a case where this
>>>> would have significantly helpful when debugging, so I am neutral between
>>>> minimal or no changes.
>>>>
>>>> On Wed, Aug 9, 2017 at 10:10 AM, Joe Bowbeer <joe.bowbeer at gmail.com>
>>>> wrote:
>>>>
>>>>> RunnableAdapter is an interesting case. I'd have most of the same
>>>>> concerns as before, to a slightly less extent. This would not be an API
>>>>> change, however.
>>>>>
>>>>> The style adopted by Java so far has been that j.u.c. objects don't by
>>>>> default reveal their internal state. It has been up to devs to opt in,
>>>>> based on their particular needs, and some devs rightly or wrongly rely on
>>>>> the format inherited from Object.
>>>>>
>>>>> If Guava or other libraries want to enhance this, that can be their
>>>>> value added.
>>>>>
>>>>> By the way, adding to my previous list of concerns, I'd also be
>>>>> concerned about leaking PI in log messages. This is related to my concern
>>>>> about the wrapped toString impl. being designed for use in a different
>>>>> context.
>>>>>
>>>>> On Wed, Aug 9, 2017 at 9:19 AM Charles Munger <clm at google.com> wrote:
>>>>>
>>>>>> I added similar toString implementations to guava's Future
>>>>>> implementations:
>>>>>> https://github.com/google/guava/commit/304c634d977127085b49f
>>>>>> 174fd1aafefd09b2bf5
>>>>>>
>>>>>> The attraction of toString on common Future implementations is that
>>>>>> propagating toString throughout a graph of transformed Futures lets you see
>>>>>> what a task is doing before it completes, either in a TimeoutException
>>>>>> message or the toString of LockSupport.getBlocker.
>>>>>>
>>>>>> Do you feel that adding toString to RunnableAdapter (and similar
>>>>>> classes, that are only exposed in public API as interfaces) would also
>>>>>> constitute an API change?
>>>>>>
>>>>>> On Tue, Aug 8, 2017 at 6:58 PM, Joe Bowbeer <joe.bowbeer at gmail.com>
>>>>>> wrote:
>>>>>>
>>>>>>> ​I would consider this to be an API change. For example, according
>>>>>>> to the current javadoc, FutureTask's toString method is inherited from
>>>>>>> Object.
>>>>>>>
>>>>>>> Practically speaking, I'd be concerned about unexpected and unwanted
>>>>>>> changes to the output/log statements of programs that have up until now
>>>>>>> been working fine. In addition to generating a lot of output that may be
>>>>>>> unwanted, this may also generate exceptions. For example,
>>>>>>> PrivilegedCallable.toString calls the toString method of the wrapped
>>>>>>> Callable, which may never have been called previously (bam!), and therefore
>>>>>>> might throw an exception. Or, the toString method of the wrapped callable
>>>>>>> may have been designed to be called in a different context.
>>>>>>>
>>>>>>> If any of the state the toString implementations are accessing is
>>>>>>> not thread-safe, I'd also be concerned about that.
>>>>>>>
>>>>>>> If tasks need toString implementations, I prefer to write them.​
>>>>>>>
>>>>>>> However, I think it would be OK to introduce new convenience
>>>>>>> methods: debugString()
>>>>>>>
>>>>>>> On Tue, Aug 8, 2017 at 6:36 PM, Martin Buchholz <martinrb at google.com
>>>>>>> > wrote:
>>>>>>>
>>>>>>>> My colleague Charles Munger suggests adding toString methods to
>>>>>>>> various task classes in j.u.c.  Obviously this makes it easier to debug
>>>>>>>> large programs that have gone wrong.  But it obviously also is a behavior
>>>>>>>> change that has the potential for trouble, even when everyone is behaving
>>>>>>>> nicely, since toString may have the effect of generating an unbounded
>>>>>>>> output.  I almost started down this road myself a few years ago but
>>>>>>>> chickened out.  What do you think?
>>>>>>>>
>>>>>>>> Index: Executors.java
>>>>>>>> ===================================================================
>>>>>>>> RCS file: /export/home/jsr166/jsr166/jsr
>>>>>>>> 166/src/main/java/util/concurrent/Executors.java,v
>>>>>>>> retrieving revision 1.97
>>>>>>>> diff -u -U 10 -r1.97 Executors.java
>>>>>>>> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
>>>>>>>> +++ Executors.java 9 Aug 2017 01:34:25 -0000
>>>>>>>> @@ -478,20 +478,24 @@
>>>>>>>>          private final Runnable task;
>>>>>>>>          private final T result;
>>>>>>>>          RunnableAdapter(Runnable task, T result) {
>>>>>>>>              this.task = task;
>>>>>>>>              this.result = result;
>>>>>>>>          }
>>>>>>>>          public T call() {
>>>>>>>>              task.run();
>>>>>>>>              return result;
>>>>>>>>          }
>>>>>>>> +        public String toString() {
>>>>>>>> +            return super.toString()
>>>>>>>> +                + "[task=[" + task + "], result=[" + result + "]]";
>>>>>>>> +        }
>>>>>>>>      }
>>>>>>>>
>>>>>>>>      /**
>>>>>>>>       * A callable that runs under established access control
>>>>>>>> settings.
>>>>>>>>       */
>>>>>>>>      private static final class PrivilegedCallable<T> implements
>>>>>>>> Callable<T> {
>>>>>>>>          final Callable<T> task;
>>>>>>>>          final AccessControlContext acc;
>>>>>>>>
>>>>>>>>          PrivilegedCallable(Callable<T> task) {
>>>>>>>> @@ -504,20 +508,24 @@
>>>>>>>>                  return AccessController.doPrivileged(
>>>>>>>>                      new PrivilegedExceptionAction<T>() {
>>>>>>>>                          public T run() throws Exception {
>>>>>>>>                              return task.call();
>>>>>>>>                          }
>>>>>>>>                      }, acc);
>>>>>>>>              } catch (PrivilegedActionException e) {
>>>>>>>>                  throw e.getException();
>>>>>>>>              }
>>>>>>>>          }
>>>>>>>> +
>>>>>>>> +        public String toString() {
>>>>>>>> +            return super.toString() + "[task=[" + task + "]]";
>>>>>>>> +        }
>>>>>>>>      }
>>>>>>>>
>>>>>>>>      /**
>>>>>>>>       * A callable that runs under established access control
>>>>>>>> settings and
>>>>>>>>       * current ClassLoader.
>>>>>>>>       */
>>>>>>>>      private static final class PrivilegedCallableUsingCurrent
>>>>>>>> ClassLoader<T>
>>>>>>>>              implements Callable<T> {
>>>>>>>>          final Callable<T> task;
>>>>>>>>          final AccessControlContext acc;
>>>>>>>> @@ -556,20 +564,24 @@
>>>>>>>>                                  } finally {
>>>>>>>>                                      t.setContextClassLoader(cl);
>>>>>>>>                                  }
>>>>>>>>                              }
>>>>>>>>                          }
>>>>>>>>                      }, acc);
>>>>>>>>              } catch (PrivilegedActionException e) {
>>>>>>>>                  throw e.getException();
>>>>>>>>              }
>>>>>>>>          }
>>>>>>>> +
>>>>>>>> +        public String toString() {
>>>>>>>> +            return super.toString() + "[task=[" + task + "]]";
>>>>>>>> +        }
>>>>>>>>      }
>>>>>>>>
>>>>>>>>      /**
>>>>>>>>       * The default thread factory.
>>>>>>>>       */
>>>>>>>>      private static class DefaultThreadFactory implements
>>>>>>>> ThreadFactory {
>>>>>>>>          private static final AtomicInteger poolNumber = new
>>>>>>>> AtomicInteger(1);
>>>>>>>>          private final ThreadGroup group;
>>>>>>>>          private final AtomicInteger threadNumber = new
>>>>>>>> AtomicInteger(1);
>>>>>>>>          private final String namePrefix;
>>>>>>>> Index: ForkJoinTask.java
>>>>>>>> ===================================================================
>>>>>>>> RCS file: /export/home/jsr166/jsr166/jsr
>>>>>>>> 166/src/main/java/util/concurrent/ForkJoinTask.java,v
>>>>>>>> retrieving revision 1.115
>>>>>>>> diff -u -U 10 -r1.115 ForkJoinTask.java
>>>>>>>> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
>>>>>>>> +++ ForkJoinTask.java 9 Aug 2017 01:34:25 -0000
>>>>>>>> @@ -1339,37 +1339,43 @@
>>>>>>>>          T result;
>>>>>>>>          AdaptedRunnable(Runnable runnable, T result) {
>>>>>>>>              if (runnable == null) throw new NullPointerException();
>>>>>>>>              this.runnable = runnable;
>>>>>>>>              this.result = result; // OK to set this even before
>>>>>>>> completion
>>>>>>>>          }
>>>>>>>>          public final T getRawResult() { return result; }
>>>>>>>>          public final void setRawResult(T v) { result = v; }
>>>>>>>>          public final boolean exec() { runnable.run(); return true;
>>>>>>>> }
>>>>>>>>          public final void run() { invoke(); }
>>>>>>>> +        public String toString() {
>>>>>>>> +            return super.toString() + "[task=[" + runnable + "],
>>>>>>>> result=[" + result + "]]";
>>>>>>>> +        }
>>>>>>>>          private static final long serialVersionUID =
>>>>>>>> 5232453952276885070L;
>>>>>>>>      }
>>>>>>>>
>>>>>>>>      /**
>>>>>>>>       * Adapter for Runnables without results.
>>>>>>>>       */
>>>>>>>>      static final class AdaptedRunnableAction extends
>>>>>>>> ForkJoinTask<Void>
>>>>>>>>          implements RunnableFuture<Void> {
>>>>>>>>          final Runnable runnable;
>>>>>>>>          AdaptedRunnableAction(Runnable runnable) {
>>>>>>>>              if (runnable == null) throw new NullPointerException();
>>>>>>>>              this.runnable = runnable;
>>>>>>>>          }
>>>>>>>>          public final Void getRawResult() { return null; }
>>>>>>>>          public final void setRawResult(Void v) { }
>>>>>>>>          public final boolean exec() { runnable.run(); return true;
>>>>>>>> }
>>>>>>>>          public final void run() { invoke(); }
>>>>>>>> +        public String toString() {
>>>>>>>> +            return super.toString() + "[task=[" + runnable + "]]";
>>>>>>>> +        }
>>>>>>>>          private static final long serialVersionUID =
>>>>>>>> 5232453952276885070L;
>>>>>>>>      }
>>>>>>>>
>>>>>>>>      /**
>>>>>>>>       * Adapter for Runnables in which failure forces worker
>>>>>>>> exception.
>>>>>>>>       */
>>>>>>>>      static final class RunnableExecuteAction extends
>>>>>>>> ForkJoinTask<Void> {
>>>>>>>>          final Runnable runnable;
>>>>>>>>          RunnableExecuteAction(Runnable runnable) {
>>>>>>>>              if (runnable == null) throw new NullPointerException();
>>>>>>>> @@ -1402,20 +1408,23 @@
>>>>>>>>                  result = callable.call();
>>>>>>>>                  return true;
>>>>>>>>              } catch (RuntimeException rex) {
>>>>>>>>                  throw rex;
>>>>>>>>              } catch (Exception ex) {
>>>>>>>>                  throw new RuntimeException(ex);
>>>>>>>>              }
>>>>>>>>          }
>>>>>>>>          public final void run() { invoke(); }
>>>>>>>>          private static final long serialVersionUID =
>>>>>>>> 2838392045355241008L;
>>>>>>>> +        public String toString() {
>>>>>>>> +            return super.toString() + "[task=[" + callable + "]]";
>>>>>>>> +        }
>>>>>>>>      }
>>>>>>>>
>>>>>>>>      /**
>>>>>>>>       * Returns a new {@code ForkJoinTask} that performs the {@code
>>>>>>>> run}
>>>>>>>>       * method of the given {@code Runnable} as its action, and
>>>>>>>> returns
>>>>>>>>       * a null result upon {@link #join}.
>>>>>>>>       *
>>>>>>>>       * @param runnable the runnable action
>>>>>>>>       * @return the task
>>>>>>>>       */
>>>>>>>> Index: FutureTask.java
>>>>>>>> ===================================================================
>>>>>>>> RCS file: /export/home/jsr166/jsr166/jsr
>>>>>>>> 166/src/main/java/util/concurrent/FutureTask.java,v
>>>>>>>> retrieving revision 1.118
>>>>>>>> diff -u -U 10 -r1.118 FutureTask.java
>>>>>>>> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
>>>>>>>> +++ FutureTask.java 9 Aug 2017 01:34:25 -0000
>>>>>>>> @@ -444,20 +444,49 @@
>>>>>>>>                              continue retry;
>>>>>>>>                      }
>>>>>>>>                      else if (!WAITERS.compareAndSet(this, q, s))
>>>>>>>>                          continue retry;
>>>>>>>>                  }
>>>>>>>>                  break;
>>>>>>>>              }
>>>>>>>>          }
>>>>>>>>      }
>>>>>>>>
>>>>>>>> +    public String toString() {
>>>>>>>> +        String start = super.toString() + "[status=";
>>>>>>>> +        try {
>>>>>>>> +            switch (state) {
>>>>>>>> +            case NEW:
>>>>>>>> +            case COMPLETING:
>>>>>>>> +                final Callable<?> callable = this.callable;
>>>>>>>> +                if (callable != null) {
>>>>>>>> +                    return start + "PENDING, task=[" + callable +
>>>>>>>> "]]";
>>>>>>>> +                } else {
>>>>>>>> +                    return start + "PENDING]";
>>>>>>>> +                }
>>>>>>>> +            case NORMAL:
>>>>>>>> +                return start + "SUCCESS, result=[" + outcome +
>>>>>>>> "]]";
>>>>>>>> +            case EXCEPTIONAL:
>>>>>>>> +                return start + "FAILURE, cause=[" + outcome + "]]";
>>>>>>>> +            case CANCELLED:
>>>>>>>> +            case INTERRUPTING:
>>>>>>>> +            case INTERRUPTED:
>>>>>>>> +                return start + "CANCELLED]";
>>>>>>>> +            default:
>>>>>>>> +                throw new IllegalStateException();
>>>>>>>> +            }
>>>>>>>> +        } catch (RuntimeException thrownFromToString) {
>>>>>>>> +            return start + "UNKNOWN, cause=["
>>>>>>>> +                + thrownFromToString.getClass() + "]";
>>>>>>>> +        }
>>>>>>>> +    }
>>>>>>>> +
>>>>>>>>      // VarHandle mechanics
>>>>>>>>      private static final VarHandle STATE;
>>>>>>>>      private static final VarHandle RUNNER;
>>>>>>>>      private static final VarHandle WAITERS;
>>>>>>>>      static {
>>>>>>>>          try {
>>>>>>>>              MethodHandles.Lookup l = MethodHandles.lookup();
>>>>>>>>              STATE = l.findVarHandle(FutureTask.class, "state",
>>>>>>>> int.class);
>>>>>>>>              RUNNER = l.findVarHandle(FutureTask.class, "runner",
>>>>>>>> Thread.class);
>>>>>>>>              WAITERS = l.findVarHandle(FutureTask.class,
>>>>>>>> "waiters", WaitNode.class);
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170811/14cdc038/attachment-0001.html>

From joe.bowbeer at gmail.com  Fri Aug 11 20:08:07 2017
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri, 11 Aug 2017 17:08:07 -0700
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CAHzJPErRU0rDAMbdk2rTO5QB-QSKc8bUuZT0R+N8h2ZnDHWHjw@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
 <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
 <CAHktk4g6XaP--9QTn5BORDqD43Th3ag0XtJsbe+fQhtPoKCLxw@mail.gmail.com>
 <CAHzJPEpgWQR8wyarTj_thU9tSEqz8cpoMtFqmK+Q+WD0XoATMA@mail.gmail.com>
 <CAGu0=MOeVhowQ9kFgoVRiukmzBpinVZa5AOFcsxUiCkSTDe_JA@mail.gmail.com>
 <CAHktk4jTJ=3B0Xgwt+h6-58LGdQqdZa7zin5ZC7B2G41qbMiNw@mail.gmail.com>
 <CAHzJPEpJ52Xdf0Rcsf_9b3go=g66DFarBXn20swrWLWr7u3s+A@mail.gmail.com>
 <CA+kOe09HHF+u4LvXn5FP2j02CvJn4T_KU0awTCZWh9-AweJy2w@mail.gmail.com>
 <CAHzJPErRU0rDAMbdk2rTO5QB-QSKc8bUuZT0R+N8h2ZnDHWHjw@mail.gmail.com>
Message-ID: <CAHzJPEpJnHS1M_76qPfKq-8c6_O5=oh_Kw2=0axHZ-6p7nES6w@mail.gmail.com>

Martin, it wasn't clear to me whether you are proposing this for some
future major release or not. Java 10, for example, or whatever the next
train is. That seems like the right time to make the broader change that
you are suggesting, which, as you say wrote, has the potential for trouble.


On Fri, Aug 11, 2017 at 4:31 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> I would not assume that calling toString is safe or desirable, for the
> various reasons I listed.
>
> These toString implementations have not existed for a dozen years, yet
> their lack of existence has never been mentioned on this list (right?), so
> I would err on the side of caution.
>
> On Aug 11, 2017 4:16 PM, "Martin Buchholz" <martinrb at google.com> wrote:
>
>> I propose the variant below, which is generally useful and assumes that
>> calling toString on tasks and exceptions is safe, but calling toString on
>> results is not.  If y'all are happy with that, we can add docs (for
>> FutureTask.toString) and tests.
>>
>> Index: Executors.java
>> ===================================================================
>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>> ent/Executors.java,v
>> retrieving revision 1.97
>> diff -u -r1.97 Executors.java
>> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
>> +++ Executors.java 11 Aug 2017 23:12:14 -0000
>> @@ -485,6 +485,9 @@
>>              task.run();
>>              return result;
>>          }
>> +        public String toString() {
>> +            return super.toString() + "[wrapped task = " + task + "]";
>> +        }
>>      }
>>
>>      /**
>> @@ -511,6 +514,10 @@
>>                  throw e.getException();
>>              }
>>          }
>> +
>> +        public String toString() {
>> +            return super.toString() + "[wrapped task = " + task + "]";
>> +        }
>>      }
>>
>>      /**
>> @@ -563,6 +570,10 @@
>>                  throw e.getException();
>>              }
>>          }
>> +
>> +        public String toString() {
>> +            return super.toString() + "[wrapped task = " + task + "]";
>> +        }
>>      }
>>
>>      /**
>> Index: ForkJoinTask.java
>> ===================================================================
>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>> ent/ForkJoinTask.java,v
>> retrieving revision 1.115
>> diff -u -r1.115 ForkJoinTask.java
>> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
>> +++ ForkJoinTask.java 11 Aug 2017 23:12:14 -0000
>> @@ -1346,6 +1346,9 @@
>>          public final void setRawResult(T v) { result = v; }
>>          public final boolean exec() { runnable.run(); return true; }
>>          public final void run() { invoke(); }
>> +        public String toString() {
>> +            return super.toString() + "[wrapped task = " + runnable +
>> "]";
>> +        }
>>          private static final long serialVersionUID =
>> 5232453952276885070L;
>>      }
>>
>> @@ -1363,6 +1366,9 @@
>>          public final void setRawResult(Void v) { }
>>          public final boolean exec() { runnable.run(); return true; }
>>          public final void run() { invoke(); }
>> +        public String toString() {
>> +            return super.toString() + "[wrapped task = " + runnable +
>> "]";
>> +        }
>>          private static final long serialVersionUID =
>> 5232453952276885070L;
>>      }
>>
>> @@ -1409,6 +1415,9 @@
>>          }
>>          public final void run() { invoke(); }
>>          private static final long serialVersionUID =
>> 2838392045355241008L;
>> +        public String toString() {
>> +            return super.toString() + "[wrapped task = " + callable +
>> "]";
>> +        }
>>      }
>>
>>      /**
>> Index: FutureTask.java
>> ===================================================================
>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>> ent/FutureTask.java,v
>> retrieving revision 1.118
>> diff -u -r1.118 FutureTask.java
>> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
>> +++ FutureTask.java 11 Aug 2017 23:12:14 -0000
>> @@ -451,6 +451,27 @@
>>          }
>>      }
>>
>> +    public String toString() {
>> +        final String status;
>> +        switch (state) {
>> +        case NORMAL:
>> +            status = "[completed normally]";
>> +            break;
>> +        case EXCEPTIONAL:
>> +            status = "[completed exceptionally: " + outcome + "]";
>> +            break;
>> +        case CANCELLED:
>> +            status = "[cancelled]";
>> +            break;
>> +        default:
>> +            final Callable<?> callable = this.callable;
>> +            status = (callable == null)
>> +                ? "[incomplete]"
>> +                : "[incomplete, task = " + callable + "]";
>> +        }
>> +        return super.toString() + status;
>> +    }
>> +
>>      // VarHandle mechanics
>>      private static final VarHandle STATE;
>>      private static final VarHandle RUNNER;
>>
>>
>> On Fri, Aug 11, 2017 at 10:09 AM, Joe Bowbeer <joe.bowbeer at gmail.com>
>> wrote:
>>
>>> Yes, that minimal enhancement seems safe and efficient.
>>>
>>> On Wed, Aug 9, 2017 at 10:55 AM Charles Munger <clm at google.com> wrote:
>>>
>>>> How about starting by adding the following toString method to the
>>>> adapter classes:
>>>>
>>>> @Override
>>>> public String toString() {
>>>>    return super.toString() + "[" + task.getClass().getName() + '@' +
>>>> Integer.toHexString(System.identityHashCode(task)) + "]";
>>>> }
>>>>
>>>> That produces bounded output size, exposes no PII, doesn't risk an
>>>> exception or thread safety issues, and still provides enhanced debugging
>>>> output. In fact, for nearly all implementations of Runnable and Callable,
>>>> the class name and identity hash is all the useful output that someone
>>>> needs.
>>>>
>>>> On Wed, Aug 9, 2017 at 10:29 AM, Benjamin Manes <ben.manes at gmail.com>
>>>> wrote:
>>>>
>>>>> I would be comfortable with a toString() showing the task's class and
>>>>> other high level state of owned fields, but not if calling foreign code
>>>>> like the value's toString(). However, I can't think of a case where this
>>>>> would have significantly helpful when debugging, so I am neutral between
>>>>> minimal or no changes.
>>>>>
>>>>> On Wed, Aug 9, 2017 at 10:10 AM, Joe Bowbeer <joe.bowbeer at gmail.com>
>>>>> wrote:
>>>>>
>>>>>> RunnableAdapter is an interesting case. I'd have most of the same
>>>>>> concerns as before, to a slightly less extent. This would not be an API
>>>>>> change, however.
>>>>>>
>>>>>> The style adopted by Java so far has been that j.u.c. objects don't
>>>>>> by default reveal their internal state. It has been up to devs to opt in,
>>>>>> based on their particular needs, and some devs rightly or wrongly rely on
>>>>>> the format inherited from Object.
>>>>>>
>>>>>> If Guava or other libraries want to enhance this, that can be their
>>>>>> value added.
>>>>>>
>>>>>> By the way, adding to my previous list of concerns, I'd also be
>>>>>> concerned about leaking PI in log messages. This is related to my concern
>>>>>> about the wrapped toString impl. being designed for use in a different
>>>>>> context.
>>>>>>
>>>>>> On Wed, Aug 9, 2017 at 9:19 AM Charles Munger <clm at google.com> wrote:
>>>>>>
>>>>>>> I added similar toString implementations to guava's Future
>>>>>>> implementations:
>>>>>>> https://github.com/google/guava/commit/304c634d977127085b49f
>>>>>>> 174fd1aafefd09b2bf5
>>>>>>>
>>>>>>> The attraction of toString on common Future implementations is that
>>>>>>> propagating toString throughout a graph of transformed Futures lets you see
>>>>>>> what a task is doing before it completes, either in a TimeoutException
>>>>>>> message or the toString of LockSupport.getBlocker.
>>>>>>>
>>>>>>> Do you feel that adding toString to RunnableAdapter (and similar
>>>>>>> classes, that are only exposed in public API as interfaces) would also
>>>>>>> constitute an API change?
>>>>>>>
>>>>>>> On Tue, Aug 8, 2017 at 6:58 PM, Joe Bowbeer <joe.bowbeer at gmail.com>
>>>>>>> wrote:
>>>>>>>
>>>>>>>> ​I would consider this to be an API change. For example, according
>>>>>>>> to the current javadoc, FutureTask's toString method is inherited from
>>>>>>>> Object.
>>>>>>>>
>>>>>>>> Practically speaking, I'd be concerned about unexpected and
>>>>>>>> unwanted changes to the output/log statements of programs that have up
>>>>>>>> until now been working fine. In addition to generating a lot of output that
>>>>>>>> may be unwanted, this may also generate exceptions. For example,
>>>>>>>> PrivilegedCallable.toString calls the toString method of the wrapped
>>>>>>>> Callable, which may never have been called previously (bam!), and therefore
>>>>>>>> might throw an exception. Or, the toString method of the wrapped callable
>>>>>>>> may have been designed to be called in a different context.
>>>>>>>>
>>>>>>>> If any of the state the toString implementations are accessing is
>>>>>>>> not thread-safe, I'd also be concerned about that.
>>>>>>>>
>>>>>>>> If tasks need toString implementations, I prefer to write them.​
>>>>>>>>
>>>>>>>> However, I think it would be OK to introduce new convenience
>>>>>>>> methods: debugString()
>>>>>>>>
>>>>>>>> On Tue, Aug 8, 2017 at 6:36 PM, Martin Buchholz <
>>>>>>>> martinrb at google.com> wrote:
>>>>>>>>
>>>>>>>>> My colleague Charles Munger suggests adding toString methods to
>>>>>>>>> various task classes in j.u.c.  Obviously this makes it easier to debug
>>>>>>>>> large programs that have gone wrong.  But it obviously also is a behavior
>>>>>>>>> change that has the potential for trouble, even when everyone is behaving
>>>>>>>>> nicely, since toString may have the effect of generating an unbounded
>>>>>>>>> output.  I almost started down this road myself a few years ago but
>>>>>>>>> chickened out.  What do you think?
>>>>>>>>>
>>>>>>>>> Index: Executors.java
>>>>>>>>> ============================================================
>>>>>>>>> =======
>>>>>>>>> RCS file: /export/home/jsr166/jsr166/jsr
>>>>>>>>> 166/src/main/java/util/concurrent/Executors.java,v
>>>>>>>>> retrieving revision 1.97
>>>>>>>>> diff -u -U 10 -r1.97 Executors.java
>>>>>>>>> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
>>>>>>>>> +++ Executors.java 9 Aug 2017 01:34:25 -0000
>>>>>>>>> @@ -478,20 +478,24 @@
>>>>>>>>>          private final Runnable task;
>>>>>>>>>          private final T result;
>>>>>>>>>          RunnableAdapter(Runnable task, T result) {
>>>>>>>>>              this.task = task;
>>>>>>>>>              this.result = result;
>>>>>>>>>          }
>>>>>>>>>          public T call() {
>>>>>>>>>              task.run();
>>>>>>>>>              return result;
>>>>>>>>>          }
>>>>>>>>> +        public String toString() {
>>>>>>>>> +            return super.toString()
>>>>>>>>> +                + "[task=[" + task + "], result=[" + result +
>>>>>>>>> "]]";
>>>>>>>>> +        }
>>>>>>>>>      }
>>>>>>>>>
>>>>>>>>>      /**
>>>>>>>>>       * A callable that runs under established access control
>>>>>>>>> settings.
>>>>>>>>>       */
>>>>>>>>>      private static final class PrivilegedCallable<T> implements
>>>>>>>>> Callable<T> {
>>>>>>>>>          final Callable<T> task;
>>>>>>>>>          final AccessControlContext acc;
>>>>>>>>>
>>>>>>>>>          PrivilegedCallable(Callable<T> task) {
>>>>>>>>> @@ -504,20 +508,24 @@
>>>>>>>>>                  return AccessController.doPrivileged(
>>>>>>>>>                      new PrivilegedExceptionAction<T>() {
>>>>>>>>>                          public T run() throws Exception {
>>>>>>>>>                              return task.call();
>>>>>>>>>                          }
>>>>>>>>>                      }, acc);
>>>>>>>>>              } catch (PrivilegedActionException e) {
>>>>>>>>>                  throw e.getException();
>>>>>>>>>              }
>>>>>>>>>          }
>>>>>>>>> +
>>>>>>>>> +        public String toString() {
>>>>>>>>> +            return super.toString() + "[task=[" + task + "]]";
>>>>>>>>> +        }
>>>>>>>>>      }
>>>>>>>>>
>>>>>>>>>      /**
>>>>>>>>>       * A callable that runs under established access control
>>>>>>>>> settings and
>>>>>>>>>       * current ClassLoader.
>>>>>>>>>       */
>>>>>>>>>      private static final class PrivilegedCallableUsingCurrent
>>>>>>>>> ClassLoader<T>
>>>>>>>>>              implements Callable<T> {
>>>>>>>>>          final Callable<T> task;
>>>>>>>>>          final AccessControlContext acc;
>>>>>>>>> @@ -556,20 +564,24 @@
>>>>>>>>>                                  } finally {
>>>>>>>>>                                      t.setContextClassLoader(cl);
>>>>>>>>>                                  }
>>>>>>>>>                              }
>>>>>>>>>                          }
>>>>>>>>>                      }, acc);
>>>>>>>>>              } catch (PrivilegedActionException e) {
>>>>>>>>>                  throw e.getException();
>>>>>>>>>              }
>>>>>>>>>          }
>>>>>>>>> +
>>>>>>>>> +        public String toString() {
>>>>>>>>> +            return super.toString() + "[task=[" + task + "]]";
>>>>>>>>> +        }
>>>>>>>>>      }
>>>>>>>>>
>>>>>>>>>      /**
>>>>>>>>>       * The default thread factory.
>>>>>>>>>       */
>>>>>>>>>      private static class DefaultThreadFactory implements
>>>>>>>>> ThreadFactory {
>>>>>>>>>          private static final AtomicInteger poolNumber = new
>>>>>>>>> AtomicInteger(1);
>>>>>>>>>          private final ThreadGroup group;
>>>>>>>>>          private final AtomicInteger threadNumber = new
>>>>>>>>> AtomicInteger(1);
>>>>>>>>>          private final String namePrefix;
>>>>>>>>> Index: ForkJoinTask.java
>>>>>>>>> ============================================================
>>>>>>>>> =======
>>>>>>>>> RCS file: /export/home/jsr166/jsr166/jsr
>>>>>>>>> 166/src/main/java/util/concurrent/ForkJoinTask.java,v
>>>>>>>>> retrieving revision 1.115
>>>>>>>>> diff -u -U 10 -r1.115 ForkJoinTask.java
>>>>>>>>> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
>>>>>>>>> +++ ForkJoinTask.java 9 Aug 2017 01:34:25 -0000
>>>>>>>>> @@ -1339,37 +1339,43 @@
>>>>>>>>>          T result;
>>>>>>>>>          AdaptedRunnable(Runnable runnable, T result) {
>>>>>>>>>              if (runnable == null) throw new
>>>>>>>>> NullPointerException();
>>>>>>>>>              this.runnable = runnable;
>>>>>>>>>              this.result = result; // OK to set this even before
>>>>>>>>> completion
>>>>>>>>>          }
>>>>>>>>>          public final T getRawResult() { return result; }
>>>>>>>>>          public final void setRawResult(T v) { result = v; }
>>>>>>>>>          public final boolean exec() { runnable.run(); return
>>>>>>>>> true; }
>>>>>>>>>          public final void run() { invoke(); }
>>>>>>>>> +        public String toString() {
>>>>>>>>> +            return super.toString() + "[task=[" + runnable + "],
>>>>>>>>> result=[" + result + "]]";
>>>>>>>>> +        }
>>>>>>>>>          private static final long serialVersionUID =
>>>>>>>>> 5232453952276885070L;
>>>>>>>>>      }
>>>>>>>>>
>>>>>>>>>      /**
>>>>>>>>>       * Adapter for Runnables without results.
>>>>>>>>>       */
>>>>>>>>>      static final class AdaptedRunnableAction extends
>>>>>>>>> ForkJoinTask<Void>
>>>>>>>>>          implements RunnableFuture<Void> {
>>>>>>>>>          final Runnable runnable;
>>>>>>>>>          AdaptedRunnableAction(Runnable runnable) {
>>>>>>>>>              if (runnable == null) throw new
>>>>>>>>> NullPointerException();
>>>>>>>>>              this.runnable = runnable;
>>>>>>>>>          }
>>>>>>>>>          public final Void getRawResult() { return null; }
>>>>>>>>>          public final void setRawResult(Void v) { }
>>>>>>>>>          public final boolean exec() { runnable.run(); return
>>>>>>>>> true; }
>>>>>>>>>          public final void run() { invoke(); }
>>>>>>>>> +        public String toString() {
>>>>>>>>> +            return super.toString() + "[task=[" + runnable + "]]";
>>>>>>>>> +        }
>>>>>>>>>          private static final long serialVersionUID =
>>>>>>>>> 5232453952276885070L;
>>>>>>>>>      }
>>>>>>>>>
>>>>>>>>>      /**
>>>>>>>>>       * Adapter for Runnables in which failure forces worker
>>>>>>>>> exception.
>>>>>>>>>       */
>>>>>>>>>      static final class RunnableExecuteAction extends
>>>>>>>>> ForkJoinTask<Void> {
>>>>>>>>>          final Runnable runnable;
>>>>>>>>>          RunnableExecuteAction(Runnable runnable) {
>>>>>>>>>              if (runnable == null) throw new
>>>>>>>>> NullPointerException();
>>>>>>>>> @@ -1402,20 +1408,23 @@
>>>>>>>>>                  result = callable.call();
>>>>>>>>>                  return true;
>>>>>>>>>              } catch (RuntimeException rex) {
>>>>>>>>>                  throw rex;
>>>>>>>>>              } catch (Exception ex) {
>>>>>>>>>                  throw new RuntimeException(ex);
>>>>>>>>>              }
>>>>>>>>>          }
>>>>>>>>>          public final void run() { invoke(); }
>>>>>>>>>          private static final long serialVersionUID =
>>>>>>>>> 2838392045355241008L;
>>>>>>>>> +        public String toString() {
>>>>>>>>> +            return super.toString() + "[task=[" + callable + "]]";
>>>>>>>>> +        }
>>>>>>>>>      }
>>>>>>>>>
>>>>>>>>>      /**
>>>>>>>>>       * Returns a new {@code ForkJoinTask} that performs the
>>>>>>>>> {@code run}
>>>>>>>>>       * method of the given {@code Runnable} as its action, and
>>>>>>>>> returns
>>>>>>>>>       * a null result upon {@link #join}.
>>>>>>>>>       *
>>>>>>>>>       * @param runnable the runnable action
>>>>>>>>>       * @return the task
>>>>>>>>>       */
>>>>>>>>> Index: FutureTask.java
>>>>>>>>> ============================================================
>>>>>>>>> =======
>>>>>>>>> RCS file: /export/home/jsr166/jsr166/jsr
>>>>>>>>> 166/src/main/java/util/concurrent/FutureTask.java,v
>>>>>>>>> retrieving revision 1.118
>>>>>>>>> diff -u -U 10 -r1.118 FutureTask.java
>>>>>>>>> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
>>>>>>>>> +++ FutureTask.java 9 Aug 2017 01:34:25 -0000
>>>>>>>>> @@ -444,20 +444,49 @@
>>>>>>>>>                              continue retry;
>>>>>>>>>                      }
>>>>>>>>>                      else if (!WAITERS.compareAndSet(this, q, s))
>>>>>>>>>                          continue retry;
>>>>>>>>>                  }
>>>>>>>>>                  break;
>>>>>>>>>              }
>>>>>>>>>          }
>>>>>>>>>      }
>>>>>>>>>
>>>>>>>>> +    public String toString() {
>>>>>>>>> +        String start = super.toString() + "[status=";
>>>>>>>>> +        try {
>>>>>>>>> +            switch (state) {
>>>>>>>>> +            case NEW:
>>>>>>>>> +            case COMPLETING:
>>>>>>>>> +                final Callable<?> callable = this.callable;
>>>>>>>>> +                if (callable != null) {
>>>>>>>>> +                    return start + "PENDING, task=[" + callable +
>>>>>>>>> "]]";
>>>>>>>>> +                } else {
>>>>>>>>> +                    return start + "PENDING]";
>>>>>>>>> +                }
>>>>>>>>> +            case NORMAL:
>>>>>>>>> +                return start + "SUCCESS, result=[" + outcome +
>>>>>>>>> "]]";
>>>>>>>>> +            case EXCEPTIONAL:
>>>>>>>>> +                return start + "FAILURE, cause=[" + outcome +
>>>>>>>>> "]]";
>>>>>>>>> +            case CANCELLED:
>>>>>>>>> +            case INTERRUPTING:
>>>>>>>>> +            case INTERRUPTED:
>>>>>>>>> +                return start + "CANCELLED]";
>>>>>>>>> +            default:
>>>>>>>>> +                throw new IllegalStateException();
>>>>>>>>> +            }
>>>>>>>>> +        } catch (RuntimeException thrownFromToString) {
>>>>>>>>> +            return start + "UNKNOWN, cause=["
>>>>>>>>> +                + thrownFromToString.getClass() + "]";
>>>>>>>>> +        }
>>>>>>>>> +    }
>>>>>>>>> +
>>>>>>>>>      // VarHandle mechanics
>>>>>>>>>      private static final VarHandle STATE;
>>>>>>>>>      private static final VarHandle RUNNER;
>>>>>>>>>      private static final VarHandle WAITERS;
>>>>>>>>>      static {
>>>>>>>>>          try {
>>>>>>>>>              MethodHandles.Lookup l = MethodHandles.lookup();
>>>>>>>>>              STATE = l.findVarHandle(FutureTask.class, "state",
>>>>>>>>> int.class);
>>>>>>>>>              RUNNER = l.findVarHandle(FutureTask.class, "runner",
>>>>>>>>> Thread.class);
>>>>>>>>>              WAITERS = l.findVarHandle(FutureTask.class,
>>>>>>>>> "waiters", WaitNode.class);
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170811/985dd81e/attachment-0001.html>

From martinrb at google.com  Fri Aug 11 21:09:05 2017
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 11 Aug 2017 18:09:05 -0700
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CAHzJPEpJnHS1M_76qPfKq-8c6_O5=oh_Kw2=0axHZ-6p7nES6w@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
 <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
 <CAHktk4g6XaP--9QTn5BORDqD43Th3ag0XtJsbe+fQhtPoKCLxw@mail.gmail.com>
 <CAHzJPEpgWQR8wyarTj_thU9tSEqz8cpoMtFqmK+Q+WD0XoATMA@mail.gmail.com>
 <CAGu0=MOeVhowQ9kFgoVRiukmzBpinVZa5AOFcsxUiCkSTDe_JA@mail.gmail.com>
 <CAHktk4jTJ=3B0Xgwt+h6-58LGdQqdZa7zin5ZC7B2G41qbMiNw@mail.gmail.com>
 <CAHzJPEpJ52Xdf0Rcsf_9b3go=g66DFarBXn20swrWLWr7u3s+A@mail.gmail.com>
 <CA+kOe09HHF+u4LvXn5FP2j02CvJn4T_KU0awTCZWh9-AweJy2w@mail.gmail.com>
 <CAHzJPErRU0rDAMbdk2rTO5QB-QSKc8bUuZT0R+N8h2ZnDHWHjw@mail.gmail.com>
 <CAHzJPEpJnHS1M_76qPfKq-8c6_O5=oh_Kw2=0axHZ-6p7nES6w@mail.gmail.com>
Message-ID: <CA+kOe090-KAcjDc-4ihGga1Xs+52SjeuDJFc52+hktsTGHR0zA@mail.gmail.com>

Joe, yes, this is a jdk10 proposal.

An argument for printing exceptions is that those are especially useful for
debugging and inversely, are particularly likely to be designed to have
useful string representations.

An argument for propagating toString contents in adapter classes is that
the adapter class should be as much as possible a drop-in replacement for
the wrapped class, and the wrapper class will not have a toString method
that is less safe than the wrapped class.

Latest version:

Index: Executors.java
===================================================================
RCS file:
/export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/Executors.java,v
retrieving revision 1.97
diff -u -r1.97 Executors.java
--- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
+++ Executors.java 12 Aug 2017 01:08:34 -0000
@@ -485,6 +485,9 @@
             task.run();
             return result;
         }
+        public String toString() {
+            return super.toString() + "[wrapped task = " + task + "]";
+        }
     }

     /**
@@ -511,6 +514,10 @@
                 throw e.getException();
             }
         }
+
+        public String toString() {
+            return super.toString() + "[wrapped task = " + task + "]";
+        }
     }

     /**
@@ -563,6 +570,10 @@
                 throw e.getException();
             }
         }
+
+        public String toString() {
+            return super.toString() + "[wrapped task = " + task + "]";
+        }
     }

     /**
Index: ForkJoinTask.java
===================================================================
RCS file:
/export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/ForkJoinTask.java,v
retrieving revision 1.115
diff -u -r1.115 ForkJoinTask.java
--- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
+++ ForkJoinTask.java 12 Aug 2017 01:08:34 -0000
@@ -1346,6 +1346,9 @@
         public final void setRawResult(T v) { result = v; }
         public final boolean exec() { runnable.run(); return true; }
         public final void run() { invoke(); }
+        public String toString() {
+            return super.toString() + "[wrapped task = " + runnable + "]";
+        }
         private static final long serialVersionUID = 5232453952276885070L;
     }

@@ -1363,6 +1366,9 @@
         public final void setRawResult(Void v) { }
         public final boolean exec() { runnable.run(); return true; }
         public final void run() { invoke(); }
+        public String toString() {
+            return super.toString() + "[wrapped task = " + runnable + "]";
+        }
         private static final long serialVersionUID = 5232453952276885070L;
     }

@@ -1409,6 +1415,9 @@
         }
         public final void run() { invoke(); }
         private static final long serialVersionUID = 2838392045355241008L;
+        public String toString() {
+            return super.toString() + "[wrapped task = " + callable + "]";
+        }
     }

     /**
Index: FutureTask.java
===================================================================
RCS file:
/export/home/jsr166/jsr166/jsr166/src/main/java/util/concurrent/FutureTask.java,v
retrieving revision 1.118
diff -u -r1.118 FutureTask.java
--- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
+++ FutureTask.java 12 Aug 2017 01:08:34 -0000
@@ -451,6 +451,29 @@
         }
     }

+    public String toString() {
+        final String status;
+        switch (state) {
+        case NORMAL:
+            status = "[completed normally]";
+            break;
+        case EXCEPTIONAL:
+            status = "[completed exceptionally: " + outcome + "]";
+            break;
+        case CANCELLED:
+        case INTERRUPTING:
+        case INTERRUPTED:
+            status = "[cancelled]";
+            break;
+        default:
+            final Callable<?> callable = this.callable;
+            status = (callable == null)
+                ? "[incomplete]"
+                : "[incomplete, task = " + callable + "]";
+        }
+        return super.toString() + status;
+    }
+
     // VarHandle mechanics
     private static final VarHandle STATE;
     private static final VarHandle RUNNER;



On Fri, Aug 11, 2017 at 5:08 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> Martin, it wasn't clear to me whether you are proposing this for some
> future major release or not. Java 10, for example, or whatever the next
> train is. That seems like the right time to make the broader change that
> you are suggesting, which, as you say wrote, has the potential for trouble.
>
>
> On Fri, Aug 11, 2017 at 4:31 PM, Joe Bowbeer <joe.bowbeer at gmail.com>
> wrote:
>
>> I would not assume that calling toString is safe or desirable, for the
>> various reasons I listed.
>>
>> These toString implementations have not existed for a dozen years, yet
>> their lack of existence has never been mentioned on this list (right?), so
>> I would err on the side of caution.
>>
>> On Aug 11, 2017 4:16 PM, "Martin Buchholz" <martinrb at google.com> wrote:
>>
>>> I propose the variant below, which is generally useful and assumes that
>>> calling toString on tasks and exceptions is safe, but calling toString on
>>> results is not.  If y'all are happy with that, we can add docs (for
>>> FutureTask.toString) and tests.
>>>
>>> Index: Executors.java
>>> ===================================================================
>>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>>> ent/Executors.java,v
>>> retrieving revision 1.97
>>> diff -u -r1.97 Executors.java
>>> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
>>> +++ Executors.java 11 Aug 2017 23:12:14 -0000
>>> @@ -485,6 +485,9 @@
>>>              task.run();
>>>              return result;
>>>          }
>>> +        public String toString() {
>>> +            return super.toString() + "[wrapped task = " + task + "]";
>>> +        }
>>>      }
>>>
>>>      /**
>>> @@ -511,6 +514,10 @@
>>>                  throw e.getException();
>>>              }
>>>          }
>>> +
>>> +        public String toString() {
>>> +            return super.toString() + "[wrapped task = " + task + "]";
>>> +        }
>>>      }
>>>
>>>      /**
>>> @@ -563,6 +570,10 @@
>>>                  throw e.getException();
>>>              }
>>>          }
>>> +
>>> +        public String toString() {
>>> +            return super.toString() + "[wrapped task = " + task + "]";
>>> +        }
>>>      }
>>>
>>>      /**
>>> Index: ForkJoinTask.java
>>> ===================================================================
>>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>>> ent/ForkJoinTask.java,v
>>> retrieving revision 1.115
>>> diff -u -r1.115 ForkJoinTask.java
>>> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
>>> +++ ForkJoinTask.java 11 Aug 2017 23:12:14 -0000
>>> @@ -1346,6 +1346,9 @@
>>>          public final void setRawResult(T v) { result = v; }
>>>          public final boolean exec() { runnable.run(); return true; }
>>>          public final void run() { invoke(); }
>>> +        public String toString() {
>>> +            return super.toString() + "[wrapped task = " + runnable +
>>> "]";
>>> +        }
>>>          private static final long serialVersionUID =
>>> 5232453952276885070L;
>>>      }
>>>
>>> @@ -1363,6 +1366,9 @@
>>>          public final void setRawResult(Void v) { }
>>>          public final boolean exec() { runnable.run(); return true; }
>>>          public final void run() { invoke(); }
>>> +        public String toString() {
>>> +            return super.toString() + "[wrapped task = " + runnable +
>>> "]";
>>> +        }
>>>          private static final long serialVersionUID =
>>> 5232453952276885070L;
>>>      }
>>>
>>> @@ -1409,6 +1415,9 @@
>>>          }
>>>          public final void run() { invoke(); }
>>>          private static final long serialVersionUID =
>>> 2838392045355241008L;
>>> +        public String toString() {
>>> +            return super.toString() + "[wrapped task = " + callable +
>>> "]";
>>> +        }
>>>      }
>>>
>>>      /**
>>> Index: FutureTask.java
>>> ===================================================================
>>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>>> ent/FutureTask.java,v
>>> retrieving revision 1.118
>>> diff -u -r1.118 FutureTask.java
>>> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
>>> +++ FutureTask.java 11 Aug 2017 23:12:14 -0000
>>> @@ -451,6 +451,27 @@
>>>          }
>>>      }
>>>
>>> +    public String toString() {
>>> +        final String status;
>>> +        switch (state) {
>>> +        case NORMAL:
>>> +            status = "[completed normally]";
>>> +            break;
>>> +        case EXCEPTIONAL:
>>> +            status = "[completed exceptionally: " + outcome + "]";
>>> +            break;
>>> +        case CANCELLED:
>>> +            status = "[cancelled]";
>>> +            break;
>>> +        default:
>>> +            final Callable<?> callable = this.callable;
>>> +            status = (callable == null)
>>> +                ? "[incomplete]"
>>> +                : "[incomplete, task = " + callable + "]";
>>> +        }
>>> +        return super.toString() + status;
>>> +    }
>>> +
>>>      // VarHandle mechanics
>>>      private static final VarHandle STATE;
>>>      private static final VarHandle RUNNER;
>>>
>>>
>>> On Fri, Aug 11, 2017 at 10:09 AM, Joe Bowbeer <joe.bowbeer at gmail.com>
>>> wrote:
>>>
>>>> Yes, that minimal enhancement seems safe and efficient.
>>>>
>>>> On Wed, Aug 9, 2017 at 10:55 AM Charles Munger <clm at google.com> wrote:
>>>>
>>>>> How about starting by adding the following toString method to the
>>>>> adapter classes:
>>>>>
>>>>> @Override
>>>>> public String toString() {
>>>>>    return super.toString() + "[" + task.getClass().getName() + '@' +
>>>>> Integer.toHexString(System.identityHashCode(task)) + "]";
>>>>> }
>>>>>
>>>>> That produces bounded output size, exposes no PII, doesn't risk an
>>>>> exception or thread safety issues, and still provides enhanced debugging
>>>>> output. In fact, for nearly all implementations of Runnable and Callable,
>>>>> the class name and identity hash is all the useful output that someone
>>>>> needs.
>>>>>
>>>>> On Wed, Aug 9, 2017 at 10:29 AM, Benjamin Manes <ben.manes at gmail.com>
>>>>> wrote:
>>>>>
>>>>>> I would be comfortable with a toString() showing the task's class and
>>>>>> other high level state of owned fields, but not if calling foreign code
>>>>>> like the value's toString(). However, I can't think of a case where this
>>>>>> would have significantly helpful when debugging, so I am neutral between
>>>>>> minimal or no changes.
>>>>>>
>>>>>> On Wed, Aug 9, 2017 at 10:10 AM, Joe Bowbeer <joe.bowbeer at gmail.com>
>>>>>> wrote:
>>>>>>
>>>>>>> RunnableAdapter is an interesting case. I'd have most of the same
>>>>>>> concerns as before, to a slightly less extent. This would not be an API
>>>>>>> change, however.
>>>>>>>
>>>>>>> The style adopted by Java so far has been that j.u.c. objects don't
>>>>>>> by default reveal their internal state. It has been up to devs to opt in,
>>>>>>> based on their particular needs, and some devs rightly or wrongly rely on
>>>>>>> the format inherited from Object.
>>>>>>>
>>>>>>> If Guava or other libraries want to enhance this, that can be their
>>>>>>> value added.
>>>>>>>
>>>>>>> By the way, adding to my previous list of concerns, I'd also be
>>>>>>> concerned about leaking PI in log messages. This is related to my concern
>>>>>>> about the wrapped toString impl. being designed for use in a different
>>>>>>> context.
>>>>>>>
>>>>>>> On Wed, Aug 9, 2017 at 9:19 AM Charles Munger <clm at google.com>
>>>>>>> wrote:
>>>>>>>
>>>>>>>> I added similar toString implementations to guava's Future
>>>>>>>> implementations:
>>>>>>>> https://github.com/google/guava/commit/304c634d977127085b49f
>>>>>>>> 174fd1aafefd09b2bf5
>>>>>>>>
>>>>>>>> The attraction of toString on common Future implementations is that
>>>>>>>> propagating toString throughout a graph of transformed Futures lets you see
>>>>>>>> what a task is doing before it completes, either in a TimeoutException
>>>>>>>> message or the toString of LockSupport.getBlocker.
>>>>>>>>
>>>>>>>> Do you feel that adding toString to RunnableAdapter (and similar
>>>>>>>> classes, that are only exposed in public API as interfaces) would also
>>>>>>>> constitute an API change?
>>>>>>>>
>>>>>>>> On Tue, Aug 8, 2017 at 6:58 PM, Joe Bowbeer <joe.bowbeer at gmail.com>
>>>>>>>> wrote:
>>>>>>>>
>>>>>>>>> ​I would consider this to be an API change. For example, according
>>>>>>>>> to the current javadoc, FutureTask's toString method is inherited from
>>>>>>>>> Object.
>>>>>>>>>
>>>>>>>>> Practically speaking, I'd be concerned about unexpected and
>>>>>>>>> unwanted changes to the output/log statements of programs that have up
>>>>>>>>> until now been working fine. In addition to generating a lot of output that
>>>>>>>>> may be unwanted, this may also generate exceptions. For example,
>>>>>>>>> PrivilegedCallable.toString calls the toString method of the wrapped
>>>>>>>>> Callable, which may never have been called previously (bam!), and therefore
>>>>>>>>> might throw an exception. Or, the toString method of the wrapped callable
>>>>>>>>> may have been designed to be called in a different context.
>>>>>>>>>
>>>>>>>>> If any of the state the toString implementations are accessing is
>>>>>>>>> not thread-safe, I'd also be concerned about that.
>>>>>>>>>
>>>>>>>>> If tasks need toString implementations, I prefer to write them.​
>>>>>>>>>
>>>>>>>>> However, I think it would be OK to introduce new convenience
>>>>>>>>> methods: debugString()
>>>>>>>>>
>>>>>>>>> On Tue, Aug 8, 2017 at 6:36 PM, Martin Buchholz <
>>>>>>>>> martinrb at google.com> wrote:
>>>>>>>>>
>>>>>>>>>> My colleague Charles Munger suggests adding toString methods to
>>>>>>>>>> various task classes in j.u.c.  Obviously this makes it easier to debug
>>>>>>>>>> large programs that have gone wrong.  But it obviously also is a behavior
>>>>>>>>>> change that has the potential for trouble, even when everyone is behaving
>>>>>>>>>> nicely, since toString may have the effect of generating an unbounded
>>>>>>>>>> output.  I almost started down this road myself a few years ago but
>>>>>>>>>> chickened out.  What do you think?
>>>>>>>>>>
>>>>>>>>>> Index: Executors.java
>>>>>>>>>> ============================================================
>>>>>>>>>> =======
>>>>>>>>>> RCS file: /export/home/jsr166/jsr166/jsr
>>>>>>>>>> 166/src/main/java/util/concurrent/Executors.java,v
>>>>>>>>>> retrieving revision 1.97
>>>>>>>>>> diff -u -U 10 -r1.97 Executors.java
>>>>>>>>>> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
>>>>>>>>>> +++ Executors.java 9 Aug 2017 01:34:25 -0000
>>>>>>>>>> @@ -478,20 +478,24 @@
>>>>>>>>>>          private final Runnable task;
>>>>>>>>>>          private final T result;
>>>>>>>>>>          RunnableAdapter(Runnable task, T result) {
>>>>>>>>>>              this.task = task;
>>>>>>>>>>              this.result = result;
>>>>>>>>>>          }
>>>>>>>>>>          public T call() {
>>>>>>>>>>              task.run();
>>>>>>>>>>              return result;
>>>>>>>>>>          }
>>>>>>>>>> +        public String toString() {
>>>>>>>>>> +            return super.toString()
>>>>>>>>>> +                + "[task=[" + task + "], result=[" + result +
>>>>>>>>>> "]]";
>>>>>>>>>> +        }
>>>>>>>>>>      }
>>>>>>>>>>
>>>>>>>>>>      /**
>>>>>>>>>>       * A callable that runs under established access control
>>>>>>>>>> settings.
>>>>>>>>>>       */
>>>>>>>>>>      private static final class PrivilegedCallable<T> implements
>>>>>>>>>> Callable<T> {
>>>>>>>>>>          final Callable<T> task;
>>>>>>>>>>          final AccessControlContext acc;
>>>>>>>>>>
>>>>>>>>>>          PrivilegedCallable(Callable<T> task) {
>>>>>>>>>> @@ -504,20 +508,24 @@
>>>>>>>>>>                  return AccessController.doPrivileged(
>>>>>>>>>>                      new PrivilegedExceptionAction<T>() {
>>>>>>>>>>                          public T run() throws Exception {
>>>>>>>>>>                              return task.call();
>>>>>>>>>>                          }
>>>>>>>>>>                      }, acc);
>>>>>>>>>>              } catch (PrivilegedActionException e) {
>>>>>>>>>>                  throw e.getException();
>>>>>>>>>>              }
>>>>>>>>>>          }
>>>>>>>>>> +
>>>>>>>>>> +        public String toString() {
>>>>>>>>>> +            return super.toString() + "[task=[" + task + "]]";
>>>>>>>>>> +        }
>>>>>>>>>>      }
>>>>>>>>>>
>>>>>>>>>>      /**
>>>>>>>>>>       * A callable that runs under established access control
>>>>>>>>>> settings and
>>>>>>>>>>       * current ClassLoader.
>>>>>>>>>>       */
>>>>>>>>>>      private static final class PrivilegedCallableUsingCurrent
>>>>>>>>>> ClassLoader<T>
>>>>>>>>>>              implements Callable<T> {
>>>>>>>>>>          final Callable<T> task;
>>>>>>>>>>          final AccessControlContext acc;
>>>>>>>>>> @@ -556,20 +564,24 @@
>>>>>>>>>>                                  } finally {
>>>>>>>>>>                                      t.setContextClassLoader(cl);
>>>>>>>>>>                                  }
>>>>>>>>>>                              }
>>>>>>>>>>                          }
>>>>>>>>>>                      }, acc);
>>>>>>>>>>              } catch (PrivilegedActionException e) {
>>>>>>>>>>                  throw e.getException();
>>>>>>>>>>              }
>>>>>>>>>>          }
>>>>>>>>>> +
>>>>>>>>>> +        public String toString() {
>>>>>>>>>> +            return super.toString() + "[task=[" + task + "]]";
>>>>>>>>>> +        }
>>>>>>>>>>      }
>>>>>>>>>>
>>>>>>>>>>      /**
>>>>>>>>>>       * The default thread factory.
>>>>>>>>>>       */
>>>>>>>>>>      private static class DefaultThreadFactory implements
>>>>>>>>>> ThreadFactory {
>>>>>>>>>>          private static final AtomicInteger poolNumber = new
>>>>>>>>>> AtomicInteger(1);
>>>>>>>>>>          private final ThreadGroup group;
>>>>>>>>>>          private final AtomicInteger threadNumber = new
>>>>>>>>>> AtomicInteger(1);
>>>>>>>>>>          private final String namePrefix;
>>>>>>>>>> Index: ForkJoinTask.java
>>>>>>>>>> ============================================================
>>>>>>>>>> =======
>>>>>>>>>> RCS file: /export/home/jsr166/jsr166/jsr
>>>>>>>>>> 166/src/main/java/util/concurrent/ForkJoinTask.java,v
>>>>>>>>>> retrieving revision 1.115
>>>>>>>>>> diff -u -U 10 -r1.115 ForkJoinTask.java
>>>>>>>>>> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
>>>>>>>>>> +++ ForkJoinTask.java 9 Aug 2017 01:34:25 -0000
>>>>>>>>>> @@ -1339,37 +1339,43 @@
>>>>>>>>>>          T result;
>>>>>>>>>>          AdaptedRunnable(Runnable runnable, T result) {
>>>>>>>>>>              if (runnable == null) throw new
>>>>>>>>>> NullPointerException();
>>>>>>>>>>              this.runnable = runnable;
>>>>>>>>>>              this.result = result; // OK to set this even before
>>>>>>>>>> completion
>>>>>>>>>>          }
>>>>>>>>>>          public final T getRawResult() { return result; }
>>>>>>>>>>          public final void setRawResult(T v) { result = v; }
>>>>>>>>>>          public final boolean exec() { runnable.run(); return
>>>>>>>>>> true; }
>>>>>>>>>>          public final void run() { invoke(); }
>>>>>>>>>> +        public String toString() {
>>>>>>>>>> +            return super.toString() + "[task=[" + runnable + "],
>>>>>>>>>> result=[" + result + "]]";
>>>>>>>>>> +        }
>>>>>>>>>>          private static final long serialVersionUID =
>>>>>>>>>> 5232453952276885070L;
>>>>>>>>>>      }
>>>>>>>>>>
>>>>>>>>>>      /**
>>>>>>>>>>       * Adapter for Runnables without results.
>>>>>>>>>>       */
>>>>>>>>>>      static final class AdaptedRunnableAction extends
>>>>>>>>>> ForkJoinTask<Void>
>>>>>>>>>>          implements RunnableFuture<Void> {
>>>>>>>>>>          final Runnable runnable;
>>>>>>>>>>          AdaptedRunnableAction(Runnable runnable) {
>>>>>>>>>>              if (runnable == null) throw new
>>>>>>>>>> NullPointerException();
>>>>>>>>>>              this.runnable = runnable;
>>>>>>>>>>          }
>>>>>>>>>>          public final Void getRawResult() { return null; }
>>>>>>>>>>          public final void setRawResult(Void v) { }
>>>>>>>>>>          public final boolean exec() { runnable.run(); return
>>>>>>>>>> true; }
>>>>>>>>>>          public final void run() { invoke(); }
>>>>>>>>>> +        public String toString() {
>>>>>>>>>> +            return super.toString() + "[task=[" + runnable +
>>>>>>>>>> "]]";
>>>>>>>>>> +        }
>>>>>>>>>>          private static final long serialVersionUID =
>>>>>>>>>> 5232453952276885070L;
>>>>>>>>>>      }
>>>>>>>>>>
>>>>>>>>>>      /**
>>>>>>>>>>       * Adapter for Runnables in which failure forces worker
>>>>>>>>>> exception.
>>>>>>>>>>       */
>>>>>>>>>>      static final class RunnableExecuteAction extends
>>>>>>>>>> ForkJoinTask<Void> {
>>>>>>>>>>          final Runnable runnable;
>>>>>>>>>>          RunnableExecuteAction(Runnable runnable) {
>>>>>>>>>>              if (runnable == null) throw new
>>>>>>>>>> NullPointerException();
>>>>>>>>>> @@ -1402,20 +1408,23 @@
>>>>>>>>>>                  result = callable.call();
>>>>>>>>>>                  return true;
>>>>>>>>>>              } catch (RuntimeException rex) {
>>>>>>>>>>                  throw rex;
>>>>>>>>>>              } catch (Exception ex) {
>>>>>>>>>>                  throw new RuntimeException(ex);
>>>>>>>>>>              }
>>>>>>>>>>          }
>>>>>>>>>>          public final void run() { invoke(); }
>>>>>>>>>>          private static final long serialVersionUID =
>>>>>>>>>> 2838392045355241008L;
>>>>>>>>>> +        public String toString() {
>>>>>>>>>> +            return super.toString() + "[task=[" + callable +
>>>>>>>>>> "]]";
>>>>>>>>>> +        }
>>>>>>>>>>      }
>>>>>>>>>>
>>>>>>>>>>      /**
>>>>>>>>>>       * Returns a new {@code ForkJoinTask} that performs the
>>>>>>>>>> {@code run}
>>>>>>>>>>       * method of the given {@code Runnable} as its action, and
>>>>>>>>>> returns
>>>>>>>>>>       * a null result upon {@link #join}.
>>>>>>>>>>       *
>>>>>>>>>>       * @param runnable the runnable action
>>>>>>>>>>       * @return the task
>>>>>>>>>>       */
>>>>>>>>>> Index: FutureTask.java
>>>>>>>>>> ============================================================
>>>>>>>>>> =======
>>>>>>>>>> RCS file: /export/home/jsr166/jsr166/jsr
>>>>>>>>>> 166/src/main/java/util/concurrent/FutureTask.java,v
>>>>>>>>>> retrieving revision 1.118
>>>>>>>>>> diff -u -U 10 -r1.118 FutureTask.java
>>>>>>>>>> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
>>>>>>>>>> +++ FutureTask.java 9 Aug 2017 01:34:25 -0000
>>>>>>>>>> @@ -444,20 +444,49 @@
>>>>>>>>>>                              continue retry;
>>>>>>>>>>                      }
>>>>>>>>>>                      else if (!WAITERS.compareAndSet(this, q, s))
>>>>>>>>>>                          continue retry;
>>>>>>>>>>                  }
>>>>>>>>>>                  break;
>>>>>>>>>>              }
>>>>>>>>>>          }
>>>>>>>>>>      }
>>>>>>>>>>
>>>>>>>>>> +    public String toString() {
>>>>>>>>>> +        String start = super.toString() + "[status=";
>>>>>>>>>> +        try {
>>>>>>>>>> +            switch (state) {
>>>>>>>>>> +            case NEW:
>>>>>>>>>> +            case COMPLETING:
>>>>>>>>>> +                final Callable<?> callable = this.callable;
>>>>>>>>>> +                if (callable != null) {
>>>>>>>>>> +                    return start + "PENDING, task=[" + callable
>>>>>>>>>> + "]]";
>>>>>>>>>> +                } else {
>>>>>>>>>> +                    return start + "PENDING]";
>>>>>>>>>> +                }
>>>>>>>>>> +            case NORMAL:
>>>>>>>>>> +                return start + "SUCCESS, result=[" + outcome +
>>>>>>>>>> "]]";
>>>>>>>>>> +            case EXCEPTIONAL:
>>>>>>>>>> +                return start + "FAILURE, cause=[" + outcome +
>>>>>>>>>> "]]";
>>>>>>>>>> +            case CANCELLED:
>>>>>>>>>> +            case INTERRUPTING:
>>>>>>>>>> +            case INTERRUPTED:
>>>>>>>>>> +                return start + "CANCELLED]";
>>>>>>>>>> +            default:
>>>>>>>>>> +                throw new IllegalStateException();
>>>>>>>>>> +            }
>>>>>>>>>> +        } catch (RuntimeException thrownFromToString) {
>>>>>>>>>> +            return start + "UNKNOWN, cause=["
>>>>>>>>>> +                + thrownFromToString.getClass() + "]";
>>>>>>>>>> +        }
>>>>>>>>>> +    }
>>>>>>>>>> +
>>>>>>>>>>      // VarHandle mechanics
>>>>>>>>>>      private static final VarHandle STATE;
>>>>>>>>>>      private static final VarHandle RUNNER;
>>>>>>>>>>      private static final VarHandle WAITERS;
>>>>>>>>>>      static {
>>>>>>>>>>          try {
>>>>>>>>>>              MethodHandles.Lookup l = MethodHandles.lookup();
>>>>>>>>>>              STATE = l.findVarHandle(FutureTask.class, "state",
>>>>>>>>>> int.class);
>>>>>>>>>>              RUNNER = l.findVarHandle(FutureTask.class,
>>>>>>>>>> "runner", Thread.class);
>>>>>>>>>>              WAITERS = l.findVarHandle(FutureTask.class,
>>>>>>>>>> "waiters", WaitNode.class);
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170811/26e91e06/attachment-0001.html>

From carfield at carfield.com.hk  Sat Aug 12 01:01:49 2017
From: carfield at carfield.com.hk (Carfield Yim)
Date: Sat, 12 Aug 2017 13:01:49 +0800
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
 <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
Message-ID: <CACfbOvesOQdkqR1EVXZ9QwD558jYNK_OChd6BKtEOPCXi7JyAQ@mail.gmail.com>

Sorry, just a side question, if toString() is not used for debug, what is
the original propose of having it?

On Wed, Aug 9, 2017 at 9:58 AM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> ​I would consider this to be an API change. For example, according to the
> current javadoc, FutureTask's toString method is inherited from Object.
>
> Practically speaking, I'd be concerned about unexpected and unwanted
> changes to the output/log statements of programs that have up until now
> been working fine. In addition to generating a lot of output that may be
> unwanted, this may also generate exceptions. For example,
> PrivilegedCallable.toString calls the toString method of the wrapped
> Callable, which may never have been called previously (bam!), and therefore
> might throw an exception. Or, the toString method of the wrapped callable
> may have been designed to be called in a different context.
>
> If any of the state the toString implementations are accessing is not
> thread-safe, I'd also be concerned about that.
>
> If tasks need toString implementations, I prefer to write them.​
>
> However, I think it would be OK to introduce new convenience methods:
> debugString()
>
> On Tue, Aug 8, 2017 at 6:36 PM, Martin Buchholz <martinrb at google.com>
> wrote:
>
>> My colleague Charles Munger suggests adding toString methods to various
>> task classes in j.u.c.  Obviously this makes it easier to debug large
>> programs that have gone wrong.  But it obviously also is a behavior change
>> that has the potential for trouble, even when everyone is behaving nicely,
>> since toString may have the effect of generating an unbounded output.  I
>> almost started down this road myself a few years ago but chickened out.
>> What do you think?
>>
>> Index: Executors.java
>> ===================================================================
>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>> ent/Executors.java,v
>> retrieving revision 1.97
>> diff -u -U 10 -r1.97 Executors.java
>> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
>> +++ Executors.java 9 Aug 2017 01:34:25 -0000
>> @@ -478,20 +478,24 @@
>>          private final Runnable task;
>>          private final T result;
>>          RunnableAdapter(Runnable task, T result) {
>>              this.task = task;
>>              this.result = result;
>>          }
>>          public T call() {
>>              task.run();
>>              return result;
>>          }
>> +        public String toString() {
>> +            return super.toString()
>> +                + "[task=[" + task + "], result=[" + result + "]]";
>> +        }
>>      }
>>
>>      /**
>>       * A callable that runs under established access control settings.
>>       */
>>      private static final class PrivilegedCallable<T> implements
>> Callable<T> {
>>          final Callable<T> task;
>>          final AccessControlContext acc;
>>
>>          PrivilegedCallable(Callable<T> task) {
>> @@ -504,20 +508,24 @@
>>                  return AccessController.doPrivileged(
>>                      new PrivilegedExceptionAction<T>() {
>>                          public T run() throws Exception {
>>                              return task.call();
>>                          }
>>                      }, acc);
>>              } catch (PrivilegedActionException e) {
>>                  throw e.getException();
>>              }
>>          }
>> +
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + task + "]]";
>> +        }
>>      }
>>
>>      /**
>>       * A callable that runs under established access control settings and
>>       * current ClassLoader.
>>       */
>>      private static final class PrivilegedCallableUsingCurrent
>> ClassLoader<T>
>>              implements Callable<T> {
>>          final Callable<T> task;
>>          final AccessControlContext acc;
>> @@ -556,20 +564,24 @@
>>                                  } finally {
>>                                      t.setContextClassLoader(cl);
>>                                  }
>>                              }
>>                          }
>>                      }, acc);
>>              } catch (PrivilegedActionException e) {
>>                  throw e.getException();
>>              }
>>          }
>> +
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + task + "]]";
>> +        }
>>      }
>>
>>      /**
>>       * The default thread factory.
>>       */
>>      private static class DefaultThreadFactory implements ThreadFactory {
>>          private static final AtomicInteger poolNumber = new
>> AtomicInteger(1);
>>          private final ThreadGroup group;
>>          private final AtomicInteger threadNumber = new AtomicInteger(1);
>>          private final String namePrefix;
>> Index: ForkJoinTask.java
>> ===================================================================
>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>> ent/ForkJoinTask.java,v
>> retrieving revision 1.115
>> diff -u -U 10 -r1.115 ForkJoinTask.java
>> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
>> +++ ForkJoinTask.java 9 Aug 2017 01:34:25 -0000
>> @@ -1339,37 +1339,43 @@
>>          T result;
>>          AdaptedRunnable(Runnable runnable, T result) {
>>              if (runnable == null) throw new NullPointerException();
>>              this.runnable = runnable;
>>              this.result = result; // OK to set this even before
>> completion
>>          }
>>          public final T getRawResult() { return result; }
>>          public final void setRawResult(T v) { result = v; }
>>          public final boolean exec() { runnable.run(); return true; }
>>          public final void run() { invoke(); }
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + runnable + "],
>> result=[" + result + "]]";
>> +        }
>>          private static final long serialVersionUID =
>> 5232453952276885070L;
>>      }
>>
>>      /**
>>       * Adapter for Runnables without results.
>>       */
>>      static final class AdaptedRunnableAction extends ForkJoinTask<Void>
>>          implements RunnableFuture<Void> {
>>          final Runnable runnable;
>>          AdaptedRunnableAction(Runnable runnable) {
>>              if (runnable == null) throw new NullPointerException();
>>              this.runnable = runnable;
>>          }
>>          public final Void getRawResult() { return null; }
>>          public final void setRawResult(Void v) { }
>>          public final boolean exec() { runnable.run(); return true; }
>>          public final void run() { invoke(); }
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + runnable + "]]";
>> +        }
>>          private static final long serialVersionUID =
>> 5232453952276885070L;
>>      }
>>
>>      /**
>>       * Adapter for Runnables in which failure forces worker exception.
>>       */
>>      static final class RunnableExecuteAction extends ForkJoinTask<Void> {
>>          final Runnable runnable;
>>          RunnableExecuteAction(Runnable runnable) {
>>              if (runnable == null) throw new NullPointerException();
>> @@ -1402,20 +1408,23 @@
>>                  result = callable.call();
>>                  return true;
>>              } catch (RuntimeException rex) {
>>                  throw rex;
>>              } catch (Exception ex) {
>>                  throw new RuntimeException(ex);
>>              }
>>          }
>>          public final void run() { invoke(); }
>>          private static final long serialVersionUID =
>> 2838392045355241008L;
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + callable + "]]";
>> +        }
>>      }
>>
>>      /**
>>       * Returns a new {@code ForkJoinTask} that performs the {@code run}
>>       * method of the given {@code Runnable} as its action, and returns
>>       * a null result upon {@link #join}.
>>       *
>>       * @param runnable the runnable action
>>       * @return the task
>>       */
>> Index: FutureTask.java
>> ===================================================================
>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>> ent/FutureTask.java,v
>> retrieving revision 1.118
>> diff -u -U 10 -r1.118 FutureTask.java
>> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
>> +++ FutureTask.java 9 Aug 2017 01:34:25 -0000
>> @@ -444,20 +444,49 @@
>>                              continue retry;
>>                      }
>>                      else if (!WAITERS.compareAndSet(this, q, s))
>>                          continue retry;
>>                  }
>>                  break;
>>              }
>>          }
>>      }
>>
>> +    public String toString() {
>> +        String start = super.toString() + "[status=";
>> +        try {
>> +            switch (state) {
>> +            case NEW:
>> +            case COMPLETING:
>> +                final Callable<?> callable = this.callable;
>> +                if (callable != null) {
>> +                    return start + "PENDING, task=[" + callable + "]]";
>> +                } else {
>> +                    return start + "PENDING]";
>> +                }
>> +            case NORMAL:
>> +                return start + "SUCCESS, result=[" + outcome + "]]";
>> +            case EXCEPTIONAL:
>> +                return start + "FAILURE, cause=[" + outcome + "]]";
>> +            case CANCELLED:
>> +            case INTERRUPTING:
>> +            case INTERRUPTED:
>> +                return start + "CANCELLED]";
>> +            default:
>> +                throw new IllegalStateException();
>> +            }
>> +        } catch (RuntimeException thrownFromToString) {
>> +            return start + "UNKNOWN, cause=["
>> +                + thrownFromToString.getClass() + "]";
>> +        }
>> +    }
>> +
>>      // VarHandle mechanics
>>      private static final VarHandle STATE;
>>      private static final VarHandle RUNNER;
>>      private static final VarHandle WAITERS;
>>      static {
>>          try {
>>              MethodHandles.Lookup l = MethodHandles.lookup();
>>              STATE = l.findVarHandle(FutureTask.class, "state",
>> int.class);
>>              RUNNER = l.findVarHandle(FutureTask.class, "runner",
>> Thread.class);
>>              WAITERS = l.findVarHandle(FutureTask.class, "waiters",
>> WaitNode.class);
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170812/5202e057/attachment-0001.html>

From joe.bowbeer at gmail.com  Sat Aug 12 02:18:44 2017
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri, 11 Aug 2017 23:18:44 -0700
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CACfbOvesOQdkqR1EVXZ9QwD558jYNK_OChd6BKtEOPCXi7JyAQ@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
 <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
 <CACfbOvesOQdkqR1EVXZ9QwD558jYNK_OChd6BKtEOPCXi7JyAQ@mail.gmail.com>
Message-ID: <CAHzJPEpBDnpdFuvxa1kVeZWU43h+tjRpQ2tPvLtWjBkmt--SBA@mail.gmail.com>

toString is an expedient string representation that in practice can be used
for a lot of things, including formatted output, log statements, debug
output, stack traces, and so on, as the need arises.

On Aug 11, 2017 10:01 PM, "Carfield Yim" <carfield at carfield.com.hk> wrote:

Sorry, just a side question, if toString() is not used for debug, what is
the original propose of having it?

On Wed, Aug 9, 2017 at 9:58 AM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> ​I would consider this to be an API change. For example, according to the
> current javadoc, FutureTask's toString method is inherited from Object.
>
> Practically speaking, I'd be concerned about unexpected and unwanted
> changes to the output/log statements of programs that have up until now
> been working fine. In addition to generating a lot of output that may be
> unwanted, this may also generate exceptions. For example,
> PrivilegedCallable.toString calls the toString method of the wrapped
> Callable, which may never have been called previously (bam!), and therefore
> might throw an exception. Or, the toString method of the wrapped callable
> may have been designed to be called in a different context.
>
> If any of the state the toString implementations are accessing is not
> thread-safe, I'd also be concerned about that.
>
> If tasks need toString implementations, I prefer to write them.​
>
> However, I think it would be OK to introduce new convenience methods:
> debugString()
>
> On Tue, Aug 8, 2017 at 6:36 PM, Martin Buchholz <martinrb at google.com>
> wrote:
>
>> My colleague Charles Munger suggests adding toString methods to various
>> task classes in j.u.c.  Obviously this makes it easier to debug large
>> programs that have gone wrong.  But it obviously also is a behavior change
>> that has the potential for trouble, even when everyone is behaving nicely,
>> since toString may have the effect of generating an unbounded output.  I
>> almost started down this road myself a few years ago but chickened out.
>> What do you think?
>>
>> Index: Executors.java
>> ===================================================================
>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>> ent/Executors.java,v
>> retrieving revision 1.97
>> diff -u -U 10 -r1.97 Executors.java
>> --- Executors.java 15 Apr 2017 00:12:38 -0000 1.97
>> +++ Executors.java 9 Aug 2017 01:34:25 -0000
>> @@ -478,20 +478,24 @@
>>          private final Runnable task;
>>          private final T result;
>>          RunnableAdapter(Runnable task, T result) {
>>              this.task = task;
>>              this.result = result;
>>          }
>>          public T call() {
>>              task.run();
>>              return result;
>>          }
>> +        public String toString() {
>> +            return super.toString()
>> +                + "[task=[" + task + "], result=[" + result + "]]";
>> +        }
>>      }
>>
>>      /**
>>       * A callable that runs under established access control settings.
>>       */
>>      private static final class PrivilegedCallable<T> implements
>> Callable<T> {
>>          final Callable<T> task;
>>          final AccessControlContext acc;
>>
>>          PrivilegedCallable(Callable<T> task) {
>> @@ -504,20 +508,24 @@
>>                  return AccessController.doPrivileged(
>>                      new PrivilegedExceptionAction<T>() {
>>                          public T run() throws Exception {
>>                              return task.call();
>>                          }
>>                      }, acc);
>>              } catch (PrivilegedActionException e) {
>>                  throw e.getException();
>>              }
>>          }
>> +
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + task + "]]";
>> +        }
>>      }
>>
>>      /**
>>       * A callable that runs under established access control settings and
>>       * current ClassLoader.
>>       */
>>      private static final class PrivilegedCallableUsingCurrent
>> ClassLoader<T>
>>              implements Callable<T> {
>>          final Callable<T> task;
>>          final AccessControlContext acc;
>> @@ -556,20 +564,24 @@
>>                                  } finally {
>>                                      t.setContextClassLoader(cl);
>>                                  }
>>                              }
>>                          }
>>                      }, acc);
>>              } catch (PrivilegedActionException e) {
>>                  throw e.getException();
>>              }
>>          }
>> +
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + task + "]]";
>> +        }
>>      }
>>
>>      /**
>>       * The default thread factory.
>>       */
>>      private static class DefaultThreadFactory implements ThreadFactory {
>>          private static final AtomicInteger poolNumber = new
>> AtomicInteger(1);
>>          private final ThreadGroup group;
>>          private final AtomicInteger threadNumber = new AtomicInteger(1);
>>          private final String namePrefix;
>> Index: ForkJoinTask.java
>> ===================================================================
>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>> ent/ForkJoinTask.java,v
>> retrieving revision 1.115
>> diff -u -U 10 -r1.115 ForkJoinTask.java
>> --- ForkJoinTask.java 19 Apr 2017 23:45:51 -0000 1.115
>> +++ ForkJoinTask.java 9 Aug 2017 01:34:25 -0000
>> @@ -1339,37 +1339,43 @@
>>          T result;
>>          AdaptedRunnable(Runnable runnable, T result) {
>>              if (runnable == null) throw new NullPointerException();
>>              this.runnable = runnable;
>>              this.result = result; // OK to set this even before
>> completion
>>          }
>>          public final T getRawResult() { return result; }
>>          public final void setRawResult(T v) { result = v; }
>>          public final boolean exec() { runnable.run(); return true; }
>>          public final void run() { invoke(); }
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + runnable + "],
>> result=[" + result + "]]";
>> +        }
>>          private static final long serialVersionUID =
>> 5232453952276885070L;
>>      }
>>
>>      /**
>>       * Adapter for Runnables without results.
>>       */
>>      static final class AdaptedRunnableAction extends ForkJoinTask<Void>
>>          implements RunnableFuture<Void> {
>>          final Runnable runnable;
>>          AdaptedRunnableAction(Runnable runnable) {
>>              if (runnable == null) throw new NullPointerException();
>>              this.runnable = runnable;
>>          }
>>          public final Void getRawResult() { return null; }
>>          public final void setRawResult(Void v) { }
>>          public final boolean exec() { runnable.run(); return true; }
>>          public final void run() { invoke(); }
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + runnable + "]]";
>> +        }
>>          private static final long serialVersionUID =
>> 5232453952276885070L;
>>      }
>>
>>      /**
>>       * Adapter for Runnables in which failure forces worker exception.
>>       */
>>      static final class RunnableExecuteAction extends ForkJoinTask<Void> {
>>          final Runnable runnable;
>>          RunnableExecuteAction(Runnable runnable) {
>>              if (runnable == null) throw new NullPointerException();
>> @@ -1402,20 +1408,23 @@
>>                  result = callable.call();
>>                  return true;
>>              } catch (RuntimeException rex) {
>>                  throw rex;
>>              } catch (Exception ex) {
>>                  throw new RuntimeException(ex);
>>              }
>>          }
>>          public final void run() { invoke(); }
>>          private static final long serialVersionUID =
>> 2838392045355241008L;
>> +        public String toString() {
>> +            return super.toString() + "[task=[" + callable + "]]";
>> +        }
>>      }
>>
>>      /**
>>       * Returns a new {@code ForkJoinTask} that performs the {@code run}
>>       * method of the given {@code Runnable} as its action, and returns
>>       * a null result upon {@link #join}.
>>       *
>>       * @param runnable the runnable action
>>       * @return the task
>>       */
>> Index: FutureTask.java
>> ===================================================================
>> RCS file: /export/home/jsr166/jsr166/jsr166/src/main/java/util/concurr
>> ent/FutureTask.java,v
>> retrieving revision 1.118
>> diff -u -U 10 -r1.118 FutureTask.java
>> --- FutureTask.java 10 Sep 2016 04:06:51 -0000 1.118
>> +++ FutureTask.java 9 Aug 2017 01:34:25 -0000
>> @@ -444,20 +444,49 @@
>>                              continue retry;
>>                      }
>>                      else if (!WAITERS.compareAndSet(this, q, s))
>>                          continue retry;
>>                  }
>>                  break;
>>              }
>>          }
>>      }
>>
>> +    public String toString() {
>> +        String start = super.toString() + "[status=";
>> +        try {
>> +            switch (state) {
>> +            case NEW:
>> +            case COMPLETING:
>> +                final Callable<?> callable = this.callable;
>> +                if (callable != null) {
>> +                    return start + "PENDING, task=[" + callable + "]]";
>> +                } else {
>> +                    return start + "PENDING]";
>> +                }
>> +            case NORMAL:
>> +                return start + "SUCCESS, result=[" + outcome + "]]";
>> +            case EXCEPTIONAL:
>> +                return start + "FAILURE, cause=[" + outcome + "]]";
>> +            case CANCELLED:
>> +            case INTERRUPTING:
>> +            case INTERRUPTED:
>> +                return start + "CANCELLED]";
>> +            default:
>> +                throw new IllegalStateException();
>> +            }
>> +        } catch (RuntimeException thrownFromToString) {
>> +            return start + "UNKNOWN, cause=["
>> +                + thrownFromToString.getClass() + "]";
>> +        }
>> +    }
>> +
>>      // VarHandle mechanics
>>      private static final VarHandle STATE;
>>      private static final VarHandle RUNNER;
>>      private static final VarHandle WAITERS;
>>      static {
>>          try {
>>              MethodHandles.Lookup l = MethodHandles.lookup();
>>              STATE = l.findVarHandle(FutureTask.class, "state",
>> int.class);
>>              RUNNER = l.findVarHandle(FutureTask.class, "runner",
>> Thread.class);
>>              WAITERS = l.findVarHandle(FutureTask.class, "waiters",
>> WaitNode.class);
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170811/17988ff8/attachment-0001.html>

From dl at cs.oswego.edu  Mon Aug 14 09:00:58 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 14 Aug 2017 09:00:58 -0400
Subject: [concurrency-interest] ConcurrentSkipListMap
Message-ID: <80e962fc-95c0-5464-8189-48b65c9c56ed@cs.oswego.edu>


As of JDK9 (and in part internally with JDK8), it's possible to
improve performance of some concurrently-readable data structures
using techniques that substantially reduce the number of volatile-mode
reads. This has only a small impact on TSO machines (including X86)
but can be very noticeable on weaker processors (ARM, POWER, RISCV).
ConcurrentSkipListMap (CSLM) is the best target in j.u.c for putting
these techniques into place. Even though CSLM is rarely as fast as
ConcurrentHashMap for insertion and removal, it should be among the
fastest concurrent data structures for traversal etc (plus, sometimes
you need things to be sorted, so need CSLM anyway).  And this
generally seems to hold after reworking CSLM: on some POWER8 and ARMv8
processors tested (thanks to Paul McKenney/OSUOSL and Andrew
Haley/RedHat) performance improvements seem to range from a few
percent to a factor of six, depending on operation load mix, key
types, size, etc. Performance on X86 is also a little better.  The
main interaction is with cache misses -- large and/or heavily
contended maps encounter a lot of them, limiting speedups.  A
paste of some of the internal documentation below describes the
man ideas (which as usual took much longer to figure out how to put
into place than I had first guessed).

While revisiting CSLM, a couple of other improvements were made.  When
it was first introduced, we didn't have the contention-avoiding
LongAdder to track size, so lived with very slow O(n) estimation.
Even though the javadocs tell people not to call size(), some still
do/did. There's now no reason to do this.  Also, the indexing
originally maxed out at levels corresponding to a billion elements
(slowing down after that), which is now up to essentially unbounded
(Long.MAX_VALUE) elements. Plus other minor things, with possibly
a few more to come. I haven't completely given up on ways to reduce
floating-garbage issues common to all concurrent linked structures.
And there are several opportunities to use and discover more related
techniques for other j.u.c classes.

It would be great if people using CSLM could try this out and report
experiences.  In the process of developing/testing, I made a JDK8
backport version, that I checked in so that others could try. See
http://gee.cs.oswego.edu/dl/concurrency-interest/index.html for
instructions for getting either jsr166.jar abd running jdk9 "java
--patch-module java.base=jsr166.jar",  or getting jsr166-4jdk8.jar
and running jdk8 -Xbootclasspath/p:jsr166-4jdk8.jar. (Also, anyone
interested in trying on Android is invited to build from jdk8 source.)

Also, if you have JMH or other performance tests that target
realistic use cases, please let me know. As usual, we can only
roughly guess about typical operation mixes.

... internal documentation excerpts ...

     * This class provides concurrent-reader-style memory consistency,
     * ensuring that read-only methods report status and/or values no
     * staler than those holding at method entry. This is done by
     * performing all publication and structural updates using
     * (volatile) CAS, placing an acquireFence in a few access
     * methods, and ensuring that linked objects are transitively
     * acquired via dependent reads (normally once) unless performing
     * a volatile-mode CAS operation (that also acts as an acquire and
     * release).  This form of fence-hoisting is similar to RCU
     * and related techniques (see McKenney's online book
     *
https://www.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html)
     * It minimizes overhead that may otherwise occur when using so
     * many volatile-mode reads. Using explicit acquireFences is
     * logistically easier than targeting particular fields to be read
     * in acquire mode: fences are just hoisted up as far as possible,
     * to the entry points or loop headers of a few methods. A
     * potential disadvantage is that these few remaining fences are
     * not easily optimized away by compilers under exclusively
     * single-thread use.  It requires some care avoid volatile mode
     * reads of other fields. (Note that the memory semantics of a
     * reference dependently read in plain mode exactly once are
     * equivalent to those for atomic opaque mode.)  Iterators and
     * other traversals encounter each node and value exactly once.
     * Other operations locate an element (or position to insert an
     * element) via a sequence of dereferences. This search is broken
     * into two parts. Method findPredecessor (and its specialized
     * embeddings) searches index nodes only, returning a base-level
     * predecessor of the key. Callers carry out the base-level
     * search, restarting if encountering a marker preventing link
     * modification.  In some cases, it is possible to encounter a
     * node multiple times while descending levels. For mutative
     * operations, the reported value is validated using CAS (else
     * retrying), preserving linearizability with respect to each
     * other. Others may return any (non-null) value holding in the
     * course of the method call.

From dl at cs.oswego.edu  Mon Aug 14 09:37:55 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 14 Aug 2017 09:37:55 -0400
Subject: [concurrency-interest] ConcurrentSkipListMap
In-Reply-To: <80e962fc-95c0-5464-8189-48b65c9c56ed@cs.oswego.edu>
References: <80e962fc-95c0-5464-8189-48b65c9c56ed@cs.oswego.edu>
Message-ID: <a6a90c0f-3aa9-635f-a868-155c62492760@cs.oswego.edu>

On 08/14/2017 09:00 AM, Doug Lea wrote:

> See
> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html for
> instructions for getting either jsr166.jar abd running jdk9 "java
> --patch-module java.base=jsr166.jar",  or getting jsr166-4jdk8.jar
> and running jdk8 -Xbootclasspath/p:jsr166-4jdk8.jar. (Also, anyone
> interested in trying on Android is invited to build from jdk8 source.)

I sent this before actually updating these, but they are now in place.

-Doug


From akarnokd at gmail.com  Tue Aug 15 10:18:26 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Tue, 15 Aug 2017 16:18:26 +0200
Subject: [concurrency-interest] MethodHandles.lookup().findVarHandle
	alternative not throwing checked exceptions?
Message-ID: <CAAWwtm-Ua_t-gjso=RiZBms=cDQwiXRis7PeW9YfRYQJ0Jv25A@mail.gmail.com>

Hello,

I've been implementing a lot of concurrent code with VarHandles lately and
there is a repeated inconvenience of using

MethodHandles.lookup().findVarHandle(...)

because I can't use it to initialize static fields directly but have to use
a static initialization block and have try-catch around them:

static {
   try {
       UPSTREAM = MethodHandles.lookup().findVarHandle(A.class, "upstream",
Flow.Subscription.class);
   } catch (Throwable ex) {
      throw new InternalError(ex);
   }
}

Apart from writing the above by hand all the time, there is a slight
annoyance that a well parameterized findVarHandle will never throw
thus the throw
new InternalError remains uncovered by code-coverage.

Factoring out the lookup part doesn't work if the target class and/or field
is non accessible from the point of the common routine, plus I lose the
nice IntelliJ feature of validating the findVarHandle parameters in the IDE
itself.

Would it be possible to have some versions of findVarHandle and co in Java
10+ that don't throw checked exceptions?

(Tools such as Lombok may (eventually) help with hiding the VarHandle setup
via annotation, but the generated catch code would still remain uncovered.)

-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170815/9d7efbcc/attachment.html>

From nathanila at gmail.com  Tue Aug 15 10:31:44 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Tue, 15 Aug 2017 08:31:44 -0600
Subject: [concurrency-interest] MethodHandles.lookup().findVarHandle
 alternative not throwing checked exceptions?
In-Reply-To: <CAAWwtm-Ua_t-gjso=RiZBms=cDQwiXRis7PeW9YfRYQJ0Jv25A@mail.gmail.com>
References: <CAAWwtm-Ua_t-gjso=RiZBms=cDQwiXRis7PeW9YfRYQJ0Jv25A@mail.gmail.com>
Message-ID: <d55e8f2d-a704-9234-8b2b-be539d49fd26@gmail.com>

Until findVarHandle() with unchecked exceptions, how about writing a 
utility class that has a static findVarHandle(Class<?>, String, 
Class<?>) with the code you have below?  The initialization code would 
then be...

UPSTREAM = VarHandleUtilities.findVarHandle(A.class, "upstream", 
Flow.Subscription.class);

-Nathan

On 8/15/2017 8:18 AM, Dávid Karnok wrote:
> Hello,
>
> I've been implementing a lot of concurrent code with VarHandles lately 
> and there is a repeated inconvenience of using
>
> MethodHandles.lookup().findVarHandle(...)
>
> because I can't use it to initialize static fields directly but have 
> to use a static initialization block and have try-catch around them:
>
> static {
>    try {
>        UPSTREAM = MethodHandles.lookup().findVarHandle(A.class, 
> "upstream", Flow.Subscription.class);
>    } catch (Throwable ex) {
>       throw new InternalError(ex);
>    }
> }
>
> Apart from writing the above by hand all the time, there is a slight 
> annoyance that a well parameterized findVarHandle will never throw 
> thus the throw new InternalError remains uncovered by code-coverage.
>
> Factoring out the lookup part doesn't work if the target class and/or 
> field is non accessible from the point of the common routine, plus I 
> lose the nice IntelliJ feature of validating the findVarHandle 
> parameters in the IDE itself.
>
> Would it be possible to have some versions of findVarHandle and co in 
> Java 10+ that don't throw checked exceptions?
>
> (Tools such as Lombok may (eventually) help with hiding the VarHandle 
> setup via annotation, but the generated catch code would still remain 
> uncovered.)
>
> -- 
> Best regards,
> David Karnok
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-- 
-Nathan

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170815/88f7fdee/attachment.html>

From akarnokd at gmail.com  Tue Aug 15 11:40:35 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Tue, 15 Aug 2017 17:40:35 +0200
Subject: [concurrency-interest] MethodHandles.lookup().findVarHandle
 alternative not throwing checked exceptions?
In-Reply-To: <d55e8f2d-a704-9234-8b2b-be539d49fd26@gmail.com>
References: <CAAWwtm-Ua_t-gjso=RiZBms=cDQwiXRis7PeW9YfRYQJ0Jv25A@mail.gmail.com>
 <d55e8f2d-a704-9234-8b2b-be539d49fd26@gmail.com>
Message-ID: <CAAWwtm_RYFTKhfRBRwjp8FDifjfqxgDdNF2_vXoT4vR-E4=dcg@mail.gmail.com>

Already mentioned:

Factoring out the lookup part doesn't work if the target class and/or field
is non accessible from the point of the common routine

My code is full of package-private classes and fields, so I have to have
the helper class in every package or make the classes or fields public.

In addition, I can't use modules in case the library's users don't use it
either (assuming it is still true that in order to use a library that is
modularized, one has to be modularized itself).


2017-08-15 16:31 GMT+02:00 Nathan and Ila Reynolds <nathanila at gmail.com>:

> Until findVarHandle() with unchecked exceptions, how about writing a
> utility class that has a static findVarHandle(Class<?>, String, Class<?>)
> with the code you have below?  The initialization code would then be...
>
> UPSTREAM = VarHandleUtilities.findVarHandle(A.class, "upstream",
> Flow.Subscription.class);
>
> -Nathan
>
>
> On 8/15/2017 8:18 AM, Dávid Karnok wrote:
>
> Hello,
>
> I've been implementing a lot of concurrent code with VarHandles lately and
> there is a repeated inconvenience of using
>
> MethodHandles.lookup().findVarHandle(...)
>
> because I can't use it to initialize static fields directly but have to
> use a static initialization block and have try-catch around them:
>
> static {
>    try {
>        UPSTREAM = MethodHandles.lookup().findVarHandle(A.class,
> "upstream", Flow.Subscription.class);
>    } catch (Throwable ex) {
>       throw new InternalError(ex);
>    }
> }
>
> Apart from writing the above by hand all the time, there is a slight
> annoyance that a well parameterized findVarHandle will never throw thus the throw
> new InternalError remains uncovered by code-coverage.
>
> Factoring out the lookup part doesn't work if the target class and/or
> field is non accessible from the point of the common routine, plus I lose
> the nice IntelliJ feature of validating the findVarHandle parameters in
> the IDE itself.
>
> Would it be possible to have some versions of findVarHandle and co in Java
> 10+ that don't throw checked exceptions?
>
> (Tools such as Lombok may (eventually) help with hiding the VarHandle
> setup via annotation, but the generated catch code would still remain
> uncovered.)
>
> --
> Best regards,
> David Karnok
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> --
> -Nathan
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170815/ea3e1cf5/attachment.html>

From aaron.grunthal at infinite-source.de  Tue Aug 15 12:25:56 2017
From: aaron.grunthal at infinite-source.de (Aaron Grunthal)
Date: Tue, 15 Aug 2017 18:25:56 +0200
Subject: [concurrency-interest] MethodHandles.lookup().findVarHandle
 alternative not throwing checked exceptions?
In-Reply-To: <CAAWwtm_RYFTKhfRBRwjp8FDifjfqxgDdNF2_vXoT4vR-E4=dcg@mail.gmail.com>
References: <CAAWwtm-Ua_t-gjso=RiZBms=cDQwiXRis7PeW9YfRYQJ0Jv25A@mail.gmail.com>
 <d55e8f2d-a704-9234-8b2b-be539d49fd26@gmail.com>
 <CAAWwtm_RYFTKhfRBRwjp8FDifjfqxgDdNF2_vXoT4vR-E4=dcg@mail.gmail.com>
Message-ID: <e92f547d-4772-3908-3f41-a161a720dac3@infinite-source.de>

You could create a MethodHandles.Lookup in the caller and pass it to the utility class. The creation does not throw an exception.

On 15.08.2017 17:40, Dávid Karnok wrote:
> Already mentioned:
> 
> Factoring out the lookup part doesn't work if the target class and/or field is non accessible from the point of the common routine
> 
> My code is full of package-private classes and fields, so I have to have the helper class in every package or make the classes or fields public. 
> 
> In addition, I can't use modules in case the library's users don't use it either (assuming it is still true that in order to use a library that is modularized, one has to be modularized itself).
> 
> 
> 2017-08-15 16:31 GMT+02:00 Nathan and Ila Reynolds <nathanila at gmail.com <mailto:nathanila at gmail.com>>:
> 
>     Until findVarHandle() with unchecked exceptions, how about writing a utility class that has a static findVarHandle(Class<?>, String, Class<?>) with the code you have below?  The initialization
>     code would then be...
> 
>     UPSTREAM = VarHandleUtilities.findVarHandle(A.class, "upstream", Flow.Subscription.class);
> 
>     -Nathan
> 
> 
>     On 8/15/2017 8:18 AM, Dávid Karnok wrote:
>>     Hello,
>>
>>     I've been implementing a lot of concurrent code with VarHandles lately and there is a repeated inconvenience of using
>>
>>     MethodHandles.lookup().findVarHandle(...)
>>
>>     because I can't use it to initialize static fields directly but have to use a static initialization block and have try-catch around them:
>>
>>     static {
>>        try {
>>            UPSTREAM = MethodHandles.lookup().findVarHandle(A.class, "upstream", Flow.Subscription.class);
>>        } catch (Throwable ex) {
>>           throw new InternalError(ex);
>>        }
>>     }
>>
>>     Apart from writing the above by hand all the time, there is a slight annoyance that a well parameterized findVarHandle will never throw thus the throw new InternalError remains uncovered by
>>     code-coverage.
>>
>>     Factoring out the lookup part doesn't work if the target class and/or field is non accessible from the point of the common routine, plus I lose the nice IntelliJ feature of validating the
>>     findVarHandle parameters in the IDE itself.
>>
>>     Would it be possible to have some versions of findVarHandle and co in Java 10+ that don't throw checked exceptions?
>>
>>     (Tools such as Lombok may (eventually) help with hiding the VarHandle setup via annotation, but the generated catch code would still remain uncovered.)
>>
>>     -- 
>>     Best regards,
>>     David Karnok
>>
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
>     -- 
>     -Nathan
> 
> 
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 
> 
> 
> -- 
> Best regards,
> David Karnok
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From martinrb at google.com  Wed Aug 16 14:30:22 2017
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 16 Aug 2017 11:30:22 -0700
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CA+kOe090-KAcjDc-4ihGga1Xs+52SjeuDJFc52+hktsTGHR0zA@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
 <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
 <CAHktk4g6XaP--9QTn5BORDqD43Th3ag0XtJsbe+fQhtPoKCLxw@mail.gmail.com>
 <CAHzJPEpgWQR8wyarTj_thU9tSEqz8cpoMtFqmK+Q+WD0XoATMA@mail.gmail.com>
 <CAGu0=MOeVhowQ9kFgoVRiukmzBpinVZa5AOFcsxUiCkSTDe_JA@mail.gmail.com>
 <CAHktk4jTJ=3B0Xgwt+h6-58LGdQqdZa7zin5ZC7B2G41qbMiNw@mail.gmail.com>
 <CAHzJPEpJ52Xdf0Rcsf_9b3go=g66DFarBXn20swrWLWr7u3s+A@mail.gmail.com>
 <CA+kOe09HHF+u4LvXn5FP2j02CvJn4T_KU0awTCZWh9-AweJy2w@mail.gmail.com>
 <CAHzJPErRU0rDAMbdk2rTO5QB-QSKc8bUuZT0R+N8h2ZnDHWHjw@mail.gmail.com>
 <CAHzJPEpJnHS1M_76qPfKq-8c6_O5=oh_Kw2=0axHZ-6p7nES6w@mail.gmail.com>
 <CA+kOe090-KAcjDc-4ihGga1Xs+52SjeuDJFc52+hktsTGHR0zA@mail.gmail.com>
Message-ID: <CA+kOe0_rpM2jG3LJxjk8tQk5xistoBx6wTbZiyuSyo6taB6-0g@mail.gmail.com>

We now have a serious proposal, with docs and tests.

http://cr.openjdk.java.net/~martin/webrevs/openjdk10/jsr166-integration/toString-moredata/

CompletableFuture.toString already included status, so aligned
FutureTask.toString with that.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170816/5772c787/attachment.html>

From dl at cs.oswego.edu  Wed Aug 16 14:34:24 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 16 Aug 2017 14:34:24 -0400
Subject: [concurrency-interest] Adding toString methods for task objects?
In-Reply-To: <CA+kOe0_rpM2jG3LJxjk8tQk5xistoBx6wTbZiyuSyo6taB6-0g@mail.gmail.com>
References: <CA+kOe08CSmm5-iSFz2LdBJ0CyU8v4BP2a1PYM1K8ZkBAkJTR3w@mail.gmail.com>
 <CAHzJPErACe50qtGhoqzZ-XfoSyOhFLjCDj0jOBRsyKE6zmvgPQ@mail.gmail.com>
 <CAHktk4g6XaP--9QTn5BORDqD43Th3ag0XtJsbe+fQhtPoKCLxw@mail.gmail.com>
 <CAHzJPEpgWQR8wyarTj_thU9tSEqz8cpoMtFqmK+Q+WD0XoATMA@mail.gmail.com>
 <CAGu0=MOeVhowQ9kFgoVRiukmzBpinVZa5AOFcsxUiCkSTDe_JA@mail.gmail.com>
 <CAHktk4jTJ=3B0Xgwt+h6-58LGdQqdZa7zin5ZC7B2G41qbMiNw@mail.gmail.com>
 <CAHzJPEpJ52Xdf0Rcsf_9b3go=g66DFarBXn20swrWLWr7u3s+A@mail.gmail.com>
 <CA+kOe09HHF+u4LvXn5FP2j02CvJn4T_KU0awTCZWh9-AweJy2w@mail.gmail.com>
 <CAHzJPErRU0rDAMbdk2rTO5QB-QSKc8bUuZT0R+N8h2ZnDHWHjw@mail.gmail.com>
 <CAHzJPEpJnHS1M_76qPfKq-8c6_O5=oh_Kw2=0axHZ-6p7nES6w@mail.gmail.com>
 <CA+kOe090-KAcjDc-4ihGga1Xs+52SjeuDJFc52+hktsTGHR0zA@mail.gmail.com>
 <CA+kOe0_rpM2jG3LJxjk8tQk5xistoBx6wTbZiyuSyo6taB6-0g@mail.gmail.com>
Message-ID: <49575bcd-5a0c-0200-b91d-10869ac1d9bc@cs.oswego.edu>

On 08/16/2017 02:30 PM, Martin Buchholz wrote:
> We now have a serious proposal, with docs and tests.
> 
> http://cr.openjdk.java.net/~martin/webrevs/openjdk10/jsr166-integration/toString-moredata/
> 

I hadn't replied initially, wanting to hear of any unknown reason
it might be problematic, but given responses, I think this is worth
doing.

-Doug


> CompletableFuture.toString already included status, so aligned
> FutureTask.toString with that.
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From dl at cs.oswego.edu  Thu Aug 17 13:16:36 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 17 Aug 2017 13:16:36 -0400
Subject: [concurrency-interest] ConcurrentSkipListMap
In-Reply-To: <80e962fc-95c0-5464-8189-48b65c9c56ed@cs.oswego.edu>
References: <80e962fc-95c0-5464-8189-48b65c9c56ed@cs.oswego.edu>
Message-ID: <b7964fb8-31c2-7e09-88f0-44e96beb1c85@cs.oswego.edu>


Thanks to Pedro Ramalhete for helping check that new CSLM doesn't alter
thread-safety properties. But while doing so, we noticed that the
existing javadocs for Object.equals, Comparable.compareTo, and
Comparator.compare at best only implicitly indicate their need for
thread safety, and that it's easy to come up with examples in CSLM,
ConcurrentHashMap, and other classes in which failure to comply
leads to crazy behavior.

This should not be news to anyone. But still, the equals, compareTo,
and compare javadocs should be explicit. Something along the lines of:


Object.java:

*** b/Object.java	2017-05-18 13:47:17.975768272 -0400
--- ./Object.java	2017-08-17 12:51:36.021851040 -0400
***************
*** 129,135 ****
       * <li>It is <i>consistent</i>: for any non-null reference values
!      *     {@code x} and {@code y}, multiple invocations of
!      *     {@code x.equals(y)} consistently return {@code true}
!      *     or consistently return {@code false}, provided no
!      *     information used in {@code equals} comparisons on the
!      *     objects is modified.
       * <li>For any non-null reference value {@code x},
--- 129,138 ----
       * <li>It is <i>consistent</i>: for any non-null reference values
!      *     {@code x} and {@code y}, multiple invocations of {@code
!      *     x.equals(y)} (possibly across multiple threads)
!      *     consistently return {@code true} or consistently return
!      *     {@code false}, provided no information used in {@code
!      *     equals} comparisons on the objects is modified. In
!      *     multithreaded programs, this can be guaranteed by ensuring
!      *     that all values used in computing equality are immutable or
!      *     are accessed under correct synchronization.
       * <li>For any non-null reference value {@code x},


Comparable.java:

*** b/Comparator.java	2017-05-18 13:47:39.301752902 -0400
--- ./Comparator.java	2017-08-17 13:05:15.702034642 -0400
***************
*** 91,92 ****
--- 91,99 ----
   *
+  * <p>As is the case for {@link Object#equals}, the {@code compare}
+  * method must be <em>consistent</em>: In the absence of modification,
+  * multiple invocations (possibly across multiple thread) have
+  * equivalent results. In multithreaded programs, this can be
+  * guaranteed by ensuring that all compared values are immutable or
+  * accessed under correct synchronization.
+  *
   * <p>Unlike {@code Comparable}, a comparator may optionally permit


Comparator.java:

*** b/Comparator.java	2017-05-18 13:47:39.301752902 -0400
--- ./Comparator.java	2017-08-17 13:05:15.702034642 -0400
***************
*** 91,92 ****
--- 91,99 ----
   *
+  * <p>As is the case for {@link Object#equals}, the {@code compare}
+  * method must be <em>consistent</em>: In the absence of modification,
+  * multiple invocations (possibly across multiple thread) have
+  * equivalent results. In multithreaded programs, this can be
+  * guaranteed by ensuring that all compared values are immutable or
+  * accessed under correct synchronization.
+  *
   * <p>Unlike {@code Comparable}, a comparator may optionally permit



From akarnokd at gmail.com  Thu Aug 17 16:00:36 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Thu, 17 Aug 2017 22:00:36 +0200
Subject: [concurrency-interest] MethodHandles.lookup().findVarHandle
 alternative not throwing checked exceptions?
In-Reply-To: <e92f547d-4772-3908-3f41-a161a720dac3@infinite-source.de>
References: <CAAWwtm-Ua_t-gjso=RiZBms=cDQwiXRis7PeW9YfRYQJ0Jv25A@mail.gmail.com>
 <d55e8f2d-a704-9234-8b2b-be539d49fd26@gmail.com>
 <CAAWwtm_RYFTKhfRBRwjp8FDifjfqxgDdNF2_vXoT4vR-E4=dcg@mail.gmail.com>
 <e92f547d-4772-3908-3f41-a161a720dac3@infinite-source.de>
Message-ID: <CAAWwtm8ECufKZuGJ+6t2_B8Vq_Si6x5bnKy=PQ5VhM9==zftAw@mail.gmail.com>

Thanks for all the feedback. Indeed, one has to hand
MethodHandles.lookup()'s result as well into the utility method because the
Lookup gets all the rights to access the package private fields.

public static VarHandle find(MethodHandles.Lookup lookup, Class<?>
parent, String field, Class<?> type) {
    try {
        return lookup.findVarHandle(parent, field, type);
    } catch (Throwable ex) {
        throw new InternalError(ex);
    }
}



2017-08-15 18:25 GMT+02:00 Aaron Grunthal <aaron.grunthal at infinite-source.de
>:

> You could create a MethodHandles.Lookup in the caller and pass it to the
> utility class. The creation does not throw an exception.
>
> On 15.08.2017 17:40, Dávid Karnok wrote:
> > Already mentioned:
> >
> > Factoring out the lookup part doesn't work if the target class and/or
> field is non accessible from the point of the common routine
> >
> > My code is full of package-private classes and fields, so I have to have
> the helper class in every package or make the classes or fields public.
> >
> > In addition, I can't use modules in case the library's users don't use
> it either (assuming it is still true that in order to use a library that is
> modularized, one has to be modularized itself).
> >
> >
> > 2017-08-15 16:31 GMT+02:00 Nathan and Ila Reynolds <nathanila at gmail.com
> <mailto:nathanila at gmail.com>>:
> >
> >     Until findVarHandle() with unchecked exceptions, how about writing a
> utility class that has a static findVarHandle(Class<?>, String, Class<?>)
> with the code you have below?  The initialization
> >     code would then be...
> >
> >     UPSTREAM = VarHandleUtilities.findVarHandle(A.class, "upstream",
> Flow.Subscription.class);
> >
> >     -Nathan
> >
> >
> >     On 8/15/2017 8:18 AM, Dávid Karnok wrote:
> >>     Hello,
> >>
> >>     I've been implementing a lot of concurrent code with VarHandles
> lately and there is a repeated inconvenience of using
> >>
> >>     MethodHandles.lookup().findVarHandle(...)
> >>
> >>     because I can't use it to initialize static fields directly but
> have to use a static initialization block and have try-catch around them:
> >>
> >>     static {
> >>        try {
> >>            UPSTREAM = MethodHandles.lookup().findVarHandle(A.class,
> "upstream", Flow.Subscription.class);
> >>        } catch (Throwable ex) {
> >>           throw new InternalError(ex);
> >>        }
> >>     }
> >>
> >>     Apart from writing the above by hand all the time, there is a
> slight annoyance that a well parameterized findVarHandle will never throw
> thus the throw new InternalError remains uncovered by
> >>     code-coverage.
> >>
> >>     Factoring out the lookup part doesn't work if the target class
> and/or field is non accessible from the point of the common routine, plus I
> lose the nice IntelliJ feature of validating the
> >>     findVarHandle parameters in the IDE itself.
> >>
> >>     Would it be possible to have some versions of findVarHandle and co
> in Java 10+ that don't throw checked exceptions?
> >>
> >>     (Tools such as Lombok may (eventually) help with hiding the
> VarHandle setup via annotation, but the generated catch code would still
> remain uncovered.)
> >>
> >>     --
> >>     Best regards,
> >>     David Karnok
> >>
> >>
> >>     _______________________________________________
> >>     Concurrency-interest mailing list
> >>     Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest@
> cs.oswego.edu>
> >>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest <
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> >
> >     --
> >     -Nathan
> >
> >
> >     _______________________________________________
> >     Concurrency-interest mailing list
> >     Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest@
> cs.oswego.edu>
> >     http://cs.oswego.edu/mailman/listinfo/concurrency-interest <
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> >
> >
> >
> >
> > --
> > Best regards,
> > David Karnok
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170817/020574e4/attachment.html>

From gergg at cox.net  Thu Aug 17 16:49:19 2017
From: gergg at cox.net (Gregg Wonderly)
Date: Thu, 17 Aug 2017 15:49:19 -0500
Subject: [concurrency-interest] MethodHandles.lookup().findVarHandle
 alternative not throwing checked exceptions?
In-Reply-To: <yL121v03G02hR0p01L1641>
References: <CAAWwtm-Ua_t-gjso=RiZBms=cDQwiXRis7PeW9YfRYQJ0Jv25A@mail.gmail.com>
 <d55e8f2d-a704-9234-8b2b-be539d49fd26@gmail.com>
 <CAAWwtm_RYFTKhfRBRwjp8FDifjfqxgDdNF2_vXoT4vR-E4=dcg@mail.gmail.com>
 <e92f547d-4772-3908-3f41-a161a720dac3@infinite-source.de>
 <yL121v03G02hR0p01L1641>
Message-ID: <CE90B4FE-462B-4097-81CB-1DC348291E15@cox.net>

It seems that the specific detail is that he is using static VarHandle values and in having to declare them in static {} blocks, is stuck with catching exceptions because there is not a path out of static initializers for checked Exception handling.  Thus, one has to catch them, and then rethrow an unchecked exception to cause the exception to be transferable to the caller.  Thus, the use of an unchecked exception makes more sense in this weird case.  Even using the suggested method, only pastes over the details.  Security/Access exceptions have never been checked exceptions before, and making them checked now, for this one case, seems irregular doesn’t it?  I am not against checked exceptions, but this seems like an odd man out API design that will, in the end, cause a lot of mindless catch->throw logic to be plastered all over code to deal with it.

Gregg


> On Aug 17, 2017, at 3:00 PM, Dávid Karnok <akarnokd at gmail.com> wrote:
> 
> Thanks for all the feedback. Indeed, one has to hand MethodHandles.lookup()'s result as well into the utility method because the Lookup gets all the rights to access the package private fields.
> 
> public static VarHandle find(MethodHandles.Lookup lookup, Class<?> parent, String field, Class<?> type) {
>     try {
>         return lookup.findVarHandle(parent, field, type);
>     } catch (Throwable ex) {
>         throw new InternalError(ex);
>     }
> }
> 
> 
> 2017-08-15 18:25 GMT+02:00 Aaron Grunthal <aaron.grunthal at infinite-source.de <mailto:aaron.grunthal at infinite-source.de>>:
> You could create a MethodHandles.Lookup in the caller and pass it to the utility class. The creation does not throw an exception.
> 
> On 15.08.2017 17:40, Dávid Karnok wrote:
> > Already mentioned:
> >
> > Factoring out the lookup part doesn't work if the target class and/or field is non accessible from the point of the common routine
> >
> > My code is full of package-private classes and fields, so I have to have the helper class in every package or make the classes or fields public.
> >
> > In addition, I can't use modules in case the library's users don't use it either (assuming it is still true that in order to use a library that is modularized, one has to be modularized itself).
> >
> >
> > 2017-08-15 16:31 GMT+02:00 Nathan and Ila Reynolds <nathanila at gmail.com <mailto:nathanila at gmail.com> <mailto:nathanila at gmail.com <mailto:nathanila at gmail.com>>>:
> >
> >     Until findVarHandle() with unchecked exceptions, how about writing a utility class that has a static findVarHandle(Class<?>, String, Class<?>) with the code you have below?  The initialization
> >     code would then be...
> >
> >     UPSTREAM = VarHandleUtilities.findVarHandle(A.class, "upstream", Flow.Subscription.class);
> >
> >     -Nathan
> >
> >
> >     On 8/15/2017 8:18 AM, Dávid Karnok wrote:
> >>     Hello,
> >>
> >>     I've been implementing a lot of concurrent code with VarHandles lately and there is a repeated inconvenience of using
> >>
> >>     MethodHandles.lookup().findVarHandle(...)
> >>
> >>     because I can't use it to initialize static fields directly but have to use a static initialization block and have try-catch around them:
> >>
> >>     static {
> >>        try {
> >>            UPSTREAM = MethodHandles.lookup().findVarHandle(A.class, "upstream", Flow.Subscription.class);
> >>        } catch (Throwable ex) {
> >>           throw new InternalError(ex);
> >>        }
> >>     }
> >>
> >>     Apart from writing the above by hand all the time, there is a slight annoyance that a well parameterized findVarHandle will never throw thus the throw new InternalError remains uncovered by
> >>     code-coverage.
> >>
> >>     Factoring out the lookup part doesn't work if the target class and/or field is non accessible from the point of the common routine, plus I lose the nice IntelliJ feature of validating the
> >>     findVarHandle parameters in the IDE itself.
> >>
> >>     Would it be possible to have some versions of findVarHandle and co in Java 10+ that don't throw checked exceptions?
> >>
> >>     (Tools such as Lombok may (eventually) help with hiding the VarHandle setup via annotation, but the generated catch code would still remain uncovered.)
> >>
> >>     --
> >>     Best regards,
> >>     David Karnok
> >>
> >>
> >>     _______________________________________________
> >>     Concurrency-interest mailing list
> >>     Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> <mailto:Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>>
> >>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest> <http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>>
> >
> >     --
> >     -Nathan
> >
> >
> >     _______________________________________________
> >     Concurrency-interest mailing list
> >     Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> <mailto:Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>>
> >     http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest> <http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>>
> >
> >
> >
> >
> > --
> > Best regards,
> > David Karnok
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> >
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 
> 
> -- 
> Best regards,
> David Karnok
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170817/5652e5d2/attachment-0001.html>

From akarnokd at gmail.com  Fri Aug 18 14:49:10 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Fri, 18 Aug 2017 20:49:10 +0200
Subject: [concurrency-interest] VarHandle.setVolatile vs classical volatile
	write
Message-ID: <CAAWwtm9eT8-OiVhW=8k6xYS4=7mo363-THxjFuW5Cy3JpepHGA@mail.gmail.com>

Hi,

in an older blog post (
https://shipilev.net/blog/2014/on-the-fence-with-dependencies/#_storeload_barrier_and_stack_usages)
about write barriers, it is mentioned the JIT uses a stack local address
and XADD to flush the write buffer when a volatile field is written on x86
and also mentions the option to use XCHG instead, targeting the actual
memory location.

My question is, does a compiled VarHandle.setVolatile do the same XADD
trick or is it using XCHG? Has there been a newer performance evaluation
with XCHG since the blog post? In other terms, is there a performance
penalty/benefit in changing VarHandle.setVolatile() into
VarHandle.getAndSet() when considering a modern x86 ?

My particular use case is for running code designed for concurrency in
non-concurrent fashion and perhaps saving the cost of a MOVE + XADD pair
when an XCHG has the very same effect.

Thank you for your time.
-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170818/ebe0e7ff/attachment.html>

From paul.sandoz at oracle.com  Fri Aug 18 15:21:32 2017
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Fri, 18 Aug 2017 12:21:32 -0700
Subject: [concurrency-interest] VarHandle.setVolatile vs classical
	volatile write
In-Reply-To: <CAAWwtm9eT8-OiVhW=8k6xYS4=7mo363-THxjFuW5Cy3JpepHGA@mail.gmail.com>
References: <CAAWwtm9eT8-OiVhW=8k6xYS4=7mo363-THxjFuW5Cy3JpepHGA@mail.gmail.com>
Message-ID: <4CF0185D-0FA3-41BD-9284-B69FD235096E@oracle.com>


> On 18 Aug 2017, at 11:49, Dávid Karnok <akarnokd at gmail.com> wrote:
> 
> Hi,
> 
> in an older blog post (https://shipilev.net/blog/2014/on-the-fence-with-dependencies/#_storeload_barrier_and_stack_usages <https://shipilev.net/blog/2014/on-the-fence-with-dependencies/#_storeload_barrier_and_stack_usages>) about write barriers, it is mentioned the JIT uses a stack local address and XADD to flush the write buffer when a volatile field is written on x86 and also mentions the option to use XCHG instead, targeting the actual memory location.
> 
> My question is, does a compiled VarHandle.setVolatile do the same XADD trick or is it using XCHG?

It uses the same trick, since the VarHandles implementation in OpenJDK tunnels through to Unsafe with surrounding safety checks that the compiler folds away when it knows it’s safe to do so.


> Has there been a newer performance evaluation with XCHG since the blog post?

Not that i am aware of.


> In other terms, is there a performance penalty/benefit in changing VarHandle.setVolatile() into VarHandle.getAndSet() when considering a modern x86 ?
> 

I suspect in general there may be a penalty since getAndSet provides stronger ordering (a volatile read and write), so i would hold off with any global search and replace of setVolatile with getAndSet :-)

I would be interested in looking at performance results and generated assembly from some nano benchmarks.

Paul.

> My particular use case is for running code designed for concurrency in non-concurrent fashion and perhaps saving the cost of a MOVE + XADD pair when an XCHG has the very same effect.
> 
> Thank you for your time.
> --
> Best regards,
> David Karnok
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170818/72a6ff17/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 841 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170818/72a6ff17/attachment.sig>

From shevek at anarres.org  Fri Aug 18 16:42:55 2017
From: shevek at anarres.org (Shevek)
Date: Fri, 18 Aug 2017 13:42:55 -0700
Subject: [concurrency-interest] Awaiting a set of tasks on an ExecutorService
Message-ID: <c1f2f48a-6554-22d5-3587-d987ce63fcb6@anarres.org>

Hi,

I need to build a complicated object on a multiprocessor system. The 
target object uses synchronization to guarantee thread-safe access. 
However, the individual tasks which build elements of the target object 
are expensive, so I farm them out to an ExecutorService. The question is:

What is the recommended way to submit a stream of tasks to an 
ExecutorService, and then at a point, wait until they're all done.

* I don't know the list of tasks up front. I read them iteratively from 
a set of files or events.
* A big collection of Future(s) isn't realistic, there are just too many 
tasks.
* Reaping completed futures on submission means that I end up with 
exceptions in weird places; I really need to gather max 100 suppressed 
exceptions, and discard the rest.
* ForkJoinPool has invoke() but I think for a million-task job, I still 
end up with a huge list of futures. This also assumes I ignore the note 
about synchronization.
* CompletionService allows me to wait for _any_ of the submitted tasks, 
but not for _all_ of them.

* Bonus points for sharing a single ExecutorService and having "sets" of 
tasks which can be independently awaited. This starts to sound very like 
FJP, except for the blocking/I/O and the stream-ness of my task set.

Mostly, dear list, I'm expecting a one-liner from some API class that 
I've missed because this is NOT an original request, I just can't find a 
standard solution.

Thank you.

S.

From jhump at bluegosling.com  Fri Aug 18 16:48:41 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Fri, 18 Aug 2017 16:48:41 -0400
Subject: [concurrency-interest] Awaiting a set of tasks on an
	ExecutorService
In-Reply-To: <c1f2f48a-6554-22d5-3587-d987ce63fcb6@anarres.org>
References: <c1f2f48a-6554-22d5-3587-d987ce63fcb6@anarres.org>
Message-ID: <CAO78j+LaEKB5g3ED+SYi2mJDYrbxzQJJjqjXdERh8uQmEYgKUQ@mail.gmail.com>

I think the easiest thing would be to decorate each task to call
"latch.countDown()" on a CountDownLatch that is initialized with the total
number of tasks. After they are all submitted, the code that wants to wait
for them to finish would simply await the latch. This decouples completion
of all tasks from the actual ExecutorService that is running them, so you
can share the same ExecutorService for multiple, even overlapping, sets of
tasks.

----
*Josh Humphries*
jhump at bluegosling.com

On Fri, Aug 18, 2017 at 4:42 PM, Shevek <shevek at anarres.org> wrote:

> Hi,
>
> I need to build a complicated object on a multiprocessor system. The
> target object uses synchronization to guarantee thread-safe access.
> However, the individual tasks which build elements of the target object are
> expensive, so I farm them out to an ExecutorService. The question is:
>
> What is the recommended way to submit a stream of tasks to an
> ExecutorService, and then at a point, wait until they're all done.
>
> * I don't know the list of tasks up front. I read them iteratively from a
> set of files or events.
> * A big collection of Future(s) isn't realistic, there are just too many
> tasks.
> * Reaping completed futures on submission means that I end up with
> exceptions in weird places; I really need to gather max 100 suppressed
> exceptions, and discard the rest.
> * ForkJoinPool has invoke() but I think for a million-task job, I still
> end up with a huge list of futures. This also assumes I ignore the note
> about synchronization.
> * CompletionService allows me to wait for _any_ of the submitted tasks,
> but not for _all_ of them.
>
> * Bonus points for sharing a single ExecutorService and having "sets" of
> tasks which can be independently awaited. This starts to sound very like
> FJP, except for the blocking/I/O and the stream-ness of my task set.
>
> Mostly, dear list, I'm expecting a one-liner from some API class that I've
> missed because this is NOT an original request, I just can't find a
> standard solution.
>
> Thank you.
>
> S.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170818/c47d2117/attachment.html>

From shevek at anarres.org  Fri Aug 18 16:54:00 2017
From: shevek at anarres.org (Shevek)
Date: Fri, 18 Aug 2017 13:54:00 -0700
Subject: [concurrency-interest] Awaiting a set of tasks on an
 ExecutorService
In-Reply-To: <CAO78j+LaEKB5g3ED+SYi2mJDYrbxzQJJjqjXdERh8uQmEYgKUQ@mail.gmail.com>
References: <c1f2f48a-6554-22d5-3587-d987ce63fcb6@anarres.org>
 <CAO78j+LaEKB5g3ED+SYi2mJDYrbxzQJJjqjXdERh8uQmEYgKUQ@mail.gmail.com>
Message-ID: <cee5292e-b306-8f42-aaab-eda1c8fc1516@anarres.org>

I can't use CountDownLatch because of the streamy nature of the source. 
I have no idea how many tasks there are going to be up front. I read an 
incoming stream, it turns out there's about 50 million in it, and this 
is going to go up by the usual orders of magnitude.

I could use a List of CountDownLatches each with ... but then I rapidly 
get into "Someone cleverer than me MUST have solved this before" territory.

I can do my own tricks with an AtomicLong and wait()/notify(), but I 
have to make sure the master thread calls get() on the relevant Future 
each time a job finishes, otherwise there isn't a happens-before 
relationship with the master thread, so I'd need the job to put its own 
Future onto a Deque, or something...?

The tasks all return Void, but it's nice to collect the first few 
exceptions (currently there are about 750,000 total exceptions thrown).

S.

On 08/18/2017 01:48 PM, Josh Humphries wrote:
> I think the easiest thing would be to decorate each task to call 
> "latch.countDown()" on a CountDownLatch that is initialized with the 
> total number of tasks. After they are all submitted, the code that wants 
> to wait for them to finish would simply await the latch. This decouples 
> completion of all tasks from the actual ExecutorService that is running 
> them, so you can share the same ExecutorService for multiple, even 
> overlapping, sets of tasks.
> 
> ----
> *Josh Humphries*
> jhump at bluegosling.com <mailto:jhump at bluegosling.com>
> 
> On Fri, Aug 18, 2017 at 4:42 PM, Shevek <shevek at anarres.org 
> <mailto:shevek at anarres.org>> wrote:
> 
>     Hi,
> 
>     I need to build a complicated object on a multiprocessor system. The
>     target object uses synchronization to guarantee thread-safe access.
>     However, the individual tasks which build elements of the target
>     object are expensive, so I farm them out to an ExecutorService. The
>     question is:
> 
>     What is the recommended way to submit a stream of tasks to an
>     ExecutorService, and then at a point, wait until they're all done.
> 
>     * I don't know the list of tasks up front. I read them iteratively
>     from a set of files or events.
>     * A big collection of Future(s) isn't realistic, there are just too
>     many tasks.
>     * Reaping completed futures on submission means that I end up with
>     exceptions in weird places; I really need to gather max 100
>     suppressed exceptions, and discard the rest.
>     * ForkJoinPool has invoke() but I think for a million-task job, I
>     still end up with a huge list of futures. This also assumes I ignore
>     the note about synchronization.
>     * CompletionService allows me to wait for _any_ of the submitted
>     tasks, but not for _all_ of them.
> 
>     * Bonus points for sharing a single ExecutorService and having
>     "sets" of tasks which can be independently awaited. This starts to
>     sound very like FJP, except for the blocking/I/O and the stream-ness
>     of my task set.
> 
>     Mostly, dear list, I'm expecting a one-liner from some API class
>     that I've missed because this is NOT an original request, I just
>     can't find a standard solution.
> 
>     Thank you.
> 
>     S.
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 

From jhump at bluegosling.com  Fri Aug 18 16:53:27 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Fri, 18 Aug 2017 16:53:27 -0400
Subject: [concurrency-interest] Awaiting a set of tasks on an
	ExecutorService
In-Reply-To: <CAO78j+LaEKB5g3ED+SYi2mJDYrbxzQJJjqjXdERh8uQmEYgKUQ@mail.gmail.com>
References: <c1f2f48a-6554-22d5-3587-d987ce63fcb6@anarres.org>
 <CAO78j+LaEKB5g3ED+SYi2mJDYrbxzQJJjqjXdERh8uQmEYgKUQ@mail.gmail.com>
Message-ID: <CAO78j+Li2W8XZTE1H7bisH9+oG+sB2CE5Ohr3TAp0A8gqpchzA@mail.gmail.com>

I forgot to address the concern about error handling. For that, you could
collect them into a synchronized list, where you simply ignore failures
after the size of the list reaches the limit.

Another possibility is to use an ExecutorCompletionService. You can create
a new one for each set of tasks, submit all tasks to it, and then poll them
all to wait until tasks finish. With that approach, you won't need to
decorate the tasks, and instead handle the errors and tracking how many
tasks you've polled in the code that is waiting for them to finish.

The ExecutorCompletionService also lets you re-use an ExecutorService. You
create a new CompletionService for each group of tasks, but they can all
wrap the same underlying ExecutorService.


----
*Josh Humphries*
jhump at bluegosling.com

On Fri, Aug 18, 2017 at 4:48 PM, Josh Humphries <jhump at bluegosling.com>
wrote:

> I think the easiest thing would be to decorate each task to call
> "latch.countDown()" on a CountDownLatch that is initialized with the total
> number of tasks. After they are all submitted, the code that wants to wait
> for them to finish would simply await the latch. This decouples completion
> of all tasks from the actual ExecutorService that is running them, so you
> can share the same ExecutorService for multiple, even overlapping, sets of
> tasks.
>
> ----
> *Josh Humphries*
> jhump at bluegosling.com
>
> On Fri, Aug 18, 2017 at 4:42 PM, Shevek <shevek at anarres.org> wrote:
>
>> Hi,
>>
>> I need to build a complicated object on a multiprocessor system. The
>> target object uses synchronization to guarantee thread-safe access.
>> However, the individual tasks which build elements of the target object are
>> expensive, so I farm them out to an ExecutorService. The question is:
>>
>> What is the recommended way to submit a stream of tasks to an
>> ExecutorService, and then at a point, wait until they're all done.
>>
>> * I don't know the list of tasks up front. I read them iteratively from a
>> set of files or events.
>> * A big collection of Future(s) isn't realistic, there are just too many
>> tasks.
>> * Reaping completed futures on submission means that I end up with
>> exceptions in weird places; I really need to gather max 100 suppressed
>> exceptions, and discard the rest.
>> * ForkJoinPool has invoke() but I think for a million-task job, I still
>> end up with a huge list of futures. This also assumes I ignore the note
>> about synchronization.
>> * CompletionService allows me to wait for _any_ of the submitted tasks,
>> but not for _all_ of them.
>>
>> * Bonus points for sharing a single ExecutorService and having "sets" of
>> tasks which can be independently awaited. This starts to sound very like
>> FJP, except for the blocking/I/O and the stream-ness of my task set.
>>
>> Mostly, dear list, I'm expecting a one-liner from some API class that
>> I've missed because this is NOT an original request, I just can't find a
>> standard solution.
>>
>> Thank you.
>>
>> S.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170818/f7ae28c6/attachment.html>

From akarnokd at gmail.com  Fri Aug 18 16:58:52 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Fri, 18 Aug 2017 22:58:52 +0200
Subject: [concurrency-interest] VarHandle.setVolatile vs classical
 volatile write
In-Reply-To: <4CF0185D-0FA3-41BD-9284-B69FD235096E@oracle.com>
References: <CAAWwtm9eT8-OiVhW=8k6xYS4=7mo363-THxjFuW5Cy3JpepHGA@mail.gmail.com>
 <4CF0185D-0FA3-41BD-9284-B69FD235096E@oracle.com>
Message-ID: <CAAWwtm-nCv=iYvVVRUHJyJUg_4nO-KXkFs8=mRRxwoZgqTxCYQ@mail.gmail.com>

Thanks. I did a benchmark (
https://gist.github.com/akarnokd/c0d606bd7e29d143ee82f2026898dbb5) and got
the following results:

i5 6440HQ, Windows 10 x64, Java 9b181, JMH 1.19

Benchmark                       Mode  Cnt          Score         Error
 Units
VolatilePerf.getAndAdd         thrpt    5  117841308,999 ± 3940711,142
 ops/s
VolatilePerf.getAndSet         thrpt    5  118162019,136 ± 1349823,016
 ops/s
VolatilePerf.releaseGetAndAdd  thrpt    5  118688354,409 ±  642044,969
 ops/s
VolatilePerf.setRelease        thrpt    5  890890009,555 ± 4323041,380
 ops/s
VolatilePerf.setVolatile       thrpt    5  118419990,949 ±  793885,407
 ops/s


Being on Windows and on a Laptop usually yields some variance, but looks
like there is practically minimal difference between the full barrier
operations.

Btw, thinking about XCHG and XADD, they have to provide the same strong
volatile read and write as they both read and write something atomically. I
would have thought XADD involving some ALU is detectably more costly but a
3 cycle addition is relatively small compared to a 22-45 cycle cache action.


2017-08-18 21:21 GMT+02:00 Paul Sandoz <paul.sandoz at oracle.com>:

>
> On 18 Aug 2017, at 11:49, Dávid Karnok <akarnokd at gmail.com> wrote:
>
> Hi,
>
> in an older blog post (https://shipilev.net/blog/2014/on-the-fence-with-
> dependencies/#_storeload_barrier_and_stack_usages) about write barriers,
> it is mentioned the JIT uses a stack local address and XADD to flush the
> write buffer when a volatile field is written on x86 and also mentions the
> option to use XCHG instead, targeting the actual memory location.
>
> My question is, does a compiled VarHandle.setVolatile do the same XADD
> trick or is it using XCHG?
>
>
> It uses the same trick, since the VarHandles implementation in OpenJDK
> tunnels through to Unsafe with surrounding safety checks that the compiler
> folds away when it knows it’s safe to do so.
>
>
> Has there been a newer performance evaluation with XCHG since the blog
> post?
>
>
> Not that i am aware of.
>
>
> In other terms, is there a performance penalty/benefit in changing
> VarHandle.setVolatile() into VarHandle.getAndSet() when considering a
> modern x86 ?
>
>
> I suspect in general there may be a penalty since getAndSet provides
> stronger ordering (a volatile read and write), so i would hold off with any
> global search and replace of setVolatile with getAndSet :-)
>
> I would be interested in looking at performance results and generated
> assembly from some nano benchmarks.
>
> Paul.
>
> My particular use case is for running code designed for concurrency in
> non-concurrent fashion and perhaps saving the cost of a MOVE + XADD pair
> when an XCHG has the very same effect.
>
> Thank you for your time.
> --
> Best regards,
> David Karnok
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>


-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170818/d7d579f5/attachment.html>

From jhump at bluegosling.com  Fri Aug 18 17:06:25 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Fri, 18 Aug 2017 17:06:25 -0400
Subject: [concurrency-interest] Awaiting a set of tasks on an
	ExecutorService
In-Reply-To: <cee5292e-b306-8f42-aaab-eda1c8fc1516@anarres.org>
References: <c1f2f48a-6554-22d5-3587-d987ce63fcb6@anarres.org>
 <CAO78j+LaEKB5g3ED+SYi2mJDYrbxzQJJjqjXdERh8uQmEYgKUQ@mail.gmail.com>
 <cee5292e-b306-8f42-aaab-eda1c8fc1516@anarres.org>
Message-ID: <CAO78j+JjuGAERjnuvT-+QDQnMm++Bvu2D0ZzHgTCSgNdFNqSyQ@mail.gmail.com>

Sorry that my suggestion got broken into two message. Indeed my first
suggestion was incomplete. But the second suggestion, of using a
CompletionService should suffice. Would you queue up 50 million tasks in
the scenario you describe or do you also need a solution that provides
back-pressure?

Without back-pressure, it's simple enough to submit everything to a
CompletionService and then poll as many as you submitted when done. But
that also will buffer up all results as they complete (and if using a
limited-capacity queue, it could deadlock if it's the same thread
submitting as polling).

If you need backpressure, I'd imagine something more like this:

   - One thread pulling tasks as they come and submitting to the
   CompletionService.
      - Before submitting each task:
         - Acquire a permit from a semaphore that has been setup with the
         maximum number of in-flight/queued tasks you want.
         - Increment a counter (e.g. AtomicLong).
      - After submitting the last task (e.g. end of stream has been
      detected), set a flag (AtomicBoolean) and then also submit a no-op task
      (sentinel) to the CompletionService.
         - Acquire permit and increment counter, even for the no-op task
      - Have a second thread that is awaiting completion of all tasks. It
   is in a loop polling the CompletionService.
      - After polling a task, add exception to list of failures if list is
      not already maxed out (e.g. already extracted 100 failures).
      - Also release a permit back to the semaphore and decrement the
      counter.
      - If counter has reached zero and flag is set, all tasks are
      processed. Done!
      - Otherwise, go back to top of loop, to poll next task.


----
*Josh Humphries*
jhump at bluegosling.com

On Fri, Aug 18, 2017 at 4:54 PM, Shevek <shevek at anarres.org> wrote:

> I can't use CountDownLatch because of the streamy nature of the source. I
> have no idea how many tasks there are going to be up front. I read an
> incoming stream, it turns out there's about 50 million in it, and this is
> going to go up by the usual orders of magnitude.
>
> I could use a List of CountDownLatches each with ... but then I rapidly
> get into "Someone cleverer than me MUST have solved this before" territory.
>
> I can do my own tricks with an AtomicLong and wait()/notify(), but I have
> to make sure the master thread calls get() on the relevant Future each time
> a job finishes, otherwise there isn't a happens-before relationship with
> the master thread, so I'd need the job to put its own Future onto a Deque,
> or something...?
>
> The tasks all return Void, but it's nice to collect the first few
> exceptions (currently there are about 750,000 total exceptions thrown).
>
> S.
>
> On 08/18/2017 01:48 PM, Josh Humphries wrote:
>
>> I think the easiest thing would be to decorate each task to call
>> "latch.countDown()" on a CountDownLatch that is initialized with the total
>> number of tasks. After they are all submitted, the code that wants to wait
>> for them to finish would simply await the latch. This decouples completion
>> of all tasks from the actual ExecutorService that is running them, so you
>> can share the same ExecutorService for multiple, even overlapping, sets of
>> tasks.
>>
>> ----
>> *Josh Humphries*
>> jhump at bluegosling.com <mailto:jhump at bluegosling.com>
>>
>>
>> On Fri, Aug 18, 2017 at 4:42 PM, Shevek <shevek at anarres.org <mailto:
>> shevek at anarres.org>> wrote:
>>
>>     Hi,
>>
>>     I need to build a complicated object on a multiprocessor system. The
>>     target object uses synchronization to guarantee thread-safe access.
>>     However, the individual tasks which build elements of the target
>>     object are expensive, so I farm them out to an ExecutorService. The
>>     question is:
>>
>>     What is the recommended way to submit a stream of tasks to an
>>     ExecutorService, and then at a point, wait until they're all done.
>>
>>     * I don't know the list of tasks up front. I read them iteratively
>>     from a set of files or events.
>>     * A big collection of Future(s) isn't realistic, there are just too
>>     many tasks.
>>     * Reaping completed futures on submission means that I end up with
>>     exceptions in weird places; I really need to gather max 100
>>     suppressed exceptions, and discard the rest.
>>     * ForkJoinPool has invoke() but I think for a million-task job, I
>>     still end up with a huge list of futures. This also assumes I ignore
>>     the note about synchronization.
>>     * CompletionService allows me to wait for _any_ of the submitted
>>     tasks, but not for _all_ of them.
>>
>>     * Bonus points for sharing a single ExecutorService and having
>>     "sets" of tasks which can be independently awaited. This starts to
>>     sound very like FJP, except for the blocking/I/O and the stream-ness
>>     of my task set.
>>
>>     Mostly, dear list, I'm expecting a one-liner from some API class
>>     that I've missed because this is NOT an original request, I just
>>     can't find a standard solution.
>>
>>     Thank you.
>>
>>     S.
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu
>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170818/54c49f98/attachment-0001.html>

From nathanila at gmail.com  Fri Aug 18 17:22:57 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Fri, 18 Aug 2017 15:22:57 -0600
Subject: [concurrency-interest] Awaiting a set of tasks on an
 ExecutorService
In-Reply-To: <cee5292e-b306-8f42-aaab-eda1c8fc1516@anarres.org>
References: <c1f2f48a-6554-22d5-3587-d987ce63fcb6@anarres.org>
 <CAO78j+LaEKB5g3ED+SYi2mJDYrbxzQJJjqjXdERh8uQmEYgKUQ@mail.gmail.com>
 <cee5292e-b306-8f42-aaab-eda1c8fc1516@anarres.org>
Message-ID: <9695ff58-cddc-7a09-8913-7ac105c5d53d@gmail.com>

What about CountedCompleter?  The master thread registers a callback via 
CountedCompleter.onCompletion().  Call 
CountedCompleter.addToPendingCount() before a new task is enqueued. When 
a task is completed, call CountedCompleter.tryComplete().

The master thread should call addToPendingCount(1) when the stream of 
tasks is first started.  The master thread should call tryComplete() 
when the end of the stream is reached.  Otherwise, onCompletion() might 
be called prematurely because the master thread is too slow at adding tasks.

If CountedCompleter does not work, consider Phaser.bulkRegister() and 
arrive().

-Nathan

On 8/18/2017 2:54 PM, Shevek wrote:
> I can't use CountDownLatch because of the streamy nature of the 
> source. I have no idea how many tasks there are going to be up front. 
> I read an incoming stream, it turns out there's about 50 million in 
> it, and this is going to go up by the usual orders of magnitude.
>
> I could use a List of CountDownLatches each with ... but then I 
> rapidly get into "Someone cleverer than me MUST have solved this 
> before" territory.
>
> I can do my own tricks with an AtomicLong and wait()/notify(), but I 
> have to make sure the master thread calls get() on the relevant Future 
> each time a job finishes, otherwise there isn't a happens-before 
> relationship with the master thread, so I'd need the job to put its 
> own Future onto a Deque, or something...?
>
> The tasks all return Void, but it's nice to collect the first few 
> exceptions (currently there are about 750,000 total exceptions thrown).
>
> S.
>
> On 08/18/2017 01:48 PM, Josh Humphries wrote:
>> I think the easiest thing would be to decorate each task to call 
>> "latch.countDown()" on a CountDownLatch that is initialized with the 
>> total number of tasks. After they are all submitted, the code that 
>> wants to wait for them to finish would simply await the latch. This 
>> decouples completion of all tasks from the actual ExecutorService 
>> that is running them, so you can share the same ExecutorService for 
>> multiple, even overlapping, sets of tasks.
>>
>> ----
>> *Josh Humphries*
>> jhump at bluegosling.com <mailto:jhump at bluegosling.com>
>>
>> On Fri, Aug 18, 2017 at 4:42 PM, Shevek <shevek at anarres.org 
>> <mailto:shevek at anarres.org>> wrote:
>>
>>     Hi,
>>
>>     I need to build a complicated object on a multiprocessor system. The
>>     target object uses synchronization to guarantee thread-safe access.
>>     However, the individual tasks which build elements of the target
>>     object are expensive, so I farm them out to an ExecutorService. The
>>     question is:
>>
>>     What is the recommended way to submit a stream of tasks to an
>>     ExecutorService, and then at a point, wait until they're all done.
>>
>>     * I don't know the list of tasks up front. I read them iteratively
>>     from a set of files or events.
>>     * A big collection of Future(s) isn't realistic, there are just too
>>     many tasks.
>>     * Reaping completed futures on submission means that I end up with
>>     exceptions in weird places; I really need to gather max 100
>>     suppressed exceptions, and discard the rest.
>>     * ForkJoinPool has invoke() but I think for a million-task job, I
>>     still end up with a huge list of futures. This also assumes I ignore
>>     the note about synchronization.
>>     * CompletionService allows me to wait for _any_ of the submitted
>>     tasks, but not for _all_ of them.
>>
>>     * Bonus points for sharing a single ExecutorService and having
>>     "sets" of tasks which can be independently awaited. This starts to
>>     sound very like FJP, except for the blocking/I/O and the stream-ness
>>     of my task set.
>>
>>     Mostly, dear list, I'm expecting a one-liner from some API class
>>     that I've missed because this is NOT an original request, I just
>>     can't find a standard solution.
>>
>>     Thank you.
>>
>>     S.
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu
>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-- 
-Nathan


From akarnokd at gmail.com  Fri Aug 18 17:25:14 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Fri, 18 Aug 2017 23:25:14 +0200
Subject: [concurrency-interest] Awaiting a set of tasks on an
	ExecutorService
In-Reply-To: <c1f2f48a-6554-22d5-3587-d987ce63fcb6@anarres.org>
References: <c1f2f48a-6554-22d5-3587-d987ce63fcb6@anarres.org>
Message-ID: <CAAWwtm_9+b-JvrA782oqBvZvWnjeCTg=Ex5AV8R5YFN_vqKo9A@mail.gmail.com>

I don't think there is a one liner solution for your case given the amount
of tasks, exception handling and other constraints.

You may consider using a reactive library for the job, which are data
centric instead of task centric and can manage an unknow number of data
items, asynchrony, parallelism and error handling for you.

Due to this data centric viewpoint, I can only give a general feel how I'd
do a files-lines processing with RxJava:

ExpensiveObject o = new ExpensiveObject();
List<Throwable> errors = new ArrayList<Throwable>();

Flowable.fromIterable(listOfFiles)
    .flatMapIterable(file -> Files.readLines(file))
    .parallel()
    .runOn(Schedulers.computation())
    .map(line -> {
         List<Runnable> toExecute = new ArrayList<>();
         try {
             toExecute.add(() -> { o.lines++ });

             if (line.contains("error")) {
                 toExecute.add(() -> { o.errorLines++ });
             }
         } catch (Throwable ex) {
             toExecute.add(() -> { if (errors.size() < 100) {
errors.add(ex); } });
         }
         return toExecute;
    })
    .sequential()
    .blockingSubscribe(list -> list.forEach(Runnable::run),
Throwable::printStackTrace);

In your case, you'd probably calculate something in "map", then create a
Runnable that sets a field/calls a setter on "o" with the calculated value.

2017-08-18 22:42 GMT+02:00 Shevek <shevek at anarres.org>:

> Hi,
>
> I need to build a complicated object on a multiprocessor system. The
> target object uses synchronization to guarantee thread-safe access.
> However, the individual tasks which build elements of the target object are
> expensive, so I farm them out to an ExecutorService. The question is:
>
> What is the recommended way to submit a stream of tasks to an
> ExecutorService, and then at a point, wait until they're all done.
>
> * I don't know the list of tasks up front. I read them iteratively from a
> set of files or events.
> * A big collection of Future(s) isn't realistic, there are just too many
> tasks.
> * Reaping completed futures on submission means that I end up with
> exceptions in weird places; I really need to gather max 100 suppressed
> exceptions, and discard the rest.
> * ForkJoinPool has invoke() but I think for a million-task job, I still
> end up with a huge list of futures. This also assumes I ignore the note
> about synchronization.
> * CompletionService allows me to wait for _any_ of the submitted tasks,
> but not for _all_ of them.
>
> * Bonus points for sharing a single ExecutorService and having "sets" of
> tasks which can be independently awaited. This starts to sound very like
> FJP, except for the blocking/I/O and the stream-ness of my task set.
>
> Mostly, dear list, I'm expecting a one-liner from some API class that I've
> missed because this is NOT an original request, I just can't find a
> standard solution.
>
> Thank you.
>
> S.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170818/7cc47ea6/attachment.html>

From shevek at anarres.org  Fri Aug 18 17:38:26 2017
From: shevek at anarres.org (Shevek)
Date: Fri, 18 Aug 2017 14:38:26 -0700
Subject: [concurrency-interest] Awaiting a set of tasks on an
 ExecutorService
In-Reply-To: <CAO78j+JjuGAERjnuvT-+QDQnMm++Bvu2D0ZzHgTCSgNdFNqSyQ@mail.gmail.com>
References: <c1f2f48a-6554-22d5-3587-d987ce63fcb6@anarres.org>
 <CAO78j+LaEKB5g3ED+SYi2mJDYrbxzQJJjqjXdERh8uQmEYgKUQ@mail.gmail.com>
 <cee5292e-b306-8f42-aaab-eda1c8fc1516@anarres.org>
 <CAO78j+JjuGAERjnuvT-+QDQnMm++Bvu2D0ZzHgTCSgNdFNqSyQ@mail.gmail.com>
Message-ID: <5b1bed26-db2d-623e-06e1-a7eced9b7670@anarres.org>

Thank you all.

I now have this:

https://gist.github.com/shevek/5f8b3fad55c346ca1391349404a2c0fa

It's meant to allow multiple submits and awaits from various threads; 
the caller is responsible for making sure that people stop calling 
submit() before anyone calls await() in seriousness.

I do need backpressure; I've been achieving that with an 
ArrayBlockingQueue(ncpus * 10) and a CallerRunsPolicy, and the *10 is 
meant to deal with the uneven-ness in the task sizes. Is that sane?

S.

On 08/18/2017 02:06 PM, Josh Humphries wrote:
> Sorry that my suggestion got broken into two message. Indeed my first 
> suggestion was incomplete. But the second suggestion, of using a 
> CompletionService should suffice. Would you queue up 50 million tasks in 
> the scenario you describe or do you also need a solution that provides 
> back-pressure?
> 
> Without back-pressure, it's simple enough to submit everything to a 
> CompletionService and then poll as many as you submitted when done. But 
> that also will buffer up all results as they complete (and if using a 
> limited-capacity queue, it could deadlock if it's the same thread 
> submitting as polling).
> 
> If you need backpressure, I'd imagine something more like this:
> 
>   * One thread pulling tasks as they come and submitting to the
>     CompletionService.
>       o Before submitting each task:
>           + Acquire a permit from a semaphore that has been setup with
>             the maximum number of in-flight/queued tasks you want.
>           + Increment a counter (e.g. AtomicLong).
>       o After submitting the last task (e.g. end of stream has been
>         detected), set a flag (AtomicBoolean) and then also submit a
>         no-op task (sentinel) to the CompletionService.
>           + Acquire permit and increment counter, even for the no-op task
>   * Have a second thread that is awaiting completion of all tasks. It is
>     in a loop polling the CompletionService.
>       o After polling a task, add exception to list of failures if list
>         is not already maxed out (e.g. already extracted 100 failures).
>       o Also release a permit back to the semaphore and decrement the
>         counter.
>       o If counter has reached zero and flag is set, all tasks are
>         processed. Done!
>       o Otherwise, go back to top of loop, to poll next task.
> 
> 
> ----
> *Josh Humphries*
> jhump at bluegosling.com <mailto:jhump at bluegosling.com>
> 
> On Fri, Aug 18, 2017 at 4:54 PM, Shevek <shevek at anarres.org 
> <mailto:shevek at anarres.org>> wrote:
> 
>     I can't use CountDownLatch because of the streamy nature of the
>     source. I have no idea how many tasks there are going to be up
>     front. I read an incoming stream, it turns out there's about 50
>     million in it, and this is going to go up by the usual orders of
>     magnitude.
> 
>     I could use a List of CountDownLatches each with ... but then I
>     rapidly get into "Someone cleverer than me MUST have solved this
>     before" territory.
> 
>     I can do my own tricks with an AtomicLong and wait()/notify(), but I
>     have to make sure the master thread calls get() on the relevant
>     Future each time a job finishes, otherwise there isn't a
>     happens-before relationship with the master thread, so I'd need the
>     job to put its own Future onto a Deque, or something...?
> 
>     The tasks all return Void, but it's nice to collect the first few
>     exceptions (currently there are about 750,000 total exceptions thrown).
> 
>     S.
> 
>     On 08/18/2017 01:48 PM, Josh Humphries wrote:
> 
>         I think the easiest thing would be to decorate each task to call
>         "latch.countDown()" on a CountDownLatch that is initialized with
>         the total number of tasks. After they are all submitted, the
>         code that wants to wait for them to finish would simply await
>         the latch. This decouples completion of all tasks from the
>         actual ExecutorService that is running them, so you can share
>         the same ExecutorService for multiple, even overlapping, sets of
>         tasks.
> 
>         ----
>         *Josh Humphries*
>         jhump at bluegosling.com <mailto:jhump at bluegosling.com>
>         <mailto:jhump at bluegosling.com <mailto:jhump at bluegosling.com>>
> 
> 
>         On Fri, Aug 18, 2017 at 4:42 PM, Shevek <shevek at anarres.org
>         <mailto:shevek at anarres.org> <mailto:shevek at anarres.org
>         <mailto:shevek at anarres.org>>> wrote:
> 
>              Hi,
> 
>              I need to build a complicated object on a multiprocessor
>         system. The
>              target object uses synchronization to guarantee thread-safe
>         access.
>              However, the individual tasks which build elements of the
>         target
>              object are expensive, so I farm them out to an
>         ExecutorService. The
>              question is:
> 
>              What is the recommended way to submit a stream of tasks to an
>              ExecutorService, and then at a point, wait until they're
>         all done.
> 
>              * I don't know the list of tasks up front. I read them
>         iteratively
>              from a set of files or events.
>              * A big collection of Future(s) isn't realistic, there are
>         just too
>              many tasks.
>              * Reaping completed futures on submission means that I end
>         up with
>              exceptions in weird places; I really need to gather max 100
>              suppressed exceptions, and discard the rest.
>              * ForkJoinPool has invoke() but I think for a million-task
>         job, I
>              still end up with a huge list of futures. This also assumes
>         I ignore
>              the note about synchronization.
>              * CompletionService allows me to wait for _any_ of the
>         submitted
>              tasks, but not for _all_ of them.
> 
>              * Bonus points for sharing a single ExecutorService and having
>              "sets" of tasks which can be independently awaited. This
>         starts to
>              sound very like FJP, except for the blocking/I/O and the
>         stream-ness
>              of my task set.
> 
>              Mostly, dear list, I'm expecting a one-liner from some API
>         class
>              that I've missed because this is NOT an original request, I
>         just
>              can't find a standard solution.
> 
>              Thank you.
> 
>              S.
>              _______________________________________________
>              Concurrency-interest mailing list
>         Concurrency-interest at cs.oswego.edu
>         <mailto:Concurrency-interest at cs.oswego.edu>
>              <mailto:Concurrency-interest at cs.oswego.edu
>         <mailto:Concurrency-interest at cs.oswego.edu>>
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>              <http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>>
> 
> 
> 

From jhump at bluegosling.com  Fri Aug 18 17:54:12 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Fri, 18 Aug 2017 17:54:12 -0400
Subject: [concurrency-interest] Awaiting a set of tasks on an
	ExecutorService
In-Reply-To: <5b1bed26-db2d-623e-06e1-a7eced9b7670@anarres.org>
References: <c1f2f48a-6554-22d5-3587-d987ce63fcb6@anarres.org>
 <CAO78j+LaEKB5g3ED+SYi2mJDYrbxzQJJjqjXdERh8uQmEYgKUQ@mail.gmail.com>
 <cee5292e-b306-8f42-aaab-eda1c8fc1516@anarres.org>
 <CAO78j+JjuGAERjnuvT-+QDQnMm++Bvu2D0ZzHgTCSgNdFNqSyQ@mail.gmail.com>
 <5b1bed26-db2d-623e-06e1-a7eced9b7670@anarres.org>
Message-ID: <CAO78j+L87fZ7q0-Z86W807pmsWK-wNRpukqvBidzhR8eKhDDhw@mail.gmail.com>

On Fri, Aug 18, 2017 at 5:38 PM, Shevek <shevek at anarres.org> wrote:

> Thank you all.
>
> I now have this:
>
> https://gist.github.com/shevek/5f8b3fad55c346ca1391349404a2c0fa


>
> It's meant to allow multiple submits and awaits from various threads; the
> caller is responsible for making sure that people stop calling submit()
> before anyone calls await() in seriousness.
>
> I do need backpressure; I've been achieving that with an
> ArrayBlockingQueue(ncpus * 10) and a CallerRunsPolicy, and the *10 is meant
> to deal with the uneven-ness in the task sizes. Is that sane?
>

Definitely sane! ThreadPoolExecutor's rejection policy + fixed capacity
queue is definitely the way to do backpressure. I would have suggested it,
but wasn't sure if you needed to re-use ExecutorService because it was some
sort of otherwise shared resource. (In which case, relying on that for
backpressure vs. a separate mechanism could starve other clients of the
thread pool.)



>
> S.
>
> On 08/18/2017 02:06 PM, Josh Humphries wrote:
>
>> Sorry that my suggestion got broken into two message. Indeed my first
>> suggestion was incomplete. But the second suggestion, of using a
>> CompletionService should suffice. Would you queue up 50 million tasks in
>> the scenario you describe or do you also need a solution that provides
>> back-pressure?
>>
>> Without back-pressure, it's simple enough to submit everything to a
>> CompletionService and then poll as many as you submitted when done. But
>> that also will buffer up all results as they complete (and if using a
>> limited-capacity queue, it could deadlock if it's the same thread
>> submitting as polling).
>>
>> If you need backpressure, I'd imagine something more like this:
>>
>>   * One thread pulling tasks as they come and submitting to the
>>     CompletionService.
>>       o Before submitting each task:
>>           + Acquire a permit from a semaphore that has been setup with
>>             the maximum number of in-flight/queued tasks you want.
>>           + Increment a counter (e.g. AtomicLong).
>>       o After submitting the last task (e.g. end of stream has been
>>         detected), set a flag (AtomicBoolean) and then also submit a
>>         no-op task (sentinel) to the CompletionService.
>>           + Acquire permit and increment counter, even for the no-op task
>>   * Have a second thread that is awaiting completion of all tasks. It is
>>     in a loop polling the CompletionService.
>>       o After polling a task, add exception to list of failures if list
>>         is not already maxed out (e.g. already extracted 100 failures).
>>       o Also release a permit back to the semaphore and decrement the
>>         counter.
>>       o If counter has reached zero and flag is set, all tasks are
>>         processed. Done!
>>       o Otherwise, go back to top of loop, to poll next task.
>>
>>
>> ----
>> *Josh Humphries*
>> jhump at bluegosling.com <mailto:jhump at bluegosling.com>
>>
>> On Fri, Aug 18, 2017 at 4:54 PM, Shevek <shevek at anarres.org <mailto:
>> shevek at anarres.org>> wrote:
>>
>>     I can't use CountDownLatch because of the streamy nature of the
>>     source. I have no idea how many tasks there are going to be up
>>     front. I read an incoming stream, it turns out there's about 50
>>     million in it, and this is going to go up by the usual orders of
>>     magnitude.
>>
>>     I could use a List of CountDownLatches each with ... but then I
>>     rapidly get into "Someone cleverer than me MUST have solved this
>>     before" territory.
>>
>>     I can do my own tricks with an AtomicLong and wait()/notify(), but I
>>     have to make sure the master thread calls get() on the relevant
>>     Future each time a job finishes, otherwise there isn't a
>>     happens-before relationship with the master thread, so I'd need the
>>     job to put its own Future onto a Deque, or something...?
>>
>>     The tasks all return Void, but it's nice to collect the first few
>>     exceptions (currently there are about 750,000 total exceptions
>> thrown).
>>
>>     S.
>>
>>     On 08/18/2017 01:48 PM, Josh Humphries wrote:
>>
>>         I think the easiest thing would be to decorate each task to call
>>         "latch.countDown()" on a CountDownLatch that is initialized with
>>         the total number of tasks. After they are all submitted, the
>>         code that wants to wait for them to finish would simply await
>>         the latch. This decouples completion of all tasks from the
>>         actual ExecutorService that is running them, so you can share
>>         the same ExecutorService for multiple, even overlapping, sets of
>>         tasks.
>>
>>         ----
>>         *Josh Humphries*
>>         jhump at bluegosling.com <mailto:jhump at bluegosling.com>
>>         <mailto:jhump at bluegosling.com <mailto:jhump at bluegosling.com>>
>>
>>
>>         On Fri, Aug 18, 2017 at 4:42 PM, Shevek <shevek at anarres.org
>>         <mailto:shevek at anarres.org> <mailto:shevek at anarres.org
>>
>>         <mailto:shevek at anarres.org>>> wrote:
>>
>>              Hi,
>>
>>              I need to build a complicated object on a multiprocessor
>>         system. The
>>              target object uses synchronization to guarantee thread-safe
>>         access.
>>              However, the individual tasks which build elements of the
>>         target
>>              object are expensive, so I farm them out to an
>>         ExecutorService. The
>>              question is:
>>
>>              What is the recommended way to submit a stream of tasks to an
>>              ExecutorService, and then at a point, wait until they're
>>         all done.
>>
>>              * I don't know the list of tasks up front. I read them
>>         iteratively
>>              from a set of files or events.
>>              * A big collection of Future(s) isn't realistic, there are
>>         just too
>>              many tasks.
>>              * Reaping completed futures on submission means that I end
>>         up with
>>              exceptions in weird places; I really need to gather max 100
>>              suppressed exceptions, and discard the rest.
>>              * ForkJoinPool has invoke() but I think for a million-task
>>         job, I
>>              still end up with a huge list of futures. This also assumes
>>         I ignore
>>              the note about synchronization.
>>              * CompletionService allows me to wait for _any_ of the
>>         submitted
>>              tasks, but not for _all_ of them.
>>
>>              * Bonus points for sharing a single ExecutorService and
>> having
>>              "sets" of tasks which can be independently awaited. This
>>         starts to
>>              sound very like FJP, except for the blocking/I/O and the
>>         stream-ness
>>              of my task set.
>>
>>              Mostly, dear list, I'm expecting a one-liner from some API
>>         class
>>              that I've missed because this is NOT an original request, I
>>         just
>>              can't find a standard solution.
>>
>>              Thank you.
>>
>>              S.
>>              _______________________________________________
>>              Concurrency-interest mailing list
>>         Concurrency-interest at cs.oswego.edu
>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>              <mailto:Concurrency-interest at cs.oswego.edu
>>         <mailto:Concurrency-interest at cs.oswego.edu>>
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>              <http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>>
>>
>>
>>
>> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170818/37b0f546/attachment-0001.html>

From jhump at bluegosling.com  Sat Aug 19 12:44:11 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Sat, 19 Aug 2017 12:44:11 -0400
Subject: [concurrency-interest] Awaiting a set of tasks on an
	ExecutorService
In-Reply-To: <5b1bed26-db2d-623e-06e1-a7eced9b7670@anarres.org>
References: <c1f2f48a-6554-22d5-3587-d987ce63fcb6@anarres.org>
 <CAO78j+LaEKB5g3ED+SYi2mJDYrbxzQJJjqjXdERh8uQmEYgKUQ@mail.gmail.com>
 <cee5292e-b306-8f42-aaab-eda1c8fc1516@anarres.org>
 <CAO78j+JjuGAERjnuvT-+QDQnMm++Bvu2D0ZzHgTCSgNdFNqSyQ@mail.gmail.com>
 <5b1bed26-db2d-623e-06e1-a7eced9b7670@anarres.org>
Message-ID: <CAO78j+K_m0WsqbEX1ueMMjVOohbpETj9UH17GupeqyudQHeZzQ@mail.gmail.com>

On Fri, Aug 18, 2017 at 5:38 PM, Shevek <shevek at anarres.org> wrote:

> Thank you all.
>
> I now have this:
>
> https://gist.github.com/shevek/5f8b3fad55c346ca1391349404a2c0fa
>
> It's meant to allow multiple submits and awaits from various threads; the
> caller is responsible for making sure that people stop calling submit()
> before anyone calls await() in seriousness.
>

Thinking about this a bit more, I think Nathan Reynold's suggestion to use
a Phaser, instead of my CompletionService idea, would be better. This will
result in less garbage (since you don't need to create and queue futures --
"execute" the tasks instead of "submit" them) and allows you to skip the
logic that drains the completion service queue as tasks are submitted, to
prevent too many from accumulating (which is non-deterministic and could
still result in a large number of futures queued up if many tasks can
complete in between calls to add new tasks).

As tasks are submitted, "register" with the phaser. Then you need only
"await" the phaser's current/latest phase at the end. You'd then decorate
each task to catch any throwables (and record up to 100, or whatever limit,
in a concurrent or synchronized collection) as well as finally "arrive"
with the phaser on completion.

Phaser's API is a bit confusing IMO (capable of supporting far more complex
use cases than this one). I've written simple "up-and-down" latches (on top
of AbstractQueuedSynchronizer) that result in easier to read and understand
usages (more-or-less like Go's sync.WaitGroup), but I can't seem to find a
link to one right now (I guess the ones I've written weren't in any
open-source projects). If I find one, I'll send it in case it helps.


> I do need backpressure; I've been achieving that with an
> ArrayBlockingQueue(ncpus * 10) and a CallerRunsPolicy, and the *10 is meant
> to deal with the uneven-ness in the task sizes. Is that sane?
>
> S.
>
> On 08/18/2017 02:06 PM, Josh Humphries wrote:
>
>> Sorry that my suggestion got broken into two message. Indeed my first
>> suggestion was incomplete. But the second suggestion, of using a
>> CompletionService should suffice. Would you queue up 50 million tasks in
>> the scenario you describe or do you also need a solution that provides
>> back-pressure?
>>
>> Without back-pressure, it's simple enough to submit everything to a
>> CompletionService and then poll as many as you submitted when done. But
>> that also will buffer up all results as they complete (and if using a
>> limited-capacity queue, it could deadlock if it's the same thread
>> submitting as polling).
>>
>> If you need backpressure, I'd imagine something more like this:
>>
>>   * One thread pulling tasks as they come and submitting to the
>>     CompletionService.
>>       o Before submitting each task:
>>           + Acquire a permit from a semaphore that has been setup with
>>             the maximum number of in-flight/queued tasks you want.
>>           + Increment a counter (e.g. AtomicLong).
>>       o After submitting the last task (e.g. end of stream has been
>>         detected), set a flag (AtomicBoolean) and then also submit a
>>         no-op task (sentinel) to the CompletionService.
>>           + Acquire permit and increment counter, even for the no-op task
>>   * Have a second thread that is awaiting completion of all tasks. It is
>>     in a loop polling the CompletionService.
>>       o After polling a task, add exception to list of failures if list
>>         is not already maxed out (e.g. already extracted 100 failures).
>>       o Also release a permit back to the semaphore and decrement the
>>         counter.
>>       o If counter has reached zero and flag is set, all tasks are
>>         processed. Done!
>>       o Otherwise, go back to top of loop, to poll next task.
>>
>>
>> ----
>> *Josh Humphries*
>> jhump at bluegosling.com <mailto:jhump at bluegosling.com>
>>
>> On Fri, Aug 18, 2017 at 4:54 PM, Shevek <shevek at anarres.org <mailto:
>> shevek at anarres.org>> wrote:
>>
>>     I can't use CountDownLatch because of the streamy nature of the
>>     source. I have no idea how many tasks there are going to be up
>>     front. I read an incoming stream, it turns out there's about 50
>>     million in it, and this is going to go up by the usual orders of
>>     magnitude.
>>
>>     I could use a List of CountDownLatches each with ... but then I
>>     rapidly get into "Someone cleverer than me MUST have solved this
>>     before" territory.
>>
>>     I can do my own tricks with an AtomicLong and wait()/notify(), but I
>>     have to make sure the master thread calls get() on the relevant
>>     Future each time a job finishes, otherwise there isn't a
>>     happens-before relationship with the master thread, so I'd need the
>>     job to put its own Future onto a Deque, or something...?
>>
>>     The tasks all return Void, but it's nice to collect the first few
>>     exceptions (currently there are about 750,000 total exceptions
>> thrown).
>>
>>     S.
>>
>>     On 08/18/2017 01:48 PM, Josh Humphries wrote:
>>
>>         I think the easiest thing would be to decorate each task to call
>>         "latch.countDown()" on a CountDownLatch that is initialized with
>>         the total number of tasks. After they are all submitted, the
>>         code that wants to wait for them to finish would simply await
>>         the latch. This decouples completion of all tasks from the
>>         actual ExecutorService that is running them, so you can share
>>         the same ExecutorService for multiple, even overlapping, sets of
>>         tasks.
>>
>>         ----
>>         *Josh Humphries*
>>         jhump at bluegosling.com <mailto:jhump at bluegosling.com>
>>         <mailto:jhump at bluegosling.com <mailto:jhump at bluegosling.com>>
>>
>>
>>         On Fri, Aug 18, 2017 at 4:42 PM, Shevek <shevek at anarres.org
>>         <mailto:shevek at anarres.org> <mailto:shevek at anarres.org
>>
>>         <mailto:shevek at anarres.org>>> wrote:
>>
>>              Hi,
>>
>>              I need to build a complicated object on a multiprocessor
>>         system. The
>>              target object uses synchronization to guarantee thread-safe
>>         access.
>>              However, the individual tasks which build elements of the
>>         target
>>              object are expensive, so I farm them out to an
>>         ExecutorService. The
>>              question is:
>>
>>              What is the recommended way to submit a stream of tasks to an
>>              ExecutorService, and then at a point, wait until they're
>>         all done.
>>
>>              * I don't know the list of tasks up front. I read them
>>         iteratively
>>              from a set of files or events.
>>              * A big collection of Future(s) isn't realistic, there are
>>         just too
>>              many tasks.
>>              * Reaping completed futures on submission means that I end
>>         up with
>>              exceptions in weird places; I really need to gather max 100
>>              suppressed exceptions, and discard the rest.
>>              * ForkJoinPool has invoke() but I think for a million-task
>>         job, I
>>              still end up with a huge list of futures. This also assumes
>>         I ignore
>>              the note about synchronization.
>>              * CompletionService allows me to wait for _any_ of the
>>         submitted
>>              tasks, but not for _all_ of them.
>>
>>              * Bonus points for sharing a single ExecutorService and
>> having
>>              "sets" of tasks which can be independently awaited. This
>>         starts to
>>              sound very like FJP, except for the blocking/I/O and the
>>         stream-ness
>>              of my task set.
>>
>>              Mostly, dear list, I'm expecting a one-liner from some API
>>         class
>>              that I've missed because this is NOT an original request, I
>>         just
>>              can't find a standard solution.
>>
>>              Thank you.
>>
>>              S.
>>              _______________________________________________
>>              Concurrency-interest mailing list
>>         Concurrency-interest at cs.oswego.edu
>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>              <mailto:Concurrency-interest at cs.oswego.edu
>>         <mailto:Concurrency-interest at cs.oswego.edu>>
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>              <http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>>
>>
>>
>>
>> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170819/15bebf27/attachment.html>

From concurrency-interest at stefan-marr.de  Wed Aug 23 10:24:13 2017
From: concurrency-interest at stefan-marr.de (Stefan Marr)
Date: Wed, 23 Aug 2017 16:24:13 +0200
Subject: [concurrency-interest] Call for Presentations and Participation:
 4th Virtual Machine Meetup, co-located with ManLang'17
Message-ID: <044AA0BF-6EB6-4806-98FF-2F1715EB1AC3@stefan-marr.de>

                    Call for Participation: VMM’17
                    ==============================

                      4th Virtual Machine Meetup

                        Co-located with ManLang
               September 27-29, 2017, Prague, Czech Republic
                   
                    http://vmmeetup.github.io/2017/


The 4th Virtual Machine Meetup (VMM'17) is a venue for discussing the latest
research and developments in the area of managed language execution. It will be
held from 27th to 29th of September at the Charles University Prague,
Prague, Czech Republic and is colocated with the Managed Languages conference
2017 (http://d3s.mff.cuni.cz/conferences/manlang17/). We welcome presentations of new
research results, experience reports, as well as position statements that can
lead to interesting discussions.


Topics include, but are not limited to:

 - Programming language design
 - Dynamic and static program analysis
 - Compiler construction
 - Managed runtime architectures
 - Data processing engines
 - Distributed execution environments

Participation is free of charge! To participate, please register at
"http://d3s.mff.cuni.cz/conferences/manlang17/?n=Main.Registration".
There are limited participant slots due to the constraints of the room,
so please register early, and by September 19th the latest.

If you would like to give a presentation, please submit a presentation abstract 
(a title with max. 100 characters and an abstract with max. 400 characters) to
https://ssw.jku.at/VMM17/.
We may ask for additional information from you before making the program decision.
Presentation slots are either 30 minutes (long) or 15 minutes (short)
including Q/A.


Important dates:

 - Submissions:  August 31st, 2017
 - Author notification: September 1st, 2017
 - Registration for participation: September 19th, 2017
 - Virtual machine Meetup: Sep 27th to 29th at Charles University Prague
 - Social Event: Sep 29th 2017, optional

Submission link:

 - https://ssw.jku.at/VMM17/

Program committee:

 - Stefan Marr, JKU Linz, Austria
 - Matthias Grimmer, Oracle Labs Austria
 - Thomas Wuerthinger, Oracle Labs Switzerland

From aph at redhat.com  Fri Aug 25 05:37:08 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 25 Aug 2017 10:37:08 +0100
Subject: [concurrency-interest] On park and unpark
Message-ID: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>

At the bottom of every blocking operation in j.u.c is the park/unpark
pair.  I'm curious about the choice of these primitives.  Herlihy et
al [1] use a mutex/condvar when they want to block (as indeed does
HotSpot's implementation of park/unpark) and I haven't been able to
find park and unpark in high-level lanuguages apart from Java.

To my questions: why use park/unpark in j.u.c?  And where does the
original idea come from anyway?  I see that BSD and Solaris have the
lwp_park syscall so perhaps Java's park/unpark was based on that, but
we don't use lwp_park in HotSpot, even for Solaris.

Maybe park/unpark were actually invented someone at by BSD, but Forth
has used a very similar primitive (STOP and awaken) since the 1970s.
Perhaps the idea is "just obvious" and has been reinvented several
times.

[1] The Art of Multiprocessor Programming, Maurice Herlihy, Nir
Shavit, Morgan Kaufmann, 2011

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From dl at cs.oswego.edu  Fri Aug 25 07:12:45 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 25 Aug 2017 07:12:45 -0400
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
Message-ID: <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>

On 08/25/2017 05:37 AM, Andrew Haley wrote:
> At the bottom of every blocking operation in j.u.c is the park/unpark
> pair.  I'm curious about the choice of these primitives. 

They were introduced by Dave Dice (in hotspot) and me (in j.u.c
in the original jsr166), as the most OS-independent low-level blocking
primitives we could imagine -- it is a leaky one-bit semaphore,
inspired in part from some 1990s DEC SRC papers. My 2004 AQS paper
http://gee.cs.oswego.edu/dl/papers/aqs.pdf includes some discussion.

BTW, on linux, it should be more efficient to implement using
Futex instead of the current scheme based on original Solaris
version. But no one has ever volunteered to do this.

-Doug

From bronee at gmail.com  Fri Aug 25 10:34:41 2017
From: bronee at gmail.com (Brian S O'Neill)
Date: Fri, 25 Aug 2017 07:34:41 -0700
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
Message-ID: <4374f57b-51b6-f671-37ed-4834e2fde6cb@gmail.com>

What would be the potential wins from using a Futex directly? By the 
time park/unpark is called (from AQS et al), the thread has determined 
that the expensive operation must be performed. Is there any step that 
the Futex could potentially bypass?

On 2017-08-25 04:12 AM, Doug Lea wrote:
> On 08/25/2017 05:37 AM, Andrew Haley wrote:
>> At the bottom of every blocking operation in j.u.c is the park/unpark
>> pair.  I'm curious about the choice of these primitives.
> 
> They were introduced by Dave Dice (in hotspot) and me (in j.u.c
> in the original jsr166), as the most OS-independent low-level blocking
> primitives we could imagine -- it is a leaky one-bit semaphore,
> inspired in part from some 1990s DEC SRC papers. My 2004 AQS paper
> http://gee.cs.oswego.edu/dl/papers/aqs.pdf includes some discussion.
> 
> BTW, on linux, it should be more efficient to implement using
> Futex instead of the current scheme based on original Solaris
> version. But no one has ever volunteered to do this.
> 
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From aph at redhat.com  Fri Aug 25 11:12:11 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 25 Aug 2017 16:12:11 +0100
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
Message-ID: <1df357e5-cee3-ddde-c6aa-e3d061705e25@redhat.com>

On 25/08/17 12:12, Doug Lea wrote:
> BTW, on linux, it should be more efficient to implement using
> Futex instead of the current scheme based on original Solaris
> version. But no one has ever volunteered to do this.

I've done it, and could not measure any difference.  In the case where
the kernel blocks, the additional savings from not doing the
mutex/condvar are small: syscall overhead dominates.  In the case
where we return immediately it makes no difference because we (almost)
never get as far as the futex call.  So I never submitted the patch.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From dl at cs.oswego.edu  Fri Aug 25 12:28:33 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 25 Aug 2017 12:28:33 -0400
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <1df357e5-cee3-ddde-c6aa-e3d061705e25@redhat.com>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <1df357e5-cee3-ddde-c6aa-e3d061705e25@redhat.com>
Message-ID: <4da3b132-5698-a79e-0883-a9bffc537658@cs.oswego.edu>

On 08/25/2017 11:12 AM, Andrew Haley wrote:
> On 25/08/17 12:12, Doug Lea wrote:
>> BTW, on linux, it should be more efficient to implement using
>> Futex instead of the current scheme based on original Solaris
>> version. But no one has ever volunteered to do this.
> 
> I've done it, and could not measure any difference. 
Well, it should still save a few electrons (or millions, across
deployments), so still seems to be the Right Thing to do.

-Doug

From nathanila at gmail.com  Fri Aug 25 12:49:47 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Fri, 25 Aug 2017 10:49:47 -0600
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <4da3b132-5698-a79e-0883-a9bffc537658@cs.oswego.edu>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <1df357e5-cee3-ddde-c6aa-e3d061705e25@redhat.com>
 <4da3b132-5698-a79e-0883-a9bffc537658@cs.oswego.edu>
Message-ID: <da0152f6-3bc6-04c2-831d-d91e8b90de08@gmail.com>

Several years ago, I saw Linux futex perform poorly in the kernel.  
Futex was getting a bad rap by others as well.  In my experience, the 
kernel would spend a lot of CPU time dealing with futexes.  I do not 
remember the circumstances that cause this scenario.  So, I recommend 
proceeding with caution and lots of testing.  Perhaps, this caution is 
not warranted and the problem was fixed in the kernel.

For the blocking case, I would guess there would not be much difference 
in performance.

I recommend running some microbenchmark tests for the non-blocking case 
(i.e. unpark() before park()).  You might see a CPU performance gain.

-Nathan

On 8/25/2017 10:28 AM, Doug Lea wrote:
> On 08/25/2017 11:12 AM, Andrew Haley wrote:
>> On 25/08/17 12:12, Doug Lea wrote:
>>> BTW, on linux, it should be more efficient to implement using
>>> Futex instead of the current scheme based on original Solaris
>>> version. But no one has ever volunteered to do this.
>> I've done it, and could not measure any difference.
> Well, it should still save a few electrons (or millions, across
> deployments), so still seems to be the Right Thing to do.
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-- 
-Nathan


From aph at redhat.com  Fri Aug 25 12:53:57 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 25 Aug 2017 17:53:57 +0100
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <da0152f6-3bc6-04c2-831d-d91e8b90de08@gmail.com>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <1df357e5-cee3-ddde-c6aa-e3d061705e25@redhat.com>
 <4da3b132-5698-a79e-0883-a9bffc537658@cs.oswego.edu>
 <da0152f6-3bc6-04c2-831d-d91e8b90de08@gmail.com>
Message-ID: <270dc40c-e19a-4aac-b574-70d2ca2361af@redhat.com>

On 25/08/17 17:49, Nathan and Ila Reynolds wrote:
> Several years ago, I saw Linux futex perform poorly in the kernel.  
> Futex was getting a bad rap by others as well.  In my experience, the 
> kernel would spend a lot of CPU time dealing with futexes.  I do not 
> remember the circumstances that cause this scenario.  So, I recommend 
> proceeding with caution and lots of testing.  Perhaps, this caution is 
> not warranted and the problem was fixed in the kernel.

That's won't help, because Linux mutexes always use futex.  There's
no way to bypass a futex call if you block.

> For the blocking case, I would guess there would not be much difference 
> in performance.
> 
> I recommend running some microbenchmark tests for the non-blocking case 
> (i.e. unpark() before park()).  You might see a CPU performance gain.

Really?  I doubt it, because the park permit flag would be set so the
park() return immediately.  The only time that wouldn't happen is a
narrow race condition between that flag being tested and a mutex being
acquired.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From nathanila at gmail.com  Fri Aug 25 13:01:14 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Fri, 25 Aug 2017 11:01:14 -0600
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <270dc40c-e19a-4aac-b574-70d2ca2361af@redhat.com>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <1df357e5-cee3-ddde-c6aa-e3d061705e25@redhat.com>
 <4da3b132-5698-a79e-0883-a9bffc537658@cs.oswego.edu>
 <da0152f6-3bc6-04c2-831d-d91e8b90de08@gmail.com>
 <270dc40c-e19a-4aac-b574-70d2ca2361af@redhat.com>
Message-ID: <ef2c22ec-4ddf-a261-537c-defee74951d6@gmail.com>

Thank you for clarifying the details.  I was not fully up to speed.

Last I heard (and this is old hearing), unpark() had to acquire the 
mutex before checking the park permit flag.  From the sound of it, using 
futex directly would allow for checking the park permit flag without 
acquiring the mutex.  Hence, fewer atomic operations (i.e. no need to 
acquire and release the mutex).  However, I could be very wrong since I 
have never dug into the details and I am only working off of hearsay.

-Nathan

On 8/25/2017 10:53 AM, Andrew Haley wrote:
> On 25/08/17 17:49, Nathan and Ila Reynolds wrote:
>> Several years ago, I saw Linux futex perform poorly in the kernel.
>> Futex was getting a bad rap by others as well.  In my experience, the
>> kernel would spend a lot of CPU time dealing with futexes.  I do not
>> remember the circumstances that cause this scenario.  So, I recommend
>> proceeding with caution and lots of testing.  Perhaps, this caution is
>> not warranted and the problem was fixed in the kernel.
> That's won't help, because Linux mutexes always use futex.  There's
> no way to bypass a futex call if you block.
>
>> For the blocking case, I would guess there would not be much difference
>> in performance.
>>
>> I recommend running some microbenchmark tests for the non-blocking case
>> (i.e. unpark() before park()).  You might see a CPU performance gain.
> Really?  I doubt it, because the park permit flag would be set so the
> park() return immediately.  The only time that wouldn't happen is a
> narrow race condition between that flag being tested and a mutex being
> acquired.
>

-- 
-Nathan


From paul.sandoz at oracle.com  Fri Aug 25 13:02:48 2017
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Fri, 25 Aug 2017 10:02:48 -0700
Subject: [concurrency-interest] VarHandle.setVolatile vs classical
	volatile write
In-Reply-To: <CAAWwtm-nCv=iYvVVRUHJyJUg_4nO-KXkFs8=mRRxwoZgqTxCYQ@mail.gmail.com>
References: <CAAWwtm9eT8-OiVhW=8k6xYS4=7mo363-THxjFuW5Cy3JpepHGA@mail.gmail.com>
 <4CF0185D-0FA3-41BD-9284-B69FD235096E@oracle.com>
 <CAAWwtm-nCv=iYvVVRUHJyJUg_4nO-KXkFs8=mRRxwoZgqTxCYQ@mail.gmail.com>
Message-ID: <BBE78468-0987-452F-9B87-082CEF06E339@oracle.com>


> On 18 Aug 2017, at 13:58, Dávid Karnok <akarnokd at gmail.com> wrote:
> 
> Thanks. I did a benchmark (https://gist.github.com/akarnokd/c0d606bd7e29d143ee82f2026898dbb5 <https://gist.github.com/akarnokd/c0d606bd7e29d143ee82f2026898dbb5>) and got the following results:
> 
> i5 6440HQ, Windows 10 x64, Java 9b181, JMH 1.19
> 
> Benchmark                       Mode  Cnt          Score         Error  Units
> VolatilePerf.getAndAdd         thrpt    5  117841308,999 ± 3940711,142  ops/s
> VolatilePerf.getAndSet         thrpt    5  118162019,136 ± 1349823,016  ops/s
> VolatilePerf.releaseGetAndAdd  thrpt    5  118688354,409 ±  642044,969  ops/s
> VolatilePerf.setRelease        thrpt    5  890890009,555 ± 4323041,380  ops/s
> VolatilePerf.setVolatile       thrpt    5  118419990,949 ±  793885,407  ops/s
> 
> 
> Being on Windows and on a Laptop usually yields some variance, but looks like there is practically minimal difference between the full barrier operations. 
> 

Ok, good to know, thanks for dong that!


> Btw, thinking about XCHG and XADD, they have to provide the same strong volatile read and write as they both read and write something atomically. I would have thought XADD involving some ALU is detectably more costly but a 3 cycle addition is relatively small compared to a 22-45 cycle cache action.
> 

Yes, good point.

Paul.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170825/ffe523f2/attachment.html>

From aph at redhat.com  Fri Aug 25 13:28:30 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 25 Aug 2017 18:28:30 +0100
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <ef2c22ec-4ddf-a261-537c-defee74951d6@gmail.com>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <1df357e5-cee3-ddde-c6aa-e3d061705e25@redhat.com>
 <4da3b132-5698-a79e-0883-a9bffc537658@cs.oswego.edu>
 <da0152f6-3bc6-04c2-831d-d91e8b90de08@gmail.com>
 <270dc40c-e19a-4aac-b574-70d2ca2361af@redhat.com>
 <ef2c22ec-4ddf-a261-537c-defee74951d6@gmail.com>
Message-ID: <e3a7ca90-514c-8e92-274e-03d6b0cd3eda@redhat.com>

On 25/08/17 18:01, Nathan and Ila Reynolds wrote:
> Last I heard (and this is old hearing), unpark() had to acquire the 
> mutex before checking the park permit flag.  From the sound of it, using 
> futex directly would allow for checking the park permit flag without 
> acquiring the mutex.  Hence, fewer atomic operations (i.e. no need to 
> acquire and release the mutex).  However, I could be very wrong since I 
> have never dug into the details and I am only working off of hearsay.

Here's now it works now:

void Parker::park(bool isAbsolute, jlong time) {

  // Optional fast-path check:
  // Return immediately if a permit is available.
  // We depend on Atomic::xchg() having full barrier semantics
  // since we are doing a lock-free update to _counter.
  if (Atomic::xchg(0, &_counter) > 0) return;

... stuff with timers and thread interrupts ...

  // Don't wait if cannot get lock since interference arises from
  // unblocking.  Also. check interrupt before trying wait
  if (Thread::is_interrupted(thread, false) ||
      os::Solaris::mutex_trylock(_mutex) != 0) {
    return;
  }

  if (_counter > 0)  { // no wait needed
    _counter = 0;
    status = os::Solaris::mutex_unlock(_mutex);
    assert(status == 0, "invariant");
    // Paranoia to ensure our locked and lock-free paths interact
    // correctly with each other and Java-level accesses.
    OrderAccess::fence();
    return;
  }

...

  // Do this the hard way by blocking ...
  // See http://monaco.sfbay/detail.jsf?cr=5094058.
  if (time == 0) {
    status = os::Solaris::cond_wait(_cond, _mutex);
  } else {
    status = os::Solaris::cond_timedwait (_cond, _mutex, &absTime);
  }

But even if we had had to lock the mutex to read the _counter, it's
just a CAS which would always succeed unless we were being unparked.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From nathanila at gmail.com  Fri Aug 25 14:45:55 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Fri, 25 Aug 2017 12:45:55 -0600
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <e3a7ca90-514c-8e92-274e-03d6b0cd3eda@redhat.com>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <1df357e5-cee3-ddde-c6aa-e3d061705e25@redhat.com>
 <4da3b132-5698-a79e-0883-a9bffc537658@cs.oswego.edu>
 <da0152f6-3bc6-04c2-831d-d91e8b90de08@gmail.com>
 <270dc40c-e19a-4aac-b574-70d2ca2361af@redhat.com>
 <ef2c22ec-4ddf-a261-537c-defee74951d6@gmail.com>
 <e3a7ca90-514c-8e92-274e-03d6b0cd3eda@redhat.com>
Message-ID: <345440f2-b0ee-b868-5d35-98b28d68e9c0@gmail.com>

So, if we switch this to a futex, then we can get rid of the 
cond_wait/cond_timedwait calls.  Is this correct?  If correct, then this 
change will slightly reduce CPU usage and probably worth the effort.  
The change may reduce the code complexity and reduce maintenance costs.  
At least, the change will reduce the number of emails about suggesting 
that park/unpark uses futexes.  ;)

-Nathan

On 8/25/2017 11:28 AM, Andrew Haley wrote:
> On 25/08/17 18:01, Nathan and Ila Reynolds wrote:
>> Last I heard (and this is old hearing), unpark() had to acquire the
>> mutex before checking the park permit flag.  From the sound of it, using
>> futex directly would allow for checking the park permit flag without
>> acquiring the mutex.  Hence, fewer atomic operations (i.e. no need to
>> acquire and release the mutex).  However, I could be very wrong since I
>> have never dug into the details and I am only working off of hearsay.
> Here's now it works now:
>
> void Parker::park(bool isAbsolute, jlong time) {
>
>    // Optional fast-path check:
>    // Return immediately if a permit is available.
>    // We depend on Atomic::xchg() having full barrier semantics
>    // since we are doing a lock-free update to _counter.
>    if (Atomic::xchg(0, &_counter) > 0) return;
>
> ... stuff with timers and thread interrupts ...
>
>    // Don't wait if cannot get lock since interference arises from
>    // unblocking.  Also. check interrupt before trying wait
>    if (Thread::is_interrupted(thread, false) ||
>        os::Solaris::mutex_trylock(_mutex) != 0) {
>      return;
>    }
>
>    if (_counter > 0)  { // no wait needed
>      _counter = 0;
>      status = os::Solaris::mutex_unlock(_mutex);
>      assert(status == 0, "invariant");
>      // Paranoia to ensure our locked and lock-free paths interact
>      // correctly with each other and Java-level accesses.
>      OrderAccess::fence();
>      return;
>    }
>
> ...
>
>    // Do this the hard way by blocking ...
>    // See http://monaco.sfbay/detail.jsf?cr=5094058.
>    if (time == 0) {
>      status = os::Solaris::cond_wait(_cond, _mutex);
>    } else {
>      status = os::Solaris::cond_timedwait (_cond, _mutex, &absTime);
>    }
>
> But even if we had had to lock the mutex to read the _counter, it's
> just a CAS which would always succeed unless we were being unparked.
>

-- 
-Nathan


From david.dice at gmail.com  Fri Aug 25 15:12:56 2017
From: david.dice at gmail.com (David Dice)
Date: Fri, 25 Aug 2017 15:12:56 -0400
Subject: [concurrency-interest]  On park and unpark
Message-ID: <CANbRUchuCiRP-MjpVg5ptk4dMGsZSD9r7PGKrjWS-nkCs0pDnw@mail.gmail.com>

I've tried the futex (with the PRIVATE wait and wake) operators and didn't
see appreciable difference between that approach and the existing
mutex-condvar form.  If we're really going to block or unblock threads, the
extra overheads from the mutex-condvar layer are a tiny fraction of the
overall path.

The mutex should suffer contention infrequently, so the main cost of the
mutex-condvar form is arguably the atomics -- a local cost -- associated
with the mutex.

When I've floated the idea direct futex usage, folks have expressed concern
about the portability & stability of the interface over the wide range of
supported linux distributions.   This strikes me as a reasonable concern.
(We prefer "PRIVATE" for instance, but do all targeted distributions
support that flavor?).

Dave

p.s., it might make sense to check that the virtual address placement of
condvar -- which is fairly regular -- doesn't interact poorly with the
futex hash chain function, possibly resulting in excessive collisions and
poor distribution over the chains.   This issue would apply to both direct
futex usage and the condvar-mutex forms.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170825/0f439e46/attachment.html>

From aph at redhat.com  Fri Aug 25 16:29:57 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 25 Aug 2017 21:29:57 +0100
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <345440f2-b0ee-b868-5d35-98b28d68e9c0@gmail.com>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <1df357e5-cee3-ddde-c6aa-e3d061705e25@redhat.com>
 <4da3b132-5698-a79e-0883-a9bffc537658@cs.oswego.edu>
 <da0152f6-3bc6-04c2-831d-d91e8b90de08@gmail.com>
 <270dc40c-e19a-4aac-b574-70d2ca2361af@redhat.com>
 <ef2c22ec-4ddf-a261-537c-defee74951d6@gmail.com>
 <e3a7ca90-514c-8e92-274e-03d6b0cd3eda@redhat.com>
 <345440f2-b0ee-b868-5d35-98b28d68e9c0@gmail.com>
Message-ID: <ba541ab2-d715-356b-173e-2115a5b69c00@redhat.com>

On 25/08/17 19:45, Nathan and Ila Reynolds wrote:
> So, if we switch this to a futex, then we can get rid of the 
> cond_wait/cond_timedwait calls.  Is this correct?  If correct, then this 
> change will slightly reduce CPU usage and probably worth the effort.  

It'll get rid of the mutex_trylock and mutex_unlock calls.  It'll
replace the cond_wait/cond_timedwait calls with futex calls.

> The change may reduce the code complexity and reduce maintenance costs.

Sort of.  The current code, although it has had bugs in the past, is
robust enough that it needs very little maintance.  But I take your
point.

> At least, the change will reduce the number of emails about suggesting 
> that park/unpark uses futexes.  ;)

At best, probably.  :-)

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From aph at redhat.com  Fri Aug 25 16:34:14 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 25 Aug 2017 21:34:14 +0100
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <CANbRUchuCiRP-MjpVg5ptk4dMGsZSD9r7PGKrjWS-nkCs0pDnw@mail.gmail.com>
References: <CANbRUchuCiRP-MjpVg5ptk4dMGsZSD9r7PGKrjWS-nkCs0pDnw@mail.gmail.com>
Message-ID: <05dc3f8c-7ad7-232c-2829-b606e4631853@redhat.com>

On 25/08/17 20:12, David Dice wrote:
> When I've floated the idea direct futex usage, folks have expressed concern
> about the portability & stability of the interface over the wide range of
> supported linux distributions.

I suspect that concern is unjustified.  The interface between the
kernel and libc is, if anything, more stable than that between libc
and users' code.  There is no possibility of anyone breaking the
futex interface, but it all depends on how far back you want to go.

> This strikes me as a reasonable concern.
> (We prefer "PRIVATE" for instance, but do all targeted distributions
> support that flavor?).

Mmm, okay, you're worried about ancient kernels.  Seems unlikely,
but I take your point.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From davidcholmes at aapt.net.au  Fri Aug 25 18:29:42 2017
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 26 Aug 2017 08:29:42 +1000
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
Message-ID: <027801d31df1$a5bdf590$f139e0b0$@aapt.net.au>

Hi Doug,

> -----Original Message-----
> From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Doug Lea
> Sent: Friday, August 25, 2017 9:13 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] On park and unpark
> 
> On 08/25/2017 05:37 AM, Andrew Haley wrote:
> > At the bottom of every blocking operation in j.u.c is the park/unpark
> > pair.  I'm curious about the choice of these primitives.
> 
> They were introduced by Dave Dice (in hotspot) and me (in j.u.c in the original jsr166), as the most OS-independent low-level blocking
> primitives we could imagine -- it is a leaky one-bit semaphore, inspired in part from some 1990s DEC SRC papers. My 2004 AQS paper
> http://gee.cs.oswego.edu/dl/papers/aqs.pdf includes some discussion.
> 
> BTW, on linux, it should be more efficient to implement using Futex instead of the current scheme based on original Solaris version.
> But no one has ever volunteered to do this.

We've been trying to consolidate  and share as much common code as possible on "posix" supporting platforms and recently refactored things to share the PlatformEvent and Parker code (8174231). So to me there would have to be a big win in using futex directly to justify using a custom implementation.

Cheers,
David
 
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From aph at redhat.com  Sat Aug 26 05:03:22 2017
From: aph at redhat.com (Andrew Haley)
Date: Sat, 26 Aug 2017 10:03:22 +0100
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <027801d31df1$a5bdf590$f139e0b0$@aapt.net.au>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <027801d31df1$a5bdf590$f139e0b0$@aapt.net.au>
Message-ID: <402bc686-4c37-6ab8-7ada-038222394d9f@redhat.com>

On 25/08/17 23:29, David Holmes wrote:

> We've been trying to consolidate and share as much common code as
> possible on "posix" supporting platforms and recently refactored
> things to share the PlatformEvent and Parker code (8174231). So to
> me there would have to be a big win in using futex directly to
> justify using a custom implementation.

That seems rather surprising to me: HotSpot has always allowed (nay,
even encouraged) back ends to use custom code for performance reasons,
and has never insisted that there must be a "big win".  At least as
long as I can remember.  If there's been a change of policy in this
area it should be up for discussion.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From davidcholmes at aapt.net.au  Sat Aug 26 18:56:57 2017
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sun, 27 Aug 2017 08:56:57 +1000
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <402bc686-4c37-6ab8-7ada-038222394d9f@redhat.com>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <027801d31df1$a5bdf590$f139e0b0$@aapt.net.au>
 <402bc686-4c37-6ab8-7ada-038222394d9f@redhat.com>
Message-ID: <02a101d31ebe$9e94d590$dbbe80b0$@aapt.net.au>

Hi Andrew,

> -----Original Message-----
> From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
> Sent: Saturday, August 26, 2017 7:03 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] On park and unpark
> 
> On 25/08/17 23:29, David Holmes wrote:
> 
> > We've been trying to consolidate and share as much common code as
> > possible on "posix" supporting platforms and recently refactored
> > things to share the PlatformEvent and Parker code (8174231). So to me
> > there would have to be a big win in using futex directly to justify
> > using a custom implementation.
> 
> That seems rather surprising to me: HotSpot has always allowed (nay, even encouraged) back ends to use custom code for
> performance reasons, and has never insisted that there must be a "big win".  At least as long as I can remember.  If there's been a
> change of policy in this area it should be up for discussion.

To me "performance reasons" == "big win". You don't introduce specialized, harder to maintain, platform specific code, unless there is a good reason to. I don't think there has been any "change in policy" here - not that there has really been a "policy" as such.

David
 
> --
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671 _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From aph at redhat.com  Sun Aug 27 03:08:28 2017
From: aph at redhat.com (Andrew Haley)
Date: Sun, 27 Aug 2017 08:08:28 +0100
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <02a101d31ebe$9e94d590$dbbe80b0$@aapt.net.au>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <027801d31df1$a5bdf590$f139e0b0$@aapt.net.au>
 <402bc686-4c37-6ab8-7ada-038222394d9f@redhat.com>
 <02a101d31ebe$9e94d590$dbbe80b0$@aapt.net.au>
Message-ID: <c10c381a-2a1c-c9b1-fda1-5c8eb9fc35b7@redhat.com>

On 26/08/17 23:56, David Holmes wrote:
>> On 25/08/17 23:29, David Holmes wrote:
>>
>>> We've been trying to consolidate and share as much common code as
>>> possible on "posix" supporting platforms and recently refactored
>>> things to share the PlatformEvent and Parker code (8174231). So to
>>> me there would have to be a big win in using futex directly to
>>> justify using a custom implementation.

>> That seems rather surprising to me: HotSpot has always allowed
>> (nay, even encouraged) back ends to use custom code for performance
>> reasons, and has never insisted that there must be a "big win".  At
>> least as long as I can remember.  If there's been a change of
>> policy in this area it should be up for discussion.

> To me "performance reasons" == "big win". You don't introduce
> specialized, harder to maintain, platform specific code, unless
> there is a good reason to. I don't think there has been any "change
> in policy" here - not that there has really been a "policy" as such.

Okay, but "big win" is IMO raising the bar much too high.  Efficient
systems are composed of thousands of tiny incremental improvements,
each one of which may be too small to measure on its own.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From boehm at acm.org  Mon Aug 28 20:27:20 2017
From: boehm at acm.org (Hans Boehm)
Date: Mon, 28 Aug 2017 17:27:20 -0700
Subject: [concurrency-interest] VarHandle.setVolatile vs classical
 volatile write
In-Reply-To: <BBE78468-0987-452F-9B87-082CEF06E339@oracle.com>
References: <CAAWwtm9eT8-OiVhW=8k6xYS4=7mo363-THxjFuW5Cy3JpepHGA@mail.gmail.com>
 <4CF0185D-0FA3-41BD-9284-B69FD235096E@oracle.com>
 <CAAWwtm-nCv=iYvVVRUHJyJUg_4nO-KXkFs8=mRRxwoZgqTxCYQ@mail.gmail.com>
 <BBE78468-0987-452F-9B87-082CEF06E339@oracle.com>
Message-ID: <CAPUmR1bzF9_1prk5JX6_4Hz9tPOktASGgMwU+1gFD0VEH=Q0Qg@mail.gmail.com>

Can someone explain why setRelease seems to be appreciably slower, when it
is the only one that should not need any kind of fence on x86, and hence
should be much faster? Am I misreading the results?

On Fri, Aug 25, 2017 at 10:02 AM, Paul Sandoz <paul.sandoz at oracle.com>
wrote:

>
> On 18 Aug 2017, at 13:58, Dávid Karnok <akarnokd at gmail.com> wrote:
>
> Thanks. I did a benchmark (https://gist.github.com/akarnokd/
> c0d606bd7e29d143ee82f2026898dbb5) and got the following results:
>
> i5 6440HQ, Windows 10 x64, Java 9b181, JMH 1.19
>
> Benchmark                       Mode  Cnt          Score         Error
>  Units
> VolatilePerf.getAndAdd         thrpt    5  117841308,999 ± 3940711,142
>  ops/s
> VolatilePerf.getAndSet         thrpt    5  118162019,136 ± 1349823,016
>  ops/s
> VolatilePerf.releaseGetAndAdd  thrpt    5  118688354,409 ±  642044,969
>  ops/s
> VolatilePerf.setRelease        thrpt    5  890890009,555 ± 4323041,380
>  ops/s
> VolatilePerf.setVolatile       thrpt    5  118419990,949 ±  793885,407
>  ops/s
>
>
> Being on Windows and on a Laptop usually yields some variance, but looks
> like there is practically minimal difference between the full barrier
> operations.
>
>
> Ok, good to know, thanks for dong that!
>
>
> Btw, thinking about XCHG and XADD, they have to provide the same strong
> volatile read and write as they both read and write something atomically. I
> would have thought XADD involving some ALU is detectably more costly but a
> 3 cycle addition is relatively small compared to a 22-45 cycle cache action.
>
>
> Yes, good point.
>
> Paul.
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170828/760cebb5/attachment.html>

From paul.sandoz at oracle.com  Mon Aug 28 20:38:15 2017
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Mon, 28 Aug 2017 17:38:15 -0700
Subject: [concurrency-interest] VarHandle.setVolatile vs classical
	volatile write
In-Reply-To: <CAPUmR1bzF9_1prk5JX6_4Hz9tPOktASGgMwU+1gFD0VEH=Q0Qg@mail.gmail.com>
References: <CAAWwtm9eT8-OiVhW=8k6xYS4=7mo363-THxjFuW5Cy3JpepHGA@mail.gmail.com>
 <4CF0185D-0FA3-41BD-9284-B69FD235096E@oracle.com>
 <CAAWwtm-nCv=iYvVVRUHJyJUg_4nO-KXkFs8=mRRxwoZgqTxCYQ@mail.gmail.com>
 <BBE78468-0987-452F-9B87-082CEF06E339@oracle.com>
 <CAPUmR1bzF9_1prk5JX6_4Hz9tPOktASGgMwU+1gFD0VEH=Q0Qg@mail.gmail.com>
Message-ID: <87EA0AF0-52A6-4870-8E0D-9DD5581FBE76@oracle.com>


> On 28 Aug 2017, at 17:27, Hans Boehm <boehm at acm.org> wrote:
> 
> Can someone explain why setRelease seems to be appreciably slower, when it is the only one that should not need any kind of fence on x86, and hence should be much faster? Am I misreading the results?
> 

Yes, you are misreading them. The units are number operations per second.

Paul.

> On Fri, Aug 25, 2017 at 10:02 AM, Paul Sandoz <paul.sandoz at oracle.com <mailto:paul.sandoz at oracle.com>> wrote:
> 
>> On 18 Aug 2017, at 13:58, Dávid Karnok <akarnokd at gmail.com <mailto:akarnokd at gmail.com>> wrote:
>> 
>> Thanks. I did a benchmark (https://gist.github.com/akarnokd/c0d606bd7e29d143ee82f2026898dbb5 <https://gist.github.com/akarnokd/c0d606bd7e29d143ee82f2026898dbb5>) and got the following results:
>> 
>> i5 6440HQ, Windows 10 x64, Java 9b181, JMH 1.19
>> 
>> Benchmark                       Mode  Cnt          Score         Error  Units
>> VolatilePerf.getAndAdd         thrpt    5  117841308,999 ± 3940711,142  ops/s
>> VolatilePerf.getAndSet         thrpt    5  118162019,136 ± 1349823,016  ops/s
>> VolatilePerf.releaseGetAndAdd  thrpt    5  118688354,409 ±  642044,969  ops/s
>> VolatilePerf.setRelease        thrpt    5  890890009,555 ± 4323041,380  ops/s
>> VolatilePerf.setVolatile       thrpt    5  118419990,949 ±  793885,407  ops/s
>> 
>> 
>> Being on Windows and on a Laptop usually yields some variance, but looks like there is practically minimal difference between the full barrier operations. 
>> 
> 
> Ok, good to know, thanks for dong that!
> 
> 
>> Btw, thinking about XCHG and XADD, they have to provide the same strong volatile read and write as they both read and write something atomically. I would have thought XADD involving some ALU is detectably more costly but a 3 cycle addition is relatively small compared to a 22-45 cycle cache action.
>> 
> 
> Yes, good point.
> 
> Paul.
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170828/1a0dbb16/attachment.html>

From aph at redhat.com  Tue Aug 29 04:04:01 2017
From: aph at redhat.com (Andrew Haley)
Date: Tue, 29 Aug 2017 09:04:01 +0100
Subject: [concurrency-interest] VarHandle.setVolatile vs classical
 volatile write
In-Reply-To: <87EA0AF0-52A6-4870-8E0D-9DD5581FBE76@oracle.com>
References: <CAAWwtm9eT8-OiVhW=8k6xYS4=7mo363-THxjFuW5Cy3JpepHGA@mail.gmail.com>
 <4CF0185D-0FA3-41BD-9284-B69FD235096E@oracle.com>
 <CAAWwtm-nCv=iYvVVRUHJyJUg_4nO-KXkFs8=mRRxwoZgqTxCYQ@mail.gmail.com>
 <BBE78468-0987-452F-9B87-082CEF06E339@oracle.com>
 <CAPUmR1bzF9_1prk5JX6_4Hz9tPOktASGgMwU+1gFD0VEH=Q0Qg@mail.gmail.com>
 <87EA0AF0-52A6-4870-8E0D-9DD5581FBE76@oracle.com>
Message-ID: <e05d249c-08e6-4137-f1f7-ffe8f5dc99da@redhat.com>

On 29/08/17 01:38, Paul Sandoz wrote:
> Yes, you are misreading them. The units are number operations per second.

This default is always very confusing.  I always use jcstress and
set units to nanoseconds.  That would make a much more sensible
default.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From shade at redhat.com  Tue Aug 29 04:19:02 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Tue, 29 Aug 2017 10:19:02 +0200
Subject: [concurrency-interest] VarHandle.setVolatile vs classical
 volatile write
In-Reply-To: <e05d249c-08e6-4137-f1f7-ffe8f5dc99da@redhat.com>
References: <CAAWwtm9eT8-OiVhW=8k6xYS4=7mo363-THxjFuW5Cy3JpepHGA@mail.gmail.com>
 <4CF0185D-0FA3-41BD-9284-B69FD235096E@oracle.com>
 <CAAWwtm-nCv=iYvVVRUHJyJUg_4nO-KXkFs8=mRRxwoZgqTxCYQ@mail.gmail.com>
 <BBE78468-0987-452F-9B87-082CEF06E339@oracle.com>
 <CAPUmR1bzF9_1prk5JX6_4Hz9tPOktASGgMwU+1gFD0VEH=Q0Qg@mail.gmail.com>
 <87EA0AF0-52A6-4870-8E0D-9DD5581FBE76@oracle.com>
 <e05d249c-08e6-4137-f1f7-ffe8f5dc99da@redhat.com>
Message-ID: <f5f26826-938a-e4d1-9318-6959fd308537@redhat.com>

On 08/29/2017 10:04 AM, Andrew Haley wrote:
> On 29/08/17 01:38, Paul Sandoz wrote:
>> Yes, you are misreading them. The units are number operations per second.
> 
> This default is always very confusing.  I always use jcstress and
> set units to nanoseconds.  That would make a much more sensible
> default.

Living in nanobenchmarks world, I generally agree. The throughput/second was the widely agreed
default at JMH 1.0 era that focused on larger benchmarks. However, I frequently see large numbers in
JMH output as the litmus test for novice user: if submitter cannot (or did not bother to) choose the
right units for experiments, maybe submitter does not know how to operate JMH, and thus the chance
the benchmarks need more attention is much higher. :) The correlation is strong with this one...

As for benchmark mode, there are always people who would expect "larger is better", and for them
"average time" would be confusing. Been there, tried that.

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170829/b43da1e2/attachment-0001.sig>

From akarnokd at gmail.com  Tue Aug 29 05:01:11 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Tue, 29 Aug 2017 11:01:11 +0200
Subject: [concurrency-interest] VarHandle.setVolatile vs classical
 volatile write
In-Reply-To: <f5f26826-938a-e4d1-9318-6959fd308537@redhat.com>
References: <CAAWwtm9eT8-OiVhW=8k6xYS4=7mo363-THxjFuW5Cy3JpepHGA@mail.gmail.com>
 <4CF0185D-0FA3-41BD-9284-B69FD235096E@oracle.com>
 <CAAWwtm-nCv=iYvVVRUHJyJUg_4nO-KXkFs8=mRRxwoZgqTxCYQ@mail.gmail.com>
 <BBE78468-0987-452F-9B87-082CEF06E339@oracle.com>
 <CAPUmR1bzF9_1prk5JX6_4Hz9tPOktASGgMwU+1gFD0VEH=Q0Qg@mail.gmail.com>
 <87EA0AF0-52A6-4870-8E0D-9DD5581FBE76@oracle.com>
 <e05d249c-08e6-4137-f1f7-ffe8f5dc99da@redhat.com>
 <f5f26826-938a-e4d1-9318-6959fd308537@redhat.com>
Message-ID: <CAAWwtm_308gMm3D0mEe8oZ6KBy4-c30uTmJEuFGR7G6zt4TAJQ@mail.gmail.com>

My target setting is usually the development of libraries to execute and
support reactive dataflows where the typical question is: how many
items/objects/messages can a particular flow transmit over time. Therefore,
if a throughput measurement of 100Mops/s jumps to 120 Mops/s after some
optimization, that is more telling to me than seeing the time go from 6ns
to 5ns per op.

2017-08-29 10:19 GMT+02:00 Aleksey Shipilev <shade at redhat.com>:

> On 08/29/2017 10:04 AM, Andrew Haley wrote:
> > On 29/08/17 01:38, Paul Sandoz wrote:
> >> Yes, you are misreading them. The units are number operations per
> second.
> >
> > This default is always very confusing.  I always use jcstress and
> > set units to nanoseconds.  That would make a much more sensible
> > default.
>
> Living in nanobenchmarks world, I generally agree. The throughput/second
> was the widely agreed
> default at JMH 1.0 era that focused on larger benchmarks. However, I
> frequently see large numbers in
> JMH output as the litmus test for novice user: if submitter cannot (or did
> not bother to) choose the
> right units for experiments, maybe submitter does not know how to operate
> JMH, and thus the chance
> the benchmarks need more attention is much higher. :) The correlation is
> strong with this one...
>
> As for benchmark mode, there are always people who would expect "larger is
> better", and for them
> "average time" would be confusing. Been there, tried that.
>
> Thanks,
> -Aleksey
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170829/a38376b7/attachment.html>

From ndkoval at ya.ru  Wed Aug 30 14:32:09 2017
From: ndkoval at ya.ru (Nikita Koval)
Date: Wed, 30 Aug 2017 21:32:09 +0300
Subject: [concurrency-interest] =?utf-8?q?Correctness_of_final_array_acces?=
	=?utf-8?b?cyB1bmRlciBhIHJhY2XigIvigIvigIvigIvigIvigIvigIs=?=
Message-ID: <1215011504117929@web2j.yandex.ru>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170830/1c84f5b3/attachment.html>

From shevek at anarres.org  Wed Aug 30 21:40:22 2017
From: shevek at anarres.org (Shevek)
Date: Wed, 30 Aug 2017 18:40:22 -0700
Subject: [concurrency-interest] On the allocation overhead of
	ExecutorCompletionService
Message-ID: <79415b7f-ebad-de19-b52a-fd0198d872c8@anarres.org>

I'm a little bothered by the number of objects which need to be 
allocated by ExecutorCompletionService.submit(). Without being 
overprecise, a Runnable gets:
* FutureTask.<init> -> Executors.callable(r) -> new RunnableAdapter()
* ExecutorCompletionService.newTaskFor() -> new FutureTask()
* ExecutorCompletionService.submit() -> new QueueingFuture()

Could not the first two of these be omitted by having 
ExecutorCompletionService.submit(Runnable, V) construct a new 
QueueingFuture() in the first place, and then have QueueingFuture append 
itself, rather than an embedded task field to the completionQueue?

Aside from omitting the call to aes.newTaskFor(), which I'm sure has 
semantics somewhere, does this actually break anything, or does it just 
reduce the number of allocations per-task?

I've fairly easily written something executor-like which just creates a 
self-enqueueing QueueingFuture directly over a given Runnable, and 
returns it to the user, and it seems fine to me.

Thank you.

S.

From thomas.krieger at vmlens.com  Thu Aug 31 05:17:11 2017
From: thomas.krieger at vmlens.com (Thomas Krieger)
Date: Thu, 31 Aug 2017 11:17:11 +0200 (CEST)
Subject: [concurrency-interest] Question about final field semantic in case
	of a race
Message-ID: <1958398980.1115154.1504171031378@communicator.strato.com>

Hi,

I am running the following JCStressTest on a Raspberry Pi 3 with a Java(TM) SE Runtime Environment (build 1.8.0_65-b17) Java HotSpot(TM) Client VM (build 25.65-b01, mixed mode):

@JCStressTest
@Outcome(id = "0", expect = Expect.ACCEPTABLE, desc = "Default outcome.")
@State
public class BigDecimalToString {
    private final  BigDecimal testBigDecimal = new BigDecimal("0.56");
    @Actor
    public void actor1(IntResult1 r) {
        testBigDecimal.toString().length();
    }
    @Actor
    public void actor2(IntResult1 r) {
        testBigDecimal.toString().length();
    }    
}

In about half of the iterations, I see the following Exception:
java.lang.NullPointerException
at java.lang.String.length(String.java:623)
at com.vmlens.stressTest.tests.BigDecimalToString.actor1(BigDecimalToString.java:12)
at com.vmlens.stressTest.tests.BigDecimalToString_jcstress.actor1(BigDecimalToString_jcstress.java:145)
at java.util.concurrent.FutureTask.run(FutureTask.java:266)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)

The NullPointerException happens at this statement: return value.length. The BigDecimal toString method caches the String leading to race:
@Override
    public String toString() {
        String sc = stringCache;
        if (sc == null)
            stringCache = sc = layoutChars(true);
        return sc;
    }
    /**
     * Used to store the canonical string representation, if computed.
     */
    private transient String stringCache;

But the field "value" of the Class String is final. So my question:
Is the behavior of the test the expected result?  The JLS spec (17.5) states: "A thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object's final fields.". In my test, a thread can get a reference to a String which has not been completely initialized and the NullPointerException is a
consequence of the Race. Or, because of the final field, all threads should have only seen an initialized value?


Thank you very much
Thomas Krieger
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170831/1e3e7d65/attachment.html>

From shade at redhat.com  Thu Aug 31 05:40:29 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Thu, 31 Aug 2017 11:40:29 +0200
Subject: [concurrency-interest] Question about final field semantic in
 case of a race
In-Reply-To: <1958398980.1115154.1504171031378@communicator.strato.com>
References: <1958398980.1115154.1504171031378@communicator.strato.com>
Message-ID: <c98d72a0-485d-9cf2-a7d4-d843d19cd81d@redhat.com>

On 08/31/2017 11:17 AM, Thomas Krieger wrote:
> I am running the following JCStressTest on a Raspberry Pi 3 with a Java(TM) SE Runtime Environment
> (build 1.8.0_65-b17) Java HotSpot(TM) Client VM (build 25.65-b01, mixed mode):
> 
> @JCStressTest
> @Outcome(id = "0", expect = Expect.ACCEPTABLE, desc = "Default outcome.")
> @State
> public class BigDecimalToString {
>     private final  BigDecimal testBigDecimal = new BigDecimal("0.56");
>     @Actor
>     public void actor1(IntResult1 r) {
>         testBigDecimal.toString().length();
>     }
>     @Actor
>     public void actor2(IntResult1 r) {
>         testBigDecimal.toString().length();
>     }    
> }
> 
> In about half of the iterations, I see the following Exception:> java.lang.NullPointerException

...

> Or, because of the final field, all threads should have only seen an
> initialized value?

String is published by race, but String.value is final, so it should be safe. Seeing NPE on
dereferencing String.value is weird, and probably points to a compiler bug. Run with more modern
JDK?. It is also not clear if you run ARMv7 or AArch64 VM (not all RPi 3 distros are 64-bit, and
many identify RPi 3 as 32-bit ARM).

Thanks,
-Aleksey


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170831/07d0aced/attachment.sig>

From shade at redhat.com  Thu Aug 31 06:09:51 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Thu, 31 Aug 2017 12:09:51 +0200
Subject: [concurrency-interest] Question about final field semantic in
 case of a race
In-Reply-To: <c98d72a0-485d-9cf2-a7d4-d843d19cd81d@redhat.com>
References: <1958398980.1115154.1504171031378@communicator.strato.com>
 <c98d72a0-485d-9cf2-a7d4-d843d19cd81d@redhat.com>
Message-ID: <7ba3a537-9fad-2f3f-99a3-9609d386c72e@redhat.com>

On 08/31/2017 11:40 AM, Aleksey Shipilev wrote:
> String is published by race, but String.value is final, so it should be safe. Seeing NPE on
> dereferencing String.value is weird, and probably points to a compiler bug. Run with more modern
> JDK?. It is also not clear if you run ARMv7 or AArch64 VM (not all RPi 3 distros are 64-bit, and
> many identify RPi 3 as 32-bit ARM).

Pushed the variants of the test to jcstress, so they are picked up by vendor testing:
  http://hg.openjdk.java.net/code-tools/jcstress/rev/12d706400981

For sanity, booted up my RPi 3 with AArch64 distro, downloaded the AdoptOpenJDK build from here:
  https://github.com/AdoptOpenJDK/openjdk8-releases/releases/tag/jdk8u144-b01

And ran without failures:
 $ j2sdk-image/bin/java -jar jcstress.jar -t strings.Big

*** INTERESTING tests
  Some interesting behaviors observed. This is for the plain curiosity.

  0 matching test results.

*** FAILED tests
  Strong asserts were violated. Correct implementations should have no assert failures here.

  0 matching test results.

*** ERROR tests
  Tests break for some reason, other than failing the assert. Correct implementations should have none.

  0 matching test results.

*** All remaining tests
  Tests that do not fall into any of the previous categories.

  16 matching test results.  Use -v to print them.


Thanks,
-Aleksey


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170831/5e3d5377/attachment-0001.sig>

From thomas.krieger at vmlens.com  Thu Aug 31 06:20:39 2017
From: thomas.krieger at vmlens.com (Thomas Krieger)
Date: Thu, 31 Aug 2017 12:20:39 +0200 (CEST)
Subject: [concurrency-interest] Question about final field semantic in
 case of a race
In-Reply-To: <c98d72a0-485d-9cf2-a7d4-d843d19cd81d@redhat.com>
References: <1958398980.1115154.1504171031378@communicator.strato.com>
 <c98d72a0-485d-9cf2-a7d4-d843d19cd81d@redhat.com>
Message-ID: <129591427.1119434.1504174840103@communicator.strato.com>

It is ARMv7: uname -a

Linux raspberrypi 4.4.11-v7+ #888 SMP Mon May 23 20:10:33 BST 2016 armv7l GNU/Linux

The JVM is rather new:

java version "1.8.0_65"
Java(TM) SE Runtime Environment (build 1.8.0_65-b17)
Java HotSpot(TM) Client VM (build 25.65-b01, mixed mode)

It is an Oracle JVM (jdk-8-oracle-arm32-vfp-hflt)


Thanks,

Thomas Krieger


> 
>     On 31 August 2017 at 11:40 Aleksey Shipilev <shade at redhat.com> wrote:
> 
>     On 08/31/2017 11:17 AM, Thomas Krieger wrote:
> 
>         > > 
> >         I am running the following JCStressTest on a Raspberry Pi 3 with a Java(TM) SE Runtime Environment
> >         (build 1.8.0_65-b17) Java HotSpot(TM) Client VM (build 25.65-b01, mixed mode):
> > 
> >         @JCStressTest
> >         @Outcome(id = "0", expect = Expect.ACCEPTABLE, desc = "Default outcome.")
> >         @State
> >         public class BigDecimalToString {
> >         private final BigDecimal testBigDecimal = new BigDecimal("0.56");
> >         @Actor
> >         public void actor1(IntResult1 r) {
> >         testBigDecimal.toString().length();
> >         }
> >         @Actor
> >         public void actor2(IntResult1 r) {
> >         testBigDecimal.toString().length();
> >         }
> >         }
> > 
> >         In about half of the iterations, I see the following Exception:> java.lang.NullPointerException
> > 
> >     > 
>     ...
> 
>         > > 
> >         Or, because of the final field, all threads should have only seen an
> >         initialized value?
> > 
> >     > 
>     String is published by race, but String.value is final, so it should be safe. Seeing NPE on
>     dereferencing String.value is weird, and probably points to a compiler bug. Run with more modern
>     JDK?. It is also not clear if you run ARMv7 or AArch64 VM (not all RPi 3 distros are 64-bit, and
>     many identify RPi 3 as 32-bit ARM).
> 
>     Thanks,
>     -Aleksey
> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170831/2d54ec1c/attachment.html>

From shade at redhat.com  Thu Aug 31 09:04:13 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Thu, 31 Aug 2017 15:04:13 +0200
Subject: [concurrency-interest]
 =?utf-8?q?Correctness_of_final_array_acces?=
 =?utf-8?b?cyB1bmRlciBhIHJhY2XigIvigIvigIvigIvigIvigIvigIs=?=
In-Reply-To: <1215011504117929@web2j.yandex.ru>
References: <1215011504117929@web2j.yandex.ru>
Message-ID: <0af92ac3-931d-e155-9360-1e96795b0cc7@redhat.com>

On 08/30/2017 08:32 PM, Nikita Koval wrote:
> I am thinking about reading String under a race. String class has the array of chars field, which is
> final and is initialized during the construction. However, elements of this array "are not final" in
> terms of the memory model (but they effectively are). Therefore, I do not understand why reading the
> array of non-final chars cannot read the array of default char elements. I think I do not clearly
> understand the final's semantics. 

I think it follows directly from the spec definition:

"Given a write $w, a freeze $f, an action $a (that is not a read of a final field), a read
$r1 of the final field frozen by $f, and a read $r2 such that hb($w, $f), hb($f, $a), mc($a, $r1),
and dereferences($r1, $r2), then when determining which values can be seen by $r2,
we consider hb($w, $r2)."

For example:

Thread 1:

  class C {
    final int[] arr;
    C() {
       arr = new int[1];
       arr[0] = 42; // $w
       {freeze}     // $f
    }
  }

  GLOBAL = new C;


Thread 2:

  C c = GLOBAL;    // $a
  int[] a = c.arr; // $r1
  int t = a[0];    // $r2


Now I remember this is the example from "Final Fields Semantics" by Sitnikov and Kovalenko:
  https://www.slideshare.net/VladimirSitnikv/final-field-semantics, see around slide #68

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170831/2e7df510/attachment.sig>

From me at yawk.at  Thu Aug 31 09:12:51 2017
From: me at yawk.at (Jonas Konrad)
Date: Thu, 31 Aug 2017 15:12:51 +0200
Subject: [concurrency-interest]
 =?utf-8?q?Correctness_of_final_array_acces?=
 =?utf-8?b?cyB1bmRlciBhIHJhY2XigIvigIvigIvigIvigIvigIvigIs=?=
In-Reply-To: <0af92ac3-931d-e155-9360-1e96795b0cc7@redhat.com>
References: <1215011504117929@web2j.yandex.ru>
 <0af92ac3-931d-e155-9360-1e96795b0cc7@redhat.com>
Message-ID: <7600c726-6dfd-c65d-44d8-f6b51dbc8af8@yawk.at>

JCIP also talks about this behaviour in section 16.3: all variables that 
can be *reached* through a final field are visible to other threads 
after (proper) construction. It also explicitly mentions array contents 
as an example of this.

- Jonas

On 08/31/2017 03:04 PM, Aleksey Shipilev wrote:
> On 08/30/2017 08:32 PM, Nikita Koval wrote:
>> I am thinking about reading String under a race. String class has the array of chars field, which is
>> final and is initialized during the construction. However, elements of this array "are not final" in
>> terms of the memory model (but they effectively are). Therefore, I do not understand why reading the
>> array of non-final chars cannot read the array of default char elements. I think I do not clearly
>> understand the final's semantics.
> 
> I think it follows directly from the spec definition:
> 
> "Given a write $w, a freeze $f, an action $a (that is not a read of a final field), a read
> $r1 of the final field frozen by $f, and a read $r2 such that hb($w, $f), hb($f, $a), mc($a, $r1),
> and dereferences($r1, $r2), then when determining which values can be seen by $r2,
> we consider hb($w, $r2)."
> 
> For example:
> 
> Thread 1:
> 
>    class C {
>      final int[] arr;
>      C() {
>         arr = new int[1];
>         arr[0] = 42; // $w
>         {freeze}     // $f
>      }
>    }
> 
>    GLOBAL = new C;
> 
> 
> Thread 2:
> 
>    C c = GLOBAL;    // $a
>    int[] a = c.arr; // $r1
>    int t = a[0];    // $r2
> 
> 
> Now I remember this is the example from "Final Fields Semantics" by Sitnikov and Kovalenko:
>    https://www.slideshare.net/VladimirSitnikv/final-field-semantics, see around slide #68
> 
> Thanks,
> -Aleksey
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From aph at redhat.com  Thu Aug 31 09:13:42 2017
From: aph at redhat.com (Andrew Haley)
Date: Thu, 31 Aug 2017 14:13:42 +0100
Subject: [concurrency-interest] Question about final field semantic in
 case of a race
In-Reply-To: <129591427.1119434.1504174840103@communicator.strato.com>
References: <1958398980.1115154.1504171031378@communicator.strato.com>
 <c98d72a0-485d-9cf2-a7d4-d843d19cd81d@redhat.com>
 <129591427.1119434.1504174840103@communicator.strato.com>
Message-ID: <389dec70-1021-073e-17fe-80a4a50888d3@redhat.com>

On 31/08/17 11:20, Thomas Krieger wrote:
> It is ARMv7: uname -a
> 
> Linux raspberrypi 4.4.11-v7+ #888 SMP Mon May 23 20:10:33 BST 2016 armv7l GNU/Linux
> 
> The JVM is rather new:
> 
> java version "1.8.0_65"
> Java(TM) SE Runtime Environment (build 1.8.0_65-b17)
> Java HotSpot(TM) Client VM (build 25.65-b01, mixed mode)
> 
> It is an Oracle JVM (jdk-8-oracle-arm32-vfp-hflt)

I think that's a compiler bug.  I haven't got an armv7 system here I can try.
It'd be interesting to see if we can duplicate that with OpenJDK 9.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

