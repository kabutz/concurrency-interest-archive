From heinz at javaspecialists.eu  Thu Apr  5 10:57:02 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Thu, 05 Apr 2012 17:57:02 +0300
Subject: [concurrency-interest] Joint Talk for JavaOne?
Message-ID: <4F7DB2BE.5030205@javaspecialists.eu>

Good afternoon,

I am thinking of submitting a talk on finding and diagnosing deadlocks 
for JavaOne.  It might be a workshop, instead of a simple conference 
talk.  Or we might be able to turn the talk into a workshop where they 
need to find a deadlock in a body of code.  Could be something 
different, which might go incredibly well or crash in a blaze of 
flames.  Would any of you be interested in co-presenting this with me at 
JavaOne?

Regards

Heinz
-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun Java Champion
IEEE Certified Software Development Professional
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz 


From nathan.reynolds at oracle.com  Thu Apr  5 13:01:16 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Thu, 05 Apr 2012 10:01:16 -0700
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7DB2BE.5030205@javaspecialists.eu>
References: <4F7DB2BE.5030205@javaspecialists.eu>
Message-ID: <4F7DCFDC.5020101@oracle.com>

I am curious as to the intended content of your presentation.  Here's 
some ideas.  I wondering what you are planing on doing.

 1. Printing the call stacks with lock information using a tool such as
    jstack
 2. Press the "Detect Deadlock" button in JConsole
 3. Dealing with Lock and Condition objects instead of synchronized blocks
 4. Detecting live lock
 5. Distributed deadlocks

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
> Good afternoon,
>
> I am thinking of submitting a talk on finding and diagnosing deadlocks 
> for JavaOne.  It might be a workshop, instead of a simple conference 
> talk.  Or we might be able to turn the talk into a workshop where they 
> need to find a deadlock in a body of code.  Could be something 
> different, which might go incredibly well or crash in a blaze of 
> flames.  Would any of you be interested in co-presenting this with me 
> at JavaOne?
>
> Regards
>
> Heinz
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/06afd8e8/attachment.html>

From kirk at kodewerk.com  Thu Apr  5 13:29:31 2012
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Thu, 5 Apr 2012 19:29:31 +0200
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7DB2BE.5030205@javaspecialists.eu>
References: <4F7DB2BE.5030205@javaspecialists.eu>
Message-ID: <D99C2FCB-F480-4F64-BE12-5705B81C7D12@kodewerk.com>

you'd need a tutorial session which is 3 hours long. I think you can submit an abstract for such a beast.

Kirk

On 2012-04-05, at 4:57 PM, Dr Heinz M. Kabutz wrote:

> Good afternoon,
> 
> I am thinking of submitting a talk on finding and diagnosing deadlocks for JavaOne.  It might be a workshop, instead of a simple conference talk.  Or we might be able to turn the talk into a workshop where they need to find a deadlock in a body of code.  Could be something different, which might go incredibly well or crash in a blaze of flames.  Would any of you be interested in co-presenting this with me at JavaOne?
> 
> Regards
> 
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun Java Champion
> IEEE Certified Software Development Professional
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From heinz at javaspecialists.eu  Thu Apr  5 15:03:10 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Thu, 05 Apr 2012 22:03:10 +0300
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7DCFDC.5020101@oracle.com>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
Message-ID: <4F7DEC6E.1000204@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/3320dc7d/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ConcurrencyDeadlockWorkshop.zip
Type: video/x-flv
Size: 538481 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/3320dc7d/attachment-0001.bin>

From nathan.reynolds at oracle.com  Thu Apr  5 15:29:29 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Thu, 05 Apr 2012 12:29:29 -0700
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7DEC6E.1000204@javaspecialists.eu>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
	<4F7DEC6E.1000204@javaspecialists.eu>
Message-ID: <4F7DF299.4070209@oracle.com>

I took the bait and tried out the demo on HotSpot 7 Update 3.  It didn't 
deadlock for a minute or two.  Then the application froze.  I then used 
jstack to dump the call stacks.  At the end of the report, it said 
"Found one Java-level deadlock".  It then dumped out the locks and 
threads involved in the deadlock.  I never looked at the source code... 
in fact it wasn't in the zip file.  This took about 5-7 minutes from 
starting the application to finding the deadlock in the call stacks.

A 100 good Java developers?  Really?  I guess I can understand.  Most 
engineers don't understand locks.  Most of the time I get answers like 
one should put a lock around shared variables.  This is accurate but 
they can't really go any deeper.

It sounds like the material of your presentation should be very good.  
It covers things that the deadlock detection tool probably can't figure out.

So, it seems like you have everything figured out.  Why do you need 
someone else?

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
> Hi Nathan,
>
> a stack trace will only show you a certain class of obvious deadlocks 
> that are easy to find and solve.  I remember solving deadlocks 
> /before/ we had the brilliant deadlock detection tool in the 
> ThreadMXBean.  Yes, the deadlock detection tool shows you /some/ 
> deadlocks, but definitely not all of them.  I can think of a bunch 
> that it would not find:
>
> 1. Semaphores running out of permits
> 2. ReadWriteLocks trying to upgrade from write lock to read lock
> 3. Resource deadlocks
>
> And some others that I will not describe in detail, such as some nasty 
> livelocks that we can cause which will hang up the JVM :-)
>
> I agree with Kirk - it should probably be a 3 hour workshop.  I've 
> done this three times now - twice in Spain and once via webinar.  The 
> workshop would involve some lessons on deadlocks, what causes them and 
> how we can prevent them.  Also an explanation as to why we see them so 
> seldom in real production.  I've got material prepared for this 
> workshop.  And then a practical part to the workshop where they can 
> try to find a deadlock in a body of code.
>
> Attached is an example of the workshop.  You can try find the deadlock 
> if you like.  I've shown it to almost 100 good Java developers and so 
> far, not one has found it by themselves.  I would expect that they 
> should find it in 5 minutes.  In our workshop they would obviously be 
> helped a bit with hints, so that they can walk away with a good 
> experience.  Use anything you like.  Oscilloscope, jstack, jconsole, 
> whatever you like.  Only rule for you guys on the 
> "concurrency-interest" list is: you can only look at the code once 
> you've found the problem, otherwise it would be too easy for you :-)  
> Once you have found it, you can also fix the code and make sure that 
> the code then works correctly.
> Regards
>
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun Java Champion
> IEEE Certified Software Development Professional
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
>
> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>> I am curious as to the intended content of your presentation.  Here's 
>> some ideas.  I wondering what you are planing on doing.
>>
>>  1. Printing the call stacks with lock information using a tool such
>>     as jstack
>>  2. Press the "Detect Deadlock" button in JConsole
>>  3. Dealing with Lock and Condition objects instead of synchronized
>>     blocks
>>  4. Detecting live lock
>>  5. Distributed deadlocks
>>
>> Nathan Reynolds 
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>> Consulting Member of Technical Staff | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>
>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>> Good afternoon,
>>>
>>> I am thinking of submitting a talk on finding and diagnosing 
>>> deadlocks for JavaOne.  It might be a workshop, instead of a simple 
>>> conference talk.  Or we might be able to turn the talk into a 
>>> workshop where they need to find a deadlock in a body of code.  
>>> Could be something different, which might go incredibly well or 
>>> crash in a blaze of flames.  Would any of you be interested in 
>>> co-presenting this with me at JavaOne?
>>>
>>> Regards
>>>
>>> Heinz
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/ab3db2db/attachment.html>

From alex at puredanger.com  Thu Apr  5 15:31:19 2012
From: alex at puredanger.com (Alex Miller)
Date: Thu, 5 Apr 2012 14:31:19 -0500
Subject: [concurrency-interest] Joint Talk for JavaOne?
Message-ID: <CAOdgdgyWAu9UQwLLEiej0H3VvtHnuUmnv2g5HW=KGmd3cyrhtg@mail.gmail.com>

You might also consider submitting such a talk to Strange Loop (St. Louis -
Sept 23-25th - http://thestrangeloop.com).  CFP will open any day now.

Alex Miller
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/55c39a6e/attachment.html>

From kirk at kodewerk.com  Thu Apr  5 15:42:25 2012
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Thu, 5 Apr 2012 21:42:25 +0200
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7DF299.4070209@oracle.com>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
	<4F7DEC6E.1000204@javaspecialists.eu> <4F7DF299.4070209@oracle.com>
Message-ID: <FD55907B-8720-43F5-848B-5455C6D948F8@kodewerk.com>

+1 on every thing.. Heinz, put together an abstract for the core track and try to have it put in as a tutorial. If you can't get a tutorial because of the system, I'll start a conversation with Sharat.

Kirk
On 2012-04-05, at 9:29 PM, Nathan Reynolds wrote:

> I took the bait and tried out the demo on HotSpot 7 Update 3.  It didn't deadlock for a minute or two.  Then the application froze.  I then used jstack to dump the call stacks.  At the end of the report, it said "Found one Java-level deadlock".  It then dumped out the locks and threads involved in the deadlock.  I never looked at the source code... in fact it wasn't in the zip file.  This took about 5-7 minutes from starting the application to finding the deadlock in the call stacks.
> 
> A 100 good Java developers?  Really?  I guess I can understand.  Most engineers don't understand locks.  Most of the time I get answers like one should put a lock around shared variables.  This is accurate but they can't really go any deeper.
> 
> It sounds like the material of your presentation should be very good.  It covers things that the deadlock detection tool probably can't figure out.
> 
> So, it seems like you have everything figured out.  Why do you need someone else?
> 
> Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering | Server Technology
> 
> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>> 
>> Hi Nathan,
>> 
>> a stack trace will only show you a certain class of obvious deadlocks that are easy to find and solve.  I remember solving deadlocks before we had the brilliant deadlock detection tool in the ThreadMXBean.  Yes, the deadlock detection tool shows you some deadlocks, but definitely not all of them.  I can think of a bunch that it would not find:
>> 
>> 1. Semaphores running out of permits
>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>> 3. Resource deadlocks
>> 
>> And some others that I will not describe in detail, such as some nasty livelocks that we can cause which will hang up the JVM :-)
>> 
>> I agree with Kirk - it should probably be a 3 hour workshop.  I've done this three times now - twice in Spain and once via webinar.  The workshop would involve some lessons on deadlocks, what causes them and how we can prevent them.  Also an explanation as to why we see them so seldom in real production.  I've got material prepared for this workshop.  And then a practical part to the workshop where they can try to find a deadlock in a body of code.
>> 
>> Attached is an example of the workshop.  You can try find the deadlock if you like.  I've shown it to almost 100 good Java developers and so far, not one has found it by themselves.  I would expect that they should find it in 5 minutes.  In our workshop they would obviously be helped a bit with hints, so that they can walk away with a good experience.  Use anything you like.  Oscilloscope, jstack, jconsole, whatever you like.  Only rule for you guys on the "concurrency-interest" list is: you can only look at the code once you've found the problem, otherwise it would be too easy for you :-)  Once you have found it, you can also fix the code and make sure that the code then works correctly.
>> Regards
>> 
>> Heinz
>> -- 
>> Dr Heinz M. Kabutz (PhD CompSci)
>> Author of "The Java(tm) Specialists' Newsletter"
>> Sun Java Champion
>> IEEE Certified Software Development Professional
>> http://www.javaspecialists.eu
>> Tel: +30 69 75 595 262
>> Skype: kabutz 
>> 
>> 
>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>> 
>>> I am curious as to the intended content of your presentation.  Here's some ideas.  I wondering what you are planing on doing.
>>> Printing the call stacks with lock information using a tool such as jstack
>>> Press the "Detect Deadlock" button in JConsole
>>> Dealing with Lock and Condition objects instead of synchronized blocks
>>> Detecting live lock
>>> Distributed deadlocks
>>> Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
>>> Oracle PSR Engineering | Server Technology
>>> 
>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>> 
>>>> Good afternoon, 
>>>> 
>>>> I am thinking of submitting a talk on finding and diagnosing deadlocks for JavaOne.  It might be a workshop, instead of a simple conference talk.  Or we might be able to turn the talk into a workshop where they need to find a deadlock in a body of code.  Could be something different, which might go incredibly well or crash in a blaze of flames.  Would any of you be interested in co-presenting this with me at JavaOne? 
>>>> 
>>>> Regards 
>>>> 
>>>> Heinz 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/02f81248/attachment-0001.html>

From dawid.weiss at gmail.com  Thu Apr  5 15:44:34 2012
From: dawid.weiss at gmail.com (Dawid Weiss)
Date: Thu, 5 Apr 2012 21:44:34 +0200
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7DF299.4070209@oracle.com>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
	<4F7DEC6E.1000204@javaspecialists.eu> <4F7DF299.4070209@oracle.com>
Message-ID: <CAM21Rt9rtN2aP3VANJg06EFF1pdAhXriTugRtFmsfVrNo_uHgg@mail.gmail.com>

> 1. Semaphores running out of permits
> 2. ReadWriteLocks trying to upgrade from write lock to read lock
> 3. Resource deadlocks

I'd add to this list a pseudo-deadlock caused by broken coordination
of threads via non-volatile public variables and spin loops. While not
technically a deadlock the symptoms are similar -- one thread is
spinning waiting for a variable to change and the system never
advances (because the variable is read once and peeled away from the
loop). This can constitute a number of very entertaining examples:

1) run with -client (-d32, c1 compiler) or in interpreted mode. The code works.
2) run with -server (or move to a bigger machine where -server is the
default); the code deadlocks.
3) show people that once you try to put a breakpoint (or interrupt the
execution) of a deadlocked vm, the deadlock no longer exists and
everything advances as if nothing happened (deopts)...

This was perhaps one of my favorite and fun exercises with students.

Dawid
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Example02.java
Type: application/octet-stream
Size: 724 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/35da0ca5/attachment.obj>

From heinz at javaspecialists.eu  Thu Apr  5 15:52:23 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Thu, 5 Apr 2012 22:52:23 +0300
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7DF299.4070209@oracle.com>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
	<4F7DEC6E.1000204@javaspecialists.eu> <4F7DF299.4070209@oracle.com>
Message-ID: <CACLL95qwW96sz6pDwjqC5nXmB3D57P5vUWBN+xfBRnM3o6+J=g@mail.gmail.com>

You did not find the deadlock that caused your application to freeze
up :-). 101 good Java developers now.

On 05/04/2012, Nathan Reynolds <nathan.reynolds at oracle.com> wrote:
> I took the bait and tried out the demo on HotSpot 7 Update 3.  It didn't
> deadlock for a minute or two.  Then the application froze.  I then used
> jstack to dump the call stacks.  At the end of the report, it said
> "Found one Java-level deadlock".  It then dumped out the locks and
> threads involved in the deadlock.  I never looked at the source code...
> in fact it wasn't in the zip file.  This took about 5-7 minutes from
> starting the application to finding the deadlock in the call stacks.
>
> A 100 good Java developers?  Really?  I guess I can understand.  Most
> engineers don't understand locks.  Most of the time I get answers like
> one should put a lock around shared variables.  This is accurate but
> they can't really go any deeper.
>
> It sounds like the material of your presentation should be very good.
> It covers things that the deadlock detection tool probably can't figure out.
>
> So, it seems like you have everything figured out.  Why do you need
> someone else?
>
> Nathan Reynolds
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>> Hi Nathan,
>>
>> a stack trace will only show you a certain class of obvious deadlocks
>> that are easy to find and solve.  I remember solving deadlocks
>> /before/ we had the brilliant deadlock detection tool in the
>> ThreadMXBean.  Yes, the deadlock detection tool shows you /some/
>> deadlocks, but definitely not all of them.  I can think of a bunch
>> that it would not find:
>>
>> 1. Semaphores running out of permits
>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>> 3. Resource deadlocks
>>
>> And some others that I will not describe in detail, such as some nasty
>> livelocks that we can cause which will hang up the JVM :-)
>>
>> I agree with Kirk - it should probably be a 3 hour workshop.  I've
>> done this three times now - twice in Spain and once via webinar.  The
>> workshop would involve some lessons on deadlocks, what causes them and
>> how we can prevent them.  Also an explanation as to why we see them so
>> seldom in real production.  I've got material prepared for this
>> workshop.  And then a practical part to the workshop where they can
>> try to find a deadlock in a body of code.
>>
>> Attached is an example of the workshop.  You can try find the deadlock
>> if you like.  I've shown it to almost 100 good Java developers and so
>> far, not one has found it by themselves.  I would expect that they
>> should find it in 5 minutes.  In our workshop they would obviously be
>> helped a bit with hints, so that they can walk away with a good
>> experience.  Use anything you like.  Oscilloscope, jstack, jconsole,
>> whatever you like.  Only rule for you guys on the
>> "concurrency-interest" list is: you can only look at the code once
>> you've found the problem, otherwise it would be too easy for you :-)
>> Once you have found it, you can also fix the code and make sure that
>> the code then works correctly.
>> Regards
>>
>> Heinz
>> --
>> Dr Heinz M. Kabutz (PhD CompSci)
>> Author of "The Java(tm) Specialists' Newsletter"
>> Sun Java Champion
>> IEEE Certified Software Development Professional
>> http://www.javaspecialists.eu
>> Tel: +30 69 75 595 262
>> Skype: kabutz
>>
>>
>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>> I am curious as to the intended content of your presentation.  Here's
>>> some ideas.  I wondering what you are planing on doing.
>>>
>>>  1. Printing the call stacks with lock information using a tool such
>>>     as jstack
>>>  2. Press the "Detect Deadlock" button in JConsole
>>>  3. Dealing with Lock and Condition objects instead of synchronized
>>>     blocks
>>>  4. Detecting live lock
>>>  5. Distributed deadlocks
>>>
>>> Nathan Reynolds
>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>> Consulting Member of Technical Staff | 602.333.9091
>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>
>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>> Good afternoon,
>>>>
>>>> I am thinking of submitting a talk on finding and diagnosing
>>>> deadlocks for JavaOne.  It might be a workshop, instead of a simple
>>>> conference talk.  Or we might be able to turn the talk into a
>>>> workshop where they need to find a deadlock in a body of code.
>>>> Could be something different, which might go incredibly well or
>>>> crash in a blaze of flames.  Would any of you be interested in
>>>> co-presenting this with me at JavaOne?
>>>>
>>>> Regards
>>>>
>>>> Heinz
>


-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun Java Champion
IEEE Certified Software Development Professional
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz

From heinz at javaspecialists.eu  Thu Apr  5 16:22:37 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Thu, 05 Apr 2012 23:22:37 +0300
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7DF299.4070209@oracle.com>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
	<4F7DEC6E.1000204@javaspecialists.eu> <4F7DF299.4070209@oracle.com>
Message-ID: <4F7DFF0D.7030605@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/5024873c/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ConcurrencyDeadlockWorkshop.zip
Type: video/x-flv
Size: 891350 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/5024873c/attachment-0001.bin>

From nathan.reynolds at oracle.com  Thu Apr  5 16:29:09 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Thu, 05 Apr 2012 13:29:09 -0700
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <CACLL95qwW96sz6pDwjqC5nXmB3D57P5vUWBN+xfBRnM3o6+J=g@mail.gmail.com>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
	<4F7DEC6E.1000204@javaspecialists.eu> <4F7DF299.4070209@oracle.com>
	<CACLL95qwW96sz6pDwjqC5nXmB3D57P5vUWBN+xfBRnM3o6+J=g@mail.gmail.com>
Message-ID: <4F7E0095.3070701@oracle.com>

I jumped at the first deadlock I found and stopped.  I didn't even 
consider that the AWT EventQueue thread had to be involved to deadlock 
the GUI.  I simply saw the deadlock and quit.  Nice distraction!  
Without spoiling it for others, it took me another minute to see the 
2^(n)^(d) deadlock.  Nice.  Please don't tell me that this is just 
another distraction from another deadlock hiding in the code.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/5/2012 12:52 PM, Dr Heinz M. Kabutz wrote:
> You did not find the deadlock that caused your application to freeze
> up :-). 101 good Java developers now.
>
> On 05/04/2012, Nathan Reynolds<nathan.reynolds at oracle.com>  wrote:
>> I took the bait and tried out the demo on HotSpot 7 Update 3.  It didn't
>> deadlock for a minute or two.  Then the application froze.  I then used
>> jstack to dump the call stacks.  At the end of the report, it said
>> "Found one Java-level deadlock".  It then dumped out the locks and
>> threads involved in the deadlock.  I never looked at the source code...
>> in fact it wasn't in the zip file.  This took about 5-7 minutes from
>> starting the application to finding the deadlock in the call stacks.
>>
>> A 100 good Java developers?  Really?  I guess I can understand.  Most
>> engineers don't understand locks.  Most of the time I get answers like
>> one should put a lock around shared variables.  This is accurate but
>> they can't really go any deeper.
>>
>> It sounds like the material of your presentation should be very good.
>> It covers things that the deadlock detection tool probably can't figure out.
>>
>> So, it seems like you have everything figured out.  Why do you need
>> someone else?
>>
>> Nathan Reynolds
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>  |
>> Consulting Member of Technical Staff | 602.333.9091
>> Oracle PSR Engineering<http://psr.us.oracle.com/>  | Server Technology
>>
>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>> Hi Nathan,
>>>
>>> a stack trace will only show you a certain class of obvious deadlocks
>>> that are easy to find and solve.  I remember solving deadlocks
>>> /before/ we had the brilliant deadlock detection tool in the
>>> ThreadMXBean.  Yes, the deadlock detection tool shows you /some/
>>> deadlocks, but definitely not all of them.  I can think of a bunch
>>> that it would not find:
>>>
>>> 1. Semaphores running out of permits
>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>>> 3. Resource deadlocks
>>>
>>> And some others that I will not describe in detail, such as some nasty
>>> livelocks that we can cause which will hang up the JVM :-)
>>>
>>> I agree with Kirk - it should probably be a 3 hour workshop.  I've
>>> done this three times now - twice in Spain and once via webinar.  The
>>> workshop would involve some lessons on deadlocks, what causes them and
>>> how we can prevent them.  Also an explanation as to why we see them so
>>> seldom in real production.  I've got material prepared for this
>>> workshop.  And then a practical part to the workshop where they can
>>> try to find a deadlock in a body of code.
>>>
>>> Attached is an example of the workshop.  You can try find the deadlock
>>> if you like.  I've shown it to almost 100 good Java developers and so
>>> far, not one has found it by themselves.  I would expect that they
>>> should find it in 5 minutes.  In our workshop they would obviously be
>>> helped a bit with hints, so that they can walk away with a good
>>> experience.  Use anything you like.  Oscilloscope, jstack, jconsole,
>>> whatever you like.  Only rule for you guys on the
>>> "concurrency-interest" list is: you can only look at the code once
>>> you've found the problem, otherwise it would be too easy for you :-)
>>> Once you have found it, you can also fix the code and make sure that
>>> the code then works correctly.
>>> Regards
>>>
>>> Heinz
>>> --
>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> Author of "The Java(tm) Specialists' Newsletter"
>>> Sun Java Champion
>>> IEEE Certified Software Development Professional
>>> http://www.javaspecialists.eu
>>> Tel: +30 69 75 595 262
>>> Skype: kabutz
>>>
>>>
>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>> I am curious as to the intended content of your presentation.  Here's
>>>> some ideas.  I wondering what you are planing on doing.
>>>>
>>>>   1. Printing the call stacks with lock information using a tool such
>>>>      as jstack
>>>>   2. Press the "Detect Deadlock" button in JConsole
>>>>   3. Dealing with Lock and Condition objects instead of synchronized
>>>>      blocks
>>>>   4. Detecting live lock
>>>>   5. Distributed deadlocks
>>>>
>>>> Nathan Reynolds
>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>  |
>>>> Consulting Member of Technical Staff | 602.333.9091
>>>> Oracle PSR Engineering<http://psr.us.oracle.com/>  | Server Technology
>>>>
>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>>> Good afternoon,
>>>>>
>>>>> I am thinking of submitting a talk on finding and diagnosing
>>>>> deadlocks for JavaOne.  It might be a workshop, instead of a simple
>>>>> conference talk.  Or we might be able to turn the talk into a
>>>>> workshop where they need to find a deadlock in a body of code.
>>>>> Could be something different, which might go incredibly well or
>>>>> crash in a blaze of flames.  Would any of you be interested in
>>>>> co-presenting this with me at JavaOne?
>>>>>
>>>>> Regards
>>>>>
>>>>> Heinz
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/a9aa92f9/attachment.html>

From nathan.reynolds at oracle.com  Thu Apr  5 16:30:33 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Thu, 05 Apr 2012 13:30:33 -0700
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7DFF0D.7030605@javaspecialists.eu>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
	<4F7DEC6E.1000204@javaspecialists.eu> <4F7DF299.4070209@oracle.com>
	<4F7DFF0D.7030605@javaspecialists.eu>
Message-ID: <4F7E00E9.5040504@oracle.com>

I guess it is a good idea to not initially include the source code in 
the workshop because many times I initially don't have the source code 
when trying to figure out performance or scalability problems.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
> Sorry Nathan, here is the zip file including the source code an an Ant 
> script to build the code.  Sorry for accidentally excluding that from 
> the file I sent earlier.  The problem was between the chair and the 
> keyboard.  However, one should be able to pinpoint the deadlock 
> without seeing a line of code.  At the workshop I presented in Spain 
> last week, most of the programmers immediately started delving into 
> the code before they knew where to look.
> Regards
>
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun Java Champion
> IEEE Certified Software Development Professional
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
>
> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>> I took the bait and tried out the demo on HotSpot 7 Update 3.  It 
>> didn't deadlock for a minute or two.  Then the application froze.  I 
>> then used jstack to dump the call stacks.  At the end of the report, 
>> it said "Found one Java-level deadlock".  It then dumped out the 
>> locks and threads involved in the deadlock.  I never looked at the 
>> source code... in fact it wasn't in the zip file.  This took about 
>> 5-7 minutes from starting the application to finding the deadlock in 
>> the call stacks.
>>
>> A 100 good Java developers?  Really?  I guess I can understand.  Most 
>> engineers don't understand locks.  Most of the time I get answers 
>> like one should put a lock around shared variables.  This is accurate 
>> but they can't really go any deeper.
>>
>> It sounds like the material of your presentation should be very 
>> good.  It covers things that the deadlock detection tool probably 
>> can't figure out.
>>
>> So, it seems like you have everything figured out.  Why do you need 
>> someone else?
>>
>> Nathan Reynolds 
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>> Consulting Member of Technical Staff | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>
>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>> Hi Nathan,
>>>
>>> a stack trace will only show you a certain class of obvious 
>>> deadlocks that are easy to find and solve.  I remember solving 
>>> deadlocks /before/ we had the brilliant deadlock detection tool in 
>>> the ThreadMXBean.  Yes, the deadlock detection tool shows you /some/ 
>>> deadlocks, but definitely not all of them.  I can think of a bunch 
>>> that it would not find:
>>>
>>> 1. Semaphores running out of permits
>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>>> 3. Resource deadlocks
>>>
>>> And some others that I will not describe in detail, such as some 
>>> nasty livelocks that we can cause which will hang up the JVM :-)
>>>
>>> I agree with Kirk - it should probably be a 3 hour workshop.  I've 
>>> done this three times now - twice in Spain and once via webinar.  
>>> The workshop would involve some lessons on deadlocks, what causes 
>>> them and how we can prevent them.  Also an explanation as to why we 
>>> see them so seldom in real production.  I've got material prepared 
>>> for this workshop.  And then a practical part to the workshop where 
>>> they can try to find a deadlock in a body of code.
>>>
>>> Attached is an example of the workshop.  You can try find the 
>>> deadlock if you like.  I've shown it to almost 100 good Java 
>>> developers and so far, not one has found it by themselves.  I would 
>>> expect that they should find it in 5 minutes.  In our workshop they 
>>> would obviously be helped a bit with hints, so that they can walk 
>>> away with a good experience.  Use anything you like.  Oscilloscope, 
>>> jstack, jconsole, whatever you like.  Only rule for you guys on the 
>>> "concurrency-interest" list is: you can only look at the code once 
>>> you've found the problem, otherwise it would be too easy for you 
>>> :-)  Once you have found it, you can also fix the code and make sure 
>>> that the code then works correctly.
>>> Regards
>>>
>>> Heinz
>>> -- 
>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> Author of "The Java(tm) Specialists' Newsletter"
>>> Sun Java Champion
>>> IEEE Certified Software Development Professional
>>> http://www.javaspecialists.eu
>>> Tel: +30 69 75 595 262
>>> Skype: kabutz
>>>      
>>>
>>>
>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>> I am curious as to the intended content of your presentation.  
>>>> Here's some ideas.  I wondering what you are planing on doing.
>>>>
>>>>  1. Printing the call stacks with lock information using a tool
>>>>     such as jstack
>>>>  2. Press the "Detect Deadlock" button in JConsole
>>>>  3. Dealing with Lock and Condition objects instead of synchronized
>>>>     blocks
>>>>  4. Detecting live lock
>>>>  5. Distributed deadlocks
>>>>
>>>> Nathan Reynolds 
>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>>>> Consulting Member of Technical Staff | 602.333.9091
>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>>
>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>>> Good afternoon,
>>>>>
>>>>> I am thinking of submitting a talk on finding and diagnosing 
>>>>> deadlocks for JavaOne.  It might be a workshop, instead of a 
>>>>> simple conference talk.  Or we might be able to turn the talk into 
>>>>> a workshop where they need to find a deadlock in a body of code.  
>>>>> Could be something different, which might go incredibly well or 
>>>>> crash in a blaze of flames.  Would any of you be interested in 
>>>>> co-presenting this with me at JavaOne?
>>>>>
>>>>> Regards
>>>>>
>>>>> Heinz
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/b13da5d1/attachment-0001.html>

From heinz at javaspecialists.eu  Thu Apr  5 16:33:19 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Thu, 05 Apr 2012 23:33:19 +0300
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7E0095.3070701@oracle.com>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
	<4F7DEC6E.1000204@javaspecialists.eu> <4F7DF299.4070209@oracle.com>
	<CACLL95qwW96sz6pDwjqC5nXmB3D57P5vUWBN+xfBRnM3o6+J=g@mail.gmail.com>
	<4F7E0095.3070701@oracle.com>
Message-ID: <4F7E018F.8070400@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/0138f0db/attachment.html>

From heinz at javaspecialists.eu  Thu Apr  5 16:35:05 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Thu, 05 Apr 2012 23:35:05 +0300
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7E00E9.5040504@oracle.com>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
	<4F7DEC6E.1000204@javaspecialists.eu> <4F7DF299.4070209@oracle.com>
	<4F7DFF0D.7030605@javaspecialists.eu> <4F7E00E9.5040504@oracle.com>
Message-ID: <4F7E01F9.4020100@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/fa57579f/attachment.html>

From kirk at kodewerk.com  Thu Apr  5 17:23:57 2012
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Thu, 5 Apr 2012 23:23:57 +0200
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7E0095.3070701@oracle.com>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
	<4F7DEC6E.1000204@javaspecialists.eu> <4F7DF299.4070209@oracle.com>
	<CACLL95qwW96sz6pDwjqC5nXmB3D57P5vUWBN+xfBRnM3o6+J=g@mail.gmail.com>
	<4F7E0095.3070701@oracle.com>
Message-ID: <BDFA13FD-2F2B-4688-867C-1F56D4738F04@kodewerk.com>

I made the same mistake....

On 2012-04-05, at 10:29 PM, Nathan Reynolds wrote:

> I jumped at the first deadlock I found and stopped.  I didn't even consider that the AWT EventQueue thread had to be involved to deadlock the GUI.  I simply saw the deadlock and quit.  Nice distraction!  Without spoiling it for others, it took me another minute to see the 2?? deadlock.  Nice.  Please don't tell me that this is just another distraction from another deadlock hiding in the code.
> 
> Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering | Server Technology
> 
> On 4/5/2012 12:52 PM, Dr Heinz M. Kabutz wrote:
>> 
>> You did not find the deadlock that caused your application to freeze
>> up :-). 101 good Java developers now.
>> 
>> On 05/04/2012, Nathan Reynolds <nathan.reynolds at oracle.com> wrote:
>>> I took the bait and tried out the demo on HotSpot 7 Update 3.  It didn't
>>> deadlock for a minute or two.  Then the application froze.  I then used
>>> jstack to dump the call stacks.  At the end of the report, it said
>>> "Found one Java-level deadlock".  It then dumped out the locks and
>>> threads involved in the deadlock.  I never looked at the source code...
>>> in fact it wasn't in the zip file.  This took about 5-7 minutes from
>>> starting the application to finding the deadlock in the call stacks.
>>> 
>>> A 100 good Java developers?  Really?  I guess I can understand.  Most
>>> engineers don't understand locks.  Most of the time I get answers like
>>> one should put a lock around shared variables.  This is accurate but
>>> they can't really go any deeper.
>>> 
>>> It sounds like the material of your presentation should be very good.
>>> It covers things that the deadlock detection tool probably can't figure out.
>>> 
>>> So, it seems like you have everything figured out.  Why do you need
>>> someone else?
>>> 
>>> Nathan Reynolds
>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>> Consulting Member of Technical Staff | 602.333.9091
>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>> 
>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>>> Hi Nathan,
>>>> 
>>>> a stack trace will only show you a certain class of obvious deadlocks
>>>> that are easy to find and solve.  I remember solving deadlocks
>>>> /before/ we had the brilliant deadlock detection tool in the
>>>> ThreadMXBean.  Yes, the deadlock detection tool shows you /some/
>>>> deadlocks, but definitely not all of them.  I can think of a bunch
>>>> that it would not find:
>>>> 
>>>> 1. Semaphores running out of permits
>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>>>> 3. Resource deadlocks
>>>> 
>>>> And some others that I will not describe in detail, such as some nasty
>>>> livelocks that we can cause which will hang up the JVM :-)
>>>> 
>>>> I agree with Kirk - it should probably be a 3 hour workshop.  I've
>>>> done this three times now - twice in Spain and once via webinar.  The
>>>> workshop would involve some lessons on deadlocks, what causes them and
>>>> how we can prevent them.  Also an explanation as to why we see them so
>>>> seldom in real production.  I've got material prepared for this
>>>> workshop.  And then a practical part to the workshop where they can
>>>> try to find a deadlock in a body of code.
>>>> 
>>>> Attached is an example of the workshop.  You can try find the deadlock
>>>> if you like.  I've shown it to almost 100 good Java developers and so
>>>> far, not one has found it by themselves.  I would expect that they
>>>> should find it in 5 minutes.  In our workshop they would obviously be
>>>> helped a bit with hints, so that they can walk away with a good
>>>> experience.  Use anything you like.  Oscilloscope, jstack, jconsole,
>>>> whatever you like.  Only rule for you guys on the
>>>> "concurrency-interest" list is: you can only look at the code once
>>>> you've found the problem, otherwise it would be too easy for you :-)
>>>> Once you have found it, you can also fix the code and make sure that
>>>> the code then works correctly.
>>>> Regards
>>>> 
>>>> Heinz
>>>> --
>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>> Sun Java Champion
>>>> IEEE Certified Software Development Professional
>>>> http://www.javaspecialists.eu
>>>> Tel: +30 69 75 595 262
>>>> Skype: kabutz
>>>> 
>>>> 
>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>>> I am curious as to the intended content of your presentation.  Here's
>>>>> some ideas.  I wondering what you are planing on doing.
>>>>> 
>>>>>  1. Printing the call stacks with lock information using a tool such
>>>>>     as jstack
>>>>>  2. Press the "Detect Deadlock" button in JConsole
>>>>>  3. Dealing with Lock and Condition objects instead of synchronized
>>>>>     blocks
>>>>>  4. Detecting live lock
>>>>>  5. Distributed deadlocks
>>>>> 
>>>>> Nathan Reynolds
>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>> Consulting Member of Technical Staff | 602.333.9091
>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>>> 
>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>>>> Good afternoon,
>>>>>> 
>>>>>> I am thinking of submitting a talk on finding and diagnosing
>>>>>> deadlocks for JavaOne.  It might be a workshop, instead of a simple
>>>>>> conference talk.  Or we might be able to turn the talk into a
>>>>>> workshop where they need to find a deadlock in a body of code.
>>>>>> Could be something different, which might go incredibly well or
>>>>>> crash in a blaze of flames.  Would any of you be interested in
>>>>>> co-presenting this with me at JavaOne?
>>>>>> 
>>>>>> Regards
>>>>>> 
>>>>>> Heinz
>> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120405/defd216b/attachment-0001.html>

From forax at univ-mlv.fr  Thu Apr  5 18:51:17 2012
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Fri, 06 Apr 2012 00:51:17 +0200
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7E01F9.4020100@javaspecialists.eu>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
	<4F7DEC6E.1000204@javaspecialists.eu> <4F7DF299.4070209@oracle.com>
	<4F7DFF0D.7030605@javaspecialists.eu> <4F7E00E9.5040504@oracle.com>
	<4F7E01F9.4020100@javaspecialists.eu>
Message-ID: <4F7E21E5.5020705@univ-mlv.fr>

jdk8 crashes if I click on images of the tapped pane.

R?mi

On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
> Yes, you are correct.
>
> However, the mistake most programmers make is to #1 scratch around in 
> the source code to try and discover the problem and #2 then fix it 
> without really understanding what they are doing.  I think the lesson 
> is bigger if we give them the source code.  In addition, it is 
> probably more difficult to solve if you have the sources to muse over.
> Regards
>
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun Java Champion
> IEEE Certified Software Development Professional
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
>
> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>> I guess it is a good idea to not initially include the source code in 
>> the workshop because many times I initially don't have the source 
>> code when trying to figure out performance or scalability problems.
>>
>> Nathan Reynolds 
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>> Consulting Member of Technical Staff | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>
>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>>> Sorry Nathan, here is the zip file including the source code an an 
>>> Ant script to build the code.  Sorry for accidentally excluding that 
>>> from the file I sent earlier.  The problem was between the chair and 
>>> the keyboard.  However, one should be able to pinpoint the deadlock 
>>> without seeing a line of code.  At the workshop I presented in Spain 
>>> last week, most of the programmers immediately started delving into 
>>> the code before they knew where to look.
>>> Regards
>>>
>>> Heinz
>>> -- 
>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> Author of "The Java(tm) Specialists' Newsletter"
>>> Sun Java Champion
>>> IEEE Certified Software Development Professional
>>> http://www.javaspecialists.eu
>>> Tel: +30 69 75 595 262
>>> Skype: kabutz
>>>      
>>>
>>>
>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>>>> I took the bait and tried out the demo on HotSpot 7 Update 3.  It 
>>>> didn't deadlock for a minute or two.  Then the application froze.  
>>>> I then used jstack to dump the call stacks.  At the end of the 
>>>> report, it said "Found one Java-level deadlock".  It then dumped 
>>>> out the locks and threads involved in the deadlock.  I never looked 
>>>> at the source code... in fact it wasn't in the zip file.  This took 
>>>> about 5-7 minutes from starting the application to finding the 
>>>> deadlock in the call stacks.
>>>>
>>>> A 100 good Java developers?  Really?  I guess I can understand.  
>>>> Most engineers don't understand locks.  Most of the time I get 
>>>> answers like one should put a lock around shared variables.  This 
>>>> is accurate but they can't really go any deeper.
>>>>
>>>> It sounds like the material of your presentation should be very 
>>>> good.  It covers things that the deadlock detection tool probably 
>>>> can't figure out.
>>>>
>>>> So, it seems like you have everything figured out.  Why do you need 
>>>> someone else?
>>>>
>>>> Nathan Reynolds 
>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>>>> Consulting Member of Technical Staff | 602.333.9091
>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>>
>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>>>> Hi Nathan,
>>>>>
>>>>> a stack trace will only show you a certain class of obvious 
>>>>> deadlocks that are easy to find and solve.  I remember solving 
>>>>> deadlocks /before/ we had the brilliant deadlock detection tool in 
>>>>> the ThreadMXBean.  Yes, the deadlock detection tool shows you 
>>>>> /some/ deadlocks, but definitely not all of them.  I can think of 
>>>>> a bunch that it would not find:
>>>>>
>>>>> 1. Semaphores running out of permits
>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>>>>> 3. Resource deadlocks
>>>>>
>>>>> And some others that I will not describe in detail, such as some 
>>>>> nasty livelocks that we can cause which will hang up the JVM :-)
>>>>>
>>>>> I agree with Kirk - it should probably be a 3 hour workshop.  I've 
>>>>> done this three times now - twice in Spain and once via webinar.  
>>>>> The workshop would involve some lessons on deadlocks, what causes 
>>>>> them and how we can prevent them.  Also an explanation as to why 
>>>>> we see them so seldom in real production.  I've got material 
>>>>> prepared for this workshop.  And then a practical part to the 
>>>>> workshop where they can try to find a deadlock in a body of code.
>>>>>
>>>>> Attached is an example of the workshop.  You can try find the 
>>>>> deadlock if you like.  I've shown it to almost 100 good Java 
>>>>> developers and so far, not one has found it by themselves.  I 
>>>>> would expect that they should find it in 5 minutes.  In our 
>>>>> workshop they would obviously be helped a bit with hints, so that 
>>>>> they can walk away with a good experience.  Use anything you 
>>>>> like.  Oscilloscope, jstack, jconsole, whatever you like.  Only 
>>>>> rule for you guys on the "concurrency-interest" list is: you can 
>>>>> only look at the code once you've found the problem, otherwise it 
>>>>> would be too easy for you :-)  Once you have found it, you can 
>>>>> also fix the code and make sure that the code then works correctly.
>>>>> Regards
>>>>>
>>>>> Heinz
>>>>> -- 
>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>> Sun Java Champion
>>>>> IEEE Certified Software Development Professional
>>>>> http://www.javaspecialists.eu
>>>>> Tel: +30 69 75 595 262
>>>>> Skype: kabutz
>>>>>      
>>>>>
>>>>>
>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>>>> I am curious as to the intended content of your presentation.  
>>>>>> Here's some ideas.  I wondering what you are planing on doing.
>>>>>>
>>>>>>  1. Printing the call stacks with lock information using a tool
>>>>>>     such as jstack
>>>>>>  2. Press the "Detect Deadlock" button in JConsole
>>>>>>  3. Dealing with Lock and Condition objects instead of
>>>>>>     synchronized blocks
>>>>>>  4. Detecting live lock
>>>>>>  5. Distributed deadlocks
>>>>>>
>>>>>> Nathan Reynolds 
>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>>>>>> Consulting Member of Technical Staff | 602.333.9091
>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server 
>>>>>> Technology
>>>>>>
>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>>>>> Good afternoon,
>>>>>>>
>>>>>>> I am thinking of submitting a talk on finding and diagnosing 
>>>>>>> deadlocks for JavaOne.  It might be a workshop, instead of a 
>>>>>>> simple conference talk.  Or we might be able to turn the talk 
>>>>>>> into a workshop where they need to find a deadlock in a body of 
>>>>>>> code.  Could be something different, which might go incredibly 
>>>>>>> well or crash in a blaze of flames.  Would any of you be 
>>>>>>> interested in co-presenting this with me at JavaOne?
>>>>>>>
>>>>>>> Regards
>>>>>>>
>>>>>>> Heinz
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From heinz at javaspecialists.eu  Sat Apr  7 04:17:02 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Sat, 07 Apr 2012 11:17:02 +0300
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7E21E5.5020705@univ-mlv.fr>
References: <4F7DB2BE.5030205@javaspecialists.eu>
	<4F7DCFDC.5020101@oracle.com>	<4F7DEC6E.1000204@javaspecialists.eu>
	<4F7DF299.4070209@oracle.com>	<4F7DFF0D.7030605@javaspecialists.eu>
	<4F7E00E9.5040504@oracle.com>	<4F7E01F9.4020100@javaspecialists.eu>
	<4F7E21E5.5020705@univ-mlv.fr>
Message-ID: <4F7FF7FE.4090007@javaspecialists.eu>

I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6.  I see 
that the Java2Demo has been removed from the demos folder of JDK 1.7 and 
1.8.  It thus is a Java 8 issue, rather than the changes I made to the 
code.  Thanks for the warning R?mi.

Regards

Heinz
-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun Java Champion
IEEE Certified Software Development Professional
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz 



On 4/6/12 1:51 AM, R?mi Forax wrote:
> jdk8 crashes if I click on images of the tapped pane.
>
> R?mi
>
> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
>> Yes, you are correct.
>>
>> However, the mistake most programmers make is to #1 scratch around in 
>> the source code to try and discover the problem and #2 then fix it 
>> without really understanding what they are doing.  I think the lesson 
>> is bigger if we give them the source code.  In addition, it is 
>> probably more difficult to solve if you have the sources to muse over.
>> Regards
>>
>> Heinz
>> -- 
>> Dr Heinz M. Kabutz (PhD CompSci)
>> Author of "The Java(tm) Specialists' Newsletter"
>> Sun Java Champion
>> IEEE Certified Software Development Professional
>> http://www.javaspecialists.eu
>> Tel: +30 69 75 595 262
>> Skype: kabutz
>>
>>
>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>>> I guess it is a good idea to not initially include the source code 
>>> in the workshop because many times I initially don't have the source 
>>> code when trying to figure out performance or scalability problems.
>>>
>>> Nathan Reynolds 
>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>>> Consulting Member of Technical Staff | 602.333.9091
>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>
>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>>>> Sorry Nathan, here is the zip file including the source code an an 
>>>> Ant script to build the code.  Sorry for accidentally excluding 
>>>> that from the file I sent earlier.  The problem was between the 
>>>> chair and the keyboard.  However, one should be able to pinpoint 
>>>> the deadlock without seeing a line of code.  At the workshop I 
>>>> presented in Spain last week, most of the programmers immediately 
>>>> started delving into the code before they knew where to look.
>>>> Regards
>>>>
>>>> Heinz
>>>> -- 
>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>> Sun Java Champion
>>>> IEEE Certified Software Development Professional
>>>> http://www.javaspecialists.eu
>>>> Tel: +30 69 75 595 262
>>>> Skype: kabutz
>>>>     
>>>>
>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3.  It 
>>>>> didn't deadlock for a minute or two.  Then the application froze.  
>>>>> I then used jstack to dump the call stacks.  At the end of the 
>>>>> report, it said "Found one Java-level deadlock".  It then dumped 
>>>>> out the locks and threads involved in the deadlock.  I never 
>>>>> looked at the source code... in fact it wasn't in the zip file.  
>>>>> This took about 5-7 minutes from starting the application to 
>>>>> finding the deadlock in the call stacks.
>>>>>
>>>>> A 100 good Java developers?  Really?  I guess I can understand.  
>>>>> Most engineers don't understand locks.  Most of the time I get 
>>>>> answers like one should put a lock around shared variables.  This 
>>>>> is accurate but they can't really go any deeper.
>>>>>
>>>>> It sounds like the material of your presentation should be very 
>>>>> good.  It covers things that the deadlock detection tool probably 
>>>>> can't figure out.
>>>>>
>>>>> So, it seems like you have everything figured out.  Why do you 
>>>>> need someone else?
>>>>>
>>>>> Nathan Reynolds 
>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>>>>> Consulting Member of Technical Staff | 602.333.9091
>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server 
>>>>> Technology
>>>>>
>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>>>>> Hi Nathan,
>>>>>>
>>>>>> a stack trace will only show you a certain class of obvious 
>>>>>> deadlocks that are easy to find and solve.  I remember solving 
>>>>>> deadlocks /before/ we had the brilliant deadlock detection tool 
>>>>>> in the ThreadMXBean.  Yes, the deadlock detection tool shows you 
>>>>>> /some/ deadlocks, but definitely not all of them.  I can think of 
>>>>>> a bunch that it would not find:
>>>>>>
>>>>>> 1. Semaphores running out of permits
>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>>>>>> 3. Resource deadlocks
>>>>>>
>>>>>> And some others that I will not describe in detail, such as some 
>>>>>> nasty livelocks that we can cause which will hang up the JVM :-)
>>>>>>
>>>>>> I agree with Kirk - it should probably be a 3 hour workshop.  
>>>>>> I've done this three times now - twice in Spain and once via 
>>>>>> webinar.  The workshop would involve some lessons on deadlocks, 
>>>>>> what causes them and how we can prevent them.  Also an 
>>>>>> explanation as to why we see them so seldom in real production.  
>>>>>> I've got material prepared for this workshop.  And then a 
>>>>>> practical part to the workshop where they can try to find a 
>>>>>> deadlock in a body of code.
>>>>>>
>>>>>> Attached is an example of the workshop.  You can try find the 
>>>>>> deadlock if you like.  I've shown it to almost 100 good Java 
>>>>>> developers and so far, not one has found it by themselves.  I 
>>>>>> would expect that they should find it in 5 minutes.  In our 
>>>>>> workshop they would obviously be helped a bit with hints, so that 
>>>>>> they can walk away with a good experience.  Use anything you 
>>>>>> like.  Oscilloscope, jstack, jconsole, whatever you like.  Only 
>>>>>> rule for you guys on the "concurrency-interest" list is: you can 
>>>>>> only look at the code once you've found the problem, otherwise it 
>>>>>> would be too easy for you :-)  Once you have found it, you can 
>>>>>> also fix the code and make sure that the code then works correctly.
>>>>>> Regards
>>>>>>
>>>>>> Heinz
>>>>>> -- 
>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>> Sun Java Champion
>>>>>> IEEE Certified Software Development Professional
>>>>>> http://www.javaspecialists.eu
>>>>>> Tel: +30 69 75 595 262
>>>>>> Skype: kabutz
>>>>>>     
>>>>>>
>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>>>>> I am curious as to the intended content of your presentation.  
>>>>>>> Here's some ideas.  I wondering what you are planing on doing.
>>>>>>>
>>>>>>>  1. Printing the call stacks with lock information using a tool
>>>>>>>     such as jstack
>>>>>>>  2. Press the "Detect Deadlock" button in JConsole
>>>>>>>  3. Dealing with Lock and Condition objects instead of
>>>>>>>     synchronized blocks
>>>>>>>  4. Detecting live lock
>>>>>>>  5. Distributed deadlocks
>>>>>>>
>>>>>>> Nathan Reynolds 
>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>>>>>>> Consulting Member of Technical Staff | 602.333.9091
>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server 
>>>>>>> Technology
>>>>>>>
>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>>>>>> Good afternoon,
>>>>>>>>
>>>>>>>> I am thinking of submitting a talk on finding and diagnosing 
>>>>>>>> deadlocks for JavaOne.  It might be a workshop, instead of a 
>>>>>>>> simple conference talk.  Or we might be able to turn the talk 
>>>>>>>> into a workshop where they need to find a deadlock in a body of 
>>>>>>>> code.  Could be something different, which might go incredibly 
>>>>>>>> well or crash in a blaze of flames.  Would any of you be 
>>>>>>>> interested in co-presenting this with me at JavaOne?
>>>>>>>>
>>>>>>>> Regards
>>>>>>>>
>>>>>>>> Heinz
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From benjamin.john.evans at gmail.com  Sat Apr  7 04:43:22 2012
From: benjamin.john.evans at gmail.com (Ben Evans)
Date: Sat, 7 Apr 2012 11:43:22 +0300
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F7FF7FE.4090007@javaspecialists.eu>
References: <4F7DB2BE.5030205@javaspecialists.eu> <4F7DCFDC.5020101@oracle.com>
	<4F7DEC6E.1000204@javaspecialists.eu> <4F7DF299.4070209@oracle.com>
	<4F7DFF0D.7030605@javaspecialists.eu> <4F7E00E9.5040504@oracle.com>
	<4F7E01F9.4020100@javaspecialists.eu>
	<4F7E21E5.5020705@univ-mlv.fr>
	<4F7FF7FE.4090007@javaspecialists.eu>
Message-ID: <CABKW8RhwExDyuXhePLs=mVwTTd2OnsOew0V-MUeFd_eikZjoug@mail.gmail.com>

Heinz, was this with the new jdk8 + lambda build?

If so, we should report this crash back to lambda-dev.

Thanks,

Ben

On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
<heinz at javaspecialists.eu> wrote:
> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6. ?I see that
> the Java2Demo has been removed from the demos folder of JDK 1.7 and 1.8. ?It
> thus is a Java 8 issue, rather than the changes I made to the code. ?Thanks
> for the warning R?mi.
>
>
> Regards
>
> Heinz
> --
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun Java Champion
> IEEE Certified Software Development Professional
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
>
> On 4/6/12 1:51 AM, R?mi Forax wrote:
>>
>> jdk8 crashes if I click on images of the tapped pane.
>>
>> R?mi
>>
>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
>>>
>>> Yes, you are correct.
>>>
>>> However, the mistake most programmers make is to #1 scratch around in the
>>> source code to try and discover the problem and #2 then fix it without
>>> really understanding what they are doing. ?I think the lesson is bigger if
>>> we give them the source code. ?In addition, it is probably more difficult to
>>> solve if you have the sources to muse over.
>>> Regards
>>>
>>> Heinz
>>> --
>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> Author of "The Java(tm) Specialists' Newsletter"
>>> Sun Java Champion
>>> IEEE Certified Software Development Professional
>>> http://www.javaspecialists.eu
>>> Tel: +30 69 75 595 262
>>> Skype: kabutz
>>>
>>>
>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>>>>
>>>> I guess it is a good idea to not initially include the source code in
>>>> the workshop because many times I initially don't have the source code when
>>>> trying to figure out performance or scalability problems.
>>>>
>>>> Nathan Reynolds
>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | Consulting
>>>> Member of Technical Staff | 602.333.9091
>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>>
>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>>>>>
>>>>> Sorry Nathan, here is the zip file including the source code an an Ant
>>>>> script to build the code. ?Sorry for accidentally excluding that from the
>>>>> file I sent earlier. ?The problem was between the chair and the keyboard.
>>>>> ?However, one should be able to pinpoint the deadlock without seeing a line
>>>>> of code. ?At the workshop I presented in Spain last week, most of the
>>>>> programmers immediately started delving into the code before they knew where
>>>>> to look.
>>>>> Regards
>>>>>
>>>>> Heinz
>>>>> --
>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>> Sun Java Champion
>>>>> IEEE Certified Software Development Professional
>>>>> http://www.javaspecialists.eu
>>>>> Tel: +30 69 75 595 262
>>>>> Skype: kabutz
>>>>>
>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>>>>>>
>>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3. ?It
>>>>>> didn't deadlock for a minute or two. ?Then the application froze. ?I then
>>>>>> used jstack to dump the call stacks. ?At the end of the report, it said
>>>>>> "Found one Java-level deadlock". ?It then dumped out the locks and threads
>>>>>> involved in the deadlock. ?I never looked at the source code... in fact it
>>>>>> wasn't in the zip file. ?This took about 5-7 minutes from starting the
>>>>>> application to finding the deadlock in the call stacks.
>>>>>>
>>>>>> A 100 good Java developers? ?Really? ?I guess I can understand. ?Most
>>>>>> engineers don't understand locks. ?Most of the time I get answers like one
>>>>>> should put a lock around shared variables. ?This is accurate but they can't
>>>>>> really go any deeper.
>>>>>>
>>>>>> It sounds like the material of your presentation should be very good.
>>>>>> ?It covers things that the deadlock detection tool probably can't figure
>>>>>> out.
>>>>>>
>>>>>> So, it seems like you have everything figured out. ?Why do you need
>>>>>> someone else?
>>>>>>
>>>>>> Nathan Reynolds
>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | Consulting
>>>>>> Member of Technical Staff | 602.333.9091
>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>>>>
>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>>>>>>
>>>>>>> Hi Nathan,
>>>>>>>
>>>>>>> a stack trace will only show you a certain class of obvious deadlocks
>>>>>>> that are easy to find and solve. ?I remember solving deadlocks /before/ we
>>>>>>> had the brilliant deadlock detection tool in the ThreadMXBean. ?Yes, the
>>>>>>> deadlock detection tool shows you /some/ deadlocks, but definitely not all
>>>>>>> of them. ?I can think of a bunch that it would not find:
>>>>>>>
>>>>>>> 1. Semaphores running out of permits
>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>>>>>>> 3. Resource deadlocks
>>>>>>>
>>>>>>> And some others that I will not describe in detail, such as some
>>>>>>> nasty livelocks that we can cause which will hang up the JVM :-)
>>>>>>>
>>>>>>> I agree with Kirk - it should probably be a 3 hour workshop. ?I've
>>>>>>> done this three times now - twice in Spain and once via webinar. ?The
>>>>>>> workshop would involve some lessons on deadlocks, what causes them and how
>>>>>>> we can prevent them. ?Also an explanation as to why we see them so seldom in
>>>>>>> real production. ?I've got material prepared for this workshop. ?And then a
>>>>>>> practical part to the workshop where they can try to find a deadlock in a
>>>>>>> body of code.
>>>>>>>
>>>>>>> Attached is an example of the workshop. ?You can try find the
>>>>>>> deadlock if you like. ?I've shown it to almost 100 good Java developers and
>>>>>>> so far, not one has found it by themselves. ?I would expect that they should
>>>>>>> find it in 5 minutes. ?In our workshop they would obviously be helped a bit
>>>>>>> with hints, so that they can walk away with a good experience. ?Use anything
>>>>>>> you like. ?Oscilloscope, jstack, jconsole, whatever you like. ?Only rule for
>>>>>>> you guys on the "concurrency-interest" list is: you can only look at the
>>>>>>> code once you've found the problem, otherwise it would be too easy for you
>>>>>>> :-) ?Once you have found it, you can also fix the code and make sure that
>>>>>>> the code then works correctly.
>>>>>>> Regards
>>>>>>>
>>>>>>> Heinz
>>>>>>> --
>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>>> Sun Java Champion
>>>>>>> IEEE Certified Software Development Professional
>>>>>>> http://www.javaspecialists.eu
>>>>>>> Tel: +30 69 75 595 262
>>>>>>> Skype: kabutz
>>>>>>>
>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>>>>>>
>>>>>>>> I am curious as to the intended content of your presentation.
>>>>>>>> ?Here's some ideas. ?I wondering what you are planing on doing.
>>>>>>>>
>>>>>>>> ?1. Printing the call stacks with lock information using a tool
>>>>>>>> ? ?such as jstack
>>>>>>>> ?2. Press the "Detect Deadlock" button in JConsole
>>>>>>>> ?3. Dealing with Lock and Condition objects instead of
>>>>>>>> ? ?synchronized blocks
>>>>>>>> ?4. Detecting live lock
>>>>>>>> ?5. Distributed deadlocks
>>>>>>>>
>>>>>>>> Nathan Reynolds
>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | Consulting
>>>>>>>> Member of Technical Staff | 602.333.9091
>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>>>>>> Technology
>>>>>>>>
>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>>>>>>>
>>>>>>>>> Good afternoon,
>>>>>>>>>
>>>>>>>>> I am thinking of submitting a talk on finding and diagnosing
>>>>>>>>> deadlocks for JavaOne. ?It might be a workshop, instead of a simple
>>>>>>>>> conference talk. ?Or we might be able to turn the talk into a workshop where
>>>>>>>>> they need to find a deadlock in a body of code. ?Could be something
>>>>>>>>> different, which might go incredibly well or crash in a blaze of flames.
>>>>>>>>> ?Would any of you be interested in co-presenting this with me at JavaOne?
>>>>>>>>>
>>>>>>>>> Regards
>>>>>>>>>
>>>>>>>>> Heinz
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From forax at univ-mlv.fr  Sat Apr  7 07:42:05 2012
From: forax at univ-mlv.fr (=?utf-8?B?UmVtaSBGb3JheA==?=)
Date: Sat, 07 Apr 2012 13:42:05 +0200
Subject: [concurrency-interest] =?utf-8?q?Joint_Talk_for_JavaOne=3F?=
Message-ID: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>

No, it's more an AWRY or Java2D bug.

R?mi

Sent from my Phone

----- Reply message -----
From: "Ben Evans" <benjamin.john.evans at gmail.com>
To: "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
Cc: "R?mi Forax" <forax at univ-mlv.fr>, <concurrency-interest at cs.oswego.edu>
Subject: [concurrency-interest] Joint Talk for JavaOne?
Date: Sat, Apr 7, 2012 10:43


Heinz, was this with the new jdk8 + lambda build?

If so, we should report this crash back to lambda-dev.

Thanks,

Ben

On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
<heinz at javaspecialists.eu> wrote:
> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6. ?I see that
> the Java2Demo has been removed from the demos folder of JDK 1.7 and 1.8. ?It
> thus is a Java 8 issue, rather than the changes I made to the code. ?Thanks
> for the warning R?mi.
>
>
> Regards
>
> Heinz
> --
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun Java Champion
> IEEE Certified Software Development Professional
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
>
> On 4/6/12 1:51 AM, R?mi Forax wrote:
>>
>> jdk8 crashes if I click on images of the tapped pane.
>>
>> R?mi
>>
>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
>>>
>>> Yes, you are correct.
>>>
>>> However, the mistake most programmers make is to #1 scratch around in the
>>> source code to try and discover the problem and #2 then fix it without
>>> really understanding what they are doing. ?I think the lesson is bigger if
>>> we give them the source code. ?In addition, it is probably more difficult to
>>> solve if you have the sources to muse over.
>>> Regards
>>>
>>> Heinz
>>> --
>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> Author of "The Java(tm) Specialists' Newsletter"
>>> Sun Java Champion
>>> IEEE Certified Software Development Professional
>>> http://www.javaspecialists.eu
>>> Tel: +30 69 75 595 262
>>> Skype: kabutz
>>>
>>>
>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>>>>
>>>> I guess it is a good idea to not initially include the source code in
>>>> the workshop because many times I initially don't have the source code when
>>>> trying to figure out performance or scalability problems.
>>>>
>>>> Nathan Reynolds
>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | Consulting
>>>> Member of Technical Staff | 602.333.9091
>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>>
>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>>>>>
>>>>> Sorry Nathan, here is the zip file including the source code an an Ant
>>>>> script to build the code. ?Sorry for accidentally excluding that from the
>>>>> file I sent earlier. ?The problem was between the chair and the keyboard.
>>>>> ?However, one should be able to pinpoint the deadlock without seeing a line
>>>>> of code. ?At the workshop I presented in Spain last week, most of the
>>>>> programmers immediately started delving into the code before they knew where
>>>>> to look.
>>>>> Regards
>>>>>
>>>>> Heinz
>>>>> --
>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>> Sun Java Champion
>>>>> IEEE Certified Software Development Professional
>>>>> http://www.javaspecialists.eu
>>>>> Tel: +30 69 75 595 262
>>>>> Skype: kabutz
>>>>>
>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>>>>>>
>>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3. ?It
>>>>>> didn't deadlock for a minute or two. ?Then the application froze. ?I then
>>>>>> used jstack to dump the call stacks. ?At the end of the report, it said
>>>>>> "Found one Java-level deadlock". ?It then dumped out the locks and threads
>>>>>> involved in the deadlock. ?I never looked at the source code... in fact it
>>>>>> wasn't in the zip file. ?This took about 5-7 minutes from starting the
>>>>>> application to finding the deadlock in the call stacks.
>>>>>>
>>>>>> A 100 good Java developers? ?Really? ?I guess I can understand. ?Most
>>>>>> engineers don't understand locks. ?Most of the time I get answers like one
>>>>>> should put a lock around shared variables. ?This is accurate but they can't
>>>>>> really go any deeper.
>>>>>>
>>>>>> It sounds like the material of your presentation should be very good.
>>>>>> ?It covers things that the deadlock detection tool probably can't figure
>>>>>> out.
>>>>>>
>>>>>> So, it seems like you have everything figured out. ?Why do you need
>>>>>> someone else?
>>>>>>
>>>>>> Nathan Reynolds
>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | Consulting
>>>>>> Member of Technical Staff | 602.333.9091
>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>>>>
>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>>>>>>
>>>>>>> Hi Nathan,
>>>>>>>
>>>>>>> a stack trace will only show you a certain class of obvious deadlocks
>>>>>>> that are easy to find and solve. ?I remember solving deadlocks /before/ we
>>>>>>> had the brilliant deadlock detection tool in the ThreadMXBean. ?Yes, the
>>>>>>> deadlock detection tool shows you /some/ deadlocks, but definitely not all
>>>>>>> of them. ?I can think of a bunch that it would not find:
>>>>>>>
>>>>>>> 1. Semaphores running out of permits
>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>>>>>>> 3. Resource deadlocks
>>>>>>>
>>>>>>> And some others that I will not describe in detail, such as some
>>>>>>> nasty livelocks that we can cause which will hang up the JVM :-)
>>>>>>>
>>>>>>> I agree with Kirk - it should probably be a 3 hour workshop. ?I've
>>>>>>> done this three times now - twice in Spain and once via webinar. ?The
>>>>>>> workshop would involve some lessons on deadlocks, what causes them and how
>>>>>>> we can prevent them. ?Also an explanation as to why we see them so seldom in
>>>>>>> real production. ?I've got material prepared for this workshop. ?And then a
>>>>>>> practical part to the workshop where they can try to find a deadlock in a
>>>>>>> body of code.
>>>>>>>
>>>>>>> Attached is an example of the workshop. ?You can try find the
>>>>>>> deadlock if you like. ?I've shown it to almost 100 good Java developers and
>>>>>>> so far, not one has found it by themselves. ?I would expect that they should
>>>>>>> find it in 5 minutes. ?In our workshop they would obviously be helped a bit
>>>>>>> with hints, so that they can walk away with a good experience. ?Use anything
>>>>>>> you like. ?Oscilloscope, jstack, jconsole, whatever you like. ?Only rule for
>>>>>>> you guys on the "concurrency-interest" list is: you can only look at the
>>>>>>> code once you've found the problem, otherwise it would be too easy for you
>>>>>>> :-) ?Once you have found it, you can also fix the code and make sure that
>>>>>>> the code then works correctly.
>>>>>>> Regards
>>>>>>>
>>>>>>> Heinz
>>>>>>> --
>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>>> Sun Java Champion
>>>>>>> IEEE Certified Software Development Professional
>>>>>>> http://www.javaspecialists.eu
>>>>>>> Tel: +30 69 75 595 262
>>>>>>> Skype: kabutz
>>>>>>>
>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>>>>>>
>>>>>>>> I am curious as to the intended content of your presentation.
>>>>>>>> ?Here's some ideas. ?I wondering what you are planing on doing.
>>>>>>>>
>>>>>>>> ?1. Printing the call stacks with lock information using a tool
>>>>>>>> ? ?such as jstack
>>>>>>>> ?2. Press the "Detect Deadlock" button in JConsole
>>>>>>>> ?3. Dealing with Lock and Condition objects instead of
>>>>>>>> ? ?synchronized blocks
>>>>>>>> ?4. Detecting live lock
>>>>>>>> ?5. Distributed deadlocks
>>>>>>>>
>>>>>>>> Nathan Reynolds
>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | Consulting
>>>>>>>> Member of Technical Staff | 602.333.9091
>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>>>>>> Technology
>>>>>>>>
>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>>>>>>>
>>>>>>>>> Good afternoon,
>>>>>>>>>
>>>>>>>>> I am thinking of submitting a talk on finding and diagnosing
>>>>>>>>> deadlocks for JavaOne. ?It might be a workshop, instead of a simple
>>>>>>>>> conference talk. ?Or we might be able to turn the talk into a workshop where
>>>>>>>>> they need to find a deadlock in a body of code. ?Could be something
>>>>>>>>> different, which might go incredibly well or crash in a blaze of flames.
>>>>>>>>> ?Would any of you be interested in co-presenting this with me at JavaOne?
>>>>>>>>>
>>>>>>>>> Regards
>>>>>>>>>
>>>>>>>>> Heinz
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120407/1309267f/attachment-0001.html>

From ilya.mirsky at gmail.com  Sat Apr  7 13:45:57 2012
From: ilya.mirsky at gmail.com (Ilya Mirsky)
Date: Sat, 7 Apr 2012 20:45:57 +0300
Subject: [concurrency-interest] ConcurrentLinkedQueue in Java 5 vs. 6
Message-ID: <CANRvXTNTyHKves17-F=1o81ZZrLe0mJ9SYk3PgDPZzAvCM-VvA@mail.gmail.com>

Hi,

Running some benchmarks on a multicore machine (Ultra SPARC T2),
I noticed a significant improvement in performance
of ConcurrentLinkedQueue in Java 6 (1.6.0_23) over Java 5 (1.5.0_14).
 The improvement in high contention scenarios is in a factor of up to 5
times!

I'm curious about the reason for this improvement, as the basic algorithm
is the same (MS queue)...
Examining both of the source files, I noticed that in Java 6 version
there's a use in lazySet in some places,
and direct usage of Unsafe class, instead of AtomicReferenceFieldUpdater in
java 5.

But could this explain the significant improvement, or are there other key
chages?


Thanks in advance,
---
Best Regards,
Ilya Mirsky
<http://www.cs.bgu.ac.il/~mirskyil/>  <http://il.linkedin.com/in/ilyamirsky>
   <https://www.facebook.com/ilya.mirsky>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120407/9abe8f9b/attachment.html>

From viktor.klang at gmail.com  Sat Apr  7 13:55:54 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Sat, 7 Apr 2012 19:55:54 +0200
Subject: [concurrency-interest] ConcurrentLinkedQueue in Java 5 vs. 6
In-Reply-To: <CANRvXTNTyHKves17-F=1o81ZZrLe0mJ9SYk3PgDPZzAvCM-VvA@mail.gmail.com>
References: <CANRvXTNTyHKves17-F=1o81ZZrLe0mJ9SYk3PgDPZzAvCM-VvA@mail.gmail.com>
Message-ID: <CANPzfU8U7UuXvUv0dB4ZjSWfHkMoDNzZZgV=jeycJ_H6rkx6Hw@mail.gmail.com>

On Sat, Apr 7, 2012 at 7:45 PM, Ilya Mirsky <ilya.mirsky at gmail.com> wrote:

> Hi,
>
> Running some benchmarks on a multicore machine (Ultra SPARC T2),
> I noticed a significant improvement in performance
> of ConcurrentLinkedQueue in Java 6 (1.6.0_23) over Java 5 (1.5.0_14).
>  The improvement in high contention scenarios is in a factor of up to 5
> times!
>
> I'm curious about the reason for this improvement, as the basic algorithm
> is the same (MS queue)...
> Examining both of the source files, I noticed that in Java 6 version
> there's a use in lazySet in some places,
> and direct usage of Unsafe class, instead of AtomicReferenceFieldUpdater
> in java 5.
>

My experience with AtomicReferenceFieldUpdater has been a sad one. Use
Unsafe + volatile field to avoid the cost of the runtime checks of the
updater and the false sharing issues with the AtomicReference/Integer etc.
The runtime costs of the Updaters get worse when there is contention since
the checks run on each retry.


>
> But could this explain the significant improvement, or are there other key
> chages?
>

I'll let the man himself answer that :-)

Cheers,
?


>
>
> Thanks in advance,
> ---
> Best Regards,
> Ilya Mirsky
> <http://www.cs.bgu.ac.il/~mirskyil/>  <http://il.linkedin.com/in/ilyamirsky>
>    <https://www.facebook.com/ilya.mirsky>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120407/bb07b88a/attachment.html>

From martinrb at google.com  Sat Apr  7 15:15:33 2012
From: martinrb at google.com (Martin Buchholz)
Date: Sat, 7 Apr 2012 12:15:33 -0700
Subject: [concurrency-interest] ConcurrentLinkedQueue in Java 5 vs. 6
In-Reply-To: <CANRvXTNTyHKves17-F=1o81ZZrLe0mJ9SYk3PgDPZzAvCM-VvA@mail.gmail.com>
References: <CANRvXTNTyHKves17-F=1o81ZZrLe0mJ9SYk3PgDPZzAvCM-VvA@mail.gmail.com>
Message-ID: <CA+kOe0_GcR_E3UGtnAv6x6dwxV__AQ-SGmuHiES3SYqUw1Yp7Q@mail.gmail.com>

On Sat, Apr 7, 2012 at 10:45, Ilya Mirsky <ilya.mirsky at gmail.com> wrote:

> Hi,
>
> Running some benchmarks on a multicore machine (Ultra SPARC T2),
> I noticed a significant improvement in performance
> of ConcurrentLinkedQueue in Java 6 (1.6.0_23) over Java 5 (1.5.0_14).
>  The improvement in high contention scenarios is in a factor of up to 5
> times!
>
> That kind of improvement is a bit of a surprise, but one we're happy to
see.


> I'm curious about the reason for this improvement, as the basic algorithm
> is the same (MS queue)...
> Examining both of the source files, I noticed that in Java 6 version
> there's a use in lazySet in some places,
> and direct usage of Unsafe class, instead of AtomicReferenceFieldUpdater
> in java 5.
>
> But could this explain the significant improvement, or are there other key
> chages?
>
> Good question.  There were lots of small improvements.  Perhaps it's due
to updateHead trying CAS only once.  Or perhaps breaking long chains of
dead nodes, to be nice to the GC, and to avoid useless iteration.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120407/11274146/attachment.html>

From mabrouk2005 at gmail.com  Sun Apr  8 18:29:55 2012
From: mabrouk2005 at gmail.com (mabrouk2005 at gmail.com)
Date: Sun, 8 Apr 2012 18:29:55 -0400
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>
Message-ID: <CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>

Nice exercise Dr Heinz,

As others mentioned there were 2 kind of deadlocks the first one was
very is easy to find via jconsole so likeI thought that was it and
went and fixed that but then when ran it again it hang it so I knew
thee was more. the interesting thing the jconsole did not detect the
AWT deadlock it showed no deadlock even though the app hang. I had to
force stack dump and get clues to where is the deadlock. Does anyone
have experienced something like this with jconsole not detecting AWT
deadlocks?

Thanks again for the nice exercise and the great java news letter I am
a big fan.

Cheers,
Mabrouk

On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax <forax at univ-mlv.fr> wrote:
> No, it's more an AWRY or Java2D bug.
>
> R?mi
>
> Sent from my Phone
>
>
> ----- Reply message -----
> From: "Ben Evans" <benjamin.john.evans at gmail.com>
> To: "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
> Cc: "R?mi Forax" <forax at univ-mlv.fr>, <concurrency-interest at cs.oswego.edu>
> Subject: [concurrency-interest] Joint Talk for JavaOne?
> Date: Sat, Apr 7, 2012 10:43
>
>
> Heinz, was this with the new jdk8 + lambda build?
>
> If so, we should report this crash back to lambda-dev.
>
> Thanks,
>
> Ben
>
> On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
> <heinz at javaspecialists.eu> wrote:
>> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6. ?I see
>> that
>> the Java2Demo has been removed from the demos folder of JDK 1.7 and 1.8.
>> ?It
>> thus is a Java 8 issue, rather than the changes I made to the code.
>> ?Thanks
>> for the warning R?mi.
>>
>>
>> Regards
>>
>> Heinz
>> --
>> Dr Heinz M. Kabutz (PhD CompSci)
>> Author of "The Java(tm) Specialists' Newsletter"
>> Sun Java Champion
>> IEEE Certified Software Development Professional
>> http://www.javaspecialists.eu
>> Tel: +30 69 75 595 262
>> Skype: kabutz
>>
>>
>> On 4/6/12 1:51 AM, R?mi Forax wrote:
>>>
>>> jdk8 crashes if I click on images of the tapped pane.
>>>
>>> R?mi
>>>
>>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
>>>>
>>>> Yes, you are correct.
>>>>
>>>> However, the mistake most programmers make is to #1 scratch around in
>>>> the
>>>> source code to try and discover the problem and #2 then fix it without
>>>> really understanding what they are doing. ?I think the lesson is bigger
>>>> if
>>>> we give them the source code. ?In addition, it is probably more
>>>> difficult to
>>>> solve if you have the sources to muse over.
>>>> Regards
>>>>
>>>> Heinz
>>>> --
>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>> Sun Java Champion
>>>> IEEE Certified Software Development Professional
>>>> http://www.javaspecialists.eu
>>>> Tel: +30 69 75 595 262
>>>> Skype: kabutz
>>>>
>>>>
>>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>>>>>
>>>>> I guess it is a good idea to not initially include the source code in
>>>>> the workshop because many times I initially don't have the source code
>>>>> when
>>>>> trying to figure out performance or scalability problems.
>>>>>
>>>>> Nathan Reynolds
>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>> Consulting
>>>>> Member of Technical Staff | 602.333.9091
>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>>>
>>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>>>>>>
>>>>>> Sorry Nathan, here is the zip file including the source code an an Ant
>>>>>> script to build the code. ?Sorry for accidentally excluding that from
>>>>>> the
>>>>>> file I sent earlier. ?The problem was between the chair and the
>>>>>> keyboard.
>>>>>> ?However, one should be able to pinpoint the deadlock without seeing a
>>>>>> line
>>>>>> of code. ?At the workshop I presented in Spain last week, most of the
>>>>>> programmers immediately started delving into the code before they knew
>>>>>> where
>>>>>> to look.
>>>>>> Regards
>>>>>>
>>>>>> Heinz
>>>>>> --
>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>> Sun Java Champion
>>>>>> IEEE Certified Software Development Professional
>>>>>> http://www.javaspecialists.eu
>>>>>> Tel: +30 69 75 595 262
>>>>>> Skype: kabutz
>>>>>>
>>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>>>>>>>
>>>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3. ?It
>>>>>>> didn't deadlock for a minute or two. ?Then the application froze. ?I
>>>>>>> then
>>>>>>> used jstack to dump the call stacks. ?At the end of the report, it
>>>>>>> said
>>>>>>> "Found one Java-level deadlock". ?It then dumped out the locks and
>>>>>>> threads
>>>>>>> involved in the deadlock. ?I never looked at the source code... in
>>>>>>> fact it
>>>>>>> wasn't in the zip file. ?This took about 5-7 minutes from starting
>>>>>>> the
>>>>>>> application to finding the deadlock in the call stacks.
>>>>>>>
>>>>>>> A 100 good Java developers? ?Really? ?I guess I can understand. ?Most
>>>>>>> engineers don't understand locks. ?Most of the time I get answers
>>>>>>> like one
>>>>>>> should put a lock around shared variables. ?This is accurate but they
>>>>>>> can't
>>>>>>> really go any deeper.
>>>>>>>
>>>>>>> It sounds like the material of your presentation should be very good.
>>>>>>> ?It covers things that the deadlock detection tool probably can't
>>>>>>> figure
>>>>>>> out.
>>>>>>>
>>>>>>> So, it seems like you have everything figured out. ?Why do you need
>>>>>>> someone else?
>>>>>>>
>>>>>>> Nathan Reynolds
>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>>> Consulting
>>>>>>> Member of Technical Staff | 602.333.9091
>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>>>>> Technology
>>>>>>>
>>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>>>>>>>
>>>>>>>> Hi Nathan,
>>>>>>>>
>>>>>>>> a stack trace will only show you a certain class of obvious
>>>>>>>> deadlocks
>>>>>>>> that are easy to find and solve. ?I remember solving deadlocks
>>>>>>>> /before/ we
>>>>>>>> had the brilliant deadlock detection tool in the ThreadMXBean. ?Yes,
>>>>>>>> the
>>>>>>>> deadlock detection tool shows you /some/ deadlocks, but definitely
>>>>>>>> not all
>>>>>>>> of them. ?I can think of a bunch that it would not find:
>>>>>>>>
>>>>>>>> 1. Semaphores running out of permits
>>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>>>>>>>> 3. Resource deadlocks
>>>>>>>>
>>>>>>>> And some others that I will not describe in detail, such as some
>>>>>>>> nasty livelocks that we can cause which will hang up the JVM :-)
>>>>>>>>
>>>>>>>> I agree with Kirk - it should probably be a 3 hour workshop. ?I've
>>>>>>>> done this three times now - twice in Spain and once via webinar.
>>>>>>>> ?The
>>>>>>>> workshop would involve some lessons on deadlocks, what causes them
>>>>>>>> and how
>>>>>>>> we can prevent them. ?Also an explanation as to why we see them so
>>>>>>>> seldom in
>>>>>>>> real production. ?I've got material prepared for this workshop. ?And
>>>>>>>> then a
>>>>>>>> practical part to the workshop where they can try to find a deadlock
>>>>>>>> in a
>>>>>>>> body of code.
>>>>>>>>
>>>>>>>> Attached is an example of the workshop. ?You can try find the
>>>>>>>> deadlock if you like. ?I've shown it to almost 100 good Java
>>>>>>>> developers and
>>>>>>>> so far, not one has found it by themselves. ?I would expect that
>>>>>>>> they should
>>>>>>>> find it in 5 minutes. ?In our workshop they would obviously be
>>>>>>>> helped a bit
>>>>>>>> with hints, so that they can walk away with a good experience. ?Use
>>>>>>>> anything
>>>>>>>> you like. ?Oscilloscope, jstack, jconsole, whatever you like. ?Only
>>>>>>>> rule for
>>>>>>>> you guys on the "concurrency-interest" list is: you can only look at
>>>>>>>> the
>>>>>>>> code once you've found the problem, otherwise it would be too easy
>>>>>>>> for you
>>>>>>>> :-) ?Once you have found it, you can also fix the code and make sure
>>>>>>>> that
>>>>>>>> the code then works correctly.
>>>>>>>> Regards
>>>>>>>>
>>>>>>>> Heinz
>>>>>>>> --
>>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>>>> Sun Java Champion
>>>>>>>> IEEE Certified Software Development Professional
>>>>>>>> http://www.javaspecialists.eu
>>>>>>>> Tel: +30 69 75 595 262
>>>>>>>> Skype: kabutz
>>>>>>>>
>>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>>>>>>>
>>>>>>>>> I am curious as to the intended content of your presentation.
>>>>>>>>> ?Here's some ideas. ?I wondering what you are planing on doing.
>>>>>>>>>
>>>>>>>>> ?1. Printing the call stacks with lock information using a tool
>>>>>>>>> ? ?such as jstack
>>>>>>>>> ?2. Press the "Detect Deadlock" button in JConsole
>>>>>>>>> ?3. Dealing with Lock and Condition objects instead of
>>>>>>>>> ? ?synchronized blocks
>>>>>>>>> ?4. Detecting live lock
>>>>>>>>> ?5. Distributed deadlocks
>>>>>>>>>
>>>>>>>>> Nathan Reynolds
>>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>>>>> Consulting
>>>>>>>>> Member of Technical Staff | 602.333.9091
>>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>>>>>>> Technology
>>>>>>>>>
>>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>>>>>>>>
>>>>>>>>>> Good afternoon,
>>>>>>>>>>
>>>>>>>>>> I am thinking of submitting a talk on finding and diagnosing
>>>>>>>>>> deadlocks for JavaOne. ?It might be a workshop, instead of a
>>>>>>>>>> simple
>>>>>>>>>> conference talk. ?Or we might be able to turn the talk into a
>>>>>>>>>> workshop where
>>>>>>>>>> they need to find a deadlock in a body of code. ?Could be
>>>>>>>>>> something
>>>>>>>>>> different, which might go incredibly well or crash in a blaze of
>>>>>>>>>> flames.
>>>>>>>>>> ?Would any of you be interested in co-presenting this with me at
>>>>>>>>>> JavaOne?
>>>>>>>>>>
>>>>>>>>>> Regards
>>>>>>>>>>
>>>>>>>>>> Heinz
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From radhakrishnan.mohan at gmail.com  Sun Apr  8 23:23:28 2012
From: radhakrishnan.mohan at gmail.com (Mohan Radhakrishnan)
Date: Mon, 9 Apr 2012 08:53:28 +0530
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>
	<CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>
Message-ID: <CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>

I could look at the first deadlock by dumping locks and threads. I was
planning to find the next one using Java Path Finder but I think it is not
recommended for such a big codebase. I am not sure. Its heuristics might
take too much memory.

Mohan

On Mon, Apr 9, 2012 at 3:59 AM, <mabrouk2005 at gmail.com> wrote:

> Nice exercise Dr Heinz,
>
> As others mentioned there were 2 kind of deadlocks the first one was
> very is easy to find via jconsole so likeI thought that was it and
> went and fixed that but then when ran it again it hang it so I knew
> thee was more. the interesting thing the jconsole did not detect the
> AWT deadlock it showed no deadlock even though the app hang. I had to
> force stack dump and get clues to where is the deadlock. Does anyone
> have experienced something like this with jconsole not detecting AWT
> deadlocks?
>
> Thanks again for the nice exercise and the great java news letter I am
> a big fan.
>
> Cheers,
> Mabrouk
>
> On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax <forax at univ-mlv.fr> wrote:
> > No, it's more an AWRY or Java2D bug.
> >
> > R?mi
> >
> > Sent from my Phone
> >
> >
> > ----- Reply message -----
> > From: "Ben Evans" <benjamin.john.evans at gmail.com>
> > To: "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
> > Cc: "R?mi Forax" <forax at univ-mlv.fr>, <
> concurrency-interest at cs.oswego.edu>
> > Subject: [concurrency-interest] Joint Talk for JavaOne?
> > Date: Sat, Apr 7, 2012 10:43
> >
> >
> > Heinz, was this with the new jdk8 + lambda build?
> >
> > If so, we should report this crash back to lambda-dev.
> >
> > Thanks,
> >
> > Ben
> >
> > On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
> > <heinz at javaspecialists.eu> wrote:
> >> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6.  I see
> >> that
> >> the Java2Demo has been removed from the demos folder of JDK 1.7 and 1.8.
> >>  It
> >> thus is a Java 8 issue, rather than the changes I made to the code.
> >>  Thanks
> >> for the warning R?mi.
> >>
> >>
> >> Regards
> >>
> >> Heinz
> >> --
> >> Dr Heinz M. Kabutz (PhD CompSci)
> >> Author of "The Java(tm) Specialists' Newsletter"
> >> Sun Java Champion
> >> IEEE Certified Software Development Professional
> >> http://www.javaspecialists.eu
> >> Tel: +30 69 75 595 262
> >> Skype: kabutz
> >>
> >>
> >> On 4/6/12 1:51 AM, R?mi Forax wrote:
> >>>
> >>> jdk8 crashes if I click on images of the tapped pane.
> >>>
> >>> R?mi
> >>>
> >>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
> >>>>
> >>>> Yes, you are correct.
> >>>>
> >>>> However, the mistake most programmers make is to #1 scratch around in
> >>>> the
> >>>> source code to try and discover the problem and #2 then fix it without
> >>>> really understanding what they are doing.  I think the lesson is
> bigger
> >>>> if
> >>>> we give them the source code.  In addition, it is probably more
> >>>> difficult to
> >>>> solve if you have the sources to muse over.
> >>>> Regards
> >>>>
> >>>> Heinz
> >>>> --
> >>>> Dr Heinz M. Kabutz (PhD CompSci)
> >>>> Author of "The Java(tm) Specialists' Newsletter"
> >>>> Sun Java Champion
> >>>> IEEE Certified Software Development Professional
> >>>> http://www.javaspecialists.eu
> >>>> Tel: +30 69 75 595 262
> >>>> Skype: kabutz
> >>>>
> >>>>
> >>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
> >>>>>
> >>>>> I guess it is a good idea to not initially include the source code in
> >>>>> the workshop because many times I initially don't have the source
> code
> >>>>> when
> >>>>> trying to figure out performance or scalability problems.
> >>>>>
> >>>>> Nathan Reynolds
> >>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> >>>>> Consulting
> >>>>> Member of Technical Staff | 602.333.9091
> >>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
> Technology
> >>>>>
> >>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
> >>>>>>
> >>>>>> Sorry Nathan, here is the zip file including the source code an an
> Ant
> >>>>>> script to build the code.  Sorry for accidentally excluding that
> from
> >>>>>> the
> >>>>>> file I sent earlier.  The problem was between the chair and the
> >>>>>> keyboard.
> >>>>>>  However, one should be able to pinpoint the deadlock without
> seeing a
> >>>>>> line
> >>>>>> of code.  At the workshop I presented in Spain last week, most of
> the
> >>>>>> programmers immediately started delving into the code before they
> knew
> >>>>>> where
> >>>>>> to look.
> >>>>>> Regards
> >>>>>>
> >>>>>> Heinz
> >>>>>> --
> >>>>>> Dr Heinz M. Kabutz (PhD CompSci)
> >>>>>> Author of "The Java(tm) Specialists' Newsletter"
> >>>>>> Sun Java Champion
> >>>>>> IEEE Certified Software Development Professional
> >>>>>> http://www.javaspecialists.eu
> >>>>>> Tel: +30 69 75 595 262
> >>>>>> Skype: kabutz
> >>>>>>
> >>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
> >>>>>>>
> >>>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3.  It
> >>>>>>> didn't deadlock for a minute or two.  Then the application froze.
>  I
> >>>>>>> then
> >>>>>>> used jstack to dump the call stacks.  At the end of the report, it
> >>>>>>> said
> >>>>>>> "Found one Java-level deadlock".  It then dumped out the locks and
> >>>>>>> threads
> >>>>>>> involved in the deadlock.  I never looked at the source code... in
> >>>>>>> fact it
> >>>>>>> wasn't in the zip file.  This took about 5-7 minutes from starting
> >>>>>>> the
> >>>>>>> application to finding the deadlock in the call stacks.
> >>>>>>>
> >>>>>>> A 100 good Java developers?  Really?  I guess I can understand.
>  Most
> >>>>>>> engineers don't understand locks.  Most of the time I get answers
> >>>>>>> like one
> >>>>>>> should put a lock around shared variables.  This is accurate but
> they
> >>>>>>> can't
> >>>>>>> really go any deeper.
> >>>>>>>
> >>>>>>> It sounds like the material of your presentation should be very
> good.
> >>>>>>>  It covers things that the deadlock detection tool probably can't
> >>>>>>> figure
> >>>>>>> out.
> >>>>>>>
> >>>>>>> So, it seems like you have everything figured out.  Why do you need
> >>>>>>> someone else?
> >>>>>>>
> >>>>>>> Nathan Reynolds
> >>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> >>>>>>> Consulting
> >>>>>>> Member of Technical Staff | 602.333.9091
> >>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
> >>>>>>> Technology
> >>>>>>>
> >>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
> >>>>>>>>
> >>>>>>>> Hi Nathan,
> >>>>>>>>
> >>>>>>>> a stack trace will only show you a certain class of obvious
> >>>>>>>> deadlocks
> >>>>>>>> that are easy to find and solve.  I remember solving deadlocks
> >>>>>>>> /before/ we
> >>>>>>>> had the brilliant deadlock detection tool in the ThreadMXBean.
>  Yes,
> >>>>>>>> the
> >>>>>>>> deadlock detection tool shows you /some/ deadlocks, but definitely
> >>>>>>>> not all
> >>>>>>>> of them.  I can think of a bunch that it would not find:
> >>>>>>>>
> >>>>>>>> 1. Semaphores running out of permits
> >>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
> >>>>>>>> 3. Resource deadlocks
> >>>>>>>>
> >>>>>>>> And some others that I will not describe in detail, such as some
> >>>>>>>> nasty livelocks that we can cause which will hang up the JVM :-)
> >>>>>>>>
> >>>>>>>> I agree with Kirk - it should probably be a 3 hour workshop.  I've
> >>>>>>>> done this three times now - twice in Spain and once via webinar.
> >>>>>>>>  The
> >>>>>>>> workshop would involve some lessons on deadlocks, what causes them
> >>>>>>>> and how
> >>>>>>>> we can prevent them.  Also an explanation as to why we see them so
> >>>>>>>> seldom in
> >>>>>>>> real production.  I've got material prepared for this workshop.
>  And
> >>>>>>>> then a
> >>>>>>>> practical part to the workshop where they can try to find a
> deadlock
> >>>>>>>> in a
> >>>>>>>> body of code.
> >>>>>>>>
> >>>>>>>> Attached is an example of the workshop.  You can try find the
> >>>>>>>> deadlock if you like.  I've shown it to almost 100 good Java
> >>>>>>>> developers and
> >>>>>>>> so far, not one has found it by themselves.  I would expect that
> >>>>>>>> they should
> >>>>>>>> find it in 5 minutes.  In our workshop they would obviously be
> >>>>>>>> helped a bit
> >>>>>>>> with hints, so that they can walk away with a good experience.
>  Use
> >>>>>>>> anything
> >>>>>>>> you like.  Oscilloscope, jstack, jconsole, whatever you like.
>  Only
> >>>>>>>> rule for
> >>>>>>>> you guys on the "concurrency-interest" list is: you can only look
> at
> >>>>>>>> the
> >>>>>>>> code once you've found the problem, otherwise it would be too easy
> >>>>>>>> for you
> >>>>>>>> :-)  Once you have found it, you can also fix the code and make
> sure
> >>>>>>>> that
> >>>>>>>> the code then works correctly.
> >>>>>>>> Regards
> >>>>>>>>
> >>>>>>>> Heinz
> >>>>>>>> --
> >>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
> >>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
> >>>>>>>> Sun Java Champion
> >>>>>>>> IEEE Certified Software Development Professional
> >>>>>>>> http://www.javaspecialists.eu
> >>>>>>>> Tel: +30 69 75 595 262
> >>>>>>>> Skype: kabutz
> >>>>>>>>
> >>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
> >>>>>>>>>
> >>>>>>>>> I am curious as to the intended content of your presentation.
> >>>>>>>>>  Here's some ideas.  I wondering what you are planing on doing.
> >>>>>>>>>
> >>>>>>>>>  1. Printing the call stacks with lock information using a tool
> >>>>>>>>>    such as jstack
> >>>>>>>>>  2. Press the "Detect Deadlock" button in JConsole
> >>>>>>>>>  3. Dealing with Lock and Condition objects instead of
> >>>>>>>>>    synchronized blocks
> >>>>>>>>>  4. Detecting live lock
> >>>>>>>>>  5. Distributed deadlocks
> >>>>>>>>>
> >>>>>>>>> Nathan Reynolds
> >>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> >>>>>>>>> Consulting
> >>>>>>>>> Member of Technical Staff | 602.333.9091
> >>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
> >>>>>>>>> Technology
> >>>>>>>>>
> >>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
> >>>>>>>>>>
> >>>>>>>>>> Good afternoon,
> >>>>>>>>>>
> >>>>>>>>>> I am thinking of submitting a talk on finding and diagnosing
> >>>>>>>>>> deadlocks for JavaOne.  It might be a workshop, instead of a
> >>>>>>>>>> simple
> >>>>>>>>>> conference talk.  Or we might be able to turn the talk into a
> >>>>>>>>>> workshop where
> >>>>>>>>>> they need to find a deadlock in a body of code.  Could be
> >>>>>>>>>> something
> >>>>>>>>>> different, which might go incredibly well or crash in a blaze of
> >>>>>>>>>> flames.
> >>>>>>>>>>  Would any of you be interested in co-presenting this with me at
> >>>>>>>>>> JavaOne?
> >>>>>>>>>>
> >>>>>>>>>> Regards
> >>>>>>>>>>
> >>>>>>>>>> Heinz
> >>>>
> >>>>
> >>>>
> >>>> _______________________________________________
> >>>> Concurrency-interest mailing list
> >>>> Concurrency-interest at cs.oswego.edu
> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>
> >>>
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120409/49733350/attachment-0001.html>

From heinz at javaspecialists.eu  Mon Apr  9 02:04:03 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Mon, 09 Apr 2012 09:04:03 +0300
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>
	<CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>
Message-ID: <4F827BD3.30808@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120409/3b4b86d5/attachment.html>

From heinz at javaspecialists.eu  Mon Apr  9 02:08:39 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Mon, 09 Apr 2012 09:08:39 +0300
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>	<CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>
	<CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>
Message-ID: <4F827CE7.1020101@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120409/fd0de75a/attachment-0001.html>

From william.louth at jinspired.com  Mon Apr  9 02:45:41 2012
From: william.louth at jinspired.com (William Louth (JINSPIRED.COM))
Date: Mon, 09 Apr 2012 08:45:41 +0200
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F827CE7.1020101@javaspecialists.eu>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>	<CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>
	<CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>
	<4F827CE7.1020101@javaspecialists.eu>
Message-ID: <4F828595.4000600@jinspired.com>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120409/3c1dbbf1/attachment-0001.html>

From kirk at kodewerk.com  Mon Apr  9 04:17:25 2012
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Mon, 9 Apr 2012 10:17:25 +0200
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F828595.4000600@jinspired.com>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>	<CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>
	<CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>
	<4F827CE7.1020101@javaspecialists.eu>
	<4F828595.4000600@jinspired.com>
Message-ID: <E743036F-0DED-41A0-ACB7-79DC31D3D965@kodewerk.com>

Hi William,

I'm on the core track committee and I vote based on 1) content (based on the strength of the abstract and supporting materials), 2) the % of informercial content (lower is better IMHO) 3) my feeling on the speakers ability to deliver. Heinz's doesn't get a pass because he's a very good friend. He'll get's my vote based on the criteria laid out. But since I've seen many of Heinz's talks I know that he'll pass on points 2 and 3 and I doubt he'll fail on point 1. The risk is, he's going for a hands on lab and from my experience in the past, he's going to need an extra helping hand from inside Oracle to get that approved. So, if you've a talk to submit, submit it and I promise it will be evaluated on it's merits. But do remember, there are a large number of fantastic abstracts on the cutting room floor just because our slot allocated wasn't enough to take them all.

Kirk

On 2012-04-09, at 8:45 AM, William Louth (JINSPIRED.COM) wrote:

> I'd much prefer a session that discussed ways to automatically detect such issues before they happened (at development and more importantly in production) as well as runtime mechanisms (control/scheduling actions) at such point to avoid them...I don't know anyone that wants to find such issues in production when they only course of action is too simply kill the process (though the cloud or other more fault "tolerant" software makes this slightly less discomforting for some assume no residue following on). In terms of avoidance I am assuming that the developer can't simply rewrite everything from scratch to be align to some form of packet messaging.
> 
> btw the way does the JavaOne conf still have rules on canvasing amongst those involved in the selection of talks?
> 
> On 09/04/2012 08:08, Dr Heinz M. Kabutz wrote:
>> 
>> 15.000 lines is a tiny code base.  The problem is very easy to solve once you get past the initial red herring.  It took Nathan Reynolds two minutes to discover and fix it.  If you look at the stack traces, there is only one possible place it could be and the stack trace takes you straight to the class and line number where the problem is.
>> 
>> That said, I would be very interested to see if there are any tools that could discover this deadlock statically or dynamically.
>> Regards
>> 
>> Heinz
>> -- 
>> Dr Heinz M. Kabutz (PhD CompSci)
>> Author of "The Java(tm) Specialists' Newsletter"
>> Sun Java Champion
>> IEEE Certified Software Development Professional
>> http://www.javaspecialists.eu
>> Tel: +30 69 75 595 262
>> Skype: kabutz 
>> 
>> 
>> On 4/9/12 6:23 AM, Mohan Radhakrishnan wrote:
>>> 
>>> I could look at the first deadlock by dumping locks and threads. I was planning to find the next one using Java Path Finder but I think it is not recommended for such a big codebase. I am not sure. Its heuristics might take too much memory.
>>> 
>>> Mohan
>>> 
>>> On Mon, Apr 9, 2012 at 3:59 AM, <mabrouk2005 at gmail.com> wrote:
>>> Nice exercise Dr Heinz,
>>> 
>>> As others mentioned there were 2 kind of deadlocks the first one was
>>> very is easy to find via jconsole so likeI thought that was it and
>>> went and fixed that but then when ran it again it hang it so I knew
>>> thee was more. the interesting thing the jconsole did not detect the
>>> AWT deadlock it showed no deadlock even though the app hang. I had to
>>> force stack dump and get clues to where is the deadlock. Does anyone
>>> have experienced something like this with jconsole not detecting AWT
>>> deadlocks?
>>> 
>>> Thanks again for the nice exercise and the great java news letter I am
>>> a big fan.
>>> 
>>> Cheers,
>>> Mabrouk
>>> 
>>> On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax <forax at univ-mlv.fr> wrote:
>>> > No, it's more an AWRY or Java2D bug.
>>> >
>>> > R?mi
>>> >
>>> > Sent from my Phone
>>> >
>>> >
>>> > ----- Reply message -----
>>> > From: "Ben Evans" <benjamin.john.evans at gmail.com>
>>> > To: "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
>>> > Cc: "R?mi Forax" <forax at univ-mlv.fr>, <concurrency-interest at cs.oswego.edu>
>>> > Subject: [concurrency-interest] Joint Talk for JavaOne?
>>> > Date: Sat, Apr 7, 2012 10:43
>>> >
>>> >
>>> > Heinz, was this with the new jdk8 + lambda build?
>>> >
>>> > If so, we should report this crash back to lambda-dev.
>>> >
>>> > Thanks,
>>> >
>>> > Ben
>>> >
>>> > On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
>>> > <heinz at javaspecialists.eu> wrote:
>>> >> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6.  I see
>>> >> that
>>> >> the Java2Demo has been removed from the demos folder of JDK 1.7 and 1.8.
>>> >>  It
>>> >> thus is a Java 8 issue, rather than the changes I made to the code.
>>> >>  Thanks
>>> >> for the warning R?mi.
>>> >>
>>> >>
>>> >> Regards
>>> >>
>>> >> Heinz
>>> >> --
>>> >> Dr Heinz M. Kabutz (PhD CompSci)
>>> >> Author of "The Java(tm) Specialists' Newsletter"
>>> >> Sun Java Champion
>>> >> IEEE Certified Software Development Professional
>>> >> http://www.javaspecialists.eu
>>> >> Tel: +30 69 75 595 262
>>> >> Skype: kabutz
>>> >>
>>> >>
>>> >> On 4/6/12 1:51 AM, R?mi Forax wrote:
>>> >>>
>>> >>> jdk8 crashes if I click on images of the tapped pane.
>>> >>>
>>> >>> R?mi
>>> >>>
>>> >>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
>>> >>>>
>>> >>>> Yes, you are correct.
>>> >>>>
>>> >>>> However, the mistake most programmers make is to #1 scratch around in
>>> >>>> the
>>> >>>> source code to try and discover the problem and #2 then fix it without
>>> >>>> really understanding what they are doing.  I think the lesson is bigger
>>> >>>> if
>>> >>>> we give them the source code.  In addition, it is probably more
>>> >>>> difficult to
>>> >>>> solve if you have the sources to muse over.
>>> >>>> Regards
>>> >>>>
>>> >>>> Heinz
>>> >>>> --
>>> >>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> >>>> Author of "The Java(tm) Specialists' Newsletter"
>>> >>>> Sun Java Champion
>>> >>>> IEEE Certified Software Development Professional
>>> >>>> http://www.javaspecialists.eu
>>> >>>> Tel: +30 69 75 595 262
>>> >>>> Skype: kabutz
>>> >>>>
>>> >>>>
>>> >>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>>> >>>>>
>>> >>>>> I guess it is a good idea to not initially include the source code in
>>> >>>>> the workshop because many times I initially don't have the source code
>>> >>>>> when
>>> >>>>> trying to figure out performance or scalability problems.
>>> >>>>>
>>> >>>>> Nathan Reynolds
>>> >>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>> >>>>> Consulting
>>> >>>>> Member of Technical Staff | 602.333.9091
>>> >>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>> >>>>>
>>> >>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>>> >>>>>>
>>> >>>>>> Sorry Nathan, here is the zip file including the source code an an Ant
>>> >>>>>> script to build the code.  Sorry for accidentally excluding that from
>>> >>>>>> the
>>> >>>>>> file I sent earlier.  The problem was between the chair and the
>>> >>>>>> keyboard.
>>> >>>>>>  However, one should be able to pinpoint the deadlock without seeing a
>>> >>>>>> line
>>> >>>>>> of code.  At the workshop I presented in Spain last week, most of the
>>> >>>>>> programmers immediately started delving into the code before they knew
>>> >>>>>> where
>>> >>>>>> to look.
>>> >>>>>> Regards
>>> >>>>>>
>>> >>>>>> Heinz
>>> >>>>>> --
>>> >>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> >>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>> >>>>>> Sun Java Champion
>>> >>>>>> IEEE Certified Software Development Professional
>>> >>>>>> http://www.javaspecialists.eu
>>> >>>>>> Tel: +30 69 75 595 262
>>> >>>>>> Skype: kabutz
>>> >>>>>>
>>> >>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>>> >>>>>>>
>>> >>>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3.  It
>>> >>>>>>> didn't deadlock for a minute or two.  Then the application froze.  I
>>> >>>>>>> then
>>> >>>>>>> used jstack to dump the call stacks.  At the end of the report, it
>>> >>>>>>> said
>>> >>>>>>> "Found one Java-level deadlock".  It then dumped out the locks and
>>> >>>>>>> threads
>>> >>>>>>> involved in the deadlock.  I never looked at the source code... in
>>> >>>>>>> fact it
>>> >>>>>>> wasn't in the zip file.  This took about 5-7 minutes from starting
>>> >>>>>>> the
>>> >>>>>>> application to finding the deadlock in the call stacks.
>>> >>>>>>>
>>> >>>>>>> A 100 good Java developers?  Really?  I guess I can understand.  Most
>>> >>>>>>> engineers don't understand locks.  Most of the time I get answers
>>> >>>>>>> like one
>>> >>>>>>> should put a lock around shared variables.  This is accurate but they
>>> >>>>>>> can't
>>> >>>>>>> really go any deeper.
>>> >>>>>>>
>>> >>>>>>> It sounds like the material of your presentation should be very good.
>>> >>>>>>>  It covers things that the deadlock detection tool probably can't
>>> >>>>>>> figure
>>> >>>>>>> out.
>>> >>>>>>>
>>> >>>>>>> So, it seems like you have everything figured out.  Why do you need
>>> >>>>>>> someone else?
>>> >>>>>>>
>>> >>>>>>> Nathan Reynolds
>>> >>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>> >>>>>>> Consulting
>>> >>>>>>> Member of Technical Staff | 602.333.9091
>>> >>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>> >>>>>>> Technology
>>> >>>>>>>
>>> >>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>> >>>>>>>>
>>> >>>>>>>> Hi Nathan,
>>> >>>>>>>>
>>> >>>>>>>> a stack trace will only show you a certain class of obvious
>>> >>>>>>>> deadlocks
>>> >>>>>>>> that are easy to find and solve.  I remember solving deadlocks
>>> >>>>>>>> /before/ we
>>> >>>>>>>> had the brilliant deadlock detection tool in the ThreadMXBean.  Yes,
>>> >>>>>>>> the
>>> >>>>>>>> deadlock detection tool shows you /some/ deadlocks, but definitely
>>> >>>>>>>> not all
>>> >>>>>>>> of them.  I can think of a bunch that it would not find:
>>> >>>>>>>>
>>> >>>>>>>> 1. Semaphores running out of permits
>>> >>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>>> >>>>>>>> 3. Resource deadlocks
>>> >>>>>>>>
>>> >>>>>>>> And some others that I will not describe in detail, such as some
>>> >>>>>>>> nasty livelocks that we can cause which will hang up the JVM :-)
>>> >>>>>>>>
>>> >>>>>>>> I agree with Kirk - it should probably be a 3 hour workshop.  I've
>>> >>>>>>>> done this three times now - twice in Spain and once via webinar.
>>> >>>>>>>>  The
>>> >>>>>>>> workshop would involve some lessons on deadlocks, what causes them
>>> >>>>>>>> and how
>>> >>>>>>>> we can prevent them.  Also an explanation as to why we see them so
>>> >>>>>>>> seldom in
>>> >>>>>>>> real production.  I've got material prepared for this workshop.  And
>>> >>>>>>>> then a
>>> >>>>>>>> practical part to the workshop where they can try to find a deadlock
>>> >>>>>>>> in a
>>> >>>>>>>> body of code.
>>> >>>>>>>>
>>> >>>>>>>> Attached is an example of the workshop.  You can try find the
>>> >>>>>>>> deadlock if you like.  I've shown it to almost 100 good Java
>>> >>>>>>>> developers and
>>> >>>>>>>> so far, not one has found it by themselves.  I would expect that
>>> >>>>>>>> they should
>>> >>>>>>>> find it in 5 minutes.  In our workshop they would obviously be
>>> >>>>>>>> helped a bit
>>> >>>>>>>> with hints, so that they can walk away with a good experience.  Use
>>> >>>>>>>> anything
>>> >>>>>>>> you like.  Oscilloscope, jstack, jconsole, whatever you like.  Only
>>> >>>>>>>> rule for
>>> >>>>>>>> you guys on the "concurrency-interest" list is: you can only look at
>>> >>>>>>>> the
>>> >>>>>>>> code once you've found the problem, otherwise it would be too easy
>>> >>>>>>>> for you
>>> >>>>>>>> :-)  Once you have found it, you can also fix the code and make sure
>>> >>>>>>>> that
>>> >>>>>>>> the code then works correctly.
>>> >>>>>>>> Regards
>>> >>>>>>>>
>>> >>>>>>>> Heinz
>>> >>>>>>>> --
>>> >>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> >>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>> >>>>>>>> Sun Java Champion
>>> >>>>>>>> IEEE Certified Software Development Professional
>>> >>>>>>>> http://www.javaspecialists.eu
>>> >>>>>>>> Tel: +30 69 75 595 262
>>> >>>>>>>> Skype: kabutz
>>> >>>>>>>>
>>> >>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>> >>>>>>>>>
>>> >>>>>>>>> I am curious as to the intended content of your presentation.
>>> >>>>>>>>>  Here's some ideas.  I wondering what you are planing on doing.
>>> >>>>>>>>>
>>> >>>>>>>>>  1. Printing the call stacks with lock information using a tool
>>> >>>>>>>>>    such as jstack
>>> >>>>>>>>>  2. Press the "Detect Deadlock" button in JConsole
>>> >>>>>>>>>  3. Dealing with Lock and Condition objects instead of
>>> >>>>>>>>>    synchronized blocks
>>> >>>>>>>>>  4. Detecting live lock
>>> >>>>>>>>>  5. Distributed deadlocks
>>> >>>>>>>>>
>>> >>>>>>>>> Nathan Reynolds
>>> >>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>> >>>>>>>>> Consulting
>>> >>>>>>>>> Member of Technical Staff | 602.333.9091
>>> >>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>> >>>>>>>>> Technology
>>> >>>>>>>>>
>>> >>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>> >>>>>>>>>>
>>> >>>>>>>>>> Good afternoon,
>>> >>>>>>>>>>
>>> >>>>>>>>>> I am thinking of submitting a talk on finding and diagnosing
>>> >>>>>>>>>> deadlocks for JavaOne.  It might be a workshop, instead of a
>>> >>>>>>>>>> simple
>>> >>>>>>>>>> conference talk.  Or we might be able to turn the talk into a
>>> >>>>>>>>>> workshop where
>>> >>>>>>>>>> they need to find a deadlock in a body of code.  Could be
>>> >>>>>>>>>> something
>>> >>>>>>>>>> different, which might go incredibly well or crash in a blaze of
>>> >>>>>>>>>> flames.
>>> >>>>>>>>>>  Would any of you be interested in co-presenting this with me at
>>> >>>>>>>>>> JavaOne?
>>> >>>>>>>>>>
>>> >>>>>>>>>> Regards
>>> >>>>>>>>>>
>>> >>>>>>>>>> Heinz
>>> >>>>
>>> >>>>
>>> >>>>
>>> >>>> _______________________________________________
>>> >>>> Concurrency-interest mailing list
>>> >>>> Concurrency-interest at cs.oswego.edu
>>> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >>>
>>> >>>
>>> >>> _______________________________________________
>>> >>> Concurrency-interest mailing list
>>> >>> Concurrency-interest at cs.oswego.edu
>>> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >>>
>>> >> _______________________________________________
>>> >> Concurrency-interest mailing list
>>> >> Concurrency-interest at cs.oswego.edu
>>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> 
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>   
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120409/d2d493df/attachment-0001.html>

From imavroukakis at gmail.com  Mon Apr  9 07:24:05 2012
From: imavroukakis at gmail.com (Ioannis Mavroukakis)
Date: Mon, 9 Apr 2012 12:24:05 +0100
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <E743036F-0DED-41A0-ACB7-79DC31D3D965@kodewerk.com>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>
	<CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>
	<CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>
	<4F827CE7.1020101@javaspecialists.eu> <4F828595.4000600@jinspired.com>
	<E743036F-0DED-41A0-ACB7-79DC31D3D965@kodewerk.com>
Message-ID: <CAMroGZr6byAOQZi++0j6JYXCSnPsuVOiTHY2jpbU-fFB05ikdg@mail.gmail.com>

Hello everyone,



Although I will not be attending JavaOne, I would like to offer my opinion.
Automatic detection is a nice to have but I believe that as a  developer, I
would like to be educated in the "eyball" ways that exist to detect an
issue. Although one would argue (and I believe strongly in that) in
"prevent, don't cure" , brown runny stuff happens and something will creep
past you. In that instance, such a workshop by Dr Kabutz would be of high
educational value.



Cheers,

Ioannis

On 9 April 2012 09:17, Kirk Pepperdine <kirk at kodewerk.com> wrote:

> Hi William,
>
> I'm on the core track committee and I vote based on 1) content (based on
> the strength of the abstract and supporting materials), 2) the % of
> informercial content (lower is better IMHO) 3) my feeling on the speakers
> ability to deliver. Heinz's doesn't get a pass because he's a very good
> friend. He'll get's my vote based on the criteria laid out. But since I've
> seen many of Heinz's talks I know that he'll pass on points 2 and 3 and I
> doubt he'll fail on point 1. The risk is, he's going for a hands on lab and
> from my experience in the past, he's going to need an extra helping hand
> from inside Oracle to get that approved. So, if you've a talk to submit,
> submit it and I promise it will be evaluated on it's merits. But do
> remember, there are a large number of fantastic abstracts on the cutting
> room floor just because our slot allocated wasn't enough to take them all.
>
> Kirk
>
> On 2012-04-09, at 8:45 AM, William Louth (JINSPIRED.COM) wrote:
>
>  I'd much prefer a session that discussed ways to automatically detect
> such issues before they happened (at development and more importantly in
> production) as well as runtime mechanisms (control/scheduling actions) at
> such point to avoid them...I don't know anyone that wants to find such
> issues in production when they only course of action is too simply kill the
> process (though the cloud or other more fault "tolerant" software makes
> this slightly less discomforting for some assume no residue following on).
> In terms of avoidance I am assuming that the developer can't simply rewrite
> everything from scratch to be align to some form of packet messaging.
>
> btw the way does the JavaOne conf still have rules on canvasing amongst
> those involved in the selection of talks?
>
> On 09/04/2012 08:08, Dr Heinz M. Kabutz wrote:
>
> 15.000 lines is a tiny code base.  The problem is very easy to solve once
> you get past the initial red herring.  It took Nathan Reynolds two minutes
> to discover and fix it.  If you look at the stack traces, there is only one
> possible place it could be and the stack trace takes you straight to the
> class and line number where the problem is.
>
> That said, I would be very interested to see if there are any tools that
> could discover this deadlock statically or dynamically.
>
> Regards
>
> Heinz
> --
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun Java Champion
> IEEE Certified Software Development Professionalhttp://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
>
>
> On 4/9/12 6:23 AM, Mohan Radhakrishnan wrote:
>
> I could look at the first deadlock by dumping locks and threads. I was
> planning to find the next one using Java Path Finder but I think it is not
> recommended for such a big codebase. I am not sure. Its heuristics might
> take too much memory.
>
>  Mohan
>
> On Mon, Apr 9, 2012 at 3:59 AM, <mabrouk2005 at gmail.com> wrote:
>
>> Nice exercise Dr Heinz,
>>
>> As others mentioned there were 2 kind of deadlocks the first one was
>> very is easy to find via jconsole so likeI thought that was it and
>> went and fixed that but then when ran it again it hang it so I knew
>> thee was more. the interesting thing the jconsole did not detect the
>> AWT deadlock it showed no deadlock even though the app hang. I had to
>> force stack dump and get clues to where is the deadlock. Does anyone
>> have experienced something like this with jconsole not detecting AWT
>> deadlocks?
>>
>> Thanks again for the nice exercise and the great java news letter I am
>> a big fan.
>>
>> Cheers,
>> Mabrouk
>>
>> On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax <forax at univ-mlv.fr> wrote:
>> > No, it's more an AWRY or Java2D bug.
>> >
>> > R?mi
>> >
>> > Sent from my Phone
>> >
>> >
>> > ----- Reply message -----
>> > From: "Ben Evans" <benjamin.john.evans at gmail.com>
>> > To: "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
>> > Cc: "R?mi Forax" <forax at univ-mlv.fr>, <
>> concurrency-interest at cs.oswego.edu>
>> > Subject: [concurrency-interest] Joint Talk for JavaOne?
>> > Date: Sat, Apr 7, 2012 10:43
>> >
>> >
>> > Heinz, was this with the new jdk8 + lambda build?
>> >
>> > If so, we should report this crash back to lambda-dev.
>> >
>> > Thanks,
>> >
>> > Ben
>> >
>> > On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
>> > <heinz at javaspecialists.eu> wrote:
>> >> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6.  I see
>> >> that
>> >> the Java2Demo has been removed from the demos folder of JDK 1.7 and
>> 1.8.
>> >>  It
>> >> thus is a Java 8 issue, rather than the changes I made to the code.
>> >>  Thanks
>> >> for the warning R?mi.
>> >>
>> >>
>> >> Regards
>> >>
>> >> Heinz
>> >> --
>> >> Dr Heinz M. Kabutz (PhD CompSci)
>> >> Author of "The Java(tm) Specialists' Newsletter"
>> >> Sun Java Champion
>> >> IEEE Certified Software Development Professional
>> >> http://www.javaspecialists.eu
>> >> Tel: +30 69 75 595 262
>> >> Skype: kabutz
>> >>
>> >>
>> >> On 4/6/12 1:51 AM, R?mi Forax wrote:
>> >>>
>> >>> jdk8 crashes if I click on images of the tapped pane.
>> >>>
>> >>> R?mi
>> >>>
>> >>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
>> >>>>
>> >>>> Yes, you are correct.
>> >>>>
>> >>>> However, the mistake most programmers make is to #1 scratch around in
>> >>>> the
>> >>>> source code to try and discover the problem and #2 then fix it
>> without
>> >>>> really understanding what they are doing.  I think the lesson is
>> bigger
>> >>>> if
>> >>>> we give them the source code.  In addition, it is probably more
>> >>>> difficult to
>> >>>> solve if you have the sources to muse over.
>> >>>> Regards
>> >>>>
>> >>>> Heinz
>> >>>> --
>> >>>> Dr Heinz M. Kabutz (PhD CompSci)
>> >>>> Author of "The Java(tm) Specialists' Newsletter"
>> >>>> Sun Java Champion
>> >>>> IEEE Certified Software Development Professional
>> >>>> http://www.javaspecialists.eu
>> >>>> Tel: +30 69 75 595 262
>> >>>> Skype: kabutz
>> >>>>
>> >>>>
>> >>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>> >>>>>
>> >>>>> I guess it is a good idea to not initially include the source code
>> in
>> >>>>> the workshop because many times I initially don't have the source
>> code
>> >>>>> when
>> >>>>> trying to figure out performance or scalability problems.
>> >>>>>
>> >>>>> Nathan Reynolds
>> >>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>> >>>>> Consulting
>> >>>>> Member of Technical Staff | 602.333.9091
>> >>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>> Technology
>> >>>>>
>> >>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>> >>>>>>
>> >>>>>> Sorry Nathan, here is the zip file including the source code an an
>> Ant
>> >>>>>> script to build the code.  Sorry for accidentally excluding that
>> from
>> >>>>>> the
>> >>>>>> file I sent earlier.  The problem was between the chair and the
>> >>>>>> keyboard.
>> >>>>>>  However, one should be able to pinpoint the deadlock without
>> seeing a
>> >>>>>> line
>> >>>>>> of code.  At the workshop I presented in Spain last week, most of
>> the
>> >>>>>> programmers immediately started delving into the code before they
>> knew
>> >>>>>> where
>> >>>>>> to look.
>> >>>>>> Regards
>> >>>>>>
>> >>>>>> Heinz
>> >>>>>> --
>> >>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>> >>>>>> Author of "The Java(tm) Specialists' Newsletter"
>> >>>>>> Sun Java Champion
>> >>>>>> IEEE Certified Software Development Professional
>> >>>>>> http://www.javaspecialists.eu
>> >>>>>> Tel: +30 69 75 595 262
>> >>>>>> Skype: kabutz
>> >>>>>>
>> >>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>> >>>>>>>
>> >>>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3.  It
>> >>>>>>> didn't deadlock for a minute or two.  Then the application froze.
>>  I
>> >>>>>>> then
>> >>>>>>> used jstack to dump the call stacks.  At the end of the report, it
>> >>>>>>> said
>> >>>>>>> "Found one Java-level deadlock".  It then dumped out the locks and
>> >>>>>>> threads
>> >>>>>>> involved in the deadlock.  I never looked at the source code... in
>> >>>>>>> fact it
>> >>>>>>> wasn't in the zip file.  This took about 5-7 minutes from starting
>> >>>>>>> the
>> >>>>>>> application to finding the deadlock in the call stacks.
>> >>>>>>>
>> >>>>>>> A 100 good Java developers?  Really?  I guess I can understand.
>>  Most
>> >>>>>>> engineers don't understand locks.  Most of the time I get answers
>> >>>>>>> like one
>> >>>>>>> should put a lock around shared variables.  This is accurate but
>> they
>> >>>>>>> can't
>> >>>>>>> really go any deeper.
>> >>>>>>>
>> >>>>>>> It sounds like the material of your presentation should be very
>> good.
>> >>>>>>>  It covers things that the deadlock detection tool probably can't
>> >>>>>>> figure
>> >>>>>>> out.
>> >>>>>>>
>> >>>>>>> So, it seems like you have everything figured out.  Why do you
>> need
>> >>>>>>> someone else?
>> >>>>>>>
>> >>>>>>> Nathan Reynolds
>> >>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>> >>>>>>> Consulting
>> >>>>>>> Member of Technical Staff | 602.333.9091
>> >>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>> >>>>>>> Technology
>> >>>>>>>
>> >>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>> >>>>>>>>
>> >>>>>>>> Hi Nathan,
>> >>>>>>>>
>> >>>>>>>> a stack trace will only show you a certain class of obvious
>> >>>>>>>> deadlocks
>> >>>>>>>> that are easy to find and solve.  I remember solving deadlocks
>> >>>>>>>> /before/ we
>> >>>>>>>> had the brilliant deadlock detection tool in the ThreadMXBean.
>>  Yes,
>> >>>>>>>> the
>> >>>>>>>> deadlock detection tool shows you /some/ deadlocks, but
>> definitely
>> >>>>>>>> not all
>> >>>>>>>> of them.  I can think of a bunch that it would not find:
>> >>>>>>>>
>> >>>>>>>> 1. Semaphores running out of permits
>> >>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>> >>>>>>>> 3. Resource deadlocks
>> >>>>>>>>
>> >>>>>>>> And some others that I will not describe in detail, such as some
>> >>>>>>>> nasty livelocks that we can cause which will hang up the JVM :-)
>> >>>>>>>>
>> >>>>>>>> I agree with Kirk - it should probably be a 3 hour workshop.
>>  I've
>> >>>>>>>> done this three times now - twice in Spain and once via webinar.
>> >>>>>>>>  The
>> >>>>>>>> workshop would involve some lessons on deadlocks, what causes
>> them
>> >>>>>>>> and how
>> >>>>>>>> we can prevent them.  Also an explanation as to why we see them
>> so
>> >>>>>>>> seldom in
>> >>>>>>>> real production.  I've got material prepared for this workshop.
>>  And
>> >>>>>>>> then a
>> >>>>>>>> practical part to the workshop where they can try to find a
>> deadlock
>> >>>>>>>> in a
>> >>>>>>>> body of code.
>> >>>>>>>>
>> >>>>>>>> Attached is an example of the workshop.  You can try find the
>> >>>>>>>> deadlock if you like.  I've shown it to almost 100 good Java
>> >>>>>>>> developers and
>> >>>>>>>> so far, not one has found it by themselves.  I would expect that
>> >>>>>>>> they should
>> >>>>>>>> find it in 5 minutes.  In our workshop they would obviously be
>> >>>>>>>> helped a bit
>> >>>>>>>> with hints, so that they can walk away with a good experience.
>>  Use
>> >>>>>>>> anything
>> >>>>>>>> you like.  Oscilloscope, jstack, jconsole, whatever you like.
>>  Only
>> >>>>>>>> rule for
>> >>>>>>>> you guys on the "concurrency-interest" list is: you can only
>> look at
>> >>>>>>>> the
>> >>>>>>>> code once you've found the problem, otherwise it would be too
>> easy
>> >>>>>>>> for you
>> >>>>>>>> :-)  Once you have found it, you can also fix the code and make
>> sure
>> >>>>>>>> that
>> >>>>>>>> the code then works correctly.
>> >>>>>>>> Regards
>> >>>>>>>>
>> >>>>>>>> Heinz
>> >>>>>>>> --
>> >>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>> >>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>> >>>>>>>> Sun Java Champion
>> >>>>>>>> IEEE Certified Software Development Professional
>> >>>>>>>> http://www.javaspecialists.eu
>> >>>>>>>> Tel: +30 69 75 595 262
>> >>>>>>>> Skype: kabutz
>> >>>>>>>>
>> >>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>> >>>>>>>>>
>> >>>>>>>>> I am curious as to the intended content of your presentation.
>> >>>>>>>>>  Here's some ideas.  I wondering what you are planing on doing.
>> >>>>>>>>>
>> >>>>>>>>>  1. Printing the call stacks with lock information using a tool
>> >>>>>>>>>    such as jstack
>> >>>>>>>>>  2. Press the "Detect Deadlock" button in JConsole
>> >>>>>>>>>  3. Dealing with Lock and Condition objects instead of
>> >>>>>>>>>    synchronized blocks
>> >>>>>>>>>  4. Detecting live lock
>> >>>>>>>>>  5. Distributed deadlocks
>> >>>>>>>>>
>> >>>>>>>>> Nathan Reynolds
>> >>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>> |
>> >>>>>>>>> Consulting
>> >>>>>>>>> Member of Technical Staff | 602.333.9091
>> >>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>> >>>>>>>>> Technology
>> >>>>>>>>>
>> >>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>> >>>>>>>>>>
>> >>>>>>>>>> Good afternoon,
>> >>>>>>>>>>
>> >>>>>>>>>> I am thinking of submitting a talk on finding and diagnosing
>> >>>>>>>>>> deadlocks for JavaOne.  It might be a workshop, instead of a
>> >>>>>>>>>> simple
>> >>>>>>>>>> conference talk.  Or we might be able to turn the talk into a
>> >>>>>>>>>> workshop where
>> >>>>>>>>>> they need to find a deadlock in a body of code.  Could be
>> >>>>>>>>>> something
>> >>>>>>>>>> different, which might go incredibly well or crash in a blaze
>> of
>> >>>>>>>>>> flames.
>> >>>>>>>>>>  Would any of you be interested in co-presenting this with me
>> at
>> >>>>>>>>>> JavaOne?
>> >>>>>>>>>>
>> >>>>>>>>>> Regards
>> >>>>>>>>>>
>> >>>>>>>>>> Heinz
>> >>>>
>> >>>>
>> >>>>
>> >>>> _______________________________________________
>> >>>> Concurrency-interest mailing list
>> >>>> Concurrency-interest at cs.oswego.edu
>> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>
>> >>>
>> >>> _______________________________________________
>> >>> Concurrency-interest mailing list
>> >>> Concurrency-interest at cs.oswego.edu
>> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>  ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>  _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120409/42ae0249/attachment-0001.html>

From kirk at kodewerk.com  Mon Apr  9 08:32:36 2012
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Mon, 9 Apr 2012 14:32:36 +0200
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <CAMroGZr6byAOQZi++0j6JYXCSnPsuVOiTHY2jpbU-fFB05ikdg@mail.gmail.com>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>
	<CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>
	<CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>
	<4F827CE7.1020101@javaspecialists.eu>
	<4F828595.4000600@jinspired.com>
	<E743036F-0DED-41A0-ACB7-79DC31D3D965@kodewerk.com>
	<CAMroGZr6byAOQZi++0j6JYXCSnPsuVOiTHY2jpbU-fFB05ikdg@mail.gmail.com>
Message-ID: <E03ED887-ACC1-497D-86C4-0F703F3ECB6C@kodewerk.com>

since it's very difficult to predict execution paths and execution paths are the source of the problem.....
On 2012-04-09, at 1:24 PM, Ioannis Mavroukakis wrote:

> Hello everyone,
> 
>  
> Although I will not be attending JavaOne, I would like to offer my opinion. Automatic detection is a nice to have but I believe that as a  developer, I would like to be educated in the "eyball" ways that exist to detect an issue. Although one would argue (and I believe strongly in that) in "prevent, don't cure" , brown runny stuff happens and something will creep past you. In that instance, such a workshop by Dr Kabutz would be of high educational value.
> 
>  
> Cheers,
> 
> Ioannis
> 
> 
> On 9 April 2012 09:17, Kirk Pepperdine <kirk at kodewerk.com> wrote:
> Hi William,
> 
> I'm on the core track committee and I vote based on 1) content (based on the strength of the abstract and supporting materials), 2) the % of informercial content (lower is better IMHO) 3) my feeling on the speakers ability to deliver. Heinz's doesn't get a pass because he's a very good friend. He'll get's my vote based on the criteria laid out. But since I've seen many of Heinz's talks I know that he'll pass on points 2 and 3 and I doubt he'll fail on point 1. The risk is, he's going for a hands on lab and from my experience in the past, he's going to need an extra helping hand from inside Oracle to get that approved. So, if you've a talk to submit, submit it and I promise it will be evaluated on it's merits. But do remember, there are a large number of fantastic abstracts on the cutting room floor just because our slot allocated wasn't enough to take them all.
> 
> Kirk
> 
> On 2012-04-09, at 8:45 AM, William Louth (JINSPIRED.COM) wrote:
> 
>> I'd much prefer a session that discussed ways to automatically detect such issues before they happened (at development and more importantly in production) as well as runtime mechanisms (control/scheduling actions) at such point to avoid them...I don't know anyone that wants to find such issues in production when they only course of action is too simply kill the process (though the cloud or other more fault "tolerant" software makes this slightly less discomforting for some assume no residue following on). In terms of avoidance I am assuming that the developer can't simply rewrite everything from scratch to be align to some form of packet messaging.
>> 
>> btw the way does the JavaOne conf still have rules on canvasing amongst those involved in the selection of talks?
>> 
>> On 09/04/2012 08:08, Dr Heinz M. Kabutz wrote:
>>> 
>>> 15.000 lines is a tiny code base.  The problem is very easy to solve once you get past the initial red herring.  It took Nathan Reynolds two minutes to discover and fix it.  If you look at the stack traces, there is only one possible place it could be and the stack trace takes you straight to the class and line number where the problem is.
>>> 
>>> That said, I would be very interested to see if there are any tools that could discover this deadlock statically or dynamically.
>>> Regards
>>> 
>>> Heinz
>>> -- 
>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> Author of "The Java(tm) Specialists' Newsletter"
>>> Sun Java Champion
>>> IEEE Certified Software Development Professional
>>> http://www.javaspecialists.eu
>>> Tel: +30 69 75 595 262
>>> Skype: kabutz 
>>> 
>>> 
>>> On 4/9/12 6:23 AM, Mohan Radhakrishnan wrote:
>>>> 
>>>> I could look at the first deadlock by dumping locks and threads. I was planning to find the next one using Java Path Finder but I think it is not recommended for such a big codebase. I am not sure. Its heuristics might take too much memory.
>>>> 
>>>> Mohan
>>>> 
>>>> On Mon, Apr 9, 2012 at 3:59 AM, <mabrouk2005 at gmail.com> wrote:
>>>> Nice exercise Dr Heinz,
>>>> 
>>>> As others mentioned there were 2 kind of deadlocks the first one was
>>>> very is easy to find via jconsole so likeI thought that was it and
>>>> went and fixed that but then when ran it again it hang it so I knew
>>>> thee was more. the interesting thing the jconsole did not detect the
>>>> AWT deadlock it showed no deadlock even though the app hang. I had to
>>>> force stack dump and get clues to where is the deadlock. Does anyone
>>>> have experienced something like this with jconsole not detecting AWT
>>>> deadlocks?
>>>> 
>>>> Thanks again for the nice exercise and the great java news letter I am
>>>> a big fan.
>>>> 
>>>> Cheers,
>>>> Mabrouk
>>>> 
>>>> On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax <forax at univ-mlv.fr> wrote:
>>>> > No, it's more an AWRY or Java2D bug.
>>>> >
>>>> > R?mi
>>>> >
>>>> > Sent from my Phone
>>>> >
>>>> >
>>>> > ----- Reply message -----
>>>> > From: "Ben Evans" <benjamin.john.evans at gmail.com>
>>>> > To: "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu>
>>>> > Cc: "R?mi Forax" <forax at univ-mlv.fr>, <concurrency-interest at cs.oswego.edu>
>>>> > Subject: [concurrency-interest] Joint Talk for JavaOne?
>>>> > Date: Sat, Apr 7, 2012 10:43
>>>> >
>>>> >
>>>> > Heinz, was this with the new jdk8 + lambda build?
>>>> >
>>>> > If so, we should report this crash back to lambda-dev.
>>>> >
>>>> > Thanks,
>>>> >
>>>> > Ben
>>>> >
>>>> > On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
>>>> > <heinz at javaspecialists.eu> wrote:
>>>> >> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6.  I see
>>>> >> that
>>>> >> the Java2Demo has been removed from the demos folder of JDK 1.7 and 1.8.
>>>> >>  It
>>>> >> thus is a Java 8 issue, rather than the changes I made to the code.
>>>> >>  Thanks
>>>> >> for the warning R?mi.
>>>> >>
>>>> >>
>>>> >> Regards
>>>> >>
>>>> >> Heinz
>>>> >> --
>>>> >> Dr Heinz M. Kabutz (PhD CompSci)
>>>> >> Author of "The Java(tm) Specialists' Newsletter"
>>>> >> Sun Java Champion
>>>> >> IEEE Certified Software Development Professional
>>>> >> http://www.javaspecialists.eu
>>>> >> Tel: +30 69 75 595 262
>>>> >> Skype: kabutz
>>>> >>
>>>> >>
>>>> >> On 4/6/12 1:51 AM, R?mi Forax wrote:
>>>> >>>
>>>> >>> jdk8 crashes if I click on images of the tapped pane.
>>>> >>>
>>>> >>> R?mi
>>>> >>>
>>>> >>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
>>>> >>>>
>>>> >>>> Yes, you are correct.
>>>> >>>>
>>>> >>>> However, the mistake most programmers make is to #1 scratch around in
>>>> >>>> the
>>>> >>>> source code to try and discover the problem and #2 then fix it without
>>>> >>>> really understanding what they are doing.  I think the lesson is bigger
>>>> >>>> if
>>>> >>>> we give them the source code.  In addition, it is probably more
>>>> >>>> difficult to
>>>> >>>> solve if you have the sources to muse over.
>>>> >>>> Regards
>>>> >>>>
>>>> >>>> Heinz
>>>> >>>> --
>>>> >>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>> >>>> Author of "The Java(tm) Specialists' Newsletter"
>>>> >>>> Sun Java Champion
>>>> >>>> IEEE Certified Software Development Professional
>>>> >>>> http://www.javaspecialists.eu
>>>> >>>> Tel: +30 69 75 595 262
>>>> >>>> Skype: kabutz
>>>> >>>>
>>>> >>>>
>>>> >>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>>>> >>>>>
>>>> >>>>> I guess it is a good idea to not initially include the source code in
>>>> >>>>> the workshop because many times I initially don't have the source code
>>>> >>>>> when
>>>> >>>>> trying to figure out performance or scalability problems.
>>>> >>>>>
>>>> >>>>> Nathan Reynolds
>>>> >>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>> >>>>> Consulting
>>>> >>>>> Member of Technical Staff | 602.333.9091
>>>> >>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>> >>>>>
>>>> >>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>>>> >>>>>>
>>>> >>>>>> Sorry Nathan, here is the zip file including the source code an an Ant
>>>> >>>>>> script to build the code.  Sorry for accidentally excluding that from
>>>> >>>>>> the
>>>> >>>>>> file I sent earlier.  The problem was between the chair and the
>>>> >>>>>> keyboard.
>>>> >>>>>>  However, one should be able to pinpoint the deadlock without seeing a
>>>> >>>>>> line
>>>> >>>>>> of code.  At the workshop I presented in Spain last week, most of the
>>>> >>>>>> programmers immediately started delving into the code before they knew
>>>> >>>>>> where
>>>> >>>>>> to look.
>>>> >>>>>> Regards
>>>> >>>>>>
>>>> >>>>>> Heinz
>>>> >>>>>> --
>>>> >>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>> >>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>> >>>>>> Sun Java Champion
>>>> >>>>>> IEEE Certified Software Development Professional
>>>> >>>>>> http://www.javaspecialists.eu
>>>> >>>>>> Tel: +30 69 75 595 262
>>>> >>>>>> Skype: kabutz
>>>> >>>>>>
>>>> >>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>>>> >>>>>>>
>>>> >>>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3.  It
>>>> >>>>>>> didn't deadlock for a minute or two.  Then the application froze.  I
>>>> >>>>>>> then
>>>> >>>>>>> used jstack to dump the call stacks.  At the end of the report, it
>>>> >>>>>>> said
>>>> >>>>>>> "Found one Java-level deadlock".  It then dumped out the locks and
>>>> >>>>>>> threads
>>>> >>>>>>> involved in the deadlock.  I never looked at the source code... in
>>>> >>>>>>> fact it
>>>> >>>>>>> wasn't in the zip file.  This took about 5-7 minutes from starting
>>>> >>>>>>> the
>>>> >>>>>>> application to finding the deadlock in the call stacks.
>>>> >>>>>>>
>>>> >>>>>>> A 100 good Java developers?  Really?  I guess I can understand.  Most
>>>> >>>>>>> engineers don't understand locks.  Most of the time I get answers
>>>> >>>>>>> like one
>>>> >>>>>>> should put a lock around shared variables.  This is accurate but they
>>>> >>>>>>> can't
>>>> >>>>>>> really go any deeper.
>>>> >>>>>>>
>>>> >>>>>>> It sounds like the material of your presentation should be very good.
>>>> >>>>>>>  It covers things that the deadlock detection tool probably can't
>>>> >>>>>>> figure
>>>> >>>>>>> out.
>>>> >>>>>>>
>>>> >>>>>>> So, it seems like you have everything figured out.  Why do you need
>>>> >>>>>>> someone else?
>>>> >>>>>>>
>>>> >>>>>>> Nathan Reynolds
>>>> >>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>> >>>>>>> Consulting
>>>> >>>>>>> Member of Technical Staff | 602.333.9091
>>>> >>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>> >>>>>>> Technology
>>>> >>>>>>>
>>>> >>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>>> >>>>>>>>
>>>> >>>>>>>> Hi Nathan,
>>>> >>>>>>>>
>>>> >>>>>>>> a stack trace will only show you a certain class of obvious
>>>> >>>>>>>> deadlocks
>>>> >>>>>>>> that are easy to find and solve.  I remember solving deadlocks
>>>> >>>>>>>> /before/ we
>>>> >>>>>>>> had the brilliant deadlock detection tool in the ThreadMXBean.  Yes,
>>>> >>>>>>>> the
>>>> >>>>>>>> deadlock detection tool shows you /some/ deadlocks, but definitely
>>>> >>>>>>>> not all
>>>> >>>>>>>> of them.  I can think of a bunch that it would not find:
>>>> >>>>>>>>
>>>> >>>>>>>> 1. Semaphores running out of permits
>>>> >>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>>>> >>>>>>>> 3. Resource deadlocks
>>>> >>>>>>>>
>>>> >>>>>>>> And some others that I will not describe in detail, such as some
>>>> >>>>>>>> nasty livelocks that we can cause which will hang up the JVM :-)
>>>> >>>>>>>>
>>>> >>>>>>>> I agree with Kirk - it should probably be a 3 hour workshop.  I've
>>>> >>>>>>>> done this three times now - twice in Spain and once via webinar.
>>>> >>>>>>>>  The
>>>> >>>>>>>> workshop would involve some lessons on deadlocks, what causes them
>>>> >>>>>>>> and how
>>>> >>>>>>>> we can prevent them.  Also an explanation as to why we see them so
>>>> >>>>>>>> seldom in
>>>> >>>>>>>> real production.  I've got material prepared for this workshop.  And
>>>> >>>>>>>> then a
>>>> >>>>>>>> practical part to the workshop where they can try to find a deadlock
>>>> >>>>>>>> in a
>>>> >>>>>>>> body of code.
>>>> >>>>>>>>
>>>> >>>>>>>> Attached is an example of the workshop.  You can try find the
>>>> >>>>>>>> deadlock if you like.  I've shown it to almost 100 good Java
>>>> >>>>>>>> developers and
>>>> >>>>>>>> so far, not one has found it by themselves.  I would expect that
>>>> >>>>>>>> they should
>>>> >>>>>>>> find it in 5 minutes.  In our workshop they would obviously be
>>>> >>>>>>>> helped a bit
>>>> >>>>>>>> with hints, so that they can walk away with a good experience.  Use
>>>> >>>>>>>> anything
>>>> >>>>>>>> you like.  Oscilloscope, jstack, jconsole, whatever you like.  Only
>>>> >>>>>>>> rule for
>>>> >>>>>>>> you guys on the "concurrency-interest" list is: you can only look at
>>>> >>>>>>>> the
>>>> >>>>>>>> code once you've found the problem, otherwise it would be too easy
>>>> >>>>>>>> for you
>>>> >>>>>>>> :-)  Once you have found it, you can also fix the code and make sure
>>>> >>>>>>>> that
>>>> >>>>>>>> the code then works correctly.
>>>> >>>>>>>> Regards
>>>> >>>>>>>>
>>>> >>>>>>>> Heinz
>>>> >>>>>>>> --
>>>> >>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>> >>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>> >>>>>>>> Sun Java Champion
>>>> >>>>>>>> IEEE Certified Software Development Professional
>>>> >>>>>>>> http://www.javaspecialists.eu
>>>> >>>>>>>> Tel: +30 69 75 595 262
>>>> >>>>>>>> Skype: kabutz
>>>> >>>>>>>>
>>>> >>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>> >>>>>>>>>
>>>> >>>>>>>>> I am curious as to the intended content of your presentation.
>>>> >>>>>>>>>  Here's some ideas.  I wondering what you are planing on doing.
>>>> >>>>>>>>>
>>>> >>>>>>>>>  1. Printing the call stacks with lock information using a tool
>>>> >>>>>>>>>    such as jstack
>>>> >>>>>>>>>  2. Press the "Detect Deadlock" button in JConsole
>>>> >>>>>>>>>  3. Dealing with Lock and Condition objects instead of
>>>> >>>>>>>>>    synchronized blocks
>>>> >>>>>>>>>  4. Detecting live lock
>>>> >>>>>>>>>  5. Distributed deadlocks
>>>> >>>>>>>>>
>>>> >>>>>>>>> Nathan Reynolds
>>>> >>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>> >>>>>>>>> Consulting
>>>> >>>>>>>>> Member of Technical Staff | 602.333.9091
>>>> >>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>> >>>>>>>>> Technology
>>>> >>>>>>>>>
>>>> >>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>> >>>>>>>>>>
>>>> >>>>>>>>>> Good afternoon,
>>>> >>>>>>>>>>
>>>> >>>>>>>>>> I am thinking of submitting a talk on finding and diagnosing
>>>> >>>>>>>>>> deadlocks for JavaOne.  It might be a workshop, instead of a
>>>> >>>>>>>>>> simple
>>>> >>>>>>>>>> conference talk.  Or we might be able to turn the talk into a
>>>> >>>>>>>>>> workshop where
>>>> >>>>>>>>>> they need to find a deadlock in a body of code.  Could be
>>>> >>>>>>>>>> something
>>>> >>>>>>>>>> different, which might go incredibly well or crash in a blaze of
>>>> >>>>>>>>>> flames.
>>>> >>>>>>>>>>  Would any of you be interested in co-presenting this with me at
>>>> >>>>>>>>>> JavaOne?
>>>> >>>>>>>>>>
>>>> >>>>>>>>>> Regards
>>>> >>>>>>>>>>
>>>> >>>>>>>>>> Heinz
>>>> >>>>
>>>> >>>>
>>>> >>>>
>>>> >>>> _______________________________________________
>>>> >>>> Concurrency-interest mailing list
>>>> >>>> Concurrency-interest at cs.oswego.edu
>>>> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >>>
>>>> >>>
>>>> >>> _______________________________________________
>>>> >>> Concurrency-interest mailing list
>>>> >>> Concurrency-interest at cs.oswego.edu
>>>> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >>>
>>>> >> _______________________________________________
>>>> >> Concurrency-interest mailing list
>>>> >> Concurrency-interest at cs.oswego.edu
>>>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >
>>>> > _______________________________________________
>>>> > Concurrency-interest mailing list
>>>> > Concurrency-interest at cs.oswego.edu
>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >
>>>> 
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> 
>>>> 
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>   
>>> 
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120409/6f00ec90/attachment-0001.html>

From william.louth at jinspired.com  Mon Apr  9 08:53:52 2012
From: william.louth at jinspired.com (William Louth (JINSPIRED.COM))
Date: Mon, 09 Apr 2012 14:53:52 +0200
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <CAMroGZr6byAOQZi++0j6JYXCSnPsuVOiTHY2jpbU-fFB05ikdg@mail.gmail.com>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>
	<CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>
	<CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>
	<4F827CE7.1020101@javaspecialists.eu>
	<4F828595.4000600@jinspired.com>
	<E743036F-0DED-41A0-ACB7-79DC31D3D965@kodewerk.com>
	<CAMroGZr6byAOQZi++0j6JYXCSnPsuVOiTHY2jpbU-fFB05ikdg@mail.gmail.com>
Message-ID: <4F82DBE0.40104@jinspired.com>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120409/25f31f1d/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: callframes-with-ids.pdf
Type: application/pdf
Size: 165430 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120409/25f31f1d/attachment-0001.pdf>

From gregg at cytetech.com  Mon Apr  9 09:14:59 2012
From: gregg at cytetech.com (Gregg Wonderly)
Date: Mon, 09 Apr 2012 08:14:59 -0500
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <E03ED887-ACC1-497D-86C4-0F703F3ECB6C@kodewerk.com>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>
	<CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>
	<CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>
	<4F827CE7.1020101@javaspecialists.eu>
	<4F828595.4000600@jinspired.com>
	<E743036F-0DED-41A0-ACB7-79DC31D3D965@kodewerk.com>
	<CAMroGZr6byAOQZi++0j6JYXCSnPsuVOiTHY2jpbU-fFB05ikdg@mail.gmail.com>
	<E03ED887-ACC1-497D-86C4-0F703F3ECB6C@kodewerk.com>
Message-ID: <4F82E0D3.4070906@cytetech.com>

Ahh, but this is part of API design.  You need to be able to "predict" execution 
paths by controlling them.  Complex state changes inside complex objects need to 
be controlled by a state machine, not by external "action order".  There are 
lots of reasons why good software design education, and training/experience is 
always a good thing.  Tools help when you are stuck with unknown, or 
inaccessible source bases.

For me, a stack trace is always what I use.  When any software I am supporting 
is behaving unpredictably, I will have already done several things, when putting 
it into operation.

1. I will have started it as a service on a UNIX like OS, so that I can see into 
it with many different tools, including:

	o lsof - to see what files are open to what destinations
	o /proc - or other process meta-data to see number of open files,
           memory use etc.
	o stdout and stderr will be redirected to append to a file at startup,
           so that I can just do "ps" to find it, and "kill -3" to see where
           threads are stuck at. I may even do kill -11 on it so that it stops
           with a JDK fault analysis which will expose library versions and
           several other internal things.

The script that runs the service will look like

while :
do
	echo "----------------- ${PRODUCT} Starting ------------------" >>$log
	${JAVA} ${opts} ${PRODCLASS} ${args} >>$log 2>&1 </dev/null &
         pid=$!
	echo $pid >${PRODHOME}/${PRODUCT}.pid
	# make killing this script kill the service
	trap "kill $pid;exit " 0 1 15
	wait
	# process exited without trapped signal, restart it
	trap - 0 1 15
	echo "----------  ${PRODUCT} Shutdown  ----------------------------------" >>$log
	echo "---------------- `date` -----------------" >>$log
	echo "---------------------------------------------------------------" >>$log
	# If still running, another was started, exit to avoid
	# creating lots
	if ps -awwwx | grep $JAVA | grep ${PRODCLASS}; then
		echo "$0: another instance of ${PROD} was found running, exiting" >&2
		exit
	fi
done

Setting around for many minutes, with a SSH session tailing $log, and another 
hitting it occasionally with kill -3, provides a tremendous amount of deadlock 
detection, but also it shows you hot spots.  You can see threads stuck waiting 
on locks (which aren't deadlock sources) and know that perhaps that point of 
contention is hotter than you imagined, or wanted it to be.

But, in the end, API design should really control paths so that you can, 
internally optimize the performance through those paths without having to 
'change' a bunch of code, refactoring access to make some contention or deadlock 
go away.

Gregg Wonderly

On 4/9/2012 7:32 AM, Kirk Pepperdine wrote:
> since it's very difficult to predict execution paths and execution paths are the
> source of the problem.....
> On 2012-04-09, at 1:24 PM, Ioannis Mavroukakis wrote:
>
>> Hello everyone,
>>
>>
>> Although I will not be attending JavaOne, I would like to offer my opinion.
>> Automatic detection is a nice to have but I believe that as a developer, I
>> would like to be educated in the "eyball" ways that exist to detect an issue.
>> Although one would argue (and I believe strongly in that) in "prevent, don't
>> cure" , brown runny stuff happens and something will creep past you. In that
>> instance, such a workshop by Dr Kabutz would be of high educational value.
>>
>>
>> Cheers,
>>
>> Ioannis
>>
>> On 9 April 2012 09:17, Kirk Pepperdine <kirk at kodewerk.com
>> <mailto:kirk at kodewerk.com>> wrote:
>>
>>     Hi William,
>>
>>     I'm on the core track committee and I vote based on 1) content (based on
>>     the strength of the abstract and supporting materials), 2) the % of
>>     informercial content (lower is better IMHO) 3) my feeling on the speakers
>>     ability to deliver. Heinz's doesn't get a pass because he's a very good
>>     friend. He'll get's my vote based on the criteria laid out. But since I've
>>     seen many of Heinz's talks I know that he'll pass on points 2 and 3 and I
>>     doubt he'll fail on point 1. The risk is, he's going for a hands on lab
>>     and from my experience in the past, he's going to need an extra helping
>>     hand from inside Oracle to get that approved. So, if you've a talk to
>>     submit, submit it and I promise it will be evaluated on it's merits. But
>>     do remember, there are a large number of fantastic abstracts on the
>>     cutting room floor just because our slot allocated wasn't enough to take
>>     them all.
>>
>>     Kirk
>>
>>     On 2012-04-09, at 8:45 AM, William Louth (JINSPIRED.COM
>>     <http://JINSPIRED.COM/>) wrote:
>>
>>>     I'd much prefer a session that discussed ways to automatically detect
>>>     such issues before they happened (at development and more importantly in
>>>     production) as well as runtime mechanisms (control/scheduling actions) at
>>>     such point to avoid them...I don't know anyone that wants to find such
>>>     issues in production when they only course of action is too simply kill
>>>     the process (though the cloud or other more fault "tolerant" software
>>>     makes this slightly less discomforting for some assume no residue
>>>     following on). In terms of avoidance I am assuming that the developer
>>>     can't simply rewrite everything from scratch to be align to some form of
>>>     packet messaging.
>>>
>>>     btw the way does the JavaOne conf still have rules on canvasing amongst
>>>     those involved in the selection of talks?
>>>
>>>     On 09/04/2012 08:08, Dr Heinz M. Kabutz wrote:
>>>>     15.000 lines is a tiny code base. The problem is very easy to solve once
>>>>     you get past the initial red herring. It took Nathan Reynolds two
>>>>     minutes to discover and fix it. If you look at the stack traces, there
>>>>     is only one possible place it could be and the stack trace takes you
>>>>     straight to the class and line number where the problem is.
>>>>
>>>>     That said, I would be very interested to see if there are any tools that
>>>>     could discover this deadlock statically or dynamically.
>>>>     Regards
>>>>
>>>>     Heinz
>>>>     --
>>>>     Dr Heinz M. Kabutz (PhD CompSci)
>>>>     Author of "The Java(tm) Specialists' Newsletter"
>>>>     Sun Java Champion
>>>>     IEEE Certified Software Development Professional
>>>>     http://www.javaspecialists.eu  <http://www.javaspecialists.eu/>
>>>>     Tel:+30 69 75 595 262  <tel:%2B30%2069%2075%20595%20262>
>>>>     Skype: kabutz
>>>>
>>>>
>>>>     On 4/9/12 6:23 AM, Mohan Radhakrishnan wrote:
>>>>>     I could look at the first deadlock by dumping locks and threads. I was
>>>>>     planning to find the next one using Java Path Finder but I think it is
>>>>>     not recommended for such a big codebase. I am not sure. Its heuristics
>>>>>     might take too much memory.
>>>>>
>>>>>     Mohan
>>>>>
>>>>>     On Mon, Apr 9, 2012 at 3:59 AM, <mabrouk2005 at gmail.com
>>>>>     <mailto:mabrouk2005 at gmail.com>> wrote:
>>>>>
>>>>>         Nice exercise Dr Heinz,
>>>>>
>>>>>         As others mentioned there were 2 kind of deadlocks the first one was
>>>>>         very is easy to find via jconsole so likeI thought that was it and
>>>>>         went and fixed that but then when ran it again it hang it so I knew
>>>>>         thee was more. the interesting thing the jconsole did not detect the
>>>>>         AWT deadlock it showed no deadlock even though the app hang. I had to
>>>>>         force stack dump and get clues to where is the deadlock. Does anyone
>>>>>         have experienced something like this with jconsole not detecting AWT
>>>>>         deadlocks?
>>>>>
>>>>>         Thanks again for the nice exercise and the great java news letter I am
>>>>>         a big fan.
>>>>>
>>>>>         Cheers,
>>>>>         Mabrouk
>>>>>
>>>>>         On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax <forax at univ-mlv.fr
>>>>>         <mailto:forax at univ-mlv.fr>> wrote:
>>>>>         > No, it's more an AWRY or Java2D bug.
>>>>>         >
>>>>>         > R?mi
>>>>>         >
>>>>>         > Sent from my Phone
>>>>>         >
>>>>>         >
>>>>>         > ----- Reply message -----
>>>>>         > From: "Ben Evans" <benjamin.john.evans at gmail.com
>>>>>         <mailto:benjamin.john.evans at gmail.com>>
>>>>>         > To: "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu
>>>>>         <mailto:heinz at javaspecialists.eu>>
>>>>>         > Cc: "R?mi Forax" <forax at univ-mlv.fr <mailto:forax at univ-mlv.fr>>,
>>>>>         <concurrency-interest at cs.oswego.edu
>>>>>         <mailto:concurrency-interest at cs.oswego.edu>>
>>>>>         > Subject: [concurrency-interest] Joint Talk for JavaOne?
>>>>>         > Date: Sat, Apr 7, 2012 10:43
>>>>>         >
>>>>>         >
>>>>>         > Heinz, was this with the new jdk8 + lambda build?
>>>>>         >
>>>>>         > If so, we should report this crash back to lambda-dev.
>>>>>         >
>>>>>         > Thanks,
>>>>>         >
>>>>>         > Ben
>>>>>         >
>>>>>         > On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
>>>>>         > <heinz at javaspecialists.eu <mailto:heinz at javaspecialists.eu>> wrote:
>>>>>         >> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6.
>>>>>         I see
>>>>>         >> that
>>>>>         >> the Java2Demo has been removed from the demos folder of JDK 1.7
>>>>>         and 1.8.
>>>>>         >> It
>>>>>         >> thus is a Java 8 issue, rather than the changes I made to the code.
>>>>>         >> Thanks
>>>>>         >> for the warning R?mi.
>>>>>         >>
>>>>>         >>
>>>>>         >> Regards
>>>>>         >>
>>>>>         >> Heinz
>>>>>         >> --
>>>>>         >> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>         >> Author of "The Java(tm) Specialists' Newsletter"
>>>>>         >> Sun Java Champion
>>>>>         >> IEEE Certified Software Development Professional
>>>>>         >> http://www.javaspecialists.eu <http://www.javaspecialists.eu/>
>>>>>         >> Tel: +30 69 75 595 262 <tel:%2B30%2069%2075%20595%20262>
>>>>>         >> Skype: kabutz
>>>>>         >>
>>>>>         >>
>>>>>         >> On 4/6/12 1:51 AM, R?mi Forax wrote:
>>>>>         >>>
>>>>>         >>> jdk8 crashes if I click on images of the tapped pane.
>>>>>         >>>
>>>>>         >>> R?mi
>>>>>         >>>
>>>>>         >>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
>>>>>         >>>>
>>>>>         >>>> Yes, you are correct.
>>>>>         >>>>
>>>>>         >>>> However, the mistake most programmers make is to #1 scratch
>>>>>         around in
>>>>>         >>>> the
>>>>>         >>>> source code to try and discover the problem and #2 then fix it
>>>>>         without
>>>>>         >>>> really understanding what they are doing. I think the lesson
>>>>>         is bigger
>>>>>         >>>> if
>>>>>         >>>> we give them the source code. In addition, it is probably more
>>>>>         >>>> difficult to
>>>>>         >>>> solve if you have the sources to muse over.
>>>>>         >>>> Regards
>>>>>         >>>>
>>>>>         >>>> Heinz
>>>>>         >>>> --
>>>>>         >>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>         >>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>         >>>> Sun Java Champion
>>>>>         >>>> IEEE Certified Software Development Professional
>>>>>         >>>> http://www.javaspecialists.eu <http://www.javaspecialists.eu/>
>>>>>         >>>> Tel: +30 69 75 595 262 <tel:%2B30%2069%2075%20595%20262>
>>>>>         >>>> Skype: kabutz
>>>>>         >>>>
>>>>>         >>>>
>>>>>         >>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>>>>>         >>>>>
>>>>>         >>>>> I guess it is a good idea to not initially include the source
>>>>>         code in
>>>>>         >>>>> the workshop because many times I initially don't have the
>>>>>         source code
>>>>>         >>>>> when
>>>>>         >>>>> trying to figure out performance or scalability problems.
>>>>>         >>>>>
>>>>>         >>>>> Nathan Reynolds
>>>>>         >>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>         >>>>> Consulting
>>>>>         >>>>> Member of Technical Staff | 602.333.9091
>>>>>         >>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>>>         Technology
>>>>>         >>>>>
>>>>>         >>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>>>>>         >>>>>>
>>>>>         >>>>>> Sorry Nathan, here is the zip file including the source code
>>>>>         an an Ant
>>>>>         >>>>>> script to build the code. Sorry for accidentally excluding
>>>>>         that from
>>>>>         >>>>>> the
>>>>>         >>>>>> file I sent earlier. The problem was between the chair and the
>>>>>         >>>>>> keyboard.
>>>>>         >>>>>> However, one should be able to pinpoint the deadlock without
>>>>>         seeing a
>>>>>         >>>>>> line
>>>>>         >>>>>> of code. At the workshop I presented in Spain last week,
>>>>>         most of the
>>>>>         >>>>>> programmers immediately started delving into the code before
>>>>>         they knew
>>>>>         >>>>>> where
>>>>>         >>>>>> to look.
>>>>>         >>>>>> Regards
>>>>>         >>>>>>
>>>>>         >>>>>> Heinz
>>>>>         >>>>>> --
>>>>>         >>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>         >>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>         >>>>>> Sun Java Champion
>>>>>         >>>>>> IEEE Certified Software Development Professional
>>>>>         >>>>>> http://www.javaspecialists.eu <http://www.javaspecialists.eu/>
>>>>>         >>>>>> Tel: +30 69 75 595 262 <tel:%2B30%2069%2075%20595%20262>
>>>>>         >>>>>> Skype: kabutz
>>>>>         >>>>>>
>>>>>         >>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>>>>>         >>>>>>>
>>>>>         >>>>>>> I took the bait and tried out the demo on HotSpot 7 Update
>>>>>         3. It
>>>>>         >>>>>>> didn't deadlock for a minute or two. Then the application
>>>>>         froze. I
>>>>>         >>>>>>> then
>>>>>         >>>>>>> used jstack to dump the call stacks. At the end of the
>>>>>         report, it
>>>>>         >>>>>>> said
>>>>>         >>>>>>> "Found one Java-level deadlock". It then dumped out the
>>>>>         locks and
>>>>>         >>>>>>> threads
>>>>>         >>>>>>> involved in the deadlock. I never looked at the source
>>>>>         code... in
>>>>>         >>>>>>> fact it
>>>>>         >>>>>>> wasn't in the zip file. This took about 5-7 minutes from
>>>>>         starting
>>>>>         >>>>>>> the
>>>>>         >>>>>>> application to finding the deadlock in the call stacks.
>>>>>         >>>>>>>
>>>>>         >>>>>>> A 100 good Java developers? Really? I guess I can
>>>>>         understand. Most
>>>>>         >>>>>>> engineers don't understand locks. Most of the time I get
>>>>>         answers
>>>>>         >>>>>>> like one
>>>>>         >>>>>>> should put a lock around shared variables. This is accurate
>>>>>         but they
>>>>>         >>>>>>> can't
>>>>>         >>>>>>> really go any deeper.
>>>>>         >>>>>>>
>>>>>         >>>>>>> It sounds like the material of your presentation should be
>>>>>         very good.
>>>>>         >>>>>>> It covers things that the deadlock detection tool probably
>>>>>         can't
>>>>>         >>>>>>> figure
>>>>>         >>>>>>> out.
>>>>>         >>>>>>>
>>>>>         >>>>>>> So, it seems like you have everything figured out. Why do
>>>>>         you need
>>>>>         >>>>>>> someone else?
>>>>>         >>>>>>>
>>>>>         >>>>>>> Nathan Reynolds
>>>>>         >>>>>>>
>>>>>         <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>         >>>>>>> Consulting
>>>>>         >>>>>>> Member of Technical Staff | 602.333.9091
>>>>>         >>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>>>         >>>>>>> Technology
>>>>>         >>>>>>>
>>>>>         >>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>>>>         >>>>>>>>
>>>>>         >>>>>>>> Hi Nathan,
>>>>>         >>>>>>>>
>>>>>         >>>>>>>> a stack trace will only show you a certain class of obvious
>>>>>         >>>>>>>> deadlocks
>>>>>         >>>>>>>> that are easy to find and solve. I remember solving deadlocks
>>>>>         >>>>>>>> /before/ we
>>>>>         >>>>>>>> had the brilliant deadlock detection tool in the
>>>>>         ThreadMXBean. Yes,
>>>>>         >>>>>>>> the
>>>>>         >>>>>>>> deadlock detection tool shows you /some/ deadlocks, but
>>>>>         definitely
>>>>>         >>>>>>>> not all
>>>>>         >>>>>>>> of them. I can think of a bunch that it would not find:
>>>>>         >>>>>>>>
>>>>>         >>>>>>>> 1. Semaphores running out of permits
>>>>>         >>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to
>>>>>         read lock
>>>>>         >>>>>>>> 3. Resource deadlocks
>>>>>         >>>>>>>>
>>>>>         >>>>>>>> And some others that I will not describe in detail, such
>>>>>         as some
>>>>>         >>>>>>>> nasty livelocks that we can cause which will hang up the
>>>>>         JVM :-)
>>>>>         >>>>>>>>
>>>>>         >>>>>>>> I agree with Kirk - it should probably be a 3 hour
>>>>>         workshop. I've
>>>>>         >>>>>>>> done this three times now - twice in Spain and once via
>>>>>         webinar.
>>>>>         >>>>>>>> The
>>>>>         >>>>>>>> workshop would involve some lessons on deadlocks, what
>>>>>         causes them
>>>>>         >>>>>>>> and how
>>>>>         >>>>>>>> we can prevent them. Also an explanation as to why we see
>>>>>         them so
>>>>>         >>>>>>>> seldom in
>>>>>         >>>>>>>> real production. I've got material prepared for this
>>>>>         workshop. And
>>>>>         >>>>>>>> then a
>>>>>         >>>>>>>> practical part to the workshop where they can try to find
>>>>>         a deadlock
>>>>>         >>>>>>>> in a
>>>>>         >>>>>>>> body of code.
>>>>>         >>>>>>>>
>>>>>         >>>>>>>> Attached is an example of the workshop. You can try find the
>>>>>         >>>>>>>> deadlock if you like. I've shown it to almost 100 good Java
>>>>>         >>>>>>>> developers and
>>>>>         >>>>>>>> so far, not one has found it by themselves. I would expect
>>>>>         that
>>>>>         >>>>>>>> they should
>>>>>         >>>>>>>> find it in 5 minutes. In our workshop they would obviously be
>>>>>         >>>>>>>> helped a bit
>>>>>         >>>>>>>> with hints, so that they can walk away with a good
>>>>>         experience. Use
>>>>>         >>>>>>>> anything
>>>>>         >>>>>>>> you like. Oscilloscope, jstack, jconsole, whatever you
>>>>>         like. Only
>>>>>         >>>>>>>> rule for
>>>>>         >>>>>>>> you guys on the "concurrency-interest" list is: you can
>>>>>         only look at
>>>>>         >>>>>>>> the
>>>>>         >>>>>>>> code once you've found the problem, otherwise it would be
>>>>>         too easy
>>>>>         >>>>>>>> for you
>>>>>         >>>>>>>> :-) Once you have found it, you can also fix the code and
>>>>>         make sure
>>>>>         >>>>>>>> that
>>>>>         >>>>>>>> the code then works correctly.
>>>>>         >>>>>>>> Regards
>>>>>         >>>>>>>>
>>>>>         >>>>>>>> Heinz
>>>>>         >>>>>>>> --
>>>>>         >>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>         >>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>         >>>>>>>> Sun Java Champion
>>>>>         >>>>>>>> IEEE Certified Software Development Professional
>>>>>         >>>>>>>> http://www.javaspecialists.eu <http://www.javaspecialists.eu/>
>>>>>         >>>>>>>> Tel: +30 69 75 595 262
>>>>>         >>>>>>>> Skype: kabutz
>>>>>         >>>>>>>>
>>>>>         >>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>>>         >>>>>>>>>
>>>>>         >>>>>>>>> I am curious as to the intended content of your presentation.
>>>>>         >>>>>>>>> Here's some ideas. I wondering what you are planing on doing.
>>>>>         >>>>>>>>>
>>>>>         >>>>>>>>> 1. Printing the call stacks with lock information using a
>>>>>         tool
>>>>>         >>>>>>>>> such as jstack
>>>>>         >>>>>>>>> 2. Press the "Detect Deadlock" button in JConsole
>>>>>         >>>>>>>>> 3. Dealing with Lock and Condition objects instead of
>>>>>         >>>>>>>>> synchronized blocks
>>>>>         >>>>>>>>> 4. Detecting live lock
>>>>>         >>>>>>>>> 5. Distributed deadlocks
>>>>>         >>>>>>>>>
>>>>>         >>>>>>>>> Nathan Reynolds
>>>>>         >>>>>>>>>
>>>>>         <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>         >>>>>>>>> Consulting
>>>>>         >>>>>>>>> Member of Technical Staff | 602.333.9091
>>>>>         >>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>>>         >>>>>>>>> Technology
>>>>>         >>>>>>>>>
>>>>>         >>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>>>         >>>>>>>>>>
>>>>>         >>>>>>>>>> Good afternoon,
>>>>>         >>>>>>>>>>
>>>>>         >>>>>>>>>> I am thinking of submitting a talk on finding and diagnosing
>>>>>         >>>>>>>>>> deadlocks for JavaOne. It might be a workshop, instead of a
>>>>>         >>>>>>>>>> simple
>>>>>         >>>>>>>>>> conference talk. Or we might be able to turn the talk into a
>>>>>         >>>>>>>>>> workshop where
>>>>>         >>>>>>>>>> they need to find a deadlock in a body of code. Could be
>>>>>         >>>>>>>>>> something
>>>>>         >>>>>>>>>> different, which might go incredibly well or crash in a
>>>>>         blaze of
>>>>>         >>>>>>>>>> flames.
>>>>>         >>>>>>>>>> Would any of you be interested in co-presenting this
>>>>>         with me at
>>>>>         >>>>>>>>>> JavaOne?
>>>>>         >>>>>>>>>>
>>>>>         >>>>>>>>>> Regards
>>>>>         >>>>>>>>>>
>>>>>         >>>>>>>>>> Heinz
>>>>>         >>>>
>>>>>         >>>>
>>>>>         >>>>
>>>>>         >>>> _______________________________________________
>>>>>         >>>> Concurrency-interest mailing list
>>>>>         >>>> Concurrency-interest at cs.oswego.edu
>>>>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>         >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>         >>>
>>>>>         >>>
>>>>>         >>> _______________________________________________
>>>>>         >>> Concurrency-interest mailing list
>>>>>         >>> Concurrency-interest at cs.oswego.edu
>>>>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>         >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>         >>>
>>>>>         >> _______________________________________________
>>>>>         >> Concurrency-interest mailing list
>>>>>         >> Concurrency-interest at cs.oswego.edu
>>>>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>         >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>         >
>>>>>         > _______________________________________________
>>>>>         > Concurrency-interest mailing list
>>>>>         > Concurrency-interest at cs.oswego.edu
>>>>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>         > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>         >
>>>>>
>>>>>         _______________________________________________
>>>>>         Concurrency-interest mailing list
>>>>>         Concurrency-interest at cs.oswego.edu
>>>>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>>     --------------------------------------------------------------------------------
>>>>>
>>>>>     _______________________________________________
>>>>>     Concurrency-interest mailing list
>>>>>     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>>
>>>>     _______________________________________________
>>>>     Concurrency-interest mailing list
>>>>     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>     _______________________________________________
>>>     Concurrency-interest mailing list
>>>     Concurrency-interest at cs.oswego.edu
>>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From dl at cs.oswego.edu  Mon Apr  9 10:16:01 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 09 Apr 2012 10:16:01 -0400
Subject: [concurrency-interest] CountedCompleters
Message-ID: <4F82EF21.4020804@cs.oswego.edu>


After sitting on multiple variations for months, I committed
CountedCompleter, a completion-based flavor of ForkJoinTask.

As mentioned a few times over the past year, the main motivation
is to better support tasks that perform IO or other base
actions that may (or may not) take a lot of time to execute.
As is the case with JDK7 async IO and other completion-based
frameworks, the most common path to efficiency is for such tasks
to arrange continuation actions that occur upon their completion.
The main twist for CountedCompleters is that continuations
might be dependent on multiple actions, not just one. (Or in
other words, the continuations must be preceded by a specialized,
"bottom-up" form of join.)

The CountedCompleter abstract class provides a minimal basis
for these kinds of tasks. While some of the mechanics are
reminiscent of other FJ-like frameworks such as Intel TBB,
CountedCompleters are designed to fit smoothly with other
kinds of ForkJoinTasks (like RecursiveActions), and so still
allow people to use the more pleasant Future-style conventions
rather than count-based bottom-up joining unless they need them.
At the same time, the CountedCompleter class exposes enough
mechanics to allow all sorts of tweaks that people can use
to improve performance.
In particular, in addition to usually being the best way to deal
with IO etc bound tasks, CountedCompleters sometimes fare better
than RecursiveActions in programs that entail lots of garbage
collection because GC can have similar impact on task variability.

Even though targeted for JDK8, versions of CountedCompleter
appear in the jsr166y and main repositories, not jsr166e. This is
because they require a non-public hook into modified ForkJoinTask
exception handling mechanics in order to properly propagate
exceptional completions. For sources, docs, and jar files, see
the usual links at http://gee.cs.oswego.edu/dl/concurrency-interest/index.html

The API docs include more details and some examples:
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html

I also added a few (with more to come) test/demo programs that illustrate
other usages. See CCBoxedLongSort and CCJacobi in
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/

Please try these out. As always, comments and suggestions
(hopefully based on usage experience) would be welcome.

-Doug



From nathan.reynolds at oracle.com  Mon Apr  9 12:43:45 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 09 Apr 2012 09:43:45 -0700
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr>
	<CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com>
	<CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>
Message-ID: <4F8311C1.8030505@oracle.com>

Java Path Finder is great for finding deadlocks and data races.  
However, it has its limitations.

 1. The search space is exponential in the number of threads (i.e. O(2^t
    )).  This program has way too many threads.  One would have to
    reduce the threads to a bare minimum.
 2. The Java Memory Model (i.e. volatile fields) isn't supported.  That
    isn't a problem in this case but something to be aware of.

Otherwise, I rely on Java Path Finder to prove that my code is going to 
work in concurrent situations.  It has found a ton of concurrency bugs 
in my code.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/8/2012 8:23 PM, Mohan Radhakrishnan wrote:
> I could look at the first deadlock by dumping locks and threads. I was 
> planning to find the next one using Java Path Finder but I think it is 
> not recommended for such a big codebase. I am not sure. Its heuristics 
> might take too much memory.
>
> Mohan
>
> On Mon, Apr 9, 2012 at 3:59 AM, <mabrouk2005 at gmail.com 
> <mailto:mabrouk2005 at gmail.com>> wrote:
>
>     Nice exercise Dr Heinz,
>
>     As others mentioned there were 2 kind of deadlocks the first one was
>     very is easy to find via jconsole so likeI thought that was it and
>     went and fixed that but then when ran it again it hang it so I knew
>     thee was more. the interesting thing the jconsole did not detect the
>     AWT deadlock it showed no deadlock even though the app hang. I had to
>     force stack dump and get clues to where is the deadlock. Does anyone
>     have experienced something like this with jconsole not detecting AWT
>     deadlocks?
>
>     Thanks again for the nice exercise and the great java news letter I am
>     a big fan.
>
>     Cheers,
>     Mabrouk
>
>     On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax <forax at univ-mlv.fr
>     <mailto:forax at univ-mlv.fr>> wrote:
>     > No, it's more an AWRY or Java2D bug.
>     >
>     > R?mi
>     >
>     > Sent from my Phone
>     >
>     >
>     > ----- Reply message -----
>     > From: "Ben Evans" <benjamin.john.evans at gmail.com
>     <mailto:benjamin.john.evans at gmail.com>>
>     > To: "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu
>     <mailto:heinz at javaspecialists.eu>>
>     > Cc: "R?mi Forax" <forax at univ-mlv.fr <mailto:forax at univ-mlv.fr>>,
>     <concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>>
>     > Subject: [concurrency-interest] Joint Talk for JavaOne?
>     > Date: Sat, Apr 7, 2012 10:43
>     >
>     >
>     > Heinz, was this with the new jdk8 + lambda build?
>     >
>     > If so, we should report this crash back to lambda-dev.
>     >
>     > Thanks,
>     >
>     > Ben
>     >
>     > On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
>     > <heinz at javaspecialists.eu <mailto:heinz at javaspecialists.eu>> wrote:
>     >> I see JDK8 crashes even with the vanilla Java2Demo from JDK
>     1.6.  I see
>     >> that
>     >> the Java2Demo has been removed from the demos folder of JDK 1.7
>     and 1.8.
>     >>  It
>     >> thus is a Java 8 issue, rather than the changes I made to the code.
>     >>  Thanks
>     >> for the warning R?mi.
>     >>
>     >>
>     >> Regards
>     >>
>     >> Heinz
>     >> --
>     >> Dr Heinz M. Kabutz (PhD CompSci)
>     >> Author of "The Java(tm) Specialists' Newsletter"
>     >> Sun Java Champion
>     >> IEEE Certified Software Development Professional
>     >> http://www.javaspecialists.eu
>     >> Tel: +30 69 75 595 262
>     >> Skype: kabutz
>     >>
>     >>
>     >> On 4/6/12 1:51 AM, R?mi Forax wrote:
>     >>>
>     >>> jdk8 crashes if I click on images of the tapped pane.
>     >>>
>     >>> R?mi
>     >>>
>     >>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
>     >>>>
>     >>>> Yes, you are correct.
>     >>>>
>     >>>> However, the mistake most programmers make is to #1 scratch
>     around in
>     >>>> the
>     >>>> source code to try and discover the problem and #2 then fix
>     it without
>     >>>> really understanding what they are doing.  I think the lesson
>     is bigger
>     >>>> if
>     >>>> we give them the source code.  In addition, it is probably more
>     >>>> difficult to
>     >>>> solve if you have the sources to muse over.
>     >>>> Regards
>     >>>>
>     >>>> Heinz
>     >>>> --
>     >>>> Dr Heinz M. Kabutz (PhD CompSci)
>     >>>> Author of "The Java(tm) Specialists' Newsletter"
>     >>>> Sun Java Champion
>     >>>> IEEE Certified Software Development Professional
>     >>>> http://www.javaspecialists.eu
>     >>>> Tel: +30 69 75 595 262
>     >>>> Skype: kabutz
>     >>>>
>     >>>>
>     >>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>     >>>>>
>     >>>>> I guess it is a good idea to not initially include the
>     source code in
>     >>>>> the workshop because many times I initially don't have the
>     source code
>     >>>>> when
>     >>>>> trying to figure out performance or scalability problems.
>     >>>>>
>     >>>>> Nathan Reynolds
>     >>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>     >>>>> Consulting
>     >>>>> Member of Technical Staff | 602.333.9091
>     >>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>     Technology
>     >>>>>
>     >>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>     >>>>>>
>     >>>>>> Sorry Nathan, here is the zip file including the source
>     code an an Ant
>     >>>>>> script to build the code.  Sorry for accidentally excluding
>     that from
>     >>>>>> the
>     >>>>>> file I sent earlier.  The problem was between the chair and the
>     >>>>>> keyboard.
>     >>>>>>  However, one should be able to pinpoint the deadlock
>     without seeing a
>     >>>>>> line
>     >>>>>> of code.  At the workshop I presented in Spain last week,
>     most of the
>     >>>>>> programmers immediately started delving into the code
>     before they knew
>     >>>>>> where
>     >>>>>> to look.
>     >>>>>> Regards
>     >>>>>>
>     >>>>>> Heinz
>     >>>>>> --
>     >>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>     >>>>>> Author of "The Java(tm) Specialists' Newsletter"
>     >>>>>> Sun Java Champion
>     >>>>>> IEEE Certified Software Development Professional
>     >>>>>> http://www.javaspecialists.eu
>     >>>>>> Tel: +30 69 75 595 262
>     >>>>>> Skype: kabutz
>     >>>>>>
>     >>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>     >>>>>>>
>     >>>>>>> I took the bait and tried out the demo on HotSpot 7 Update
>     3.  It
>     >>>>>>> didn't deadlock for a minute or two.  Then the application
>     froze.  I
>     >>>>>>> then
>     >>>>>>> used jstack to dump the call stacks.  At the end of the
>     report, it
>     >>>>>>> said
>     >>>>>>> "Found one Java-level deadlock".  It then dumped out the
>     locks and
>     >>>>>>> threads
>     >>>>>>> involved in the deadlock.  I never looked at the source
>     code... in
>     >>>>>>> fact it
>     >>>>>>> wasn't in the zip file.  This took about 5-7 minutes from
>     starting
>     >>>>>>> the
>     >>>>>>> application to finding the deadlock in the call stacks.
>     >>>>>>>
>     >>>>>>> A 100 good Java developers?  Really?  I guess I can
>     understand.  Most
>     >>>>>>> engineers don't understand locks.  Most of the time I get
>     answers
>     >>>>>>> like one
>     >>>>>>> should put a lock around shared variables.  This is
>     accurate but they
>     >>>>>>> can't
>     >>>>>>> really go any deeper.
>     >>>>>>>
>     >>>>>>> It sounds like the material of your presentation should be
>     very good.
>     >>>>>>>  It covers things that the deadlock detection tool
>     probably can't
>     >>>>>>> figure
>     >>>>>>> out.
>     >>>>>>>
>     >>>>>>> So, it seems like you have everything figured out.  Why do
>     you need
>     >>>>>>> someone else?
>     >>>>>>>
>     >>>>>>> Nathan Reynolds
>     >>>>>>>
>     <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>     >>>>>>> Consulting
>     >>>>>>> Member of Technical Staff | 602.333.9091
>     >>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>     >>>>>>> Technology
>     >>>>>>>
>     >>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>     >>>>>>>>
>     >>>>>>>> Hi Nathan,
>     >>>>>>>>
>     >>>>>>>> a stack trace will only show you a certain class of obvious
>     >>>>>>>> deadlocks
>     >>>>>>>> that are easy to find and solve.  I remember solving
>     deadlocks
>     >>>>>>>> /before/ we
>     >>>>>>>> had the brilliant deadlock detection tool in the
>     ThreadMXBean.  Yes,
>     >>>>>>>> the
>     >>>>>>>> deadlock detection tool shows you /some/ deadlocks, but
>     definitely
>     >>>>>>>> not all
>     >>>>>>>> of them.  I can think of a bunch that it would not find:
>     >>>>>>>>
>     >>>>>>>> 1. Semaphores running out of permits
>     >>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to
>     read lock
>     >>>>>>>> 3. Resource deadlocks
>     >>>>>>>>
>     >>>>>>>> And some others that I will not describe in detail, such
>     as some
>     >>>>>>>> nasty livelocks that we can cause which will hang up the
>     JVM :-)
>     >>>>>>>>
>     >>>>>>>> I agree with Kirk - it should probably be a 3 hour
>     workshop.  I've
>     >>>>>>>> done this three times now - twice in Spain and once via
>     webinar.
>     >>>>>>>>  The
>     >>>>>>>> workshop would involve some lessons on deadlocks, what
>     causes them
>     >>>>>>>> and how
>     >>>>>>>> we can prevent them.  Also an explanation as to why we
>     see them so
>     >>>>>>>> seldom in
>     >>>>>>>> real production.  I've got material prepared for this
>     workshop.  And
>     >>>>>>>> then a
>     >>>>>>>> practical part to the workshop where they can try to find
>     a deadlock
>     >>>>>>>> in a
>     >>>>>>>> body of code.
>     >>>>>>>>
>     >>>>>>>> Attached is an example of the workshop.  You can try find the
>     >>>>>>>> deadlock if you like.  I've shown it to almost 100 good Java
>     >>>>>>>> developers and
>     >>>>>>>> so far, not one has found it by themselves.  I would
>     expect that
>     >>>>>>>> they should
>     >>>>>>>> find it in 5 minutes.  In our workshop they would
>     obviously be
>     >>>>>>>> helped a bit
>     >>>>>>>> with hints, so that they can walk away with a good
>     experience.  Use
>     >>>>>>>> anything
>     >>>>>>>> you like.  Oscilloscope, jstack, jconsole, whatever you
>     like.  Only
>     >>>>>>>> rule for
>     >>>>>>>> you guys on the "concurrency-interest" list is: you can
>     only look at
>     >>>>>>>> the
>     >>>>>>>> code once you've found the problem, otherwise it would be
>     too easy
>     >>>>>>>> for you
>     >>>>>>>> :-)  Once you have found it, you can also fix the code
>     and make sure
>     >>>>>>>> that
>     >>>>>>>> the code then works correctly.
>     >>>>>>>> Regards
>     >>>>>>>>
>     >>>>>>>> Heinz
>     >>>>>>>> --
>     >>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>     >>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>     >>>>>>>> Sun Java Champion
>     >>>>>>>> IEEE Certified Software Development Professional
>     >>>>>>>> http://www.javaspecialists.eu
>     >>>>>>>> Tel: +30 69 75 595 262
>     >>>>>>>> Skype: kabutz
>     >>>>>>>>
>     >>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>     >>>>>>>>>
>     >>>>>>>>> I am curious as to the intended content of your
>     presentation.
>     >>>>>>>>>  Here's some ideas.  I wondering what you are planing on
>     doing.
>     >>>>>>>>>
>     >>>>>>>>>  1. Printing the call stacks with lock information using
>     a tool
>     >>>>>>>>>    such as jstack
>     >>>>>>>>>  2. Press the "Detect Deadlock" button in JConsole
>     >>>>>>>>>  3. Dealing with Lock and Condition objects instead of
>     >>>>>>>>>    synchronized blocks
>     >>>>>>>>>  4. Detecting live lock
>     >>>>>>>>>  5. Distributed deadlocks
>     >>>>>>>>>
>     >>>>>>>>> Nathan Reynolds
>     >>>>>>>>>
>     <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>     >>>>>>>>> Consulting
>     >>>>>>>>> Member of Technical Staff | 602.333.9091
>     >>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>     >>>>>>>>> Technology
>     >>>>>>>>>
>     >>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>     >>>>>>>>>>
>     >>>>>>>>>> Good afternoon,
>     >>>>>>>>>>
>     >>>>>>>>>> I am thinking of submitting a talk on finding and
>     diagnosing
>     >>>>>>>>>> deadlocks for JavaOne.  It might be a workshop, instead
>     of a
>     >>>>>>>>>> simple
>     >>>>>>>>>> conference talk.  Or we might be able to turn the talk
>     into a
>     >>>>>>>>>> workshop where
>     >>>>>>>>>> they need to find a deadlock in a body of code.  Could be
>     >>>>>>>>>> something
>     >>>>>>>>>> different, which might go incredibly well or crash in a
>     blaze of
>     >>>>>>>>>> flames.
>     >>>>>>>>>>  Would any of you be interested in co-presenting this
>     with me at
>     >>>>>>>>>> JavaOne?
>     >>>>>>>>>>
>     >>>>>>>>>> Regards
>     >>>>>>>>>>
>     >>>>>>>>>> Heinz
>     >>>>
>     >>>>
>     >>>>
>     >>>> _______________________________________________
>     >>>> Concurrency-interest mailing list
>     >>>> Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >>>
>     >>>
>     >>> _______________________________________________
>     >>> Concurrency-interest mailing list
>     >>> Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >>>
>     >> _______________________________________________
>     >> Concurrency-interest mailing list
>     >> Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >
>     > _______________________________________________
>     > Concurrency-interest mailing list
>     > Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120409/a8256ff6/attachment-0001.html>

From Joe.Kearney at gsacapital.com  Tue Apr 10 07:44:58 2012
From: Joe.Kearney at gsacapital.com (Kearney, Joe)
Date: Tue, 10 Apr 2012 12:44:58 +0100
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <4F8311C1.8030505@oracle.com>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr><CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com><CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>
	<4F8311C1.8030505@oracle.com>
Message-ID: <9319F360221C65428EA819A4E8DC34ED03A399B03C@OPMBOX21UK.options-it.com>

Does lack of support for volatile fields render this tool useless for testing non-blocking concurrency and concurrent programs that don't only use synchronized blocks?

In particular does it support locking through LockSupport, AQS and friends - for example does it understand uses of Phaser or CyclicBarrier?

Is there a list somewhere of these limitations? Perhaps these things are spread around the sub-projects.

Thanks,
Joe

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Nathan Reynolds
Sent: 09 April 2012 17:44
To: Mohan Radhakrishnan
Cc: Concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Joint Talk for JavaOne?

Java Path Finder is great for finding deadlocks and data races.  However, it has its limitations.

 1.  The search space is exponential in the number of threads (i.e. O(2t)).  This program has way too many threads.  One would have to reduce the threads to a bare minimum.
 2.  The Java Memory Model (i.e. volatile fields) isn't supported.  That isn't a problem in this case but something to be aware of.

Otherwise, I rely on Java Path Finder to prove that my code is going to work in concurrent situations.  It has found a ton of concurrency bugs in my code.
Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering<http://psr.us.oracle.com/> | Server Technology

On 4/8/2012 8:23 PM, Mohan Radhakrishnan wrote:
I could look at the first deadlock by dumping locks and threads. I was planning to find the next one using Java Path Finder but I think it is not recommended for such a big codebase. I am not sure. Its heuristics might take too much memory.

Mohan
On Mon, Apr 9, 2012 at 3:59 AM, <mabrouk2005 at gmail.com<mailto:mabrouk2005 at gmail.com>> wrote:
Nice exercise Dr Heinz,

As others mentioned there were 2 kind of deadlocks the first one was
very is easy to find via jconsole so likeI thought that was it and
went and fixed that but then when ran it again it hang it so I knew
thee was more. the interesting thing the jconsole did not detect the
AWT deadlock it showed no deadlock even though the app hang. I had to
force stack dump and get clues to where is the deadlock. Does anyone
have experienced something like this with jconsole not detecting AWT
deadlocks?

Thanks again for the nice exercise and the great java news letter I am
a big fan.

Cheers,
Mabrouk

On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax <forax at univ-mlv.fr<mailto:forax at univ-mlv.fr>> wrote:
> No, it's more an AWRY or Java2D bug.
>
> R?mi
>
> Sent from my Phone
>
>
> ----- Reply message -----
> From: "Ben Evans" <benjamin.john.evans at gmail.com<mailto:benjamin.john.evans at gmail.com>>
> To: "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu<mailto:heinz at javaspecialists.eu>>
> Cc: "R?mi Forax" <forax at univ-mlv.fr<mailto:forax at univ-mlv.fr>>, <concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>>
> Subject: [concurrency-interest] Joint Talk for JavaOne?
> Date: Sat, Apr 7, 2012 10:43
>
>
> Heinz, was this with the new jdk8 + lambda build?
>
> If so, we should report this crash back to lambda-dev.
>
> Thanks,
>
> Ben
>
> On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
> <heinz at javaspecialists.eu<mailto:heinz at javaspecialists.eu>> wrote:
>> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6.  I see
>> that
>> the Java2Demo has been removed from the demos folder of JDK 1.7 and 1.8.
>>  It
>> thus is a Java 8 issue, rather than the changes I made to the code.
>>  Thanks
>> for the warning R?mi.
>>
>>
>> Regards
>>
>> Heinz
>> --
>> Dr Heinz M. Kabutz (PhD CompSci)
>> Author of "The Java(tm) Specialists' Newsletter"
>> Sun Java Champion
>> IEEE Certified Software Development Professional
>> http://www.javaspecialists.eu
>> Tel: +30 69 75 595 262
>> Skype: kabutz
>>
>>
>> On 4/6/12 1:51 AM, R?mi Forax wrote:
>>>
>>> jdk8 crashes if I click on images of the tapped pane.
>>>
>>> R?mi
>>>
>>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
>>>>
>>>> Yes, you are correct.
>>>>
>>>> However, the mistake most programmers make is to #1 scratch around in
>>>> the
>>>> source code to try and discover the problem and #2 then fix it without
>>>> really understanding what they are doing.  I think the lesson is bigger
>>>> if
>>>> we give them the source code.  In addition, it is probably more
>>>> difficult to
>>>> solve if you have the sources to muse over.
>>>> Regards
>>>>
>>>> Heinz
>>>> --
>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>> Sun Java Champion
>>>> IEEE Certified Software Development Professional
>>>> http://www.javaspecialists.eu
>>>> Tel: +30 69 75 595 262
>>>> Skype: kabutz
>>>>
>>>>
>>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>>>>>
>>>>> I guess it is a good idea to not initially include the source code in
>>>>> the workshop because many times I initially don't have the source code
>>>>> when
>>>>> trying to figure out performance or scalability problems.
>>>>>
>>>>> Nathan Reynolds
>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>> Consulting
>>>>> Member of Technical Staff | 602.333.9091
>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>>>
>>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>>>>>>
>>>>>> Sorry Nathan, here is the zip file including the source code an an Ant
>>>>>> script to build the code.  Sorry for accidentally excluding that from
>>>>>> the
>>>>>> file I sent earlier.  The problem was between the chair and the
>>>>>> keyboard.
>>>>>>  However, one should be able to pinpoint the deadlock without seeing a
>>>>>> line
>>>>>> of code.  At the workshop I presented in Spain last week, most of the
>>>>>> programmers immediately started delving into the code before they knew
>>>>>> where
>>>>>> to look.
>>>>>> Regards
>>>>>>
>>>>>> Heinz
>>>>>> --
>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>> Sun Java Champion
>>>>>> IEEE Certified Software Development Professional
>>>>>> http://www.javaspecialists.eu
>>>>>> Tel: +30 69 75 595 262
>>>>>> Skype: kabutz
>>>>>>
>>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>>>>>>>
>>>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3.  It
>>>>>>> didn't deadlock for a minute or two.  Then the application froze.  I
>>>>>>> then
>>>>>>> used jstack to dump the call stacks.  At the end of the report, it
>>>>>>> said
>>>>>>> "Found one Java-level deadlock".  It then dumped out the locks and
>>>>>>> threads
>>>>>>> involved in the deadlock.  I never looked at the source code... in
>>>>>>> fact it
>>>>>>> wasn't in the zip file.  This took about 5-7 minutes from starting
>>>>>>> the
>>>>>>> application to finding the deadlock in the call stacks.
>>>>>>>
>>>>>>> A 100 good Java developers?  Really?  I guess I can understand.  Most
>>>>>>> engineers don't understand locks.  Most of the time I get answers
>>>>>>> like one
>>>>>>> should put a lock around shared variables.  This is accurate but they
>>>>>>> can't
>>>>>>> really go any deeper.
>>>>>>>
>>>>>>> It sounds like the material of your presentation should be very good.
>>>>>>>  It covers things that the deadlock detection tool probably can't
>>>>>>> figure
>>>>>>> out.
>>>>>>>
>>>>>>> So, it seems like you have everything figured out.  Why do you need
>>>>>>> someone else?
>>>>>>>
>>>>>>> Nathan Reynolds
>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>>> Consulting
>>>>>>> Member of Technical Staff | 602.333.9091
>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>>>>> Technology
>>>>>>>
>>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>>>>>>>
>>>>>>>> Hi Nathan,
>>>>>>>>
>>>>>>>> a stack trace will only show you a certain class of obvious
>>>>>>>> deadlocks
>>>>>>>> that are easy to find and solve.  I remember solving deadlocks
>>>>>>>> /before/ we
>>>>>>>> had the brilliant deadlock detection tool in the ThreadMXBean.  Yes,
>>>>>>>> the
>>>>>>>> deadlock detection tool shows you /some/ deadlocks, but definitely
>>>>>>>> not all
>>>>>>>> of them.  I can think of a bunch that it would not find:
>>>>>>>>
>>>>>>>> 1. Semaphores running out of permits
>>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>>>>>>>> 3. Resource deadlocks
>>>>>>>>
>>>>>>>> And some others that I will not describe in detail, such as some
>>>>>>>> nasty livelocks that we can cause which will hang up the JVM :-)
>>>>>>>>
>>>>>>>> I agree with Kirk - it should probably be a 3 hour workshop.  I've
>>>>>>>> done this three times now - twice in Spain and once via webinar.
>>>>>>>>  The
>>>>>>>> workshop would involve some lessons on deadlocks, what causes them
>>>>>>>> and how
>>>>>>>> we can prevent them.  Also an explanation as to why we see them so
>>>>>>>> seldom in
>>>>>>>> real production.  I've got material prepared for this workshop.  And
>>>>>>>> then a
>>>>>>>> practical part to the workshop where they can try to find a deadlock
>>>>>>>> in a
>>>>>>>> body of code.
>>>>>>>>
>>>>>>>> Attached is an example of the workshop.  You can try find the
>>>>>>>> deadlock if you like.  I've shown it to almost 100 good Java
>>>>>>>> developers and
>>>>>>>> so far, not one has found it by themselves.  I would expect that
>>>>>>>> they should
>>>>>>>> find it in 5 minutes.  In our workshop they would obviously be
>>>>>>>> helped a bit
>>>>>>>> with hints, so that they can walk away with a good experience.  Use
>>>>>>>> anything
>>>>>>>> you like.  Oscilloscope, jstack, jconsole, whatever you like.  Only
>>>>>>>> rule for
>>>>>>>> you guys on the "concurrency-interest" list is: you can only look at
>>>>>>>> the
>>>>>>>> code once you've found the problem, otherwise it would be too easy
>>>>>>>> for you
>>>>>>>> :-)  Once you have found it, you can also fix the code and make sure
>>>>>>>> that
>>>>>>>> the code then works correctly.
>>>>>>>> Regards
>>>>>>>>
>>>>>>>> Heinz
>>>>>>>> --
>>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>>>> Sun Java Champion
>>>>>>>> IEEE Certified Software Development Professional
>>>>>>>> http://www.javaspecialists.eu
>>>>>>>> Tel: +30 69 75 595 262
>>>>>>>> Skype: kabutz
>>>>>>>>
>>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>>>>>>>
>>>>>>>>> I am curious as to the intended content of your presentation.
>>>>>>>>>  Here's some ideas.  I wondering what you are planing on doing.
>>>>>>>>>
>>>>>>>>>  1. Printing the call stacks with lock information using a tool
>>>>>>>>>    such as jstack
>>>>>>>>>  2. Press the "Detect Deadlock" button in JConsole
>>>>>>>>>  3. Dealing with Lock and Condition objects instead of
>>>>>>>>>    synchronized blocks
>>>>>>>>>  4. Detecting live lock
>>>>>>>>>  5. Distributed deadlocks
>>>>>>>>>
>>>>>>>>> Nathan Reynolds
>>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>>>>> Consulting
>>>>>>>>> Member of Technical Staff | 602.333.9091
>>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>>>>>>> Technology
>>>>>>>>>
>>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>>>>>>>>
>>>>>>>>>> Good afternoon,
>>>>>>>>>>
>>>>>>>>>> I am thinking of submitting a talk on finding and diagnosing
>>>>>>>>>> deadlocks for JavaOne.  It might be a workshop, instead of a
>>>>>>>>>> simple
>>>>>>>>>> conference talk.  Or we might be able to turn the talk into a
>>>>>>>>>> workshop where
>>>>>>>>>> they need to find a deadlock in a body of code.  Could be
>>>>>>>>>> something
>>>>>>>>>> different, which might go incredibly well or crash in a blaze of
>>>>>>>>>> flames.
>>>>>>>>>>  Would any of you be interested in co-presenting this with me at
>>>>>>>>>> JavaOne?
>>>>>>>>>>
>>>>>>>>>> Regards
>>>>>>>>>>
>>>>>>>>>> Heinz
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest





_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest


This email and any files transmitted with it contain confidential and proprietary information and is solely for the use of the intended recipient.  If you are not the intended recipient please return the email to the sender and delete it from your computer and you must not use, disclose, distribute, copy, print or rely on this email or its contents.  This communication is for informational purposes only.  It is not intended as an offer or solicitation for the purchase or sale of any financial instrument or as an official confirmation of any transaction.   Any comments or statements made herein do not necessarily reflect those of GSA Capital. GSA Capital Partners LLP is authorised and regulated by the Financial Services Authority and is registered in England and Wales at Stratton House, 5 Stratton Street, London W1J 8LA, number OC309261. GSA Capital Services Limited is registered in England and Wales at the same address, number 5320529.


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120410/196f40e9/attachment-0001.html>

From sanders at cise.ufl.edu  Tue Apr 10 08:52:13 2012
From: sanders at cise.ufl.edu (Beverly Sanders)
Date: Tue, 10 Apr 2012 08:52:13 -0400
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
	Issue 19
In-Reply-To: <mailman.100.1334058314.3324.concurrency-interest@cs.oswego.edu>
References: <mailman.100.1334058314.3324.concurrency-interest@cs.oswego.edu>
Message-ID: <16982a6c25f2afdfb1a8b3dff0337218.squirrel@webmail.cise.ufl.edu>


There is an extension to java pathfinder that can precisely detect data
races as defined by the JMM, and thus works for lock-free algorithms that
use volatiles and atomics.

http://babelfish.arc.nasa.gov/trac/jpf/wiki/projects/jpf-racefinder

I'm not sure if the tool has kept up with the latest changes to jpf, but
expressions of interest could encourage that to happen.

Generally, you would want to to check your program with standard JPF
first, then use jpf-racefinder to make sure there are no data races.  If
the program is data-race free, then standard JPF is sound.

(If you are intersted in using JPF to reason about Java programs that
intentionally have, presumably benign, data races, please contact me.  See
the paper by Jin, Yavuz-Khaveci and Sanders in TACAS'12)


On Tue, April 10, 2012 7:45 am, concurrency-interest-request at cs.oswego.edu
wrote:
> Send Concurrency-interest mailing list submissions to
> 	concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
> 	http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
> 	concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
> 	concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>    1. Re: Joint Talk for JavaOne? (Kearney, Joe)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Tue, 10 Apr 2012 12:44:58 +0100
> From: "Kearney, Joe" <Joe.Kearney at gsacapital.com>
> To: Nathan Reynolds <nathan.reynolds at oracle.com>
> Cc: "Concurrency-interest at cs.oswego.edu"
> 	<Concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Joint Talk for JavaOne?
> Message-ID:
> 	<9319F360221C65428EA819A4E8DC34ED03A399B03C at OPMBOX21UK.options-it.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Does lack of support for volatile fields render this tool useless for
> testing non-blocking concurrency and concurrent programs that don't only
> use synchronized blocks?
>
> In particular does it support locking through LockSupport, AQS and friends
> - for example does it understand uses of Phaser or CyclicBarrier?
>
> Is there a list somewhere of these limitations? Perhaps these things are
> spread around the sub-projects.
>
> Thanks,
> Joe
>
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Nathan
> Reynolds
> Sent: 09 April 2012 17:44
> To: Mohan Radhakrishnan
> Cc: Concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Joint Talk for JavaOne?
>
> Java Path Finder is great for finding deadlocks and data races.  However,
> it has its limitations.
>
>  1.  The search space is exponential in the number of threads (i.e.
> O(2t)).  This program has way too many threads.  One would have to reduce
> the threads to a bare minimum.
>  2.  The Java Memory Model (i.e. volatile fields) isn't supported.  That
> isn't a problem in this case but something to be aware of.
>
> Otherwise, I rely on Java Path Finder to prove that my code is going to
> work in concurrent situations.  It has found a ton of concurrency bugs in
> my code.
> Nathan
> Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering<http://psr.us.oracle.com/> | Server Technology
>
> On 4/8/2012 8:23 PM, Mohan Radhakrishnan wrote:
> I could look at the first deadlock by dumping locks and threads. I was
> planning to find the next one using Java Path Finder but I think it is not
> recommended for such a big codebase. I am not sure. Its heuristics might
> take too much memory.
>
> Mohan
> On Mon, Apr 9, 2012 at 3:59 AM,
> <mabrouk2005 at gmail.com<mailto:mabrouk2005 at gmail.com>> wrote:
> Nice exercise Dr Heinz,
>
> As others mentioned there were 2 kind of deadlocks the first one was
> very is easy to find via jconsole so likeI thought that was it and
> went and fixed that but then when ran it again it hang it so I knew
> thee was more. the interesting thing the jconsole did not detect the
> AWT deadlock it showed no deadlock even though the app hang. I had to
> force stack dump and get clues to where is the deadlock. Does anyone
> have experienced something like this with jconsole not detecting AWT
> deadlocks?
>
> Thanks again for the nice exercise and the great java news letter I am
> a big fan.
>
> Cheers,
> Mabrouk
>
> On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax
> <forax at univ-mlv.fr<mailto:forax at univ-mlv.fr>> wrote:
>> No, it's more an AWRY or Java2D bug.
>>
>> R?mi
>>
>> Sent from my Phone
>>
>>
>> ----- Reply message -----
>> From: "Ben Evans"
>> <benjamin.john.evans at gmail.com<mailto:benjamin.john.evans at gmail.com>>
>> To: "Dr Heinz M. Kabutz"
>> <heinz at javaspecialists.eu<mailto:heinz at javaspecialists.eu>>
>> Cc: "R?mi Forax" <forax at univ-mlv.fr<mailto:forax at univ-mlv.fr>>,
>> <concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>>
>> Subject: [concurrency-interest] Joint Talk for JavaOne?
>> Date: Sat, Apr 7, 2012 10:43
>>
>>
>> Heinz, was this with the new jdk8 + lambda build?
>>
>> If so, we should report this crash back to lambda-dev.
>>
>> Thanks,
>>
>> Ben
>>
>> On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
>> <heinz at javaspecialists.eu<mailto:heinz at javaspecialists.eu>> wrote:
>>> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6.  I see
>>> that
>>> the Java2Demo has been removed from the demos folder of JDK 1.7 and
>>> 1.8.
>>>  It
>>> thus is a Java 8 issue, rather than the changes I made to the code.
>>>  Thanks
>>> for the warning R?mi.
>>>
>>>
>>> Regards
>>>
>>> Heinz
>>> --
>>> Dr Heinz M. Kabutz (PhD CompSci)
>>> Author of "The Java(tm) Specialists' Newsletter"
>>> Sun Java Champion
>>> IEEE Certified Software Development Professional
>>> http://www.javaspecialists.eu
>>> Tel: +30 69 75 595 262
>>> Skype: kabutz
>>>
>>>
>>> On 4/6/12 1:51 AM, R?mi Forax wrote:
>>>>
>>>> jdk8 crashes if I click on images of the tapped pane.
>>>>
>>>> R?mi
>>>>
>>>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
>>>>>
>>>>> Yes, you are correct.
>>>>>
>>>>> However, the mistake most programmers make is to #1 scratch around in
>>>>> the
>>>>> source code to try and discover the problem and #2 then fix it
>>>>> without
>>>>> really understanding what they are doing.  I think the lesson is
>>>>> bigger
>>>>> if
>>>>> we give them the source code.  In addition, it is probably more
>>>>> difficult to
>>>>> solve if you have the sources to muse over.
>>>>> Regards
>>>>>
>>>>> Heinz
>>>>> --
>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>> Sun Java Champion
>>>>> IEEE Certified Software Development Professional
>>>>> http://www.javaspecialists.eu
>>>>> Tel: +30 69 75 595 262
>>>>> Skype: kabutz
>>>>>
>>>>>
>>>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>>>>>>
>>>>>> I guess it is a good idea to not initially include the source code
>>>>>> in
>>>>>> the workshop because many times I initially don't have the source
>>>>>> code
>>>>>> when
>>>>>> trying to figure out performance or scalability problems.
>>>>>>
>>>>>> Nathan Reynolds
>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>> Consulting
>>>>>> Member of Technical Staff | 602.333.9091
>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>>>> Technology
>>>>>>
>>>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>>>>>>>
>>>>>>> Sorry Nathan, here is the zip file including the source code an an
>>>>>>> Ant
>>>>>>> script to build the code.  Sorry for accidentally excluding that
>>>>>>> from
>>>>>>> the
>>>>>>> file I sent earlier.  The problem was between the chair and the
>>>>>>> keyboard.
>>>>>>>  However, one should be able to pinpoint the deadlock without
>>>>>>> seeing a
>>>>>>> line
>>>>>>> of code.  At the workshop I presented in Spain last week, most of
>>>>>>> the
>>>>>>> programmers immediately started delving into the code before they
>>>>>>> knew
>>>>>>> where
>>>>>>> to look.
>>>>>>> Regards
>>>>>>>
>>>>>>> Heinz
>>>>>>> --
>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>>> Sun Java Champion
>>>>>>> IEEE Certified Software Development Professional
>>>>>>> http://www.javaspecialists.eu
>>>>>>> Tel: +30 69 75 595 262
>>>>>>> Skype: kabutz
>>>>>>>
>>>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>>>>>>>>
>>>>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3.  It
>>>>>>>> didn't deadlock for a minute or two.  Then the application froze.
>>>>>>>> I
>>>>>>>> then
>>>>>>>> used jstack to dump the call stacks.  At the end of the report, it
>>>>>>>> said
>>>>>>>> "Found one Java-level deadlock".  It then dumped out the locks and
>>>>>>>> threads
>>>>>>>> involved in the deadlock.  I never looked at the source code... in
>>>>>>>> fact it
>>>>>>>> wasn't in the zip file.  This took about 5-7 minutes from starting
>>>>>>>> the
>>>>>>>> application to finding the deadlock in the call stacks.
>>>>>>>>
>>>>>>>> A 100 good Java developers?  Really?  I guess I can understand.
>>>>>>>> Most
>>>>>>>> engineers don't understand locks.  Most of the time I get answers
>>>>>>>> like one
>>>>>>>> should put a lock around shared variables.  This is accurate but
>>>>>>>> they
>>>>>>>> can't
>>>>>>>> really go any deeper.
>>>>>>>>
>>>>>>>> It sounds like the material of your presentation should be very
>>>>>>>> good.
>>>>>>>>  It covers things that the deadlock detection tool probably can't
>>>>>>>> figure
>>>>>>>> out.
>>>>>>>>
>>>>>>>> So, it seems like you have everything figured out.  Why do you
>>>>>>>> need
>>>>>>>> someone else?
>>>>>>>>
>>>>>>>> Nathan Reynolds
>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>>>> Consulting
>>>>>>>> Member of Technical Staff | 602.333.9091
>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>>>>>> Technology
>>>>>>>>
>>>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>>>>>>>>
>>>>>>>>> Hi Nathan,
>>>>>>>>>
>>>>>>>>> a stack trace will only show you a certain class of obvious
>>>>>>>>> deadlocks
>>>>>>>>> that are easy to find and solve.  I remember solving deadlocks
>>>>>>>>> /before/ we
>>>>>>>>> had the brilliant deadlock detection tool in the ThreadMXBean.
>>>>>>>>> Yes,
>>>>>>>>> the
>>>>>>>>> deadlock detection tool shows you /some/ deadlocks, but
>>>>>>>>> definitely
>>>>>>>>> not all
>>>>>>>>> of them.  I can think of a bunch that it would not find:
>>>>>>>>>
>>>>>>>>> 1. Semaphores running out of permits
>>>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
>>>>>>>>> 3. Resource deadlocks
>>>>>>>>>
>>>>>>>>> And some others that I will not describe in detail, such as some
>>>>>>>>> nasty livelocks that we can cause which will hang up the JVM :-)
>>>>>>>>>
>>>>>>>>> I agree with Kirk - it should probably be a 3 hour workshop.
>>>>>>>>> I've
>>>>>>>>> done this three times now - twice in Spain and once via webinar.
>>>>>>>>>  The
>>>>>>>>> workshop would involve some lessons on deadlocks, what causes
>>>>>>>>> them
>>>>>>>>> and how
>>>>>>>>> we can prevent them.  Also an explanation as to why we see them
>>>>>>>>> so
>>>>>>>>> seldom in
>>>>>>>>> real production.  I've got material prepared for this workshop.
>>>>>>>>> And
>>>>>>>>> then a
>>>>>>>>> practical part to the workshop where they can try to find a
>>>>>>>>> deadlock
>>>>>>>>> in a
>>>>>>>>> body of code.
>>>>>>>>>
>>>>>>>>> Attached is an example of the workshop.  You can try find the
>>>>>>>>> deadlock if you like.  I've shown it to almost 100 good Java
>>>>>>>>> developers and
>>>>>>>>> so far, not one has found it by themselves.  I would expect that
>>>>>>>>> they should
>>>>>>>>> find it in 5 minutes.  In our workshop they would obviously be
>>>>>>>>> helped a bit
>>>>>>>>> with hints, so that they can walk away with a good experience.
>>>>>>>>> Use
>>>>>>>>> anything
>>>>>>>>> you like.  Oscilloscope, jstack, jconsole, whatever you like.
>>>>>>>>> Only
>>>>>>>>> rule for
>>>>>>>>> you guys on the "concurrency-interest" list is: you can only look
>>>>>>>>> at
>>>>>>>>> the
>>>>>>>>> code once you've found the problem, otherwise it would be too
>>>>>>>>> easy
>>>>>>>>> for you
>>>>>>>>> :-)  Once you have found it, you can also fix the code and make
>>>>>>>>> sure
>>>>>>>>> that
>>>>>>>>> the code then works correctly.
>>>>>>>>> Regards
>>>>>>>>>
>>>>>>>>> Heinz
>>>>>>>>> --
>>>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>>>>> Sun Java Champion
>>>>>>>>> IEEE Certified Software Development Professional
>>>>>>>>> http://www.javaspecialists.eu
>>>>>>>>> Tel: +30 69 75 595 262
>>>>>>>>> Skype: kabutz
>>>>>>>>>
>>>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>>>>>>>>
>>>>>>>>>> I am curious as to the intended content of your presentation.
>>>>>>>>>>  Here's some ideas.  I wondering what you are planing on doing.
>>>>>>>>>>
>>>>>>>>>>  1. Printing the call stacks with lock information using a tool
>>>>>>>>>>    such as jstack
>>>>>>>>>>  2. Press the "Detect Deadlock" button in JConsole
>>>>>>>>>>  3. Dealing with Lock and Condition objects instead of
>>>>>>>>>>    synchronized blocks
>>>>>>>>>>  4. Detecting live lock
>>>>>>>>>>  5. Distributed deadlocks
>>>>>>>>>>
>>>>>>>>>> Nathan Reynolds
>>>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>>>>>> Consulting
>>>>>>>>>> Member of Technical Staff | 602.333.9091
>>>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>>>>>>>> Technology
>>>>>>>>>>
>>>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>>>>>>>>>
>>>>>>>>>>> Good afternoon,
>>>>>>>>>>>
>>>>>>>>>>> I am thinking of submitting a talk on finding and diagnosing
>>>>>>>>>>> deadlocks for JavaOne.  It might be a workshop, instead of a
>>>>>>>>>>> simple
>>>>>>>>>>> conference talk.  Or we might be able to turn the talk into a
>>>>>>>>>>> workshop where
>>>>>>>>>>> they need to find a deadlock in a body of code.  Could be
>>>>>>>>>>> something
>>>>>>>>>>> different, which might go incredibly well or crash in a blaze
>>>>>>>>>>> of
>>>>>>>>>>> flames.
>>>>>>>>>>>  Would any of you be interested in co-presenting this with me
>>>>>>>>>>> at
>>>>>>>>>>> JavaOne?
>>>>>>>>>>>
>>>>>>>>>>> Regards
>>>>>>>>>>>
>>>>>>>>>>> Heinz
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> _______________________________________________
>
> Concurrency-interest mailing list
>
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> This email and any files transmitted with it contain confidential and
> proprietary information and is solely for the use of the intended
> recipient.  If you are not the intended recipient please return the email
> to the sender and delete it from your computer and you must not use,
> disclose, distribute, copy, print or rely on this email or its contents.
> This communication is for informational purposes only.  It is not intended
> as an offer or solicitation for the purchase or sale of any financial
> instrument or as an official confirmation of any transaction.   Any
> comments or statements made herein do not necessarily reflect those of GSA
> Capital. GSA Capital Partners LLP is authorised and regulated by the
> Financial Services Authority and is registered in England and Wales at
> Stratton House, 5 Stratton Street, London W1J 8LA, number OC309261. GSA
> Capital Services Limited is registered in England and Wales at the same
> address, number 5320529.
>
>
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL:
> <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120410/196f40e9/attachment.html>
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 87, Issue 19
> ****************************************************
>
>


-- 
Beverly A. Sanders, Ph.D.
Associate Professor
Department of Computer & Information Science & Engineering
P.O. Box 116120
University of Florida
Gainesville, FL 32611-6120
www.cise.ufl.edu/~sanders
tel: (352) 505-1563
fax: (352) 392-1220


From nathan.reynolds at oracle.com  Tue Apr 10 12:25:20 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 10 Apr 2012 09:25:20 -0700
Subject: [concurrency-interest] Joint Talk for JavaOne?
In-Reply-To: <9319F360221C65428EA819A4E8DC34ED03A399B03C@OPMBOX21UK.options-it.com>
References: <201204071142.q37Bg5r9020649@monge.univ-mlv.fr><CABV5wh_DdxoOMvLRJsoak1-9BiCWPmzNj_RZneCNZYC_kkTuMQ@mail.gmail.com><CAOoXFP_WNffPnBPRRb9s7K66c-GnU8mX+uW1i2Qf+465vG=UDw@mail.gmail.com>
	<4F8311C1.8030505@oracle.com>
	<9319F360221C65428EA819A4E8DC34ED03A399B03C@OPMBOX21UK.options-it.com>
Message-ID: <4F845EF0.2060303@oracle.com>

Consider a ring FIFO buffer with only 1 reader and 1 writer thread.  
This can be implemented using volatiles for the read and write indexes.  
At some point, the reader thread is going to load the write index.  Java 
Path Finder will flag a problem if it can find a thread interleaving 
where the reader thread is loading the write index and the writer thread 
is storing the write index.  The code is thread safe but Java Path 
Finder doesn't like it.  The workaround is to use a AtomicInteger's or 
AtomicIntegerFieldUpdater's get() and set() for Java Path Finder testing.

jpf-racefinder is a sub-project which addresses the problem of Java 
relaxed memory model (i.e. JDK 5).  I played with this about 2 years ago 
and it needed an maintenance update to work with the current version of 
Java Path Finder.  The web pages for it have been updated so it might be 
usable now.  See the example on this page for the problem it solves.  
http://www.cise.ufl.edu/research/JavaRacefinder/Java_RaceFinder/JRF_Home.html  
It seems like that the ring buffer example above would work just fine.

Java Path Finder probably supports all of java.util.concurrent.  The 
difficulty with these classes is state explosion because of all the 
different ways threads can interact within these classes.  
jpf-concurrent is a sub-project which has custom implementations of 
these classes.  These custom implementations use special Java Path 
Finder APIs to reduce or eliminate state explosion.  This is a two-edge 
sword though.  Sometimes you need some state explosion in order for your 
code to be fully tested.  Java Path Finder can be customized for these 
needs.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/10/2012 4:44 AM, Kearney, Joe wrote:
>
> Does lack of support for volatile fields render this tool useless for 
> testing non-blocking concurrency and concurrent programs that don't 
> only use synchronized blocks?
>
> In particular does it support locking through LockSupport, AQS and 
> friends -- for example does it understand uses of Phaser or CyclicBarrier?
>
> Is there a list somewhere of these limitations? Perhaps these things 
> are spread around the sub-projects.
>
> Thanks,
>
> Joe
>
> *From:*concurrency-interest-bounces at cs.oswego.edu 
> [mailto:concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of 
> *Nathan Reynolds
> *Sent:* 09 April 2012 17:44
> *To:* Mohan Radhakrishnan
> *Cc:* Concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Joint Talk for JavaOne?
>
> Java Path Finder is great for finding deadlocks and data races.  
> However, it has its limitations.
>
>  1. The search space is exponential in the number of threads (i.e.
>     O(2^t )).  This program has way too many threads.  One would have
>     to reduce the threads to a bare minimum.
>  2. The Java Memory Model (i.e. volatile fields) isn't supported. 
>     That isn't a problem in this case but something to be aware of.
>
> Otherwise, I rely on Java Path Finder to prove that my code is going 
> to work in concurrent situations.  It has found a ton of concurrency 
> bugs in my code.
>
> Nathan Reynolds 
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
> Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
>
> On 4/8/2012 8:23 PM, Mohan Radhakrishnan wrote:
>
> I could look at the first deadlock by dumping locks and threads. I was 
> planning to find the next one using Java Path Finder but I think it is 
> not recommended for such a big codebase. I am not sure. Its heuristics 
> might take too much memory.
>
> Mohan
>
> On Mon, Apr 9, 2012 at 3:59 AM, <mabrouk2005 at gmail.com 
> <mailto:mabrouk2005 at gmail.com>> wrote:
>
> Nice exercise Dr Heinz,
>
> As others mentioned there were 2 kind of deadlocks the first one was
> very is easy to find via jconsole so likeI thought that was it and
> went and fixed that but then when ran it again it hang it so I knew
> thee was more. the interesting thing the jconsole did not detect the
> AWT deadlock it showed no deadlock even though the app hang. I had to
> force stack dump and get clues to where is the deadlock. Does anyone
> have experienced something like this with jconsole not detecting AWT
> deadlocks?
>
> Thanks again for the nice exercise and the great java news letter I am
> a big fan.
>
> Cheers,
> Mabrouk
>
>
> On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax <forax at univ-mlv.fr 
> <mailto:forax at univ-mlv.fr>> wrote:
> > No, it's more an AWRY or Java2D bug.
> >
> > R?mi
> >
> > Sent from my Phone
> >
> >
> > ----- Reply message -----
> > From: "Ben Evans" <benjamin.john.evans at gmail.com 
> <mailto:benjamin.john.evans at gmail.com>>
> > To: "Dr Heinz M. Kabutz" <heinz at javaspecialists.eu 
> <mailto:heinz at javaspecialists.eu>>
> > Cc: "R?mi Forax" <forax at univ-mlv.fr <mailto:forax at univ-mlv.fr>>, 
> <concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>>
> > Subject: [concurrency-interest] Joint Talk for JavaOne?
> > Date: Sat, Apr 7, 2012 10:43
> >
> >
> > Heinz, was this with the new jdk8 + lambda build?
> >
> > If so, we should report this crash back to lambda-dev.
> >
> > Thanks,
> >
> > Ben
> >
> > On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
> > <heinz at javaspecialists.eu <mailto:heinz at javaspecialists.eu>> wrote:
> >> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6.  I see
> >> that
> >> the Java2Demo has been removed from the demos folder of JDK 1.7 and 
> 1.8.
> >>  It
> >> thus is a Java 8 issue, rather than the changes I made to the code.
> >>  Thanks
> >> for the warning R?mi.
> >>
> >>
> >> Regards
> >>
> >> Heinz
> >> --
> >> Dr Heinz M. Kabutz (PhD CompSci)
> >> Author of "The Java(tm) Specialists' Newsletter"
> >> Sun Java Champion
> >> IEEE Certified Software Development Professional
> >> http://www.javaspecialists.eu
> >> Tel: +30 69 75 595 262
> >> Skype: kabutz
> >>
> >>
> >> On 4/6/12 1:51 AM, R?mi Forax wrote:
> >>>
> >>> jdk8 crashes if I click on images of the tapped pane.
> >>>
> >>> R?mi
> >>>
> >>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
> >>>>
> >>>> Yes, you are correct.
> >>>>
> >>>> However, the mistake most programmers make is to #1 scratch around in
> >>>> the
> >>>> source code to try and discover the problem and #2 then fix it 
> without
> >>>> really understanding what they are doing.  I think the lesson is 
> bigger
> >>>> if
> >>>> we give them the source code.  In addition, it is probably more
> >>>> difficult to
> >>>> solve if you have the sources to muse over.
> >>>> Regards
> >>>>
> >>>> Heinz
> >>>> --
> >>>> Dr Heinz M. Kabutz (PhD CompSci)
> >>>> Author of "The Java(tm) Specialists' Newsletter"
> >>>> Sun Java Champion
> >>>> IEEE Certified Software Development Professional
> >>>> http://www.javaspecialists.eu
> >>>> Tel: +30 69 75 595 262
> >>>> Skype: kabutz
> >>>>
> >>>>
> >>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
> >>>>>
> >>>>> I guess it is a good idea to not initially include the source 
> code in
> >>>>> the workshop because many times I initially don't have the 
> source code
> >>>>> when
> >>>>> trying to figure out performance or scalability problems.
> >>>>>
> >>>>> Nathan Reynolds
> >>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> >>>>> Consulting
> >>>>> Member of Technical Staff | 602.333.9091
> >>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server 
> Technology
> >>>>>
> >>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
> >>>>>>
> >>>>>> Sorry Nathan, here is the zip file including the source code an 
> an Ant
> >>>>>> script to build the code.  Sorry for accidentally excluding 
> that from
> >>>>>> the
> >>>>>> file I sent earlier.  The problem was between the chair and the
> >>>>>> keyboard.
> >>>>>>  However, one should be able to pinpoint the deadlock without 
> seeing a
> >>>>>> line
> >>>>>> of code.  At the workshop I presented in Spain last week, most 
> of the
> >>>>>> programmers immediately started delving into the code before 
> they knew
> >>>>>> where
> >>>>>> to look.
> >>>>>> Regards
> >>>>>>
> >>>>>> Heinz
> >>>>>> --
> >>>>>> Dr Heinz M. Kabutz (PhD CompSci)
> >>>>>> Author of "The Java(tm) Specialists' Newsletter"
> >>>>>> Sun Java Champion
> >>>>>> IEEE Certified Software Development Professional
> >>>>>> http://www.javaspecialists.eu
> >>>>>> Tel: +30 69 75 595 262
> >>>>>> Skype: kabutz
> >>>>>>
> >>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
> >>>>>>>
> >>>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3.  It
> >>>>>>> didn't deadlock for a minute or two.  Then the application 
> froze.  I
> >>>>>>> then
> >>>>>>> used jstack to dump the call stacks.  At the end of the report, it
> >>>>>>> said
> >>>>>>> "Found one Java-level deadlock".  It then dumped out the locks and
> >>>>>>> threads
> >>>>>>> involved in the deadlock.  I never looked at the source code... in
> >>>>>>> fact it
> >>>>>>> wasn't in the zip file.  This took about 5-7 minutes from starting
> >>>>>>> the
> >>>>>>> application to finding the deadlock in the call stacks.
> >>>>>>>
> >>>>>>> A 100 good Java developers?  Really?  I guess I can 
> understand.  Most
> >>>>>>> engineers don't understand locks.  Most of the time I get answers
> >>>>>>> like one
> >>>>>>> should put a lock around shared variables.  This is accurate 
> but they
> >>>>>>> can't
> >>>>>>> really go any deeper.
> >>>>>>>
> >>>>>>> It sounds like the material of your presentation should be 
> very good.
> >>>>>>>  It covers things that the deadlock detection tool probably can't
> >>>>>>> figure
> >>>>>>> out.
> >>>>>>>
> >>>>>>> So, it seems like you have everything figured out.  Why do you 
> need
> >>>>>>> someone else?
> >>>>>>>
> >>>>>>> Nathan Reynolds
> >>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> >>>>>>> Consulting
> >>>>>>> Member of Technical Staff | 602.333.9091
> >>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
> >>>>>>> Technology
> >>>>>>>
> >>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
> >>>>>>>>
> >>>>>>>> Hi Nathan,
> >>>>>>>>
> >>>>>>>> a stack trace will only show you a certain class of obvious
> >>>>>>>> deadlocks
> >>>>>>>> that are easy to find and solve.  I remember solving deadlocks
> >>>>>>>> /before/ we
> >>>>>>>> had the brilliant deadlock detection tool in the 
> ThreadMXBean.  Yes,
> >>>>>>>> the
> >>>>>>>> deadlock detection tool shows you /some/ deadlocks, but 
> definitely
> >>>>>>>> not all
> >>>>>>>> of them.  I can think of a bunch that it would not find:
> >>>>>>>>
> >>>>>>>> 1. Semaphores running out of permits
> >>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read lock
> >>>>>>>> 3. Resource deadlocks
> >>>>>>>>
> >>>>>>>> And some others that I will not describe in detail, such as some
> >>>>>>>> nasty livelocks that we can cause which will hang up the JVM :-)
> >>>>>>>>
> >>>>>>>> I agree with Kirk - it should probably be a 3 hour workshop. 
>  I've
> >>>>>>>> done this three times now - twice in Spain and once via webinar.
> >>>>>>>>  The
> >>>>>>>> workshop would involve some lessons on deadlocks, what causes 
> them
> >>>>>>>> and how
> >>>>>>>> we can prevent them.  Also an explanation as to why we see 
> them so
> >>>>>>>> seldom in
> >>>>>>>> real production.  I've got material prepared for this 
> workshop.  And
> >>>>>>>> then a
> >>>>>>>> practical part to the workshop where they can try to find a 
> deadlock
> >>>>>>>> in a
> >>>>>>>> body of code.
> >>>>>>>>
> >>>>>>>> Attached is an example of the workshop.  You can try find the
> >>>>>>>> deadlock if you like.  I've shown it to almost 100 good Java
> >>>>>>>> developers and
> >>>>>>>> so far, not one has found it by themselves.  I would expect that
> >>>>>>>> they should
> >>>>>>>> find it in 5 minutes.  In our workshop they would obviously be
> >>>>>>>> helped a bit
> >>>>>>>> with hints, so that they can walk away with a good 
> experience.  Use
> >>>>>>>> anything
> >>>>>>>> you like.  Oscilloscope, jstack, jconsole, whatever you like. 
>  Only
> >>>>>>>> rule for
> >>>>>>>> you guys on the "concurrency-interest" list is: you can only 
> look at
> >>>>>>>> the
> >>>>>>>> code once you've found the problem, otherwise it would be too 
> easy
> >>>>>>>> for you
> >>>>>>>> :-)  Once you have found it, you can also fix the code and 
> make sure
> >>>>>>>> that
> >>>>>>>> the code then works correctly.
> >>>>>>>> Regards
> >>>>>>>>
> >>>>>>>> Heinz
> >>>>>>>> --
> >>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
> >>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
> >>>>>>>> Sun Java Champion
> >>>>>>>> IEEE Certified Software Development Professional
> >>>>>>>> http://www.javaspecialists.eu
> >>>>>>>> Tel: +30 69 75 595 262
> >>>>>>>> Skype: kabutz
> >>>>>>>>
> >>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
> >>>>>>>>>
> >>>>>>>>> I am curious as to the intended content of your presentation.
> >>>>>>>>>  Here's some ideas.  I wondering what you are planing on doing.
> >>>>>>>>>
> >>>>>>>>>  1. Printing the call stacks with lock information using a tool
> >>>>>>>>>    such as jstack
> >>>>>>>>>  2. Press the "Detect Deadlock" button in JConsole
> >>>>>>>>>  3. Dealing with Lock and Condition objects instead of
> >>>>>>>>>    synchronized blocks
> >>>>>>>>>  4. Detecting live lock
> >>>>>>>>>  5. Distributed deadlocks
> >>>>>>>>>
> >>>>>>>>> Nathan Reynolds
> >>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> >>>>>>>>> Consulting
> >>>>>>>>> Member of Technical Staff | 602.333.9091
> >>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
> >>>>>>>>> Technology
> >>>>>>>>>
> >>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
> >>>>>>>>>>
> >>>>>>>>>> Good afternoon,
> >>>>>>>>>>
> >>>>>>>>>> I am thinking of submitting a talk on finding and diagnosing
> >>>>>>>>>> deadlocks for JavaOne.  It might be a workshop, instead of a
> >>>>>>>>>> simple
> >>>>>>>>>> conference talk.  Or we might be able to turn the talk into a
> >>>>>>>>>> workshop where
> >>>>>>>>>> they need to find a deadlock in a body of code.  Could be
> >>>>>>>>>> something
> >>>>>>>>>> different, which might go incredibly well or crash in a 
> blaze of
> >>>>>>>>>> flames.
> >>>>>>>>>>  Would any of you be interested in co-presenting this with 
> me at
> >>>>>>>>>> JavaOne?
> >>>>>>>>>>
> >>>>>>>>>> Regards
> >>>>>>>>>>
> >>>>>>>>>> Heinz
> >>>>
> >>>>
> >>>>
> >>>> _______________________________________________
> >>>> Concurrency-interest mailing list
> >>>> Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>
> >>>
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> This email and any files transmitted with it contain confidential and 
> proprietary information and is solely for the use of the intended 
> recipient.  If you are not the intended recipient please return the 
> email to the sender and delete it from your computer and you must not 
> use, disclose, distribute, copy, print or rely on this email or its 
> contents.  This communication is for informational purposes only.  It 
> is not intended as an offer or solicitation for the purchase or sale 
> of any financial instrument or as an official confirmation of any 
> transaction.   Any comments or statements made herein do not 
> necessarily reflect those of GSA Capital. GSA Capital Partners LLP is 
> authorised and regulated by the Financial Services Authority and is 
> registered in England and Wales at Stratton House, 5 Stratton Street, 
> London W1J 8LA, number OC309261. GSA Capital Services Limited is 
> registered in England and Wales at the same address, number 5320529.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120410/de75084d/attachment-0001.html>

From hans.boehm at hp.com  Tue Apr 10 13:25:24 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Tue, 10 Apr 2012 17:25:24 +0000
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
	Issue 19
In-Reply-To: <16982a6c25f2afdfb1a8b3dff0337218.squirrel@webmail.cise.ufl.edu>
References: <mailman.100.1334058314.3324.concurrency-interest@cs.oswego.edu>
	<16982a6c25f2afdfb1a8b3dff0337218.squirrel@webmail.cise.ufl.edu>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235541B3D@G4W3299.americas.hpqcorp.net>

Naively, this approach seems like a bit of overkill.  Once you know that the program is data-race-free, which you should be able to determine by considering only context switches at synchronization points, you then know that program behavior can't be affected by context switches anywhere other than at synchronization points.  Thus naively it seems to me that if your target is a data-race-free program, you should be able to greatly reduce the search space.  Am I missing something?  Or are there other techniques that effectively already take advantage of this?

Hans

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Beverly Sanders
> Sent: Tuesday, April 10, 2012 5:52 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
> 87, Issue 19
> 
> 
> There is an extension to java pathfinder that can precisely detect data
> races as defined by the JMM, and thus works for lock-free algorithms
> that
> use volatiles and atomics.
> 
> http://babelfish.arc.nasa.gov/trac/jpf/wiki/projects/jpf-racefinder
> 
> I'm not sure if the tool has kept up with the latest changes to jpf,
> but
> expressions of interest could encourage that to happen.
> 
> Generally, you would want to to check your program with standard JPF
> first, then use jpf-racefinder to make sure there are no data races.
> If
> the program is data-race free, then standard JPF is sound.
> 
> (If you are intersted in using JPF to reason about Java programs that
> intentionally have, presumably benign, data races, please contact me.
> See
> the paper by Jin, Yavuz-Khaveci and Sanders in TACAS'12)
> 
> 
> On Tue, April 10, 2012 7:45 am, concurrency-interest-
> request at cs.oswego.edu
> wrote:
> > Send Concurrency-interest mailing list submissions to
> > 	concurrency-interest at cs.oswego.edu
> >
> > To subscribe or unsubscribe via the World Wide Web, visit
> > 	http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > or, via email, send a message with subject or body 'help' to
> > 	concurrency-interest-request at cs.oswego.edu
> >
> > You can reach the person managing the list at
> > 	concurrency-interest-owner at cs.oswego.edu
> >
> > When replying, please edit your Subject line so it is more specific
> > than "Re: Contents of Concurrency-interest digest..."
> >
> >
> > Today's Topics:
> >
> >    1. Re: Joint Talk for JavaOne? (Kearney, Joe)
> >
> >
> > ---------------------------------------------------------------------
> -
> >
> > Message: 1
> > Date: Tue, 10 Apr 2012 12:44:58 +0100
> > From: "Kearney, Joe" <Joe.Kearney at gsacapital.com>
> > To: Nathan Reynolds <nathan.reynolds at oracle.com>
> > Cc: "Concurrency-interest at cs.oswego.edu"
> > 	<Concurrency-interest at cs.oswego.edu>
> > Subject: Re: [concurrency-interest] Joint Talk for JavaOne?
> > Message-ID:
> > 	<9319F360221C65428EA819A4E8DC34ED03A399B03C at OPMBOX21UK.options-
> it.com>
> > Content-Type: text/plain; charset="iso-8859-1"
> >
> > Does lack of support for volatile fields render this tool useless for
> > testing non-blocking concurrency and concurrent programs that don't
> only
> > use synchronized blocks?
> >
> > In particular does it support locking through LockSupport, AQS and
> friends
> > - for example does it understand uses of Phaser or CyclicBarrier?
> >
> > Is there a list somewhere of these limitations? Perhaps these things
> are
> > spread around the sub-projects.
> >
> > Thanks,
> > Joe
> >
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of
> Nathan
> > Reynolds
> > Sent: 09 April 2012 17:44
> > To: Mohan Radhakrishnan
> > Cc: Concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Joint Talk for JavaOne?
> >
> > Java Path Finder is great for finding deadlocks and data races.
> However,
> > it has its limitations.
> >
> >  1.  The search space is exponential in the number of threads (i.e.
> > O(2t)).  This program has way too many threads.  One would have to
> reduce
> > the threads to a bare minimum.
> >  2.  The Java Memory Model (i.e. volatile fields) isn't supported.
> That
> > isn't a problem in this case but something to be aware of.
> >
> > Otherwise, I rely on Java Path Finder to prove that my code is going
> to
> > work in concurrent situations.  It has found a ton of concurrency
> bugs in
> > my code.
> > Nathan
> >
> Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
> |
> > Consulting Member of Technical Staff | 602.333.9091
> > Oracle PSR Engineering<http://psr.us.oracle.com/> | Server Technology
> >
> > On 4/8/2012 8:23 PM, Mohan Radhakrishnan wrote:
> > I could look at the first deadlock by dumping locks and threads. I
> was
> > planning to find the next one using Java Path Finder but I think it
> is not
> > recommended for such a big codebase. I am not sure. Its heuristics
> might
> > take too much memory.
> >
> > Mohan
> > On Mon, Apr 9, 2012 at 3:59 AM,
> > <mabrouk2005 at gmail.com<mailto:mabrouk2005 at gmail.com>> wrote:
> > Nice exercise Dr Heinz,
> >
> > As others mentioned there were 2 kind of deadlocks the first one was
> > very is easy to find via jconsole so likeI thought that was it and
> > went and fixed that but then when ran it again it hang it so I knew
> > thee was more. the interesting thing the jconsole did not detect the
> > AWT deadlock it showed no deadlock even though the app hang. I had to
> > force stack dump and get clues to where is the deadlock. Does anyone
> > have experienced something like this with jconsole not detecting AWT
> > deadlocks?
> >
> > Thanks again for the nice exercise and the great java news letter I
> am
> > a big fan.
> >
> > Cheers,
> > Mabrouk
> >
> > On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax
> > <forax at univ-mlv.fr<mailto:forax at univ-mlv.fr>> wrote:
> >> No, it's more an AWRY or Java2D bug.
> >>
> >> R?mi
> >>
> >> Sent from my Phone
> >>
> >>
> >> ----- Reply message -----
> >> From: "Ben Evans"
> >>
> <benjamin.john.evans at gmail.com<mailto:benjamin.john.evans at gmail.com>>
> >> To: "Dr Heinz M. Kabutz"
> >> <heinz at javaspecialists.eu<mailto:heinz at javaspecialists.eu>>
> >> Cc: "R?mi Forax" <forax at univ-mlv.fr<mailto:forax at univ-mlv.fr>>,
> >> <concurrency-interest at cs.oswego.edu<mailto:concurrency-
> interest at cs.oswego.edu>>
> >> Subject: [concurrency-interest] Joint Talk for JavaOne?
> >> Date: Sat, Apr 7, 2012 10:43
> >>
> >>
> >> Heinz, was this with the new jdk8 + lambda build?
> >>
> >> If so, we should report this crash back to lambda-dev.
> >>
> >> Thanks,
> >>
> >> Ben
> >>
> >> On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
> >> <heinz at javaspecialists.eu<mailto:heinz at javaspecialists.eu>> wrote:
> >>> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6.  I
> see
> >>> that
> >>> the Java2Demo has been removed from the demos folder of JDK 1.7 and
> >>> 1.8.
> >>>  It
> >>> thus is a Java 8 issue, rather than the changes I made to the code.
> >>>  Thanks
> >>> for the warning R?mi.
> >>>
> >>>
> >>> Regards
> >>>
> >>> Heinz
> >>> --
> >>> Dr Heinz M. Kabutz (PhD CompSci)
> >>> Author of "The Java(tm) Specialists' Newsletter"
> >>> Sun Java Champion
> >>> IEEE Certified Software Development Professional
> >>> http://www.javaspecialists.eu
> >>> Tel: +30 69 75 595 262
> >>> Skype: kabutz
> >>>
> >>>
> >>> On 4/6/12 1:51 AM, R?mi Forax wrote:
> >>>>
> >>>> jdk8 crashes if I click on images of the tapped pane.
> >>>>
> >>>> R?mi
> >>>>
> >>>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
> >>>>>
> >>>>> Yes, you are correct.
> >>>>>
> >>>>> However, the mistake most programmers make is to #1 scratch
> around in
> >>>>> the
> >>>>> source code to try and discover the problem and #2 then fix it
> >>>>> without
> >>>>> really understanding what they are doing.  I think the lesson is
> >>>>> bigger
> >>>>> if
> >>>>> we give them the source code.  In addition, it is probably more
> >>>>> difficult to
> >>>>> solve if you have the sources to muse over.
> >>>>> Regards
> >>>>>
> >>>>> Heinz
> >>>>> --
> >>>>> Dr Heinz M. Kabutz (PhD CompSci)
> >>>>> Author of "The Java(tm) Specialists' Newsletter"
> >>>>> Sun Java Champion
> >>>>> IEEE Certified Software Development Professional
> >>>>> http://www.javaspecialists.eu
> >>>>> Tel: +30 69 75 595 262
> >>>>> Skype: kabutz
> >>>>>
> >>>>>
> >>>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
> >>>>>>
> >>>>>> I guess it is a good idea to not initially include the source
> code
> >>>>>> in
> >>>>>> the workshop because many times I initially don't have the
> source
> >>>>>> code
> >>>>>> when
> >>>>>> trying to figure out performance or scalability problems.
> >>>>>>
> >>>>>> Nathan Reynolds
> >>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> >>>>>> Consulting
> >>>>>> Member of Technical Staff | 602.333.9091
> >>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
> >>>>>> Technology
> >>>>>>
> >>>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
> >>>>>>>
> >>>>>>> Sorry Nathan, here is the zip file including the source code an
> an
> >>>>>>> Ant
> >>>>>>> script to build the code.  Sorry for accidentally excluding
> that
> >>>>>>> from
> >>>>>>> the
> >>>>>>> file I sent earlier.  The problem was between the chair and the
> >>>>>>> keyboard.
> >>>>>>>  However, one should be able to pinpoint the deadlock without
> >>>>>>> seeing a
> >>>>>>> line
> >>>>>>> of code.  At the workshop I presented in Spain last week, most
> of
> >>>>>>> the
> >>>>>>> programmers immediately started delving into the code before
> they
> >>>>>>> knew
> >>>>>>> where
> >>>>>>> to look.
> >>>>>>> Regards
> >>>>>>>
> >>>>>>> Heinz
> >>>>>>> --
> >>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
> >>>>>>> Author of "The Java(tm) Specialists' Newsletter"
> >>>>>>> Sun Java Champion
> >>>>>>> IEEE Certified Software Development Professional
> >>>>>>> http://www.javaspecialists.eu
> >>>>>>> Tel: +30 69 75 595 262
> >>>>>>> Skype: kabutz
> >>>>>>>
> >>>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
> >>>>>>>>
> >>>>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3.
> It
> >>>>>>>> didn't deadlock for a minute or two.  Then the application
> froze.
> >>>>>>>> I
> >>>>>>>> then
> >>>>>>>> used jstack to dump the call stacks.  At the end of the
> report, it
> >>>>>>>> said
> >>>>>>>> "Found one Java-level deadlock".  It then dumped out the locks
> and
> >>>>>>>> threads
> >>>>>>>> involved in the deadlock.  I never looked at the source
> code... in
> >>>>>>>> fact it
> >>>>>>>> wasn't in the zip file.  This took about 5-7 minutes from
> starting
> >>>>>>>> the
> >>>>>>>> application to finding the deadlock in the call stacks.
> >>>>>>>>
> >>>>>>>> A 100 good Java developers?  Really?  I guess I can
> understand.
> >>>>>>>> Most
> >>>>>>>> engineers don't understand locks.  Most of the time I get
> answers
> >>>>>>>> like one
> >>>>>>>> should put a lock around shared variables.  This is accurate
> but
> >>>>>>>> they
> >>>>>>>> can't
> >>>>>>>> really go any deeper.
> >>>>>>>>
> >>>>>>>> It sounds like the material of your presentation should be
> very
> >>>>>>>> good.
> >>>>>>>>  It covers things that the deadlock detection tool probably
> can't
> >>>>>>>> figure
> >>>>>>>> out.
> >>>>>>>>
> >>>>>>>> So, it seems like you have everything figured out.  Why do you
> >>>>>>>> need
> >>>>>>>> someone else?
> >>>>>>>>
> >>>>>>>> Nathan Reynolds
> >>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
> |
> >>>>>>>> Consulting
> >>>>>>>> Member of Technical Staff | 602.333.9091
> >>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
> >>>>>>>> Technology
> >>>>>>>>
> >>>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
> >>>>>>>>>
> >>>>>>>>> Hi Nathan,
> >>>>>>>>>
> >>>>>>>>> a stack trace will only show you a certain class of obvious
> >>>>>>>>> deadlocks
> >>>>>>>>> that are easy to find and solve.  I remember solving
> deadlocks
> >>>>>>>>> /before/ we
> >>>>>>>>> had the brilliant deadlock detection tool in the
> ThreadMXBean.
> >>>>>>>>> Yes,
> >>>>>>>>> the
> >>>>>>>>> deadlock detection tool shows you /some/ deadlocks, but
> >>>>>>>>> definitely
> >>>>>>>>> not all
> >>>>>>>>> of them.  I can think of a bunch that it would not find:
> >>>>>>>>>
> >>>>>>>>> 1. Semaphores running out of permits
> >>>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read
> lock
> >>>>>>>>> 3. Resource deadlocks
> >>>>>>>>>
> >>>>>>>>> And some others that I will not describe in detail, such as
> some
> >>>>>>>>> nasty livelocks that we can cause which will hang up the JVM
> :-)
> >>>>>>>>>
> >>>>>>>>> I agree with Kirk - it should probably be a 3 hour workshop.
> >>>>>>>>> I've
> >>>>>>>>> done this three times now - twice in Spain and once via
> webinar.
> >>>>>>>>>  The
> >>>>>>>>> workshop would involve some lessons on deadlocks, what causes
> >>>>>>>>> them
> >>>>>>>>> and how
> >>>>>>>>> we can prevent them.  Also an explanation as to why we see
> them
> >>>>>>>>> so
> >>>>>>>>> seldom in
> >>>>>>>>> real production.  I've got material prepared for this
> workshop.
> >>>>>>>>> And
> >>>>>>>>> then a
> >>>>>>>>> practical part to the workshop where they can try to find a
> >>>>>>>>> deadlock
> >>>>>>>>> in a
> >>>>>>>>> body of code.
> >>>>>>>>>
> >>>>>>>>> Attached is an example of the workshop.  You can try find the
> >>>>>>>>> deadlock if you like.  I've shown it to almost 100 good Java
> >>>>>>>>> developers and
> >>>>>>>>> so far, not one has found it by themselves.  I would expect
> that
> >>>>>>>>> they should
> >>>>>>>>> find it in 5 minutes.  In our workshop they would obviously
> be
> >>>>>>>>> helped a bit
> >>>>>>>>> with hints, so that they can walk away with a good
> experience.
> >>>>>>>>> Use
> >>>>>>>>> anything
> >>>>>>>>> you like.  Oscilloscope, jstack, jconsole, whatever you like.
> >>>>>>>>> Only
> >>>>>>>>> rule for
> >>>>>>>>> you guys on the "concurrency-interest" list is: you can only
> look
> >>>>>>>>> at
> >>>>>>>>> the
> >>>>>>>>> code once you've found the problem, otherwise it would be too
> >>>>>>>>> easy
> >>>>>>>>> for you
> >>>>>>>>> :-)  Once you have found it, you can also fix the code and
> make
> >>>>>>>>> sure
> >>>>>>>>> that
> >>>>>>>>> the code then works correctly.
> >>>>>>>>> Regards
> >>>>>>>>>
> >>>>>>>>> Heinz
> >>>>>>>>> --
> >>>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
> >>>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
> >>>>>>>>> Sun Java Champion
> >>>>>>>>> IEEE Certified Software Development Professional
> >>>>>>>>> http://www.javaspecialists.eu
> >>>>>>>>> Tel: +30 69 75 595 262
> >>>>>>>>> Skype: kabutz
> >>>>>>>>>
> >>>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
> >>>>>>>>>>
> >>>>>>>>>> I am curious as to the intended content of your
> presentation.
> >>>>>>>>>>  Here's some ideas.  I wondering what you are planing on
> doing.
> >>>>>>>>>>
> >>>>>>>>>>  1. Printing the call stacks with lock information using a
> tool
> >>>>>>>>>>    such as jstack
> >>>>>>>>>>  2. Press the "Detect Deadlock" button in JConsole
> >>>>>>>>>>  3. Dealing with Lock and Condition objects instead of
> >>>>>>>>>>    synchronized blocks
> >>>>>>>>>>  4. Detecting live lock
> >>>>>>>>>>  5. Distributed deadlocks
> >>>>>>>>>>
> >>>>>>>>>> Nathan Reynolds
> >>>>>>>>>>
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> >>>>>>>>>> Consulting
> >>>>>>>>>> Member of Technical Staff | 602.333.9091
> >>>>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
> >>>>>>>>>> Technology
> >>>>>>>>>>
> >>>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
> >>>>>>>>>>>
> >>>>>>>>>>> Good afternoon,
> >>>>>>>>>>>
> >>>>>>>>>>> I am thinking of submitting a talk on finding and
> diagnosing
> >>>>>>>>>>> deadlocks for JavaOne.  It might be a workshop, instead of
> a
> >>>>>>>>>>> simple
> >>>>>>>>>>> conference talk.  Or we might be able to turn the talk into
> a
> >>>>>>>>>>> workshop where
> >>>>>>>>>>> they need to find a deadlock in a body of code.  Could be
> >>>>>>>>>>> something
> >>>>>>>>>>> different, which might go incredibly well or crash in a
> blaze
> >>>>>>>>>>> of
> >>>>>>>>>>> flames.
> >>>>>>>>>>>  Would any of you be interested in co-presenting this with
> me
> >>>>>>>>>>> at
> >>>>>>>>>>> JavaOne?
> >>>>>>>>>>>
> >>>>>>>>>>> Regards
> >>>>>>>>>>>
> >>>>>>>>>>> Heinz
> >>>>>
> >>>>>
> >>>>>
> >>>>> _______________________________________________
> >>>>> Concurrency-interest mailing list
> >>>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
> interest at cs.oswego.edu>
> >>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>
> >>>>
> >>>> _______________________________________________
> >>>> Concurrency-interest mailing list
> >>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
> interest at cs.oswego.edu>
> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
> interest at cs.oswego.edu>
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
> interest at cs.oswego.edu>
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
> interest at cs.oswego.edu>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> >
> >
> > _______________________________________________
> >
> > Concurrency-interest mailing list
> >
> > Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
> interest at cs.oswego.edu>
> >
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > This email and any files transmitted with it contain confidential and
> > proprietary information and is solely for the use of the intended
> > recipient.  If you are not the intended recipient please return the
> email
> > to the sender and delete it from your computer and you must not use,
> > disclose, distribute, copy, print or rely on this email or its
> contents.
> > This communication is for informational purposes only.  It is not
> intended
> > as an offer or solicitation for the purchase or sale of any financial
> > instrument or as an official confirmation of any transaction.   Any
> > comments or statements made herein do not necessarily reflect those
> of GSA
> > Capital. GSA Capital Partners LLP is authorised and regulated by the
> > Financial Services Authority and is registered in England and Wales
> at
> > Stratton House, 5 Stratton Street, London W1J 8LA, number OC309261.
> GSA
> > Capital Services Limited is registered in England and Wales at the
> same
> > address, number 5320529.
> >
> >
> > -------------- next part --------------
> > An HTML attachment was scrubbed...
> > URL:
> > <http://cs.oswego.edu/pipermail/concurrency-
> interest/attachments/20120410/196f40e9/attachment.html>
> >
> > ------------------------------
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > End of Concurrency-interest Digest, Vol 87, Issue 19
> > ****************************************************
> >
> >
> 
> 
> --
> Beverly A. Sanders, Ph.D.
> Associate Professor
> Department of Computer & Information Science & Engineering
> P.O. Box 116120
> University of Florida
> Gainesville, FL 32611-6120
> www.cise.ufl.edu/~sanders
> tel: (352) 505-1563
> fax: (352) 392-1220
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From ach at quartetfs.com  Wed Apr 11 06:10:09 2012
From: ach at quartetfs.com (Antoine Chambille)
Date: Wed, 11 Apr 2012 12:10:09 +0200
Subject: [concurrency-interest] CountedCompleters
In-Reply-To: <4F82EF21.4020804@cs.oswego.edu>
References: <4F82EF21.4020804@cs.oswego.edu>
Message-ID: <CAJGQDwmrQ01i-X0qaCnHFX+yTEpprs_-M6j9jLPsxhMN4rOxBg@mail.gmail.com>

Hello Doug and All,



This is an exciting addition to the framework. I think it makes the
fork/join pool even more fit for general purpose multithreading. Two years
ago I decided to switch to fork/join pool exclusively to support all the
multi-threading in the "ActivePivot" project (an in-memory analytics
solution). This works pretty well, and we reach far higher multi-core usage
than with standard thread pools.


Yet we still have performance drops with tasks that access shared data and
acquire a lock for that. While the task waits for the lock, it ?wastes? its
worker thread that could otherwise do something else. Not much you can do
about it unless you have access to some other work to run after tryLock()
fails. But it gets worse when another task joins the locking task as it may
itself ?waste? its worker thread waiting, same thing for the entire chain
of parents? It is possible to reach a state where the pool has most of its
worker threads joining. Counted completers help a lot, because they remove
those intermediary joins.


You have mentioned that counted completers would help with tasks that
perform IO, or last an unpredicted long time. I think they will also better
handle a few locking tasks, more efficiently than a managed blocker that is
often difficult to put in place when the actual lock is hidden.



That being said when rewriting some of our core algorithms with counted
completers, I find it difficult to propagate exceptions. It was very fast
migrating code based on recursive actions, but exceptions thrown in the sub
tasks would be swallowed (also if that makes you skip the tryComplete()
call, joining the root task is an infinite wait). When a sub task fails,
what is the best way to propagate the exception to the parent completer?




-Antoine

Quartet FS





On 9 April 2012 16:16, Doug Lea <dl at cs.oswego.edu> wrote:

>
> After sitting on multiple variations for months, I committed
> CountedCompleter, a completion-based flavor of ForkJoinTask.
>
> As mentioned a few times over the past year, the main motivation
> is to better support tasks that perform IO or other base
> actions that may (or may not) take a lot of time to execute.
> As is the case with JDK7 async IO and other completion-based
> frameworks, the most common path to efficiency is for such tasks
> to arrange continuation actions that occur upon their completion.
> The main twist for CountedCompleters is that continuations
> might be dependent on multiple actions, not just one. (Or in
> other words, the continuations must be preceded by a specialized,
> "bottom-up" form of join.)
>
> The CountedCompleter abstract class provides a minimal basis
> for these kinds of tasks. While some of the mechanics are
> reminiscent of other FJ-like frameworks such as Intel TBB,
> CountedCompleters are designed to fit smoothly with other
> kinds of ForkJoinTasks (like RecursiveActions), and so still
> allow people to use the more pleasant Future-style conventions
> rather than count-based bottom-up joining unless they need them.
> At the same time, the CountedCompleter class exposes enough
> mechanics to allow all sorts of tweaks that people can use
> to improve performance.
> In particular, in addition to usually being the best way to deal
> with IO etc bound tasks, CountedCompleters sometimes fare better
> than RecursiveActions in programs that entail lots of garbage
> collection because GC can have similar impact on task variability.
>
> Even though targeted for JDK8, versions of CountedCompleter
> appear in the jsr166y and main repositories, not jsr166e. This is
> because they require a non-public hook into modified ForkJoinTask
> exception handling mechanics in order to properly propagate
> exceptional completions. For sources, docs, and jar files, see
> the usual links at http://gee.cs.oswego.edu/dl/**
> concurrency-interest/index.**html<http://gee.cs.oswego.edu/dl/concurrency-interest/index.html>
>
> The API docs include more details and some examples:
> http://gee.cs.oswego.edu/dl/**jsr166/dist/docs/java/util/**
> concurrent/CountedCompleter.**html<http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html>
>
> I also added a few (with more to come) test/demo programs that illustrate
> other usages. See CCBoxedLongSort and CCJacobi in
> http://gee.cs.oswego.edu/cgi-**bin/viewcvs.cgi/jsr166/src/**test/loops/<http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/>
>
> Please try these out. As always, comments and suggestions
> (hopefully based on usage experience) would be welcome.
>
> -Doug
>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Antoine CHAMBILLE
R&D Director
Quartet FS
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120411/b2c62f2a/attachment-0001.html>

From dl at cs.oswego.edu  Wed Apr 11 06:46:42 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 11 Apr 2012 06:46:42 -0400
Subject: [concurrency-interest] CountedCompleters
In-Reply-To: <CAJGQDwmrQ01i-X0qaCnHFX+yTEpprs_-M6j9jLPsxhMN4rOxBg@mail.gmail.com>
References: <4F82EF21.4020804@cs.oswego.edu>
	<CAJGQDwmrQ01i-X0qaCnHFX+yTEpprs_-M6j9jLPsxhMN4rOxBg@mail.gmail.com>
Message-ID: <4F856112.4090704@cs.oswego.edu>

On 04/11/12 06:10, Antoine Chambille wrote:
> You have mentioned that counted completers would help with tasks that perform
> IO, or last an unpredicted long time. I think they will also better handle a few
> locking tasks, more efficiently than a managed blocker that is often difficult
> to put in place when the actual lock is hidden.

Yes, thanks. I should mention this in the documentation. (Although
worded in a way that does not encourage people to use locks in tasks,
but mentions CountedCompleters as one way to cope with code that does.)

>
> That being said when rewriting some of our core algorithms with counted
> completers, I find it difficult to propagate exceptions. It was very fast
> migrating code based on recursive actions, but exceptions thrown in the sub
> tasks would be swallowed (also if that makes you skip the tryComplete() call,
> joining the root task is an infinite wait). When a sub task fails, what is the
> best way to propagate the exception to the parent completer?
>

When CountedCompleter.compute throws an exception,
and the task is not already marked as completed, it triggers the
internal version of ForkJoinTask.completeExceptionally, which
marks that task as complete with the given exception, and
then does the same for that task's completer, and so on
until hitting a null completer. This should have the effects
you want in most cases, but you can also explicitly call
completeExceptionally in other cases to force this to happen before
return, or internally catch exceptions before returning from
compute if you'd like to handle them differently. If you find
a situation where these options don't suffice, please let me know.

-Doug

From nathan.reynolds at oracle.com  Wed Apr 11 13:06:40 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Wed, 11 Apr 2012 10:06:40 -0700
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
 Issue 19
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235541B3D@G4W3299.americas.hpqcorp.net>
References: <mailman.100.1334058314.3324.concurrency-interest@cs.oswego.edu>
	<16982a6c25f2afdfb1a8b3dff0337218.squirrel@webmail.cise.ufl.edu>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235541B3D@G4W3299.americas.hpqcorp.net>
Message-ID: <4F85BA20.6080600@oracle.com>

When you said synchronization points do you mean communication points?  
By communication points, I mean two threads accessing shared data.

Let's say you write a lock based off of the code in this paper.  
http://www.cise.ufl.edu/tr/DOC/REP-1992-71.pdf   The paper claims it is 
correct.  But, can you prove that your implementation is correct?  
Concurrency bugs are extremely difficult to find via code inspection.  
This is where Java Path Finder can be a huge help.

Java Path Finder employs a lot of tricks to reduce the search space.  
For example, operations on objects which are only visible to 1 thread 
never increase the search space.  Of course, reducing the amount of code 
tested to only those areas where threads can interact is very helpful.  
Reducing the number of threads down to 2 is also very helpful (when 
possible).  Even so, the search space can still be very large depending 
upon how complex the concurrent algorithm is.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/10/2012 10:25 AM, Boehm, Hans wrote:
> Naively, this approach seems like a bit of overkill.  Once you know that the program is data-race-free, which you should be able to determine by considering only context switches at synchronization points, you then know that program behavior can't be affected by context switches anywhere other than at synchronization points.  Thus naively it seems to me that if your target is a data-race-free program, you should be able to greatly reduce the search space.  Am I missing something?  Or are there other techniques that effectively already take advantage of this?
>
> Hans
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>> interest-bounces at cs.oswego.edu] On Behalf Of Beverly Sanders
>> Sent: Tuesday, April 10, 2012 5:52 AM
>> To: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
>> 87, Issue 19
>>
>>
>> There is an extension to java pathfinder that can precisely detect data
>> races as defined by the JMM, and thus works for lock-free algorithms
>> that
>> use volatiles and atomics.
>>
>> http://babelfish.arc.nasa.gov/trac/jpf/wiki/projects/jpf-racefinder
>>
>> I'm not sure if the tool has kept up with the latest changes to jpf,
>> but
>> expressions of interest could encourage that to happen.
>>
>> Generally, you would want to to check your program with standard JPF
>> first, then use jpf-racefinder to make sure there are no data races.
>> If
>> the program is data-race free, then standard JPF is sound.
>>
>> (If you are intersted in using JPF to reason about Java programs that
>> intentionally have, presumably benign, data races, please contact me.
>> See
>> the paper by Jin, Yavuz-Khaveci and Sanders in TACAS'12)
>>
>>
>> On Tue, April 10, 2012 7:45 am, concurrency-interest-
>> request at cs.oswego.edu
>> wrote:
>>> Send Concurrency-interest mailing list submissions to
>>> 	concurrency-interest at cs.oswego.edu
>>>
>>> To subscribe or unsubscribe via the World Wide Web, visit
>>> 	http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> or, via email, send a message with subject or body 'help' to
>>> 	concurrency-interest-request at cs.oswego.edu
>>>
>>> You can reach the person managing the list at
>>> 	concurrency-interest-owner at cs.oswego.edu
>>>
>>> When replying, please edit your Subject line so it is more specific
>>> than "Re: Contents of Concurrency-interest digest..."
>>>
>>>
>>> Today's Topics:
>>>
>>>     1. Re: Joint Talk for JavaOne? (Kearney, Joe)
>>>
>>>
>>> ---------------------------------------------------------------------
>> -
>>> Message: 1
>>> Date: Tue, 10 Apr 2012 12:44:58 +0100
>>> From: "Kearney, Joe"<Joe.Kearney at gsacapital.com>
>>> To: Nathan Reynolds<nathan.reynolds at oracle.com>
>>> Cc: "Concurrency-interest at cs.oswego.edu"
>>> 	<Concurrency-interest at cs.oswego.edu>
>>> Subject: Re: [concurrency-interest] Joint Talk for JavaOne?
>>> Message-ID:
>>> 	<9319F360221C65428EA819A4E8DC34ED03A399B03C at OPMBOX21UK.options-
>> it.com>
>>> Content-Type: text/plain; charset="iso-8859-1"
>>>
>>> Does lack of support for volatile fields render this tool useless for
>>> testing non-blocking concurrency and concurrent programs that don't
>> only
>>> use synchronized blocks?
>>>
>>> In particular does it support locking through LockSupport, AQS and
>> friends
>>> - for example does it understand uses of Phaser or CyclicBarrier?
>>>
>>> Is there a list somewhere of these limitations? Perhaps these things
>> are
>>> spread around the sub-projects.
>>>
>>> Thanks,
>>> Joe
>>>
>>> From: concurrency-interest-bounces at cs.oswego.edu
>>> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of
>> Nathan
>>> Reynolds
>>> Sent: 09 April 2012 17:44
>>> To: Mohan Radhakrishnan
>>> Cc: Concurrency-interest at cs.oswego.edu
>>> Subject: Re: [concurrency-interest] Joint Talk for JavaOne?
>>>
>>> Java Path Finder is great for finding deadlocks and data races.
>> However,
>>> it has its limitations.
>>>
>>>   1.  The search space is exponential in the number of threads (i.e.
>>> O(2t)).  This program has way too many threads.  One would have to
>> reduce
>>> the threads to a bare minimum.
>>>   2.  The Java Memory Model (i.e. volatile fields) isn't supported.
>> That
>>> isn't a problem in this case but something to be aware of.
>>>
>>> Otherwise, I rely on Java Path Finder to prove that my code is going
>> to
>>> work in concurrent situations.  It has found a ton of concurrency
>> bugs in
>>> my code.
>>> Nathan
>>>
>> Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>> |
>>> Consulting Member of Technical Staff | 602.333.9091
>>> Oracle PSR Engineering<http://psr.us.oracle.com/>  | Server Technology
>>>
>>> On 4/8/2012 8:23 PM, Mohan Radhakrishnan wrote:
>>> I could look at the first deadlock by dumping locks and threads. I
>> was
>>> planning to find the next one using Java Path Finder but I think it
>> is not
>>> recommended for such a big codebase. I am not sure. Its heuristics
>> might
>>> take too much memory.
>>>
>>> Mohan
>>> On Mon, Apr 9, 2012 at 3:59 AM,
>>> <mabrouk2005 at gmail.com<mailto:mabrouk2005 at gmail.com>>  wrote:
>>> Nice exercise Dr Heinz,
>>>
>>> As others mentioned there were 2 kind of deadlocks the first one was
>>> very is easy to find via jconsole so likeI thought that was it and
>>> went and fixed that but then when ran it again it hang it so I knew
>>> thee was more. the interesting thing the jconsole did not detect the
>>> AWT deadlock it showed no deadlock even though the app hang. I had to
>>> force stack dump and get clues to where is the deadlock. Does anyone
>>> have experienced something like this with jconsole not detecting AWT
>>> deadlocks?
>>>
>>> Thanks again for the nice exercise and the great java news letter I
>> am
>>> a big fan.
>>>
>>> Cheers,
>>> Mabrouk
>>>
>>> On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax
>>> <forax at univ-mlv.fr<mailto:forax at univ-mlv.fr>>  wrote:
>>>> No, it's more an AWRY or Java2D bug.
>>>>
>>>> R?mi
>>>>
>>>> Sent from my Phone
>>>>
>>>>
>>>> ----- Reply message -----
>>>> From: "Ben Evans"
>>>>
>> <benjamin.john.evans at gmail.com<mailto:benjamin.john.evans at gmail.com>>
>>>> To: "Dr Heinz M. Kabutz"
>>>> <heinz at javaspecialists.eu<mailto:heinz at javaspecialists.eu>>
>>>> Cc: "R?mi Forax"<forax at univ-mlv.fr<mailto:forax at univ-mlv.fr>>,
>>>> <concurrency-interest at cs.oswego.edu<mailto:concurrency-
>> interest at cs.oswego.edu>>
>>>> Subject: [concurrency-interest] Joint Talk for JavaOne?
>>>> Date: Sat, Apr 7, 2012 10:43
>>>>
>>>>
>>>> Heinz, was this with the new jdk8 + lambda build?
>>>>
>>>> If so, we should report this crash back to lambda-dev.
>>>>
>>>> Thanks,
>>>>
>>>> Ben
>>>>
>>>> On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz
>>>> <heinz at javaspecialists.eu<mailto:heinz at javaspecialists.eu>>  wrote:
>>>>> I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6.  I
>> see
>>>>> that
>>>>> the Java2Demo has been removed from the demos folder of JDK 1.7 and
>>>>> 1.8.
>>>>>   It
>>>>> thus is a Java 8 issue, rather than the changes I made to the code.
>>>>>   Thanks
>>>>> for the warning R?mi.
>>>>>
>>>>>
>>>>> Regards
>>>>>
>>>>> Heinz
>>>>> --
>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>> Sun Java Champion
>>>>> IEEE Certified Software Development Professional
>>>>> http://www.javaspecialists.eu
>>>>> Tel: +30 69 75 595 262
>>>>> Skype: kabutz
>>>>>
>>>>>
>>>>> On 4/6/12 1:51 AM, R?mi Forax wrote:
>>>>>> jdk8 crashes if I click on images of the tapped pane.
>>>>>>
>>>>>> R?mi
>>>>>>
>>>>>> On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:
>>>>>>> Yes, you are correct.
>>>>>>>
>>>>>>> However, the mistake most programmers make is to #1 scratch
>> around in
>>>>>>> the
>>>>>>> source code to try and discover the problem and #2 then fix it
>>>>>>> without
>>>>>>> really understanding what they are doing.  I think the lesson is
>>>>>>> bigger
>>>>>>> if
>>>>>>> we give them the source code.  In addition, it is probably more
>>>>>>> difficult to
>>>>>>> solve if you have the sources to muse over.
>>>>>>> Regards
>>>>>>>
>>>>>>> Heinz
>>>>>>> --
>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>>> Sun Java Champion
>>>>>>> IEEE Certified Software Development Professional
>>>>>>> http://www.javaspecialists.eu
>>>>>>> Tel: +30 69 75 595 262
>>>>>>> Skype: kabutz
>>>>>>>
>>>>>>>
>>>>>>> On 4/5/12 11:30 PM, Nathan Reynolds wrote:
>>>>>>>> I guess it is a good idea to not initially include the source
>> code
>>>>>>>> in
>>>>>>>> the workshop because many times I initially don't have the
>> source
>>>>>>>> code
>>>>>>>> when
>>>>>>>> trying to figure out performance or scalability problems.
>>>>>>>>
>>>>>>>> Nathan Reynolds
>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>  |
>>>>>>>> Consulting
>>>>>>>> Member of Technical Staff | 602.333.9091
>>>>>>>> Oracle PSR Engineering<http://psr.us.oracle.com/>  | Server
>>>>>>>> Technology
>>>>>>>>
>>>>>>>> On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:
>>>>>>>>> Sorry Nathan, here is the zip file including the source code an
>> an
>>>>>>>>> Ant
>>>>>>>>> script to build the code.  Sorry for accidentally excluding
>> that
>>>>>>>>> from
>>>>>>>>> the
>>>>>>>>> file I sent earlier.  The problem was between the chair and the
>>>>>>>>> keyboard.
>>>>>>>>>   However, one should be able to pinpoint the deadlock without
>>>>>>>>> seeing a
>>>>>>>>> line
>>>>>>>>> of code.  At the workshop I presented in Spain last week, most
>> of
>>>>>>>>> the
>>>>>>>>> programmers immediately started delving into the code before
>> they
>>>>>>>>> knew
>>>>>>>>> where
>>>>>>>>> to look.
>>>>>>>>> Regards
>>>>>>>>>
>>>>>>>>> Heinz
>>>>>>>>> --
>>>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>>>>> Sun Java Champion
>>>>>>>>> IEEE Certified Software Development Professional
>>>>>>>>> http://www.javaspecialists.eu
>>>>>>>>> Tel: +30 69 75 595 262
>>>>>>>>> Skype: kabutz
>>>>>>>>>
>>>>>>>>> On 4/5/12 10:29 PM, Nathan Reynolds wrote:
>>>>>>>>>> I took the bait and tried out the demo on HotSpot 7 Update 3.
>> It
>>>>>>>>>> didn't deadlock for a minute or two.  Then the application
>> froze.
>>>>>>>>>> I
>>>>>>>>>> then
>>>>>>>>>> used jstack to dump the call stacks.  At the end of the
>> report, it
>>>>>>>>>> said
>>>>>>>>>> "Found one Java-level deadlock".  It then dumped out the locks
>> and
>>>>>>>>>> threads
>>>>>>>>>> involved in the deadlock.  I never looked at the source
>> code... in
>>>>>>>>>> fact it
>>>>>>>>>> wasn't in the zip file.  This took about 5-7 minutes from
>> starting
>>>>>>>>>> the
>>>>>>>>>> application to finding the deadlock in the call stacks.
>>>>>>>>>>
>>>>>>>>>> A 100 good Java developers?  Really?  I guess I can
>> understand.
>>>>>>>>>> Most
>>>>>>>>>> engineers don't understand locks.  Most of the time I get
>> answers
>>>>>>>>>> like one
>>>>>>>>>> should put a lock around shared variables.  This is accurate
>> but
>>>>>>>>>> they
>>>>>>>>>> can't
>>>>>>>>>> really go any deeper.
>>>>>>>>>>
>>>>>>>>>> It sounds like the material of your presentation should be
>> very
>>>>>>>>>> good.
>>>>>>>>>>   It covers things that the deadlock detection tool probably
>> can't
>>>>>>>>>> figure
>>>>>>>>>> out.
>>>>>>>>>>
>>>>>>>>>> So, it seems like you have everything figured out.  Why do you
>>>>>>>>>> need
>>>>>>>>>> someone else?
>>>>>>>>>>
>>>>>>>>>> Nathan Reynolds
>>>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>> |
>>>>>>>>>> Consulting
>>>>>>>>>> Member of Technical Staff | 602.333.9091
>>>>>>>>>> Oracle PSR Engineering<http://psr.us.oracle.com/>  | Server
>>>>>>>>>> Technology
>>>>>>>>>>
>>>>>>>>>> On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:
>>>>>>>>>>> Hi Nathan,
>>>>>>>>>>>
>>>>>>>>>>> a stack trace will only show you a certain class of obvious
>>>>>>>>>>> deadlocks
>>>>>>>>>>> that are easy to find and solve.  I remember solving
>> deadlocks
>>>>>>>>>>> /before/ we
>>>>>>>>>>> had the brilliant deadlock detection tool in the
>> ThreadMXBean.
>>>>>>>>>>> Yes,
>>>>>>>>>>> the
>>>>>>>>>>> deadlock detection tool shows you /some/ deadlocks, but
>>>>>>>>>>> definitely
>>>>>>>>>>> not all
>>>>>>>>>>> of them.  I can think of a bunch that it would not find:
>>>>>>>>>>>
>>>>>>>>>>> 1. Semaphores running out of permits
>>>>>>>>>>> 2. ReadWriteLocks trying to upgrade from write lock to read
>> lock
>>>>>>>>>>> 3. Resource deadlocks
>>>>>>>>>>>
>>>>>>>>>>> And some others that I will not describe in detail, such as
>> some
>>>>>>>>>>> nasty livelocks that we can cause which will hang up the JVM
>> :-)
>>>>>>>>>>> I agree with Kirk - it should probably be a 3 hour workshop.
>>>>>>>>>>> I've
>>>>>>>>>>> done this three times now - twice in Spain and once via
>> webinar.
>>>>>>>>>>>   The
>>>>>>>>>>> workshop would involve some lessons on deadlocks, what causes
>>>>>>>>>>> them
>>>>>>>>>>> and how
>>>>>>>>>>> we can prevent them.  Also an explanation as to why we see
>> them
>>>>>>>>>>> so
>>>>>>>>>>> seldom in
>>>>>>>>>>> real production.  I've got material prepared for this
>> workshop.
>>>>>>>>>>> And
>>>>>>>>>>> then a
>>>>>>>>>>> practical part to the workshop where they can try to find a
>>>>>>>>>>> deadlock
>>>>>>>>>>> in a
>>>>>>>>>>> body of code.
>>>>>>>>>>>
>>>>>>>>>>> Attached is an example of the workshop.  You can try find the
>>>>>>>>>>> deadlock if you like.  I've shown it to almost 100 good Java
>>>>>>>>>>> developers and
>>>>>>>>>>> so far, not one has found it by themselves.  I would expect
>> that
>>>>>>>>>>> they should
>>>>>>>>>>> find it in 5 minutes.  In our workshop they would obviously
>> be
>>>>>>>>>>> helped a bit
>>>>>>>>>>> with hints, so that they can walk away with a good
>> experience.
>>>>>>>>>>> Use
>>>>>>>>>>> anything
>>>>>>>>>>> you like.  Oscilloscope, jstack, jconsole, whatever you like.
>>>>>>>>>>> Only
>>>>>>>>>>> rule for
>>>>>>>>>>> you guys on the "concurrency-interest" list is: you can only
>> look
>>>>>>>>>>> at
>>>>>>>>>>> the
>>>>>>>>>>> code once you've found the problem, otherwise it would be too
>>>>>>>>>>> easy
>>>>>>>>>>> for you
>>>>>>>>>>> :-)  Once you have found it, you can also fix the code and
>> make
>>>>>>>>>>> sure
>>>>>>>>>>> that
>>>>>>>>>>> the code then works correctly.
>>>>>>>>>>> Regards
>>>>>>>>>>>
>>>>>>>>>>> Heinz
>>>>>>>>>>> --
>>>>>>>>>>> Dr Heinz M. Kabutz (PhD CompSci)
>>>>>>>>>>> Author of "The Java(tm) Specialists' Newsletter"
>>>>>>>>>>> Sun Java Champion
>>>>>>>>>>> IEEE Certified Software Development Professional
>>>>>>>>>>> http://www.javaspecialists.eu
>>>>>>>>>>> Tel: +30 69 75 595 262
>>>>>>>>>>> Skype: kabutz
>>>>>>>>>>>
>>>>>>>>>>> On 4/5/12 8:01 PM, Nathan Reynolds wrote:
>>>>>>>>>>>> I am curious as to the intended content of your
>> presentation.
>>>>>>>>>>>>   Here's some ideas.  I wondering what you are planing on
>> doing.
>>>>>>>>>>>>   1. Printing the call stacks with lock information using a
>> tool
>>>>>>>>>>>>     such as jstack
>>>>>>>>>>>>   2. Press the "Detect Deadlock" button in JConsole
>>>>>>>>>>>>   3. Dealing with Lock and Condition objects instead of
>>>>>>>>>>>>     synchronized blocks
>>>>>>>>>>>>   4. Detecting live lock
>>>>>>>>>>>>   5. Distributed deadlocks
>>>>>>>>>>>>
>>>>>>>>>>>> Nathan Reynolds
>>>>>>>>>>>>
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>  |
>>>>>>>>>>>> Consulting
>>>>>>>>>>>> Member of Technical Staff | 602.333.9091
>>>>>>>>>>>> Oracle PSR Engineering<http://psr.us.oracle.com/>  | Server
>>>>>>>>>>>> Technology
>>>>>>>>>>>>
>>>>>>>>>>>> On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:
>>>>>>>>>>>>> Good afternoon,
>>>>>>>>>>>>>
>>>>>>>>>>>>> I am thinking of submitting a talk on finding and
>> diagnosing
>>>>>>>>>>>>> deadlocks for JavaOne.  It might be a workshop, instead of
>> a
>>>>>>>>>>>>> simple
>>>>>>>>>>>>> conference talk.  Or we might be able to turn the talk into
>> a
>>>>>>>>>>>>> workshop where
>>>>>>>>>>>>> they need to find a deadlock in a body of code.  Could be
>>>>>>>>>>>>> something
>>>>>>>>>>>>> different, which might go incredibly well or crash in a
>> blaze
>>>>>>>>>>>>> of
>>>>>>>>>>>>> flames.
>>>>>>>>>>>>>   Would any of you be interested in co-presenting this with
>> me
>>>>>>>>>>>>> at
>>>>>>>>>>>>> JavaOne?
>>>>>>>>>>>>>
>>>>>>>>>>>>> Regards
>>>>>>>>>>>>>
>>>>>>>>>>>>> Heinz
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
>> interest at cs.oswego.edu>
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
>> interest at cs.oswego.edu>
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
>> interest at cs.oswego.edu>
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
>> interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
>> interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>>
>>> Concurrency-interest mailing list
>>>
>>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
>> interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>> This email and any files transmitted with it contain confidential and
>>> proprietary information and is solely for the use of the intended
>>> recipient.  If you are not the intended recipient please return the
>> email
>>> to the sender and delete it from your computer and you must not use,
>>> disclose, distribute, copy, print or rely on this email or its
>> contents.
>>> This communication is for informational purposes only.  It is not
>> intended
>>> as an offer or solicitation for the purchase or sale of any financial
>>> instrument or as an official confirmation of any transaction.   Any
>>> comments or statements made herein do not necessarily reflect those
>> of GSA
>>> Capital. GSA Capital Partners LLP is authorised and regulated by the
>>> Financial Services Authority and is registered in England and Wales
>> at
>>> Stratton House, 5 Stratton Street, London W1J 8LA, number OC309261.
>> GSA
>>> Capital Services Limited is registered in England and Wales at the
>> same
>>> address, number 5320529.
>>>
>>>
>>> -------------- next part --------------
>>> An HTML attachment was scrubbed...
>>> URL:
>>> <http://cs.oswego.edu/pipermail/concurrency-
>> interest/attachments/20120410/196f40e9/attachment.html>
>>> ------------------------------
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>> End of Concurrency-interest Digest, Vol 87, Issue 19
>>> ****************************************************
>>>
>>>
>>
>> --
>> Beverly A. Sanders, Ph.D.
>> Associate Professor
>> Department of Computer&  Information Science&  Engineering
>> P.O. Box 116120
>> University of Florida
>> Gainesville, FL 32611-6120
>> www.cise.ufl.edu/~sanders
>> tel: (352) 505-1563
>> fax: (352) 392-1220
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120411/048ea92d/attachment-0001.html>

From hans.boehm at hp.com  Wed Apr 11 18:50:15 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 11 Apr 2012 22:50:15 +0000
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
 Issue 19
In-Reply-To: <4F85BA20.6080600@oracle.com>
References: <mailman.100.1334058314.3324.concurrency-interest@cs.oswego.edu>
	<16982a6c25f2afdfb1a8b3dff0337218.squirrel@webmail.cise.ufl.edu>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235541B3D@G4W3299.americas.hpqcorp.net>
	<4F85BA20.6080600@oracle.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235542454@G4W3299.americas.hpqcorp.net>

Once you know that a program is data-race-free, you know that synchronization-free code regions appear to be atomic, even if they access shared data.  If an observer thread could witness a state in the middle of a synchronization-free code region, then the observer would be engaged in a data race with that synchronization-free region.  We rely on that regularly when optimizing multi-threaded programs; we usually optimize synchronization-free regions almost as though they were sequential code, knowing that another thread can only catch us in the act by introducing a data race.  As a result, it seems to me that data-race-freedom is potentially a very useful tool for a priori narrowing the search space.

Similarly, I believe that you can always find the first data race in a program while considering only context switches at synchronization points.  The execution up to that point is data-race-free, and hence synchronization-free regions behave atomically.  Thus if there is a data race, there has to be an interleaving of synchronization-free regions in which two conflicting operations are in synchronization-free regions not ordered by happens-before.

If you wanted to write a correct Java version of the lock implementation you cite, some of the lock fields would have to be declared volatile, and accesses to those fields would thus be considered synchronization operations.

Thus I think you need to consider context switches at ordinary shared variable accesses only for intentionally racy programs.  And to first-order approximation, you shouldn't be writing those.  And indeed considering context switches at such accesses seems inherently dubious, since compilers don't preserve access order etc. within synchronization-free regions.  You would really have to correctly model the behavior of racy variable accesses in Java, and we don't really know what that is.

It's less clear to me whether any of this actually helps in practice, or whether the search space you eliminate a priori this way would have also been easy to eliminate by other means.

Hans

From: Nathan Reynolds [mailto:nathan.reynolds at oracle.com]
Sent: Wednesday, April 11, 2012 10:07 AM
To: Boehm, Hans
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol 87, Issue 19

When you said synchronization points do you mean communication points?  By communication points, I mean two threads accessing shared data.

Let's say you write a lock based off of the code in this paper.  http://www.cise.ufl.edu/tr/DOC/REP-1992-71.pdf   The paper claims it is correct.  But, can you prove that your implementation is correct?  Concurrency bugs are extremely difficult to find via code inspection.  This is where Java Path Finder can be a huge help.

Java Path Finder employs a lot of tricks to reduce the search space.  For example, operations on objects which are only visible to 1 thread never increase the search space.  Of course, reducing the amount of code tested to only those areas where threads can interact is very helpful.  Reducing the number of threads down to 2 is also very helpful (when possible).  Even so, the search space can still be very large depending upon how complex the concurrent algorithm is.
Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering<http://psr.us.oracle.com/> | Server Technology

On 4/10/2012 10:25 AM, Boehm, Hans wrote:

Naively, this approach seems like a bit of overkill.  Once you know that the program is data-race-free, which you should be able to determine by considering only context switches at synchronization points, you then know that program behavior can't be affected by context switches anywhere other than at synchronization points.  Thus naively it seems to me that if your target is a data-race-free program, you should be able to greatly reduce the search space.  Am I missing something?  Or are there other techniques that effectively already take advantage of this?



Hans



-----Original Message-----

From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-

interest-bounces at cs.oswego.edu<mailto:interest-bounces at cs.oswego.edu>] On Behalf Of Beverly Sanders

Sent: Tuesday, April 10, 2012 5:52 AM

To: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>

Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol

87, Issue 19





There is an extension to java pathfinder that can precisely detect data

races as defined by the JMM, and thus works for lock-free algorithms

that

use volatiles and atomics.



http://babelfish.arc.nasa.gov/trac/jpf/wiki/projects/jpf-racefinder



I'm not sure if the tool has kept up with the latest changes to jpf,

but

expressions of interest could encourage that to happen.



Generally, you would want to to check your program with standard JPF

first, then use jpf-racefinder to make sure there are no data races.

If

the program is data-race free, then standard JPF is sound.



(If you are intersted in using JPF to reason about Java programs that

intentionally have, presumably benign, data races, please contact me.

See

the paper by Jin, Yavuz-Khaveci and Sanders in TACAS'12)





On Tue, April 10, 2012 7:45 am, concurrency-interest-

request at cs.oswego.edu<mailto:request at cs.oswego.edu>

wrote:

Send Concurrency-interest mailing list submissions to

  concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>



To subscribe or unsubscribe via the World Wide Web, visit

  http://cs.oswego.edu/mailman/listinfo/concurrency-interest

or, via email, send a message with subject or body 'help' to

  concurrency-interest-request at cs.oswego.edu<mailto:concurrency-interest-request at cs.oswego.edu>



You can reach the person managing the list at

  concurrency-interest-owner at cs.oswego.edu<mailto:concurrency-interest-owner at cs.oswego.edu>



When replying, please edit your Subject line so it is more specific

than "Re: Contents of Concurrency-interest digest..."





Today's Topics:



   1. Re: Joint Talk for JavaOne? (Kearney, Joe)





---------------------------------------------------------------------

-



Message: 1

Date: Tue, 10 Apr 2012 12:44:58 +0100

From: "Kearney, Joe" <Joe.Kearney at gsacapital.com><mailto:Joe.Kearney at gsacapital.com>

To: Nathan Reynolds <nathan.reynolds at oracle.com><mailto:nathan.reynolds at oracle.com>

Cc: "Concurrency-interest at cs.oswego.edu"<mailto:Concurrency-interest at cs.oswego.edu>

  <Concurrency-interest at cs.oswego.edu><mailto:Concurrency-interest at cs.oswego.edu>

Subject: Re: [concurrency-interest] Joint Talk for JavaOne?

Message-ID:

  <9319F360221C65428EA819A4E8DC34ED03A399B03C at OPMBOX21UK.options<mailto:9319F360221C65428EA819A4E8DC34ED03A399B03C at OPMBOX21UK.options>-

it.com>

Content-Type: text/plain; charset="iso-8859-1"



Does lack of support for volatile fields render this tool useless for

testing non-blocking concurrency and concurrent programs that don't

only

use synchronized blocks?



In particular does it support locking through LockSupport, AQS and

friends

- for example does it understand uses of Phaser or CyclicBarrier?



Is there a list somewhere of these limitations? Perhaps these things

are

spread around the sub-projects.



Thanks,

Joe



From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu>

[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of

Nathan

Reynolds

Sent: 09 April 2012 17:44

To: Mohan Radhakrishnan

Cc: Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

Subject: Re: [concurrency-interest] Joint Talk for JavaOne?



Java Path Finder is great for finding deadlocks and data races.

However,

it has its limitations.



 1.  The search space is exponential in the number of threads (i.e.

O(2t)).  This program has way too many threads.  One would have to

reduce

the threads to a bare minimum.

 2.  The Java Memory Model (i.e. volatile fields) isn't supported.

That

isn't a problem in this case but something to be aware of.



Otherwise, I rely on Java Path Finder to prove that my code is going

to

work in concurrent situations.  It has found a ton of concurrency

bugs in

my code.

Nathan



Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds><http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>

|

Consulting Member of Technical Staff | 602.333.9091

Oracle PSR Engineering<http://psr.us.oracle.com/><http://psr.us.oracle.com/> | Server Technology



On 4/8/2012 8:23 PM, Mohan Radhakrishnan wrote:

I could look at the first deadlock by dumping locks and threads. I

was

planning to find the next one using Java Path Finder but I think it

is not

recommended for such a big codebase. I am not sure. Its heuristics

might

take too much memory.



Mohan

On Mon, Apr 9, 2012 at 3:59 AM,

<mabrouk2005 at gmail.com<mailto:mabrouk2005 at gmail.com><mailto:mabrouk2005 at gmail.com><mailto:mabrouk2005 at gmail.com>> wrote:

Nice exercise Dr Heinz,



As others mentioned there were 2 kind of deadlocks the first one was

very is easy to find via jconsole so likeI thought that was it and

went and fixed that but then when ran it again it hang it so I knew

thee was more. the interesting thing the jconsole did not detect the

AWT deadlock it showed no deadlock even though the app hang. I had to

force stack dump and get clues to where is the deadlock. Does anyone

have experienced something like this with jconsole not detecting AWT

deadlocks?



Thanks again for the nice exercise and the great java news letter I

am

a big fan.



Cheers,

Mabrouk



On Sat, Apr 7, 2012 at 7:42 AM, Remi Forax

<forax at univ-mlv.fr<mailto:forax at univ-mlv.fr><mailto:forax at univ-mlv.fr><mailto:forax at univ-mlv.fr>> wrote:

No, it's more an AWRY or Java2D bug.



R?mi



Sent from my Phone





----- Reply message -----

From: "Ben Evans"



<benjamin.john.evans at gmail.com<mailto:benjamin.john.evans at gmail.com><mailto:benjamin.john.evans at gmail.com><mailto:benjamin.john.evans at gmail.com>>

To: "Dr Heinz M. Kabutz"

<heinz at javaspecialists.eu<mailto:heinz at javaspecialists.eu><mailto:heinz at javaspecialists.eu><mailto:heinz at javaspecialists.eu>>

Cc: "R?mi Forax" <forax at univ-mlv.fr<mailto:forax at univ-mlv.fr><mailto:forax at univ-mlv.fr><mailto:forax at univ-mlv.fr>>,

<concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu><mailto:concurrency-

interest at cs.oswego.edu<mailto:interest at cs.oswego.edu>>>

Subject: [concurrency-interest] Joint Talk for JavaOne?

Date: Sat, Apr 7, 2012 10:43





Heinz, was this with the new jdk8 + lambda build?



If so, we should report this crash back to lambda-dev.



Thanks,



Ben



On Sat, Apr 7, 2012 at 11:17 AM, Dr Heinz M. Kabutz

<heinz at javaspecialists.eu<mailto:heinz at javaspecialists.eu><mailto:heinz at javaspecialists.eu><mailto:heinz at javaspecialists.eu>> wrote:

I see JDK8 crashes even with the vanilla Java2Demo from JDK 1.6.  I

see

that

the Java2Demo has been removed from the demos folder of JDK 1.7 and

1.8.

 It

thus is a Java 8 issue, rather than the changes I made to the code.

 Thanks

for the warning R?mi.





Regards



Heinz

--

Dr Heinz M. Kabutz (PhD CompSci)

Author of "The Java(tm) Specialists' Newsletter"

Sun Java Champion

IEEE Certified Software Development Professional

http://www.javaspecialists.eu

Tel: +30 69 75 595 262

Skype: kabutz





On 4/6/12 1:51 AM, R?mi Forax wrote:



jdk8 crashes if I click on images of the tapped pane.



R?mi



On 04/05/2012 10:35 PM, Dr Heinz M. Kabutz wrote:



Yes, you are correct.



However, the mistake most programmers make is to #1 scratch

around in

the

source code to try and discover the problem and #2 then fix it

without

really understanding what they are doing.  I think the lesson is

bigger

if

we give them the source code.  In addition, it is probably more

difficult to

solve if you have the sources to muse over.

Regards



Heinz

--

Dr Heinz M. Kabutz (PhD CompSci)

Author of "The Java(tm) Specialists' Newsletter"

Sun Java Champion

IEEE Certified Software Development Professional

http://www.javaspecialists.eu

Tel: +30 69 75 595 262

Skype: kabutz





On 4/5/12 11:30 PM, Nathan Reynolds wrote:



I guess it is a good idea to not initially include the source

code

in

the workshop because many times I initially don't have the

source

code

when

trying to figure out performance or scalability problems.



Nathan Reynolds

<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds><http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |

Consulting

Member of Technical Staff | 602.333.9091

Oracle PSR Engineering <http://psr.us.oracle.com/><http://psr.us.oracle.com/> | Server

Technology



On 4/5/2012 1:22 PM, Dr Heinz M. Kabutz wrote:



Sorry Nathan, here is the zip file including the source code an

an

Ant

script to build the code.  Sorry for accidentally excluding

that

from

the

file I sent earlier.  The problem was between the chair and the

keyboard.

 However, one should be able to pinpoint the deadlock without

seeing a

line

of code.  At the workshop I presented in Spain last week, most

of

the

programmers immediately started delving into the code before

they

knew

where

to look.

Regards



Heinz

--

Dr Heinz M. Kabutz (PhD CompSci)

Author of "The Java(tm) Specialists' Newsletter"

Sun Java Champion

IEEE Certified Software Development Professional

http://www.javaspecialists.eu

Tel: +30 69 75 595 262

Skype: kabutz



On 4/5/12 10:29 PM, Nathan Reynolds wrote:



I took the bait and tried out the demo on HotSpot 7 Update 3.

It

didn't deadlock for a minute or two.  Then the application

froze.

I

then

used jstack to dump the call stacks.  At the end of the

report, it

said

"Found one Java-level deadlock".  It then dumped out the locks

and

threads

involved in the deadlock.  I never looked at the source

code... in

fact it

wasn't in the zip file.  This took about 5-7 minutes from

starting

the

application to finding the deadlock in the call stacks.



A 100 good Java developers?  Really?  I guess I can

understand.

Most

engineers don't understand locks.  Most of the time I get

answers

like one

should put a lock around shared variables.  This is accurate

but

they

can't

really go any deeper.



It sounds like the material of your presentation should be

very

good.

 It covers things that the deadlock detection tool probably

can't

figure

out.



So, it seems like you have everything figured out.  Why do you

need

someone else?



Nathan Reynolds

<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds><http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>

|

Consulting

Member of Technical Staff | 602.333.9091

Oracle PSR Engineering <http://psr.us.oracle.com/><http://psr.us.oracle.com/> | Server

Technology



On 4/5/2012 12:03 PM, Dr Heinz M. Kabutz wrote:



Hi Nathan,



a stack trace will only show you a certain class of obvious

deadlocks

that are easy to find and solve.  I remember solving

deadlocks

/before/ we

had the brilliant deadlock detection tool in the

ThreadMXBean.

Yes,

the

deadlock detection tool shows you /some/ deadlocks, but

definitely

not all

of them.  I can think of a bunch that it would not find:



1. Semaphores running out of permits

2. ReadWriteLocks trying to upgrade from write lock to read

lock

3. Resource deadlocks



And some others that I will not describe in detail, such as

some

nasty livelocks that we can cause which will hang up the JVM

:-)



I agree with Kirk - it should probably be a 3 hour workshop.

I've

done this three times now - twice in Spain and once via

webinar.

 The

workshop would involve some lessons on deadlocks, what causes

them

and how

we can prevent them.  Also an explanation as to why we see

them

so

seldom in

real production.  I've got material prepared for this

workshop.

And

then a

practical part to the workshop where they can try to find a

deadlock

in a

body of code.



Attached is an example of the workshop.  You can try find the

deadlock if you like.  I've shown it to almost 100 good Java

developers and

so far, not one has found it by themselves.  I would expect

that

they should

find it in 5 minutes.  In our workshop they would obviously

be

helped a bit

with hints, so that they can walk away with a good

experience.

Use

anything

you like.  Oscilloscope, jstack, jconsole, whatever you like.

Only

rule for

you guys on the "concurrency-interest" list is: you can only

look

at

the

code once you've found the problem, otherwise it would be too

easy

for you

:-)  Once you have found it, you can also fix the code and

make

sure

that

the code then works correctly.

Regards



Heinz

--

Dr Heinz M. Kabutz (PhD CompSci)

Author of "The Java(tm) Specialists' Newsletter"

Sun Java Champion

IEEE Certified Software Development Professional

http://www.javaspecialists.eu

Tel: +30 69 75 595 262

Skype: kabutz



On 4/5/12 8:01 PM, Nathan Reynolds wrote:



I am curious as to the intended content of your

presentation.

 Here's some ideas.  I wondering what you are planing on

doing.



 1. Printing the call stacks with lock information using a

tool

   such as jstack

 2. Press the "Detect Deadlock" button in JConsole

 3. Dealing with Lock and Condition objects instead of

   synchronized blocks

 4. Detecting live lock

 5. Distributed deadlocks



Nathan Reynolds



<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds><http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |

Consulting

Member of Technical Staff | 602.333.9091

Oracle PSR Engineering <http://psr.us.oracle.com/><http://psr.us.oracle.com/> | Server

Technology



On 4/5/2012 7:57 AM, Dr Heinz M. Kabutz wrote:



Good afternoon,



I am thinking of submitting a talk on finding and

diagnosing

deadlocks for JavaOne.  It might be a workshop, instead of

a

simple

conference talk.  Or we might be able to turn the talk into

a

workshop where

they need to find a deadlock in a body of code.  Could be

something

different, which might go incredibly well or crash in a

blaze

of

flames.

 Would any of you be interested in co-presenting this with

me

at

JavaOne?



Regards



Heinz







_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu><mailto:Concurrency-

interest at cs.oswego.edu<mailto:interest at cs.oswego.edu>>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest





_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu><mailto:Concurrency-

interest at cs.oswego.edu<mailto:interest at cs.oswego.edu>>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest



_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu><mailto:Concurrency-

interest at cs.oswego.edu<mailto:interest at cs.oswego.edu>>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest



_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu><mailto:Concurrency-

interest at cs.oswego.edu<mailto:interest at cs.oswego.edu>>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest





_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu><mailto:Concurrency-

interest at cs.oswego.edu<mailto:interest at cs.oswego.edu>>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest











_______________________________________________



Concurrency-interest mailing list



Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu><mailto:Concurrency-

interest at cs.oswego.edu<mailto:interest at cs.oswego.edu>>



http://cs.oswego.edu/mailman/listinfo/concurrency-interest





This email and any files transmitted with it contain confidential and

proprietary information and is solely for the use of the intended

recipient.  If you are not the intended recipient please return the

email

to the sender and delete it from your computer and you must not use,

disclose, distribute, copy, print or rely on this email or its

contents.

This communication is for informational purposes only.  It is not

intended

as an offer or solicitation for the purchase or sale of any financial

instrument or as an official confirmation of any transaction.   Any

comments or statements made herein do not necessarily reflect those

of GSA

Capital. GSA Capital Partners LLP is authorised and regulated by the

Financial Services Authority and is registered in England and Wales

at

Stratton House, 5 Stratton Street, London W1J 8LA, number OC309261.

GSA

Capital Services Limited is registered in England and Wales at the

same

address, number 5320529.





-------------- next part --------------

An HTML attachment was scrubbed...

URL:

<http://cs.oswego.edu/pipermail/concurrency-

interest/attachments/20120410/196f40e9/attachment.html>



------------------------------



_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest





End of Concurrency-interest Digest, Vol 87, Issue 19

****************************************************









--

Beverly A. Sanders, Ph.D.

Associate Professor

Department of Computer & Information Science & Engineering

P.O. Box 116120

University of Florida

Gainesville, FL 32611-6120

www.cise.ufl.edu/~sanders<http://www.cise.ufl.edu/~sanders>

tel: (352) 505-1563

fax: (352) 392-1220



_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest



_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120411/d3359572/attachment-0001.html>

From rohitk242 at yahoo.co.in  Mon Apr 16 07:03:59 2012
From: rohitk242 at yahoo.co.in (Rohit Kumar)
Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT)
Subject: [concurrency-interest] (no subject)
Message-ID: <1334574239.81244.YahooMailNeo@web193402.mail.sg3.yahoo.com>

Hi All,
?
I have found a way of preventing deadlocks in java. The methodology(which is code) completely prevents the deadlock from accuring by detecting it in advance. This can be used across the systems seamlessly. 
?
Kindly let me know what I need to do next. I want this to be part of next jdk release.
?
Thanks & Regards,
Rohit Kumar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/a6588341/attachment.html>

From rohitk242 at yahoo.co.in  Mon Apr 16 07:06:22 2012
From: rohitk242 at yahoo.co.in (Rohit Kumar)
Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)
Subject: [concurrency-interest] Java Deadlocks prevented
In-Reply-To: <1334574239.81244.YahooMailNeo@web193402.mail.sg3.yahoo.com>
References: <1334574239.81244.YahooMailNeo@web193402.mail.sg3.yahoo.com>
Message-ID: <1334574382.90584.YahooMailNeo@web193403.mail.sg3.yahoo.com>



Hi All,

I have found a way of preventing deadlocks in java. The methodology(which is code) completely prevents the deadlock from occuring by detecting it in advance. This can be used across the systems seamlessly. 

Kindly let me know what I need to do next. I want this to be part of next jdk release. I am writing this email as I have no idea what I need to do next to bring it into limelight.

Thanks & Regards,
Rohit Kumar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/064a4873/attachment.html>

From aph at redhat.com  Mon Apr 16 07:33:45 2012
From: aph at redhat.com (Andrew Haley)
Date: Mon, 16 Apr 2012 12:33:45 +0100
Subject: [concurrency-interest] Java Deadlocks prevented
In-Reply-To: <1334574382.90584.YahooMailNeo@web193403.mail.sg3.yahoo.com>
References: <1334574239.81244.YahooMailNeo@web193402.mail.sg3.yahoo.com>
	<1334574382.90584.YahooMailNeo@web193403.mail.sg3.yahoo.com>
Message-ID: <4F8C0399.8040301@redhat.com>

On 04/16/2012 12:06 PM, Rohit Kumar wrote:

> I have found a way of preventing deadlocks in java. The
> methodology(which is code) completely prevents the deadlock from
> occuring by detecting it in advance. This can be used across the
> systems seamlessly.
> 
> Kindly let me know what I need to do next. I want this to be part of
> next jdk release. I am writing this email as I have no idea what I
> need to do next to bring it into limelight.

Write it up, maybe present it to a conference, and wait for feedback.
That's how it always works.  If your idea really works, people will
use it.

Andrew.

From wolfgang.baltes at laposte.net  Mon Apr 16 10:48:31 2012
From: wolfgang.baltes at laposte.net (Wolfgang Baltes)
Date: Mon, 16 Apr 2012 16:48:31 +0200
Subject: [concurrency-interest] CountedCompleters
In-Reply-To: <4F82EF21.4020804@cs.oswego.edu>
References: <4F82EF21.4020804@cs.oswego.edu>
Message-ID: <4F8C313F.2080308@laposte.net>

Thanks, Doug, for a this addition to the FJ framework. I think that 
CountedCompleter will address the needs of an entire class of 
applications in an efficient and simple to use manner.

I used the code and noticed that method doJoin() has become more 
effective in avoiding blocking threads, and as a result fewer extra 
threads are created. I found the performance, compared to 
RecursiveAction, to be equal or insignificantly different. This reduces 
the problem described in item 3 below.

However, at the same time, CountedCompleter does not fully satisfy the 
needs for a class of problems I work on. To this end, here are a few 
enhancements I would like to suggest:

1: Symmetrically to onCompletion(), provide 
onExceptionalCompletion(Throwable). This allows filtering exception 
propagation. There are cases where the propagation of the exception is 
desired, and others where a corrective action is taken instead, such as 
a retry.

2: As a further enhancement to 1: enable any Throwable, including 
checked exceptions. This allows the use of a CountedCompleter as a 
CompletionHandler for asynchronous IO operations or as a wrapper for 
MethodHandles (which throw Throwable) without adding extra logic to 
capture and convert an IO exception. I read the documentation which 
explains why this is currently limited to unchecked exceptions. While I 
can agree with this in general, I feel the argument is weak for 
CountedCompleter if it is there to support asynchronous tasks/events. 
(May I add that using this type of framework is not for the 
faint-hearted anyway!?)

3: Provide a method to join a task that is not forked and/or not 
completable, while minimizing worker thread blocking. For example, 
CountedCompleter allows creating chains of dependent tasks. Unless the 
ultimate task (the last in the chain) is forked/exists on the task stack 
AND can complete because all dependencies are resolved, joining it will 
block the worker thread. I noticed (and my testing is limited to a few 
test cases and therefore not representative) the blocking and the 
creation of other worker threads, ultimately running out of memory or 
reaching the thread count limit. If this task is not forked, then 
join()/quietlyJoin() will block the worker thread. The following code is 
my (inexpert) attempt to provide a remedy. It is based on the assumption 
that a task that depends on others for completion is not forked until 
all dependencies are resolved. For example, a CountedCompleter 
implementing CompletionHandler would fork itself ("implicit fork") when 
the IO operation is done. This works very well in my test cases, but at 
this time I would not claim it to be universally applicable or error 
free. It is shown here more to demonstrate the attempt rather than as a 
reference implementation. With access to private data structures, this 
can be done more elegantly and more reliably.

         static final int RETRIES = 16;
         static final long WAIT_TIMEOUT = 1_000;     // Timeout in 
microseconds.

         public final void quietlyJoinUnforked() {
             this.doJoinUnforked(false);
         }

         public final void quietlyJoinUnforkedInterruptibly()
         throws InterruptedException {
             if (this.doJoinUnforked(true)) {
                 throw new InterruptedException();
             }
         }

         public final boolean doJoinUnforked(final boolean interruptibly) {
             int retries = RETRIES;
             boolean wasInterrupted = false;
             while (!this.isDone()) {
                 ForkJoinTask<?> t;
                 if ((t = pollTask()) != null) {
                     t.quietlyInvoke();
                     if (t == this) {
                         break;
                     }
                 }
                 else {
                     if (retries-- > 0) {
                         Thread.yield();
                         continue;
                     }
                     wasInterrupted = Thread.interrupted();
                     try {
                         // get(...) is used as a timed join(). It is 
assumed that
                         // other code will perform get() on this task 
to retrieve
                         // the task's result or exception.
                         this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
                         break;
                     }
                     catch (final InterruptedException consumed) {
                         if (!interruptibly) {
                             wasInterrupted = true;
                             continue;
                         }
                         return true;
                     }
                     catch (final ExecutionException ignored) {
                         // See comment on get() above.
                         break;
                     }
                     catch (final TimeoutException ignored) {
                         continue;
                     }
                 }
                 retries = RETRIES;
             }
             if (wasInterrupted && !interruptibly) {
                 Thread.currentThread().interrupt();
                 return false;
             }
             return wasInterrupted;
         }

As already mentioned this works quite well in a number of cases. For 
example, adding this method to the example MergeSort code and calling 
quietlyJoinUnforked(), results in the same overall performance, reduces 
the number of extra blocked worker threads to 1 if any (instead of up to 
8 for the unmodified code; on a PC with 4 hyper-threading cores/8 
threads), and allows for some extra (recreational?) freedom in joining 
the right and left sub-tasks in any order. It works in cases where no 
sub-task is forked explicitly. I observed that worker thread blocking 
only occurs towards the end of a large recursion, suggesting that worker 
threads only block - as intended - when there is no other work available 
(sometimes while implicit forking has not yet happened).

Wolfgang.



On 2012-04-09 16:16, Doug Lea wrote:
>
> After sitting on multiple variations for months, I committed
> CountedCompleter, a completion-based flavor of ForkJoinTask.
>
> As mentioned a few times over the past year, the main motivation
> is to better support tasks that perform IO or other base
> actions that may (or may not) take a lot of time to execute.
> As is the case with JDK7 async IO and other completion-based
> frameworks, the most common path to efficiency is for such tasks
> to arrange continuation actions that occur upon their completion.
> The main twist for CountedCompleters is that continuations
> might be dependent on multiple actions, not just one. (Or in
> other words, the continuations must be preceded by a specialized,
> "bottom-up" form of join.)
>
> The CountedCompleter abstract class provides a minimal basis
> for these kinds of tasks. While some of the mechanics are
> reminiscent of other FJ-like frameworks such as Intel TBB,
> CountedCompleters are designed to fit smoothly with other
> kinds of ForkJoinTasks (like RecursiveActions), and so still
> allow people to use the more pleasant Future-style conventions
> rather than count-based bottom-up joining unless they need them.
> At the same time, the CountedCompleter class exposes enough
> mechanics to allow all sorts of tweaks that people can use
> to improve performance.
> In particular, in addition to usually being the best way to deal
> with IO etc bound tasks, CountedCompleters sometimes fare better
> than RecursiveActions in programs that entail lots of garbage
> collection because GC can have similar impact on task variability.
>
> Even though targeted for JDK8, versions of CountedCompleter
> appear in the jsr166y and main repositories, not jsr166e. This is
> because they require a non-public hook into modified ForkJoinTask
> exception handling mechanics in order to properly propagate
> exceptional completions. For sources, docs, and jar files, see
> the usual links at 
> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>
> The API docs include more details and some examples:
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html 
>
>
> I also added a few (with more to come) test/demo programs that illustrate
> other usages. See CCBoxedLongSort and CCJacobi in
> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
>
> Please try these out. As always, comments and suggestions
> (hopefully based on usage experience) would be welcome.
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From wolfgang.baltes at laposte.net  Mon Apr 16 12:01:50 2012
From: wolfgang.baltes at laposte.net (Wolfgang Baltes)
Date: Mon, 16 Apr 2012 18:01:50 +0200
Subject: [concurrency-interest] CountedCompleters
In-Reply-To: <4F8C313F.2080308@laposte.net>
References: <4F82EF21.4020804@cs.oswego.edu> <4F8C313F.2080308@laposte.net>
Message-ID: <4F8C426E.6090704@laposte.net>

I apologize for a mistake in the last paragraph of my memo: using 
quietlyJoinUnforked() in the SDK7 sample code for MergeSort does have a 
non-negligible performance impact (not no impact as stated). There is 
better performance in case of recursions which produce many tasks that 
are not explicitly forked, and it reduces the number of extra threads 
significantly, allowing larger problems to be solved with smaller memory 
footprint.

Wolfgang.

On 2012-04-16 16:48, Wolfgang Baltes wrote:
> Thanks, Doug, for a this addition to the FJ framework. I think that
> CountedCompleter will address the needs of an entire class of
> applications in an efficient and simple to use manner.
>
> I used the code and noticed that method doJoin() has become more
> effective in avoiding blocking threads, and as a result fewer extra
> threads are created. I found the performance, compared to
> RecursiveAction, to be equal or insignificantly different. This
> reduces the problem described in item 3 below.
>
> However, at the same time, CountedCompleter does not fully satisfy the
> needs for a class of problems I work on. To this end, here are a few
> enhancements I would like to suggest:
>
> 1: Symmetrically to onCompletion(), provide
> onExceptionalCompletion(Throwable). This allows filtering exception
> propagation. There are cases where the propagation of the exception is
> desired, and others where a corrective action is taken instead, such
> as a retry.
>
> 2: As a further enhancement to 1: enable any Throwable, including
> checked exceptions. This allows the use of a CountedCompleter as a
> CompletionHandler for asynchronous IO operations or as a wrapper for
> MethodHandles (which throw Throwable) without adding extra logic to
> capture and convert an IO exception. I read the documentation which
> explains why this is currently limited to unchecked exceptions. While
> I can agree with this in general, I feel the argument is weak for
> CountedCompleter if it is there to support asynchronous tasks/events.
> (May I add that using this type of framework is not for the
> faint-hearted anyway!?)
>
> 3: Provide a method to join a task that is not forked and/or not
> completable, while minimizing worker thread blocking. For example,
> CountedCompleter allows creating chains of dependent tasks. Unless the
> ultimate task (the last in the chain) is forked/exists on the task
> stack AND can complete because all dependencies are resolved, joining
> it will block the worker thread. I noticed (and my testing is limited
> to a few test cases and therefore not representative) the blocking and
> the creation of other worker threads, ultimately running out of memory
> or reaching the thread count limit. If this task is not forked, then
> join()/quietlyJoin() will block the worker thread. The following code
> is my (inexpert) attempt to provide a remedy. It is based on the
> assumption that a task that depends on others for completion is not
> forked until all dependencies are resolved. For example, a
> CountedCompleter implementing CompletionHandler would fork itself
> ("implicit fork") when the IO operation is done. This works very well
> in my test cases, but at this time I would not claim it to be
> universally applicable or error free. It is shown here more to
> demonstrate the attempt rather than as a reference implementation.
> With access to private data structures, this can be done more
> elegantly and more reliably.
>
>         static final int RETRIES = 16;
>         static final long WAIT_TIMEOUT = 1_000;     // Timeout in
> microseconds.
>
>         public final void quietlyJoinUnforked() {
>             this.doJoinUnforked(false);
>         }
>
>         public final void quietlyJoinUnforkedInterruptibly()
>         throws InterruptedException {
>             if (this.doJoinUnforked(true)) {
>                 throw new InterruptedException();
>             }
>         }
>
>         public final boolean doJoinUnforked(final boolean
> interruptibly) {
>             int retries = RETRIES;
>             boolean wasInterrupted = false;
>             while (!this.isDone()) {
>                 ForkJoinTask<?> t;
>                 if ((t = pollTask()) != null) {
>                     t.quietlyInvoke();
>                     if (t == this) {
>                         break;
>                     }
>                 }
>                 else {
>                     if (retries-- > 0) {
>                         Thread.yield();
>                         continue;
>                     }
>                     wasInterrupted = Thread.interrupted();
>                     try {
>                         // get(...) is used as a timed join(). It is
> assumed that
>                         // other code will perform get() on this task
> to retrieve
>                         // the task's result or exception.
>                         this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
>                         break;
>                     }
>                     catch (final InterruptedException consumed) {
>                         if (!interruptibly) {
>                             wasInterrupted = true;
>                             continue;
>                         }
>                         return true;
>                     }
>                     catch (final ExecutionException ignored) {
>                         // See comment on get() above.
>                         break;
>                     }
>                     catch (final TimeoutException ignored) {
>                         continue;
>                     }
>                 }
>                 retries = RETRIES;
>             }
>             if (wasInterrupted && !interruptibly) {
>                 Thread.currentThread().interrupt();
>                 return false;
>             }
>             return wasInterrupted;
>         }
>
> As already mentioned this works quite well in a number of cases. For
> example, adding this method to the example MergeSort code and calling
> quietlyJoinUnforked(), results in the same overall performance,
> reduces the number of extra blocked worker threads to 1 if any
> (instead of up to 8 for the unmodified code; on a PC with 4
> hyper-threading cores/8 threads), and allows for some extra
> (recreational?) freedom in joining the right and left sub-tasks in any
> order. It works in cases where no sub-task is forked explicitly. I
> observed that worker thread blocking only occurs towards the end of a
> large recursion, suggesting that worker threads only block - as
> intended - when there is no other work available (sometimes while
> implicit forking has not yet happened).
>
> Wolfgang.
>
>
>
> On 2012-04-09 16:16, Doug Lea wrote:
>>
>> After sitting on multiple variations for months, I committed
>> CountedCompleter, a completion-based flavor of ForkJoinTask.
>>
>> As mentioned a few times over the past year, the main motivation
>> is to better support tasks that perform IO or other base
>> actions that may (or may not) take a lot of time to execute.
>> As is the case with JDK7 async IO and other completion-based
>> frameworks, the most common path to efficiency is for such tasks
>> to arrange continuation actions that occur upon their completion.
>> The main twist for CountedCompleters is that continuations
>> might be dependent on multiple actions, not just one. (Or in
>> other words, the continuations must be preceded by a specialized,
>> "bottom-up" form of join.)
>>
>> The CountedCompleter abstract class provides a minimal basis
>> for these kinds of tasks. While some of the mechanics are
>> reminiscent of other FJ-like frameworks such as Intel TBB,
>> CountedCompleters are designed to fit smoothly with other
>> kinds of ForkJoinTasks (like RecursiveActions), and so still
>> allow people to use the more pleasant Future-style conventions
>> rather than count-based bottom-up joining unless they need them.
>> At the same time, the CountedCompleter class exposes enough
>> mechanics to allow all sorts of tweaks that people can use
>> to improve performance.
>> In particular, in addition to usually being the best way to deal
>> with IO etc bound tasks, CountedCompleters sometimes fare better
>> than RecursiveActions in programs that entail lots of garbage
>> collection because GC can have similar impact on task variability.
>>
>> Even though targeted for JDK8, versions of CountedCompleter
>> appear in the jsr166y and main repositories, not jsr166e. This is
>> because they require a non-public hook into modified ForkJoinTask
>> exception handling mechanics in order to properly propagate
>> exceptional completions. For sources, docs, and jar files, see
>> the usual links at
>> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>>
>> The API docs include more details and some examples:
>> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
>>
>>
>> I also added a few (with more to come) test/demo programs that
>> illustrate
>> other usages. See CCBoxedLongSort and CCJacobi in
>> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
>>
>> Please try these out. As always, comments and suggestions
>> (hopefully based on usage experience) would be welcome.
>>
>> -Doug
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From hans.boehm at hp.com  Mon Apr 16 12:38:00 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Mon, 16 Apr 2012 16:38:00 +0000
Subject: [concurrency-interest] Java Deadlocks prevented
In-Reply-To: <4F8C0399.8040301@redhat.com>
References: <1334574239.81244.YahooMailNeo@web193402.mail.sg3.yahoo.com>
	<1334574382.90584.YahooMailNeo@web193403.mail.sg3.yahoo.com>
	<4F8C0399.8040301@redhat.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B@G4W3299.americas.hpqcorp.net>

Important questions to consider when you write it up:

How does it compare to something like Gadara that uses whole program analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it doesn't need whole program analysis.)  Other deadlock avoidance schemes?

Once you detect a potential deadlock, how do you recover?  Or can you always schedule so that the possibility doesn't arise?

Hans

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
> Sent: Monday, April 16, 2012 4:34 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> 
> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
> 
> > I have found a way of preventing deadlocks in java. The
> > methodology(which is code) completely prevents the deadlock from
> > occuring by detecting it in advance. This can be used across the
> > systems seamlessly.
> >
> > Kindly let me know what I need to do next. I want this to be part of
> > next jdk release. I am writing this email as I have no idea what I
> > need to do next to bring it into limelight.
> 
> Write it up, maybe present it to a conference, and wait for feedback.
> That's how it always works.  If your idea really works, people will
> use it.
> 
> Andrew.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From nathan.reynolds at oracle.com  Mon Apr 16 13:11:00 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 16 Apr 2012 10:11:00 -0700
Subject: [concurrency-interest] Java Deadlocks prevented
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B@G4W3299.americas.hpqcorp.net>
References: <1334574239.81244.YahooMailNeo@web193402.mail.sg3.yahoo.com>
	<1334574382.90584.YahooMailNeo@web193403.mail.sg3.yahoo.com>
	<4F8C0399.8040301@redhat.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B@G4W3299.americas.hpqcorp.net>
Message-ID: <4F8C52A4.70002@oracle.com>

Deadlock prevention is very valuable.  It means deadlock prone code 
won't bring down a production server and cost the company millions in 
down time.  It means consumers won't kill the process and request a refund.

How much does deadlock prevention cost?  Is the cost on the thread that 
acquires locks or is it in a background thread?

Each time processors or systems increase the number of cores, I find we 
have to do a round of lock contention fixing.  I have only seen 1 lock 
at a time be the bottleneck in the system.  Does deadlock prevention 
increase the critical region of locks?  If so, this will definitely 
reduce the scalability of the system if it impacts the 1 bottlenecking lock.

Lock performance is a very important consideration.  Locks have evolved 
from fat locks (i.e trips into the OS kernel) to thin locks (i.e. spin 
and CAS in user mode) to biased/lazy locks (i.e. no CAS and an 
indefinite lock owner).  All of this was done to reduce the performance 
overhead of locks.  How does deadlock prevention impact the performance 
of biased, thin and fat locks?  I am not as concerned about fat lock 
performance since most of the time the thread is going to block.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/16/2012 9:38 AM, Boehm, Hans wrote:
> Important questions to consider when you write it up:
>
> How does it compare to something like Gadara that uses whole program analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it doesn't need whole program analysis.)  Other deadlock avoidance schemes?
>
> Once you detect a potential deadlock, how do you recover?  Or can you always schedule so that the possibility doesn't arise?
>
> Hans
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
>> Sent: Monday, April 16, 2012 4:34 AM
>> To: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Java Deadlocks prevented
>>
>> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>>
>>> I have found a way of preventing deadlocks in java. The
>>> methodology(which is code) completely prevents the deadlock from
>>> occuring by detecting it in advance. This can be used across the
>>> systems seamlessly.
>>>
>>> Kindly let me know what I need to do next. I want this to be part of
>>> next jdk release. I am writing this email as I have no idea what I
>>> need to do next to bring it into limelight.
>> Write it up, maybe present it to a conference, and wait for feedback.
>> That's how it always works.  If your idea really works, people will
>> use it.
>>
>> Andrew.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/7ea89bb3/attachment.html>

From rohitk242 at yahoo.co.in  Mon Apr 16 13:20:15 2012
From: rohitk242 at yahoo.co.in (Rohit Kumar)
Date: Tue, 17 Apr 2012 01:20:15 +0800 (SGT)
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
	Issue 26 (Java deadlock prevented)
In-Reply-To: <mailman.1.1334592007.11165.concurrency-interest@cs.oswego.edu>
References: <mailman.1.1334592007.11165.concurrency-interest@cs.oswego.edu>
Message-ID: <1334596815.27848.YahooMailNeo@web193403.mail.sg3.yahoo.com>

Andrew:
?
Thanks for the reply. Can you kindly let me know where do I need to present it ? Where will the conference be held ? Can I present it online or I have to come in person ?
?
Waiting for your early reply once again.
?
Thanks & Regards,
Rohit Kumar

From: "concurrency-interest-request at cs.oswego.edu" <concurrency-interest-request at cs.oswego.edu>
To: concurrency-interest at cs.oswego.edu 
Sent: Monday, 16 April 2012 9:30 PM
Subject: Concurrency-interest Digest, Vol 87, Issue 26

Send Concurrency-interest mailing list submissions to
??? concurrency-interest at cs.oswego.edu

To subscribe or unsubscribe via the World Wide Web, visit
??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
or, via email, send a message with subject or body 'help' to
??? concurrency-interest-request at cs.oswego.edu

You can reach the person managing the list at
??? concurrency-interest-owner at cs.oswego.edu

When replying, please edit your Subject line so it is more specific
than "Re: Contents of Concurrency-interest digest..."


Today's Topics:

? 1. (no subject) (Rohit Kumar)
? 2. Java Deadlocks prevented (Rohit Kumar)
? 3. Re: Java Deadlocks prevented (Andrew Haley)
? 4. Re: CountedCompleters (Wolfgang Baltes)


----------------------------------------------------------------------

Message: 1
Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT)
From: Rohit Kumar <rohitk242 at yahoo.co.in>
To: "concurrency-interest at cs.oswego.edu"
??? <concurrency-interest at cs.oswego.edu>
Cc: "concurrency-interest-owner at cs.oswego.edu"
??? <concurrency-interest-owner at cs.oswego.edu>
Subject: [concurrency-interest] (no subject)
Message-ID:
??? <1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com>
Content-Type: text/plain; charset="iso-8859-1"

Hi All,
?
I have found a way of preventing deadlocks in java. The methodology(which is code) completely prevents the deadlock from accuring by detecting it in advance. This can be used across the systems seamlessly. 
?
Kindly let me know what I need to do next. I want this to be part of next jdk release.
?
Thanks & Regards,
Rohit Kumar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/a6588341/attachment-0001.html>

------------------------------

Message: 2
Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)
From: Rohit Kumar <rohitk242 at yahoo.co.in>
To: "concurrency-interest at cs.oswego.edu"
??? <concurrency-interest at cs.oswego.edu>
Cc: "concurrency-interest-owner at cs.oswego.edu"
??? <concurrency-interest-owner at cs.oswego.edu>
Subject: [concurrency-interest] Java Deadlocks prevented
Message-ID:
??? <1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com>
Content-Type: text/plain; charset="utf-8"



Hi All,

I have found a way of preventing deadlocks in java. The methodology(which is code) completely prevents the deadlock from occuring by detecting it in advance. This can be used across the systems seamlessly. 

Kindly let me know what I need to do next. I want this to be part of next jdk release. I am writing this email as I have no idea what I need to do next to bring it into limelight.

Thanks & Regards,
Rohit Kumar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/064a4873/attachment-0001.html>

------------------------------

Message: 3
Date: Mon, 16 Apr 2012 12:33:45 +0100
From: Andrew Haley <aph at redhat.com>
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Java Deadlocks prevented
Message-ID: <4F8C0399.8040301 at redhat.com>
Content-Type: text/plain; charset=ISO-8859-1

On 04/16/2012 12:06 PM, Rohit Kumar wrote:

> I have found a way of preventing deadlocks in java. The
> methodology(which is code) completely prevents the deadlock from
> occuring by detecting it in advance. This can be used across the
> systems seamlessly.
> 
> Kindly let me know what I need to do next. I want this to be part of
> next jdk release. I am writing this email as I have no idea what I
> need to do next to bring it into limelight.

Write it up, maybe present it to a conference, and wait for feedback.
That's how it always works.? If your idea really works, people will
use it.

Andrew.


------------------------------

Message: 4
Date: Mon, 16 Apr 2012 16:48:31 +0200
From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
To: "Concurrency-interest at cs.oswego.edu"
??? <Concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] CountedCompleters
Message-ID: <4F8C313F.2080308 at laposte.net>
Content-Type: text/plain; charset=ISO-8859-1; format=flowed

Thanks, Doug, for a this addition to the FJ framework. I think that 
CountedCompleter will address the needs of an entire class of 
applications in an efficient and simple to use manner.

I used the code and noticed that method doJoin() has become more 
effective in avoiding blocking threads, and as a result fewer extra 
threads are created. I found the performance, compared to 
RecursiveAction, to be equal or insignificantly different. This reduces 
the problem described in item 3 below.

However, at the same time, CountedCompleter does not fully satisfy the 
needs for a class of problems I work on. To this end, here are a few 
enhancements I would like to suggest:

1: Symmetrically to onCompletion(), provide 
onExceptionalCompletion(Throwable). This allows filtering exception 
propagation. There are cases where the propagation of the exception is 
desired, and others where a corrective action is taken instead, such as 
a retry.

2: As a further enhancement to 1: enable any Throwable, including 
checked exceptions. This allows the use of a CountedCompleter as a 
CompletionHandler for asynchronous IO operations or as a wrapper for 
MethodHandles (which throw Throwable) without adding extra logic to 
capture and convert an IO exception. I read the documentation which 
explains why this is currently limited to unchecked exceptions. While I 
can agree with this in general, I feel the argument is weak for 
CountedCompleter if it is there to support asynchronous tasks/events. 
(May I add that using this type of framework is not for the 
faint-hearted anyway!?)

3: Provide a method to join a task that is not forked and/or not 
completable, while minimizing worker thread blocking. For example, 
CountedCompleter allows creating chains of dependent tasks. Unless the 
ultimate task (the last in the chain) is forked/exists on the task stack 
AND can complete because all dependencies are resolved, joining it will 
block the worker thread. I noticed (and my testing is limited to a few 
test cases and therefore not representative) the blocking and the 
creation of other worker threads, ultimately running out of memory or 
reaching the thread count limit. If this task is not forked, then 
join()/quietlyJoin() will block the worker thread. The following code is 
my (inexpert) attempt to provide a remedy. It is based on the assumption 
that a task that depends on others for completion is not forked until 
all dependencies are resolved. For example, a CountedCompleter 
implementing CompletionHandler would fork itself ("implicit fork") when 
the IO operation is done. This works very well in my test cases, but at 
this time I would not claim it to be universally applicable or error 
free. It is shown here more to demonstrate the attempt rather than as a 
reference implementation. With access to private data structures, this 
can be done more elegantly and more reliably.

? ? ? ? static final int RETRIES = 16;
? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in 
microseconds.

? ? ? ? public final void quietlyJoinUnforked() {
? ? ? ? ? ? this.doJoinUnforked(false);
? ? ? ? }

? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
? ? ? ? throws InterruptedException {
? ? ? ? ? ? if (this.doJoinUnforked(true)) {
? ? ? ? ? ? ? ? throw new InterruptedException();
? ? ? ? ? ? }
? ? ? ? }

? ? ? ? public final boolean doJoinUnforked(final boolean interruptibly) {
? ? ? ? ? ? int retries = RETRIES;
? ? ? ? ? ? boolean wasInterrupted = false;
? ? ? ? ? ? while (!this.isDone()) {
? ? ? ? ? ? ? ? ForkJoinTask<?> t;
? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
? ? ? ? ? ? ? ? ? ? if (t == this) {
? ? ? ? ? ? ? ? ? ? ? ? break;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? else {
? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
? ? ? ? ? ? ? ? ? ? ? ? continue;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
? ? ? ? ? ? ? ? ? ? try {
? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is 
assumed that
? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task 
to retrieve
? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
? ? ? ? ? ? ? ? ? ? ? ? break;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
? ? ? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? ? ? return true;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
? ? ? ? ? ? ? ? ? ? ? ? break;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
? ? ? ? ? ? ? ? ? ? ? ? continue;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? retries = RETRIES;
? ? ? ? ? ? }
? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
? ? ? ? ? ? ? ? return false;
? ? ? ? ? ? }
? ? ? ? ? ? return wasInterrupted;
? ? ? ? }

As already mentioned this works quite well in a number of cases. For 
example, adding this method to the example MergeSort code and calling 
quietlyJoinUnforked(), results in the same overall performance, reduces 
the number of extra blocked worker threads to 1 if any (instead of up to 
8 for the unmodified code; on a PC with 4 hyper-threading cores/8 
threads), and allows for some extra (recreational?) freedom in joining 
the right and left sub-tasks in any order. It works in cases where no 
sub-task is forked explicitly. I observed that worker thread blocking 
only occurs towards the end of a large recursion, suggesting that worker 
threads only block - as intended - when there is no other work available 
(sometimes while implicit forking has not yet happened).

Wolfgang.



On 2012-04-09 16:16, Doug Lea wrote:
>
> After sitting on multiple variations for months, I committed
> CountedCompleter, a completion-based flavor of ForkJoinTask.
>
> As mentioned a few times over the past year, the main motivation
> is to better support tasks that perform IO or other base
> actions that may (or may not) take a lot of time to execute.
> As is the case with JDK7 async IO and other completion-based
> frameworks, the most common path to efficiency is for such tasks
> to arrange continuation actions that occur upon their completion.
> The main twist for CountedCompleters is that continuations
> might be dependent on multiple actions, not just one. (Or in
> other words, the continuations must be preceded by a specialized,
> "bottom-up" form of join.)
>
> The CountedCompleter abstract class provides a minimal basis
> for these kinds of tasks. While some of the mechanics are
> reminiscent of other FJ-like frameworks such as Intel TBB,
> CountedCompleters are designed to fit smoothly with other
> kinds of ForkJoinTasks (like RecursiveActions), and so still
> allow people to use the more pleasant Future-style conventions
> rather than count-based bottom-up joining unless they need them.
> At the same time, the CountedCompleter class exposes enough
> mechanics to allow all sorts of tweaks that people can use
> to improve performance.
> In particular, in addition to usually being the best way to deal
> with IO etc bound tasks, CountedCompleters sometimes fare better
> than RecursiveActions in programs that entail lots of garbage
> collection because GC can have similar impact on task variability.
>
> Even though targeted for JDK8, versions of CountedCompleter
> appear in the jsr166y and main repositories, not jsr166e. This is
> because they require a non-public hook into modified ForkJoinTask
> exception handling mechanics in order to properly propagate
> exceptional completions. For sources, docs, and jar files, see
> the usual links at 
> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>
> The API docs include more details and some examples:
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html 
>
>
> I also added a few (with more to come) test/demo programs that illustrate
> other usages. See CCBoxedLongSort and CCJacobi in
> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
>
> Please try these out. As always, comments and suggestions
> (hopefully based on usage experience) would be welcome.
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


------------------------------

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


End of Concurrency-interest Digest, Vol 87, Issue 26
****************************************************
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/75746dcb/attachment-0001.html>

From rohitk242 at yahoo.co.in  Mon Apr 16 14:36:00 2012
From: rohitk242 at yahoo.co.in (Rohit Kumar)
Date: Tue, 17 Apr 2012 02:36:00 +0800 (SGT)
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
	Issue 27
In-Reply-To: <mailman.117.1334596831.3324.concurrency-interest@cs.oswego.edu>
References: <mailman.117.1334596831.3324.concurrency-interest@cs.oswego.edu>
Message-ID: <1334601360.99294.YahooMailNeo@web193402.mail.sg3.yahoo.com>

Hans,Nathan,
?
I am not aware of anything like Gadara yet. My implementation assumes that there are no synchnonized keywords (implicit locks)?in your program. It requires you to use explicit locks (e.g. Lock class in java concurrent api). There is no background thread running here. The deadlock-check happens at each lock acquisition request; it runs an algorithms internally to see if there are any cycles formed in the lock-acquisition graph. If yes, it doesn't let you acquire the lock but throws an exception. You can catch this exception and take necessary steps to re-acquire all the locks once again or whatever you want. The program is written in java and it is hardly 270 lines of code.
?
Finally where do I need to present this writeup ?
?
Thanks & Regards,
Rohit Kumar

From: "concurrency-interest-request at cs.oswego.edu" <concurrency-interest-request at cs.oswego.edu>
To: concurrency-interest at cs.oswego.edu 
Sent: Monday, 16 April 2012 10:50 PM
Subject: Concurrency-interest Digest, Vol 87, Issue 27

Send Concurrency-interest mailing list submissions to
??? concurrency-interest at cs.oswego.edu

To subscribe or unsubscribe via the World Wide Web, visit
??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
or, via email, send a message with subject or body 'help' to
??? concurrency-interest-request at cs.oswego.edu

You can reach the person managing the list at
??? concurrency-interest-owner at cs.oswego.edu

When replying, please edit your Subject line so it is more specific
than "Re: Contents of Concurrency-interest digest..."


Today's Topics:

? 1. Re: CountedCompleters (Wolfgang Baltes)
? 2. Re: Java Deadlocks prevented (Boehm, Hans)
? 3. Re: Java Deadlocks prevented (Nathan Reynolds)
? 4. Re: Concurrency-interest Digest, Vol 87,??? Issue 26 (Java
? ? ? deadlock prevented) (Rohit Kumar)


----------------------------------------------------------------------

Message: 1
Date: Mon, 16 Apr 2012 18:01:50 +0200
From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] CountedCompleters
Message-ID: <4F8C426E.6090704 at laposte.net>
Content-Type: text/plain; charset=ISO-8859-1; format=flowed

I apologize for a mistake in the last paragraph of my memo: using 
quietlyJoinUnforked() in the SDK7 sample code for MergeSort does have a 
non-negligible performance impact (not no impact as stated). There is 
better performance in case of recursions which produce many tasks that 
are not explicitly forked, and it reduces the number of extra threads 
significantly, allowing larger problems to be solved with smaller memory 
footprint.

Wolfgang.

On 2012-04-16 16:48, Wolfgang Baltes wrote:
> Thanks, Doug, for a this addition to the FJ framework. I think that
> CountedCompleter will address the needs of an entire class of
> applications in an efficient and simple to use manner.
>
> I used the code and noticed that method doJoin() has become more
> effective in avoiding blocking threads, and as a result fewer extra
> threads are created. I found the performance, compared to
> RecursiveAction, to be equal or insignificantly different. This
> reduces the problem described in item 3 below.
>
> However, at the same time, CountedCompleter does not fully satisfy the
> needs for a class of problems I work on. To this end, here are a few
> enhancements I would like to suggest:
>
> 1: Symmetrically to onCompletion(), provide
> onExceptionalCompletion(Throwable). This allows filtering exception
> propagation. There are cases where the propagation of the exception is
> desired, and others where a corrective action is taken instead, such
> as a retry.
>
> 2: As a further enhancement to 1: enable any Throwable, including
> checked exceptions. This allows the use of a CountedCompleter as a
> CompletionHandler for asynchronous IO operations or as a wrapper for
> MethodHandles (which throw Throwable) without adding extra logic to
> capture and convert an IO exception. I read the documentation which
> explains why this is currently limited to unchecked exceptions. While
> I can agree with this in general, I feel the argument is weak for
> CountedCompleter if it is there to support asynchronous tasks/events.
> (May I add that using this type of framework is not for the
> faint-hearted anyway!?)
>
> 3: Provide a method to join a task that is not forked and/or not
> completable, while minimizing worker thread blocking. For example,
> CountedCompleter allows creating chains of dependent tasks. Unless the
> ultimate task (the last in the chain) is forked/exists on the task
> stack AND can complete because all dependencies are resolved, joining
> it will block the worker thread. I noticed (and my testing is limited
> to a few test cases and therefore not representative) the blocking and
> the creation of other worker threads, ultimately running out of memory
> or reaching the thread count limit. If this task is not forked, then
> join()/quietlyJoin() will block the worker thread. The following code
> is my (inexpert) attempt to provide a remedy. It is based on the
> assumption that a task that depends on others for completion is not
> forked until all dependencies are resolved. For example, a
> CountedCompleter implementing CompletionHandler would fork itself
> ("implicit fork") when the IO operation is done. This works very well
> in my test cases, but at this time I would not claim it to be
> universally applicable or error free. It is shown here more to
> demonstrate the attempt rather than as a reference implementation.
> With access to private data structures, this can be done more
> elegantly and more reliably.
>
>? ? ? ? static final int RETRIES = 16;
>? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in
> microseconds.
>
>? ? ? ? public final void quietlyJoinUnforked() {
>? ? ? ? ? ? this.doJoinUnforked(false);
>? ? ? ? }
>
>? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
>? ? ? ? throws InterruptedException {
>? ? ? ? ? ? if (this.doJoinUnforked(true)) {
>? ? ? ? ? ? ? ? throw new InterruptedException();
>? ? ? ? ? ? }
>? ? ? ? }
>
>? ? ? ? public final boolean doJoinUnforked(final boolean
> interruptibly) {
>? ? ? ? ? ? int retries = RETRIES;
>? ? ? ? ? ? boolean wasInterrupted = false;
>? ? ? ? ? ? while (!this.isDone()) {
>? ? ? ? ? ? ? ? ForkJoinTask<?> t;
>? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
>? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
>? ? ? ? ? ? ? ? ? ? if (t == this) {
>? ? ? ? ? ? ? ? ? ? ? ? break;
>? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? else {
>? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
>? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
>? ? ? ? ? ? ? ? ? ? ? ? continue;
>? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
>? ? ? ? ? ? ? ? ? ? try {
>? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is
> assumed that
>? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task
> to retrieve
>? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
>? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
>? ? ? ? ? ? ? ? ? ? ? ? break;
>? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
>? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
>? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
>? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
>? ? ? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? ? ? ? ? return true;
>? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
>? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
>? ? ? ? ? ? ? ? ? ? ? ? break;
>? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
>? ? ? ? ? ? ? ? ? ? ? ? continue;
>? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? retries = RETRIES;
>? ? ? ? ? ? }
>? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
>? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
>? ? ? ? ? ? ? ? return false;
>? ? ? ? ? ? }
>? ? ? ? ? ? return wasInterrupted;
>? ? ? ? }
>
> As already mentioned this works quite well in a number of cases. For
> example, adding this method to the example MergeSort code and calling
> quietlyJoinUnforked(), results in the same overall performance,
> reduces the number of extra blocked worker threads to 1 if any
> (instead of up to 8 for the unmodified code; on a PC with 4
> hyper-threading cores/8 threads), and allows for some extra
> (recreational?) freedom in joining the right and left sub-tasks in any
> order. It works in cases where no sub-task is forked explicitly. I
> observed that worker thread blocking only occurs towards the end of a
> large recursion, suggesting that worker threads only block - as
> intended - when there is no other work available (sometimes while
> implicit forking has not yet happened).
>
> Wolfgang.
>
>
>
> On 2012-04-09 16:16, Doug Lea wrote:
>>
>> After sitting on multiple variations for months, I committed
>> CountedCompleter, a completion-based flavor of ForkJoinTask.
>>
>> As mentioned a few times over the past year, the main motivation
>> is to better support tasks that perform IO or other base
>> actions that may (or may not) take a lot of time to execute.
>> As is the case with JDK7 async IO and other completion-based
>> frameworks, the most common path to efficiency is for such tasks
>> to arrange continuation actions that occur upon their completion.
>> The main twist for CountedCompleters is that continuations
>> might be dependent on multiple actions, not just one. (Or in
>> other words, the continuations must be preceded by a specialized,
>> "bottom-up" form of join.)
>>
>> The CountedCompleter abstract class provides a minimal basis
>> for these kinds of tasks. While some of the mechanics are
>> reminiscent of other FJ-like frameworks such as Intel TBB,
>> CountedCompleters are designed to fit smoothly with other
>> kinds of ForkJoinTasks (like RecursiveActions), and so still
>> allow people to use the more pleasant Future-style conventions
>> rather than count-based bottom-up joining unless they need them.
>> At the same time, the CountedCompleter class exposes enough
>> mechanics to allow all sorts of tweaks that people can use
>> to improve performance.
>> In particular, in addition to usually being the best way to deal
>> with IO etc bound tasks, CountedCompleters sometimes fare better
>> than RecursiveActions in programs that entail lots of garbage
>> collection because GC can have similar impact on task variability.
>>
>> Even though targeted for JDK8, versions of CountedCompleter
>> appear in the jsr166y and main repositories, not jsr166e. This is
>> because they require a non-public hook into modified ForkJoinTask
>> exception handling mechanics in order to properly propagate
>> exceptional completions. For sources, docs, and jar files, see
>> the usual links at
>> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>>
>> The API docs include more details and some examples:
>> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
>>
>>
>> I also added a few (with more to come) test/demo programs that
>> illustrate
>> other usages. See CCBoxedLongSort and CCJacobi in
>> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
>>
>> Please try these out. As always, comments and suggestions
>> (hopefully based on usage experience) would be welcome.
>>
>> -Doug
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


------------------------------

Message: 2
Date: Mon, 16 Apr 2012 16:38:00 +0000
From: "Boehm, Hans" <hans.boehm at hp.com>
To: Andrew Haley <aph at redhat.com>,
??? "concurrency-interest at cs.oswego.edu"
??? <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Java Deadlocks prevented
Message-ID:
??? <A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hpqcorp.net>
??? 
Content-Type: text/plain; charset="us-ascii"

Important questions to consider when you write it up:

How does it compare to something like Gadara that uses whole program analysis and scheduling to avoid lock-based deadlocks?? (Hopefully it doesn't need whole program analysis.)? Other deadlock avoidance schemes?

Once you detect a potential deadlock, how do you recover?? Or can you always schedule so that the possibility doesn't arise?

Hans

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
> Sent: Monday, April 16, 2012 4:34 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> 
> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
> 
> > I have found a way of preventing deadlocks in java. The
> > methodology(which is code) completely prevents the deadlock from
> > occuring by detecting it in advance. This can be used across the
> > systems seamlessly.
> >
> > Kindly let me know what I need to do next. I want this to be part of
> > next jdk release. I am writing this email as I have no idea what I
> > need to do next to bring it into limelight.
> 
> Write it up, maybe present it to a conference, and wait for feedback.
> That's how it always works.? If your idea really works, people will
> use it.
> 
> Andrew.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



------------------------------

Message: 3
Date: Mon, 16 Apr 2012 10:11:00 -0700
From: Nathan Reynolds <nathan.reynolds at oracle.com>
To: "Boehm, Hans" <hans.boehm at hp.com>
Cc: "concurrency-interest at cs.oswego.edu"
??? <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Java Deadlocks prevented
Message-ID: <4F8C52A4.70002 at oracle.com>
Content-Type: text/plain; charset="iso-8859-1"; Format="flowed"

Deadlock prevention is very valuable.? It means deadlock prone code 
won't bring down a production server and cost the company millions in 
down time.? It means consumers won't kill the process and request a refund.

How much does deadlock prevention cost?? Is the cost on the thread that 
acquires locks or is it in a background thread?

Each time processors or systems increase the number of cores, I find we 
have to do a round of lock contention fixing.? I have only seen 1 lock 
at a time be the bottleneck in the system.? Does deadlock prevention 
increase the critical region of locks?? If so, this will definitely 
reduce the scalability of the system if it impacts the 1 bottlenecking lock.

Lock performance is a very important consideration.? Locks have evolved 
from fat locks (i.e trips into the OS kernel) to thin locks (i.e. spin 
and CAS in user mode) to biased/lazy locks (i.e. no CAS and an 
indefinite lock owner).? All of this was done to reduce the performance 
overhead of locks.? How does deadlock prevention impact the performance 
of biased, thin and fat locks?? I am not as concerned about fat lock 
performance since most of the time the thread is going to block.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/16/2012 9:38 AM, Boehm, Hans wrote:
> Important questions to consider when you write it up:
>
> How does it compare to something like Gadara that uses whole program analysis and scheduling to avoid lock-based deadlocks?? (Hopefully it doesn't need whole program analysis.)? Other deadlock avoidance schemes?
>
> Once you detect a potential deadlock, how do you recover?? Or can you always schedule so that the possibility doesn't arise?
>
> Hans
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
>> Sent: Monday, April 16, 2012 4:34 AM
>> To: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Java Deadlocks prevented
>>
>> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>>
>>> I have found a way of preventing deadlocks in java. The
>>> methodology(which is code) completely prevents the deadlock from
>>> occuring by detecting it in advance. This can be used across the
>>> systems seamlessly.
>>>
>>> Kindly let me know what I need to do next. I want this to be part of
>>> next jdk release. I am writing this email as I have no idea what I
>>> need to do next to bring it into limelight.
>> Write it up, maybe present it to a conference, and wait for feedback.
>> That's how it always works.? If your idea really works, people will
>> use it.
>>
>> Andrew.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/7ea89bb3/attachment-0001.html>

------------------------------

Message: 4
Date: Tue, 17 Apr 2012 01:20:15 +0800 (SGT)
From: Rohit Kumar <rohitk242 at yahoo.co.in>
To: "concurrency-interest at cs.oswego.edu"
??? <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
??? 87,??? Issue 26 (Java deadlock prevented)
Message-ID:
??? <1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com>
Content-Type: text/plain; charset="iso-8859-1"

Andrew:
?
Thanks for the reply. Can you kindly let me know where do I need to present it ? Where will the conference be held ? Can I present it online or I have to come in person ?
?
Waiting for your early reply once again.
?
Thanks & Regards,
Rohit Kumar

From: "concurrency-interest-request at cs.oswego.edu" <concurrency-interest-request at cs.oswego.edu>
To: concurrency-interest at cs.oswego.edu 
Sent: Monday, 16 April 2012 9:30 PM
Subject: Concurrency-interest Digest, Vol 87, Issue 26

Send Concurrency-interest mailing list submissions to
??? concurrency-interest at cs.oswego.edu

To subscribe or unsubscribe via the World Wide Web, visit
??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
or, via email, send a message with subject or body 'help' to
??? concurrency-interest-request at cs.oswego.edu

You can reach the person managing the list at
??? concurrency-interest-owner at cs.oswego.edu

When replying, please edit your Subject line so it is more specific
than "Re: Contents of Concurrency-interest digest..."


Today's Topics:

? 1. (no subject) (Rohit Kumar)
? 2. Java Deadlocks prevented (Rohit Kumar)
? 3. Re: Java Deadlocks prevented (Andrew Haley)
? 4. Re: CountedCompleters (Wolfgang Baltes)


----------------------------------------------------------------------

Message: 1
Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT)
From: Rohit Kumar <rohitk242 at yahoo.co.in>
To: "concurrency-interest at cs.oswego.edu"
??? <concurrency-interest at cs.oswego.edu>
Cc: "concurrency-interest-owner at cs.oswego.edu"
??? <concurrency-interest-owner at cs.oswego.edu>
Subject: [concurrency-interest] (no subject)
Message-ID:
??? <1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com>
Content-Type: text/plain; charset="iso-8859-1"

Hi All,
?
I have found a way of preventing deadlocks in java. The methodology(which is code) completely prevents the deadlock from accuring by detecting it in advance. This can be used across the systems seamlessly. 
?
Kindly let me know what I need to do next. I want this to be part of next jdk release.
?
Thanks & Regards,
Rohit Kumar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/a6588341/attachment-0001.html>

------------------------------

Message: 2
Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)
From: Rohit Kumar <rohitk242 at yahoo.co.in>
To: "concurrency-interest at cs.oswego.edu"
??? <concurrency-interest at cs.oswego.edu>
Cc: "concurrency-interest-owner at cs.oswego.edu"
??? <concurrency-interest-owner at cs.oswego.edu>
Subject: [concurrency-interest] Java Deadlocks prevented
Message-ID:
??? <1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com>
Content-Type: text/plain; charset="utf-8"



Hi All,

I have found a way of preventing deadlocks in java. The methodology(which is code) completely prevents the deadlock from occuring by detecting it in advance. This can be used across the systems seamlessly. 

Kindly let me know what I need to do next. I want this to be part of next jdk release. I am writing this email as I have no idea what I need to do next to bring it into limelight.

Thanks & Regards,
Rohit Kumar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/064a4873/attachment-0001.html>

------------------------------

Message: 3
Date: Mon, 16 Apr 2012 12:33:45 +0100
From: Andrew Haley <aph at redhat.com>
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Java Deadlocks prevented
Message-ID: <4F8C0399.8040301 at redhat.com>
Content-Type: text/plain; charset=ISO-8859-1

On 04/16/2012 12:06 PM, Rohit Kumar wrote:

> I have found a way of preventing deadlocks in java. The
> methodology(which is code) completely prevents the deadlock from
> occuring by detecting it in advance. This can be used across the
> systems seamlessly.
> 
> Kindly let me know what I need to do next. I want this to be part of
> next jdk release. I am writing this email as I have no idea what I
> need to do next to bring it into limelight.

Write it up, maybe present it to a conference, and wait for feedback.
That's how it always works.? If your idea really works, people will
use it.

Andrew.


------------------------------

Message: 4
Date: Mon, 16 Apr 2012 16:48:31 +0200
From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
To: "Concurrency-interest at cs.oswego.edu"
??? <Concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] CountedCompleters
Message-ID: <4F8C313F.2080308 at laposte.net>
Content-Type: text/plain; charset=ISO-8859-1; format=flowed

Thanks, Doug, for a this addition to the FJ framework. I think that 
CountedCompleter will address the needs of an entire class of 
applications in an efficient and simple to use manner.

I used the code and noticed that method doJoin() has become more 
effective in avoiding blocking threads, and as a result fewer extra 
threads are created. I found the performance, compared to 
RecursiveAction, to be equal or insignificantly different. This reduces 
the problem described in item 3 below.

However, at the same time, CountedCompleter does not fully satisfy the 
needs for a class of problems I work on. To this end, here are a few 
enhancements I would like to suggest:

1: Symmetrically to onCompletion(), provide 
onExceptionalCompletion(Throwable). This allows filtering exception 
propagation. There are cases where the propagation of the exception is 
desired, and others where a corrective action is taken instead, such as 
a retry.

2: As a further enhancement to 1: enable any Throwable, including 
checked exceptions. This allows the use of a CountedCompleter as a 
CompletionHandler for asynchronous IO operations or as a wrapper for 
MethodHandles (which throw Throwable) without adding extra logic to 
capture and convert an IO exception. I read the documentation which 
explains why this is currently limited to unchecked exceptions. While I 
can agree with this in general, I feel the argument is weak for 
CountedCompleter if it is there to support asynchronous tasks/events. 
(May I add that using this type of framework is not for the 
faint-hearted anyway!?)

3: Provide a method to join a task that is not forked and/or not 
completable, while minimizing worker thread blocking. For example, 
CountedCompleter allows creating chains of dependent tasks. Unless the 
ultimate task (the last in the chain) is forked/exists on the task stack 
AND can complete because all dependencies are resolved, joining it will 
block the worker thread. I noticed (and my testing is limited to a few 
test cases and therefore not representative) the blocking and the 
creation of other worker threads, ultimately running out of memory or 
reaching the thread count limit. If this task is not forked, then 
join()/quietlyJoin() will block the worker thread. The following code is 
my (inexpert) attempt to provide a remedy. It is based on the assumption 
that a task that depends on others for completion is not forked until 
all dependencies are resolved. For example, a CountedCompleter 
implementing CompletionHandler would fork itself ("implicit fork") when 
the IO operation is done. This works very well in my test cases, but at 
this time I would not claim it to be universally applicable or error 
free. It is shown here more to demonstrate the attempt rather than as a 
reference implementation. With access to private data structures, this 
can be done more elegantly and more reliably.

? ? ? ? static final int RETRIES = 16;
? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in 
microseconds.

? ? ? ? public final void quietlyJoinUnforked() {
? ? ? ? ? ? this.doJoinUnforked(false);
? ? ? ? }

? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
? ? ? ? throws InterruptedException {
? ? ? ? ? ? if (this.doJoinUnforked(true)) {
? ? ? ? ? ? ? ? throw new InterruptedException();
? ? ? ? ? ? }
? ? ? ? }

? ? ? ? public final boolean doJoinUnforked(final boolean interruptibly) {
? ? ? ? ? ? int retries = RETRIES;
? ? ? ? ? ? boolean wasInterrupted = false;
? ? ? ? ? ? while (!this.isDone()) {
? ? ? ? ? ? ? ? ForkJoinTask<?> t;
? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
? ? ? ? ? ? ? ? ? ? if (t == this) {
? ? ? ? ? ? ? ? ? ? ? ? break;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? else {
? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
? ? ? ? ? ? ? ? ? ? ? ? continue;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
? ? ? ? ? ? ? ? ? ? try {
? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is 
assumed that
? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task 
to retrieve
? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
? ? ? ? ? ? ? ? ? ? ? ? break;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
? ? ? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? ? ? return true;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
? ? ? ? ? ? ? ? ? ? ? ? break;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
? ? ? ? ? ? ? ? ? ? ? ? continue;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? retries = RETRIES;
? ? ? ? ? ? }
? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
? ? ? ? ? ? ? ? return false;
? ? ? ? ? ? }
? ? ? ? ? ? return wasInterrupted;
? ? ? ? }

As already mentioned this works quite well in a number of cases. For 
example, adding this method to the example MergeSort code and calling 
quietlyJoinUnforked(), results in the same overall performance, reduces 
the number of extra blocked worker threads to 1 if any (instead of up to 
8 for the unmodified code; on a PC with 4 hyper-threading cores/8 
threads), and allows for some extra (recreational?) freedom in joining 
the right and left sub-tasks in any order. It works in cases where no 
sub-task is forked explicitly. I observed that worker thread blocking 
only occurs towards the end of a large recursion, suggesting that worker 
threads only block - as intended - when there is no other work available 
(sometimes while implicit forking has not yet happened).

Wolfgang.



On 2012-04-09 16:16, Doug Lea wrote:
>
> After sitting on multiple variations for months, I committed
> CountedCompleter, a completion-based flavor of ForkJoinTask.
>
> As mentioned a few times over the past year, the main motivation
> is to better support tasks that perform IO or other base
> actions that may (or may not) take a lot of time to execute.
> As is the case with JDK7 async IO and other completion-based
> frameworks, the most common path to efficiency is for such tasks
> to arrange continuation actions that occur upon their completion.
> The main twist for CountedCompleters is that continuations
> might be dependent on multiple actions, not just one. (Or in
> other words, the continuations must be preceded by a specialized,
> "bottom-up" form of join.)
>
> The CountedCompleter abstract class provides a minimal basis
> for these kinds of tasks. While some of the mechanics are
> reminiscent of other FJ-like frameworks such as Intel TBB,
> CountedCompleters are designed to fit smoothly with other
> kinds of ForkJoinTasks (like RecursiveActions), and so still
> allow people to use the more pleasant Future-style conventions
> rather than count-based bottom-up joining unless they need them.
> At the same time, the CountedCompleter class exposes enough
> mechanics to allow all sorts of tweaks that people can use
> to improve performance.
> In particular, in addition to usually being the best way to deal
> with IO etc bound tasks, CountedCompleters sometimes fare better
> than RecursiveActions in programs that entail lots of garbage
> collection because GC can have similar impact on task variability.
>
> Even though targeted for JDK8, versions of CountedCompleter
> appear in the jsr166y and main repositories, not jsr166e. This is
> because they require a non-public hook into modified ForkJoinTask
> exception handling mechanics in order to properly propagate
> exceptional completions. For sources, docs, and jar files, see
> the usual links at 
> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>
> The API docs include more details and some examples:
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html 
>
>
> I also added a few (with more to come) test/demo programs that illustrate
> other usages. See CCBoxedLongSort and CCJacobi in
> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
>
> Please try these out. As always, comments and suggestions
> (hopefully based on usage experience) would be welcome.
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


------------------------------

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


End of Concurrency-interest Digest, Vol 87, Issue 26
****************************************************
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/75746dcb/attachment.html>

------------------------------

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


End of Concurrency-interest Digest, Vol 87, Issue 27
****************************************************
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/6d618b3f/attachment-0001.html>

From khilan at doc.ic.ac.uk  Mon Apr 16 15:22:10 2012
From: khilan at doc.ic.ac.uk (Khilan Gudka)
Date: Mon, 16 Apr 2012 20:22:10 +0100
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
	Issue 27
In-Reply-To: <1334601360.99294.YahooMailNeo@web193402.mail.sg3.yahoo.com>
References: <mailman.117.1334596831.3324.concurrency-interest@cs.oswego.edu>
	<1334601360.99294.YahooMailNeo@web193402.mail.sg3.yahoo.com>
Message-ID: <CAEtTSAZ-GN=DzbjQ3UH-TQ8y02McbaED44vUEDuYH2AhXeiv7g@mail.gmail.com>

Hi Rohit

This sounds very interesting.

A few questions though...

What happens if you have already acquired locks further up and have
performed side effects since then? Also, what if you are involved in a
mutual deadlock whereby side effects have occurred in two or more processes
so you cannot simply rollback the locks?

In our lock inference work, we bunch all the locks together so if a
deadlock occurs, like you say, you can just release already acquired locks
and try again. We don't do cycle detection though because of the potential
overheads. What kind of overheads do you get? Is it proportional to the
number of threads?

Thanks

--
Khilan Gudka
PhD Student
Department of Computing
Imperial College London
http://www.doc.ic.ac.uk/~khilan/



On 16 April 2012 19:36, Rohit Kumar <rohitk242 at yahoo.co.in> wrote:

> Hans,Nathan,
>
> I am not aware of anything like Gadara yet. My implementation assumes that
> there are no synchnonized keywords (implicit locks) in your program. It
> requires you to use explicit locks (e.g. Lock class in java concurrent
> api). There is no background thread running here. The deadlock-check
> happens at each lock acquisition request; it runs an algorithms internally
> to see if there are any cycles formed in the lock-acquisition graph. If
> yes, it doesn't let you acquire the lock but throws an exception. You can
> catch this exception and take necessary steps to re-acquire all the locks
> once again or whatever you want. The program is written in java and it is
> hardly 270 lines of code.
>
> Finally where do I need to present this writeup ?
>
> Thanks & Regards,
> Rohit Kumar
>
>   *From:* "concurrency-interest-request at cs.oswego.edu" <
> concurrency-interest-request at cs.oswego.edu>
> *To:* concurrency-interest at cs.oswego.edu
> *Sent:* Monday, 16 April 2012 10:50 PM
> *Subject:* Concurrency-interest Digest, Vol 87, Issue 27
>
> Send Concurrency-interest mailing list submissions to
>     concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
>     concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
>     concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>   1. Re: CountedCompleters (Wolfgang Baltes)
>   2. Re: Java Deadlocks prevented (Boehm, Hans)
>   3. Re: Java Deadlocks prevented (Nathan Reynolds)
>   4. Re: Concurrency-interest Digest, Vol 87,    Issue 26 (Java
>       deadlock prevented) (Rohit Kumar)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 16 Apr 2012 18:01:50 +0200
> From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] CountedCompleters
> Message-ID: <4F8C426E.6090704 at laposte.net>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> I apologize for a mistake in the last paragraph of my memo: using
> quietlyJoinUnforked() in the SDK7 sample code for MergeSort does have a
> non-negligible performance impact (not no impact as stated). There is
> better performance in case of recursions which produce many tasks that
> are not explicitly forked, and it reduces the number of extra threads
> significantly, allowing larger problems to be solved with smaller memory
> footprint.
>
> Wolfgang.
>
> On 2012-04-16 16:48, Wolfgang Baltes wrote:
> > Thanks, Doug, for a this addition to the FJ framework. I think that
> > CountedCompleter will address the needs of an entire class of
> > applications in an efficient and simple to use manner.
> >
> > I used the code and noticed that method doJoin() has become more
> > effective in avoiding blocking threads, and as a result fewer extra
> > threads are created. I found the performance, compared to
> > RecursiveAction, to be equal or insignificantly different. This
> > reduces the problem described in item 3 below.
> >
> > However, at the same time, CountedCompleter does not fully satisfy the
> > needs for a class of problems I work on. To this end, here are a few
> > enhancements I would like to suggest:
> >
> > 1: Symmetrically to onCompletion(), provide
> > onExceptionalCompletion(Throwable). This allows filtering exception
> > propagation. There are cases where the propagation of the exception is
> > desired, and others where a corrective action is taken instead, such
> > as a retry.
> >
> > 2: As a further enhancement to 1: enable any Throwable, including
> > checked exceptions. This allows the use of a CountedCompleter as a
> > CompletionHandler for asynchronous IO operations or as a wrapper for
> > MethodHandles (which throw Throwable) without adding extra logic to
> > capture and convert an IO exception. I read the documentation which
> > explains why this is currently limited to unchecked exceptions. While
> > I can agree with this in general, I feel the argument is weak for
> > CountedCompleter if it is there to support asynchronous tasks/events.
> > (May I add that using this type of framework is not for the
> > faint-hearted anyway!?)
> >
> > 3: Provide a method to join a task that is not forked and/or not
> > completable, while minimizing worker thread blocking. For example,
> > CountedCompleter allows creating chains of dependent tasks. Unless the
> > ultimate task (the last in the chain) is forked/exists on the task
> > stack AND can complete because all dependencies are resolved, joining
> > it will block the worker thread. I noticed (and my testing is limited
> > to a few test cases and therefore not representative) the blocking and
> > the creation of other worker threads, ultimately running out of memory
> > or reaching the thread count limit. If this task is not forked, then
> > join()/quietlyJoin() will block the worker thread. The following code
> > is my (inexpert) attempt to provide a remedy. It is based on the
> > assumption that a task that depends on others for completion is not
> > forked until all dependencies are resolved. For example, a
> > CountedCompleter implementing CompletionHandler would fork itself
> > ("implicit fork") when the IO operation is done. This works very well
> > in my test cases, but at this time I would not claim it to be
> > universally applicable or error free. It is shown here more to
> > demonstrate the attempt rather than as a reference implementation.
> > With access to private data structures, this can be done more
> > elegantly and more reliably.
> >
> >        static final int RETRIES = 16;
> >        static final long WAIT_TIMEOUT = 1_000;    // Timeout in
> > microseconds.
> >
> >        public final void quietlyJoinUnforked() {
> >            this.doJoinUnforked(false);
> >        }
> >
> >        public final void quietlyJoinUnforkedInterruptibly()
> >        throws InterruptedException {
> >            if (this.doJoinUnforked(true)) {
> >                throw new InterruptedException();
> >            }
> >        }
> >
> >        public final boolean doJoinUnforked(final boolean
> > interruptibly) {
> >            int retries = RETRIES;
> >            boolean wasInterrupted = false;
> >            while (!this.isDone()) {
> >                ForkJoinTask<?> t;
> >                if ((t = pollTask()) != null) {
> >                    t.quietlyInvoke();
> >                    if (t == this) {
> >                        break;
> >                    }
> >                }
> >                else {
> >                    if (retries-- > 0) {
> >                        Thread.yield();
> >                        continue;
> >                    }
> >                    wasInterrupted = Thread.interrupted();
> >                    try {
> >                        // get(...) is used as a timed join(). It is
> > assumed that
> >                        // other code will perform get() on this task
> > to retrieve
> >                        // the task's result or exception.
> >                        this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
> >                        break;
> >                    }
> >                    catch (final InterruptedException consumed) {
> >                        if (!interruptibly) {
> >                            wasInterrupted = true;
> >                            continue;
> >                        }
> >                        return true;
> >                    }
> >                    catch (final ExecutionException ignored) {
> >                        // See comment on get() above.
> >                        break;
> >                    }
> >                    catch (final TimeoutException ignored) {
> >                        continue;
> >                    }
> >                }
> >                retries = RETRIES;
> >            }
> >            if (wasInterrupted && !interruptibly) {
> >                Thread.currentThread().interrupt();
> >                return false;
> >            }
> >            return wasInterrupted;
> >        }
> >
> > As already mentioned this works quite well in a number of cases. For
> > example, adding this method to the example MergeSort code and calling
> > quietlyJoinUnforked(), results in the same overall performance,
> > reduces the number of extra blocked worker threads to 1 if any
> > (instead of up to 8 for the unmodified code; on a PC with 4
> > hyper-threading cores/8 threads), and allows for some extra
> > (recreational?) freedom in joining the right and left sub-tasks in any
> > order. It works in cases where no sub-task is forked explicitly. I
> > observed that worker thread blocking only occurs towards the end of a
> > large recursion, suggesting that worker threads only block - as
> > intended - when there is no other work available (sometimes while
> > implicit forking has not yet happened).
> >
> > Wolfgang.
> >
> >
> >
> > On 2012-04-09 16:16, Doug Lea wrote:
> >>
> >> After sitting on multiple variations for months, I committed
> >> CountedCompleter, a completion-based flavor of ForkJoinTask.
> >>
> >> As mentioned a few times over the past year, the main motivation
> >> is to better support tasks that perform IO or other base
> >> actions that may (or may not) take a lot of time to execute.
> >> As is the case with JDK7 async IO and other completion-based
> >> frameworks, the most common path to efficiency is for such tasks
> >> to arrange continuation actions that occur upon their completion.
> >> The main twist for CountedCompleters is that continuations
> >> might be dependent on multiple actions, not just one. (Or in
> >> other words, the continuations must be preceded by a specialized,
> >> "bottom-up" form of join.)
> >>
> >> The CountedCompleter abstract class provides a minimal basis
> >> for these kinds of tasks. While some of the mechanics are
> >> reminiscent of other FJ-like frameworks such as Intel TBB,
> >> CountedCompleters are designed to fit smoothly with other
> >> kinds of ForkJoinTasks (like RecursiveActions), and so still
> >> allow people to use the more pleasant Future-style conventions
> >> rather than count-based bottom-up joining unless they need them.
> >> At the same time, the CountedCompleter class exposes enough
> >> mechanics to allow all sorts of tweaks that people can use
> >> to improve performance.
> >> In particular, in addition to usually being the best way to deal
> >> with IO etc bound tasks, CountedCompleters sometimes fare better
> >> than RecursiveActions in programs that entail lots of garbage
> >> collection because GC can have similar impact on task variability.
> >>
> >> Even though targeted for JDK8, versions of CountedCompleter
> >> appear in the jsr166y and main repositories, not jsr166e. This is
> >> because they require a non-public hook into modified ForkJoinTask
> >> exception handling mechanics in order to properly propagate
> >> exceptional completions. For sources, docs, and jar files, see
> >> the usual links at
> >> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> >>
> >> The API docs include more details and some examples:
> >>
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
> >>
> >>
> >> I also added a few (with more to come) test/demo programs that
> >> illustrate
> >> other usages. See CCBoxedLongSort and CCJacobi in
> >> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
> >>
> >> Please try these out. As always, comments and suggestions
> >> (hopefully based on usage experience) would be welcome.
> >>
> >> -Doug
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> ------------------------------
>
> Message: 2
> Date: Mon, 16 Apr 2012 16:38:00 +0000
> From: "Boehm, Hans" <hans.boehm at hp.com>
> To: Andrew Haley <aph at redhat.com>,
>     "concurrency-interest at cs.oswego.edu"
>     <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID:
>     <A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hpqcorp.net
> >
>
> Content-Type: text/plain; charset="us-ascii"
>
> Important questions to consider when you write it up:
>
> How does it compare to something like Gadara that uses whole program
> analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it
> doesn't need whole program analysis.)  Other deadlock avoidance schemes?
>
> Once you detect a potential deadlock, how do you recover?  Or can you
> always schedule so that the possibility doesn't arise?
>
> Hans
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
> > Sent: Monday, April 16, 2012 4:34 AM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Java Deadlocks prevented
> >
> > On 04/16/2012 12:06 PM, Rohit Kumar wrote:
> >
> > > I have found a way of preventing deadlocks in java. The
> > > methodology(which is code) completely prevents the deadlock from
> > > occuring by detecting it in advance. This can be used across the
> > > systems seamlessly.
> > >
> > > Kindly let me know what I need to do next. I want this to be part of
> > > next jdk release. I am writing this email as I have no idea what I
> > > need to do next to bring it into limelight.
> >
> > Write it up, maybe present it to a conference, and wait for feedback.
> > That's how it always works.  If your idea really works, people will
> > use it.
> >
> > Andrew.
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> ------------------------------
>
> Message: 3
> Date: Mon, 16 Apr 2012 10:11:00 -0700
> From: Nathan Reynolds <nathan.reynolds at oracle.com>
> To: "Boehm, Hans" <hans.boehm at hp.com>
> Cc: "concurrency-interest at cs.oswego.edu"
>     <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID: <4F8C52A4.70002 at oracle.com>
> Content-Type: text/plain; charset="iso-8859-1"; Format="flowed"
>
> Deadlock prevention is very valuable.  It means deadlock prone code
> won't bring down a production server and cost the company millions in
> down time.  It means consumers won't kill the process and request a refund.
>
> How much does deadlock prevention cost?  Is the cost on the thread that
> acquires locks or is it in a background thread?
>
> Each time processors or systems increase the number of cores, I find we
> have to do a round of lock contention fixing.  I have only seen 1 lock
> at a time be the bottleneck in the system.  Does deadlock prevention
> increase the critical region of locks?  If so, this will definitely
> reduce the scalability of the system if it impacts the 1 bottlenecking
> lock.
>
> Lock performance is a very important consideration.  Locks have evolved
> from fat locks (i.e trips into the OS kernel) to thin locks (i.e. spin
> and CAS in user mode) to biased/lazy locks (i.e. no CAS and an
> indefinite lock owner).  All of this was done to reduce the performance
> overhead of locks.  How does deadlock prevention impact the performance
> of biased, thin and fat locks?  I am not as concerned about fat lock
> performance since most of the time the thread is going to block.
>
> Nathan Reynolds
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
> On 4/16/2012 9:38 AM, Boehm, Hans wrote:
> > Important questions to consider when you write it up:
> >
> > How does it compare to something like Gadara that uses whole program
> analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it
> doesn't need whole program analysis.)  Other deadlock avoidance schemes?
> >
> > Once you detect a potential deadlock, how do you recover?  Or can you
> always schedule so that the possibility doesn't arise?
> >
> > Hans
> >
> >> -----Original Message-----
> >> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> >> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
> >> Sent: Monday, April 16, 2012 4:34 AM
> >> To: concurrency-interest at cs.oswego.edu
> >> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> >>
> >> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
> >>
> >>> I have found a way of preventing deadlocks in java. The
> >>> methodology(which is code) completely prevents the deadlock from
> >>> occuring by detecting it in advance. This can be used across the
> >>> systems seamlessly.
> >>>
> >>> Kindly let me know what I need to do next. I want this to be part of
> >>> next jdk release. I am writing this email as I have no idea what I
> >>> need to do next to bring it into limelight.
> >> Write it up, maybe present it to a conference, and wait for feedback.
> >> That's how it always works.  If your idea really works, people will
> >> use it.
> >>
> >> Andrew.
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/7ea89bb3/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 4
> Date: Tue, 17 Apr 2012 01:20:15 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in>
> To: "concurrency-interest at cs.oswego.edu"
>     <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
>     87,    Issue 26 (Java deadlock prevented)
> Message-ID:
>     <1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Andrew:
> ?
> Thanks for the reply. Can you kindly let me know where do I need to
> present it ? Where will the conference be held ? Can I present it online or
> I have to come in person ?
> ?
> Waiting for your early reply once again.
> ?
> Thanks & Regards,
> Rohit Kumar
>
> From: "concurrency-interest-request at cs.oswego.edu" <
> concurrency-interest-request at cs.oswego.edu>
> To: concurrency-interest at cs.oswego.edu
> Sent: Monday, 16 April 2012 9:30 PM
> Subject: Concurrency-interest Digest, Vol 87, Issue 26
>
> Send Concurrency-interest mailing list submissions to
> ??? concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
> ??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
> ??? concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
> ??? concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
> ? 1. (no subject) (Rohit Kumar)
> ? 2. Java Deadlocks prevented (Rohit Kumar)
> ? 3. Re: Java Deadlocks prevented (Andrew Haley)
> ? 4. Re: CountedCompleters (Wolfgang Baltes)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in>
> To: "concurrency-interest at cs.oswego.edu"
> ??? <concurrency-interest at cs.oswego.edu>
> Cc: "concurrency-interest-owner at cs.oswego.edu"
> ??? <concurrency-interest-owner at cs.oswego.edu>
> Subject: [concurrency-interest] (no subject)
> Message-ID:
> ??? <1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Hi All,
> ?
> I have found a way of preventing deadlocks in java. The methodology(which
> is code) completely prevents the deadlock from accuring by detecting it in
> advance. This can be used across the systems seamlessly.
> ?
> Kindly let me know what I need to do next. I want this to be part of next
> jdk release.
> ?
> Thanks & Regards,
> Rohit Kumar
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/a6588341/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 2
> Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in>
> To: "concurrency-interest at cs.oswego.edu"
> ??? <concurrency-interest at cs.oswego.edu>
> Cc: "concurrency-interest-owner at cs.oswego.edu"
> ??? <concurrency-interest-owner at cs.oswego.edu>
> Subject: [concurrency-interest] Java Deadlocks prevented
> Message-ID:
> ??? <1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com>
> Content-Type: text/plain; charset="utf-8"
>
>
>
> Hi All,
>
> I have found a way of preventing deadlocks in java. The methodology(which
> is code) completely prevents the deadlock from occuring by detecting it in
> advance. This can be used across the systems seamlessly.
>
> Kindly let me know what I need to do next. I want this to be part of next
> jdk release. I am writing this email as I have no idea what I need to do
> next to bring it into limelight.
>
> Thanks & Regards,
> Rohit Kumar
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/064a4873/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 3
> Date: Mon, 16 Apr 2012 12:33:45 +0100
> From: Andrew Haley <aph at redhat.com>
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID: <4F8C0399.8040301 at redhat.com>
> Content-Type: text/plain; charset=ISO-8859-1
>
> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>
> > I have found a way of preventing deadlocks in java. The
> > methodology(which is code) completely prevents the deadlock from
> > occuring by detecting it in advance. This can be used across the
> > systems seamlessly.
> >
> > Kindly let me know what I need to do next. I want this to be part of
> > next jdk release. I am writing this email as I have no idea what I
> > need to do next to bring it into limelight.
>
> Write it up, maybe present it to a conference, and wait for feedback.
> That's how it always works.? If your idea really works, people will
> use it.
>
> Andrew.
>
>
> ------------------------------
>
> Message: 4
> Date: Mon, 16 Apr 2012 16:48:31 +0200
> From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
> To: "Concurrency-interest at cs.oswego.edu"
> ??? <Concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] CountedCompleters
> Message-ID: <4F8C313F.2080308 at laposte.net>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> Thanks, Doug, for a this addition to the FJ framework. I think that
> CountedCompleter will address the needs of an entire class of
> applications in an efficient and simple to use manner.
>
> I used the code and noticed that method doJoin() has become more
> effective in avoiding blocking threads, and as a result fewer extra
> threads are created. I found the performance, compared to
> RecursiveAction, to be equal or insignificantly different. This reduces
> the problem described in item 3 below.
>
> However, at the same time, CountedCompleter does not fully satisfy the
> needs for a class of problems I work on. To this end, here are a few
> enhancements I would like to suggest:
>
> 1: Symmetrically to onCompletion(), provide
> onExceptionalCompletion(Throwable). This allows filtering exception
> propagation. There are cases where the propagation of the exception is
> desired, and others where a corrective action is taken instead, such as
> a retry.
>
> 2: As a further enhancement to 1: enable any Throwable, including
> checked exceptions. This allows the use of a CountedCompleter as a
> CompletionHandler for asynchronous IO operations or as a wrapper for
> MethodHandles (which throw Throwable) without adding extra logic to
> capture and convert an IO exception. I read the documentation which
> explains why this is currently limited to unchecked exceptions. While I
> can agree with this in general, I feel the argument is weak for
> CountedCompleter if it is there to support asynchronous tasks/events.
> (May I add that using this type of framework is not for the
> faint-hearted anyway!?)
>
> 3: Provide a method to join a task that is not forked and/or not
> completable, while minimizing worker thread blocking. For example,
> CountedCompleter allows creating chains of dependent tasks. Unless the
> ultimate task (the last in the chain) is forked/exists on the task stack
> AND can complete because all dependencies are resolved, joining it will
> block the worker thread. I noticed (and my testing is limited to a few
> test cases and therefore not representative) the blocking and the
> creation of other worker threads, ultimately running out of memory or
> reaching the thread count limit. If this task is not forked, then
> join()/quietlyJoin() will block the worker thread. The following code is
> my (inexpert) attempt to provide a remedy. It is based on the assumption
> that a task that depends on others for completion is not forked until
> all dependencies are resolved. For example, a CountedCompleter
> implementing CompletionHandler would fork itself ("implicit fork") when
> the IO operation is done. This works very well in my test cases, but at
> this time I would not claim it to be universally applicable or error
> free. It is shown here more to demonstrate the attempt rather than as a
> reference implementation. With access to private data structures, this
> can be done more elegantly and more reliably.
>
> ? ? ? ? static final int RETRIES = 16;
> ? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in
> microseconds.
>
> ? ? ? ? public final void quietlyJoinUnforked() {
> ? ? ? ? ? ? this.doJoinUnforked(false);
> ? ? ? ? }
>
> ? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
> ? ? ? ? throws InterruptedException {
> ? ? ? ? ? ? if (this.doJoinUnforked(true)) {
> ? ? ? ? ? ? ? ? throw new InterruptedException();
> ? ? ? ? ? ? }
> ? ? ? ? }
>
> ? ? ? ? public final boolean doJoinUnforked(final boolean interruptibly) {
> ? ? ? ? ? ? int retries = RETRIES;
> ? ? ? ? ? ? boolean wasInterrupted = false;
> ? ? ? ? ? ? while (!this.isDone()) {
> ? ? ? ? ? ? ? ? ForkJoinTask<?> t;
> ? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
> ? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
> ? ? ? ? ? ? ? ? ? ? if (t == this) {
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? else {
> ? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
> ? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
> ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
> ? ? ? ? ? ? ? ? ? ? try {
> ? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is
> assumed that
> ? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task
> to retrieve
> ? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
> ? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
> ? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? ? ? return true;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
> ? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
> ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? retries = RETRIES;
> ? ? ? ? ? ? }
> ? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
> ? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
> ? ? ? ? ? ? ? ? return false;
> ? ? ? ? ? ? }
> ? ? ? ? ? ? return wasInterrupted;
> ? ? ? ? }
>
> As already mentioned this works quite well in a number of cases. For
> example, adding this method to the example MergeSort code and calling
> quietlyJoinUnforked(), results in the same overall performance, reduces
> the number of extra blocked worker threads to 1 if any (instead of up to
> 8 for the unmodified code; on a PC with 4 hyper-threading cores/8
> threads), and allows for some extra (recreational?) freedom in joining
> the right and left sub-tasks in any order. It works in cases where no
> sub-task is forked explicitly. I observed that worker thread blocking
> only occurs towards the end of a large recursion, suggesting that worker
> threads only block - as intended - when there is no other work available
> (sometimes while implicit forking has not yet happened).
>
> Wolfgang.
>
>
>
> On 2012-04-09 16:16, Doug Lea wrote:
> >
> > After sitting on multiple variations for months, I committed
> > CountedCompleter, a completion-based flavor of ForkJoinTask.
> >
> > As mentioned a few times over the past year, the main motivation
> > is to better support tasks that perform IO or other base
> > actions that may (or may not) take a lot of time to execute.
> > As is the case with JDK7 async IO and other completion-based
> > frameworks, the most common path to efficiency is for such tasks
> > to arrange continuation actions that occur upon their completion.
> > The main twist for CountedCompleters is that continuations
> > might be dependent on multiple actions, not just one. (Or in
> > other words, the continuations must be preceded by a specialized,
> > "bottom-up" form of join.)
> >
> > The CountedCompleter abstract class provides a minimal basis
> > for these kinds of tasks. While some of the mechanics are
> > reminiscent of other FJ-like frameworks such as Intel TBB,
> > CountedCompleters are designed to fit smoothly with other
> > kinds of ForkJoinTasks (like RecursiveActions), and so still
> > allow people to use the more pleasant Future-style conventions
> > rather than count-based bottom-up joining unless they need them.
> > At the same time, the CountedCompleter class exposes enough
> > mechanics to allow all sorts of tweaks that people can use
> > to improve performance.
> > In particular, in addition to usually being the best way to deal
> > with IO etc bound tasks, CountedCompleters sometimes fare better
> > than RecursiveActions in programs that entail lots of garbage
> > collection because GC can have similar impact on task variability.
> >
> > Even though targeted for JDK8, versions of CountedCompleter
> > appear in the jsr166y and main repositories, not jsr166e. This is
> > because they require a non-public hook into modified ForkJoinTask
> > exception handling mechanics in order to properly propagate
> > exceptional completions. For sources, docs, and jar files, see
> > the usual links at
> > http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> >
> > The API docs include more details and some examples:
> >
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
> >
> >
> > I also added a few (with more to come) test/demo programs that illustrate
> > other usages. See CCBoxedLongSort and CCJacobi in
> > http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
> >
> > Please try these out. As always, comments and suggestions
> > (hopefully based on usage experience) would be welcome.
> >
> > -Doug
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 87, Issue 26
> ****************************************************
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/75746dcb/attachment.html
> >
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 87, Issue 27
> ****************************************************
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/938491d7/attachment-0001.html>

From sandeep.bansal85 at gmail.com  Mon Apr 16 15:22:56 2012
From: sandeep.bansal85 at gmail.com (Sandeep Bansal)
Date: Mon, 16 Apr 2012 12:22:56 -0700
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
Message-ID: <5553972781886771476@unknownmsgid>

 Issue 27
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="===============0377691237=="

--===============0377691237==
Content-Type: multipart/alternative;
boundary="897404883-1652871492-1334601360=:99294"

--897404883-1652871492-1334601360=:99294
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: quoted-printable

What happens in your algorithm if two threads are trying to take the
same lock simultaneously? Does the algorithm itself uses critical
section(locks??) to handle this case?

Thanks,
Sandeep
Sent from my Windows Phone
From: Rohit Kumar
Sent: 17/04/2012 12:08 AM
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
87, Issue 27
Hans,Nathan,
=C2=A0
I am not aware of anything like Gadara yet. My implementation assumes that =
there are no synchnonized keywords (implicit locks)=C2=A0in your program. I=
t requires you to use explicit locks (e.g. Lock class in java concurrent ap=
i). There is no background thread running here. The deadlock-check happens =
at each lock acquisition request; it runs an algorithms internally to see i=
f there are any cycles formed in the lock-acquisition graph. If yes, it doe=
sn't let you acquire the lock but throws an exception. You can catch this e=
xception and take necessary steps to re-acquire all the locks once again or=
 whatever you want. The program is written in java and it is hardly 270 lin=
es of code.
=C2=A0
Finally where do I need to present this writeup ?
=C2=A0
Thanks & Regards,
Rohit Kumar

From: "concurrency-interest-request at cs.oswego.edu" <concurrency-interest-re=
quest at cs.oswego.edu>
To: concurrency-interest at cs.oswego.edu=20
Sent: Monday, 16 April 2012 10:50 PM
Subject: Concurrency-interest Digest, Vol 87, Issue 27

Send Concurrency-interest mailing list submissions to
=C2=A0=C2=A0=C2=A0 concurrency-interest at cs.oswego.edu

To subscribe or unsubscribe via the World Wide Web, visit
=C2=A0=C2=A0=C2=A0 http://cs.oswego.edu/mailman/listinfo/concurrency-intere=
st
or, via email, send a message with subject or body 'help' to
=C2=A0=C2=A0=C2=A0 concurrency-interest-request at cs.oswego.edu

You can reach the person managing the list at
=C2=A0=C2=A0=C2=A0 concurrency-interest-owner at cs.oswego.edu

When replying, please edit your Subject line so it is more specific
than "Re: Contents of Concurrency-interest digest..."


Today's Topics:

=C2=A0 1. Re: CountedCompleters (Wolfgang Baltes)
=C2=A0 2. Re: Java Deadlocks prevented (Boehm, Hans)
=C2=A0 3. Re: Java Deadlocks prevented (Nathan Reynolds)
=C2=A0 4. Re: Concurrency-interest Digest, Vol 87,=C2=A0=C2=A0=C2=A0 Issue =
26 (Java
=C2=A0 =C2=A0 =C2=A0 deadlock prevented) (Rohit Kumar)


----------------------------------------------------------------------

Message: 1
Date: Mon, 16 Apr 2012 18:01:50 +0200
From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] CountedCompleters
Message-ID: <4F8C426E.6090704 at laposte.net>
Content-Type: text/plain; charset=3DISO-8859-1; format=3Dflowed

I apologize for a mistake in the last paragraph of my memo: using=20
quietlyJoinUnforked() in the SDK7 sample code for MergeSort does have a=20
non-negligible performance impact (not no impact as stated). There is=20
better performance in case of recursions which produce many tasks that=20
are not explicitly forked, and it reduces the number of extra threads=20
significantly, allowing larger problems to be solved with smaller memory=20
footprint.

Wolfgang.

On 2012-04-16 16:48, Wolfgang Baltes wrote:
> Thanks, Doug, for a this addition to the FJ framework. I think that
> CountedCompleter will address the needs of an entire class of
> applications in an efficient and simple to use manner.
>
> I used the code and noticed that method doJoin() has become more
> effective in avoiding blocking threads, and as a result fewer extra
> threads are created. I found the performance, compared to
> RecursiveAction, to be equal or insignificantly different. This
> reduces the problem described in item 3 below.
>
> However, at the same time, CountedCompleter does not fully satisfy the
> needs for a class of problems I work on. To this end, here are a few
> enhancements I would like to suggest:
>
> 1: Symmetrically to onCompletion(), provide
> onExceptionalCompletion(Throwable). This allows filtering exception
> propagation. There are cases where the propagation of the exception is
> desired, and others where a corrective action is taken instead, such
> as a retry.
>
> 2: As a further enhancement to 1: enable any Throwable, including
> checked exceptions. This allows the use of a CountedCompleter as a
> CompletionHandler for asynchronous IO operations or as a wrapper for
> MethodHandles (which throw Throwable) without adding extra logic to
> capture and convert an IO exception. I read the documentation which
> explains why this is currently limited to unchecked exceptions. While
> I can agree with this in general, I feel the argument is weak for
> CountedCompleter if it is there to support asynchronous tasks/events.
> (May I add that using this type of framework is not for the
> faint-hearted anyway!?)
>
> 3: Provide a method to join a task that is not forked and/or not
> completable, while minimizing worker thread blocking. For example,
> CountedCompleter allows creating chains of dependent tasks. Unless the
> ultimate task (the last in the chain) is forked/exists on the task
> stack AND can complete because all dependencies are resolved, joining
> it will block the worker thread. I noticed (and my testing is limited
> to a few test cases and therefore not representative) the blocking and
> the creation of other worker threads, ultimately running out of memory
> or reaching the thread count limit. If this task is not forked, then
> join()/quietlyJoin() will block the worker thread. The following code
> is my (inexpert) attempt to provide a remedy. It is based on the
> assumption that a task that depends on others for completion is not
> forked until all dependencies are resolved. For example, a
> CountedCompleter implementing CompletionHandler would fork itself
> ("implicit fork") when the IO operation is done. This works very well
> in my test cases, but at this time I would not claim it to be
> universally applicable or error free. It is shown here more to
> demonstrate the attempt rather than as a reference implementation.
> With access to private data structures, this can be done more
> elegantly and more reliably.
>
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 static final int RETRIES =3D 16;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 static final long WAIT_TIMEOUT =3D 1_000;=C2=
=A0 =C2=A0 // Timeout in
> microseconds.
>
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 public final void quietlyJoinUnforked() {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 this.doJoinUnforked(false);
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 public final void quietlyJoinUnforkedInterrupt=
ibly()
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 throws InterruptedException {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 if (this.doJoinUnforked(true)) {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 throw new Interrup=
tedException();
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 public final boolean doJoinUnforked(final bool=
ean
> interruptibly) {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 int retries =3D RETRIES;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 boolean wasInterrupted =3D false=
;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 while (!this.isDone()) {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ForkJoinTask<?> t;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 if ((t =3D pollTas=
k()) !=3D null) {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 t.qu=
ietlyInvoke();
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 if (=
t =3D=3D this) {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 break;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 else {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 if (=
retries-- > 0) {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 Thread.yield();
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 continue;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 wasI=
nterrupted =3D Thread.interrupted();
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 try =
{
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 // get(...) is used as a timed join(). It is
> assumed that
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 // other code will perform get() on this task
> to retrieve
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 // the task's result or exception.
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 break;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 catc=
h (final InterruptedException consumed) {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 if (!interruptibly) {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 =C2=A0 =C2=A0 wasInterrupted =3D true;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 =C2=A0 =C2=A0 continue;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 }
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 return true;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 catc=
h (final ExecutionException ignored) {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 // See comment on get() above.
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 break;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 catc=
h (final TimeoutException ignored) {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 continue;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 retries =3D RETRIE=
S;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 if (wasInterrupted && !interrupt=
ibly) {
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 Thread.currentThre=
ad().interrupt();
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 return false;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 return wasInterrupted;
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 }
>
> As already mentioned this works quite well in a number of cases. For
> example, adding this method to the example MergeSort code and calling
> quietlyJoinUnforked(), results in the same overall performance,
> reduces the number of extra blocked worker threads to 1 if any
> (instead of up to 8 for the unmodified code; on a PC with 4
> hyper-threading cores/8 threads), and allows for some extra
> (recreational?) freedom in joining the right and left sub-tasks in any
> order. It works in cases where no sub-task is forked explicitly. I
> observed that worker thread blocking only occurs towards the end of a
> large recursion, suggesting that worker threads only block - as
> intended - when there is no other work available (sometimes while
> implicit forking has not yet happened).
>
> Wolfgang.
>
>
>
> On 2012-04-09 16:16, Doug Lea wrote:
>>
>> After sitting on multiple variations for months, I committed
>> CountedCompleter, a completion-based flavor of ForkJoinTask.
>>
>> As mentioned a few times over the past year, the main motivation
>> is to better support tasks that perform IO or other base
>> actions that may (or may not) take a lot of time to execute.
>> As is the case with JDK7 async IO and other completion-based
>> frameworks, the most common path to efficiency is for such tasks
>> to arrange continuation actions that occur upon their completion.
>> The main twist for CountedCompleters is that continuations
>> might be dependent on multiple actions, not just one. (Or in
>> other words, the continuations must be preceded by a specialized,
>> "bottom-up" form of join.)
>>
>> The CountedCompleter abstract class provides a minimal basis
>> for these kinds of tasks. While some of the mechanics are
>> reminiscent of other FJ-like frameworks such as Intel TBB,
>> CountedCompleters are designed to fit smoothly with other
>> kinds of ForkJoinTasks (like RecursiveActions), and so still
>> allow people to use the more pleasant Future-style conventions
>> rather than count-based bottom-up joining unless they need them.
>> At the same time, the CountedCompleter class exposes enough
>> mechanics to allow all sorts of tweaks that people can use
>> to improve performance.
>> In particular, in addition to usually being the best way to deal
>> with IO etc bound tasks, CountedCompleters sometimes fare better
>> than RecursiveActions in programs that entail lots of garbage
>> collection because GC can have similar impact on task variability.
>>
>> Even though targeted for JDK8, versions of CountedCompleter
>> appear in the jsr166y and main repositories, not jsr166e. This is
>> because they require a non-public hook into modified ForkJoinTask
>> exception handling mechanics in order to properly propagate
>> exceptional completions. For sources, docs, and jar files, see
>> the usual links at
>> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>>
>> The API docs include more details and some examples:
>> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/Counte=
dCompleter.html
>>
>>
>> I also added a few (with more to come) test/demo programs that
>> illustrate
>> other usages. See CCBoxedLongSort and CCJacobi in
>> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
>>
>> Please try these out. As always, comments and suggestions
>> (hopefully based on usage experience) would be welcome.
>>
>> -Doug
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


------------------------------

Message: 2
Date: Mon, 16 Apr 2012 16:38:00 +0000
From: "Boehm, Hans" <hans.boehm at hp.com>
To: Andrew Haley <aph at redhat.com>,
=C2=A0=C2=A0=C2=A0 "concurrency-interest at cs.oswego.edu"
=C2=A0=C2=A0=C2=A0 <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Java Deadlocks prevented
Message-ID:
=C2=A0=C2=A0=C2=A0 <A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americ=
as.hpqcorp.net>
=C2=A0=C2=A0=C2=A0=20
Content-Type: text/plain; charset=3D"us-ascii"

Important questions to consider when you write it up:

How does it compare to something like Gadara that uses whole program analys=
is and scheduling to avoid lock-based deadlocks?=C2=A0 (Hopefully it doesn'=
t need whole program analysis.)=C2=A0 Other deadlock avoidance schemes?

Once you detect a potential deadlock, how do you recover?=C2=A0 Or can you =
always schedule so that the possibility doesn't arise?

Hans

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
> Sent: Monday, April 16, 2012 4:34 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
>=20
> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>=20
> > I have found a way of preventing deadlocks in java. The
> > methodology(which is code) completely prevents the deadlock from
> > occuring by detecting it in advance. This can be used across the
> > systems seamlessly.
> >
> > Kindly let me know what I need to do next. I want this to be part of
> > next jdk release. I am writing this email as I have no idea what I
> > need to do next to bring it into limelight.
>=20
> Write it up, maybe present it to a conference, and wait for feedback.
> That's how it always works.=C2=A0 If your idea really works, people will
> use it.
>=20
> Andrew.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



------------------------------

Message: 3
Date: Mon, 16 Apr 2012 10:11:00 -0700
From: Nathan Reynolds <nathan.reynolds at oracle.com>
To: "Boehm, Hans" <hans.boehm at hp.com>
Cc: "concurrency-interest at cs.oswego.edu"
=C2=A0=C2=A0=C2=A0 <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Java Deadlocks prevented
Message-ID: <4F8C52A4.70002 at oracle.com>
Content-Type: text/plain; charset=3D"iso-8859-1"; Format=3D"flowed"

Deadlock prevention is very valuable.=C2=A0 It means deadlock prone code=20
won't bring down a production server and cost the company millions in=20
down time.=C2=A0 It means consumers won't kill the process and request a re=
fund.

How much does deadlock prevention cost?=C2=A0 Is the cost on the thread tha=
t=20
acquires locks or is it in a background thread?

Each time processors or systems increase the number of cores, I find we=20
have to do a round of lock contention fixing.=C2=A0 I have only seen 1 lock=
=20
at a time be the bottleneck in the system.=C2=A0 Does deadlock prevention=
=20
increase the critical region of locks?=C2=A0 If so, this will definitely=20
reduce the scalability of the system if it impacts the 1 bottlenecking lock=
.

Lock performance is a very important consideration.=C2=A0 Locks have evolve=
d=20
from fat locks (i.e trips into the OS kernel) to thin locks (i.e. spin=20
and CAS in user mode) to biased/lazy locks (i.e. no CAS and an=20
indefinite lock owner).=C2=A0 All of this was done to reduce the performanc=
e=20
overhead of locks.=C2=A0 How does deadlock prevention impact the performanc=
e=20
of biased, thin and fat locks?=C2=A0 I am not as concerned about fat lock=
=20
performance since most of the time the thread is going to block.

Nathan Reynolds=20
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |=20
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/16/2012 9:38 AM, Boehm, Hans wrote:
> Important questions to consider when you write it up:
>
> How does it compare to something like Gadara that uses whole program anal=
ysis and scheduling to avoid lock-based deadlocks?=C2=A0 (Hopefully it does=
n't need whole program analysis.)=C2=A0 Other deadlock avoidance schemes?
>
> Once you detect a potential deadlock, how do you recover?=C2=A0 Or can yo=
u always schedule so that the possibility doesn't arise?
>
> Hans
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
>> Sent: Monday, April 16, 2012 4:34 AM
>> To: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Java Deadlocks prevented
>>
>> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>>
>>> I have found a way of preventing deadlocks in java. The
>>> methodology(which is code) completely prevents the deadlock from
>>> occuring by detecting it in advance. This can be used across the
>>> systems seamlessly.
>>>
>>> Kindly let me know what I need to do next. I want this to be part of
>>> next jdk release. I am writing this email as I have no idea what I
>>> need to do next to bring it into limelight.
>> Write it up, maybe present it to a conference, and wait for feedback.
>> That's how it always works.=C2=A0 If your idea really works, people will
>> use it.
>>
>> Andrew.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120=
416/7ea89bb3/attachment-0001.html>

------------------------------

Message: 4
Date: Tue, 17 Apr 2012 01:20:15 +0800 (SGT)
From: Rohit Kumar <rohitk242 at yahoo.co.in>
To: "concurrency-interest at cs.oswego.edu"
=C2=A0=C2=A0=C2=A0 <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
=C2=A0=C2=A0=C2=A0 87,=C2=A0=C2=A0=C2=A0 Issue 26 (Java deadlock prevented)
Message-ID:
=C2=A0=C2=A0=C2=A0 <1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.=
com>
Content-Type: text/plain; charset=3D"iso-8859-1"

Andrew:
?
Thanks for the reply. Can you kindly let me know where do I need to present=
 it ? Where will the conference be held ? Can I present it online or I have=
 to come in person ?
?
Waiting for your early reply once again.
?
Thanks & Regards,
Rohit Kumar

From: "concurrency-interest-request at cs.oswego.edu" <concurrency-interest-re=
quest at cs.oswego.edu>
To: concurrency-interest at cs.oswego.edu=20
Sent: Monday, 16 April 2012 9:30 PM
Subject: Concurrency-interest Digest, Vol 87, Issue 26

Send Concurrency-interest mailing list submissions to
??? concurrency-interest at cs.oswego.edu

To subscribe or unsubscribe via the World Wide Web, visit
??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
or, via email, send a message with subject or body 'help' to
??? concurrency-interest-request at cs.oswego.edu

You can reach the person managing the list at
??? concurrency-interest-owner at cs.oswego.edu

When replying, please edit your Subject line so it is more specific
than "Re: Contents of Concurrency-interest digest..."


Today's Topics:

? 1. (no subject) (Rohit Kumar)
? 2. Java Deadlocks prevented (Rohit Kumar)
? 3. Re: Java Deadlocks prevented (Andrew Haley)
? 4. Re: CountedCompleters (Wolfgang Baltes)


----------------------------------------------------------------------

Message: 1
Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT)
From: Rohit Kumar <rohitk242 at yahoo.co.in>
To: "concurrency-interest at cs.oswego.edu"
??? <concurrency-interest at cs.oswego.edu>
Cc: "concurrency-interest-owner at cs.oswego.edu"
??? <concurrency-interest-owner at cs.oswego.edu>
Subject: [concurrency-interest] (no subject)
Message-ID:
??? <1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com>
Content-Type: text/plain; charset=3D"iso-8859-1"

Hi All,
?
I have found a way of preventing deadlocks in java. The methodology(which i=
s code) completely prevents the deadlock from accuring by detecting it in a=
dvance. This can be used across the systems seamlessly.=20
?
Kindly let me know what I need to do next. I want this to be part of next j=
dk release.
?
Thanks & Regards,
Rohit Kumar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120=
416/a6588341/attachment-0001.html>

------------------------------

Message: 2
Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)
From: Rohit Kumar <rohitk242 at yahoo.co.in>
To: "concurrency-interest at cs.oswego.edu"
??? <concurrency-interest at cs.oswego.edu>
Cc: "concurrency-interest-owner at cs.oswego.edu"
??? <concurrency-interest-owner at cs.oswego.edu>
Subject: [concurrency-interest] Java Deadlocks prevented
Message-ID:
??? <1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com>
Content-Type: text/plain; charset=3D"utf-8"



Hi All,

I have found a way of preventing deadlocks in java. The methodology(which i=
s code) completely prevents the deadlock from occuring by detecting it in a=
dvance. This can be used across the systems seamlessly.=20

Kindly let me know what I need to do next. I want this to be part of next j=
dk release. I am writing this email as I have no idea what I need to do nex=
t to bring it into limelight.

Thanks & Regards,
Rohit Kumar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120=
416/064a4873/attachment-0001.html>

------------------------------

Message: 3
Date: Mon, 16 Apr 2012 12:33:45 +0100
From: Andrew Haley <aph at redhat.com>
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Java Deadlocks prevented
Message-ID: <4F8C0399.8040301 at redhat.com>
Content-Type: text/plain; charset=3DISO-8859-1

On 04/16/2012 12:06 PM, Rohit Kumar wrote:

> I have found a way of preventing deadlocks in java. The
> methodology(which is code) completely prevents the deadlock from
> occuring by detecting it in advance. This can be used across the
> systems seamlessly.
>=20
> Kindly let me know what I need to do next. I want this to be part of
> next jdk release. I am writing this email as I have no idea what I
> need to do next to bring it into limelight.

Write it up, maybe present it to a conference, and wait for feedback.
That's how it always works.? If your idea really works, people will
use it.

Andrew.


------------------------------

Message: 4
Date: Mon, 16 Apr 2012 16:48:31 +0200
From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
To: "Concurrency-interest at cs.oswego.edu"
??? <Concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] CountedCompleters
Message-ID: <4F8C313F.2080308 at laposte.net>
Content-Type: text/plain; charset=3DISO-8859-1; format=3Dflowed

Thanks, Doug, for a this addition to the FJ framework. I think that=20
CountedCompleter will address the needs of an entire class of=20
applications in an efficient and simple to use manner.

I used the code and noticed that method doJoin() has become more=20
effective in avoiding blocking threads, and as a result fewer extra=20
threads are created. I found the performance, compared to=20
RecursiveAction, to be equal or insignificantly different. This reduces=20
the problem described in item 3 below.

However, at the same time, CountedCompleter does not fully satisfy the=20
needs for a class of problems I work on. To this end, here are a few=20
enhancements I would like to suggest:

1: Symmetrically to onCompletion(), provide=20
onExceptionalCompletion(Throwable). This allows filtering exception=20
propagation. There are cases where the propagation of the exception is=20
desired, and others where a corrective action is taken instead, such as=20
a retry.

2: As a further enhancement to 1: enable any Throwable, including=20
checked exceptions. This allows the use of a CountedCompleter as a=20
CompletionHandler for asynchronous IO operations or as a wrapper for=20
MethodHandles (which throw Throwable) without adding extra logic to=20
capture and convert an IO exception. I read the documentation which=20
explains why this is currently limited to unchecked exceptions. While I=20
can agree with this in general, I feel the argument is weak for=20
CountedCompleter if it is there to support asynchronous tasks/events.=20
(May I add that using this type of framework is not for the=20
faint-hearted anyway!?)

3: Provide a method to join a task that is not forked and/or not=20
completable, while minimizing worker thread blocking. For example,=20
CountedCompleter allows creating chains of dependent tasks. Unless the=20
ultimate task (the last in the chain) is forked/exists on the task stack=20
AND can complete because all dependencies are resolved, joining it will=20
block the worker thread. I noticed (and my testing is limited to a few=20
test cases and therefore not representative) the blocking and the=20
creation of other worker threads, ultimately running out of memory or=20
reaching the thread count limit. If this task is not forked, then=20
join()/quietlyJoin() will block the worker thread. The following code is=20
my (inexpert) attempt to provide a remedy. It is based on the assumption=20
that a task that depends on others for completion is not forked until=20
all dependencies are resolved. For example, a CountedCompleter=20
implementing CompletionHandler would fork itself ("implicit fork") when=20
the IO operation is done. This works very well in my test cases, but at=20
this time I would not claim it to be universally applicable or error=20
free. It is shown here more to demonstrate the attempt rather than as a=20
reference implementation. With access to private data structures, this=20
can be done more elegantly and more reliably.

? ? ? ? static final int RETRIES =3D 16;
? ? ? ? static final long WAIT_TIMEOUT =3D 1_000;? ? // Timeout in=20
microseconds.

? ? ? ? public final void quietlyJoinUnforked() {
? ? ? ? ? ? this.doJoinUnforked(false);
? ? ? ? }

? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
? ? ? ? throws InterruptedException {
? ? ? ? ? ? if (this.doJoinUnforked(true)) {
? ? ? ? ? ? ? ? throw new InterruptedException();
? ? ? ? ? ? }
? ? ? ? }

? ? ? ? public final boolean doJoinUnforked(final boolean interruptibly) {
? ? ? ? ? ? int retries =3D RETRIES;
? ? ? ? ? ? boolean wasInterrupted =3D false;
? ? ? ? ? ? while (!this.isDone()) {
? ? ? ? ? ? ? ? ForkJoinTask<?> t;
? ? ? ? ? ? ? ? if ((t =3D pollTask()) !=3D null) {
? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
? ? ? ? ? ? ? ? ? ? if (t =3D=3D this) {
? ? ? ? ? ? ? ? ? ? ? ? break;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? else {
? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
? ? ? ? ? ? ? ? ? ? ? ? continue;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? wasInterrupted =3D Thread.interrupted();
? ? ? ? ? ? ? ? ? ? try {
? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is=20
assumed that
? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task=20
to retrieve
? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
? ? ? ? ? ? ? ? ? ? ? ? break;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted =3D true;
? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
? ? ? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? ? ? return true;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
? ? ? ? ? ? ? ? ? ? ? ? break;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
? ? ? ? ? ? ? ? ? ? ? ? continue;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? retries =3D RETRIES;
? ? ? ? ? ? }
? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
? ? ? ? ? ? ? ? return false;
? ? ? ? ? ? }
? ? ? ? ? ? return wasInterrupted;
? ? ? ? }

As already mentioned this works quite well in a number of cases. For=20
example, adding this method to the example MergeSort code and calling=20
quietlyJoinUnforked(), results in the same overall performance, reduces=20
the number of extra blocked worker threads to 1 if any (instead of up to=20
8 for the unmodified code; on a PC with 4 hyper-threading cores/8=20
threads), and allows for some extra (recreational?) freedom in joining=20
the right and left sub-tasks in any order. It works in cases where no=20
sub-task is forked explicitly. I observed that worker thread blocking=20
only occurs towards the end of a large recursion, suggesting that worker=20
threads only block - as intended - when there is no other work available=20
(sometimes while implicit forking has not yet happened).

Wolfgang.



On 2012-04-09 16:16, Doug Lea wrote:
>
> After sitting on multiple variations for months, I committed
> CountedCompleter, a completion-based flavor of ForkJoinTask.
>
> As mentioned a few times over the past year, the main motivation
> is to better support tasks that perform IO or other base
> actions that may (or may not) take a lot of time to execute.
> As is the case with JDK7 async IO and other completion-based
> frameworks, the most common path to efficiency is for such tasks
> to arrange continuation actions that occur upon their completion.
> The main twist for CountedCompleters is that continuations
> might be dependent on multiple actions, not just one. (Or in
> other words, the continuations must be preceded by a specialized,
> "bottom-up" form of join.)
>
> The CountedCompleter abstract class provides a minimal basis
> for these kinds of tasks. While some of the mechanics are
> reminiscent of other FJ-like frameworks such as Intel TBB,
> CountedCompleters are designed to fit smoothly with other
> kinds of ForkJoinTasks (like RecursiveActions), and so still
> allow people to use the more pleasant Future-style conventions
> rather than count-based bottom-up joining unless they need them.
> At the same time, the CountedCompleter class exposes enough
> mechanics to allow all sorts of tweaks that people can use
> to improve performance.
> In particular, in addition to usually being the best way to deal
> with IO etc bound tasks, CountedCompleters sometimes fare better
> than RecursiveActions in programs that entail lots of garbage
> collection because GC can have similar impact on task variability.
>
> Even though targeted for JDK8, versions of CountedCompleter
> appear in the jsr166y and main repositories, not jsr166e. This is
> because they require a non-public hook into modified ForkJoinTask
> exception handling mechanics in order to properly propagate
> exceptional completions. For sources, docs, and jar files, see
> the usual links at=20
> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>
> The API docs include more details and some examples:
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/Counted=
Completer.html=20
>
>
> I also added a few (with more to come) test/demo programs that illustrate
> other usages. See CCBoxedLongSort and CCJacobi in
> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
>
> Please try these out. As always, comments and suggestions
> (hopefully based on usage experience) would be welcome.
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


------------------------------

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


End of Concurrency-interest Digest, Vol 87, Issue 26
****************************************************
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120=
417/75746dcb/attachment.html>

------------------------------

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


End of Concurrency-interest Digest, Vol 87, Issue 27
****************************************************
--897404883-1652871492-1334601360=:99294
Content-Type: text/html; charset="utf-8"
Content-Transfer-Encoding: quoted-printable

<html><body><html><head><meta content=3D"text/html; charset=3Dutf-8" http-e=
quiv=3D"Content-Type"></head><body><div><div style=3D"font-family: Calibri,=
sans-serif; font-size: 11pt;">What happens in your algorithm if two threads=
 are trying to take the same lock simultaneously? Does the algorithm itself=
&nbsp; uses critical section(locks??) to handle this case?<br><br>Thanks,<b=
r>Sandeep<br>Sent from my Windows Phone<br></div></div><hr><span style=3D"f=
ont-family: Tahoma,sans-serif; font-size: 10pt; font-weight: bold;">From: <=
/span><span style=3D"font-family: Tahoma,sans-serif; font-size: 10pt;">Rohi=
t Kumar</span><br><span style=3D"font-family: Tahoma,sans-serif; font-size:=
 10pt; font-weight: bold;">Sent: </span><span style=3D"font-family: Tahoma,=
sans-serif; font-size: 10pt;">17/04/2012 12:08 AM</span><br><span style=3D"=
font-family: Tahoma,sans-serif; font-size: 10pt; font-weight: bold;">To: </=
span><span style=3D"font-family: Tahoma,sans-serif; font-size: 10pt;">concu=
rrency-interest at cs.oswego.edu</span><br><span style=3D"font-family: Tahoma,=
sans-serif; font-size: 10pt; font-weight: bold;">Subject: </span><span styl=
e=3D"font-family: Tahoma,sans-serif; font-size: 10pt;">Re: [concurrency-int=
erest] Concurrency-interest Digest, Vol 87, Issue 27</span><br><br></body><=
/html><div style=3D"color:#000; background-color:#fff; font-family:times ne=
w roman, new york, times, serif;font-size:12pt"><div style=3D"RIGHT: auto">=
<SPAN style=3D"RIGHT: auto">Hans,Nathan,</SPAN></div>
<div style=3D"RIGHT: auto"><SPAN style=3D"RIGHT: auto"></SPAN>&nbsp;</div>
<div style=3D"RIGHT: auto"><SPAN style=3D"RIGHT: auto">I am not aware of an=
ything like Gadara yet. My implementation assumes that there are no synchno=
nized keywords (implicit locks)&nbsp;in your program. It requires you to us=
e explicit locks (e.g. Lock class in java concurrent api). There is no back=
ground thread running here. The deadlock-check happens at each lock acquisi=
tion request; it runs an algorithms internally to see if there are any cycl=
es formed in the lock-acquisition graph. If yes, it doesn't let you acquire=
 the lock but throws an exception. You can catch this exception and take ne=
cessary steps to re-acquire all the locks once again or whatever you want. =
The program is written in java and it is hardly 270 lines of code.</SPAN></=
div>
<div style=3D"RIGHT: auto"><SPAN style=3D"RIGHT: auto"></SPAN>&nbsp;</div>
<div style=3D"RIGHT: auto"><SPAN style=3D"RIGHT: auto">Finally where do I n=
eed to present this writeup ?<VAR id=3Dyui-ie-cursor></VAR></SPAN></div>
<div style=3D"RIGHT: auto"><SPAN style=3D"RIGHT: auto"></SPAN>&nbsp;</div>
<div style=3D"RIGHT: auto"><SPAN style=3D"RIGHT: auto">Thanks &amp; Regards=
,</SPAN></div>
<div style=3D"RIGHT: auto"><SPAN style=3D"RIGHT: auto">Rohit Kumar</SPAN></=
div>
<div><BR></div>
<DIV style=3D"FONT-FAMILY: times new roman, new york, times, serif; FONT-SI=
ZE: 12pt">
<DIV style=3D"FONT-FAMILY: times new roman, new york, times, serif; FONT-SI=
ZE: 12pt">
<DIV dir=3Dltr><FONT size=3D2 face=3DArial>
<DIV style=3D"BORDER-BOTTOM: #ccc 1px solid; BORDER-LEFT: #ccc 1px solid; P=
ADDING-BOTTOM: 0px; LINE-HEIGHT: 0; MARGIN: 5px 0px; PADDING-LEFT: 0px; PAD=
DING-RIGHT: 0px; HEIGHT: 0px; FONT-SIZE: 0px; BORDER-TOP: #ccc 1px solid; B=
ORDER-RIGHT: #ccc 1px solid; PADDING-TOP: 0px" class=3Dhr readonly=3D"true"=
 contenteditable=3D"false"></DIV><B><SPAN style=3D"FONT-WEIGHT: bold">From:=
</SPAN></B> "concurrency-interest-request at cs.oswego.edu" &lt;concurrency-in=
terest-request at cs.oswego.edu&gt;<BR><B><SPAN style=3D"FONT-WEIGHT: bold">To=
:</SPAN></B> concurrency-interest at cs.oswego.edu <BR><B><SPAN style=3D"FONT-=
WEIGHT: bold">Sent:</SPAN></B> Monday, 16 April 2012 10:50 PM<BR><B><SPAN s=
tyle=3D"FONT-WEIGHT: bold">Subject:</SPAN></B> Concurrency-interest Digest,=
 Vol 87, Issue 27<BR></FONT></DIV><BR>Send Concurrency-interest mailing lis=
t submissions to<BR>&nbsp;&nbsp;&nbsp; <A href=3D"mailto:concurrency-intere=
st at cs.oswego.edu"
 ymailto=3D"mailto:concurrency-interest at cs.oswego.edu">concurrency-interest=
@cs.oswego.edu</A><BR><BR>To subscribe or unsubscribe via the World Wide We=
b, visit<BR>&nbsp;&nbsp;&nbsp; <A href=3D"http://cs.oswego.edu/mailman/list=
info/concurrency-interest" target=3D_blank>http://cs.oswego.edu/mailman/lis=
tinfo/concurrency-interest</A><BR>or, via email, send a message with subjec=
t or body 'help' to<BR>&nbsp;&nbsp;&nbsp; <A href=3D"mailto:concurrency-int=
erest-request at cs.oswego.edu" ymailto=3D"mailto:concurrency-interest-request=
@cs.oswego.edu">concurrency-interest-request at cs.oswego.edu</A><BR><BR>You c=
an reach the person managing the list at<BR>&nbsp;&nbsp;&nbsp; <A href=3D"m=
ailto:concurrency-interest-owner at cs.oswego.edu" ymailto=3D"mailto:concurren=
cy-interest-owner at cs.oswego.edu">concurrency-interest-owner at cs.oswego.edu</=
A><BR><BR>When replying, please edit your Subject line so it is more specif=
ic<BR>than "Re: Contents of Concurrency-interest digest..."<BR><BR><BR>Toda=
y's
 Topics:<BR><BR>&nbsp; 1. Re: CountedCompleters (Wolfgang Baltes)<BR>&nbsp;=
 2. Re: Java Deadlocks prevented (Boehm, Hans)<BR>&nbsp; 3. Re: Java Deadlo=
cks prevented (Nathan Reynolds)<BR>&nbsp; 4. Re: Concurrency-interest Diges=
t, Vol 87,&nbsp;&nbsp;&nbsp; Issue 26 (Java<BR>&nbsp; &nbsp; &nbsp; deadloc=
k prevented) (Rohit Kumar)<BR><BR><BR>-------------------------------------=
---------------------------------<BR><BR>Message: 1<BR>Date: Mon, 16 Apr 20=
12 18:01:50 +0200<BR>From: Wolfgang Baltes &lt;<A href=3D"mailto:wolfgang.b=
altes at laposte.net" ymailto=3D"mailto:wolfgang.baltes at laposte.net">wolfgang.=
baltes at laposte.net</A>&gt;<BR>To: <A href=3D"mailto:concurrency-interest at cs=
.oswego.edu" ymailto=3D"mailto:concurrency-interest at cs.oswego.edu">concurre=
ncy-interest at cs.oswego.edu</A><BR>Subject: Re: [concurrency-interest] Count=
edCompleters<BR>Message-ID: &lt;<A href=3D"mailto:4F8C426E.6090704 at laposte.=
net"
 ymailto=3D"mailto:4F8C426E.6090704 at laposte.net">4F8C426E.6090704 at laposte.n=
et</A>&gt;<BR>Content-Type: text/plain; charset=3DISO-8859-1; format=3Dflow=
ed<BR><BR>I apologize for a mistake in the last paragraph of my memo: using=
 <BR>quietlyJoinUnforked() in the SDK7 sample code for MergeSort does have =
a <BR>non-negligible performance impact (not no impact as stated). There is=
 <BR>better performance in case of recursions which produce many tasks that=
 <BR>are not explicitly forked, and it reduces the number of extra threads =
<BR>significantly, allowing larger problems to be solved with smaller memor=
y <BR>footprint.<BR><BR>Wolfgang.<BR><BR>On 2012-04-16 16:48, Wolfgang Balt=
es wrote:<BR>&gt; Thanks, Doug, for a this addition to the FJ framework. I =
think that<BR>&gt; CountedCompleter will address the needs of an entire cla=
ss of<BR>&gt; applications in an efficient and simple to use manner.<BR>&gt=
;<BR>&gt; I used the code and noticed that method doJoin() has become
 more<BR>&gt; effective in avoiding blocking threads, and as a result fewer=
 extra<BR>&gt; threads are created. I found the performance, compared to<BR=
>&gt; RecursiveAction, to be equal or insignificantly different. This<BR>&g=
t; reduces the problem described in item 3 below.<BR>&gt;<BR>&gt; However, =
at the same time, CountedCompleter does not fully satisfy the<BR>&gt; needs=
 for a class of problems I work on. To this end, here are a few<BR>&gt; enh=
ancements I would like to suggest:<BR>&gt;<BR>&gt; 1: Symmetrically to onCo=
mpletion(), provide<BR>&gt; onExceptionalCompletion(Throwable). This allows=
 filtering exception<BR>&gt; propagation. There are cases where the propaga=
tion of the exception is<BR>&gt; desired, and others where a corrective act=
ion is taken instead, such<BR>&gt; as a retry.<BR>&gt;<BR>&gt; 2: As a furt=
her enhancement to 1: enable any Throwable, including<BR>&gt; checked excep=
tions. This allows the use of a CountedCompleter as a<BR>&gt;
 CompletionHandler for asynchronous IO operations or as a wrapper for<BR>&g=
t; MethodHandles (which throw Throwable) without adding extra logic to<BR>&=
gt; capture and convert an IO exception. I read the documentation which<BR>=
&gt; explains why this is currently limited to unchecked exceptions. While<=
BR>&gt; I can agree with this in general, I feel the argument is weak for<B=
R>&gt; CountedCompleter if it is there to support asynchronous tasks/events=
.<BR>&gt; (May I add that using this type of framework is not for the<BR>&g=
t; faint-hearted anyway!?)<BR>&gt;<BR>&gt; 3: Provide a method to join a ta=
sk that is not forked and/or not<BR>&gt; completable, while minimizing work=
er thread blocking. For example,<BR>&gt; CountedCompleter allows creating c=
hains of dependent tasks. Unless the<BR>&gt; ultimate task (the last in the=
 chain) is forked/exists on the task<BR>&gt; stack AND can complete because=
 all dependencies are resolved, joining<BR>&gt; it will block the
 worker thread. I noticed (and my testing is limited<BR>&gt; to a few test =
cases and therefore not representative) the blocking and<BR>&gt; the creati=
on of other worker threads, ultimately running out of memory<BR>&gt; or rea=
ching the thread count limit. If this task is not forked, then<BR>&gt; join=
()/quietlyJoin() will block the worker thread. The following code<BR>&gt; i=
s my (inexpert) attempt to provide a remedy. It is based on the<BR>&gt; ass=
umption that a task that depends on others for completion is not<BR>&gt; fo=
rked until all dependencies are resolved. For example, a<BR>&gt; CountedCom=
pleter implementing CompletionHandler would fork itself<BR>&gt; ("implicit =
fork") when the IO operation is done. This works very well<BR>&gt; in my te=
st cases, but at this time I would not claim it to be<BR>&gt; universally a=
pplicable or error free. It is shown here more to<BR>&gt; demonstrate the a=
ttempt rather than as a reference implementation.<BR>&gt; With
 access to private data structures, this can be done more<BR>&gt; elegantly=
 and more reliably.<BR>&gt;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; static final=
 int RETRIES =3D 16;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; static final long W=
AIT_TIMEOUT =3D 1_000;&nbsp; &nbsp; // Timeout in<BR>&gt; microseconds.<BR>=
&gt;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; public final void quietlyJoinUnfork=
ed() {<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.doJoinUnforked=
(false);<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&gt;<BR>&gt;&nbsp; &nbsp; =
&nbsp; &nbsp; public final void quietlyJoinUnforkedInterruptibly()<BR>&gt;&=
nbsp; &nbsp; &nbsp; &nbsp; throws InterruptedException {<BR>&gt;&nbsp; &nbs=
p; &nbsp; &nbsp; &nbsp; &nbsp; if (this.doJoinUnforked(true)) {<BR>&gt;&nbs=
p; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new InterruptedEx=
ception();<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<BR>&gt;&nbsp;=
 &nbsp; &nbsp; &nbsp; }<BR>&gt;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp;
 public final boolean doJoinUnforked(final boolean<BR>&gt; interruptibly) {=
<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int retries =3D RETRIES;<=
BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boolean wasInterrupted =3D=
 false;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (!this.isDon=
e()) {<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkJ=
oinTask&lt;?&gt; t;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;=
 &nbsp; if ((t =3D pollTask()) !=3D null) {<BR>&gt;&nbsp; &nbsp; &nbsp; &nb=
sp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t.quietlyInvoke();<BR>&gt;&nb=
sp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (t =
=3D=3D this) {<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbs=
p; &nbsp; &nbsp; &nbsp; &nbsp; break;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &n=
bsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp=
; &nbsp; &nbsp; &nbsp; &nbsp; }<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &=
nbsp;
 &nbsp; &nbsp; else {<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbs=
p; &nbsp; &nbsp; &nbsp; if (retries-- &gt; 0) {<BR>&gt;&nbsp; &nbsp; &nbsp;=
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Thread.yiel=
d();<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
&nbsp; &nbsp; &nbsp; continue;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &n=
bsp; &nbsp; &nbsp; &nbsp; &nbsp; }<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp=
; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wasInterrupted =3D Thread.interrupted(=
);<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &n=
bsp; try {<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &=
nbsp; &nbsp; &nbsp; &nbsp; // get(...) is used as a timed join(). It is<BR>=
&gt; assumed that<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &=
nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // other code will perform get() on this =
task<BR>&gt; to retrieve<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // the task's result or e=
xception.<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &n=
bsp; &nbsp; &nbsp; &nbsp; this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);<BR=
>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
&nbsp; &nbsp; break;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp=
; &nbsp; &nbsp; &nbsp; }<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &=
nbsp; &nbsp; &nbsp; &nbsp; catch (final InterruptedException consumed) {<BR=
>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
&nbsp; &nbsp; if (!interruptibly) {<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbs=
p; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wasInterr=
upted =3D true;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nb=
sp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<BR>&gt;&nbsp; &nbsp=
; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; }<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &n=
bsp; &nbsp; &nbsp; &nbsp; return true;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &=
nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<BR>&gt;&nbsp; &nbsp; &nbsp; &nbs=
p; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; catch (final ExecutionExceptio=
n ignored) {<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;=
 &nbsp; &nbsp; &nbsp; &nbsp; // See comment on get() above.<BR>&gt;&nbsp; &=
nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;=
 break;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbs=
p; &nbsp; }<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
&nbsp; &nbsp; catch (final TimeoutException ignored) {<BR>&gt;&nbsp; &nbsp;=
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cont=
inue;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;=
 &nbsp; }<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; }<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; re=
tries =3D RETRIES;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<BR>&g=
t;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (wasInterrupted &amp;&amp; !=
interruptibly) {<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &n=
bsp; Thread.currentThread().interrupt();<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp;=
 &nbsp; &nbsp; &nbsp; &nbsp; return false;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbs=
p; &nbsp; &nbsp; }<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return =
wasInterrupted;<BR>&gt;&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&gt;<BR>&gt; As alr=
eady mentioned this works quite well in a number of cases. For<BR>&gt; exam=
ple, adding this method to the example MergeSort code and calling<BR>&gt; q=
uietlyJoinUnforked(), results in the same overall performance,<BR>&gt; redu=
ces the number of extra blocked worker threads to 1 if any<BR>&gt; (instead=
 of up to 8 for the unmodified code; on a PC with 4<BR>&gt;
 hyper-threading cores/8 threads), and allows for some extra<BR>&gt; (recre=
ational?) freedom in joining the right and left sub-tasks in any<BR>&gt; or=
der. It works in cases where no sub-task is forked explicitly. I<BR>&gt; ob=
served that worker thread blocking only occurs towards the end of a<BR>&gt;=
 large recursion, suggesting that worker threads only block - as<BR>&gt; in=
tended - when there is no other work available (sometimes while<BR>&gt; imp=
licit forking has not yet happened).<BR>&gt;<BR>&gt; Wolfgang.<BR>&gt;<BR>&=
gt;<BR>&gt;<BR>&gt; On 2012-04-09 16:16, Doug Lea wrote:<BR>&gt;&gt;<BR>&gt=
;&gt; After sitting on multiple variations for months, I committed<BR>&gt;&=
gt; CountedCompleter, a completion-based flavor of ForkJoinTask.<BR>&gt;&gt=
;<BR>&gt;&gt; As mentioned a few times over the past year, the main motivat=
ion<BR>&gt;&gt; is to better support tasks that perform IO or other base<BR=
>&gt;&gt; actions that may (or may not) take a lot of time to
 execute.<BR>&gt;&gt; As is the case with JDK7 async IO and other completio=
n-based<BR>&gt;&gt; frameworks, the most common path to efficiency is for s=
uch tasks<BR>&gt;&gt; to arrange continuation actions that occur upon their=
 completion.<BR>&gt;&gt; The main twist for CountedCompleters is that conti=
nuations<BR>&gt;&gt; might be dependent on multiple actions, not just one. =
(Or in<BR>&gt;&gt; other words, the continuations must be preceded by a spe=
cialized,<BR>&gt;&gt; "bottom-up" form of join.)<BR>&gt;&gt;<BR>&gt;&gt; Th=
e CountedCompleter abstract class provides a minimal basis<BR>&gt;&gt; for =
these kinds of tasks. While some of the mechanics are<BR>&gt;&gt; reminisce=
nt of other FJ-like frameworks such as Intel TBB,<BR>&gt;&gt; CountedComple=
ters are designed to fit smoothly with other<BR>&gt;&gt; kinds of ForkJoinT=
asks (like RecursiveActions), and so still<BR>&gt;&gt; allow people to use =
the more pleasant Future-style conventions<BR>&gt;&gt; rather than
 count-based bottom-up joining unless they need them.<BR>&gt;&gt; At the sa=
me time, the CountedCompleter class exposes enough<BR>&gt;&gt; mechanics to=
 allow all sorts of tweaks that people can use<BR>&gt;&gt; to improve perfo=
rmance.<BR>&gt;&gt; In particular, in addition to usually being the best wa=
y to deal<BR>&gt;&gt; with IO etc bound tasks, CountedCompleters sometimes =
fare better<BR>&gt;&gt; than RecursiveActions in programs that entail lots =
of garbage<BR>&gt;&gt; collection because GC can have similar impact on tas=
k variability.<BR>&gt;&gt;<BR>&gt;&gt; Even though targeted for JDK8, versi=
ons of CountedCompleter<BR>&gt;&gt; appear in the jsr166y and main reposito=
ries, not jsr166e. This is<BR>&gt;&gt; because they require a non-public ho=
ok into modified ForkJoinTask<BR>&gt;&gt; exception handling mechanics in o=
rder to properly propagate<BR>&gt;&gt; exceptional completions. For sources=
, docs, and jar files, see<BR>&gt;&gt; the usual links
 at<BR>&gt;&gt; <A href=3D"http://gee.cs.oswego.edu/dl/concurrency-interest=
/index.html" target=3D_blank>http://gee.cs.oswego.edu/dl/concurrency-intere=
st/index.html</A><BR>&gt;&gt;<BR>&gt;&gt; The API docs include more details=
 and some examples:<BR>&gt;&gt; <A href=3D"http://gee.cs.oswego.edu/dl/jsr1=
66/dist/docs/java/util/concurrent/CountedCompleter.html" target=3D_blank>ht=
tp://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedComp=
leter.html</A><BR>&gt;&gt;<BR>&gt;&gt;<BR>&gt;&gt; I also added a few (with=
 more to come) test/demo programs that<BR>&gt;&gt; illustrate<BR>&gt;&gt; o=
ther usages. See CCBoxedLongSort and CCJacobi in<BR>&gt;&gt; <A href=3D"htt=
p://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/" target=3D=
_blank>http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/<=
/A><BR>&gt;&gt;<BR>&gt;&gt; Please try these out. As always, comments and s=
uggestions<BR>&gt;&gt; (hopefully based on usage experience) would be
 welcome.<BR>&gt;&gt;<BR>&gt;&gt; -Doug<BR>&gt;&gt;<BR>&gt;&gt;<BR>&gt;&gt;=
 _______________________________________________<BR>&gt;&gt; Concurrency-in=
terest mailing list<BR>&gt;&gt; <A href=3D"mailto:Concurrency-interest at cs.o=
swego.edu" ymailto=3D"mailto:Concurrency-interest at cs.oswego.edu">Concurrenc=
y-interest at cs.oswego.edu</A><BR>&gt;&gt; <A href=3D"http://cs.oswego.edu/ma=
ilman/listinfo/concurrency-interest" target=3D_blank>http://cs.oswego.edu/m=
ailman/listinfo/concurrency-interest</A><BR>&gt;&gt;<BR>&gt; ______________=
_________________________________<BR>&gt; Concurrency-interest mailing list=
<BR>&gt; <A href=3D"mailto:Concurrency-interest at cs.oswego.edu" ymailto=3D"m=
ailto:Concurrency-interest at cs.oswego.edu">Concurrency-interest at cs.oswego.ed=
u</A><BR>&gt; <A href=3D"http://cs.oswego.edu/mailman/listinfo/concurrency-=
interest" target=3D_blank>http://cs.oswego.edu/mailman/listinfo/concurrency=
-interest</A><BR>&gt;<BR><BR><BR>------------------------------<BR><BR>Mess=
age:
 2<BR>Date: Mon, 16 Apr 2012 16:38:00 +0000<BR>From: "Boehm, Hans" &lt;<A h=
ref=3D"mailto:hans.boehm at hp.com" ymailto=3D"mailto:hans.boehm at hp.com">hans.=
boehm at hp.com</A>&gt;<BR>To: Andrew Haley &lt;<A href=3D"mailto:aph at redhat.c=
om" ymailto=3D"mailto:aph at redhat.com">aph at redhat.com</A>&gt;,<BR>&nbsp;&nbs=
p;&nbsp; "<A href=3D"mailto:concurrency-interest at cs.oswego.edu" ymailto=3D"=
mailto:concurrency-interest at cs.oswego.edu">concurrency-interest at cs.oswego.e=
du</A>"<BR>&nbsp;&nbsp;&nbsp; &lt;<A href=3D"mailto:concurrency-interest at cs=
.oswego.edu" ymailto=3D"mailto:concurrency-interest at cs.oswego.edu">concurre=
ncy-interest at cs.oswego.edu</A>&gt;<BR>Subject: Re: [concurrency-interest] J=
ava Deadlocks prevented<BR>Message-ID:<BR>&nbsp;&nbsp;&nbsp; &lt;<A href=3D=
"mailto:A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hpqcorp.n=
et"
 ymailto=3D"mailto:A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.america=
s.hpqcorp.net">A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hp=
qcorp.net</A>&gt;<BR>&nbsp;&nbsp;&nbsp; <BR>Content-Type: text/plain; chars=
et=3D"us-ascii"<BR><BR>Important questions to consider when you write it up=
:<BR><BR>How does it compare to something like Gadara that uses whole progr=
am analysis and scheduling to avoid lock-based deadlocks?&nbsp; (Hopefully =
it doesn't need whole program analysis.)&nbsp; Other deadlock avoidance sch=
emes?<BR><BR>Once you detect a potential deadlock, how do you recover?&nbsp=
; Or can you always schedule so that the possibility doesn't arise?<BR><BR>=
Hans<BR><BR>&gt; -----Original Message-----<BR>&gt; From: <A href=3D"mailto=
:concurrency-interest-bounces at cs.oswego.edu" ymailto=3D"mailto:concurrency-=
interest-bounces at cs.oswego.edu">concurrency-interest-bounces at cs.oswego.edu<=
/A> [mailto:concurrency-<BR>&gt; <A
 href=3D"mailto:interest-bounces at cs.oswego.edu" ymailto=3D"mailto:interest-=
bounces at cs.oswego.edu">interest-bounces at cs.oswego.edu</A>] On Behalf Of And=
rew Haley<BR>&gt; Sent: Monday, April 16, 2012 4:34 AM<BR>&gt; To: <A href=
=3D"mailto:concurrency-interest at cs.oswego.edu" ymailto=3D"mailto:concurrenc=
y-interest at cs.oswego.edu">concurrency-interest at cs.oswego.edu</A><BR>&gt; Su=
bject: Re: [concurrency-interest] Java Deadlocks prevented<BR>&gt; <BR>&gt;=
 On 04/16/2012 12:06 PM, Rohit Kumar wrote:<BR>&gt; <BR>&gt; &gt; I have fo=
und a way of preventing deadlocks in java. The<BR>&gt; &gt; methodology(whi=
ch is code) completely prevents the deadlock from<BR>&gt; &gt; occuring by =
detecting it in advance. This can be used across the<BR>&gt; &gt; systems s=
eamlessly.<BR>&gt; &gt;<BR>&gt; &gt; Kindly let me know what I need to do n=
ext. I want this to be part of<BR>&gt; &gt; next jdk release. I am writing =
this email as I have no idea what I<BR>&gt; &gt; need to do next to bring i=
t
 into limelight.<BR>&gt; <BR>&gt; Write it up, maybe present it to a confer=
ence, and wait for feedback.<BR>&gt; That's how it always works.&nbsp; If y=
our idea really works, people will<BR>&gt; use it.<BR>&gt; <BR>&gt; Andrew.=
<BR>&gt; _______________________________________________<BR>&gt; Concurrenc=
y-interest mailing list<BR>&gt; <A href=3D"mailto:Concurrency-interest at cs.o=
swego.edu" ymailto=3D"mailto:Concurrency-interest at cs.oswego.edu">Concurrenc=
y-interest at cs.oswego.edu</A><BR>&gt; <A href=3D"http://cs.oswego.edu/mailma=
n/listinfo/concurrency-interest" target=3D_blank>http://cs.oswego.edu/mailm=
an/listinfo/concurrency-interest</A><BR><BR><BR><BR>-----------------------=
-------<BR><BR>Message: 3<BR>Date: Mon, 16 Apr 2012 10:11:00 -0700<BR>From:=
 Nathan Reynolds &lt;<A href=3D"mailto:nathan.reynolds at oracle.com" ymailto=
=3D"mailto:nathan.reynolds at oracle.com">nathan.reynolds at oracle.com</A>&gt;<B=
R>To: "Boehm, Hans" &lt;<A href=3D"mailto:hans.boehm at hp.com"
 ymailto=3D"mailto:hans.boehm at hp.com">hans.boehm at hp.com</A>&gt;<BR>Cc: "<A =
href=3D"mailto:concurrency-interest at cs.oswego.edu" ymailto=3D"mailto:concur=
rency-interest at cs.oswego.edu">concurrency-interest at cs.oswego.edu</A>"<BR>&n=
bsp;&nbsp;&nbsp; &lt;<A href=3D"mailto:concurrency-interest at cs.oswego.edu" =
ymailto=3D"mailto:concurrency-interest at cs.oswego.edu">concurrency-interest@=
cs.oswego.edu</A>&gt;<BR>Subject: Re: [concurrency-interest] Java Deadlocks=
 prevented<BR>Message-ID: &lt;<A href=3D"mailto:4F8C52A4.70002 at oracle.com" =
ymailto=3D"mailto:4F8C52A4.70002 at oracle.com">4F8C52A4.70002 at oracle.com</A>&=
gt;<BR>Content-Type: text/plain; charset=3D"iso-8859-1"; Format=3D"flowed"<=
BR><BR>Deadlock prevention is very valuable.&nbsp; It means deadlock prone =
code <BR>won't bring down a production server and cost the company millions=
 in <BR>down time.&nbsp; It means consumers won't kill the process and requ=
est a refund.<BR><BR>How much does deadlock prevention cost?&nbsp; Is the c=
ost on the
 thread that <BR>acquires locks or is it in a background thread?<BR><BR>Eac=
h time processors or systems increase the number of cores, I find we <BR>ha=
ve to do a round of lock contention fixing.&nbsp; I have only seen 1 lock <=
BR>at a time be the bottleneck in the system.&nbsp; Does deadlock preventio=
n <BR>increase the critical region of locks?&nbsp; If so, this will definit=
ely <BR>reduce the scalability of the system if it impacts the 1 bottleneck=
ing lock.<BR><BR>Lock performance is a very important consideration.&nbsp; =
Locks have evolved <BR>from fat locks (i.e trips into the OS kernel) to thi=
n locks (i.e. spin <BR>and CAS in user mode) to biased/lazy locks (i.e. no =
CAS and an <BR>indefinite lock owner).&nbsp; All of this was done to reduce=
 the performance <BR>overhead of locks.&nbsp; How does deadlock prevention =
impact the performance <BR>of biased, thin and fat locks?&nbsp; I am not as=
 concerned about fat lock <BR>performance since most of the time the
 thread is going to block.<BR><BR>Nathan Reynolds <BR>&lt;<A href=3D"http:/=
/psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds" target=3D_blank>htt=
p://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds</A>&gt; | <BR>Con=
sulting Member of Technical Staff | 602.333.9091<BR>Oracle PSR Engineering =
&lt;<A href=3D"http://psr.us.oracle.com/" target=3D_blank>http://psr.us.ora=
cle.com/</A>&gt; | Server Technology<BR><BR>On 4/16/2012 9:38 AM, Boehm, Ha=
ns wrote:<BR>&gt; Important questions to consider when you write it up:<BR>=
&gt;<BR>&gt; How does it compare to something like Gadara that uses whole p=
rogram analysis and scheduling to avoid lock-based deadlocks?&nbsp; (Hopefu=
lly it doesn't need whole program analysis.)&nbsp; Other deadlock avoidance=
 schemes?<BR>&gt;<BR>&gt; Once you detect a potential deadlock, how do you =
recover?&nbsp; Or can you always schedule so that the possibility doesn't a=
rise?<BR>&gt;<BR>&gt; Hans<BR>&gt;<BR>&gt;&gt; -----Original
 Message-----<BR>&gt;&gt; From: <A href=3D"mailto:concurrency-interest-boun=
ces at cs.oswego.edu" ymailto=3D"mailto:concurrency-interest-bounces at cs.oswego=
.edu">concurrency-interest-bounces at cs.oswego.edu</A> [mailto:concurrency-<B=
R>&gt;&gt; <A href=3D"mailto:interest-bounces at cs.oswego.edu" ymailto=3D"mai=
lto:interest-bounces at cs.oswego.edu">interest-bounces at cs.oswego.edu</A>] On =
Behalf Of Andrew Haley<BR>&gt;&gt; Sent: Monday, April 16, 2012 4:34 AM<BR>=
&gt;&gt; To: <A href=3D"mailto:concurrency-interest at cs.oswego.edu" ymailto=
=3D"mailto:concurrency-interest at cs.oswego.edu">concurrency-interest at cs.oswe=
go.edu</A><BR>&gt;&gt; Subject: Re: [concurrency-interest] Java Deadlocks p=
revented<BR>&gt;&gt;<BR>&gt;&gt; On 04/16/2012 12:06 PM, Rohit Kumar wrote:=
<BR>&gt;&gt;<BR>&gt;&gt;&gt; I have found a way of preventing deadlocks in =
java. The<BR>&gt;&gt;&gt; methodology(which is code) completely prevents th=
e deadlock from<BR>&gt;&gt;&gt; occuring by detecting it in advance. This c=
an be
 used across the<BR>&gt;&gt;&gt; systems seamlessly.<BR>&gt;&gt;&gt;<BR>&gt=
;&gt;&gt; Kindly let me know what I need to do next. I want this to be part=
 of<BR>&gt;&gt;&gt; next jdk release. I am writing this email as I have no =
idea what I<BR>&gt;&gt;&gt; need to do next to bring it into limelight.<BR>=
&gt;&gt; Write it up, maybe present it to a conference, and wait for feedba=
ck.<BR>&gt;&gt; That's how it always works.&nbsp; If your idea really works=
, people will<BR>&gt;&gt; use it.<BR>&gt;&gt;<BR>&gt;&gt; Andrew.<BR>&gt;&g=
t; _______________________________________________<BR>&gt;&gt; Concurrency-=
interest mailing list<BR>&gt;&gt; <A href=3D"mailto:Concurrency-interest at cs=
.oswego.edu" ymailto=3D"mailto:Concurrency-interest at cs.oswego.edu">Concurre=
ncy-interest at cs.oswego.edu</A><BR>&gt;&gt; <A href=3D"http://cs.oswego.edu/=
mailman/listinfo/concurrency-interest" target=3D_blank>http://cs.oswego.edu=
/mailman/listinfo/concurrency-interest</A><BR>&gt;
 _______________________________________________<BR>&gt; Concurrency-intere=
st mailing list<BR>&gt; <A href=3D"mailto:Concurrency-interest at cs.oswego.ed=
u" ymailto=3D"mailto:Concurrency-interest at cs.oswego.edu">Concurrency-intere=
st at cs.oswego.edu</A><BR>&gt; <A href=3D"http://cs.oswego.edu/mailman/listin=
fo/concurrency-interest" target=3D_blank>http://cs.oswego.edu/mailman/listi=
nfo/concurrency-interest</A><BR>-------------- next part --------------<BR>=
An HTML attachment was scrubbed...<BR>URL: &lt;<A href=3D"http://cs.oswego.=
edu/pipermail/concurrency-interest/attachments/20120416/7ea89bb3/attachment=
-0001.html" target=3D_blank>http://cs.oswego.edu/pipermail/concurrency-inte=
rest/attachments/20120416/7ea89bb3/attachment-0001.html</A>&gt;<BR><BR>----=
--------------------------<BR><BR>Message: 4<BR>Date: Tue, 17 Apr 2012 01:2=
0:15 +0800 (SGT)<BR>From: Rohit Kumar &lt;<A href=3D"mailto:rohitk242 at yahoo=
.co.in"
 ymailto=3D"mailto:rohitk242 at yahoo.co.in">rohitk242 at yahoo.co.in</A>&gt;<BR>=
To: "<A href=3D"mailto:concurrency-interest at cs.oswego.edu" ymailto=3D"mailt=
o:concurrency-interest at cs.oswego.edu">concurrency-interest at cs.oswego.edu</A=
>"<BR>&nbsp;&nbsp;&nbsp; &lt;<A href=3D"mailto:concurrency-interest at cs.oswe=
go.edu" ymailto=3D"mailto:concurrency-interest at cs.oswego.edu">concurrency-i=
nterest at cs.oswego.edu</A>&gt;<BR>Subject: Re: [concurrency-interest] Concur=
rency-interest Digest, Vol<BR>&nbsp;&nbsp;&nbsp; 87,&nbsp;&nbsp;&nbsp; Issu=
e 26 (Java deadlock prevented)<BR>Message-ID:<BR>&nbsp;&nbsp;&nbsp; &lt;<A =
href=3D"mailto:1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com" =
ymailto=3D"mailto:1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.co=
m">1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com</A>&gt;<BR>Co=
ntent-Type: text/plain; charset=3D"iso-8859-1"<BR><BR>Andrew:<BR>?<BR>Thank=
s for the reply. Can you kindly let me know where do I need to present it ?=
 Where
 will the conference be held ? Can I present it online or I have to come in=
 person ?<BR>?<BR>Waiting for your early reply once again.<BR>?<BR>Thanks &=
amp; Regards,<BR>Rohit Kumar<BR><BR>From: "<A href=3D"mailto:concurrency-in=
terest-request at cs.oswego.edu" ymailto=3D"mailto:concurrency-interest-reques=
t at cs.oswego.edu">concurrency-interest-request at cs.oswego.edu</A>" &lt;<A hre=
f=3D"mailto:concurrency-interest-request at cs.oswego.edu" ymailto=3D"mailto:c=
oncurrency-interest-request at cs.oswego.edu">concurrency-interest-request at cs.=
oswego.edu</A>&gt;<BR>To: <A href=3D"mailto:concurrency-interest at cs.oswego.=
edu" ymailto=3D"mailto:concurrency-interest at cs.oswego.edu">concurrency-inte=
rest at cs.oswego.edu</A> <BR>Sent: Monday, 16 April 2012 9:30 PM<BR>Subject: =
Concurrency-interest Digest, Vol 87, Issue 26<BR><BR>Send Concurrency-inter=
est mailing list submissions to<BR>??? <A href=3D"mailto:concurrency-intere=
st at cs.oswego.edu"
 ymailto=3D"mailto:concurrency-interest at cs.oswego.edu">concurrency-interest=
@cs.oswego.edu</A><BR><BR>To subscribe or unsubscribe via the World Wide We=
b, visit<BR>??? <A href=3D"http://cs.oswego.edu/mailman/listinfo/concurrenc=
y-interest" target=3D_blank>http://cs.oswego.edu/mailman/listinfo/concurren=
cy-interest</A><BR>or, via email, send a message with subject or body 'help=
' to<BR>??? <A href=3D"mailto:concurrency-interest-request at cs.oswego.edu" y=
mailto=3D"mailto:concurrency-interest-request at cs.oswego.edu">concurrency-in=
terest-request at cs.oswego.edu</A><BR><BR>You can reach the person managing t=
he list at<BR>??? <A href=3D"mailto:concurrency-interest-owner at cs.oswego.ed=
u" ymailto=3D"mailto:concurrency-interest-owner at cs.oswego.edu">concurrency-=
interest-owner at cs.oswego.edu</A><BR><BR>When replying, please edit your Sub=
ject line so it is more specific<BR>than "Re: Contents of Concurrency-inter=
est digest..."<BR><BR><BR>Today's Topics:<BR><BR>? 1. (no subject) (Rohit
 Kumar)<BR>? 2. Java Deadlocks prevented (Rohit Kumar)<BR>? 3. Re: Java Dea=
dlocks prevented (Andrew Haley)<BR>? 4. Re: CountedCompleters (Wolfgang Bal=
tes)<BR><BR><BR>-----------------------------------------------------------=
-----------<BR><BR>Message: 1<BR>Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT=
)<BR>From: Rohit Kumar &lt;<A href=3D"mailto:rohitk242 at yahoo.co.in" ymailto=
=3D"mailto:rohitk242 at yahoo.co.in">rohitk242 at yahoo.co.in</A>&gt;<BR>To: "<A =
href=3D"mailto:concurrency-interest at cs.oswego.edu" ymailto=3D"mailto:concur=
rency-interest at cs.oswego.edu">concurrency-interest at cs.oswego.edu</A>"<BR>??=
? &lt;<A href=3D"mailto:concurrency-interest at cs.oswego.edu" ymailto=3D"mail=
to:concurrency-interest at cs.oswego.edu">concurrency-interest at cs.oswego.edu</=
A>&gt;<BR>Cc: "<A href=3D"mailto:concurrency-interest-owner at cs.oswego.edu" =
ymailto=3D"mailto:concurrency-interest-owner at cs.oswego.edu">concurrency-int=
erest-owner at cs.oswego.edu</A>"<BR>??? &lt;<A
 href=3D"mailto:concurrency-interest-owner at cs.oswego.edu" ymailto=3D"mailto=
:concurrency-interest-owner at cs.oswego.edu">concurrency-interest-owner at cs.os=
wego.edu</A>&gt;<BR>Subject: [concurrency-interest] (no subject)<BR>Message=
-ID:<BR>??? &lt;<A href=3D"mailto:1334574239.81244.YahooMailNeo at web193402.m=
ail.sg3.yahoo.com" ymailto=3D"mailto:1334574239.81244.YahooMailNeo at web19340=
2.mail.sg3.yahoo.com">1334574239.81244.YahooMailNeo at web193402.mail.sg3.yaho=
o.com</A>&gt;<BR>Content-Type: text/plain; charset=3D"iso-8859-1"<BR><BR>Hi=
 All,<BR>?<BR>I have found a way of preventing deadlocks in java. The metho=
dology(which is code) completely prevents the deadlock from accuring by det=
ecting it in advance. This can be used across the systems seamlessly. <BR>?=
<BR>Kindly let me know what I need to do next. I want this to be part of ne=
xt jdk release.<BR>?<BR>Thanks &amp; Regards,<BR>Rohit Kumar<BR>-----------=
--- next part --------------<BR>An HTML attachment was scrubbed...<BR>URL:
 &lt;<A href=3D"http://cs.oswego.edu/pipermail/concurrency-interest/attachm=
ents/20120416/a6588341/attachment-0001.html" target=3D_blank>http://cs.oswe=
go.edu/pipermail/concurrency-interest/attachments/20120416/a6588341/attachm=
ent-0001.html</A>&gt;<BR><BR>------------------------------<BR><BR>Message:=
 2<BR>Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)<BR>From: Rohit Kumar &lt;=
<A href=3D"mailto:rohitk242 at yahoo.co.in" ymailto=3D"mailto:rohitk242 at yahoo.=
co.in">rohitk242 at yahoo.co.in</A>&gt;<BR>To: "<A href=3D"mailto:concurrency-=
interest at cs.oswego.edu" ymailto=3D"mailto:concurrency-interest at cs.oswego.ed=
u">concurrency-interest at cs.oswego.edu</A>"<BR>??? &lt;<A href=3D"mailto:con=
currency-interest at cs.oswego.edu" ymailto=3D"mailto:concurrency-interest at cs.=
oswego.edu">concurrency-interest at cs.oswego.edu</A>&gt;<BR>Cc: "<A href=3D"m=
ailto:concurrency-interest-owner at cs.oswego.edu" ymailto=3D"mailto:concurren=
cy-interest-owner at cs.oswego.edu">concurrency-interest-owner at cs.oswego.edu</=
A>"<BR>???
 &lt;<A href=3D"mailto:concurrency-interest-owner at cs.oswego.edu" ymailto=3D=
"mailto:concurrency-interest-owner at cs.oswego.edu">concurrency-interest-owne=
r at cs.oswego.edu</A>&gt;<BR>Subject: [concurrency-interest] Java Deadlocks p=
revented<BR>Message-ID:<BR>??? &lt;<A href=3D"mailto:1334574382.90584.Yahoo=
MailNeo at web193403.mail.sg3.yahoo.com" ymailto=3D"mailto:1334574382.90584.Ya=
hooMailNeo at web193403.mail.sg3.yahoo.com">1334574382.90584.YahooMailNeo at web1=
93403.mail.sg3.yahoo.com</A>&gt;<BR>Content-Type: text/plain; charset=3D"ut=
f-8"<BR><BR><BR><BR>Hi All,<BR><BR>I have found a way of preventing deadloc=
ks in java. The methodology(which is code) completely prevents the deadlock=
 from occuring by detecting it in advance. This can be used across the syst=
ems seamlessly. <BR><BR>Kindly let me know what I need to do next. I want t=
his to be part of next jdk release. I am writing this email as I have no id=
ea what I need to do next to bring it into limelight.<BR><BR>Thanks &amp;
 Regards,<BR>Rohit Kumar<BR>-------------- next part --------------<BR>An H=
TML attachment was scrubbed...<BR>URL: &lt;<A href=3D"http://cs.oswego.edu/=
pipermail/concurrency-interest/attachments/20120416/064a4873/attachment-000=
1.html" target=3D_blank>http://cs.oswego.edu/pipermail/concurrency-interest=
/attachments/20120416/064a4873/attachment-0001.html</A>&gt;<BR><BR>--------=
----------------------<BR><BR>Message: 3<BR>Date: Mon, 16 Apr 2012 12:33:45=
 +0100<BR>From: Andrew Haley &lt;<A href=3D"mailto:aph at redhat.com" ymailto=
=3D"mailto:aph at redhat.com">aph at redhat.com</A>&gt;<BR>To: <A href=3D"mailto:=
concurrency-interest at cs.oswego.edu" ymailto=3D"mailto:concurrency-interest@=
cs.oswego.edu">concurrency-interest at cs.oswego.edu</A><BR>Subject: Re: [conc=
urrency-interest] Java Deadlocks prevented<BR>Message-ID: &lt;<A href=3D"ma=
ilto:4F8C0399.8040301 at redhat.com" ymailto=3D"mailto:4F8C0399.8040301 at redhat=
.com">4F8C0399.8040301 at redhat.com</A>&gt;<BR>Content-Type: text/plain;
 charset=3DISO-8859-1<BR><BR>On 04/16/2012 12:06 PM, Rohit Kumar wrote:<BR>=
<BR>&gt; I have found a way of preventing deadlocks in java. The<BR>&gt; me=
thodology(which is code) completely prevents the deadlock from<BR>&gt; occu=
ring by detecting it in advance. This can be used across the<BR>&gt; system=
s seamlessly.<BR>&gt; <BR>&gt; Kindly let me know what I need to do next. I=
 want this to be part of<BR>&gt; next jdk release. I am writing this email =
as I have no idea what I<BR>&gt; need to do next to bring it into limelight=
.<BR><BR>Write it up, maybe present it to a conference, and wait for feedba=
ck.<BR>That's how it always works.? If your idea really works, people will<=
BR>use it.<BR><BR>Andrew.<BR><BR><BR>------------------------------<BR><BR>=
Message: 4<BR>Date: Mon, 16 Apr 2012 16:48:31 +0200<BR>From: Wolfgang Balte=
s &lt;<A href=3D"mailto:wolfgang.baltes at laposte.net" ymailto=3D"mailto:wolf=
gang.baltes at laposte.net">wolfgang.baltes at laposte.net</A>&gt;<BR>To: "<A
 href=3D"mailto:Concurrency-interest at cs.oswego.edu" ymailto=3D"mailto:Concu=
rrency-interest at cs.oswego.edu">Concurrency-interest at cs.oswego.edu</A>"<BR>?=
?? &lt;<A href=3D"mailto:Concurrency-interest at cs.oswego.edu" ymailto=3D"mai=
lto:Concurrency-interest at cs.oswego.edu">Concurrency-interest at cs.oswego.edu<=
/A>&gt;<BR>Subject: Re: [concurrency-interest] CountedCompleters<BR>Message=
-ID: &lt;<A href=3D"mailto:4F8C313F.2080308 at laposte.net" ymailto=3D"mailto:=
4F8C313F.2080308 at laposte.net">4F8C313F.2080308 at laposte.net</A>&gt;<BR>Conte=
nt-Type: text/plain; charset=3DISO-8859-1; format=3Dflowed<BR><BR>Thanks, D=
oug, for a this addition to the FJ framework. I think that <BR>CountedCompl=
eter will address the needs of an entire class of <BR>applications in an ef=
ficient and simple to use manner.<BR><BR>I used the code and noticed that m=
ethod doJoin() has become more <BR>effective in avoiding blocking threads, =
and as a result fewer extra <BR>threads are created. I found the performanc=
e,
 compared to <BR>RecursiveAction, to be equal or insignificantly different.=
 This reduces <BR>the problem described in item 3 below.<BR><BR>However, at=
 the same time, CountedCompleter does not fully satisfy the <BR>needs for a=
 class of problems I work on. To this end, here are a few <BR>enhancements =
I would like to suggest:<BR><BR>1: Symmetrically to onCompletion(), provide=
 <BR>onExceptionalCompletion(Throwable). This allows filtering exception <B=
R>propagation. There are cases where the propagation of the exception is <B=
R>desired, and others where a corrective action is taken instead, such as <=
BR>a retry.<BR><BR>2: As a further enhancement to 1: enable any Throwable, =
including <BR>checked exceptions. This allows the use of a CountedCompleter=
 as a <BR>CompletionHandler for asynchronous IO operations or as a wrapper =
for <BR>MethodHandles (which throw Throwable) without adding extra logic to=
 <BR>capture and convert an IO exception. I read the documentation
 which <BR>explains why this is currently limited to unchecked exceptions. =
While I <BR>can agree with this in general, I feel the argument is weak for=
 <BR>CountedCompleter if it is there to support asynchronous tasks/events. =
<BR>(May I add that using this type of framework is not for the <BR>faint-h=
earted anyway!?)<BR><BR>3: Provide a method to join a task that is not fork=
ed and/or not <BR>completable, while minimizing worker thread blocking. For=
 example, <BR>CountedCompleter allows creating chains of dependent tasks. U=
nless the <BR>ultimate task (the last in the chain) is forked/exists on the=
 task stack <BR>AND can complete because all dependencies are resolved, joi=
ning it will <BR>block the worker thread. I noticed (and my testing is limi=
ted to a few <BR>test cases and therefore not representative) the blocking =
and the <BR>creation of other worker threads, ultimately running out of mem=
ory or <BR>reaching the thread count limit. If this task is not
 forked, then <BR>join()/quietlyJoin() will block the worker thread. The fo=
llowing code is <BR>my (inexpert) attempt to provide a remedy. It is based =
on the assumption <BR>that a task that depends on others for completion is =
not forked until <BR>all dependencies are resolved. For example, a CountedC=
ompleter <BR>implementing CompletionHandler would fork itself ("implicit fo=
rk") when <BR>the IO operation is done. This works very well in my test cas=
es, but at <BR>this time I would not claim it to be universally applicable =
or error <BR>free. It is shown here more to demonstrate the attempt rather =
than as a <BR>reference implementation. With access to private data structu=
res, this <BR>can be done more elegantly and more reliably.<BR><BR>? ? ? ? =
static final int RETRIES =3D 16;<BR>? ? ? ? static final long WAIT_TIMEOUT =
=3D 1_000;? ? // Timeout in <BR>microseconds.<BR><BR>? ? ? ? public final v=
oid quietlyJoinUnforked() {<BR>? ? ? ? ? ?
 this.doJoinUnforked(false);<BR>? ? ? ? }<BR><BR>? ? ? ? public final void =
quietlyJoinUnforkedInterruptibly()<BR>? ? ? ? throws InterruptedException {=
<BR>? ? ? ? ? ? if (this.doJoinUnforked(true)) {<BR>? ? ? ? ? ? ? ? throw n=
ew InterruptedException();<BR>? ? ? ? ? ? }<BR>? ? ? ? }<BR><BR>? ? ? ? pub=
lic final boolean doJoinUnforked(final boolean interruptibly) {<BR>? ? ? ? =
? ? int retries =3D RETRIES;<BR>? ? ? ? ? ? boolean wasInterrupted =3D fals=
e;<BR>? ? ? ? ? ? while (!this.isDone()) {<BR>? ? ? ? ? ? ? ? ForkJoinTask&=
lt;?&gt; t;<BR>? ? ? ? ? ? ? ? if ((t =3D pollTask()) !=3D null) {<BR>? ? ?=
 ? ? ? ? ? ? ? t.quietlyInvoke();<BR>? ? ? ? ? ? ? ? ? ? if (t =3D=3D this)=
 {<BR>? ? ? ? ? ? ? ? ? ? ? ? break;<BR>? ? ? ? ? ? ? ? ? ? }<BR>? ? ? ? ? =
? ? ? }<BR>? ? ? ? ? ? ? ? else {<BR>? ? ? ? ? ? ? ? ? ? if (retries-- &gt;=
 0) {<BR>? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();<BR>? ? ? ? ? ? ? ? ? ? ? ?=
 continue;<BR>? ? ? ? ? ? ? ? ? ? }<BR>? ? ? ? ? ? ? ? ? ? wasInterrupted =
=3D
 Thread.interrupted();<BR>? ? ? ? ? ? ? ? ? ? try {<BR>? ? ? ? ? ? ? ? ? ? =
? ? // get(...) is used as a timed join(). It is <BR>assumed that<BR>? ? ? =
? ? ? ? ? ? ? ? ? // other code will perform get() on this task <BR>to retr=
ieve<BR>? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.<BR>? ? ?=
 ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);<BR>? ? ? =
? ? ? ? ? ? ? ? ? break;<BR>? ? ? ? ? ? ? ? ? ? }<BR>? ? ? ? ? ? ? ? ? ? ca=
tch (final InterruptedException consumed) {<BR>? ? ? ? ? ? ? ? ? ? ? ? if (=
!interruptibly) {<BR>? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted =3D true;<B=
R>? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;<BR>? ? ? ? ? ? ? ? ? ? ? ? }<BR>? ?=
 ? ? ? ? ? ? ? ? ? ? return true;<BR>? ? ? ? ? ? ? ? ? ? }<BR>? ? ? ? ? ? ?=
 ? ? ? catch (final ExecutionException ignored) {<BR>? ? ? ? ? ? ? ? ? ? ? =
? // See comment on get() above.<BR>? ? ? ? ? ? ? ? ? ? ? ? break;<BR>? ? ?=
 ? ? ? ? ? ? ? }<BR>? ? ? ? ? ? ? ? ? ? catch (final TimeoutException
 ignored) {<BR>? ? ? ? ? ? ? ? ? ? ? ? continue;<BR>? ? ? ? ? ? ? ? ? ? }<B=
R>? ? ? ? ? ? ? ? }<BR>? ? ? ? ? ? ? ? retries =3D RETRIES;<BR>? ? ? ? ? ? =
}<BR>? ? ? ? ? ? if (wasInterrupted &amp;&amp; !interruptibly) {<BR>? ? ? ?=
 ? ? ? ? Thread.currentThread().interrupt();<BR>? ? ? ? ? ? ? ? return fals=
e;<BR>? ? ? ? ? ? }<BR>? ? ? ? ? ? return wasInterrupted;<BR>? ? ? ? }<BR><=
BR>As already mentioned this works quite well in a number of cases. For <BR=
>example, adding this method to the example MergeSort code and calling <BR>=
quietlyJoinUnforked(), results in the same overall performance, reduces <BR=
>the number of extra blocked worker threads to 1 if any (instead of up to <=
BR>8 for the unmodified code; on a PC with 4 hyper-threading cores/8 <BR>th=
reads), and allows for some extra (recreational?) freedom in joining <BR>th=
e right and left sub-tasks in any order. It works in cases where no <BR>sub=
-task is forked explicitly. I observed that worker thread blocking
 <BR>only occurs towards the end of a large recursion, suggesting that work=
er <BR>threads only block - as intended - when there is no other work avail=
able <BR>(sometimes while implicit forking has not yet happened).<BR><BR>Wo=
lfgang.<BR><BR><BR><BR>On 2012-04-09 16:16, Doug Lea wrote:<BR>&gt;<BR>&gt;=
 After sitting on multiple variations for months, I committed<BR>&gt; Count=
edCompleter, a completion-based flavor of ForkJoinTask.<BR>&gt;<BR>&gt; As =
mentioned a few times over the past year, the main motivation<BR>&gt; is to=
 better support tasks that perform IO or other base<BR>&gt; actions that ma=
y (or may not) take a lot of time to execute.<BR>&gt; As is the case with J=
DK7 async IO and other completion-based<BR>&gt; frameworks, the most common=
 path to efficiency is for such tasks<BR>&gt; to arrange continuation actio=
ns that occur upon their completion.<BR>&gt; The main twist for CountedComp=
leters is that continuations<BR>&gt; might be dependent on multiple
 actions, not just one. (Or in<BR>&gt; other words, the continuations must =
be preceded by a specialized,<BR>&gt; "bottom-up" form of join.)<BR>&gt;<BR=
>&gt; The CountedCompleter abstract class provides a minimal basis<BR>&gt; =
for these kinds of tasks. While some of the mechanics are<BR>&gt; reminisce=
nt of other FJ-like frameworks such as Intel TBB,<BR>&gt; CountedCompleters=
 are designed to fit smoothly with other<BR>&gt; kinds of ForkJoinTasks (li=
ke RecursiveActions), and so still<BR>&gt; allow people to use the more ple=
asant Future-style conventions<BR>&gt; rather than count-based bottom-up jo=
ining unless they need them.<BR>&gt; At the same time, the CountedCompleter=
 class exposes enough<BR>&gt; mechanics to allow all sorts of tweaks that p=
eople can use<BR>&gt; to improve performance.<BR>&gt; In particular, in add=
ition to usually being the best way to deal<BR>&gt; with IO etc bound tasks=
, CountedCompleters sometimes fare better<BR>&gt; than
 RecursiveActions in programs that entail lots of garbage<BR>&gt; collectio=
n because GC can have similar impact on task variability.<BR>&gt;<BR>&gt; E=
ven though targeted for JDK8, versions of CountedCompleter<BR>&gt; appear i=
n the jsr166y and main repositories, not jsr166e. This is<BR>&gt; because t=
hey require a non-public hook into modified ForkJoinTask<BR>&gt; exception =
handling mechanics in order to properly propagate<BR>&gt; exceptional compl=
etions. For sources, docs, and jar files, see<BR>&gt; the usual links at <B=
R>&gt; <A href=3D"http://gee.cs.oswego.edu/dl/concurrency-interest/index.ht=
ml" target=3D_blank>http://gee.cs.oswego.edu/dl/concurrency-interest/index.=
html</A><BR>&gt;<BR>&gt; The API docs include more details and some example=
s:<BR>&gt; <A href=3D"http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/uti=
l/concurrent/CountedCompleter.html" target=3D_blank>http://gee.cs.oswego.ed=
u/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html</A>
 <BR>&gt;<BR>&gt;<BR>&gt; I also added a few (with more to come) test/demo =
programs that illustrate<BR>&gt; other usages. See CCBoxedLongSort and CCJa=
cobi in<BR>&gt; <A href=3D"http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr=
166/src/test/loops/" target=3D_blank>http://gee.cs.oswego.edu/cgi-bin/viewc=
vs.cgi/jsr166/src/test/loops/</A><BR>&gt;<BR>&gt; Please try these out. As =
always, comments and suggestions<BR>&gt; (hopefully based on usage experien=
ce) would be welcome.<BR>&gt;<BR>&gt; -Doug<BR>&gt;<BR>&gt;<BR>&gt; _______=
________________________________________<BR>&gt; Concurrency-interest maili=
ng list<BR>&gt; <A href=3D"mailto:Concurrency-interest at cs.oswego.edu" ymail=
to=3D"mailto:Concurrency-interest at cs.oswego.edu">Concurrency-interest at cs.os=
wego.edu</A><BR>&gt; <A href=3D"http://cs.oswego.edu/mailman/listinfo/concu=
rrency-interest"
 target=3D_blank>http://cs.oswego.edu/mailman/listinfo/concurrency-interest=
</A><BR>&gt;<BR><BR><BR>------------------------------<BR><BR>_____________=
__________________________________<BR>Concurrency-interest mailing list<BR>=
<A href=3D"mailto:Concurrency-interest at cs.oswego.edu" ymailto=3D"mailto:Con=
currency-interest at cs.oswego.edu">Concurrency-interest at cs.oswego.edu</A><BR>=
<A href=3D"http://cs.oswego.edu/mailman/listinfo/concurrency-interest" targ=
et=3D_blank>http://cs.oswego.edu/mailman/listinfo/concurrency-interest</A><=
BR><BR><BR>End of Concurrency-interest Digest, Vol 87, Issue 26<BR>********=
********************************************<BR>-------------- next part --=
------------<BR>An HTML attachment was scrubbed...<BR>URL: &lt;<A href=3D"h=
ttp://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/757=
46dcb/attachment.html"
 target=3D_blank>http://cs.oswego.edu/pipermail/concurrency-interest/attach=
ments/20120417/75746dcb/attachment.html</A>&gt;<BR><BR>--------------------=
----------<BR><BR>_______________________________________________<BR>Concur=
rency-interest mailing list<BR><A href=3D"mailto:Concurrency-interest at cs.os=
wego.edu" ymailto=3D"mailto:Concurrency-interest at cs.oswego.edu">Concurrency=
-interest at cs.oswego.edu</A><BR><A href=3D"http://cs.oswego.edu/mailman/list=
info/concurrency-interest" target=3D_blank>http://cs.oswego.edu/mailman/lis=
tinfo/concurrency-interest</A><BR><BR><BR>End of Concurrency-interest Diges=
t, Vol 87, Issue 27<BR>****************************************************=
<BR><BR><BR></DIV></DIV></div></body></html>
--897404883-1652871492-1334601360=:99294--

--===============0377691237==
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

--===============0377691237==--

From nathan.reynolds at oracle.com  Mon Apr 16 15:22:56 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 16 Apr 2012 12:22:56 -0700
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
 Issue 27
In-Reply-To: <1334601360.99294.YahooMailNeo@web193402.mail.sg3.yahoo.com>
References: <mailman.117.1334596831.3324.concurrency-interest@cs.oswego.edu>
	<1334601360.99294.YahooMailNeo@web193402.mail.sg3.yahoo.com>
Message-ID: <4F8C7190.6030103@oracle.com>

Synchronized blocks are used every where.  You could use ASM 
(http://asm.ow2.org/) to instrument all synchronized blocks (i.e. 
monitorenter and monitorexit bytecodes).  Simply put a call to your 
deadlock-check just before the monitorenter instruction.  You could also 
use this to inject your code into all Locks.

If you want to avoid the overhead during lock acquisition, you could 
have a background thread detect the deadlock and then make one thread 
involved in the deadlock throw an exception using 
Thread.stop(Throwable).  Thread.stop() is a misnomer in my opinion.  It 
doesn't stop the thread immediately.  Instead, it causes the thread to 
throw an exception which unwinds the stack and if not caught causes the 
thread to terminate.  It is deprecated because the exception can be 
thrown at any point during the execution of the thread and this makes it 
very hard to get it bug free.  (It might be deprecated for other reasons 
as well.)  However, if you know that the threads are indefinitely 
deadlocked, then the thread won't wake up any time and I naively don't 
see why using Thread.stop(Throwable) would be a problem.  (Note: I am 
not sure if Thread.stop() will throw an exception while the thread is 
blocked inside monitorenter).

 > Finally where do I need to present this writeup?

I have never presented anything outside of Oracle Open World.  I have 
attended Java One.  Sorry, I can't be of much help.  Since this is Java 
code, you might consider presenting at Java One.  I am not sure if that 
is appropriate venue, though.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/16/2012 11:36 AM, Rohit Kumar wrote:
> Hans,Nathan,
> I am not aware of anything like Gadara yet. My implementation assumes 
> that there are no synchnonized keywords (implicit locks) in your 
> program. It requires you to use explicit locks (e.g. Lock class in 
> java concurrent api). There is no background thread running here. The 
> deadlock-check happens at each lock acquisition request; it runs an 
> algorithms internally to see if there are any cycles formed in the 
> lock-acquisition graph. If yes, it doesn't let you acquire the lock 
> but throws an exception. You can catch this exception and take 
> necessary steps to re-acquire all the locks once again or whatever you 
> want. The program is written in java and it is hardly 270 lines of code.
> Finally where do I need to present this writeup ?
> Thanks & Regards,
> Rohit Kumar
>
> *From:* "concurrency-interest-request at cs.oswego.edu" 
> <concurrency-interest-request at cs.oswego.edu>
> *To:* concurrency-interest at cs.oswego.edu
> *Sent:* Monday, 16 April 2012 10:50 PM
> *Subject:* Concurrency-interest Digest, Vol 87, Issue 27
>
> Send Concurrency-interest mailing list submissions to
> concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>
>
> To subscribe or unsubscribe via the World Wide Web, visit
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
> concurrency-interest-request at cs.oswego.edu 
> <mailto:concurrency-interest-request at cs.oswego.edu>
>
> You can reach the person managing the list at
> concurrency-interest-owner at cs.oswego.edu 
> <mailto:concurrency-interest-owner at cs.oswego.edu>
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>   1. Re: CountedCompleters (Wolfgang Baltes)
>   2. Re: Java Deadlocks prevented (Boehm, Hans)
>   3. Re: Java Deadlocks prevented (Nathan Reynolds)
>   4. Re: Concurrency-interest Digest, Vol 87,    Issue 26 (Java
>       deadlock prevented) (Rohit Kumar)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 16 Apr 2012 18:01:50 +0200
> From: Wolfgang Baltes <wolfgang.baltes at laposte.net 
> <mailto:wolfgang.baltes at laposte.net>>
> To: concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] CountedCompleters
> Message-ID: <4F8C426E.6090704 at laposte.net 
> <mailto:4F8C426E.6090704 at laposte.net>>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> I apologize for a mistake in the last paragraph of my memo: using
> quietlyJoinUnforked() in the SDK7 sample code for MergeSort does have a
> non-negligible performance impact (not no impact as stated). There is
> better performance in case of recursions which produce many tasks that
> are not explicitly forked, and it reduces the number of extra threads
> significantly, allowing larger problems to be solved with smaller memory
> footprint.
>
> Wolfgang.
>
> On 2012-04-16 16:48, Wolfgang Baltes wrote:
> > Thanks, Doug, for a this addition to the FJ framework. I think that
> > CountedCompleter will address the needs of an entire class of
> > applications in an efficient and simple to use manner.
> >
> > I used the code and noticed that method doJoin() has become more
> > effective in avoiding blocking threads, and as a result fewer extra
> > threads are created. I found the performance, compared to
> > RecursiveAction, to be equal or insignificantly different. This
> > reduces the problem described in item 3 below.
> >
> > However, at the same time, CountedCompleter does not fully satisfy the
> > needs for a class of problems I work on. To this end, here are a few
> > enhancements I would like to suggest:
> >
> > 1: Symmetrically to onCompletion(), provide
> > onExceptionalCompletion(Throwable). This allows filtering exception
> > propagation. There are cases where the propagation of the exception is
> > desired, and others where a corrective action is taken instead, such
> > as a retry.
> >
> > 2: As a further enhancement to 1: enable any Throwable, including
> > checked exceptions. This allows the use of a CountedCompleter as a
> > CompletionHandler for asynchronous IO operations or as a wrapper for
> > MethodHandles (which throw Throwable) without adding extra logic to
> > capture and convert an IO exception. I read the documentation which
> > explains why this is currently limited to unchecked exceptions. While
> > I can agree with this in general, I feel the argument is weak for
> > CountedCompleter if it is there to support asynchronous tasks/events.
> > (May I add that using this type of framework is not for the
> > faint-hearted anyway!?)
> >
> > 3: Provide a method to join a task that is not forked and/or not
> > completable, while minimizing worker thread blocking. For example,
> > CountedCompleter allows creating chains of dependent tasks. Unless the
> > ultimate task (the last in the chain) is forked/exists on the task
> > stack AND can complete because all dependencies are resolved, joining
> > it will block the worker thread. I noticed (and my testing is limited
> > to a few test cases and therefore not representative) the blocking and
> > the creation of other worker threads, ultimately running out of memory
> > or reaching the thread count limit. If this task is not forked, then
> > join()/quietlyJoin() will block the worker thread. The following code
> > is my (inexpert) attempt to provide a remedy. It is based on the
> > assumption that a task that depends on others for completion is not
> > forked until all dependencies are resolved. For example, a
> > CountedCompleter implementing CompletionHandler would fork itself
> > ("implicit fork") when the IO operation is done. This works very well
> > in my test cases, but at this time I would not claim it to be
> > universally applicable or error free. It is shown here more to
> > demonstrate the attempt rather than as a reference implementation.
> > With access to private data structures, this can be done more
> > elegantly and more reliably.
> >
> >        static final int RETRIES = 16;
> >        static final long WAIT_TIMEOUT = 1_000;    // Timeout in
> > microseconds.
> >
> >        public final void quietlyJoinUnforked() {
> >            this.doJoinUnforked(false);
> >        }
> >
> >        public final void quietlyJoinUnforkedInterruptibly()
> >        throws InterruptedException {
> >            if (this.doJoinUnforked(true)) {
> >                throw new InterruptedException();
> >            }
> >        }
> >
> >        public final boolean doJoinUnforked(final boolean
> > interruptibly) {
> >            int retries = RETRIES;
> >            boolean wasInterrupted = false;
> >            while (!this.isDone()) {
> >                ForkJoinTask<?> t;
> >                if ((t = pollTask()) != null) {
> >                    t.quietlyInvoke();
> >                    if (t == this) {
> >                        break;
> >                    }
> >                }
> >                else {
> >                    if (retries-- > 0) {
> >                        Thread.yield();
> >                        continue;
> >                    }
> >                    wasInterrupted = Thread.interrupted();
> >                    try {
> >                        // get(...) is used as a timed join(). It is
> > assumed that
> >                        // other code will perform get() on this task
> > to retrieve
> >                        // the task's result or exception.
> >                        this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
> >                        break;
> >                    }
> >                    catch (final InterruptedException consumed) {
> >                        if (!interruptibly) {
> >                            wasInterrupted = true;
> >                            continue;
> >                        }
> >                        return true;
> >                    }
> >                    catch (final ExecutionException ignored) {
> >                        // See comment on get() above.
> >                        break;
> >                    }
> >                    catch (final TimeoutException ignored) {
> >                        continue;
> >                    }
> >                }
> >                retries = RETRIES;
> >            }
> >            if (wasInterrupted && !interruptibly) {
> >                Thread.currentThread().interrupt();
> >                return false;
> >            }
> >            return wasInterrupted;
> >        }
> >
> > As already mentioned this works quite well in a number of cases. For
> > example, adding this method to the example MergeSort code and calling
> > quietlyJoinUnforked(), results in the same overall performance,
> > reduces the number of extra blocked worker threads to 1 if any
> > (instead of up to 8 for the unmodified code; on a PC with 4
> > hyper-threading cores/8 threads), and allows for some extra
> > (recreational?) freedom in joining the right and left sub-tasks in any
> > order. It works in cases where no sub-task is forked explicitly. I
> > observed that worker thread blocking only occurs towards the end of a
> > large recursion, suggesting that worker threads only block - as
> > intended - when there is no other work available (sometimes while
> > implicit forking has not yet happened).
> >
> > Wolfgang.
> >
> >
> >
> > On 2012-04-09 16:16, Doug Lea wrote:
> >>
> >> After sitting on multiple variations for months, I committed
> >> CountedCompleter, a completion-based flavor of ForkJoinTask.
> >>
> >> As mentioned a few times over the past year, the main motivation
> >> is to better support tasks that perform IO or other base
> >> actions that may (or may not) take a lot of time to execute.
> >> As is the case with JDK7 async IO and other completion-based
> >> frameworks, the most common path to efficiency is for such tasks
> >> to arrange continuation actions that occur upon their completion.
> >> The main twist for CountedCompleters is that continuations
> >> might be dependent on multiple actions, not just one. (Or in
> >> other words, the continuations must be preceded by a specialized,
> >> "bottom-up" form of join.)
> >>
> >> The CountedCompleter abstract class provides a minimal basis
> >> for these kinds of tasks. While some of the mechanics are
> >> reminiscent of other FJ-like frameworks such as Intel TBB,
> >> CountedCompleters are designed to fit smoothly with other
> >> kinds of ForkJoinTasks (like RecursiveActions), and so still
> >> allow people to use the more pleasant Future-style conventions
> >> rather than count-based bottom-up joining unless they need them.
> >> At the same time, the CountedCompleter class exposes enough
> >> mechanics to allow all sorts of tweaks that people can use
> >> to improve performance.
> >> In particular, in addition to usually being the best way to deal
> >> with IO etc bound tasks, CountedCompleters sometimes fare better
> >> than RecursiveActions in programs that entail lots of garbage
> >> collection because GC can have similar impact on task variability.
> >>
> >> Even though targeted for JDK8, versions of CountedCompleter
> >> appear in the jsr166y and main repositories, not jsr166e. This is
> >> because they require a non-public hook into modified ForkJoinTask
> >> exception handling mechanics in order to properly propagate
> >> exceptional completions. For sources, docs, and jar files, see
> >> the usual links at
> >> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> >>
> >> The API docs include more details and some examples:
> >> 
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
> >>
> >>
> >> I also added a few (with more to come) test/demo programs that
> >> illustrate
> >> other usages. See CCBoxedLongSort and CCJacobi in
> >> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
> >>
> >> Please try these out. As always, comments and suggestions
> >> (hopefully based on usage experience) would be welcome.
> >>
> >> -Doug
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> ------------------------------
>
> Message: 2
> Date: Mon, 16 Apr 2012 16:38:00 +0000
> From: "Boehm, Hans" <hans.boehm at hp.com <mailto:hans.boehm at hp.com>>
> To: Andrew Haley <aph at redhat.com <mailto:aph at redhat.com>>,
>     "concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>"
> <concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>>
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID:
> <A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hpqcorp.net 
> <mailto:A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hpqcorp.net>>
>
> Content-Type: text/plain; charset="us-ascii"
>
> Important questions to consider when you write it up:
>
> How does it compare to something like Gadara that uses whole program 
> analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it 
> doesn't need whole program analysis.)  Other deadlock avoidance schemes?
>
> Once you detect a potential deadlock, how do you recover?  Or can you 
> always schedule so that the possibility doesn't arise?
>
> Hans
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu 
> <mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-
> > interest-bounces at cs.oswego.edu 
> <mailto:interest-bounces at cs.oswego.edu>] On Behalf Of Andrew Haley
> > Sent: Monday, April 16, 2012 4:34 AM
> > To: concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>
> > Subject: Re: [concurrency-interest] Java Deadlocks prevented
> >
> > On 04/16/2012 12:06 PM, Rohit Kumar wrote:
> >
> > > I have found a way of preventing deadlocks in java. The
> > > methodology(which is code) completely prevents the deadlock from
> > > occuring by detecting it in advance. This can be used across the
> > > systems seamlessly.
> > >
> > > Kindly let me know what I need to do next. I want this to be part of
> > > next jdk release. I am writing this email as I have no idea what I
> > > need to do next to bring it into limelight.
> >
> > Write it up, maybe present it to a conference, and wait for feedback.
> > That's how it always works.  If your idea really works, people will
> > use it.
> >
> > Andrew.
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> ------------------------------
>
> Message: 3
> Date: Mon, 16 Apr 2012 10:11:00 -0700
> From: Nathan Reynolds <nathan.reynolds at oracle.com 
> <mailto:nathan.reynolds at oracle.com>>
> To: "Boehm, Hans" <hans.boehm at hp.com <mailto:hans.boehm at hp.com>>
> Cc: "concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>"
> <concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>>
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID: <4F8C52A4.70002 at oracle.com <mailto:4F8C52A4.70002 at oracle.com>>
> Content-Type: text/plain; charset="iso-8859-1"; Format="flowed"
>
> Deadlock prevention is very valuable.  It means deadlock prone code
> won't bring down a production server and cost the company millions in
> down time.  It means consumers won't kill the process and request a 
> refund.
>
> How much does deadlock prevention cost?  Is the cost on the thread that
> acquires locks or is it in a background thread?
>
> Each time processors or systems increase the number of cores, I find we
> have to do a round of lock contention fixing.  I have only seen 1 lock
> at a time be the bottleneck in the system.  Does deadlock prevention
> increase the critical region of locks?  If so, this will definitely
> reduce the scalability of the system if it impacts the 1 bottlenecking 
> lock.
>
> Lock performance is a very important consideration.  Locks have evolved
> from fat locks (i.e trips into the OS kernel) to thin locks (i.e. spin
> and CAS in user mode) to biased/lazy locks (i.e. no CAS and an
> indefinite lock owner).  All of this was done to reduce the performance
> overhead of locks.  How does deadlock prevention impact the performance
> of biased, thin and fat locks?  I am not as concerned about fat lock
> performance since most of the time the thread is going to block.
>
> Nathan Reynolds
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
> On 4/16/2012 9:38 AM, Boehm, Hans wrote:
> > Important questions to consider when you write it up:
> >
> > How does it compare to something like Gadara that uses whole program 
> analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it 
> doesn't need whole program analysis.)  Other deadlock avoidance schemes?
> >
> > Once you detect a potential deadlock, how do you recover?  Or can 
> you always schedule so that the possibility doesn't arise?
> >
> > Hans
> >
> >> -----Original Message-----
> >> From: concurrency-interest-bounces at cs.oswego.edu 
> <mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-
> >> interest-bounces at cs.oswego.edu 
> <mailto:interest-bounces at cs.oswego.edu>] On Behalf Of Andrew Haley
> >> Sent: Monday, April 16, 2012 4:34 AM
> >> To: concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>
> >> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> >>
> >> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
> >>
> >>> I have found a way of preventing deadlocks in java. The
> >>> methodology(which is code) completely prevents the deadlock from
> >>> occuring by detecting it in advance. This can be used across the
> >>> systems seamlessly.
> >>>
> >>> Kindly let me know what I need to do next. I want this to be part of
> >>> next jdk release. I am writing this email as I have no idea what I
> >>> need to do next to bring it into limelight.
> >> Write it up, maybe present it to a conference, and wait for feedback.
> >> That's how it always works.  If your idea really works, people will
> >> use it.
> >>
> >> Andrew.
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: 
> <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/7ea89bb3/attachment-0001.html>
>
> ------------------------------
>
> Message: 4
> Date: Tue, 17 Apr 2012 01:20:15 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in <mailto:rohitk242 at yahoo.co.in>>
> To: "concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>"
> <concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>>
> Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
>     87,    Issue 26 (Java deadlock prevented)
> Message-ID:
> <1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com 
> <mailto:1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com>>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Andrew:
> ?
> Thanks for the reply. Can you kindly let me know where do I need to 
> present it ? Where will the conference be held ? Can I present it 
> online or I have to come in person ?
> ?
> Waiting for your early reply once again.
> ?
> Thanks & Regards,
> Rohit Kumar
>
> From: "concurrency-interest-request at cs.oswego.edu 
> <mailto:concurrency-interest-request at cs.oswego.edu>" 
> <concurrency-interest-request at cs.oswego.edu 
> <mailto:concurrency-interest-request at cs.oswego.edu>>
> To: concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>
> Sent: Monday, 16 April 2012 9:30 PM
> Subject: Concurrency-interest Digest, Vol 87, Issue 26
>
> Send Concurrency-interest mailing list submissions to
> ??? concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>
>
> To subscribe or unsubscribe via the World Wide Web, visit
> ??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
> ??? concurrency-interest-request at cs.oswego.edu 
> <mailto:concurrency-interest-request at cs.oswego.edu>
>
> You can reach the person managing the list at
> ??? concurrency-interest-owner at cs.oswego.edu 
> <mailto:concurrency-interest-owner at cs.oswego.edu>
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
> ? 1. (no subject) (Rohit Kumar)
> ? 2. Java Deadlocks prevented (Rohit Kumar)
> ? 3. Re: Java Deadlocks prevented (Andrew Haley)
> ? 4. Re: CountedCompleters (Wolfgang Baltes)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in <mailto:rohitk242 at yahoo.co.in>>
> To: "concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>"
> ??? <concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>>
> Cc: "concurrency-interest-owner at cs.oswego.edu 
> <mailto:concurrency-interest-owner at cs.oswego.edu>"
> ??? <concurrency-interest-owner at cs.oswego.edu 
> <mailto:concurrency-interest-owner at cs.oswego.edu>>
> Subject: [concurrency-interest] (no subject)
> Message-ID:
> ??? <1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com 
> <mailto:1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com>>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Hi All,
> ?
> I have found a way of preventing deadlocks in java. The 
> methodology(which is code) completely prevents the deadlock from 
> accuring by detecting it in advance. This can be used across the 
> systems seamlessly.
> ?
> Kindly let me know what I need to do next. I want this to be part of 
> next jdk release.
> ?
> Thanks & Regards,
> Rohit Kumar
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: 
> <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/a6588341/attachment-0001.html>
>
> ------------------------------
>
> Message: 2
> Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in <mailto:rohitk242 at yahoo.co.in>>
> To: "concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>"
> ??? <concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>>
> Cc: "concurrency-interest-owner at cs.oswego.edu 
> <mailto:concurrency-interest-owner at cs.oswego.edu>"
> ??? <concurrency-interest-owner at cs.oswego.edu 
> <mailto:concurrency-interest-owner at cs.oswego.edu>>
> Subject: [concurrency-interest] Java Deadlocks prevented
> Message-ID:
> ??? <1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com 
> <mailto:1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com>>
> Content-Type: text/plain; charset="utf-8"
>
>
>
> Hi All,
>
> I have found a way of preventing deadlocks in java. The 
> methodology(which is code) completely prevents the deadlock from 
> occuring by detecting it in advance. This can be used across the 
> systems seamlessly.
>
> Kindly let me know what I need to do next. I want this to be part of 
> next jdk release. I am writing this email as I have no idea what I 
> need to do next to bring it into limelight.
>
> Thanks & Regards,
> Rohit Kumar
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: 
> <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/064a4873/attachment-0001.html>
>
> ------------------------------
>
> Message: 3
> Date: Mon, 16 Apr 2012 12:33:45 +0100
> From: Andrew Haley <aph at redhat.com <mailto:aph at redhat.com>>
> To: concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID: <4F8C0399.8040301 at redhat.com 
> <mailto:4F8C0399.8040301 at redhat.com>>
> Content-Type: text/plain; charset=ISO-8859-1
>
> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>
> > I have found a way of preventing deadlocks in java. The
> > methodology(which is code) completely prevents the deadlock from
> > occuring by detecting it in advance. This can be used across the
> > systems seamlessly.
> >
> > Kindly let me know what I need to do next. I want this to be part of
> > next jdk release. I am writing this email as I have no idea what I
> > need to do next to bring it into limelight.
>
> Write it up, maybe present it to a conference, and wait for feedback.
> That's how it always works.? If your idea really works, people will
> use it.
>
> Andrew.
>
>
> ------------------------------
>
> Message: 4
> Date: Mon, 16 Apr 2012 16:48:31 +0200
> From: Wolfgang Baltes <wolfgang.baltes at laposte.net 
> <mailto:wolfgang.baltes at laposte.net>>
> To: "Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>"
> ??? <Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>>
> Subject: Re: [concurrency-interest] CountedCompleters
> Message-ID: <4F8C313F.2080308 at laposte.net 
> <mailto:4F8C313F.2080308 at laposte.net>>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> Thanks, Doug, for a this addition to the FJ framework. I think that
> CountedCompleter will address the needs of an entire class of
> applications in an efficient and simple to use manner.
>
> I used the code and noticed that method doJoin() has become more
> effective in avoiding blocking threads, and as a result fewer extra
> threads are created. I found the performance, compared to
> RecursiveAction, to be equal or insignificantly different. This reduces
> the problem described in item 3 below.
>
> However, at the same time, CountedCompleter does not fully satisfy the
> needs for a class of problems I work on. To this end, here are a few
> enhancements I would like to suggest:
>
> 1: Symmetrically to onCompletion(), provide
> onExceptionalCompletion(Throwable). This allows filtering exception
> propagation. There are cases where the propagation of the exception is
> desired, and others where a corrective action is taken instead, such as
> a retry.
>
> 2: As a further enhancement to 1: enable any Throwable, including
> checked exceptions. This allows the use of a CountedCompleter as a
> CompletionHandler for asynchronous IO operations or as a wrapper for
> MethodHandles (which throw Throwable) without adding extra logic to
> capture and convert an IO exception. I read the documentation which
> explains why this is currently limited to unchecked exceptions. While I
> can agree with this in general, I feel the argument is weak for
> CountedCompleter if it is there to support asynchronous tasks/events.
> (May I add that using this type of framework is not for the
> faint-hearted anyway!?)
>
> 3: Provide a method to join a task that is not forked and/or not
> completable, while minimizing worker thread blocking. For example,
> CountedCompleter allows creating chains of dependent tasks. Unless the
> ultimate task (the last in the chain) is forked/exists on the task stack
> AND can complete because all dependencies are resolved, joining it will
> block the worker thread. I noticed (and my testing is limited to a few
> test cases and therefore not representative) the blocking and the
> creation of other worker threads, ultimately running out of memory or
> reaching the thread count limit. If this task is not forked, then
> join()/quietlyJoin() will block the worker thread. The following code is
> my (inexpert) attempt to provide a remedy. It is based on the assumption
> that a task that depends on others for completion is not forked until
> all dependencies are resolved. For example, a CountedCompleter
> implementing CompletionHandler would fork itself ("implicit fork") when
> the IO operation is done. This works very well in my test cases, but at
> this time I would not claim it to be universally applicable or error
> free. It is shown here more to demonstrate the attempt rather than as a
> reference implementation. With access to private data structures, this
> can be done more elegantly and more reliably.
>
> ? ? ? ? static final int RETRIES = 16;
> ? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in
> microseconds.
>
> ? ? ? ? public final void quietlyJoinUnforked() {
> ? ? ? ? ? ? this.doJoinUnforked(false);
> ? ? ? ? }
>
> ? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
> ? ? ? ? throws InterruptedException {
> ? ? ? ? ? ? if (this.doJoinUnforked(true)) {
> ? ? ? ? ? ? ? ? throw new InterruptedException();
> ? ? ? ? ? ? }
> ? ? ? ? }
>
> ? ? ? ? public final boolean doJoinUnforked(final boolean interruptibly) {
> ? ? ? ? ? ? int retries = RETRIES;
> ? ? ? ? ? ? boolean wasInterrupted = false;
> ? ? ? ? ? ? while (!this.isDone()) {
> ? ? ? ? ? ? ? ? ForkJoinTask<?> t;
> ? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
> ? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
> ? ? ? ? ? ? ? ? ? ? if (t == this) {
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? else {
> ? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
> ? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
> ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
> ? ? ? ? ? ? ? ? ? ? try {
> ? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is
> assumed that
> ? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task
> to retrieve
> ? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
> ? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
> ? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? ? ? return true;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
> ? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
> ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? retries = RETRIES;
> ? ? ? ? ? ? }
> ? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
> ? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
> ? ? ? ? ? ? ? ? return false;
> ? ? ? ? ? ? }
> ? ? ? ? ? ? return wasInterrupted;
> ? ? ? ? }
>
> As already mentioned this works quite well in a number of cases. For
> example, adding this method to the example MergeSort code and calling
> quietlyJoinUnforked(), results in the same overall performance, reduces
> the number of extra blocked worker threads to 1 if any (instead of up to
> 8 for the unmodified code; on a PC with 4 hyper-threading cores/8
> threads), and allows for some extra (recreational?) freedom in joining
> the right and left sub-tasks in any order. It works in cases where no
> sub-task is forked explicitly. I observed that worker thread blocking
> only occurs towards the end of a large recursion, suggesting that worker
> threads only block - as intended - when there is no other work available
> (sometimes while implicit forking has not yet happened).
>
> Wolfgang.
>
>
>
> On 2012-04-09 16:16, Doug Lea wrote:
> >
> > After sitting on multiple variations for months, I committed
> > CountedCompleter, a completion-based flavor of ForkJoinTask.
> >
> > As mentioned a few times over the past year, the main motivation
> > is to better support tasks that perform IO or other base
> > actions that may (or may not) take a lot of time to execute.
> > As is the case with JDK7 async IO and other completion-based
> > frameworks, the most common path to efficiency is for such tasks
> > to arrange continuation actions that occur upon their completion.
> > The main twist for CountedCompleters is that continuations
> > might be dependent on multiple actions, not just one. (Or in
> > other words, the continuations must be preceded by a specialized,
> > "bottom-up" form of join.)
> >
> > The CountedCompleter abstract class provides a minimal basis
> > for these kinds of tasks. While some of the mechanics are
> > reminiscent of other FJ-like frameworks such as Intel TBB,
> > CountedCompleters are designed to fit smoothly with other
> > kinds of ForkJoinTasks (like RecursiveActions), and so still
> > allow people to use the more pleasant Future-style conventions
> > rather than count-based bottom-up joining unless they need them.
> > At the same time, the CountedCompleter class exposes enough
> > mechanics to allow all sorts of tweaks that people can use
> > to improve performance.
> > In particular, in addition to usually being the best way to deal
> > with IO etc bound tasks, CountedCompleters sometimes fare better
> > than RecursiveActions in programs that entail lots of garbage
> > collection because GC can have similar impact on task variability.
> >
> > Even though targeted for JDK8, versions of CountedCompleter
> > appear in the jsr166y and main repositories, not jsr166e. This is
> > because they require a non-public hook into modified ForkJoinTask
> > exception handling mechanics in order to properly propagate
> > exceptional completions. For sources, docs, and jar files, see
> > the usual links at
> > http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> >
> > The API docs include more details and some examples:
> > 
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html 
>
> >
> >
> > I also added a few (with more to come) test/demo programs that 
> illustrate
> > other usages. See CCBoxedLongSort and CCJacobi in
> > http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
> >
> > Please try these out. As always, comments and suggestions
> > (hopefully based on usage experience) would be welcome.
> >
> > -Doug
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 87, Issue 26
> ****************************************************
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: 
> <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/75746dcb/attachment.html>
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 87, Issue 27
> ****************************************************
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/c41cde8b/attachment-0001.html>

From rohitk242 at yahoo.co.in  Mon Apr 16 15:45:28 2012
From: rohitk242 at yahoo.co.in (Rohit Kumar)
Date: Tue, 17 Apr 2012 03:45:28 +0800 (SGT)
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
	Issue 27
In-Reply-To: <4F8C7190.6030103@oracle.com>
References: <mailman.117.1334596831.3324.concurrency-interest@cs.oswego.edu>
	<1334601360.99294.YahooMailNeo@web193402.mail.sg3.yahoo.com>
	<4F8C7190.6030103@oracle.com>
Message-ID: <1334605528.11594.YahooMailNeo@web193406.mail.sg3.yahoo.com>

The whole idea that I wanted to bring up is that use of synchronized keyword (implicit locks) can make your program vulnerable to deadlocks as you have no control over acquisition of locks. Once you use explicit locks as provided by java concurrent apis, deadlocks can be prevented completely. And yes, my program uses synchronized keywords, but all in one place and is completely and thoroughly?tested. Usage of synchronized keyword should be confined.
?
My program detects cycles in lock-acquisition graph. The overhead will be proportional to all the threads that are holding?locks?but not yet released and this is not great compared to restarting the server everytime the deadlock happens.
?
I will see if I can present it to any java forum. This is written in java but the concept can be applied in any programming language.
?
Thanks & Regards,
Rohit Kumar

From: Nathan Reynolds <nathan.reynolds at oracle.com>
To: Rohit Kumar <rohitk242 at yahoo.co.in> 
Cc: "concurrency-interest at cs.oswego.edu" <concurrency-interest at cs.oswego.edu> 
Sent: Tuesday, 17 April 2012 12:52 AM
Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol 87, Issue 27


Synchronized blocks are used every where.? You could use ASM (http://asm.ow2.org/) to instrument all synchronized blocks (i.e. monitorenter and monitorexit bytecodes).? Simply put a call to your deadlock-check just before the monitorenter instruction.? You could also use this to inject your code into all Locks.

If you want to avoid the overhead during lock acquisition, you could have a background thread detect the deadlock and then make one thread involved in the deadlock throw an exception using Thread.stop(Throwable).? Thread.stop() is a misnomer in my opinion.? It doesn't stop the thread immediately.? Instead, it causes the thread to throw an exception which unwinds the stack and if not caught causes the thread to terminate.? It is deprecated because the exception can be thrown at any point during the execution of the thread and this makes it very hard to get it bug free.? (It might be deprecated for other reasons as well.)? However, if you know that the threads are indefinitely deadlocked, then the thread won't wake up any time and I naively don't see why using Thread.stop(Throwable) would be a problem.? (Note: I am not sure if Thread.stop() will throw an exception while the thread is blocked inside monitorenter).

> Finally where do I need to present this writeup?

I have never presented anything outside of Oracle Open World.? I have attended Java One.? Sorry, I can't be of much help.? Since this is Java code, you might consider presenting at Java One.? I am not sure if that is appropriate venue, though.


Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering | Server Technology

On 4/16/2012 11:36 AM, Rohit Kumar wrote: 
Hans,Nathan,
>?
>I am not aware of anything like Gadara yet. My implementation assumes that there are no synchnonized keywords (implicit locks)?in your program. It requires you to use explicit locks (e.g. Lock class in java concurrent api). There is no background thread running here. The deadlock-check happens at each lock acquisition request; it runs an algorithms internally to see if there are any cycles formed in the lock-acquisition graph. If yes, it doesn't let you acquire the lock but throws an exception. You can catch this exception and take necessary steps to re-acquire all the locks once again or whatever you want. The program is written in java and it is hardly 270 lines of code.
>?
>Finally where do I need to present this writeup ?
>?
>Thanks & Regards,
>Rohit Kumar
>
>
>From: "concurrency-interest-request at cs.oswego.edu" <concurrency-interest-request at cs.oswego.edu>
>To: concurrency-interest at cs.oswego.edu 
>Sent: Monday, 16 April 2012 10:50 PM
>Subject: Concurrency-interest Digest, Vol 87, Issue 27
>
>Send Concurrency-interest mailing list submissions to
>??? concurrency-interest at cs.oswego.edu
>
>To subscribe or unsubscribe via the World Wide Web, visit
>??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>or, via email, send a message with subject or body 'help' to
>??? concurrency-interest-request at cs.oswego.edu
>
>You can reach the person managing the list at
>??? concurrency-interest-owner at cs.oswego.edu
>
>When replying, please edit your Subject line so it is more specific
>than "Re: Contents of Concurrency-interest digest..."
>
>
>Today's Topics:
>
>? 1. Re: CountedCompleters (Wolfgang Baltes)
>? 2. Re: Java Deadlocks prevented (Boehm, Hans)
>? 3. Re: Java Deadlocks prevented (Nathan Reynolds)
>? 4. Re: Concurrency-interest Digest, Vol 87,??? Issue 26 (Java
>? ? ? deadlock prevented) (Rohit Kumar)
>
>
>----------------------------------------------------------------------
>
>Message: 1
>Date: Mon, 16 Apr 2012 18:01:50 +0200
>From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
>To: concurrency-interest at cs.oswego.edu
>Subject: Re: [concurrency-interest] CountedCompleters
>Message-ID: <4F8C426E.6090704 at laposte.net>
>Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
>I apologize for a mistake in the last paragraph of my memo: using 
>quietlyJoinUnforked() in the SDK7 sample code for MergeSort does have a 
>non-negligible performance impact (not no impact as stated). There is 
>better performance in case of recursions which produce many tasks that 
>are not explicitly forked, and it reduces the number of extra threads 
>significantly, allowing larger problems to be solved with smaller memory 
>footprint.
>
>Wolfgang.
>
>On 2012-04-16 16:48, Wolfgang Baltes wrote:
>> Thanks, Doug, for a this addition to the FJ framework. I think that
>> CountedCompleter will address the needs of an entire class of
>> applications in an efficient and simple to use manner.
>>
>> I used the code and noticed that method doJoin() has become more
>> effective in avoiding blocking threads, and as a result fewer extra
>> threads are created. I found the performance, compared to
>> RecursiveAction, to be equal or insignificantly different. This
>> reduces the problem described in item 3 below.
>>
>> However, at the same time, CountedCompleter does not fully satisfy the
>> needs for a class of problems I work on. To this end, here are a few
>> enhancements I would like to suggest:
>>
>> 1: Symmetrically to onCompletion(), provide
>> onExceptionalCompletion(Throwable). This allows filtering exception
>> propagation. There are cases where the propagation of the exception is
>> desired, and others where a corrective action is taken instead, such
>> as a retry.
>>
>> 2: As a further enhancement to 1: enable any Throwable, including
>> checked exceptions. This allows the use of a CountedCompleter as a
>> CompletionHandler for asynchronous IO operations or as a wrapper for
>> MethodHandles (which throw Throwable) without adding extra logic to
>> capture and convert an IO exception. I read the documentation which
>> explains why this is currently limited to unchecked exceptions. While
>> I can agree with this in general, I feel the argument is weak for
>> CountedCompleter if it is there to support asynchronous tasks/events.
>> (May I add that using this type of framework is not for the
>> faint-hearted anyway!?)
>>
>> 3: Provide a method to join a task that is not forked and/or not
>> completable, while minimizing worker thread blocking. For example,
>> CountedCompleter allows creating chains of dependent tasks. Unless the
>> ultimate task (the last in the chain) is forked/exists on the task
>> stack AND can complete because all dependencies are resolved, joining
>> it will block the worker thread. I noticed (and my testing is limited
>> to a few test cases and therefore not representative) the blocking and
>> the creation of other worker threads, ultimately running out of memory
>> or reaching the thread count limit. If this task is not forked, then
>> join()/quietlyJoin() will block the worker thread. The following code
>> is my (inexpert) attempt to provide a remedy. It is based on the
>> assumption that a task that depends on others for completion is not
>> forked until all dependencies are resolved. For example, a
>> CountedCompleter implementing CompletionHandler would fork itself
>> ("implicit fork") when the IO operation is done. This works very well
>> in my test cases, but at this time I would not claim it to be
>> universally applicable or error free. It is shown here more to
>> demonstrate the attempt rather than as a reference implementation.
>> With access to private data structures, this can be done more
>> elegantly and more reliably.
>>
>>? ? ? ? static final int RETRIES = 16;
>>? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in
>> microseconds.
>>
>>? ? ? ? public final void quietlyJoinUnforked() {
>>? ? ? ? ? ? this.doJoinUnforked(false);
>>? ? ? ? }
>>
>>? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
>>? ? ? ? throws InterruptedException {
>>? ? ? ? ? ? if (this.doJoinUnforked(true)) {
>>? ? ? ? ? ? ? ? throw new InterruptedException();
>>? ? ? ? ? ? }
>>? ? ? ? }
>>
>>? ? ? ? public final boolean doJoinUnforked(final boolean
>> interruptibly) {
>>? ? ? ? ? ? int retries = RETRIES;
>>? ? ? ? ? ? boolean wasInterrupted = false;
>>? ? ? ? ? ? while (!this.isDone()) {
>>? ? ? ? ? ? ? ? ForkJoinTask<?> t;
>>? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
>>? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
>>? ? ? ? ? ? ? ? ? ? if (t == this) {
>>? ? ? ? ? ? ? ? ? ? ? ? break;
>>? ? ? ? ? ? ? ? ? ? }
>>? ? ? ? ? ? ? ? }
>>? ? ? ? ? ? ? ? else {
>>? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
>>? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
>>? ? ? ? ? ? ? ? ? ? ? ? continue;
>>? ? ? ? ? ? ? ? ? ? }
>>? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
>>? ? ? ? ? ? ? ? ? ? try {
>>? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is
>> assumed that
>>? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task
>> to retrieve
>>? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
>>? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
>>? ? ? ? ? ? ? ? ? ? ? ? break;
>>? ? ? ? ? ? ? ? ? ? }
>>? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
>>? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
>>? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
>>? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
>>? ? ? ? ? ? ? ? ? ? ? ? }
>>? ? ? ? ? ? ? ? ? ? ? ? return true;
>>? ? ? ? ? ? ? ? ? ? }
>>? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
>>? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
>>? ? ? ? ? ? ? ? ? ? ? ? break;
>>? ? ? ? ? ? ? ? ? ? }
>>? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
>>? ? ? ? ? ? ? ? ? ? ? ? continue;
>>? ? ? ? ? ? ? ? ? ? }
>>? ? ? ? ? ? ? ? }
>>? ? ? ? ? ? ? ? retries = RETRIES;
>>? ? ? ? ? ? }
>>? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
>>? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
>>? ? ? ? ? ? ? ? return false;
>>? ? ? ? ? ? }
>>? ? ? ? ? ? return wasInterrupted;
>>? ? ? ? }
>>
>> As already mentioned this works quite well in a number of cases. For
>> example, adding this method to the example MergeSort code and calling
>> quietlyJoinUnforked(), results in the same overall performance,
>> reduces the number of extra blocked worker threads to 1 if any
>> (instead of up to 8 for the unmodified code; on a PC with 4
>> hyper-threading cores/8 threads), and allows for some extra
>> (recreational?) freedom in joining the right and left sub-tasks in any
>> order. It works in cases where no sub-task is forked explicitly. I
>> observed that worker thread blocking only occurs towards the end of a
>> large recursion, suggesting that worker threads only block - as
>> intended - when there is no other work available (sometimes while
>> implicit forking has not yet happened).
>>
>> Wolfgang.
>>
>>
>>
>> On 2012-04-09 16:16, Doug Lea wrote:
>>>
>>> After sitting on multiple variations for months, I committed
>>> CountedCompleter, a completion-based flavor of ForkJoinTask.
>>>
>>> As mentioned a few times over the past year, the main motivation
>>> is to better support tasks that perform IO or other base
>>> actions that may (or may not) take a lot of time to execute.
>>> As is the case with JDK7 async IO and other completion-based
>>> frameworks, the most common path to efficiency is for such tasks
>>> to arrange continuation actions that occur upon their completion.
>>> The main twist for CountedCompleters is that continuations
>>> might be dependent on multiple actions, not just one. (Or in
>>> other words, the continuations must be preceded by a specialized,
>>> "bottom-up" form of join.)
>>>
>>> The CountedCompleter abstract class provides a minimal basis
>>> for these kinds of tasks. While some of the mechanics are
>>> reminiscent of other FJ-like frameworks such as Intel TBB,
>>> CountedCompleters are designed to fit smoothly with other
>>> kinds of ForkJoinTasks (like RecursiveActions), and so still
>>> allow people to use the more pleasant Future-style conventions
>>> rather than count-based bottom-up joining unless they need them.
>>> At the same time, the CountedCompleter class exposes enough
>>> mechanics to allow all sorts of tweaks that people can use
>>> to improve performance.
>>> In particular, in addition to usually being the best way to deal
>>> with IO etc bound tasks, CountedCompleters sometimes fare better
>>> than RecursiveActions in programs that entail lots of garbage
>>> collection because GC can have similar impact on task variability.
>>>
>>> Even though targeted for JDK8, versions of CountedCompleter
>>> appear in the jsr166y and main repositories, not jsr166e. This is
>>> because they require a non-public hook into modified ForkJoinTask
>>> exception handling mechanics in order to properly propagate
>>> exceptional completions. For sources, docs, and jar files, see
>>> the usual links at
>>> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>>>
>>> The API docs include more details and some examples:
>>> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
>>>
>>>
>>> I also added a few (with more to come) test/demo programs that
>>> illustrate
>>> other usages. See CCBoxedLongSort and CCJacobi in
>>> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
>>>
>>> Please try these out. As always, comments and suggestions
>>> (hopefully based on usage experience) would be welcome.
>>>
>>> -Doug
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>------------------------------
>
>Message: 2
>Date: Mon, 16 Apr 2012 16:38:00 +0000
>From: "Boehm, Hans" <hans.boehm at hp.com>
>To: Andrew Haley <aph at redhat.com>,
>??? "concurrency-interest at cs.oswego.edu"
>??? <concurrency-interest at cs.oswego.edu>
>Subject: Re: [concurrency-interest] Java Deadlocks prevented
>Message-ID:
>??? <A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hpqcorp.net>
>??? 
>Content-Type: text/plain; charset="us-ascii"
>
>Important questions to consider when you write it up:
>
>How does it compare to something like Gadara that uses whole program analysis and scheduling to avoid lock-based deadlocks?? (Hopefully it doesn't need whole program analysis.)? Other deadlock avoidance schemes?
>
>Once you detect a potential deadlock, how do you recover?? Or can you always schedule so that the possibility doesn't arise?
>
>Hans
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
>> Sent: Monday, April 16, 2012 4:34 AM
>> To: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Java Deadlocks prevented
>> 
>> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>> 
>> > I have found a way of preventing deadlocks in java. The
>> > methodology(which is code) completely prevents the deadlock from
>> > occuring by detecting it in advance. This can be used across the
>> > systems seamlessly.
>> >
>> > Kindly let me know what I need to do next. I want this to be part of
>> > next jdk release. I am writing this email as I have no idea what I
>> > need to do next to bring it into limelight.
>> 
>> Write it up, maybe present it to a conference, and wait for feedback.
>> That's how it always works.? If your idea really works, people will
>> use it.
>> 
>> Andrew.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>------------------------------
>
>Message: 3
>Date: Mon, 16 Apr 2012 10:11:00 -0700
>From: Nathan Reynolds <nathan.reynolds at oracle.com>
>To: "Boehm, Hans" <hans.boehm at hp.com>
>Cc: "concurrency-interest at cs.oswego.edu"
>??? <concurrency-interest at cs.oswego.edu>
>Subject: Re: [concurrency-interest] Java Deadlocks prevented
>Message-ID: <4F8C52A4.70002 at oracle.com>
>Content-Type: text/plain; charset="iso-8859-1"; Format="flowed"
>
>Deadlock prevention is very valuable.? It means deadlock prone code 
>won't bring down a production server and cost the company millions in 
>down time.? It means consumers won't kill the process and request a refund.
>
>How much does deadlock prevention cost?? Is the cost on the thread that 
>acquires locks or is it in a background thread?
>
>Each time processors or systems increase the number of cores, I find we 
>have to do a round of lock contention fixing.? I have only seen 1 lock 
>at a time be the bottleneck in the system.? Does deadlock prevention 
>increase the critical region of locks?? If so, this will definitely 
>reduce the scalability of the system if it impacts the 1 bottlenecking lock.
>
>Lock performance is a very important consideration.? Locks have evolved 
>from fat locks (i.e trips into the OS kernel) to thin locks (i.e. spin 
>and CAS in user mode) to biased/lazy locks (i.e. no CAS and an 
>indefinite lock owner).? All of this was done to reduce the performance 
>overhead of locks.? How does deadlock prevention impact the performance 
>of biased, thin and fat locks?? I am not as concerned about fat lock 
>performance since most of the time the thread is going to block.
>
>Nathan Reynolds 
><http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
>Consulting Member of Technical Staff | 602.333.9091
>Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
>On 4/16/2012 9:38 AM, Boehm, Hans wrote:
>> Important questions to consider when you write it up:
>>
>> How does it compare to something like Gadara that uses whole program analysis and scheduling to avoid lock-based deadlocks?? (Hopefully it doesn't need whole program analysis.)? Other deadlock avoidance schemes?
>>
>> Once you detect a potential deadlock, how do you recover?? Or can you always schedule so that the possibility doesn't arise?
>>
>> Hans
>>
>>> -----Original Message-----
>>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>>> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
>>> Sent: Monday, April 16, 2012 4:34 AM
>>> To: concurrency-interest at cs.oswego.edu
>>> Subject: Re: [concurrency-interest] Java Deadlocks prevented
>>>
>>> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>>>
>>>> I have found a way of preventing deadlocks in java. The
>>>> methodology(which is code) completely prevents the deadlock from
>>>> occuring by detecting it in advance. This can be used across the
>>>> systems seamlessly.
>>>>
>>>> Kindly let me know what I need to do next. I want this to be part of
>>>> next jdk release. I am writing this email as I have no idea what I
>>>> need to do next to bring it into limelight.
>>> Write it up, maybe present it to a conference, and wait for feedback.
>>> That's how it always works.? If your idea really works, people will
>>> use it.
>>>
>>> Andrew.
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>-------------- next part --------------
>An HTML attachment was scrubbed...
>URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/7ea89bb3/attachment-0001.html>
>
>------------------------------
>
>Message: 4
>Date: Tue, 17 Apr 2012 01:20:15 +0800 (SGT)
>From: Rohit Kumar <rohitk242 at yahoo.co.in>
>To: "concurrency-interest at cs.oswego.edu"
>??? <concurrency-interest at cs.oswego.edu>
>Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
>??? 87,??? Issue 26 (Java deadlock prevented)
>Message-ID:
>??? <1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com>
>Content-Type: text/plain; charset="iso-8859-1"
>
>Andrew:
>?
>Thanks for the reply. Can you kindly let me know where do I need to present it ? Where will the conference be held ? Can I present it online or I have to come in person ?
>?
>Waiting for your early reply once again.
>?
>Thanks & Regards,
>Rohit Kumar
>
>From: "concurrency-interest-request at cs.oswego.edu" <concurrency-interest-request at cs.oswego.edu>
>To: concurrency-interest at cs.oswego.edu 
>Sent: Monday, 16 April 2012 9:30 PM
>Subject: Concurrency-interest Digest, Vol 87, Issue 26
>
>Send Concurrency-interest mailing list submissions to
>??? concurrency-interest at cs.oswego.edu
>
>To subscribe or unsubscribe via the World Wide Web, visit
>??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>or, via email, send a message with subject or body 'help' to
>??? concurrency-interest-request at cs.oswego.edu
>
>You can reach the person managing the list at
>??? concurrency-interest-owner at cs.oswego.edu
>
>When replying, please edit your Subject line so it is more specific
>than "Re: Contents of Concurrency-interest digest..."
>
>
>Today's Topics:
>
>? 1. (no subject) (Rohit Kumar)
>? 2. Java Deadlocks prevented (Rohit Kumar)
>? 3. Re: Java Deadlocks prevented (Andrew Haley)
>? 4. Re: CountedCompleters (Wolfgang Baltes)
>
>
>----------------------------------------------------------------------
>
>Message: 1
>Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT)
>From: Rohit Kumar <rohitk242 at yahoo.co.in>
>To: "concurrency-interest at cs.oswego.edu"
>??? <concurrency-interest at cs.oswego.edu>
>Cc: "concurrency-interest-owner at cs.oswego.edu"
>??? <concurrency-interest-owner at cs.oswego.edu>
>Subject: [concurrency-interest] (no subject)
>Message-ID:
>??? <1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com>
>Content-Type: text/plain; charset="iso-8859-1"
>
>Hi All,
>?
>I have found a way of preventing deadlocks in java. The methodology(which is code) completely prevents the deadlock from accuring by detecting it in advance. This can be used across the systems seamlessly. 
>?
>Kindly let me know what I need to do next. I want this to be part of next jdk release.
>?
>Thanks & Regards,
>Rohit Kumar
>-------------- next part --------------
>An HTML attachment was scrubbed...
>URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/a6588341/attachment-0001.html>
>
>------------------------------
>
>Message: 2
>Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)
>From: Rohit Kumar <rohitk242 at yahoo.co.in>
>To: "concurrency-interest at cs.oswego.edu"
>??? <concurrency-interest at cs.oswego.edu>
>Cc: "concurrency-interest-owner at cs.oswego.edu"
>??? <concurrency-interest-owner at cs.oswego.edu>
>Subject: [concurrency-interest] Java Deadlocks prevented
>Message-ID:
>??? <1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com>
>Content-Type: text/plain; charset="utf-8"
>
>
>
>Hi All,
>
>I have found a way of preventing deadlocks in java. The methodology(which is code) completely prevents the deadlock from occuring by detecting it in advance. This can be used across the systems seamlessly. 
>
>Kindly let me know what I need to do next. I want this to be part of next jdk release. I am writing this email as I have no idea what I need to do next to bring it into limelight.
>
>Thanks & Regards,
>Rohit Kumar
>-------------- next part --------------
>An HTML attachment was scrubbed...
>URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/064a4873/attachment-0001.html>
>
>------------------------------
>
>Message: 3
>Date: Mon, 16 Apr 2012 12:33:45 +0100
>From: Andrew Haley <aph at redhat.com>
>To: concurrency-interest at cs.oswego.edu
>Subject: Re: [concurrency-interest] Java Deadlocks prevented
>Message-ID: <4F8C0399.8040301 at redhat.com>
>Content-Type: text/plain; charset=ISO-8859-1
>
>On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>
>> I have found a way of preventing deadlocks in java. The
>> methodology(which is code) completely prevents the deadlock from
>> occuring by detecting it in advance. This can be used across the
>> systems seamlessly.
>> 
>> Kindly let me know what I need to do next. I want this to be part of
>> next jdk release. I am writing this email as I have no idea what I
>> need to do next to bring it into limelight.
>
>Write it up, maybe present it to a conference, and wait for feedback.
>That's how it always works.? If your idea really works, people will
>use it.
>
>Andrew.
>
>
>------------------------------
>
>Message: 4
>Date: Mon, 16 Apr 2012 16:48:31 +0200
>From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
>To: "Concurrency-interest at cs.oswego.edu"
>??? <Concurrency-interest at cs.oswego.edu>
>Subject: Re: [concurrency-interest] CountedCompleters
>Message-ID: <4F8C313F.2080308 at laposte.net>
>Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
>Thanks, Doug, for a this addition to the FJ framework. I think that 
>CountedCompleter will address the needs of an entire class of 
>applications in an efficient and simple to use manner.
>
>I used the code and noticed that method doJoin() has become more 
>effective in avoiding blocking threads, and as a result fewer extra 
>threads are created. I found the performance, compared to 
>RecursiveAction, to be equal or insignificantly different. This reduces 
>the problem described in item 3 below.
>
>However, at the same time, CountedCompleter does not fully satisfy the 
>needs for a class of problems I work on. To this end, here are a few 
>enhancements I would like to suggest:
>
>1: Symmetrically to onCompletion(), provide 
>onExceptionalCompletion(Throwable). This allows filtering exception 
>propagation. There are cases where the propagation of the exception is 
>desired, and others where a corrective action is taken instead, such as 
>a retry.
>
>2: As a further enhancement to 1: enable any Throwable, including 
>checked exceptions. This allows the use of a CountedCompleter as a 
>CompletionHandler for asynchronous IO operations or as a wrapper for 
>MethodHandles (which throw Throwable) without adding extra logic to 
>capture and convert an IO exception. I read the documentation which 
>explains why this is currently limited to unchecked exceptions. While I 
>can agree with this in general, I feel the argument is weak for 
>CountedCompleter if it is there to support asynchronous tasks/events. 
>(May I add that using this type of framework is not for the 
>faint-hearted anyway!?)
>
>3: Provide a method to join a task that is not forked and/or not 
>completable, while minimizing worker thread blocking. For example, 
>CountedCompleter allows creating chains of dependent tasks. Unless the 
>ultimate task (the last in the chain) is forked/exists on the task stack 
>AND can complete because all dependencies are resolved, joining it will 
>block the worker thread. I noticed (and my testing is limited to a few 
>test cases and therefore not representative) the blocking and the 
>creation of other worker threads, ultimately running out of memory or 
>reaching the thread count limit. If this task is not forked, then 
>join()/quietlyJoin() will block the worker thread. The following code is 
>my (inexpert) attempt to provide a remedy. It is based on the assumption 
>that a task that depends on others for completion is not forked until 
>all dependencies are resolved. For example, a CountedCompleter 
>implementing CompletionHandler would fork itself ("implicit fork") when 
>the IO operation is done. This works very well in my test cases, but at 
>this time I would not claim it to be universally applicable or error 
>free. It is shown here more to demonstrate the attempt rather than as a 
>reference implementation. With access to private data structures, this 
>can be done more elegantly and more reliably.
>
>? ? ? ? static final int RETRIES = 16;
>? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in 
>microseconds.
>
>? ? ? ? public final void quietlyJoinUnforked() {
>? ? ? ? ? ? this.doJoinUnforked(false);
>? ? ? ? }
>
>? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
>? ? ? ? throws InterruptedException {
>? ? ? ? ? ? if (this.doJoinUnforked(true)) {
>? ? ? ? ? ? ? ? throw new InterruptedException();
>? ? ? ? ? ? }
>? ? ? ? }
>
>? ? ? ? public final boolean doJoinUnforked(final boolean interruptibly) {
>? ? ? ? ? ? int retries = RETRIES;
>? ? ? ? ? ? boolean wasInterrupted = false;
>? ? ? ? ? ? while (!this.isDone()) {
>? ? ? ? ? ? ? ? ForkJoinTask<?> t;
>? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
>? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
>? ? ? ? ? ? ? ? ? ? if (t == this) {
>? ? ? ? ? ? ? ? ? ? ? ? break;
>? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? else {
>? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
>? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
>? ? ? ? ? ? ? ? ? ? ? ? continue;
>? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
>? ? ? ? ? ? ? ? ? ? try {
>? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is 
>assumed that
>? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task 
>to retrieve
>? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
>? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
>? ? ? ? ? ? ? ? ? ? ? ? break;
>? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
>? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
>? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
>? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
>? ? ? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? ? ? ? ? return true;
>? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
>? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
>? ? ? ? ? ? ? ? ? ? ? ? break;
>? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
>? ? ? ? ? ? ? ? ? ? ? ? continue;
>? ? ? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? }
>? ? ? ? ? ? ? ? retries = RETRIES;
>? ? ? ? ? ? }
>? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
>? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
>? ? ? ? ? ? ? ? return false;
>? ? ? ? ? ? }
>? ? ? ? ? ? return wasInterrupted;
>? ? ? ? }
>
>As already mentioned this works quite well in a number of cases. For 
>example, adding this method to the example MergeSort code and calling 
>quietlyJoinUnforked(), results in the same overall performance, reduces 
>the number of extra blocked worker threads to 1 if any (instead of up to 
>8 for the unmodified code; on a PC with 4 hyper-threading cores/8 
>threads), and allows for some extra (recreational?) freedom in joining 
>the right and left sub-tasks in any order. It works in cases where no 
>sub-task is forked explicitly. I observed that worker thread blocking 
>only occurs towards the end of a large recursion, suggesting that worker 
>threads only block - as intended - when there is no other work available 
>(sometimes while implicit forking has not yet happened).
>
>Wolfgang.
>
>
>
>On 2012-04-09 16:16, Doug Lea wrote:
>>
>> After sitting on multiple variations for months, I committed
>> CountedCompleter, a completion-based flavor of ForkJoinTask.
>>
>> As mentioned a few times over the past year, the main motivation
>> is to better support tasks that perform IO or other base
>> actions that may (or may not) take a lot of time to execute.
>> As is the case with JDK7 async IO and other completion-based
>> frameworks, the most common path to efficiency is for such tasks
>> to arrange continuation actions that occur upon their completion.
>> The main twist for CountedCompleters is that continuations
>> might be dependent on multiple actions, not just one. (Or in
>> other words, the continuations must be preceded by a specialized,
>> "bottom-up" form of join.)
>>
>> The CountedCompleter abstract class provides a minimal basis
>> for these kinds of tasks. While some of the mechanics are
>> reminiscent of other FJ-like frameworks such as Intel TBB,
>> CountedCompleters are designed to fit smoothly with other
>> kinds of ForkJoinTasks (like RecursiveActions), and so still
>> allow people to use the more pleasant Future-style conventions
>> rather than count-based bottom-up joining unless they need them.
>> At the same time, the CountedCompleter class exposes enough
>> mechanics to allow all sorts of tweaks that people can use
>> to improve performance.
>> In particular, in addition to usually being the best way to deal
>> with IO etc bound tasks, CountedCompleters sometimes fare better
>> than RecursiveActions in programs that entail lots of garbage
>> collection because GC can have similar impact on task variability.
>>
>> Even though targeted for JDK8, versions of CountedCompleter
>> appear in the jsr166y and main repositories, not jsr166e. This is
>> because they require a non-public hook into modified ForkJoinTask
>> exception handling mechanics in order to properly propagate
>> exceptional completions. For sources, docs, and jar files, see
>> the usual links at 
>> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>>
>> The API docs include more details and some examples:
>> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html 
>>
>>
>> I also added a few (with more to come) test/demo programs that illustrate
>> other usages. See CCBoxedLongSort and CCJacobi in
>> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
>>
>> Please try these out. As always, comments and suggestions
>> (hopefully based on usage experience) would be welcome.
>>
>> -Doug
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>------------------------------
>
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest at cs.oswego.edu
>http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>End of Concurrency-interest Digest, Vol 87, Issue 26
>****************************************************
>-------------- next part --------------
>An HTML attachment was scrubbed...
>URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/75746dcb/attachment.html>
>
>------------------------------
>
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest at cs.oswego.edu
>http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>End of Concurrency-interest Digest, Vol 87, Issue 27
>****************************************************
>
>
>
> 
>
>_______________________________________________
Concurrency-interest mailing list Concurrency-interest at cs.oswego.edu http://cs.oswego.edu/mailman/listinfo/concurrency-interest 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/742f03b3/attachment-0001.html>

From khilan at doc.ic.ac.uk  Mon Apr 16 15:53:19 2012
From: khilan at doc.ic.ac.uk (Khilan Gudka)
Date: Mon, 16 Apr 2012 20:53:19 +0100
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
	Issue 27
In-Reply-To: <1334605528.11594.YahooMailNeo@web193406.mail.sg3.yahoo.com>
References: <mailman.117.1334596831.3324.concurrency-interest@cs.oswego.edu>
	<1334601360.99294.YahooMailNeo@web193402.mail.sg3.yahoo.com>
	<4F8C7190.6030103@oracle.com>
	<1334605528.11594.YahooMailNeo@web193406.mail.sg3.yahoo.com>
Message-ID: <CAEtTSAaM_O8LGvMFczjZuhxoM0_H3xHAZYvYpEWCBTdCCLSO3w@mail.gmail.com>

While it is true that using explicit locks gives you more flexibility, i
think a distinction needs to be made here between preventing deadlock from
occurring but it being too late to rectify things (your approach if am not
mistaken) versus not ever reaching a situation where deadlock could even be
detected (gadara).

The former is obviously useful because at least it means your system cannot
hang, but then the next question is how does the system continue when you
have detected deadlock? In particular, if you have to release multiple
locks, how do you rollback side effects that have been made in the
mean-time?

--
Khilan Gudka
PhD Student
Department of Computing
Imperial College London
http://www.doc.ic.ac.uk/~khilan/



On 16 April 2012 20:45, Rohit Kumar <rohitk242 at yahoo.co.in> wrote:

> The whole idea that I wanted to bring up is that use of synchronized
> keyword (implicit locks) can make your program vulnerable to deadlocks as
> you have no control over acquisition of locks. Once you use explicit locks
> as provided by java concurrent apis, deadlocks can be prevented completely.
> And yes, my program uses synchronized keywords, but all in one place and is
> completely and thoroughly tested. Usage of synchronized keyword should be
> confined.
>
> My program detects cycles in lock-acquisition graph. The overhead will be
> proportional to all the threads that are holding locks but not yet released and
> this is not great compared to restarting the server everytime the deadlock
> happens.
>
> I will see if I can present it to any java forum. This is written in java
> but the concept can be applied in any programming language.
>
> Thanks & Regards,
> Rohit Kumar
>
>   *From:* Nathan Reynolds <nathan.reynolds at oracle.com>
> *To:* Rohit Kumar <rohitk242 at yahoo.co.in>
> *Cc:* "concurrency-interest at cs.oswego.edu" <
> concurrency-interest at cs.oswego.edu>
> *Sent:* Tuesday, 17 April 2012 12:52 AM
> *Subject:* Re: [concurrency-interest] Concurrency-interest Digest, Vol
> 87, Issue 27
>
>  Synchronized blocks are used every where.  You could use ASM (
> http://asm.ow2.org/) to instrument all synchronized blocks (i.e.
> monitorenter and monitorexit bytecodes).  Simply put a call to your
> deadlock-check just before the monitorenter instruction.  You could also
> use this to inject your code into all Locks.
>
> If you want to avoid the overhead during lock acquisition, you could have
> a background thread detect the deadlock and then make one thread involved
> in the deadlock throw an exception using Thread.stop(Throwable).
> Thread.stop() is a misnomer in my opinion.  It doesn't stop the thread
> immediately.  Instead, it causes the thread to throw an exception which
> unwinds the stack and if not caught causes the thread to terminate.  It is
> deprecated because the exception can be thrown at any point during the
> execution of the thread and this makes it very hard to get it bug free.
> (It might be deprecated for other reasons as well.)  However, if you know
> that the threads are indefinitely deadlocked, then the thread won't wake up
> any time and I naively don't see why using Thread.stop(Throwable) would be
> a problem.  (Note: I am not sure if Thread.stop() will throw an exception
> while the thread is blocked inside monitorenter).
>
> > Finally where do I need to present this writeup?
>
> I have never presented anything outside of Oracle Open World.  I have
> attended Java One.  Sorry, I can't be of much help.  Since this is Java
> code, you might consider presenting at Java One.  I am not sure if that is
> appropriate venue, though.
>
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
> On 4/16/2012 11:36 AM, Rohit Kumar wrote:
>
>  Hans,Nathan,
>
> I am not aware of anything like Gadara yet. My implementation assumes that
> there are no synchnonized keywords (implicit locks) in your program. It
> requires you to use explicit locks (e.g. Lock class in java concurrent
> api). There is no background thread running here. The deadlock-check
> happens at each lock acquisition request; it runs an algorithms internally
> to see if there are any cycles formed in the lock-acquisition graph. If
> yes, it doesn't let you acquire the lock but throws an exception. You can
> catch this exception and take necessary steps to re-acquire all the locks
> once again or whatever you want. The program is written in java and it is
> hardly 270 lines of code.
>
> Finally where do I need to present this writeup ?
>
> Thanks & Regards,
> Rohit Kumar
>
>  *From:* "concurrency-interest-request at cs.oswego.edu"<concurrency-interest-request at cs.oswego.edu>
> <concurrency-interest-request at cs.oswego.edu><concurrency-interest-request at cs.oswego.edu>
> *To:* concurrency-interest at cs.oswego.edu
> *Sent:* Monday, 16 April 2012 10:50 PM
> *Subject:* Concurrency-interest Digest, Vol 87, Issue 27
>
> Send Concurrency-interest mailing list submissions to
>     concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
>     concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
>     concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>   1. Re: CountedCompleters (Wolfgang Baltes)
>   2. Re: Java Deadlocks prevented (Boehm, Hans)
>   3. Re: Java Deadlocks prevented (Nathan Reynolds)
>   4. Re: Concurrency-interest Digest, Vol 87,    Issue 26 (Java
>       deadlock prevented) (Rohit Kumar)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 16 Apr 2012 18:01:50 +0200
> From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] CountedCompleters
> Message-ID: <4F8C426E.6090704 at laposte.net>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> I apologize for a mistake in the last paragraph of my memo: using
> quietlyJoinUnforked() in the SDK7 sample code for MergeSort does have a
> non-negligible performance impact (not no impact as stated). There is
> better performance in case of recursions which produce many tasks that
> are not explicitly forked, and it reduces the number of extra threads
> significantly, allowing larger problems to be solved with smaller memory
> footprint.
>
> Wolfgang.
>
> On 2012-04-16 16:48, Wolfgang Baltes wrote:
> > Thanks, Doug, for a this addition to the FJ framework. I think that
> > CountedCompleter will address the needs of an entire class of
> > applications in an efficient and simple to use manner.
> >
> > I used the code and noticed that method doJoin() has become more
> > effective in avoiding blocking threads, and as a result fewer extra
> > threads are created. I found the performance, compared to
> > RecursiveAction, to be equal or insignificantly different. This
> > reduces the problem described in item 3 below.
> >
> > However, at the same time, CountedCompleter does not fully satisfy the
> > needs for a class of problems I work on. To this end, here are a few
> > enhancements I would like to suggest:
> >
> > 1: Symmetrically to onCompletion(), provide
> > onExceptionalCompletion(Throwable). This allows filtering exception
> > propagation. There are cases where the propagation of the exception is
> > desired, and others where a corrective action is taken instead, such
> > as a retry.
> >
> > 2: As a further enhancement to 1: enable any Throwable, including
> > checked exceptions. This allows the use of a CountedCompleter as a
> > CompletionHandler for asynchronous IO operations or as a wrapper for
> > MethodHandles (which throw Throwable) without adding extra logic to
> > capture and convert an IO exception. I read the documentation which
> > explains why this is currently limited to unchecked exceptions. While
> > I can agree with this in general, I feel the argument is weak for
> > CountedCompleter if it is there to support asynchronous tasks/events.
> > (May I add that using this type of framework is not for the
> > faint-hearted anyway!?)
> >
> > 3: Provide a method to join a task that is not forked and/or not
> > completable, while minimizing worker thread blocking. For example,
> > CountedCompleter allows creating chains of dependent tasks. Unless the
> > ultimate task (the last in the chain) is forked/exists on the task
> > stack AND can complete because all dependencies are resolved, joining
> > it will block the worker thread. I noticed (and my testing is limited
> > to a few test cases and therefore not representative) the blocking and
> > the creation of other worker threads, ultimately running out of memory
> > or reaching the thread count limit. If this task is not forked, then
> > join()/quietlyJoin() will block the worker thread. The following code
> > is my (inexpert) attempt to provide a remedy. It is based on the
> > assumption that a task that depends on others for completion is not
> > forked until all dependencies are resolved. For example, a
> > CountedCompleter implementing CompletionHandler would fork itself
> > ("implicit fork") when the IO operation is done. This works very well
> > in my test cases, but at this time I would not claim it to be
> > universally applicable or error free. It is shown here more to
> > demonstrate the attempt rather than as a reference implementation.
> > With access to private data structures, this can be done more
> > elegantly and more reliably.
> >
> >        static final int RETRIES = 16;
> >        static final long WAIT_TIMEOUT = 1_000;    // Timeout in
> > microseconds.
> >
> >        public final void quietlyJoinUnforked() {
> >            this.doJoinUnforked(false);
> >        }
> >
> >        public final void quietlyJoinUnforkedInterruptibly()
> >        throws InterruptedException {
> >            if (this.doJoinUnforked(true)) {
> >                throw new InterruptedException();
> >            }
> >        }
> >
> >        public final boolean doJoinUnforked(final boolean
> > interruptibly) {
> >            int retries = RETRIES;
> >            boolean wasInterrupted = false;
> >            while (!this.isDone()) {
> >                ForkJoinTask<?> t;
> >                if ((t = pollTask()) != null) {
> >                    t.quietlyInvoke();
> >                    if (t == this) {
> >                        break;
> >                    }
> >                }
> >                else {
> >                    if (retries-- > 0) {
> >                        Thread.yield();
> >                        continue;
> >                    }
> >                    wasInterrupted = Thread.interrupted();
> >                    try {
> >                        // get(...) is used as a timed join(). It is
> > assumed that
> >                        // other code will perform get() on this task
> > to retrieve
> >                        // the task's result or exception.
> >                        this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
> >                        break;
> >                    }
> >                    catch (final InterruptedException consumed) {
> >                        if (!interruptibly) {
> >                            wasInterrupted = true;
> >                            continue;
> >                        }
> >                        return true;
> >                    }
> >                    catch (final ExecutionException ignored) {
> >                        // See comment on get() above.
> >                        break;
> >                    }
> >                    catch (final TimeoutException ignored) {
> >                        continue;
> >                    }
> >                }
> >                retries = RETRIES;
> >            }
> >            if (wasInterrupted && !interruptibly) {
> >                Thread.currentThread().interrupt();
> >                return false;
> >            }
> >            return wasInterrupted;
> >        }
> >
> > As already mentioned this works quite well in a number of cases. For
> > example, adding this method to the example MergeSort code and calling
> > quietlyJoinUnforked(), results in the same overall performance,
> > reduces the number of extra blocked worker threads to 1 if any
> > (instead of up to 8 for the unmodified code; on a PC with 4
> > hyper-threading cores/8 threads), and allows for some extra
> > (recreational?) freedom in joining the right and left sub-tasks in any
> > order. It works in cases where no sub-task is forked explicitly. I
> > observed that worker thread blocking only occurs towards the end of a
> > large recursion, suggesting that worker threads only block - as
> > intended - when there is no other work available (sometimes while
> > implicit forking has not yet happened).
> >
> > Wolfgang.
> >
> >
> >
> > On 2012-04-09 16:16, Doug Lea wrote:
> >>
> >> After sitting on multiple variations for months, I committed
> >> CountedCompleter, a completion-based flavor of ForkJoinTask.
> >>
> >> As mentioned a few times over the past year, the main motivation
> >> is to better support tasks that perform IO or other base
> >> actions that may (or may not) take a lot of time to execute.
> >> As is the case with JDK7 async IO and other completion-based
> >> frameworks, the most common path to efficiency is for such tasks
> >> to arrange continuation actions that occur upon their completion.
> >> The main twist for CountedCompleters is that continuations
> >> might be dependent on multiple actions, not just one. (Or in
> >> other words, the continuations must be preceded by a specialized,
> >> "bottom-up" form of join.)
> >>
> >> The CountedCompleter abstract class provides a minimal basis
> >> for these kinds of tasks. While some of the mechanics are
> >> reminiscent of other FJ-like frameworks such as Intel TBB,
> >> CountedCompleters are designed to fit smoothly with other
> >> kinds of ForkJoinTasks (like RecursiveActions), and so still
> >> allow people to use the more pleasant Future-style conventions
> >> rather than count-based bottom-up joining unless they need them.
> >> At the same time, the CountedCompleter class exposes enough
> >> mechanics to allow all sorts of tweaks that people can use
> >> to improve performance.
> >> In particular, in addition to usually being the best way to deal
> >> with IO etc bound tasks, CountedCompleters sometimes fare better
> >> than RecursiveActions in programs that entail lots of garbage
> >> collection because GC can have similar impact on task variability.
> >>
> >> Even though targeted for JDK8, versions of CountedCompleter
> >> appear in the jsr166y and main repositories, not jsr166e. This is
> >> because they require a non-public hook into modified ForkJoinTask
> >> exception handling mechanics in order to properly propagate
> >> exceptional completions. For sources, docs, and jar files, see
> >> the usual links at
> >> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> >>
> >> The API docs include more details and some examples:
> >>
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
> >>
> >>
> >> I also added a few (with more to come) test/demo programs that
> >> illustrate
> >> other usages. See CCBoxedLongSort and CCJacobi in
> >> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
> >>
> >> Please try these out. As always, comments and suggestions
> >> (hopefully based on usage experience) would be welcome.
> >>
> >> -Doug
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> ------------------------------
>
> Message: 2
> Date: Mon, 16 Apr 2012 16:38:00 +0000
> From: "Boehm, Hans" <hans.boehm at hp.com>
> To: Andrew Haley <aph at redhat.com>,
>     "concurrency-interest at cs.oswego.edu"
>     <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID:
>     <A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hpqcorp.net
> >
>
> Content-Type: text/plain; charset="us-ascii"
>
> Important questions to consider when you write it up:
>
> How does it compare to something like Gadara that uses whole program
> analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it
> doesn't need whole program analysis.)  Other deadlock avoidance schemes?
>
> Once you detect a potential deadlock, how do you recover?  Or can you
> always schedule so that the possibility doesn't arise?
>
> Hans
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency<concurrency>
> -
> > interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
> > Sent: Monday, April 16, 2012 4:34 AM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Java Deadlocks prevented
> >
> > On 04/16/2012 12:06 PM, Rohit Kumar wrote:
> >
> > > I have found a way of preventing deadlocks in java. The
> > > methodology(which is code) completely prevents the deadlock from
> > > occuring by detecting it in advance. This can be used across the
> > > systems seamlessly.
> > >
> > > Kindly let me know what I need to do next. I want this to be part of
> > > next jdk release. I am writing this email as I have no idea what I
> > > need to do next to bring it into limelight.
> >
> > Write it up, maybe present it to a conference, and wait for feedback.
> > That's how it always works.  If your idea really works, people will
> > use it.
> >
> > Andrew.
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> ------------------------------
>
> Message: 3
> Date: Mon, 16 Apr 2012 10:11:00 -0700
> From: Nathan Reynolds <nathan.reynolds at oracle.com>
> To: "Boehm, Hans" <hans.boehm at hp.com>
> Cc: "concurrency-interest at cs.oswego.edu"
>     <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID: <4F8C52A4.70002 at oracle.com>
> Content-Type: text/plain; charset="iso-8859-1"; Format="flowed"
>
> Deadlock prevention is very valuable.  It means deadlock prone code
> won't bring down a production server and cost the company millions in
> down time.  It means consumers won't kill the process and request a refund.
>
> How much does deadlock prevention cost?  Is the cost on the thread that
> acquires locks or is it in a background thread?
>
> Each time processors or systems increase the number of cores, I find we
> have to do a round of lock contention fixing.  I have only seen 1 lock
> at a time be the bottleneck in the system.  Does deadlock prevention
> increase the critical region of locks?  If so, this will definitely
> reduce the scalability of the system if it impacts the 1 bottlenecking
> lock.
>
> Lock performance is a very important consideration.  Locks have evolved
> from fat locks (i.e trips into the OS kernel) to thin locks (i.e. spin
> and CAS in user mode) to biased/lazy locks (i.e. no CAS and an
> indefinite lock owner).  All of this was done to reduce the performance
> overhead of locks.  How does deadlock prevention impact the performance
> of biased, thin and fat locks?  I am not as concerned about fat lock
> performance since most of the time the thread is going to block.
>
> Nathan Reynolds
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
> On 4/16/2012 9:38 AM, Boehm, Hans wrote:
> > Important questions to consider when you write it up:
> >
> > How does it compare to something like Gadara that uses whole program
> analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it
> doesn't need whole program analysis.)  Other deadlock avoidance schemes?
> >
> > Once you detect a potential deadlock, how do you recover?  Or can you
> always schedule so that the possibility doesn't arise?
> >
> > Hans
> >
> >> -----Original Message-----
> >> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency<concurrency>
> -
> >> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
> >> Sent: Monday, April 16, 2012 4:34 AM
> >> To: concurrency-interest at cs.oswego.edu
> >> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> >>
> >> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
> >>
> >>> I have found a way of preventing deadlocks in java. The
> >>> methodology(which is code) completely prevents the deadlock from
> >>> occuring by detecting it in advance. This can be used across the
> >>> systems seamlessly.
> >>>
> >>> Kindly let me know what I need to do next. I want this to be part of
> >>> next jdk release. I am writing this email as I have no idea what I
> >>> need to do next to bring it into limelight.
> >> Write it up, maybe present it to a conference, and wait for feedback.
> >> That's how it always works.  If your idea really works, people will
> >> use it.
> >>
> >> Andrew.
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/7ea89bb3/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 4
> Date: Tue, 17 Apr 2012 01:20:15 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in>
> To: "concurrency-interest at cs.oswego.edu"
>     <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
>     87,    Issue 26 (Java deadlock prevented)
> Message-ID:
>     <1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Andrew:
> ?
> Thanks for the reply. Can you kindly let me know where do I need to
> present it ? Where will the conference be held ? Can I present it online or
> I have to come in person ?
> ?
> Waiting for your early reply once again.
> ?
> Thanks & Regards,
> Rohit Kumar
>
> From: "concurrency-interest-request at cs.oswego.edu" <
> concurrency-interest-request at cs.oswego.edu>
> To: concurrency-interest at cs.oswego.edu
> Sent: Monday, 16 April 2012 9:30 PM
> Subject: Concurrency-interest Digest, Vol 87, Issue 26
>
> Send Concurrency-interest mailing list submissions to
> ??? concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
> ??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
> ??? concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
> ??? concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
> ? 1. (no subject) (Rohit Kumar)
> ? 2. Java Deadlocks prevented (Rohit Kumar)
> ? 3. Re: Java Deadlocks prevented (Andrew Haley)
> ? 4. Re: CountedCompleters (Wolfgang Baltes)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in>
> To: "concurrency-interest at cs.oswego.edu"
> ??? <concurrency-interest at cs.oswego.edu>
> Cc: "concurrency-interest-owner at cs.oswego.edu"
> ??? <concurrency-interest-owner at cs.oswego.edu>
> Subject: [concurrency-interest] (no subject)
> Message-ID:
> ??? <1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Hi All,
> ?
> I have found a way of preventing deadlocks in java. The methodology(which
> is code) completely prevents the deadlock from accuring by detecting it in
> advance. This can be used across the systems seamlessly.
> ?
> Kindly let me know what I need to do next. I want this to be part of next
> jdk release.
> ?
> Thanks & Regards,
> Rohit Kumar
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/a6588341/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 2
> Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in>
> To: "concurrency-interest at cs.oswego.edu"
> ??? <concurrency-interest at cs.oswego.edu>
> Cc: "concurrency-interest-owner at cs.oswego.edu"
> ??? <concurrency-interest-owner at cs.oswego.edu>
> Subject: [concurrency-interest] Java Deadlocks prevented
> Message-ID:
> ??? <1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com>
> Content-Type: text/plain; charset="utf-8"
>
>
>
> Hi All,
>
> I have found a way of preventing deadlocks in java. The methodology(which
> is code) completely prevents the deadlock from occuring by detecting it in
> advance. This can be used across the systems seamlessly.
>
> Kindly let me know what I need to do next. I want this to be part of next
> jdk release. I am writing this email as I have no idea what I need to do
> next to bring it into limelight.
>
> Thanks & Regards,
> Rohit Kumar
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/064a4873/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 3
> Date: Mon, 16 Apr 2012 12:33:45 +0100
> From: Andrew Haley <aph at redhat.com>
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID: <4F8C0399.8040301 at redhat.com>
> Content-Type: text/plain; charset=ISO-8859-1
>
> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>
> > I have found a way of preventing deadlocks in java. The
> > methodology(which is code) completely prevents the deadlock from
> > occuring by detecting it in advance. This can be used across the
> > systems seamlessly.
> >
> > Kindly let me know what I need to do next. I want this to be part of
> > next jdk release. I am writing this email as I have no idea what I
> > need to do next to bring it into limelight.
>
> Write it up, maybe present it to a conference, and wait for feedback.
> That's how it always works.? If your idea really works, people will
> use it.
>
> Andrew.
>
>
> ------------------------------
>
> Message: 4
> Date: Mon, 16 Apr 2012 16:48:31 +0200
> From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
> To: "Concurrency-interest at cs.oswego.edu"
> ??? <Concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] CountedCompleters
> Message-ID: <4F8C313F.2080308 at laposte.net>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> Thanks, Doug, for a this addition to the FJ framework. I think that
> CountedCompleter will address the needs of an entire class of
> applications in an efficient and simple to use manner.
>
> I used the code and noticed that method doJoin() has become more
> effective in avoiding blocking threads, and as a result fewer extra
> threads are created. I found the performance, compared to
> RecursiveAction, to be equal or insignificantly different. This reduces
> the problem described in item 3 below.
>
> However, at the same time, CountedCompleter does not fully satisfy the
> needs for a class of problems I work on. To this end, here are a few
> enhancements I would like to suggest:
>
> 1: Symmetrically to onCompletion(), provide
> onExceptionalCompletion(Throwable). This allows filtering exception
> propagation. There are cases where the propagation of the exception is
> desired, and others where a corrective action is taken instead, such as
> a retry.
>
> 2: As a further enhancement to 1: enable any Throwable, including
> checked exceptions. This allows the use of a CountedCompleter as a
> CompletionHandler for asynchronous IO operations or as a wrapper for
> MethodHandles (which throw Throwable) without adding extra logic to
> capture and convert an IO exception. I read the documentation which
> explains why this is currently limited to unchecked exceptions. While I
> can agree with this in general, I feel the argument is weak for
> CountedCompleter if it is there to support asynchronous tasks/events.
> (May I add that using this type of framework is not for the
> faint-hearted anyway!?)
>
> 3: Provide a method to join a task that is not forked and/or not
> completable, while minimizing worker thread blocking. For example,
> CountedCompleter allows creating chains of dependent tasks. Unless the
> ultimate task (the last in the chain) is forked/exists on the task stack
> AND can complete because all dependencies are resolved, joining it will
> block the worker thread. I noticed (and my testing is limited to a few
> test cases and therefore not representative) the blocking and the
> creation of other worker threads, ultimately running out of memory or
> reaching the thread count limit. If this task is not forked, then
> join()/quietlyJoin() will block the worker thread. The following code is
> my (inexpert) attempt to provide a remedy. It is based on the assumption
> that a task that depends on others for completion is not forked until
> all dependencies are resolved. For example, a CountedCompleter
> implementing CompletionHandler would fork itself ("implicit fork") when
> the IO operation is done. This works very well in my test cases, but at
> this time I would not claim it to be universally applicable or error
> free. It is shown here more to demonstrate the attempt rather than as a
> reference implementation. With access to private data structures, this
> can be done more elegantly and more reliably.
>
> ? ? ? ? static final int RETRIES = 16;
> ? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in
> microseconds.
>
> ? ? ? ? public final void quietlyJoinUnforked() {
> ? ? ? ? ? ? this.doJoinUnforked(false);
> ? ? ? ? }
>
> ? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
> ? ? ? ? throws InterruptedException {
> ? ? ? ? ? ? if (this.doJoinUnforked(true)) {
> ? ? ? ? ? ? ? ? throw new InterruptedException();
> ? ? ? ? ? ? }
> ? ? ? ? }
>
> ? ? ? ? public final boolean doJoinUnforked(final boolean interruptibly) {
> ? ? ? ? ? ? int retries = RETRIES;
> ? ? ? ? ? ? boolean wasInterrupted = false;
> ? ? ? ? ? ? while (!this.isDone()) {
> ? ? ? ? ? ? ? ? ForkJoinTask<?> t;
> ? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
> ? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
> ? ? ? ? ? ? ? ? ? ? if (t == this) {
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? else {
> ? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
> ? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
> ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
> ? ? ? ? ? ? ? ? ? ? try {
> ? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is
> assumed that
> ? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task
> to retrieve
> ? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
> ? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
> ? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? ? ? return true;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
> ? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
> ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? retries = RETRIES;
> ? ? ? ? ? ? }
> ? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
> ? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
> ? ? ? ? ? ? ? ? return false;
> ? ? ? ? ? ? }
> ? ? ? ? ? ? return wasInterrupted;
> ? ? ? ? }
>
> As already mentioned this works quite well in a number of cases. For
> example, adding this method to the example MergeSort code and calling
> quietlyJoinUnforked(), results in the same overall performance, reduces
> the number of extra blocked worker threads to 1 if any (instead of up to
> 8 for the unmodified code; on a PC with 4 hyper-threading cores/8
> threads), and allows for some extra (recreational?) freedom in joining
> the right and left sub-tasks in any order. It works in cases where no
> sub-task is forked explicitly. I observed that worker thread blocking
> only occurs towards the end of a large recursion, suggesting that worker
> threads only block - as intended - when there is no other work available
> (sometimes while implicit forking has not yet happened).
>
> Wolfgang.
>
>
>
> On 2012-04-09 16:16, Doug Lea wrote:
> >
> > After sitting on multiple variations for months, I committed
> > CountedCompleter, a completion-based flavor of ForkJoinTask.
> >
> > As mentioned a few times over the past year, the main motivation
> > is to better support tasks that perform IO or other base
> > actions that may (or may not) take a lot of time to execute.
> > As is the case with JDK7 async IO and other completion-based
> > frameworks, the most common path to efficiency is for such tasks
> > to arrange continuation actions that occur upon their completion.
> > The main twist for CountedCompleters is that continuations
> > might be dependent on multiple actions, not just one. (Or in
> > other words, the continuations must be preceded by a specialized,
> > "bottom-up" form of join.)
> >
> > The CountedCompleter abstract class provides a minimal basis
> > for these kinds of tasks. While some of the mechanics are
> > reminiscent of other FJ-like frameworks such as Intel TBB,
> > CountedCompleters are designed to fit smoothly with other
> > kinds of ForkJoinTasks (like RecursiveActions), and so still
> > allow people to use the more pleasant Future-style conventions
> > rather than count-based bottom-up joining unless they need them.
> > At the same time, the CountedCompleter class exposes enough
> > mechanics to allow all sorts of tweaks that people can use
> > to improve performance.
> > In particular, in addition to usually being the best way to deal
> > with IO etc bound tasks, CountedCompleters sometimes fare better
> > than RecursiveActions in programs that entail lots of garbage
> > collection because GC can have similar impact on task variability.
> >
> > Even though targeted for JDK8, versions of CountedCompleter
> > appear in the jsr166y and main repositories, not jsr166e. This is
> > because they require a non-public hook into modified ForkJoinTask
> > exception handling mechanics in order to properly propagate
> > exceptional completions. For sources, docs, and jar files, see
> > the usual links at
> > http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> >
> > The API docs include more details and some examples:
> >
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
> >
> >
> > I also added a few (with more to come) test/demo programs that illustrate
> > other usages. See CCBoxedLongSort and CCJacobi in
> > http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
> >
> > Please try these out. As always, comments and suggestions
> > (hopefully based on usage experience) would be welcome.
> >
> > -Doug
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 87, Issue 26
> ****************************************************
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/75746dcb/attachment.html
> >
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 87, Issue 27
> ****************************************************
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/a205cd94/attachment-0001.html>

From hans.boehm at hp.com  Mon Apr 16 18:39:05 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Mon, 16 Apr 2012 22:39:05 +0000
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
	Issue 27
In-Reply-To: <1334605528.11594.YahooMailNeo@web193406.mail.sg3.yahoo.com>
References: <mailman.117.1334596831.3324.concurrency-interest@cs.oswego.edu>
	<1334601360.99294.YahooMailNeo@web193402.mail.sg3.yahoo.com>
	<4F8C7190.6030103@oracle.com>
	<1334605528.11594.YahooMailNeo@web193406.mail.sg3.yahoo.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD2355442A4@G4W3299.americas.hpqcorp.net>

The core problem with this is:  Once you detect the deadlock, what do you do then?  If you somehow throw an exception, then every lock acquisition must be prepared to correctly handle a deadlock exception, and perhaps release other locks and retry.  It seems to me that's the hard part, especially since it involves arbitrary functions dealing with exceptions they're not prepared to handle.  If you don't get that part right, you've now turned fail-stop behavior (deadlock) into data corruption caused by failure to clean up correctly when the deadlock exception is thrown.  Bad trade-off.

Hans

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Rohit Kumar
Sent: Monday, April 16, 2012 12:45 PM
To: Nathan Reynolds; sandeep.bansal85 at gmail.com; khilan at doc.ic.ac.uk
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol 87, Issue 27

The whole idea that I wanted to bring up is that use of synchronized keyword (implicit locks) can make your program vulnerable to deadlocks as you have no control over acquisition of locks. Once you use explicit locks as provided by java concurrent apis, deadlocks can be prevented completely. And yes, my program uses synchronized keywords, but all in one place and is completely and thoroughly tested. Usage of synchronized keyword should be confined.

My program detects cycles in lock-acquisition graph. The overhead will be proportional to all the threads that are holding locks but not yet released and this is not great compared to restarting the server everytime the deadlock happens.

I will see if I can present it to any java forum. This is written in java but the concept can be applied in any programming language.

Thanks & Regards,
Rohit Kumar

From: Nathan Reynolds <nathan.reynolds at oracle.com>
To: Rohit Kumar <rohitk242 at yahoo.co.in>
Cc: "concurrency-interest at cs.oswego.edu" <concurrency-interest at cs.oswego.edu>
Sent: Tuesday, 17 April 2012 12:52 AM
Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol 87, Issue 27


Synchronized blocks are used every where.  You could use ASM (http://asm.ow2.org/) to instrument all synchronized blocks (i.e. monitorenter and monitorexit bytecodes).  Simply put a call to your deadlock-check just before the monitorenter instruction.  You could also use this to inject your code into all Locks.

If you want to avoid the overhead during lock acquisition, you could have a background thread detect the deadlock and then make one thread involved in the deadlock throw an exception using Thread.stop(Throwable).  Thread.stop() is a misnomer in my opinion.  It doesn't stop the thread immediately.  Instead, it causes the thread to throw an exception which unwinds the stack and if not caught causes the thread to terminate.  It is deprecated because the exception can be thrown at any point during the execution of the thread and this makes it very hard to get it bug free.  (It might be deprecated for other reasons as well.)  However, if you know that the threads are indefinitely deadlocked, then the thread won't wake up any time and I naively don't see why using Thread.stop(Throwable) would be a problem.  (Note: I am not sure if Thread.stop() will throw an exception while the thread is blocked inside monitorenter).

> Finally where do I need to present this writeup?

I have never presented anything outside of Oracle Open World.  I have attended Java One.  Sorry, I can't be of much help.  Since this is Java code, you might consider presenting at Java One.  I am not sure if that is appropriate venue, though.
Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering<http://psr.us.oracle.com/> | Server Technology

On 4/16/2012 11:36 AM, Rohit Kumar wrote:
Hans,Nathan,

I am not aware of anything like Gadara yet. My implementation assumes that there are no synchnonized keywords (implicit locks) in your program. It requires you to use explicit locks (e.g. Lock class in java concurrent api). There is no background thread running here. The deadlock-check happens at each lock acquisition request; it runs an algorithms internally to see if there are any cycles formed in the lock-acquisition graph. If yes, it doesn't let you acquire the lock but throws an exception. You can catch this exception and take necessary steps to re-acquire all the locks once again or whatever you want. The program is written in java and it is hardly 270 lines of code.

Finally where do I need to present this writeup ?

Thanks & Regards,
Rohit Kumar

From: "concurrency-interest-request at cs.oswego.edu"<mailto:concurrency-interest-request at cs.oswego.edu> <concurrency-interest-request at cs.oswego.edu><mailto:concurrency-interest-request at cs.oswego.edu>
To: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
Sent: Monday, 16 April 2012 10:50 PM
Subject: Concurrency-interest Digest, Vol 87, Issue 27

Send Concurrency-interest mailing list submissions to
    concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>

To subscribe or unsubscribe via the World Wide Web, visit
    http://cs.oswego.edu/mailman/listinfo/concurrency-interest
or, via email, send a message with subject or body 'help' to
    concurrency-interest-request at cs.oswego.edu<mailto:concurrency-interest-request at cs.oswego.edu>

You can reach the person managing the list at
    concurrency-interest-owner at cs.oswego.edu<mailto:concurrency-interest-owner at cs.oswego.edu>

When replying, please edit your Subject line so it is more specific
than "Re: Contents of Concurrency-interest digest..."


Today's Topics:

  1. Re: CountedCompleters (Wolfgang Baltes)
  2. Re: Java Deadlocks prevented (Boehm, Hans)
  3. Re: Java Deadlocks prevented (Nathan Reynolds)
  4. Re: Concurrency-interest Digest, Vol 87,    Issue 26 (Java
      deadlock prevented) (Rohit Kumar)


----------------------------------------------------------------------

Message: 1
Date: Mon, 16 Apr 2012 18:01:50 +0200
From: Wolfgang Baltes <wolfgang.baltes at laposte.net<mailto:wolfgang.baltes at laposte.net>>
To: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] CountedCompleters
Message-ID: <4F8C426E.6090704 at laposte.net<mailto:4F8C426E.6090704 at laposte.net>>
Content-Type: text/plain; charset=ISO-8859-1; format=flowed

I apologize for a mistake in the last paragraph of my memo: using
quietlyJoinUnforked() in the SDK7 sample code for MergeSort does have a
non-negligible performance impact (not no impact as stated). There is
better performance in case of recursions which produce many tasks that
are not explicitly forked, and it reduces the number of extra threads
significantly, allowing larger problems to be solved with smaller memory
footprint.

Wolfgang.

On 2012-04-16 16:48, Wolfgang Baltes wrote:
> Thanks, Doug, for a this addition to the FJ framework. I think that
> CountedCompleter will address the needs of an entire class of
> applications in an efficient and simple to use manner.
>
> I used the code and noticed that method doJoin() has become more
> effective in avoiding blocking threads, and as a result fewer extra
> threads are created. I found the performance, compared to
> RecursiveAction, to be equal or insignificantly different. This
> reduces the problem described in item 3 below.
>
> However, at the same time, CountedCompleter does not fully satisfy the
> needs for a class of problems I work on. To this end, here are a few
> enhancements I would like to suggest:
>
> 1: Symmetrically to onCompletion(), provide
> onExceptionalCompletion(Throwable). This allows filtering exception
> propagation. There are cases where the propagation of the exception is
> desired, and others where a corrective action is taken instead, such
> as a retry.
>
> 2: As a further enhancement to 1: enable any Throwable, including
> checked exceptions. This allows the use of a CountedCompleter as a
> CompletionHandler for asynchronous IO operations or as a wrapper for
> MethodHandles (which throw Throwable) without adding extra logic to
> capture and convert an IO exception. I read the documentation which
> explains why this is currently limited to unchecked exceptions. While
> I can agree with this in general, I feel the argument is weak for
> CountedCompleter if it is there to support asynchronous tasks/events.
> (May I add that using this type of framework is not for the
> faint-hearted anyway!?)
>
> 3: Provide a method to join a task that is not forked and/or not
> completable, while minimizing worker thread blocking. For example,
> CountedCompleter allows creating chains of dependent tasks. Unless the
> ultimate task (the last in the chain) is forked/exists on the task
> stack AND can complete because all dependencies are resolved, joining
> it will block the worker thread. I noticed (and my testing is limited
> to a few test cases and therefore not representative) the blocking and
> the creation of other worker threads, ultimately running out of memory
> or reaching the thread count limit. If this task is not forked, then
> join()/quietlyJoin() will block the worker thread. The following code
> is my (inexpert) attempt to provide a remedy. It is based on the
> assumption that a task that depends on others for completion is not
> forked until all dependencies are resolved. For example, a
> CountedCompleter implementing CompletionHandler would fork itself
> ("implicit fork") when the IO operation is done. This works very well
> in my test cases, but at this time I would not claim it to be
> universally applicable or error free. It is shown here more to
> demonstrate the attempt rather than as a reference implementation.
> With access to private data structures, this can be done more
> elegantly and more reliably.
>
>        static final int RETRIES = 16;
>        static final long WAIT_TIMEOUT = 1_000;    // Timeout in
> microseconds.
>
>        public final void quietlyJoinUnforked() {
>            this.doJoinUnforked(false);
>        }
>
>        public final void quietlyJoinUnforkedInterruptibly()
>        throws InterruptedException {
>            if (this.doJoinUnforked(true)) {
>                throw new InterruptedException();
>            }
>        }
>
>        public final boolean doJoinUnforked(final boolean
> interruptibly) {
>            int retries = RETRIES;
>            boolean wasInterrupted = false;
>            while (!this.isDone()) {
>                ForkJoinTask<?> t;
>                if ((t = pollTask()) != null) {
>                    t.quietlyInvoke();
>                    if (t == this) {
>                        break;
>                    }
>                }
>                else {
>                    if (retries-- > 0) {
>                        Thread.yield();
>                        continue;
>                    }
>                    wasInterrupted = Thread.interrupted();
>                    try {
>                        // get(...) is used as a timed join(). It is
> assumed that
>                        // other code will perform get() on this task
> to retrieve
>                        // the task's result or exception.
>                        this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
>                        break;
>                    }
>                    catch (final InterruptedException consumed) {
>                        if (!interruptibly) {
>                            wasInterrupted = true;
>                            continue;
>                        }
>                        return true;
>                    }
>                    catch (final ExecutionException ignored) {
>                        // See comment on get() above.
>                        break;
>                    }
>                    catch (final TimeoutException ignored) {
>                        continue;
>                    }
>                }
>                retries = RETRIES;
>            }
>            if (wasInterrupted && !interruptibly) {
>                Thread.currentThread().interrupt();
>                return false;
>            }
>            return wasInterrupted;
>        }
>
> As already mentioned this works quite well in a number of cases. For
> example, adding this method to the example MergeSort code and calling
> quietlyJoinUnforked(), results in the same overall performance,
> reduces the number of extra blocked worker threads to 1 if any
> (instead of up to 8 for the unmodified code; on a PC with 4
> hyper-threading cores/8 threads), and allows for some extra
> (recreational?) freedom in joining the right and left sub-tasks in any
> order. It works in cases where no sub-task is forked explicitly. I
> observed that worker thread blocking only occurs towards the end of a
> large recursion, suggesting that worker threads only block - as
> intended - when there is no other work available (sometimes while
> implicit forking has not yet happened).
>
> Wolfgang.
>
>
>
> On 2012-04-09 16:16, Doug Lea wrote:
>>
>> After sitting on multiple variations for months, I committed
>> CountedCompleter, a completion-based flavor of ForkJoinTask.
>>
>> As mentioned a few times over the past year, the main motivation
>> is to better support tasks that perform IO or other base
>> actions that may (or may not) take a lot of time to execute.
>> As is the case with JDK7 async IO and other completion-based
>> frameworks, the most common path to efficiency is for such tasks
>> to arrange continuation actions that occur upon their completion.
>> The main twist for CountedCompleters is that continuations
>> might be dependent on multiple actions, not just one. (Or in
>> other words, the continuations must be preceded by a specialized,
>> "bottom-up" form of join.)
>>
>> The CountedCompleter abstract class provides a minimal basis
>> for these kinds of tasks. While some of the mechanics are
>> reminiscent of other FJ-like frameworks such as Intel TBB,
>> CountedCompleters are designed to fit smoothly with other
>> kinds of ForkJoinTasks (like RecursiveActions), and so still
>> allow people to use the more pleasant Future-style conventions
>> rather than count-based bottom-up joining unless they need them.
>> At the same time, the CountedCompleter class exposes enough
>> mechanics to allow all sorts of tweaks that people can use
>> to improve performance.
>> In particular, in addition to usually being the best way to deal
>> with IO etc bound tasks, CountedCompleters sometimes fare better
>> than RecursiveActions in programs that entail lots of garbage
>> collection because GC can have similar impact on task variability.
>>
>> Even though targeted for JDK8, versions of CountedCompleter
>> appear in the jsr166y and main repositories, not jsr166e. This is
>> because they require a non-public hook into modified ForkJoinTask
>> exception handling mechanics in order to properly propagate
>> exceptional completions. For sources, docs, and jar files, see
>> the usual links at
>> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>>
>> The API docs include more details and some examples:
>> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
>>
>>
>> I also added a few (with more to come) test/demo programs that
>> illustrate
>> other usages. See CCBoxedLongSort and CCJacobi in
>> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
>>
>> Please try these out. As always, comments and suggestions
>> (hopefully based on usage experience) would be welcome.
>>
>> -Doug
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


------------------------------

Message: 2
Date: Mon, 16 Apr 2012 16:38:00 +0000
From: "Boehm, Hans" <hans.boehm at hp.com<mailto:hans.boehm at hp.com>>
To: Andrew Haley <aph at redhat.com<mailto:aph at redhat.com>>,
    "concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>"
    <concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>>
Subject: Re: [concurrency-interest] Java Deadlocks prevented
Message-ID:
    <A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hpqcorp.net<mailto:A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hpqcorp.net>>

Content-Type: text/plain; charset="us-ascii"

Important questions to consider when you write it up:

How does it compare to something like Gadara that uses whole program analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it doesn't need whole program analysis.)  Other deadlock avoidance schemes?

Once you detect a potential deadlock, how do you recover?  Or can you always schedule so that the possibility doesn't arise?

Hans

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-
> interest-bounces at cs.oswego.edu<mailto:interest-bounces at cs.oswego.edu>] On Behalf Of Andrew Haley
> Sent: Monday, April 16, 2012 4:34 AM
> To: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
>
> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>
> > I have found a way of preventing deadlocks in java. The
> > methodology(which is code) completely prevents the deadlock from
> > occuring by detecting it in advance. This can be used across the
> > systems seamlessly.
> >
> > Kindly let me know what I need to do next. I want this to be part of
> > next jdk release. I am writing this email as I have no idea what I
> > need to do next to bring it into limelight.
>
> Write it up, maybe present it to a conference, and wait for feedback.
> That's how it always works.  If your idea really works, people will
> use it.
>
> Andrew.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



------------------------------

Message: 3
Date: Mon, 16 Apr 2012 10:11:00 -0700
From: Nathan Reynolds <nathan.reynolds at oracle.com<mailto:nathan.reynolds at oracle.com>>
To: "Boehm, Hans" <hans.boehm at hp.com<mailto:hans.boehm at hp.com>>
Cc: "concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>"
    <concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>>
Subject: Re: [concurrency-interest] Java Deadlocks prevented
Message-ID: <4F8C52A4.70002 at oracle.com<mailto:4F8C52A4.70002 at oracle.com>>
Content-Type: text/plain; charset="iso-8859-1"; Format="flowed"

Deadlock prevention is very valuable.  It means deadlock prone code
won't bring down a production server and cost the company millions in
down time.  It means consumers won't kill the process and request a refund.

How much does deadlock prevention cost?  Is the cost on the thread that
acquires locks or is it in a background thread?

Each time processors or systems increase the number of cores, I find we
have to do a round of lock contention fixing.  I have only seen 1 lock
at a time be the bottleneck in the system.  Does deadlock prevention
increase the critical region of locks?  If so, this will definitely
reduce the scalability of the system if it impacts the 1 bottlenecking lock.

Lock performance is a very important consideration.  Locks have evolved
from fat locks (i.e trips into the OS kernel) to thin locks (i.e. spin
and CAS in user mode) to biased/lazy locks (i.e. no CAS and an
indefinite lock owner).  All of this was done to reduce the performance
overhead of locks.  How does deadlock prevention impact the performance
of biased, thin and fat locks?  I am not as concerned about fat lock
performance since most of the time the thread is going to block.

Nathan Reynolds
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/16/2012 9:38 AM, Boehm, Hans wrote:
> Important questions to consider when you write it up:
>
> How does it compare to something like Gadara that uses whole program analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it doesn't need whole program analysis.)  Other deadlock avoidance schemes?
>
> Once you detect a potential deadlock, how do you recover?  Or can you always schedule so that the possibility doesn't arise?
>
> Hans
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-
>> interest-bounces at cs.oswego.edu<mailto:interest-bounces at cs.oswego.edu>] On Behalf Of Andrew Haley
>> Sent: Monday, April 16, 2012 4:34 AM
>> To: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
>> Subject: Re: [concurrency-interest] Java Deadlocks prevented
>>
>> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>>
>>> I have found a way of preventing deadlocks in java. The
>>> methodology(which is code) completely prevents the deadlock from
>>> occuring by detecting it in advance. This can be used across the
>>> systems seamlessly.
>>>
>>> Kindly let me know what I need to do next. I want this to be part of
>>> next jdk release. I am writing this email as I have no idea what I
>>> need to do next to bring it into limelight.
>> Write it up, maybe present it to a conference, and wait for feedback.
>> That's how it always works.  If your idea really works, people will
>> use it.
>>
>> Andrew.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/7ea89bb3/attachment-0001.html>

------------------------------

Message: 4
Date: Tue, 17 Apr 2012 01:20:15 +0800 (SGT)
From: Rohit Kumar <rohitk242 at yahoo.co.in<mailto:rohitk242 at yahoo.co.in>>
To: "concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>"
    <concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>>
Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
    87,    Issue 26 (Java deadlock prevented)
Message-ID:
    <1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com<mailto:1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com>>
Content-Type: text/plain; charset="iso-8859-1"

Andrew:
?
Thanks for the reply. Can you kindly let me know where do I need to present it ? Where will the conference be held ? Can I present it online or I have to come in person ?
?
Waiting for your early reply once again.
?
Thanks & Regards,
Rohit Kumar

From: "concurrency-interest-request at cs.oswego.edu<mailto:concurrency-interest-request at cs.oswego.edu>" <concurrency-interest-request at cs.oswego.edu<mailto:concurrency-interest-request at cs.oswego.edu>>
To: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
Sent: Monday, 16 April 2012 9:30 PM
Subject: Concurrency-interest Digest, Vol 87, Issue 26

Send Concurrency-interest mailing list submissions to
??? concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>

To subscribe or unsubscribe via the World Wide Web, visit
??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
or, via email, send a message with subject or body 'help' to
??? concurrency-interest-request at cs.oswego.edu<mailto:concurrency-interest-request at cs.oswego.edu>

You can reach the person managing the list at
??? concurrency-interest-owner at cs.oswego.edu<mailto:concurrency-interest-owner at cs.oswego.edu>

When replying, please edit your Subject line so it is more specific
than "Re: Contents of Concurrency-interest digest..."


Today's Topics:

? 1. (no subject) (Rohit Kumar)
? 2. Java Deadlocks prevented (Rohit Kumar)
? 3. Re: Java Deadlocks prevented (Andrew Haley)
? 4. Re: CountedCompleters (Wolfgang Baltes)


----------------------------------------------------------------------

Message: 1
Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT)
From: Rohit Kumar <rohitk242 at yahoo.co.in<mailto:rohitk242 at yahoo.co.in>>
To: "concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>"
??? <concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>>
Cc: "concurrency-interest-owner at cs.oswego.edu<mailto:concurrency-interest-owner at cs.oswego.edu>"
??? <concurrency-interest-owner at cs.oswego.edu<mailto:concurrency-interest-owner at cs.oswego.edu>>
Subject: [concurrency-interest] (no subject)
Message-ID:
??? <1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com<mailto:1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com>>
Content-Type: text/plain; charset="iso-8859-1"

Hi All,
?
I have found a way of preventing deadlocks in java. The methodology(which is code) completely prevents the deadlock from accuring by detecting it in advance. This can be used across the systems seamlessly.
?
Kindly let me know what I need to do next. I want this to be part of next jdk release.
?
Thanks & Regards,
Rohit Kumar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/a6588341/attachment-0001.html>

------------------------------

Message: 2
Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)
From: Rohit Kumar <rohitk242 at yahoo.co.in<mailto:rohitk242 at yahoo.co.in>>
To: "concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>"
??? <concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>>
Cc: "concurrency-interest-owner at cs.oswego.edu<mailto:concurrency-interest-owner at cs.oswego.edu>"
??? <concurrency-interest-owner at cs.oswego.edu<mailto:concurrency-interest-owner at cs.oswego.edu>>
Subject: [concurrency-interest] Java Deadlocks prevented
Message-ID:
??? <1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com<mailto:1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com>>
Content-Type: text/plain; charset="utf-8"



Hi All,

I have found a way of preventing deadlocks in java. The methodology(which is code) completely prevents the deadlock from occuring by detecting it in advance. This can be used across the systems seamlessly.

Kindly let me know what I need to do next. I want this to be part of next jdk release. I am writing this email as I have no idea what I need to do next to bring it into limelight.

Thanks & Regards,
Rohit Kumar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/064a4873/attachment-0001.html>

------------------------------

Message: 3
Date: Mon, 16 Apr 2012 12:33:45 +0100
From: Andrew Haley <aph at redhat.com<mailto:aph at redhat.com>>
To: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Java Deadlocks prevented
Message-ID: <4F8C0399.8040301 at redhat.com<mailto:4F8C0399.8040301 at redhat.com>>
Content-Type: text/plain; charset=ISO-8859-1

On 04/16/2012 12:06 PM, Rohit Kumar wrote:

> I have found a way of preventing deadlocks in java. The
> methodology(which is code) completely prevents the deadlock from
> occuring by detecting it in advance. This can be used across the
> systems seamlessly.
>
> Kindly let me know what I need to do next. I want this to be part of
> next jdk release. I am writing this email as I have no idea what I
> need to do next to bring it into limelight.

Write it up, maybe present it to a conference, and wait for feedback.
That's how it always works.? If your idea really works, people will
use it.

Andrew.


------------------------------

Message: 4
Date: Mon, 16 Apr 2012 16:48:31 +0200
From: Wolfgang Baltes <wolfgang.baltes at laposte.net<mailto:wolfgang.baltes at laposte.net>>
To: "Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>"
??? <Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>>
Subject: Re: [concurrency-interest] CountedCompleters
Message-ID: <4F8C313F.2080308 at laposte.net<mailto:4F8C313F.2080308 at laposte.net>>
Content-Type: text/plain; charset=ISO-8859-1; format=flowed

Thanks, Doug, for a this addition to the FJ framework. I think that
CountedCompleter will address the needs of an entire class of
applications in an efficient and simple to use manner.

I used the code and noticed that method doJoin() has become more
effective in avoiding blocking threads, and as a result fewer extra
threads are created. I found the performance, compared to
RecursiveAction, to be equal or insignificantly different. This reduces
the problem described in item 3 below.

However, at the same time, CountedCompleter does not fully satisfy the
needs for a class of problems I work on. To this end, here are a few
enhancements I would like to suggest:

1: Symmetrically to onCompletion(), provide
onExceptionalCompletion(Throwable). This allows filtering exception
propagation. There are cases where the propagation of the exception is
desired, and others where a corrective action is taken instead, such as
a retry.

2: As a further enhancement to 1: enable any Throwable, including
checked exceptions. This allows the use of a CountedCompleter as a
CompletionHandler for asynchronous IO operations or as a wrapper for
MethodHandles (which throw Throwable) without adding extra logic to
capture and convert an IO exception. I read the documentation which
explains why this is currently limited to unchecked exceptions. While I
can agree with this in general, I feel the argument is weak for
CountedCompleter if it is there to support asynchronous tasks/events.
(May I add that using this type of framework is not for the
faint-hearted anyway!?)

3: Provide a method to join a task that is not forked and/or not
completable, while minimizing worker thread blocking. For example,
CountedCompleter allows creating chains of dependent tasks. Unless the
ultimate task (the last in the chain) is forked/exists on the task stack
AND can complete because all dependencies are resolved, joining it will
block the worker thread. I noticed (and my testing is limited to a few
test cases and therefore not representative) the blocking and the
creation of other worker threads, ultimately running out of memory or
reaching the thread count limit. If this task is not forked, then
join()/quietlyJoin() will block the worker thread. The following code is
my (inexpert) attempt to provide a remedy. It is based on the assumption
that a task that depends on others for completion is not forked until
all dependencies are resolved. For example, a CountedCompleter
implementing CompletionHandler would fork itself ("implicit fork") when
the IO operation is done. This works very well in my test cases, but at
this time I would not claim it to be universally applicable or error
free. It is shown here more to demonstrate the attempt rather than as a
reference implementation. With access to private data structures, this
can be done more elegantly and more reliably.

? ? ? ? static final int RETRIES = 16;
? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in
microseconds.

? ? ? ? public final void quietlyJoinUnforked() {
? ? ? ? ? ? this.doJoinUnforked(false);
? ? ? ? }

? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
? ? ? ? throws InterruptedException {
? ? ? ? ? ? if (this.doJoinUnforked(true)) {
? ? ? ? ? ? ? ? throw new InterruptedException();
? ? ? ? ? ? }
? ? ? ? }

? ? ? ? public final boolean doJoinUnforked(final boolean interruptibly) {
? ? ? ? ? ? int retries = RETRIES;
? ? ? ? ? ? boolean wasInterrupted = false;
? ? ? ? ? ? while (!this.isDone()) {
? ? ? ? ? ? ? ? ForkJoinTask<?> t;
? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
? ? ? ? ? ? ? ? ? ? if (t == this) {
? ? ? ? ? ? ? ? ? ? ? ? break;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? else {
? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
? ? ? ? ? ? ? ? ? ? ? ? continue;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
? ? ? ? ? ? ? ? ? ? try {
? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is
assumed that
? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task
to retrieve
? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
? ? ? ? ? ? ? ? ? ? ? ? break;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
? ? ? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? ? ? return true;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
? ? ? ? ? ? ? ? ? ? ? ? break;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
? ? ? ? ? ? ? ? ? ? ? ? continue;
? ? ? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? }
? ? ? ? ? ? ? ? retries = RETRIES;
? ? ? ? ? ? }
? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
? ? ? ? ? ? ? ? return false;
? ? ? ? ? ? }
? ? ? ? ? ? return wasInterrupted;
? ? ? ? }

As already mentioned this works quite well in a number of cases. For
example, adding this method to the example MergeSort code and calling
quietlyJoinUnforked(), results in the same overall performance, reduces
the number of extra blocked worker threads to 1 if any (instead of up to
8 for the unmodified code; on a PC with 4 hyper-threading cores/8
threads), and allows for some extra (recreational?) freedom in joining
the right and left sub-tasks in any order. It works in cases where no
sub-task is forked explicitly. I observed that worker thread blocking
only occurs towards the end of a large recursion, suggesting that worker
threads only block - as intended - when there is no other work available
(sometimes while implicit forking has not yet happened).

Wolfgang.



On 2012-04-09 16:16, Doug Lea wrote:
>
> After sitting on multiple variations for months, I committed
> CountedCompleter, a completion-based flavor of ForkJoinTask.
>
> As mentioned a few times over the past year, the main motivation
> is to better support tasks that perform IO or other base
> actions that may (or may not) take a lot of time to execute.
> As is the case with JDK7 async IO and other completion-based
> frameworks, the most common path to efficiency is for such tasks
> to arrange continuation actions that occur upon their completion.
> The main twist for CountedCompleters is that continuations
> might be dependent on multiple actions, not just one. (Or in
> other words, the continuations must be preceded by a specialized,
> "bottom-up" form of join.)
>
> The CountedCompleter abstract class provides a minimal basis
> for these kinds of tasks. While some of the mechanics are
> reminiscent of other FJ-like frameworks such as Intel TBB,
> CountedCompleters are designed to fit smoothly with other
> kinds of ForkJoinTasks (like RecursiveActions), and so still
> allow people to use the more pleasant Future-style conventions
> rather than count-based bottom-up joining unless they need them.
> At the same time, the CountedCompleter class exposes enough
> mechanics to allow all sorts of tweaks that people can use
> to improve performance.
> In particular, in addition to usually being the best way to deal
> with IO etc bound tasks, CountedCompleters sometimes fare better
> than RecursiveActions in programs that entail lots of garbage
> collection because GC can have similar impact on task variability.
>
> Even though targeted for JDK8, versions of CountedCompleter
> appear in the jsr166y and main repositories, not jsr166e. This is
> because they require a non-public hook into modified ForkJoinTask
> exception handling mechanics in order to properly propagate
> exceptional completions. For sources, docs, and jar files, see
> the usual links at
> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>
> The API docs include more details and some examples:
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
>
>
> I also added a few (with more to come) test/demo programs that illustrate
> other usages. See CCBoxedLongSort and CCJacobi in
> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
>
> Please try these out. As always, comments and suggestions
> (hopefully based on usage experience) would be welcome.
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


------------------------------

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


End of Concurrency-interest Digest, Vol 87, Issue 26
****************************************************
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/75746dcb/attachment.html>

------------------------------

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


End of Concurrency-interest Digest, Vol 87, Issue 27
****************************************************




_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/1dc9aec4/attachment-0001.html>

From davidcholmes at aapt.net.au  Mon Apr 16 18:45:27 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 17 Apr 2012 08:45:27 +1000
Subject: [concurrency-interest] Java Deadlock prevented
In-Reply-To: <1334605528.11594.YahooMailNeo@web193406.mail.sg3.yahoo.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEBAJEAA.davidcholmes@aapt.net.au>

(Fixed subject line: everyone - please don't reply to a digest and so screw
up the subject!)

I hate to be a wet blanket but really this is nothing new. Deadlock
detection and prevention is as old as deadlock. Throwing an exception when
you are potentially going to deadlock avoids the deadlock but doesn't
necessarily imply that any corrective action is possible at runtime - you
would need to employ transactional semantics to undo nested state changes,
and all of your code would need to know about the rest to know how the
locking is related and so may be done a different way. Such mechanisms can
be useful development tools, but static analysis can be better at
identifying potential deadlocks, than runtime checks that require the right
timing for the deadlock to be encountered. There's decades of literature on
this.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Rohit Kumar
  Sent: Tuesday, 17 April 2012 5:45 AM
  To: Nathan Reynolds; sandeep.bansal85 at gmail.com; khilan at doc.ic.ac.uk
  Cc: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
87,Issue 27


  The whole idea that I wanted to bring up is that use of synchronized
keyword (implicit locks) can make your program vulnerable to deadlocks as
you have no control over acquisition of locks. Once you use explicit locks
as provided by java concurrent apis, deadlocks can be prevented completely.
And yes, my program uses synchronized keywords, but all in one place and is
completely and thoroughly tested. Usage of synchronized keyword should be
confined.

  My program detects cycles in lock-acquisition graph. The overhead will be
proportional to all the threads that are holding locks but not yet released
and this is not great compared to restarting the server everytime the
deadlock happens.

  I will see if I can present it to any java forum. This is written in java
but the concept can be applied in any programming language.

  Thanks & Regards,
  Rohit Kumar


  From: Nathan Reynolds <nathan.reynolds at oracle.com>
  To: Rohit Kumar <rohitk242 at yahoo.co.in>
  Cc: "concurrency-interest at cs.oswego.edu"
<concurrency-interest at cs.oswego.edu>
  Sent: Tuesday, 17 April 2012 12:52 AM
  Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol 87,
Issue 27



  Synchronized blocks are used every where.  You could use ASM
(http://asm.ow2.org/) to instrument all synchronized blocks (i.e.
monitorenter and monitorexit bytecodes).  Simply put a call to your
deadlock-check just before the monitorenter instruction.  You could also use
this to inject your code into all Locks.

  If you want to avoid the overhead during lock acquisition, you could have
a background thread detect the deadlock and then make one thread involved in
the deadlock throw an exception using Thread.stop(Throwable).  Thread.stop()
is a misnomer in my opinion.  It doesn't stop the thread immediately.
Instead, it causes the thread to throw an exception which unwinds the stack
and if not caught causes the thread to terminate.  It is deprecated because
the exception can be thrown at any point during the execution of the thread
and this makes it very hard to get it bug free.  (It might be deprecated for
other reasons as well.)  However, if you know that the threads are
indefinitely deadlocked, then the thread won't wake up any time and I
naively don't see why using Thread.stop(Throwable) would be a problem.
(Note: I am not sure if Thread.stop() will throw an exception while the
thread is blocked inside monitorenter).

  > Finally where do I need to present this writeup?

  I have never presented anything outside of Oracle Open World.  I have
attended Java One.  Sorry, I can't be of much help.  Since this is Java
code, you might consider presenting at Java One.  I am not sure if that is
appropriate venue, though.


  Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
  Oracle PSR Engineering | Server Technology


  On 4/16/2012 11:36 AM, Rohit Kumar wrote:
    Hans,Nathan,

    I am not aware of anything like Gadara yet. My implementation assumes
that there are no synchnonized keywords (implicit locks) in your program. It
requires you to use explicit locks (e.g. Lock class in java concurrent api).
There is no background thread running here. The deadlock-check happens at
each lock acquisition request; it runs an algorithms internally to see if
there are any cycles formed in the lock-acquisition graph. If yes, it
doesn't let you acquire the lock but throws an exception. You can catch this
exception and take necessary steps to re-acquire all the locks once again or
whatever you want. The program is written in java and it is hardly 270 lines
of code.

    Finally where do I need to present this writeup ?

    Thanks & Regards,
    Rohit Kumar


    From: "concurrency-interest-request at cs.oswego.edu"
<concurrency-interest-request at cs.oswego.edu>
    To: concurrency-interest at cs.oswego.edu
    Sent: Monday, 16 April 2012 10:50 PM
    Subject: Concurrency-interest Digest, Vol 87, Issue 27


    Send Concurrency-interest mailing list submissions to
        concurrency-interest at cs.oswego.edu

    To subscribe or unsubscribe via the World Wide Web, visit
        http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    or, via email, send a message with subject or body 'help' to
        concurrency-interest-request at cs.oswego.edu

    You can reach the person managing the list at
        concurrency-interest-owner at cs.oswego.edu

    When replying, please edit your Subject line so it is more specific
    than "Re: Contents of Concurrency-interest digest..."


    Today's Topics:

      1. Re: CountedCompleters (Wolfgang Baltes)
      2. Re: Java Deadlocks prevented (Boehm, Hans)
      3. Re: Java Deadlocks prevented (Nathan Reynolds)
      4. Re: Concurrency-interest Digest, Vol 87,    Issue 26 (Java
          deadlock prevented) (Rohit Kumar)


    ----------------------------------------------------------------------

    Message: 1
    Date: Mon, 16 Apr 2012 18:01:50 +0200
    From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
    To: concurrency-interest at cs.oswego.edu
    Subject: Re: [concurrency-interest] CountedCompleters
    Message-ID: <4F8C426E.6090704 at laposte.net>
    Content-Type: text/plain; charset=ISO-8859-1; format=flowed

    I apologize for a mistake in the last paragraph of my memo: using
    quietlyJoinUnforked() in the SDK7 sample code for MergeSort does have a
    non-negligible performance impact (not no impact as stated). There is
    better performance in case of recursions which produce many tasks that
    are not explicitly forked, and it reduces the number of extra threads
    significantly, allowing larger problems to be solved with smaller memory
    footprint.

    Wolfgang.

    On 2012-04-16 16:48, Wolfgang Baltes wrote:
    > Thanks, Doug, for a this addition to the FJ framework. I think that
    > CountedCompleter will address the needs of an entire class of
    > applications in an efficient and simple to use manner.
    >
    > I used the code and noticed that method doJoin() has become more
    > effective in avoiding blocking threads, and as a result fewer extra
    > threads are created. I found the performance, compared to
    > RecursiveAction, to be equal or insignificantly different. This
    > reduces the problem described in item 3 below.
    >
    > However, at the same time, CountedCompleter does not fully satisfy the
    > needs for a class of problems I work on. To this end, here are a few
    > enhancements I would like to suggest:
    >
    > 1: Symmetrically to onCompletion(), provide
    > onExceptionalCompletion(Throwable). This allows filtering exception
    > propagation. There are cases where the propagation of the exception is
    > desired, and others where a corrective action is taken instead, such
    > as a retry.
    >
    > 2: As a further enhancement to 1: enable any Throwable, including
    > checked exceptions. This allows the use of a CountedCompleter as a
    > CompletionHandler for asynchronous IO operations or as a wrapper for
    > MethodHandles (which throw Throwable) without adding extra logic to
    > capture and convert an IO exception. I read the documentation which
    > explains why this is currently limited to unchecked exceptions. While
    > I can agree with this in general, I feel the argument is weak for
    > CountedCompleter if it is there to support asynchronous tasks/events.
    > (May I add that using this type of framework is not for the
    > faint-hearted anyway!?)
    >
    > 3: Provide a method to join a task that is not forked and/or not
    > completable, while minimizing worker thread blocking. For example,
    > CountedCompleter allows creating chains of dependent tasks. Unless the
    > ultimate task (the last in the chain) is forked/exists on the task
    > stack AND can complete because all dependencies are resolved, joining
    > it will block the worker thread. I noticed (and my testing is limited
    > to a few test cases and therefore not representative) the blocking and
    > the creation of other worker threads, ultimately running out of memory
    > or reaching the thread count limit. If this task is not forked, then
    > join()/quietlyJoin() will block the worker thread. The following code
    > is my (inexpert) attempt to provide a remedy. It is based on the
    > assumption that a task that depends on others for completion is not
    > forked until all dependencies are resolved. For example, a
    > CountedCompleter implementing CompletionHandler would fork itself
    > ("implicit fork") when the IO operation is done. This works very well
    > in my test cases, but at this time I would not claim it to be
    > universally applicable or error free. It is shown here more to
    > demonstrate the attempt rather than as a reference implementation.
    > With access to private data structures, this can be done more
    > elegantly and more reliably.
    >
    >        static final int RETRIES = 16;
    >        static final long WAIT_TIMEOUT = 1_000;    // Timeout in
    > microseconds.
    >
    >        public final void quietlyJoinUnforked() {
    >            this.doJoinUnforked(false);
    >        }
    >
    >        public final void quietlyJoinUnforkedInterruptibly()
    >        throws InterruptedException {
    >            if (this.doJoinUnforked(true)) {
    >                throw new InterruptedException();
    >            }
    >        }
    >
    >        public final boolean doJoinUnforked(final boolean
    > interruptibly) {
    >            int retries = RETRIES;
    >            boolean wasInterrupted = false;
    >            while (!this.isDone()) {
    >                ForkJoinTask<?> t;
    >                if ((t = pollTask()) != null) {
    >                    t.quietlyInvoke();
    >                    if (t == this) {
    >                        break;
    >                    }
    >                }
    >                else {
    >                    if (retries-- > 0) {
    >                        Thread.yield();
    >                        continue;
    >                    }
    >                    wasInterrupted = Thread.interrupted();
    >                    try {
    >                        // get(...) is used as a timed join(). It is
    > assumed that
    >                        // other code will perform get() on this task
    > to retrieve
    >                        // the task's result or exception.
    >                        this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
    >                        break;
    >                    }
    >                    catch (final InterruptedException consumed) {
    >                        if (!interruptibly) {
    >                            wasInterrupted = true;
    >                            continue;
    >                        }
    >                        return true;
    >                    }
    >                    catch (final ExecutionException ignored) {
    >                        // See comment on get() above.
    >                        break;
    >                    }
    >                    catch (final TimeoutException ignored) {
    >                        continue;
    >                    }
    >                }
    >                retries = RETRIES;
    >            }
    >            if (wasInterrupted && !interruptibly) {
    >                Thread.currentThread().interrupt();
    >                return false;
    >            }
    >            return wasInterrupted;
    >        }
    >
    > As already mentioned this works quite well in a number of cases. For
    > example, adding this method to the example MergeSort code and calling
    > quietlyJoinUnforked(), results in the same overall performance,
    > reduces the number of extra blocked worker threads to 1 if any
    > (instead of up to 8 for the unmodified code; on a PC with 4
    > hyper-threading cores/8 threads), and allows for some extra
    > (recreational?) freedom in joining the right and left sub-tasks in any
    > order. It works in cases where no sub-task is forked explicitly. I
    > observed that worker thread blocking only occurs towards the end of a
    > large recursion, suggesting that worker threads only block - as
    > intended - when there is no other work available (sometimes while
    > implicit forking has not yet happened).
    >
    > Wolfgang.
    >
    >
    >
    > On 2012-04-09 16:16, Doug Lea wrote:
    >>
    >> After sitting on multiple variations for months, I committed
    >> CountedCompleter, a completion-based flavor of ForkJoinTask.
    >>
    >> As mentioned a few times over the past year, the main motivation
    >> is to better support tasks that perform IO or other base
    >> actions that may (or may not) take a lot of time to execute.
    >> As is the case with JDK7 async IO and other completion-based
    >> frameworks, the most common path to efficiency is for such tasks
    >> to arrange continuation actions that occur upon their completion.
    >> The main twist for CountedCompleters is that continuations
    >> might be dependent on multiple actions, not just one. (Or in
    >> other words, the continuations must be preceded by a specialized,
    >> "bottom-up" form of join.)
    >>
    >> The CountedCompleter abstract class provides a minimal basis
    >> for these kinds of tasks. While some of the mechanics are
    >> reminiscent of other FJ-like frameworks such as Intel TBB,
    >> CountedCompleters are designed to fit smoothly with other
    >> kinds of ForkJoinTasks (like RecursiveActions), and so still
    >> allow people to use the more pleasant Future-style conventions
    >> rather than count-based bottom-up joining unless they need them.
    >> At the same time, the CountedCompleter class exposes enough
    >> mechanics to allow all sorts of tweaks that people can use
    >> to improve performance.
    >> In particular, in addition to usually being the best way to deal
    >> with IO etc bound tasks, CountedCompleters sometimes fare better
    >> than RecursiveActions in programs that entail lots of garbage
    >> collection because GC can have similar impact on task variability.
    >>
    >> Even though targeted for JDK8, versions of CountedCompleter
    >> appear in the jsr166y and main repositories, not jsr166e. This is
    >> because they require a non-public hook into modified ForkJoinTask
    >> exception handling mechanics in order to properly propagate
    >> exceptional completions. For sources, docs, and jar files, see
    >> the usual links at
    >> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
    >>
    >> The API docs include more details and some examples:
    >>
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCom
pleter.html
    >>
    >>
    >> I also added a few (with more to come) test/demo programs that
    >> illustrate
    >> other usages. See CCBoxedLongSort and CCJacobi in
    >> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
    >>
    >> Please try these out. As always, comments and suggestions
    >> (hopefully based on usage experience) would be welcome.
    >>
    >> -Doug
    >>
    >>
    >> _______________________________________________
    >> Concurrency-interest mailing list
    >> Concurrency-interest at cs.oswego.edu
    >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    >>
    > _______________________________________________
    > Concurrency-interest mailing list
    > Concurrency-interest at cs.oswego.edu
    > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    >


    ------------------------------

    Message: 2
    Date: Mon, 16 Apr 2012 16:38:00 +0000
    From: "Boehm, Hans" <hans.boehm at hp.com>
    To: Andrew Haley <aph at redhat.com>,
        "concurrency-interest at cs.oswego.edu"
        <concurrency-interest at cs.oswego.edu>
    Subject: Re: [concurrency-interest] Java Deadlocks prevented
    Message-ID:
        <A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hpqcorp.n
et>

    Content-Type: text/plain; charset="us-ascii"

    Important questions to consider when you write it up:

    How does it compare to something like Gadara that uses whole program
analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it
doesn't need whole program analysis.)  Other deadlock avoidance schemes?

    Once you detect a potential deadlock, how do you recover?  Or can you
always schedule so that the possibility doesn't arise?

    Hans

    > -----Original Message-----
    > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
    > interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
    > Sent: Monday, April 16, 2012 4:34 AM
    > To: concurrency-interest at cs.oswego.edu
    > Subject: Re: [concurrency-interest] Java Deadlocks prevented
    >
    > On 04/16/2012 12:06 PM, Rohit Kumar wrote:
    >
    > > I have found a way of preventing deadlocks in java. The
    > > methodology(which is code) completely prevents the deadlock from
    > > occuring by detecting it in advance. This can be used across the
    > > systems seamlessly.
    > >
    > > Kindly let me know what I need to do next. I want this to be part of
    > > next jdk release. I am writing this email as I have no idea what I
    > > need to do next to bring it into limelight.
    >
    > Write it up, maybe present it to a conference, and wait for feedback.
    > That's how it always works.  If your idea really works, people will
    > use it.
    >
    > Andrew.
    > _______________________________________________
    > Concurrency-interest mailing list
    > Concurrency-interest at cs.oswego.edu
    > http://cs.oswego.edu/mailman/listinfo/concurrency-interest



    ------------------------------

    Message: 3
    Date: Mon, 16 Apr 2012 10:11:00 -0700
    From: Nathan Reynolds <nathan.reynolds at oracle.com>
    To: "Boehm, Hans" <hans.boehm at hp.com>
    Cc: "concurrency-interest at cs.oswego.edu"
        <concurrency-interest at cs.oswego.edu>
    Subject: Re: [concurrency-interest] Java Deadlocks prevented
    Message-ID: <4F8C52A4.70002 at oracle.com>
    Content-Type: text/plain; charset="iso-8859-1"; Format="flowed"

    Deadlock prevention is very valuable.  It means deadlock prone code
    won't bring down a production server and cost the company millions in
    down time.  It means consumers won't kill the process and request a
refund.

    How much does deadlock prevention cost?  Is the cost on the thread that
    acquires locks or is it in a background thread?

    Each time processors or systems increase the number of cores, I find we
    have to do a round of lock contention fixing.  I have only seen 1 lock
    at a time be the bottleneck in the system.  Does deadlock prevention
    increase the critical region of locks?  If so, this will definitely
    reduce the scalability of the system if it impacts the 1 bottlenecking
lock.

    Lock performance is a very important consideration.  Locks have evolved
    from fat locks (i.e trips into the OS kernel) to thin locks (i.e. spin
    and CAS in user mode) to biased/lazy locks (i.e. no CAS and an
    indefinite lock owner).  All of this was done to reduce the performance
    overhead of locks.  How does deadlock prevention impact the performance
    of biased, thin and fat locks?  I am not as concerned about fat lock
    performance since most of the time the thread is going to block.

    Nathan Reynolds
    <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
    Consulting Member of Technical Staff | 602.333.9091
    Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

    On 4/16/2012 9:38 AM, Boehm, Hans wrote:
    > Important questions to consider when you write it up:
    >
    > How does it compare to something like Gadara that uses whole program
analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it
doesn't need whole program analysis.)  Other deadlock avoidance schemes?
    >
    > Once you detect a potential deadlock, how do you recover?  Or can you
always schedule so that the possibility doesn't arise?
    >
    > Hans
    >
    >> -----Original Message-----
    >> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
    >> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
    >> Sent: Monday, April 16, 2012 4:34 AM
    >> To: concurrency-interest at cs.oswego.edu
    >> Subject: Re: [concurrency-interest] Java Deadlocks prevented
    >>
    >> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
    >>
    >>> I have found a way of preventing deadlocks in java. The
    >>> methodology(which is code) completely prevents the deadlock from
    >>> occuring by detecting it in advance. This can be used across the
    >>> systems seamlessly.
    >>>
    >>> Kindly let me know what I need to do next. I want this to be part of
    >>> next jdk release. I am writing this email as I have no idea what I
    >>> need to do next to bring it into limelight.
    >> Write it up, maybe present it to a conference, and wait for feedback.
    >> That's how it always works.  If your idea really works, people will
    >> use it.
    >>
    >> Andrew.
    >> _______________________________________________
    >> Concurrency-interest mailing list
    >> Concurrency-interest at cs.oswego.edu
    >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > _______________________________________________
    > Concurrency-interest mailing list
    > Concurrency-interest at cs.oswego.edu
    > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    -------------- next part --------------
    An HTML attachment was scrubbed...
    URL:
<http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/7e
a89bb3/attachment-0001.html>

    ------------------------------

    Message: 4
    Date: Tue, 17 Apr 2012 01:20:15 +0800 (SGT)
    From: Rohit Kumar <rohitk242 at yahoo.co.in>
    To: "concurrency-interest at cs.oswego.edu"
        <concurrency-interest at cs.oswego.edu>
    Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
        87,    Issue 26 (Java deadlock prevented)
    Message-ID:
        <1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com>
    Content-Type: text/plain; charset="iso-8859-1"

    Andrew:
    ?
    Thanks for the reply. Can you kindly let me know where do I need to
present it ? Where will the conference be held ? Can I present it online or
I have to come in person ?
    ?
    Waiting for your early reply once again.
    ?
    Thanks & Regards,
    Rohit Kumar

    From: "concurrency-interest-request at cs.oswego.edu"
<concurrency-interest-request at cs.oswego.edu>
    To: concurrency-interest at cs.oswego.edu
    Sent: Monday, 16 April 2012 9:30 PM
    Subject: Concurrency-interest Digest, Vol 87, Issue 26

    Send Concurrency-interest mailing list submissions to
    ??? concurrency-interest at cs.oswego.edu

    To subscribe or unsubscribe via the World Wide Web, visit
    ??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    or, via email, send a message with subject or body 'help' to
    ??? concurrency-interest-request at cs.oswego.edu

    You can reach the person managing the list at
    ??? concurrency-interest-owner at cs.oswego.edu

    When replying, please edit your Subject line so it is more specific
    than "Re: Contents of Concurrency-interest digest..."


    Today's Topics:

    ? 1. (no subject) (Rohit Kumar)
    ? 2. Java Deadlocks prevented (Rohit Kumar)
    ? 3. Re: Java Deadlocks prevented (Andrew Haley)
    ? 4. Re: CountedCompleters (Wolfgang Baltes)


    ----------------------------------------------------------------------

    Message: 1
    Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT)
    From: Rohit Kumar <rohitk242 at yahoo.co.in>
    To: "concurrency-interest at cs.oswego.edu"
    ??? <concurrency-interest at cs.oswego.edu>
    Cc: "concurrency-interest-owner at cs.oswego.edu"
    ??? <concurrency-interest-owner at cs.oswego.edu>
    Subject: [concurrency-interest] (no subject)
    Message-ID:
    ??? <1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com>
    Content-Type: text/plain; charset="iso-8859-1"

    Hi All,
    ?
    I have found a way of preventing deadlocks in java. The
methodology(which is code) completely prevents the deadlock from accuring by
detecting it in advance. This can be used across the systems seamlessly.
    ?
    Kindly let me know what I need to do next. I want this to be part of
next jdk release.
    ?
    Thanks & Regards,
    Rohit Kumar
    -------------- next part --------------
    An HTML attachment was scrubbed...
    URL:
<http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/a6
588341/attachment-0001.html>

    ------------------------------

    Message: 2
    Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)
    From: Rohit Kumar <rohitk242 at yahoo.co.in>
    To: "concurrency-interest at cs.oswego.edu"
    ??? <concurrency-interest at cs.oswego.edu>
    Cc: "concurrency-interest-owner at cs.oswego.edu"
    ??? <concurrency-interest-owner at cs.oswego.edu>
    Subject: [concurrency-interest] Java Deadlocks prevented
    Message-ID:
    ??? <1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com>
    Content-Type: text/plain; charset="utf-8"



    Hi All,

    I have found a way of preventing deadlocks in java. The
methodology(which is code) completely prevents the deadlock from occuring by
detecting it in advance. This can be used across the systems seamlessly.

    Kindly let me know what I need to do next. I want this to be part of
next jdk release. I am writing this email as I have no idea what I need to
do next to bring it into limelight.

    Thanks & Regards,
    Rohit Kumar
    -------------- next part --------------
    An HTML attachment was scrubbed...
    URL:
<http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/06
4a4873/attachment-0001.html>

    ------------------------------

    Message: 3
    Date: Mon, 16 Apr 2012 12:33:45 +0100
    From: Andrew Haley <aph at redhat.com>
    To: concurrency-interest at cs.oswego.edu
    Subject: Re: [concurrency-interest] Java Deadlocks prevented
    Message-ID: <4F8C0399.8040301 at redhat.com>
    Content-Type: text/plain; charset=ISO-8859-1

    On 04/16/2012 12:06 PM, Rohit Kumar wrote:

    > I have found a way of preventing deadlocks in java. The
    > methodology(which is code) completely prevents the deadlock from
    > occuring by detecting it in advance. This can be used across the
    > systems seamlessly.
    >
    > Kindly let me know what I need to do next. I want this to be part of
    > next jdk release. I am writing this email as I have no idea what I
    > need to do next to bring it into limelight.

    Write it up, maybe present it to a conference, and wait for feedback.
    That's how it always works.? If your idea really works, people will
    use it.

    Andrew.


    ------------------------------

    Message: 4
    Date: Mon, 16 Apr 2012 16:48:31 +0200
    From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
    To: "Concurrency-interest at cs.oswego.edu"
    ??? <Concurrency-interest at cs.oswego.edu>
    Subject: Re: [concurrency-interest] CountedCompleters
    Message-ID: <4F8C313F.2080308 at laposte.net>
    Content-Type: text/plain; charset=ISO-8859-1; format=flowed

    Thanks, Doug, for a this addition to the FJ framework. I think that
    CountedCompleter will address the needs of an entire class of
    applications in an efficient and simple to use manner.

    I used the code and noticed that method doJoin() has become more
    effective in avoiding blocking threads, and as a result fewer extra
    threads are created. I found the performance, compared to
    RecursiveAction, to be equal or insignificantly different. This reduces
    the problem described in item 3 below.

    However, at the same time, CountedCompleter does not fully satisfy the
    needs for a class of problems I work on. To this end, here are a few
    enhancements I would like to suggest:

    1: Symmetrically to onCompletion(), provide
    onExceptionalCompletion(Throwable). This allows filtering exception
    propagation. There are cases where the propagation of the exception is
    desired, and others where a corrective action is taken instead, such as
    a retry.

    2: As a further enhancement to 1: enable any Throwable, including
    checked exceptions. This allows the use of a CountedCompleter as a
    CompletionHandler for asynchronous IO operations or as a wrapper for
    MethodHandles (which throw Throwable) without adding extra logic to
    capture and convert an IO exception. I read the documentation which
    explains why this is currently limited to unchecked exceptions. While I
    can agree with this in general, I feel the argument is weak for
    CountedCompleter if it is there to support asynchronous tasks/events.
    (May I add that using this type of framework is not for the
    faint-hearted anyway!?)

    3: Provide a method to join a task that is not forked and/or not
    completable, while minimizing worker thread blocking. For example,
    CountedCompleter allows creating chains of dependent tasks. Unless the
    ultimate task (the last in the chain) is forked/exists on the task stack
    AND can complete because all dependencies are resolved, joining it will
    block the worker thread. I noticed (and my testing is limited to a few
    test cases and therefore not representative) the blocking and the
    creation of other worker threads, ultimately running out of memory or
    reaching the thread count limit. If this task is not forked, then
    join()/quietlyJoin() will block the worker thread. The following code is
    my (inexpert) attempt to provide a remedy. It is based on the assumption
    that a task that depends on others for completion is not forked until
    all dependencies are resolved. For example, a CountedCompleter
    implementing CompletionHandler would fork itself ("implicit fork") when
    the IO operation is done. This works very well in my test cases, but at
    this time I would not claim it to be universally applicable or error
    free. It is shown here more to demonstrate the attempt rather than as a
    reference implementation. With access to private data structures, this
    can be done more elegantly and more reliably.

    ? ? ? ? static final int RETRIES = 16;
    ? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in
    microseconds.

    ? ? ? ? public final void quietlyJoinUnforked() {
    ? ? ? ? ? ? this.doJoinUnforked(false);
    ? ? ? ? }

    ? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
    ? ? ? ? throws InterruptedException {
    ? ? ? ? ? ? if (this.doJoinUnforked(true)) {
    ? ? ? ? ? ? ? ? throw new InterruptedException();
    ? ? ? ? ? ? }
    ? ? ? ? }

    ? ? ? ? public final boolean doJoinUnforked(final boolean interruptibly)
{
    ? ? ? ? ? ? int retries = RETRIES;
    ? ? ? ? ? ? boolean wasInterrupted = false;
    ? ? ? ? ? ? while (!this.isDone()) {
    ? ? ? ? ? ? ? ? ForkJoinTask<?> t;
    ? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
    ? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
    ? ? ? ? ? ? ? ? ? ? if (t == this) {
    ? ? ? ? ? ? ? ? ? ? ? ? break;
    ? ? ? ? ? ? ? ? ? ? }
    ? ? ? ? ? ? ? ? }
    ? ? ? ? ? ? ? ? else {
    ? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
    ? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
    ? ? ? ? ? ? ? ? ? ? ? ? continue;
    ? ? ? ? ? ? ? ? ? ? }
    ? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
    ? ? ? ? ? ? ? ? ? ? try {
    ? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is
    assumed that
    ? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task
    to retrieve
    ? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
    ? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
    ? ? ? ? ? ? ? ? ? ? ? ? break;
    ? ? ? ? ? ? ? ? ? ? }
    ? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
    ? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
    ? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
    ? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
    ? ? ? ? ? ? ? ? ? ? ? ? }
    ? ? ? ? ? ? ? ? ? ? ? ? return true;
    ? ? ? ? ? ? ? ? ? ? }
    ? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
    ? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
    ? ? ? ? ? ? ? ? ? ? ? ? break;
    ? ? ? ? ? ? ? ? ? ? }
    ? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
    ? ? ? ? ? ? ? ? ? ? ? ? continue;
    ? ? ? ? ? ? ? ? ? ? }
    ? ? ? ? ? ? ? ? }
    ? ? ? ? ? ? ? ? retries = RETRIES;
    ? ? ? ? ? ? }
    ? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
    ? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
    ? ? ? ? ? ? ? ? return false;
    ? ? ? ? ? ? }
    ? ? ? ? ? ? return wasInterrupted;
    ? ? ? ? }

    As already mentioned this works quite well in a number of cases. For
    example, adding this method to the example MergeSort code and calling
    quietlyJoinUnforked(), results in the same overall performance, reduces
    the number of extra blocked worker threads to 1 if any (instead of up to
    8 for the unmodified code; on a PC with 4 hyper-threading cores/8
    threads), and allows for some extra (recreational?) freedom in joining
    the right and left sub-tasks in any order. It works in cases where no
    sub-task is forked explicitly. I observed that worker thread blocking
    only occurs towards the end of a large recursion, suggesting that worker
    threads only block - as intended - when there is no other work available
    (sometimes while implicit forking has not yet happened).

    Wolfgang.



    On 2012-04-09 16:16, Doug Lea wrote:
    >
    > After sitting on multiple variations for months, I committed
    > CountedCompleter, a completion-based flavor of ForkJoinTask.
    >
    > As mentioned a few times over the past year, the main motivation
    > is to better support tasks that perform IO or other base
    > actions that may (or may not) take a lot of time to execute.
    > As is the case with JDK7 async IO and other completion-based
    > frameworks, the most common path to efficiency is for such tasks
    > to arrange continuation actions that occur upon their completion.
    > The main twist for CountedCompleters is that continuations
    > might be dependent on multiple actions, not just one. (Or in
    > other words, the continuations must be preceded by a specialized,
    > "bottom-up" form of join.)
    >
    > The CountedCompleter abstract class provides a minimal basis
    > for these kinds of tasks. While some of the mechanics are
    > reminiscent of other FJ-like frameworks such as Intel TBB,
    > CountedCompleters are designed to fit smoothly with other
    > kinds of ForkJoinTasks (like RecursiveActions), and so still
    > allow people to use the more pleasant Future-style conventions
    > rather than count-based bottom-up joining unless they need them.
    > At the same time, the CountedCompleter class exposes enough
    > mechanics to allow all sorts of tweaks that people can use
    > to improve performance.
    > In particular, in addition to usually being the best way to deal
    > with IO etc bound tasks, CountedCompleters sometimes fare better
    > than RecursiveActions in programs that entail lots of garbage
    > collection because GC can have similar impact on task variability.
    >
    > Even though targeted for JDK8, versions of CountedCompleter
    > appear in the jsr166y and main repositories, not jsr166e. This is
    > because they require a non-public hook into modified ForkJoinTask
    > exception handling mechanics in order to properly propagate
    > exceptional completions. For sources, docs, and jar files, see
    > the usual links at
    > http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
    >
    > The API docs include more details and some examples:
    >
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCom
pleter.html
    >
    >
    > I also added a few (with more to come) test/demo programs that
illustrate
    > other usages. See CCBoxedLongSort and CCJacobi in
    > http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
    >
    > Please try these out. As always, comments and suggestions
    > (hopefully based on usage experience) would be welcome.
    >
    > -Doug
    >
    >
    > _______________________________________________
    > Concurrency-interest mailing list
    > Concurrency-interest at cs.oswego.edu
    > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    >


    ------------------------------

    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at cs.oswego.edu
    http://cs.oswego.edu/mailman/listinfo/concurrency-interest


    End of Concurrency-interest Digest, Vol 87, Issue 26
    ****************************************************
    -------------- next part --------------
    An HTML attachment was scrubbed...
    URL:
<http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/75
746dcb/attachment.html>

    ------------------------------

    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at cs.oswego.edu
    http://cs.oswego.edu/mailman/listinfo/concurrency-interest


    End of Concurrency-interest Digest, Vol 87, Issue 27
    ****************************************************






_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/f6329099/attachment-0001.html>

From khilan at doc.ic.ac.uk  Mon Apr 16 19:03:05 2012
From: khilan at doc.ic.ac.uk (Khilan Gudka)
Date: Tue, 17 Apr 2012 00:03:05 +0100
Subject: [concurrency-interest] Java Deadlock prevented
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEBAJEAA.davidcholmes@aapt.net.au>
References: <1334605528.11594.YahooMailNeo@web193406.mail.sg3.yahoo.com>
	<NFBBKALFDCPFIDBNKAPCKEBAJEAA.davidcholmes@aapt.net.au>
Message-ID: <CAEtTSAbwZB=xg+CxvQKBNiO5_mM71msTf9vSeTw7bzmysEqaqg@mail.gmail.com>

Yep I think in general what you want is either 1) some mechanism to recover
from a deadlock, like a transactional rollback, but then you have the
overhead of keeping track of all your changes or 2) to be able to ensure
that deadlock never occurs, either through static analysis and/or having a
global ordering on locks. However, I think applying principles ala JCIP are
difficult given that locks are not modular. I mean, is it enough to ensure
global ordering of locks in client code to ensure deadlock-freedom of the
entire system (i.e. client + library)?

--
Khilan Gudka
PhD Student
Department of Computing
Imperial College London
http://www.doc.ic.ac.uk/~khilan/



On 16 April 2012 23:45, David Holmes <davidcholmes at aapt.net.au> wrote:

> **
> (Fixed subject line: everyone - please don't reply to a digest and so
> screw up the subject!)
>
> I hate to be a wet blanket but really this is nothing new. Deadlock
> detection and prevention is as old as deadlock. Throwing an exception when
> you are potentially going to deadlock avoids the deadlock but doesn't
> necessarily imply that any corrective action is possible at runtime - you
> would need to employ transactional semantics to undo nested state changes,
> and all of your code would need to know about the rest to know how the
> locking is related and so may be done a different way. Such mechanisms can
> be useful development tools, but static analysis can be better at
> identifying potential deadlocks, than runtime checks that require the right
> timing for the deadlock to be encountered. There's decades of literature on
> this.
>
> David Holmes
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Rohit Kumar
> *Sent:* Tuesday, 17 April 2012 5:45 AM
> *To:* Nathan Reynolds; sandeep.bansal85 at gmail.com; khilan at doc.ic.ac.uk
> *Cc:* concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Concurrency-interest Digest, Vol
> 87,Issue 27
>
>  The whole idea that I wanted to bring up is that use of synchronized
> keyword (implicit locks) can make your program vulnerable to deadlocks as
> you have no control over acquisition of locks. Once you use explicit locks
> as provided by java concurrent apis, deadlocks can be prevented completely.
> And yes, my program uses synchronized keywords, but all in one place and is
> completely and thoroughly tested. Usage of synchronized keyword should be
> confined.
>
> My program detects cycles in lock-acquisition graph. The overhead will be
> proportional to all the threads that are holding locks but not yet released and
> this is not great compared to restarting the server everytime the deadlock
> happens.
>
> I will see if I can present it to any java forum. This is written in java
> but the concept can be applied in any programming language.
>
> Thanks & Regards,
> Rohit Kumar
>
>   *From:* Nathan Reynolds <nathan.reynolds at oracle.com>
> *To:* Rohit Kumar <rohitk242 at yahoo.co.in>
> *Cc:* "concurrency-interest at cs.oswego.edu" <
> concurrency-interest at cs.oswego.edu>
> *Sent:* Tuesday, 17 April 2012 12:52 AM
> *Subject:* Re: [concurrency-interest] Concurrency-interest Digest, Vol
> 87, Issue 27
>
>  Synchronized blocks are used every where.  You could use ASM (
> http://asm.ow2.org/) to instrument all synchronized blocks (i.e.
> monitorenter and monitorexit bytecodes).  Simply put a call to your
> deadlock-check just before the monitorenter instruction.  You could also
> use this to inject your code into all Locks.
>
> If you want to avoid the overhead during lock acquisition, you could have
> a background thread detect the deadlock and then make one thread involved
> in the deadlock throw an exception using Thread.stop(Throwable).
> Thread.stop() is a misnomer in my opinion.  It doesn't stop the thread
> immediately.  Instead, it causes the thread to throw an exception which
> unwinds the stack and if not caught causes the thread to terminate.  It is
> deprecated because the exception can be thrown at any point during the
> execution of the thread and this makes it very hard to get it bug free.
> (It might be deprecated for other reasons as well.)  However, if you know
> that the threads are indefinitely deadlocked, then the thread won't wake up
> any time and I naively don't see why using Thread.stop(Throwable) would be
> a problem.  (Note: I am not sure if Thread.stop() will throw an exception
> while the thread is blocked inside monitorenter).
>
> > Finally where do I need to present this writeup?
>
> I have never presented anything outside of Oracle Open World.  I have
> attended Java One.  Sorry, I can't be of much help.  Since this is Java
> code, you might consider presenting at Java One.  I am not sure if that is
> appropriate venue, though.
>
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
> On 4/16/2012 11:36 AM, Rohit Kumar wrote:
>
>  Hans,Nathan,
>
> I am not aware of anything like Gadara yet. My implementation assumes that
> there are no synchnonized keywords (implicit locks) in your program. It
> requires you to use explicit locks (e.g. Lock class in java concurrent
> api). There is no background thread running here. The deadlock-check
> happens at each lock acquisition request; it runs an algorithms internally
> to see if there are any cycles formed in the lock-acquisition graph. If
> yes, it doesn't let you acquire the lock but throws an exception. You can
> catch this exception and take necessary steps to re-acquire all the locks
> once again or whatever you want. The program is written in java and it is
> hardly 270 lines of code.
>
> Finally where do I need to present this writeup ?
>
> Thanks & Regards,
> Rohit Kumar
>
>  *From:* "concurrency-interest-request at cs.oswego.edu"<concurrency-interest-request at cs.oswego.edu>
> <concurrency-interest-request at cs.oswego.edu><concurrency-interest-request at cs.oswego.edu>
> *To:* concurrency-interest at cs.oswego.edu
> *Sent:* Monday, 16 April 2012 10:50 PM
> *Subject:* Concurrency-interest Digest, Vol 87, Issue 27
>
> Send Concurrency-interest mailing list submissions to
>     concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
>     concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
>     concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>   1. Re: CountedCompleters (Wolfgang Baltes)
>   2. Re: Java Deadlocks prevented (Boehm, Hans)
>   3. Re: Java Deadlocks prevented (Nathan Reynolds)
>   4. Re: Concurrency-interest Digest, Vol 87,    Issue 26 (Java
>       deadlock prevented) (Rohit Kumar)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 16 Apr 2012 18:01:50 +0200
> From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] CountedCompleters
> Message-ID: <4F8C426E.6090704 at laposte.net>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> I apologize for a mistake in the last paragraph of my memo: using
> quietlyJoinUnforked() in the SDK7 sample code for MergeSort does have a
> non-negligible performance impact (not no impact as stated). There is
> better performance in case of recursions which produce many tasks that
> are not explicitly forked, and it reduces the number of extra threads
> significantly, allowing larger problems to be solved with smaller memory
> footprint.
>
> Wolfgang.
>
> On 2012-04-16 16:48, Wolfgang Baltes wrote:
> > Thanks, Doug, for a this addition to the FJ framework. I think that
> > CountedCompleter will address the needs of an entire class of
> > applications in an efficient and simple to use manner.
> >
> > I used the code and noticed that method doJoin() has become more
> > effective in avoiding blocking threads, and as a result fewer extra
> > threads are created. I found the performance, compared to
> > RecursiveAction, to be equal or insignificantly different. This
> > reduces the problem described in item 3 below.
> >
> > However, at the same time, CountedCompleter does not fully satisfy the
> > needs for a class of problems I work on. To this end, here are a few
> > enhancements I would like to suggest:
> >
> > 1: Symmetrically to onCompletion(), provide
> > onExceptionalCompletion(Throwable). This allows filtering exception
> > propagation. There are cases where the propagation of the exception is
> > desired, and others where a corrective action is taken instead, such
> > as a retry.
> >
> > 2: As a further enhancement to 1: enable any Throwable, including
> > checked exceptions. This allows the use of a CountedCompleter as a
> > CompletionHandler for asynchronous IO operations or as a wrapper for
> > MethodHandles (which throw Throwable) without adding extra logic to
> > capture and convert an IO exception. I read the documentation which
> > explains why this is currently limited to unchecked exceptions. While
> > I can agree with this in general, I feel the argument is weak for
> > CountedCompleter if it is there to support asynchronous tasks/events.
> > (May I add that using this type of framework is not for the
> > faint-hearted anyway!?)
> >
> > 3: Provide a method to join a task that is not forked and/or not
> > completable, while minimizing worker thread blocking. For example,
> > CountedCompleter allows creating chains of dependent tasks. Unless the
> > ultimate task (the last in the chain) is forked/exists on the task
> > stack AND can complete because all dependencies are resolved, joining
> > it will block the worker thread. I noticed (and my testing is limited
> > to a few test cases and therefore not representative) the blocking and
> > the creation of other worker threads, ultimately running out of memory
> > or reaching the thread count limit. If this task is not forked, then
> > join()/quietlyJoin() will block the worker thread. The following code
> > is my (inexpert) attempt to provide a remedy. It is based on the
> > assumption that a task that depends on others for completion is not
> > forked until all dependencies are resolved. For example, a
> > CountedCompleter implementing CompletionHandler would fork itself
> > ("implicit fork") when the IO operation is done. This works very well
> > in my test cases, but at this time I would not claim it to be
> > universally applicable or error free. It is shown here more to
> > demonstrate the attempt rather than as a reference implementation.
> > With access to private data structures, this can be done more
> > elegantly and more reliably.
> >
> >        static final int RETRIES = 16;
> >        static final long WAIT_TIMEOUT = 1_000;    // Timeout in
> > microseconds.
> >
> >        public final void quietlyJoinUnforked() {
> >            this.doJoinUnforked(false);
> >        }
> >
> >        public final void quietlyJoinUnforkedInterruptibly()
> >        throws InterruptedException {
> >            if (this.doJoinUnforked(true)) {
> >                throw new InterruptedException();
> >            }
> >        }
> >
> >        public final boolean doJoinUnforked(final boolean
> > interruptibly) {
> >            int retries = RETRIES;
> >            boolean wasInterrupted = false;
> >            while (!this.isDone()) {
> >                ForkJoinTask<?> t;
> >                if ((t = pollTask()) != null) {
> >                    t.quietlyInvoke();
> >                    if (t == this) {
> >                        break;
> >                    }
> >                }
> >                else {
> >                    if (retries-- > 0) {
> >                        Thread.yield();
> >                        continue;
> >                    }
> >                    wasInterrupted = Thread.interrupted();
> >                    try {
> >                        // get(...) is used as a timed join(). It is
> > assumed that
> >                        // other code will perform get() on this task
> > to retrieve
> >                        // the task's result or exception.
> >                        this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
> >                        break;
> >                    }
> >                    catch (final InterruptedException consumed) {
> >                        if (!interruptibly) {
> >                            wasInterrupted = true;
> >                            continue;
> >                        }
> >                        return true;
> >                    }
> >                    catch (final ExecutionException ignored) {
> >                        // See comment on get() above.
> >                        break;
> >                    }
> >                    catch (final TimeoutException ignored) {
> >                        continue;
> >                    }
> >                }
> >                retries = RETRIES;
> >            }
> >            if (wasInterrupted && !interruptibly) {
> >                Thread.currentThread().interrupt();
> >                return false;
> >            }
> >            return wasInterrupted;
> >        }
> >
> > As already mentioned this works quite well in a number of cases. For
> > example, adding this method to the example MergeSort code and calling
> > quietlyJoinUnforked(), results in the same overall performance,
> > reduces the number of extra blocked worker threads to 1 if any
> > (instead of up to 8 for the unmodified code; on a PC with 4
> > hyper-threading cores/8 threads), and allows for some extra
> > (recreational?) freedom in joining the right and left sub-tasks in any
> > order. It works in cases where no sub-task is forked explicitly. I
> > observed that worker thread blocking only occurs towards the end of a
> > large recursion, suggesting that worker threads only block - as
> > intended - when there is no other work available (sometimes while
> > implicit forking has not yet happened).
> >
> > Wolfgang.
> >
> >
> >
> > On 2012-04-09 16:16, Doug Lea wrote:
> >>
> >> After sitting on multiple variations for months, I committed
> >> CountedCompleter, a completion-based flavor of ForkJoinTask.
> >>
> >> As mentioned a few times over the past year, the main motivation
> >> is to better support tasks that perform IO or other base
> >> actions that may (or may not) take a lot of time to execute.
> >> As is the case with JDK7 async IO and other completion-based
> >> frameworks, the most common path to efficiency is for such tasks
> >> to arrange continuation actions that occur upon their completion.
> >> The main twist for CountedCompleters is that continuations
> >> might be dependent on multiple actions, not just one. (Or in
> >> other words, the continuations must be preceded by a specialized,
> >> "bottom-up" form of join.)
> >>
> >> The CountedCompleter abstract class provides a minimal basis
> >> for these kinds of tasks. While some of the mechanics are
> >> reminiscent of other FJ-like frameworks such as Intel TBB,
> >> CountedCompleters are designed to fit smoothly with other
> >> kinds of ForkJoinTasks (like RecursiveActions), and so still
> >> allow people to use the more pleasant Future-style conventions
> >> rather than count-based bottom-up joining unless they need them.
> >> At the same time, the CountedCompleter class exposes enough
> >> mechanics to allow all sorts of tweaks that people can use
> >> to improve performance.
> >> In particular, in addition to usually being the best way to deal
> >> with IO etc bound tasks, CountedCompleters sometimes fare better
> >> than RecursiveActions in programs that entail lots of garbage
> >> collection because GC can have similar impact on task variability.
> >>
> >> Even though targeted for JDK8, versions of CountedCompleter
> >> appear in the jsr166y and main repositories, not jsr166e. This is
> >> because they require a non-public hook into modified ForkJoinTask
> >> exception handling mechanics in order to properly propagate
> >> exceptional completions. For sources, docs, and jar files, see
> >> the usual links at
> >> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> >>
> >> The API docs include more details and some examples:
> >>
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
> >>
> >>
> >> I also added a few (with more to come) test/demo programs that
> >> illustrate
> >> other usages. See CCBoxedLongSort and CCJacobi in
> >> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
> >>
> >> Please try these out. As always, comments and suggestions
> >> (hopefully based on usage experience) would be welcome.
> >>
> >> -Doug
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> ------------------------------
>
> Message: 2
> Date: Mon, 16 Apr 2012 16:38:00 +0000
> From: "Boehm, Hans" <hans.boehm at hp.com>
> To: Andrew Haley <aph at redhat.com>,
>     "concurrency-interest at cs.oswego.edu"
>     <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID:
>     <A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hpqcorp.net
> >
>
> Content-Type: text/plain; charset="us-ascii"
>
> Important questions to consider when you write it up:
>
> How does it compare to something like Gadara that uses whole program
> analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it
> doesn't need whole program analysis.)  Other deadlock avoidance schemes?
>
> Once you detect a potential deadlock, how do you recover?  Or can you
> always schedule so that the possibility doesn't arise?
>
> Hans
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency<concurrency>
> -
> > interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
> > Sent: Monday, April 16, 2012 4:34 AM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Java Deadlocks prevented
> >
> > On 04/16/2012 12:06 PM, Rohit Kumar wrote:
> >
> > > I have found a way of preventing deadlocks in java. The
> > > methodology(which is code) completely prevents the deadlock from
> > > occuring by detecting it in advance. This can be used across the
> > > systems seamlessly.
> > >
> > > Kindly let me know what I need to do next. I want this to be part of
> > > next jdk release. I am writing this email as I have no idea what I
> > > need to do next to bring it into limelight.
> >
> > Write it up, maybe present it to a conference, and wait for feedback.
> > That's how it always works.  If your idea really works, people will
> > use it.
> >
> > Andrew.
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> ------------------------------
>
> Message: 3
> Date: Mon, 16 Apr 2012 10:11:00 -0700
> From: Nathan Reynolds <nathan.reynolds at oracle.com>
> To: "Boehm, Hans" <hans.boehm at hp.com>
> Cc: "concurrency-interest at cs.oswego.edu"
>     <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID: <4F8C52A4.70002 at oracle.com>
> Content-Type: text/plain; charset="iso-8859-1"; Format="flowed"
>
> Deadlock prevention is very valuable.  It means deadlock prone code
> won't bring down a production server and cost the company millions in
> down time.  It means consumers won't kill the process and request a refund.
>
> How much does deadlock prevention cost?  Is the cost on the thread that
> acquires locks or is it in a background thread?
>
> Each time processors or systems increase the number of cores, I find we
> have to do a round of lock contention fixing.  I have only seen 1 lock
> at a time be the bottleneck in the system.  Does deadlock prevention
> increase the critical region of locks?  If so, this will definitely
> reduce the scalability of the system if it impacts the 1 bottlenecking
> lock.
>
> Lock performance is a very important consideration.  Locks have evolved
> from fat locks (i.e trips into the OS kernel) to thin locks (i.e. spin
> and CAS in user mode) to biased/lazy locks (i.e. no CAS and an
> indefinite lock owner).  All of this was done to reduce the performance
> overhead of locks.  How does deadlock prevention impact the performance
> of biased, thin and fat locks?  I am not as concerned about fat lock
> performance since most of the time the thread is going to block.
>
> Nathan Reynolds
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
> On 4/16/2012 9:38 AM, Boehm, Hans wrote:
> > Important questions to consider when you write it up:
> >
> > How does it compare to something like Gadara that uses whole program
> analysis and scheduling to avoid lock-based deadlocks?  (Hopefully it
> doesn't need whole program analysis.)  Other deadlock avoidance schemes?
> >
> > Once you detect a potential deadlock, how do you recover?  Or can you
> always schedule so that the possibility doesn't arise?
> >
> > Hans
> >
> >> -----Original Message-----
> >> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency<concurrency>
> -
> >> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
> >> Sent: Monday, April 16, 2012 4:34 AM
> >> To: concurrency-interest at cs.oswego.edu
> >> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> >>
> >> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
> >>
> >>> I have found a way of preventing deadlocks in java. The
> >>> methodology(which is code) completely prevents the deadlock from
> >>> occuring by detecting it in advance. This can be used across the
> >>> systems seamlessly.
> >>>
> >>> Kindly let me know what I need to do next. I want this to be part of
> >>> next jdk release. I am writing this email as I have no idea what I
> >>> need to do next to bring it into limelight.
> >> Write it up, maybe present it to a conference, and wait for feedback.
> >> That's how it always works.  If your idea really works, people will
> >> use it.
> >>
> >> Andrew.
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/7ea89bb3/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 4
> Date: Tue, 17 Apr 2012 01:20:15 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in>
> To: "concurrency-interest at cs.oswego.edu"
>     <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
>     87,    Issue 26 (Java deadlock prevented)
> Message-ID:
>     <1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Andrew:
> ?
> Thanks for the reply. Can you kindly let me know where do I need to
> present it ? Where will the conference be held ? Can I present it online or
> I have to come in person ?
> ?
> Waiting for your early reply once again.
> ?
> Thanks & Regards,
> Rohit Kumar
>
> From: "concurrency-interest-request at cs.oswego.edu" <
> concurrency-interest-request at cs.oswego.edu>
> To: concurrency-interest at cs.oswego.edu
> Sent: Monday, 16 April 2012 9:30 PM
> Subject: Concurrency-interest Digest, Vol 87, Issue 26
>
> Send Concurrency-interest mailing list submissions to
> ??? concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
> ??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
> ??? concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
> ??? concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
> ? 1. (no subject) (Rohit Kumar)
> ? 2. Java Deadlocks prevented (Rohit Kumar)
> ? 3. Re: Java Deadlocks prevented (Andrew Haley)
> ? 4. Re: CountedCompleters (Wolfgang Baltes)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in>
> To: "concurrency-interest at cs.oswego.edu"
> ??? <concurrency-interest at cs.oswego.edu>
> Cc: "concurrency-interest-owner at cs.oswego.edu"
> ??? <concurrency-interest-owner at cs.oswego.edu>
> Subject: [concurrency-interest] (no subject)
> Message-ID:
> ??? <1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Hi All,
> ?
> I have found a way of preventing deadlocks in java. The methodology(which
> is code) completely prevents the deadlock from accuring by detecting it in
> advance. This can be used across the systems seamlessly.
> ?
> Kindly let me know what I need to do next. I want this to be part of next
> jdk release.
> ?
> Thanks & Regards,
> Rohit Kumar
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/a6588341/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 2
> Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in>
> To: "concurrency-interest at cs.oswego.edu"
> ??? <concurrency-interest at cs.oswego.edu>
> Cc: "concurrency-interest-owner at cs.oswego.edu"
> ??? <concurrency-interest-owner at cs.oswego.edu>
> Subject: [concurrency-interest] Java Deadlocks prevented
> Message-ID:
> ??? <1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com>
> Content-Type: text/plain; charset="utf-8"
>
>
>
> Hi All,
>
> I have found a way of preventing deadlocks in java. The methodology(which
> is code) completely prevents the deadlock from occuring by detecting it in
> advance. This can be used across the systems seamlessly.
>
> Kindly let me know what I need to do next. I want this to be part of next
> jdk release. I am writing this email as I have no idea what I need to do
> next to bring it into limelight.
>
> Thanks & Regards,
> Rohit Kumar
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/064a4873/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 3
> Date: Mon, 16 Apr 2012 12:33:45 +0100
> From: Andrew Haley <aph at redhat.com>
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID: <4F8C0399.8040301 at redhat.com>
> Content-Type: text/plain; charset=ISO-8859-1
>
> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>
> > I have found a way of preventing deadlocks in java. The
> > methodology(which is code) completely prevents the deadlock from
> > occuring by detecting it in advance. This can be used across the
> > systems seamlessly.
> >
> > Kindly let me know what I need to do next. I want this to be part of
> > next jdk release. I am writing this email as I have no idea what I
> > need to do next to bring it into limelight.
>
> Write it up, maybe present it to a conference, and wait for feedback.
> That's how it always works.? If your idea really works, people will
> use it.
>
> Andrew.
>
>
> ------------------------------
>
> Message: 4
> Date: Mon, 16 Apr 2012 16:48:31 +0200
> From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
> To: "Concurrency-interest at cs.oswego.edu"
> ??? <Concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] CountedCompleters
> Message-ID: <4F8C313F.2080308 at laposte.net>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> Thanks, Doug, for a this addition to the FJ framework. I think that
> CountedCompleter will address the needs of an entire class of
> applications in an efficient and simple to use manner.
>
> I used the code and noticed that method doJoin() has become more
> effective in avoiding blocking threads, and as a result fewer extra
> threads are created. I found the performance, compared to
> RecursiveAction, to be equal or insignificantly different. This reduces
> the problem described in item 3 below.
>
> However, at the same time, CountedCompleter does not fully satisfy the
> needs for a class of problems I work on. To this end, here are a few
> enhancements I would like to suggest:
>
> 1: Symmetrically to onCompletion(), provide
> onExceptionalCompletion(Throwable). This allows filtering exception
> propagation. There are cases where the propagation of the exception is
> desired, and others where a corrective action is taken instead, such as
> a retry.
>
> 2: As a further enhancement to 1: enable any Throwable, including
> checked exceptions. This allows the use of a CountedCompleter as a
> CompletionHandler for asynchronous IO operations or as a wrapper for
> MethodHandles (which throw Throwable) without adding extra logic to
> capture and convert an IO exception. I read the documentation which
> explains why this is currently limited to unchecked exceptions. While I
> can agree with this in general, I feel the argument is weak for
> CountedCompleter if it is there to support asynchronous tasks/events.
> (May I add that using this type of framework is not for the
> faint-hearted anyway!?)
>
> 3: Provide a method to join a task that is not forked and/or not
> completable, while minimizing worker thread blocking. For example,
> CountedCompleter allows creating chains of dependent tasks. Unless the
> ultimate task (the last in the chain) is forked/exists on the task stack
> AND can complete because all dependencies are resolved, joining it will
> block the worker thread. I noticed (and my testing is limited to a few
> test cases and therefore not representative) the blocking and the
> creation of other worker threads, ultimately running out of memory or
> reaching the thread count limit. If this task is not forked, then
> join()/quietlyJoin() will block the worker thread. The following code is
> my (inexpert) attempt to provide a remedy. It is based on the assumption
> that a task that depends on others for completion is not forked until
> all dependencies are resolved. For example, a CountedCompleter
> implementing CompletionHandler would fork itself ("implicit fork") when
> the IO operation is done. This works very well in my test cases, but at
> this time I would not claim it to be universally applicable or error
> free. It is shown here more to demonstrate the attempt rather than as a
> reference implementation. With access to private data structures, this
> can be done more elegantly and more reliably.
>
> ? ? ? ? static final int RETRIES = 16;
> ? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in
> microseconds.
>
> ? ? ? ? public final void quietlyJoinUnforked() {
> ? ? ? ? ? ? this.doJoinUnforked(false);
> ? ? ? ? }
>
> ? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
> ? ? ? ? throws InterruptedException {
> ? ? ? ? ? ? if (this.doJoinUnforked(true)) {
> ? ? ? ? ? ? ? ? throw new InterruptedException();
> ? ? ? ? ? ? }
> ? ? ? ? }
>
> ? ? ? ? public final boolean doJoinUnforked(final boolean interruptibly) {
> ? ? ? ? ? ? int retries = RETRIES;
> ? ? ? ? ? ? boolean wasInterrupted = false;
> ? ? ? ? ? ? while (!this.isDone()) {
> ? ? ? ? ? ? ? ? ForkJoinTask<?> t;
> ? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
> ? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
> ? ? ? ? ? ? ? ? ? ? if (t == this) {
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? else {
> ? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
> ? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
> ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
> ? ? ? ? ? ? ? ? ? ? try {
> ? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is
> assumed that
> ? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task
> to retrieve
> ? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
> ? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
> ? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? ? ? return true;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
> ? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
> ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? retries = RETRIES;
> ? ? ? ? ? ? }
> ? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
> ? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
> ? ? ? ? ? ? ? ? return false;
> ? ? ? ? ? ? }
> ? ? ? ? ? ? return wasInterrupted;
> ? ? ? ? }
>
> As already mentioned this works quite well in a number of cases. For
> example, adding this method to the example MergeSort code and calling
> quietlyJoinUnforked(), results in the same overall performance, reduces
> the number of extra blocked worker threads to 1 if any (instead of up to
> 8 for the unmodified code; on a PC with 4 hyper-threading cores/8
> threads), and allows for some extra (recreational?) freedom in joining
> the right and left sub-tasks in any order. It works in cases where no
> sub-task is forked explicitly. I observed that worker thread blocking
> only occurs towards the end of a large recursion, suggesting that worker
> threads only block - as intended - when there is no other work available
> (sometimes while implicit forking has not yet happened).
>
> Wolfgang.
>
>
>
> On 2012-04-09 16:16, Doug Lea wrote:
> >
> > After sitting on multiple variations for months, I committed
> > CountedCompleter, a completion-based flavor of ForkJoinTask.
> >
> > As mentioned a few times over the past year, the main motivation
> > is to better support tasks that perform IO or other base
> > actions that may (or may not) take a lot of time to execute.
> > As is the case with JDK7 async IO and other completion-based
> > frameworks, the most common path to efficiency is for such tasks
> > to arrange continuation actions that occur upon their completion.
> > The main twist for CountedCompleters is that continuations
> > might be dependent on multiple actions, not just one. (Or in
> > other words, the continuations must be preceded by a specialized,
> > "bottom-up" form of join.)
> >
> > The CountedCompleter abstract class provides a minimal basis
> > for these kinds of tasks. While some of the mechanics are
> > reminiscent of other FJ-like frameworks such as Intel TBB,
> > CountedCompleters are designed to fit smoothly with other
> > kinds of ForkJoinTasks (like RecursiveActions), and so still
> > allow people to use the more pleasant Future-style conventions
> > rather than count-based bottom-up joining unless they need them.
> > At the same time, the CountedCompleter class exposes enough
> > mechanics to allow all sorts of tweaks that people can use
> > to improve performance.
> > In particular, in addition to usually being the best way to deal
> > with IO etc bound tasks, CountedCompleters sometimes fare better
> > than RecursiveActions in programs that entail lots of garbage
> > collection because GC can have similar impact on task variability.
> >
> > Even though targeted for JDK8, versions of CountedCompleter
> > appear in the jsr166y and main repositories, not jsr166e. This is
> > because they require a non-public hook into modified ForkJoinTask
> > exception handling mechanics in order to properly propagate
> > exceptional completions. For sources, docs, and jar files, see
> > the usual links at
> > http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> >
> > The API docs include more details and some examples:
> >
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
> >
> >
> > I also added a few (with more to come) test/demo programs that illustrate
> > other usages. See CCBoxedLongSort and CCJacobi in
> > http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
> >
> > Please try these out. As always, comments and suggestions
> > (hopefully based on usage experience) would be welcome.
> >
> > -Doug
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 87, Issue 26
> ****************************************************
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/75746dcb/attachment.html
> >
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 87, Issue 27
> ****************************************************
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/5c5fa2e5/attachment-0001.html>

From rohitk242 at yahoo.co.in  Tue Apr 17 02:10:12 2012
From: rohitk242 at yahoo.co.in (Rohit Kumar)
Date: Tue, 17 Apr 2012 14:10:12 +0800 (SGT)
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
	Issue 36
In-Reply-To: <mailman.135.1334617421.3324.concurrency-interest@cs.oswego.edu>
References: <mailman.135.1334617421.3324.concurrency-interest@cs.oswego.edu>
Message-ID: <1334643012.72155.YahooMailNeo@web193403.mail.sg3.yahoo.com>

Yes. Recovery is very important in case there is a deadlock exception. When a method involved in the lock acquisition tries to recover from deadlock exception, it only has to recover till the point when it started acquiring the locks, not before that. I suppose that everyone will agree with me. Now following things can normally?happen in a method that is involved in the lock acquisition. 
?
1. changes to the local variable.
????local variables are local to the methods that will be different for differen threads, so we don't have to worry about them.
2. changes to the global variable.
????????changes to the global variables should be guarded by the same locks? everywhere. This should be part of the synchronization policy.
3. changes to the arguments passed to the method.
????????changes to the arguments passed to the method must be guarded by the same lock everywhere.
4. transaction (db etc.)
????Transaction can be rolled back.
?
Also, preferably locks should be acquired-released in the following manner in order for deadlock recovery to be easy (though the detection methodology doesn't impose any restrictions.)
?
lock1 --> acquireLock
????lock2 --> acquireLock
????????lock3 --> acquireLock
????????lock3 --> releaseLock
????lock2 --> releaseLock
lock1 --> releaseLock
?
This hierarchy is?like a First-in-last-out (FILO) hierarchy. This way the exception can propagate the the lock hierarchy chain and undo the changes in the catch block and release the locks. If we can follow lock acquisition-release hierarchy as discussed, it will be easier to recover from the deadlock.
?
Suggestions and comments are welcome.
?
Thanks & Regards,
Rohit Kumar

From: "concurrency-interest-request at cs.oswego.edu" <concurrency-interest-request at cs.oswego.edu>
To: concurrency-interest at cs.oswego.edu 
Sent: Tuesday, 17 April 2012 4:33 AM
Subject: Concurrency-interest Digest, Vol 87, Issue 36

Send Concurrency-interest mailing list submissions to
??? concurrency-interest at cs.oswego.edu

To subscribe or unsubscribe via the World Wide Web, visit
??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
or, via email, send a message with subject or body 'help' to
??? concurrency-interest-request at cs.oswego.edu

You can reach the person managing the list at
??? concurrency-interest-owner at cs.oswego.edu

When replying, please edit your Subject line so it is more specific
than "Re: Contents of Concurrency-interest digest..."


Today's Topics:

? 1. Re: Java Deadlock prevented (Khilan Gudka)


----------------------------------------------------------------------

Message: 1
Date: Tue, 17 Apr 2012 00:03:05 +0100
From: Khilan Gudka <khilan at doc.ic.ac.uk>
To: dholmes at ieee.org
Cc: Rohit Kumar <rohitk242 at yahoo.co.in>,
??? concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Java Deadlock prevented
Message-ID:
??? <CAEtTSAbwZB=xg+CxvQKBNiO5_mM71msTf9vSeTw7bzmysEqaqg at mail.gmail.com>
Content-Type: text/plain; charset="utf-8"

Yep I think in general what you want is either 1) some mechanism to recover
from a deadlock, like a transactional rollback, but then you have the
overhead of keeping track of all your changes or 2) to be able to ensure
that deadlock never occurs, either through static analysis and/or having a
global ordering on locks. However, I think applying principles ala JCIP are
difficult given that locks are not modular. I mean, is it enough to ensure
global ordering of locks in client code to ensure deadlock-freedom of the
entire system (i.e. client + library)?

--
Khilan Gudka
PhD Student
Department of Computing
Imperial College London
http://www.doc.ic.ac.uk/~khilan/



On 16 April 2012 23:45, David Holmes <davidcholmes at aapt.net.au> wrote:

> **
> (Fixed subject line: everyone - please don't reply to a digest and so
> screw up the subject!)
>
> I hate to be a wet blanket but really this is nothing new. Deadlock
> detection and prevention is as old as deadlock. Throwing an exception when
> you are potentially going to deadlock avoids the deadlock but doesn't
> necessarily imply that any corrective action is possible at runtime - you
> would need to employ transactional semantics to undo nested state changes,
> and all of your code would need to know about the rest to know how the
> locking is related and so may be done a different way. Such mechanisms can
> be useful development tools, but static analysis can be better at
> identifying potential deadlocks, than runtime checks that require the right
> timing for the deadlock to be encountered. There's decades of literature on
> this.
>
> David Holmes
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Rohit Kumar
> *Sent:* Tuesday, 17 April 2012 5:45 AM
> *To:* Nathan Reynolds; sandeep.bansal85 at gmail.com; khilan at doc.ic.ac.uk
> *Cc:* concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Concurrency-interest Digest, Vol
> 87,Issue 27
>
>? The whole idea that I wanted to bring up is that use of synchronized
> keyword (implicit locks) can make your program vulnerable to deadlocks as
> you have no control over acquisition of locks. Once you use explicit locks
> as provided by java concurrent apis, deadlocks can be prevented completely.
> And yes, my program uses synchronized keywords, but all in one place and is
> completely and thoroughly tested. Usage of synchronized keyword should be
> confined.
>
> My program detects cycles in lock-acquisition graph. The overhead will be
> proportional to all the threads that are holding locks but not yet released and
> this is not great compared to restarting the server everytime the deadlock
> happens.
>
> I will see if I can present it to any java forum. This is written in java
> but the concept can be applied in any programming language.
>
> Thanks & Regards,
> Rohit Kumar
>
>? *From:* Nathan Reynolds <nathan.reynolds at oracle.com>
> *To:* Rohit Kumar <rohitk242 at yahoo.co.in>
> *Cc:* "concurrency-interest at cs.oswego.edu" <
> concurrency-interest at cs.oswego.edu>
> *Sent:* Tuesday, 17 April 2012 12:52 AM
> *Subject:* Re: [concurrency-interest] Concurrency-interest Digest, Vol
> 87, Issue 27
>
>? Synchronized blocks are used every where.? You could use ASM (
> http://asm.ow2.org/) to instrument all synchronized blocks (i.e.
> monitorenter and monitorexit bytecodes).? Simply put a call to your
> deadlock-check just before the monitorenter instruction.? You could also
> use this to inject your code into all Locks.
>
> If you want to avoid the overhead during lock acquisition, you could have
> a background thread detect the deadlock and then make one thread involved
> in the deadlock throw an exception using Thread.stop(Throwable).
> Thread.stop() is a misnomer in my opinion.? It doesn't stop the thread
> immediately.? Instead, it causes the thread to throw an exception which
> unwinds the stack and if not caught causes the thread to terminate.? It is
> deprecated because the exception can be thrown at any point during the
> execution of the thread and this makes it very hard to get it bug free.
> (It might be deprecated for other reasons as well.)? However, if you know
> that the threads are indefinitely deadlocked, then the thread won't wake up
> any time and I naively don't see why using Thread.stop(Throwable) would be
> a problem.? (Note: I am not sure if Thread.stop() will throw an exception
> while the thread is blocked inside monitorenter).
>
> > Finally where do I need to present this writeup?
>
> I have never presented anything outside of Oracle Open World.? I have
> attended Java One.? Sorry, I can't be of much help.? Since this is Java
> code, you might consider presenting at Java One.? I am not sure if that is
> appropriate venue, though.
>
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
> On 4/16/2012 11:36 AM, Rohit Kumar wrote:
>
>? Hans,Nathan,
>
> I am not aware of anything like Gadara yet. My implementation assumes that
> there are no synchnonized keywords (implicit locks) in your program. It
> requires you to use explicit locks (e.g. Lock class in java concurrent
> api). There is no background thread running here. The deadlock-check
> happens at each lock acquisition request; it runs an algorithms internally
> to see if there are any cycles formed in the lock-acquisition graph. If
> yes, it doesn't let you acquire the lock but throws an exception. You can
> catch this exception and take necessary steps to re-acquire all the locks
> once again or whatever you want. The program is written in java and it is
> hardly 270 lines of code.
>
> Finally where do I need to present this writeup ?
>
> Thanks & Regards,
> Rohit Kumar
>
>? *From:* "concurrency-interest-request at cs.oswego.edu"<concurrency-interest-request at cs.oswego.edu>
> <concurrency-interest-request at cs.oswego.edu><concurrency-interest-request at cs.oswego.edu>
> *To:* concurrency-interest at cs.oswego.edu
> *Sent:* Monday, 16 April 2012 10:50 PM
> *Subject:* Concurrency-interest Digest, Vol 87, Issue 27
>
> Send Concurrency-interest mailing list submissions to
>? ? concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
>? ? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
>? ? concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
>? ? concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>? 1. Re: CountedCompleters (Wolfgang Baltes)
>? 2. Re: Java Deadlocks prevented (Boehm, Hans)
>? 3. Re: Java Deadlocks prevented (Nathan Reynolds)
>? 4. Re: Concurrency-interest Digest, Vol 87,? ? Issue 26 (Java
>? ? ? deadlock prevented) (Rohit Kumar)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 16 Apr 2012 18:01:50 +0200
> From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] CountedCompleters
> Message-ID: <4F8C426E.6090704 at laposte.net>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> I apologize for a mistake in the last paragraph of my memo: using
> quietlyJoinUnforked() in the SDK7 sample code for MergeSort does have a
> non-negligible performance impact (not no impact as stated). There is
> better performance in case of recursions which produce many tasks that
> are not explicitly forked, and it reduces the number of extra threads
> significantly, allowing larger problems to be solved with smaller memory
> footprint.
>
> Wolfgang.
>
> On 2012-04-16 16:48, Wolfgang Baltes wrote:
> > Thanks, Doug, for a this addition to the FJ framework. I think that
> > CountedCompleter will address the needs of an entire class of
> > applications in an efficient and simple to use manner.
> >
> > I used the code and noticed that method doJoin() has become more
> > effective in avoiding blocking threads, and as a result fewer extra
> > threads are created. I found the performance, compared to
> > RecursiveAction, to be equal or insignificantly different. This
> > reduces the problem described in item 3 below.
> >
> > However, at the same time, CountedCompleter does not fully satisfy the
> > needs for a class of problems I work on. To this end, here are a few
> > enhancements I would like to suggest:
> >
> > 1: Symmetrically to onCompletion(), provide
> > onExceptionalCompletion(Throwable). This allows filtering exception
> > propagation. There are cases where the propagation of the exception is
> > desired, and others where a corrective action is taken instead, such
> > as a retry.
> >
> > 2: As a further enhancement to 1: enable any Throwable, including
> > checked exceptions. This allows the use of a CountedCompleter as a
> > CompletionHandler for asynchronous IO operations or as a wrapper for
> > MethodHandles (which throw Throwable) without adding extra logic to
> > capture and convert an IO exception. I read the documentation which
> > explains why this is currently limited to unchecked exceptions. While
> > I can agree with this in general, I feel the argument is weak for
> > CountedCompleter if it is there to support asynchronous tasks/events.
> > (May I add that using this type of framework is not for the
> > faint-hearted anyway!?)
> >
> > 3: Provide a method to join a task that is not forked and/or not
> > completable, while minimizing worker thread blocking. For example,
> > CountedCompleter allows creating chains of dependent tasks. Unless the
> > ultimate task (the last in the chain) is forked/exists on the task
> > stack AND can complete because all dependencies are resolved, joining
> > it will block the worker thread. I noticed (and my testing is limited
> > to a few test cases and therefore not representative) the blocking and
> > the creation of other worker threads, ultimately running out of memory
> > or reaching the thread count limit. If this task is not forked, then
> > join()/quietlyJoin() will block the worker thread. The following code
> > is my (inexpert) attempt to provide a remedy. It is based on the
> > assumption that a task that depends on others for completion is not
> > forked until all dependencies are resolved. For example, a
> > CountedCompleter implementing CompletionHandler would fork itself
> > ("implicit fork") when the IO operation is done. This works very well
> > in my test cases, but at this time I would not claim it to be
> > universally applicable or error free. It is shown here more to
> > demonstrate the attempt rather than as a reference implementation.
> > With access to private data structures, this can be done more
> > elegantly and more reliably.
> >
> >? ? ? ? static final int RETRIES = 16;
> >? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in
> > microseconds.
> >
> >? ? ? ? public final void quietlyJoinUnforked() {
> >? ? ? ? ? ? this.doJoinUnforked(false);
> >? ? ? ? }
> >
> >? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
> >? ? ? ? throws InterruptedException {
> >? ? ? ? ? ? if (this.doJoinUnforked(true)) {
> >? ? ? ? ? ? ? ? throw new InterruptedException();
> >? ? ? ? ? ? }
> >? ? ? ? }
> >
> >? ? ? ? public final boolean doJoinUnforked(final boolean
> > interruptibly) {
> >? ? ? ? ? ? int retries = RETRIES;
> >? ? ? ? ? ? boolean wasInterrupted = false;
> >? ? ? ? ? ? while (!this.isDone()) {
> >? ? ? ? ? ? ? ? ForkJoinTask<?> t;
> >? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
> >? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
> >? ? ? ? ? ? ? ? ? ? if (t == this) {
> >? ? ? ? ? ? ? ? ? ? ? ? break;
> >? ? ? ? ? ? ? ? ? ? }
> >? ? ? ? ? ? ? ? }
> >? ? ? ? ? ? ? ? else {
> >? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
> >? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
> >? ? ? ? ? ? ? ? ? ? ? ? continue;
> >? ? ? ? ? ? ? ? ? ? }
> >? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
> >? ? ? ? ? ? ? ? ? ? try {
> >? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is
> > assumed that
> >? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task
> > to retrieve
> >? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
> >? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
> >? ? ? ? ? ? ? ? ? ? ? ? break;
> >? ? ? ? ? ? ? ? ? ? }
> >? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
> >? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
> >? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
> >? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
> >? ? ? ? ? ? ? ? ? ? ? ? }
> >? ? ? ? ? ? ? ? ? ? ? ? return true;
> >? ? ? ? ? ? ? ? ? ? }
> >? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
> >? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
> >? ? ? ? ? ? ? ? ? ? ? ? break;
> >? ? ? ? ? ? ? ? ? ? }
> >? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
> >? ? ? ? ? ? ? ? ? ? ? ? continue;
> >? ? ? ? ? ? ? ? ? ? }
> >? ? ? ? ? ? ? ? }
> >? ? ? ? ? ? ? ? retries = RETRIES;
> >? ? ? ? ? ? }
> >? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
> >? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
> >? ? ? ? ? ? ? ? return false;
> >? ? ? ? ? ? }
> >? ? ? ? ? ? return wasInterrupted;
> >? ? ? ? }
> >
> > As already mentioned this works quite well in a number of cases. For
> > example, adding this method to the example MergeSort code and calling
> > quietlyJoinUnforked(), results in the same overall performance,
> > reduces the number of extra blocked worker threads to 1 if any
> > (instead of up to 8 for the unmodified code; on a PC with 4
> > hyper-threading cores/8 threads), and allows for some extra
> > (recreational?) freedom in joining the right and left sub-tasks in any
> > order. It works in cases where no sub-task is forked explicitly. I
> > observed that worker thread blocking only occurs towards the end of a
> > large recursion, suggesting that worker threads only block - as
> > intended - when there is no other work available (sometimes while
> > implicit forking has not yet happened).
> >
> > Wolfgang.
> >
> >
> >
> > On 2012-04-09 16:16, Doug Lea wrote:
> >>
> >> After sitting on multiple variations for months, I committed
> >> CountedCompleter, a completion-based flavor of ForkJoinTask.
> >>
> >> As mentioned a few times over the past year, the main motivation
> >> is to better support tasks that perform IO or other base
> >> actions that may (or may not) take a lot of time to execute.
> >> As is the case with JDK7 async IO and other completion-based
> >> frameworks, the most common path to efficiency is for such tasks
> >> to arrange continuation actions that occur upon their completion.
> >> The main twist for CountedCompleters is that continuations
> >> might be dependent on multiple actions, not just one. (Or in
> >> other words, the continuations must be preceded by a specialized,
> >> "bottom-up" form of join.)
> >>
> >> The CountedCompleter abstract class provides a minimal basis
> >> for these kinds of tasks. While some of the mechanics are
> >> reminiscent of other FJ-like frameworks such as Intel TBB,
> >> CountedCompleters are designed to fit smoothly with other
> >> kinds of ForkJoinTasks (like RecursiveActions), and so still
> >> allow people to use the more pleasant Future-style conventions
> >> rather than count-based bottom-up joining unless they need them.
> >> At the same time, the CountedCompleter class exposes enough
> >> mechanics to allow all sorts of tweaks that people can use
> >> to improve performance.
> >> In particular, in addition to usually being the best way to deal
> >> with IO etc bound tasks, CountedCompleters sometimes fare better
> >> than RecursiveActions in programs that entail lots of garbage
> >> collection because GC can have similar impact on task variability.
> >>
> >> Even though targeted for JDK8, versions of CountedCompleter
> >> appear in the jsr166y and main repositories, not jsr166e. This is
> >> because they require a non-public hook into modified ForkJoinTask
> >> exception handling mechanics in order to properly propagate
> >> exceptional completions. For sources, docs, and jar files, see
> >> the usual links at
> >> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> >>
> >> The API docs include more details and some examples:
> >>
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
> >>
> >>
> >> I also added a few (with more to come) test/demo programs that
> >> illustrate
> >> other usages. See CCBoxedLongSort and CCJacobi in
> >> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
> >>
> >> Please try these out. As always, comments and suggestions
> >> (hopefully based on usage experience) would be welcome.
> >>
> >> -Doug
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> ------------------------------
>
> Message: 2
> Date: Mon, 16 Apr 2012 16:38:00 +0000
> From: "Boehm, Hans" <hans.boehm at hp.com>
> To: Andrew Haley <aph at redhat.com>,
>? ? "concurrency-interest at cs.oswego.edu"
>? ? <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID:
>? ? <A3E67C2071F49C4CBC4F17E6D77CDDD235543F5B at G4W3299.americas.hpqcorp.net
> >
>
> Content-Type: text/plain; charset="us-ascii"
>
> Important questions to consider when you write it up:
>
> How does it compare to something like Gadara that uses whole program
> analysis and scheduling to avoid lock-based deadlocks?? (Hopefully it
> doesn't need whole program analysis.)? Other deadlock avoidance schemes?
>
> Once you detect a potential deadlock, how do you recover?? Or can you
> always schedule so that the possibility doesn't arise?
>
> Hans
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency<concurrency>
> -
> > interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
> > Sent: Monday, April 16, 2012 4:34 AM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Java Deadlocks prevented
> >
> > On 04/16/2012 12:06 PM, Rohit Kumar wrote:
> >
> > > I have found a way of preventing deadlocks in java. The
> > > methodology(which is code) completely prevents the deadlock from
> > > occuring by detecting it in advance. This can be used across the
> > > systems seamlessly.
> > >
> > > Kindly let me know what I need to do next. I want this to be part of
> > > next jdk release. I am writing this email as I have no idea what I
> > > need to do next to bring it into limelight.
> >
> > Write it up, maybe present it to a conference, and wait for feedback.
> > That's how it always works.? If your idea really works, people will
> > use it.
> >
> > Andrew.
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> ------------------------------
>
> Message: 3
> Date: Mon, 16 Apr 2012 10:11:00 -0700
> From: Nathan Reynolds <nathan.reynolds at oracle.com>
> To: "Boehm, Hans" <hans.boehm at hp.com>
> Cc: "concurrency-interest at cs.oswego.edu"
>? ? <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID: <4F8C52A4.70002 at oracle.com>
> Content-Type: text/plain; charset="iso-8859-1"; Format="flowed"
>
> Deadlock prevention is very valuable.? It means deadlock prone code
> won't bring down a production server and cost the company millions in
> down time.? It means consumers won't kill the process and request a refund.
>
> How much does deadlock prevention cost?? Is the cost on the thread that
> acquires locks or is it in a background thread?
>
> Each time processors or systems increase the number of cores, I find we
> have to do a round of lock contention fixing.? I have only seen 1 lock
> at a time be the bottleneck in the system.? Does deadlock prevention
> increase the critical region of locks?? If so, this will definitely
> reduce the scalability of the system if it impacts the 1 bottlenecking
> lock.
>
> Lock performance is a very important consideration.? Locks have evolved
> from fat locks (i.e trips into the OS kernel) to thin locks (i.e. spin
> and CAS in user mode) to biased/lazy locks (i.e. no CAS and an
> indefinite lock owner).? All of this was done to reduce the performance
> overhead of locks.? How does deadlock prevention impact the performance
> of biased, thin and fat locks?? I am not as concerned about fat lock
> performance since most of the time the thread is going to block.
>
> Nathan Reynolds
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
> On 4/16/2012 9:38 AM, Boehm, Hans wrote:
> > Important questions to consider when you write it up:
> >
> > How does it compare to something like Gadara that uses whole program
> analysis and scheduling to avoid lock-based deadlocks?? (Hopefully it
> doesn't need whole program analysis.)? Other deadlock avoidance schemes?
> >
> > Once you detect a potential deadlock, how do you recover?? Or can you
> always schedule so that the possibility doesn't arise?
> >
> > Hans
> >
> >> -----Original Message-----
> >> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency<concurrency>
> -
> >> interest-bounces at cs.oswego.edu] On Behalf Of Andrew Haley
> >> Sent: Monday, April 16, 2012 4:34 AM
> >> To: concurrency-interest at cs.oswego.edu
> >> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> >>
> >> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
> >>
> >>> I have found a way of preventing deadlocks in java. The
> >>> methodology(which is code) completely prevents the deadlock from
> >>> occuring by detecting it in advance. This can be used across the
> >>> systems seamlessly.
> >>>
> >>> Kindly let me know what I need to do next. I want this to be part of
> >>> next jdk release. I am writing this email as I have no idea what I
> >>> need to do next to bring it into limelight.
> >> Write it up, maybe present it to a conference, and wait for feedback.
> >> That's how it always works.? If your idea really works, people will
> >> use it.
> >>
> >> Andrew.
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/7ea89bb3/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 4
> Date: Tue, 17 Apr 2012 01:20:15 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in>
> To: "concurrency-interest at cs.oswego.edu"
>? ? <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Concurrency-interest Digest, Vol
>? ? 87,? ? Issue 26 (Java deadlock prevented)
> Message-ID:
>? ? <1334596815.27848.YahooMailNeo at web193403.mail.sg3.yahoo.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Andrew:
> ?
> Thanks for the reply. Can you kindly let me know where do I need to
> present it ? Where will the conference be held ? Can I present it online or
> I have to come in person ?
> ?
> Waiting for your early reply once again.
> ?
> Thanks & Regards,
> Rohit Kumar
>
> From: "concurrency-interest-request at cs.oswego.edu" <
> concurrency-interest-request at cs.oswego.edu>
> To: concurrency-interest at cs.oswego.edu
> Sent: Monday, 16 April 2012 9:30 PM
> Subject: Concurrency-interest Digest, Vol 87, Issue 26
>
> Send Concurrency-interest mailing list submissions to
> ??? concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
> ??? http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
> ??? concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
> ??? concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
> ? 1. (no subject) (Rohit Kumar)
> ? 2. Java Deadlocks prevented (Rohit Kumar)
> ? 3. Re: Java Deadlocks prevented (Andrew Haley)
> ? 4. Re: CountedCompleters (Wolfgang Baltes)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 16 Apr 2012 19:03:59 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in>
> To: "concurrency-interest at cs.oswego.edu"
> ??? <concurrency-interest at cs.oswego.edu>
> Cc: "concurrency-interest-owner at cs.oswego.edu"
> ??? <concurrency-interest-owner at cs.oswego.edu>
> Subject: [concurrency-interest] (no subject)
> Message-ID:
> ??? <1334574239.81244.YahooMailNeo at web193402.mail.sg3.yahoo.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Hi All,
> ?
> I have found a way of preventing deadlocks in java. The methodology(which
> is code) completely prevents the deadlock from accuring by detecting it in
> advance. This can be used across the systems seamlessly.
> ?
> Kindly let me know what I need to do next. I want this to be part of next
> jdk release.
> ?
> Thanks & Regards,
> Rohit Kumar
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/a6588341/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 2
> Date: Mon, 16 Apr 2012 19:06:22 +0800 (SGT)
> From: Rohit Kumar <rohitk242 at yahoo.co.in>
> To: "concurrency-interest at cs.oswego.edu"
> ??? <concurrency-interest at cs.oswego.edu>
> Cc: "concurrency-interest-owner at cs.oswego.edu"
> ??? <concurrency-interest-owner at cs.oswego.edu>
> Subject: [concurrency-interest] Java Deadlocks prevented
> Message-ID:
> ??? <1334574382.90584.YahooMailNeo at web193403.mail.sg3.yahoo.com>
> Content-Type: text/plain; charset="utf-8"
>
>
>
> Hi All,
>
> I have found a way of preventing deadlocks in java. The methodology(which
> is code) completely prevents the deadlock from occuring by detecting it in
> advance. This can be used across the systems seamlessly.
>
> Kindly let me know what I need to do next. I want this to be part of next
> jdk release. I am writing this email as I have no idea what I need to do
> next to bring it into limelight.
>
> Thanks & Regards,
> Rohit Kumar
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120416/064a4873/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 3
> Date: Mon, 16 Apr 2012 12:33:45 +0100
> From: Andrew Haley <aph at redhat.com>
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Java Deadlocks prevented
> Message-ID: <4F8C0399.8040301 at redhat.com>
> Content-Type: text/plain; charset=ISO-8859-1
>
> On 04/16/2012 12:06 PM, Rohit Kumar wrote:
>
> > I have found a way of preventing deadlocks in java. The
> > methodology(which is code) completely prevents the deadlock from
> > occuring by detecting it in advance. This can be used across the
> > systems seamlessly.
> >
> > Kindly let me know what I need to do next. I want this to be part of
> > next jdk release. I am writing this email as I have no idea what I
> > need to do next to bring it into limelight.
>
> Write it up, maybe present it to a conference, and wait for feedback.
> That's how it always works.? If your idea really works, people will
> use it.
>
> Andrew.
>
>
> ------------------------------
>
> Message: 4
> Date: Mon, 16 Apr 2012 16:48:31 +0200
> From: Wolfgang Baltes <wolfgang.baltes at laposte.net>
> To: "Concurrency-interest at cs.oswego.edu"
> ??? <Concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] CountedCompleters
> Message-ID: <4F8C313F.2080308 at laposte.net>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> Thanks, Doug, for a this addition to the FJ framework. I think that
> CountedCompleter will address the needs of an entire class of
> applications in an efficient and simple to use manner.
>
> I used the code and noticed that method doJoin() has become more
> effective in avoiding blocking threads, and as a result fewer extra
> threads are created. I found the performance, compared to
> RecursiveAction, to be equal or insignificantly different. This reduces
> the problem described in item 3 below.
>
> However, at the same time, CountedCompleter does not fully satisfy the
> needs for a class of problems I work on. To this end, here are a few
> enhancements I would like to suggest:
>
> 1: Symmetrically to onCompletion(), provide
> onExceptionalCompletion(Throwable). This allows filtering exception
> propagation. There are cases where the propagation of the exception is
> desired, and others where a corrective action is taken instead, such as
> a retry.
>
> 2: As a further enhancement to 1: enable any Throwable, including
> checked exceptions. This allows the use of a CountedCompleter as a
> CompletionHandler for asynchronous IO operations or as a wrapper for
> MethodHandles (which throw Throwable) without adding extra logic to
> capture and convert an IO exception. I read the documentation which
> explains why this is currently limited to unchecked exceptions. While I
> can agree with this in general, I feel the argument is weak for
> CountedCompleter if it is there to support asynchronous tasks/events.
> (May I add that using this type of framework is not for the
> faint-hearted anyway!?)
>
> 3: Provide a method to join a task that is not forked and/or not
> completable, while minimizing worker thread blocking. For example,
> CountedCompleter allows creating chains of dependent tasks. Unless the
> ultimate task (the last in the chain) is forked/exists on the task stack
> AND can complete because all dependencies are resolved, joining it will
> block the worker thread. I noticed (and my testing is limited to a few
> test cases and therefore not representative) the blocking and the
> creation of other worker threads, ultimately running out of memory or
> reaching the thread count limit. If this task is not forked, then
> join()/quietlyJoin() will block the worker thread. The following code is
> my (inexpert) attempt to provide a remedy. It is based on the assumption
> that a task that depends on others for completion is not forked until
> all dependencies are resolved. For example, a CountedCompleter
> implementing CompletionHandler would fork itself ("implicit fork") when
> the IO operation is done. This works very well in my test cases, but at
> this time I would not claim it to be universally applicable or error
> free. It is shown here more to demonstrate the attempt rather than as a
> reference implementation. With access to private data structures, this
> can be done more elegantly and more reliably.
>
> ? ? ? ? static final int RETRIES = 16;
> ? ? ? ? static final long WAIT_TIMEOUT = 1_000;? ? // Timeout in
> microseconds.
>
> ? ? ? ? public final void quietlyJoinUnforked() {
> ? ? ? ? ? ? this.doJoinUnforked(false);
> ? ? ? ? }
>
> ? ? ? ? public final void quietlyJoinUnforkedInterruptibly()
> ? ? ? ? throws InterruptedException {
> ? ? ? ? ? ? if (this.doJoinUnforked(true)) {
> ? ? ? ? ? ? ? ? throw new InterruptedException();
> ? ? ? ? ? ? }
> ? ? ? ? }
>
> ? ? ? ? public final boolean doJoinUnforked(final boolean interruptibly) {
> ? ? ? ? ? ? int retries = RETRIES;
> ? ? ? ? ? ? boolean wasInterrupted = false;
> ? ? ? ? ? ? while (!this.isDone()) {
> ? ? ? ? ? ? ? ? ForkJoinTask<?> t;
> ? ? ? ? ? ? ? ? if ((t = pollTask()) != null) {
> ? ? ? ? ? ? ? ? ? ? t.quietlyInvoke();
> ? ? ? ? ? ? ? ? ? ? if (t == this) {
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? else {
> ? ? ? ? ? ? ? ? ? ? if (retries-- > 0) {
> ? ? ? ? ? ? ? ? ? ? ? ? Thread.yield();
> ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? wasInterrupted = Thread.interrupted();
> ? ? ? ? ? ? ? ? ? ? try {
> ? ? ? ? ? ? ? ? ? ? ? ? // get(...) is used as a timed join(). It is
> assumed that
> ? ? ? ? ? ? ? ? ? ? ? ? // other code will perform get() on this task
> to retrieve
> ? ? ? ? ? ? ? ? ? ? ? ? // the task's result or exception.
> ? ? ? ? ? ? ? ? ? ? ? ? this.get(WAIT_TIMEOUT, TimeUnit.MICROSECONDS);
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final InterruptedException consumed) {
> ? ? ? ? ? ? ? ? ? ? ? ? if (!interruptibly) {
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? wasInterrupted = true;
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? ? ? return true;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final ExecutionException ignored) {
> ? ? ? ? ? ? ? ? ? ? ? ? // See comment on get() above.
> ? ? ? ? ? ? ? ? ? ? ? ? break;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? ? ? catch (final TimeoutException ignored) {
> ? ? ? ? ? ? ? ? ? ? ? ? continue;
> ? ? ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? }
> ? ? ? ? ? ? ? ? retries = RETRIES;
> ? ? ? ? ? ? }
> ? ? ? ? ? ? if (wasInterrupted && !interruptibly) {
> ? ? ? ? ? ? ? ? Thread.currentThread().interrupt();
> ? ? ? ? ? ? ? ? return false;
> ? ? ? ? ? ? }
> ? ? ? ? ? ? return wasInterrupted;
> ? ? ? ? }
>
> As already mentioned this works quite well in a number of cases. For
> example, adding this method to the example MergeSort code and calling
> quietlyJoinUnforked(), results in the same overall performance, reduces
> the number of extra blocked worker threads to 1 if any (instead of up to
> 8 for the unmodified code; on a PC with 4 hyper-threading cores/8
> threads), and allows for some extra (recreational?) freedom in joining
> the right and left sub-tasks in any order. It works in cases where no
> sub-task is forked explicitly. I observed that worker thread blocking
> only occurs towards the end of a large recursion, suggesting that worker
> threads only block - as intended - when there is no other work available
> (sometimes while implicit forking has not yet happened).
>
> Wolfgang.
>
>
>
> On 2012-04-09 16:16, Doug Lea wrote:
> >
> > After sitting on multiple variations for months, I committed
> > CountedCompleter, a completion-based flavor of ForkJoinTask.
> >
> > As mentioned a few times over the past year, the main motivation
> > is to better support tasks that perform IO or other base
> > actions that may (or may not) take a lot of time to execute.
> > As is the case with JDK7 async IO and other completion-based
> > frameworks, the most common path to efficiency is for such tasks
> > to arrange continuation actions that occur upon their completion.
> > The main twist for CountedCompleters is that continuations
> > might be dependent on multiple actions, not just one. (Or in
> > other words, the continuations must be preceded by a specialized,
> > "bottom-up" form of join.)
> >
> > The CountedCompleter abstract class provides a minimal basis
> > for these kinds of tasks. While some of the mechanics are
> > reminiscent of other FJ-like frameworks such as Intel TBB,
> > CountedCompleters are designed to fit smoothly with other
> > kinds of ForkJoinTasks (like RecursiveActions), and so still
> > allow people to use the more pleasant Future-style conventions
> > rather than count-based bottom-up joining unless they need them.
> > At the same time, the CountedCompleter class exposes enough
> > mechanics to allow all sorts of tweaks that people can use
> > to improve performance.
> > In particular, in addition to usually being the best way to deal
> > with IO etc bound tasks, CountedCompleters sometimes fare better
> > than RecursiveActions in programs that entail lots of garbage
> > collection because GC can have similar impact on task variability.
> >
> > Even though targeted for JDK8, versions of CountedCompleter
> > appear in the jsr166y and main repositories, not jsr166e. This is
> > because they require a non-public hook into modified ForkJoinTask
> > exception handling mechanics in order to properly propagate
> > exceptional completions. For sources, docs, and jar files, see
> > the usual links at
> > http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> >
> > The API docs include more details and some examples:
> >
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CountedCompleter.html
> >
> >
> > I also added a few (with more to come) test/demo programs that illustrate
> > other usages. See CCBoxedLongSort and CCJacobi in
> > http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
> >
> > Please try these out. As always, comments and suggestions
> > (hopefully based on usage experience) would be welcome.
> >
> > -Doug
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 87, Issue 26
> ****************************************************
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/75746dcb/attachment.html
> >
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 87, Issue 27
> ****************************************************
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/5c5fa2e5/attachment.html>

------------------------------

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


End of Concurrency-interest Digest, Vol 87, Issue 36
****************************************************
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/281c8113/attachment-0001.html>

From coderplay at gmail.com  Tue Apr 17 06:30:17 2012
From: coderplay at gmail.com (Min Zhou)
Date: Tue, 17 Apr 2012 18:30:17 +0800
Subject: [concurrency-interest] ForkJoinPool seems lead to a worse latency
	than traditional ExecutorServices
Message-ID: <CALO_SpTLYGSesKU44e3cyGp8-tS72=RQeGm5GALkch14nKu-_w@mail.gmail.com>

Hi, all,

I tried to use  the newest version of  ForkJoinPool from the cvs repository
of jsr166y to replace the old  ExecutorService on our RPC project
opensource at http://code.google.com/p/nfs-rpc/ .

The modification is quite slight. Here is the diff

Index:
nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java
===================================================================
---
nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java
(revision
0)
+++
nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java
(revision
0)
@@ -0,0 +1,48 @@
+package code.google.nfs.rpc;
+/**
+ * nfs-rpc
+ *   Apache License
+ *
+ *   http://code.google.com/p/nfs-rpc (c) 2011
+ */
+import java.util.concurrent.atomic.AtomicInteger;
+
+import code.google.nfs.rpc.jsr166y.ForkJoinPool;
+import
code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
+import code.google.nfs.rpc.jsr166y.ForkJoinWorkerThread;
+
+/**
+ * Helper class to let user can monitor worker threads.
+ *
+ * @author <a href="mailto:coderplay at gmail.com">coderplay</a>
+ */
+public class NamedForkJoinThreadFactory implements
ForkJoinWorkerThreadFactory {
+
+ static final AtomicInteger poolNumber = new AtomicInteger(1);
+
+    final AtomicInteger threadNumber = new AtomicInteger(1);
+    final String namePrefix;
+    final boolean isDaemon;
+
+    public NamedForkJoinThreadFactory() {
+        this("pool");
+    }
+    public NamedForkJoinThreadFactory(String name) {
+        this(name, false);
+    }
+    public NamedForkJoinThreadFactory(String preffix, boolean daemon) {
+        namePrefix = preffix + "-" + poolNumber.getAndIncrement() +
"-thread-";
+        isDaemon = daemon;
+    }
+
+    @Override
+    public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+        ForkJoinWorkerThread t =
+
 ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+        t.setName(namePrefix + threadNumber.getAndIncrement());
+        t.setDaemon(isDaemon);
+        return t;
+    }
+
+}
+
Index:
nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java
===================================================================
---
nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java
(revision
120)
+++
nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java
(working
copy)
@@ -8,12 +8,10 @@
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;

-import code.google.nfs.rpc.NamedThreadFactory;
+import code.google.nfs.rpc.NamedForkJoinThreadFactory;
+import code.google.nfs.rpc.jsr166y.ForkJoinPool;
+import
code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
 import code.google.nfs.rpc.protocol.PBDecoder;
 import code.google.nfs.rpc.protocol.RPCProtocol;
 import code.google.nfs.rpc.protocol.SimpleProcessorProtocol;
@@ -66,9 +64,13 @@
  });
  server.registerProcessor(RPCProtocol.TYPE, "testservice", new
BenchmarkTestServiceImpl(responseSize));
  server.registerProcessor(RPCProtocol.TYPE, "testservicepb", new
PBBenchmarkTestServiceImpl(responseSize));
- ThreadFactory tf = new NamedThreadFactory("BUSINESSTHREADPOOL");
- ExecutorService threadPool = new ThreadPoolExecutor(20, maxThreads,
- 300, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), tf);
+ ForkJoinWorkerThreadFactory tf = new
NamedForkJoinThreadFactory("BUSINESSTHREADPOOL");
+ ExecutorService threadPool = new ForkJoinPool(maxThreads, tf,
+          new Thread.UncaughtExceptionHandler() {
+              public void uncaughtException(Thread t, Throwable e){
+                // do nothing;
+              };
+          }, true);
  server.start(listenPort, threadPool);
  }


I did a benchmark (see
http://code.google.com/p/nfs-rpc/wiki/HowToRunBenchmark ) with the hope of
significant TPS improvments, but got a bad result cross to the purpose.
 ForkJoinPool (avg response time 12 ms) seems lead to a worse latency than
it did with traditional ExecutorService (avg response time 3ms).

With ForkJoinPool:

----------Benchmark Statistics--------------
 Concurrents: 500
 CodecType: 3
 ClientNums: 1
 RequestSize: 100 bytes
 Runtime: 120 seconds
 Benchmark Time: 81
 Requests: 3740311 Success: 99% (3739274) Error: 0% (1037)
 Avg TPS: 41374 Max TPS: 62881 Min TPS: 3333
 Avg RT: 12ms
 RT <= 0: 0% 1829/3740311
 RT (0,1]: 1% 59989/3740311
 RT (1,5]: 47% 1778386/3740311
 RT (5,10]: 17% 655377/3740311
 RT (10,50]: 32% 1204205/3740311
 RT (50,100]: 0% 31479/3740311
 RT (100,500]: 0% 546/3740311
 RT (500,1000]: 0% 7463/3740311
 RT > 1000: 0% 1037/3740311


With traditional thread pool:
----------Benchmark Statistics--------------
 Concurrents: 500
 CodecType: 3
 ClientNums: 1
 RequestSize: 100 bytes
 Runtime: 120 seconds
 Benchmark Time: 81
 Requests: 12957281 Success: 100% (12957281) Error: 0% (0)
 Avg TPS: 144261 Max TPS: 183390 Min TPS: 81526
 Avg RT: 3ms
 RT <= 0: 0% 3997/12957281
 RT (0,1]: 4% 592905/12957281
 RT (1,5]: 95% 12312500/12957281
 RT (5,10]: 0% 19280/12957281
 RT (10,50]: 0% 92/12957281
 RT (50,100]: 0% 507/12957281
 RT (100,500]: 0% 26500/12957281
 RT (500,1000]: 0% 1500/12957281
 RT > 1000: 0% 0/12957281


I ran this benchmark on two 16 cores Westmere machines ( Xeon E5620 8 core
HT) with the same configuration below of the two tests.

1. JDK version: Oracle 1.7.0_03 (hotspot)

2. client side JVM options:
-Xms4g -Xmx4g -Xmn1g -XX:+PrintGCDetails -XX:+PrintGCDateStamps
-Xloggc:gc.log -Dwrite.statistics=true -XX:+UseParallelGC
-XX:+UseCondCardMark -XX:-UseBiasedLocking
-Djava.ext.dirs=/home/min/nfs-rpc
code.google.nfs.rpc.netty.benchmark.NettySimpleBenchmarkClient 10.232.98.96
8888 500 1000 3 100 120 1

3. server side JVM options:
-Xms2g -Xmx2g -Xmn500m -XX:+UseParallelGC -XX:+PrintGCDetails
-XX:+PrintGCDateStamps -Xloggc:gc.log -XX:+UseCondCardMark
-XX:-UseBiasedLocking -Djava.ext.dirs=/home/min/nfs-rpc
code.google.nfs.rpc.netty.benchmark.NettyBenchmarkServer 8888 100 100

Low context switches, about 8000 per second, is also observed with
ForkJoinPool against to which with the old threadpool it's about 150000.
Benchmarks under Oracle JDK 1.6 is also did by me with similar results.

Is there anyone kindly explain the reason why leading to those describe
above for me ?

Thanks,
Min

-- 
My research interests are distributed systems, parallel computing and
bytecode based virtual machine.

My profile:
http://www.linkedin.com/in/coderplay
My blog:
http://coderplay.javaeye.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/5780b0e9/attachment.html>

From dl at cs.oswego.edu  Tue Apr 17 07:32:00 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 17 Apr 2012 07:32:00 -0400
Subject: [concurrency-interest] CountedCompleters
In-Reply-To: <4F8C313F.2080308@laposte.net>
References: <4F82EF21.4020804@cs.oswego.edu> <4F8C313F.2080308@laposte.net>
Message-ID: <4F8D54B0.8030904@cs.oswego.edu>

Thanks for the suggestions!

On 04/16/12 10:48, Wolfgang Baltes wrote:
> 1: Symmetrically to onCompletion(), provide onExceptionalCompletion(Throwable).
> This allows filtering exception propagation. There are cases where the
> propagation of the exception is desired, and others where a corrective action is
> taken instead, such as a retry.

This is a good idea. One way to do it is to support
   boolean onExceptionalCompletion(Throwable t, CountedCompleter c) {
      return true; // default
   }
that returns false if the exception should not be further propagated
to this task's completer. I had this (without a default) in several
preliminary versions but left it out in attempt to further simplify API.
But given that it can be done with a sensible default, it makes sense
to reinstate it. I'll do this in next commit (which might not be for a
week or so).

>
> 2: As a further enhancement to 1: enable any Throwable, including checked
> exceptions.

The issue boils down to where we'd like users to place exception
code. In the current scheme, any task doing IO etc can do:
   try {
     io();
   } catch(IOException ex) {
      completeExceptionally(ex); // or throw new Error(ex)
      return;
   }

... as opposed to placing the call to compute() itself in
a try/catch. My take is that the current scheme is a little
easier and slightly more pleasant to use. Counter-examples
would be welcome though.

> 3: Provide a method to join a task that is not forked and/or not completable,
> while minimizing worker thread blocking.

Whenever you find yourself wanting to do this, there are better
alternatives that entail creating little trigger
objects. See for example CCBoxedLongSort in
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
I'll add some further examples sometime hopefully soon.


-Doug



From davidcholmes at aapt.net.au  Tue Apr 17 08:13:56 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 17 Apr 2012 22:13:56 +1000
Subject: [concurrency-interest] ForkJoinPool seems lead to a worse
	latencythan traditional ExecutorServices
In-Reply-To: <CALO_SpTLYGSesKU44e3cyGp8-tS72=RQeGm5GALkch14nKu-_w@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEBCJEAA.davidcholmes@aapt.net.au>

What makes your RPC project suitable for Fork/Join parallelism?

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Min Zhou
  Sent: Tuesday, 17 April 2012 8:30 PM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] ForkJoinPool seems lead to a worse
latencythan traditional ExecutorServices


  Hi, all,


  I tried to use  the newest version of  ForkJoinPool from the cvs
repository of jsr166y to replace the old  ExecutorService on our RPC project
opensource at http://code.google.com/p/nfs-rpc/ .


  The modification is quite slight. Here is the diff


  Index:
nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.
java
  ===================================================================
  ---
nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.
java (revision 0)
  +++
nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.
java (revision 0)
  @@ -0,0 +1,48 @@
  +package code.google.nfs.rpc;
  +/**
  + * nfs-rpc
  + *   Apache License
  + *
  + *   http://code.google.com/p/nfs-rpc (c) 2011
  + */
  +import java.util.concurrent.atomic.AtomicInteger;
  +
  +import code.google.nfs.rpc.jsr166y.ForkJoinPool;
  +import
code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
  +import code.google.nfs.rpc.jsr166y.ForkJoinWorkerThread;
  +
  +/**
  + * Helper class to let user can monitor worker threads.
  + *
  + * @author <a href="mailto:coderplay at gmail.com">coderplay</a>
  + */
  +public class NamedForkJoinThreadFactory implements
ForkJoinWorkerThreadFactory {
  +
  + static final AtomicInteger poolNumber = new AtomicInteger(1);
  +
  +    final AtomicInteger threadNumber = new AtomicInteger(1);
  +    final String namePrefix;
  +    final boolean isDaemon;
  +
  +    public NamedForkJoinThreadFactory() {
  +        this("pool");
  +    }
  +    public NamedForkJoinThreadFactory(String name) {
  +        this(name, false);
  +    }
  +    public NamedForkJoinThreadFactory(String preffix, boolean daemon) {
  +        namePrefix = preffix + "-" + poolNumber.getAndIncrement() +
"-thread-";
  +        isDaemon = daemon;
  +    }
  +
  +    @Override
  +    public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
  +        ForkJoinWorkerThread t =
  +
ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
  +        t.setName(namePrefix + threadNumber.getAndIncrement());
  +        t.setDaemon(isDaemon);
  +        return t;
  +    }
  +
  +}
  +
  Index:
nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmark
Server.java
  ===================================================================
  ---
nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmark
Server.java (revision 120)
  +++
nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmark
Server.java (working copy)
  @@ -8,12 +8,10 @@
   import java.text.SimpleDateFormat;
   import java.util.Date;
   import java.util.concurrent.ExecutorService;
  -import java.util.concurrent.SynchronousQueue;
  -import java.util.concurrent.ThreadFactory;
  -import java.util.concurrent.ThreadPoolExecutor;
  -import java.util.concurrent.TimeUnit;

  -import code.google.nfs.rpc.NamedThreadFactory;
  +import code.google.nfs.rpc.NamedForkJoinThreadFactory;
  +import code.google.nfs.rpc.jsr166y.ForkJoinPool;
  +import
code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
   import code.google.nfs.rpc.protocol.PBDecoder;
   import code.google.nfs.rpc.protocol.RPCProtocol;
   import code.google.nfs.rpc.protocol.SimpleProcessorProtocol;
  @@ -66,9 +64,13 @@
    });
    server.registerProcessor(RPCProtocol.TYPE, "testservice", new
BenchmarkTestServiceImpl(responseSize));
    server.registerProcessor(RPCProtocol.TYPE, "testservicepb", new
PBBenchmarkTestServiceImpl(responseSize));
  - ThreadFactory tf = new NamedThreadFactory("BUSINESSTHREADPOOL");
  - ExecutorService threadPool = new ThreadPoolExecutor(20, maxThreads,
  - 300, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), tf);
  + ForkJoinWorkerThreadFactory tf = new
NamedForkJoinThreadFactory("BUSINESSTHREADPOOL");
  + ExecutorService threadPool = new ForkJoinPool(maxThreads, tf,
  +          new Thread.UncaughtExceptionHandler() {
  +              public void uncaughtException(Thread t, Throwable e){
  +                // do nothing;
  +              };
  +          }, true);
    server.start(listenPort, threadPool);
    }




  I did a benchmark (see
http://code.google.com/p/nfs-rpc/wiki/HowToRunBenchmark ) with the hope of
significant TPS improvments, but got a bad result cross to the purpose.
ForkJoinPool (avg response time 12 ms) seems lead to a worse latency than it
did with traditional ExecutorService (avg response time 3ms).


  With ForkJoinPool:


  ----------Benchmark Statistics--------------
   Concurrents: 500
   CodecType: 3
   ClientNums: 1
   RequestSize: 100 bytes
   Runtime: 120 seconds
   Benchmark Time: 81
   Requests: 3740311 Success: 99% (3739274) Error: 0% (1037)
   Avg TPS: 41374 Max TPS: 62881 Min TPS: 3333
   Avg RT: 12ms
   RT <= 0: 0% 1829/3740311
   RT (0,1]: 1% 59989/3740311
   RT (1,5]: 47% 1778386/3740311
   RT (5,10]: 17% 655377/3740311
   RT (10,50]: 32% 1204205/3740311
   RT (50,100]: 0% 31479/3740311
   RT (100,500]: 0% 546/3740311
   RT (500,1000]: 0% 7463/3740311
   RT > 1000: 0% 1037/3740311




  With traditional thread pool:
  ----------Benchmark Statistics--------------
   Concurrents: 500
   CodecType: 3
   ClientNums: 1
   RequestSize: 100 bytes
   Runtime: 120 seconds
   Benchmark Time: 81
   Requests: 12957281 Success: 100% (12957281) Error: 0% (0)
   Avg TPS: 144261 Max TPS: 183390 Min TPS: 81526
   Avg RT: 3ms
   RT <= 0: 0% 3997/12957281
   RT (0,1]: 4% 592905/12957281
   RT (1,5]: 95% 12312500/12957281
   RT (5,10]: 0% 19280/12957281
   RT (10,50]: 0% 92/12957281
   RT (50,100]: 0% 507/12957281
   RT (100,500]: 0% 26500/12957281
   RT (500,1000]: 0% 1500/12957281
   RT > 1000: 0% 0/12957281




  I ran this benchmark on two 16 cores Westmere machines ( Xeon E5620 8 core
HT) with the same configuration below of the two tests.


  1. JDK version: Oracle 1.7.0_03 (hotspot)


  2. client side JVM options:
  -Xms4g -Xmx4g -Xmn1g -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc
.log -Dwrite.statistics=true -XX:+UseParallelGC -XX:+UseCondCardMark -XX:-Us
eBiasedLocking -Djava.ext.dirs=/home/min/nfs-rpc
code.google.nfs.rpc.netty.benchmark.NettySimpleBenchmarkClient 10.232.98.96
8888 500 1000 3 100 120 1


  3. server side JVM options:
  -Xms2g -Xmx2g -Xmn500m -XX:+UseParallelGC -XX:+PrintGCDetails -XX:+PrintGC
DateStamps -Xloggc:gc.log -XX:+UseCondCardMark -XX:-UseBiasedLocking -Djava.
ext.dirs=/home/min/nfs-rpc
code.google.nfs.rpc.netty.benchmark.NettyBenchmarkServer 8888 100 100


  Low context switches, about 8000 per second, is also observed with
ForkJoinPool against to which with the old threadpool it's about 150000.
  Benchmarks under Oracle JDK 1.6 is also did by me with similar results.


  Is there anyone kindly explain the reason why leading to those describe
above for me ?


  Thanks,
  Min


  --
  My research interests are distributed systems, parallel computing and
bytecode based virtual machine.

  My profile:
  http://www.linkedin.com/in/coderplay
  My blog:
  http://coderplay.javaeye.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/5d15ba41/attachment-0001.html>

From wolfgang.baltes at laposte.net  Tue Apr 17 08:47:13 2012
From: wolfgang.baltes at laposte.net (Wolfgang Baltes)
Date: Tue, 17 Apr 2012 14:47:13 +0200
Subject: [concurrency-interest] CountedCompleters
In-Reply-To: <4F8D54B0.8030904@cs.oswego.edu>
References: <4F82EF21.4020804@cs.oswego.edu> <4F8C313F.2080308@laposte.net>
	<4F8D54B0.8030904@cs.oswego.edu>
Message-ID: <4F8D6651.40309@laposte.net>

Hi Doug,

thanks for the feedback. See inline.

By the way, I made a double mistake on the performance of 
quietlyJoinUnforked(). The performance degradation is negligible after 
all. I had tested it and found it to be good. Then I wrote my post and 
made some improvement, followed by another performance test. During this 
test something happened that caused a substantial delay, reason why I 
wrote the apology. But then this test turned out to be erroneous and 
further testing confirmed the initial results (no performance degradation).

W.

On 2012-04-17 13:32, Doug Lea wrote:
> Thanks for the suggestions!
>
> On 04/16/12 10:48, Wolfgang Baltes wrote:
>> 1: Symmetrically to onCompletion(), provide 
>> onExceptionalCompletion(Throwable).
>> This allows filtering exception propagation. There are cases where the
>> propagation of the exception is desired, and others where a 
>> corrective action is
>> taken instead, such as a retry.
>
> This is a good idea. One way to do it is to support
>   boolean onExceptionalCompletion(Throwable t, CountedCompleter c) {
>      return true; // default
>   }
> that returns false if the exception should not be further propagated
> to this task's completer. I had this (without a default) in several
> preliminary versions but left it out in attempt to further simplify API.
> But given that it can be done with a sensible default, it makes sense
> to reinstate it. I'll do this in next commit (which might not be for a
> week or so).

Glad to hear you will do this. This is the most important of my 
suggestions; it is the only one for which there is no work around at 
all. Thanks!
>>
>> 2: As a further enhancement to 1: enable any Throwable, including 
>> checked
>> exceptions.
>
> The issue boils down to where we'd like users to place exception
> code. In the current scheme, any task doing IO etc can do:
>   try {
>     io();
>   } catch(IOException ex) {
>      completeExceptionally(ex); // or throw new Error(ex)
>      return;
>   }
>
> ... as opposed to placing the call to compute() itself in
> a try/catch. My take is that the current scheme is a little
> easier and slightly more pleasant to use. Counter-examples
> would be welcome though.
>
This is what I do now. But there is already a try construct in the main 
worker thread loop, and this adds an extra try block. This requires some 
extra time to execute, which is even more annoying as it will be 
executed every time the task is run.
>> 3: Provide a method to join a task that is not forked and/or not 
>> completable,
>> while minimizing worker thread blocking.
>
> Whenever you find yourself wanting to do this, there are better
> alternatives that entail creating little trigger
> objects. See for example CCBoxedLongSort in
> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/
> I'll add some further examples sometime hopefully soon.
>
I am aware of the trigger object idea. You also use it in the class 
documentation for CountedCompleter. This assumes that every task can be 
split in a way as to isolate the trigger action into an "external sub 
task". This may be difficult/tricky to do when this occurs in a 
conditional or iteration constructs. In this case you would have to have 
your trigger circle back to the main task and deal with it in its 
onCompletion() method, or create longer task chains. I think this is 
possible in some cases, but difficult and awkward in others. At a 
minimum, it requires a lot of extra boilerplate code to just set up all 
the different tasks.
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From davidcholmes at aapt.net.au  Tue Apr 17 08:51:20 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 17 Apr 2012 22:51:20 +1000
Subject: [concurrency-interest] ForkJoinPool seems lead to a
	worselatencythan traditional ExecutorServices
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEBCJEAA.davidcholmes@aapt.net.au>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEBDJEAA.davidcholmes@aapt.net.au>

Sorry that was somewhat terse.

ForkJoinPool is not a drop-in replacement as an arbitrary ExecutorService.
It is specifically design to efficiently execute tasks that implement
fork/join parallelism. If your tasks don't perform fork/join parallelism but
are plain old Runnables/callables that do blocking I/O and other "regular"
programming operations then they will not likely see any benefit from using
a ForkJoinPool.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of David Holmes
  Sent: Tuesday, 17 April 2012 10:14 PM
  To: Min Zhou; concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] ForkJoinPool seems lead to a
worselatencythan traditional ExecutorServices


  What makes your RPC project suitable for Fork/Join parallelism?

  David Holmes
    -----Original Message-----
    From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Min Zhou
    Sent: Tuesday, 17 April 2012 8:30 PM
    To: concurrency-interest at cs.oswego.edu
    Subject: [concurrency-interest] ForkJoinPool seems lead to a worse
latencythan traditional ExecutorServices


    Hi, all,


    I tried to use  the newest version of  ForkJoinPool from the cvs
repository of jsr166y to replace the old  ExecutorService on our RPC project
opensource at http://code.google.com/p/nfs-rpc/ .


    The modification is quite slight. Here is the diff


    Index:
nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.
java
    ===================================================================
    ---
nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.
java (revision 0)
    +++
nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.
java (revision 0)
    @@ -0,0 +1,48 @@
    +package code.google.nfs.rpc;
    +/**
    + * nfs-rpc
    + *   Apache License
    + *
    + *   http://code.google.com/p/nfs-rpc (c) 2011
    + */
    +import java.util.concurrent.atomic.AtomicInteger;
    +
    +import code.google.nfs.rpc.jsr166y.ForkJoinPool;
    +import
code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
    +import code.google.nfs.rpc.jsr166y.ForkJoinWorkerThread;
    +
    +/**
    + * Helper class to let user can monitor worker threads.
    + *
    + * @author <a href="mailto:coderplay at gmail.com">coderplay</a>
    + */
    +public class NamedForkJoinThreadFactory implements
ForkJoinWorkerThreadFactory {
    +
    + static final AtomicInteger poolNumber = new AtomicInteger(1);
    +
    +    final AtomicInteger threadNumber = new AtomicInteger(1);
    +    final String namePrefix;
    +    final boolean isDaemon;
    +
    +    public NamedForkJoinThreadFactory() {
    +        this("pool");
    +    }
    +    public NamedForkJoinThreadFactory(String name) {
    +        this(name, false);
    +    }
    +    public NamedForkJoinThreadFactory(String preffix, boolean daemon) {
    +        namePrefix = preffix + "-" + poolNumber.getAndIncrement() +
"-thread-";
    +        isDaemon = daemon;
    +    }
    +
    +    @Override
    +    public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
    +        ForkJoinWorkerThread t =
    +
ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
    +        t.setName(namePrefix + threadNumber.getAndIncrement());
    +        t.setDaemon(isDaemon);
    +        return t;
    +    }
    +
    +}
    +
    Index:
nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmark
Server.java
    ===================================================================
    ---
nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmark
Server.java (revision 120)
    +++
nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmark
Server.java (working copy)
    @@ -8,12 +8,10 @@
     import java.text.SimpleDateFormat;
     import java.util.Date;
     import java.util.concurrent.ExecutorService;
    -import java.util.concurrent.SynchronousQueue;
    -import java.util.concurrent.ThreadFactory;
    -import java.util.concurrent.ThreadPoolExecutor;
    -import java.util.concurrent.TimeUnit;

    -import code.google.nfs.rpc.NamedThreadFactory;
    +import code.google.nfs.rpc.NamedForkJoinThreadFactory;
    +import code.google.nfs.rpc.jsr166y.ForkJoinPool;
    +import
code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
     import code.google.nfs.rpc.protocol.PBDecoder;
     import code.google.nfs.rpc.protocol.RPCProtocol;
     import code.google.nfs.rpc.protocol.SimpleProcessorProtocol;
    @@ -66,9 +64,13 @@
      });
      server.registerProcessor(RPCProtocol.TYPE, "testservice", new
BenchmarkTestServiceImpl(responseSize));
      server.registerProcessor(RPCProtocol.TYPE, "testservicepb", new
PBBenchmarkTestServiceImpl(responseSize));
    - ThreadFactory tf = new NamedThreadFactory("BUSINESSTHREADPOOL");
    - ExecutorService threadPool = new ThreadPoolExecutor(20, maxThreads,
    - 300, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), tf);
    + ForkJoinWorkerThreadFactory tf = new
NamedForkJoinThreadFactory("BUSINESSTHREADPOOL");
    + ExecutorService threadPool = new ForkJoinPool(maxThreads, tf,
    +          new Thread.UncaughtExceptionHandler() {
    +              public void uncaughtException(Thread t, Throwable e){
    +                // do nothing;
    +              };
    +          }, true);
      server.start(listenPort, threadPool);
      }




    I did a benchmark (see
http://code.google.com/p/nfs-rpc/wiki/HowToRunBenchmark ) with the hope of
significant TPS improvments, but got a bad result cross to the purpose.
ForkJoinPool (avg response time 12 ms) seems lead to a worse latency than it
did with traditional ExecutorService (avg response time 3ms).


    With ForkJoinPool:


    ----------Benchmark Statistics--------------
     Concurrents: 500
     CodecType: 3
     ClientNums: 1
     RequestSize: 100 bytes
     Runtime: 120 seconds
     Benchmark Time: 81
     Requests: 3740311 Success: 99% (3739274) Error: 0% (1037)
     Avg TPS: 41374 Max TPS: 62881 Min TPS: 3333
     Avg RT: 12ms
     RT <= 0: 0% 1829/3740311
     RT (0,1]: 1% 59989/3740311
     RT (1,5]: 47% 1778386/3740311
     RT (5,10]: 17% 655377/3740311
     RT (10,50]: 32% 1204205/3740311
     RT (50,100]: 0% 31479/3740311
     RT (100,500]: 0% 546/3740311
     RT (500,1000]: 0% 7463/3740311
     RT > 1000: 0% 1037/3740311




    With traditional thread pool:
    ----------Benchmark Statistics--------------
     Concurrents: 500
     CodecType: 3
     ClientNums: 1
     RequestSize: 100 bytes
     Runtime: 120 seconds
     Benchmark Time: 81
     Requests: 12957281 Success: 100% (12957281) Error: 0% (0)
     Avg TPS: 144261 Max TPS: 183390 Min TPS: 81526
     Avg RT: 3ms
     RT <= 0: 0% 3997/12957281
     RT (0,1]: 4% 592905/12957281
     RT (1,5]: 95% 12312500/12957281
     RT (5,10]: 0% 19280/12957281
     RT (10,50]: 0% 92/12957281
     RT (50,100]: 0% 507/12957281
     RT (100,500]: 0% 26500/12957281
     RT (500,1000]: 0% 1500/12957281
     RT > 1000: 0% 0/12957281




    I ran this benchmark on two 16 cores Westmere machines ( Xeon E5620 8
core HT) with the same configuration below of the two tests.


    1. JDK version: Oracle 1.7.0_03 (hotspot)


    2. client side JVM options:
    -Xms4g -Xmx4g -Xmn1g -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:
gc.log -Dwrite.statistics=true -XX:+UseParallelGC -XX:+UseCondCardMark -XX:-
UseBiasedLocking -Djava.ext.dirs=/home/min/nfs-rpc
code.google.nfs.rpc.netty.benchmark.NettySimpleBenchmarkClient 10.232.98.96
8888 500 1000 3 100 120 1


    3. server side JVM options:
    -Xms2g -Xmx2g -Xmn500m -XX:+UseParallelGC -XX:+PrintGCDetails -XX:+Print
GCDateStamps -Xloggc:gc.log -XX:+UseCondCardMark -XX:-UseBiasedLocking -Djav
a.ext.dirs=/home/min/nfs-rpc
code.google.nfs.rpc.netty.benchmark.NettyBenchmarkServer 8888 100 100


    Low context switches, about 8000 per second, is also observed with
ForkJoinPool against to which with the old threadpool it's about 150000.
    Benchmarks under Oracle JDK 1.6 is also did by me with similar results.


    Is there anyone kindly explain the reason why leading to those describe
above for me ?


    Thanks,
    Min


    --
    My research interests are distributed systems, parallel computing and
bytecode based virtual machine.

    My profile:
    http://www.linkedin.com/in/coderplay
    My blog:
    http://coderplay.javaeye.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/956c46a6/attachment-0001.html>

From viktor.klang at gmail.com  Tue Apr 17 09:22:41 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Tue, 17 Apr 2012 15:22:41 +0200
Subject: [concurrency-interest] ForkJoinPool seems lead to a
 worselatencythan traditional ExecutorServices
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEBDJEAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCOEBCJEAA.davidcholmes@aapt.net.au>
	<NFBBKALFDCPFIDBNKAPCEEBDJEAA.davidcholmes@aapt.net.au>
Message-ID: <CANPzfU8Pn7-mFH69O5kP75qUgBg9EYq8==XHEPjbzhkp_GLzuA@mail.gmail.com>

On Tue, Apr 17, 2012 at 2:51 PM, David Holmes <davidcholmes at aapt.net.au>wrote:

> **
> Sorry that was somewhat terse.
>
> ForkJoinPool is not a drop-in replacement as an arbitrary ExecutorService.
> It is specifically design to efficiently execute tasks that implement
> fork/join parallelism. If your tasks don't perform fork/join parallelism
> but are plain old Runnables/callables that do blocking I/O and other
> "regular" programming operations then they will not likely see any benefit
> from using a ForkJoinPool.
>

I disagree:

http://letitcrash.com/post/20397701710/50-million-messages-per-second-on-a-single-machine

Cheers,
?


>
> David
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *David Holmes
> *Sent:* Tuesday, 17 April 2012 10:14 PM
> *To:* Min Zhou; concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] ForkJoinPool seems lead to a
> worselatencythan traditional ExecutorServices
>
> What makes your RPC project suitable for Fork/Join parallelism?
>
> David Holmes
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Min Zhou
> *Sent:* Tuesday, 17 April 2012 8:30 PM
> *To:* concurrency-interest at cs.oswego.edu
> *Subject:* [concurrency-interest] ForkJoinPool seems lead to a worse
> latencythan traditional ExecutorServices
>
> Hi, all,
>
> I tried to use  the newest version of  ForkJoinPool from the cvs
> repository of jsr166y to replace the old  ExecutorService on our RPC
> project opensource at http://code.google.com/p/nfs-rpc/ .
>
> The modification is quite slight. Here is the diff
>
>  Index:
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java
> ===================================================================
> ---
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java (revision
> 0)
> +++
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java (revision
> 0)
> @@ -0,0 +1,48 @@
> +package code.google.nfs.rpc;
> +/**
> + * nfs-rpc
> + *   Apache License
> + *
> + *   http://code.google.com/p/nfs-rpc (c) 2011
> + */
> +import java.util.concurrent.atomic.AtomicInteger;
> +
> +import code.google.nfs.rpc.jsr166y.ForkJoinPool;
> +import
> code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
> +import code.google.nfs.rpc.jsr166y.ForkJoinWorkerThread;
> +
> +/**
> + * Helper class to let user can monitor worker threads.
> + *
> + * @author <a href="mailto:coderplay at gmail.com">coderplay</a>
> + */
> +public class NamedForkJoinThreadFactory implements
> ForkJoinWorkerThreadFactory {
> +
> + static final AtomicInteger poolNumber = new AtomicInteger(1);
> +
> +    final AtomicInteger threadNumber = new AtomicInteger(1);
> +    final String namePrefix;
> +    final boolean isDaemon;
> +
> +    public NamedForkJoinThreadFactory() {
> +        this("pool");
> +    }
> +    public NamedForkJoinThreadFactory(String name) {
> +        this(name, false);
> +    }
> +    public NamedForkJoinThreadFactory(String preffix, boolean daemon) {
> +        namePrefix = preffix + "-" + poolNumber.getAndIncrement() +
> "-thread-";
> +        isDaemon = daemon;
> +    }
> +
> +    @Override
> +    public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
> +        ForkJoinWorkerThread t =
> +
>  ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
> +        t.setName(namePrefix + threadNumber.getAndIncrement());
> +        t.setDaemon(isDaemon);
> +        return t;
> +    }
> +
> +}
> +
> Index:
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java
> ===================================================================
> ---
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java (revision
> 120)
> +++
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java (working
> copy)
> @@ -8,12 +8,10 @@
>  import java.text.SimpleDateFormat;
>  import java.util.Date;
>  import java.util.concurrent.ExecutorService;
> -import java.util.concurrent.SynchronousQueue;
> -import java.util.concurrent.ThreadFactory;
> -import java.util.concurrent.ThreadPoolExecutor;
> -import java.util.concurrent.TimeUnit;
>
> -import code.google.nfs.rpc.NamedThreadFactory;
> +import code.google.nfs.rpc.NamedForkJoinThreadFactory;
> +import code.google.nfs.rpc.jsr166y.ForkJoinPool;
> +import
> code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
>  import code.google.nfs.rpc.protocol.PBDecoder;
>  import code.google.nfs.rpc.protocol.RPCProtocol;
>  import code.google.nfs.rpc.protocol.SimpleProcessorProtocol;
> @@ -66,9 +64,13 @@
>   });
>   server.registerProcessor(RPCProtocol.TYPE, "testservice", new
> BenchmarkTestServiceImpl(responseSize));
>   server.registerProcessor(RPCProtocol.TYPE, "testservicepb", new
> PBBenchmarkTestServiceImpl(responseSize));
> - ThreadFactory tf = new NamedThreadFactory("BUSINESSTHREADPOOL");
> - ExecutorService threadPool = new ThreadPoolExecutor(20, maxThreads,
> - 300, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), tf);
> + ForkJoinWorkerThreadFactory tf = new
> NamedForkJoinThreadFactory("BUSINESSTHREADPOOL");
> + ExecutorService threadPool = new ForkJoinPool(maxThreads, tf,
> +          new Thread.UncaughtExceptionHandler() {
> +              public void uncaughtException(Thread t, Throwable e){
> +                // do nothing;
> +              };
> +          }, true);
>   server.start(listenPort, threadPool);
>   }
>
>
> I did a benchmark (see
> http://code.google.com/p/nfs-rpc/wiki/HowToRunBenchmark ) with the hope
> of significant TPS improvments, but got a bad result cross to the purpose.
>  ForkJoinPool (avg response time 12 ms) seems lead to a worse latency than
> it did with traditional ExecutorService (avg response time 3ms).
>
> With ForkJoinPool:
>
>  ----------Benchmark Statistics--------------
>  Concurrents: 500
>  CodecType: 3
>  ClientNums: 1
>  RequestSize: 100 bytes
>  Runtime: 120 seconds
>  Benchmark Time: 81
>  Requests: 3740311 Success: 99% (3739274) Error: 0% (1037)
>  Avg TPS: 41374 Max TPS: 62881 Min TPS: 3333
>  Avg RT: 12ms
>  RT <= 0: 0% 1829/3740311
>  RT (0,1]: 1% 59989/3740311
>  RT (1,5]: 47% 1778386/3740311
>  RT (5,10]: 17% 655377/3740311
>  RT (10,50]: 32% 1204205/3740311
>  RT (50,100]: 0% 31479/3740311
>  RT (100,500]: 0% 546/3740311
>  RT (500,1000]: 0% 7463/3740311
>  RT > 1000: 0% 1037/3740311
>
>
> With traditional thread pool:
>  ----------Benchmark Statistics--------------
>  Concurrents: 500
>  CodecType: 3
>  ClientNums: 1
>  RequestSize: 100 bytes
>  Runtime: 120 seconds
>  Benchmark Time: 81
>  Requests: 12957281 Success: 100% (12957281) Error: 0% (0)
>  Avg TPS: 144261 Max TPS: 183390 Min TPS: 81526
>  Avg RT: 3ms
>  RT <= 0: 0% 3997/12957281
>  RT (0,1]: 4% 592905/12957281
>  RT (1,5]: 95% 12312500/12957281
>  RT (5,10]: 0% 19280/12957281
>  RT (10,50]: 0% 92/12957281
>  RT (50,100]: 0% 507/12957281
>  RT (100,500]: 0% 26500/12957281
>  RT (500,1000]: 0% 1500/12957281
>  RT > 1000: 0% 0/12957281
>
>
> I ran this benchmark on two 16 cores Westmere machines ( Xeon E5620 8 core
> HT) with the same configuration below of the two tests.
>
> 1. JDK version: Oracle 1.7.0_03 (hotspot)
>
> 2. client side JVM options:
> -Xms4g -Xmx4g -Xmn1g -XX:+PrintGCDetails -XX:+PrintGCDateStamps
> -Xloggc:gc.log -Dwrite.statistics=true -XX:+UseParallelGC
> -XX:+UseCondCardMark -XX:-UseBiasedLocking
> -Djava.ext.dirs=/home/min/nfs-rpc
> code.google.nfs.rpc.netty.benchmark.NettySimpleBenchmarkClient 10.232.98.96
> 8888 500 1000 3 100 120 1
>
> 3. server side JVM options:
> -Xms2g -Xmx2g -Xmn500m -XX:+UseParallelGC -XX:+PrintGCDetails
> -XX:+PrintGCDateStamps -Xloggc:gc.log -XX:+UseCondCardMark
> -XX:-UseBiasedLocking -Djava.ext.dirs=/home/min/nfs-rpc
> code.google.nfs.rpc.netty.benchmark.NettyBenchmarkServer 8888 100 100
>
> Low context switches, about 8000 per second, is also observed with
> ForkJoinPool against to which with the old threadpool it's about 150000.
> Benchmarks under Oracle JDK 1.6 is also did by me with similar results.
>
> Is there anyone kindly explain the reason why leading to those describe
> above for me ?
>
> Thanks,
> Min
>
> --
> My research interests are distributed systems, parallel computing and
> bytecode based virtual machine.
>
> My profile:
> http://www.linkedin.com/in/coderplay
> My blog:
> http://coderplay.javaeye.com
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/cedcd3b4/attachment.html>

From gregg at cytetech.com  Tue Apr 17 09:31:55 2012
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 17 Apr 2012 08:31:55 -0500
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 87,
 Issue 27
In-Reply-To: <CAEtTSAaM_O8LGvMFczjZuhxoM0_H3xHAZYvYpEWCBTdCCLSO3w@mail.gmail.com>
References: <mailman.117.1334596831.3324.concurrency-interest@cs.oswego.edu>
	<1334601360.99294.YahooMailNeo@web193402.mail.sg3.yahoo.com>
	<4F8C7190.6030103@oracle.com>
	<1334605528.11594.YahooMailNeo@web193406.mail.sg3.yahoo.com>
	<CAEtTSAaM_O8LGvMFczjZuhxoM0_H3xHAZYvYpEWCBTdCCLSO3w@mail.gmail.com>
Message-ID: <4F8D70CB.6090208@cytetech.com>

On 4/16/2012 2:53 PM, Khilan Gudka wrote:
> While it is true that using explicit locks gives you more flexibility, i think a
> distinction needs to be made here between preventing deadlock from occurring but
> it being too late to rectify things (your approach if am not mistaken) versus
> not ever reaching a situation where deadlock could even be detected (gadara).
>
> The former is obviously useful because at least it means your system cannot
> hang, but then the next question is how does the system continue when you have
> detected deadlock? In particular, if you have to release multiple locks, how do
> you rollback side effects that have been made in the mean-time?

The most obvious way to accomplish this, is to use transactional behaviors so 
that at any level, permanent changes in state can be reverted to a "safe" form 
by causing a transaction or transactional-like rollback.

In Java, the Jini (now Apache River) platform provides a distributed transaction 
service which makes it possible to do this relatively easily.  In JavaEE 
applications, there is, of course, transactions already available for "database" 
kinds of transactions.

It requires a more deliberate software failure design focus, but that is what 
Jini has been about all along.  In a "distributed" (at the thread, process or 
machine level) system, partial failure must be dealt with effectively.

Transactional behaviors are what makes the most sense, but you need to be able 
to do the "rollback" without acquiring any additional locks.  Code blocks such 
as the following,

FileInputStream fs = new FileInputStream( inFile );
try {
	readContentAndProcessFrom(fs);
	inputRead = true;
} catch( IOException ex ) {
	reportIOExceptionOnFile( ex, inFile );
	return false;
} catch( RuntimeException ex ) {
	reportProcessingException( ex, inFile );
	return false;
} finally {
	fs.close();
}
return true;

have transactional behaviors because they indicate the progress made, 
definitively, so that your application can "recoup" after an unexpected
error (return false;) and be ready to try again with no "hung state".

Using Jini transactions, I've written applications which keep multiple instances 
of postgres databases in sync.  The use of Jini leasing also lets you monitor 
progress, and use another thread to "cancel" a transaction so that lack of 
progress can be overted, appropriately.

Gregg Wonderly

From gregg at cytetech.com  Tue Apr 17 09:47:48 2012
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 17 Apr 2012 08:47:48 -0500
Subject: [concurrency-interest] ForkJoinPool seems lead to a
 worselatencythan traditional ExecutorServices
In-Reply-To: <CANPzfU8Pn7-mFH69O5kP75qUgBg9EYq8==XHEPjbzhkp_GLzuA@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCOEBCJEAA.davidcholmes@aapt.net.au>
	<NFBBKALFDCPFIDBNKAPCEEBDJEAA.davidcholmes@aapt.net.au>
	<CANPzfU8Pn7-mFH69O5kP75qUgBg9EYq8==XHEPjbzhkp_GLzuA@mail.gmail.com>
Message-ID: <4F8D7484.9040400@cytetech.com>

On 4/17/2012 8:22 AM, ?iktor ?lang wrote:
>
>
> On Tue, Apr 17, 2012 at 2:51 PM, David Holmes <davidcholmes at aapt.net.au
> <mailto:davidcholmes at aapt.net.au>> wrote:
>
>     __
>     Sorry that was somewhat terse.
>     ForkJoinPool is not a drop-in replacement as an arbitrary ExecutorService.
>     It is specifically design to efficiently execute tasks that implement
>     fork/join parallelism. If your tasks don't perform fork/join parallelism but
>     are plain old Runnables/callables that do blocking I/O and other "regular"
>     programming operations then they will not likely see any benefit from using
>     a ForkJoinPool.
>
>
> I disagree:
>
> http://letitcrash.com/post/20397701710/50-million-messages-per-second-on-a-single-machine

That has nothing to do with the use of ForkJoin it appears to me.  It is simply 
a thread use efficiency change that causes a scheduled thread to do enough work 
that the latency of scheduling becomes a small enough component that it 
disappears from view because the other thread is running (2 are available per 
core) while scheduling occurs.

This would happen no matter what kind of thread pool was used, with appropriate 
timings/thread-scheduling that created the same effect.

Gregg Wonderly

From viktor.klang at gmail.com  Tue Apr 17 09:51:06 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Tue, 17 Apr 2012 15:51:06 +0200
Subject: [concurrency-interest] ForkJoinPool seems lead to a
 worselatencythan traditional ExecutorServices
In-Reply-To: <4F8D7484.9040400@cytetech.com>
References: <NFBBKALFDCPFIDBNKAPCOEBCJEAA.davidcholmes@aapt.net.au>
	<NFBBKALFDCPFIDBNKAPCEEBDJEAA.davidcholmes@aapt.net.au>
	<CANPzfU8Pn7-mFH69O5kP75qUgBg9EYq8==XHEPjbzhkp_GLzuA@mail.gmail.com>
	<4F8D7484.9040400@cytetech.com>
Message-ID: <CANPzfU_tSzpAhhab3LxfK6ANj1Fm1MDiJCtDs6apWHE-Xubidg@mail.gmail.com>

2012/4/17 Gregg Wonderly <gregg at cytetech.com>

> On 4/17/2012 8:22 AM, ?iktor ?lang wrote:
>
>>
>>
>> On Tue, Apr 17, 2012 at 2:51 PM, David Holmes <davidcholmes at aapt.net.au
>> <mailto:davidcholmes at aapt.net.**au <davidcholmes at aapt.net.au>>> wrote:
>>
>>    __
>>
>>    Sorry that was somewhat terse.
>>    ForkJoinPool is not a drop-in replacement as an arbitrary
>> ExecutorService.
>>    It is specifically design to efficiently execute tasks that implement
>>    fork/join parallelism. If your tasks don't perform fork/join
>> parallelism but
>>    are plain old Runnables/callables that do blocking I/O and other
>> "regular"
>>    programming operations then they will not likely see any benefit from
>> using
>>    a ForkJoinPool.
>>
>>
>> I disagree:
>>
>> http://letitcrash.com/post/**20397701710/50-million-**
>> messages-per-second-on-a-**single-machine<http://letitcrash.com/post/20397701710/50-million-messages-per-second-on-a-single-machine>
>>
>
> That has nothing to do with the use of ForkJoin it appears to me.  It is
> simply a thread use efficiency change that causes a scheduled thread to do
> enough work that the latency of scheduling becomes a small enough component
> that it disappears from view because the other thread is running (2 are
> available per core) while scheduling occurs.
>
> This would happen no matter what kind of thread pool was used, with
> appropriate timings/thread-scheduling that created the same effect.


No, the scalability of the ForkJoinPoll is extremely much better than other
j.u.c implementations:

http://letitcrash.com/post/17607272336/scalability-of-fork-join-pool

Cheers,
?


>
>
> Gregg Wonderly
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/f2f86e04/attachment.html>

From gregg at cytetech.com  Tue Apr 17 10:03:54 2012
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 17 Apr 2012 09:03:54 -0500
Subject: [concurrency-interest] ForkJoinPool seems lead to a
 worselatencythan traditional ExecutorServices
In-Reply-To: <CANPzfU_tSzpAhhab3LxfK6ANj1Fm1MDiJCtDs6apWHE-Xubidg@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCOEBCJEAA.davidcholmes@aapt.net.au>
	<NFBBKALFDCPFIDBNKAPCEEBDJEAA.davidcholmes@aapt.net.au>
	<CANPzfU8Pn7-mFH69O5kP75qUgBg9EYq8==XHEPjbzhkp_GLzuA@mail.gmail.com>
	<4F8D7484.9040400@cytetech.com>
	<CANPzfU_tSzpAhhab3LxfK6ANj1Fm1MDiJCtDs6apWHE-Xubidg@mail.gmail.com>
Message-ID: <4F8D784A.1060807@cytetech.com>

On 4/17/2012 8:51 AM, ?iktor ?lang wrote:
>
>
> 2012/4/17 Gregg Wonderly <gregg at cytetech.com <mailto:gregg at cytetech.com>>
>
>     On 4/17/2012 8:22 AM, ?iktor ?lang wrote:
>
>
>
>         On Tue, Apr 17, 2012 at 2:51 PM, David Holmes <davidcholmes at aapt.net.au
>         <mailto:davidcholmes at aapt.net.au>
>         <mailto:davidcholmes at aapt.net.__au <mailto:davidcholmes at aapt.net.au>>>
>         wrote:
>
>             __
>
>             Sorry that was somewhat terse.
>             ForkJoinPool is not a drop-in replacement as an arbitrary
>         ExecutorService.
>             It is specifically design to efficiently execute tasks that implement
>             fork/join parallelism. If your tasks don't perform fork/join
>         parallelism but
>             are plain old Runnables/callables that do blocking I/O and other
>         "regular"
>             programming operations then they will not likely see any benefit
>         from using
>             a ForkJoinPool.
>
>
>         I disagree:
>
>         http://letitcrash.com/post/__20397701710/50-million-__messages-per-second-on-a-__single-machine
>         <http://letitcrash.com/post/20397701710/50-million-messages-per-second-on-a-single-machine>
>
>
>     That has nothing to do with the use of ForkJoin it appears to me.  It is
>     simply a thread use efficiency change that causes a scheduled thread to do
>     enough work that the latency of scheduling becomes a small enough component
>     that it disappears from view because the other thread is running (2 are
>     available per core) while scheduling occurs.
>
>     This would happen no matter what kind of thread pool was used, with
>     appropriate timings/thread-scheduling that created the same effect.
>
>
> No, the scalability of the ForkJoinPoll is extremely much better than other
> j.u.c implementations:

The example you pointed at, had nothing to do with using forkjoin.  It merely 
demonstrated that if you have twice as many threads, as cores, that you could 
start to hide the scheduling overhead/context switch latency by performing work 
in one thread while another thread had encountered some form of scheduling 
latency.  That example showed that somewhere around 50 messages could be 
processed in the time that it took to switch to another thread.  Once you hit 
that wall, no more progress is made.

 > http://letitcrash.com/post/17607272336/scalability-of-fork-join-pool

Yes, this page does say:

"When using thread pool executor (java.util.concurrent.ThreadPoolExecutor) the 
benchmark didn?t scale beyond 12 parallel actors. "

and I will agree that there are efficiency issues indicated in that statement, 
but without source code to look at, it's not really possible to understand where 
there might be problems in the benchmark code.

ForkJoin is about efficiency for many classes of problems, but this problem in 
particular, is not one that I would use ForkJoin for.  It would, of used my own 
thread pool, specifically because I know all about many inefficiencies and 
undesirable side effects of using TPE to just schedule a bunch of threads for 
parallelism.  I only use TPE as a means to throttle thread use against bursty 
loads that work much better with TPE and a queue that blocks on full insert 
attempts.

Gregg

 >Cheers,
 >?

From coderplay at gmail.com  Tue Apr 17 10:46:17 2012
From: coderplay at gmail.com (Min Zhou)
Date: Tue, 17 Apr 2012 22:46:17 +0800
Subject: [concurrency-interest] ForkJoinPool seems lead to a worse
 latencythan traditional ExecutorServices
In-Reply-To: <CALO_SpRSgaMApus3A13sDA-2_2EUqcTnvcZTdoGHYj55_vBEwg@mail.gmail.com>
References: <CALO_SpTLYGSesKU44e3cyGp8-tS72=RQeGm5GALkch14nKu-_w@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCOEBCJEAA.davidcholmes@aapt.net.au>
	<CALO_SpRSgaMApus3A13sDA-2_2EUqcTnvcZTdoGHYj55_vBEwg@mail.gmail.com>
Message-ID: <CALO_SpRTpRKwEQddpVL-ZaTLh4Xi435o2yFbdL-VhSEmD5u=9A@mail.gmail.com>

I use the F/J in the server side , where a  few of threads in the front-end
is used to the I/O workloads like accepting connection requests,
receiving/sending messages from clients, as well as (un)marshalling
packets. After messages is received and unmarshalled by those threads,
those messages will be put into a back-end thread pool where F/J is adopted
for doing the business things.  Actually, I am not very sure whether F/J is
suitable for that scenario.

Thanks,
Min


On Tue, Apr 17, 2012 at 8:13 PM, David Holmes <davidcholmes at aapt.net.au>wrote:

> **
> What makes your RPC project suitable for Fork/Join parallelism?
>
> David Holmes
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Min Zhou
> *Sent:* Tuesday, 17 April 2012 8:30 PM
> *To:* concurrency-interest at cs.oswego.edu
> *Subject:* [concurrency-interest] ForkJoinPool seems lead to a worse
> latencythan traditional ExecutorServices
>
> Hi, all,
>
> I tried to use  the newest version of  ForkJoinPool from the cvs
> repository of jsr166y to replace the old  ExecutorService on our RPC
> project opensource at http://code.google.com/p/nfs-rpc/ .
>
> The modification is quite slight. Here is the diff
>
>  Index:
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java
> ===================================================================
> ---
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java (revision
> 0)
> +++
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java (revision
> 0)
> @@ -0,0 +1,48 @@
> +package code.google.nfs.rpc;
> +/**
> + * nfs-rpc
> + *   Apache License
> + *
> + *   http://code.google.com/p/nfs-rpc (c) 2011
> + */
> +import java.util.concurrent.atomic.AtomicInteger;
> +
> +import code.google.nfs.rpc.jsr166y.ForkJoinPool;
> +import
> code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
> +import code.google.nfs.rpc.jsr166y.ForkJoinWorkerThread;
> +
> +/**
> + * Helper class to let user can monitor worker threads.
> + *
> + * @author <a href="mailto:coderplay at gmail.com">coderplay</a>
> + */
> +public class NamedForkJoinThreadFactory implements
> ForkJoinWorkerThreadFactory {
> +
> + static final AtomicInteger poolNumber = new AtomicInteger(1);
> +
> +    final AtomicInteger threadNumber = new AtomicInteger(1);
> +    final String namePrefix;
> +    final boolean isDaemon;
> +
> +    public NamedForkJoinThreadFactory() {
> +        this("pool");
> +    }
> +    public NamedForkJoinThreadFactory(String name) {
> +        this(name, false);
> +    }
> +    public NamedForkJoinThreadFactory(String preffix, boolean daemon) {
> +        namePrefix = preffix + "-" + poolNumber.getAndIncrement() +
> "-thread-";
> +        isDaemon = daemon;
> +    }
> +
> +    @Override
> +    public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
> +        ForkJoinWorkerThread t =
> +
>  ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
> +        t.setName(namePrefix + threadNumber.getAndIncrement());
> +        t.setDaemon(isDaemon);
> +        return t;
> +    }
> +
> +}
> +
> Index:
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java
> ===================================================================
> ---
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java (revision
> 120)
> +++
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java (working
> copy)
> @@ -8,12 +8,10 @@
>  import java.text.SimpleDateFormat;
>  import java.util.Date;
>  import java.util.concurrent.ExecutorService;
> -import java.util.concurrent.SynchronousQueue;
> -import java.util.concurrent.ThreadFactory;
> -import java.util.concurrent.ThreadPoolExecutor;
> -import java.util.concurrent.TimeUnit;
>
> -import code.google.nfs.rpc.NamedThreadFactory;
> +import code.google.nfs.rpc.NamedForkJoinThreadFactory;
> +import code.google.nfs.rpc.jsr166y.ForkJoinPool;
> +import
> code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
>  import code.google.nfs.rpc.protocol.PBDecoder;
>  import code.google.nfs.rpc.protocol.RPCProtocol;
>  import code.google.nfs.rpc.protocol.SimpleProcessorProtocol;
> @@ -66,9 +64,13 @@
>   });
>   server.registerProcessor(RPCProtocol.TYPE, "testservice", new
> BenchmarkTestServiceImpl(responseSize));
>   server.registerProcessor(RPCProtocol.TYPE, "testservicepb", new
> PBBenchmarkTestServiceImpl(responseSize));
> - ThreadFactory tf = new NamedThreadFactory("BUSINESSTHREADPOOL");
> - ExecutorService threadPool = new ThreadPoolExecutor(20, maxThreads,
> - 300, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), tf);
> + ForkJoinWorkerThreadFactory tf = new
> NamedForkJoinThreadFactory("BUSINESSTHREADPOOL");
> + ExecutorService threadPool = new ForkJoinPool(maxThreads, tf,
> +          new Thread.UncaughtExceptionHandler() {
> +              public void uncaughtException(Thread t, Throwable e){
> +                // do nothing;
> +              };
> +          }, true);
>   server.start(listenPort, threadPool);
>   }
>
>
> I did a benchmark (see
> http://code.google.com/p/nfs-rpc/wiki/HowToRunBenchmark ) with the hope
> of significant TPS improvments, but got a bad result cross to the purpose.
>  ForkJoinPool (avg response time 12 ms) seems lead to a worse latency than
> it did with traditional ExecutorService (avg response time 3ms).
>
> With ForkJoinPool:
>
>  ----------Benchmark Statistics--------------
>  Concurrents: 500
>  CodecType: 3
>  ClientNums: 1
>  RequestSize: 100 bytes
>  Runtime: 120 seconds
>  Benchmark Time: 81
>  Requests: 3740311 Success: 99% (3739274) Error: 0% (1037)
>  Avg TPS: 41374 Max TPS: 62881 Min TPS: 3333
>  Avg RT: 12ms
>  RT <= 0: 0% 1829/3740311
>  RT (0,1]: 1% 59989/3740311
>  RT (1,5]: 47% 1778386/3740311
>  RT (5,10]: 17% 655377/3740311
>  RT (10,50]: 32% 1204205/3740311
>  RT (50,100]: 0% 31479/3740311
>  RT (100,500]: 0% 546/3740311
>  RT (500,1000]: 0% 7463/3740311
>  RT > 1000: 0% 1037/3740311
>
>
> With traditional thread pool:
>  ----------Benchmark Statistics--------------
>  Concurrents: 500
>  CodecType: 3
>  ClientNums: 1
>  RequestSize: 100 bytes
>  Runtime: 120 seconds
>  Benchmark Time: 81
>  Requests: 12957281 Success: 100% (12957281) Error: 0% (0)
>  Avg TPS: 144261 Max TPS: 183390 Min TPS: 81526
>  Avg RT: 3ms
>  RT <= 0: 0% 3997/12957281
>  RT (0,1]: 4% 592905/12957281
>  RT (1,5]: 95% 12312500/12957281
>  RT (5,10]: 0% 19280/12957281
>  RT (10,50]: 0% 92/12957281
>  RT (50,100]: 0% 507/12957281
>  RT (100,500]: 0% 26500/12957281
>  RT (500,1000]: 0% 1500/12957281
>  RT > 1000: 0% 0/12957281
>
>
> I ran this benchmark on two 16 cores Westmere machines ( Xeon E5620 8 core
> HT) with the same configuration below of the two tests.
>
> 1. JDK version: Oracle 1.7.0_03 (hotspot)
>
> 2. client side JVM options:
> -Xms4g -Xmx4g -Xmn1g -XX:+PrintGCDetails -XX:+PrintGCDateStamps
> -Xloggc:gc.log -Dwrite.statistics=true -XX:+UseParallelGC
> -XX:+UseCondCardMark -XX:-UseBiasedLocking
> -Djava.ext.dirs=/home/min/nfs-rpc
> code.google.nfs.rpc.netty.benchmark.NettySimpleBenchmarkClient 10.232.98.96
> 8888 500 1000 3 100 120 1
>
> 3. server side JVM options:
> -Xms2g -Xmx2g -Xmn500m -XX:+UseParallelGC -XX:+PrintGCDetails
> -XX:+PrintGCDateStamps -Xloggc:gc.log -XX:+UseCondCardMark
> -XX:-UseBiasedLocking -Djava.ext.dirs=/home/min/nfs-rpc
> code.google.nfs.rpc.netty.benchmark.NettyBenchmarkServer 8888 100 100
>
> Low context switches, about 8000 per second, is also observed with
> ForkJoinPool against to which with the old threadpool it's about 150000.
> Benchmarks under Oracle JDK 1.6 is also did by me with similar results.
>
> Is there anyone kindly explain the reason why leading to those describe
> above for me ?
>
> Thanks,
> Min
>
> --
> My research interests are distributed systems, parallel computing and
> bytecode based virtual machine.
>
> My profile:
> http://www.linkedin.com/in/coderplay
> My blog:
> http://coderplay.javaeye.com
>
>


-- 
My research interests are distributed systems, parallel computing and
bytecode based virtual machine.

My profile:
http://www.linkedin.com/in/coderplay
My blog:
http://coderplay.javaeye.com



-- 
My research interests are distributed systems, parallel computing and
bytecode based virtual machine.

My profile:
http://www.linkedin.com/in/coderplay
My blog:
http://coderplay.javaeye.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/3e4cb263/attachment-0001.html>

From coderplay at gmail.com  Tue Apr 17 10:47:26 2012
From: coderplay at gmail.com (Min Zhou)
Date: Tue, 17 Apr 2012 22:47:26 +0800
Subject: [concurrency-interest] ForkJoinPool seems lead to a
 worselatencythan traditional ExecutorServices
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEBDJEAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCOEBCJEAA.davidcholmes@aapt.net.au>
	<NFBBKALFDCPFIDBNKAPCEEBDJEAA.davidcholmes@aapt.net.au>
Message-ID: <CALO_SpRx7cfjorAtc=77um6bQ8wP0yX5JYb=k2SA50OsmUOF7g@mail.gmail.com>

Thanks David for your reply.
The business for each F/J task is quite simple, taking message from the
front-end I/O threads and put them back into a  transfer queue where the
I/O threads would consume and send back to the clients eventually.  Yes,
there is a blocking operation for each F/J task that put the messages into
a transfer queue. It that okay?

Thanks,
Min

On Tue, Apr 17, 2012 at 8:51 PM, David Holmes <davidcholmes at aapt.net.au>wrote:

> **
> Sorry that was somewhat terse.
>
> ForkJoinPool is not a drop-in replacement as an arbitrary ExecutorService.
> It is specifically design to efficiently execute tasks that implement
> fork/join parallelism. If your tasks don't perform fork/join parallelism
> but are plain old Runnables/callables that do blocking I/O and other
> "regular" programming operations then they will not likely see any benefit
> from using a ForkJoinPool.
>
> David
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *David Holmes
> *Sent:* Tuesday, 17 April 2012 10:14 PM
> *To:* Min Zhou; concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] ForkJoinPool seems lead to a
> worselatencythan traditional ExecutorServices
>
> What makes your RPC project suitable for Fork/Join parallelism?
>
> David Holmes
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Min Zhou
> *Sent:* Tuesday, 17 April 2012 8:30 PM
> *To:* concurrency-interest at cs.oswego.edu
> *Subject:* [concurrency-interest] ForkJoinPool seems lead to a worse
> latencythan traditional ExecutorServices
>
> Hi, all,
>
> I tried to use  the newest version of  ForkJoinPool from the cvs
> repository of jsr166y to replace the old  ExecutorService on our RPC
> project opensource at http://code.google.com/p/nfs-rpc/ .
>
> The modification is quite slight. Here is the diff
>
>  Index:
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java
> ===================================================================
> ---
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java (revision
> 0)
> +++
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java (revision
> 0)
> @@ -0,0 +1,48 @@
> +package code.google.nfs.rpc;
> +/**
> + * nfs-rpc
> + *   Apache License
> + *
> + *   http://code.google.com/p/nfs-rpc (c) 2011
> + */
> +import java.util.concurrent.atomic.AtomicInteger;
> +
> +import code.google.nfs.rpc.jsr166y.ForkJoinPool;
> +import
> code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
> +import code.google.nfs.rpc.jsr166y.ForkJoinWorkerThread;
> +
> +/**
> + * Helper class to let user can monitor worker threads.
> + *
> + * @author <a href="mailto:coderplay at gmail.com">coderplay</a>
> + */
> +public class NamedForkJoinThreadFactory implements
> ForkJoinWorkerThreadFactory {
> +
> + static final AtomicInteger poolNumber = new AtomicInteger(1);
> +
> +    final AtomicInteger threadNumber = new AtomicInteger(1);
> +    final String namePrefix;
> +    final boolean isDaemon;
> +
> +    public NamedForkJoinThreadFactory() {
> +        this("pool");
> +    }
> +    public NamedForkJoinThreadFactory(String name) {
> +        this(name, false);
> +    }
> +    public NamedForkJoinThreadFactory(String preffix, boolean daemon) {
> +        namePrefix = preffix + "-" + poolNumber.getAndIncrement() +
> "-thread-";
> +        isDaemon = daemon;
> +    }
> +
> +    @Override
> +    public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
> +        ForkJoinWorkerThread t =
> +
>  ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
> +        t.setName(namePrefix + threadNumber.getAndIncrement());
> +        t.setDaemon(isDaemon);
> +        return t;
> +    }
> +
> +}
> +
> Index:
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java
> ===================================================================
> ---
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java (revision
> 120)
> +++
> nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java (working
> copy)
> @@ -8,12 +8,10 @@
>  import java.text.SimpleDateFormat;
>  import java.util.Date;
>  import java.util.concurrent.ExecutorService;
> -import java.util.concurrent.SynchronousQueue;
> -import java.util.concurrent.ThreadFactory;
> -import java.util.concurrent.ThreadPoolExecutor;
> -import java.util.concurrent.TimeUnit;
>
> -import code.google.nfs.rpc.NamedThreadFactory;
> +import code.google.nfs.rpc.NamedForkJoinThreadFactory;
> +import code.google.nfs.rpc.jsr166y.ForkJoinPool;
> +import
> code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
>  import code.google.nfs.rpc.protocol.PBDecoder;
>  import code.google.nfs.rpc.protocol.RPCProtocol;
>  import code.google.nfs.rpc.protocol.SimpleProcessorProtocol;
> @@ -66,9 +64,13 @@
>   });
>   server.registerProcessor(RPCProtocol.TYPE, "testservice", new
> BenchmarkTestServiceImpl(responseSize));
>   server.registerProcessor(RPCProtocol.TYPE, "testservicepb", new
> PBBenchmarkTestServiceImpl(responseSize));
> - ThreadFactory tf = new NamedThreadFactory("BUSINESSTHREADPOOL");
> - ExecutorService threadPool = new ThreadPoolExecutor(20, maxThreads,
> - 300, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), tf);
> + ForkJoinWorkerThreadFactory tf = new
> NamedForkJoinThreadFactory("BUSINESSTHREADPOOL");
> + ExecutorService threadPool = new ForkJoinPool(maxThreads, tf,
> +          new Thread.UncaughtExceptionHandler() {
> +              public void uncaughtException(Thread t, Throwable e){
> +                // do nothing;
> +              };
> +          }, true);
>   server.start(listenPort, threadPool);
>   }
>
>
> I did a benchmark (see
> http://code.google.com/p/nfs-rpc/wiki/HowToRunBenchmark ) with the hope
> of significant TPS improvments, but got a bad result cross to the purpose.
>  ForkJoinPool (avg response time 12 ms) seems lead to a worse latency than
> it did with traditional ExecutorService (avg response time 3ms).
>
> With ForkJoinPool:
>
>  ----------Benchmark Statistics--------------
>  Concurrents: 500
>  CodecType: 3
>  ClientNums: 1
>  RequestSize: 100 bytes
>  Runtime: 120 seconds
>  Benchmark Time: 81
>  Requests: 3740311 Success: 99% (3739274) Error: 0% (1037)
>  Avg TPS: 41374 Max TPS: 62881 Min TPS: 3333
>  Avg RT: 12ms
>  RT <= 0: 0% 1829/3740311
>  RT (0,1]: 1% 59989/3740311
>  RT (1,5]: 47% 1778386/3740311
>  RT (5,10]: 17% 655377/3740311
>  RT (10,50]: 32% 1204205/3740311
>  RT (50,100]: 0% 31479/3740311
>  RT (100,500]: 0% 546/3740311
>  RT (500,1000]: 0% 7463/3740311
>  RT > 1000: 0% 1037/3740311
>
>
> With traditional thread pool:
>  ----------Benchmark Statistics--------------
>  Concurrents: 500
>  CodecType: 3
>  ClientNums: 1
>  RequestSize: 100 bytes
>  Runtime: 120 seconds
>  Benchmark Time: 81
>  Requests: 12957281 Success: 100% (12957281) Error: 0% (0)
>  Avg TPS: 144261 Max TPS: 183390 Min TPS: 81526
>  Avg RT: 3ms
>  RT <= 0: 0% 3997/12957281
>  RT (0,1]: 4% 592905/12957281
>  RT (1,5]: 95% 12312500/12957281
>  RT (5,10]: 0% 19280/12957281
>  RT (10,50]: 0% 92/12957281
>  RT (50,100]: 0% 507/12957281
>  RT (100,500]: 0% 26500/12957281
>  RT (500,1000]: 0% 1500/12957281
>  RT > 1000: 0% 0/12957281
>
>
> I ran this benchmark on two 16 cores Westmere machines ( Xeon E5620 8 core
> HT) with the same configuration below of the two tests.
>
> 1. JDK version: Oracle 1.7.0_03 (hotspot)
>
> 2. client side JVM options:
> -Xms4g -Xmx4g -Xmn1g -XX:+PrintGCDetails -XX:+PrintGCDateStamps
> -Xloggc:gc.log -Dwrite.statistics=true -XX:+UseParallelGC
> -XX:+UseCondCardMark -XX:-UseBiasedLocking
> -Djava.ext.dirs=/home/min/nfs-rpc
> code.google.nfs.rpc.netty.benchmark.NettySimpleBenchmarkClient 10.232.98.96
> 8888 500 1000 3 100 120 1
>
> 3. server side JVM options:
> -Xms2g -Xmx2g -Xmn500m -XX:+UseParallelGC -XX:+PrintGCDetails
> -XX:+PrintGCDateStamps -Xloggc:gc.log -XX:+UseCondCardMark
> -XX:-UseBiasedLocking -Djava.ext.dirs=/home/min/nfs-rpc
> code.google.nfs.rpc.netty.benchmark.NettyBenchmarkServer 8888 100 100
>
> Low context switches, about 8000 per second, is also observed with
> ForkJoinPool against to which with the old threadpool it's about 150000.
> Benchmarks under Oracle JDK 1.6 is also did by me with similar results.
>
> Is there anyone kindly explain the reason why leading to those describe
> above for me ?
>
> Thanks,
> Min
>
> --
> My research interests are distributed systems, parallel computing and
> bytecode based virtual machine.
>
> My profile:
> http://www.linkedin.com/in/coderplay
> My blog:
> http://coderplay.javaeye.com
>
>


-- 
My research interests are distributed systems, parallel computing and
bytecode based virtual machine.

My profile:
http://www.linkedin.com/in/coderplay
My blog:
http://coderplay.javaeye.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/292a4d1f/attachment.html>

From ariel at weisberg.ws  Tue Apr 17 11:39:56 2012
From: ariel at weisberg.ws (Ariel Weisberg)
Date: Tue, 17 Apr 2012 11:39:56 -0400
Subject: [concurrency-interest] Composing multiple tasks into a single
	Future/FutureTask
Message-ID: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>

Hi all,

I have been looking for the right way to build an API that returns a
Future that is composed of tasks that will be performed in multiple
stages, potentially from more than one thread.

My use cases is a disk based persistence store. The initial put API
call creates a task that compresses and checksums the payload. The
resulting Future is bound in a Runnable and submitted to a single
thread ExecutorService that timestamps the entry and appends it to a
file and it is the Future of the second task that is currently returned
by the API.

 The trick is that the Future that is returned by the put call should
 not complete until the write is durable. Writes are made durable by
 periodically invoking fsync from a dedicated thread or by rotating
 write threads as each blocks on fsync/force. This allows for group
 commit at an interval the IO device can handle without killing
 throughput.

Ideally I could create a FutureTask that is composed of several other
Futures, some of which will not exist when the FutureTask is initially
created and returned by the API. I do know how many dependencies there
will be
expected up front.

If I had such a thing I would create a task to do the fsync and add it
as the last dependency to every Future read by the put API call.

This would be a lot easier if I were willing to have many threads
standing around blocking on Futures, but that rubs me the wrong way. It
isn't fun to jstack and see all the noise.

I suspect that there is something in Guava
com.google.common.util.concurrent.Futures to handle this case, but it
isn't jumping out at me.

Thanks,
Ariel Weisberg

From mr.chrisvest at gmail.com  Tue Apr 17 12:21:30 2012
From: mr.chrisvest at gmail.com (Chris Vest)
Date: Tue, 17 Apr 2012 18:21:30 +0200
Subject: [concurrency-interest] Composing multiple tasks into a single
	Future/FutureTask
In-Reply-To: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>
References: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>
Message-ID: <CAHXi_0cMRxDY18xOGg4bKz6apCr0gO=QwgR+KHo3AWaud2VMgA@mail.gmail.com>

Hi Ariel,

One thing that came to mind as I read your mail is this:
After the tasks have made their writes, they could create a
CountDownLatch(1), put it on a special stack, and then await it.
Then your fsync'ing thread could operate like this in a loop:
 * pop the entire stack of latches
 * do the fsync
 * count down all the popped latches because their writes are now durable
 * (possibly sleep a little? I don't know...)

This way, the write operations happen before the latch is pushed to the
"sync stack", which happens before the latch is popped, which in turn
happens before the fsync, and then the counting down. Then the task, which
is awaiting on the latch, doesn't complete until the write has been
fsync'ed. This should ensure that no writes are considered durable before
they complete.

I'm not that familiar with guava, so I don't know if it can help you avoid
writing some or all of this infrastructure yourself.

Cheers,
Chris

On Tue, Apr 17, 2012 at 17:39, Ariel Weisberg <ariel at weisberg.ws> wrote:

> Hi all,
>
> I have been looking for the right way to build an API that returns a
> Future that is composed of tasks that will be performed in multiple
> stages, potentially from more than one thread.
>
> My use cases is a disk based persistence store. The initial put API
> call creates a task that compresses and checksums the payload. The
> resulting Future is bound in a Runnable and submitted to a single
> thread ExecutorService that timestamps the entry and appends it to a
> file and it is the Future of the second task that is currently returned
> by the API.
>
>  The trick is that the Future that is returned by the put call should
>  not complete until the write is durable. Writes are made durable by
>  periodically invoking fsync from a dedicated thread or by rotating
>  write threads as each blocks on fsync/force. This allows for group
>  commit at an interval the IO device can handle without killing
>  throughput.
>
> Ideally I could create a FutureTask that is composed of several other
> Futures, some of which will not exist when the FutureTask is initially
> created and returned by the API. I do know how many dependencies there
> will be
> expected up front.
>
> If I had such a thing I would create a task to do the fsync and add it
> as the last dependency to every Future read by the put API call.
>
> This would be a lot easier if I were willing to have many threads
> standing around blocking on Futures, but that rubs me the wrong way. It
> isn't fun to jstack and see all the noise.
>
> I suspect that there is something in Guava
> com.google.common.util.concurrent.Futures to handle this case, but it
> isn't jumping out at me.
>
> Thanks,
> Ariel Weisberg
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/8e1f6699/attachment.html>

From viktor.klang at gmail.com  Tue Apr 17 18:44:43 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 18 Apr 2012 00:44:43 +0200
Subject: [concurrency-interest] Composing multiple tasks into a single
	Future/FutureTask
In-Reply-To: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>
References: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>
Message-ID: <CANPzfU9fwU01mfbJj-c3xS8_HhkowEucTBn0Ov_pp7SdJuyp=g@mail.gmail.com>

Hi Ariel,

Akka's got composable Futures:
http://doc.akka.io/docs/akka/2.0/java/futures.html

Essentiall, what you're looking for is the "andThen" operation:

(Scala)

val resultingFuture = Future { compressAndChecksum(payload) } andThen { _
=> fsync() }

Cheers,
?

On Tue, Apr 17, 2012 at 5:39 PM, Ariel Weisberg <ariel at weisberg.ws> wrote:

> Hi all,
>
> I have been looking for the right way to build an API that returns a
> Future that is composed of tasks that will be performed in multiple
> stages, potentially from more than one thread.
>
> My use cases is a disk based persistence store. The initial put API
> call creates a task that compresses and checksums the payload. The
> resulting Future is bound in a Runnable and submitted to a single
> thread ExecutorService that timestamps the entry and appends it to a
> file and it is the Future of the second task that is currently returned
> by the API.
>
>  The trick is that the Future that is returned by the put call should
>  not complete until the write is durable. Writes are made durable by
>  periodically invoking fsync from a dedicated thread or by rotating
>  write threads as each blocks on fsync/force. This allows for group
>  commit at an interval the IO device can handle without killing
>  throughput.
>
> Ideally I could create a FutureTask that is composed of several other
> Futures, some of which will not exist when the FutureTask is initially
> created and returned by the API. I do know how many dependencies there
> will be
> expected up front.
>
> If I had such a thing I would create a task to do the fsync and add it
> as the last dependency to every Future read by the put API call.
>
> This would be a lot easier if I were willing to have many threads
> standing around blocking on Futures, but that rubs me the wrong way. It
> isn't fun to jstack and see all the noise.
>
> I suspect that there is something in Guava
> com.google.common.util.concurrent.Futures to handle this case, but it
> isn't jumping out at me.
>
> Thanks,
> Ariel Weisberg
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120418/d1df0c4b/attachment.html>

From ariel at weisberg.ws  Tue Apr 17 19:38:36 2012
From: ariel at weisberg.ws (Ariel Weisberg)
Date: Tue, 17 Apr 2012 19:38:36 -0400
Subject: [concurrency-interest] Composing multiple tasks into a single
 Future/FutureTask
In-Reply-To: <CANPzfU9fwU01mfbJj-c3xS8_HhkowEucTBn0Ov_pp7SdJuyp=g@mail.gmail.com>
References: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>
	<CANPzfU9fwU01mfbJj-c3xS8_HhkowEucTBn0Ov_pp7SdJuyp=g@mail.gmail.com>
Message-ID: <1334705916.29813.140661063799689.297C1B43@webmail.messagingengine.com>

Hi,

I am using Future and ListeningFuture interchangeably.

There isn't a causal relationship. The fsync task exists at the
time the overall put Future is created, but it isn't run until
some time later.

The thread running the fsync task has to cause all the put
Futures depending on it to enter the completed state and then all
the listeners have to be notified.

It seems like I want some combination of Guava's
ListenableFutureTask and maybe extending
ForwardingListenableFuture.

If the fsync action were a ListenableFutureTask I could forward
the the listener registrations to it. However part of the return
value is specific to each put (latency, compression ratio etc.).
Also cancel and related wouldn't go to the fsync Future either,
it would go to the write Future. If I bind the Future for the
fsync task and the Future for the write task and then extend
ForwardingFuture I could point each method to the correct place.
That is probably the "simplest" way to do it, but I wanted to
avoid extending a Future implementation and adding custom
behavior.

I think it is mostly co-incidence that I happen to be able to map
the various methods of ListenableFuture usefully to the two other
ListenableFutures (fsync tasks, write task) and it doesn't seem
like a great design pattern.

Akka is definitely something that interests me, especially the
distributed aspects, but it is a  lot to take on to solve this
problem.

Thanks,
Ariel

On Wed, Apr 18, 2012, at 12:44 AM, ?iktor ?lang wrote:

  Hi Ariel,



Akka's got composable
Futures: [1]http://doc.akka.io/docs/akka/2.0/java/futures.html



Essentiall, what you're looking for is the "andThen" operation:



(Scala)



val resultingFuture = Future { compressAndChecksum(payload) }
andThen { _ => fsync() }



Cheers,

?
On Tue, Apr 17, 2012 at 5:39 PM, Ariel Weisberg
<[2]ariel at weisberg.ws> wrote:

  Hi all,
  I have been looking for the right way to build an API that
  returns a
  Future that is composed of tasks that will be performed in
  multiple
  stages, potentially from more than one thread.
  My use cases is a disk based persistence store. The initial
  put API
  call creates a task that compresses and checksums the payload.
  The
  resulting Future is bound in a Runnable and submitted to a
  single
  thread ExecutorService that timestamps the entry and appends
  it to a
  file and it is the Future of the second task that is currently
  returned
  by the API.
   The trick is that the Future that is returned by the put call
  should
   not complete until the write is durable. Writes are made
  durable by
   periodically invoking fsync from a dedicated thread or by
  rotating
   write threads as each blocks on fsync/force. This allows for
  group
   commit at an interval the IO device can handle without
  killing
   throughput.
  Ideally I could create a FutureTask that is composed of
  several other
  Futures, some of which will not exist when the FutureTask is
  initially
  created and returned by the API. I do know how many
  dependencies there
  will be
  expected up front.
  If I had such a thing I would create a task to do the fsync
  and add it
  as the last dependency to every Future read by the put API
  call.
  This would be a lot easier if I were willing to have many
  threads
  standing around blocking on Futures, but that rubs me the
  wrong way. It
  isn't fun to jstack and see all the noise.
  I suspect that there is something in Guava
  com.google.common.util.concurrent.Futures to handle this case,
  but it
  isn't jumping out at me.
  Thanks,
  Ariel Weisberg
  _______________________________________________
  Concurrency-interest mailing list
  [3]Concurrency-interest at cs.oswego.edu
  [4]http://cs.oswego.edu/mailman/listinfo/concurrency-interest


--
Viktor Klang
Akka Tech Lead
[5]Typesafe - The software stack for applications that scale
Twitter: @viktorklang

References

1. http://doc.akka.io/docs/akka/2.0/java/futures.html
2. mailto:ariel at weisberg.ws
3. mailto:Concurrency-interest at cs.oswego.edu
4. http://cs.oswego.edu/mailman/listinfo/concurrency-interest
5. http://www.typesafe.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/574b8cba/attachment-0001.html>

From joe.bowbeer at gmail.com  Tue Apr 17 20:36:33 2012
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 17 Apr 2012 17:36:33 -0700
Subject: [concurrency-interest] Composing multiple tasks into a single
	Future/FutureTask
In-Reply-To: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>
References: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>
Message-ID: <CAHzJPEq-nFeyVQ1+efmc96dafeydCOi+Vy_y_kcU+MtHOxesrg@mail.gmail.com>

FutureTask has a protected set() method which completes the future.
 FutureTask.get blocks until set is called.

Instead of having your future results depend on the fsync task, I would
hand your futures to the fsync task so that it can complete them when the
writes are durable -- by calling their (public) set method, or a custom
method.

I'm picturing your custom Future results as little state machines that
implement a setState(state) method.  The final transition is when fsync
sets their state to WRITTEN; at this point the custom Future sets its
result and completes.

Joe

On Tue, Apr 17, 2012 at 8:39 AM, Ariel Weisberg wrote:

> Hi all,
>
> I have been looking for the right way to build an API that returns a
> Future that is composed of tasks that will be performed in multiple
> stages, potentially from more than one thread.
>
> My use cases is a disk based persistence store. The initial put API
> call creates a task that compresses and checksums the payload. The
> resulting Future is bound in a Runnable and submitted to a single
> thread ExecutorService that timestamps the entry and appends it to a
> file and it is the Future of the second task that is currently returned
> by the API.
>
>  The trick is that the Future that is returned by the put call should
>  not complete until the write is durable. Writes are made durable by
>  periodically invoking fsync from a dedicated thread or by rotating
>  write threads as each blocks on fsync/force. This allows for group
>  commit at an interval the IO device can handle without killing
>  throughput.
>
> Ideally I could create a FutureTask that is composed of several other
> Futures, some of which will not exist when the FutureTask is initially
> created and returned by the API. I do know how many dependencies there
> will be
> expected up front.
>
> If I had such a thing I would create a task to do the fsync and add it
> as the last dependency to every Future read by the put API call.
>
> This would be a lot easier if I were willing to have many threads
> standing around blocking on Futures, but that rubs me the wrong way. It
> isn't fun to jstack and see all the noise.
>
> I suspect that there is something in Guava
> com.google.common.util.concurrent.Futures to handle this case, but it
> isn't jumping out at me.
>
> Thanks,
> Ariel Weisberg
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120417/f8543694/attachment.html>

From coderplay at gmail.com  Tue Apr 17 21:49:52 2012
From: coderplay at gmail.com (Min Zhou)
Date: Wed, 18 Apr 2012 09:49:52 +0800
Subject: [concurrency-interest] ForkJoinPool seems lead to a
 worselatencythan traditional ExecutorServices
In-Reply-To: <CANPzfU8Pn7-mFH69O5kP75qUgBg9EYq8==XHEPjbzhkp_GLzuA@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCOEBCJEAA.davidcholmes@aapt.net.au>
	<NFBBKALFDCPFIDBNKAPCEEBDJEAA.davidcholmes@aapt.net.au>
	<CANPzfU8Pn7-mFH69O5kP75qUgBg9EYq8==XHEPjbzhkp_GLzuA@mail.gmail.com>
Message-ID: <CALO_SpQPPDApZ66HfD-ejwvCmBVGxhHB_n=rjX2bKq5O4ZSPcw@mail.gmail.com>

Hi, Viktor,

This is a throughput benchmark, do you have any number of about the latency?

Thanks,
Min

On Tue, Apr 17, 2012 at 9:22 PM, ?iktor ?lang <viktor.klang at gmail.com>wrote:

>
>
> On Tue, Apr 17, 2012 at 2:51 PM, David Holmes <davidcholmes at aapt.net.au>wrote:
>
>> **
>> Sorry that was somewhat terse.
>>
>> ForkJoinPool is not a drop-in replacement as an arbitrary
>> ExecutorService. It is specifically design to efficiently execute tasks
>> that implement fork/join parallelism. If your tasks don't perform fork/join
>> parallelism but are plain old Runnables/callables that do blocking I/O and
>> other "regular" programming operations then they will not likely see any
>> benefit from using a ForkJoinPool.
>>
>
> I disagree:
>
>
> http://letitcrash.com/post/20397701710/50-million-messages-per-second-on-a-single-machine
>
> Cheers,
> ?
>
>
>>
>> David
>>
>> -----Original Message-----
>> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
>> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *David Holmes
>> *Sent:* Tuesday, 17 April 2012 10:14 PM
>> *To:* Min Zhou; concurrency-interest at cs.oswego.edu
>> *Subject:* Re: [concurrency-interest] ForkJoinPool seems lead to a
>> worselatencythan traditional ExecutorServices
>>
>> What makes your RPC project suitable for Fork/Join parallelism?
>>
>> David Holmes
>>
>> -----Original Message-----
>> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
>> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Min Zhou
>> *Sent:* Tuesday, 17 April 2012 8:30 PM
>> *To:* concurrency-interest at cs.oswego.edu
>> *Subject:* [concurrency-interest] ForkJoinPool seems lead to a worse
>> latencythan traditional ExecutorServices
>>
>> Hi, all,
>>
>> I tried to use  the newest version of  ForkJoinPool from the cvs
>> repository of jsr166y to replace the old  ExecutorService on our RPC
>> project opensource at http://code.google.com/p/nfs-rpc/ .
>>
>> The modification is quite slight. Here is the diff
>>
>>  Index:
>> nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java
>> ===================================================================
>> ---
>> nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java (revision
>> 0)
>> +++
>> nfs-rpc-common/src/main/java/code/google/nfs/rpc/NamedForkJoinThreadFactory.java (revision
>> 0)
>> @@ -0,0 +1,48 @@
>> +package code.google.nfs.rpc;
>> +/**
>> + * nfs-rpc
>> + *   Apache License
>> + *
>> + *   http://code.google.com/p/nfs-rpc (c) 2011
>> + */
>> +import java.util.concurrent.atomic.AtomicInteger;
>> +
>> +import code.google.nfs.rpc.jsr166y.ForkJoinPool;
>> +import
>> code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
>> +import code.google.nfs.rpc.jsr166y.ForkJoinWorkerThread;
>> +
>> +/**
>> + * Helper class to let user can monitor worker threads.
>> + *
>> + * @author <a href="mailto:coderplay at gmail.com">coderplay</a>
>> + */
>> +public class NamedForkJoinThreadFactory implements
>> ForkJoinWorkerThreadFactory {
>> +
>> + static final AtomicInteger poolNumber = new AtomicInteger(1);
>> +
>> +    final AtomicInteger threadNumber = new AtomicInteger(1);
>> +    final String namePrefix;
>> +    final boolean isDaemon;
>> +
>> +    public NamedForkJoinThreadFactory() {
>> +        this("pool");
>> +    }
>> +    public NamedForkJoinThreadFactory(String name) {
>> +        this(name, false);
>> +    }
>> +    public NamedForkJoinThreadFactory(String preffix, boolean daemon) {
>> +        namePrefix = preffix + "-" + poolNumber.getAndIncrement() +
>> "-thread-";
>> +        isDaemon = daemon;
>> +    }
>> +
>> +    @Override
>> +    public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
>> +        ForkJoinWorkerThread t =
>> +
>>  ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
>> +        t.setName(namePrefix + threadNumber.getAndIncrement());
>> +        t.setDaemon(isDaemon);
>> +        return t;
>> +    }
>> +
>> +}
>> +
>> Index:
>> nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java
>> ===================================================================
>> ---
>> nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java (revision
>> 120)
>> +++
>> nfs-rpc-common/src/main/java/code/google/nfs/rpc/benchmark/AbstractBenchmarkServer.java (working
>> copy)
>> @@ -8,12 +8,10 @@
>>  import java.text.SimpleDateFormat;
>>  import java.util.Date;
>>  import java.util.concurrent.ExecutorService;
>> -import java.util.concurrent.SynchronousQueue;
>> -import java.util.concurrent.ThreadFactory;
>> -import java.util.concurrent.ThreadPoolExecutor;
>> -import java.util.concurrent.TimeUnit;
>>
>> -import code.google.nfs.rpc.NamedThreadFactory;
>> +import code.google.nfs.rpc.NamedForkJoinThreadFactory;
>> +import code.google.nfs.rpc.jsr166y.ForkJoinPool;
>> +import
>> code.google.nfs.rpc.jsr166y.ForkJoinPool.ForkJoinWorkerThreadFactory;
>>  import code.google.nfs.rpc.protocol.PBDecoder;
>>  import code.google.nfs.rpc.protocol.RPCProtocol;
>>  import code.google.nfs.rpc.protocol.SimpleProcessorProtocol;
>> @@ -66,9 +64,13 @@
>>   });
>>   server.registerProcessor(RPCProtocol.TYPE, "testservice", new
>> BenchmarkTestServiceImpl(responseSize));
>>   server.registerProcessor(RPCProtocol.TYPE, "testservicepb", new
>> PBBenchmarkTestServiceImpl(responseSize));
>> - ThreadFactory tf = new NamedThreadFactory("BUSINESSTHREADPOOL");
>> - ExecutorService threadPool = new ThreadPoolExecutor(20, maxThreads,
>> - 300, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), tf);
>> + ForkJoinWorkerThreadFactory tf = new
>> NamedForkJoinThreadFactory("BUSINESSTHREADPOOL");
>> + ExecutorService threadPool = new ForkJoinPool(maxThreads, tf,
>> +          new Thread.UncaughtExceptionHandler() {
>> +              public void uncaughtException(Thread t, Throwable e){
>> +                // do nothing;
>> +              };
>> +          }, true);
>>   server.start(listenPort, threadPool);
>>   }
>>
>>
>> I did a benchmark (see
>> http://code.google.com/p/nfs-rpc/wiki/HowToRunBenchmark ) with the hope
>> of significant TPS improvments, but got a bad result cross to the purpose.
>>  ForkJoinPool (avg response time 12 ms) seems lead to a worse latency than
>> it did with traditional ExecutorService (avg response time 3ms).
>>
>> With ForkJoinPool:
>>
>>  ----------Benchmark Statistics--------------
>>  Concurrents: 500
>>  CodecType: 3
>>  ClientNums: 1
>>  RequestSize: 100 bytes
>>  Runtime: 120 seconds
>>  Benchmark Time: 81
>>  Requests: 3740311 Success: 99% (3739274) Error: 0% (1037)
>>  Avg TPS: 41374 Max TPS: 62881 Min TPS: 3333
>>  Avg RT: 12ms
>>  RT <= 0: 0% 1829/3740311
>>  RT (0,1]: 1% 59989/3740311
>>  RT (1,5]: 47% 1778386/3740311
>>  RT (5,10]: 17% 655377/3740311
>>  RT (10,50]: 32% 1204205/3740311
>>  RT (50,100]: 0% 31479/3740311
>>  RT (100,500]: 0% 546/3740311
>>  RT (500,1000]: 0% 7463/3740311
>>  RT > 1000: 0% 1037/3740311
>>
>>
>> With traditional thread pool:
>>  ----------Benchmark Statistics--------------
>>  Concurrents: 500
>>  CodecType: 3
>>  ClientNums: 1
>>  RequestSize: 100 bytes
>>  Runtime: 120 seconds
>>  Benchmark Time: 81
>>  Requests: 12957281 Success: 100% (12957281) Error: 0% (0)
>>  Avg TPS: 144261 Max TPS: 183390 Min TPS: 81526
>>  Avg RT: 3ms
>>  RT <= 0: 0% 3997/12957281
>>  RT (0,1]: 4% 592905/12957281
>>  RT (1,5]: 95% 12312500/12957281
>>  RT (5,10]: 0% 19280/12957281
>>  RT (10,50]: 0% 92/12957281
>>  RT (50,100]: 0% 507/12957281
>>  RT (100,500]: 0% 26500/12957281
>>  RT (500,1000]: 0% 1500/12957281
>>  RT > 1000: 0% 0/12957281
>>
>>
>> I ran this benchmark on two 16 cores Westmere machines ( Xeon E5620 8
>> core HT) with the same configuration below of the two tests.
>>
>> 1. JDK version: Oracle 1.7.0_03 (hotspot)
>>
>> 2. client side JVM options:
>> -Xms4g -Xmx4g -Xmn1g -XX:+PrintGCDetails -XX:+PrintGCDateStamps
>> -Xloggc:gc.log -Dwrite.statistics=true -XX:+UseParallelGC
>> -XX:+UseCondCardMark -XX:-UseBiasedLocking
>> -Djava.ext.dirs=/home/min/nfs-rpc
>> code.google.nfs.rpc.netty.benchmark.NettySimpleBenchmarkClient 10.232.98.96
>> 8888 500 1000 3 100 120 1
>>
>> 3. server side JVM options:
>> -Xms2g -Xmx2g -Xmn500m -XX:+UseParallelGC -XX:+PrintGCDetails
>> -XX:+PrintGCDateStamps -Xloggc:gc.log -XX:+UseCondCardMark
>> -XX:-UseBiasedLocking -Djava.ext.dirs=/home/min/nfs-rpc
>> code.google.nfs.rpc.netty.benchmark.NettyBenchmarkServer 8888 100 100
>>
>> Low context switches, about 8000 per second, is also observed with
>> ForkJoinPool against to which with the old threadpool it's about 150000.
>> Benchmarks under Oracle JDK 1.6 is also did by me with similar results.
>>
>> Is there anyone kindly explain the reason why leading to those describe
>> above for me ?
>>
>> Thanks,
>> Min
>>
>> --
>> My research interests are distributed systems, parallel computing and
>> bytecode based virtual machine.
>>
>> My profile:
>> http://www.linkedin.com/in/coderplay
>> My blog:
>> http://coderplay.javaeye.com
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> --
> Viktor Klang
>
> Akka Tech Lead
> Typesafe <http://www.typesafe.com/> - The software stack for applications
> that scale
>
> Twitter: @viktorklang
>
>


-- 
My research interests are distributed systems, parallel computing and
bytecode based virtual machine.

My profile:
http://www.linkedin.com/in/coderplay
My blog:
http://coderplay.javaeye.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120418/336a66a5/attachment-0001.html>

From viktor.klang at gmail.com  Wed Apr 18 02:03:52 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 18 Apr 2012 08:03:52 +0200
Subject: [concurrency-interest] Composing multiple tasks into a single
	Future/FutureTask
In-Reply-To: <1334705916.29813.140661063799689.297C1B43@webmail.messagingengine.com>
References: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>
	<CANPzfU9fwU01mfbJj-c3xS8_HhkowEucTBn0Ov_pp7SdJuyp=g@mail.gmail.com>
	<1334705916.29813.140661063799689.297C1B43@webmail.messagingengine.com>
Message-ID: <CANPzfU-Ghwa-pUTBzCowLRmEbKeJzH5O+ch98u3wMdVTksrKhg@mail.gmail.com>

2012/4/18 Ariel Weisberg <ariel at weisberg.ws>

>   Hi,
>
>  I am using Future and ListeningFuture interchangeably.
>
>  There isn't a causal relationship. The fsync task exists at the time the
> overall put Future is created, but it isn't run until some time later.
>
>  The thread running the fsync task has to cause all the put Futures
> depending on it to enter the completed state and then all the listeners
> have to be notified.
>
>  It seems like I want some combination of Guava's ListenableFutureTask and
> maybe extending ForwardingListenableFuture.
>
>  If the fsync action were a ListenableFutureTask I could forward the the
> listener registrations to it. However part of the return value is specific
> to each put (latency, compression ratio etc.). Also cancel and related
> wouldn't go to the fsync Future either, it would go to the write Future. If
> I bind the Future for the fsync task and the Future for the write task and
> then extend ForwardingFuture I could point each method to the correct
> place. That is probably the "simplest" way to do it, but I wanted to avoid
> extending a Future implementation and adding custom behavior.
>
>  I think it is mostly co-incidence that I happen to be able to map the
> various methods of ListenableFuture usefully to the two other
> ListenableFutures (fsync tasks, write task) and it doesn't seem like a
> great design pattern.
>
>  Akka is definitely something that interests me, especially the
> distributed aspects, but it is a  lot to take on to solve this problem.
>

The core-jar (akka-actor.jar) is completely standalone and has nothing to
do with distributed aspects. Just use the Future-implementation.

Cheers,
?


>
>  Thanks,
>  Ariel
>
>  On Wed, Apr 18, 2012, at 12:44 AM, ?iktor ?lang wrote:
>
> Hi Ariel,
>
>  Akka's got composable Futures:
> http://doc.akka.io/docs/akka/2.0/java/futures.html
>
>  Essentiall, what you're looking for is the "andThen" operation:
>
>  (Scala)
>
>  val resultingFuture = Future { compressAndChecksum(payload) } andThen { _
> => fsync() }
>
>  Cheers,
>  ?
>
>  On Tue, Apr 17, 2012 at 5:39 PM, Ariel Weisberg <ariel at weisberg.ws>wrote:
>
> Hi all,
>
> I have been looking for the right way to build an API that returns a
> Future that is composed of tasks that will be performed in multiple
> stages, potentially from more than one thread.
>
> My use cases is a disk based persistence store. The initial put API
> call creates a task that compresses and checksums the payload. The
> resulting Future is bound in a Runnable and submitted to a single
> thread ExecutorService that timestamps the entry and appends it to a
> file and it is the Future of the second task that is currently returned
> by the API.
>
>  The trick is that the Future that is returned by the put call should
>  not complete until the write is durable. Writes are made durable by
>  periodically invoking fsync from a dedicated thread or by rotating
>  write threads as each blocks on fsync/force. This allows for group
>  commit at an interval the IO device can handle without killing
>  throughput.
>
> Ideally I could create a FutureTask that is composed of several other
> Futures, some of which will not exist when the FutureTask is initially
> created and returned by the API. I do know how many dependencies there
> will be
> expected up front.
>
> If I had such a thing I would create a task to do the fsync and add it
> as the last dependency to every Future read by the put API call.
>
> This would be a lot easier if I were willing to have many threads
> standing around blocking on Futures, but that rubs me the wrong way. It
> isn't fun to jstack and see all the noise.
>
> I suspect that there is something in Guava
> com.google.common.util.concurrent.Futures to handle this case, but it
> isn't jumping out at me.
>
> Thanks,
> Ariel Weisberg
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> --
> Viktor Klang
>
> Akka Tech Lead
> Typesafe <http://www.typesafe.com/> - The software stack for applications
> that scale
>
> Twitter: @viktorklang
>
>
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120418/f249e240/attachment.html>

From viktor.klang at gmail.com  Wed Apr 18 04:39:41 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 18 Apr 2012 10:39:41 +0200
Subject: [concurrency-interest] ForkJoinPool seems lead to a
 worselatencythan traditional ExecutorServices
In-Reply-To: <4F8D784A.1060807@cytetech.com>
References: <NFBBKALFDCPFIDBNKAPCOEBCJEAA.davidcholmes@aapt.net.au>
	<NFBBKALFDCPFIDBNKAPCEEBDJEAA.davidcholmes@aapt.net.au>
	<CANPzfU8Pn7-mFH69O5kP75qUgBg9EYq8==XHEPjbzhkp_GLzuA@mail.gmail.com>
	<4F8D7484.9040400@cytetech.com>
	<CANPzfU_tSzpAhhab3LxfK6ANj1Fm1MDiJCtDs6apWHE-Xubidg@mail.gmail.com>
	<4F8D784A.1060807@cytetech.com>
Message-ID: <CANPzfU_JCnA_+VemwW+0Pesnpqw57-_A_h_=sDeX3+YHhvWaTw@mail.gmail.com>

2012/4/17 Gregg Wonderly <gregg at cytetech.com>

> On 4/17/2012 8:51 AM, ?iktor ?lang wrote:
>
>>
>>
>> 2012/4/17 Gregg Wonderly <gregg at cytetech.com <mailto:gregg at cytetech.com>>
>>
>>
>>    On 4/17/2012 8:22 AM, ?iktor ?lang wrote:
>>
>>
>>
>>        On Tue, Apr 17, 2012 at 2:51 PM, David Holmes <
>> davidcholmes at aapt.net.au
>>        <mailto:davidcholmes at aapt.net.**au <davidcholmes at aapt.net.au>>
>>        <mailto:davidcholmes at aapt.net.**__au <mailto:
>> davidcholmes at aapt.net.**au <davidcholmes at aapt.net.au>>>>
>>
>>        wrote:
>>
>>            __
>>
>>            Sorry that was somewhat terse.
>>            ForkJoinPool is not a drop-in replacement as an arbitrary
>>        ExecutorService.
>>            It is specifically design to efficiently execute tasks that
>> implement
>>            fork/join parallelism. If your tasks don't perform fork/join
>>        parallelism but
>>            are plain old Runnables/callables that do blocking I/O and
>> other
>>        "regular"
>>            programming operations then they will not likely see any
>> benefit
>>        from using
>>            a ForkJoinPool.
>>
>>
>>        I disagree:
>>
>>        http://letitcrash.com/post/__**20397701710/50-million-__**
>> messages-per-second-on-a-__**single-machine<http://letitcrash.com/post/__20397701710/50-million-__messages-per-second-on-a-__single-machine>
>>
>>        <http://letitcrash.com/post/**20397701710/50-million-**
>> messages-per-second-on-a-**single-machine<http://letitcrash.com/post/20397701710/50-million-messages-per-second-on-a-single-machine>
>> >
>>
>>
>>    That has nothing to do with the use of ForkJoin it appears to me.  It
>> is
>>    simply a thread use efficiency change that causes a scheduled thread
>> to do
>>    enough work that the latency of scheduling becomes a small enough
>> component
>>    that it disappears from view because the other thread is running (2 are
>>    available per core) while scheduling occurs.
>>
>>    This would happen no matter what kind of thread pool was used, with
>>    appropriate timings/thread-scheduling that created the same effect.
>>
>>
>> No, the scalability of the ForkJoinPoll is extremely much better than
>> other
>> j.u.c implementations:
>>
>
> The example you pointed at, had nothing to do with using forkjoin.  It
> merely demonstrated that if you have twice as many threads, as cores, that
> you could start to hide the scheduling overhead/context switch latency by
> performing work in one thread while another thread had encountered some
> form of scheduling latency.  That example showed that somewhere around 50
> messages could be processed in the time that it took to switch to another
> thread.  Once you hit that wall, no more progress is made.
>

That post leads naturally to the second post. That FJP scales way better
than TPE, even for non-join workloads.


>
> > http://letitcrash.com/post/**17607272336/scalability-of-**fork-join-pool<http://letitcrash.com/post/17607272336/scalability-of-fork-join-pool>
>
> Yes, this page does say:
>
> "When using thread pool executor (java.util.concurrent.**ThreadPoolExecutor)
> the benchmark didn?t scale beyond 12 parallel actors. "
>
> and I will agree that there are efficiency issues indicated in that
> statement, but without source code to look at, it's not really possible to
> understand where there might be problems in the benchmark code.
>
> ForkJoin is about efficiency for many classes of problems, but this
> problem in particular, is not one that I would use ForkJoin for.  It would,
> of used my own thread pool, specifically because I know all about many
> inefficiencies and undesirable side effects of using TPE to just schedule a
> bunch of threads for parallelism.  I only use TPE as a means to throttle
> thread use against bursty loads that work much better with TPE and a queue
> that blocks on full insert attempts.
>

Yes, of course one can always build your own thread pool, but that only
means that it will be optimized for a certain workload. Using the new
version of FJP allows us to use different problem solving strategies in the
same pool of threads.

If you have some interesting implementations of custom thread pools to
share, please do.

Cheers,
?


>
> Gregg
>
> >Cheers,
> >?
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120418/c0989236/attachment-0001.html>

From ariel at weisberg.ws  Wed Apr 18 10:42:29 2012
From: ariel at weisberg.ws (Ariel Weisberg)
Date: Wed, 18 Apr 2012 10:42:29 -0400
Subject: [concurrency-interest] Composing multiple tasks into a single
 Future/FutureTask
In-Reply-To: <CANPzfU-Ghwa-pUTBzCowLRmEbKeJzH5O+ch98u3wMdVTksrKhg@mail.gmail.com>
References: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>
	<CANPzfU9fwU01mfbJj-c3xS8_HhkowEucTBn0Ov_pp7SdJuyp=g@mail.gmail.com>
	<1334705916.29813.140661063799689.297C1B43@webmail.messagingengine.com>
	<CANPzfU-Ghwa-pUTBzCowLRmEbKeJzH5O+ch98u3wMdVTksrKhg@mail.gmail.com>
Message-ID: <1334760149.29653.140661064074917.6C4EA86E@webmail.messagingengine.com>

Hi,

It looks like Akka Futures don't implement the regular Future
interface? My concern is that I would have to go all in on Akka
for my Future/ExecutorService needs. I don't mind it, but it
means that others who come after will have to learn to grok Akka
and the javadocs and implementation are in Scala.

The first issue which is that it isn't a causal relationship
still exists. I can't invoke the fsync task once for each put.
The equivalent of and then with Guava is ListenableFuture which
is more flexible in that you can add multiple dependencies and it
separates the concern of when/how the dependencies will be
executed.

I think that Joe's suggestion of exposing the set methods would
work. I can add listeners to the fsync task that invoke set on
the FutureTask returned by the put API. Guava has a
SettableFuture for this.

Thanks,
Ariel

On Wed, Apr 18, 2012, at 08:03 AM, ?iktor ?lang wrote:

2012/4/18 Ariel Weisberg <[1]ariel at weisberg.ws>

Hi,

I am using Future and ListeningFuture interchangeably.

There isn't a causal relationship. The fsync task exists at the
time the overall put Future is created, but it isn't run until
some time later.

The thread running the fsync task has to cause all the put
Futures depending on it to enter the completed state and then all
the listeners have to be notified.

It seems like I want some combination of Guava's
ListenableFutureTask and maybe extending
ForwardingListenableFuture.

If the fsync action were a ListenableFutureTask I could forward
the the listener registrations to it. However part of the return
value is specific to each put (latency, compression ratio etc.).
Also cancel and related wouldn't go to the fsync Future either,
it would go to the write Future. If I bind the Future for the
fsync task and the Future for the write task and then extend
ForwardingFuture I could point each method to the correct place.
That is probably the "simplest" way to do it, but I wanted to
avoid extending a Future implementation and adding custom
behavior.

I think it is mostly co-incidence that I happen to be able to map
the various methods of ListenableFuture usefully to the two other
ListenableFutures (fsync tasks, write task) and it doesn't seem
like a great design pattern.

Akka is definitely something that interests me, especially the
distributed aspects, but it is a  lot to take on to solve this
problem.


The core-jar (akka-actor.jar) is completely standalone and has
nothing to do with distributed aspects. Just use the
Future-implementation.

Cheers,
?


Thanks,
Ariel

On Wed, Apr 18, 2012, at 12:44 AM, ?iktor ?lang wrote:

  Hi Ariel,



Akka's got composable
Futures: [2]http://doc.akka.io/docs/akka/2.0/java/futures.html



Essentiall, what you're looking for is the "andThen" operation:



(Scala)



val resultingFuture = Future { compressAndChecksum(payload) }
andThen { _ => fsync() }



Cheers,

?
On Tue, Apr 17, 2012 at 5:39 PM, Ariel Weisberg
<[3]ariel at weisberg.ws> wrote:

  Hi all,
  I have been looking for the right way to build an API that
  returns a
  Future that is composed of tasks that will be performed in
  multiple
  stages, potentially from more than one thread.
  My use cases is a disk based persistence store. The initial
  put API
  call creates a task that compresses and checksums the payload.
  The
  resulting Future is bound in a Runnable and submitted to a
  single
  thread ExecutorService that timestamps the entry and appends
  it to a
  file and it is the Future of the second task that is currently
  returned
  by the API.
   The trick is that the Future that is returned by the put call
  should
   not complete until the write is durable. Writes are made
  durable by
   periodically invoking fsync from a dedicated thread or by
  rotating
   write threads as each blocks on fsync/force. This allows for
  group
   commit at an interval the IO device can handle without
  killing
   throughput.
  Ideally I could create a FutureTask that is composed of
  several other
  Futures, some of which will not exist when the FutureTask is
  initially
  created and returned by the API. I do know how many
  dependencies there
  will be
  expected up front.
  If I had such a thing I would create a task to do the fsync
  and add it
  as the last dependency to every Future read by the put API
  call.
  This would be a lot easier if I were willing to have many
  threads
  standing around blocking on Futures, but that rubs me the
  wrong way. It
  isn't fun to jstack and see all the noise.
  I suspect that there is something in Guava
  com.google.common.util.concurrent.Futures to handle this case,
  but it
  isn't jumping out at me.
  Thanks,
  Ariel Weisberg
  _______________________________________________
  Concurrency-interest mailing list
  [4]Concurrency-interest at cs.oswego.edu
  [5]http://cs.oswego.edu/mailman/listinfo/concurrency-interest


--
Viktor Klang
Akka Tech Lead
[6]Typesafe - The software stack for applications that scale
Twitter: @viktorklang




  --
  Viktor Klang
  Akka Tech Lead

[7]Typesafe - The software stack for applications that scale
Twitter: @viktorklang

References

1. mailto:ariel at weisberg.ws
2. http://doc.akka.io/docs/akka/2.0/java/futures.html
3. mailto:ariel at weisberg.ws
4. mailto:Concurrency-interest at cs.oswego.edu
5. http://cs.oswego.edu/mailman/listinfo/concurrency-interest
6. http://www.typesafe.com/
7. http://www.typesafe.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120418/544fab9a/attachment.html>

From viktor.klang at gmail.com  Wed Apr 18 11:12:08 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 18 Apr 2012 17:12:08 +0200
Subject: [concurrency-interest] Composing multiple tasks into a single
	Future/FutureTask
In-Reply-To: <1334760149.29653.140661064074917.6C4EA86E@webmail.messagingengine.com>
References: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>
	<CANPzfU9fwU01mfbJj-c3xS8_HhkowEucTBn0Ov_pp7SdJuyp=g@mail.gmail.com>
	<1334705916.29813.140661063799689.297C1B43@webmail.messagingengine.com>
	<CANPzfU-Ghwa-pUTBzCowLRmEbKeJzH5O+ch98u3wMdVTksrKhg@mail.gmail.com>
	<1334760149.29653.140661064074917.6C4EA86E@webmail.messagingengine.com>
Message-ID: <CANPzfU-0Q0X0sEttGCkLzYSio75c_Jf7fFry6S2LFzmQUzv6gg@mail.gmail.com>

2012/4/18 Ariel Weisberg <ariel at weisberg.ws>

>   Hi,
>
>  It looks like Akka Futures don't implement the regular Future interface?
> My concern is that I would have to go all in on Akka for my
> Future/ExecutorService needs. I don't mind it, but it means that others who
> come after will have to learn to grok Akka and the javadocs and
> implementation are in Scala.
>

Implementing java.util.concurrent.Future would be of little value as it
does not support non-blocking composition.

Any others who come after definitely need to learn a few things, that's
where documentation is nice.
A programmer who is not willing to learn is dangerous.


>
>  The first issue which is that it isn't a causal relationship still
> exists. I can't invoke the fsync task once for each put.
>
The equivalent of and then with Guava is ListenableFuture which is more
> flexible in that you can add multiple dependencies and it separates the
> concern of when/how the dependencies will be executed.
>

Can you illustrate where the ListenableFuture is more flexible?


>
>  I think that Joe's suggestion of exposing the set methods would work. I
> can add listeners to the fsync task that invoke set on the FutureTask
> returned by the put API. Guava has a SettableFuture for this.
>

Promise is what you're looking for here.

Cheers,
?


>
>  Thanks,
>  Ariel
>
>  On Wed, Apr 18, 2012, at 08:03 AM, ?iktor ?lang wrote:
>
>
>
>  2012/4/18 Ariel Weisberg <ariel at weisberg.ws>
>
>    Hi,
>
>  I am using Future and ListeningFuture interchangeably.
>
>  There isn't a causal relationship. The fsync task exists at the time the
> overall put Future is created, but it isn't run until some time later.
>
>  The thread running the fsync task has to cause all the put Futures
> depending on it to enter the completed state and then all the listeners
> have to be notified.
>
>  It seems like I want some combination of Guava's ListenableFutureTask and
> maybe extending ForwardingListenableFuture.
>
>  If the fsync action were a ListenableFutureTask I could forward the the
> listener registrations to it. However part of the return value is specific
> to each put (latency, compression ratio etc.). Also cancel and related
> wouldn't go to the fsync Future either, it would go to the write Future. If
> I bind the Future for the fsync task and the Future for the write task and
> then extend ForwardingFuture I could point each method to the correct
> place. That is probably the "simplest" way to do it, but I wanted to avoid
> extending a Future implementation and adding custom behavior.
>
>  I think it is mostly co-incidence that I happen to be able to map the
> various methods of ListenableFuture usefully to the two other
> ListenableFutures (fsync tasks, write task) and it doesn't seem like a
> great design pattern.
>
>  Akka is definitely something that interests me, especially the
> distributed aspects, but it is a  lot to take on to solve this problem.
>
>
>  The core-jar (akka-actor.jar) is completely standalone and has nothing to
> do with distributed aspects. Just use the Future-implementation.
>
>  Cheers,
>  ?
>
>
>
>  Thanks,
>  Ariel
>
>  On Wed, Apr 18, 2012, at 12:44 AM, ?iktor ?lang wrote:
>
> Hi Ariel,
>
>  Akka's got composable Futures:
> http://doc.akka.io/docs/akka/2.0/java/futures.html
>
>  Essentiall, what you're looking for is the "andThen" operation:
>
>  (Scala)
>
>  val resultingFuture = Future { compressAndChecksum(payload) } andThen { _
> => fsync() }
>
>  Cheers,
>  ?
>
>  On Tue, Apr 17, 2012 at 5:39 PM, Ariel Weisberg <ariel at weisberg.ws>wrote:
>
> Hi all,
>
> I have been looking for the right way to build an API that returns a
> Future that is composed of tasks that will be performed in multiple
> stages, potentially from more than one thread.
>
> My use cases is a disk based persistence store. The initial put API
> call creates a task that compresses and checksums the payload. The
> resulting Future is bound in a Runnable and submitted to a single
> thread ExecutorService that timestamps the entry and appends it to a
> file and it is the Future of the second task that is currently returned
> by the API.
>
>  The trick is that the Future that is returned by the put call should
>  not complete until the write is durable. Writes are made durable by
>  periodically invoking fsync from a dedicated thread or by rotating
>  write threads as each blocks on fsync/force. This allows for group
>  commit at an interval the IO device can handle without killing
>  throughput.
>
> Ideally I could create a FutureTask that is composed of several other
> Futures, some of which will not exist when the FutureTask is initially
> created and returned by the API. I do know how many dependencies there
> will be
> expected up front.
>
> If I had such a thing I would create a task to do the fsync and add it
> as the last dependency to every Future read by the put API call.
>
> This would be a lot easier if I were willing to have many threads
> standing around blocking on Futures, but that rubs me the wrong way. It
> isn't fun to jstack and see all the noise.
>
> I suspect that there is something in Guava
> com.google.common.util.concurrent.Futures to handle this case, but it
> isn't jumping out at me.
>
> Thanks,
> Ariel Weisberg
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> --
> Viktor Klang
>
> Akka Tech Lead
> Typesafe <http://www.typesafe.com/> - The software stack for applications
> that scale
>
> Twitter: @viktorklang
>
>
>
>
>
>
> --
> Viktor Klang
>
> Akka Tech Lead
> Typesafe <http://www.typesafe.com/> - The software stack for applications
> that scale
>
> Twitter: @viktorklang
>
>
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120418/411b44e4/attachment-0001.html>

From ariel at weisberg.ws  Wed Apr 18 12:57:38 2012
From: ariel at weisberg.ws (Ariel Weisberg)
Date: Wed, 18 Apr 2012 12:57:38 -0400
Subject: [concurrency-interest] Composing multiple tasks into a single
 Future/FutureTask
In-Reply-To: <CANPzfU-0Q0X0sEttGCkLzYSio75c_Jf7fFry6S2LFzmQUzv6gg@mail.gmail.com>
References: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>
	<CANPzfU9fwU01mfbJj-c3xS8_HhkowEucTBn0Ov_pp7SdJuyp=g@mail.gmail.com>
	<1334705916.29813.140661063799689.297C1B43@webmail.messagingengine.com>
	<CANPzfU-Ghwa-pUTBzCowLRmEbKeJzH5O+ch98u3wMdVTksrKhg@mail.gmail.com>
	<1334760149.29653.140661064074917.6C4EA86E@webmail.messagingengine.com>
	<CANPzfU-0Q0X0sEttGCkLzYSio75c_Jf7fFry6S2LFzmQUzv6gg@mail.gmail.com>
Message-ID: <1334768258.16264.140661064122189.0E7DF10A@webmail.messagingengine.com>

Hi,

Any others who come after definitely need to learn a few things,
that's where documentation is nice.
A programmer who is not willing to learn is dangerous.

I agree, but I have to balance the overhead of making other
people learn a new tool with the value I am going to extract from
the tool. Going all in on Akka means that I can't use the
java.util and Guava's concurrency functionality which people are
already familiar with and is already used in several places.

After doing some quick cross checking it looks like Scala's
Future/Promise is roughly equivalent to Java's Future/FutureTask
which are extended by Guava to add the ListenableFuture
functionality. ListenableFutures effectively extend the
FutureTasks protected done method so that it invokes a set of
listeners and has some plumbing for maintaining the set of
listeners.

Can you illustrate where the ListenableFuture is more flexible?



Without actually validating with a compiler and without factoring
out functions to eliminate the nesting I would
do [1]http://pastebin.com/eC5XfeW4.

There are two key difference I see between andThen and
ListenableFuture. ListenableFuture can accept multiple listeners
and doesn't have to be run on completion of the Future on which
andThen would be invoked. ListenableFuture also allows you to
explicitly specify what thread will run the handler which may
allow you to skip some locking if you have a thread with
exclusive access to state the handler needs.

However this doesn't handle cancellation. I might be okay with
that and have cancel always return false.

Thanks,
Ariel

On Wed, Apr 18, 2012, at 05:12 PM, ?iktor ?lang wrote:

2012/4/18 Ariel Weisberg <[2]ariel at weisberg.ws>

Hi,

It looks like Akka Futures don't implement the regular Future
interface? My concern is that I would have to go all in on Akka
for my Future/ExecutorService needs. I don't mind it, but it
means that others who come after will have to learn to grok Akka
and the javadocs and implementation are in Scala.


Implementing java.util.concurrent.Future would be of little value
as it does not support non-blocking composition.

Any others who come after definitely need to learn a few things,
that's where documentation is nice.
A programmer who is not willing to learn is dangerous.


The first issue which is that it isn't a causal relationship
still exists. I can't invoke the fsync task once for each put.

The equivalent of and then with Guava is ListenableFuture which
is more flexible in that you can add multiple dependencies and it
separates the concern of when/how the dependencies will be
executed.


Can you illustrate where the ListenableFuture is more flexible?


I think that Joe's suggestion of exposing the set methods would
work. I can add listeners to the fsync task that invoke set on
the FutureTask returned by the put API. Guava has a
SettableFuture for this.


Promise is what you're looking for here.

Cheers,
?


Thanks,
Ariel

On Wed, Apr 18, 2012, at 08:03 AM, ?iktor ?lang wrote:

2012/4/18 Ariel Weisberg <[3]ariel at weisberg.ws>

Hi,

I am using Future and ListeningFuture interchangeably.

There isn't a causal relationship. The fsync task exists at the
time the overall put Future is created, but it isn't run until
some time later.

The thread running the fsync task has to cause all the put
Futures depending on it to enter the completed state and then all
the listeners have to be notified.

It seems like I want some combination of Guava's
ListenableFutureTask and maybe extending
ForwardingListenableFuture.

If the fsync action were a ListenableFutureTask I could forward
the the listener registrations to it. However part of the return
value is specific to each put (latency, compression ratio etc.).
Also cancel and related wouldn't go to the fsync Future either,
it would go to the write Future. If I bind the Future for the
fsync task and the Future for the write task and then extend
ForwardingFuture I could point each method to the correct place.
That is probably the "simplest" way to do it, but I wanted to
avoid extending a Future implementation and adding custom
behavior.

I think it is mostly co-incidence that I happen to be able to map
the various methods of ListenableFuture usefully to the two other
ListenableFutures (fsync tasks, write task) and it doesn't seem
like a great design pattern.

Akka is definitely something that interests me, especially the
distributed aspects, but it is a  lot to take on to solve this
problem.


The core-jar (akka-actor.jar) is completely standalone and has
nothing to do with distributed aspects. Just use the
Future-implementation.

Cheers,
?


Thanks,
Ariel

On Wed, Apr 18, 2012, at 12:44 AM, ?iktor ?lang wrote:

  Hi Ariel,



Akka's got composable
Futures: [4]http://doc.akka.io/docs/akka/2.0/java/futures.html



Essentiall, what you're looking for is the "andThen" operation:



(Scala)



val resultingFuture = Future { compressAndChecksum(payload) }
andThen { _ => fsync() }



Cheers,

?
On Tue, Apr 17, 2012 at 5:39 PM, Ariel Weisberg
<[5]ariel at weisberg.ws> wrote:

  Hi all,
  I have been looking for the right way to build an API that
  returns a
  Future that is composed of tasks that will be performed in
  multiple
  stages, potentially from more than one thread.
  My use cases is a disk based persistence store. The initial
  put API
  call creates a task that compresses and checksums the payload.
  The
  resulting Future is bound in a Runnable and submitted to a
  single
  thread ExecutorService that timestamps the entry and appends
  it to a
  file and it is the Future of the second task that is currently
  returned
  by the API.
   The trick is that the Future that is returned by the put call
  should
   not complete until the write is durable. Writes are made
  durable by
   periodically invoking fsync from a dedicated thread or by
  rotating
   write threads as each blocks on fsync/force. This allows for
  group
   commit at an interval the IO device can handle without
  killing
   throughput.
  Ideally I could create a FutureTask that is composed of
  several other
  Futures, some of which will not exist when the FutureTask is
  initially
  created and returned by the API. I do know how many
  dependencies there
  will be
  expected up front.
  If I had such a thing I would create a task to do the fsync
  and add it
  as the last dependency to every Future read by the put API
  call.
  This would be a lot easier if I were willing to have many
  threads
  standing around blocking on Futures, but that rubs me the
  wrong way. It
  isn't fun to jstack and see all the noise.
  I suspect that there is something in Guava
  com.google.common.util.concurrent.Futures to handle this case,
  but it
  isn't jumping out at me.
  Thanks,
  Ariel Weisberg
  _______________________________________________
  Concurrency-interest mailing list
  [6]Concurrency-interest at cs.oswego.edu
  [7]http://cs.oswego.edu/mailman/listinfo/concurrency-interest


--
Viktor Klang
Akka Tech Lead
[8]Typesafe - The software stack for applications that scale
Twitter: @viktorklang




  --
  Viktor Klang
  Akka Tech Lead

[9]Typesafe - The software stack for applications that scale
Twitter: @viktorklang




  --
  Viktor Klang
  Akka Tech Lead

[10]Typesafe - The software stack for applications that scale
Twitter: @viktorklang

References

1. http://pastebin.com/eC5XfeW4
2. mailto:ariel at weisberg.ws
3. mailto:ariel at weisberg.ws
4. http://doc.akka.io/docs/akka/2.0/java/futures.html
5. mailto:ariel at weisberg.ws
6. mailto:Concurrency-interest at cs.oswego.edu
7. http://cs.oswego.edu/mailman/listinfo/concurrency-interest
8. http://www.typesafe.com/
9. http://www.typesafe.com/
  10. http://www.typesafe.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120418/97dee816/attachment-0001.html>

From joe.bowbeer at gmail.com  Wed Apr 18 19:27:03 2012
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 18 Apr 2012 16:27:03 -0700
Subject: [concurrency-interest] Composing multiple tasks into a single
	Future/FutureTask
In-Reply-To: <1334768258.16264.140661064122189.0E7DF10A@webmail.messagingengine.com>
References: <1334677196.22912.140661063604833.6A52E16B@webmail.messagingengine.com>
	<CANPzfU9fwU01mfbJj-c3xS8_HhkowEucTBn0Ov_pp7SdJuyp=g@mail.gmail.com>
	<1334705916.29813.140661063799689.297C1B43@webmail.messagingengine.com>
	<CANPzfU-Ghwa-pUTBzCowLRmEbKeJzH5O+ch98u3wMdVTksrKhg@mail.gmail.com>
	<1334760149.29653.140661064074917.6C4EA86E@webmail.messagingengine.com>
	<CANPzfU-0Q0X0sEttGCkLzYSio75c_Jf7fFry6S2LFzmQUzv6gg@mail.gmail.com>
	<1334768258.16264.140661064122189.0E7DF10A@webmail.messagingengine.com>
Message-ID: <CAHzJPEqKj8zqZWyuggS7tYk0-PK9MTQiCpy3sMee_M00Vp2dUw@mail.gmail.com>

Below is a sketch using a periodic TimerTask to do the fsync() and set the
results.  Cancellation is implemented by checking whether future.isDone()
at opportune times.

public class Put {

    final Executor worker = Executors.newSingleThreadExecutor();

    final BlockingQueue<Written> queue = new LinkedBlockingQueue<>();

    final Timer fsyncTimer = new Timer();

    public interface Result { }

    public Future<Result> put(final byte[] key, final byte[] value) {
        final SettableFuture<Result> future = new SettableFuture<>();
        final long start = System.currentTimeMillis();
        worker.execute(new Runnable() {

            public void run() {
                try {
                    if (future.isDone()) return;
                    byte[] data = compress(key, value);
                    if (future.isDone()) return;
                    write(data);
                    if (future.isDone()) return;
                    queue.put(new Written(start, value.length, data.length,
future));
                } catch (InterruptedException ex) {
                    throw new IllegalStateException(ex); // TODO
                } catch (Throwable t) {
                    future.setException(t);
                }
            }
        });
        return future;
    }

    public void start() {
        TimerTask fsyncTask = new TimerTask() {

            public void run() {
                List<Written> list = new ArrayList<>();
                if (queue.drainTo(list) > 0) {
                    fsync();
                    long now = System.currentTimeMillis();
                    for (Written w : list) {
                        w.future.set(makeResult(now - w.start, w.length,
w.compressed));
                    }
                }
            }
        };

        fsyncTimer.schedule(fsyncTask, 5000, 5000);
    }

    public void stop() {
        fsyncTimer.cancel();
        // TODO: drain queue?
    }


    static class Written {
        final long start;
        final long length;
        final long compressed;
        final SettableFuture<Result> future;
        /* ... */
    }

    /* ... */
}


On Wed, Apr 18, 2012 at 9:57 AM, Ariel Weisberg wrote:

>   Hi,
>
>
>  Any others who come after definitely need to learn a few things, that's
> where documentation is nice.
>  A programmer who is not willing to learn is dangerous.
>
>  I agree, but I have to balance the overhead of making other people learn
> a new tool with the value I am going to extract from the tool. Going all in
> on Akka means that I can't use the java.util and Guava's concurrency
> functionality which people are already familiar with and is already used in
> several places.
>
>  After doing some quick cross checking it looks like Scala's
> Future/Promise is roughly equivalent to Java's Future/FutureTask which are
> extended by Guava to add the ListenableFuture functionality.
> ListenableFutures effectively extend the FutureTasks protected done method
> so that it invokes a set of listeners and has some plumbing for maintaining
> the set of listeners.
>
>
>  Can you illustrate where the ListenableFuture is more flexible?
>
>
>  Without actually validating with a compiler and without factoring out
> functions to eliminate the nesting I would do http://pastebin.com/eC5XfeW4
> .
>
>  There are two key difference I see between andThen and ListenableFuture.
> ListenableFuture can accept multiple listeners and doesn't have to be run
> on completion of the Future on which andThen would be invoked.
> ListenableFuture also allows you to explicitly specify what thread will run
> the handler which may allow you to skip some locking if you have a thread
> with exclusive access to state the handler needs.
>
>  However this doesn't handle cancellation. I might be okay with that and
> have cancel always return false.
>
>  Thanks,
>  Ariel
>
>  On Wed, Apr 18, 2012, at 05:12 PM, ?iktor ?lang wrote:
>
>
>
>  2012/4/18 Ariel Weisberg
>
>    Hi,
>
>  It looks like Akka Futures don't implement the regular Future interface?
> My concern is that I would have to go all in on Akka for my
> Future/ExecutorService needs. I don't mind it, but it means that others who
> come after will have to learn to grok Akka and the javadocs and
> implementation are in Scala.
>
>
>  Implementing java.util.concurrent.Future would be of little value as it
> does not support non-blocking composition.
>
>  Any others who come after definitely need to learn a few things, that's
> where documentation is nice.
>  A programmer who is not willing to learn is dangerous.
>
>
>
>  The first issue which is that it isn't a causal relationship still
> exists. I can't invoke the fsync task once for each put.
>
>    The equivalent of and then with Guava is ListenableFuture which is
> more flexible in that you can add multiple dependencies and it separates
> the concern of when/how the dependencies will be executed.
>
>
>  Can you illustrate where the ListenableFuture is more flexible?
>
>
>
>  I think that Joe's suggestion of exposing the set methods would work. I
> can add listeners to the fsync task that invoke set on the FutureTask
> returned by the put API. Guava has a SettableFuture for this.
>
>
>  Promise is what you're looking for here.
>
>  Cheers,
>  ?
>
>
>
>  Thanks,
>  Ariel
>
>  On Wed, Apr 18, 2012, at 08:03 AM, ?iktor ?lang wrote:
>
>
>
>  2012/4/18 Ariel Weisberg
>
>    Hi,
>
>  I am using Future and ListeningFuture interchangeably.
>
>  There isn't a causal relationship. The fsync task exists at the time the
> overall put Future is created, but it isn't run until some time later.
>
>  The thread running the fsync task has to cause all the put Futures
> depending on it to enter the completed state and then all the listeners
> have to be notified.
>
>  It seems like I want some combination of Guava's ListenableFutureTask and
> maybe extending ForwardingListenableFuture.
>
>  If the fsync action were a ListenableFutureTask I could forward the the
> listener registrations to it. However part of the return value is specific
> to each put (latency, compression ratio etc.). Also cancel and related
> wouldn't go to the fsync Future either, it would go to the write Future. If
> I bind the Future for the fsync task and the Future for the write task and
> then extend ForwardingFuture I could point each method to the correct
> place. That is probably the "simplest" way to do it, but I wanted to avoid
> extending a Future implementation and adding custom behavior.
>
>  I think it is mostly co-incidence that I happen to be able to map the
> various methods of ListenableFuture usefully to the two other
> ListenableFutures (fsync tasks, write task) and it doesn't seem like a
> great design pattern.
>
>  Akka is definitely something that interests me, especially the
> distributed aspects, but it is a  lot to take on to solve this problem.
>
>
>  The core-jar (akka-actor.jar) is completely standalone and has nothing to
> do with distributed aspects. Just use the Future-implementation.
>
>  Cheers,
>  ?
>
>
>
>  Thanks,
>  Ariel
>
>  On Wed, Apr 18, 2012, at 12:44 AM, ?iktor ?lang wrote:
>
> Hi Ariel,
>
>  Akka's got composable Futures:
> http://doc.akka.io/docs/akka/2.0/java/futures.html
>
>  Essentiall, what you're looking for is the "andThen" operation:
>
>  (Scala)
>
>  val resultingFuture = Future { compressAndChecksum(payload) } andThen { _
> => fsync() }
>
>  Cheers,
>  ?
>
>  On Tue, Apr 17, 2012 at 5:39 PM, Ariel Weisberg wrote:
>
> Hi all,
>
> I have been looking for the right way to build an API that returns a
> Future that is composed of tasks that will be performed in multiple
> stages, potentially from more than one thread.
>
> My use cases is a disk based persistence store. The initial put API
> call creates a task that compresses and checksums the payload. The
> resulting Future is bound in a Runnable and submitted to a single
> thread ExecutorService that timestamps the entry and appends it to a
> file and it is the Future of the second task that is currently returned
> by the API.
>
>  The trick is that the Future that is returned by the put call should
>  not complete until the write is durable. Writes are made durable by
>  periodically invoking fsync from a dedicated thread or by rotating
>  write threads as each blocks on fsync/force. This allows for group
>  commit at an interval the IO device can handle without killing
>  throughput.
>
> Ideally I could create a FutureTask that is composed of several other
> Futures, some of which will not exist when the FutureTask is initially
> created and returned by the API. I do know how many dependencies there
> will be
> expected up front.
>
> If I had such a thing I would create a task to do the fsync and add it
> as the last dependency to every Future read by the put API call.
>
> This would be a lot easier if I were willing to have many threads
> standing around blocking on Futures, but that rubs me the wrong way. It
> isn't fun to jstack and see all the noise.
>
> I suspect that there is something in Guava
> com.google.common.util.concurrent.Futures to handle this case, but it
> isn't jumping out at me.
>
> Thanks,
> Ariel Weisberg
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120418/96385780/attachment-0001.html>

From aleksey.shipilev at gmail.com  Thu Apr 19 11:14:59 2012
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Thu, 19 Apr 2012 19:14:59 +0400
Subject: [concurrency-interest] Work-stealing ThreadPool
Message-ID: <4F902BF3.1090309@gmail.com>

Hi guys,

There are multiple cases now when people are choosing ForkJoinPool over
regular ThreadPoolExecutor because of improved submission throughput and
work balancing. Can we embrace this fact and do proper isolation in API
for this cases?

I'm thinking public class j.u.c.WorkStealingExecutor implementing
ExecutorService, but delegating directly to ForkJoinPool. If that is
added to JDK7/JDK8, we can properly isolate these customers from
exposing FJP underneath. Moreover, after this API is exposed, we can
gradually replace FJP delegation with independent work-stealing
executor, if ties with FJP will bother anyone.

Are there any troubles with this proposal I missed?

-Aleksey.

From viktor.klang at gmail.com  Thu Apr 19 13:29:05 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Thu, 19 Apr 2012 19:29:05 +0200
Subject: [concurrency-interest] Work-stealing ThreadPool
In-Reply-To: <4F902BF3.1090309@gmail.com>
References: <4F902BF3.1090309@gmail.com>
Message-ID: <CANPzfU-muL8zUqBFkbp1AG9GE9G875EsJ20_vDHkNW1_3K4rrw@mail.gmail.com>

I really recommend to avoid the use of the ExecutorService interface,
it's just way too general/broad, placing a lot of burden on the underlying
implementation.

That being said, I definitely think that splitting out the idea of
worker-local submission queues and work-stealing should be ripped out of
ForkJoinPool and then build ForkJoinPool on top of it.

Cheers,
?

On Thu, Apr 19, 2012 at 5:14 PM, Aleksey Shipilev <
aleksey.shipilev at gmail.com> wrote:

> Hi guys,
>
> There are multiple cases now when people are choosing ForkJoinPool over
> regular ThreadPoolExecutor because of improved submission throughput and
> work balancing. Can we embrace this fact and do proper isolation in API
> for this cases?
>
> I'm thinking public class j.u.c.WorkStealingExecutor implementing
> ExecutorService, but delegating directly to ForkJoinPool. If that is
> added to JDK7/JDK8, we can properly isolate these customers from
> exposing FJP underneath. Moreover, after this API is exposed, we can
> gradually replace FJP delegation with independent work-stealing
> executor, if ties with FJP will bother anyone.
>
> Are there any troubles with this proposal I missed?
>
> -Aleksey.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120419/28e637c7/attachment.html>

From radhakrishnan.mohan at gmail.com  Fri Apr 20 00:58:41 2012
From: radhakrishnan.mohan at gmail.com (Mohan Radhakrishnan)
Date: Fri, 20 Apr 2012 10:28:41 +0530
Subject: [concurrency-interest] Work-stealing ThreadPool
In-Reply-To: <4F902BF3.1090309@gmail.com>
References: <4F902BF3.1090309@gmail.com>
Message-ID: <CAOoXFP9CfFSn2kMpHMYtg-hz4rceF9sLpu8qDYzwAZ8dKFoK=w@mail.gmail.com>

Hi,

Are there many OSS frameworks that use FJ in different ways to understand
these requirements ? The
wide adoption of these ideas could form a better sample space. Now it seems
that only specialized framework
developers use them.

I might be wrong because we don't have colleagues who are aware of some of
these advanced ideas.

Thanks.

On Thu, Apr 19, 2012 at 8:44 PM, Aleksey Shipilev <
aleksey.shipilev at gmail.com> wrote:

> Hi guys,
>
> There are multiple cases now when people are choosing ForkJoinPool over
> regular ThreadPoolExecutor because of improved submission throughput and
> work balancing. Can we embrace this fact and do proper isolation in API
> for this cases?
>
> I'm thinking public class j.u.c.WorkStealingExecutor implementing
> ExecutorService, but delegating directly to ForkJoinPool. If that is
> added to JDK7/JDK8, we can properly isolate these customers from
> exposing FJP underneath. Moreover, after this API is exposed, we can
> gradually replace FJP delegation with independent work-stealing
> executor, if ties with FJP will bother anyone.
>
> Are there any troubles with this proposal I missed?
>
> -Aleksey.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120420/597edc97/attachment.html>

From aleksey.shipilev at gmail.com  Fri Apr 20 04:29:57 2012
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Fri, 20 Apr 2012 12:29:57 +0400
Subject: [concurrency-interest] Proper workaround for FutureTask.set()/get()
	race (CR 7132378)
Message-ID: <4F911E85.6080109@gmail.com>

Hi guys,

I'm trying to workaround the FutureTask race described in CR 7132378:
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7132378

I do realize the fix is already there in Doug's code, but both waiting
for JDK update or bootclasspath-ing jsr166.jar is not an option for this
particular case I'm dealing with.

Hence, my question is: can this code be considered a proper workaround?

/**
 * Specialized form of future allowing to set the result.
 *
 * @param <V>
 */
public class SettableFuture<V> extends FutureTask<V> {

    /**
     * Implementation notes:
     *
     * This implementation also accounts for known bug in FutureTask:
     * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7132378
     *
     * We compensate for possible race by making sure set() had
     * completed before returning from get(). Since get() is
     * blocking operation, we first wait without any synchronization,
     * and then do get() again synchronizing with set() to make sure
     * set() had indeed completed.
     *
     * This bails out earlier on exception or if the timeout had
     * expired.
     */

    /**
     * Dummy callable so that underlying implementation
     * will not complain.
     */
    private static final Callable DUMMY = new Callable() {
        @Override
        public Object call() throws Exception {
            throw new IllegalStateException("Trying to read from dummy
callable in SettableFuture");
        }
    };

    public SettableFuture() {
        super(DUMMY);
    }

    @Override
    public void set(V v) {
        synchronized (this) {
            super.set(v);
        }
    }

    @Override
    protected void setException(Throwable t) {
        synchronized (this) {
            super.setException(t);
        }
    }

    @Override
    public V get() throws InterruptedException, ExecutionException {
        super.get();
        synchronized (this) {
            return super.get();
        }
    }

    @Override
    public V get(long timeout, TimeUnit unit) throws
InterruptedException, ExecutionException, TimeoutException {
        super.get(timeout, unit);
        synchronized (this) {
            return super.get();
        }
    }
}

Thanks,
Aleksey.


From dl at cs.oswego.edu  Fri Apr 20 07:15:00 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 20 Apr 2012 07:15:00 -0400
Subject: [concurrency-interest] Work-stealing ThreadPool
In-Reply-To: <4F902BF3.1090309@gmail.com>
References: <4F902BF3.1090309@gmail.com>
Message-ID: <4F914534.5090108@cs.oswego.edu>

On 04/19/12 11:14, Aleksey Shipilev wrote:
> Hi guys,
>
> There are multiple cases now when people are choosing ForkJoinPool over
> regular ThreadPoolExecutor because of improved submission throughput and
> work balancing. Can we embrace this fact and do proper isolation in API
> for this cases?

To clarify what you are asking for.....
Both ForkJoinPool and ThreadPoolExecutor implement ExecutorService.
So if you'd don't want to expose any FJP or TPE methods, you
can just use these. If you'd like to further make non-ExecutorService
methods inaccessible even under downcast, then you'd instead want
a simple DelegatingExecutorService that relays only ExecutorService
methods; or possibly only a subset (for example, no shutdown()).
Is this what you are looking for?

If not, maybe the simplest addition is to add a factory method
in class Executors:
   ExecutorService workStealingExecutor() {
     return new ForkJoinPool();
   }



-Doug

From aleksey.shipilev at gmail.com  Fri Apr 20 07:44:03 2012
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Fri, 20 Apr 2012 15:44:03 +0400
Subject: [concurrency-interest] Work-stealing ThreadPool
In-Reply-To: <4F914534.5090108@cs.oswego.edu>
References: <4F902BF3.1090309@gmail.com> <4F914534.5090108@cs.oswego.edu>
Message-ID: <4F914C03.2020202@gmail.com>

Hi Doug,

On 04/20/2012 03:15 PM, Doug Lea wrote:
> Is this what you are looking for?

Not quite. If I control the application source code, I can do proper
isolation. However, from the purist JDK point of view, we (JDK
maintainers) are better provide clean API to make users tell us the only
thing they want from executor is not FJP itself, but just work-stealing
executor.

> If not, maybe the simplest addition is to add a factory method
> in class Executors:
>   ExecutorService workStealingExecutor() {
>     return new ForkJoinPool();
>   }

Yes, that works. IMO, there's also should be additional method which
controls parallelism. Also, should we force async mode here?

-Aleksey.

From dl at cs.oswego.edu  Sat Apr 21 08:13:08 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 21 Apr 2012 08:13:08 -0400
Subject: [concurrency-interest] CountedCompleters
In-Reply-To: <4F8D6651.40309@laposte.net>
References: <4F82EF21.4020804@cs.oswego.edu>
	<4F8C313F.2080308@laposte.net>	<4F8D54B0.8030904@cs.oswego.edu>
	<4F8D6651.40309@laposte.net>
Message-ID: <4F92A454.5080205@cs.oswego.edu>

The updated version of CountedCompleter now includes:

     /**
      * Performs an action when method {@link #completeExceptionally}
      * is invoked or method {@link #compute} throws an exception, and
      * this task has not otherwise already completed normally. On
      * entry to this method, this task {@link
      * ForkJoinTask#isCompletedAbnormally}.  The return value of this
      * method controls further propagation: If {@code true} and this
      * task has a completer, then this completer is also completed
      * exceptionally.  The default implementation of this method does
      * nothing except return {@code true}.
      *
      * @param ex the exception
      * @param caller the task invoking this method (which may
      * be this task itself).
      * @return true if this exception should be propagated to this
      * tasks completer, if one exists.
      */
     public boolean onExceptionalCompletion(Throwable ex, CountedCompleter caller)


On 04/17/12 08:47, Wolfgang Baltes wrote:
>
>>
>> The issue boils down to where we'd like users to place exception
>> code. In the current scheme, any task doing IO etc can do:
>> try {
>> io();
>> } catch(IOException ex) {
>> completeExceptionally(ex); // or throw new Error(ex)
>> return;
>> }
>>
>> ... as opposed to placing the call to compute() itself in
>> a try/catch. My take is that the current scheme is a little
>> easier and slightly more pleasant to use. Counter-examples
>> would be welcome though.
>>
> This is what I do now. But there is already a try construct in the main worker
> thread loop, and this adds an extra try block. This requires some extra time to
> execute, which is even more annoying as it will be executed every time the task
> is run.

I don't believe this extra try-block costs anything -- or if so, not
enough to worry about. The generated instructions for compiled code
of versions using variant conventions are a little different, but
not obviously worse than each other.

>>> 3: Provide a method to join a task that is not forked and/or not completable,
>>> while minimizing worker thread blocking.

I'm still not sure about whether or how to address this.
Could you send me examples with more context off-list
so I can contemplate alternatives?

-Doug

From wolfgang.baltes at laposte.net  Sat Apr 21 08:54:22 2012
From: wolfgang.baltes at laposte.net (Wolfgang Baltes)
Date: Sat, 21 Apr 2012 14:54:22 +0200
Subject: [concurrency-interest] CountedCompleters
In-Reply-To: <4F92A454.5080205@cs.oswego.edu>
References: <4F82EF21.4020804@cs.oswego.edu>
	<4F8C313F.2080308@laposte.net>	<4F8D54B0.8030904@cs.oswego.edu>
	<4F8D6651.40309@laposte.net> <4F92A454.5080205@cs.oswego.edu>
Message-ID: <4F92ADFE.70804@laposte.net>

Thanks, Doug, for implementing this and providing the update to this 
list. I guess all this will come with JDK 8, and not before!?
Wolfgang.

On 2012-04-21 14:13, Doug Lea wrote:
> The updated version of CountedCompleter now includes:
>
>     /**
>      * Performs an action when method {@link #completeExceptionally}
>      * is invoked or method {@link #compute} throws an exception, and
>      * this task has not otherwise already completed normally. On
>      * entry to this method, this task {@link
>      * ForkJoinTask#isCompletedAbnormally}.  The return value of this
>      * method controls further propagation: If {@code true} and this
>      * task has a completer, then this completer is also completed
>      * exceptionally.  The default implementation of this method does
>      * nothing except return {@code true}.
>      *
>      * @param ex the exception
>      * @param caller the task invoking this method (which may
>      * be this task itself).
>      * @return true if this exception should be propagated to this
>      * tasks completer, if one exists.
>      */
>     public boolean onExceptionalCompletion(Throwable ex,
> CountedCompleter caller)
>
>
> On 04/17/12 08:47, Wolfgang Baltes wrote:
>>
>>>
>>> The issue boils down to where we'd like users to place exception
>>> code. In the current scheme, any task doing IO etc can do:
>>> try {
>>> io();
>>> } catch(IOException ex) {
>>> completeExceptionally(ex); // or throw new Error(ex)
>>> return;
>>> }
>>>
>>> ... as opposed to placing the call to compute() itself in
>>> a try/catch. My take is that the current scheme is a little
>>> easier and slightly more pleasant to use. Counter-examples
>>> would be welcome though.
>>>
>> This is what I do now. But there is already a try construct in the
>> main worker
>> thread loop, and this adds an extra try block. This requires some
>> extra time to
>> execute, which is even more annoying as it will be executed every
>> time the task
>> is run.
>
> I don't believe this extra try-block costs anything -- or if so, not
> enough to worry about. The generated instructions for compiled code
> of versions using variant conventions are a little different, but
> not obviously worse than each other.
>
>>>> 3: Provide a method to join a task that is not forked and/or not
>>>> completable,
>>>> while minimizing worker thread blocking.
>
> I'm still not sure about whether or how to address this.
> Could you send me examples with more context off-list
> so I can contemplate alternatives?
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dl at cs.oswego.edu  Sat Apr 21 09:05:29 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 21 Apr 2012 09:05:29 -0400
Subject: [concurrency-interest] CountedCompleters
In-Reply-To: <4F92ADFE.70804@laposte.net>
References: <4F82EF21.4020804@cs.oswego.edu>	<4F8C313F.2080308@laposte.net>	<4F8D54B0.8030904@cs.oswego.edu>	<4F8D6651.40309@laposte.net>
	<4F92A454.5080205@cs.oswego.edu> <4F92ADFE.70804@laposte.net>
Message-ID: <4F92B099.3000403@cs.oswego.edu>

On 04/21/12 08:54, Wolfgang Baltes wrote:
> Thanks, Doug, for implementing this and providing the update to this list. I
> guess all this will come with JDK 8, and not before!?

Yes, but we keep the jsr166y versions in sync with updates
to j.u.c versions. Assuming you are able to run java with
with special booclasspath settings, you can use them now
(with any jdk6+ JVM) just by changing imports from
java.util.concurrent to jsr166y and then running with
jsr166y.jar in your bootclasspath. (Although this may
not work under some SecurityManagers.)

-Doug

From dl at cs.oswego.edu  Sat Apr 21 09:17:48 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 21 Apr 2012 09:17:48 -0400
Subject: [concurrency-interest] Work-stealing ThreadPool
In-Reply-To: <4F914C03.2020202@gmail.com>
References: <4F902BF3.1090309@gmail.com> <4F914534.5090108@cs.oswego.edu>
	<4F914C03.2020202@gmail.com>
Message-ID: <4F92B37C.8020807@cs.oswego.edu>

On 04/20/12 07:44, Aleksey Shipilev wrote:

> Yes, that works. IMO.

I provisionally added the following to the j.u.c.Executors class.
Comments, suggestions, and objections would be welcome.



     /**
      * Creates a thread pool that maintains enough threads to support
      * the given parallelism level, and may use multiple queues to
      * reduce contention. The parallelism level corresponds to the
      * maximum number of threads actively engaged in, or available to
      * engage in, task processing. The actual number of threads may
      * grow and shrink dynamically. A work-stealing pool makes no
      * guarantees about the order in which submitted tasks are
      * executed.
      *
      * @param parallelism the targeted parallelism level
      * @return the newly created thread pool
      * @throws IllegalArgumentException if {@code parallelism <= 0}
      * @since 1.8
      */
     public static ExecutorService newWorkStealingPool(int parallelism) {
         return new ForkJoinPool
             (parallelism,
              ForkJoinPool.defaultForkJoinWorkerThreadFactory,
              null, true);
     }

     /**
      * Creates a work-stealing thread pool using all
      * (@link Runtime#availableProcessors available processors}
      * as its target parallelism level.
      * @return the newly created thread pool
      * @since 1.8
      */
     public static ExecutorService newWorkStealingPool() {
         return new ForkJoinPool
             (Runtime.getRuntime().availableProcessors(),
              ForkJoinPool.defaultForkJoinWorkerThreadFactory,
              null, true);
     }

From wolfgang.baltes at laposte.net  Sat Apr 21 10:29:15 2012
From: wolfgang.baltes at laposte.net (Wolfgang Baltes)
Date: Sat, 21 Apr 2012 16:29:15 +0200
Subject: [concurrency-interest] CountedCompleters
In-Reply-To: <4F92B099.3000403@cs.oswego.edu>
References: <4F82EF21.4020804@cs.oswego.edu>	<4F8C313F.2080308@laposte.net>	<4F8D54B0.8030904@cs.oswego.edu>	<4F8D6651.40309@laposte.net>
	<4F92A454.5080205@cs.oswego.edu> <4F92ADFE.70804@laposte.net>
	<4F92B099.3000403@cs.oswego.edu>
Message-ID: <4F92C43B.7090307@laposte.net>

For the time being, using jsr166y in bootclasspath with Java 7 is 
better. I noticed that the latest available build for Java 8 is 
significantly slower.

W.

On 2012-04-21 15:05, Doug Lea wrote:
> On 04/21/12 08:54, Wolfgang Baltes wrote:
>> Thanks, Doug, for implementing this and providing the update to this 
>> list. I
>> guess all this will come with JDK 8, and not before!?
>
> Yes, but we keep the jsr166y versions in sync with updates
> to j.u.c versions. Assuming you are able to run java with
> with special booclasspath settings, you can use them now
> (with any jdk6+ JVM) just by changing imports from
> java.util.concurrent to jsr166y and then running with
> jsr166y.jar in your bootclasspath. (Although this may
> not work under some SecurityManagers.)
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dl at cs.oswego.edu  Sat Apr 21 10:51:24 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 21 Apr 2012 10:51:24 -0400
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F911E85.6080109@gmail.com>
References: <4F911E85.6080109@gmail.com>
Message-ID: <4F92C96C.1000108@cs.oswego.edu>

On 04/20/12 04:29, Aleksey Shipilev wrote:
> Hi guys,
>
> I'm trying to workaround the FutureTask race described in CR 7132378:
> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7132378
>
> I do realize the fix is already there in Doug's code, but both waiting
> for JDK update or bootclasspath-ing jsr166.jar is not an option for this
> particular case I'm dealing with.

Although it would seem that if you could add SettableFuture, you
might as well just take/adapt the updated FutureTask class instead?
Even if you have to cripple it a bit by using AtomicXFieldUpdaters
instead of direct CAS calls, it is probably a better option.
If not, your workaround seems OK though.

(BTW, one moral of that CR is that whenever you don't explicitly
disallow an unintended usage, it will eventually  end up as a
bug report :-)


-Doug


>
> Hence, my question is: can this code be considered a proper workaround?
>
> /**
>   * Specialized form of future allowing to set the result.
>   *
>   * @param<V>
>   */
> public class SettableFuture<V>  extends FutureTask<V>  {
>
>      /**
>       * Implementation notes:
>       *
>       * This implementation also accounts for known bug in FutureTask:
>       * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7132378
>       *
>       * We compensate for possible race by making sure set() had
>       * completed before returning from get(). Since get() is
>       * blocking operation, we first wait without any synchronization,
>       * and then do get() again synchronizing with set() to make sure
>       * set() had indeed completed.
>       *
>       * This bails out earlier on exception or if the timeout had
>       * expired.
>       */
>
>      /**
>       * Dummy callable so that underlying implementation
>       * will not complain.
>       */
>      private static final Callable DUMMY = new Callable() {
>          @Override
>          public Object call() throws Exception {
>              throw new IllegalStateException("Trying to read from dummy
> callable in SettableFuture");
>          }
>      };
>
>      public SettableFuture() {
>          super(DUMMY);
>      }
>
>      @Override
>      public void set(V v) {
>          synchronized (this) {
>              super.set(v);
>          }
>      }
>
>      @Override
>      protected void setException(Throwable t) {
>          synchronized (this) {
>              super.setException(t);
>          }
>      }
>
>      @Override
>      public V get() throws InterruptedException, ExecutionException {
>          super.get();
>          synchronized (this) {
>              return super.get();
>          }
>      }
>
>      @Override
>      public V get(long timeout, TimeUnit unit) throws
> InterruptedException, ExecutionException, TimeoutException {
>          super.get(timeout, unit);
>          synchronized (this) {
>              return super.get();
>          }
>      }
> }
>
> Thanks,
> Aleksey.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From aleksey.shipilev at gmail.com  Sat Apr 21 14:53:28 2012
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Sat, 21 Apr 2012 22:53:28 +0400
Subject: [concurrency-interest] Work-stealing ThreadPool
In-Reply-To: <4F92B37C.8020807@cs.oswego.edu>
References: <4F902BF3.1090309@gmail.com> <4F914534.5090108@cs.oswego.edu>
	<4F914C03.2020202@gmail.com> <4F92B37C.8020807@cs.oswego.edu>
Message-ID: <4F930228.8000603@gmail.com>

On 04/21/2012 05:17 PM, Doug Lea wrote:
> On 04/20/12 07:44, Aleksey Shipilev wrote:
> I provisionally added the following to the j.u.c.Executors class.
> Comments, suggestions, and objections would be welcome.

Thanks!

Additional one with settable thread factory would come handy as well.

-Aleksey.

From aleksey.shipilev at gmail.com  Sat Apr 21 15:08:10 2012
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Sat, 21 Apr 2012 23:08:10 +0400
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F92C96C.1000108@cs.oswego.edu>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
Message-ID: <4F93059A.6050703@gmail.com>

On 04/21/2012 06:51 PM, Doug Lea wrote:
> Although it would seem that if you could add SettableFuture, you
> might as well just take/adapt the updated FutureTask class instead?
> Even if you have to cripple it a bit by using AtomicXFieldUpdaters
> instead of direct CAS calls, it is probably a better option.

In fact, this was the starting point of this whole trouble.

Some library guys have indeed copied FutureTask into their project and
hacked it to allow public set(). It is 1:1 comparable with JDK-ish
version, but it will never get the proper fix from JDK. So they now are
persuaded to extend FutureTask directly, to pick up whatever
fixes/changes are there in JDK.

> If not, your workaround seems OK though.

Thanks for reviewing it. The beauty of this workaround is that once the
fix hits the JDK, maintainers can remove synchronized {}, and that
single change transforms this class to just one single adapter.

> (BTW, one moral of that CR is that whenever you don't explicitly
> disallow an unintended usage, it will eventually  end up as a
> bug report :-)

Yes. SettableFuture-like class is something missing from concurrent
classes I'm redoing over and over again in most of the projects.
Implementing it directly on top of AQS might provide some benefits
comparing to extending from FutureTask? Oh wait, it smells like another
API enhancement proposal? :)

Cheers,
Aleksey.

From joe.bowbeer at gmail.com  Sat Apr 21 16:33:04 2012
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sat, 21 Apr 2012 13:33:04 -0700
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F93059A.6050703@gmail.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
Message-ID: <CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>

On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:

> Yes. SettableFuture-like class is something missing from concurrent
> classes I'm redoing over and over again in most of the projects.
> Implementing it directly on top of AQS might provide some benefits
> comparing to extending from FutureTask? Oh wait, it smells like another
> API enhancement proposal? :)
>

Alex,

Bill Pugh once suggested a separate concurrency abstraction: an
externally settable FutureValue<V>, which supports the following methods:

       V get() -  Waits if necessary for the value to be set, and then
returns the value.
       boolean isDone() - Returns true if the value is set
       boolean set(V v) - Sets the value if it was not already set.
               Returns true if the value was set by this call, false if it
               was set by another call.

Having set(v) return a boolean seems like a good idea.  What do you think?

To this I would also add the other Future methods such as cancel(), plus
setException().  In other words, I envision FutureValue as a Future with
two additional methods: boolean set(v) and boolean setException(e).

Are there any other Future enhancements that you think are sorely needed in
j.u.c.?

--Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120421/0a384bff/attachment.html>

From aleksey.shipilev at gmail.com  Sat Apr 21 17:06:16 2012
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Sun, 22 Apr 2012 01:06:16 +0400
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
Message-ID: <4F932148.8080301@gmail.com>

On 04/22/2012 12:33 AM, Joe Bowbeer wrote:
> Having set(v) return a boolean seems like a good idea.  What do you think?
> 
> To this I would also add the other Future methods such as cancel(), plus
> setException().  In other words, I envision FutureValue as a Future with
> two additional methods: boolean set(v) and boolean setException(e).

Yes, I will support this thinking.

Returning boolean definitely helps with two threads racing to set the
result. What should be the behavior when one thread is setting the
completed result, and other sets the exception? Making these two cases
distinct raises a weird corollary for two consecutive get()-s: first can
return the proper result, and then second one throw the
ExecutionException. I think this somewhat isolated by FutureTask now
requiring proper Runnable/Callable to be executed, but we need to
recheck if that race is still viable with manual set()/setException().

> Are there any other Future enhancements that you think are sorely needed
> in j.u.c.?

I think that's the one. Otherwise I am very happy with j.u.c.

Cheers,
Aleksey.

From joe.bowbeer at gmail.com  Sat Apr 21 17:25:29 2012
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sat, 21 Apr 2012 14:25:29 -0700
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F932148.8080301@gmail.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F932148.8080301@gmail.com>
Message-ID: <CAHzJPEqodvjEMMQGkyuszEE1_WAorQun8gAD+DJRmnguuxiaAw@mail.gmail.com>

On Sat, Apr 21, 2012 at 2:06 PM, Aleksey Shipilev wrote:

> On 04/22/2012 12:33 AM, Joe Bowbeer wrote:
> > Having set(v) return a boolean seems like a good idea.  What do you
> think?
> >
> > To this I would also add the other Future methods such as cancel(), plus
> > setException().  In other words, I envision FutureValue as a Future with
> > two additional methods: boolean set(v) and boolean setException(e).
>
> Yes, I will support this thinking.
>
> Returning boolean definitely helps with two threads racing to set the
> result. What should be the behavior when one thread is setting the
> completed result, and other sets the exception? Making these two cases
> distinct raises a weird corollary for two consecutive get()-s: first can
> return the proper result, and then second one throw the
> ExecutionException. I think this somewhat isolated by FutureTask now
> requiring proper Runnable/Callable to be executed, but we need to
> recheck if that race is still viable with manual set()/setException().


My assumption is that the FutureValue can only complete once, whether by
cancel(), set(v), or setException(e).

Once complete, isDone returns true, and set(v) and setException(e) do
nothing but return false.

--Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120421/642941f5/attachment.html>

From tim at peierls.net  Sat Apr 21 17:56:47 2012
From: tim at peierls.net (Tim Peierls)
Date: Sat, 21 Apr 2012 17:56:47 -0400
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <CAHzJPEqodvjEMMQGkyuszEE1_WAorQun8gAD+DJRmnguuxiaAw@mail.gmail.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F932148.8080301@gmail.com>
	<CAHzJPEqodvjEMMQGkyuszEE1_WAorQun8gAD+DJRmnguuxiaAw@mail.gmail.com>
Message-ID: <CA+F8eeQO4+VHWynLz5raCERvQumSFLA9Dr4vxwGgDBvquGGaQQ@mail.gmail.com>

Guava's SettableFuture [1] provides this behavior, or comes very close. I'd
be interesting in hearing from people who are dissatisfied with the current
j.u.c to what extent, if any, com.google.common.util.concurrent [2]
addresses those dissatisfactions.

--tim

[1]
http://docs.guava-libraries.googlecode.com/git-history/v12.0/javadoc/com/google/common/util/concurrent/SettableFuture.html
[2]
http://docs.guava-libraries.googlecode.com/git-history/v12.0/javadoc/com/google/common/util/concurrent/package-summary.html


On Sat, Apr 21, 2012 at 5:25 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> On Sat, Apr 21, 2012 at 2:06 PM, Aleksey Shipilev wrote:
>
>> On 04/22/2012 12:33 AM, Joe Bowbeer wrote:
>> > Having set(v) return a boolean seems like a good idea.  What do you
>> think?
>> >
>> > To this I would also add the other Future methods such as cancel(), plus
>> > setException().  In other words, I envision FutureValue as a Future with
>> > two additional methods: boolean set(v) and boolean setException(e).
>>
>> Yes, I will support this thinking.
>>
>> Returning boolean definitely helps with two threads racing to set the
>> result. What should be the behavior when one thread is setting the
>> completed result, and other sets the exception? Making these two cases
>> distinct raises a weird corollary for two consecutive get()-s: first can
>> return the proper result, and then second one throw the
>> ExecutionException. I think this somewhat isolated by FutureTask now
>> requiring proper Runnable/Callable to be executed, but we need to
>> recheck if that race is still viable with manual set()/setException().
>
>
> My assumption is that the FutureValue can only complete once, whether by
> cancel(), set(v), or setException(e).
>
> Once complete, isDone returns true, and set(v) and setException(e) do
> nothing but return false.
>
> --Joe
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120421/c18c5baa/attachment-0001.html>

From viktor.klang at gmail.com  Sat Apr 21 18:19:49 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Sun, 22 Apr 2012 00:19:49 +0200
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
Message-ID: <CANPzfU9U12BZSz6aTDZxHXmkdN3-YsfJx58swu0ZDJr29VgW7w@mail.gmail.com>

On Sat, Apr 21, 2012 at 10:33 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>
>> Yes. SettableFuture-like class is something missing from concurrent
>> classes I'm redoing over and over again in most of the projects.
>> Implementing it directly on top of AQS might provide some benefits
>> comparing to extending from FutureTask? Oh wait, it smells like another
>> API enhancement proposal? :)
>>
>
> Alex,
>
> Bill Pugh once suggested a separate concurrency abstraction: an
> externally settable FutureValue<V>, which supports the following methods:
>
>        V get() -  Waits if necessary for the value to be set, and then
> returns the value.
>        boolean isDone() - Returns true if the value is set
>        boolean set(V v) - Sets the value if it was not already set.
>                Returns true if the value was set by this call, false if it
>                was set by another call.
>
> Having set(v) return a boolean seems like a good idea.  What do you think?
>
> To this I would also add the other Future methods such as cancel(), plus
> setException().  In other words, I envision FutureValue as a Future with
> two additional methods: boolean set(v) and boolean setException(e).
>
> Are there any other Future enhancements that you think are sorely needed
> in j.u.c.?
>

onResult + onException callbacks.

Cheers,
?


>
> --Joe
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120422/440ec527/attachment.html>

From dl at cs.oswego.edu  Sun Apr 22 10:56:09 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 22 Apr 2012 10:56:09 -0400
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <CANPzfU9U12BZSz6aTDZxHXmkdN3-YsfJx58swu0ZDJr29VgW7w@mail.gmail.com>
References: <4F911E85.6080109@gmail.com>
	<4F92C96C.1000108@cs.oswego.edu>	<4F93059A.6050703@gmail.com>	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<CANPzfU9U12BZSz6aTDZxHXmkdN3-YsfJx58swu0ZDJr29VgW7w@mail.gmail.com>
Message-ID: <4F941C09.30002@cs.oswego.edu>

On 04/21/12 18:19, ?iktor ?lang wrote:
>     Having set(v) return a boolean seems like a good idea.  What do you think?
>
>     To this I would also add the other Future methods such as cancel(), plus
>     setException().  In other words, I envision FutureValue as a Future with two
>     additional methods: boolean set(v) and boolean setException(e).
>
>     Are there any other Future enhancements that you think are sorely needed in
>     j.u.c.?
>
>
> onResult + onException callbacks.
>

My main uncomfortableness with the line of attack is that it
leads to some odd in-between points between FutureTask and
ForkJoinTask.

Backing up: The main difference between them is that a
FutureTask runs a Runnable/Callable that is oblivious
to its surroundings, while the different flavors of
ForkJoinTask have integrated compute methods that can internally
access  all of the task mechanics (including setting results, as
well as extensible completion mechanics in the new CountedCompleter.)

It also just so happens that if you have a ForkJoinTask
rather than a FutureTask or some other Future, we know
how to run it much more efficiently if you submit it to
a ForkJoinPool, as opposed to some other Executor.

There's clearly a place for both the oblivious
and integrated approaches -- We make it pretty easy to
interconvert among them (e.g., in ForkJoinTask.adapt).
But as you keep adding more non-oblivious
methods in FutureTask-like classes, you end up with a
variant of ForkJoinTask that we do NOT know how to
execute as efficiently as real ForkJoinTasks, and I don't
see a path for making them so.

-Doug






From aleksey.shipilev at gmail.com  Sun Apr 22 11:18:31 2012
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Sun, 22 Apr 2012 19:18:31 +0400
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F941C09.30002@cs.oswego.edu>
References: <4F911E85.6080109@gmail.com>
	<4F92C96C.1000108@cs.oswego.edu>	<4F93059A.6050703@gmail.com>	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<CANPzfU9U12BZSz6aTDZxHXmkdN3-YsfJx58swu0ZDJr29VgW7w@mail.gmail.com>
	<4F941C09.30002@cs.oswego.edu>
Message-ID: <4F942147.8040601@gmail.com>

Hi Doug,

On 04/22/2012 06:56 PM, Doug Lea wrote:
> My main uncomfortableness with the line of attack is that it
> leads to some odd in-between points between FutureTask and
> ForkJoinTask.

Sorry, but I fail to see the connection between FutureTask/ForkJoinTask
and proposed FutureValue. In my perspective you should not be able to
submit FutureValue anywhere, this is just the efficient shortcut for
asynchronously-settable value.

If I understand your explanation right, it clearly highlights that
FutureValue functionality better not be done on top of FutureTask,
because that leads to odd consequences with executors. I'm fine with
leaving FutureTask alone: once you have Runnable/Callable you can submit
to threadpool, it's advisable to do so.

However, there are cases when I need to communicate single value between
two threads, with one thread blocked for the result. This is the case
where FutureValue comes handy. The cases like these are not as rare as
one might expect. :(

My observation is that users needing that functionality will end up either:
 a. extending FutureTask and publicizing set()
 b. using single-element BlockingQueue
 c. guard result field with the CountDownLatch
 d. (or even) wait()/notify() for result

All these above are heavier then just FutureValue on top of AQS.

Cheers,
Aleksey.

P.S. I'm not allowed to look into Guava source code, but I will bet
their SettableFuture is done directly on AQS (it's the only sane option
at hand).

From dl at cs.oswego.edu  Sun Apr 22 15:49:39 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 22 Apr 2012 15:49:39 -0400
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F942147.8040601@gmail.com>
References: <4F911E85.6080109@gmail.com>
	<4F92C96C.1000108@cs.oswego.edu>	<4F93059A.6050703@gmail.com>	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<CANPzfU9U12BZSz6aTDZxHXmkdN3-YsfJx58swu0ZDJr29VgW7w@mail.gmail.com>
	<4F941C09.30002@cs.oswego.edu> <4F942147.8040601@gmail.com>
Message-ID: <4F9460D3.2050509@cs.oswego.edu>

On 04/22/12 11:18, Aleksey Shipilev wrote:
> Sorry, but I fail to see the connection between FutureTask/ForkJoinTask
> and proposed FutureValue. In my perspective you should not be able to
> submit FutureValue anywhere, this is just the efficient shortcut for
> asynchronously-settable value.

Yes. I was commenting on adding operations like onResult, etc
that invite usages requiring them be submittable to Executors.

> However, there are cases when I need to communicate single value between
> two threads, with one thread blocked for the result. This is the case
> where FutureValue comes handy. The cases like these are not as rare as
> one might expect. :(
>

Yes, I agree that this is (only) the functionality to target.

> P.S. I'm not allowed to look into Guava source code, but I will bet
> their SettableFuture is done directly on AQS (it's the only sane option
> at hand).
>

(It is.)

-Doug

From viktor.klang at gmail.com  Sun Apr 22 17:42:39 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Sun, 22 Apr 2012 23:42:39 +0200
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F9460D3.2050509@cs.oswego.edu>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<CANPzfU9U12BZSz6aTDZxHXmkdN3-YsfJx58swu0ZDJr29VgW7w@mail.gmail.com>
	<4F941C09.30002@cs.oswego.edu> <4F942147.8040601@gmail.com>
	<4F9460D3.2050509@cs.oswego.edu>
Message-ID: <CANPzfU-NAeZBaL2jf6o3uFJEqnJ0j0Y30nFWx-ZC8DNfXFdkfg@mail.gmail.com>

On Sun, Apr 22, 2012 at 9:49 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 04/22/12 11:18, Aleksey Shipilev wrote:
>
>> Sorry, but I fail to see the connection between FutureTask/ForkJoinTask
>> and proposed FutureValue. In my perspective you should not be able to
>> submit FutureValue anywhere, this is just the efficient shortcut for
>> asynchronously-settable value.
>>
>
> Yes. I was commenting on adding operations like onResult, etc
> that invite usages requiring them be submittable to Executors.


Why would onResult/onException callbacks involve Executors?
Also, with defender methods you can simply have them throw an UOE.

Since j.u.c sort of sets the interop standard with regards to different
languages of the jvm, it would be nice to offer interop that doesn't
require sending worker threads to sleep.

Cheers,
?


>
>
>  However, there are cases when I need to communicate single value between
>> two threads, with one thread blocked for the result. This is the case
>> where FutureValue comes handy. The cases like these are not as rare as
>> one might expect. :(
>>
>>
> Yes, I agree that this is (only) the functionality to target.
>
>
>  P.S. I'm not allowed to look into Guava source code, but I will bet
>> their SettableFuture is done directly on AQS (it's the only sane option
>> at hand).
>>
>>
> (It is.)
>
> -Doug
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120422/87349fc3/attachment.html>

From nathan.reynolds at oracle.com  Mon Apr 23 12:37:32 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 23 Apr 2012 09:37:32 -0700
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
Message-ID: <4F95854C.8090903@oracle.com>

Consider throwing an exception instead of returning false.  The 
exception will force the caller to deal with the already set condition.  
Returning false is a bug waiting to happen.

Calling set() twice usually indicates a larger bug in the caller code.  
Why would the algorithm call it twice?  Is there a race between 2 
threads in the caller code?  Is one part of the caller code not aware of 
what the other part of code did?

I raise this concern because FindBugs flags issues if the caller doesn't 
deal with the result of the java.io.File and java.util.concurrent.Lock 
APIs.  For many that don't use FindBugs, they will have a lot of bugs.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>
>     Yes. SettableFuture-like class is something missing from concurrent
>     classes I'm redoing over and over again in most of the projects.
>     Implementing it directly on top of AQS might provide some benefits
>     comparing to extending from FutureTask? Oh wait, it smells like
>     another
>     API enhancement proposal? :)
>
>
> Alex,
>
> Bill Pugh once suggested a separate concurrency abstraction: an 
> externally settable FutureValue<V>, which supports the following methods:
>
>        V get() -  Waits if necessary for the value to be set, and then 
> returns the value.
>        boolean isDone() - Returns true if the value is set
>        boolean set(V v) - Sets the value if it was not already set.
>                Returns true if the value was set by this call, false if it
>                was set by another call.
>
> Having set(v) return a boolean seems like a good idea.  What do you think?
>
> To this I would also add the other Future methods such as cancel(), 
> plus setException().  In other words, I envision FutureValue as a 
> Future with two additional methods: boolean set(v) and boolean 
> setException(e).
>
> Are there any other Future enhancements that you think are sorely 
> needed in j.u.c.?
>
> --Joe
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120423/79e2cd9e/attachment.html>

From david.lloyd at redhat.com  Mon Apr 23 13:10:15 2012
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Mon, 23 Apr 2012 12:10:15 -0500
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F95854C.8090903@oracle.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com>
Message-ID: <4F958CF7.2040608@redhat.com>

I disagree.  May times using set() on an object like this is the point 
of coordination.  Would you throw an exception if putIfAbsent() failed?

On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
> Consider throwing an exception instead of returning false. The exception
> will force the caller to deal with the already set condition. Returning
> false is a bug waiting to happen.
>
> Calling set() twice usually indicates a larger bug in the caller code.
> Why would the algorithm call it twice? Is there a race between 2 threads
> in the caller code? Is one part of the caller code not aware of what the
> other part of code did?
>
> I raise this concern because FindBugs flags issues if the caller doesn't
> deal with the result of the java.io.File and java.util.concurrent.Lock
> APIs. For many that don't use FindBugs, they will have a lot of bugs.
>
> Nathan Reynolds
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>
>>     Yes. SettableFuture-like class is something missing from concurrent
>>     classes I'm redoing over and over again in most of the projects.
>>     Implementing it directly on top of AQS might provide some benefits
>>     comparing to extending from FutureTask? Oh wait, it smells like
>>     another
>>     API enhancement proposal? :)
>>
>>
>> Alex,
>>
>> Bill Pugh once suggested a separate concurrency abstraction: an
>> externally settable FutureValue<V>, which supports the following methods:
>>
>> V get() - Waits if necessary for the value to be set, and then returns
>> the value.
>> boolean isDone() - Returns true if the value is set
>> boolean set(V v) - Sets the value if it was not already set.
>> Returns true if the value was set by this call, false if it
>> was set by another call.
>>
>> Having set(v) return a boolean seems like a good idea. What do you think?
>>
>> To this I would also add the other Future methods such as cancel(),
>> plus setException(). In other words, I envision FutureValue as a
>> Future with two additional methods: boolean set(v) and boolean
>> setException(e).
>>
>> Are there any other Future enhancements that you think are sorely
>> needed in j.u.c.?
>>
>> --Joe
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-- 
- DML

From kirk at kodewerk.com  Mon Apr 23 13:31:41 2012
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Mon, 23 Apr 2012 19:31:41 +0200
Subject: [concurrency-interest] Proper workaround for
	FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F958CF7.2040608@redhat.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
Message-ID: <1165A916-D0A1-4B44-8C46-492853089FFC@kodewerk.com>

define failure for putIfAbsent???


On 2012-04-23, at 7:10 PM, David M. Lloyd wrote:

> I disagree.  May times using set() on an object like this is the point of coordination.  Would you throw an exception if putIfAbsent() failed?
> 
> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>> Consider throwing an exception instead of returning false. The exception
>> will force the caller to deal with the already set condition. Returning
>> false is a bug waiting to happen.
>> 
>> Calling set() twice usually indicates a larger bug in the caller code.
>> Why would the algorithm call it twice? Is there a race between 2 threads
>> in the caller code? Is one part of the caller code not aware of what the
>> other part of code did?
>> 
>> I raise this concern because FindBugs flags issues if the caller doesn't
>> deal with the result of the java.io.File and java.util.concurrent.Lock
>> APIs. For many that don't use FindBugs, they will have a lot of bugs.
>> 
>> Nathan Reynolds
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>> Consulting Member of Technical Staff | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>> 
>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>> 
>>>    Yes. SettableFuture-like class is something missing from concurrent
>>>    classes I'm redoing over and over again in most of the projects.
>>>    Implementing it directly on top of AQS might provide some benefits
>>>    comparing to extending from FutureTask? Oh wait, it smells like
>>>    another
>>>    API enhancement proposal? :)
>>> 
>>> 
>>> Alex,
>>> 
>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>> externally settable FutureValue<V>, which supports the following methods:
>>> 
>>> V get() - Waits if necessary for the value to be set, and then returns
>>> the value.
>>> boolean isDone() - Returns true if the value is set
>>> boolean set(V v) - Sets the value if it was not already set.
>>> Returns true if the value was set by this call, false if it
>>> was set by another call.
>>> 
>>> Having set(v) return a boolean seems like a good idea. What do you think?
>>> 
>>> To this I would also add the other Future methods such as cancel(),
>>> plus setException(). In other words, I envision FutureValue as a
>>> Future with two additional methods: boolean set(v) and boolean
>>> setException(e).
>>> 
>>> Are there any other Future enhancements that you think are sorely
>>> needed in j.u.c.?
>>> 
>>> --Joe
>>> 
>>> 
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> -- 
> - DML
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From david.lloyd at redhat.com  Mon Apr 23 13:33:46 2012
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Mon, 23 Apr 2012 12:33:46 -0500
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <1165A916-D0A1-4B44-8C46-492853089FFC@kodewerk.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<1165A916-D0A1-4B44-8C46-492853089FFC@kodewerk.com>
Message-ID: <4F95927A.4050600@redhat.com>

If you call putIfAbsent but the key is already mapped, then the put 
fails and the old value is returned instead.

On 04/23/2012 12:31 PM, Kirk Pepperdine wrote:
> define failure for putIfAbsent???
>
>
> On 2012-04-23, at 7:10 PM, David M. Lloyd wrote:
>
>> I disagree.  May times using set() on an object like this is the point of coordination.  Would you throw an exception if putIfAbsent() failed?
>>
>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>>> Consider throwing an exception instead of returning false. The exception
>>> will force the caller to deal with the already set condition. Returning
>>> false is a bug waiting to happen.
>>>
>>> Calling set() twice usually indicates a larger bug in the caller code.
>>> Why would the algorithm call it twice? Is there a race between 2 threads
>>> in the caller code? Is one part of the caller code not aware of what the
>>> other part of code did?
>>>
>>> I raise this concern because FindBugs flags issues if the caller doesn't
>>> deal with the result of the java.io.File and java.util.concurrent.Lock
>>> APIs. For many that don't use FindBugs, they will have a lot of bugs.
>>>
>>> Nathan Reynolds
>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>  |
>>> Consulting Member of Technical Staff | 602.333.9091
>>> Oracle PSR Engineering<http://psr.us.oracle.com/>  | Server Technology
>>>
>>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>>>
>>>>     Yes. SettableFuture-like class is something missing from concurrent
>>>>     classes I'm redoing over and over again in most of the projects.
>>>>     Implementing it directly on top of AQS might provide some benefits
>>>>     comparing to extending from FutureTask? Oh wait, it smells like
>>>>     another
>>>>     API enhancement proposal? :)
>>>>
>>>>
>>>> Alex,
>>>>
>>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>>> externally settable FutureValue<V>, which supports the following methods:
>>>>
>>>> V get() - Waits if necessary for the value to be set, and then returns
>>>> the value.
>>>> boolean isDone() - Returns true if the value is set
>>>> boolean set(V v) - Sets the value if it was not already set.
>>>> Returns true if the value was set by this call, false if it
>>>> was set by another call.
>>>>
>>>> Having set(v) return a boolean seems like a good idea. What do you think?
>>>>
>>>> To this I would also add the other Future methods such as cancel(),
>>>> plus setException(). In other words, I envision FutureValue as a
>>>> Future with two additional methods: boolean set(v) and boolean
>>>> setException(e).
>>>>
>>>> Are there any other Future enhancements that you think are sorely
>>>> needed in j.u.c.?
>>>>
>>>> --Joe
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> --
>> - DML
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
- DML

From joe.bowbeer at gmail.com  Mon Apr 23 13:34:23 2012
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 23 Apr 2012 10:34:23 -0700
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F958CF7.2040608@redhat.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
Message-ID: <CAHzJPErhNwbE7fLSxAtLyr=Ts3U0MDOstz3jH2UO4K38+acY+w@mail.gmail.com>

I disagree as well.  I use futures a lot (and in addition to using
FindBugs, I write my own custom FindBugs detectors:-)

For me, ignoring duplicates is better than throwing an exception.

The simplest use case is when the value is canceled by the owner and then
subsequently set by a worker.  Cancel wins.

Or when the value is farmed out to several competing strategies, and first
one to answer wins.

The boolean result of the set methods is symmetric with the boolean result
of cancel.

--Joe

On Mon, Apr 23, 2012 at 10:10 AM, David M. Lloyd wrote:

> I disagree.  May times using set() on an object like this is the point of
> coordination.  Would you throw an exception if putIfAbsent() failed?
>
>
> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>
>> Consider throwing an exception instead of returning false. The exception
>> will force the caller to deal with the already set condition. Returning
>> false is a bug waiting to happen.
>>
>> Calling set() twice usually indicates a larger bug in the caller code.
>> Why would the algorithm call it twice? Is there a race between 2 threads
>> in the caller code? Is one part of the caller code not aware of what the
>> other part of code did?
>>
>> I raise this concern because FindBugs flags issues if the caller doesn't
>> deal with the result of the java.io.File and java.util.concurrent.Lock
>> APIs. For many that don't use FindBugs, they will have a lot of bugs.
>>
>> Nathan Reynolds
>> <http://psr.us.oracle.com/**wiki/index.php/User:Nathan_**Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>>
>> |
>>
>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>
>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>>
>>>    Yes. SettableFuture-like class is something missing from concurrent
>>>    classes I'm redoing over and over again in most of the projects.
>>>    Implementing it directly on top of AQS might provide some benefits
>>>    comparing to extending from FutureTask? Oh wait, it smells like
>>>    another
>>>    API enhancement proposal? :)
>>>
>>>
>>> Alex,
>>>
>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>> externally settable FutureValue<V>, which supports the following methods:
>>>
>>> V get() - Waits if necessary for the value to be set, and then returns
>>> the value.
>>> boolean isDone() - Returns true if the value is set
>>> boolean set(V v) - Sets the value if it was not already set.
>>> Returns true if the value was set by this call, false if it
>>> was set by another call.
>>>
>>> Having set(v) return a boolean seems like a good idea. What do you think?
>>>
>>> To this I would also add the other Future methods such as cancel(),
>>> plus setException(). In other words, I envision FutureValue as a
>>> Future with two additional methods: boolean set(v) and boolean
>>> setException(e).
>>>
>>> Are there any other Future enhancements that you think are sorely
>>> needed in j.u.c.?
>>>
>>> --Joe
>>>
>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120423/0ddc3235/attachment-0001.html>

From david.lloyd at redhat.com  Mon Apr 23 13:45:08 2012
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Mon, 23 Apr 2012 12:45:08 -0500
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <CAHzJPErhNwbE7fLSxAtLyr=Ts3U0MDOstz3jH2UO4K38+acY+w@mail.gmail.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<CAHzJPErhNwbE7fLSxAtLyr=Ts3U0MDOstz3jH2UO4K38+acY+w@mail.gmail.com>
Message-ID: <4F959524.5010909@redhat.com>

To put it another way - I have extensively used Future-like objects 
which have three result methods: setResult(T result), 
setFailure(Exception cause), setCancelled(), each returning a boolean. 
The first one called returns "true", the latter ones return "false". 
This hugely simplifies asynchronous cancellation logic.  Yes there are 
non-sane invocation possibilities but the results are always 
deterministic, and it works pretty well in practice.

On 04/23/2012 12:34 PM, Joe Bowbeer wrote:
> I disagree as well.  I use futures a lot (and in addition to using
> FindBugs, I write my own custom FindBugs detectors:-)
>
> For me, ignoring duplicates is better than throwing an exception.
>
> The simplest use case is when the value is canceled by the owner and
> then subsequently set by a worker.  Cancel wins.
>
> Or when the value is farmed out to several competing strategies, and
> first one to answer wins.
>
> The boolean result of the set methods is symmetric with the boolean
> result of cancel.
>
> --Joe
>
> On Mon, Apr 23, 2012 at 10:10 AM, David M. Lloyd wrote:
>
>     I disagree.  May times using set() on an object like this is the
>     point of coordination.  Would you throw an exception if
>     putIfAbsent() failed?
>
>
>     On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>
>         Consider throwing an exception instead of returning false. The
>         exception
>         will force the caller to deal with the already set condition.
>         Returning
>         false is a bug waiting to happen.
>
>         Calling set() twice usually indicates a larger bug in the caller
>         code.
>         Why would the algorithm call it twice? Is there a race between 2
>         threads
>         in the caller code? Is one part of the caller code not aware of
>         what the
>         other part of code did?
>
>         I raise this concern because FindBugs flags issues if the caller
>         doesn't
>         deal with the result of the java.io.File and
>         java.util.concurrent.Lock
>         APIs. For many that don't use FindBugs, they will have a lot of
>         bugs.
>
>         Nathan Reynolds
>         <http://psr.us.oracle.com/__wiki/index.php/User:Nathan___Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>>
>         |
>
>         On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>
>             On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>
>                 Yes. SettableFuture-like class is something missing from
>             concurrent
>                 classes I'm redoing over and over again in most of the
>             projects.
>                 Implementing it directly on top of AQS might provide
>             some benefits
>                 comparing to extending from FutureTask? Oh wait, it
>             smells like
>                 another
>                 API enhancement proposal? :)
>
>
>             Alex,
>
>             Bill Pugh once suggested a separate concurrency abstraction: an
>             externally settable FutureValue<V>, which supports the
>             following methods:
>
>             V get() - Waits if necessary for the value to be set, and
>             then returns
>             the value.
>             boolean isDone() - Returns true if the value is set
>             boolean set(V v) - Sets the value if it was not already set.
>             Returns true if the value was set by this call, false if it
>             was set by another call.
>
>             Having set(v) return a boolean seems like a good idea. What
>             do you think?
>
>             To this I would also add the other Future methods such as
>             cancel(),
>             plus setException(). In other words, I envision FutureValue as a
>             Future with two additional methods: boolean set(v) and boolean
>             setException(e).
>
>             Are there any other Future enhancements that you think are
>             sorely
>             needed in j.u.c.?
>
>             --Joe
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-- 
- DML

From gregg at cytetech.com  Mon Apr 23 14:22:50 2012
From: gregg at cytetech.com (Gregg Wonderly)
Date: Mon, 23 Apr 2012 13:22:50 -0500
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F959524.5010909@redhat.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<CAHzJPErhNwbE7fLSxAtLyr=Ts3U0MDOstz3jH2UO4K38+acY+w@mail.gmail.com>
	<4F959524.5010909@redhat.com>
Message-ID: <4F959DFA.5020308@cytetech.com>

For me, the "putIfAbsent" name, says that you care to ignore failures.  "set" 
doesn't indicate a desire to ignore failures.  Not checking the true/false 
return will be a point of "failure".  If an exception is thrown on failure, than 
it tells the developer, quite directly, that there is an expected usage pattern.

If both patterns need to be supported, than make the API support both literally.

public boolean setIfNotSet( T val );
public void set( T val ) throws ValueAlreadySetException;

The boolean return feels more like a CAS operation.  For some people, CAS 
operations are "friendly".  For others who don't use those kinds of APIs, and 
don't understand races in their code, it can be quiet a bit painful to see that 
when you say "set" like so many other "property" like functions, it doesn't 
actually "set" the value.

Don't use "set" as the API if it will return boolean.  Pick something more 
verbose so that it is clear that the user needs to check the return value.

Gregg Wonderly

On 4/23/2012 12:45 PM, David M. Lloyd wrote:
> To put it another way - I have extensively used Future-like objects which have
> three result methods: setResult(T result), setFailure(Exception cause),
> setCancelled(), each returning a boolean. The first one called returns "true",
> the latter ones return "false". This hugely simplifies asynchronous cancellation
> logic. Yes there are non-sane invocation possibilities but the results are
> always deterministic, and it works pretty well in practice.
>
> On 04/23/2012 12:34 PM, Joe Bowbeer wrote:
>> I disagree as well. I use futures a lot (and in addition to using
>> FindBugs, I write my own custom FindBugs detectors:-)
>>
>> For me, ignoring duplicates is better than throwing an exception.
>>
>> The simplest use case is when the value is canceled by the owner and
>> then subsequently set by a worker. Cancel wins.
>>
>> Or when the value is farmed out to several competing strategies, and
>> first one to answer wins.
>>
>> The boolean result of the set methods is symmetric with the boolean
>> result of cancel.
>>
>> --Joe
>>
>> On Mon, Apr 23, 2012 at 10:10 AM, David M. Lloyd wrote:
>>
>> I disagree. May times using set() on an object like this is the
>> point of coordination. Would you throw an exception if
>> putIfAbsent() failed?
>>
>>
>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>>
>> Consider throwing an exception instead of returning false. The
>> exception
>> will force the caller to deal with the already set condition.
>> Returning
>> false is a bug waiting to happen.
>>
>> Calling set() twice usually indicates a larger bug in the caller
>> code.
>> Why would the algorithm call it twice? Is there a race between 2
>> threads
>> in the caller code? Is one part of the caller code not aware of
>> what the
>> other part of code did?
>>
>> I raise this concern because FindBugs flags issues if the caller
>> doesn't
>> deal with the result of the java.io.File and
>> java.util.concurrent.Lock
>> APIs. For many that don't use FindBugs, they will have a lot of
>> bugs.
>>
>> Nathan Reynolds
>> <http://psr.us.oracle.com/__wiki/index.php/User:Nathan___Reynolds
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>>
>> |
>>
>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>
>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>
>> Yes. SettableFuture-like class is something missing from
>> concurrent
>> classes I'm redoing over and over again in most of the
>> projects.
>> Implementing it directly on top of AQS might provide
>> some benefits
>> comparing to extending from FutureTask? Oh wait, it
>> smells like
>> another
>> API enhancement proposal? :)
>>
>>
>> Alex,
>>
>> Bill Pugh once suggested a separate concurrency abstraction: an
>> externally settable FutureValue<V>, which supports the
>> following methods:
>>
>> V get() - Waits if necessary for the value to be set, and
>> then returns
>> the value.
>> boolean isDone() - Returns true if the value is set
>> boolean set(V v) - Sets the value if it was not already set.
>> Returns true if the value was set by this call, false if it
>> was set by another call.
>>
>> Having set(v) return a boolean seems like a good idea. What
>> do you think?
>>
>> To this I would also add the other Future methods such as
>> cancel(),
>> plus setException(). In other words, I envision FutureValue as a
>> Future with two additional methods: boolean set(v) and boolean
>> setException(e).
>>
>> Are there any other Future enhancements that you think are
>> sorely
>> needed in j.u.c.?
>>
>> --Joe
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From david.lloyd at redhat.com  Mon Apr 23 14:33:34 2012
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Mon, 23 Apr 2012 13:33:34 -0500
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F959DFA.5020308@cytetech.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<CAHzJPErhNwbE7fLSxAtLyr=Ts3U0MDOstz3jH2UO4K38+acY+w@mail.gmail.com>
	<4F959524.5010909@redhat.com> <4F959DFA.5020308@cytetech.com>
Message-ID: <4F95A07E.8010207@redhat.com>

Sounds reasonable.  A "try..." prefix is also an option for this kind of 
thing.

On 04/23/2012 01:22 PM, Gregg Wonderly wrote:
> For me, the "putIfAbsent" name, says that you care to ignore failures.
> "set" doesn't indicate a desire to ignore failures. Not checking the
> true/false return will be a point of "failure". If an exception is
> thrown on failure, than it tells the developer, quite directly, that
> there is an expected usage pattern.
>
> If both patterns need to be supported, than make the API support both
> literally.
>
> public boolean setIfNotSet( T val );
> public void set( T val ) throws ValueAlreadySetException;
>
> The boolean return feels more like a CAS operation. For some people, CAS
> operations are "friendly". For others who don't use those kinds of APIs,
> and don't understand races in their code, it can be quiet a bit painful
> to see that when you say "set" like so many other "property" like
> functions, it doesn't actually "set" the value.
>
> Don't use "set" as the API if it will return boolean. Pick something
> more verbose so that it is clear that the user needs to check the return
> value.
>
> Gregg Wonderly
>
> On 4/23/2012 12:45 PM, David M. Lloyd wrote:
>> To put it another way - I have extensively used Future-like objects
>> which have
>> three result methods: setResult(T result), setFailure(Exception cause),
>> setCancelled(), each returning a boolean. The first one called returns
>> "true",
>> the latter ones return "false". This hugely simplifies asynchronous
>> cancellation
>> logic. Yes there are non-sane invocation possibilities but the results
>> are
>> always deterministic, and it works pretty well in practice.
>>
>> On 04/23/2012 12:34 PM, Joe Bowbeer wrote:
>>> I disagree as well. I use futures a lot (and in addition to using
>>> FindBugs, I write my own custom FindBugs detectors:-)
>>>
>>> For me, ignoring duplicates is better than throwing an exception.
>>>
>>> The simplest use case is when the value is canceled by the owner and
>>> then subsequently set by a worker. Cancel wins.
>>>
>>> Or when the value is farmed out to several competing strategies, and
>>> first one to answer wins.
>>>
>>> The boolean result of the set methods is symmetric with the boolean
>>> result of cancel.
>>>
>>> --Joe
>>>
>>> On Mon, Apr 23, 2012 at 10:10 AM, David M. Lloyd wrote:
>>>
>>> I disagree. May times using set() on an object like this is the
>>> point of coordination. Would you throw an exception if
>>> putIfAbsent() failed?
>>>
>>>
>>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>>>
>>> Consider throwing an exception instead of returning false. The
>>> exception
>>> will force the caller to deal with the already set condition.
>>> Returning
>>> false is a bug waiting to happen.
>>>
>>> Calling set() twice usually indicates a larger bug in the caller
>>> code.
>>> Why would the algorithm call it twice? Is there a race between 2
>>> threads
>>> in the caller code? Is one part of the caller code not aware of
>>> what the
>>> other part of code did?
>>>
>>> I raise this concern because FindBugs flags issues if the caller
>>> doesn't
>>> deal with the result of the java.io.File and
>>> java.util.concurrent.Lock
>>> APIs. For many that don't use FindBugs, they will have a lot of
>>> bugs.
>>>
>>> Nathan Reynolds
>>> <http://psr.us.oracle.com/__wiki/index.php/User:Nathan___Reynolds
>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>>
>>> |
>>>
>>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>>
>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>>
>>> Yes. SettableFuture-like class is something missing from
>>> concurrent
>>> classes I'm redoing over and over again in most of the
>>> projects.
>>> Implementing it directly on top of AQS might provide
>>> some benefits
>>> comparing to extending from FutureTask? Oh wait, it
>>> smells like
>>> another
>>> API enhancement proposal? :)
>>>
>>>
>>> Alex,
>>>
>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>> externally settable FutureValue<V>, which supports the
>>> following methods:
>>>
>>> V get() - Waits if necessary for the value to be set, and
>>> then returns
>>> the value.
>>> boolean isDone() - Returns true if the value is set
>>> boolean set(V v) - Sets the value if it was not already set.
>>> Returns true if the value was set by this call, false if it
>>> was set by another call.
>>>
>>> Having set(v) return a boolean seems like a good idea. What
>>> do you think?
>>>
>>> To this I would also add the other Future methods such as
>>> cancel(),
>>> plus setException(). In other words, I envision FutureValue as a
>>> Future with two additional methods: boolean set(v) and boolean
>>> setException(e).
>>>
>>> Are there any other Future enhancements that you think are
>>> sorely
>>> needed in j.u.c.?
>>>
>>> --Joe
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>


-- 
- DML

From r.spilker at topdesk.com  Mon Apr 23 15:17:45 2012
From: r.spilker at topdesk.com (Roel Spilker)
Date: Mon, 23 Apr 2012 21:17:45 +0200
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F959DFA.5020308@cytetech.com>
References: <4F959524.5010909@redhat.com> <4F959DFA.5020308@cytetech.com>
Message-ID: <4F95AAD9.7070105@topdesk.com>

Why not

public T setIfNotSet(T val);

And return the set value or null it it wasn't set. That would be more 
consistent with putIfAbsent.

Actually, I would have preferred if putIfAbsent would either return the 
value already in there or its value from the parameter if it wasn't so I 
would have been able to write:

return map.putIfAbsent(key, calculateValue());

instead of

T value = calculateValue();
T val = map.putIfAbsent(key, value);
return val != null ? val : value;

Roel

On 23-4-2012 20:22, Gregg Wonderly wrote:
> If both patterns need to be supported, than make the API support both literally.
>
> public boolean setIfNotSet( T val );
> public void set( T val ) throws ValueAlreadySetException;
>

From joe.bowbeer at gmail.com  Mon Apr 23 15:31:24 2012
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 23 Apr 2012 12:31:24 -0700
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F95AAD9.7070105@topdesk.com>
References: <4F959524.5010909@redhat.com> <4F959DFA.5020308@cytetech.com>
	<4F95AAD9.7070105@topdesk.com>
Message-ID: <CAHzJPEoBVVLw9PZLGCT_wMGQuE1KQwVzbKtGf2-0rfsjHYK88Q@mail.gmail.com>

The result in this case may be CancellationException, ExecutionException or
T.

I still prefer the simplicity of:

boolean set(v)
boolean setException(e)

Since the Future result never changes (unlike a Map), you can always get()
it if you want it.

--Joe

On Mon, Apr 23, 2012 at 12:17 PM, Roel Spilker wrote:

> Why not
>
> public T setIfNotSet(T val);
>
> And return the set value or null it it wasn't set. That would be more
> consistent with putIfAbsent.
>
> Actually, I would have preferred if putIfAbsent would either return the
> value already in there or its value from the parameter if it wasn't so I
> would have been able to write:
>
> return map.putIfAbsent(key, calculateValue());
>
> instead of
>
> T value = calculateValue();
> T val = map.putIfAbsent(key, value);
> return val != null ? val : value;
>
> Roel
>
>
> On 23-4-2012 20:22, Gregg Wonderly wrote:
>
>> If both patterns need to be supported, than make the API support both
>> literally.
>>
>> public boolean setIfNotSet( T val );
>> public void set( T val ) throws ValueAlreadySetException;
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120423/bdffc30e/attachment.html>

From kirk at kodewerk.com  Mon Apr 23 15:51:18 2012
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Mon, 23 Apr 2012 21:51:18 +0200
Subject: [concurrency-interest] Proper workaround for
	FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F95927A.4050600@redhat.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<1165A916-D0A1-4B44-8C46-492853089FFC@kodewerk.com>
	<4F95927A.4050600@redhat.com>
Message-ID: <772975C2-4876-47C2-AA2A-FD60ECFB3AB4@kodewerk.com>

what makes this case exceptional?

On 2012-04-23, at 7:33 PM, David M. Lloyd wrote:

> If you call putIfAbsent but the key is already mapped, then the put fails and the old value is returned instead.
> 
> On 04/23/2012 12:31 PM, Kirk Pepperdine wrote:
>> define failure for putIfAbsent???
>> 
>> 
>> On 2012-04-23, at 7:10 PM, David M. Lloyd wrote:
>> 
>>> I disagree.  May times using set() on an object like this is the point of coordination.  Would you throw an exception if putIfAbsent() failed?
>>> 
>>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>>>> Consider throwing an exception instead of returning false. The exception
>>>> will force the caller to deal with the already set condition. Returning
>>>> false is a bug waiting to happen.
>>>> 
>>>> Calling set() twice usually indicates a larger bug in the caller code.
>>>> Why would the algorithm call it twice? Is there a race between 2 threads
>>>> in the caller code? Is one part of the caller code not aware of what the
>>>> other part of code did?
>>>> 
>>>> I raise this concern because FindBugs flags issues if the caller doesn't
>>>> deal with the result of the java.io.File and java.util.concurrent.Lock
>>>> APIs. For many that don't use FindBugs, they will have a lot of bugs.
>>>> 
>>>> Nathan Reynolds
>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>  |
>>>> Consulting Member of Technical Staff | 602.333.9091
>>>> Oracle PSR Engineering<http://psr.us.oracle.com/>  | Server Technology
>>>> 
>>>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>>>> 
>>>>>    Yes. SettableFuture-like class is something missing from concurrent
>>>>>    classes I'm redoing over and over again in most of the projects.
>>>>>    Implementing it directly on top of AQS might provide some benefits
>>>>>    comparing to extending from FutureTask? Oh wait, it smells like
>>>>>    another
>>>>>    API enhancement proposal? :)
>>>>> 
>>>>> 
>>>>> Alex,
>>>>> 
>>>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>>>> externally settable FutureValue<V>, which supports the following methods:
>>>>> 
>>>>> V get() - Waits if necessary for the value to be set, and then returns
>>>>> the value.
>>>>> boolean isDone() - Returns true if the value is set
>>>>> boolean set(V v) - Sets the value if it was not already set.
>>>>> Returns true if the value was set by this call, false if it
>>>>> was set by another call.
>>>>> 
>>>>> Having set(v) return a boolean seems like a good idea. What do you think?
>>>>> 
>>>>> To this I would also add the other Future methods such as cancel(),
>>>>> plus setException(). In other words, I envision FutureValue as a
>>>>> Future with two additional methods: boolean set(v) and boolean
>>>>> setException(e).
>>>>> 
>>>>> Are there any other Future enhancements that you think are sorely
>>>>> needed in j.u.c.?
>>>>> 
>>>>> --Joe
>>>>> 
>>>>> 
>>>>> 
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> 
>>>> 
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> 
>>> 
>>> --
>>> - DML
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
> 
> 
> -- 
> - DML



From david.lloyd at redhat.com  Mon Apr 23 15:54:27 2012
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Mon, 23 Apr 2012 14:54:27 -0500
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <772975C2-4876-47C2-AA2A-FD60ECFB3AB4@kodewerk.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<1165A916-D0A1-4B44-8C46-492853089FFC@kodewerk.com>
	<4F95927A.4050600@redhat.com>
	<772975C2-4876-47C2-AA2A-FD60ECFB3AB4@kodewerk.com>
Message-ID: <4F95B373.2000706@redhat.com>

My subjective opinion.  And in that same opinion, a set() is a similar 
CAS-flavored operation.

On 04/23/2012 02:51 PM, Kirk Pepperdine wrote:
> what makes this case exceptional?
>
> On 2012-04-23, at 7:33 PM, David M. Lloyd wrote:
>
>> If you call putIfAbsent but the key is already mapped, then the put fails and the old value is returned instead.
>>
>> On 04/23/2012 12:31 PM, Kirk Pepperdine wrote:
>>> define failure for putIfAbsent???
>>>
>>>
>>> On 2012-04-23, at 7:10 PM, David M. Lloyd wrote:
>>>
>>>> I disagree.  May times using set() on an object like this is the point of coordination.  Would you throw an exception if putIfAbsent() failed?
>>>>
>>>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>>>>> Consider throwing an exception instead of returning false. The exception
>>>>> will force the caller to deal with the already set condition. Returning
>>>>> false is a bug waiting to happen.
>>>>>
>>>>> Calling set() twice usually indicates a larger bug in the caller code.
>>>>> Why would the algorithm call it twice? Is there a race between 2 threads
>>>>> in the caller code? Is one part of the caller code not aware of what the
>>>>> other part of code did?
>>>>>
>>>>> I raise this concern because FindBugs flags issues if the caller doesn't
>>>>> deal with the result of the java.io.File and java.util.concurrent.Lock
>>>>> APIs. For many that don't use FindBugs, they will have a lot of bugs.
>>>>>
>>>>> Nathan Reynolds
>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>   |
>>>>> Consulting Member of Technical Staff | 602.333.9091
>>>>> Oracle PSR Engineering<http://psr.us.oracle.com/>   | Server Technology
>>>>>
>>>>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>>>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>>>>>
>>>>>>     Yes. SettableFuture-like class is something missing from concurrent
>>>>>>     classes I'm redoing over and over again in most of the projects.
>>>>>>     Implementing it directly on top of AQS might provide some benefits
>>>>>>     comparing to extending from FutureTask? Oh wait, it smells like
>>>>>>     another
>>>>>>     API enhancement proposal? :)
>>>>>>
>>>>>>
>>>>>> Alex,
>>>>>>
>>>>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>>>>> externally settable FutureValue<V>, which supports the following methods:
>>>>>>
>>>>>> V get() - Waits if necessary for the value to be set, and then returns
>>>>>> the value.
>>>>>> boolean isDone() - Returns true if the value is set
>>>>>> boolean set(V v) - Sets the value if it was not already set.
>>>>>> Returns true if the value was set by this call, false if it
>>>>>> was set by another call.
>>>>>>
>>>>>> Having set(v) return a boolean seems like a good idea. What do you think?
>>>>>>
>>>>>> To this I would also add the other Future methods such as cancel(),
>>>>>> plus setException(). In other words, I envision FutureValue as a
>>>>>> Future with two additional methods: boolean set(v) and boolean
>>>>>> setException(e).
>>>>>>
>>>>>> Are there any other Future enhancements that you think are sorely
>>>>>> needed in j.u.c.?
>>>>>>
>>>>>> --Joe
>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>> --
>>>> - DML
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>> --
>> - DML
>


-- 
- DML

From kirk at kodewerk.com  Mon Apr 23 16:06:35 2012
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Mon, 23 Apr 2012 22:06:35 +0200
Subject: [concurrency-interest] Proper workaround for
	FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F95B373.2000706@redhat.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<1165A916-D0A1-4B44-8C46-492853089FFC@kodewerk.com>
	<4F95927A.4050600@redhat.com>
	<772975C2-4876-47C2-AA2A-FD60ECFB3AB4@kodewerk.com>
	<4F95B373.2000706@redhat.com>
Message-ID: <83F451CD-63BC-4976-9E05-F3310066CA27@kodewerk.com>

IME, forcing an exception in these cases has been a mistake. You've assumed that if I call putIfAbsent() it's an exception if the put fails. But, putIfAbsent() suggests that the not absent case is expected. It's forcing me to wrap the call with boiler pate when in fact "failure" wasn't an exceptional case in my perfectly reasonable use case.

-- Kirk
On 2012-04-23, at 9:54 PM, David M. Lloyd wrote:

> My subjective opinion.  And in that same opinion, a set() is a similar CAS-flavored operation.
> 
> On 04/23/2012 02:51 PM, Kirk Pepperdine wrote:
>> what makes this case exceptional?
>> 
>> On 2012-04-23, at 7:33 PM, David M. Lloyd wrote:
>> 
>>> If you call putIfAbsent but the key is already mapped, then the put fails and the old value is returned instead.
>>> 
>>> On 04/23/2012 12:31 PM, Kirk Pepperdine wrote:
>>>> define failure for putIfAbsent???
>>>> 
>>>> 
>>>> On 2012-04-23, at 7:10 PM, David M. Lloyd wrote:
>>>> 
>>>>> I disagree.  May times using set() on an object like this is the point of coordination.  Would you throw an exception if putIfAbsent() failed?
>>>>> 
>>>>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>>>>>> Consider throwing an exception instead of returning false. The exception
>>>>>> will force the caller to deal with the already set condition. Returning
>>>>>> false is a bug waiting to happen.
>>>>>> 
>>>>>> Calling set() twice usually indicates a larger bug in the caller code.
>>>>>> Why would the algorithm call it twice? Is there a race between 2 threads
>>>>>> in the caller code? Is one part of the caller code not aware of what the
>>>>>> other part of code did?
>>>>>> 
>>>>>> I raise this concern because FindBugs flags issues if the caller doesn't
>>>>>> deal with the result of the java.io.File and java.util.concurrent.Lock
>>>>>> APIs. For many that don't use FindBugs, they will have a lot of bugs.
>>>>>> 
>>>>>> Nathan Reynolds
>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>   |
>>>>>> Consulting Member of Technical Staff | 602.333.9091
>>>>>> Oracle PSR Engineering<http://psr.us.oracle.com/>   | Server Technology
>>>>>> 
>>>>>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>>>>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>>>>>> 
>>>>>>>    Yes. SettableFuture-like class is something missing from concurrent
>>>>>>>    classes I'm redoing over and over again in most of the projects.
>>>>>>>    Implementing it directly on top of AQS might provide some benefits
>>>>>>>    comparing to extending from FutureTask? Oh wait, it smells like
>>>>>>>    another
>>>>>>>    API enhancement proposal? :)
>>>>>>> 
>>>>>>> 
>>>>>>> Alex,
>>>>>>> 
>>>>>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>>>>>> externally settable FutureValue<V>, which supports the following methods:
>>>>>>> 
>>>>>>> V get() - Waits if necessary for the value to be set, and then returns
>>>>>>> the value.
>>>>>>> boolean isDone() - Returns true if the value is set
>>>>>>> boolean set(V v) - Sets the value if it was not already set.
>>>>>>> Returns true if the value was set by this call, false if it
>>>>>>> was set by another call.
>>>>>>> 
>>>>>>> Having set(v) return a boolean seems like a good idea. What do you think?
>>>>>>> 
>>>>>>> To this I would also add the other Future methods such as cancel(),
>>>>>>> plus setException(). In other words, I envision FutureValue as a
>>>>>>> Future with two additional methods: boolean set(v) and boolean
>>>>>>> setException(e).
>>>>>>> 
>>>>>>> Are there any other Future enhancements that you think are sorely
>>>>>>> needed in j.u.c.?
>>>>>>> 
>>>>>>> --Joe
>>>>>>> 
>>>>>>> 
>>>>>>> 
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>> 
>>>>>> 
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> 
>>>>> 
>>>>> --
>>>>> - DML
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> 
>>> 
>>> 
>>> --
>>> - DML
>> 
> 
> 
> -- 
> - DML



From ariel at weisberg.ws  Mon Apr 23 16:07:04 2012
From: ariel at weisberg.ws (Ariel Weisberg)
Date: Mon, 23 Apr 2012 16:07:04 -0400
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F95A07E.8010207@redhat.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<CAHzJPErhNwbE7fLSxAtLyr=Ts3U0MDOstz3jH2UO4K38+acY+w@mail.gmail.com>
	<4F959524.5010909@redhat.com> <4F959DFA.5020308@cytetech.com>
	<4F95A07E.8010207@redhat.com>
Message-ID: <1335211624.25400.140661066325853.14D99240@webmail.messagingengine.com>

Hi,

I like try as well. Throwing as the default behavior results in
try/catch noise and auto-generated catch clauses that people forget to
fill in.

It's helpful for people who are new to concurrency to use APIs that are
explicit about what kind of error conditions they should be looking for.
A separate method with a checked exception outranks a Javadoc note of a
return value in terms of visibility, and it is harder for a second
author
to come along and remove the check during a rewrite.

There are several collections that offer versions of methods that throw
NoSuchElementException. I don't see this is as being very different.

Ariel
On Mon, Apr 23, 2012, at 01:33 PM, David M. Lloyd wrote:
> Sounds reasonable.  A "try..." prefix is also an option for this kind
> of thing.
>
> On 04/23/2012 01:22 PM, Gregg Wonderly wrote:
> > For me, the "putIfAbsent" name, says that you care to ignore
> > failures. "set" doesn't indicate a desire to ignore failures. Not
> > checking the true/false return will be a point of "failure". If an
> > exception is thrown on failure, than it tells the developer, quite
> > directly, that there is an expected usage pattern.
> >
> > If both patterns need to be supported, than make the API support
> > both literally.
> >
> > public boolean setIfNotSet( T val ); public void set( T val ) throws
> > ValueAlreadySetException;
> >
> > The boolean return feels more like a CAS operation. For some people,
> > CAS operations are "friendly". For others who don't use those kinds
> > of APIs, and don't understand races in their code, it can be quiet a
> > bit painful to see that when you say "set" like so many other
> > "property" like functions, it doesn't actually "set" the value.
> >
> > Don't use "set" as the API if it will return boolean. Pick something
> > more verbose so that it is clear that the user needs to check the
> > return value.
> >
> > Gregg Wonderly
> >
> > On 4/23/2012 12:45 PM, David M. Lloyd wrote:
> >> To put it another way - I have extensively used Future-like objects
> >> which have three result methods: setResult(T result),
> >> setFailure(Exception cause), setCancelled(), each returning a
> >> boolean. The first one called returns "true", the latter ones
> >> return "false". This hugely simplifies asynchronous cancellation
> >> logic. Yes there are non-sane invocation possibilities but the
> >> results are always deterministic, and it works pretty well in
> >> practice.
> >>
> >> On 04/23/2012 12:34 PM, Joe Bowbeer wrote:
> >>> I disagree as well. I use futures a lot (and in addition to using
> >>> FindBugs, I write my own custom FindBugs detectors:-)
> >>>
> >>> For me, ignoring duplicates is better than throwing an exception.
> >>>
> >>> The simplest use case is when the value is canceled by the owner
> >>> and then subsequently set by a worker. Cancel wins.
> >>>
> >>> Or when the value is farmed out to several competing strategies,
> >>> and first one to answer wins.
> >>>
> >>> The boolean result of the set methods is symmetric with the
> >>> boolean result of cancel.
> >>>
> >>> --Joe
> >>>
> >>> On Mon, Apr 23, 2012 at 10:10 AM, David M. Lloyd wrote:
> >>>
> >>> I disagree. May times using set() on an object like this is the
> >>> point of coordination. Would you throw an exception if
> >>> putIfAbsent() failed?
> >>>
> >>>
> >>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
> >>>
> >>> Consider throwing an exception instead of returning false. The
> >>> exception will force the caller to deal with the already set
> >>> condition. Returning false is a bug waiting to happen.
> >>>
> >>> Calling set() twice usually indicates a larger bug in the caller
> >>> code. Why would the algorithm call it twice? Is there a race
> >>> between 2 threads in the caller code? Is one part of the caller
> >>> code not aware of what the other part of code did?
> >>>
> >>> I raise this concern because FindBugs flags issues if the caller
> >>> doesn't deal with the result of the java.io.File and
> >>> java.util.concurrent.Lock APIs. For many that don't use FindBugs,
> >>> they will have a lot of bugs.
> >>>
> >>> Nathan Reynolds
> >>> <http://psr.us.oracle.com/__wiki/index.php/User:Nathan___Reynolds
> >>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>>
> >>> |
> >>>
> >>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
> >>>
> >>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
> >>>
> >>> Yes. SettableFuture-like class is something missing from
> >>> concurrent classes I'm redoing over and over again in most of the
> >>> projects. Implementing it directly on top of AQS might provide
> >>> some benefits comparing to extending from FutureTask? Oh wait, it
> >>> smells like another API enhancement proposal? :)
> >>>
> >>>
> >>> Alex,
> >>>
> >>> Bill Pugh once suggested a separate concurrency abstraction: an
> >>> externally settable FutureValue<V>, which supports the following
> >>> methods:
> >>>
> >>> V get() - Waits if necessary for the value to be set, and then
> >>> returns the value. boolean isDone() - Returns true if the value is
> >>> set boolean set(V v) - Sets the value if it was not already set.
> >>> Returns true if the value was set by this call, false if it was
> >>> set by another call.
> >>>
> >>> Having set(v) return a boolean seems like a good idea. What do you
> >>> think?
> >>>
> >>> To this I would also add the other Future methods such as
> >>> cancel(), plus setException(). In other words, I envision
> >>> FutureValue as a Future with two additional methods: boolean
> >>> set(v) and boolean setException(e).
> >>>
> >>> Are there any other Future enhancements that you think are sorely
> >>> needed in j.u.c.?
> >>>
> >>> --Joe
> >>>
> >>>
> >>>
> >>> _______________________________________________
> >>> Concurrency-interest mailing list Concurrency-
> >>> interest at cs.oswego.edu
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >>
> >
>
>
> --
> - DML
> _______________________________________________
> Concurrency-interest mailing list Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From david.lloyd at redhat.com  Mon Apr 23 16:09:53 2012
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Mon, 23 Apr 2012 15:09:53 -0500
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <83F451CD-63BC-4976-9E05-F3310066CA27@kodewerk.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<1165A916-D0A1-4B44-8C46-492853089FFC@kodewerk.com>
	<4F95927A.4050600@redhat.com>
	<772975C2-4876-47C2-AA2A-FD60ECFB3AB4@kodewerk.com>
	<4F95B373.2000706@redhat.com>
	<83F451CD-63BC-4976-9E05-F3310066CA27@kodewerk.com>
Message-ID: <4F95B711.70905@redhat.com>

I'm not forcing you to do anything.  I'm saying that exceptions should 
*not* be used for CAS-style methods, though CAS-style methods could 
certainly be used to detect cases where an exception should be thrown 
(using the word "exceptional" to refer to this case BTW is a bit of a 
semantic land-mine).

On 04/23/2012 03:06 PM, Kirk Pepperdine wrote:
> IME, forcing an exception in these cases has been a mistake. You've assumed that if I call putIfAbsent() it's an exception if the put fails. But, putIfAbsent() suggests that the not absent case is expected. It's forcing me to wrap the call with boiler pate when in fact "failure" wasn't an exceptional case in my perfectly reasonable use case.
>
> -- Kirk
> On 2012-04-23, at 9:54 PM, David M. Lloyd wrote:
>
>> My subjective opinion.  And in that same opinion, a set() is a similar CAS-flavored operation.
>>
>> On 04/23/2012 02:51 PM, Kirk Pepperdine wrote:
>>> what makes this case exceptional?
>>>
>>> On 2012-04-23, at 7:33 PM, David M. Lloyd wrote:
>>>
>>>> If you call putIfAbsent but the key is already mapped, then the put fails and the old value is returned instead.
>>>>
>>>> On 04/23/2012 12:31 PM, Kirk Pepperdine wrote:
>>>>> define failure for putIfAbsent???
>>>>>
>>>>>
>>>>> On 2012-04-23, at 7:10 PM, David M. Lloyd wrote:
>>>>>
>>>>>> I disagree.  May times using set() on an object like this is the point of coordination.  Would you throw an exception if putIfAbsent() failed?
>>>>>>
>>>>>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>>>>>>> Consider throwing an exception instead of returning false. The exception
>>>>>>> will force the caller to deal with the already set condition. Returning
>>>>>>> false is a bug waiting to happen.
>>>>>>>
>>>>>>> Calling set() twice usually indicates a larger bug in the caller code.
>>>>>>> Why would the algorithm call it twice? Is there a race between 2 threads
>>>>>>> in the caller code? Is one part of the caller code not aware of what the
>>>>>>> other part of code did?
>>>>>>>
>>>>>>> I raise this concern because FindBugs flags issues if the caller doesn't
>>>>>>> deal with the result of the java.io.File and java.util.concurrent.Lock
>>>>>>> APIs. For many that don't use FindBugs, they will have a lot of bugs.
>>>>>>>
>>>>>>> Nathan Reynolds
>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>    |
>>>>>>> Consulting Member of Technical Staff | 602.333.9091
>>>>>>> Oracle PSR Engineering<http://psr.us.oracle.com/>    | Server Technology
>>>>>>>
>>>>>>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>>>>>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>>>>>>>
>>>>>>>>     Yes. SettableFuture-like class is something missing from concurrent
>>>>>>>>     classes I'm redoing over and over again in most of the projects.
>>>>>>>>     Implementing it directly on top of AQS might provide some benefits
>>>>>>>>     comparing to extending from FutureTask? Oh wait, it smells like
>>>>>>>>     another
>>>>>>>>     API enhancement proposal? :)
>>>>>>>>
>>>>>>>>
>>>>>>>> Alex,
>>>>>>>>
>>>>>>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>>>>>>> externally settable FutureValue<V>, which supports the following methods:
>>>>>>>>
>>>>>>>> V get() - Waits if necessary for the value to be set, and then returns
>>>>>>>> the value.
>>>>>>>> boolean isDone() - Returns true if the value is set
>>>>>>>> boolean set(V v) - Sets the value if it was not already set.
>>>>>>>> Returns true if the value was set by this call, false if it
>>>>>>>> was set by another call.
>>>>>>>>
>>>>>>>> Having set(v) return a boolean seems like a good idea. What do you think?
>>>>>>>>
>>>>>>>> To this I would also add the other Future methods such as cancel(),
>>>>>>>> plus setException(). In other words, I envision FutureValue as a
>>>>>>>> Future with two additional methods: boolean set(v) and boolean
>>>>>>>> setException(e).
>>>>>>>>
>>>>>>>> Are there any other Future enhancements that you think are sorely
>>>>>>>> needed in j.u.c.?
>>>>>>>>
>>>>>>>> --Joe
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>> --
>>>>>> - DML
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>>
>>>> --
>>>> - DML
>>>
>>
>>
>> --
>> - DML
>


-- 
- DML

From kirk at kodewerk.com  Mon Apr 23 16:30:01 2012
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Mon, 23 Apr 2012 22:30:01 +0200
Subject: [concurrency-interest] Proper workaround for
	FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F95B711.70905@redhat.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<1165A916-D0A1-4B44-8C46-492853089FFC@kodewerk.com>
	<4F95927A.4050600@redhat.com>
	<772975C2-4876-47C2-AA2A-FD60ECFB3AB4@kodewerk.com>
	<4F95B373.2000706@redhat.com>
	<83F451CD-63BC-4976-9E05-F3310066CA27@kodewerk.com>
	<4F95B711.70905@redhat.com>
Message-ID: <638DA21A-5BA7-47CA-88D2-8D88B9E53393@kodewerk.com>

ahhh, my misunderstanding and my appologies.

Using the word exceptional shouldn't be a semantic land-mine. It has a very clear definition.

exceptional
adjective
1 the drought was exceptional: unusual, uncommon, abnormal, atypical, extraordinary, out of the ordinary, rare, unprecedented, unexpected, surprising; strange, odd,freakish, anomalous, peculiar, weird; informal freaky, something else. ANTONYMS normal, usual.


That aside, using try suggests that failure is possible which means it's not exceptional.

-- Kirk 

On 2012-04-23, at 10:09 PM, David M. Lloyd wrote:

> I'm not forcing you to do anything.  I'm saying that exceptions should *not* be used for CAS-style methods, though CAS-style methods could certainly be used to detect cases where an exception should be thrown (using the word "exceptional" to refer to this case BTW is a bit of a semantic land-mine).
> 
> On 04/23/2012 03:06 PM, Kirk Pepperdine wrote:
>> IME, forcing an exception in these cases has been a mistake. You've assumed that if I call putIfAbsent() it's an exception if the put fails. But, putIfAbsent() suggests that the not absent case is expected. It's forcing me to wrap the call with boiler pate when in fact "failure" wasn't an exceptional case in my perfectly reasonable use case.
>> 
>> -- Kirk
>> On 2012-04-23, at 9:54 PM, David M. Lloyd wrote:
>> 
>>> My subjective opinion.  And in that same opinion, a set() is a similar CAS-flavored operation.
>>> 
>>> On 04/23/2012 02:51 PM, Kirk Pepperdine wrote:
>>>> what makes this case exceptional?
>>>> 
>>>> On 2012-04-23, at 7:33 PM, David M. Lloyd wrote:
>>>> 
>>>>> If you call putIfAbsent but the key is already mapped, then the put fails and the old value is returned instead.
>>>>> 
>>>>> On 04/23/2012 12:31 PM, Kirk Pepperdine wrote:
>>>>>> define failure for putIfAbsent???
>>>>>> 
>>>>>> 
>>>>>> On 2012-04-23, at 7:10 PM, David M. Lloyd wrote:
>>>>>> 
>>>>>>> I disagree.  May times using set() on an object like this is the point of coordination.  Would you throw an exception if putIfAbsent() failed?
>>>>>>> 
>>>>>>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>>>>>>>> Consider throwing an exception instead of returning false. The exception
>>>>>>>> will force the caller to deal with the already set condition. Returning
>>>>>>>> false is a bug waiting to happen.
>>>>>>>> 
>>>>>>>> Calling set() twice usually indicates a larger bug in the caller code.
>>>>>>>> Why would the algorithm call it twice? Is there a race between 2 threads
>>>>>>>> in the caller code? Is one part of the caller code not aware of what the
>>>>>>>> other part of code did?
>>>>>>>> 
>>>>>>>> I raise this concern because FindBugs flags issues if the caller doesn't
>>>>>>>> deal with the result of the java.io.File and java.util.concurrent.Lock
>>>>>>>> APIs. For many that don't use FindBugs, they will have a lot of bugs.
>>>>>>>> 
>>>>>>>> Nathan Reynolds
>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>    |
>>>>>>>> Consulting Member of Technical Staff | 602.333.9091
>>>>>>>> Oracle PSR Engineering<http://psr.us.oracle.com/>    | Server Technology
>>>>>>>> 
>>>>>>>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>>>>>>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>>>>>>>> 
>>>>>>>>>    Yes. SettableFuture-like class is something missing from concurrent
>>>>>>>>>    classes I'm redoing over and over again in most of the projects.
>>>>>>>>>    Implementing it directly on top of AQS might provide some benefits
>>>>>>>>>    comparing to extending from FutureTask? Oh wait, it smells like
>>>>>>>>>    another
>>>>>>>>>    API enhancement proposal? :)
>>>>>>>>> 
>>>>>>>>> 
>>>>>>>>> Alex,
>>>>>>>>> 
>>>>>>>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>>>>>>>> externally settable FutureValue<V>, which supports the following methods:
>>>>>>>>> 
>>>>>>>>> V get() - Waits if necessary for the value to be set, and then returns
>>>>>>>>> the value.
>>>>>>>>> boolean isDone() - Returns true if the value is set
>>>>>>>>> boolean set(V v) - Sets the value if it was not already set.
>>>>>>>>> Returns true if the value was set by this call, false if it
>>>>>>>>> was set by another call.
>>>>>>>>> 
>>>>>>>>> Having set(v) return a boolean seems like a good idea. What do you think?
>>>>>>>>> 
>>>>>>>>> To this I would also add the other Future methods such as cancel(),
>>>>>>>>> plus setException(). In other words, I envision FutureValue as a
>>>>>>>>> Future with two additional methods: boolean set(v) and boolean
>>>>>>>>> setException(e).
>>>>>>>>> 
>>>>>>>>> Are there any other Future enhancements that you think are sorely
>>>>>>>>> needed in j.u.c.?
>>>>>>>>> 
>>>>>>>>> --Joe
>>>>>>>>> 
>>>>>>>>> 
>>>>>>>>> 
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>> 
>>>>>>>> 
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>> 
>>>>>>> 
>>>>>>> --
>>>>>>> - DML
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>> 
>>>>> 
>>>>> 
>>>>> --
>>>>> - DML
>>>> 
>>> 
>>> 
>>> --
>>> - DML
>> 
> 
> 
> -- 
> - DML

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120423/fc6d1c56/attachment-0001.html>

From viktor.klang at gmail.com  Mon Apr 23 16:33:43 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Mon, 23 Apr 2012 22:33:43 +0200
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F95B711.70905@redhat.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<1165A916-D0A1-4B44-8C46-492853089FFC@kodewerk.com>
	<4F95927A.4050600@redhat.com>
	<772975C2-4876-47C2-AA2A-FD60ECFB3AB4@kodewerk.com>
	<4F95B373.2000706@redhat.com>
	<83F451CD-63BC-4976-9E05-F3310066CA27@kodewerk.com>
	<4F95B711.70905@redhat.com>
Message-ID: <CANPzfU_zgk6J1R=A=ri7=-oFi6u2a4KUykXo0dh5Rh=47Zo+vQ@mail.gmail.com>

On Mon, Apr 23, 2012 at 10:09 PM, David M. Lloyd <david.lloyd at redhat.com>wrote:

> I'm not forcing you to do anything.  I'm saying that exceptions should
> *not* be used for CAS-style methods, though CAS-style methods could
> certainly be used to detect cases where an exception should be thrown
> (using the word "exceptional" to refer to this case BTW is a bit of a
> semantic land-mine).


Absolutely, this reflects my experience and also is how SIP-14
(scala.concurrent.Future) is designed:

complete == throw if future already completed
tryComplete == return whether this call completed the future or not

Cheers,
?


>
>
> On 04/23/2012 03:06 PM, Kirk Pepperdine wrote:
>
>> IME, forcing an exception in these cases has been a mistake. You've
>> assumed that if I call putIfAbsent() it's an exception if the put fails.
>> But, putIfAbsent() suggests that the not absent case is expected. It's
>> forcing me to wrap the call with boiler pate when in fact "failure" wasn't
>> an exceptional case in my perfectly reasonable use case.
>>
>> -- Kirk
>> On 2012-04-23, at 9:54 PM, David M. Lloyd wrote:
>>
>>  My subjective opinion.  And in that same opinion, a set() is a similar
>>> CAS-flavored operation.
>>>
>>> On 04/23/2012 02:51 PM, Kirk Pepperdine wrote:
>>>
>>>> what makes this case exceptional?
>>>>
>>>> On 2012-04-23, at 7:33 PM, David M. Lloyd wrote:
>>>>
>>>>  If you call putIfAbsent but the key is already mapped, then the put
>>>>> fails and the old value is returned instead.
>>>>>
>>>>> On 04/23/2012 12:31 PM, Kirk Pepperdine wrote:
>>>>>
>>>>>> define failure for putIfAbsent???
>>>>>>
>>>>>>
>>>>>> On 2012-04-23, at 7:10 PM, David M. Lloyd wrote:
>>>>>>
>>>>>>  I disagree.  May times using set() on an object like this is the
>>>>>>> point of coordination.  Would you throw an exception if putIfAbsent()
>>>>>>> failed?
>>>>>>>
>>>>>>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>>>>>>>
>>>>>>>> Consider throwing an exception instead of returning false. The
>>>>>>>> exception
>>>>>>>> will force the caller to deal with the already set condition.
>>>>>>>> Returning
>>>>>>>> false is a bug waiting to happen.
>>>>>>>>
>>>>>>>> Calling set() twice usually indicates a larger bug in the caller
>>>>>>>> code.
>>>>>>>> Why would the algorithm call it twice? Is there a race between 2
>>>>>>>> threads
>>>>>>>> in the caller code? Is one part of the caller code not aware of
>>>>>>>> what the
>>>>>>>> other part of code did?
>>>>>>>>
>>>>>>>> I raise this concern because FindBugs flags issues if the caller
>>>>>>>> doesn't
>>>>>>>> deal with the result of the java.io.File and
>>>>>>>> java.util.concurrent.Lock
>>>>>>>> APIs. For many that don't use FindBugs, they will have a lot of
>>>>>>>> bugs.
>>>>>>>>
>>>>>>>> Nathan Reynolds
>>>>>>>> <http://psr.us.oracle.com/**wiki/index.php/User:Nathan_**Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>>
>>>>>>>>    |
>>>>>>>> Consulting Member of Technical Staff | 602.333.9091
>>>>>>>> Oracle PSR Engineering<http://psr.us.**oracle.com/<http://psr.us.oracle.com/>>
>>>>>>>>    | Server Technology
>>>>>>>>
>>>>>>>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>>>>>>>
>>>>>>>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>>>>>>>>
>>>>>>>>>    Yes. SettableFuture-like class is something missing from
>>>>>>>>> concurrent
>>>>>>>>>    classes I'm redoing over and over again in most of the projects.
>>>>>>>>>    Implementing it directly on top of AQS might provide some
>>>>>>>>> benefits
>>>>>>>>>    comparing to extending from FutureTask? Oh wait, it smells like
>>>>>>>>>    another
>>>>>>>>>    API enhancement proposal? :)
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> Alex,
>>>>>>>>>
>>>>>>>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>>>>>>>> externally settable FutureValue<V>, which supports the following
>>>>>>>>> methods:
>>>>>>>>>
>>>>>>>>> V get() - Waits if necessary for the value to be set, and then
>>>>>>>>> returns
>>>>>>>>> the value.
>>>>>>>>> boolean isDone() - Returns true if the value is set
>>>>>>>>> boolean set(V v) - Sets the value if it was not already set.
>>>>>>>>> Returns true if the value was set by this call, false if it
>>>>>>>>> was set by another call.
>>>>>>>>>
>>>>>>>>> Having set(v) return a boolean seems like a good idea. What do you
>>>>>>>>> think?
>>>>>>>>>
>>>>>>>>> To this I would also add the other Future methods such as cancel(),
>>>>>>>>> plus setException(). In other words, I envision FutureValue as a
>>>>>>>>> Future with two additional methods: boolean set(v) and boolean
>>>>>>>>> setException(e).
>>>>>>>>>
>>>>>>>>> Are there any other Future enhancements that you think are sorely
>>>>>>>>> needed in j.u.c.?
>>>>>>>>>
>>>>>>>>> --Joe
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> ______________________________**_________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>>>>>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>> ______________________________**_________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>>>>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> --
>>>>>>> - DML
>>>>>>> ______________________________**_________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>>>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>>>>
>>>>>>
>>>>>>
>>>>>
>>>>> --
>>>>> - DML
>>>>>
>>>>
>>>>
>>>
>>> --
>>> - DML
>>>
>>
>>
>
> --
> - DML
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120423/5415f0e7/attachment.html>

From aleksey.shipilev at gmail.com  Mon Apr 23 16:50:34 2012
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Tue, 24 Apr 2012 00:50:34 +0400
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <CANPzfU_zgk6J1R=A=ri7=-oFi6u2a4KUykXo0dh5Rh=47Zo+vQ@mail.gmail.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<1165A916-D0A1-4B44-8C46-492853089FFC@kodewerk.com>
	<4F95927A.4050600@redhat.com>
	<772975C2-4876-47C2-AA2A-FD60ECFB3AB4@kodewerk.com>
	<4F95B373.2000706@redhat.com>
	<83F451CD-63BC-4976-9E05-F3310066CA27@kodewerk.com>
	<4F95B711.70905@redhat.com>
	<CANPzfU_zgk6J1R=A=ri7=-oFi6u2a4KUykXo0dh5Rh=47Zo+vQ@mail.gmail.com>
Message-ID: <CA+1LWGF9CMYUnbFrHne_HV=MP1wjsxOMQvvzbgaxSDSw=M1Urg@mail.gmail.com>

I'm good with having trySet() method returning boolean, and set()
throwing the exception. One could certainly argue whether returning
false is considered exceptional, and there are cases when the opposite
is true. So, instead of imposing these artificial constraints based on
our momentary understanding of use cases, it's better to support both
and let user decide. Even though I have the premonition about adding
new checked exceptions to JDK code.

-Aleksey.

2012/4/24 ?iktor ?lang <viktor.klang at gmail.com>:
>
>
> On Mon, Apr 23, 2012 at 10:09 PM, David M. Lloyd <david.lloyd at redhat.com>
> wrote:
>>
>> I'm not forcing you to do anything. ?I'm saying that exceptions should
>> *not* be used for CAS-style methods, though CAS-style methods could
>> certainly be used to detect cases where an exception should be thrown (using
>> the word "exceptional" to refer to this case BTW is a bit of a semantic
>> land-mine).
>
>
> Absolutely, this reflects my experience and also is how SIP-14
> (scala.concurrent.Future) is designed:
>
> complete == throw if future already completed
> tryComplete == return whether this call completed the future or not

-Aleksey.


From gregg at cytetech.com  Mon Apr 23 17:33:52 2012
From: gregg at cytetech.com (Gregg Wonderly)
Date: Mon, 23 Apr 2012 16:33:52 -0500
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <1335211624.25400.140661066325853.14D99240@webmail.messagingengine.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<CAHzJPErhNwbE7fLSxAtLyr=Ts3U0MDOstz3jH2UO4K38+acY+w@mail.gmail.com>
	<4F959524.5010909@redhat.com> <4F959DFA.5020308@cytetech.com>
	<4F95A07E.8010207@redhat.com>
	<1335211624.25400.140661066325853.14D99240@webmail.messagingengine.com>
Message-ID: <4F95CAC0.5050101@cytetech.com>

One of the things that I think is important to consider for any software system, 
is that partial failure is always something to consider.  In the days of 
multi-programming, we counted partial failure as a "major failure" because 
typically a whole program/process disappeared or otherwise failed to complete. 
In this day and age, and in this forum in particular, we are using 
multi-threading as the preferred programming practice.

Partial failure is still a vital system design issue.  You need to think about 
how your system will either fail, or complete/retry something that did not 
"complete" as the system expected it to.

Throwing checked exceptions, for me, is something that one should always 
consider as a way to say, there is no choice to ignore this issue.

Boolean returns or null/non-null returns etc, are for me, less partial failure 
oriented and more logic-processing oriented.

If, in this API, setting twice, is a programmatic error, than an exception 
should be thrown.  If it is a logic flow management technique, than that's fine, 
but the API should help the developer recognize how the API works by using 
meaningful method names.

For me, set(), is not meaningful in this case.  There needs to be some "please 
attempt to set this value and tell me how that works out" method name, if the 
API design truly needs to "allow" the developer the choice of using 
failure-to-set as a logic flow mechanism.

Gregg Wonderly

On 4/23/2012 3:07 PM, Ariel Weisberg wrote:
> Hi,
>
> I like try as well. Throwing as the default behavior results in
> try/catch noise and auto-generated catch clauses that people forget to
> fill in.
>
> It's helpful for people who are new to concurrency to use APIs that are
> explicit about what kind of error conditions they should be looking for.
> A separate method with a checked exception outranks a Javadoc note of a
> return value in terms of visibility, and it is harder for a second
> author
> to come along and remove the check during a rewrite.
>
> There are several collections that offer versions of methods that throw
> NoSuchElementException. I don't see this is as being very different.
>
> Ariel
> On Mon, Apr 23, 2012, at 01:33 PM, David M. Lloyd wrote:
>> Sounds reasonable.  A "try..." prefix is also an option for this kind
>> of thing.
>>
>> On 04/23/2012 01:22 PM, Gregg Wonderly wrote:
>>> For me, the "putIfAbsent" name, says that you care to ignore
>>> failures. "set" doesn't indicate a desire to ignore failures. Not
>>> checking the true/false return will be a point of "failure". If an
>>> exception is thrown on failure, than it tells the developer, quite
>>> directly, that there is an expected usage pattern.
>>>
>>> If both patterns need to be supported, than make the API support
>>> both literally.
>>>
>>> public boolean setIfNotSet( T val ); public void set( T val ) throws
>>> ValueAlreadySetException;
>>>
>>> The boolean return feels more like a CAS operation. For some people,
>>> CAS operations are "friendly". For others who don't use those kinds
>>> of APIs, and don't understand races in their code, it can be quiet a
>>> bit painful to see that when you say "set" like so many other
>>> "property" like functions, it doesn't actually "set" the value.
>>>
>>> Don't use "set" as the API if it will return boolean. Pick something
>>> more verbose so that it is clear that the user needs to check the
>>> return value.
>>>
>>> Gregg Wonderly
>>>
>>> On 4/23/2012 12:45 PM, David M. Lloyd wrote:
>>>> To put it another way - I have extensively used Future-like objects
>>>> which have three result methods: setResult(T result),
>>>> setFailure(Exception cause), setCancelled(), each returning a
>>>> boolean. The first one called returns "true", the latter ones
>>>> return "false". This hugely simplifies asynchronous cancellation
>>>> logic. Yes there are non-sane invocation possibilities but the
>>>> results are always deterministic, and it works pretty well in
>>>> practice.
>>>>
>>>> On 04/23/2012 12:34 PM, Joe Bowbeer wrote:
>>>>> I disagree as well. I use futures a lot (and in addition to using
>>>>> FindBugs, I write my own custom FindBugs detectors:-)
>>>>>
>>>>> For me, ignoring duplicates is better than throwing an exception.
>>>>>
>>>>> The simplest use case is when the value is canceled by the owner
>>>>> and then subsequently set by a worker. Cancel wins.
>>>>>
>>>>> Or when the value is farmed out to several competing strategies,
>>>>> and first one to answer wins.
>>>>>
>>>>> The boolean result of the set methods is symmetric with the
>>>>> boolean result of cancel.
>>>>>
>>>>> --Joe
>>>>>
>>>>> On Mon, Apr 23, 2012 at 10:10 AM, David M. Lloyd wrote:
>>>>>
>>>>> I disagree. May times using set() on an object like this is the
>>>>> point of coordination. Would you throw an exception if
>>>>> putIfAbsent() failed?
>>>>>
>>>>>
>>>>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>>>>>
>>>>> Consider throwing an exception instead of returning false. The
>>>>> exception will force the caller to deal with the already set
>>>>> condition. Returning false is a bug waiting to happen.
>>>>>
>>>>> Calling set() twice usually indicates a larger bug in the caller
>>>>> code. Why would the algorithm call it twice? Is there a race
>>>>> between 2 threads in the caller code? Is one part of the caller
>>>>> code not aware of what the other part of code did?
>>>>>
>>>>> I raise this concern because FindBugs flags issues if the caller
>>>>> doesn't deal with the result of the java.io.File and
>>>>> java.util.concurrent.Lock APIs. For many that don't use FindBugs,
>>>>> they will have a lot of bugs.
>>>>>
>>>>> Nathan Reynolds
>>>>> <http://psr.us.oracle.com/__wiki/index.php/User:Nathan___Reynolds
>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>>
>>>>> |
>>>>>
>>>>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>>>>
>>>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>>>>
>>>>> Yes. SettableFuture-like class is something missing from
>>>>> concurrent classes I'm redoing over and over again in most of the
>>>>> projects. Implementing it directly on top of AQS might provide
>>>>> some benefits comparing to extending from FutureTask? Oh wait, it
>>>>> smells like another API enhancement proposal? :)
>>>>>
>>>>>
>>>>> Alex,
>>>>>
>>>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>>>> externally settable FutureValue<V>, which supports the following
>>>>> methods:
>>>>>
>>>>> V get() - Waits if necessary for the value to be set, and then
>>>>> returns the value. boolean isDone() - Returns true if the value is
>>>>> set boolean set(V v) - Sets the value if it was not already set.
>>>>> Returns true if the value was set by this call, false if it was
>>>>> set by another call.
>>>>>
>>>>> Having set(v) return a boolean seems like a good idea. What do you
>>>>> think?
>>>>>
>>>>> To this I would also add the other Future methods such as
>>>>> cancel(), plus setException(). In other words, I envision
>>>>> FutureValue as a Future with two additional methods: boolean
>>>>> set(v) and boolean setException(e).
>>>>>
>>>>> Are there any other Future enhancements that you think are sorely
>>>>> needed in j.u.c.?
>>>>>
>>>>> --Joe
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list Concurrency-
>>>>> interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
>>
>> --
>> - DML
>> _______________________________________________
>> Concurrency-interest mailing list Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From david.lloyd at redhat.com  Mon Apr 23 17:37:43 2012
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Mon, 23 Apr 2012 16:37:43 -0500
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <638DA21A-5BA7-47CA-88D2-8D88B9E53393@kodewerk.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<1165A916-D0A1-4B44-8C46-492853089FFC@kodewerk.com>
	<4F95927A.4050600@redhat.com>
	<772975C2-4876-47C2-AA2A-FD60ECFB3AB4@kodewerk.com>
	<4F95B373.2000706@redhat.com>
	<83F451CD-63BC-4976-9E05-F3310066CA27@kodewerk.com>
	<4F95B711.70905@redhat.com>
	<638DA21A-5BA7-47CA-88D2-8D88B9E53393@kodewerk.com>
Message-ID: <4F95CBA7.9070103@redhat.com>

Indeed this underlines my point that "exceptional" is not used solely to 
mean "throws an exception".  Instead it's just "uncommon".  It is pretty 
normal, in my experience, to see and write CAS-oriented code which is 
optimized for the common case.  Returning true in this case is the 
common case, and returning false is the "exceptional" or uncommon case 
(but with no Java exception objects in sight).

On 04/23/2012 03:30 PM, Kirk Pepperdine wrote:
> ahhh, my misunderstanding and my appologies.
>
> Using the word exceptional shouldn't be a semantic land-mine. It has a
> very clear definition.
>
> exceptionaladjective1 the drought was exceptional: unusual, uncommon,
> abnormal, atypical, extraordinary, out of the ordinary, rare,
> unprecedented, unexpected, surprising; strange, odd,freakish, anomalous,
> peculiar, weird; informal freaky, something else.ANTONYMS normal, usual.
>
> That aside, using try suggests that failure is possible which means it's
> not exceptional.
> -- Kirk
>
> On 2012-04-23, at 10:09 PM, David M. Lloyd wrote:
>
>> I'm not forcing you to do anything. I'm saying that exceptions should
>> *not* be used for CAS-style methods, though CAS-style methods could
>> certainly be used to detect cases where an exception should be thrown
>> (using the word "exceptional" to refer to this case BTW is a bit of a
>> semantic land-mine).
>>
>> On 04/23/2012 03:06 PM, Kirk Pepperdine wrote:
>>> IME, forcing an exception in these cases has been a mistake. You've
>>> assumed that if I call putIfAbsent() it's an exception if the put
>>> fails. But, putIfAbsent() suggests that the not absent case is
>>> expected. It's forcing me to wrap the call with boiler pate when in
>>> fact "failure" wasn't an exceptional case in my perfectly reasonable
>>> use case.
>>>
>>> -- Kirk
>>> On 2012-04-23, at 9:54 PM, David M. Lloyd wrote:
>>>
>>>> My subjective opinion. And in that same opinion, a set() is a
>>>> similar CAS-flavored operation.
>>>>
>>>> On 04/23/2012 02:51 PM, Kirk Pepperdine wrote:
>>>>> what makes this case exceptional?
>>>>>
>>>>> On 2012-04-23, at 7:33 PM, David M. Lloyd wrote:
>>>>>
>>>>>> If you call putIfAbsent but the key is already mapped, then the
>>>>>> put fails and the old value is returned instead.
>>>>>>
>>>>>> On 04/23/2012 12:31 PM, Kirk Pepperdine wrote:
>>>>>>> define failure for putIfAbsent???
>>>>>>>
>>>>>>>
>>>>>>> On 2012-04-23, at 7:10 PM, David M. Lloyd wrote:
>>>>>>>
>>>>>>>> I disagree. May times using set() on an object like this is the
>>>>>>>> point of coordination. Would you throw an exception if
>>>>>>>> putIfAbsent() failed?
>>>>>>>>
>>>>>>>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>>>>>>>>> Consider throwing an exception instead of returning false. The
>>>>>>>>> exception
>>>>>>>>> will force the caller to deal with the already set condition.
>>>>>>>>> Returning
>>>>>>>>> false is a bug waiting to happen.
>>>>>>>>>
>>>>>>>>> Calling set() twice usually indicates a larger bug in the
>>>>>>>>> caller code.
>>>>>>>>> Why would the algorithm call it twice? Is there a race between
>>>>>>>>> 2 threads
>>>>>>>>> in the caller code? Is one part of the caller code not aware of
>>>>>>>>> what the
>>>>>>>>> other part of code did?
>>>>>>>>>
>>>>>>>>> I raise this concern because FindBugs flags issues if the
>>>>>>>>> caller doesn't
>>>>>>>>> deal with the result of the java.io.File and
>>>>>>>>> java.util.concurrent.Lock
>>>>>>>>> APIs. For many that don't use FindBugs, they will have a lot of
>>>>>>>>> bugs.
>>>>>>>>>
>>>>>>>>> Nathan Reynolds
>>>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>>>>> Consulting Member of Technical Staff | 602.333.9091
>>>>>>>>> Oracle PSR Engineering<http://psr.us.oracle.com/> | Server
>>>>>>>>> Technology
>>>>>>>>>
>>>>>>>>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>>>>>>>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>>>>>>>>>
>>>>>>>>>> Yes. SettableFuture-like class is something missing from
>>>>>>>>>> concurrent
>>>>>>>>>> classes I'm redoing over and over again in most of the projects.
>>>>>>>>>> Implementing it directly on top of AQS might provide some benefits
>>>>>>>>>> comparing to extending from FutureTask? Oh wait, it smells like
>>>>>>>>>> another
>>>>>>>>>> API enhancement proposal? :)
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> Alex,
>>>>>>>>>>
>>>>>>>>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>>>>>>>>> externally settable FutureValue<V>, which supports the
>>>>>>>>>> following methods:
>>>>>>>>>>
>>>>>>>>>> V get() - Waits if necessary for the value to be set, and then
>>>>>>>>>> returns
>>>>>>>>>> the value.
>>>>>>>>>> boolean isDone() - Returns true if the value is set
>>>>>>>>>> boolean set(V v) - Sets the value if it was not already set.
>>>>>>>>>> Returns true if the value was set by this call, false if it
>>>>>>>>>> was set by another call.
>>>>>>>>>>
>>>>>>>>>> Having set(v) return a boolean seems like a good idea. What do
>>>>>>>>>> you think?
>>>>>>>>>>
>>>>>>>>>> To this I would also add the other Future methods such as
>>>>>>>>>> cancel(),
>>>>>>>>>> plus setException(). In other words, I envision FutureValue as a
>>>>>>>>>> Future with two additional methods: boolean set(v) and boolean
>>>>>>>>>> setException(e).
>>>>>>>>>>
>>>>>>>>>> Are there any other Future enhancements that you think are sorely
>>>>>>>>>> needed in j.u.c.?
>>>>>>>>>>
>>>>>>>>>> --Joe
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>> <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>> <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>> --
>>>>>>>> - DML
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>
>>>>>>
>>>>>> --
>>>>>> - DML
>>>>>
>>>>
>>>>
>>>> --
>>>> - DML
>>>
>>
>>
>> --
>> - DML
>


-- 
- DML

From joe.bowbeer at gmail.com  Mon Apr 23 18:10:38 2012
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 23 Apr 2012 15:10:38 -0700
Subject: [concurrency-interest] Proper workaround for
 FutureTask.set()/get() race (CR 7132378)
In-Reply-To: <4F95CAC0.5050101@cytetech.com>
References: <4F911E85.6080109@gmail.com> <4F92C96C.1000108@cs.oswego.edu>
	<4F93059A.6050703@gmail.com>
	<CAHzJPErGoW3tH1=xDrj7cFz0qZ7gdLdZ0O_PybmcRHNPBZxM5g@mail.gmail.com>
	<4F95854C.8090903@oracle.com> <4F958CF7.2040608@redhat.com>
	<CAHzJPErhNwbE7fLSxAtLyr=Ts3U0MDOstz3jH2UO4K38+acY+w@mail.gmail.com>
	<4F959524.5010909@redhat.com> <4F959DFA.5020308@cytetech.com>
	<4F95A07E.8010207@redhat.com>
	<1335211624.25400.140661066325853.14D99240@webmail.messagingengine.com>
	<4F95CAC0.5050101@cytetech.com>
Message-ID: <CAHzJPEoXa_vdK38kUoyrhsbUNYU=VBsOxtAkeegCtOr-LnkwfQ@mail.gmail.com>

For library maintainers, consistency with the existing API is also of
importance.  Each new method is not added in isolation.

In this case, the closest comparables (like real estate?) are:

1. Future.cancel(mayInterrupt).  Implemented by FutureValue.  This is a
best-effort method whose name is not prefixed with "try".  Returns boolean;
does not throw exception.

2. FutureTask.set(V) and FutureTask.setException(T).  These are protected
methods in FutureValue's sibling class FutureTask.  These methods have no
effect if the FutureTask has already completed.  Return nothing; do not
throw exception.

If FV's setters do not behave the same as FT's, then I see some
justification for naming them differently, even though FT's setters are
"protected" and not "public".

--Joe

On Mon, Apr 23, 2012 at 2:33 PM, Gregg Wonderly wrote:

> One of the things that I think is important to consider for any software
> system, is that partial failure is always something to consider.  In the
> days of multi-programming, we counted partial failure as a "major failure"
> because typically a whole program/process disappeared or otherwise failed
> to complete. In this day and age, and in this forum in particular, we are
> using multi-threading as the preferred programming practice.
>
> Partial failure is still a vital system design issue.  You need to think
> about how your system will either fail, or complete/retry something that
> did not "complete" as the system expected it to.
>
> Throwing checked exceptions, for me, is something that one should always
> consider as a way to say, there is no choice to ignore this issue.
>
> Boolean returns or null/non-null returns etc, are for me, less partial
> failure oriented and more logic-processing oriented.
>
> If, in this API, setting twice, is a programmatic error, than an exception
> should be thrown.  If it is a logic flow management technique, than that's
> fine, but the API should help the developer recognize how the API works by
> using meaningful method names.
>
> For me, set(), is not meaningful in this case.  There needs to be some
> "please attempt to set this value and tell me how that works out" method
> name, if the API design truly needs to "allow" the developer the choice of
> using failure-to-set as a logic flow mechanism.
>
> Gregg Wonderly
>
>
> On 4/23/2012 3:07 PM, Ariel Weisberg wrote:
>
>> Hi,
>>
>> I like try as well. Throwing as the default behavior results in
>> try/catch noise and auto-generated catch clauses that people forget to
>> fill in.
>>
>> It's helpful for people who are new to concurrency to use APIs that are
>> explicit about what kind of error conditions they should be looking for.
>> A separate method with a checked exception outranks a Javadoc note of a
>> return value in terms of visibility, and it is harder for a second
>> author
>> to come along and remove the check during a rewrite.
>>
>> There are several collections that offer versions of methods that throw
>> NoSuchElementException. I don't see this is as being very different.
>>
>> Ariel
>> On Mon, Apr 23, 2012, at 01:33 PM, David M. Lloyd wrote:
>>
>>> Sounds reasonable.  A "try..." prefix is also an option for this kind
>>> of thing.
>>>
>>> On 04/23/2012 01:22 PM, Gregg Wonderly wrote:
>>>
>>>> For me, the "putIfAbsent" name, says that you care to ignore
>>>> failures. "set" doesn't indicate a desire to ignore failures. Not
>>>> checking the true/false return will be a point of "failure". If an
>>>> exception is thrown on failure, than it tells the developer, quite
>>>> directly, that there is an expected usage pattern.
>>>>
>>>> If both patterns need to be supported, than make the API support
>>>> both literally.
>>>>
>>>> public boolean setIfNotSet( T val ); public void set( T val ) throws
>>>> ValueAlreadySetException;
>>>>
>>>> The boolean return feels more like a CAS operation. For some people,
>>>> CAS operations are "friendly". For others who don't use those kinds
>>>> of APIs, and don't understand races in their code, it can be quiet a
>>>> bit painful to see that when you say "set" like so many other
>>>> "property" like functions, it doesn't actually "set" the value.
>>>>
>>>> Don't use "set" as the API if it will return boolean. Pick something
>>>> more verbose so that it is clear that the user needs to check the
>>>> return value.
>>>>
>>>> Gregg Wonderly
>>>>
>>>> On 4/23/2012 12:45 PM, David M. Lloyd wrote:
>>>>
>>>>> To put it another way - I have extensively used Future-like objects
>>>>> which have three result methods: setResult(T result),
>>>>> setFailure(Exception cause), setCancelled(), each returning a
>>>>> boolean. The first one called returns "true", the latter ones
>>>>> return "false". This hugely simplifies asynchronous cancellation
>>>>> logic. Yes there are non-sane invocation possibilities but the
>>>>> results are always deterministic, and it works pretty well in
>>>>> practice.
>>>>>
>>>>> On 04/23/2012 12:34 PM, Joe Bowbeer wrote:
>>>>>
>>>>>> I disagree as well. I use futures a lot (and in addition to using
>>>>>> FindBugs, I write my own custom FindBugs detectors:-)
>>>>>>
>>>>>> For me, ignoring duplicates is better than throwing an exception.
>>>>>>
>>>>>> The simplest use case is when the value is canceled by the owner
>>>>>> and then subsequently set by a worker. Cancel wins.
>>>>>>
>>>>>> Or when the value is farmed out to several competing strategies,
>>>>>> and first one to answer wins.
>>>>>>
>>>>>> The boolean result of the set methods is symmetric with the
>>>>>> boolean result of cancel.
>>>>>>
>>>>>> --Joe
>>>>>>
>>>>>> On Mon, Apr 23, 2012 at 10:10 AM, David M. Lloyd wrote:
>>>>>>
>>>>>> I disagree. May times using set() on an object like this is the
>>>>>> point of coordination. Would you throw an exception if
>>>>>> putIfAbsent() failed?
>>>>>>
>>>>>>
>>>>>> On 04/23/2012 11:37 AM, Nathan Reynolds wrote:
>>>>>>
>>>>>> Consider throwing an exception instead of returning false. The
>>>>>> exception will force the caller to deal with the already set
>>>>>> condition. Returning false is a bug waiting to happen.
>>>>>>
>>>>>> Calling set() twice usually indicates a larger bug in the caller
>>>>>> code. Why would the algorithm call it twice? Is there a race
>>>>>> between 2 threads in the caller code? Is one part of the caller
>>>>>> code not aware of what the other part of code did?
>>>>>>
>>>>>> I raise this concern because FindBugs flags issues if the caller
>>>>>> doesn't deal with the result of the java.io.File and
>>>>>> java.util.concurrent.Lock APIs. For many that don't use FindBugs,
>>>>>> they will have a lot of bugs.
>>>>>>
>>>>>> Nathan Reynolds
>>>>>> <http://psr.us.oracle.com/__**wiki/index.php/User:Nathan___**Reynolds<http://psr.us.oracle.com/__wiki/index.php/User:Nathan___Reynolds>
>>>>>> <http://psr.us.oracle.com/**wiki/index.php/User:Nathan_**Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>>>>>> >>
>>>>>> |
>>>>>>
>>>>>> On 4/21/2012 1:33 PM, Joe Bowbeer wrote:
>>>>>>
>>>>>> On Sat, Apr 21, 2012 at 12:08 PM, Aleksey Shipilev wrote:
>>>>>>
>>>>>> Yes. SettableFuture-like class is something missing from
>>>>>> concurrent classes I'm redoing over and over again in most of the
>>>>>> projects. Implementing it directly on top of AQS might provide
>>>>>> some benefits comparing to extending from FutureTask? Oh wait, it
>>>>>> smells like another API enhancement proposal? :)
>>>>>>
>>>>>>
>>>>>> Alex,
>>>>>>
>>>>>> Bill Pugh once suggested a separate concurrency abstraction: an
>>>>>> externally settable FutureValue<V>, which supports the following
>>>>>> methods:
>>>>>>
>>>>>> V get() - Waits if necessary for the value to be set, and then
>>>>>> returns the value. boolean isDone() - Returns true if the value is
>>>>>> set boolean set(V v) - Sets the value if it was not already set.
>>>>>> Returns true if the value was set by this call, false if it was
>>>>>> set by another call.
>>>>>>
>>>>>> Having set(v) return a boolean seems like a good idea. What do you
>>>>>> think?
>>>>>>
>>>>>> To this I would also add the other Future methods such as
>>>>>> cancel(), plus setException(). In other words, I envision
>>>>>> FutureValue as a Future with two additional methods: boolean
>>>>>> set(v) and boolean setException(e).
>>>>>>
>>>>>> Are there any other Future enhancements that you think are sorely
>>>>>> needed in j.u.c.?
>>>>>>
>>>>>> --Joe
>>>>>>
>>>>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120423/8a497d7a/attachment.html>

From aph at redhat.com  Wed Apr 25 07:35:25 2012
From: aph at redhat.com (Andrew Haley)
Date: Wed, 25 Apr 2012 12:35:25 +0100
Subject: [concurrency-interest] Intel's HLE and Java
Message-ID: <4F97E17D.1000402@redhat.com>

I've been thinking about what to do with Intel's Hardware Lock Elision
(HLE), if anything.

Briefly, HLE allows locked regions to proceed transactionally,
so something like Hashtable's

    public synchronized V put(K key, V value) {
        ...
    }

could proceed in parallel with other cores accessing the same
Hashtable, as long as there were no conflict with the same hash slot.
If any unsafe instructions (interrupts, I/O, etc.) were executed or if
there were a conflict with another thread, the hardware would abort the
transaction (i.e. discard all pending memory updates and automagically
fall back to locking).  If there were no conflict, all threads would
proceed in parallel, and all accesses to the lock would be elided.

In theory this could be used for Java.  There is, as far as I can see,
one significant downside: if conflicts are highly probable, there will
be a performance degradation because speculation on transactions that
will abort wastes CPU cycles.

Also, I was worried that this might not actually respect the JMM
because on the x86, a StoreLoad barrier requires some sort of fence,
such as MFENCE.  However, according to the Intel documentation MFENCE
is allowed in a transaction and will not abort, so I think we're OK.

To handle the performance worry, a JIT could use some kind of cost
measure (length, number of memory accesses, etc.) to determine whether
to use HLE, on the assumption that short transactions are unlikely to
abort.  But this doesn't actually tell us what we need to know, which
is whether a conflict is likely.  Only the programmer knows that, and
even short transactions might abort if they are very frequent.

We could create a family of HLE-enabled locks and leave it all to the
programmer, but this seems like a lot of work and means that this
potentially very useful option will be wasted.  It also means a lot
of bloat in j.u.c.

Thoughts welcome...

Andrew.


Intel? Architecture Instruction Set Extensions Programming Reference
http://software.intel.com/file/41604/319433-012a.pdf

From nathan.reynolds at oracle.com  Wed Apr 25 15:27:58 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Wed, 25 Apr 2012 12:27:58 -0700
Subject: [concurrency-interest] Intel's HLE and Java
In-Reply-To: <4F97E17D.1000402@redhat.com>
References: <4F97E17D.1000402@redhat.com>
Message-ID: <4F98503E.8090504@oracle.com>

TSX seems like another type of lock to be added to the current 
bias/thin/fat synchronized design.

I guess RTM could fit somewhere between thin and fat (experience and 
performance data will tell).  If the thin lock is too contented (i.e. 
too much spinning), then the JVM will switch the lock to an RTM lock.  
If too many aborts happen per transaction, then the JVM will switch to 
fat.  Or maybe RTM locks would be tried first and then switch to thin locks.

HLE seems like it could be added to thin locks.  If the transaction 
fails, then the thread will have to execute CAS instruction to acquire 
the lock.  If the CAS fails too many times per transaction, then we know 
that HLE won't work here and the lock will be changed to a regular thin 
lock.  If threads timeout while spinning, then the lock will be 
converted to a fat lock.

It doesn't seem like we need both RTM and HLE.  It seems like one or the 
other will be better.  HLE has the advantage of providing transactions 
in all cases but at the cost of failed transactions (hence performance 
loss).  RTM is very explicit and gives power to the JVM to decide if 
transactions are working.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 4/25/2012 4:35 AM, Andrew Haley wrote:
> I've been thinking about what to do with Intel's Hardware Lock Elision
> (HLE), if anything.
>
> Briefly, HLE allows locked regions to proceed transactionally,
> so something like Hashtable's
>
>      public synchronized V put(K key, V value) {
>          ...
>      }
>
> could proceed in parallel with other cores accessing the same
> Hashtable, as long as there were no conflict with the same hash slot.
> If any unsafe instructions (interrupts, I/O, etc.) were executed or if
> there were a conflict with another thread, the hardware would abort the
> transaction (i.e. discard all pending memory updates and automagically
> fall back to locking).  If there were no conflict, all threads would
> proceed in parallel, and all accesses to the lock would be elided.
>
> In theory this could be used for Java.  There is, as far as I can see,
> one significant downside: if conflicts are highly probable, there will
> be a performance degradation because speculation on transactions that
> will abort wastes CPU cycles.
>
> Also, I was worried that this might not actually respect the JMM
> because on the x86, a StoreLoad barrier requires some sort of fence,
> such as MFENCE.  However, according to the Intel documentation MFENCE
> is allowed in a transaction and will not abort, so I think we're OK.
>
> To handle the performance worry, a JIT could use some kind of cost
> measure (length, number of memory accesses, etc.) to determine whether
> to use HLE, on the assumption that short transactions are unlikely to
> abort.  But this doesn't actually tell us what we need to know, which
> is whether a conflict is likely.  Only the programmer knows that, and
> even short transactions might abort if they are very frequent.
>
> We could create a family of HLE-enabled locks and leave it all to the
> programmer, but this seems like a lot of work and means that this
> potentially very useful option will be wasted.  It also means a lot
> of bloat in j.u.c.
>
> Thoughts welcome...
>
> Andrew.
>
>
> Intel? Architecture Instruction Set Extensions Programming Reference
> http://software.intel.com/file/41604/319433-012a.pdf
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120425/fcd61375/attachment.html>

From aph at redhat.com  Thu Apr 26 05:50:11 2012
From: aph at redhat.com (Andrew Haley)
Date: Thu, 26 Apr 2012 10:50:11 +0100
Subject: [concurrency-interest] Intel's HLE and Java
In-Reply-To: <4F98503E.8090504@oracle.com>
References: <4F97E17D.1000402@redhat.com> <4F98503E.8090504@oracle.com>
Message-ID: <4F991A53.7060306@redhat.com>

On 04/25/2012 08:27 PM, Nathan Reynolds wrote:
> TSX seems like another type of lock to be added to the current 
> bias/thin/fat synchronized design.
> 
> I guess RTM could fit somewhere between thin and fat (experience and 
> performance data will tell).  If the thin lock is too contented (i.e. 
> too much spinning), then the JVM will switch the lock to an RTM lock.  
> If too many aborts happen per transaction, then the JVM will switch to 
> fat.  Or maybe RTM locks would be tried first and then switch to thin locks.

I was thinking more of the latter; it could reduce the pinging of
cache lines between caches in a NUMA system, for example, in cases
where transactions can run in parallel.

> HLE seems like it could be added to thin locks.  If the transaction 
> fails, then the thread will have to execute CAS instruction to acquire 
> the lock.  If the CAS fails too many times per transaction, then we know 
> that HLE won't work here and the lock will be changed to a regular thin 
> lock.  If threads timeout while spinning, then the lock will be 
> converted to a fat lock.

That sounds like thee sort of thing that I was thinking of.

> It doesn't seem like we need both RTM and HLE.  It seems like one or the 
> other will be better.  HLE has the advantage of providing transactions 
> in all cases but at the cost of failed transactions (hence performance 
> loss).  RTM is very explicit and gives power to the JVM to decide if 
> transactions are working.

OK.  I'll kick this around a bit.  Do you know of any suitable
benchmark suite that I could use?

Andrew.

From dl at cs.oswego.edu  Thu Apr 26 06:59:33 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 26 Apr 2012 06:59:33 -0400
Subject: [concurrency-interest] Intel's HLE and Java
In-Reply-To: <4F97E17D.1000402@redhat.com>
References: <4F97E17D.1000402@redhat.com>
Message-ID: <4F992A95.9080303@cs.oswego.edu>

On 04/25/12 07:35, Andrew Haley wrote:
> I've been thinking about what to do with Intel's Hardware Lock Elision
> (HLE), if anything.

Some of us have been contemplating possibilities of leveraging
new hardware atomicity constructs for a while -- including,
over the years, Azul, Sun Rock, AMD's ASF proposal, and
now Intel HLE+TM support. Dave Dice's blog
(https://blogs.oracle.com/dave/) includes some posts
and pointers to some papers.

As suggested by Nathan, the most likely role for HLE
is as a platform-specific optimization for the "fast"
paths of usually-uncontended short critical sections.
I suspect that hotspot and other JVMs will find ways
to apply them for some "synchronized" block and methods.
And we'll look into adding a couple of intrinsics to
use them strictly internally inside j.u.c on platforms
supporting them.

The more interesting question is whether/how to
additionally expose the more general TM instructions,
that amount to supporting very small transactions;
i.e., those touching only, 1, 2, 3, or 4
variables/fields. One possibility that we looked into
for Rock was to expose "Weak-NCAS". For example,
a 2CAS on Objects might look something like:
   boolean cas2(Field a, Object expectedA, Object newA,
                Field b, Object expectedB, Object newB);
returning true on success, but as with weakCompareAndSet,
allowing spurious failure.

People could them build "small" transaction classes
out of these and related methods.

One argument against this is that emulating NCAS on
machines that do not support it is very expensive.
Still, it is the only option I know that maintains
some semblance of platform-neutrality.

Aside: On Rock, we found that having 2CAS was a clear win
when used to re-implement some j.u.c functionality
including a variant of ConcurrentSkipListMap,
but there are diminishing returns with 3CAS, 4CAS, etc.
More direct hardware support of multi-variable atomicity
does not automatically make it fast.

-Doug

From aph at redhat.com  Thu Apr 26 07:10:43 2012
From: aph at redhat.com (Andrew Haley)
Date: Thu, 26 Apr 2012 12:10:43 +0100
Subject: [concurrency-interest] Intel's HLE and Java
In-Reply-To: <4F992A95.9080303@cs.oswego.edu>
References: <4F97E17D.1000402@redhat.com> <4F992A95.9080303@cs.oswego.edu>
Message-ID: <4F992D33.8010407@redhat.com>

On 04/26/2012 11:59 AM, Doug Lea wrote:
> Aside: On Rock, we found that having 2CAS was a clear win
> when used to re-implement some j.u.c functionality
> including a variant of ConcurrentSkipListMap,
> but there are diminishing returns with 3CAS, 4CAS, etc.
> More direct hardware support of multi-variable atomicity
> does not automatically make it fast.

Indeed not.  One thing that I mentioned in my previous mail is that
there is a pressing need for some way of measuring all this with a
reasonably representative set of benchmarks.  Did you have any such
thing when developing j.u.c ?

Andrew.

From dl at cs.oswego.edu  Thu Apr 26 07:44:09 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 26 Apr 2012 07:44:09 -0400
Subject: [concurrency-interest] Intel's HLE and Java
In-Reply-To: <4F992D33.8010407@redhat.com>
References: <4F97E17D.1000402@redhat.com> <4F992A95.9080303@cs.oswego.edu>
	<4F992D33.8010407@redhat.com>
Message-ID: <4F993509.9070704@cs.oswego.edu>

On 04/26/12 07:10, Andrew Haley wrote:
>  One thing that I mentioned in my previous mail is that
> there is a pressing need for some way of measuring all this with a
> reasonably representative set of benchmarks.  Did you have any such
> thing when developing j.u.c ?
>

Lots of microbenchmarks (some of which are available in our
src/test/loops CVS), that try to reduce expected use cases
to simply measurable tests. Sometimes they are obvious --
For example, anything with messages/queues can be tested with
programs that omit everything going on in a program except the
producer/consumer loops. Sometimes not -- for example, there are
too many different use patterns of concurrent maps to capture
with confidence in only one or a few tests.

There's still a need for benchmarks that better capture
application-level and integration issues for parallel workloads.
The new/upcoming specJBB2012 finally (unlike its predecessors)
looks like it will be a pretty good tool for evaluating
possible library and VM improvements.

-Doug

