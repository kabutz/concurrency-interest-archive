From larryr@saturn.sdsu.edu  Mon Nov  1 00:45:28 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 1 Nov 2004 00:45:28 -0000
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
In-Reply-To: <16773.22013.780495.747757@altair.cs.oswego.edu>
Message-ID: <20041101004528.3183.qmail@home19.riedel.org>

> >   I am worried that the pool become a bottleneck
> > with synchronization.  So, is-it possible to
> > don't do any locking when using the pool?  Is the
> > wait-free ConcurrentLinkedQueue a good choice?
>
> This is the reason that performance of GC'ed
> concurrent data structures tends to be better than
> those using recycling.

What bothers me is that with the JVM I am only allowed to
resurrect an object once, so I cannot let the garbage
collector tell me when an object is not reachable so I can
put it back in the pool.   Unless this changed in JDK 1.5.


Larry


From matthias.ernst@coremedia.com  Mon Nov  1 09:11:12 2004
From: matthias.ernst@coremedia.com (Ernst, Matthias)
Date: Mon, 1 Nov 2004 10:11:12 +0100
Subject: AW: [concurrency-interest] LIFO ThreadPoolExecutor
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5F614275@MARS.coremedia.com>

Andrew,

what I previously did in this case (GUI as well) was to "externalize"
the job list and use a simple FIFO executor. I.e. I implemented a LIFO,
pushed my real job there and scheduled a generic "grab next job from the
LIFO" into the executor. That was with d.l.u.c - I know it contradicts
the fine work that went into the executor interfaces and will certainly
be less performant since it requires additional locking on the LIFO but
in this case it seems like a workable alternative. 

When I think of it you could get rid of the LIFO altogether and query
the GUI components for the currently exposed thumbnails whenever your
executor gets CPU exposure.

Matthias


From bnewport@us.ibm.com  Mon Nov  1 10:23:44 2004
From: bnewport@us.ibm.com (Billy Newport)
Date: Mon, 1 Nov 2004 04:23:44 -0600
Subject: [concurrency-interest] Billy Newport/Rochester/IBM is out of the office.
Message-ID: <OFE559356B.DB5F34C2-ON86256F3F.00391AC5-86256F3F.00391AC6@us.ibm.com>




I will be out of the office starting  10/31/2004 and will not return until
11/08/2004.



From dl@cs.oswego.edu  Mon Nov  1 13:02:39 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 1 Nov 2004 08:02:39 -0500
Subject: [concurrency-interest] LIFO ThreadPoolExecutor
In-Reply-To: <20041030022046.875.qmail@web51309.mail.yahoo.com>
References: <20041030022046.875.qmail@web51309.mail.yahoo.com>
Message-ID: <16774.13295.734665.164218@altair.cs.oswego.edu>

The jsr166x Deque interface and its implementations should be extended
to BlockingDeque to support blocking LIFO usages. In the mean time,
you might want to use the simple LinkedBlockingStack class that I had
once written as a classroom example of using ReentrantLock and
Condition.  It is not generally useful enough to be part of
java.util.concurrent, but you can get it from my miscellaneous code
page: http://gee.cs.oswego.edu/dl/code/ . You can use it in an
Executor by instantiating and sending in one of the messy
multiparameter ThreadPoolExecutor constructors.

-Doug


From hans.boehm@hp.com  Mon Nov  1 18:21:56 2004
From: hans.boehm@hp.com (Boehm, Hans)
Date: Mon, 1 Nov 2004 10:21:56 -0800
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
Message-ID: <94505C6A90226146BD46E87646B4402F4A9110@cacexc11.americas.cpqcorp.net>

I'm not sure I fully understand this discussion.  In general,
finalization (or any flavor of weak reference) tends to be
significantly more expensive for the garbage collector to
manage than just memory reclammation.  (The GC really
runs the finalize method only if an object has a nonempty one,
which is known at allocation time.) The idea of maintaining
a separate free memory pool based on the finalizer mechanism
doesn't strike me as having much of a chance of profitability,
unless the objects in the pool are extremely expensive to reconstruct.

Aside from that, I agree that not being able to reenable finalization
on an object is an odd restriction.  But I'm not sure it has much
to do with this group.

Hans

> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu
> [mailto:concurrency-interest-admin@cs.oswego.edu]On Behalf Of Larry
> Riedel
> Sent: Sunday, October 31, 2004 4:45 PM
> To: concurrency-interest@altair.cs.oswego.edu
> Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
> 
> 
> 
> > >   I am worried that the pool become a bottleneck
> > > with synchronization.  So, is-it possible to
> > > don't do any locking when using the pool?  Is the
> > > wait-free ConcurrentLinkedQueue a good choice?
> >
> > This is the reason that performance of GC'ed
> > concurrent data structures tends to be better than
> > those using recycling.
> 
> What bothers me is that with the JVM I am only allowed to
> resurrect an object once, so I cannot let the garbage
> collector tell me when an object is not reachable so I can
> put it back in the pool.   Unless this changed in JDK 1.5.
> 
> 
> Larry
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From jean.morissette666@videotron.ca  Mon Nov  1 19:32:05 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Mon, 01 Nov 2004 14:32:05 -0500
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
In-Reply-To: <94505C6A90226146BD46E87646B4402F4A9110@cacexc11.americas.cpqcorp.net>
References: <94505C6A90226146BD46E87646B4402F4A9110@cacexc11.americas.cpqcorp.net>
Message-ID: <41868F35.50106@videotron.ca>

> The idea of maintaining
> a separate free memory pool based on the finalizer mechanism
> doesn't strike me as having much of a chance of profitability,
> unless the objects in the pool are extremely expensive to reconstruct.

We don't talk to use finalyse methods or weak references.  Instead, the 
pool could be managed internaly by the object that use the pool.  By 
exemple, we could create a class PooledConcurrentLinkedList that have an 
internal pool of Node.  A node is added to the pool when the method 
'poll()' is invoked.  Inversely, a node is removed from the pool when 
the method 'offer()' is invoked.

Jean

From gregg.wonderly@pobox.com  Mon Nov  1 19:52:22 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Mon, 01 Nov 2004 13:52:22 -0600
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
In-Reply-To: <94505C6A90226146BD46E87646B4402F4A9110@cacexc11.americas.cpqcorp.net>
References: <94505C6A90226146BD46E87646B4402F4A9110@cacexc11.americas.cpqcorp.net>
Message-ID: <418693F6.5030103@cytetech.com>

Boehm, Hans wrote:
> The idea of maintaining
> a separate free memory pool based on the finalizer mechanism
> doesn't strike me as having much of a chance of profitability,
> unless the objects in the pool are extremely expensive to reconstruct.

>>What bothers me is that with the JVM I am only allowed to
>>resurrect an object once, so I cannot let the garbage
>>collector tell me when an object is not reachable so I can
>>put it back in the pool.   Unless this changed in JDK 1.5.
>>
>>
>>Larry

The issue with the GC is exactly this.  It is expensive to run a 
finalizer.  It's also expensive to assert synchronization arbitrarily.

It seems that if objects are expensive enough to create that you want to 
preserve them, then you should be using a factory creation and disposal 
mechanism that allows you to manage the lifecycle explicitly.  The close 
method on I/O objects is an example of something that's never been 
lumped into finalization.

If it's expensive to adapt existing code to do this, then you've really 
got a different issue about design and where you are at in the lifecycle 
of the architecture.  You should deprecate the constructors and provide 
the factory creation method/class.  Then, optimize for the new uses.

If it's still too expensive and too tedious, then it may be time for a 
completely different architecture.

Gregg

From larryr@saturn.sdsu.edu  Mon Nov  1 20:44:02 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 1 Nov 2004 20:44:02 -0000
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
In-Reply-To: <418693F6.5030103@cytetech.com>
Message-ID: <20041101204402.9518.qmail@home19.riedel.org>

> It seems that if objects are expensive enough to create
> that you want to preserve them, then you should be using a
> factory creation and disposal mechanism that allows you to
> manage the lifecycle explicitly.
> 
> If it's expensive to adapt existing code to do this, then
> you've really got a different issue about design and where
> you are at in the lifecycle of the architecture.

I think whether or not there is factory, and whether
or not an object pool manager depends on the garbage
collector to keep track of object reachability, are
separate things.  I would expect there to typically be
a factory for pooled objects, and I think it should be
just fine to depend on the garbage collector to let the
pool manager know when a pooled object is no longer
reachable, rather than the pool manager requiring its
users to keep track of that; indeed I do not think the
pool manager should necessarily even require its end
users to be aware that the objects are pooled at all.


Larry


From larryr@saturn.sdsu.edu  Mon Nov  1 23:08:02 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 1 Nov 2004 23:08:02 -0000
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
In-Reply-To: <4186B968.4000906@cytetech.com>
Message-ID: <20041101230802.10543.qmail@home19.riedel.org>

> > I think it should be just fine to depend on the garbage
> > collector to let the pool manager know when a pooled object is
> > no longer reachable, rather than the pool manager requiring
> > its users to keep track of that; indeed I do not think the
> > pool manager should necessarily even require its end users to
> > be aware that the objects are pooled at all.
> 
> If the GC has to tell the factory that it's done with the
> object, why would that be 'better' than for the application
> to tell the factory it is done, explicitly.  The extra code
> in the application would seem to be negligable.

As an application developer, I generally prefer to have
the garbage collector track object references, rather than
requiring the application code to do it; that is why I
want garbage collection-- to relieve the application code
of the burden of tracking object references; and there is
nothing about objects which are pooled/cached rather than
created/destroyed which fundamentally changes this for me--
leads me to think users of objects which happen to have come
from a pool should even have to know if the objects they use
are pooled/cached vs created/destroyed.


Larry


From gregg.wonderly@pobox.com  Mon Nov  1 22:32:08 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Mon, 01 Nov 2004 16:32:08 -0600
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
In-Reply-To: <20041101204402.9518.qmail@home19.riedel.org>
References: <20041101204402.9518.qmail@home19.riedel.org>
Message-ID: <4186B968.4000906@cytetech.com>

Larry Riedel wrote:
> I would expect there to typically be
> a factory for pooled objects, and I think it should be
> just fine to depend on the garbage collector to let the
> pool manager know when a pooled object is no longer
> reachable, rather than the pool manager requiring its
> users to keep track of that; indeed I do not think the
> pool manager should necessarily even require its end
> users to be aware that the objects are pooled at all.

If the GC has to tell the factory that it's done with the object, why 
would that be 'better' than for the application to tell the factory it 
is done, explicitly.  The extra code in the application would seem to be 
negligable.

Maybe you have some examples that would make it more obvious to me where 
this would be better done by a GC->Object relationship?

Gregg


From gregg.wonderly@pobox.com  Tue Nov  2 01:23:41 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Mon, 01 Nov 2004 19:23:41 -0600
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
In-Reply-To: <20041101230802.10543.qmail@home19.riedel.org>
References: <20041101230802.10543.qmail@home19.riedel.org>
Message-ID: <4186E19D.7090605@cytetech.com>

Larry Riedel wrote:
> As an application developer, I generally prefer to have
> the garbage collector track object references, rather than
> requiring the application code to do it; that is why I
> want garbage collection-- to relieve the application code
> of the burden of tracking object references;

I can see this both ways.  Often, I want to control certain things about 
the lifecycle of the objects in the system.  Typically, I know more 
about whether something is ready to be reclaimed than I want the GC to 
implicitly discover.  I want it to spend less time using the CPU to 
discover things in O(N) time that I can tell it in O(1).  Especially for 
large counts of objects.  This is why I'd really like for Sun to put a 
counting GC on the list of GC implementations.  Mark-and-Sweep is nice, 
but not great for very large, very active collections, without a whole, 
whole, whole bunch of code that can have more bugs than you can shake a 
stick at.

 > and there is
> nothing about objects which are pooled/cached rather than
> created/destroyed which fundamentally changes this for me--
> leads me to think users of objects which happen to have come
> from a pool should even have to know if the objects they use
> are pooled/cached vs created/destroyed.

I am not saying they need to know this explicitly.  I think it would be 
better to have a facade object that would manage the removeal from the 
pool in its constructor and return the object to the pool in its 
destructor.  This would let you plug in different strategies in 
different circumstances, without having to replace the Object that 
everyone is creating.

Gregg

From larryr@saturn.sdsu.edu  Tue Nov  2 02:34:56 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 2 Nov 2004 02:34:56 -0000
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
In-Reply-To: <4186E19D.7090605@cytetech.com>
Message-ID: <20041102023456.11809.qmail@home19.riedel.org>

> > As an application developer, I generally prefer to have
> > the garbage collector track object references, rather than
> > requiring the application code to do it; that is why I
> > want garbage collection-- to relieve the application code
> > of the burden of tracking object references;
> 
> I can see this both ways.  Often, I want to control certain
> things about the lifecycle of the objects in the system.
> Typically, I know more about whether something is ready to
> be reclaimed than I want the GC to implicitly discover. [...]
> I'd really like for Sun to put a counting GC on the list
> of GC implementations.

I think it would be great if developers could explicitly manage
object lifecycles and memory allocation, tell the garbage
collector to find all unreachable objects, to run finalizers,
and be able to resurrect the unreachable objects; and to be able
to create objects with associated garbage collection policies,
and to have pluggable garbage collectors which use a standard
garbage collection API/SPI (and corresponding object metadata).


> > there is nothing about objects which are pooled/cached
> > rather than created/destroyed [leads] me to think users of
> > objects which happen to have come from a pool should even
> > have to know if the objects they use are pooled/cached vs
> > created/destroyed.
> 
> I am not saying they need to know this explicitly.  I think
> it would be better to have a facade object that would manage
> the removeal from the pool in its constructor and return the
> object to the pool in its destructor.

I think it is particularly lame to have to create/destroy an
object for every time the pooled object is put/taken, when a
mechanism for avoiding that (WeakReference/ReferenceQueue) is
already in the JVM and just lacks a ReRegisterForFinalize()
(CLR) style method.  But I would not object to the idea of
having a pool specific object for each pooled object, one which
has the same lifetime as the pooled object, but has (for
example) a finalizer so the pooled object does not have to.


Larry


From Hans.Boehm@hp.com  Tue Nov  2 06:26:26 2004
From: Hans.Boehm@hp.com (Hans Boehm)
Date: Mon, 1 Nov 2004 22:26:26 -0800 (PST)
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
In-Reply-To: <20041102023456.11809.qmail@home19.riedel.org>
References: <20041102023456.11809.qmail@home19.riedel.org>
Message-ID: <Pine.GHP.4.58.0411012221420.3173@tomil.hpl.hp.com>

On Mon, 2 Nov 2004, Larry Riedel wrote:

> I think it is particularly lame to have to create/destroy an
> object for every time the pooled object is put/taken, when a
> mechanism for avoiding that (WeakReference/ReferenceQueue) is
> already in the JVM and just lacks a ReRegisterForFinalize()
> (CLR) style method.  But I would not object to the idea of
> having a pool specific object for each pooled object, one which
> has the same lifetime as the pooled object, but has (for
> example) a finalizer so the pooled object does not have to.
>
I doubt that weak references perform much better than finalizers.
They tend to use roughly the same implementation mechanism.  (I haven't
looked at Sun's specifically.)  You'd still need awfully expensive
object constructors for this sort of strategy to pay off.

Hans

From gregg.wonderly@pobox.com  Tue Nov  2 14:52:26 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Tue, 02 Nov 2004 08:52:26 -0600
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
In-Reply-To: <20041102023456.11809.qmail@home19.riedel.org>
References: <20041102023456.11809.qmail@home19.riedel.org>
Message-ID: <41879F2A.2090903@cytetech.com>

Larry Riedel wrote:
> I think it is particularly lame to have to create/destroy an
> object for every time the pooled object is put/taken, when a
> mechanism for avoiding that (WeakReference/ReferenceQueue) is
> already in the JVM and just lacks a ReRegisterForFinalize()
> (CLR) style method.  But I would not object to the idea of
> having a pool specific object for each pooled object, one which
> has the same lifetime as the pooled object, but has (for
> example) a finalizer so the pooled object does not have to.

I guess I am not sure what you are saying here.  I am thinking that
I would create something like:

public class PublicInterfaceObject {
	PooledObjectPool pool = ...;
	public static PooledObject getInstance(...) {
		PooledObject obj = pool.getInstance(...);
		return new PublicPooledObject(pool, obj);
	}
}

public class PublicPooledObject {
	PooledObject delegate;
	PublicPooledObject( PooledObjectPool pool, PooledObject del ) {
		delegate = del;
	}

	private final void finalize() {
		pool.add(delegate);
	}

	... delegated methods if Proxy not used ...
}

It might be possible to incorporate a Proxy here, instead of a concrete 
class that delegates all methods...

Gregg

From larryr@saturn.sdsu.edu  Tue Nov  2 16:50:51 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 2 Nov 2004 16:50:51 -0000
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
In-Reply-To: <41879F2A.2090903@cytetech.com>
Message-ID: <20041102165051.15310.qmail@home19.riedel.org>

> > I think it is particularly lame to have to create/destroy
> > an object for every time the pooled object is put/taken,
> > [...] I would not object to the idea of having a pool
> > specific object for each pooled object, one which has the
> > same lifetime as the pooled object, but has (for example)
> > a finalizer so the pooled object does not have to.
> 
> I guess I am not sure what you are saying here.  I am thinking
> that I would create something like:
> 
> public class PublicInterfaceObject {
> 	PooledObjectPool pool = ...;
> 	public static PooledObject getInstance(...) {
> 		PooledObject obj = pool.getInstance(...);
> 		return new PublicPooledObject(pool, obj);
> [...]
> public class PublicPooledObject {
> 	PooledObject delegate;
> 	PublicPooledObject( PooledObjectPool pool, PooledObject del ) {
> 		delegate = del;
> 	}
> 	private final void finalize() {
> 		pool.add(delegate);

That looks right as far as what I prefer not to do-- have to
create/destroy an object for each call to getInstance().  I
want to have a WeakReference to a pooled object, which gets
put in a ReferenceQueue for the pool manager after it is no
longer strongly reachable; when the pooled object shows up
in the ReferenceQueue, it gets reset and put back in the
pool; in the dotNET CLR I can call the ReRegisterForFinalize
to complete the resurrection; in Java/JVM, an object can
only become eligible for finalization once, so a particular
object instance will only get put into a ReferenceQueue once
during its lifetime.  By the way, I am not saying I think
this is a /clean/ way to achieve the end result of utilizing
the services of the garbage collector for tracking object
reachability without having it also control the lifecycle...
it is just /a/ way.


Larry


From jean.morissette666@videotron.ca  Tue Nov  2 17:30:53 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Tue, 02 Nov 2004 12:30:53 -0500
Subject: [concurrency-interest] Strange behavior with LinkedBlockingQueue
In-Reply-To: <16773.285.693912.931132@altair.cs.oswego.edu>
References: <417ED64D.20302@videotron.ca>
 <16773.285.693912.931132@altair.cs.oswego.edu>
Message-ID: <4187C44D.60504@videotron.ca>

Doug Lea wrote:
> As now described on concurrency-interest site,
>   http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> You can obtain an updated jsr166.jar with the LinkedBlockingQueue.drainTo
> bug fix, and use it now via -Xbootclasspath option until it appears
> in a J2SE update.
> 
> Thanks again for reporting this!
> 
> -Doug

This bug can produce also a NullPointerException.

java.lang.NullPointerException
	at 
java.util.concurrent.LinkedBlockingQueue.extract(LinkedBlockingQueue.java:137)
	at 
java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:387)


Thanks for the update!
Jean
	

From gregg.wonderly@pobox.com  Tue Nov  2 22:51:04 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Tue, 02 Nov 2004 16:51:04 -0600
Subject: [concurrency-interest] Re: PooledLinkedBlockingQueue
In-Reply-To: <20041102165051.15310.qmail@home19.riedel.org>
References: <20041102165051.15310.qmail@home19.riedel.org>
Message-ID: <41880F58.5080605@cytetech.com>

Larry Riedel wrote:
> That looks right as far as what I prefer not to do-- have to
> create/destroy an object for each call to getInstance().  I
> want to have a WeakReference to a pooled object, which gets
> put in a ReferenceQueue for the pool manager after it is no
> longer strongly reachable; when the pooled object shows up
> in the ReferenceQueue, it gets reset and put back in the
> pool; in the dotNET CLR I can call the ReRegisterForFinalize
> to complete the resurrection; in Java/JVM, an object can
> only become eligible for finalization once, so a particular
> object instance will only get put into a ReferenceQueue once
> during its lifetime.  By the way, I am not saying I think
> this is a /clean/ way to achieve the end result of utilizing
> the services of the garbage collector for tracking object
> reachability without having it also control the lifecycle...
> it is just /a/ way.

I understand the issue of the CLR having and JVM not having.  CLR 
doesn't have a built in security model for downloaded code.  So I guess 
I shouldn't use the CLR?  There are great ways to do certain things and 
ways less great.  The JCP lets YOU make an issue become less of an 
issue.  With the CLR, you get to wait until MS decides to do it.  I 
don't want to start an us and them war, but I think that anyone 
interested in having the JVM do something different than it does now, 
should make an effort to make that happen.  Doug Lea and company stepped 
up to the plate to make this lists project a reality.

If you really think this would be a good thing to have, then maybe there 
is someone (including yourself) who could make it happen so that 
everyone using Java would be able to utilize such facilities.  Proposing 
a project for the JCP, and then collecting your expert team might be all 
you need to do.  The team might do the rest for you.

Gregg

From jean.morissette666@videotron.ca  Wed Nov  3 04:07:18 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Tue, 02 Nov 2004 23:07:18 -0500
Subject: [concurrency-interest] PooledLinkedBlockingQueue
In-Reply-To: <16773.22013.780495.747757@altair.cs.oswego.edu>
References: <NFBBKALFDCPFIDBNKAPCOEFCEOAA.dholmes@dltech.com.au>
 <416DD060.20808@videotron.ca> <16750.26136.84328.635097@altair.cs.oswego.edu>
 <416E9EF5.5020209@videotron.ca>
 <16751.2431.310117.617402@altair.cs.oswego.edu>
 <41851328.1050208@videotron.ca>
 <16773.22013.780495.747757@altair.cs.oswego.edu>
Message-ID: <41885976.102@videotron.ca>

Doug Lea wrote:
> While there
> are lock-free solutions to the node-recycling problem, they are very
> complicated and tend to add more overhead than does GC. For some
> recent research papers on the subject see work by Maged Michael
> (http://www.research.ibm.com/people/m/michael/pubs.htm) and by Mark
> Moir and colleagues (http://research.sun.com/scalable/moir.html).

I have read "Hazard Pointers: Safe Memory Reclamation for Lock-Free 
Objects".  If I understand well, each thread have a pool of nodes. 
Is-it exact?

With this in mind, I have implemented a simple version of 
LinkedBlockingQueue that use a method named 'alloc' to create/reuse a 
node and a method 'free' to return a node to the pool.  The pool is 
based on ThreadLocal.  See below.

Until now, the performance of this implementation don't seem to 
outperform conventionnal node allocation/deallocation.  Even, the 
performance is worse.  A lot of time is taken by the method 
'ThreadLocal.get()'.  Do you have some suggestions to improve this 
implementation?

Maybe that it could be more efficient to use a shared lock-based pool 
node in the LinkedBlockingQueue class because this class already block, 
so no overhead would be introduced?  Maybe, we could use the locks 
already defined in this class (takeLock and putLock) to synchronize our 
pool?  Any advice?

Thanks
Jean


  static class ThreadSafePool {
     private static ThreadLocal pool = new ThreadLocal() {
       protected Object initialValue() {
         return new Pool();
       }
     };

     public static Pool get() {
       return (Pool) pool.get();
     }
   }

   static class Pool {
     Node head;
     Node tail;
     int count;
   }

   private Node<E> alloc(E x) {
     Node<E> node;
     Pool pool = ThreadSafePool.get();
     if (pool.head != null) {
       node = pool.head;
       pool.head = pool.head.next;
       node.next = null;
       pool.count--;
       if (node == pool.tail)
         pool.tail = null;
     }
     else {
       node = new Node<E>(null);
     }
     node.item = x;
     return node;
   }

   private void free(Node<E> node) {
     node.next = null;
     node.item = null;
     Pool pool = ThreadSafePool.get();
     if (pool.count >= 1000) return;
     if (pool.tail == null) { // isEmpty
       pool.tail = node;
       pool.head = node;
     }
     else {
       pool.tail.next = node;
       pool.tail = node;
     }
     pool.count++;
   }

From dl@cs.oswego.edu  Wed Nov  3 14:54:13 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 3 Nov 2004 09:54:13 -0500
Subject: [concurrency-interest] PooledLinkedBlockingQueue
In-Reply-To: <41885976.102@videotron.ca>
References: <NFBBKALFDCPFIDBNKAPCOEFCEOAA.dholmes@dltech.com.au>
 <416DD060.20808@videotron.ca>
 <16750.26136.84328.635097@altair.cs.oswego.edu>
 <416E9EF5.5020209@videotron.ca>
 <16751.2431.310117.617402@altair.cs.oswego.edu>
 <41851328.1050208@videotron.ca>
 <16773.22013.780495.747757@altair.cs.oswego.edu>
 <41885976.102@videotron.ca>
Message-ID: <16776.61717.457186.581185@altair.cs.oswego.edu>

> the performance of this implementation don't seem to 
> outperform conventionnal node allocation/deallocation. 

Right. I continue to doubt that you can outperform the current
GC-based approach using ThreadLocals in most applications. Here are
some rough calculations explaining why:

Allocation and field-initialization of a small object such as a list
node in hotspot (and most JVMs) is typically pretty fast, on the order
of 10 machine instructions. Normally, a node is allocated from a TLAB
(thread-local allocation buffer), which is just a few instructions
(none of them atomic), plus field initialization for nonnull
fields. Occasionally the TLAB runs out of space and needs to be
replenished, but this usually doesn't add much to the average.

Accessing a ThreadLocal is also reasonably fast, but typically
slightly slower than an allocation. I'd guess somewhere around 20
instructions. (This varies across machines - x86 might be relatively a
bit slower than others like sparc because thread-local base pointer
isn't kept in a register because there aren't many registers.) There
are ways to speed up access of different forms of thread-locals, but
not by much. For example, you can create a Thread subclass, MyThread,
that has a listPool field. If all your Threads are of this subclass,
you can access the pool via
((MyThread)Thread.currentThread()).listPool).  This avoids a few
instructions of ThreadLocal lookup, but forces you to use MyThread
objects vs plain Threads everywhere and entails a checked cast, so
usually isn't worth it.

Comparing these, for the GC-based version, the total cost is
  Allocate/initialize + some portion of GC costs
And for recycling, it is
  2 ThreadLocal accesses + reinitialization + pool bookkeeping costs

In most producer-consumer applications, you'd expect GC to win here.
Usually, the items being queued by producers are themselves being
allocated, so there is both an item and a list node allocated per
producer operation, so the allocation of list nodes only increases the
frequency of GC by some (usually small) constant factor. If both sides
of the producer-consumer pair are relatively fast and don't retain
these items, then most of the gorbage is collected in young generation
scans, in which GC time is roughly proportional to the amount of
retained (live) objects, not the amount of garbage. In these kinds of
scenarios, the number of instructions ascribable to GC of a given list
node is likely to be less than the cost of a ThreadLocal access plus
pool bookkeeping.  There are other scenarios where it could go the
other way, but I think this one is the most typical.

-Doug

From adam@bea.com  Wed Nov  3 19:00:30 2004
From: adam@bea.com (Adam Messinger)
Date: Wed, 3 Nov 2004 11:00:30 -0800
Subject: [concurrency-interest] PooledLinkedBlockingQueue
In-Reply-To: <16776.61717.457186.581185@altair.cs.oswego.edu>
References: <NFBBKALFDCPFIDBNKAPCOEFCEOAA.dholmes@dltech.com.au> <416DD060.20808@videotron.ca> <16750.26136.84328.635097@altair.cs.oswego.edu> <416E9EF5.5020209@videotron.ca> <16751.2431.310117.617402@altair.cs.oswego.edu> <41851328.1050208@videotron.ca> <16773.22013.780495.747757@altair.cs.oswego.edu> <41885976.102@videotron.ca> <16776.61717.457186.581185@altair.cs.oswego.edu>
Message-ID: <A1B3A8CA-2DCA-11D9-8CFC-000A9575C37C@bea.com>

On Nov 3, 2004, at 6:54 AM, Doug Lea wrote:

> Right. I continue to doubt that you can outperform the current
> GC-based approach using ThreadLocals in most applications.

We've looked at this issue extensively when doing performance work on 
the WebLogic Server.  We've measured pooling in a variety of use cases, 
with a variety of pooling implementations, and on a variety of hardware 
and VMs.  What we've found empirically is that Doug is exactly right.

In addition to the costs Doug mentions in his email you must also 
consider that each pool causes additional drag on GC by occupying 
memory and thus causing GC to happen more frequently.  By dedicating 
pools of memory to specific uses some object types are essentially 
receiving a higher priority for memory use, in general I think that 
this will lead to a less globally optimal use of memory.  In addition, 
most modern VMs use a GC algorithm which has cost roughly proportional 
to the number of live objects.  Therefore keeping unused objects around 
in pools causes the GC to do more work.

> There are other scenarios where it could go the other way, but I think 
> this one is the most typical.

As Doug states there are some scenarios where pooling does help and in 
those cases we do use it inside the WebLogic Server, despite its higher 
cost of maintenance.  The two general categories where we've found 
pooling to be useful are objects which are too big to be allocated from 
the thread local area and objects which have very expensive 
constructors.  Therefore I don't think that small bucket objects of the 
type being described here, which are quite small and have very cheap 
constructors, are a good candidates for pooling.

Cheers!

Adam


From ccox@tripos.com  Wed Nov  3 21:01:59 2004
From: ccox@tripos.com (Curt Cox)
Date: Wed, 3 Nov 2004 15:01:59 -0600
Subject: [concurrency-interest] PooledLinkedBlockingQueue
In-Reply-To: <A1B3A8CA-2DCA-11D9-8CFC-000A9575C37C@bea.com>
Message-ID: <E1CPSGV-0005O8-00@mailhost.tripos.com>

To pool or not to pool.

Can anybody suggest tools or techniques for identifying
code that made the wrong pooling choice?

- Curt



From jean.morissette666@videotron.ca  Wed Nov  3 23:31:58 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Wed, 03 Nov 2004 18:31:58 -0500
Subject: [concurrency-interest] PooledLinkedBlockingQueue
In-Reply-To: <A1B3A8CA-2DCA-11D9-8CFC-000A9575C37C@bea.com>
References: <NFBBKALFDCPFIDBNKAPCOEFCEOAA.dholmes@dltech.com.au>
 <416DD060.20808@videotron.ca> <16750.26136.84328.635097@altair.cs.oswego.edu>
 <416E9EF5.5020209@videotron.ca>
 <16751.2431.310117.617402@altair.cs.oswego.edu>
 <41851328.1050208@videotron.ca>
 <16773.22013.780495.747757@altair.cs.oswego.edu> <41885976.102@videotron.ca>
 <16776.61717.457186.581185@altair.cs.oswego.edu>
 <A1B3A8CA-2DCA-11D9-8CFC-000A9575C37C@bea.com>
Message-ID: <41896A6E.1020609@videotron.ca>

Adam Messinger wrote:
> Therefore I don't think that small bucket objects of the 
> type being described here, which are quite small and have very cheap 
> constructors, are a good candidates for pooling.

Thanks for your comments, it's appreciated.  I just want to believe you, 
but how do you explain the test below.  I have modified Sun LinkedList 
into MyPooledLinkedList.  This class is exacly like LinkedList, so its 
not thread-safe.  The test show a huge performance difference between 
the two lists: MyPooledLinkedList is a  an order of magnitude more fast! 
  On my computer, LinkedList take 127400 ms and MyPooledLinkedList take 
16500 ms.  Could you explain this difference please?  Am-I missing 
something?

Thanks
Jean

import java.util.LinkedList;

public class Test {

   private static final int NUM_IT = 100000000;
   private static final int WARM_UP_IT = NUM_IT / 100;
   static Object NULL_OBJECT = new Object() {};

   /*
   LinkedList:            time  = 127458  124624
   MyPooledLinkedList     time  =  16555   16277
   */
   public static void main(String args[]) throws Exception {
     main1(); // pooled list item objects, very fast
//    main2();   // sun's linked list: very long
   }

   public static void main1() {
     MyPooledLinkedList ll = new MyPooledLinkedList();
     long before, after;

     for (int i = 0; i < WARM_UP_IT; i++) {
       ll.addFirst(NULL_OBJECT);
//      ll.removeLast();
     }

     before = System.currentTimeMillis();
     for (int i = 0; i < NUM_IT; i++) {
       ll.addFirst(NULL_OBJECT);
       ll.removeLast();
     }
     after = System.currentTimeMillis();
     System.out.print("MyPooledLinkedList: ");
     printTime(before, after, NUM_IT);
   }

   public static void main2() {
     LinkedList ll = new LinkedList();
     long before, after;

     for (int i = 0; i < WARM_UP_IT; i++) {
       ll.addFirst(NULL_OBJECT);
//      ll.removeLast();
     }

     before = System.currentTimeMillis();
     for (int i = 0; i < NUM_IT; i++) {
       ll.addFirst(NULL_OBJECT);
       ll.removeLast();
     }
     after = System.currentTimeMillis();
     System.out.print("LinkedList: ");
     printTime(before, after, NUM_IT);
   }

   private static void printTime(long before, long after, int numIt) {
     long time = after - before;
     System.out.println("time = " + time);
   }
}








import java.util.*;

public class MyPooledLinkedList
     extends AbstractSequentialList
     implements List, Queue, Cloneable, java.io.Serializable
{
   private transient Entry header = new Entry(null, null, null);
   private transient int size = 0;

   Entry[] pool = new Entry[5];
   int poolSize;

   private Entry alloc(Object o, Entry successor, Entry predecessor) {
     Entry e;

     if (poolSize == 0) {
       for (int i = 0; i < pool.length; i++) {
         pool[i] = new Entry(null, null, null);
         poolSize++;
       }
     }

     poolSize--;
     e = pool[poolSize];
     e.element = o;
     e.next = successor;
     e.previous = predecessor;
     return e;
   }

   private void free(Entry e) {
     e.next = e.previous = null;
     e.element = null;
     if (poolSize < pool.length) {
       pool[poolSize] = e;
       poolSize++;
     }
   }

   /**
    * Constructs an empty list.
    */
   public MyPooledLinkedList() {
     header.next = header.previous = header;
   }

   /**
    * Constructs a list containing the elements of the specified
    * collection, in the order they are returned by the collection's
    * iterator.
    *
    * @param  c the collection whose elements are to be placed into this 
list.
    * @throws NullPointerException if the specified collection is null.
    */
   public MyPooledLinkedList(Collection c) {
     this();
     addAll(c);
   }

   /**
    * Returns the first element in this list.
    *
    * @return the first element in this list.
    * @throws    java.util.NoSuchElementException if this list is empty.
    */
   public Object getFirst() {
     if (size==0)
       throw new NoSuchElementException();

     return header.next.element;
   }

   /**
    * Returns the last element in this list.
    *
    * @return the last element in this list.
    * @throws    NoSuchElementException if this list is empty.
    */
   public Object getLast()  {
     if (size==0)
       throw new NoSuchElementException();

     return header.previous.element;
   }

   /**
    * Removes and returns the first element from this list.
    *
    * @return the first element from this list.
    * @throws    NoSuchElementException if this list is empty.
    */
   public Object removeFirst() {
     return remove(header.next);
   }

   /**
    * Removes and returns the last element from this list.
    *
    * @return the last element from this list.
    * @throws    NoSuchElementException if this list is empty.
    */
   public Object removeLast() {
     return remove(header.previous);
   }

   /**
    * Inserts the given element at the beginning of this list.
    *
    * @param o the element to be inserted at the beginning of this list.
    */
   public void addFirst(Object o) {
     addBefore(o, header.next);
   }

   /**
    * Appends the given element to the end of this list.  (Identical in
    * function to the <tt>add</tt> method; included only for consistency.)
    *
    * @param o the element to be inserted at the end of this list.
    */
   public void addLast(Object o) {
     addBefore(o, header);
   }

   /**
    * Returns <tt>true</tt> if this list contains the specified element.
    * More formally, returns <tt>true</tt> if and only if this list contains
    * at least one element <tt>e</tt> such that <tt>(o==null ? e==null
    * : o.equals(e))</tt>.
    *
    * @param o element whose presence in this list is to be tested.
    * @return <tt>true</tt> if this list contains the specified element.
    */
   public boolean contains(Object o) {
     return indexOf(o) != -1;
   }

   /**
    * Returns the number of elements in this list.
    *
    * @return the number of elements in this list.
    */
   public int size() {
     return size;
   }

   /**
    * Appends the specified element to the end of this list.
    *
    * @param o element to be appended to this list.
    * @return <tt>true</tt> (as per the general contract of
    * <tt>Collection.add</tt>).
    */
   public boolean add(Object o) {
     addBefore(o, header);
     return true;
   }

   /**
    * Removes the first occurrence of the specified element in this 
list.  If
    * the list does not contain the element, it is unchanged.  More 
formally,
    * removes the element with the lowest index <tt>i</tt> such that
    * <tt>(o==null ? get(i)==null : o.equals(get(i)))</tt> (if such an
    * element exists).
    *
    * @param o element to be removed from this list, if present.
    * @return <tt>true</tt> if the list contained the specified element.
    */
   public boolean remove(Object o) {
     if (o==null) {
       for (Entry e = header.next; e != header; e = e.next) {
         if (e.element==null) {
           remove(e);
           return true;
         }
       }
     } else {
       for (Entry e = header.next; e != header; e = e.next) {
         if (o.equals(e.element)) {
           remove(e);
           return true;
         }
       }
     }
     return false;
   }

   /**
    * Appends all of the elements in the specified collection to the end of
    * this list, in the order that they are returned by the specified
    * collection's iterator.  The behavior of this operation is undefined if
    * the specified collection is modified while the operation is in
    * progress.  (This implies that the behavior of this call is 
undefined if
    * the specified Collection is this list, and this list is nonempty.)
    *
    * @param c the elements to be inserted into this list.
    * @return <tt>true</tt> if this list changed as a result of the call.
    * @throws NullPointerException if the specified collection is null.
    */
   public boolean addAll(Collection c) {
     return addAll(size, c);
   }

   /**
    * Inserts all of the elements in the specified collection into this
    * list, starting at the specified position.  Shifts the element
    * currently at that position (if any) and any subsequent elements to
    * the right (increases their indices).  The new elements will appear
    * in the list in the order that they are returned by the
    * specified collection's iterator.
    *
    * @param index index at which to insert first element
    *		    from the specified collection.
    * @param c elements to be inserted into this list.
    * @return <tt>true</tt> if this list changed as a result of the call.
    * @throws IndexOutOfBoundsException if the specified index is out of
    *            range (<tt>index &lt; 0 || index &gt; size()</tt>).
    * @throws NullPointerException if the specified collection is null.
    */
   public boolean addAll(int index, Collection c) {
     if (index < 0 || index > size)
       throw new IndexOutOfBoundsException("Index: "+index+
           ", Size: "+size);
     Object[] a = c.toArray();
     int numNew = a.length;
     if (numNew==0)
       return false;
     modCount++;

     Entry successor = (index==size ? header : entry(index));
     Entry predecessor = successor.previous;
     for (int i=0; i<numNew; i++) {
//      Entry e = new Entry(a[i], successor, predecessor);
       Entry e = alloc(a[i], successor, predecessor);
       predecessor.next = e;
       predecessor = e;
     }
     successor.previous = predecessor;

     size += numNew;
     return true;
   }

   /**
    * Removes all of the elements from this list.
    */
   public void clear() {
     Entry e = header.next;
     while (e != header) {
       Entry next = e.next;
       e.next = e.previous = null;
       e.element = null;
       e = next;
     }
     header.next = header.previous = header;
     size = 0;
     modCount++;
   }


   // Positional Access Operations

   /**
    * Returns the element at the specified position in this list.
    *
    * @param index index of element to return.
    * @return the element at the specified position in this list.
    *
    * @throws IndexOutOfBoundsException if the specified index is out of
    * range (<tt>index &lt; 0 || index &gt;= size()</tt>).
    */
   public Object get(int index) {
     return entry(index).element;
   }

   /**
    * Replaces the element at the specified position in this list with the
    * specified element.
    *
    * @param index index of element to replace.
    * @param element element to be stored at the specified position.
    * @return the element previously at the specified position.
    * @throws IndexOutOfBoundsException if the specified index is out of
    *		  range (<tt>index &lt; 0 || index &gt;= size()</tt>).
    */
   public Object set(int index, Object element) {
     Entry e = entry(index);
     Object oldVal = e.element;
     e.element = element;
     return oldVal;
   }

   /**
    * Inserts the specified element at the specified position in this list.
    * Shifts the element currently at that position (if any) and any
    * subsequent elements to the right (adds one to their indices).
    *
    * @param index index at which the specified element is to be inserted.
    * @param element element to be inserted.
    *
    * @throws IndexOutOfBoundsException if the specified index is out of
    *		  range (<tt>index &lt; 0 || index &gt; size()</tt>).
    */
   public void add(int index, Object element) {
     addBefore(element, (index==size ? header : entry(index)));
   }

   /**
    * Removes the element at the specified position in this list. 
Shifts any
    * subsequent elements to the left (subtracts one from their indices).
    * Returns the element that was removed from the list.
    *
    * @param index the index of the element to removed.
    * @return the element previously at the specified position.
    *
    * @throws IndexOutOfBoundsException if the specified index is out of
    * 		  range (<tt>index &lt; 0 || index &gt;= size()</tt>).
    */
   public Object remove(int index) {
     return remove(entry(index));
   }

   /**
    * Return the indexed entry.
    */
   private Entry entry(int index) {
     if (index < 0 || index >= size)
       throw new IndexOutOfBoundsException("Index: "+index+
           ", Size: "+size);
     Entry e = header;
     if (index < (size >> 1)) {
       for (int i = 0; i <= index; i++)
         e = e.next;
     } else {
       for (int i = size; i > index; i--)
         e = e.previous;
     }
     return e;
   }


   // Search Operations

   /**
    * Returns the index in this list of the first occurrence of the
    * specified element, or -1 if the List does not contain this
    * element.  More formally, returns the lowest index i such that
    * <tt>(o==null ? get(i)==null : o.equals(get(i)))</tt>, or -1 if
    * there is no such index.
    *
    * @param o element to search for.
    * @return the index in this list of the first occurrence of the
    * 	       specified element, or -1 if the list does not contain this
    * 	       element.
    */
   public int indexOf(Object o) {
     int index = 0;
     if (o==null) {
       for (Entry e = header.next; e != header; e = e.next) {
         if (e.element==null)
           return index;
         index++;
       }
     } else {
       for (Entry e = header.next; e != header; e = e.next) {
         if (o.equals(e.element))
           return index;
         index++;
       }
     }
     return -1;
   }

   /**
    * Returns the index in this list of the last occurrence of the
    * specified element, or -1 if the list does not contain this
    * element.  More formally, returns the highest index i such that
    * <tt>(o==null ? get(i)==null : o.equals(get(i)))</tt>, or -1 if
    * there is no such index.
    *
    * @param o element to search for.
    * @return the index in this list of the last occurrence of the
    * 	       specified element, or -1 if the list does not contain this
    * 	       element.
    */
   public int lastIndexOf(Object o) {
     int index = size;
     if (o==null) {
       for (Entry e = header.previous; e != header; e = e.previous) {
         index--;
         if (e.element==null)
           return index;
       }
     } else {
       for (Entry e = header.previous; e != header; e = e.previous) {
         index--;
         if (o.equals(e.element))
           return index;
       }
     }
     return -1;
   }

   // Queue operations.

   /**
    * Retrieves, but does not remove, the head (first element) of this list.
    * @return the head of this queue, or <tt>null</tt> if this queue is 
empty.
    * @since 1.5
    */
   public Object peek() {
     if (size==0)
       return null;
     return getFirst();
   }

   /**
    * Retrieves, but does not remove, the head (first element) of this list.
    * @return the head of this queue.
    * @throws NoSuchElementException if this queue is empty.
    * @since 1.5
    */
   public Object element() {
     return getFirst();
   }

   /**
    * Retrieves and removes the head (first element) of this list.
    * @return the head of this queue, or <tt>null</tt> if this queue is 
empty.
    * @since 1.5
    */
   public Object poll() {
     if (size==0)
       return null;
     return removeFirst();
   }

   /**
    * Retrieves and removes the head (first element) of this list.
    * @return the head of this queue.
    * @throws NoSuchElementException if this queue is empty.
    * @since 1.5
    */
   public Object remove() {
     return removeFirst();
   }

   /**
    * Adds the specified element as the tail (last element) of this list.
    *
    * @param o the element to add.
    * @return <tt>true</tt> (as per the general contract of
    * <tt>Queue.offer</tt>)
    * @since 1.5
    */
   public boolean offer(Object o) {
     return add(o);
   }

   /**
    * Returns a list-iterator of the elements in this list (in proper
    * sequence), starting at the specified position in the list.
    * Obeys the general contract of <tt>List.listIterator(int)</tt>.<p>
    *
    * The list-iterator is <i>fail-fast</i>: if the list is structurally
    * modified at any time after the Iterator is created, in any way except
    * through the list-iterator's own <tt>remove</tt> or <tt>add</tt>
    * methods, the list-iterator will throw a
    * <tt>ConcurrentModificationException</tt>.  Thus, in the face of
    * concurrent modification, the iterator fails quickly and cleanly, 
rather
    * than risking arbitrary, non-deterministic behavior at an undetermined
    * time in the future.
    *
    * @param index index of first element to be returned from the
    *		    list-iterator (by a call to <tt>next</tt>).
    * @return a ListIterator of the elements in this list (in proper
    * 	       sequence), starting at the specified position in the list.
    * @throws    IndexOutOfBoundsException if index is out of range
    *		  (<tt>index &lt; 0 || index &gt; size()</tt>).
    * @see List#listIterator(int)
    */
   public ListIterator listIterator(int index) {
     return new ListItr(index);
   }

   private class ListItr implements ListIterator {
     private Entry lastReturned = header;
     private Entry next;
     private int nextIndex;
     private int expectedModCount = modCount;

     ListItr(int index) {
       if (index < 0 || index > size)
         throw new IndexOutOfBoundsException("Index: "+index+
             ", Size: "+size);
       if (index < (size >> 1)) {
         next = header.next;
         for (nextIndex=0; nextIndex<index; nextIndex++)
           next = next.next;
       } else {
         next = header;
         for (nextIndex=size; nextIndex>index; nextIndex--)
           next = next.previous;
       }
     }

     public boolean hasNext() {
       return nextIndex != size;
     }

     public Object next() {
       checkForComodification();
       if (nextIndex == size)
         throw new NoSuchElementException();

       lastReturned = next;
       next = next.next;
       nextIndex++;
       return lastReturned.element;
     }

     public boolean hasPrevious() {
       return nextIndex != 0;
     }

     public Object previous() {
       if (nextIndex == 0)
         throw new NoSuchElementException();

       lastReturned = next = next.previous;
       nextIndex--;
       checkForComodification();
       return lastReturned.element;
     }

     public int nextIndex() {
       return nextIndex;
     }

     public int previousIndex() {
       return nextIndex-1;
     }

     public void remove() {
       checkForComodification();
       Entry lastNext = lastReturned.next;
       try {
         MyPooledLinkedList.this.remove(lastReturned);
       } catch (NoSuchElementException e) {
         throw new IllegalStateException();
       }
       if (next==lastReturned)
         next = lastNext;
       else
         nextIndex--;
       lastReturned = header;
       expectedModCount++;
     }

     public void set(Object o) {
       if (lastReturned == header)
         throw new IllegalStateException();
       checkForComodification();
       lastReturned.element = o;
     }

     public void add(Object o) {
       checkForComodification();
       lastReturned = header;
       addBefore(o, next);
       nextIndex++;
       expectedModCount++;
     }

     final void checkForComodification() {
       if (modCount != expectedModCount)
         throw new ConcurrentModificationException();
     }
   }

   private static class Entry<E> {
     Object element;
     Entry next;
     Entry previous;

     Entry(Object element, Entry next, Entry previous) {
       this.element = element;
       this.next = next;
       this.previous = previous;
     }
   }

   private Entry addBefore(Object o, Entry e) {
//    Entry newEntry = new Entry(o, e, e.previous);
     Entry newEntry = alloc(o, e, e.previous);
     newEntry.previous.next = newEntry;
     newEntry.next.previous = newEntry;
     size++;
     modCount++;
     return newEntry;
   }

   private Object remove(Entry e) {
     if (e == header)
       throw new NoSuchElementException();

     Object result = e.element;
     e.previous.next = e.next;
     e.next.previous = e.previous;
//    e.next = e.previous = null;
//    e.element = null;
     free(e);
     size--;
     modCount++;
     return result;
   }

   /**
    * Returns a shallow copy of this <tt>LinkedList</tt>. (The elements
    * themselves are not cloned.)
    *
    * @return a shallow copy of this <tt>LinkedList</tt> instance.
    */
   public Object clone() {
     MyPooledLinkedList clone = null;
     try {
       clone = (MyPooledLinkedList) super.clone();
     } catch (CloneNotSupportedException e) {
       throw new InternalError();
     }

     // Put clone into "virgin" state
//    clone.header = new Entry(null, null, null);
     clone.header =  alloc(null, null, null);
     clone.header.next = clone.header.previous = clone.header;
     clone.size = 0;
     clone.modCount = 0;

     // Initialize clone with our elements
     for (Entry e = header.next; e != header; e = e.next)
       clone.add(e.element);

     return clone;
   }

   /**
    * Returns an array containing all of the elements in this list
    * in the correct order.
    *
    * @return an array containing all of the elements in this list
    * 	       in the correct order.
    */
   public Object[] toArray() {
     Object[] result = new Object[size];
     int i = 0;
     for (Entry e = header.next; e != header; e = e.next)
       result[i++] = e.element;
     return result;
   }

   /**
    * Returns an array containing all of the elements in this list in
    * the correct order; the runtime type of the returned array is that of
    * the specified array.  If the list fits in the specified array, it
    * is returned therein.  Otherwise, a new array is allocated with the
    * runtime type of the specified array and the size of this list.<p>
    *
    * If the list fits in the specified array with room to spare
    * (i.e., the array has more elements than the list),
    * the element in the array immediately following the end of the
    * collection is set to null.  This is useful in determining the length
    * of the list <i>only</i> if the caller knows that the list
    * does not contain any null elements.
    *
    * @param a the array into which the elements of the list are to
    *		be stored, if it is big enough; otherwise, a new array of the
    * 		same runtime type is allocated for this purpose.
    * @return an array containing the elements of the list.
    * @throws ArrayStoreException if the runtime type of a is not a
    *         supertype of the runtime type of every element in this list.
    * @throws NullPointerException if the specified array is null.
    */
   public  Object[] toArray(Object[] a) {
     if (a.length < size)
       a = (Object[])java.lang.reflect.Array.newInstance(
           a.getClass().getComponentType(), size);
     int i = 0;
     Object[] result = a;
     for (Entry e = header.next; e != header; e = e.next)
       result[i++] = e.element;

     if (a.length > size)
       a[size] = null;

     return a;
   }

   private static final long serialVersionUID = 876323262645176354L;

   /**
    * Save the state of this <tt>LinkedList</tt> instance to a stream (that
    * is, serialize it).
    *
    * @serialData The size of the list (the number of elements it
    *		   contains) is emitted (int), followed by all of its
    * elements (each an Object) in the proper order.
    */
   private void writeObject(java.io.ObjectOutputStream s)
       throws java.io.IOException {
     // Write out any hidden serialization magic
     s.defaultWriteObject();

     // Write out size
     s.writeInt(size);

     // Write out all elements in the proper order.
     for (Entry e = header.next; e != header; e = e.next)
       s.writeObject(e.element);
   }

   /**
    * Reconstitute this <tt>LinkedList</tt> instance from a stream (that is
    * deserialize it).
    */
   private void readObject(java.io.ObjectInputStream s)
       throws java.io.IOException, ClassNotFoundException {
     // Read in any hidden serialization magic
     s.defaultReadObject();

     // Read in size
     int size = s.readInt();

     // Initialize header
//    header = new Entry(null, null, null);
     header =  alloc(null, null, null);
     header.next = header.previous = header;

     // Read in all elements in the proper order.
     for (int i=0; i<size; i++)
       addBefore(s.readObject(), header);
   }
}




From jws@cs.mu.OZ.AU  Thu Nov  4 00:27:40 2004
From: jws@cs.mu.OZ.AU (Jeff Schultz)
Date: Thu, 04 Nov 2004 11:27:40 +1100
Subject: [concurrency-interest] PooledLinkedBlockingQueue
Message-ID: <11774.1099528060@blunt>

> Thanks for your comments, it's appreciated.  I just want to believe you, 
> but how do you explain the test below.  I have modified Sun LinkedList 
> into MyPooledLinkedList.  This class is exacly like LinkedList, so its 
> not thread-safe.  The test show a huge performance difference between 
> the two lists: MyPooledLinkedList is a  an order of magnitude more fast! 
>   On my computer, LinkedList take 127400 ms and MyPooledLinkedList take 
> 16500 ms.  Could you explain this difference please?  Am-I missing 
> something?
> 
> Thanks
> Jean
> 
> import java.util.LinkedList;
> 
> public class Test {
> 
>    private static final int NUM_IT = 100000000;
>    private static final int WARM_UP_IT = NUM_IT / 100;
>    static Object NULL_OBJECT = new Object() {};
> 
>    /*
>    LinkedList:            time  = 127458  124624
>    MyPooledLinkedList     time  =  16555   16277
>    */
>    public static void main(String args[]) throws Exception {
>      main1(); // pooled list item objects, very fast
> //    main2();   // sun's linked list: very long
>    }
> 
>    public static void main1() {
>      MyPooledLinkedList ll = new MyPooledLinkedList();
>      long before, after;
> 
>      for (int i = 0; i < WARM_UP_IT; i++) {
>        ll.addFirst(NULL_OBJECT);
> //      ll.removeLast();
>      }
> 
>      before = System.currentTimeMillis();
>      for (int i = 0; i < NUM_IT; i++) {
>        ll.addFirst(NULL_OBJECT);
>        ll.removeLast();
>      }
>      after = System.currentTimeMillis();
>      System.out.print("MyPooledLinkedList: ");
>      printTime(before, after, NUM_IT);
>    }

Without wanting to look at what you've done to SUN's LinkedList, I'd
observe that you have 1 million nodes in use at any one time, and the
lifetime of each node is 1 million allocations.  These will not
usually fit in the nursery, so for the non-pooled case they're all
getting tenured (expensive) and then dying soon after.  Try it with a
smaller number of nodes in use, or change the GC parameters to
increase the size of the nursery and I'd expect you to see different
performance.


    Jeff Schultz

From dl@cs.oswego.edu  Thu Nov  4 00:53:31 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 3 Nov 2004 19:53:31 -0500
Subject: [concurrency-interest] PooledLinkedBlockingQueue
In-Reply-To: <11774.1099528060@blunt>
References: <11774.1099528060@blunt>
Message-ID: <16777.32139.808125.481530@altair.cs.oswego.edu>

> Without wanting to look at what you've done to SUN's LinkedList,

To avoid future similar reactions, I pulled that posting from the list
archives. 

-Doug

From jean.morissette666@videotron.ca  Thu Nov  4 01:24:35 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Wed, 03 Nov 2004 20:24:35 -0500
Subject: [concurrency-interest] PooledLinkedBlockingQueue
In-Reply-To: <11774.1099528060@blunt>
References: <11774.1099528060@blunt>
Message-ID: <418984D3.2050101@videotron.ca>

Jeff Schultz wrote:
> Try it with a
> smaller number of nodes in use, or change the GC parameters to
> increase the size of the nursery and I'd expect you to see different
> performance.

I have changed the test in the 'warn up loop' to remove a node after 
adding it to the list, so there is no more than one node all the time. 
Now, the performance difference is much lesser, but PooledLinkedList is 
a little more fast.
       LinkedList:  12000 ms
PooledLinkedList:   9500 ms


From jean.morissette666@videotron.ca  Thu Nov  4 02:20:23 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Wed, 03 Nov 2004 21:20:23 -0500
Subject: [concurrency-interest] PooledLinkedBlockingQueue
In-Reply-To: <16777.32139.808125.481530@altair.cs.oswego.edu>
References: <11774.1099528060@blunt>
 <16777.32139.808125.481530@altair.cs.oswego.edu>
Message-ID: <418991E7.4040402@videotron.ca>

Doug Lea wrote:
>>Without wanting to look at what you've done to SUN's LinkedList,
> 
> To avoid future similar reactions, I pulled that posting from the list
> archives. 

Excuse me.

To help the discussion, I give here only my code for the pool:

   Entry[] pool = new Entry[5];
   int poolSize;

   private Entry alloc(Object o, Entry successor, Entry predecessor) {
     Entry e;

     if (poolSize == 0) {
       for (int i = 0; i < pool.length; i++) {
         pool[i] = new Entry(null, null, null);
         poolSize++;
       }
     }

     poolSize--;
     e = pool[poolSize];
     e.element = o;
     e.next = successor;
     e.previous = predecessor;
     return e;
   }

   private void free(Entry e) {
     e.next = e.previous = null;
     e.element = null;
     if (poolSize < pool.length) {
       pool[poolSize] = e;
       poolSize++;
     }
   }



From kav@itu.dk  Thu Nov  4 09:05:07 2004
From: kav@itu.dk (kav@itu.dk)
Date: Thu, 4 Nov 2004 10:05:07 +0100 (CET)
Subject: [concurrency-interest] PooledLinkedBlockingQueue
In-Reply-To: <418991E7.4040402@videotron.ca>
References: <11774.1099528060@blunt>
 <16777.32139.808125.481530@altair.cs.oswego.edu>
 <418991E7.4040402@videotron.ca>
Message-ID: <60959.149.243.232.3.1099559107.squirrel@149.243.232.3>

On top of my head what about using something like the following (untested,
could require some optimization, and potentially i've just completely
missed something)

The idea is to loosely cache a maximum of MAX_ITEMS nodes. Under normal
conditions we cache all nodes, however, once in a while we loose a node
and need to create a new one.

First you extend the Node class that you have previously defined with an
inUse atomicBoolean that indicates whether or not the node is in use.

For the NodeCacher the cacheNode() is used for caching nodes (surprise).
Under concurrent access it will sometimes insert two nodes at the same
slot in the array. However, this is okay because we do not mind loosing a
node or two once in a while. GC should take of removing these nodes. One
thing is sure though, they will never attempt to put a node into a slot
with an index bigger then MAX_ITEMS (so no ArrayOutOfBoundException).

getNode() is used for retrieving the cached nodes or optionally create a
new one. If a previous Node has been cached the getNode(Node) method will
most likely find it. If there is concurrent access one of two things might
happen either the threads will acquire the same Node in which case we use
the node's inUse atomic boolean to decide which thread gets the node. The
thread(s) that "lost" can then create a new Node instead (or optionally
use some retry-based mechanism). The other scenario is that we get a null
from accessing the array in which case we also create a new node.

public class Node {
    final AtomicBoolean inUse = new AtomicBoolean();
    ..........your other pointers
}

public class NodeCacher {

    private volatile int index = 0;
    private final static int MAX_ITEMS = 1000;
    private final Node[] array = new Node[MAX_ITEMS];

    public void cacheNode(Node node) {
        node.inUse.set(false);
        int i = index;
        if (i < MAX_ITEMS) {
            array[i] = node;
            index = i + 1;
        }
    }

    public Node getNode() {
        int i = index - 1;
        if (i > -1) {
            Node n = array[i];
            if (n != null && n.inUse.compareAndSet(false, true)) {
                array[i] = null;
                index = i;
                return n;
            }
        }
        return new Node();
    }
}

- Kasper



From Ronald.Veldema@informatik.uni-erlangen.de  Thu Nov  4 22:39:22 2004
From: Ronald.Veldema@informatik.uni-erlangen.de (Ronald Veldema)
Date: Thu, 04 Nov 2004 23:39:22 +0100
Subject: [concurrency-interest] cvs & licencing issues ?
Message-ID: <418AAF9A.9040809@informatik.uni-erlangen.de>

Hi List,
    I'm trying to create a Java compiler and runtime system suitable
for parallel/cluster/grid programming by providing a single-system-image
using a distributed-shared-memory (DSM) system.
As such, I've thusfar been using the GNU classpath libraries
    ( http://www.gnu.org/software/classpath/classpath.html  )
which provides things like java.lang.*, java.io.*, java.rmi.*, 
java.awt.*, etc
like SUN has but only under GPL.
Because my stuff is all about parallel programming, it would
be nice to include java.util.concurrent.* except that classpath doesn't 
yet include it.

Now the question: can I checkout the sources from CVS ( 
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ 
)
and include these with my compiler ?
My compiler & classpath are all (L)GPL-ed. A quick peek at a random
file delivers:

 http://creativecommons.org/licenses/publicdomain

Am I correct that it allows me to do so ?
If so, it might be a good idea to inform the classpath/gcc/gcj people so that
we'll all have a gcc with a working java.util.concurrent too !
Regards,

Ronald.


-- 

-------------------------------
web:
http://www2.informatik.uni-erlangen.de/Personen/veldema/?language=en


From dholmes@dltech.com.au  Fri Nov  5 00:11:37 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Fri, 5 Nov 2004 10:11:37 +1000
Subject: [concurrency-interest] cvs & licencing issues ?
In-Reply-To: <418AAF9A.9040809@informatik.uni-erlangen.de>
Message-ID: <NFBBKALFDCPFIDBNKAPCOELEEPAA.dholmes@dltech.com.au>

> If so, it might be a good idea to inform the classpath/gcc/gcj
> people so that we'll all have a gcc with a working
> java.util.concurrent too !

I think I have already mentioned this to the Classpath folk, but their main
focus at present is on getting at least JDK 1.2 compatability complete - the
5.0 support will be quite a while yet (there's been some early generics
work), and j.u.c requires other 5.0 features. It also requires VM support to
work well.

I'm also not sure if the CreativeCommons license is sufficient to allow
Classpath to adopt this stuff - the FSF seems pretty hung up on (L)GPL.

David Holmes


From dl@cs.oswego.edu  Fri Nov  5 00:33:36 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 4 Nov 2004 19:33:36 -0500
Subject: [concurrency-interest] cvs & licencing issues ?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOELEEPAA.dholmes@dltech.com.au>
References: <418AAF9A.9040809@informatik.uni-erlangen.de>
 <NFBBKALFDCPFIDBNKAPCOELEEPAA.dholmes@dltech.com.au>
Message-ID: <16778.51808.926959.197789@altair.cs.oswego.edu>

> can I checkout the sources from CVS 

Sure. That's literally what Sun did when incorporating these into J2SE
5.0.  They don't have privileged access or rights to them.  I believe
that BEA jRockit has or will do the same.  You do have to check the
file headers for the files though. JSR166 included changes in a few
existing classes, for example class Thread. We placed (with
permission) the changed version in CVS even though Thread.java is
still Sun Copyright. This way, the CVS holds the full JSR166 effort.

-Doug




From dl@cs.oswego.edu  Fri Nov  5 01:17:10 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 4 Nov 2004 20:17:10 -0500
Subject: [concurrency-interest] PooledLinkedBlockingQueue
In-Reply-To: <418984D3.2050101@videotron.ca>
References: <11774.1099528060@blunt>
 <418984D3.2050101@videotron.ca>
Message-ID: <16778.54422.115507.995737@altair.cs.oswego.edu>

> MyPooledLinkedList.  This class is exacly like LinkedList, so its
> not thread-safe.  The test show a huge performance difference
> between the two lists ...  Could you explain this difference please?

In a purely sequential environment, you probably want a bulk-allocated
array-based queue -- probably it would perorm a bit faster than your
pooled version. We never got to this in JSR166 -- we planned for the
Deque interface, and to also have an array-based sequential version,
but didn't have enough time to complete this for Tiger. We have the
Deque interface up in jsr166x pacakage, and will add ArrayDeque once
Josh Bloch and I finish arguing over it :-) Deque and its
implementations should make it into next major release.  (BTW, expect
a few minor API changes to Deque interface.)

As a coarse rule of thumb, array-based structures are better in
sequential applications, and dynamic node-based better in concurrent
applications.

-Doug



From jean.morissette666@videotron.ca  Fri Nov  5 05:28:32 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Fri, 05 Nov 2004 00:28:32 -0500
Subject: [concurrency-interest] Queue throughput
Message-ID: <418B0F80.9090904@videotron.ca>

Hi,
In SMP environment, what are the expected methods of class 
LinkedBlockingQueue that should give the highest throughput for 
producer/consumer application?  The only constraint is that objects must 
be enqueued only one at time (no call to addAll()).

Javadoc of BlockingQueue interface says about drainTo that "this 
operation may be more efficient than repeatedly polling this queue".  Is 
it really more efficient for LinkedBlockingQueue class?  It seem to me 
that 'drainTo' can reduce throughput (compared to poll method) because 
it acquire also the "putLock".

Thanks
Jean

From dholmes@dltech.com.au  Fri Nov  5 05:46:35 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Fri, 5 Nov 2004 15:46:35 +1000
Subject: [concurrency-interest] Queue throughput
In-Reply-To: <418B0F80.9090904@videotron.ca>
Message-ID: <NFBBKALFDCPFIDBNKAPCEELNEPAA.dholmes@dltech.com.au>

> Jean Morissette writes:
>
> Javadoc of BlockingQueue interface says about drainTo that "this
> operation may be more efficient than repeatedly polling this queue".  Is
> it really more efficient for LinkedBlockingQueue class?  It seem to me
> that 'drainTo' can reduce throughput (compared to poll method) because
> it acquire also the "putLock".

It says *may* be more efficient. Whether it is or not depends entirely on
how you use it. For the thread doing the drainTo it will almost certainly be
more efficient than repeated polling. However, that need not translate to
improving efficiency of the application (however you want to define
efficiency for the application) as it will potentially impact on producers.

David Holmes


From adam@bea.com  Sat Nov  6 01:51:59 2004
From: adam@bea.com (Adam Messinger)
Date: Fri, 5 Nov 2004 17:51:59 -0800
Subject: [concurrency-interest] PooledLinkedBlockingQueue
Message-ID: <82447314F99FB04EB45A98AF96FD7F1708EBE638@ussfex01.bea.com>

 

> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu 
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf 
> Of Jean Morissette
> Sent: Wednesday, November 03, 2004 5:25 PM
> To: Jeff Schultz
> Cc: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] PooledLinkedBlockingQueue
> 
> Jeff Schultz wrote:
> > Try it with a
> > smaller number of nodes in use, or change the GC parameters to 
> > increase the size of the nursery and I'd expect you to see 
> different 
> > performance.
> 
> I have changed the test in the 'warn up loop' to remove a 
> node after adding it to the list, so there is no more than 
> one node all the time. 
> Now, the performance difference is much lesser, but 
> PooledLinkedList is a little more fast.
>        LinkedList:  12000 ms
> PooledLinkedList:   9500 ms

I believe that pooling can be made to perform well in the context of
some single-threaded data structures, like your new example.  The
original question was in the context of a data-structure which has
multi-threaded access.  In this case the pooling logic will be much more
expensive (to handle concurrency either via thread local pools or via a
shared concurrent pool) and I doubt you will ever make up this gap.

In my experiments I've noticed a big difference depending upon the JVM
being used.  With JRockit I see no measurable difference between the two
implementations.  With HotSpot server I see that the pooled
implementation is significantly faster.  With HotSpot client I see that
the pooled implementation is only very slightly faster.

Cheers!

Adam


From dl@cs.oswego.edu  Sun Nov  7 13:12:04 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sun, 7 Nov 2004 08:12:04 -0500
Subject: [concurrency-interest] J2SE now available under revised Java Research License
Message-ID: <16782.7972.985534.966631@altair.cs.oswego.edu>

In case you didn't see the announcements, Sun finally released full
JDK, hotspot and TCK sources under a new more liberal version of the
Java Research License. See http://www.java.net/jrl.csp 

While this doesn't directly affect JSR166, it does allow researchers to
further experiment with concurrency and other infrastructure support
that might lead to or assist in future JSRs etc. We were only able to
carry out JSR166 by getting a special license that was almost
identical to the new JRL, so I could add VM support (for atomics etc),
modify existing Java libraries, and add new ones.

-Doug


From jean.morissette666@videotron.ca  Tue Nov  9 20:30:48 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Tue, 09 Nov 2004 15:30:48 -0500
Subject: [concurrency-interest] Transactional Queue
Message-ID: <419128F8.5030108@videotron.ca>

Hi,
I would like to ear you about the possibility to write a 
TransactionalQueue that support methods like:

   TransactionID prepareEnqueue(Object[] objs)
   commitEnqueue(TransactionID txId)
   abortEnqueue(TransactionID txId)

By exemple, these methodes could be used to perform multi-queue 
transactional enqueue operations, with an "all-or-nothing" strategy for 
enqueueing events on multiple queues.

We could maybe implements that by wrapping a Queue/BlockingQueue, but 
the wrapping queue capacity seems an issue here.

Thanks
Jean

From vmarathe@cs.rochester.edu  Mon Nov 15 14:48:30 2004
From: vmarathe@cs.rochester.edu (Virendra J. Marathe)
Date: Mon, 15 Nov 2004 09:48:30 -0500 (EST)
Subject: [concurrency-interest] Benchmark applications for measuring throughput of synchronization
 algorithms
Message-ID: <Pine.LNX.4.44.0411150945480.22057-100000@a20.cs.rochester.edu>

Hi all,

I am looking for "real" applications that 
use synchronization heavily enough to be of considerable importance to the 
application's performance. 
I would be really grateful if someone could give me pointers 
to such apps or any other suggestions in this regard.

Cheers.
Virendra.



From jean.morissette666@videotron.ca  Wed Nov 24 23:57:58 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Wed, 24 Nov 2004 18:57:58 -0500
Subject: [concurrency-interest] Polling many queues with few threads
Message-ID: <41A52006.2000500@videotron.ca>

Hi,
I would like to have your advice on one of my problem.  Suppose that we 
have N queues that are polled (not pooled) continously, in a round-robin 
schedule, by only M thread, where M < N.

The question is what we should do if all queues are empty?  I don't want 
to poll continously all the empty queues because its time consumming. 
Instead, I would like to wait until one of the queues become non-empty.

What are my options?

Best regards,
Jean

From larryr@saturn.sdsu.edu  Thu Nov 25 01:53:05 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 25 Nov 2004 01:53:05 -0000
Subject: [concurrency-interest] Re: Polling many queues with few threads
In-Reply-To: <41A52006.2000500@videotron.ca>
Message-ID: <20041125015305.2261.qmail@home19.riedel.org>

> Suppose that we have N queues that are polled (not pooled)
> continously, in a round-robin schedule, by only M thread,
> where M < N. [...] The question is what we should do if all
> queues are empty?

How about one semaphore where consumer threads take/acquire before
polling and the producers put/release?  Would that be inefficient?


Larry


From matthias.ernst@coremedia.com  Thu Nov 25 06:06:46 2004
From: matthias.ernst@coremedia.com (Ernst, Matthias)
Date: Thu, 25 Nov 2004 07:06:46 +0100
Subject: [concurrency-interest] Polling many queues with few threads
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5F635E83@MARS.coremedia.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C4D2B4.F1D736E8
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Jean Morissette wrote:
> I would like to have your advice on one of my problem.  Suppose that =
we=20
> have N queues that are polled (not pooled) continously, in a =
round-robin=20
> schedule, by only M thread, where M < N.

I guess I wouldn't use N queues in the first place. Why not just one?
Which would come handy since one queue with M threads is actually a =
ThreadPoolExecutor.

Matthias

------_=_NextPart_001_01C4D2B4.F1D736E8
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Diso-8859-1">
<META NAME=3D"Generator" CONTENT=3D"MS Exchange Server version =
6.5.7226.0">
<TITLE>RE: [concurrency-interest] Polling many queues with few =
threads</TITLE>
</HEAD>
<BODY>
<!-- Converted from text/plain format -->

<P><FONT SIZE=3D2>Jean Morissette wrote:<BR>
&gt; I would like to have your advice on one of my problem.&nbsp; =
Suppose that we<BR>
&gt; have N queues that are polled (not pooled) continously, in a =
round-robin<BR>
&gt; schedule, by only M thread, where M &lt; N.<BR>
<BR>
I guess I wouldn't use N queues in the first place. Why not just =
one?<BR>
Which would come handy since one queue with M threads is actually a =
ThreadPoolExecutor.<BR>
<BR>
Matthias<BR>
</FONT>
</P>

</BODY>
</HTML>
------_=_NextPart_001_01C4D2B4.F1D736E8--

From leou@us.ibm.com  Thu Nov 25 18:33:13 2004
From: leou@us.ibm.com (Leo Uzcategui)
Date: Thu, 25 Nov 2004 11:33:13 -0700
Subject: [concurrency-interest] Leo Uzcategui/Austin/IBM is out of the office.
Message-ID: <OF22BDE393.271DAF2B-ON87256F57.0065EB07-87256F57.0065EB07@us.ibm.com>

--0__=08BBE5C4DFF66D978f9e8a93df938690918c08BBE5C4DFF66D97
Content-type: text/plain; charset=US-ASCII





I will be out of the office starting  11/22/2004 and will not return until
12/02/2004.

For assistance, please contact Robin Redden at (512) 838-1542.
--0__=08BBE5C4DFF66D978f9e8a93df938690918c08BBE5C4DFF66D97
Content-type: text/html; charset=US-ASCII
Content-Disposition: inline

<html><body>
<p>I will be out of the office starting  11/22/2004 and will not return until 12/02/2004.<br>
<br>
For assistance, please contact Robin Redden at (512) 838-1542.<br>
</body></html>
--0__=08BBE5C4DFF66D978f9e8a93df938690918c08BBE5C4DFF66D97--


From dl@cs.oswego.edu  Fri Nov 26 14:03:02 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 26 Nov 2004 09:03:02 -0500
Subject: [concurrency-interest] Polling many queues with few threads
In-Reply-To: <F34C8A704C489B46B9E9FBDBD1B91D5F635E83@MARS.coremedia.com>
References: <F34C8A704C489B46B9E9FBDBD1B91D5F635E83@MARS.coremedia.com>
Message-ID: <16807.14230.952191.366619@altair.cs.oswego.edu>

Jean Morissette:
> > I would like to have your advice on one of my problem.  Suppose that we 
> > have N queues that are polled (not pooled) continously, in a round-robin 
> > schedule, by only M thread, where M < N.
> 

Matthias Ernst:
> I guess I wouldn't use N queues in the first place. Why not just
> one?  Which would come handy since one queue with M threads is
> actually a ThreadPoolExecutor.

This is the best advice. (Also: one input queue, M worker threads, and
one output queue is an ExecutorCompletionService.)

If for some reason you must use separate queues, then you need a
secondary notification scheme.  For example, you can use a
BlockingQueue that delegates to one of the standard ones for all
operations. But additionally, on each insertion, have each queue
enqueue its identity on a secondary collector queue that contains
references to the queues that have elements, that can be used by
consumer threads. You can further specialize to a synchronizer that
keeps track of {queue, available-item-count} rather than holding
multiple references to the same queues to represent multiple available
elements. 

Notice that these kinds of designs are variations of the idea of using
just one queue. They usually impose further overhead than having just
one queue, but might still be better than the polling overhead they
replace. 

The general design issue here is one version of the
selector/demultiplexer/alt problem: Block until any of several tasks
are ready to proceed.  General solutions tend to impose overhead,
and/or usage restrictions, and/or ugly APIs. (java.nio Selectors have
some of each :-) Usually, the best advice is to redesign to avoid the
problem rather than trying to solve it. But in some cases (most
notably IO), the performance advantages of custom solutions usually
outweigh this.

-Doug

From dl@cs.oswego.edu  Fri Nov 26 15:15:24 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 26 Nov 2004 10:15:24 -0500
Subject: [concurrency-interest] BlockingDeque and revised Deque
Message-ID: <16807.18572.932848.214817@altair.cs.oswego.edu>

We put preliminary versions of javadocs for the promised BlockingDeque
interface and related APIs accessible from:
  http://gee.cs.oswego.edu/dl/jsr166/prejsr166x/index.html

(Note: As is usually the case for javadocs for files that aren't yet
in their intended packages, some of the specs for inherited and
overridden methods don't show up right.)

This includes the revised API for Deque. The main difference from the
previous version is that we decided that it was worth the usability
advantages to create method synonyms for common FIFO and LIFO (queue
and stack) operations, rather than requiring "views". So there are now
sets of methods required to do the same thing (e.g., "removeFirst",
"remove", and "pop").  One reason is to make it easier and more
natural for people to finally stop using the awful (and unfixable due
to compatibility requirements) java.util.Stack class.

You can compare new and old Deque by comparing above javadocs URL to
the version still in http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166xdocs/

The javadocs also includes ArrayDeque, that is designed to go into
java.util (not java.util.concurrent), and is intended to be the
fastest available NON-thread-safe stack/queue/deque implementation.

We'll probably check these into jsr166x soon. But we'd first like to
hear any comments on the above, and have some further questions:

1. LinkedBlockingDeque vs ConcurrentLinkedDeque

The LinkedBlockingDeque class is intended to be the "standard"
blocking deque class. The current implementation has relatively low
overhead but relatively poor scalability. So if you need only FIFO
queue functionality, you are better off using LinkedBlockingQueue,
which has about the same overhead but better scalibility (i.e.,
maintains better performance under contention by many
threads). Supplying both LinkedBlockingQueue and LinkedBlockingDeque
allows people to trade off functionality for scalability, which seems
about right. (And maybe someday we'll come up with some clever
redesign that eliminates this performance difference.)

But we are no longer so sure about whether the ConcurrentLinkedDeque
class now in jsr166x is important enough to put into
java.util.concurrent.  (The alternative is just to make it available
in the long-promised package of random extra niche concurrency
classes, that still doesn't exist.) ConcurrentLinkedDeque has almost
the opposite performance profile as LinkedBlockingDeque: relatively
high overhead, but very good scalability. This would also make sense
to supply to allow tradeoffs, except that in concurrent applications,
it is not all that common to want a Deque that is thread safe yet does
not support blocking. And most of those that do are probably better
off with special-case solutions.

Does anyone know of a use case common enough to argue for
adding ConcurrentLinkedDeque to java.util.concurrent?

2. Views

While the new renamings and aliases in the new Deque interface make it
a lot more convenient, they lose one advantage of the old version --
to be able to use a Deque in a LIFO manner as a Queue via method
asLifo (similarly for BlockingQueue). We know there is at least one
existing use case for this (LIFO-based executors). But in keeping with
Collections framework conventions, these kinds of
adaptor-factory-methods probably ought to appear in the
java.util.Collections class (that contains already adaptors like
"immutableList"). The new methods would be something like:
  static Queue asLifoQueue(Deque d)
  static BlockingQueue asLifoBlockingQueue(BlockingDeque d)

Even though supposedly trivial, these kinds of adaptors are tedious to
write and too easy to get just barely wrong, so ought to be supplied.

But doing this mildly breaks a different convention, of keeping
java.util free of all references to java.util.concurrent. So
we are left with a small judgement call. Should we...

  1. Add both of these to java.util.Collections

  2. Create a similar java.util.concurrent.ConcurrentCollections class
     and define asLifoBlockingQueue in it, but add asLifoQueue to
     java.util.Collections

Any opinions? Option (2) seems better, but we want to minimize classes
added as part of maintenance/RFE process, and this one would have a
fairly weak rationale for even existing.

(Aside: It is too bad that you cannot put static methods in interfaces
in Java. Allowing this would make the proper placement obvious.)

-Doug

From josh@bloch.us  Fri Nov 26 18:57:00 2004
From: josh@bloch.us (Joshua Bloch)
Date: Fri, 26 Nov 2004 13:57:00 -0500
Subject: [concurrency-interest] BlockingDeque and revised Deque
In-Reply-To: <16807.18572.932848.214817@altair.cs.oswego.edu>
References: <16807.18572.932848.214817@altair.cs.oswego.edu>
Message-ID: <b097ac5104112610575fae30ca@mail.gmail.com>

Folks,

I like the new interfaces, but that should come as no surprise: Doug
ang I were partners in this crime:)

Regarding Doug's open questions:


> But we are no longer so sure about whether the ConcurrentLinkedDeque
> class now in jsr166x is important enough to put into
> java.util.concurrent. 

When in doubt, leave it out.

> 2. Views
> 

> But doing this mildly breaks a different convention, of keeping
> java.util free of all references to java.util.concurrent. So
> we are left with a small judgement call. Should we...
> 
>   1. Add both of these to java.util.Collections
> 
>   2. Create a similar java.util.concurrent.ConcurrentCollections class
>      and define asLifoBlockingQueue in it, but add asLifoQueue to
>      java.util.Collections
> 

It boils down to whether we anticipate (much) more stuff like this in
the future.  I wouldn't mind jamming both adapters into
java.util.Collections unless asLifoBlockingQueue is the first in a
long line.

     Regards,

     Josh

From larryr@saturn.sdsu.edu  Fri Nov 26 21:14:37 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 26 Nov 2004 21:14:37 -0000
Subject: [concurrency-interest] Re: BlockingDeque and revised Deque
In-Reply-To: <16807.18572.932848.214817@altair.cs.oswego.edu>
Message-ID: <20041126211437.22376.qmail@home19.riedel.org>


> Does anyone know of a use case common enough to argue for
> adding ConcurrentLinkedDeque to java.util.concurrent?

I think if an API class/method provides useful and intuitively
meaningful functionality which has significant aspects distinct
from what the other classes/methods in the API provide, and it
can be implemented/maintained cleanly, it is fine to add it.


> Should we...
>   1. Add both of these to java.util.Collections
>   2. Create a similar java.util.concurrent.ConcurrentCollections
>      [....]
> Any opinions?

I think java.util.Collections is by nature a turd, and I would
not prefer a similar new turd be added to the keep the existing
one from stinking more than it already does.


Larry


From tim@peierls.net  Sat Nov 27 02:30:42 2004
From: tim@peierls.net (Tim Peierls)
Date: Fri, 26 Nov 2004 21:30:42 -0500
Subject: [concurrency-interest] BlockingDeque and revised Deque
In-Reply-To: <b097ac5104112610575fae30ca@mail.gmail.com>
References: <16807.18572.932848.214817@altair.cs.oswego.edu>
 <b097ac5104112610575fae30ca@mail.gmail.com>
Message-ID: <41A7E6D2.9000905@peierls.net>

Joshua Bloch wrote:
> I wouldn't mind jamming both adapters into
> java.util.Collections unless asLifoBlockingQueue is the first in a
> long line.

I'm sure there will be more. I'd like to have asPutOnlyBlockingQueue
and asTakeOnlyBlockingQueue, for starters. No, it isn't hard to roll
your own, but it is tedious. I think it's important to have them for
passing queues into contexts where it is impossible to guarantee that
the recipient will observe the required protocol.

So I'm in favor of j.u.c.ConcurrentCollections, especially if a shorter
name can be found.

--tim


From josh@bloch.us  Sat Nov 27 05:19:34 2004
From: josh@bloch.us (Joshua Bloch)
Date: Sat, 27 Nov 2004 00:19:34 -0500
Subject: [concurrency-interest] Re: BlockingDeque and revised Deque
In-Reply-To: <20041126211437.22376.qmail@home19.riedel.org>
References: <16807.18572.932848.214817@altair.cs.oswego.edu>
 <20041126211437.22376.qmail@home19.riedel.org>
Message-ID: <b097ac5104112621195820da8c@mail.gmail.com>

Larry,


On 26 Nov 2004 21:14:37 -0000, Larry Riedel <larryr@saturn.sdsu.edu> wrote:
> 
> 
> > Does anyone know of a use case common enough to argue for
> > adding ConcurrentLinkedDeque to java.util.concurrent?
> 
> I think java.util.Collections is by nature a turd, and I would
> not prefer a similar new turd be added to the keep the existing
> one from stinking more than it already does.

And I think you are full of turds.  java.util.Collection has a great
power-to-weight ratio.  I have no idea why you don't like it.  Of
course I'm biased.

                 Josh (AKA the author of java.util.Collections)

From dl@cs.oswego.edu  Sat Nov 27 13:53:12 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sat, 27 Nov 2004 08:53:12 -0500
Subject: [concurrency-interest] phase change notes
Message-ID: <16808.34504.203436.710693@altair.cs.oswego.edu>

Now that JSR166 is fully in maintenance/RFE mode, we made a few
changes to CVS and related files available off
  http://gee.cs.oswego.edu/dl/concurrency-interest/index.html

The CVS repository and accessible API javadocs now contain ONLY those
classes/files that originated in JSR166. We removed existing files
that were modified as part of JSR166 (for example, ThreadLocal, to
which we added the "remove" method). This allows future unrelated
JSRs, RFEs and bug fixes to further modify these without our direct
involvement. But the JSR166 maintenance group (*) will continue to
maintain the base repository holding any changes to files that we
originated.

We have been encouraged to incorporate our initial backlog of RFEs
(i.e., those we accepted while JSR166 was officially in progess but
couldn't do in time for Tiger) into Mustang (J2SE6.0) builds whenever
we are ready.  This is why we've been reviewing and touching up Deque
and BlockingDeque, as well as ConcurrentSkiplListMap and its
associated interfaces. We will probably try to integrate these into
Mustang builds sometime within a month or two. We'll still supply
these as jsr166x.jar as well, so that you won't strictly need Mustang
builds to use them.

As you probably know, early-access Mustang builds and sources are now
accessible under the Java Research License at
  https://j2se.dev.java.net/

We'd also like to encourage you to suggest now any changes or
additions that can uncontroversially be done as small maintenance
updates. Schedules for getting in even small changes for J2SE6 will
probably be short. 

(*) The JSR166 maintenance group is most of us from the JSR166 expert
group: Josh Bloch, Joe Bowbeer, Brian Goetz, David Holmes, Doug Lea
and Tim Peierls, along with Martin Buchholz and Dave Dice from Sun,
and Bill Pugh (Univ Maryland; JSR133 lead).

-Doug

From jmorissette666@hotmail.com  Sun Nov 28 20:32:18 2004
From: jmorissette666@hotmail.com (Jean Morissette)
Date: Sun, 28 Nov 2004 15:32:18 -0500
Subject: [concurrency-interest] Queue.setCapacity
Message-ID: <BAY102-F195AA8895CBF16DEB2B4AE8ABC0@phx.gbl>

<html><div style='background-color:'><DIV class=RTE>Hi, <BR>Is it possible to create classes similar to ConcurrentLinkedQueue, LinkedBlockingQueue and ArrayBlockingQueue that could support Queue.setCapacity method to change dynamically the capacity of a queue?&nbsp; If it's not possible, could you tell me what queue implementation cannot support this feature?</DIV>
<DIV class=RTE>Thanks,<BR>Jean</DIV></div></html>


From dl@cs.oswego.edu  Sun Nov 28 23:59:32 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sun, 28 Nov 2004 18:59:32 -0500
Subject: [concurrency-interest] Queue.setCapacity
In-Reply-To: <BAY102-F195AA8895CBF16DEB2B4AE8ABC0@phx.gbl>
References: <BAY102-F195AA8895CBF16DEB2B4AE8ABC0@phx.gbl>
Message-ID: <16810.26212.645069.862182@altair.cs.oswego.edu>

> Is it possible to create classes similar to ConcurrentLinkedQueue,
> LinkedBlockingQueue and ArrayBlockingQueue that could support
> Queue.setCapacity method to change dynamically the capacity of a
> queue?

Well, I suppose anything is possible, depending on how much overhead
and recoding you are prepared to accept. Of these though, only the
implementation of LinkedBlockingQueue could be changed to allow
dynamic capacity changes without major surgery or performance
degradations. (And even this would take some hard work and would lose
some performance.)

-Doug


From osvaldo@visionnaire.com.br  Mon Nov 29 11:09:48 2004
From: osvaldo@visionnaire.com.br (Osvaldo Pinali Doederlein)
Date: Mon, 29 Nov 2004 08:09:48 -0300
Subject: [concurrency-interest] BlockingDeque and revised Deque
In-Reply-To: <41A7E6D2.9000905@peierls.net>
References: <16807.18572.932848.214817@altair.cs.oswego.edu> <b097ac5104112610575fae30ca@mail.gmail.com> <41A7E6D2.9000905@peierls.net>
Message-ID: <41AB037C.5020107@visionnaire.com.br>

Tim Peierls wrote:
> Joshua Bloch wrote:
> 
>> I wouldn't mind jamming both adapters into
>> java.util.Collections unless asLifoBlockingQueue is the first in a
>> long line.
> 
> I'm sure there will be more. I'd like to have asPutOnlyBlockingQueue
> and asTakeOnlyBlockingQueue, for starters. No, it isn't hard to roll
> your own, but it is tedious. I think it's important to have them for
> passing queues into contexts where it is impossible to guarantee that
> the recipient will observe the required protocol.
> 
> So I'm in favor of j.u.c.ConcurrentCollections, especially if a shorter
> name can be found.

With the availability of static imports, this should'n be an issue.
Just make sure that there are no conflicts (methods with identical
signatures) with java.util.Collections, so I can static-import both
in my collections-heavy sources.

A+
Osvaldo

-- 
-----------------------------------------------------------------------
Osvaldo Pinali Doederlein                   Visionnaire Informtica S/A
osvaldo@visionnaire.com.br                http://www.visionnaire.com.br
Arquiteto de Tecnologia                          +55 (41) 337-1000 #223


From Michael.Mostov@morganstanley.com  Mon Nov 29 17:06:32 2004
From: Michael.Mostov@morganstanley.com (Mostov, Michael (IT))
Date: Mon, 29 Nov 2004 12:06:32 -0500
Subject: [concurrency-interest] Improving RWLock compatibility - ownership test
Message-ID: <6E5833EB518C694A8EA8CECB41D95AEF268528@NYWEXMB28.msad.ms.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C4D635.C67A22A9
Content-Type: text/plain;
	charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

Hello everybody,=20
=20
I am new to the group and apologize if I am raising issue that has been
already discussed. =20
=20
While examining source code of Oswego package, I found that release()
method of RWLocks doesn't check whether caller thread owns the lock.
The lock is always released, even when it was acquired by other thread.
=20
I discussed this feature with a number of people and none of them seemed
to be aware of this behavior.  Finally I sent email to the author, Doug
Lea, and he explained that this check (or it's absence) is not
standardized between various RWLock implementations.  I.e. Oswego
release() doesn't check ownership at all,  while J2SE5 version checks
the ownership for the write lock, but not for read locks.
Usually the decision whether to test the lock ownership or not is driven
by performance considerations, however there are also could be certain
designs that rely on specific behavior.
=20
Hence I suggest to parameterize this behavior by adding an optional
parameter to RWLock constructor.  This will enable compatibility b/n
various lock implementations.   And as an extra benefit, having this
parameter and supporting documentation will raise programmers' awareness
of the somewhat unintuitive behavior.
=20
What do you think?
=20
-Michael=20
--------------------------------------------------------
=20
NOTICE: If received in error, please destroy and notify sender.  Sender =
does not waive confidentiality or privilege, and use is prohibited.=20
=20

------_=_NextPart_001_01C4D635.C67A22A9
Content-Type: text/html;
	charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

<HTML xmlns:eXclaimer=3D"http://www.exclaimer.co.uk">
<HEAD>
<META http-equiv=3D"Content-Type" content=3D"text/html; =
charset=3DUTF-16">
<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3DUTF-16">
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Dus-ascii">
<META content=3D"MSHTML 6.00.2800.1477" name=3DGENERATOR></HEAD><BODY =
><DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D779112916-29112004>Hello =
everybody,=20
</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D779112916-29112004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D779112916-29112004>I am =
new to the=20
group and apologize if&nbsp;I am raising issue that has been already=20
discussed.&nbsp; </SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D779112916-29112004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D779112916-29112004>While =
examining=20
source code of Oswego package, I found that release() method&nbsp;of =
RWLocks=20
doesn't check whether caller thread owns the lock.&nbsp; The lock is =
always=20
released, even when it was acquired by other thread.</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D779112916-29112004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D779112916-29112004>I =
discussed this=20
feature with a number of people and none of them seemed to be aware of =
this=20
behavior.&nbsp; Finally I sent email to the author, Doug Lea, and he =
explained=20
that this&nbsp;check (or it's absence)&nbsp;is not standardized between =
various=20
RWLock implementations.&nbsp; I.e. Oswego release() doesn't check =
ownership at=20
all,&nbsp;&nbsp;while J2SE5 version checks the ownership for the write =
lock, but=20
not for read locks.</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN =
class=3D779112916-29112004>Usually&nbsp;the=20
decision whether to test the lock ownership or not is driven =
by&nbsp;performance=20
considerations, however there are also could be certain designs that =
rely on=20
specific behavior.</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D779112916-29112004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D779112916-29112004>Hence=20
I&nbsp;suggest&nbsp;to&nbsp;parameterize this behavior by adding an =
optional=20
parameter to RWLock constructor.&nbsp; This will enable compatibility =
b/n=20
various lock implementations.&nbsp;&nbsp;&nbsp;And as an extra=20
benefit</SPAN></FONT><FONT face=3DArial size=3D2><SPAN =
class=3D779112916-29112004>,=20
having this parameter and supporting documentation will raise =
programmers'=20
awareness of the somewhat unintuitive&nbsp;behavior.</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D779112916-29112004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D779112916-29112004>What =
do you=20
think?</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D779112916-29112004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D779112916-29112004>-Michael</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D779112916-29112004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D779112916-29112004></SPAN></FONT>&nbsp;</DIV></DIV>
<DIV>
<HR>
</DIV>
<DIV>
<P CLASS=3D"BulletedList" STYLE=3D"MARGIN: 0in 0in 0pt; TEXT-INDENT: =
0in; mso-list: none; tab-stops: .5in"><SPAN STYLE=3D"FONT-SIZE: 8pt; =
COLOR: gray; mso-bidi-font-family: Arial"><FONT FACE=3D"Arial">NOTICE: =
If received in error, please destroy and notify sender.<SPAN =
STYLE=3D"mso-spacerun: yes">  </SPAN>Sender does not waive =
confidentiality or privilege, and use is prohibited.</FONT></SPAN></P>
</DIV></BODY></HTML>

------_=_NextPart_001_01C4D635.C67A22A9--

From larryr@saturn.sdsu.edu  Mon Nov 29 18:58:53 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 29 Nov 2004 18:58:53 -0000
Subject: [concurrency-interest] Re: Improving RWLock compatibility - ownership test
In-Reply-To: <6E5833EB518C694A8EA8CECB41D95AEF268528@NYWEXMB28.msad.ms.com>
Message-ID: <20041129185853.12773.qmail@home19.riedel.org>

> release() method of RWLocks doesn't check whether caller thread
> owns the lock.  The lock is always released, even when it was
> acquired by other thread. [...] I suggest to parameterize this
> behavior by adding an optional parameter to RWLock constructor.

I would like that, and/or a different class, and/or different
(public) methods (one which checks and one which does not).
In any case I think it should not be an implementation detail.
If there will be no choice, I prefer the method does verify
the owner, presuming that can be done extremely quickly.


Larry


From dawidk@mathcs.emory.edu  Mon Nov 29 20:13:13 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Mon, 29 Nov 2004 15:13:13 -0500
Subject: [concurrency-interest] Re: Improving RWLock compatibility - ownership
 test
In-Reply-To: <20041129185853.12773.qmail@home19.riedel.org>
References: <20041129185853.12773.qmail@home19.riedel.org>
Message-ID: <41AB82D9.6060103@mathcs.emory.edu>

Larry Riedel wrote:

>>release() method of RWLocks doesn't check whether caller thread
>>owns the lock.  The lock is always released, even when it was
>>acquired by other thread. [...] I suggest to parameterize this
>>behavior by adding an optional parameter to RWLock constructor.
>>    
>>
>
>I would like that, and/or a different class, and/or different
>(public) methods (one which checks and one which does not).
>In any case I think it should not be an implementation detail.
>If there will be no choice, I prefer the method does verify
>the owner, presuming that can be done extremely quickly.
>  
>
I once asked about things along these lines; Doug Lea responded that 
historically, locks in dl.u.c. did not perform such checks, but the 
expert group decided that the locks in 1.5 should do that (it is a 
rather cheap operation), and they do. This new behavior is not being 
back-ported to dl.u.c. due to 1) fear of breaking compatibility with 
custom subclasses of these locks that people may have written, and 2) 
nothing really is being backported to dl.u.c. to encourage use of Java 1.5.

If you want this functionality in 1.4, I suggest you may want to check 
out the following faithful backport of java.util.concurrent to Java 1.4, 
currently available at:

http://www.mathcs.emory.edu/dcl/util/util-concurrent.jar (binaries)
http://www.mathcs.emory.edu/dcl/util/util-concurrent-src.jar (source code)
http://www.mathcs.emory.edu/dcl/util/util-concurrent-doc.jar (javadoc)

The proper Web page for this backport is in preparation. Some more 
details can be found in my earlier posting to the list, dated on 9/17/2004.

Regards,
Dawid


From larryr@saturn.sdsu.edu  Mon Nov 29 23:42:15 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 29 Nov 2004 23:42:15 -0000
Subject: [concurrency-interest] Re: Re: Improving RWLock compatibility - ownership test
In-Reply-To: <41AB82D9.6060103@mathcs.emory.edu>
Message-ID: <20041129234215.15669.qmail@home19.riedel.org>

> > I think it should not be an implementation detail.
> > If there will be no choice, I prefer the method does verify
> > the owner, presuming that can be done extremely quickly.
> 
> historically, locks in dl.u.c. did not perform such checks,
> but the expert group decided that the locks in 1.5 should
> do that (it is a rather cheap operation), and they do.

I prefer java.util.concurrent.locks.Lock specify the behavior
of unlock() in this regard, instead of leaving it undefined.
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock
implements Lock, and its 1.5.0 documentation does not seem
to say what the behavior of its unlock is.  Ideally (for me)
I could just use a Lock reference and know unlock() will
check ownership for me, because the interface says it must.


Larry


From dl@cs.oswego.edu  Tue Nov 30 00:21:35 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 29 Nov 2004 19:21:35 -0500
Subject: [concurrency-interest] Re: Re: Improving RWLock compatibility - ownership test
In-Reply-To: <20041129234215.15669.qmail@home19.riedel.org>
References: <41AB82D9.6060103@mathcs.emory.edu>
 <20041129234215.15669.qmail@home19.riedel.org>
Message-ID: <16811.48399.153637.267404@altair.cs.oswego.edu>

Larry Riedel:

> I prefer java.util.concurrent.locks.Lock specify the behavior
> of unlock() in this regard, instead of leaving it undefined.

Sorry. No can do. Some kinds of locks have a notion of ownership, and
some do not. Normally, read-locks do not (but see below). In a lock
without any notion of ownership, it is legal for one thread to unlock
on behalf of another. Sometimes this is desirable.  To express this,
we had to either create a subinterface, say OwnedLock, or require that
each implementation describe its policy. We chose the latter.

> java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock
> implements Lock, and its 1.5.0 documentation does not seem
> to say what the behavior of its unlock is.  

Please see the class doc for ReentrantReadWriteLock, near the end:

 Implementation Notes
  A reentrant write lock intrinsically defines an owner and can only
  be released by the thread that acquired it. In contrast, in this
  implementation, the read lock has no concept of ownership, and there
  is no requirement that the thread releasing a read lock is the same
  as the one that acquired it. However, this property is not
  guaranteed to hold in future implementations of this class.

And then compare the documentation for 
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.unlock
to
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.unlock

Michael Mostov:

> Hence I suggest to parameterize this behavior by adding an optional
> parameter to RWLock constructor.

Thanks for the suggestion. This is probably supportable.  And as
mentioned above, we made room for this possible change in the spec,
knowing that this issue would arise. We'll look into it.  Checks for
read-holds are intrinsically expensive though, so would slow down
performance by, I'd guess, around a factor of 3. So users would need
to think hard about whether they really needed them.  (For the
curious, the most likely implementation plan is to make yet more
internal AQS classes that are attached to in constructors, and in
which there is a per-lock (not static) ThreadLocal maintaining and
checking per-thread read lock counts.)

-Doug

From larryr@saturn.sdsu.edu  Tue Nov 30 01:35:28 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 30 Nov 2004 01:35:28 -0000
Subject: [concurrency-interest] Re: Improving RWLock compatibility - ownership test
In-Reply-To: <16811.48399.153637.267404@altair.cs.oswego.edu>
Message-ID: <20041130013528.16899.qmail@home19.riedel.org>

> > I prefer java.util.concurrent.locks.Lock specify the behavior
> > of unlock() in this regard, instead of leaving it undefined.
> 
> Sorry. No can do. Some kinds of locks have a notion of ownership,
> and some do not.

Indeed, the notion of "lock" can be defined broadly enough to
include such a plethora of non-orthogonal semantics that a
reference to a "Lock" is effectively useless without knowledge
of the semantics of the class of the referenced object instance.


Larry


From tim@peierls.net  Tue Nov 30 13:04:26 2004
From: tim@peierls.net (Tim Peierls)
Date: Tue, 30 Nov 2004 08:04:26 -0500
Subject: [concurrency-interest] Re: Improving RWLock compatibility -
 ownership test
In-Reply-To: <20041130013528.16899.qmail@home19.riedel.org>
References: <20041130013528.16899.qmail@home19.riedel.org>
Message-ID: <41AC6FDA.5050609@peierls.net>

Larry Riedel wrote:
> Indeed, the notion of "lock" can be defined broadly enough to
> include such a plethora of non-orthogonal semantics that a
> reference to a "Lock" is effectively useless without knowledge
> of the semantics of the class of the referenced object instance.

Yeah, that Lock interface is practically useless. Let's get rid
of it. While we're at it, has anyone noticed just how little the
List interface contributes? The semantics of ArrayList and LinkedList
are worlds apart, and yet those "experts" keep telling us to gloss
over the difference with that vacuous interface.

That's the great thing about concrete types: you know what you're
getting all the time, and you don't have to worry that some fool
has changed the implementation (and subtle semantics) on you.
Decoupling, shmecoupling.

</sarcasm>

Sheesh.

--tim


From larryr@saturn.sdsu.edu  Tue Nov 30 16:57:39 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 30 Nov 2004 16:57:39 -0000
Subject: [concurrency-interest] Re: Improving RWLock compatibility - ownership test
In-Reply-To: <41AC6FDA.5050609@peierls.net>
Message-ID: <20041130165739.25265.qmail@home19.riedel.org>

> > Indeed, the notion of "lock" can be defined broadly enough to
> > include such a plethora of non-orthogonal semantics that a
> > reference to a "Lock" is effectively useless without knowledge
> > of the semantics of the class of the referenced object instance.
> 
> Yeah, that Lock interface is practically useless. Let's get rid
> of it. While we're at it, has anyone noticed just how little the
> List interface contributes? The semantics of ArrayList and LinkedList
> are worlds apart, and yet those "experts" keep telling us to gloss
> over the difference with that vacuous interface.

I would agree that to the extent a commonly used operation in
the List interface has qualitative behavior exposed to the
user of that operation which is naively unpredictable without
knowledge of the implementing class, but naively predictable
with that knowledge, it might be worthwhile to add a new
operation to the List interface, add a new interface, or more
precisely specify the behavior of the operation in the interface
rather than leaving it to the implementing class to define.


> That's the great thing about concrete types: you know what you're
> getting all the time, and you don't have to worry that some fool
> has changed the implementation (and subtle semantics) on you.

I would agree that if a method implementation depends on (expects)
semantics of a class which are left unspecified in an interface
that class implements, it may be preferable for the method to use
a reference to the implementing class rather than to the interface.


Larry


From dbuttignol@virgilio.it  Tue Nov 30 17:06:30 2004
From: dbuttignol@virgilio.it (Denise Buttignol)
Date: Tue, 30 Nov 2004 18:06:30 +0100
Subject: [concurrency-interest] help on concurrent
Message-ID: <415381E70009DF97@ims5b.cp.tin.it>

Hi, 

I am using the package on concurrent specially these two classes:

import EDU.oswego.cs.dl.util.concurrent.LinkedQueue;
import EDU.oswego.cs.dl.util.concurrent.PooledExecutor;


in which I am trying to solve the  problem:

I have  a classe java or a set of class java with different methods,  and
I would like to execute  them on special order.  I am trying to do this
job using the two classes above an
using invoke method. What is the rigth way to do this?  


Thanks in advance for your help, 

Denise 

 






