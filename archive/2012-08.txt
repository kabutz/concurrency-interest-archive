From phil at philharveyonline.com  Wed Aug  1 09:20:52 2012
From: phil at philharveyonline.com (Phil Harvey)
Date: Wed, 1 Aug 2012 14:20:52 +0100
Subject: [concurrency-interest] ReentrantReadWriteLock in inconsistent state
Message-ID: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>

We had a deadlock-like failure of our application recently.

I initially reported it on the BDB JE forum (
https://forums.oracle.com/forums/thread.jspa?messageID=10480988) but
further analysis of the heap and thread dumps has exposed a problem that
looks like a Java locking bug. I'm hoping you can offer advice on whether
this is the case.

We?re using Oracle JVM 1.6.0_25-b06, running on Linux version:
2.6.18-194.32.1.el5.

We are launching Java as follows: java -server -XX:+UseConcMarkSweepGC
-XX:+HeapDumpOnOutOfMemoryError -Xmx1024m ...

Several consecutive thread dumps showed that Thread t at 41101 was blocked
indefinitely in ReentrantReadWriteLock. writeLock().lock().

We know from code inspection that nothing ever takes a read lock on this
ReentrantReadWriteLock, so started trying to find out what has got its
write lock.

The output of "jstack -l" should list which thread holds this exclusive
lock in the "locked ownable synchronizers" section but does not.

Our first theory was that the owning thread might have terminated.

We wrote a simple test program to explore this. We found from heap dump
analysis that even if the owning thread terminates, the lock itself still
refers to it via the ReentrantReadWriteLock.WriteLock.sync.
exclusiveOwnerThread field. Looking in the java.util.concurrent source
code, it seems that this field only gets null'ed when the lock is released.

However, looking in the heap dump taken following our "deadlock", we were
surprised to find that the lock in question has a null
sync.exclusiveOwnerThread field.

Surely a write lock should be in one of two states (except possibly for a
tiny instant when its state is being non-atomically switched):

1) The lock is available, and sync.exclusiveOwnerThread is null 2) The lock
is unavailable, and sync.exclusiveOwnerThread is populated

But our lock was indefinitely in this state:

3) The lock is unavailable and sync.exclusiveOwnerThread is null

Does anyone know whether this represents a bug? If not, can you explain
what it means for a lock to be in this counterintuitive state?

Thanks, Phil
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120801/027236cf/attachment.html>

From viktor.klang at gmail.com  Wed Aug  1 09:27:30 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 1 Aug 2012 15:27:30 +0200
Subject: [concurrency-interest] ReentrantReadWriteLock in inconsistent
	state
In-Reply-To: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
Message-ID: <CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>

Hi Phil,

Related to this?
http://bugs.sun.com/view_bug.do?bug_id=6822370

Cheers,
?

On Wed, Aug 1, 2012 at 3:20 PM, Phil Harvey <phil at philharveyonline.com>wrote:

> We had a deadlock-like failure of our application recently.
>
> I initially reported it on the BDB JE forum (
> https://forums.oracle.com/forums/thread.jspa?messageID=10480988) but
> further analysis of the heap and thread dumps has exposed a problem that
> looks like a Java locking bug. I'm hoping you can offer advice on whether
> this is the case.
>
> We?re using Oracle JVM 1.6.0_25-b06, running on Linux version:
> 2.6.18-194.32.1.el5.
>
> We are launching Java as follows: java -server -XX:+UseConcMarkSweepGC
> -XX:+HeapDumpOnOutOfMemoryError -Xmx1024m ...
>
> Several consecutive thread dumps showed that Thread t at 41101 was blocked
> indefinitely in ReentrantReadWriteLock. writeLock().lock().
>
> We know from code inspection that nothing ever takes a read lock on this
> ReentrantReadWriteLock, so started trying to find out what has got its
> write lock.
>
> The output of "jstack -l" should list which thread holds this exclusive
> lock in the "locked ownable synchronizers" section but does not.
>
> Our first theory was that the owning thread might have terminated.
>
> We wrote a simple test program to explore this. We found from heap dump
> analysis that even if the owning thread terminates, the lock itself still
> refers to it via the ReentrantReadWriteLock.WriteLock.sync.
> exclusiveOwnerThread field. Looking in the java.util.concurrent source
> code, it seems that this field only gets null'ed when the lock is released.
>
> However, looking in the heap dump taken following our "deadlock", we were
> surprised to find that the lock in question has a null
> sync.exclusiveOwnerThread field.
>
> Surely a write lock should be in one of two states (except possibly for a
> tiny instant when its state is being non-atomically switched):
>
> 1) The lock is available, and sync.exclusiveOwnerThread is null 2) The
> lock is unavailable, and sync.exclusiveOwnerThread is populated
>
> But our lock was indefinitely in this state:
>
> 3) The lock is unavailable and sync.exclusiveOwnerThread is null
>
> Does anyone know whether this represents a bug? If not, can you explain
> what it means for a lock to be in this counterintuitive state?
>
> Thanks, Phil
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120801/4dbc69ab/attachment.html>

From ariel at weisberg.ws  Wed Aug  1 10:04:58 2012
From: ariel at weisberg.ws (Ariel Weisberg)
Date: Wed, 01 Aug 2012 10:04:58 -0400
Subject: [concurrency-interest]
 =?iso-8859-1?q?ReentrantReadWriteLock_in_i?=
 =?iso-8859-1?q?nconsistent=09state?=
In-Reply-To: <CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
	<CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>
Message-ID: <1343829898.7338.140661109359821.57929FF4@webmail.messagingengine.com>

Hi,

I remember that. That was fixed Oracle JDK 1.6.0_18. It hasn't been
reproducing for us since 1.6.0_18, but I am not sure if we are using
ReentrantLock in the same way anymore.

The reproducer we used
was [1]https://github.com/VoltDB/voltdb/tree/master/tools/lbd_lock_test
If I remember correctly it prints '.' as it goes and when it hangs it
stops printing dots.

Regards,
Ariel

On Wed, Aug 1, 2012, at 09:27 AM, ?iktor ?lang wrote:

Hi Phil,



  Related to this?

[2]http://bugs.sun.com/view_bug.do?bug_id=6822370


Cheers,
?
On Wed, Aug 1, 2012 at 3:20 PM, Phil Harvey
<[3]phil at philharveyonline.com> wrote:

  We had a deadlock-like failure of our application recently.

  I initially reported it on the BDB JE forum (
  [4]https://forums.oracle.com/forums/thread.jspa?messageID=10480988)
  but further analysis of the heap and thread dumps has exposed a
  problem that looks like a Java locking bug. I'm hoping you can offer
  advice on whether this is the case.

  We?re using Oracle JVM 1.6.0_25-b06, running on Linux version:
  2.6.18-194.32.1.el5.

  We are launching Java as follows: java -server
  -XX:+UseConcMarkSweepGC -XX:+HeapDumpOnOutOfMemoryError -Xmx1024m
  ...

  Several consecutive thread dumps showed that Thread t at 41101 was
  blocked indefinitely in ReentrantReadWriteLock. writeLock().lock().

  We know from code inspection that nothing ever takes a read lock on
  this ReentrantReadWriteLock, so started trying to find out what has
  got its write lock.

  The output of "jstack -l" should list which thread holds this
  exclusive lock in the "locked ownable synchronizers" section but
  does not.

  Our first theory was that the owning thread might have terminated.

  We wrote a simple test program to explore this. We found from heap
  dump analysis that even if the owning thread terminates, the lock
  itself still refers to it via the
  ReentrantReadWriteLock.WriteLock.sync. exclusiveOwnerThread field.
  Looking in the java.util.concurrent source code, it seems that this
  field only gets null'ed when the lock is released.

  However, looking in the heap dump taken following our "deadlock", we
  were surprised to find that the lock in question has a null
  sync.exclusiveOwnerThread field.

  Surely a write lock should be in one of two states (except possibly
  for a tiny instant when its state is being non-atomically switched):

  1) The lock is available, and sync.exclusiveOwnerThread is null 2)
  The lock is unavailable, and sync.exclusiveOwnerThread is populated

  But our lock was indefinitely in this state:

  3) The lock is unavailable and sync.exclusiveOwnerThread is null

  Does anyone know whether this represents a bug? If not, can you
  explain what it means for a lock to be in this counterintuitive
  state?

  Thanks, Phil
  _______________________________________________
  Concurrency-interest mailing list
  [5]Concurrency-interest at cs.oswego.edu
  [6]http://cs.oswego.edu/mailman/listinfo/concurrency-interest



--
Viktor Klang
Akka Tech Lead
[7]Typesafe - The software stack for applications that scale
Twitter: @viktorklang

_______________________________________________

Concurrency-interest mailing list

[8]Concurrency-interest at cs.oswego.edu

[9]http://cs.oswego.edu/mailman/listinfo/concurrency-interest

References

1. https://github.com/VoltDB/voltdb/tree/master/tools/lbd_lock_test
2. http://bugs.sun.com/view_bug.do?bug_id=6822370
3. mailto:phil at philharveyonline.com
4. https://forums.oracle.com/forums/thread.jspa?messageID=10480988
5. mailto:Concurrency-interest at cs.oswego.edu
6. http://cs.oswego.edu/mailman/listinfo/concurrency-interest
7. http://www.typesafe.com/
8. mailto:Concurrency-interest at cs.oswego.edu
9. http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120801/532435a7/attachment-0001.html>

From gregg at cytetech.com  Wed Aug  1 10:09:27 2012
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 01 Aug 2012 09:09:27 -0500
Subject: [concurrency-interest] ReentrantReadWriteLock in inconsistent
 state
In-Reply-To: <CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
	<CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>
Message-ID: <50193897.1000208@cytetech.com>

One of the comments hints at an order of instructions issue where the head can 
be replaced, without being configured for wakeup to work.  Then, inbetween 
instructions for linking and then setting the wakeup state, a wakeup might find 
the head not ready for wakeup?

A long long time ago, in Java1.3, I encountered a wakeup problem with 
Object.wait() and Object.notify() in one of my applications, and just started 
using Object.wait(long) instead.  That's a pretty dependable way to manage 
notification/wakeup issues so that bugs from all ends of the spectrum don't 
result in loss of services.   Of course, using some instrumentation at that 
point, to log that you had wait (count retries) longer than expected, can help 
track down bugs which actually result in undesirable pauses.

Gregg Wonderly

On 8/1/2012 8:27 AM, ?iktor ?lang wrote:
> Hi Phil,
>
> Related to this?
> http://bugs.sun.com/view_bug.do?bug_id=6822370
>
> Cheers,
> ?
>
> On Wed, Aug 1, 2012 at 3:20 PM, Phil Harvey <phil at philharveyonline.com
> <mailto:phil at philharveyonline.com>> wrote:
>
>     We had a deadlock-like failure of our application recently.
>
>     I initially reported it on the BDB JE forum (
>     https://forums.oracle.com/forums/thread.jspa?messageID=10480988) but further
>     analysis of the heap and thread dumps has exposed a problem that looks like
>     a Java locking bug. I'm hoping you can offer advice on whether this is the case.
>
>     We?re using Oracle JVM 1.6.0_25-b06, running on Linux version:
>     2.6.18-194.32.1.el5.
>
>     We are launching Java as follows: java -server -XX:+UseConcMarkSweepGC
>     -XX:+HeapDumpOnOutOfMemoryError -Xmx1024m ...
>
>     Several consecutive thread dumps showed that Thread t at 41101 was blocked
>     indefinitely in ReentrantReadWriteLock. writeLock().lock().
>
>     We know from code inspection that nothing ever takes a read lock on this
>     ReentrantReadWriteLock, so started trying to find out what has got its write
>     lock.
>
>     The output of "jstack -l" should list which thread holds this exclusive lock
>     in the "locked ownable synchronizers" section but does not.
>
>     Our first theory was that the owning thread might have terminated.
>
>     We wrote a simple test program to explore this. We found from heap dump
>     analysis that even if the owning thread terminates, the lock itself still
>     refers to it via the ReentrantReadWriteLock.WriteLock.sync.
>     exclusiveOwnerThread field. Looking in the java.util.concurrent source code,
>     it seems that this field only gets null'ed when the lock is released.
>
>     However, looking in the heap dump taken following our "deadlock", we were
>     surprised to find that the lock in question has a null
>     sync.exclusiveOwnerThread field.
>
>     Surely a write lock should be in one of two states (except possibly for a
>     tiny instant when its state is being non-atomically switched):
>
>     1) The lock is available, and sync.exclusiveOwnerThread is null 2) The lock
>     is unavailable, and sync.exclusiveOwnerThread is populated
>
>     But our lock was indefinitely in this state:
>
>     3) The lock is unavailable and sync.exclusiveOwnerThread is null
>
>     Does anyone know whether this represents a bug? If not, can you explain what
>     it means for a lock to be in this counterintuitive state?
>
>     Thanks, Phil
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> --
> Viktor Klang
>
> Akka Tech Lead
> Typesafe <http://www.typesafe.com/>- The software stack for applications that scale
>
> Twitter: @viktorklang
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From stanimir at riflexo.com  Wed Aug  1 11:14:35 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Wed, 1 Aug 2012 18:14:35 +0300
Subject: [concurrency-interest] ReentrantReadWriteLock in inconsistent
	state
In-Reply-To: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
Message-ID: <CAEJX8oquzp4zV5XbOVQFAy1rXYks1U4cLokY9eG4BAZEqWvT4g@mail.gmail.com>

The usual case for that is... Thread.stop().
        protected final boolean tryRelease(int releases) {
.....
                setExclusiveOwnerThread(null);
---right here---
                setState(nextc);
....
                return true;
}

Cheers
Stanimir
On Wed, Aug 1, 2012 at 4:20 PM, Phil Harvey <phil at philharveyonline.com>wrote:

> We had a deadlock-like failure of our application recently.
>
> I initially reported it on the BDB JE forum (
> https://forums.oracle.com/forums/thread.jspa?messageID=10480988) but
> further analysis of the heap and thread dumps has exposed a problem that
> looks like a Java locking bug. I'm hoping you can offer advice on whether
> this is the case.
>
> We?re using Oracle JVM 1.6.0_25-b06, running on Linux version:
> 2.6.18-194.32.1.el5.
>
> We are launching Java as follows: java -server -XX:+UseConcMarkSweepGC
> -XX:+HeapDumpOnOutOfMemoryError -Xmx1024m ...
>
> Several consecutive thread dumps showed that Thread t at 41101 was blocked
> indefinitely in ReentrantReadWriteLock. writeLock().lock().
>
> We know from code inspection that nothing ever takes a read lock on this
> ReentrantReadWriteLock, so started trying to find out what has got its
> write lock.
>
> The output of "jstack -l" should list which thread holds this exclusive
> lock in the "locked ownable synchronizers" section but does not.
>
> Our first theory was that the owning thread might have terminated.
>
> We wrote a simple test program to explore this. We found from heap dump
> analysis that even if the owning thread terminates, the lock itself still
> refers to it via the ReentrantReadWriteLock.WriteLock.sync.
> exclusiveOwnerThread field. Looking in the java.util.concurrent source
> code, it seems that this field only gets null'ed when the lock is released.
>
> However, looking in the heap dump taken following our "deadlock", we were
> surprised to find that the lock in question has a null
> sync.exclusiveOwnerThread field.
>
> Surely a write lock should be in one of two states (except possibly for a
> tiny instant when its state is being non-atomically switched):
>
> 1) The lock is available, and sync.exclusiveOwnerThread is null 2) The
> lock is unavailable, and sync.exclusiveOwnerThread is populated
>
> But our lock was indefinitely in this state:
>
> 3) The lock is unavailable and sync.exclusiveOwnerThread is null
>
> Does anyone know whether this represents a bug? If not, can you explain
> what it means for a lock to be in this counterintuitive state?
>
> Thanks, Phil
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120801/b3302cce/attachment.html>

From raphfrk at gmail.com  Wed Aug  1 11:24:38 2012
From: raphfrk at gmail.com (Raph Frank)
Date: Wed, 1 Aug 2012 16:24:38 +0100
Subject: [concurrency-interest] Elements in AtomicReferenceArray and
	AtomicReference[] both distinct?
Message-ID: <CAN1xFdrQdczwXFyUQxQRQd_5f34VCZGF+TUU0g3ALeT8Rio57g@mail.gmail.com>

I always assumed that elements in an AtomicReferenceArray were
distinct.  Threads that accessed different elements would not
interfere.

This thread suggests otherwise, that the protection is at the entire
array level.

http://www.java-forums.org/threads-synchronization/25324-atomicreferencearray-t-equivalent-array-atomicreference-t.html

Which is correct, do an array of AtomicReferences give better concurrency?

From phil at philharveyonline.com  Wed Aug  1 11:25:08 2012
From: phil at philharveyonline.com (Phil Harvey)
Date: Wed, 1 Aug 2012 16:25:08 +0100
Subject: [concurrency-interest] ReentrantReadWriteLock in inconsistent
	state
In-Reply-To: <1343829898.7338.140661109359821.57929FF4@webmail.messagingengine.com>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
	<CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>
	<1343829898.7338.140661109359821.57929FF4@webmail.messagingengine.com>
Message-ID: <CAG44Fj0SRwkL9Av9bekhzv+Sv4En-17-azZ1Fh=EyjZMAASfFQ@mail.gmail.com>

Hi,

Yes, we had looked at that bug but assumed we were not experiencing it here
because we are using Java 1.6.0_25, and it was reported fixed in 1.6.0_18.

Do you agree that the unusual state of the ReentrantReadWriteLock suggests
we've hit a bug?

Phil
On Aug 1, 2012 3:05 PM, "Ariel Weisberg" <ariel at weisberg.ws> wrote:

>   Hi,
>
>  I remember that. That was fixed Oracle JDK 1.6.0_18. It hasn't been
> reproducing for us since 1.6.0_18, but I am not sure if we are using
> ReentrantLock in the same way anymore.
>
>  The reproducer we used was
> https://github.com/VoltDB/voltdb/tree/master/tools/lbd_lock_test
>  If I remember correctly it prints '.' as it goes and when it hangs it
> stops printing dots.
>
>  Regards,
>  Ariel
>
>  On Wed, Aug 1, 2012, at 09:27 AM, ?iktor ?lang wrote:
>
>  Hi Phil,
>
> Related to this?
> http://bugs.sun.com/view_bug.do?bug_id=6822370
>
>  Cheers,
>  ?
>
>  On Wed, Aug 1, 2012 at 3:20 PM, Phil Harvey <phil at philharveyonline.com>wrote:
>
>  We had a deadlock-like failure of our application recently.
>
> I initially reported it on the BDB JE forum (
> https://forums.oracle.com/forums/thread.jspa?messageID=10480988) but
> further analysis of the heap and thread dumps has exposed a problem that
> looks like a Java locking bug. I'm hoping you can offer advice on whether
> this is the case.
>
> We?re using Oracle JVM 1.6.0_25-b06, running on Linux version:
> 2.6.18-194.32.1.el5.
>
> We are launching Java as follows: java -server -XX:+UseConcMarkSweepGC
> -XX:+HeapDumpOnOutOfMemoryError -Xmx1024m ...
>
> Several consecutive thread dumps showed that Thread t at 41101 was blocked
> indefinitely in ReentrantReadWriteLock. writeLock().lock().
>
> We know from code inspection that nothing ever takes a read lock on this
> ReentrantReadWriteLock, so started trying to find out what has got its
> write lock.
>
> The output of "jstack -l" should list which thread holds this exclusive
> lock in the "locked ownable synchronizers" section but does not.
>
> Our first theory was that the owning thread might have terminated.
>
> We wrote a simple test program to explore this. We found from heap dump
> analysis that even if the owning thread terminates, the lock itself still
> refers to it via the ReentrantReadWriteLock.WriteLock.sync.
> exclusiveOwnerThread field. Looking in the java.util.concurrent source
> code, it seems that this field only gets null'ed when the lock is released.
>
> However, looking in the heap dump taken following our "deadlock", we were
> surprised to find that the lock in question has a null
> sync.exclusiveOwnerThread field.
>
> Surely a write lock should be in one of two states (except possibly for a
> tiny instant when its state is being non-atomically switched):
>
> 1) The lock is available, and sync.exclusiveOwnerThread is null 2) The
> lock is unavailable, and sync.exclusiveOwnerThread is populated
>
> But our lock was indefinitely in this state:
>
> 3) The lock is unavailable and sync.exclusiveOwnerThread is null
>
> Does anyone know whether this represents a bug? If not, can you explain
> what it means for a lock to be in this counterintuitive state?
>
> Thanks, Phil
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> --
> Viktor Klang
>
> Akka Tech Lead
> Typesafe <http://www.typesafe.com/> - The software stack for applications
> that scale
>
> Twitter: @viktorklang
>   *_______________________________________________*
>  Concurrency-interest mailing list
>  Concurrency-interest at cs.oswego.edu
>  http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120801/4ee33b5f/attachment-0001.html>

From stanimir at riflexo.com  Wed Aug  1 12:02:28 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Wed, 1 Aug 2012 19:02:28 +0300
Subject: [concurrency-interest] Elements in AtomicReferenceArray and
 AtomicReference[] both distinct?
In-Reply-To: <CAN1xFdrQdczwXFyUQxQRQd_5f34VCZGF+TUU0g3ALeT8Rio57g@mail.gmail.com>
References: <CAN1xFdrQdczwXFyUQxQRQd_5f34VCZGF+TUU0g3ALeT8Rio57g@mail.gmail.com>
Message-ID: <CAEJX8op9D6bRMUtYBUZ0jt9w-fFXEh3chOjWDOPZKmP83PnFHw@mail.gmail.com>

Due to cache-coherency writing to an element would have effects on the
nearby elements too. It's called "false sharing":
http://en.wikipedia.org/wiki/False_sharing
[Write] Sharing (false or not) kills concurrency.
However there is no locking and the access to distinctive elements is
atomic.

Stanimir

On Wed, Aug 1, 2012 at 6:24 PM, Raph Frank <raphfrk at gmail.com> wrote:

> I always assumed that elements in an AtomicReferenceArray were
> distinct.  Threads that accessed different elements would not
> interfere.
>
> This thread suggests otherwise, that the protection is at the entire
> array level.
>
>
> http://www.java-forums.org/threads-synchronization/25324-atomicreferencearray-t-equivalent-array-atomicreference-t.html
>
> Which is correct, do an array of AtomicReferences give better concurrency?
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120801/8a2ded78/attachment.html>

From mr.chrisvest at gmail.com  Wed Aug  1 12:03:42 2012
From: mr.chrisvest at gmail.com (Chris Vest)
Date: Wed, 1 Aug 2012 18:03:42 +0200
Subject: [concurrency-interest] Elements in AtomicReferenceArray and
 AtomicReference[] both distinct?
In-Reply-To: <CAN1xFdrQdczwXFyUQxQRQd_5f34VCZGF+TUU0g3ALeT8Rio57g@mail.gmail.com>
References: <CAN1xFdrQdczwXFyUQxQRQd_5f34VCZGF+TUU0g3ALeT8Rio57g@mail.gmail.com>
Message-ID: <CAHXi_0c0u2oCq1VDYmODVH88GFFbJsnT1DiBm-kVgqrH6CRmcQ@mail.gmail.com>

Hi Raph,

You are more likely to run into false sharing (cache-line contention) with
AtomicReferenceArray, when threads concurrently write to element indices
that are close to each other, than you are with an array of AtomicReference
objects. On the other hand, the latter uses more memory.

The implementation of ARA does not use locks:
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/atomic/AtomicReferenceArray.java?revision=1.42&view=markup


On 1 August 2012 17:24, Raph Frank <raphfrk at gmail.com> wrote:

> I always assumed that elements in an AtomicReferenceArray were
> distinct.  Threads that accessed different elements would not
> interfere.
>
> This thread suggests otherwise, that the protection is at the entire
> array level.
>
>
> http://www.java-forums.org/threads-synchronization/25324-atomicreferencearray-t-equivalent-array-atomicreference-t.html
>
> Which is correct, do an array of AtomicReferences give better concurrency?
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120801/980808be/attachment.html>

From davidcholmes at aapt.net.au  Wed Aug  1 22:41:59 2012
From: davidcholmes at aapt.net.au (davidcholmes at aapt.net.au)
Date: Thu, 02 Aug 2012 12:41:59 +1000
Subject: [concurrency-interest] Elements in AtomicReferenceArray
	and	AtomicReference[] both distinct?
In-Reply-To: <CAN1xFdrQdczwXFyUQxQRQd_5f34VCZGF+TUU0g3ALeT8Rio57g@mail.gmail.com>
References: <CAN1xFdrQdczwXFyUQxQRQd_5f34VCZGF+TUU0g3ALeT8Rio57g@mail.gmail.com>
Message-ID: <20120802124159.p2c8z41xc0gssok0@getonline.aapt.com.au>

There's a huge amount of idle speculation and erroneous reading in  
that thread. "Doug Lea's code" is the BACKPORT implementation of  
j.u.c. The backport is for pre-Java 5 system on which there is no  
direct support for atomic operations - which is what Unsafe provides  
through the VM.

There is NO locking involved in Java 5+ AtomicReferenceArray - atomic  
operations (using hardware level atomic instructions) are done per  
element.

David Holmes

Quoting Raph Frank <raphfrk at gmail.com>:

> I always assumed that elements in an AtomicReferenceArray were
> distinct.  Threads that accessed different elements would not
> interfere.
>
> This thread suggests otherwise, that the protection is at the entire
> array level.
>
> http://www.java-forums.org/threads-synchronization/25324-atomicreferencearray-t-equivalent-array-atomicreference-t.html
>
> Which is correct, do an array of AtomicReferences give better concurrency?
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>





From davidcholmes at aapt.net.au  Wed Aug  1 22:56:07 2012
From: davidcholmes at aapt.net.au (davidcholmes at aapt.net.au)
Date: Thu, 02 Aug 2012 12:56:07 +1000
Subject: [concurrency-interest] ReentrantReadWriteLock in
	inconsistent	state
In-Reply-To: <CAG44Fj0SRwkL9Av9bekhzv+Sv4En-17-azZ1Fh=EyjZMAASfFQ@mail.gmail.com>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
	<CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>
	<1343829898.7338.140661109359821.57929FF4@webmail.messagingengine.com>
	<CAG44Fj0SRwkL9Av9bekhzv+Sv4En-17-azZ1Fh=EyjZMAASfFQ@mail.gmail.com>
Message-ID: <20120802125607.rw9ghq2hgcocg4so@getonline.aapt.com.au>

Phil,

A RRWL that has no owner but can not be locked is definitely a  
problem. If this is not 6822370 then the other possibilities are  
async-exceptions occurring in the release code:

             if (free)
                 setExclusiveOwnerThread(null);
             <=== async exception here
             setState(nextc);

Two possible sources of the async exception:

a) Use of Thread.stop elsewhere
b) StackOverflowException was triggered trying to call setState

David Holmes
------------

Quoting Phil Harvey <phil at philharveyonline.com>:

> Hi,
>
> Yes, we had looked at that bug but assumed we were not experiencing it here
> because we are using Java 1.6.0_25, and it was reported fixed in 1.6.0_18.
>
> Do you agree that the unusual state of the ReentrantReadWriteLock suggests
> we've hit a bug?
>
> Phil
> On Aug 1, 2012 3:05 PM, "Ariel Weisberg" <ariel at weisberg.ws> wrote:
>
>>   Hi,
>>
>>  I remember that. That was fixed Oracle JDK 1.6.0_18. It hasn't been
>> reproducing for us since 1.6.0_18, but I am not sure if we are using
>> ReentrantLock in the same way anymore.
>>
>>  The reproducer we used was
>> https://github.com/VoltDB/voltdb/tree/master/tools/lbd_lock_test
>>  If I remember correctly it prints '.' as it goes and when it hangs it
>> stops printing dots.
>>
>>  Regards,
>>  Ariel
>>
>>  On Wed, Aug 1, 2012, at 09:27 AM, ?iktor ?lang wrote:
>>
>>  Hi Phil,
>>
>> Related to this?
>> http://bugs.sun.com/view_bug.do?bug_id=6822370
>>
>>  Cheers,
>>  ?
>>
>>  On Wed, Aug 1, 2012 at 3:20 PM, Phil Harvey   
>> <phil at philharveyonline.com>wrote:
>>
>>  We had a deadlock-like failure of our application recently.
>>
>> I initially reported it on the BDB JE forum (
>> https://forums.oracle.com/forums/thread.jspa?messageID=10480988) but
>> further analysis of the heap and thread dumps has exposed a problem that
>> looks like a Java locking bug. I'm hoping you can offer advice on whether
>> this is the case.
>>
>> We?re using Oracle JVM 1.6.0_25-b06, running on Linux version:
>> 2.6.18-194.32.1.el5.
>>
>> We are launching Java as follows: java -server -XX:+UseConcMarkSweepGC
>> -XX:+HeapDumpOnOutOfMemoryError -Xmx1024m ...
>>
>> Several consecutive thread dumps showed that Thread t at 41101 was blocked
>> indefinitely in ReentrantReadWriteLock. writeLock().lock().
>>
>> We know from code inspection that nothing ever takes a read lock on this
>> ReentrantReadWriteLock, so started trying to find out what has got its
>> write lock.
>>
>> The output of "jstack -l" should list which thread holds this exclusive
>> lock in the "locked ownable synchronizers" section but does not.
>>
>> Our first theory was that the owning thread might have terminated.
>>
>> We wrote a simple test program to explore this. We found from heap dump
>> analysis that even if the owning thread terminates, the lock itself still
>> refers to it via the ReentrantReadWriteLock.WriteLock.sync.
>> exclusiveOwnerThread field. Looking in the java.util.concurrent source
>> code, it seems that this field only gets null'ed when the lock is released.
>>
>> However, looking in the heap dump taken following our "deadlock", we were
>> surprised to find that the lock in question has a null
>> sync.exclusiveOwnerThread field.
>>
>> Surely a write lock should be in one of two states (except possibly for a
>> tiny instant when its state is being non-atomically switched):
>>
>> 1) The lock is available, and sync.exclusiveOwnerThread is null 2) The
>> lock is unavailable, and sync.exclusiveOwnerThread is populated
>>
>> But our lock was indefinitely in this state:
>>
>> 3) The lock is unavailable and sync.exclusiveOwnerThread is null
>>
>> Does anyone know whether this represents a bug? If not, can you explain
>> what it means for a lock to be in this counterintuitive state?
>>
>> Thanks, Phil
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>>
>>
>> --
>> Viktor Klang
>>
>> Akka Tech Lead
>> Typesafe <http://www.typesafe.com/> - The software stack for applications
>> that scale
>>
>> Twitter: @viktorklang
>>   *_______________________________________________*
>>  Concurrency-interest mailing list
>>  Concurrency-interest at cs.oswego.edu
>>  http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>





From stanimir at riflexo.com  Thu Aug  2 00:14:28 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Thu, 2 Aug 2012 07:14:28 +0300
Subject: [concurrency-interest] ReentrantReadWriteLock in inconsistent
	state
In-Reply-To: <20120802125607.rw9ghq2hgcocg4so@getonline.aapt.com.au>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
	<CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>
	<1343829898.7338.140661109359821.57929FF4@webmail.messagingengine.com>
	<CAG44Fj0SRwkL9Av9bekhzv+Sv4En-17-azZ1Fh=EyjZMAASfFQ@mail.gmail.com>
	<20120802125607.rw9ghq2hgcocg4so@getonline.aapt.com.au>
Message-ID: <CAEJX8oo-OJy_x+++pDVKKjuQ6OGQWXF9OVoqgM-Q-C+5XhNqnA@mail.gmail.com>

David,
I am quite positive it's Thread.stop, as setState is inlined. I've seen
that case due to Thread.stop quite a few times too.
Even though it's possible to avoid the disaster via some awkward steps
like: waiting for sleep mode/examine the stack trace, followed by
Thread.suspend/check again, then stop(). Alternatively peppering the code
w/ stop points during class loading is an option but a hard one.

That has made me wonder if hotspot can prevent adding safe points in
java.util.concurrent.locks classes, or at least the safe point to skip
checking for Thread.stop outside park(). That's it the only safe point
would be park(), as side effect it can have minor performance benefits.

I know Thread.stop is deprecated but still there is enough middleware that
makes use of.

Stanimir

On Thu, Aug 2, 2012 at 5:56 AM, <davidcholmes at aapt.net.au> wrote:

> Phil,
>
> A RRWL that has no owner but can not be locked is definitely a problem. If
> this is not 6822370 then the other possibilities are async-exceptions
> occurring in the release code:
>
>             if (free)
>                 setExclusiveOwnerThread(null);
>             <=== async exception here
>             setState(nextc);
>
> Two possible sources of the async exception:
>
> a) Use of Thread.stop elsewhere
> b) StackOverflowException was triggered trying to call setState
>
> David Holmes
> ------------
>
> Quoting Phil Harvey <phil at philharveyonline.com>:
>
>  Hi,
>>
>> Yes, we had looked at that bug but assumed we were not experiencing it
>> here
>> because we are using Java 1.6.0_25, and it was reported fixed in 1.6.0_18.
>>
>> Do you agree that the unusual state of the ReentrantReadWriteLock suggests
>> we've hit a bug?
>>
>> Phil
>> On Aug 1, 2012 3:05 PM, "Ariel Weisberg" <ariel at weisberg.ws> wrote:
>>
>>    Hi,
>>>
>>>  I remember that. That was fixed Oracle JDK 1.6.0_18. It hasn't been
>>> reproducing for us since 1.6.0_18, but I am not sure if we are using
>>> ReentrantLock in the same way anymore.
>>>
>>>  The reproducer we used was
>>> https://github.com/VoltDB/**voltdb/tree/master/tools/lbd_**lock_test<https://github.com/VoltDB/voltdb/tree/master/tools/lbd_lock_test>
>>>  If I remember correctly it prints '.' as it goes and when it hangs it
>>> stops printing dots.
>>>
>>>  Regards,
>>>  Ariel
>>>
>>>  On Wed, Aug 1, 2012, at 09:27 AM, ?iktor ?lang wrote:
>>>
>>>  Hi Phil,
>>>
>>> Related to this?
>>> http://bugs.sun.com/view_bug.**do?bug_id=6822370<http://bugs.sun.com/view_bug.do?bug_id=6822370>
>>>
>>>  Cheers,
>>>  ?
>>>
>>>  On Wed, Aug 1, 2012 at 3:20 PM, Phil Harvey  <phil at philharveyonline.com
>>> >**wrote:
>>>
>>>  We had a deadlock-like failure of our application recently.
>>>
>>> I initially reported it on the BDB JE forum (
>>> https://forums.oracle.com/**forums/thread.jspa?messageID=**10480988<https://forums.oracle.com/forums/thread.jspa?messageID=10480988>)
>>> but
>>> further analysis of the heap and thread dumps has exposed a problem that
>>> looks like a Java locking bug. I'm hoping you can offer advice on whether
>>> this is the case.
>>>
>>> We?re using Oracle JVM 1.6.0_25-b06, running on Linux version:
>>>
>>> 2.6.18-194.32.1.el5.
>>>
>>> We are launching Java as follows: java -server -XX:+UseConcMarkSweepGC
>>> -XX:+**HeapDumpOnOutOfMemoryError -Xmx1024m ...
>>>
>>> Several consecutive thread dumps showed that Thread t at 41101 was blocked
>>> indefinitely in ReentrantReadWriteLock. writeLock().lock().
>>>
>>> We know from code inspection that nothing ever takes a read lock on this
>>> ReentrantReadWriteLock, so started trying to find out what has got its
>>> write lock.
>>>
>>> The output of "jstack -l" should list which thread holds this exclusive
>>> lock in the "locked ownable synchronizers" section but does not.
>>>
>>> Our first theory was that the owning thread might have terminated.
>>>
>>> We wrote a simple test program to explore this. We found from heap dump
>>> analysis that even if the owning thread terminates, the lock itself still
>>> refers to it via the ReentrantReadWriteLock.**WriteLock.sync.
>>> exclusiveOwnerThread field. Looking in the java.util.concurrent source
>>> code, it seems that this field only gets null'ed when the lock is
>>> released.
>>>
>>> However, looking in the heap dump taken following our "deadlock", we were
>>> surprised to find that the lock in question has a null
>>> sync.exclusiveOwnerThread field.
>>>
>>> Surely a write lock should be in one of two states (except possibly for a
>>> tiny instant when its state is being non-atomically switched):
>>>
>>> 1) The lock is available, and sync.exclusiveOwnerThread is null 2) The
>>> lock is unavailable, and sync.exclusiveOwnerThread is populated
>>>
>>> But our lock was indefinitely in this state:
>>>
>>> 3) The lock is unavailable and sync.exclusiveOwnerThread is null
>>>
>>> Does anyone know whether this represents a bug? If not, can you explain
>>> what it means for a lock to be in this counterintuitive state?
>>>
>>> Thanks, Phil
>>>
>>> ______________________________**_________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>
>>>
>>>
>>>
>>>
>>> --
>>> Viktor Klang
>>>
>>> Akka Tech Lead
>>> Typesafe <http://www.typesafe.com/> - The software stack for
>>> applications
>>> that scale
>>>
>>> Twitter: @viktorklang
>>>   *_____________________________**__________________*
>>>
>>>  Concurrency-interest mailing list
>>>  Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>  http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>
>>>
>>>
>>>
>>
>
>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120802/33d7cfdb/attachment-0001.html>

From phil at philharveyonline.com  Thu Aug  2 04:15:09 2012
From: phil at philharveyonline.com (Phil Harvey)
Date: Thu, 2 Aug 2012 09:15:09 +0100
Subject: [concurrency-interest] ReentrantReadWriteLock in inconsistent
	state
In-Reply-To: <CAEJX8oo-OJy_x+++pDVKKjuQ6OGQWXF9OVoqgM-Q-C+5XhNqnA@mail.gmail.com>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
	<CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>
	<1343829898.7338.140661109359821.57929FF4@webmail.messagingengine.com>
	<CAG44Fj0SRwkL9Av9bekhzv+Sv4En-17-azZ1Fh=EyjZMAASfFQ@mail.gmail.com>
	<20120802125607.rw9ghq2hgcocg4so@getonline.aapt.com.au>
	<CAEJX8oo-OJy_x+++pDVKKjuQ6OGQWXF9OVoqgM-Q-C+5XhNqnA@mail.gmail.com>
Message-ID: <CAG44Fj2Vb_teAX9R+4BzjpprYHxmFQmDyD=MSSik=TdJMRxNiQ@mail.gmail.com>

Thanks for the advice guys.

I've checked our code and can confirm we make no Thread.stop() or
Thread.stop(Throwable) calls.

Also, we would have seen the stack trace of a StackOverflowError in our
logs.

So I still have no idea what caused this problem. I can only assume it's a
Java bug. Or am I jumping to conclusions  prematurely?

Phil
 On Aug 2, 2012 5:14 AM, "Stanimir Simeonoff" <stanimir at riflexo.com> wrote:

> David,
> I am quite positive it's Thread.stop, as setState is inlined. I've seen
> that case due to Thread.stop quite a few times too.
> Even though it's possible to avoid the disaster via some awkward steps
> like: waiting for sleep mode/examine the stack trace, followed by
> Thread.suspend/check again, then stop(). Alternatively peppering the code
> w/ stop points during class loading is an option but a hard one.
>
> That has made me wonder if hotspot can prevent adding safe points in
> java.util.concurrent.locks classes, or at least the safe point to skip
> checking for Thread.stop outside park(). That's it the only safe point
> would be park(), as side effect it can have minor performance benefits.
>
> I know Thread.stop is deprecated but still there is enough middleware that
> makes use of.
>
> Stanimir
>
> On Thu, Aug 2, 2012 at 5:56 AM, <davidcholmes at aapt.net.au> wrote:
>
>> Phil,
>>
>> A RRWL that has no owner but can not be locked is definitely a problem.
>> If this is not 6822370 then the other possibilities are async-exceptions
>> occurring in the release code:
>>
>>             if (free)
>>                 setExclusiveOwnerThread(null);
>>             <=== async exception here
>>             setState(nextc);
>>
>> Two possible sources of the async exception:
>>
>> a) Use of Thread.stop elsewhere
>> b) StackOverflowException was triggered trying to call setState
>>
>> David Holmes
>> ------------
>>
>> Quoting Phil Harvey <phil at philharveyonline.com>:
>>
>>  Hi,
>>>
>>> Yes, we had looked at that bug but assumed we were not experiencing it
>>> here
>>> because we are using Java 1.6.0_25, and it was reported fixed in
>>> 1.6.0_18.
>>>
>>> Do you agree that the unusual state of the ReentrantReadWriteLock
>>> suggests
>>> we've hit a bug?
>>>
>>> Phil
>>> On Aug 1, 2012 3:05 PM, "Ariel Weisberg" <ariel at weisberg.ws> wrote:
>>>
>>>    Hi,
>>>>
>>>>  I remember that. That was fixed Oracle JDK 1.6.0_18. It hasn't been
>>>> reproducing for us since 1.6.0_18, but I am not sure if we are using
>>>> ReentrantLock in the same way anymore.
>>>>
>>>>  The reproducer we used was
>>>> https://github.com/VoltDB/**voltdb/tree/master/tools/lbd_**lock_test<https://github.com/VoltDB/voltdb/tree/master/tools/lbd_lock_test>
>>>>  If I remember correctly it prints '.' as it goes and when it hangs it
>>>> stops printing dots.
>>>>
>>>>  Regards,
>>>>  Ariel
>>>>
>>>>  On Wed, Aug 1, 2012, at 09:27 AM, ?iktor ?lang wrote:
>>>>
>>>>  Hi Phil,
>>>>
>>>> Related to this?
>>>> http://bugs.sun.com/view_bug.**do?bug_id=6822370<http://bugs.sun.com/view_bug.do?bug_id=6822370>
>>>>
>>>>  Cheers,
>>>>  ?
>>>>
>>>>  On Wed, Aug 1, 2012 at 3:20 PM, Phil Harvey  <
>>>> phil at philharveyonline.com>**wrote:
>>>>
>>>>  We had a deadlock-like failure of our application recently.
>>>>
>>>> I initially reported it on the BDB JE forum (
>>>> https://forums.oracle.com/**forums/thread.jspa?messageID=**10480988<https://forums.oracle.com/forums/thread.jspa?messageID=10480988>)
>>>> but
>>>> further analysis of the heap and thread dumps has exposed a problem that
>>>> looks like a Java locking bug. I'm hoping you can offer advice on
>>>> whether
>>>> this is the case.
>>>>
>>>> We?re using Oracle JVM 1.6.0_25-b06, running on Linux version:
>>>>
>>>> 2.6.18-194.32.1.el5.
>>>>
>>>> We are launching Java as follows: java -server -XX:+UseConcMarkSweepGC
>>>> -XX:+**HeapDumpOnOutOfMemoryError -Xmx1024m ...
>>>>
>>>> Several consecutive thread dumps showed that Thread t at 41101 was blocked
>>>> indefinitely in ReentrantReadWriteLock. writeLock().lock().
>>>>
>>>> We know from code inspection that nothing ever takes a read lock on this
>>>> ReentrantReadWriteLock, so started trying to find out what has got its
>>>> write lock.
>>>>
>>>> The output of "jstack -l" should list which thread holds this exclusive
>>>> lock in the "locked ownable synchronizers" section but does not.
>>>>
>>>> Our first theory was that the owning thread might have terminated.
>>>>
>>>> We wrote a simple test program to explore this. We found from heap dump
>>>> analysis that even if the owning thread terminates, the lock itself
>>>> still
>>>> refers to it via the ReentrantReadWriteLock.**WriteLock.sync.
>>>> exclusiveOwnerThread field. Looking in the java.util.concurrent source
>>>> code, it seems that this field only gets null'ed when the lock is
>>>> released.
>>>>
>>>> However, looking in the heap dump taken following our "deadlock", we
>>>> were
>>>> surprised to find that the lock in question has a null
>>>> sync.exclusiveOwnerThread field.
>>>>
>>>> Surely a write lock should be in one of two states (except possibly for
>>>> a
>>>> tiny instant when its state is being non-atomically switched):
>>>>
>>>> 1) The lock is available, and sync.exclusiveOwnerThread is null 2) The
>>>> lock is unavailable, and sync.exclusiveOwnerThread is populated
>>>>
>>>> But our lock was indefinitely in this state:
>>>>
>>>> 3) The lock is unavailable and sync.exclusiveOwnerThread is null
>>>>
>>>> Does anyone know whether this represents a bug? If not, can you explain
>>>> what it means for a lock to be in this counterintuitive state?
>>>>
>>>> Thanks, Phil
>>>>
>>>> ______________________________**_________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>
>>>>
>>>>
>>>>
>>>>
>>>> --
>>>> Viktor Klang
>>>>
>>>> Akka Tech Lead
>>>> Typesafe <http://www.typesafe.com/> - The software stack for
>>>> applications
>>>> that scale
>>>>
>>>> Twitter: @viktorklang
>>>>   *_____________________________**__________________*
>>>>
>>>>  Concurrency-interest mailing list
>>>>  Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>>  http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>
>>>>
>>>>
>>>>
>>>
>>
>>
>>
>> ______________________________**_________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120802/a2921ee2/attachment.html>

From heinz at javaspecialists.eu  Thu Aug  2 04:46:42 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Thu, 02 Aug 2012 11:46:42 +0300
Subject: [concurrency-interest] ReentrantReadWriteLock in inconsistent
 state
In-Reply-To: <CAG44Fj2Vb_teAX9R+4BzjpprYHxmFQmDyD=MSSik=TdJMRxNiQ@mail.gmail.com>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>	<CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>	<1343829898.7338.140661109359821.57929FF4@webmail.messagingengine.com>	<CAG44Fj0SRwkL9Av9bekhzv+Sv4En-17-azZ1Fh=EyjZMAASfFQ@mail.gmail.com>	<20120802125607.rw9ghq2hgcocg4so@getonline.aapt.com.au>	<CAEJX8oo-OJy_x+++pDVKKjuQ6OGQWXF9OVoqgM-Q-C+5XhNqnA@mail.gmail.com>
	<CAG44Fj2Vb_teAX9R+4BzjpprYHxmFQmDyD=MSSik=TdJMRxNiQ@mail.gmail.com>
Message-ID: <501A3E72.8040402@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120802/c04ef60f/attachment-0001.html>

From dl at cs.oswego.edu  Thu Aug  2 05:18:26 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 02 Aug 2012 05:18:26 -0400
Subject: [concurrency-interest] ReentrantReadWriteLock in inconsistent
 state
In-Reply-To: <CAG44Fj2Vb_teAX9R+4BzjpprYHxmFQmDyD=MSSik=TdJMRxNiQ@mail.gmail.com>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>	<CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>	<1343829898.7338.140661109359821.57929FF4@webmail.messagingengine.com>	<CAG44Fj0SRwkL9Av9bekhzv+Sv4En-17-azZ1Fh=EyjZMAASfFQ@mail.gmail.com>	<20120802125607.rw9ghq2hgcocg4so@getonline.aapt.com.au>	<CAEJX8oo-OJy_x+++pDVKKjuQ6OGQWXF9OVoqgM-Q-C+5XhNqnA@mail.gmail.com>
	<CAG44Fj2Vb_teAX9R+4BzjpprYHxmFQmDyD=MSSik=TdJMRxNiQ@mail.gmail.com>
Message-ID: <501A45E2.7060604@cs.oswego.edu>

On 08/02/12 04:15, Phil Harvey wrote:
> Thanks for the advice guys.
>
> I've checked our code and can confirm we make no Thread.stop() or
> Thread.stop(Throwable) calls.
>
> Also, we would have seen the stack trace of a StackOverflowError in our logs.
>
> So I still have no idea what caused this problem. I can only assume it's a Java
> bug. Or am I jumping to conclusions  prematurely?

Everyone (including me) who has looked at this agrees that the
the situation you describe "cannot" happen at the Java level.
So it could be a VM, OS, or processor bug. But until there
is a self-contained test case, I don't think much can be
done to further diagnose.

-Doug


>
> Phil
>
> On Aug 2, 2012 5:14 AM, "Stanimir Simeonoff" <stanimir at riflexo.com
> <mailto:stanimir at riflexo.com>> wrote:
>
>     David,
>     I am quite positive it's Thread.stop, as setState is inlined. I've seen that
>     case due to Thread.stop quite a few times too.
>     Even though it's possible to avoid the disaster via some awkward steps like:
>     waiting for sleep mode/examine the stack trace, followed by
>     Thread.suspend/check again, then stop(). Alternatively peppering the code w/
>     stop points during class loading is an option but a hard one.
>
>     That has made me wonder if hotspot can prevent adding safe points in
>     java.util.concurrent.locks classes, or at least the safe point to skip
>     checking for Thread.stop outside park(). That's it the only safe point would
>     be park(), as side effect it can have minor performance benefits.
>
>     I know Thread.stop is deprecated but still there is enough middleware that
>     makes use of.
>
>     Stanimir
>
>     On Thu, Aug 2, 2012 at 5:56 AM, <davidcholmes at aapt.net.au
>     <mailto:davidcholmes at aapt.net.au>> wrote:
>
>         Phil,
>
>         A RRWL that has no owner but can not be locked is definitely a problem.
>         If this is not 6822370 then the other possibilities are async-exceptions
>         occurring in the release code:
>
>                      if (free)
>                          setExclusiveOwnerThread(null);
>         <=== async exception here
>                      setState(nextc);
>
>         Two possible sources of the async exception:
>
>         a) Use of Thread.stop elsewhere
>         b) StackOverflowException was triggered trying to call setState
>
>         David Holmes
>         ------------
>
>         Quoting Phil Harvey <phil at philharveyonline.com
>         <mailto:phil at philharveyonline.com>>:
>
>             Hi,
>
>             Yes, we had looked at that bug but assumed we were not experiencing
>             it here
>             because we are using Java 1.6.0_25, and it was reported fixed in
>             1.6.0_18.
>
>             Do you agree that the unusual state of the ReentrantReadWriteLock
>             suggests
>             we've hit a bug?
>
>             Phil
>             On Aug 1, 2012 3:05 PM, "Ariel Weisberg" <ariel at weisberg.ws
>             <mailto:ariel at weisberg.ws>> wrote:
>
>                    Hi,
>
>                   I remember that. That was fixed Oracle JDK 1.6.0_18. It hasn't
>                 been
>                 reproducing for us since 1.6.0_18, but I am not sure if we are using
>                 ReentrantLock in the same way anymore.
>
>                   The reproducer we used was
>                 https://github.com/VoltDB/__voltdb/tree/master/tools/lbd___lock_test
>                 <https://github.com/VoltDB/voltdb/tree/master/tools/lbd_lock_test>
>                   If I remember correctly it prints '.' as it goes and when it
>                 hangs it
>                 stops printing dots.
>
>                   Regards,
>                   Ariel
>
>                   On Wed, Aug 1, 2012, at 09:27 AM, ?iktor ?lang wrote:
>
>                   Hi Phil,
>
>                 Related to this?
>                 http://bugs.sun.com/view_bug.__do?bug_id=6822370
>                 <http://bugs.sun.com/view_bug.do?bug_id=6822370>
>
>                   Cheers,
>                   ?
>
>                   On Wed, Aug 1, 2012 at 3:20 PM, Phil Harvey
>                 <phil at philharveyonline.com
>                 <mailto:phil at philharveyonline.com>>__wrote:
>
>                   We had a deadlock-like failure of our application recently.
>
>                 I initially reported it on the BDB JE forum (
>                 https://forums.oracle.com/__forums/thread.jspa?messageID=__10480988
>                 <https://forums.oracle.com/forums/thread.jspa?messageID=10480988>)
>                 but
>                 further analysis of the heap and thread dumps has exposed a
>                 problem that
>                 looks like a Java locking bug. I'm hoping you can offer advice
>                 on whether
>                 this is the case.
>
>                 We?re using Oracle JVM 1.6.0_25-b06, running on Linux version:
>
>                 2.6.18-194.32.1.el5.
>
>                 We are launching Java as follows: java -server
>                 -XX:+UseConcMarkSweepGC
>                 -XX:+__HeapDumpOnOutOfMemoryError -Xmx1024m ...
>
>                 Several consecutive thread dumps showed that Thread t at 41101 was
>                 blocked
>                 indefinitely in ReentrantReadWriteLock. writeLock().lock().
>
>                 We know from code inspection that nothing ever takes a read lock
>                 on this
>                 ReentrantReadWriteLock, so started trying to find out what has
>                 got its
>                 write lock.
>
>                 The output of "jstack -l" should list which thread holds this
>                 exclusive
>                 lock in the "locked ownable synchronizers" section but does not.
>
>                 Our first theory was that the owning thread might have terminated.
>
>                 We wrote a simple test program to explore this. We found from
>                 heap dump
>                 analysis that even if the owning thread terminates, the lock
>                 itself still
>                 refers to it via the ReentrantReadWriteLock.__WriteLock.sync.
>                 exclusiveOwnerThread field. Looking in the java.util.concurrent
>                 source
>                 code, it seems that this field only gets null'ed when the lock
>                 is released.
>
>                 However, looking in the heap dump taken following our
>                 "deadlock", we were
>                 surprised to find that the lock in question has a null
>                 sync.exclusiveOwnerThread field.
>
>                 Surely a write lock should be in one of two states (except
>                 possibly for a
>                 tiny instant when its state is being non-atomically switched):
>
>                 1) The lock is available, and sync.exclusiveOwnerThread is null
>                 2) The
>                 lock is unavailable, and sync.exclusiveOwnerThread is populated
>
>                 But our lock was indefinitely in this state:
>
>                 3) The lock is unavailable and sync.exclusiveOwnerThread is null
>
>                 Does anyone know whether this represents a bug? If not, can you
>                 explain
>                 what it means for a lock to be in this counterintuitive state?
>
>                 Thanks, Phil
>
>                 _________________________________________________
>                 Concurrency-interest mailing list
>                 Concurrency-interest at cs.__oswego.edu
>                 <mailto:Concurrency-interest at cs.oswego.edu>
>                 http://cs.oswego.edu/mailman/__listinfo/concurrency-interest
>                 <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
>
>
>
>
>                 --
>                 Viktor Klang
>
>                 Akka Tech Lead
>                 Typesafe <http://www.typesafe.com/> - The software stack for
>                 applications
>                 that scale
>
>                 Twitter: @viktorklang
>                    *_________________________________________________*
>
>                   Concurrency-interest mailing list
>                 Concurrency-interest at cs.__oswego.edu
>                 <mailto:Concurrency-interest at cs.oswego.edu>
>                 http://cs.oswego.edu/mailman/__listinfo/concurrency-interest
>                 <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
>
>
>
>
>
>
>
>         _________________________________________________
>         Concurrency-interest mailing list
>         Concurrency-interest at cs.__oswego.edu
>         <mailto:Concurrency-interest at cs.oswego.edu>
>         http://cs.oswego.edu/mailman/__listinfo/concurrency-interest
>         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From raphfrk at gmail.com  Thu Aug  2 06:03:56 2012
From: raphfrk at gmail.com (Raph Frank)
Date: Thu, 2 Aug 2012 11:03:56 +0100
Subject: [concurrency-interest] Elements in AtomicReferenceArray and
 AtomicReference[] both distinct?
In-Reply-To: <20120802124159.p2c8z41xc0gssok0@getonline.aapt.com.au>
References: <CAN1xFdrQdczwXFyUQxQRQd_5f34VCZGF+TUU0g3ALeT8Rio57g@mail.gmail.com>
	<20120802124159.p2c8z41xc0gssok0@getonline.aapt.com.au>
Message-ID: <CAN1xFdqu-dszRzRBNQckrx-0mzz=eQiHM_8vw+jKNqi23YfqRQ@mail.gmail.com>

Thanks for the info.  That is what I thought was the situation.

The "false sharing" is link interesting.

From heinz at javaspecialists.eu  Thu Aug  2 06:04:20 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Thu, 02 Aug 2012 13:04:20 +0300
Subject: [concurrency-interest] ReentrantReadWriteLock in inconsistent
 state
In-Reply-To: <501A45E2.7060604@cs.oswego.edu>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>	<CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>	<1343829898.7338.140661109359821.57929FF4@webmail.messagingengine.com>	<CAG44Fj0SRwkL9Av9bekhzv+Sv4En-17-azZ1Fh=EyjZMAASfFQ@mail.gmail.com>	<20120802125607.rw9ghq2hgcocg4so@getonline.aapt.com.au>	<CAEJX8oo-OJy_x+++pDVKKjuQ6OGQWXF9OVoqgM-Q-C+5XhNqnA@mail.gmail.com>	<CAG44Fj2Vb_teAX9R+4BzjpprYHxmFQmDyD=MSSik=TdJMRxNiQ@mail.gmail.com>
	<501A45E2.7060604@cs.oswego.edu>
Message-ID: <501A50A4.2020308@javaspecialists.eu>

Which again leads me to think that it would be immensely useful to have 
at least some form of testing that a given JVM / OS / processor stack 
does not violate the JMM.  I know how impossible or difficult such a 
test suite would be to put together, but I believe we will see more bugs 
like this in future, as programmers write more risky code and the 
HotSpot profiler tries to eek the last ounce of performance out of the 
hardware.  How else do we know that the JVM is not broken?

Regards

Heinz
-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun Java Champion
IEEE Certified Software Development Professional
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz 



On 8/2/12 12:18 PM, Doug Lea wrote:
> On 08/02/12 04:15, Phil Harvey wrote:
>> Thanks for the advice guys.
>>
>> I've checked our code and can confirm we make no Thread.stop() or
>> Thread.stop(Throwable) calls.
>>
>> Also, we would have seen the stack trace of a StackOverflowError in 
>> our logs.
>>
>> So I still have no idea what caused this problem. I can only assume 
>> it's a Java
>> bug. Or am I jumping to conclusions  prematurely?
>
> Everyone (including me) who has looked at this agrees that the
> the situation you describe "cannot" happen at the Java level.
> So it could be a VM, OS, or processor bug. But until there
> is a self-contained test case, I don't think much can be
> done to further diagnose.
>
> -Doug
>
>
>>
>> Phil
>>
>> On Aug 2, 2012 5:14 AM, "Stanimir Simeonoff" <stanimir at riflexo.com
>> <mailto:stanimir at riflexo.com>> wrote:
>>
>>     David,
>>     I am quite positive it's Thread.stop, as setState is inlined. 
>> I've seen that
>>     case due to Thread.stop quite a few times too.
>>     Even though it's possible to avoid the disaster via some awkward 
>> steps like:
>>     waiting for sleep mode/examine the stack trace, followed by
>>     Thread.suspend/check again, then stop(). Alternatively peppering 
>> the code w/
>>     stop points during class loading is an option but a hard one.
>>
>>     That has made me wonder if hotspot can prevent adding safe points in
>>     java.util.concurrent.locks classes, or at least the safe point to 
>> skip
>>     checking for Thread.stop outside park(). That's it the only safe 
>> point would
>>     be park(), as side effect it can have minor performance benefits.
>>
>>     I know Thread.stop is deprecated but still there is enough 
>> middleware that
>>     makes use of.
>>
>>     Stanimir
>>
>>     On Thu, Aug 2, 2012 at 5:56 AM, <davidcholmes at aapt.net.au
>>     <mailto:davidcholmes at aapt.net.au>> wrote:
>>
>>         Phil,
>>
>>         A RRWL that has no owner but can not be locked is definitely 
>> a problem.
>>         If this is not 6822370 then the other possibilities are 
>> async-exceptions
>>         occurring in the release code:
>>
>>                      if (free)
>>                          setExclusiveOwnerThread(null);
>>         <=== async exception here
>>                      setState(nextc);
>>
>>         Two possible sources of the async exception:
>>
>>         a) Use of Thread.stop elsewhere
>>         b) StackOverflowException was triggered trying to call setState
>>
>>         David Holmes
>>         ------------
>>
>>         Quoting Phil Harvey <phil at philharveyonline.com
>>         <mailto:phil at philharveyonline.com>>:
>>
>>             Hi,
>>
>>             Yes, we had looked at that bug but assumed we were not 
>> experiencing
>>             it here
>>             because we are using Java 1.6.0_25, and it was reported 
>> fixed in
>>             1.6.0_18.
>>
>>             Do you agree that the unusual state of the 
>> ReentrantReadWriteLock
>>             suggests
>>             we've hit a bug?
>>
>>             Phil
>>             On Aug 1, 2012 3:05 PM, "Ariel Weisberg" <ariel at weisberg.ws
>>             <mailto:ariel at weisberg.ws>> wrote:
>>
>>                    Hi,
>>
>>                   I remember that. That was fixed Oracle JDK 
>> 1.6.0_18. It hasn't
>>                 been
>>                 reproducing for us since 1.6.0_18, but I am not sure 
>> if we are using
>>                 ReentrantLock in the same way anymore.
>>
>>                   The reproducer we used was
>>                 
>> https://github.com/VoltDB/__voltdb/tree/master/tools/lbd___lock_test
>>                 
>> <https://github.com/VoltDB/voltdb/tree/master/tools/lbd_lock_test>
>>                   If I remember correctly it prints '.' as it goes 
>> and when it
>>                 hangs it
>>                 stops printing dots.
>>
>>                   Regards,
>>                   Ariel
>>
>>                   On Wed, Aug 1, 2012, at 09:27 AM, ?iktor ?lang wrote:
>>
>>                   Hi Phil,
>>
>>                 Related to this?
>>                 http://bugs.sun.com/view_bug.__do?bug_id=6822370
>>                 <http://bugs.sun.com/view_bug.do?bug_id=6822370>
>>
>>                   Cheers,
>>                   ?
>>
>>                   On Wed, Aug 1, 2012 at 3:20 PM, Phil Harvey
>>                 <phil at philharveyonline.com
>>                 <mailto:phil at philharveyonline.com>>__wrote:
>>
>>                   We had a deadlock-like failure of our application 
>> recently.
>>
>>                 I initially reported it on the BDB JE forum (
>>                 
>> https://forums.oracle.com/__forums/thread.jspa?messageID=__10480988
>>                 
>> <https://forums.oracle.com/forums/thread.jspa?messageID=10480988>)
>>                 but
>>                 further analysis of the heap and thread dumps has 
>> exposed a
>>                 problem that
>>                 looks like a Java locking bug. I'm hoping you can 
>> offer advice
>>                 on whether
>>                 this is the case.
>>
>>                 We?re using Oracle JVM 1.6.0_25-b06, running on Linux 
>> version:
>>
>>                 2.6.18-194.32.1.el5.
>>
>>                 We are launching Java as follows: java -server
>>                 -XX:+UseConcMarkSweepGC
>>                 -XX:+__HeapDumpOnOutOfMemoryError -Xmx1024m ...
>>
>>                 Several consecutive thread dumps showed that Thread 
>> t at 41101 was
>>                 blocked
>>                 indefinitely in ReentrantReadWriteLock. 
>> writeLock().lock().
>>
>>                 We know from code inspection that nothing ever takes 
>> a read lock
>>                 on this
>>                 ReentrantReadWriteLock, so started trying to find out 
>> what has
>>                 got its
>>                 write lock.
>>
>>                 The output of "jstack -l" should list which thread 
>> holds this
>>                 exclusive
>>                 lock in the "locked ownable synchronizers" section 
>> but does not.
>>
>>                 Our first theory was that the owning thread might 
>> have terminated.
>>
>>                 We wrote a simple test program to explore this. We 
>> found from
>>                 heap dump
>>                 analysis that even if the owning thread terminates, 
>> the lock
>>                 itself still
>>                 refers to it via the 
>> ReentrantReadWriteLock.__WriteLock.sync.
>>                 exclusiveOwnerThread field. Looking in the 
>> java.util.concurrent
>>                 source
>>                 code, it seems that this field only gets null'ed when 
>> the lock
>>                 is released.
>>
>>                 However, looking in the heap dump taken following our
>>                 "deadlock", we were
>>                 surprised to find that the lock in question has a null
>>                 sync.exclusiveOwnerThread field.
>>
>>                 Surely a write lock should be in one of two states 
>> (except
>>                 possibly for a
>>                 tiny instant when its state is being non-atomically 
>> switched):
>>
>>                 1) The lock is available, and 
>> sync.exclusiveOwnerThread is null
>>                 2) The
>>                 lock is unavailable, and sync.exclusiveOwnerThread is 
>> populated
>>
>>                 But our lock was indefinitely in this state:
>>
>>                 3) The lock is unavailable and 
>> sync.exclusiveOwnerThread is null
>>
>>                 Does anyone know whether this represents a bug? If 
>> not, can you
>>                 explain
>>                 what it means for a lock to be in this 
>> counterintuitive state?
>>
>>                 Thanks, Phil
>>
>>                 _________________________________________________
>>                 Concurrency-interest mailing list
>>                 Concurrency-interest at cs.__oswego.edu
>>                 <mailto:Concurrency-interest at cs.oswego.edu>
>>                 
>> http://cs.oswego.edu/mailman/__listinfo/concurrency-interest
>>                 
>> <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>>
>>
>>
>>
>>                 --
>>                 Viktor Klang
>>
>>                 Akka Tech Lead
>>                 Typesafe <http://www.typesafe.com/> - The software 
>> stack for
>>                 applications
>>                 that scale
>>
>>                 Twitter: @viktorklang
>>                    *_________________________________________________*
>>
>>                   Concurrency-interest mailing list
>>                 Concurrency-interest at cs.__oswego.edu
>>                 <mailto:Concurrency-interest at cs.oswego.edu>
>>                 
>> http://cs.oswego.edu/mailman/__listinfo/concurrency-interest
>>                 
>> <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>>
>>
>>
>>
>>
>>
>>
>>         _________________________________________________
>>         Concurrency-interest mailing list
>>         Concurrency-interest at cs.__oswego.edu
>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>         http://cs.oswego.edu/mailman/__listinfo/concurrency-interest
>>         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From viktor.klang at gmail.com  Thu Aug  2 06:16:59 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Thu, 2 Aug 2012 12:16:59 +0200
Subject: [concurrency-interest] ReentrantReadWriteLock in inconsistent
	state
In-Reply-To: <501A50A4.2020308@javaspecialists.eu>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
	<CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>
	<1343829898.7338.140661109359821.57929FF4@webmail.messagingengine.com>
	<CAG44Fj0SRwkL9Av9bekhzv+Sv4En-17-azZ1Fh=EyjZMAASfFQ@mail.gmail.com>
	<20120802125607.rw9ghq2hgcocg4so@getonline.aapt.com.au>
	<CAEJX8oo-OJy_x+++pDVKKjuQ6OGQWXF9OVoqgM-Q-C+5XhNqnA@mail.gmail.com>
	<CAG44Fj2Vb_teAX9R+4BzjpprYHxmFQmDyD=MSSik=TdJMRxNiQ@mail.gmail.com>
	<501A45E2.7060604@cs.oswego.edu>
	<501A50A4.2020308@javaspecialists.eu>
Message-ID: <CANPzfU_tAt+sv+C=ew4O-z094NwsnhhvNGsh-0d7-MU1i81REw@mail.gmail.com>

On Thu, Aug 2, 2012 at 12:04 PM, Dr Heinz M. Kabutz <
heinz at javaspecialists.eu> wrote:

> Which again leads me to think that it would be immensely useful to have at
> least some form of testing that a given JVM / OS / processor stack does not
> violate the JMM.  I know how impossible or difficult such a test suite
> would be to put together, but I believe we will see more bugs like this in
> future, as programmers write more risky code and the HotSpot profiler tries
> to eek the last ounce of performance out of the hardware.  How else do we
> know that the JVM is not broken?


+1 from someone who needs to maintain a high-performance concurrency
library for a variety of JVMs and OSes.

Cheers,
?


>
>
> Regards
>
> Heinz
> --
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun Java Champion
> IEEE Certified Software Development Professional
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
>
> On 8/2/12 12:18 PM, Doug Lea wrote:
>
>> On 08/02/12 04:15, Phil Harvey wrote:
>>
>>> Thanks for the advice guys.
>>>
>>> I've checked our code and can confirm we make no Thread.stop() or
>>> Thread.stop(Throwable) calls.
>>>
>>> Also, we would have seen the stack trace of a StackOverflowError in our
>>> logs.
>>>
>>> So I still have no idea what caused this problem. I can only assume it's
>>> a Java
>>> bug. Or am I jumping to conclusions  prematurely?
>>>
>>
>> Everyone (including me) who has looked at this agrees that the
>> the situation you describe "cannot" happen at the Java level.
>> So it could be a VM, OS, or processor bug. But until there
>> is a self-contained test case, I don't think much can be
>> done to further diagnose.
>>
>> -Doug
>>
>>
>>
>>> Phil
>>>
>>> On Aug 2, 2012 5:14 AM, "Stanimir Simeonoff" <stanimir at riflexo.com
>>> <mailto:stanimir at riflexo.com>> wrote:
>>>
>>>     David,
>>>     I am quite positive it's Thread.stop, as setState is inlined. I've
>>> seen that
>>>     case due to Thread.stop quite a few times too.
>>>     Even though it's possible to avoid the disaster via some awkward
>>> steps like:
>>>     waiting for sleep mode/examine the stack trace, followed by
>>>     Thread.suspend/check again, then stop(). Alternatively peppering the
>>> code w/
>>>     stop points during class loading is an option but a hard one.
>>>
>>>     That has made me wonder if hotspot can prevent adding safe points in
>>>     java.util.concurrent.locks classes, or at least the safe point to
>>> skip
>>>     checking for Thread.stop outside park(). That's it the only safe
>>> point would
>>>     be park(), as side effect it can have minor performance benefits.
>>>
>>>     I know Thread.stop is deprecated but still there is enough
>>> middleware that
>>>     makes use of.
>>>
>>>     Stanimir
>>>
>>>     On Thu, Aug 2, 2012 at 5:56 AM, <davidcholmes at aapt.net.au
>>>     <mailto:davidcholmes at aapt.net.**au <davidcholmes at aapt.net.au>>>
>>> wrote:
>>>
>>>         Phil,
>>>
>>>         A RRWL that has no owner but can not be locked is definitely a
>>> problem.
>>>         If this is not 6822370 then the other possibilities are
>>> async-exceptions
>>>         occurring in the release code:
>>>
>>>                      if (free)
>>>                          setExclusiveOwnerThread(null);
>>>         <=== async exception here
>>>                      setState(nextc);
>>>
>>>         Two possible sources of the async exception:
>>>
>>>         a) Use of Thread.stop elsewhere
>>>         b) StackOverflowException was triggered trying to call setState
>>>
>>>         David Holmes
>>>         ------------
>>>
>>>         Quoting Phil Harvey <phil at philharveyonline.com
>>>         <mailto:phil at philharveyonline.**com <phil at philharveyonline.com>
>>> >>:
>>>
>>>             Hi,
>>>
>>>             Yes, we had looked at that bug but assumed we were not
>>> experiencing
>>>             it here
>>>             because we are using Java 1.6.0_25, and it was reported
>>> fixed in
>>>             1.6.0_18.
>>>
>>>             Do you agree that the unusual state of the
>>> ReentrantReadWriteLock
>>>             suggests
>>>             we've hit a bug?
>>>
>>>             Phil
>>>             On Aug 1, 2012 3:05 PM, "Ariel Weisberg" <ariel at weisberg.ws
>>>             <mailto:ariel at weisberg.ws>> wrote:
>>>
>>>                    Hi,
>>>
>>>                   I remember that. That was fixed Oracle JDK 1.6.0_18.
>>> It hasn't
>>>                 been
>>>                 reproducing for us since 1.6.0_18, but I am not sure if
>>> we are using
>>>                 ReentrantLock in the same way anymore.
>>>
>>>                   The reproducer we used was
>>>                 https://github.com/VoltDB/__**
>>> voltdb/tree/master/tools/lbd__**_lock_test<https://github.com/VoltDB/__voltdb/tree/master/tools/lbd___lock_test>
>>>                 <https://github.com/VoltDB/**
>>> voltdb/tree/master/tools/lbd_**lock_test<https://github.com/VoltDB/voltdb/tree/master/tools/lbd_lock_test>
>>> >
>>>                   If I remember correctly it prints '.' as it goes and
>>> when it
>>>                 hangs it
>>>                 stops printing dots.
>>>
>>>                   Regards,
>>>                   Ariel
>>>
>>>                   On Wed, Aug 1, 2012, at 09:27 AM, ?iktor ?lang wrote:
>>>
>>>                   Hi Phil,
>>>
>>>                 Related to this?
>>>                 http://bugs.sun.com/view_bug._**_do?bug_id=6822370<http://bugs.sun.com/view_bug.__do?bug_id=6822370>
>>>                 <http://bugs.sun.com/view_bug.**do?bug_id=6822370<http://bugs.sun.com/view_bug.do?bug_id=6822370>
>>> >
>>>
>>>                   Cheers,
>>>                   ?
>>>
>>>                   On Wed, Aug 1, 2012 at 3:20 PM, Phil Harvey
>>>                 <phil at philharveyonline.com
>>>                 <mailto:phil at philharveyonline.**com<phil at philharveyonline.com>
>>> >>__wrote:
>>>
>>>                   We had a deadlock-like failure of our application
>>> recently.
>>>
>>>                 I initially reported it on the BDB JE forum (
>>>                 https://forums.oracle.com/__**
>>> forums/thread.jspa?messageID=_**_10480988<https://forums.oracle.com/__forums/thread.jspa?messageID=__10480988>
>>>                 <https://forums.oracle.com/**
>>> forums/thread.jspa?messageID=**10480988<https://forums.oracle.com/forums/thread.jspa?messageID=10480988>
>>> >)
>>>                 but
>>>                 further analysis of the heap and thread dumps has
>>> exposed a
>>>                 problem that
>>>                 looks like a Java locking bug. I'm hoping you can offer
>>> advice
>>>                 on whether
>>>                 this is the case.
>>>
>>>                 We?re using Oracle JVM 1.6.0_25-b06, running on Linux
>>> version:
>>>
>>>                 2.6.18-194.32.1.el5.
>>>
>>>                 We are launching Java as follows: java -server
>>>                 -XX:+UseConcMarkSweepGC
>>>                 -XX:+__**HeapDumpOnOutOfMemoryError -Xmx1024m ...
>>>
>>>                 Several consecutive thread dumps showed that Thread
>>> t at 41101 was
>>>                 blocked
>>>                 indefinitely in ReentrantReadWriteLock.
>>> writeLock().lock().
>>>
>>>                 We know from code inspection that nothing ever takes a
>>> read lock
>>>                 on this
>>>                 ReentrantReadWriteLock, so started trying to find out
>>> what has
>>>                 got its
>>>                 write lock.
>>>
>>>                 The output of "jstack -l" should list which thread holds
>>> this
>>>                 exclusive
>>>                 lock in the "locked ownable synchronizers" section but
>>> does not.
>>>
>>>                 Our first theory was that the owning thread might have
>>> terminated.
>>>
>>>                 We wrote a simple test program to explore this. We found
>>> from
>>>                 heap dump
>>>                 analysis that even if the owning thread terminates, the
>>> lock
>>>                 itself still
>>>                 refers to it via the ReentrantReadWriteLock.__**
>>> WriteLock.sync.
>>>                 exclusiveOwnerThread field. Looking in the
>>> java.util.concurrent
>>>                 source
>>>                 code, it seems that this field only gets null'ed when
>>> the lock
>>>                 is released.
>>>
>>>                 However, looking in the heap dump taken following our
>>>                 "deadlock", we were
>>>                 surprised to find that the lock in question has a null
>>>                 sync.exclusiveOwnerThread field.
>>>
>>>                 Surely a write lock should be in one of two states
>>> (except
>>>                 possibly for a
>>>                 tiny instant when its state is being non-atomically
>>> switched):
>>>
>>>                 1) The lock is available, and sync.exclusiveOwnerThread
>>> is null
>>>                 2) The
>>>                 lock is unavailable, and sync.exclusiveOwnerThread is
>>> populated
>>>
>>>                 But our lock was indefinitely in this state:
>>>
>>>                 3) The lock is unavailable and sync.exclusiveOwnerThread
>>> is null
>>>
>>>                 Does anyone know whether this represents a bug? If not,
>>> can you
>>>                 explain
>>>                 what it means for a lock to be in this counterintuitive
>>> state?
>>>
>>>                 Thanks, Phil
>>>
>>>                 ______________________________**___________________
>>>                 Concurrency-interest mailing list
>>>                 Concurrency-interest at cs.__oswe**go.edu<http://oswego.edu>
>>>                 <mailto:Concurrency-interest@**cs.oswego.edu<Concurrency-interest at cs.oswego.edu>
>>> >
>>>                 http://cs.oswego.edu/mailman/_**
>>> _listinfo/concurrency-interest<http://cs.oswego.edu/mailman/__listinfo/concurrency-interest>
>>>                 <http://cs.oswego.edu/mailman/**
>>> listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>> >
>>>
>>>
>>>
>>>
>>>
>>>                 --
>>>                 Viktor Klang
>>>
>>>                 Akka Tech Lead
>>>                 Typesafe <http://www.typesafe.com/> - The software
>>> stack for
>>>                 applications
>>>                 that scale
>>>
>>>                 Twitter: @viktorklang
>>>                    *_____________________________**____________________*
>>>
>>>                   Concurrency-interest mailing list
>>>                 Concurrency-interest at cs.__oswe**go.edu<http://oswego.edu>
>>>                 <mailto:Concurrency-interest@**cs.oswego.edu<Concurrency-interest at cs.oswego.edu>
>>> >
>>>                 http://cs.oswego.edu/mailman/_**
>>> _listinfo/concurrency-interest<http://cs.oswego.edu/mailman/__listinfo/concurrency-interest>
>>>                 <http://cs.oswego.edu/mailman/**
>>> listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>> >
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>         ______________________________**___________________
>>>         Concurrency-interest mailing list
>>>         Concurrency-interest at cs.__oswe**go.edu <http://oswego.edu>
>>>         <mailto:Concurrency-interest@**cs.oswego.edu<Concurrency-interest at cs.oswego.edu>
>>> >
>>>         http://cs.oswego.edu/mailman/_**_listinfo/concurrency-interest<http://cs.oswego.edu/mailman/__listinfo/concurrency-interest>
>>>         <http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>> >
>>>
>>>
>>>
>>>
>>> ______________________________**_________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>
>>
>> ______________________________**_________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>>  ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120802/53169153/attachment-0001.html>

From davidcholmes at aapt.net.au  Thu Aug  2 12:47:28 2012
From: davidcholmes at aapt.net.au (davidcholmes at aapt.net.au)
Date: Fri, 03 Aug 2012 02:47:28 +1000
Subject: [concurrency-interest] ReentrantReadWriteLock in
	inconsistent	state
In-Reply-To: <CAG44Fj2Vb_teAX9R+4BzjpprYHxmFQmDyD=MSSik=TdJMRxNiQ@mail.gmail.com>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
	<CANPzfU_Zt5n=kyrkHyzyitNsy9B-7_ja=pFAm0YbJ1NXfPzi4w@mail.gmail.com>
	<1343829898.7338.140661109359821.57929FF4@webmail.messagingengine.com>
	<CAG44Fj0SRwkL9Av9bekhzv+Sv4En-17-azZ1Fh=EyjZMAASfFQ@mail.gmail.com>
	<20120802125607.rw9ghq2hgcocg4so@getonline.aapt.com.au>
	<CAEJX8oo-OJy_x+++pDVKKjuQ6OGQWXF9OVoqgM-Q-C+5XhNqnA@mail.gmail.com>
	<CAG44Fj2Vb_teAX9R+4BzjpprYHxmFQmDyD=MSSik=TdJMRxNiQ@mail.gmail.com>
Message-ID: <20120803024728.0e2sxhy2m8o4sg4g@getonline.aapt.com.au>

Phil,

Be wary if code that might swallow exceptions and so hide the fact  
that a stackoverflow occurred.

Also it would be useful to get a SIGQUIT based stack dump, which does  
occur at a safepoint. Though the fact it hangs suggests to me that the  
existing trace is accurate.

These things are extremely difficult to diagnoze without reproducible  
test cases - which is very difficult for these kinds of problem.

David

Quoting Phil Harvey <phil at philharveyonline.com>:

> Thanks for the advice guys.
>
> I've checked our code and can confirm we make no Thread.stop() or
> Thread.stop(Throwable) calls.
>
> Also, we would have seen the stack trace of a StackOverflowError in our
> logs.
>
> So I still have no idea what caused this problem. I can only assume it's a
> Java bug. Or am I jumping to conclusions  prematurely?
>
> Phil
>  On Aug 2, 2012 5:14 AM, "Stanimir Simeonoff" <stanimir at riflexo.com> wrote:
>
>> David,
>> I am quite positive it's Thread.stop, as setState is inlined. I've seen
>> that case due to Thread.stop quite a few times too.
>> Even though it's possible to avoid the disaster via some awkward steps
>> like: waiting for sleep mode/examine the stack trace, followed by
>> Thread.suspend/check again, then stop(). Alternatively peppering the code
>> w/ stop points during class loading is an option but a hard one.
>>
>> That has made me wonder if hotspot can prevent adding safe points in
>> java.util.concurrent.locks classes, or at least the safe point to skip
>> checking for Thread.stop outside park(). That's it the only safe point
>> would be park(), as side effect it can have minor performance benefits.
>>
>> I know Thread.stop is deprecated but still there is enough middleware that
>> makes use of.
>>
>> Stanimir
>>
>> On Thu, Aug 2, 2012 at 5:56 AM, <davidcholmes at aapt.net.au> wrote:
>>
>>> Phil,
>>>
>>> A RRWL that has no owner but can not be locked is definitely a problem.
>>> If this is not 6822370 then the other possibilities are async-exceptions
>>> occurring in the release code:
>>>
>>>             if (free)
>>>                 setExclusiveOwnerThread(null);
>>>             <=== async exception here
>>>             setState(nextc);
>>>
>>> Two possible sources of the async exception:
>>>
>>> a) Use of Thread.stop elsewhere
>>> b) StackOverflowException was triggered trying to call setState
>>>
>>> David Holmes
>>> ------------
>>>
>>> Quoting Phil Harvey <phil at philharveyonline.com>:
>>>
>>>  Hi,
>>>>
>>>> Yes, we had looked at that bug but assumed we were not experiencing it
>>>> here
>>>> because we are using Java 1.6.0_25, and it was reported fixed in
>>>> 1.6.0_18.
>>>>
>>>> Do you agree that the unusual state of the ReentrantReadWriteLock
>>>> suggests
>>>> we've hit a bug?
>>>>
>>>> Phil
>>>> On Aug 1, 2012 3:05 PM, "Ariel Weisberg" <ariel at weisberg.ws> wrote:
>>>>
>>>>    Hi,
>>>>>
>>>>>  I remember that. That was fixed Oracle JDK 1.6.0_18. It hasn't been
>>>>> reproducing for us since 1.6.0_18, but I am not sure if we are using
>>>>> ReentrantLock in the same way anymore.
>>>>>
>>>>>  The reproducer we used was
>>>>> https://github.com/VoltDB/**voltdb/tree/master/tools/lbd_**lock_test<https://github.com/VoltDB/voltdb/tree/master/tools/lbd_lock_test>
>>>>>  If I remember correctly it prints '.' as it goes and when it hangs it
>>>>> stops printing dots.
>>>>>
>>>>>  Regards,
>>>>>  Ariel
>>>>>
>>>>>  On Wed, Aug 1, 2012, at 09:27 AM, ?iktor ?lang wrote:
>>>>>
>>>>>  Hi Phil,
>>>>>
>>>>> Related to this?
>>>>> http://bugs.sun.com/view_bug.**do?bug_id=6822370<http://bugs.sun.com/view_bug.do?bug_id=6822370>
>>>>>
>>>>>  Cheers,
>>>>>  ?
>>>>>
>>>>>  On Wed, Aug 1, 2012 at 3:20 PM, Phil Harvey  <
>>>>> phil at philharveyonline.com>**wrote:
>>>>>
>>>>>  We had a deadlock-like failure of our application recently.
>>>>>
>>>>> I initially reported it on the BDB JE forum (
>>>>> https://forums.oracle.com/**forums/thread.jspa?messageID=**10480988<https://forums.oracle.com/forums/thread.jspa?messageID=10480988>)
>>>>> but
>>>>> further analysis of the heap and thread dumps has exposed a problem that
>>>>> looks like a Java locking bug. I'm hoping you can offer advice on
>>>>> whether
>>>>> this is the case.
>>>>>
>>>>> We?re using Oracle JVM 1.6.0_25-b06, running on Linux version:
>>>>>
>>>>> 2.6.18-194.32.1.el5.
>>>>>
>>>>> We are launching Java as follows: java -server -XX:+UseConcMarkSweepGC
>>>>> -XX:+**HeapDumpOnOutOfMemoryError -Xmx1024m ...
>>>>>
>>>>> Several consecutive thread dumps showed that Thread t at 41101 was blocked
>>>>> indefinitely in ReentrantReadWriteLock. writeLock().lock().
>>>>>
>>>>> We know from code inspection that nothing ever takes a read lock on this
>>>>> ReentrantReadWriteLock, so started trying to find out what has got its
>>>>> write lock.
>>>>>
>>>>> The output of "jstack -l" should list which thread holds this exclusive
>>>>> lock in the "locked ownable synchronizers" section but does not.
>>>>>
>>>>> Our first theory was that the owning thread might have terminated.
>>>>>
>>>>> We wrote a simple test program to explore this. We found from heap dump
>>>>> analysis that even if the owning thread terminates, the lock itself
>>>>> still
>>>>> refers to it via the ReentrantReadWriteLock.**WriteLock.sync.
>>>>> exclusiveOwnerThread field. Looking in the java.util.concurrent source
>>>>> code, it seems that this field only gets null'ed when the lock is
>>>>> released.
>>>>>
>>>>> However, looking in the heap dump taken following our "deadlock", we
>>>>> were
>>>>> surprised to find that the lock in question has a null
>>>>> sync.exclusiveOwnerThread field.
>>>>>
>>>>> Surely a write lock should be in one of two states (except possibly for
>>>>> a
>>>>> tiny instant when its state is being non-atomically switched):
>>>>>
>>>>> 1) The lock is available, and sync.exclusiveOwnerThread is null 2) The
>>>>> lock is unavailable, and sync.exclusiveOwnerThread is populated
>>>>>
>>>>> But our lock was indefinitely in this state:
>>>>>
>>>>> 3) The lock is unavailable and sync.exclusiveOwnerThread is null
>>>>>
>>>>> Does anyone know whether this represents a bug? If not, can you explain
>>>>> what it means for a lock to be in this counterintuitive state?
>>>>>
>>>>> Thanks, Phil
>>>>>
>>>>> ______________________________**_________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>> --
>>>>> Viktor Klang
>>>>>
>>>>> Akka Tech Lead
>>>>> Typesafe <http://www.typesafe.com/> - The software stack for
>>>>> applications
>>>>> that scale
>>>>>
>>>>> Twitter: @viktorklang
>>>>>   *_____________________________**__________________*
>>>>>
>>>>>  Concurrency-interest mailing list
>>>>>  Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>>>    
>>>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>
>>>
>>>
>>>
>>> ______________________________**_________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>
>>
>>
>





From nathan.reynolds at oracle.com  Thu Aug  2 13:52:03 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Thu, 02 Aug 2012 10:52:03 -0700
Subject: [concurrency-interest] Elements in AtomicReferenceArray and
 AtomicReference[] both distinct?
In-Reply-To: <CAHXi_0c0u2oCq1VDYmODVH88GFFbJsnT1DiBm-kVgqrH6CRmcQ@mail.gmail.com>
References: <CAN1xFdrQdczwXFyUQxQRQd_5f34VCZGF+TUU0g3ALeT8Rio57g@mail.gmail.com>
	<CAHXi_0c0u2oCq1VDYmODVH88GFFbJsnT1DiBm-kVgqrH6CRmcQ@mail.gmail.com>
Message-ID: <501ABE43.1070303@oracle.com>

In HotSpot, each thread can have a Thread Local Allocation Buffer 
(TLAB).  This allows the thread to allocate an object extremely fast 
(maybe 20 cycles).  When the TLAB is used up, the thread goes through a 
much more expensive process to get another TLAB.  When all of the TLABs 
are used up, GC is triggered.  Most of the time, if a thread allocates 2 
objects one after the other, then both objects will be located in memory 
next to each other (unless each is allocated from different TLABs).  
When GC moves the objects, they will most likely stay near each other.

AtomicReference[] can still suffer from false sharing.  If all of the 
elements (i.e. AtomicReference) are allocated by the same thread one 
after the other, then the elements will be laid out in RAM as if they 
were an array.  However, the false sharing won't be as severe since each 
AtomicReference has an object header.

For example, on HotSpot Windows 32-bit, the object header is 8 bytes and 
a reference is 4 bytes.  I guess an AtomicReference object consumes 16 
bytes in total (I haven't measured it).  Only 4 AtomicReference objects 
can share a 64-byte cache line. AtomicReferenceArray has an Object[] 
(?).  This means 16 elements can share a 64-byte cache line.  Thus, the 
false sharing is 4x worse for AtomicReferenceArray.

Should everyone stop using AtomicReferenceArrays and roll their own 
AtomicReference[] which uses padding to make sure each AtomicReference 
can't share a cache line?  No.  This will increase the memory bandwidth 
requirements and could have a negative impact.  Premature optimization 
or optimizing a microbenchmark will probably hurt overall performance.  
Make sure you are actually seeing a problem in some large benchmark or test.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 8/1/2012 9:03 AM, Chris Vest wrote:
> Hi Raph,
>
> You are more likely to run into false sharing (cache-line contention) 
> with AtomicReferenceArray, when threads concurrently write to element 
> indices that are close to each other, than you are with an array of 
> AtomicReference objects. On the other hand, the latter uses more memory.
>
> The implementation of ARA does not use locks:
> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/atomic/AtomicReferenceArray.java?revision=1.42&view=markup
>
>
> On 1 August 2012 17:24, Raph Frank <raphfrk at gmail.com 
> <mailto:raphfrk at gmail.com>> wrote:
>
>     I always assumed that elements in an AtomicReferenceArray were
>     distinct.  Threads that accessed different elements would not
>     interfere.
>
>     This thread suggests otherwise, that the protection is at the entire
>     array level.
>
>     http://www.java-forums.org/threads-synchronization/25324-atomicreferencearray-t-equivalent-array-atomicreference-t.html
>
>     Which is correct, do an array of AtomicReferences give better
>     concurrency?
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120802/db273ffa/attachment.html>

From nathan.reynolds at oracle.com  Thu Aug  2 13:59:41 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Thu, 02 Aug 2012 10:59:41 -0700
Subject: [concurrency-interest] ReentrantReadWriteLock in inconsistent
 state
In-Reply-To: <CAEJX8oquzp4zV5XbOVQFAy1rXYks1U4cLokY9eG4BAZEqWvT4g@mail.gmail.com>
References: <CAG44Fj0gD7JUHOLRZ9cnZuVBJhoN1+xVS765FeRUYLCZBhscwg@mail.gmail.com>
	<CAEJX8oquzp4zV5XbOVQFAy1rXYks1U4cLokY9eG4BAZEqWvT4g@mail.gmail.com>
Message-ID: <501AC00D.3040207@oracle.com>

One other thought is that you are running on 6 Update 25.  6 Update 33 
and 7 Update 5 are available.  You might try running on those JVM and 
hope that the problem was fixed.

You might also try changing the -server/-client flag.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 8/1/2012 8:14 AM, Stanimir Simeonoff wrote:
> The usual case for that is... Thread.stop().
>         protected final boolean tryRelease(int releases) {
> .....
>                 setExclusiveOwnerThread(null);
> ---right here---
>                 setState(nextc);
> ....
>                 return true;
> }
>
> Cheers
> Stanimir
> On Wed, Aug 1, 2012 at 4:20 PM, Phil Harvey <phil at philharveyonline.com 
> <mailto:phil at philharveyonline.com>> wrote:
>
>     We had a deadlock-like failure of our application recently.
>
>     I initially reported it on the BDB JE forum (
>     https://forums.oracle.com/forums/thread.jspa?messageID=10480988)
>     but further analysis of the heap and thread dumps has exposed a
>     problem that looks like a Java locking bug. I'm hoping you can
>     offer advice on whether this is the case.
>
>     We're using Oracle JVM 1.6.0_25-b06, running on Linux version:
>     2.6.18-194.32.1.el5.
>
>     We are launching Java as follows: java -server
>     -XX:+UseConcMarkSweepGC -XX:+HeapDumpOnOutOfMemoryError -Xmx1024m ...
>
>     Several consecutive thread dumps showed that Thread t at 41101 was
>     blocked indefinitely in ReentrantReadWriteLock. writeLock().lock().
>
>     We know from code inspection that nothing ever takes a read lock
>     on this ReentrantReadWriteLock, so started trying to find out what
>     has got its write lock.
>
>     The output of "jstack -l" should list which thread holds this
>     exclusive lock in the "locked ownable synchronizers" section but
>     does not.
>
>     Our first theory was that the owning thread might have terminated.
>
>     We wrote a simple test program to explore this. We found from heap
>     dump analysis that even if the owning thread terminates, the lock
>     itself still refers to it via the
>     ReentrantReadWriteLock.WriteLock.sync. exclusiveOwnerThread field.
>     Looking in the java.util.concurrent source code, it seems that
>     this field only gets null'ed when the lock is released.
>
>     However, looking in the heap dump taken following our "deadlock",
>     we were surprised to find that the lock in question has a null
>     sync.exclusiveOwnerThread field.
>
>     Surely a write lock should be in one of two states (except
>     possibly for a tiny instant when its state is being non-atomically
>     switched):
>
>     1) The lock is available, and sync.exclusiveOwnerThread is null 2)
>     The lock is unavailable, and sync.exclusiveOwnerThread is populated
>
>     But our lock was indefinitely in this state:
>
>     3) The lock is unavailable and sync.exclusiveOwnerThread is null
>
>     Does anyone know whether this represents a bug? If not, can you
>     explain what it means for a lock to be in this counterintuitive state?
>
>     Thanks, Phil
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120802/9ab8cb38/attachment-0001.html>

From jeffhain at rocketmail.com  Fri Aug  3 09:59:18 2012
From: jeffhain at rocketmail.com (Jeff Hain)
Date: Fri, 3 Aug 2012 14:59:18 +0100 (BST)
Subject: [concurrency-interest] ThreadPoolExecutor.terminated()
Message-ID: <1344002358.15932.YahooMailNeo@web132104.mail.ird.yahoo.com>

Hello.
At some point in history, ThreadPoolExecutor.terminated()
was not invoked from within main lock, and was invoked
_after_ state setting to TERMINATED (as its Javadoc still
seems to state):

??????????? mainLock.lock();
??????????? try {
??????????????? (...)
??????????? } finally {
??????????????? mainLock.unlock();
??????????? }
??? ??????? if (fullyTerminated)
??????? ??????? terminated();

Now, it's called from within main lock, and before
state update:

??????????? mainLock.lock();
??????????? try {
??????????????? if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
??????????????????? try {
??????????????????????? terminated();
??????????????????? } finally {
??????????????????????? ctl.set(ctlOf(TERMINATED, 0));
??????????????????????? termination.signalAll();
??????????????????? }
??????????????????? return;
??????????????? }
??????????? } finally {
??????????????? mainLock.unlock();
??????????? }

I can see a reason for calling terminated() before state change,
i.e. that whoever reads TERMINATED knows that terminated()
has been called.

Though, terminated() being called in main lock could cause deadlocks,
and I don't see a reason for it (other than making sure that _only_
whoever is in terminated() can see TIDYING state when holding lock,
but why would it be useful?).

Can please anyone enlighten me about it?

-Jeff
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120803/51578ac6/attachment.html>

From dl at cs.oswego.edu  Fri Aug  3 19:31:21 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 03 Aug 2012 19:31:21 -0400
Subject: [concurrency-interest] list/site outage Saturday (4 August 2012)
	6am-7pm EDT
Message-ID: <501C5F49.1030700@cs.oswego.edu>


There will be a scheduled power outage here on campus for most of
tomorrow (4 August 2012), so this list, and *.cs.oswego.edu
will be unreachable. We should be back up by the end of the day.

-Doug


From aleksey.shipilev at oracle.com  Mon Aug  6 05:28:38 2012
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Mon, 06 Aug 2012 13:28:38 +0400
Subject: [concurrency-interest] fjp-trace: ForkJoinPool tracer
Message-ID: <501F8E46.1040300@oracle.com>

Hi,

The next stable version of fjp-trace [1], the useful tool to analyze the
inner workings of ForkJoinPool and friends, is available at Github. Some
of the things fjp-trace could do is written out in README [1], and
sample outputs are here [3].

This tool was proven useful in understanding many of the things relying
on FJP performance, e.g. bulk operations performance coming in JDK8.

Reviews, bug reports, suggestions, general critics about this tool would
be appreciated. Success stories are welcome!

Thanks,
-Aleksey.

[1] https://github.com/shipilev/fjp-trace
[2] https://github.com/shipilev/fjp-trace/blob/master/README
[3] http://shipilev.net/pub/stuff/fjp-trace/

From concurrency-interest at stefan-marr.de  Mon Aug  6 16:31:43 2012
From: concurrency-interest at stefan-marr.de (Stefan Marr)
Date: Mon, 6 Aug 2012 22:31:43 +0200
Subject: [concurrency-interest] Deadline Extended to Aug. 10th,
	RACES'12: Relaxing Synchronization for Multicore and Manycore
	Scalability, SPLASH'12 Workshop
Message-ID: <06E3DE4D-406B-466F-B279-DD2653D5CB17@stefan-marr.de>

Deadline Extension:

The coincidence of the OOPSLA camera-ready deadline and the RACES'12 deadline
has prompted requests for an extension. Accordingly, we are extending the
RACES'12 deadline to August 10th, this Friday. We look forward to a great
workshop, with a chance to exchange ideas and glean insights.

RACES'12 Organizers.


==============================================================================
                            Call for Participation


                             R A C E S    2 0 1 2

       Relaxing Synchronization for Multicore and Manycore Scalability

              Workshop Co-located with SPLASH in Tucson, Arizona
                              Sunday, October 21

         Extended Submission deadline: Friday, August 10, 11:59PM PT
                         http://soft.vub.ac.be/races/

==============================================================================



Massively-parallel systems are coming: core counts keep rising - whether
conventional cores as in multicore and manycore systems, or specialized cores
as in GPUs. Conventional wisdom has been to utilize this parallelism by
reducing synchronization to the minimum required to preserve determinism - in
particular, by eliminating data races. However, Amdahl's law implies that on
highly-parallel systems even a small amount of synchronization that introduces
serialization will limit scaling. Thus, we are forced to confront the
trade-off between synchronization and the ability of an implementation to
scale performance with the number of processors: synchronization inherently
limits parallelism. This workshop focuses on harnessing parallelism by
limiting synchronization, even to the point where programs will compute
inconsistent or approximate rather than exact answers.


Organizers:

Andrew P. Black, Portland State University
Theo D'Hondt, Vrije Universiteit Brussel
Doug Kimelman, IBM Thomas J. Watson Research Center
Martin Rinard, MIT CSAIL
David Ungar, IBM Thomas J. Watson Research Center


Theme and Topics
----------------

A new school of thought is arising: one that accepts and even embraces
nondeterminism (including data races), and in return is able to dramatically
reduce synchronization, or even eliminate it completely. However, this
approach requires that we leave the realm of the certain and enter the realm
of the merely probable. How can we cast aside the security of correctness, the
logic of a proof, and adopt a new way of thinking, where answers are good
enough but not certain, and where many processors work together in parallel
without quite knowing the states that the others are in? We may need some
amount of synchronization, but how much? Or better yet, how little? What
mental tools and linguistic devices can we give programmers to help them adapt
to this challenge? This workshop focuses on these questions and related ones:
harnessing parallelism by limiting synchronization, even to the point where
programs will compute inconsistent or approximate rather than exact answers.


This workshop aims to bring together researchers who, in the quest for
scalability, have been exploring the limits of how much synchronization can be
avoided. We invite submissions on any topic related to the theme of the
workshop, pro or con. We want to hear from those who have experimented with
formalisms, algorithms, data structures, programming languages, and mental
models that push the limits. In addition, we hope to hear from a few voices
with wilder ideas: those who may not have reduced their notions to practice
yet, but who have thoughts that can inspire us as we head towards this
yet-uncertain future. For example, biology may yield fruitful insights. The
ideal presentation for this workshop will focus on a grand idea, but will be
backed by some experimental result.


Submission
----------

Authors are invited to submit short position papers, technical papers, or
experience reports. Submissions may range from a single paragraph to as long
as desired, but the committee can only commit to reading one full page.
Nonetheless, we expect that in many cases reviewers will read farther than
that. Submissions should be formatted according to the ACM SIG Proceedings
style at http://www.acm.org/sigs/publications/proceedings-templates and should
be submitted via EasyChair at
http://www.easychair.org/conferences/?conf=races2012 in PDF format.


PLEASE NOTE: All submissions (except for those retracted by their authors)
will be posted on the workshop website, along with reviews, which will be
signed by the reviewers, and a rating assigned by the program committee.
Further, the submissions to be presented at the workshop will be selected by a
vote of all registered attendees. As well, submissions to be published in an
official proceedings will be selected by the program committee. Please see the
sections below concerning the rationale and details for this process.


Program Committee
-----------------

Andrew P. Black, Portland State University
Yvonne Coady, University of Victoria
Tom Van Cutsem, Vrije Universiteit Brussel
Theo D'Hondt, Vrije Universiteit Brussel
Phil Howard, Portland State University
Doug Kimelman, IBM Thomas J. Watson Research Center
Eddie Kohler, Harvard SEAS
Jim Larus, Microsoft Research
Stefan Marr, Vrije Universiteit Brussel
Tim Mattson, Intel
Paul McKenney, IBM
Hannes Payer, University of Salzburg
Dan Prenner, IBM
Lakshmi Renganarayana, IBM
David Ungar, IBM Thomas J. Watson Research Center
Martin Vechev, ETH Zurich


Important Dates
---------------

August    10     Submission deadline.
August    29     Reviews sent to authors.
September  3     Last date for retraction by authors.
September  4     Papers, reviews, ratings posted on web site. Voting opens.
September 11     Voting closes.
September 14     Notification of papers accepted for presentation and/or publication.
August    21     SPLASH early registration deadline.
October   21     Workshop.
mid-November     Camera-ready copy due for papers selected for proceedings.


Goals and Outcomes
------------------

We will consider the workshop a success if attendees come away with new
insights into fundamental principles, and new ideas for algorithms, data
structures, programming languages, and mental models, leading to improving
scaling by limiting synchronization, even to the point where programs will
compute inconsistent or approximate rather than exact answers. The goal of
this workshop is both to influence current programming practice and to
initiate the coalescence of a new research community giving rise to a new
subfield within the general area of concurrent and parallel programming.
Results generated by the workshop will be made persistent via the workshop
website and possibly via the ACM Digital Library.



  The RACES 2012 Review Process and Workshop Presentation Selection Process
  =========================================================================
  
                                 David Ungar
                     IBM Thomas J. Watson Research Center
                     PC Chair for Workshop  Presentations

Technology has changed the economic tradeoffs that once shaped the reviewing
process. It has become cheap and easy to share submissions, reviews and the
preferences of the attendees. What remains scarce is the number of hours in a
day, and as a consequence the time we have in our workshop in which to learn
and share with each other. I believe that this change in the balance of
factors affords us the opportunity to significantly improve the review and
selection processes.


Sadly, all too often, those who spend their precious time attending a workshop
are not served as well they could be with respect to enlightenment, thought
provoking discussions, and being challenged by new ideas. The fault lies not
in the people who generously donate their time to serve on program committees
and do external reviews. Rather, the fault lies in the process itself. The
very notion of acceptance by committee forces us to boil a rich stew of
reactions, insights, and opinions, down to a single carrot. As a result, it is
common for PC members to come away from a meeting feeling that either some
fraud will be perpetrated on the audience by a fundamentally flawed paper, or,
more often, feeling that a sin of omission will be committed on the audience
by the suppression of a significant but controversial new idea. Sometimes
instead of a carrot we get a lump of gristle.

There are other, lesser, flaws in this process. Although reviewer anonymity
protects negative reviewers from resentment and reprisal, all too often it
prevents an open debate that would promote mutual understanding. Further, in
some cases anonymity allows a reviewer to cast aspersions on authors without
being accountable. Finally, we fail to take maximal advantage of the time and
effort spent in creating insightful reviews when we withhold them from the
audience. Attendees and readers could benefit from expert reactions as they
try to glean the wisdom embedded in the authors' papers.

In this workshop, we have an opportunity to try a different process, one that
we hope will serve all parties better: All reviews will be signed, all
submissions and reviews will be posted on the web (unless an author chooses to
retract a submission), and the attendees will be the ones selecting which
papers will be presented.

Here are the details:
---------------------

At least three committee members will review each submission, and each review
will be signed. Once all the reviews for a submission are in, they will be
sent to the author, who can decide to retract the paper if so desired. Then,
all submissions (except any that are retracted) will be posted on the workshop
website, along with all reviews and a net score determined for each submission
by the program committee.

At this point, prior to the workshop, all registered attendees will be invited
to read the submissions and the reviews, and vote on which of the papers they
want to see presented. Of course, an attendee who so wishes will be free to
merely vote according to the recommendation of the PC, or to not vote and to
accept the wisdom of the rest of the attendees. But the important point
remains: it will be those who will be spending the time in the room who get to
decide how that time is spent. Please note that a submission being posted on
the workshop website and/or presented at the workshop are not intended to
constitute prior publication for purposes of publishing in other workshops,
major conferences, or journals.

This process is a grand experiment, designed to exploit the technologies we
Computer Scientists have created, in order to better serve the advancement of
Computer Science. We hope that its potential excites you as much as it excites
us!



         The RACES 2012 Published Proceedings Paper Selection Process
         ============================================================

                                 Theo D'Hondt
                          Vrije Universiteit Brussel
                        PC Chair for Proceedings Papers

We understand that many submitters may want to publish their paper in an
official proceedings in addition to having it posted on the workshop website.
In order to satisfy that desire, we will publish a proceedings via the ACM
Digital Library. To satisfy ACM DL selectivity requirements, a separate and
more conventional process will be employed for selecting papers to be included
in the published proceedings: Even though all submissions will be posted on
the workshop website (unless retracted by the author), the program committee
will select a smaller number of papers to be included in the published
proceedings based on the signed and posted reviews. Authors of the selected
papers will be asked to submit revised and extended papers mid-November,
taking into account the reviews and the publisher's guidelines. Page limits
for the revised and extended papers to be included in the published
proceedings are anticipated to be 10 pages for research papers, and 5 pages
for position papers. Please note that inclusion in the ACM Digital Library
published proceedings may well be considered to be a prior publication for
purposes of publication in other workshops, major conferences, or journals.
For that reason, authors may choose to decline to have their submission
included in the published proceedings, even if it was presented at the
workshop.



              For questions please contact: races at soft.vub.ac.be
              For updates, follow us on Twitter: @races_workshop


==============================================================================


From dl at cs.oswego.edu  Mon Aug  6 20:25:47 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 06 Aug 2012 20:25:47 -0400
Subject: [concurrency-interest] ConcurrentHashMapV8 insertion/update methods
Message-ID: <5020608B.1010704@cs.oswego.edu>


In the midst of putting together parallel bulk operation support
for ConcurrentHashMap, I noticed that in constructions
of form
   for each x in parallel { map.maybeInsertOrUpdate(...) }
we lack support for a few usages that may become common with
growing use of functional forms.

We have now:
* put(k, v) --
    always write (or replace)
* putIfAbsent(K, v) --
    skip if present, else write
* computeIfAbsent(k, f) --
    skip if present, else write result of f(k)
* compute(k, f) --
    write result of f(k, currentValue),
    where currentValue is null if absent

The missing cases are:
* computeIfPresent(k, f) --
    skip if absent, else write result of f(k, currentValue)
* merge(k, v, f)
    if absent, write v, else write results of f(currentValue, v)
* (keyed) merge(k, v, f)
    if absent, write v, else write results of f(k, currentValue, v)

The last two can be thought of as embedded reductions, where
the keyless-function version plugs into most reduction idioms, but
the keyed-function is needed elsewhere.

This hits all possible cases of atomically skipping,
writing a value, or apply a function when the key
is absent or present. In principle, all of these things
can be done solely with the "compute" method, but it would
often require the use of heavy functions that could tie up
mappings and lead to more contention, which we'd like to help
people avoid.

Aside: One nice thing about using ConcurrentHashMaps in
bulk-parallel programming is that you don't need clever
schemes to manage parallel updates. People can just
do them in parallel forEach loops. So it's worth ensuring
that all these per-mapping atomic-update methods are available
to use in this way.

Pending any further concerns, I plan to put out an update
with these soon.

-Doug


From piotr at bzdyl.net  Tue Aug  7 05:20:38 2012
From: piotr at bzdyl.net (Piotr Bzdyl)
Date: Tue, 7 Aug 2012 11:20:38 +0200
Subject: [concurrency-interest] Java 8 "automatically-parallelizable
 bulk-data operations"
In-Reply-To: <CA+1LWGF+Rtiy9KrywMYuhkM65+tk0aR3y-v4-3A=L4U0BBpF_A@mail.gmail.com>
References: <CAOhYZa3uuuku+hyf1Mqy8=zTkAyeR4zaZP91=uXzAu6=GnbrQA@mail.gmail.com>
	<CA+1LWGF+Rtiy9KrywMYuhkM65+tk0aR3y-v4-3A=L4U0BBpF_A@mail.gmail.com>
Message-ID: <CAOhYZa0GTED-qZPwChLzHmFGw2MLgFJtjyEnQJ7AnXnCGnbZzw@mail.gmail.com>

Thanks Aleksey for the response. I checked the source code from
lambda/lambda forest and binary builds and I could indeed find bulk
operations for collections but I was unable to find any parallel one. I
will try to ask on the lambda or jdk8 mailing lists.

Piotr

On Tue, Jul 31, 2012 at 2:13 PM, Aleksey Shipilev <
aleksey.shipilev at gmail.com> wrote:

> Hi Piotr,
>
> That means operations on standard collections as well [1]. This
> piggybacks on lambda-fication of collections [2]. The development is
> done under lambda project umbrella [3], the prototype for bulk
> operations is available in lambda/lambda forest in OpenJDK, or binary
> builds at [3] as well.
>
> Please join the fun at lambda-dev@ if you are interested.
>
> -Aleksey.
>
> [1] http://openjdk.java.net/jeps/107
> [2] http://openjdk.java.net/jeps/109
> [3] http://openjdk.java.net/projects/lambda/
> [4] http://mail.openjdk.java.net/mailman/listinfo/lambda-dev
>
> On Tue, Jul 31, 2012 at 1:54 PM, Piotr Bzdyl <piotr at bzdyl.net> wrote:
> > Hello,
> >
> > I tried to google it but could not find anything specific.
> >
> > Java 8 release contents JSR-337 mentiones in the Performance section:
> >
> > "In this release we will take another big step by enhancing the
> Collections
> > Framework and related APIs to support automatically-parallelizable
> bulk-data
> > operations such as filter, map, and reduce".
> >
> > Does it mean just ParallelArray or also implementations of other
> collections
> > such as lists, sets and maps?
> >
> > Best regards,
> > Piotr
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120807/1dff416a/attachment.html>

From aleksey.shipilev at oracle.com  Tue Aug  7 06:07:20 2012
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Tue, 07 Aug 2012 14:07:20 +0400
Subject: [concurrency-interest] ConcurrentHashMapV8 insertion/update
	methods
In-Reply-To: <5020608B.1010704@cs.oswego.edu>
References: <5020608B.1010704@cs.oswego.edu>
Message-ID: <5020E8D8.9000009@oracle.com>

Hi Doug,

On 08/07/2012 04:25 AM, Doug Lea wrote:
> This hits all possible cases of atomically skipping,
> writing a value, or apply a function when the key
> is absent or present. In principle, all of these things
> can be done solely with the "compute" method, but it would
> often require the use of heavy functions that could tie up
> mappings and lead to more contention, which we'd like to help
> people avoid.

Any specific example? Assuming returning null to compute means "no
update", users will have to translate as follows:

 computeIfAbsent(k, f1) =
    compute(k, (k, curV) -> { (curV != null) ? null : f1(k); });

 computeIfPresent(k, f2) =
    compute(k, (k, curV) -> { (curV == null) ? null : f2(k, curV) });

 merge(k, v, f3) =
    compute(k, (k, curV, final v) ->
                  { (curV == null) ? v : f3(curV, final v) });

 (keyed) merge(k, v, f4) =
    compute(k, (k, curV, final v) ->
                  { (curV == null) ? v : f4(k, curV, final v) });

It is a straight-forward translation, where is the heavy functions and
contention is kicking back?

-Aleksey.

From dl at cs.oswego.edu  Tue Aug  7 06:30:09 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 07 Aug 2012 06:30:09 -0400
Subject: [concurrency-interest] ConcurrentHashMapV8
	insertion/update	methods
In-Reply-To: <5020E8D8.9000009@oracle.com>
References: <5020608B.1010704@cs.oswego.edu> <5020E8D8.9000009@oracle.com>
Message-ID: <5020EE31.5040909@cs.oswego.edu>

On 08/07/12 06:07, Aleksey Shipilev wrote:
> On 08/07/2012 04:25 AM, Doug Lea wrote:
>> This hits all possible cases of atomically skipping,
>> writing a value, or apply a function when the key
>> is absent or present. In principle, all of these things
>> can be done solely with the "compute" method, but it would
>> often require the use of heavy functions that could tie up
>> mappings and lead to more contention, which we'd like to help
>> people avoid.
>
> Any specific example? Assuming returning null to compute means "no
> update", users will have to translate as follows:
 > ...

These all are in keeping with the idea behind computeIfAbsent,
that people can avoid applying a function while still
maintaining atomicity. In all cases, these functions
ought to be idempotent, but they may consume resources
and take enough time to execute to generate contention
bottlenecks. Plus, conversely, people can (and I'm sure will)
sometimes exploit the exclusion guarantee to apply
functions that would otherwise need some sort of locking.

While I'm at it though:

> * merge(k, v, f)
>    if absent, write v, else write results of f(currentValue, v)
> * (keyed) merge(k, v, f)
>    if absent, write v, else write results of f(k, currentValue, v)
>
> The last two can be thought of as embedded reductions, where
> the keyless-function version plugs into most reduction idioms, but
> the keyed-function is needed elsewhere.

The main case for the keyless version is that it allows
use with existing reducer functions that we expect people
will have around, especially if JDK8 supplies some
prepackaged ones, as planned. But this is not so for the keyed
version, which can be eliminated without hurting any expected
usages -- people can get the effect in other ways.

-Doug

From raphfrk at gmail.com  Tue Aug  7 08:47:36 2012
From: raphfrk at gmail.com (Raph Frank)
Date: Tue, 7 Aug 2012 13:47:36 +0100
Subject: [concurrency-interest] Thread safety of WeakReference .get() method?
Message-ID: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>

Is the WeakReference.get() method safe to call from multiple threads
at the same time?

The documentation says that once an object has been determined to be
garbage collectable, "At that time it will atomically clear all weak
references to that object", so presumably, the get method can be
called, some if is atomically set to null?

From aleksey.shipilev at oracle.com  Tue Aug  7 09:49:01 2012
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Tue, 07 Aug 2012 17:49:01 +0400
Subject: [concurrency-interest] Thread safety of WeakReference .get()
 method?
In-Reply-To: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>
Message-ID: <50211CCD.7020803@oracle.com>

On 08/07/2012 04:47 PM, Raph Frank wrote:

> The documentation says that once an object has been determined to be
> garbage collectable, "At that time it will atomically clear all weak
> references to that object", so presumably, the get method can be
> called, some if is atomically set to null?

I think the real meaning behind that claim is "atomically set *all* weak
references to that object", i.e. two weak references to the same object
will simultaneously become clear once object is not reachable.

Mutator threads are not modifying the referent, and so the real question
should be: is it possible to read the non-null referent after weak
reference is cleared? There is no difference how many user threads are
accessing now, because the possible race is between mutator threads and GC.

The answer to that is VM-specific. Common sense is that all GC
operations should be committed before returning back to the mutator
after stop-the-world, or notified to the mutator as soon as possible in
concurrent GCs. If that wasn't true, WeakRefs would risk keep
referencing the objects that are not really there, and it would broke
too many applications already.

-Aleksey.


From vitalyd at gmail.com  Tue Aug  7 18:13:11 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 7 Aug 2012 18:13:11 -0400
Subject: [concurrency-interest] Thread safety of WeakReference .get()
	method?
In-Reply-To: <50211CCD.7020803@oracle.com>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>
	<50211CCD.7020803@oracle.com>
Message-ID: <CAHjP37HbpmOudA8_YCPpcg7zo5u0V5PJj8NEt3bkxiSR6vy1dw@mail.gmail.com>

I agree with this.  However, another interesting scenario is if thread 1
sets the referent and then publishes the WeakReference via a data race, can
thread 2 see the WeakRef as non-null but the referent as null or partially
initialized? Referent is not final and I don't remember seeing any other
barriers that can be piggybacked on in the constructor.  Unless the JVM
does something internally, the JMM would allow this to happen.

Cheers,
Vitaly

Sent from my phone
On Aug 7, 2012 9:54 AM, "Aleksey Shipilev" <aleksey.shipilev at oracle.com>
wrote:

> On 08/07/2012 04:47 PM, Raph Frank wrote:
>
> > The documentation says that once an object has been determined to be
> > garbage collectable, "At that time it will atomically clear all weak
> > references to that object", so presumably, the get method can be
> > called, some if is atomically set to null?
>
> I think the real meaning behind that claim is "atomically set *all* weak
> references to that object", i.e. two weak references to the same object
> will simultaneously become clear once object is not reachable.
>
> Mutator threads are not modifying the referent, and so the real question
> should be: is it possible to read the non-null referent after weak
> reference is cleared? There is no difference how many user threads are
> accessing now, because the possible race is between mutator threads and GC.
>
> The answer to that is VM-specific. Common sense is that all GC
> operations should be committed before returning back to the mutator
> after stop-the-world, or notified to the mutator as soon as possible in
> concurrent GCs. If that wasn't true, WeakRefs would risk keep
> referencing the objects that are not really there, and it would broke
> too many applications already.
>
> -Aleksey.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120807/6b70e36a/attachment.html>

From heinz at javaspecialists.eu  Wed Aug  8 04:24:21 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Wed, 08 Aug 2012 11:24:21 +0300
Subject: [concurrency-interest] Thread safety of WeakReference .get()
 method?
In-Reply-To: <50211CCD.7020803@oracle.com>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>
	<50211CCD.7020803@oracle.com>
Message-ID: <50222235.5070601@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120808/cad656d6/attachment.html>

From aleksey.shipilev at oracle.com  Wed Aug  8 04:58:12 2012
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 08 Aug 2012 12:58:12 +0400
Subject: [concurrency-interest] Thread safety of WeakReference .get()
 method?
In-Reply-To: <50222235.5070601@javaspecialists.eu>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>
	<50211CCD.7020803@oracle.com> <50222235.5070601@javaspecialists.eu>
Message-ID: <50222A24.2080700@oracle.com>

Interesting. I would agree with that non-volatile reads as the condition
to exit the busy loop are particularly nasty.

I also tend to think "volatile" is much too strict for this use case,
because it will introduce unnecessary memory ordering. In the absence of
explicit barriers, this seems to be the work for non-yet-existing
Unsafe.getOrderedObject(), which should just require VM to omit
speculative reads and re-read memory on every get().

-Aleksey.

On 08/08/2012 12:24 PM, Dr Heinz M. Kabutz wrote:
> Looks like common sense has yet again not prevailed.  In this little
> test, I am calling WeakReference.get() in a tight loop from one thread,
> called "readerThread".  Since the "referent" field inside the
> WeakReference is not volatile and there is no synchronization at all for
> that field, the "readerThread" eventually inlines the method call to
> get() and caches the value of the "referent" field.  The "queueReader"
> thread calls "remove()" from the ReferenceQueue and wakes up pretty
> quickly after we have set the field "str" to null and invoked
> System.gc().  Interestingly, The Object is finalized even though the
> readerThread still has a reference to it!
> 
> If you run this with the -server flag, the program will not finish. 
> With -client it finishes, because it does not cache the referent field
> value in the readerThread.
> 
> import java.lang.ref.*;
> 
> public class WeakReferenceTest {
>   private static Object str = new Object() {
>     public String toString() {
>       return "The Object";
>     }
> 
>     protected void finalize() throws Throwable {
>       System.out.println("The Object is being finalized");
>       super.finalize();
>     }
>   };
>   private final static ReferenceQueue<Object> rq =
>       new ReferenceQueue<Object>();
>   private final static WeakReference<Object> wr =
>       new WeakReference<Object>(str, rq);
> 
>   public static void main(String[] args)
>       throws InterruptedException {
>     Thread reader = new Thread() {
>       public void run() {
>         while (wr.get() != null) {
>         }
>         System.out.println("wr.get() returned null");
>       }
>     };
> 
>     Thread queueReader = new Thread() {
>       public void run() {
>         try {
>           Reference<? extends Object> ref = rq.remove();
>           System.out.println(ref);
>           System.out.println("queueReader returned, ref==wr is "
>               + (ref == wr));
>         } catch (InterruptedException e) {
>           System.err.println("Sleep interrupted - exiting");
>         }
>       }
>     };
> 
>     reader.start();
>     queueReader.start();
> 
>     Thread.sleep(1000);
>     str = null;
>     System.gc();
>   }
> }
> 
> 
> Output with Server HotSpot:
> 
> The Object is being finalized
> java.lang.ref.WeakReference at 72ebbf5c
> queueReader returned, ref==wr is true
>  -- VM does not end
> 
> 
> Output with Client HotSpot:
> 
> The Object is being finalized
> wr.get() returned null
> java.lang.ref.WeakReference at 110769b
> queueReader returned, ref==wr is true
> 
> 
> Conclusion:
> 
> The "referent" field in java.lang.ref.Reference should probably be
> marked as "volatile".
> 
> Regards
> 
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun Java Champion
> IEEE Certified Software Development Professional
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz 
> 
> 
> 
> On 8/7/12 4:49 PM, Aleksey Shipilev wrote:
>> On 08/07/2012 04:47 PM, Raph Frank wrote:
>>
>>   
>>> The documentation says that once an object has been determined to be
>>> garbage collectable, "At that time it will atomically clear all weak
>>> references to that object", so presumably, the get method can be
>>> called, some if is atomically set to null?
>>>     
>> I think the real meaning behind that claim is "atomically set *all* weak
>> references to that object", i.e. two weak references to the same object
>> will simultaneously become clear once object is not reachable.
>>
>> Mutator threads are not modifying the referent, and so the real question
>> should be: is it possible to read the non-null referent after weak
>> reference is cleared? There is no difference how many user threads are
>> accessing now, because the possible race is between mutator threads and GC.
>>
>> The answer to that is VM-specific. Common sense is that all GC
>> operations should be committed before returning back to the mutator
>> after stop-the-world, or notified to the mutator as soon as possible in
>> concurrent GCs. If that wasn't true, WeakRefs would risk keep
>> referencing the objects that are not really there, and it would broke
>> too many applications already.
>>
>> -Aleksey.
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>   


From stanimir at riflexo.com  Wed Aug  8 05:39:39 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Wed, 8 Aug 2012 12:39:39 +0300
Subject: [concurrency-interest] Thread safety of WeakReference .get()
	method?
In-Reply-To: <50222A24.2080700@oracle.com>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>
	<50211CCD.7020803@oracle.com> <50222235.5070601@javaspecialists.eu>
	<50222A24.2080700@oracle.com>
Message-ID: <CAEJX8ooc70wGehYoVVc9PdrsuCwWNbKQKYPObFG_pCs9DFSosw@mail.gmail.com>

> In the absence of explicit barriers, this seems to be the work for
> non-yet-existing
> Unsafe.getOrderedObject(), which should just require VM to omit
> speculative reads and re-read memory on every get().
>
> Would that be a load-load barrier as putOrderedObject is store-store?

Stanimir



> -Aleksey.
>
> On 08/08/2012 12:24 PM, Dr Heinz M. Kabutz wrote:
> > Looks like common sense has yet again not prevailed.  In this little
> > test, I am calling WeakReference.get() in a tight loop from one thread,
> > called "readerThread".  Since the "referent" field inside the
> > WeakReference is not volatile and there is no synchronization at all for
> > that field, the "readerThread" eventually inlines the method call to
> > get() and caches the value of the "referent" field.  The "queueReader"
> > thread calls "remove()" from the ReferenceQueue and wakes up pretty
> > quickly after we have set the field "str" to null and invoked
> > System.gc().  Interestingly, The Object is finalized even though the
> > readerThread still has a reference to it!
> >
> > If you run this with the -server flag, the program will not finish.
> > With -client it finishes, because it does not cache the referent field
> > value in the readerThread.
> >
> > import java.lang.ref.*;
> >
> > public class WeakReferenceTest {
> >   private static Object str = new Object() {
> >     public String toString() {
> >       return "The Object";
> >     }
> >
> >     protected void finalize() throws Throwable {
> >       System.out.println("The Object is being finalized");
> >       super.finalize();
> >     }
> >   };
> >   private final static ReferenceQueue<Object> rq =
> >       new ReferenceQueue<Object>();
> >   private final static WeakReference<Object> wr =
> >       new WeakReference<Object>(str, rq);
> >
> >   public static void main(String[] args)
> >       throws InterruptedException {
> >     Thread reader = new Thread() {
> >       public void run() {
> >         while (wr.get() != null) {
> >         }
> >         System.out.println("wr.get() returned null");
> >       }
> >     };
> >
> >     Thread queueReader = new Thread() {
> >       public void run() {
> >         try {
> >           Reference<? extends Object> ref = rq.remove();
> >           System.out.println(ref);
> >           System.out.println("queueReader returned, ref==wr is "
> >               + (ref == wr));
> >         } catch (InterruptedException e) {
> >           System.err.println("Sleep interrupted - exiting");
> >         }
> >       }
> >     };
> >
> >     reader.start();
> >     queueReader.start();
> >
> >     Thread.sleep(1000);
> >     str = null;
> >     System.gc();
> >   }
> > }
> >
> >
> > Output with Server HotSpot:
> >
> > The Object is being finalized
> > java.lang.ref.WeakReference at 72ebbf5c
> > queueReader returned, ref==wr is true
> >  -- VM does not end
> >
> >
> > Output with Client HotSpot:
> >
> > The Object is being finalized
> > wr.get() returned null
> > java.lang.ref.WeakReference at 110769b
> > queueReader returned, ref==wr is true
> >
> >
> > Conclusion:
> >
> > The "referent" field in java.lang.ref.Reference should probably be
> > marked as "volatile".
> >
> > Regards
> >
> > Heinz
> > --
> > Dr Heinz M. Kabutz (PhD CompSci)
> > Author of "The Java(tm) Specialists' Newsletter"
> > Sun Java Champion
> > IEEE Certified Software Development Professional
> > http://www.javaspecialists.eu
> > Tel: +30 69 75 595 262
> > Skype: kabutz
> >
> >
> >
> > On 8/7/12 4:49 PM, Aleksey Shipilev wrote:
> >> On 08/07/2012 04:47 PM, Raph Frank wrote:
> >>
> >>
> >>> The documentation says that once an object has been determined to be
> >>> garbage collectable, "At that time it will atomically clear all weak
> >>> references to that object", so presumably, the get method can be
> >>> called, some if is atomically set to null?
> >>>
> >> I think the real meaning behind that claim is "atomically set *all* weak
> >> references to that object", i.e. two weak references to the same object
> >> will simultaneously become clear once object is not reachable.
> >>
> >> Mutator threads are not modifying the referent, and so the real question
> >> should be: is it possible to read the non-null referent after weak
> >> reference is cleared? There is no difference how many user threads are
> >> accessing now, because the possible race is between mutator threads and
> GC.
> >>
> >> The answer to that is VM-specific. Common sense is that all GC
> >> operations should be committed before returning back to the mutator
> >> after stop-the-world, or notified to the mutator as soon as possible in
> >> concurrent GCs. If that wasn't true, WeakRefs would risk keep
> >> referencing the objects that are not really there, and it would broke
> >> too many applications already.
> >>
> >> -Aleksey.
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120808/19b4e382/attachment-0001.html>

From aleksey.shipilev at oracle.com  Wed Aug  8 08:29:08 2012
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 08 Aug 2012 16:29:08 +0400
Subject: [concurrency-interest] Atomic.*lazyGet
Message-ID: <50225B94.2080706@oracle.com>

Hi,

Inspired by Doug's API completeness endeavor in CHM, and recent
WeakReference discussion, I had remembered the thing long haunting me.

In short, I would like us to consider adding lazyGet() to our atomic
primitives. Googling around haven't got me to any pointers if anyone had
considered this before. If anyone had, please point me there.

There are couple of thoughts in favor of this proposal:
  a. Introduce relaxed semantics for volatile reads. We have relaxed
semantics for volatile writes via lazySet() to ease of the impact of
volatile stores in some cases. We get the impact of volatile reads more
or less zero for current mainstream TSO hardware, but lazyGet() could be
beneficial for non-TSO hardware.
  b. Symmetry against lazySet(). From the pure API standpoint, the
asymmetry drives my OCD crazy.
  c. Push Unsafe to implement symmetric Unsafe.getOrdered*(), this could
be useful for naked Unsafe users. This is challenging to synchronize
across all JVM vendors, so this could be the use case driving the addition.

lazyGet() should have the LoadLoad semantics, which will reduce to nop
on most platforms. However, this has the additional effect to prevent
compilers from hoisting the memory load.

If we introduce lazyGet() at this point, we could just do volatile read
for now, and then replace it with appropriate Unsafe intrinsic once
available.

Thoughts?

-Aleksey.

From raphfrk at gmail.com  Wed Aug  8 08:50:51 2012
From: raphfrk at gmail.com (Raph Frank)
Date: Wed, 8 Aug 2012 13:50:51 +0100
Subject: [concurrency-interest] Thread safety of WeakReference .get()
	method?
In-Reply-To: <CAEJX8ooc70wGehYoVVc9PdrsuCwWNbKQKYPObFG_pCs9DFSosw@mail.gmail.com>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>
	<50211CCD.7020803@oracle.com> <50222235.5070601@javaspecialists.eu>
	<50222A24.2080700@oracle.com>
	<CAEJX8ooc70wGehYoVVc9PdrsuCwWNbKQKYPObFG_pCs9DFSosw@mail.gmail.com>
Message-ID: <CAN1xFdppqBGPPtZnqhW4WzC9-=t3WYpKnUNf-KRmsBUp2EpZMg@mail.gmail.com>

So, if I create a weak reference to an object when it is created, it
is still safe to use (well no less safe anyway).

Sounds like this issue occurs if the last reference to an object is
released by one thread and the WeakReference.get() is checked from
another?

From vitalyd at gmail.com  Wed Aug  8 09:00:39 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 8 Aug 2012 09:00:39 -0400
Subject: [concurrency-interest] Thread safety of WeakReference .get()
	method?
In-Reply-To: <CAN1xFdppqBGPPtZnqhW4WzC9-=t3WYpKnUNf-KRmsBUp2EpZMg@mail.gmail.com>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>
	<50211CCD.7020803@oracle.com> <50222235.5070601@javaspecialists.eu>
	<50222A24.2080700@oracle.com>
	<CAEJX8ooc70wGehYoVVc9PdrsuCwWNbKQKYPObFG_pCs9DFSosw@mail.gmail.com>
	<CAN1xFdppqBGPPtZnqhW4WzC9-=t3WYpKnUNf-KRmsBUp2EpZMg@mail.gmail.com>
Message-ID: <CAHjP37HZM0to+f55mK4v414OvFvSAQgzR1D4rv4sfcYoP+wM7A@mail.gmail.com>

You will need to treat WeakReference as any other non-threadsafe class and
provide the necessary happens-before edges if you want to share the
instance amongst java threads.

Sent from my phone
On Aug 8, 2012 8:54 AM, "Raph Frank" <raphfrk at gmail.com> wrote:

> So, if I create a weak reference to an object when it is created, it
> is still safe to use (well no less safe anyway).
>
> Sounds like this issue occurs if the last reference to an object is
> released by one thread and the WeakReference.get() is checked from
> another?
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120808/f0dff4a2/attachment.html>

From vitalyd at gmail.com  Wed Aug  8 09:11:25 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 8 Aug 2012 09:11:25 -0400
Subject: [concurrency-interest] Atomic.*lazyGet
In-Reply-To: <50225B94.2080706@oracle.com>
References: <50225B94.2080706@oracle.com>
Message-ID: <CAHjP37EGX7dFO1joPx-czMNz0=vsfemxqiNqPy-OAJDeFV2EMg@mail.gmail.com>

Volatile read is already a LoadLoad.  What I think you're asking for is a
pure compiler barrier only, no architectural ordering?

Sent from my phone
On Aug 8, 2012 8:34 AM, "Aleksey Shipilev" <aleksey.shipilev at oracle.com>
wrote:

> Hi,
>
> Inspired by Doug's API completeness endeavor in CHM, and recent
> WeakReference discussion, I had remembered the thing long haunting me.
>
> In short, I would like us to consider adding lazyGet() to our atomic
> primitives. Googling around haven't got me to any pointers if anyone had
> considered this before. If anyone had, please point me there.
>
> There are couple of thoughts in favor of this proposal:
>   a. Introduce relaxed semantics for volatile reads. We have relaxed
> semantics for volatile writes via lazySet() to ease of the impact of
> volatile stores in some cases. We get the impact of volatile reads more
> or less zero for current mainstream TSO hardware, but lazyGet() could be
> beneficial for non-TSO hardware.
>   b. Symmetry against lazySet(). From the pure API standpoint, the
> asymmetry drives my OCD crazy.
>   c. Push Unsafe to implement symmetric Unsafe.getOrdered*(), this could
> be useful for naked Unsafe users. This is challenging to synchronize
> across all JVM vendors, so this could be the use case driving the addition.
>
> lazyGet() should have the LoadLoad semantics, which will reduce to nop
> on most platforms. However, this has the additional effect to prevent
> compilers from hoisting the memory load.
>
> If we introduce lazyGet() at this point, we could just do volatile read
> for now, and then replace it with appropriate Unsafe intrinsic once
> available.
>
> Thoughts?
>
> -Aleksey.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120808/6f5c2057/attachment.html>

From dl at cs.oswego.edu  Wed Aug  8 09:22:46 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 08 Aug 2012 09:22:46 -0400
Subject: [concurrency-interest] Atomic.*lazyGet
In-Reply-To: <50225B94.2080706@oracle.com>
References: <50225B94.2080706@oracle.com>
Message-ID: <50226826.7070706@cs.oswego.edu>

On 08/08/12 08:29, Aleksey Shipilev wrote:
> Hi,
>
> Inspired by Doug's API completeness endeavor in CHM, and recent
> WeakReference discussion, I had remembered the thing long haunting me.
>
> In short, I would like us to consider adding lazyGet() to our atomic
> primitives. Googling around haven't got me to any pointers if anyone had
> considered this before. If anyone had, please point me there.

See previous list discussions of "weakGet()" (which is a better name,
in line with weakCompareAndSet), at least as far back as 2006.
For example:
http://cs.oswego.edu/pipermail/concurrency-interest/2006-May/002526.html

I welcome Hans Boehm to summarize the reasons that we cannot
do this without first overhauling the JMM spec.
Well, we could do it, but if so, it would only have
we-hope-you-know-what-we-mean semantics, which is
not something most people are comfortable about for
fundamental concurrency constructs. The lazySet case,
that we did add without incorporation into JMM, was
different in that we were confident that we could spec
it formally without breaking things in a minor JMM revision
when it came up next. For a sense of what this would look
like, see near the end of the proposed/scrapped Fences javadoc
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html


-Doug



From vitalyd at gmail.com  Wed Aug  8 09:22:41 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 8 Aug 2012 09:22:41 -0400
Subject: [concurrency-interest] Thread safety of WeakReference .get()
	method?
In-Reply-To: <CAHjP37Ey6r7rta16WjN+CiRceasVHowgQUMg6_1iZ2EBC_qODA@mail.gmail.com>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>
	<50211CCD.7020803@oracle.com> <50222235.5070601@javaspecialists.eu>
	<50222A24.2080700@oracle.com>
	<CAEJX8ooc70wGehYoVVc9PdrsuCwWNbKQKYPObFG_pCs9DFSosw@mail.gmail.com>
	<CAN1xFdppqBGPPtZnqhW4WzC9-=t3WYpKnUNf-KRmsBUp2EpZMg@mail.gmail.com>
	<CAHjP37HZM0to+f55mK4v414OvFvSAQgzR1D4rv4sfcYoP+wM7A@mail.gmail.com>
	<CAN1xFdoN4b_D=8q_rAOeiafzJWZProT51VTyjWeNWtEbkAvxyA@mail.gmail.com>
	<CAHjP37G+LkBZQc=YUXMJK9gYh=XbHV4oQ-_crcqHmzQukACwCg@mail.gmail.com>
	<CAHjP37Ey6r7rta16WjN+CiRceasVHowgQUMg6_1iZ2EBC_qODA@mail.gmail.com>
Message-ID: <CAHjP37GAjK-SgjQy8=6qnfWwRRynaQrrjeRbbYmoXwkCW47w5w@mail.gmail.com>

Adding the list in case someone has further insight.

Sent from my phone
On Aug 8, 2012 9:20 AM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:

> I should mention though that if you loop on WR.get(), as demonstrated by
> Heinz, you can fall victim to compiler optimization where the referent
> field is enregistered.  Almost seems like a bug, but I'm guessing this is
> an unusual use case.
>
> Sent from my phone
> On Aug 8, 2012 9:14 AM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:
>
>> As Aleksey mentioned, one can assume that the interaction between java
>> and gc threads already has sufficient barriers to make it work.  Otherwise,
>> WeakReference would not work at all even in single java thread case since
>> GC runs on its own VM threads.  Or did I miss your point?
>>
>> Sent from my phone
>> On Aug 8, 2012 9:10 AM, "Raph Frank" <raphfrk at gmail.com> wrote:
>>
>>> On Wed, Aug 8, 2012 at 2:00 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>> wrote:
>>> > You will need to treat WeakReference as any other non-threadsafe class
>>> and
>>> > provide the necessary happens-before edges if you want to share the
>>> instance
>>> > amongst java threads.
>>>
>>> The issue here is the sync between the garbage collection thread(s)
>>> and the reference.
>>>
>>> The WeakReference is created in the constructor of another object and
>>> set to a final field.
>>>
>>> It sounds like setting the last reference to null from one thread and
>>> using .get() from another can cause a problem.
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120808/5ae9a131/attachment.html>

From vitalyd at gmail.com  Wed Aug  8 09:32:15 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 8 Aug 2012 09:32:15 -0400
Subject: [concurrency-interest] Atomic.*lazyGet
In-Reply-To: <50226826.7070706@cs.oswego.edu>
References: <50225B94.2080706@oracle.com>
	<50226826.7070706@cs.oswego.edu>
Message-ID: <CAHjP37GcM7M=J33RVctX=UscZF9Z72+ugB_kAHuSGfNi6WsU3Q@mail.gmail.com>

Doug, so what was the overwhelming reason for scrapping the Fences API? Is
it because the JMM would need a revision, as you mentioned? I'd think if
Fences was some "advanced" API with a caveat emptor that you need to know
what you're doing then it would be OK - or is that a can of worms you'd
rather not open?

Thanks

Sent from my phone
On Aug 8, 2012 9:26 AM, "Doug Lea" <dl at cs.oswego.edu> wrote:

> On 08/08/12 08:29, Aleksey Shipilev wrote:
>
>> Hi,
>>
>> Inspired by Doug's API completeness endeavor in CHM, and recent
>> WeakReference discussion, I had remembered the thing long haunting me.
>>
>> In short, I would like us to consider adding lazyGet() to our atomic
>> primitives. Googling around haven't got me to any pointers if anyone had
>> considered this before. If anyone had, please point me there.
>>
>
> See previous list discussions of "weakGet()" (which is a better name,
> in line with weakCompareAndSet), at least as far back as 2006.
> For example:
> http://cs.oswego.edu/**pipermail/concurrency-**
> interest/2006-May/002526.html<http://cs.oswego.edu/pipermail/concurrency-interest/2006-May/002526.html>
>
> I welcome Hans Boehm to summarize the reasons that we cannot
> do this without first overhauling the JMM spec.
> Well, we could do it, but if so, it would only have
> we-hope-you-know-what-we-mean semantics, which is
> not something most people are comfortable about for
> fundamental concurrency constructs. The lazySet case,
> that we did add without incorporation into JMM, was
> different in that we were confident that we could spec
> it formally without breaking things in a minor JMM revision
> when it came up next. For a sense of what this would look
> like, see near the end of the proposed/scrapped Fences javadoc
> http://gee.cs.oswego.edu/dl/**jsr166/dist/docs/java/util/**
> concurrent/atomic/Fences.html<http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html>
>
>
> -Doug
>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120808/cff6c098/attachment-0001.html>

From aleksey.shipilev at oracle.com  Wed Aug  8 09:54:48 2012
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 08 Aug 2012 17:54:48 +0400
Subject: [concurrency-interest] Atomic.*lazyGet
In-Reply-To: <50226826.7070706@cs.oswego.edu>
References: <50225B94.2080706@oracle.com> <50226826.7070706@cs.oswego.edu>
Message-ID: <50226FA8.6040908@oracle.com>

On 08/08/2012 05:22 PM, Doug Lea wrote:
> On 08/08/12 08:29, Aleksey Shipilev wrote:
>> In short, I would like us to consider adding lazyGet() to our atomic
>> primitives. Googling around haven't got me to any pointers if anyone had
>> considered this before. If anyone had, please point me there.
> 
> See previous list discussions of "weakGet()" (which is a better name,
> in line with weakCompareAndSet), at least as far back as 2006.
> For example:
> http://cs.oswego.edu/pipermail/concurrency-interest/2006-May/002526.html

Ah, thanks for the link. I had clearly googled for a different name. I'd
expect search engines to pick up "lazyGet" as well now.

> The lazySet case, that we did add without incorporation into JMM, was
> different in that we were confident that we could spec
> it formally without breaking things in a minor JMM revision
> when it came up next. 

But it is still not formalized, right? If we blow lazySet() by saying
"lazySet() is like naked write without HB semantics", why can't we just
say "weakGet() is like naked read without HB semantics"? No strings
attached. Granted, this is the wizardry stuff, but it is probably easier
than to introduce Fences and require revamping JMM to fit it there.

In fact, I would have done the similar thing by hand, if only VM could
provide me with the appropriate intrinsic. It seems to be better
engineering route to justify this addition with having the API exposing
it, but probably it is too much to ask? Should we instead go for
Unsafe-only route?

-Aleksey.


From dl at cs.oswego.edu  Wed Aug  8 09:57:54 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 08 Aug 2012 09:57:54 -0400
Subject: [concurrency-interest] Atomic.*lazyGet
In-Reply-To: <CAHjP37GcM7M=J33RVctX=UscZF9Z72+ugB_kAHuSGfNi6WsU3Q@mail.gmail.com>
References: <50225B94.2080706@oracle.com>	<50226826.7070706@cs.oswego.edu>
	<CAHjP37GcM7M=J33RVctX=UscZF9Z72+ugB_kAHuSGfNi6WsU3Q@mail.gmail.com>
Message-ID: <50227062.4040906@cs.oswego.edu>

On 08/08/12 09:32, Vitaly Davidovich wrote:
> Doug, so what was the overwhelming reason for scrapping the Fences API? Is it
> because the JMM would need a revision, as you mentioned? I'd think if Fences was
> some "advanced" API with a caveat emptor that you need to know what you're doing
> then it would be OK - or is that a can of worms you'd rather not open?
>

I think this proposal died for three reasons:

* The argument that the API is prone to misuse, even by experts.
There are some highly non-intuitive cases; for example those
involving accessing array elements.

* The fact that there are some minor errors in the JMM/JLS specs
that don't matter much for most purposes, but do for the otherwise
reasonable semi-formal additions in the Fences API. So this
should be done with at least a minor JMM revision. But no one
wants to do a minor revision when there are also some known
major problems that need attention. None of these major
problems are very interesting to java programmers, but they
do include for example erroneous claims that some compiler
optimizations are illegal, that compile writers happily ignore.
These problems cannot be addressed with just a few pointwise fixes.

* The notion that it would be better to instead overhaul
this part of the JMM to be more in line with the C++11 memory model specs,
focusing on explicit modes rather than fences. But no one has come
up with a way to do so. C++ could get away with the notion that
any program with races has undefined behavior. Java must define
behaviors that make minimal safety/security guarantees.
It is very challenging.

-Doug


From aleksey.shipilev at oracle.com  Wed Aug  8 10:11:37 2012
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 08 Aug 2012 18:11:37 +0400
Subject: [concurrency-interest] Thread safety of WeakReference .get()
 method?
In-Reply-To: <CAHjP37GAjK-SgjQy8=6qnfWwRRynaQrrjeRbbYmoXwkCW47w5w@mail.gmail.com>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>
	<50211CCD.7020803@oracle.com> <50222235.5070601@javaspecialists.eu>
	<50222A24.2080700@oracle.com>
	<CAEJX8ooc70wGehYoVVc9PdrsuCwWNbKQKYPObFG_pCs9DFSosw@mail.gmail.com>
	<CAN1xFdppqBGPPtZnqhW4WzC9-=t3WYpKnUNf-KRmsBUp2EpZMg@mail.gmail.com>
	<CAHjP37HZM0to+f55mK4v414OvFvSAQgzR1D4rv4sfcYoP+wM7A@mail.gmail.com>
	<CAN1xFdoN4b_D=8q_rAOeiafzJWZProT51VTyjWeNWtEbkAvxyA@mail.gmail.com>
	<CAHjP37G+LkBZQc=YUXMJK9gYh=XbHV4oQ-_crcqHmzQukACwCg@mail.gmail.com>
	<CAHjP37Ey6r7rta16WjN+CiRceasVHowgQUMg6_1iZ2EBC_qODA@mail.gmail.com>
	<CAHjP37GAjK-SgjQy8=6qnfWwRRynaQrrjeRbbYmoXwkCW47w5w@mail.gmail.com>
Message-ID: <50227399.3030804@oracle.com>

I had looked into disassembly and confirmed C2 had hoisted $referent and
reduced the readerThread loop to the infinite unconditional version.
>From the JMM standpoint, that is a correct optimization.

The genuine trouble seems to be the fact we are dealing with GC. If this
case was between two Java threads, one setting the value, and second one
is waiting in busy-loop, I would say it is a programming error not to
make the field in question "volatile".

In References, it is a bit tricker, now the "other" thread is GC. Even
if we say $referent is volatile, it does not immediately force native GC
thread to issue the barrier there. In fact, if you think about it, you
are updating it either during the STW pause, or through the appropriate
read-write barriers in concurrent phases; as if GC is already
maintaining the proper visibility for its own updates.

Hence, the compiler should probably handle the fields which are normally
updated by the GC in a specific way, e.g. prevent hoisting. Marking
referent as volatile brings that effect into life, but at the cost of
volatile write for the initial value (we had some optimization in mind
to handle that, but this is by no means a quick solution).

-Aleksey.

On 08/08/2012 05:22 PM, Vitaly Davidovich wrote:
> Adding the list in case someone has further insight.
> 
> Sent from my phone
> 
> On Aug 8, 2012 9:20 AM, "Vitaly Davidovich" <vitalyd at gmail.com
> <mailto:vitalyd at gmail.com>> wrote:
> 
>     I should mention though that if you loop on WR.get(), as
>     demonstrated by Heinz, you can fall victim to compiler optimization
>     where the referent field is enregistered.  Almost seems like a bug,
>     but I'm guessing this is an unusual use case.
> 
>     Sent from my phone
> 
>     On Aug 8, 2012 9:14 AM, "Vitaly Davidovich" <vitalyd at gmail.com
>     <mailto:vitalyd at gmail.com>> wrote:
> 
>         As Aleksey mentioned, one can assume that the interaction
>         between java and gc threads already has sufficient barriers to
>         make it work.  Otherwise, WeakReference would not work at all
>         even in single java thread case since GC runs on its own VM
>         threads.  Or did I miss your point?
> 
>         Sent from my phone
> 
>         On Aug 8, 2012 9:10 AM, "Raph Frank" <raphfrk at gmail.com
>         <mailto:raphfrk at gmail.com>> wrote:
> 
>             On Wed, Aug 8, 2012 at 2:00 PM, Vitaly Davidovich
>             <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
>             > You will need to treat WeakReference as any other
>             non-threadsafe class and
>             > provide the necessary happens-before edges if you want to
>             share the instance
>             > amongst java threads.
> 
>             The issue here is the sync between the garbage collection
>             thread(s)
>             and the reference.
> 
>             The WeakReference is created in the constructor of another
>             object and
>             set to a final field.
> 
>             It sounds like setting the last reference to null from one
>             thread and
>             using .get() from another can cause a problem.
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From vitalyd at gmail.com  Wed Aug  8 11:49:34 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 8 Aug 2012 11:49:34 -0400
Subject: [concurrency-interest] Atomic.*lazyGet
In-Reply-To: <50227062.4040906@cs.oswego.edu>
References: <50225B94.2080706@oracle.com> <50226826.7070706@cs.oswego.edu>
	<CAHjP37GcM7M=J33RVctX=UscZF9Z72+ugB_kAHuSGfNi6WsU3Q@mail.gmail.com>
	<50227062.4040906@cs.oswego.edu>
Message-ID: <CAHjP37GtyoE3NtU8_yHERYcVZPnPMbCjVyPJDqq0wHp_rkjT+w@mail.gmail.com>

Thanks for the explanation.  On #1, why are arrays challenging/troublesome?
Couldn't the fences API provide similar functionality to
AtomicReferenceArray?

As for #3, people are already reaching for Unsafe to squeeze out
performance so couldnt fences be considered in the same light?

Sent from my phone
On Aug 8, 2012 9:57 AM, "Doug Lea" <dl at cs.oswego.edu> wrote:

> On 08/08/12 09:32, Vitaly Davidovich wrote:
>
>> Doug, so what was the overwhelming reason for scrapping the Fences API?
>> Is it
>> because the JMM would need a revision, as you mentioned? I'd think if
>> Fences was
>> some "advanced" API with a caveat emptor that you need to know what
>> you're doing
>> then it would be OK - or is that a can of worms you'd rather not open?
>>
>>
> I think this proposal died for three reasons:
>
> * The argument that the API is prone to misuse, even by experts.
> There are some highly non-intuitive cases; for example those
> involving accessing array elements.
>
> * The fact that there are some minor errors in the JMM/JLS specs
> that don't matter much for most purposes, but do for the otherwise
> reasonable semi-formal additions in the Fences API. So this
> should be done with at least a minor JMM revision. But no one
> wants to do a minor revision when there are also some known
> major problems that need attention. None of these major
> problems are very interesting to java programmers, but they
> do include for example erroneous claims that some compiler
> optimizations are illegal, that compile writers happily ignore.
> These problems cannot be addressed with just a few pointwise fixes.
>
> * The notion that it would be better to instead overhaul
> this part of the JMM to be more in line with the C++11 memory model specs,
> focusing on explicit modes rather than fences. But no one has come
> up with a way to do so. C++ could get away with the notion that
> any program with races has undefined behavior. Java must define
> behaviors that make minimal safety/security guarantees.
> It is very challenging.
>
> -Doug
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120808/43ee3f02/attachment.html>

From dl at cs.oswego.edu  Wed Aug  8 14:59:51 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 08 Aug 2012 14:59:51 -0400
Subject: [concurrency-interest] Atomic.*lazyGet
In-Reply-To: <CAHjP37GtyoE3NtU8_yHERYcVZPnPMbCjVyPJDqq0wHp_rkjT+w@mail.gmail.com>
References: <50225B94.2080706@oracle.com>	<50226826.7070706@cs.oswego.edu>	<CAHjP37GcM7M=J33RVctX=UscZF9Z72+ugB_kAHuSGfNi6WsU3Q@mail.gmail.com>	<50227062.4040906@cs.oswego.edu>
	<CAHjP37GtyoE3NtU8_yHERYcVZPnPMbCjVyPJDqq0wHp_rkjT+w@mail.gmail.com>
Message-ID: <5022B727.30209@cs.oswego.edu>

On 08/08/12 11:49, Vitaly Davidovich wrote:
> Thanks for the explanation.  On #1, why are arrays challenging/troublesome?

In part because you need both a reference to an array, a,
and an index, i, to access a[i].
If you are reading them both (a and i) under different consistency rules
before accessing a[i], it is easy to be surprised.

> As for #3, people are already reaching for Unsafe to squeeze out performance so
> couldnt fences be considered in the same light?

Yes, that was one argument for introducing them.
I was surprised by the number of people who responded
saying that only people who know how to use Unsafe should
use these methods, and those people can get the effects using
Unsafe anyway, so why bother introducing a new API?

-Doug

From hans.boehm at hp.com  Wed Aug  8 23:45:10 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu, 9 Aug 2012 03:45:10 +0000
Subject: [concurrency-interest] Atomic.*lazyGet
In-Reply-To: <50226FA8.6040908@oracle.com>
References: <50225B94.2080706@oracle.com> <50226826.7070706@cs.oswego.edu>
	<50226FA8.6040908@oracle.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F5E5CF@G4W3296.americas.hpqcorp.net>

I'm confused.  LazySet() does have happens-before semantics.  And I don't think that's changeable without serious code breakage.  It doesn't participate in the total synchronization order.  That doesn't really make sense in the current memory model, since the synchronization order is what determines happens-before semantics.  But we kind of know what it's supposed to do.

I'm not sure that we should add more APIs here that we can't really define.  WeakGet would presumably behave like memory_order_acquire in C++, which is kind of, but not really, like including a trailing LoadLoad and LoadStore fence?  (Just LoadLoad would be really weird, and I think quite undesirable and not beneficial to performance.)  The semantics of that are very subtly different from a volatile load.  I'm not sure I would know how to describe it.

On the other, there is currently a large additional overhead for volatile loads on POWER, which could be avoided by weakGet, even as defined above.  See http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html .  I'm not sure Doug's mappings are quite up-to-date in this respect.  On most other architectures the differences seem to be minor to none, or at least getting there.

Hans

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Aleksey Shipilev
> Sent: Wednesday, August 08, 2012 6:55 AM
> To: Doug Lea
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Atomic.*lazyGet
> 
> On 08/08/2012 05:22 PM, Doug Lea wrote:
> > On 08/08/12 08:29, Aleksey Shipilev wrote:
> >> In short, I would like us to consider adding lazyGet() to our atomic
> >> primitives. Googling around haven't got me to any pointers if anyone
> had
> >> considered this before. If anyone had, please point me there.
> >
> > See previous list discussions of "weakGet()" (which is a better name,
> > in line with weakCompareAndSet), at least as far back as 2006.
> > For example:
> > http://cs.oswego.edu/pipermail/concurrency-interest/2006-
> May/002526.html
> 
> Ah, thanks for the link. I had clearly googled for a different name.
> I'd
> expect search engines to pick up "lazyGet" as well now.
> 
> > The lazySet case, that we did add without incorporation into JMM, was
> > different in that we were confident that we could spec
> > it formally without breaking things in a minor JMM revision
> > when it came up next.
> 
> But it is still not formalized, right? If we blow lazySet() by saying
> "lazySet() is like naked write without HB semantics", why can't we just
> say "weakGet() is like naked read without HB semantics"? No strings
> attached. Granted, this is the wizardry stuff, but it is probably
> easier
> than to introduce Fences and require revamping JMM to fit it there.
> 
> In fact, I would have done the similar thing by hand, if only VM could
> provide me with the appropriate intrinsic. It seems to be better
> engineering route to justify this addition with having the API exposing
> it, but probably it is too much to ask? Should we instead go for
> Unsafe-only route?
> 
> -Aleksey.
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From aleksey.shipilev at oracle.com  Thu Aug  9 03:05:58 2012
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Thu, 09 Aug 2012 11:05:58 +0400
Subject: [concurrency-interest] Atomic.*lazyGet
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F5E5CF@G4W3296.americas.hpqcorp.net>
References: <50225B94.2080706@oracle.com> <50226826.7070706@cs.oswego.edu>
	<50226FA8.6040908@oracle.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F5E5CF@G4W3296.americas.hpqcorp.net>
Message-ID: <50236156.20406@oracle.com>

On 08/09/2012 07:45 AM, Boehm, Hans wrote:
> I'm confused.  LazySet() does have happens-before semantics.  And I
> don't think that's changeable without serious code breakage.  It
> doesn't participate in the total synchronization order.  That doesn't
> really make sense in the current memory model, since the
> synchronization order is what determines happens-before semantics.
> But we kind of know what it's supposed to do.

Sorry, I was confusing myself. I think the real semantics I wanted from
weakGet() is "just" the naked memory read. After sleeping on it,
realized that trying to piggyback on memory effects to make the
compiler-only barrier is probably a messy idea. Also, it makes some
assumptions about HMM, which is not something we should probably embrace
in public API.

> On the other, there is currently a large additional overhead for
> volatile loads on POWER, which could be avoided by weakGet, even as
> defined above.

Yes, I was leaning towards the platforms which have non-marginal
volatile read cost. Naked memory op, as confusing as it might be for
JMM, would help in some corner cases.

-Aleksey.

From noreply+2773091977 at badoo.com  Thu Aug  9 07:12:07 2012
From: noreply+2773091977 at badoo.com (Badoo)
Date: Thu,  9 Aug 2012 11:12:07 +0000
Subject: [concurrency-interest] Hai ricevuto un messaggio da Edmondo...
Message-ID: <201208091112.q79BCAL6021441@cs.oswego.edu>

Hai ricevuto un messaggio da Edmondo...

Il mittente di questo messaggio e il suo contenuto saranno visibili solo a te. Per scoprire che cosa c'? scritto nel messaggio e per rispondere subito, segui questo link:
http://eu1.badoo.com/0113586782/in/fnubP5oNGCk/?lang_id=8&m=63&mid=50239b05000000000008000000340805031ef61d002e

Altre persone della tua zona gi? iscritte a Badoo
Josephpacha (Napoli, Italia)
Ingrid (Napoli, Italia)
Syryus (Napoli, Italia)

http://eu1.badoo.com/0113586782/in/fnubP5oNGCk/?lang_id=8&m=63&mid=50239b05000000000008000000340805031ef61d002e

Se il link qui sopra non dovesse funzionare, prova a copiarlo e incollarlo nella barra degli indirizzi del tuo browser.

Questa comunicazione fa parte del sistema di notifica per il messaggio inviato da Edmondo. Se pensi che si tratti di un errore, ignora questa comunicazione. 

Buon divertimento!
Il team di Badoo

Questa e-mail ti ? stata inviata da Badoo Trading Limited (indirizzo postale in fondo). 
http://eu1.badoo.com/impersonation.phtml?lang_id=8&email=concurrency-interest%40cs.oswego.edu&block_code=80cef1&m=63&mid=50239b05000000000008000000340805031ef61d002e
Badoo Trading Limited ? una societ? a responsabilit? limitata registrata in Inghilterra e Galles con il numero 7540255. La sede legale ? registrata all'indirizzo 12 Red Lion Square, London, WC1R 4QD.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120809/a76a990f/attachment.html>

From hans.boehm at hp.com  Thu Aug  9 11:43:59 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu, 9 Aug 2012 15:43:59 +0000
Subject: [concurrency-interest] Atomic.*lazyGet
In-Reply-To: <50236156.20406@oracle.com>
References: <50225B94.2080706@oracle.com> <50226826.7070706@cs.oswego.edu>
	<50226FA8.6040908@oracle.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F5E5CF@G4W3296.americas.hpqcorp.net>
	<50236156.20406@oracle.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F5E788@G4W3296.americas.hpqcorp.net>

I suspect you don't want to go any weaker than the equivalent of C++ memory_order_relaxed.  That guarantees at least cache coherence, i.e. loads from the same memory location can't be reordered.  There are one or two hardware architectures that allow such reordering for naked loads, even if the compiler avoids it.  But even that's quite error prone.  In my experience people commonly assume memory_order_acquire ordering without realizing it.  And it gets us back into the realm where we have to disallow out-of-thin air results, which we don't really know how to do.

I think all the solutions here are quite messy.

Hans

> -----Original Message-----
> From: Aleksey Shipilev [mailto:aleksey.shipilev at oracle.com]
> Sent: Thursday, August 09, 2012 12:06 AM
> To: Boehm, Hans
> Cc: Doug Lea; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Atomic.*lazyGet
> 
> On 08/09/2012 07:45 AM, Boehm, Hans wrote:
> > I'm confused.  LazySet() does have happens-before semantics.  And I
> > don't think that's changeable without serious code breakage.  It
> > doesn't participate in the total synchronization order.  That doesn't
> > really make sense in the current memory model, since the
> > synchronization order is what determines happens-before semantics.
> > But we kind of know what it's supposed to do.
> 
> Sorry, I was confusing myself. I think the real semantics I wanted from
> weakGet() is "just" the naked memory read. After sleeping on it,
> realized that trying to piggyback on memory effects to make the
> compiler-only barrier is probably a messy idea. Also, it makes some
> assumptions about HMM, which is not something we should probably
> embrace
> in public API.
> 
> > On the other, there is currently a large additional overhead for
> > volatile loads on POWER, which could be avoided by weakGet, even as
> > defined above.
> 
> Yes, I was leaning towards the platforms which have non-marginal
> volatile read cost. Naked memory op, as confusing as it might be for
> JMM, would help in some corner cases.
> 
> -Aleksey.


From aleksey.shipilev at oracle.com  Fri Aug 10 02:05:21 2012
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Fri, 10 Aug 2012 10:05:21 +0400
Subject: [concurrency-interest] Thread safety of WeakReference .get()
 method?
In-Reply-To: <50227399.3030804@oracle.com>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>
	<50211CCD.7020803@oracle.com> <50222235.5070601@javaspecialists.eu>
	<50222A24.2080700@oracle.com>
	<CAEJX8ooc70wGehYoVVc9PdrsuCwWNbKQKYPObFG_pCs9DFSosw@mail.gmail.com>
	<CAN1xFdppqBGPPtZnqhW4WzC9-=t3WYpKnUNf-KRmsBUp2EpZMg@mail.gmail.com>
	<CAHjP37HZM0to+f55mK4v414OvFvSAQgzR1D4rv4sfcYoP+wM7A@mail.gmail.com>
	<CAN1xFdoN4b_D=8q_rAOeiafzJWZProT51VTyjWeNWtEbkAvxyA@mail.gmail.com>
	<CAHjP37G+LkBZQc=YUXMJK9gYh=XbHV4oQ-_crcqHmzQukACwCg@mail.gmail.com>
	<CAHjP37Ey6r7rta16WjN+CiRceasVHowgQUMg6_1iZ2EBC_qODA@mail.gmail.com>
	<CAHjP37GAjK-SgjQy8=6qnfWwRRynaQrrjeRbbYmoXwkCW47w5w@mail.gmail.com>
	<50227399.3030804@oracle.com>
Message-ID: <5024A4A1.9070103@oracle.com>

On 08/08/2012 06:11 PM, Aleksey Shipilev wrote:
> Hence, the compiler should probably handle the fields which are normally
> updated by the GC in a specific way, e.g. prevent hoisting. Marking
> referent as volatile brings that effect into life, but at the cost of
> volatile write for the initial value (we had some optimization in mind
> to handle that, but this is by no means a quick solution).

FYI.

This is the submitted bug (not available in public yet):
 http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7190310

And this is the fix:
 http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2012-August/008190.html

I had double-checked Heinz's testcase now works, and disassembly shows
plain field read inside the loop. membar_acquire had essentially reduced
to nop on my x86 laptop.

-Aleksey.

From vitalyd at gmail.com  Fri Aug 10 09:30:38 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 10 Aug 2012 09:30:38 -0400
Subject: [concurrency-interest] Thread safety of WeakReference .get()
	method?
In-Reply-To: <5024A4A1.9070103@oracle.com>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>
	<50211CCD.7020803@oracle.com> <50222235.5070601@javaspecialists.eu>
	<50222A24.2080700@oracle.com>
	<CAEJX8ooc70wGehYoVVc9PdrsuCwWNbKQKYPObFG_pCs9DFSosw@mail.gmail.com>
	<CAN1xFdppqBGPPtZnqhW4WzC9-=t3WYpKnUNf-KRmsBUp2EpZMg@mail.gmail.com>
	<CAHjP37HZM0to+f55mK4v414OvFvSAQgzR1D4rv4sfcYoP+wM7A@mail.gmail.com>
	<CAN1xFdoN4b_D=8q_rAOeiafzJWZProT51VTyjWeNWtEbkAvxyA@mail.gmail.com>
	<CAHjP37G+LkBZQc=YUXMJK9gYh=XbHV4oQ-_crcqHmzQukACwCg@mail.gmail.com>
	<CAHjP37Ey6r7rta16WjN+CiRceasVHowgQUMg6_1iZ2EBC_qODA@mail.gmail.com>
	<CAHjP37GAjK-SgjQy8=6qnfWwRRynaQrrjeRbbYmoXwkCW47w5w@mail.gmail.com>
	<50227399.3030804@oracle.com> <5024A4A1.9070103@oracle.com>
Message-ID: <CAHjP37F5-2LUYq2aEVk6XkHeNNvy6BhMVmHsOUjmNH+1nw-7UQ@mail.gmail.com>

Yup I saw it on that list as well - quick work by Vladimir! :)

Sent from my phone
On Aug 10, 2012 2:05 AM, "Aleksey Shipilev" <aleksey.shipilev at oracle.com>
wrote:

> On 08/08/2012 06:11 PM, Aleksey Shipilev wrote:
> > Hence, the compiler should probably handle the fields which are normally
> > updated by the GC in a specific way, e.g. prevent hoisting. Marking
> > referent as volatile brings that effect into life, but at the cost of
> > volatile write for the initial value (we had some optimization in mind
> > to handle that, but this is by no means a quick solution).
>
> FYI.
>
> This is the submitted bug (not available in public yet):
>  http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7190310
>
> And this is the fix:
>
> http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2012-August/008190.html
>
> I had double-checked Heinz's testcase now works, and disassembly shows
> plain field read inside the loop. membar_acquire had essentially reduced
> to nop on my x86 laptop.
>
> -Aleksey.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120810/eb7af8c8/attachment.html>

From heinz at javaspecialists.eu  Fri Aug 10 11:44:40 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Fri, 10 Aug 2012 18:44:40 +0300
Subject: [concurrency-interest] Thread safety of WeakReference .get()
 method?
In-Reply-To: <5024A4A1.9070103@oracle.com>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>	<50211CCD.7020803@oracle.com>
	<50222235.5070601@javaspecialists.eu>	<50222A24.2080700@oracle.com>	<CAEJX8ooc70wGehYoVVc9PdrsuCwWNbKQKYPObFG_pCs9DFSosw@mail.gmail.com>	<CAN1xFdppqBGPPtZnqhW4WzC9-=t3WYpKnUNf-KRmsBUp2EpZMg@mail.gmail.com>	<CAHjP37HZM0to+f55mK4v414OvFvSAQgzR1D4rv4sfcYoP+wM7A@mail.gmail.com>	<CAN1xFdoN4b_D=8q_rAOeiafzJWZProT51VTyjWeNWtEbkAvxyA@mail.gmail.com>	<CAHjP37G+LkBZQc=YUXMJK9gYh=XbHV4oQ-_crcqHmzQukACwCg@mail.gmail.com>	<CAHjP37Ey6r7rta16WjN+CiRceasVHowgQUMg6_1iZ2EBC_qODA@mail.gmail.com>	<CAHjP37GAjK-SgjQy8=6qnfWwRRynaQrrjeRbbYmoXwkCW47w5w@mail.gmail.com>	<50227399.3030804@oracle.com>
	<5024A4A1.9070103@oracle.com>
Message-ID: <50252C68.2020603@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120810/e371dccc/attachment.html>

From aleksey.shipilev at oracle.com  Fri Aug 10 12:43:17 2012
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Fri, 10 Aug 2012 20:43:17 +0400
Subject: [concurrency-interest] Thread safety of WeakReference .get()
 method?
In-Reply-To: <50252C68.2020603@javaspecialists.eu>
References: <CAN1xFdrWUsx+_t-_7kxmfhs-m7SmwfW6TpvnB1JecFmnrvZBfQ@mail.gmail.com>	<50211CCD.7020803@oracle.com>
	<50222235.5070601@javaspecialists.eu>	<50222A24.2080700@oracle.com>	<CAEJX8ooc70wGehYoVVc9PdrsuCwWNbKQKYPObFG_pCs9DFSosw@mail.gmail.com>	<CAN1xFdppqBGPPtZnqhW4WzC9-=t3WYpKnUNf-KRmsBUp2EpZMg@mail.gmail.com>	<CAHjP37HZM0to+f55mK4v414OvFvSAQgzR1D4rv4sfcYoP+wM7A@mail.gmail.com>	<CAN1xFdoN4b_D=8q_rAOeiafzJWZProT51VTyjWeNWtEbkAvxyA@mail.gmail.com>	<CAHjP37G+LkBZQc=YUXMJK9gYh=XbHV4oQ-_crcqHmzQukACwCg@mail.gmail.com>	<CAHjP37Ey6r7rta16WjN+CiRceasVHowgQUMg6_1iZ2EBC_qODA@mail.gmail.com>	<CAHjP37GAjK-SgjQy8=6qnfWwRRynaQrrjeRbbYmoXwkCW47w5w@mail.gmail.com>	<50227399.3030804@oracle.com>
	<5024A4A1.9070103@oracle.com> <50252C68.2020603@javaspecialists.eu>
Message-ID: <50253A25.8080905@oracle.com>

The regression tests we have have much too similar form, so don't
bother. I'll try to double-check this test added to internal regression
tracking.

Thanks,
Aleksey.

On 08/10/2012 07:44 PM, Dr Heinz M. Kabutz wrote:
> Hi Aleksey,
> 
> if I convert my test into a JUnit testcase, could we possibly
> incorporate it into a suite of concurrency tests for regression tests?
> 
> Regards
> 
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun Java Champion
> IEEE Certified Software Development Professional
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz 
> 
> 
> 
> On 8/10/12 9:05 AM, Aleksey Shipilev wrote:
>> On 08/08/2012 06:11 PM, Aleksey Shipilev wrote:
>>   
>>> Hence, the compiler should probably handle the fields which are normally
>>> updated by the GC in a specific way, e.g. prevent hoisting. Marking
>>> referent as volatile brings that effect into life, but at the cost of
>>> volatile write for the initial value (we had some optimization in mind
>>> to handle that, but this is by no means a quick solution).
>>>     
>> FYI.
>>
>> This is the submitted bug (not available in public yet):
>>  http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7190310
>>
>> And this is the fix:
>>  http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2012-August/008190.html
>>
>> I had double-checked Heinz's testcase now works, and disassembly shows
>> plain field read inside the loop. membar_acquire had essentially reduced
>> to nop on my x86 laptop.
>>
>> -Aleksey.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>   


From stanimir at riflexo.com  Sun Aug 12 15:33:17 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Sun, 12 Aug 2012 22:33:17 +0300
Subject: [concurrency-interest] ReadMostlyVector ListIterator bug
Message-ID: <CAEJX8orxXg5WCdtOyyPS5C2V0L3EJLz2FtVMvhkp7SmOpu-3mg@mail.gmail.com>

ReadMostlyVector contains a bug in the iterator logic if previous() and
next() are used together.
Below there is a simple test case to reproduce the behavior. The problem is
that validNext and validPrev are not cleared if the iterator is used in
both directions simultaneously. While it's rare behavior to do so, it's
useful to look for an element and return previous/next.
Another side effect is that calling hasPrevious/hasNext may keep reference
(leak) an already removed object but I presume that's ok even for large
lists.

public class RMTest {
    public static void main(String[] args) {
        testList(new jsr166e.extra.ReadMostlyVector<Integer>());
        testList(new java.util.ArrayList<Integer>());
        testList(new java.util.Vector<Integer>());

    }
    private static void testList(java.util.List<Integer> v) {
        out("Testing: "+v.getClass().getName());
        v.add(1);v.add(2);v.add(3);v.add(4);
        ListIterator<Integer> i = v.listIterator();
        out(i.next());
        i.hasPrevious();//ReadMostlyVector remembers the prev value here
        out(i.next());
        out(i.next());
        out(i.previous());//must be 3, not 1 for ReadMostlyVector
    }
    static void out(Object n){
        System.out.println(n);
    }
}

Testing: jsr166e.extra.ReadMostlyVector
1
2
3
1
Testing: java.util.ArrayList
1
2
3
3
Testing: java.util.Vector
1
2
3
3
===================================

Fixing is simple by clearing the flags:
        public E next() {
            if (validNext || hasNext()) {
                *validNext = validPrev = false;**
*                lastRet = cursor++;
                return next;
            }
            throw new NoSuchElementException();
        }

        public E previous() {
            if (validPrev || hasPrevious()) {
                *validNext = validPrev = false;*
                lastRet = cursor--;
                return prev;
            }
            throw new NoSuchElementException();
        }
SubItr methods need the same code
___
Testing: jsr166e.extra.ReadMostlyVector
1
2
3
3
Testing: java.util.ArrayList
1
2
3
3
Testing: java.util.Vector
1
2
3
3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120812/da9b9552/attachment.html>

From richard.warburton at gmail.com  Sun Aug 12 15:35:51 2012
From: richard.warburton at gmail.com (Richard Warburton)
Date: Sun, 12 Aug 2012 20:35:51 +0100
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
Message-ID: <CAMaYbv+svk1YHoJbytU7wZ8CuWA9WxfkdX=Q8wnQ5dvV7f_dqA@mail.gmail.com>

Hello,

The current implementation of java.io.File::toPath [0] appears to be
using the double checked locking pattern:

     public Path toPath() {
         Path result = filePath;
         if (result == null) {
             synchronized (this) {
                 result = filePath;
                 if (result == null) {
                     result = FileSystems.getDefault().getPath(path);
                     filePath = result;
                 }
             }
         }
         return result;
     }

I was going to report the bug, but I'm a little uncertain of the
interaction between the local variable 'result' and DCL since I've
previously only seen the checking condition on the shared field
itself.  Can someone here either confirm that its a bug or explain how
the 'result' variable is fixing things?

regards,

  Richard

[0] See the end of
hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/classes/java/io/File.java

From vyazelenko at yahoo.com  Sun Aug 12 15:48:48 2012
From: vyazelenko at yahoo.com (Dmitry Vyazelenko)
Date: Sun, 12 Aug 2012 21:48:48 +0200
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAMaYbv+svk1YHoJbytU7wZ8CuWA9WxfkdX=Q8wnQ5dvV7f_dqA@mail.gmail.com>
References: <CAMaYbv+svk1YHoJbytU7wZ8CuWA9WxfkdX=Q8wnQ5dvV7f_dqA@mail.gmail.com>
Message-ID: <0FD54160-D853-4241-9DDE-CE811866EB9E@yahoo.com>

Hi Richard,

The variable "filePath" is volatile, so the double-checked locking is correct in this case. It would have been a bug prior to Java 5.

Best regards,

Dmitry Vyazelenko

On Aug 12, 2012, at 21:35 , Richard Warburton <richard.warburton at gmail.com> wrote:

> Hello,
> 
> The current implementation of java.io.File::toPath [0] appears to be
> using the double checked locking pattern:
> 
>     public Path toPath() {
>         Path result = filePath;
>         if (result == null) {
>             synchronized (this) {
>                 result = filePath;
>                 if (result == null) {
>                     result = FileSystems.getDefault().getPath(path);
>                     filePath = result;
>                 }
>             }
>         }
>         return result;
>     }
> 
> I was going to report the bug, but I'm a little uncertain of the
> interaction between the local variable 'result' and DCL since I've
> previously only seen the checking condition on the shared field
> itself.  Can someone here either confirm that its a bug or explain how
> the 'result' variable is fixing things?
> 
> regards,
> 
>  Richard
> 
> [0] See the end of
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/classes/java/io/File.java
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From gregg at cytetech.com  Sun Aug 12 15:53:03 2012
From: gregg at cytetech.com (Gregg Wonderly)
Date: Sun, 12 Aug 2012 14:53:03 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAMaYbv+svk1YHoJbytU7wZ8CuWA9WxfkdX=Q8wnQ5dvV7f_dqA@mail.gmail.com>
References: <CAMaYbv+svk1YHoJbytU7wZ8CuWA9WxfkdX=Q8wnQ5dvV7f_dqA@mail.gmail.com>
Message-ID: <5028099F.8060908@cytetech.com>

On 8/12/2012 2:35 PM, Richard Warburton wrote:
> Hello,
>
> The current implementation of java.io.File::toPath [0] appears to be
> using the double checked locking pattern:
>
>       public Path toPath() {
>           Path result = filePath;
>           if (result == null) {
>               synchronized (this) {
>                   result = filePath;
>                   if (result == null) {
>                       result = FileSystems.getDefault().getPath(path);
>                       filePath = result;
>                   }
>               }
>           }
>           return result;
>       }
>
> I was going to report the bug, but I'm a little uncertain of the
> interaction between the local variable 'result' and DCL since I've
> previously only seen the checking condition on the shared field
> itself.  Can someone here either confirm that its a bug or explain how
> the 'result' variable is fixing things?

Since filePath is volatile, the double check will "work" from a visibility 
perspective.  The volatile read of filePath goes into the result variable, and 
if it is not set, then the synchronized section creates the necessary 
ordering/control sequence to set filePath correctly.

So, it's the "volatile" on filePath that allows this to work.  Without volatile 
working correctly (the JMM spec changes in JDK 1.5 is where this started working 
on all JVMs), the double check doesn't do the right thing.  Now, this works, and 
has become a quite common "performance" change to reduce locking on lazy 
initializations like this.

Gregg Wonderly


From stanimir at riflexo.com  Sun Aug 12 15:53:31 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Sun, 12 Aug 2012 22:53:31 +0300
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAMaYbv+svk1YHoJbytU7wZ8CuWA9WxfkdX=Q8wnQ5dvV7f_dqA@mail.gmail.com>
References: <CAMaYbv+svk1YHoJbytU7wZ8CuWA9WxfkdX=Q8wnQ5dvV7f_dqA@mail.gmail.com>
Message-ID: <CAEJX8orYH1KawJq9Vd+D3dsHUVKceBgqA3DxnMGQfJrrCvz10A@mail.gmail.com>

Hi!
The code looks fine with regard to double-check idiom - filePath is
declared volatile and there is a monitor on write/double check.
String path is final, so it'd guaranteed  to be properly initialized. The
local var. result helps reduce the volatile reads.

No bug in that code (setLastModified javadocs is still incorrect for FAT
file system, only even seconds allowed there).


Stanimir

On Sun, Aug 12, 2012 at 10:35 PM, Richard Warburton <
richard.warburton at gmail.com> wrote:

> Hello,
>
> The current implementation of java.io.File::toPath [0] appears to be
> using the double checked locking pattern:
>
>      public Path toPath() {
>          Path result = filePath;
>          if (result == null) {
>              synchronized (this) {
>                  result = filePath;
>                  if (result == null) {
>                      result = FileSystems.getDefault().getPath(path);
>                      filePath = result;
>                  }
>              }
>          }
>          return result;
>      }
>
> I was going to report the bug, but I'm a little uncertain of the
> interaction between the local variable 'result' and DCL since I've
> previously only seen the checking condition on the shared field
> itself.  Can someone here either confirm that its a bug or explain how
> the 'result' variable is fixing things?
>
> regards,
>
>   Richard
>
> [0] See the end of
>
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/classes/java/io/File.java
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120812/d6e5682c/attachment-0001.html>

From henri.tremblay at gmail.com  Sun Aug 12 16:38:51 2012
From: henri.tremblay at gmail.com (Henri Tremblay)
Date: Sun, 12 Aug 2012 22:38:51 +0200
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAMaYbv+svk1YHoJbytU7wZ8CuWA9WxfkdX=Q8wnQ5dvV7f_dqA@mail.gmail.com>
References: <CAMaYbv+svk1YHoJbytU7wZ8CuWA9WxfkdX=Q8wnQ5dvV7f_dqA@mail.gmail.com>
Message-ID: <CADZL2=uOoizW2J2ZvX6WUAbm2mK=-wOU5qSL+1r5gkzL+b77pw@mail.gmail.com>

It's a valid flavor of DCL. filePath being volatile there is no issue
about doing a DCL on it.

-
Henri

On 12 August 2012 21:35, Richard Warburton <richard.warburton at gmail.com> wrote:
> Hello,
>
> The current implementation of java.io.File::toPath [0] appears to be
> using the double checked locking pattern:
>
>      public Path toPath() {
>          Path result = filePath;
>          if (result == null) {
>              synchronized (this) {
>                  result = filePath;
>                  if (result == null) {
>                      result = FileSystems.getDefault().getPath(path);
>                      filePath = result;
>                  }
>              }
>          }
>          return result;
>      }
>
> I was going to report the bug, but I'm a little uncertain of the
> interaction between the local variable 'result' and DCL since I've
> previously only seen the checking condition on the shared field
> itself.  Can someone here either confirm that its a bug or explain how
> the 'result' variable is fixing things?
>
> regards,
>
>   Richard
>
> [0] See the end of
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/classes/java/io/File.java
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From cheremin at gmail.com  Sun Aug 12 16:53:32 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Mon, 13 Aug 2012 00:53:32 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <0FD54160-D853-4241-9DDE-CE811866EB9E@yahoo.com>
References: <CAMaYbv+svk1YHoJbytU7wZ8CuWA9WxfkdX=Q8wnQ5dvV7f_dqA@mail.gmail.com>
	<0FD54160-D853-4241-9DDE-CE811866EB9E@yahoo.com>
Message-ID: <CAOwENiLMBKqJ8Y=t-EE1myuJYUpZE8y3dAtFmBeOuLPqHZmt_A@mail.gmail.com>

First of all, Path is immutable, so DCL is safe here even without
volatile. Volatile here is not required from my point of view.



2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> Hi Richard,
>
> The variable "filePath" is volatile, so the double-checked locking is correct in this case. It would have been a bug prior to Java 5.
>
> Best regards,
>
> Dmitry Vyazelenko
>
> On Aug 12, 2012, at 21:35 , Richard Warburton <richard.warburton at gmail.com> wrote:
>
>> Hello,
>>
>> The current implementation of java.io.File::toPath [0] appears to be
>> using the double checked locking pattern:
>>
>>     public Path toPath() {
>>         Path result = filePath;
>>         if (result == null) {
>>             synchronized (this) {
>>                 result = filePath;
>>                 if (result == null) {
>>                     result = FileSystems.getDefault().getPath(path);
>>                     filePath = result;
>>                 }
>>             }
>>         }
>>         return result;
>>     }
>>
>> I was going to report the bug, but I'm a little uncertain of the
>> interaction between the local variable 'result' and DCL since I've
>> previously only seen the checking condition on the shared field
>> itself.  Can someone here either confirm that its a bug or explain how
>> the 'result' variable is fixing things?
>>
>> regards,
>>
>>  Richard
>>
>> [0] See the end of
>> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/classes/java/io/File.java
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From davidcholmes at aapt.net.au  Sun Aug 12 18:30:38 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 13 Aug 2012 08:30:38 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENiLMBKqJ8Y=t-EE1myuJYUpZE8y3dAtFmBeOuLPqHZmt_A@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEAFJGAA.davidcholmes@aapt.net.au>

Ruslan Cheremin writes:
>
> First of all, Path is immutable, so DCL is safe here even without
> volatile. Volatile here is not required from my point of view.

Without the volatile the Path implementation (Path is an interface) must be
such that an instance of Path can be safely published without any additional
forms of synchronization. Immutability does not in itself ensure that. You
would have to examine the actual implementation class.

David Holmes
------------

>
>
> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> > Hi Richard,
> >
> > The variable "filePath" is volatile, so the double-checked
> locking is correct in this case. It would have been a bug prior to Java 5.
> >
> > Best regards,
> >
> > Dmitry Vyazelenko
> >
> > On Aug 12, 2012, at 21:35 , Richard Warburton
> <richard.warburton at gmail.com> wrote:
> >
> >> Hello,
> >>
> >> The current implementation of java.io.File::toPath [0] appears to be
> >> using the double checked locking pattern:
> >>
> >>     public Path toPath() {
> >>         Path result = filePath;
> >>         if (result == null) {
> >>             synchronized (this) {
> >>                 result = filePath;
> >>                 if (result == null) {
> >>                     result = FileSystems.getDefault().getPath(path);
> >>                     filePath = result;
> >>                 }
> >>             }
> >>         }
> >>         return result;
> >>     }
> >>
> >> I was going to report the bug, but I'm a little uncertain of the
> >> interaction between the local variable 'result' and DCL since I've
> >> previously only seen the checking condition on the shared field
> >> itself.  Can someone here either confirm that its a bug or explain how
> >> the 'result' variable is fixing things?
> >>
> >> regards,
> >>
> >>  Richard
> >>
> >> [0] See the end of
> >>
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> ses/java/io/File.java
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From rsk at moocat.org  Sun Aug 12 21:09:51 2012
From: rsk at moocat.org (R Samuel Klatchko)
Date: Sun, 12 Aug 2012 18:09:51 -0700
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEAFJGAA.davidcholmes@aapt.net.au>
References: <CAOwENiLMBKqJ8Y=t-EE1myuJYUpZE8y3dAtFmBeOuLPqHZmt_A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCMEAFJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAM6f_1nB3W_kX5AsUTzj2-UHes+4+FMaqHY6Qs59q94G8RsLYQ@mail.gmail.com>

Also, wouldn't this be a benign data race as wanting to
call FileSystems.getDefault().getPath only once is for performance and not
for correctness.

On Sun, Aug 12, 2012 at 3:30 PM, David Holmes <davidcholmes at aapt.net.au>wrote:

> Ruslan Cheremin writes:
> >
> > First of all, Path is immutable, so DCL is safe here even without
> > volatile. Volatile here is not required from my point of view.
>
> Without the volatile the Path implementation (Path is an interface) must be
> such that an instance of Path can be safely published without any
> additional
> forms of synchronization. Immutability does not in itself ensure that. You
> would have to examine the actual implementation class.
>
> David Holmes
> ------------
>
> >
> >
> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> > > Hi Richard,
> > >
> > > The variable "filePath" is volatile, so the double-checked
> > locking is correct in this case. It would have been a bug prior to Java
> 5.
> > >
> > > Best regards,
> > >
> > > Dmitry Vyazelenko
> > >
> > > On Aug 12, 2012, at 21:35 , Richard Warburton
> > <richard.warburton at gmail.com> wrote:
> > >
> > >> Hello,
> > >>
> > >> The current implementation of java.io.File::toPath [0] appears to be
> > >> using the double checked locking pattern:
> > >>
> > >>     public Path toPath() {
> > >>         Path result = filePath;
> > >>         if (result == null) {
> > >>             synchronized (this) {
> > >>                 result = filePath;
> > >>                 if (result == null) {
> > >>                     result = FileSystems.getDefault().getPath(path);
> > >>                     filePath = result;
> > >>                 }
> > >>             }
> > >>         }
> > >>         return result;
> > >>     }
> > >>
> > >> I was going to report the bug, but I'm a little uncertain of the
> > >> interaction between the local variable 'result' and DCL since I've
> > >> previously only seen the checking condition on the shared field
> > >> itself.  Can someone here either confirm that its a bug or explain how
> > >> the 'result' variable is fixing things?
> > >>
> > >> regards,
> > >>
> > >>  Richard
> > >>
> > >> [0] See the end of
> > >>
> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> > ses/java/io/File.java
> > >> _______________________________________________
> > >> Concurrency-interest mailing list
> > >> Concurrency-interest at cs.oswego.edu
> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120812/5492e95c/attachment.html>

From davidcholmes at aapt.net.au  Sun Aug 12 21:46:24 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 13 Aug 2012 11:46:24 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAM6f_1nB3W_kX5AsUTzj2-UHes+4+FMaqHY6Qs59q94G8RsLYQ@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEAJJGAA.davidcholmes@aapt.net.au>

For a data race to be benign the object to be installed must be idempotent (ie always the same no matter who wins the race) and safely published. I don't know whether this particular API defines an idempotent value. If it did then you wouldn't need the sync block, just the volatile, for correctness. You may still want the sync block for performance reasons.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of R Samuel Klatchko
  Sent: Monday, 13 August 2012 11:10 AM
  To: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK


  Also, wouldn't this be a benign data race as wanting to call FileSystems.getDefault().getPath only once is for performance and not for correctness.


  On Sun, Aug 12, 2012 at 3:30 PM, David Holmes <davidcholmes at aapt.net.au> wrote:

    Ruslan Cheremin writes:
    >
    > First of all, Path is immutable, so DCL is safe here even without
    > volatile. Volatile here is not required from my point of view.


    Without the volatile the Path implementation (Path is an interface) must be
    such that an instance of Path can be safely published without any additional
    forms of synchronization. Immutability does not in itself ensure that. You
    would have to examine the actual implementation class.

    David Holmes
    ------------


    >
    >
    > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
    > > Hi Richard,
    > >
    > > The variable "filePath" is volatile, so the double-checked
    > locking is correct in this case. It would have been a bug prior to Java 5.
    > >
    > > Best regards,
    > >
    > > Dmitry Vyazelenko
    > >
    > > On Aug 12, 2012, at 21:35 , Richard Warburton
    > <richard.warburton at gmail.com> wrote:
    > >
    > >> Hello,
    > >>
    > >> The current implementation of java.io.File::toPath [0] appears to be
    > >> using the double checked locking pattern:
    > >>
    > >>     public Path toPath() {
    > >>         Path result = filePath;
    > >>         if (result == null) {
    > >>             synchronized (this) {
    > >>                 result = filePath;
    > >>                 if (result == null) {
    > >>                     result = FileSystems.getDefault().getPath(path);
    > >>                     filePath = result;
    > >>                 }
    > >>             }
    > >>         }
    > >>         return result;
    > >>     }
    > >>
    > >> I was going to report the bug, but I'm a little uncertain of the
    > >> interaction between the local variable 'result' and DCL since I've
    > >> previously only seen the checking condition on the shared field
    > >> itself.  Can someone here either confirm that its a bug or explain how
    > >> the 'result' variable is fixing things?
    > >>
    > >> regards,
    > >>
    > >>  Richard
    > >>
    > >> [0] See the end of
    > >>
    > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
    > ses/java/io/File.java
    > >> _______________________________________________
    > >> Concurrency-interest mailing list
    > >> Concurrency-interest at cs.oswego.edu
    > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >
    > >
    > > _______________________________________________
    > > Concurrency-interest mailing list
    > > Concurrency-interest at cs.oswego.edu
    > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > _______________________________________________
    > Concurrency-interest mailing list
    > Concurrency-interest at cs.oswego.edu
    > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    >

    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at cs.oswego.edu
    http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120813/6219bdd4/attachment-0001.html>

From joe.bowbeer at gmail.com  Sun Aug 12 21:46:35 2012
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sun, 12 Aug 2012 18:46:35 -0700
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAM6f_1nB3W_kX5AsUTzj2-UHes+4+FMaqHY6Qs59q94G8RsLYQ@mail.gmail.com>
References: <CAOwENiLMBKqJ8Y=t-EE1myuJYUpZE8y3dAtFmBeOuLPqHZmt_A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCMEAFJGAA.davidcholmes@aapt.net.au>
	<CAM6f_1nB3W_kX5AsUTzj2-UHes+4+FMaqHY6Qs59q94G8RsLYQ@mail.gmail.com>
Message-ID: <CAHzJPEoCBX=2QLM_7LbtSQHeev7bfXGVHwu9JmX9+6hxmMK7Xw@mail.gmail.com>

On Sun, Aug 12, 2012 at 6:09 PM, R Samuel Klatchko wrote:

> Also, wouldn't this be a benign data race as wanting to
> call FileSystems.getDefault().getPath only once is for performance and not
> for correctness.


In general, Double-checked locking is broken because observing ref != null
in one thread (without synchronization) does not ensure that the internal
state of the referenced object has been safely published to that thread.

In this specific case, however, I just noticed that the Path javadoc
requires thread safety in addition to immutability:

"Implementations of this interface are immutable and safe for use by
multiple concurrent threads."

--Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120812/989802e4/attachment.html>

From cheremin at gmail.com  Mon Aug 13 00:38:48 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Mon, 13 Aug 2012 08:38:48 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEAFJGAA.davidcholmes@aapt.net.au>
References: <CAOwENiLMBKqJ8Y=t-EE1myuJYUpZE8y3dAtFmBeOuLPqHZmt_A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCMEAFJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAOwENi+VUmw7Uynb5Q4WpvnWyXPnvOHsfdOimjhSfh-AqpH9aw@mail.gmail.com>

Well, Path javadoc explicitly says "immutable and safe for
multithreaded use". Although it is not strictly defined in java what
exactly means "safe for multithreaded use" -- does it mean safe for
publishing via data race, among others? -- I suppose, it should be. Am
I wrong here?

>From other side, File.toPath javadoc explicitly says what "returned
instance must be the same for every invocation", so sync block is
required here for mutual exclusion on initialization phase. Without
this requirement it is also safe to live without sync block, afaik.

2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> Ruslan Cheremin writes:
>>
>> First of all, Path is immutable, so DCL is safe here even without
>> volatile. Volatile here is not required from my point of view.
>
> Without the volatile the Path implementation (Path is an interface) must be
> such that an instance of Path can be safely published without any additional
> forms of synchronization. Immutability does not in itself ensure that. You
> would have to examine the actual implementation class.
>
> David Holmes
> ------------
>
>>
>>
>> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> > Hi Richard,
>> >
>> > The variable "filePath" is volatile, so the double-checked
>> locking is correct in this case. It would have been a bug prior to Java 5.
>> >
>> > Best regards,
>> >
>> > Dmitry Vyazelenko
>> >
>> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> <richard.warburton at gmail.com> wrote:
>> >
>> >> Hello,
>> >>
>> >> The current implementation of java.io.File::toPath [0] appears to be
>> >> using the double checked locking pattern:
>> >>
>> >>     public Path toPath() {
>> >>         Path result = filePath;
>> >>         if (result == null) {
>> >>             synchronized (this) {
>> >>                 result = filePath;
>> >>                 if (result == null) {
>> >>                     result = FileSystems.getDefault().getPath(path);
>> >>                     filePath = result;
>> >>                 }
>> >>             }
>> >>         }
>> >>         return result;
>> >>     }
>> >>
>> >> I was going to report the bug, but I'm a little uncertain of the
>> >> interaction between the local variable 'result' and DCL since I've
>> >> previously only seen the checking condition on the shared field
>> >> itself.  Can someone here either confirm that its a bug or explain how
>> >> the 'result' variable is fixing things?
>> >>
>> >> regards,
>> >>
>> >>  Richard
>> >>
>> >> [0] See the end of
>> >>
>> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> ses/java/io/File.java
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>

From davidcholmes at aapt.net.au  Mon Aug 13 00:51:22 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 13 Aug 2012 14:51:22 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENi+VUmw7Uynb5Q4WpvnWyXPnvOHsfdOimjhSfh-AqpH9aw@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEALJGAA.davidcholmes@aapt.net.au>

Ruslan Cheremin writes:
> Well, Path javadoc explicitly says "immutable and safe for
> multithreaded use". Although it is not strictly defined in java what
> exactly means "safe for multithreaded use" -- does it mean safe for
> publishing via data race, among others? -- I suppose, it should be. Am
> I wrong here?

"safe for multi-threaded use" does not generally imply that it is safe to
publish instances without synchronization of some form.

David
-----

> From other side, File.toPath javadoc explicitly says what "returned
> instance must be the same for every invocation", so sync block is
> required here for mutual exclusion on initialization phase. Without
> this requirement it is also safe to live without sync block, afaik.
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > Ruslan Cheremin writes:
> >>
> >> First of all, Path is immutable, so DCL is safe here even without
> >> volatile. Volatile here is not required from my point of view.
> >
> > Without the volatile the Path implementation (Path is an
> interface) must be
> > such that an instance of Path can be safely published without
> any additional
> > forms of synchronization. Immutability does not in itself
> ensure that. You
> > would have to examine the actual implementation class.
> >
> > David Holmes
> > ------------
> >
> >>
> >>
> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> > Hi Richard,
> >> >
> >> > The variable "filePath" is volatile, so the double-checked
> >> locking is correct in this case. It would have been a bug
> prior to Java 5.
> >> >
> >> > Best regards,
> >> >
> >> > Dmitry Vyazelenko
> >> >
> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> <richard.warburton at gmail.com> wrote:
> >> >
> >> >> Hello,
> >> >>
> >> >> The current implementation of java.io.File::toPath [0] appears to be
> >> >> using the double checked locking pattern:
> >> >>
> >> >>     public Path toPath() {
> >> >>         Path result = filePath;
> >> >>         if (result == null) {
> >> >>             synchronized (this) {
> >> >>                 result = filePath;
> >> >>                 if (result == null) {
> >> >>                     result = FileSystems.getDefault().getPath(path);
> >> >>                     filePath = result;
> >> >>                 }
> >> >>             }
> >> >>         }
> >> >>         return result;
> >> >>     }
> >> >>
> >> >> I was going to report the bug, but I'm a little uncertain of the
> >> >> interaction between the local variable 'result' and DCL since I've
> >> >> previously only seen the checking condition on the shared field
> >> >> itself.  Can someone here either confirm that its a bug or
> explain how
> >> >> the 'result' variable is fixing things?
> >> >>
> >> >> regards,
> >> >>
> >> >>  Richard
> >> >>
> >> >> [0] See the end of
> >> >>
> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> ses/java/io/File.java
> >> >> _______________________________________________
> >> >> Concurrency-interest mailing list
> >> >> Concurrency-interest at cs.oswego.edu
> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >
>


From cheremin at gmail.com  Mon Aug 13 01:03:42 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Mon, 13 Aug 2012 09:03:42 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEALJGAA.davidcholmes@aapt.net.au>
References: <CAOwENi+VUmw7Uynb5Q4WpvnWyXPnvOHsfdOimjhSfh-AqpH9aw@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEALJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>

But is there a way to define "safe for data race publishing"? I as
far, as I remember, "immutable and thread-safe" is standard mantra in
JDK javadocs for totally safe objects. j.l.String has same mantra --
and it is safe for any way of publishing. Does you mean, I should
explicitly add "safe even for publishing via data race" in docs? But I
can't remember any such phrase in JDK docs.

2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> Ruslan Cheremin writes:
>> Well, Path javadoc explicitly says "immutable and safe for
>> multithreaded use". Although it is not strictly defined in java what
>> exactly means "safe for multithreaded use" -- does it mean safe for
>> publishing via data race, among others? -- I suppose, it should be. Am
>> I wrong here?
>
> "safe for multi-threaded use" does not generally imply that it is safe to
> publish instances without synchronization of some form.
>
> David
> -----
>
>> From other side, File.toPath javadoc explicitly says what "returned
>> instance must be the same for every invocation", so sync block is
>> required here for mutual exclusion on initialization phase. Without
>> this requirement it is also safe to live without sync block, afaik.
>>
>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> > Ruslan Cheremin writes:
>> >>
>> >> First of all, Path is immutable, so DCL is safe here even without
>> >> volatile. Volatile here is not required from my point of view.
>> >
>> > Without the volatile the Path implementation (Path is an
>> interface) must be
>> > such that an instance of Path can be safely published without
>> any additional
>> > forms of synchronization. Immutability does not in itself
>> ensure that. You
>> > would have to examine the actual implementation class.
>> >
>> > David Holmes
>> > ------------
>> >
>> >>
>> >>
>> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> > Hi Richard,
>> >> >
>> >> > The variable "filePath" is volatile, so the double-checked
>> >> locking is correct in this case. It would have been a bug
>> prior to Java 5.
>> >> >
>> >> > Best regards,
>> >> >
>> >> > Dmitry Vyazelenko
>> >> >
>> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> <richard.warburton at gmail.com> wrote:
>> >> >
>> >> >> Hello,
>> >> >>
>> >> >> The current implementation of java.io.File::toPath [0] appears to be
>> >> >> using the double checked locking pattern:
>> >> >>
>> >> >>     public Path toPath() {
>> >> >>         Path result = filePath;
>> >> >>         if (result == null) {
>> >> >>             synchronized (this) {
>> >> >>                 result = filePath;
>> >> >>                 if (result == null) {
>> >> >>                     result = FileSystems.getDefault().getPath(path);
>> >> >>                     filePath = result;
>> >> >>                 }
>> >> >>             }
>> >> >>         }
>> >> >>         return result;
>> >> >>     }
>> >> >>
>> >> >> I was going to report the bug, but I'm a little uncertain of the
>> >> >> interaction between the local variable 'result' and DCL since I've
>> >> >> previously only seen the checking condition on the shared field
>> >> >> itself.  Can someone here either confirm that its a bug or
>> explain how
>> >> >> the 'result' variable is fixing things?
>> >> >>
>> >> >> regards,
>> >> >>
>> >> >>  Richard
>> >> >>
>> >> >> [0] See the end of
>> >> >>
>> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> ses/java/io/File.java
>> >> >> _______________________________________________
>> >> >> Concurrency-interest mailing list
>> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>
>> >
>>
>

From linzuxiong1988 at gmail.com  Mon Aug 13 01:09:27 2012
From: linzuxiong1988 at gmail.com (zuxiong lin)
Date: Mon, 13 Aug 2012 13:09:27 +0800
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
References: <CAOwENi+VUmw7Uynb5Q4WpvnWyXPnvOHsfdOimjhSfh-AqpH9aw@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEALJGAA.davidcholmes@aapt.net.au>
	<CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
Message-ID: <CACSA5wZ1NJFyCRsX19-vRmy-6L3fJ2wa1img93i1QfMf8eejcQ@mail.gmail.com>

A class is thread-safe if it behaves correctly when accessed from multiple
threads, regardless of the scheduling or
interleaving of the execution of those threads by the runtime environment,
and with no additional synchronization or
other coordination on the part of the calling code.

On Mon, Aug 13, 2012 at 1:03 PM, Ruslan Cheremin <cheremin at gmail.com> wrote:

> But is there a way to define "safe for data race publishing"? I as
> far, as I remember, "immutable and thread-safe" is standard mantra in
> JDK javadocs for totally safe objects. j.l.String has same mantra --
> and it is safe for any way of publishing. Does you mean, I should
> explicitly add "safe even for publishing via data race" in docs? But I
> can't remember any such phrase in JDK docs.
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > Ruslan Cheremin writes:
> >> Well, Path javadoc explicitly says "immutable and safe for
> >> multithreaded use". Although it is not strictly defined in java what
> >> exactly means "safe for multithreaded use" -- does it mean safe for
> >> publishing via data race, among others? -- I suppose, it should be. Am
> >> I wrong here?
> >
> > "safe for multi-threaded use" does not generally imply that it is safe to
> > publish instances without synchronization of some form.
> >
> > David
> > -----
> >
> >> From other side, File.toPath javadoc explicitly says what "returned
> >> instance must be the same for every invocation", so sync block is
> >> required here for mutual exclusion on initialization phase. Without
> >> this requirement it is also safe to live without sync block, afaik.
> >>
> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> > Ruslan Cheremin writes:
> >> >>
> >> >> First of all, Path is immutable, so DCL is safe here even without
> >> >> volatile. Volatile here is not required from my point of view.
> >> >
> >> > Without the volatile the Path implementation (Path is an
> >> interface) must be
> >> > such that an instance of Path can be safely published without
> >> any additional
> >> > forms of synchronization. Immutability does not in itself
> >> ensure that. You
> >> > would have to examine the actual implementation class.
> >> >
> >> > David Holmes
> >> > ------------
> >> >
> >> >>
> >> >>
> >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> > Hi Richard,
> >> >> >
> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> locking is correct in this case. It would have been a bug
> >> prior to Java 5.
> >> >> >
> >> >> > Best regards,
> >> >> >
> >> >> > Dmitry Vyazelenko
> >> >> >
> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> <richard.warburton at gmail.com> wrote:
> >> >> >
> >> >> >> Hello,
> >> >> >>
> >> >> >> The current implementation of java.io.File::toPath [0] appears to
> be
> >> >> >> using the double checked locking pattern:
> >> >> >>
> >> >> >>     public Path toPath() {
> >> >> >>         Path result = filePath;
> >> >> >>         if (result == null) {
> >> >> >>             synchronized (this) {
> >> >> >>                 result = filePath;
> >> >> >>                 if (result == null) {
> >> >> >>                     result =
> FileSystems.getDefault().getPath(path);
> >> >> >>                     filePath = result;
> >> >> >>                 }
> >> >> >>             }
> >> >> >>         }
> >> >> >>         return result;
> >> >> >>     }
> >> >> >>
> >> >> >> I was going to report the bug, but I'm a little uncertain of the
> >> >> >> interaction between the local variable 'result' and DCL since I've
> >> >> >> previously only seen the checking condition on the shared field
> >> >> >> itself.  Can someone here either confirm that its a bug or
> >> explain how
> >> >> >> the 'result' variable is fixing things?
> >> >> >>
> >> >> >> regards,
> >> >> >>
> >> >> >>  Richard
> >> >> >>
> >> >> >> [0] See the end of
> >> >> >>
> >> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> ses/java/io/File.java
> >> >> >> _______________________________________________
> >> >> >> Concurrency-interest mailing list
> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> _______________________________________________
> >> >> Concurrency-interest mailing list
> >> >> Concurrency-interest at cs.oswego.edu
> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>
> >> >
> >>
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120813/5ea1cf17/attachment-0001.html>

From davidcholmes at aapt.net.au  Mon Aug 13 01:13:38 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 13 Aug 2012 15:13:38 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>

Ruslan Cheremin writes:>
> But is there a way to define "safe for data race publishing"? I as
> far, as I remember, "immutable and thread-safe" is standard mantra in
> JDK javadocs for totally safe objects. j.l.String has same mantra --
> and it is safe for any way of publishing. Does you mean, I should
> explicitly add "safe even for publishing via data race" in docs? But I
> can't remember any such phrase in JDK docs.

I don't recall anything in the JDK docs that mention being "totally safe"
regardless of publication mechanism. Some classes, eg String, have been
defined such that they do have that property (for security reasons). In
general neither "thread-safe" nor "immutable" imply
safe-for-unsynchronized-publication.

Java Concurrency In Practice (jcip.net) does define additional potential
annotations, where @Immutable would indeed capture the requirement of
safe-for-unsynchronized-publication.

David
-----

> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > Ruslan Cheremin writes:
> >> Well, Path javadoc explicitly says "immutable and safe for
> >> multithreaded use". Although it is not strictly defined in java what
> >> exactly means "safe for multithreaded use" -- does it mean safe for
> >> publishing via data race, among others? -- I suppose, it should be. Am
> >> I wrong here?
> >
> > "safe for multi-threaded use" does not generally imply that it
> is safe to
> > publish instances without synchronization of some form.
> >
> > David
> > -----
> >
> >> From other side, File.toPath javadoc explicitly says what "returned
> >> instance must be the same for every invocation", so sync block is
> >> required here for mutual exclusion on initialization phase. Without
> >> this requirement it is also safe to live without sync block, afaik.
> >>
> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> > Ruslan Cheremin writes:
> >> >>
> >> >> First of all, Path is immutable, so DCL is safe here even without
> >> >> volatile. Volatile here is not required from my point of view.
> >> >
> >> > Without the volatile the Path implementation (Path is an
> >> interface) must be
> >> > such that an instance of Path can be safely published without
> >> any additional
> >> > forms of synchronization. Immutability does not in itself
> >> ensure that. You
> >> > would have to examine the actual implementation class.
> >> >
> >> > David Holmes
> >> > ------------
> >> >
> >> >>
> >> >>
> >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> > Hi Richard,
> >> >> >
> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> locking is correct in this case. It would have been a bug
> >> prior to Java 5.
> >> >> >
> >> >> > Best regards,
> >> >> >
> >> >> > Dmitry Vyazelenko
> >> >> >
> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> <richard.warburton at gmail.com> wrote:
> >> >> >
> >> >> >> Hello,
> >> >> >>
> >> >> >> The current implementation of java.io.File::toPath [0]
> appears to be
> >> >> >> using the double checked locking pattern:
> >> >> >>
> >> >> >>     public Path toPath() {
> >> >> >>         Path result = filePath;
> >> >> >>         if (result == null) {
> >> >> >>             synchronized (this) {
> >> >> >>                 result = filePath;
> >> >> >>                 if (result == null) {
> >> >> >>                     result =
> FileSystems.getDefault().getPath(path);
> >> >> >>                     filePath = result;
> >> >> >>                 }
> >> >> >>             }
> >> >> >>         }
> >> >> >>         return result;
> >> >> >>     }
> >> >> >>
> >> >> >> I was going to report the bug, but I'm a little uncertain of the
> >> >> >> interaction between the local variable 'result' and DCL
> since I've
> >> >> >> previously only seen the checking condition on the shared field
> >> >> >> itself.  Can someone here either confirm that its a bug or
> >> explain how
> >> >> >> the 'result' variable is fixing things?
> >> >> >>
> >> >> >> regards,
> >> >> >>
> >> >> >>  Richard
> >> >> >>
> >> >> >> [0] See the end of
> >> >> >>
> >> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> ses/java/io/File.java
> >> >> >> _______________________________________________
> >> >> >> Concurrency-interest mailing list
> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> _______________________________________________
> >> >> Concurrency-interest mailing list
> >> >> Concurrency-interest at cs.oswego.edu
> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>
> >> >
> >>
> >
>


From davidcholmes at aapt.net.au  Mon Aug 13 01:19:53 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 13 Aug 2012 15:19:53 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACSA5wZ1NJFyCRsX19-vRmy-6L3fJ2wa1img93i1QfMf8eejcQ@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEANJGAA.davidcholmes@aapt.net.au>

That's a nice definition but what is your point? Do you think this implies
that being thread-safe deals with the manner of how the object was made
accessible? Or not?

David
  -----Original Message-----
  From: zuxiong lin [mailto:linzuxiong1988 at gmail.com]
  Sent: Monday, 13 August 2012 3:09 PM
  To: Ruslan Cheremin
  Cc: dholmes at ieee.org; concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK


  A class is thread-safe if it behaves correctly when accessed from multiple
threads, regardless of the scheduling or
  interleaving of the execution of those threads by the runtime environment,
and with no additional synchronization or
  other coordination on the part of the calling code.


  On Mon, Aug 13, 2012 at 1:03 PM, Ruslan Cheremin <cheremin at gmail.com>
wrote:

    But is there a way to define "safe for data race publishing"? I as
    far, as I remember, "immutable and thread-safe" is standard mantra in
    JDK javadocs for totally safe objects. j.l.String has same mantra --
    and it is safe for any way of publishing. Does you mean, I should
    explicitly add "safe even for publishing via data race" in docs? But I
    can't remember any such phrase in JDK docs.


    2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
    > Ruslan Cheremin writes:
    >> Well, Path javadoc explicitly says "immutable and safe for
    >> multithreaded use". Although it is not strictly defined in java what
    >> exactly means "safe for multithreaded use" -- does it mean safe for
    >> publishing via data race, among others? -- I suppose, it should be.
Am
    >> I wrong here?
    >
    > "safe for multi-threaded use" does not generally imply that it is safe
to
    > publish instances without synchronization of some form.
    >
    > David
    > -----
    >
    >> From other side, File.toPath javadoc explicitly says what "returned
    >> instance must be the same for every invocation", so sync block is
    >> required here for mutual exclusion on initialization phase. Without
    >> this requirement it is also safe to live without sync block, afaik.
    >>
    >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
    >> > Ruslan Cheremin writes:
    >> >>
    >> >> First of all, Path is immutable, so DCL is safe here even without
    >> >> volatile. Volatile here is not required from my point of view.
    >> >
    >> > Without the volatile the Path implementation (Path is an
    >> interface) must be
    >> > such that an instance of Path can be safely published without
    >> any additional
    >> > forms of synchronization. Immutability does not in itself
    >> ensure that. You
    >> > would have to examine the actual implementation class.
    >> >
    >> > David Holmes
    >> > ------------
    >> >
    >> >>
    >> >>
    >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
    >> >> > Hi Richard,
    >> >> >
    >> >> > The variable "filePath" is volatile, so the double-checked
    >> >> locking is correct in this case. It would have been a bug
    >> prior to Java 5.
    >> >> >
    >> >> > Best regards,
    >> >> >
    >> >> > Dmitry Vyazelenko
    >> >> >
    >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
    >> >> <richard.warburton at gmail.com> wrote:
    >> >> >
    >> >> >> Hello,
    >> >> >>
    >> >> >> The current implementation of java.io.File::toPath [0] appears
to be
    >> >> >> using the double checked locking pattern:
    >> >> >>
    >> >> >>     public Path toPath() {
    >> >> >>         Path result = filePath;
    >> >> >>         if (result == null) {
    >> >> >>             synchronized (this) {
    >> >> >>                 result = filePath;
    >> >> >>                 if (result == null) {
    >> >> >>                     result =
FileSystems.getDefault().getPath(path);
    >> >> >>                     filePath = result;
    >> >> >>                 }
    >> >> >>             }
    >> >> >>         }
    >> >> >>         return result;
    >> >> >>     }
    >> >> >>
    >> >> >> I was going to report the bug, but I'm a little uncertain of
the
    >> >> >> interaction between the local variable 'result' and DCL since
I've
    >> >> >> previously only seen the checking condition on the shared field
    >> >> >> itself.  Can someone here either confirm that its a bug or
    >> explain how
    >> >> >> the 'result' variable is fixing things?
    >> >> >>
    >> >> >> regards,
    >> >> >>
    >> >> >>  Richard
    >> >> >>
    >> >> >> [0] See the end of
    >> >> >>
    >> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
    >> >> ses/java/io/File.java
    >> >> >> _______________________________________________
    >> >> >> Concurrency-interest mailing list
    >> >> >> Concurrency-interest at cs.oswego.edu
    >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    >> >> >
    >> >> >
    >> >> > _______________________________________________
    >> >> > Concurrency-interest mailing list
    >> >> > Concurrency-interest at cs.oswego.edu
    >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    >> >> _______________________________________________
    >> >> Concurrency-interest mailing list
    >> >> Concurrency-interest at cs.oswego.edu
    >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    >> >>
    >> >
    >>
    >
    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at cs.oswego.edu
    http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120813/13ba8860/attachment.html>

From heinz at javaspecialists.eu  Mon Aug 13 01:41:11 2012
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Mon, 13 Aug 2012 08:41:11 +0300
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
Message-ID: <CACLL95oD9vC4M81u_dmTLmhqXpFxS+iZ+HZz79yvnzWDwx6=aw@mail.gmail.com>

The j.l.String class is an interesting example to use.  It is thread
safe, but it contains a benign data race in the hashCode() method.
The class contains mutable data, without any synchronisation, yet is
still thread safe.

Heinz

On 13/08/2012, David Holmes <davidcholmes at aapt.net.au> wrote:
> Ruslan Cheremin writes:>
>> But is there a way to define "safe for data race publishing"? I as
>> far, as I remember, "immutable and thread-safe" is standard mantra in
>> JDK javadocs for totally safe objects. j.l.String has same mantra --
>> and it is safe for any way of publishing. Does you mean, I should
>> explicitly add "safe even for publishing via data race" in docs? But I
>> can't remember any such phrase in JDK docs.
>
> I don't recall anything in the JDK docs that mention being "totally safe"
> regardless of publication mechanism. Some classes, eg String, have been
> defined such that they do have that property (for security reasons). In
> general neither "thread-safe" nor "immutable" imply
> safe-for-unsynchronized-publication.
>
> Java Concurrency In Practice (jcip.net) does define additional potential
> annotations, where @Immutable would indeed capture the requirement of
> safe-for-unsynchronized-publication.
>
> David
> -----
>
>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> > Ruslan Cheremin writes:
>> >> Well, Path javadoc explicitly says "immutable and safe for
>> >> multithreaded use". Although it is not strictly defined in java what
>> >> exactly means "safe for multithreaded use" -- does it mean safe for
>> >> publishing via data race, among others? -- I suppose, it should be. Am
>> >> I wrong here?
>> >
>> > "safe for multi-threaded use" does not generally imply that it
>> is safe to
>> > publish instances without synchronization of some form.
>> >
>> > David
>> > -----
>> >
>> >> From other side, File.toPath javadoc explicitly says what "returned
>> >> instance must be the same for every invocation", so sync block is
>> >> required here for mutual exclusion on initialization phase. Without
>> >> this requirement it is also safe to live without sync block, afaik.
>> >>
>> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> > Ruslan Cheremin writes:
>> >> >>
>> >> >> First of all, Path is immutable, so DCL is safe here even without
>> >> >> volatile. Volatile here is not required from my point of view.
>> >> >
>> >> > Without the volatile the Path implementation (Path is an
>> >> interface) must be
>> >> > such that an instance of Path can be safely published without
>> >> any additional
>> >> > forms of synchronization. Immutability does not in itself
>> >> ensure that. You
>> >> > would have to examine the actual implementation class.
>> >> >
>> >> > David Holmes
>> >> > ------------
>> >> >
>> >> >>
>> >> >>
>> >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> >> > Hi Richard,
>> >> >> >
>> >> >> > The variable "filePath" is volatile, so the double-checked
>> >> >> locking is correct in this case. It would have been a bug
>> >> prior to Java 5.
>> >> >> >
>> >> >> > Best regards,
>> >> >> >
>> >> >> > Dmitry Vyazelenko
>> >> >> >
>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >> <richard.warburton at gmail.com> wrote:
>> >> >> >
>> >> >> >> Hello,
>> >> >> >>
>> >> >> >> The current implementation of java.io.File::toPath [0]
>> appears to be
>> >> >> >> using the double checked locking pattern:
>> >> >> >>
>> >> >> >>     public Path toPath() {
>> >> >> >>         Path result = filePath;
>> >> >> >>         if (result == null) {
>> >> >> >>             synchronized (this) {
>> >> >> >>                 result = filePath;
>> >> >> >>                 if (result == null) {
>> >> >> >>                     result =
>> FileSystems.getDefault().getPath(path);
>> >> >> >>                     filePath = result;
>> >> >> >>                 }
>> >> >> >>             }
>> >> >> >>         }
>> >> >> >>         return result;
>> >> >> >>     }
>> >> >> >>
>> >> >> >> I was going to report the bug, but I'm a little uncertain of the
>> >> >> >> interaction between the local variable 'result' and DCL
>> since I've
>> >> >> >> previously only seen the checking condition on the shared field
>> >> >> >> itself.  Can someone here either confirm that its a bug or
>> >> explain how
>> >> >> >> the 'result' variable is fixing things?
>> >> >> >>
>> >> >> >> regards,
>> >> >> >>
>> >> >> >>  Richard
>> >> >> >>
>> >> >> >> [0] See the end of
>> >> >> >>
>> >> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> >> ses/java/io/File.java
>> >> >> >> _______________________________________________
>> >> >> >> Concurrency-interest mailing list
>> >> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> _______________________________________________
>> >> >> Concurrency-interest mailing list
>> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >>
>> >> >
>> >>
>> >
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun Java Champion
IEEE Certified Software Development Professional
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz

From davidcholmes at aapt.net.au  Mon Aug 13 02:03:34 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 13 Aug 2012 16:03:34 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACLL95oD9vC4M81u_dmTLmhqXpFxS+iZ+HZz79yvnzWDwx6=aw@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEANJGAA.davidcholmes@aapt.net.au>

Dr Heinz M. Kabutz writes:
>
> The j.l.String class is an interesting example to use.  It is thread
> safe, but it contains a benign data race in the hashCode() method.
> The class contains mutable data, without any synchronisation, yet is
> still thread safe.

Yes, lazy initialization of otherwise immutable state does muddy the waters
further.

David
-----

> Heinz
>
> On 13/08/2012, David Holmes <davidcholmes at aapt.net.au> wrote:
> > Ruslan Cheremin writes:>
> >> But is there a way to define "safe for data race publishing"? I as
> >> far, as I remember, "immutable and thread-safe" is standard mantra in
> >> JDK javadocs for totally safe objects. j.l.String has same mantra --
> >> and it is safe for any way of publishing. Does you mean, I should
> >> explicitly add "safe even for publishing via data race" in docs? But I
> >> can't remember any such phrase in JDK docs.
> >
> > I don't recall anything in the JDK docs that mention being
> "totally safe"
> > regardless of publication mechanism. Some classes, eg String, have been
> > defined such that they do have that property (for security reasons). In
> > general neither "thread-safe" nor "immutable" imply
> > safe-for-unsynchronized-publication.
> >
> > Java Concurrency In Practice (jcip.net) does define additional potential
> > annotations, where @Immutable would indeed capture the requirement of
> > safe-for-unsynchronized-publication.
> >
> > David
> > -----
> >
> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> > Ruslan Cheremin writes:
> >> >> Well, Path javadoc explicitly says "immutable and safe for
> >> >> multithreaded use". Although it is not strictly defined in java what
> >> >> exactly means "safe for multithreaded use" -- does it mean safe for
> >> >> publishing via data race, among others? -- I suppose, it
> should be. Am
> >> >> I wrong here?
> >> >
> >> > "safe for multi-threaded use" does not generally imply that it
> >> is safe to
> >> > publish instances without synchronization of some form.
> >> >
> >> > David
> >> > -----
> >> >
> >> >> From other side, File.toPath javadoc explicitly says what "returned
> >> >> instance must be the same for every invocation", so sync block is
> >> >> required here for mutual exclusion on initialization phase. Without
> >> >> this requirement it is also safe to live without sync block, afaik.
> >> >>
> >> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> > Ruslan Cheremin writes:
> >> >> >>
> >> >> >> First of all, Path is immutable, so DCL is safe here even without
> >> >> >> volatile. Volatile here is not required from my point of view.
> >> >> >
> >> >> > Without the volatile the Path implementation (Path is an
> >> >> interface) must be
> >> >> > such that an instance of Path can be safely published without
> >> >> any additional
> >> >> > forms of synchronization. Immutability does not in itself
> >> >> ensure that. You
> >> >> > would have to examine the actual implementation class.
> >> >> >
> >> >> > David Holmes
> >> >> > ------------
> >> >> >
> >> >> >>
> >> >> >>
> >> >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >> > Hi Richard,
> >> >> >> >
> >> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> >> locking is correct in this case. It would have been a bug
> >> >> prior to Java 5.
> >> >> >> >
> >> >> >> > Best regards,
> >> >> >> >
> >> >> >> > Dmitry Vyazelenko
> >> >> >> >
> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >> <richard.warburton at gmail.com> wrote:
> >> >> >> >
> >> >> >> >> Hello,
> >> >> >> >>
> >> >> >> >> The current implementation of java.io.File::toPath [0]
> >> appears to be
> >> >> >> >> using the double checked locking pattern:
> >> >> >> >>
> >> >> >> >>     public Path toPath() {
> >> >> >> >>         Path result = filePath;
> >> >> >> >>         if (result == null) {
> >> >> >> >>             synchronized (this) {
> >> >> >> >>                 result = filePath;
> >> >> >> >>                 if (result == null) {
> >> >> >> >>                     result =
> >> FileSystems.getDefault().getPath(path);
> >> >> >> >>                     filePath = result;
> >> >> >> >>                 }
> >> >> >> >>             }
> >> >> >> >>         }
> >> >> >> >>         return result;
> >> >> >> >>     }
> >> >> >> >>
> >> >> >> >> I was going to report the bug, but I'm a little
> uncertain of the
> >> >> >> >> interaction between the local variable 'result' and DCL
> >> since I've
> >> >> >> >> previously only seen the checking condition on the
> shared field
> >> >> >> >> itself.  Can someone here either confirm that its a bug or
> >> >> explain how
> >> >> >> >> the 'result' variable is fixing things?
> >> >> >> >>
> >> >> >> >> regards,
> >> >> >> >>
> >> >> >> >>  Richard
> >> >> >> >>
> >> >> >> >> [0] See the end of
> >> >> >> >>
> >> >> >>
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >> ses/java/io/File.java
> >> >> >> >> _______________________________________________
> >> >> >> >> Concurrency-interest mailing list
> >> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> _______________________________________________
> >> >> >> Concurrency-interest mailing list
> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >>
> >> >> >
> >> >>
> >> >
> >>
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> --
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun Java Champion
> IEEE Certified Software Development Professional
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>


From Alan.Bateman at oracle.com  Mon Aug 13 03:41:49 2012
From: Alan.Bateman at oracle.com (Alan Bateman)
Date: Mon, 13 Aug 2012 08:41:49 +0100
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENi+VUmw7Uynb5Q4WpvnWyXPnvOHsfdOimjhSfh-AqpH9aw@mail.gmail.com>
References: <CAOwENiLMBKqJ8Y=t-EE1myuJYUpZE8y3dAtFmBeOuLPqHZmt_A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCMEAFJGAA.davidcholmes@aapt.net.au>
	<CAOwENi+VUmw7Uynb5Q4WpvnWyXPnvOHsfdOimjhSfh-AqpH9aw@mail.gmail.com>
Message-ID: <5028AFBD.4000409@oracle.com>

On 13/08/2012 05:38, Ruslan Cheremin wrote:
> :
>
>  From other side, File.toPath javadoc explicitly says what "returned
> instance must be the same for every invocation", so sync block is
> required here for mutual exclusion on initialization phase.
>
Yes, the actual wording is " Subsequent invocations of this method 
return the same Path" so hopefully this explains why it was implemented 
this way.

-Alan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120813/d3010f79/attachment.html>

From dl at cs.oswego.edu  Mon Aug 13 07:18:19 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 13 Aug 2012 07:18:19 -0400
Subject: [concurrency-interest] ReadMostlyVector ListIterator bug
In-Reply-To: <CAEJX8orxXg5WCdtOyyPS5C2V0L3EJLz2FtVMvhkp7SmOpu-3mg@mail.gmail.com>
References: <CAEJX8orxXg5WCdtOyyPS5C2V0L3EJLz2FtVMvhkp7SmOpu-3mg@mail.gmail.com>
Message-ID: <5028E27B.5000701@cs.oswego.edu>

On 08/12/12 15:33, Stanimir Simeonoff wrote:
> ReadMostlyVector contains a bug in the iterator logic if previous() and next()
> are used together.

Thanks for the report; sorry for the problems. This is fixed in
next commit.

-Doug


From stanimir at riflexo.com  Mon Aug 13 08:07:30 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Mon, 13 Aug 2012 15:07:30 +0300
Subject: [concurrency-interest] ReadMostlyVector ListIterator bug
In-Reply-To: <5028E27B.5000701@cs.oswego.edu>
References: <CAEJX8orxXg5WCdtOyyPS5C2V0L3EJLz2FtVMvhkp7SmOpu-3mg@mail.gmail.com>
	<5028E27B.5000701@cs.oswego.edu>
Message-ID: <CAEJX8oq5C85UzjJGC0PjXbbN4u2ONdFru8jK0o_Lah=EW3PHOw@mail.gmail.com>

On Mon, Aug 13, 2012 at 2:18 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 08/12/12 15:33, Stanimir Simeonoff wrote:
>
>> ReadMostlyVector contains a bug in the iterator logic if previous() and
>> next()
>> are used together.
>>
>
> Thanks for the report; sorry for the problems. This is fixed in
> next commit.
>
> No problems at all. I spotted the bug looking at source code only, then
wrote the test case to help clear the bug.

Actually, I wanted to see how to implement an iterator over a sequence lock
data structure. If elements are removed from the middle and then added at
the end (concurrently) it looks some elements may be skipped. So unless
copying the entire structure under exclusive lock or a retry loop it won't
be a replacement for COWArrayList.

Is my reasoning correct?

Thanks
Stanimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120813/0cfd8775/attachment.html>

From dl at cs.oswego.edu  Mon Aug 13 09:24:53 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 13 Aug 2012 09:24:53 -0400
Subject: [concurrency-interest] ReadMostlyVector ListIterator bug
In-Reply-To: <CAEJX8oq5C85UzjJGC0PjXbbN4u2ONdFru8jK0o_Lah=EW3PHOw@mail.gmail.com>
References: <CAEJX8orxXg5WCdtOyyPS5C2V0L3EJLz2FtVMvhkp7SmOpu-3mg@mail.gmail.com>	<5028E27B.5000701@cs.oswego.edu>
	<CAEJX8oq5C85UzjJGC0PjXbbN4u2ONdFru8jK0o_Lah=EW3PHOw@mail.gmail.com>
Message-ID: <50290025.4000909@cs.oswego.edu>

On 08/13/12 08:07, Stanimir Simeonoff wrote:

> Actually, I wanted to see how to implement an iterator over a sequence lock data
> structure. If elements are removed from the middle and then added at the end
> (concurrently) it looks some elements may be skipped. So unless copying the
> entire structure under exclusive lock or a retry loop it won't be a replacement
> for COWArrayList.
>
> Is my reasoning correct?

Yes. You can imagine the results more simply by just contemplating
using index-by-index access instead of iterators: Changes spanning
more than one position may lead to either skips or revisits.

(More generally: Arrays are great for isolated parallelism;
but lousy for shared concurrency. Mixtures are challenging.)

-Doug


From stanimir at riflexo.com  Mon Aug 13 10:00:13 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Mon, 13 Aug 2012 17:00:13 +0300
Subject: [concurrency-interest] ReadMostlyVector ListIterator bug
In-Reply-To: <50290025.4000909@cs.oswego.edu>
References: <CAEJX8orxXg5WCdtOyyPS5C2V0L3EJLz2FtVMvhkp7SmOpu-3mg@mail.gmail.com>
	<5028E27B.5000701@cs.oswego.edu>
	<CAEJX8oq5C85UzjJGC0PjXbbN4u2ONdFru8jK0o_Lah=EW3PHOw@mail.gmail.com>
	<50290025.4000909@cs.oswego.edu>
Message-ID: <CAEJX8orvD3ADuV3jcokY_Xe8=hZOc09=6ipPUGJoVMUEC5RLRA@mail.gmail.com>

On Mon, Aug 13, 2012 at 4:24 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 08/13/12 08:07, Stanimir Simeonoff wrote:
>
>  Actually, I wanted to see how to implement an iterator over a sequence
>> lock data
>> structure. If elements are removed from the middle and then added at the
>> end
>> (concurrently) it looks some elements may be skipped. So unless copying
>> the
>> entire structure under exclusive lock or a retry loop it won't be a
>> replacement
>> for COWArrayList.
>>
>> Is my reasoning correct?
>>
>
> Yes. You can imagine the results more simply by just contemplating
> using index-by-index access instead of iterators: Changes spanning
> more than one position may lead to either skips or revisits.
>
> (More generally: Arrays are great for isolated parallelism;
> but lousy for shared concurrency. Mixtures are challenging.)
>
>
Exactly what I thought.
Now I wonder if a mixture between COW and MostlyRead would make sense:
Adding at the tail of an array backed list is amortized O(1), so it's ok.
However, inserting/deletion in the middle is O(n) - creating a new Object[]
is also O(n) [+allocation cost and GC of course]. Hence if modifying the
List in the middle  - a COW operation replacing the entire Object[] but
when adding/removing at the tail, it's a cheap one under lock.  Setting an
arbitrary element is also O(1).

The iterators never skip or revisit elements and they operate on the
Object[] when they have been created. I think this offers somehow better
consistency w/o any significant penalties, e.g iterating linked lists.

Thanks again
Stanimir

Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120813/60a47d5f/attachment.html>

From dl at cs.oswego.edu  Mon Aug 13 12:08:50 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 13 Aug 2012 12:08:50 -0400
Subject: [concurrency-interest] ConcurrentHashMap bulk parallel operations
Message-ID: <50292692.401@cs.oswego.edu>


As most of you know, lambda-based bulk operations with optional
parallelism are planned for JDK8. We've been working with JSR335 folks
on these. However, in addition we plan to offer access to bulk
operations designed for use on truly concurrent data structures, in
particular ConcurrentHashMaps. These methods are designed for use on
"live" data, registeries, caches, in-memory data stores, chunks of
Hadoop-style "big data" sets. and so on that might be concurrently
updated during the course of computations. The form and style of this
API are targeted to support operations that can be sensibly applied in
such contexts.  This boils down to only three basic forms: forEach,
search, and reduce (each with multiple variations), expressed in an
imperative style -- no fluency, stateful Streams, etc that are planned
for the JDK8 java.util-based framework. There is no sense in
compromising support for either of these kinds of target usages, so we
won't.  However, the functionality coverage is essentially identical
for those operations that do apply, so we anticipate that the JDK8
java.util-based framework will be able to layer on top of this when
applicable.

The API is in two layers. Nested (static) class "ForkJoinTasks"
returns task objects that, when invoked, provide the given
functionality, but may also be used in other ways. Nested (inner)
class "Parallel" provides an API for using them with a given
ForkJoinPool.  The class-level javadocs for CHM(V8).Parallel are pasted
below.  There will surely be some further API changes in the course of
JDK8 integration. However, in the mean time, we are releasing a
stand-alone form, intended to be usable by both current
ConcurrentHashMapV8 users running JDK7, as well as those experimenting
with current JDK8 preview lambda builds (at
http://jdk8.java.net/lambda/) The current javadocs don't have any
usage examples, because they look vastly different in JDK7 vs JDK8.

Doing this forces a bit of disruption on everyone though.

1. To avoid FJ version mismatches, the current jsr166y FJ classes are
duplicated into jsr166e.

2. To avoid JDK version mismatches, the j.u.c version (plain
"ConcurrentHashMap" without the "V8") is committed in main repository,
while keeping its "V8" in package jsr166e. (This also required an
initial merge of jsr166e.LongAdder and related classes.)

3. To avoid current and future naming problems, a set of function
interfaces are nested within ConcurrentHashMap, with names
intentionally different than those currently used in JDK8 previews
(for example "Action" instead of "Block").  For lambda-enabled
JDK8-preview users, this won't much matter because lambda expressions
will still match as expected.  However, others tediously using this
with emulated-lambdas via static instances of classes implementing the
interfaces will have to bear with future name changes of these
interfaces. This forbearance starts immediately, because the
previously named nested MappingFunction and RemappingFunction are
already changed so as to be applicable across the extended
APIs. Sorry.


... pasting from
http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/ConcurrentHashMapV8.Parallel.html


public class ConcurrentHashMapV8.Parallel


An extended view of a ConcurrentHashMap supporting bulk parallel operations. 
These operations are designed to be be safely, and often sensibly, applied even 
with maps that are being concurrently updated by other threads; for example, 
when computing a snapshot summary of the values in a shared registry. There are 
three kinds of operation, each with four forms, accepting functions with Keys, 
Values, Entries, and (Key, Value) arguments and/or return values. Because the 
elements of a ConcurrentHashMap are not ordered in any particular way, and may 
be processed in different orders in different parallel executions, the 
correctness of supplied functions should not depend on any ordering, or on any 
other objects or values that may transiently change while computation is in 
progress; and except for forEach actions, should ideally be side-effect-free.

     * forEach: Perform a given action on each element. A variant form applies a 
given transformation on each element before performing the action.
     * search: Return the first available non-null result of applying a given 
function on each element; skipping further search when a result is found.
     * reduce: Accumulate each element. The supplied reduction function cannot 
rely on ordering (more formally, it should be both associative and commutative). 
There are five variants:
           o Plain reductions. (There is not a form of this method for (key, 
value) function arguments since there is no corresponding return type.)
           o Mapped reductions that accumulate the results of a given function 
applied to each element.
           o Reductions to scalar doubles, longs, and ints, using a given basis 
value.

The concurrency properties of the bulk operations follow from those of 
ConcurrentHashMap: Any non-null result returned from get(key) and related access 
methods bears a happens-before relation with the associated insertion or update. 
The result of any bulk operation reflects the composition of these per-element 
relations (but is not necessarily atomic with respect to the map as a whole 
unless it is somehow known to be quiescent). Conversely, because keys and values 
in the map are never null, null serves as a reliable atomic indicator of the 
current lack of any result. To maintain this property, null serves as an 
implicit basis for all non-scalar reduction operations. For the double, long, 
and int versions, the basis should be one that, when combined with any other 
value, returns that other value (more formally, it should be the identity 
element for the reduction). Most common reductions have these properties; for 
example, computing a sum with basis 0 or a minimum with basis MAX_VALUE.

Search and transformation functions provided as arguments should similarly 
return null to indicate the lack of any result (in which case it is not used). 
In the case of mapped reductions, this also enables transformations to serve as 
filters, returning null (or, in the case of primitive specializations, the 
identity basis) if the element should not be combined. You can create compound 
transformations and filterings by composing them yourself under this "null means 
there is nothing there now" rule before using them in search or reduce operations.

Methods accepting and/or returning Entry arguments maintain key-value 
associations. They may be useful for example when finding the key for the 
greatest value. Note that "plain" Entry arguments can be supplied using new 
AbstractMap.SimpleEntry(k,v).

Bulk operations may complete abruptly, throwing an exception encountered in the 
application of a supplied function. Bear in mind when handling such exceptions 
that other concurrently executing functions could also have thrown exceptions, 
or would have done so if the first exception had not occurred.

Parallel speedups compared to sequential processing are common but not 
guaranteed. Operations involving brief functions on small maps may execute more 
slowly than sequential loops if the underlying work to parallelize the 
computation is more expensive than the computation itself. Similarly, 
parallelization may not lead to much actual parallelism if all processors are 
busy performing unrelated tasks.

All arguments to all task methods must be non-null.

jsr166e note: During transition, this class uses nested functional interfaces 
with different names but the same forms as those expected for JDK8.

From martinrb at google.com  Mon Aug 13 15:11:07 2012
From: martinrb at google.com (Martin Buchholz)
Date: Mon, 13 Aug 2012 12:11:07 -0700
Subject: [concurrency-interest] ReadMostlyVector ListIterator bug
In-Reply-To: <CAEJX8orvD3ADuV3jcokY_Xe8=hZOc09=6ipPUGJoVMUEC5RLRA@mail.gmail.com>
References: <CAEJX8orxXg5WCdtOyyPS5C2V0L3EJLz2FtVMvhkp7SmOpu-3mg@mail.gmail.com>
	<5028E27B.5000701@cs.oswego.edu>
	<CAEJX8oq5C85UzjJGC0PjXbbN4u2ONdFru8jK0o_Lah=EW3PHOw@mail.gmail.com>
	<50290025.4000909@cs.oswego.edu>
	<CAEJX8orvD3ADuV3jcokY_Xe8=hZOc09=6ipPUGJoVMUEC5RLRA@mail.gmail.com>
Message-ID: <CA+kOe0_GzL0H2T9c8yXU5JKm9y2_J8OF6ZKVtCKmdUtc=wYpaw@mail.gmail.com>

It's difficult.

SequenceLock is more problematic to use correctly and usefully than was
expected.
http://safari.ece.cmu.edu/MSPC2012/papers/p12-boehm.pdf

The List interface is quite concurrency-hostile.

Compare the efforts taken in latest ArrayBlockingQueue to get iterators
right, which required heroic action, despite the apparent simplicity of
getting it right when locks are held on access.  ABQ tries to keep track of
whether an iterator is currently active, and in principle ReadMostlyVector
could do something similar.

Martin

On Mon, Aug 13, 2012 at 7:00 AM, Stanimir Simeonoff <stanimir at riflexo.com>wrote:

>
>
> On Mon, Aug 13, 2012 at 4:24 PM, Doug Lea <dl at cs.oswego.edu> wrote:
>
>> On 08/13/12 08:07, Stanimir Simeonoff wrote:
>>
>>  Actually, I wanted to see how to implement an iterator over a sequence
>>> lock data
>>> structure. If elements are removed from the middle and then added at the
>>> end
>>> (concurrently) it looks some elements may be skipped. So unless copying
>>> the
>>> entire structure under exclusive lock or a retry loop it won't be a
>>> replacement
>>> for COWArrayList.
>>>
>>> Is my reasoning correct?
>>>
>>
>> Yes. You can imagine the results more simply by just contemplating
>> using index-by-index access instead of iterators: Changes spanning
>> more than one position may lead to either skips or revisits.
>>
>> (More generally: Arrays are great for isolated parallelism;
>> but lousy for shared concurrency. Mixtures are challenging.)
>>
>>
> Exactly what I thought.
> Now I wonder if a mixture between COW and MostlyRead would make sense:
> Adding at the tail of an array backed list is amortized O(1), so it's ok.
> However, inserting/deletion in the middle is O(n) - creating a new Object[]
> is also O(n) [+allocation cost and GC of course]. Hence if modifying the
> List in the middle  - a COW operation replacing the entire Object[] but
> when adding/removing at the tail, it's a cheap one under lock.  Setting an
> arbitrary element is also O(1).
>
> The iterators never skip or revisit elements and they operate on the
> Object[] when they have been created. I think this offers somehow better
> consistency w/o any significant penalties, e.g iterating linked lists.
>
> Thanks again
> Stanimir
>
> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120813/858c400b/attachment.html>

From cheremin at gmail.com  Mon Aug 13 15:39:06 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Mon, 13 Aug 2012 23:39:06 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>

For me it is confusing: java has only one way to have really immutable
object, and this way also gives you a total thread safety even for
data race based publication. But then docs refer object as "immutable
and thread-safe" -- we still can't assume it to be really thread-safe?

It's a pity, especially because true immutability gives us some
chances of performance optimization. As in this case -- we do not
really need .path to be volatile here, if we would assume Path to be
truly immutable. volatility here required only for ensuring safe
publishing.

2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> Ruslan Cheremin writes:>
>> But is there a way to define "safe for data race publishing"? I as
>> far, as I remember, "immutable and thread-safe" is standard mantra in
>> JDK javadocs for totally safe objects. j.l.String has same mantra --
>> and it is safe for any way of publishing. Does you mean, I should
>> explicitly add "safe even for publishing via data race" in docs? But I
>> can't remember any such phrase in JDK docs.
>
> I don't recall anything in the JDK docs that mention being "totally safe"
> regardless of publication mechanism. Some classes, eg String, have been
> defined such that they do have that property (for security reasons). In
> general neither "thread-safe" nor "immutable" imply
> safe-for-unsynchronized-publication.
>
> Java Concurrency In Practice (jcip.net) does define additional potential
> annotations, where @Immutable would indeed capture the requirement of
> safe-for-unsynchronized-publication.
>
> David
> -----
>
>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> > Ruslan Cheremin writes:
>> >> Well, Path javadoc explicitly says "immutable and safe for
>> >> multithreaded use". Although it is not strictly defined in java what
>> >> exactly means "safe for multithreaded use" -- does it mean safe for
>> >> publishing via data race, among others? -- I suppose, it should be. Am
>> >> I wrong here?
>> >
>> > "safe for multi-threaded use" does not generally imply that it
>> is safe to
>> > publish instances without synchronization of some form.
>> >
>> > David
>> > -----
>> >
>> >> From other side, File.toPath javadoc explicitly says what "returned
>> >> instance must be the same for every invocation", so sync block is
>> >> required here for mutual exclusion on initialization phase. Without
>> >> this requirement it is also safe to live without sync block, afaik.
>> >>
>> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> > Ruslan Cheremin writes:
>> >> >>
>> >> >> First of all, Path is immutable, so DCL is safe here even without
>> >> >> volatile. Volatile here is not required from my point of view.
>> >> >
>> >> > Without the volatile the Path implementation (Path is an
>> >> interface) must be
>> >> > such that an instance of Path can be safely published without
>> >> any additional
>> >> > forms of synchronization. Immutability does not in itself
>> >> ensure that. You
>> >> > would have to examine the actual implementation class.
>> >> >
>> >> > David Holmes
>> >> > ------------
>> >> >
>> >> >>
>> >> >>
>> >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> >> > Hi Richard,
>> >> >> >
>> >> >> > The variable "filePath" is volatile, so the double-checked
>> >> >> locking is correct in this case. It would have been a bug
>> >> prior to Java 5.
>> >> >> >
>> >> >> > Best regards,
>> >> >> >
>> >> >> > Dmitry Vyazelenko
>> >> >> >
>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >> <richard.warburton at gmail.com> wrote:
>> >> >> >
>> >> >> >> Hello,
>> >> >> >>
>> >> >> >> The current implementation of java.io.File::toPath [0]
>> appears to be
>> >> >> >> using the double checked locking pattern:
>> >> >> >>
>> >> >> >>     public Path toPath() {
>> >> >> >>         Path result = filePath;
>> >> >> >>         if (result == null) {
>> >> >> >>             synchronized (this) {
>> >> >> >>                 result = filePath;
>> >> >> >>                 if (result == null) {
>> >> >> >>                     result =
>> FileSystems.getDefault().getPath(path);
>> >> >> >>                     filePath = result;
>> >> >> >>                 }
>> >> >> >>             }
>> >> >> >>         }
>> >> >> >>         return result;
>> >> >> >>     }
>> >> >> >>
>> >> >> >> I was going to report the bug, but I'm a little uncertain of the
>> >> >> >> interaction between the local variable 'result' and DCL
>> since I've
>> >> >> >> previously only seen the checking condition on the shared field
>> >> >> >> itself.  Can someone here either confirm that its a bug or
>> >> explain how
>> >> >> >> the 'result' variable is fixing things?
>> >> >> >>
>> >> >> >> regards,
>> >> >> >>
>> >> >> >>  Richard
>> >> >> >>
>> >> >> >> [0] See the end of
>> >> >> >>
>> >> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> >> ses/java/io/File.java
>> >> >> >> _______________________________________________
>> >> >> >> Concurrency-interest mailing list
>> >> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> _______________________________________________
>> >> >> Concurrency-interest mailing list
>> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >>
>> >> >
>> >>
>> >
>>
>

From yshavit at akiban.com  Mon Aug 13 15:51:36 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Mon, 13 Aug 2012 15:51:36 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
Message-ID: <CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>

This class is immutable but not thread-safe absent safe publication:

public class MyImmutable {
    private long val; // not marked final or volatile
    public MyImmutable(long val) {
        this.val = val;
    }

    public int getValue() {
        return val;
    }
}

In the absence of safe publication, a thread is allowed to see:

    - val's default value (0)
    - the value passed to the constructor
    - a word tear in which val contains only the high or low word from the
value passed to the constructor

On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin <cheremin at gmail.com> wrote:

> For me it is confusing: java has only one way to have really immutable
> object, and this way also gives you a total thread safety even for
> data race based publication. But then docs refer object as "immutable
> and thread-safe" -- we still can't assume it to be really thread-safe?
>
> It's a pity, especially because true immutability gives us some
> chances of performance optimization. As in this case -- we do not
> really need .path to be volatile here, if we would assume Path to be
> truly immutable. volatility here required only for ensuring safe
> publishing.
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > Ruslan Cheremin writes:>
> >> But is there a way to define "safe for data race publishing"? I as
> >> far, as I remember, "immutable and thread-safe" is standard mantra in
> >> JDK javadocs for totally safe objects. j.l.String has same mantra --
> >> and it is safe for any way of publishing. Does you mean, I should
> >> explicitly add "safe even for publishing via data race" in docs? But I
> >> can't remember any such phrase in JDK docs.
> >
> > I don't recall anything in the JDK docs that mention being "totally safe"
> > regardless of publication mechanism. Some classes, eg String, have been
> > defined such that they do have that property (for security reasons). In
> > general neither "thread-safe" nor "immutable" imply
> > safe-for-unsynchronized-publication.
> >
> > Java Concurrency In Practice (jcip.net) does define additional potential
> > annotations, where @Immutable would indeed capture the requirement of
> > safe-for-unsynchronized-publication.
> >
> > David
> > -----
> >
> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> > Ruslan Cheremin writes:
> >> >> Well, Path javadoc explicitly says "immutable and safe for
> >> >> multithreaded use". Although it is not strictly defined in java what
> >> >> exactly means "safe for multithreaded use" -- does it mean safe for
> >> >> publishing via data race, among others? -- I suppose, it should be.
> Am
> >> >> I wrong here?
> >> >
> >> > "safe for multi-threaded use" does not generally imply that it
> >> is safe to
> >> > publish instances without synchronization of some form.
> >> >
> >> > David
> >> > -----
> >> >
> >> >> From other side, File.toPath javadoc explicitly says what "returned
> >> >> instance must be the same for every invocation", so sync block is
> >> >> required here for mutual exclusion on initialization phase. Without
> >> >> this requirement it is also safe to live without sync block, afaik.
> >> >>
> >> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> > Ruslan Cheremin writes:
> >> >> >>
> >> >> >> First of all, Path is immutable, so DCL is safe here even without
> >> >> >> volatile. Volatile here is not required from my point of view.
> >> >> >
> >> >> > Without the volatile the Path implementation (Path is an
> >> >> interface) must be
> >> >> > such that an instance of Path can be safely published without
> >> >> any additional
> >> >> > forms of synchronization. Immutability does not in itself
> >> >> ensure that. You
> >> >> > would have to examine the actual implementation class.
> >> >> >
> >> >> > David Holmes
> >> >> > ------------
> >> >> >
> >> >> >>
> >> >> >>
> >> >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >> > Hi Richard,
> >> >> >> >
> >> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> >> locking is correct in this case. It would have been a bug
> >> >> prior to Java 5.
> >> >> >> >
> >> >> >> > Best regards,
> >> >> >> >
> >> >> >> > Dmitry Vyazelenko
> >> >> >> >
> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >> <richard.warburton at gmail.com> wrote:
> >> >> >> >
> >> >> >> >> Hello,
> >> >> >> >>
> >> >> >> >> The current implementation of java.io.File::toPath [0]
> >> appears to be
> >> >> >> >> using the double checked locking pattern:
> >> >> >> >>
> >> >> >> >>     public Path toPath() {
> >> >> >> >>         Path result = filePath;
> >> >> >> >>         if (result == null) {
> >> >> >> >>             synchronized (this) {
> >> >> >> >>                 result = filePath;
> >> >> >> >>                 if (result == null) {
> >> >> >> >>                     result =
> >> FileSystems.getDefault().getPath(path);
> >> >> >> >>                     filePath = result;
> >> >> >> >>                 }
> >> >> >> >>             }
> >> >> >> >>         }
> >> >> >> >>         return result;
> >> >> >> >>     }
> >> >> >> >>
> >> >> >> >> I was going to report the bug, but I'm a little uncertain of
> the
> >> >> >> >> interaction between the local variable 'result' and DCL
> >> since I've
> >> >> >> >> previously only seen the checking condition on the shared field
> >> >> >> >> itself.  Can someone here either confirm that its a bug or
> >> >> explain how
> >> >> >> >> the 'result' variable is fixing things?
> >> >> >> >>
> >> >> >> >> regards,
> >> >> >> >>
> >> >> >> >>  Richard
> >> >> >> >>
> >> >> >> >> [0] See the end of
> >> >> >> >>
> >> >> >>
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >> ses/java/io/File.java
> >> >> >> >> _______________________________________________
> >> >> >> >> Concurrency-interest mailing list
> >> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> _______________________________________________
> >> >> >> Concurrency-interest mailing list
> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >>
> >> >> >
> >> >>
> >> >
> >>
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120813/97650256/attachment-0001.html>

From cheremin at gmail.com  Mon Aug 13 16:20:13 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Tue, 14 Aug 2012 00:20:13 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
Message-ID: <CAOwENiKx=5ktY64HuzKffVjrEhn9cKsxEStfjzSM2qG0vGq4Tg@mail.gmail.com>

Yes, and it is my point -- it's confusing to say "immutable" (which
form of?), confusing to say "thread safe" (in which multithreaded use
case it is safe?) and even more confusing to say both "immutable and
thread-safe" -- because actually there is (==I know) only two ways to
reach thread-safe immutability in java: "all fields final", or "all
methods sync-ed, including constructors" -- and the second one is very
rare.

For me "immutable and thread safe" seems to be equivalent to
"thread-safe immutable", which, in turn, implies safety for data race
publication. How can I claim object as "thread safe immutable", if I
can see in several states in multithreaded env.?


2012/8/13 Yuval Shavit <yshavit at akiban.com>:
> This class is immutable but not thread-safe absent safe publication:
>
> public class MyImmutable {
>     private long val; // not marked final or volatile
>     public MyImmutable(long val) {
>         this.val = val;
>     }
>
>     public int getValue() {
>         return val;
>     }
> }
>
> In the absence of safe publication, a thread is allowed to see:
>
>     - val's default value (0)
>     - the value passed to the constructor
>     - a word tear in which val contains only the high or low word from the
> value passed to the constructor
>
>
> On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin <cheremin at gmail.com> wrote:
>>
>> For me it is confusing: java has only one way to have really immutable
>> object, and this way also gives you a total thread safety even for
>> data race based publication. But then docs refer object as "immutable
>> and thread-safe" -- we still can't assume it to be really thread-safe?
>>
>> It's a pity, especially because true immutability gives us some
>> chances of performance optimization. As in this case -- we do not
>> really need .path to be volatile here, if we would assume Path to be
>> truly immutable. volatility here required only for ensuring safe
>> publishing.
>>
>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> > Ruslan Cheremin writes:>
>> >> But is there a way to define "safe for data race publishing"? I as
>> >> far, as I remember, "immutable and thread-safe" is standard mantra in
>> >> JDK javadocs for totally safe objects. j.l.String has same mantra --
>> >> and it is safe for any way of publishing. Does you mean, I should
>> >> explicitly add "safe even for publishing via data race" in docs? But I
>> >> can't remember any such phrase in JDK docs.
>> >
>> > I don't recall anything in the JDK docs that mention being "totally
>> > safe"
>> > regardless of publication mechanism. Some classes, eg String, have been
>> > defined such that they do have that property (for security reasons). In
>> > general neither "thread-safe" nor "immutable" imply
>> > safe-for-unsynchronized-publication.
>> >
>> > Java Concurrency In Practice (jcip.net) does define additional potential
>> > annotations, where @Immutable would indeed capture the requirement of
>> > safe-for-unsynchronized-publication.
>> >
>> > David
>> > -----
>> >
>> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> > Ruslan Cheremin writes:
>> >> >> Well, Path javadoc explicitly says "immutable and safe for
>> >> >> multithreaded use". Although it is not strictly defined in java what
>> >> >> exactly means "safe for multithreaded use" -- does it mean safe for
>> >> >> publishing via data race, among others? -- I suppose, it should be.
>> >> >> Am
>> >> >> I wrong here?
>> >> >
>> >> > "safe for multi-threaded use" does not generally imply that it
>> >> is safe to
>> >> > publish instances without synchronization of some form.
>> >> >
>> >> > David
>> >> > -----
>> >> >
>> >> >> From other side, File.toPath javadoc explicitly says what "returned
>> >> >> instance must be the same for every invocation", so sync block is
>> >> >> required here for mutual exclusion on initialization phase. Without
>> >> >> this requirement it is also safe to live without sync block, afaik.
>> >> >>
>> >> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> > Ruslan Cheremin writes:
>> >> >> >>
>> >> >> >> First of all, Path is immutable, so DCL is safe here even without
>> >> >> >> volatile. Volatile here is not required from my point of view.
>> >> >> >
>> >> >> > Without the volatile the Path implementation (Path is an
>> >> >> interface) must be
>> >> >> > such that an instance of Path can be safely published without
>> >> >> any additional
>> >> >> > forms of synchronization. Immutability does not in itself
>> >> >> ensure that. You
>> >> >> > would have to examine the actual implementation class.
>> >> >> >
>> >> >> > David Holmes
>> >> >> > ------------
>> >> >> >
>> >> >> >>
>> >> >> >>
>> >> >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> >> >> > Hi Richard,
>> >> >> >> >
>> >> >> >> > The variable "filePath" is volatile, so the double-checked
>> >> >> >> locking is correct in this case. It would have been a bug
>> >> >> prior to Java 5.
>> >> >> >> >
>> >> >> >> > Best regards,
>> >> >> >> >
>> >> >> >> > Dmitry Vyazelenko
>> >> >> >> >
>> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >> >> <richard.warburton at gmail.com> wrote:
>> >> >> >> >
>> >> >> >> >> Hello,
>> >> >> >> >>
>> >> >> >> >> The current implementation of java.io.File::toPath [0]
>> >> appears to be
>> >> >> >> >> using the double checked locking pattern:
>> >> >> >> >>
>> >> >> >> >>     public Path toPath() {
>> >> >> >> >>         Path result = filePath;
>> >> >> >> >>         if (result == null) {
>> >> >> >> >>             synchronized (this) {
>> >> >> >> >>                 result = filePath;
>> >> >> >> >>                 if (result == null) {
>> >> >> >> >>                     result =
>> >> FileSystems.getDefault().getPath(path);
>> >> >> >> >>                     filePath = result;
>> >> >> >> >>                 }
>> >> >> >> >>             }
>> >> >> >> >>         }
>> >> >> >> >>         return result;
>> >> >> >> >>     }
>> >> >> >> >>
>> >> >> >> >> I was going to report the bug, but I'm a little uncertain of
>> >> >> >> >> the
>> >> >> >> >> interaction between the local variable 'result' and DCL
>> >> since I've
>> >> >> >> >> previously only seen the checking condition on the shared
>> >> >> >> >> field
>> >> >> >> >> itself.  Can someone here either confirm that its a bug or
>> >> >> explain how
>> >> >> >> >> the 'result' variable is fixing things?
>> >> >> >> >>
>> >> >> >> >> regards,
>> >> >> >> >>
>> >> >> >> >>  Richard
>> >> >> >> >>
>> >> >> >> >> [0] See the end of
>> >> >> >> >>
>> >> >> >>
>> >> >> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> >> >> ses/java/io/File.java
>> >> >> >> >> _______________________________________________
>> >> >> >> >> Concurrency-interest mailing list
>> >> >> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> _______________________________________________
>> >> >> >> Concurrency-interest mailing list
>> >> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >>
>> >> >> >
>> >> >>
>> >> >
>> >>
>> >
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From yshavit at akiban.com  Mon Aug 13 17:24:35 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Mon, 13 Aug 2012 17:24:35 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENiKx=5ktY64HuzKffVjrEhn9cKsxEStfjzSM2qG0vGq4Tg@mail.gmail.com>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
	<CAOwENiKx=5ktY64HuzKffVjrEhn9cKsxEStfjzSM2qG0vGq4Tg@mail.gmail.com>
Message-ID: <CAC2Zdp3Cqd6LsYG6DwV7NVA7kiBqEXa2h_0fYQDwF4q3k7KX_w@mail.gmail.com>

Everything you say is true, but my class is *almost* fully thread-safe. In
particular, if it's published safely -- via an argument to a Runnable
that's about to be started, or retrieved from a thread-safe queue, etc --
then it'll be perfectly fine. Pretty much the only thing you can't do is to
publish it through a non-threadsafe collection (which is broken code even
if the object were threadsafe, since the collection could fail) or by
writing it to a non-volatile static (which is arguably broken, since other
threads might never see that reference write, even if the object it would
refer to is thread-safe).

In other words, it's almost difficult to write code which is thread safe in
every way except for an immutable object's state. I think that's why most
people consider immutable to effectively mean thread-safe. I consider it
shorthand for "threadsafe, as long as you don't publish it to threads via a
non-volatile static or a non-threadsafe collection."

On Mon, Aug 13, 2012 at 4:20 PM, Ruslan Cheremin <cheremin at gmail.com> wrote:

> Yes, and it is my point -- it's confusing to say "immutable" (which
> form of?), confusing to say "thread safe" (in which multithreaded use
> case it is safe?) and even more confusing to say both "immutable and
> thread-safe" -- because actually there is (==I know) only two ways to
> reach thread-safe immutability in java: "all fields final", or "all
> methods sync-ed, including constructors" -- and the second one is very
> rare.
>
> For me "immutable and thread safe" seems to be equivalent to
> "thread-safe immutable", which, in turn, implies safety for data race
> publication. How can I claim object as "thread safe immutable", if I
> can see in several states in multithreaded env.?
>
>
> 2012/8/13 Yuval Shavit <yshavit at akiban.com>:
> > This class is immutable but not thread-safe absent safe publication:
> >
> > public class MyImmutable {
> >     private long val; // not marked final or volatile
> >     public MyImmutable(long val) {
> >         this.val = val;
> >     }
> >
> >     public int getValue() {
> >         return val;
> >     }
> > }
> >
> > In the absence of safe publication, a thread is allowed to see:
> >
> >     - val's default value (0)
> >     - the value passed to the constructor
> >     - a word tear in which val contains only the high or low word from
> the
> > value passed to the constructor
> >
> >
> > On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin <cheremin at gmail.com>
> wrote:
> >>
> >> For me it is confusing: java has only one way to have really immutable
> >> object, and this way also gives you a total thread safety even for
> >> data race based publication. But then docs refer object as "immutable
> >> and thread-safe" -- we still can't assume it to be really thread-safe?
> >>
> >> It's a pity, especially because true immutability gives us some
> >> chances of performance optimization. As in this case -- we do not
> >> really need .path to be volatile here, if we would assume Path to be
> >> truly immutable. volatility here required only for ensuring safe
> >> publishing.
> >>
> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> > Ruslan Cheremin writes:>
> >> >> But is there a way to define "safe for data race publishing"? I as
> >> >> far, as I remember, "immutable and thread-safe" is standard mantra in
> >> >> JDK javadocs for totally safe objects. j.l.String has same mantra --
> >> >> and it is safe for any way of publishing. Does you mean, I should
> >> >> explicitly add "safe even for publishing via data race" in docs? But
> I
> >> >> can't remember any such phrase in JDK docs.
> >> >
> >> > I don't recall anything in the JDK docs that mention being "totally
> >> > safe"
> >> > regardless of publication mechanism. Some classes, eg String, have
> been
> >> > defined such that they do have that property (for security reasons).
> In
> >> > general neither "thread-safe" nor "immutable" imply
> >> > safe-for-unsynchronized-publication.
> >> >
> >> > Java Concurrency In Practice (jcip.net) does define additional
> potential
> >> > annotations, where @Immutable would indeed capture the requirement of
> >> > safe-for-unsynchronized-publication.
> >> >
> >> > David
> >> > -----
> >> >
> >> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> > Ruslan Cheremin writes:
> >> >> >> Well, Path javadoc explicitly says "immutable and safe for
> >> >> >> multithreaded use". Although it is not strictly defined in java
> what
> >> >> >> exactly means "safe for multithreaded use" -- does it mean safe
> for
> >> >> >> publishing via data race, among others? -- I suppose, it should
> be.
> >> >> >> Am
> >> >> >> I wrong here?
> >> >> >
> >> >> > "safe for multi-threaded use" does not generally imply that it
> >> >> is safe to
> >> >> > publish instances without synchronization of some form.
> >> >> >
> >> >> > David
> >> >> > -----
> >> >> >
> >> >> >> From other side, File.toPath javadoc explicitly says what
> "returned
> >> >> >> instance must be the same for every invocation", so sync block is
> >> >> >> required here for mutual exclusion on initialization phase.
> Without
> >> >> >> this requirement it is also safe to live without sync block,
> afaik.
> >> >> >>
> >> >> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >>
> >> >> >> >> First of all, Path is immutable, so DCL is safe here even
> without
> >> >> >> >> volatile. Volatile here is not required from my point of view.
> >> >> >> >
> >> >> >> > Without the volatile the Path implementation (Path is an
> >> >> >> interface) must be
> >> >> >> > such that an instance of Path can be safely published without
> >> >> >> any additional
> >> >> >> > forms of synchronization. Immutability does not in itself
> >> >> >> ensure that. You
> >> >> >> > would have to examine the actual implementation class.
> >> >> >> >
> >> >> >> > David Holmes
> >> >> >> > ------------
> >> >> >> >
> >> >> >> >>
> >> >> >> >>
> >> >> >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >> >> > Hi Richard,
> >> >> >> >> >
> >> >> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> >> >> locking is correct in this case. It would have been a bug
> >> >> >> prior to Java 5.
> >> >> >> >> >
> >> >> >> >> > Best regards,
> >> >> >> >> >
> >> >> >> >> > Dmitry Vyazelenko
> >> >> >> >> >
> >> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >> >> <richard.warburton at gmail.com> wrote:
> >> >> >> >> >
> >> >> >> >> >> Hello,
> >> >> >> >> >>
> >> >> >> >> >> The current implementation of java.io.File::toPath [0]
> >> >> appears to be
> >> >> >> >> >> using the double checked locking pattern:
> >> >> >> >> >>
> >> >> >> >> >>     public Path toPath() {
> >> >> >> >> >>         Path result = filePath;
> >> >> >> >> >>         if (result == null) {
> >> >> >> >> >>             synchronized (this) {
> >> >> >> >> >>                 result = filePath;
> >> >> >> >> >>                 if (result == null) {
> >> >> >> >> >>                     result =
> >> >> FileSystems.getDefault().getPath(path);
> >> >> >> >> >>                     filePath = result;
> >> >> >> >> >>                 }
> >> >> >> >> >>             }
> >> >> >> >> >>         }
> >> >> >> >> >>         return result;
> >> >> >> >> >>     }
> >> >> >> >> >>
> >> >> >> >> >> I was going to report the bug, but I'm a little uncertain of
> >> >> >> >> >> the
> >> >> >> >> >> interaction between the local variable 'result' and DCL
> >> >> since I've
> >> >> >> >> >> previously only seen the checking condition on the shared
> >> >> >> >> >> field
> >> >> >> >> >> itself.  Can someone here either confirm that its a bug or
> >> >> >> explain how
> >> >> >> >> >> the 'result' variable is fixing things?
> >> >> >> >> >>
> >> >> >> >> >> regards,
> >> >> >> >> >>
> >> >> >> >> >>  Richard
> >> >> >> >> >>
> >> >> >> >> >> [0] See the end of
> >> >> >> >> >>
> >> >> >> >>
> >> >> >> >>
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >> >> ses/java/io/File.java
> >> >> >> >> >> _______________________________________________
> >> >> >> >> >> Concurrency-interest mailing list
> >> >> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >> >
> >> >> >> >> >
> >> >> >> >> > _______________________________________________
> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >> _______________________________________________
> >> >> >> >> Concurrency-interest mailing list
> >> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >>
> >> >> >> >
> >> >> >>
> >> >> >
> >> >>
> >> >
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120813/c8049d8a/attachment-0001.html>

From wolfgang.baltes at laposte.net  Mon Aug 13 17:46:06 2012
From: wolfgang.baltes at laposte.net (Wolfgang Baltes)
Date: Mon, 13 Aug 2012 14:46:06 -0700
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENiKx=5ktY64HuzKffVjrEhn9cKsxEStfjzSM2qG0vGq4Tg@mail.gmail.com>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
	<CAOwENiKx=5ktY64HuzKffVjrEhn9cKsxEStfjzSM2qG0vGq4Tg@mail.gmail.com>
Message-ID: <5029759E.4070601@laposte.net>

Immutability and thread safety should be considered essentially 
orthogonal concepts. However, the final keyword can be useful in both.

Immutability just means that the object cannot be changed after 
instantiation. There are several ways to achieve this, the most obvious 
ones are a) to make a data fields final, and b) not to provide a method 
that changes the values of data fields.

Thread safe publishing means that, when an object reference is shared 
between threads, all threads see the object only in the same state as 
the thread which has last modified (or instantiated) the object. There 
are different ways to accomplish this, the most obvious ones being to 
declare a fields final or volatile. Final provides the guarantee that a 
field can safely be published to other threads after the constructor 
that assigns the value is finished. If there are multiple fields, than 
only those that are marked final are covered by the guarantee. This is 
different from volatile, where instructions - such as writes to non 
volatile fields - that appear in the code before a write to a volatile 
field, are guaranteed to be executed before the first subsequent read of 
that volatile field, no matter in which thread this read instruction 
occurs. In the latter case, a non volatile field which is never modified 
by any method may also appear as immutable and be published in a thread 
safe manner.

Hence, marking a field final makes it immutable and publishable in a 
thread safe manner, if the reference to the object that holds the field 
is published after the constructor is finished.

Wolfgang.


On 2012-08-13 13:20, Ruslan Cheremin wrote:
> Yes, and it is my point -- it's confusing to say "immutable" (which
> form of?), confusing to say "thread safe" (in which multithreaded use
> case it is safe?) and even more confusing to say both "immutable and
> thread-safe" -- because actually there is (==I know) only two ways to
> reach thread-safe immutability in java: "all fields final", or "all
> methods sync-ed, including constructors" -- and the second one is very
> rare.
>
> For me "immutable and thread safe" seems to be equivalent to
> "thread-safe immutable", which, in turn, implies safety for data race
> publication. How can I claim object as "thread safe immutable", if I
> can see in several states in multithreaded env.?
>
>
> 2012/8/13 Yuval Shavit <yshavit at akiban.com>:
>> This class is immutable but not thread-safe absent safe publication:
>>
>> public class MyImmutable {
>>      private long val; // not marked final or volatile
>>      public MyImmutable(long val) {
>>          this.val = val;
>>      }
>>
>>      public int getValue() {
>>          return val;
>>      }
>> }
>>
>> In the absence of safe publication, a thread is allowed to see:
>>
>>      - val's default value (0)
>>      - the value passed to the constructor
>>      - a word tear in which val contains only the high or low word from the
>> value passed to the constructor
>>
>>
>> On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin <cheremin at gmail.com> wrote:
>>> For me it is confusing: java has only one way to have really immutable
>>> object, and this way also gives you a total thread safety even for
>>> data race based publication. But then docs refer object as "immutable
>>> and thread-safe" -- we still can't assume it to be really thread-safe?
>>>
>>> It's a pity, especially because true immutability gives us some
>>> chances of performance optimization. As in this case -- we do not
>>> really need .path to be volatile here, if we would assume Path to be
>>> truly immutable. volatility here required only for ensuring safe
>>> publishing.
>>>
>>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>> Ruslan Cheremin writes:>
>>>>> But is there a way to define "safe for data race publishing"? I as
>>>>> far, as I remember, "immutable and thread-safe" is standard mantra in
>>>>> JDK javadocs for totally safe objects. j.l.String has same mantra --
>>>>> and it is safe for any way of publishing. Does you mean, I should
>>>>> explicitly add "safe even for publishing via data race" in docs? But I
>>>>> can't remember any such phrase in JDK docs.
>>>> I don't recall anything in the JDK docs that mention being "totally
>>>> safe"
>>>> regardless of publication mechanism. Some classes, eg String, have been
>>>> defined such that they do have that property (for security reasons). In
>>>> general neither "thread-safe" nor "immutable" imply
>>>> safe-for-unsynchronized-publication.
>>>>
>>>> Java Concurrency In Practice (jcip.net) does define additional potential
>>>> annotations, where @Immutable would indeed capture the requirement of
>>>> safe-for-unsynchronized-publication.
>>>>
>>>> David
>>>> -----
>>>>
>>>>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>>>> Ruslan Cheremin writes:
>>>>>>> Well, Path javadoc explicitly says "immutable and safe for
>>>>>>> multithreaded use". Although it is not strictly defined in java what
>>>>>>> exactly means "safe for multithreaded use" -- does it mean safe for
>>>>>>> publishing via data race, among others? -- I suppose, it should be.
>>>>>>> Am
>>>>>>> I wrong here?
>>>>>> "safe for multi-threaded use" does not generally imply that it
>>>>> is safe to
>>>>>> publish instances without synchronization of some form.
>>>>>>
>>>>>> David
>>>>>> -----
>>>>>>
>>>>>>>  From other side, File.toPath javadoc explicitly says what "returned
>>>>>>> instance must be the same for every invocation", so sync block is
>>>>>>> required here for mutual exclusion on initialization phase. Without
>>>>>>> this requirement it is also safe to live without sync block, afaik.
>>>>>>>
>>>>>>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>>>>>> Ruslan Cheremin writes:
>>>>>>>>> First of all, Path is immutable, so DCL is safe here even without
>>>>>>>>> volatile. Volatile here is not required from my point of view.
>>>>>>>> Without the volatile the Path implementation (Path is an
>>>>>>> interface) must be
>>>>>>>> such that an instance of Path can be safely published without
>>>>>>> any additional
>>>>>>>> forms of synchronization. Immutability does not in itself
>>>>>>> ensure that. You
>>>>>>>> would have to examine the actual implementation class.
>>>>>>>>
>>>>>>>> David Holmes
>>>>>>>> ------------
>>>>>>>>
>>>>>>>>>
>>>>>>>>> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>>>>>>>>>> Hi Richard,
>>>>>>>>>>
>>>>>>>>>> The variable "filePath" is volatile, so the double-checked
>>>>>>>>> locking is correct in this case. It would have been a bug
>>>>>>> prior to Java 5.
>>>>>>>>>> Best regards,
>>>>>>>>>>
>>>>>>>>>> Dmitry Vyazelenko
>>>>>>>>>>
>>>>>>>>>> On Aug 12, 2012, at 21:35 , Richard Warburton
>>>>>>>>> <richard.warburton at gmail.com> wrote:
>>>>>>>>>>> Hello,
>>>>>>>>>>>
>>>>>>>>>>> The current implementation of java.io.File::toPath [0]
>>>>> appears to be
>>>>>>>>>>> using the double checked locking pattern:
>>>>>>>>>>>
>>>>>>>>>>>      public Path toPath() {
>>>>>>>>>>>          Path result = filePath;
>>>>>>>>>>>          if (result == null) {
>>>>>>>>>>>              synchronized (this) {
>>>>>>>>>>>                  result = filePath;
>>>>>>>>>>>                  if (result == null) {
>>>>>>>>>>>                      result =
>>>>> FileSystems.getDefault().getPath(path);
>>>>>>>>>>>                      filePath = result;
>>>>>>>>>>>                  }
>>>>>>>>>>>              }
>>>>>>>>>>>          }
>>>>>>>>>>>          return result;
>>>>>>>>>>>      }
>>>>>>>>>>>
>>>>>>>>>>> I was going to report the bug, but I'm a little uncertain of
>>>>>>>>>>> the
>>>>>>>>>>> interaction between the local variable 'result' and DCL
>>>>> since I've
>>>>>>>>>>> previously only seen the checking condition on the shared
>>>>>>>>>>> field
>>>>>>>>>>> itself.  Can someone here either confirm that its a bug or
>>>>>>> explain how
>>>>>>>>>>> the 'result' variable is fixing things?
>>>>>>>>>>>
>>>>>>>>>>> regards,
>>>>>>>>>>>
>>>>>>>>>>>   Richard
>>>>>>>>>>>
>>>>>>>>>>> [0] See the end of
>>>>>>>>>>>
>>>>>>>>> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>>>>>>>>> ses/java/io/File.java
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From joe.bowbeer at gmail.com  Mon Aug 13 18:01:31 2012
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 13 Aug 2012 15:01:31 -0700
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <5029759E.4070601@laposte.net>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
	<CAOwENiKx=5ktY64HuzKffVjrEhn9cKsxEStfjzSM2qG0vGq4Tg@mail.gmail.com>
	<5029759E.4070601@laposte.net>
Message-ID: <CAHzJPEq-AxjzYoEQFny5qpOaFWq+h=dY-Q3rjw1qaYsJJKn3WA@mail.gmail.com>

For completeness, here is the documentation for the @Immutable annotation
from JCiP, which is more heavily laden than the standard definition, and
leaves nothing to the imagination of paranoid programmers:

http://jcip.net/annotations/doc/net/jcip/annotations/Immutable.html

The class to which this annotation is applied is immutable. This means that
> its state cannot be seen to change by callers, which implies that
>
>    - all public fields are final,
>
>
>    - all public final reference fields refer to other immutable objects,
>    and
>
>
>    - constructors and methods do not publish references to any internal
>    state which is potentially mutable by the implementation.
>
>
> Immutable objects may still have internal mutable state for purposes of
> performance optimization; some state variables may be lazily computed, so
> long as they are computed from immutable state and that callers cannot tell
> the difference.
> Immutable objects are inherently thread-safe; they may be passed between
> threads or published without synchronization.



--Joe


On Mon, Aug 13, 2012 at 2:46 PM, Wolfgang Baltes wrote:

> Immutability and thread safety should be considered essentially orthogonal
> concepts. However, the final keyword can be useful in both.
>
> Immutability just means that the object cannot be changed after
> instantiation. There are several ways to achieve this, the most obvious
> ones are a) to make a data fields final, and b) not to provide a method
> that changes the values of data fields.
>
> Thread safe publishing means that, when an object reference is shared
> between threads, all threads see the object only in the same state as the
> thread which has last modified (or instantiated) the object. There are
> different ways to accomplish this, the most obvious ones being to declare a
> fields final or volatile. Final provides the guarantee that a field can
> safely be published to other threads after the constructor that assigns the
> value is finished. If there are multiple fields, than only those that are
> marked final are covered by the guarantee. This is different from volatile,
> where instructions - such as writes to non volatile fields - that appear in
> the code before a write to a volatile field, are guaranteed to be executed
> before the first subsequent read of that volatile field, no matter in which
> thread this read instruction occurs. In the latter case, a non volatile
> field which is never modified by any method may also appear as immutable
> and be published in a thread safe manner.
>
> Hence, marking a field final makes it immutable and publishable in a
> thread safe manner, if the reference to the object that holds the field is
> published after the constructor is finished.
>
> Wolfgang.
>
>
>
> On 2012-08-13 13:20, Ruslan Cheremin wrote:
>
>> Yes, and it is my point -- it's confusing to say "immutable" (which
>> form of?), confusing to say "thread safe" (in which multithreaded use
>> case it is safe?) and even more confusing to say both "immutable and
>> thread-safe" -- because actually there is (==I know) only two ways to
>> reach thread-safe immutability in java: "all fields final", or "all
>> methods sync-ed, including constructors" -- and the second one is very
>> rare.
>>
>> For me "immutable and thread safe" seems to be equivalent to
>> "thread-safe immutable", which, in turn, implies safety for data race
>> publication. How can I claim object as "thread safe immutable", if I
>> can see in several states in multithreaded env.?
>>
>>
>> 2012/8/13 Yuval Shavit:
>>
>>> This class is immutable but not thread-safe absent safe publication:
>>>
>>> public class MyImmutable {
>>>      private long val; // not marked final or volatile
>>>      public MyImmutable(long val) {
>>>          this.val = val;
>>>      }
>>>
>>>      public int getValue() {
>>>          return val;
>>>      }
>>> }
>>>
>>> In the absence of safe publication, a thread is allowed to see:
>>>
>>>      - val's default value (0)
>>>      - the value passed to the constructor
>>>      - a word tear in which val contains only the high or low word from
>>> the
>>> value passed to the constructor
>>>
>>>
>>> On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin wrote:
>>>
>>>> For me it is confusing: java has only one way to have really immutable
>>>> object, and this way also gives you a total thread safety even for
>>>> data race based publication. But then docs refer object as "immutable
>>>> and thread-safe" -- we still can't assume it to be really thread-safe?
>>>>
>>>> It's a pity, especially because true immutability gives us some
>>>> chances of performance optimization. As in this case -- we do not
>>>> really need .path to be volatile here, if we would assume Path to be
>>>> truly immutable. volatility here required only for ensuring safe
>>>> publishing.
>>>>
>>>> 2012/8/13 David Holmes:
>>>>
>>>>> Ruslan Cheremin writes:>
>>>>>
>>>>>> But is there a way to define "safe for data race publishing"? I as
>>>>>> far, as I remember, "immutable and thread-safe" is standard mantra in
>>>>>> JDK javadocs for totally safe objects. j.l.String has same mantra --
>>>>>> and it is safe for any way of publishing. Does you mean, I should
>>>>>> explicitly add "safe even for publishing via data race" in docs? But I
>>>>>> can't remember any such phrase in JDK docs.
>>>>>>
>>>>> I don't recall anything in the JDK docs that mention being "totally
>>>>> safe"
>>>>> regardless of publication mechanism. Some classes, eg String, have been
>>>>> defined such that they do have that property (for security reasons). In
>>>>> general neither "thread-safe" nor "immutable" imply
>>>>> safe-for-unsynchronized-**publication.
>>>>>
>>>>> Java Concurrency In Practice (jcip.net) does define additional
>>>>> potential
>>>>> annotations, where @Immutable would indeed capture the requirement of
>>>>> safe-for-unsynchronized-**publication.
>>>>>
>>>>> David
>>>>>
>>>>>>
>>>>>>>>>>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120813/f80de30d/attachment.html>

From yshavit at akiban.com  Mon Aug 13 18:02:37 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Mon, 13 Aug 2012 18:02:37 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <5029759E.4070601@laposte.net>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
	<CAOwENiKx=5ktY64HuzKffVjrEhn9cKsxEStfjzSM2qG0vGq4Tg@mail.gmail.com>
	<5029759E.4070601@laposte.net>
Message-ID: <CAC2Zdp1g3ie+UOmVdHE1UBSHEOFHdpZjo+duX6r8JuqkNg7hvg@mail.gmail.com>

On Mon, Aug 13, 2012 at 5:46 PM, Wolfgang Baltes <
wolfgang.baltes at laposte.net> wrote:

> There are different ways to accomplish this, the most obvious ones being
> to declare a fields final or volatile.


I would say that the most obvious way is to use a safe publication
mechanism, such as any of the threadsafe collections, which establishes a
happens-before between the put and subsequent get. If your object's fields
don't change after the constructor, and thread A gives the object to thread
B via a threadsafe collection, then it doesn't matter whether the object's
fields are final/volatile -- the HB barrier is provided by the collection.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120813/ccb2ac53/attachment-0001.html>

From davidcholmes at aapt.net.au  Mon Aug 13 19:08:13 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 14 Aug 2012 09:08:13 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>

Ruslan Cheremin writes:
>
> For me it is confusing: java has only one way to have really immutable
> object, and this way also gives you a total thread safety even for
> data race based publication. But then docs refer object as "immutable
> and thread-safe" -- we still can't assume it to be really thread-safe?

It is better/simpler to isolate the notion of thread-safety and safe
publication. Thread-safety comes into play after you have safely shared an
object. The means by which you safely share an object is orthogonal to how
the object itself is made thread-safe.

The means by which an object is shared has to involve shared mutable state,
and use of shared mutable state always needs some form of synchronization
(either implicit eg due to static initialization; or explicit by using
volatile or synchronized getter/setter methods).

David
-----

> It's a pity, especially because true immutability gives us some
> chances of performance optimization. As in this case -- we do not
> really need .path to be volatile here, if we would assume Path to be
> truly immutable. volatility here required only for ensuring safe
> publishing.
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > Ruslan Cheremin writes:>
> >> But is there a way to define "safe for data race publishing"? I as
> >> far, as I remember, "immutable and thread-safe" is standard mantra in
> >> JDK javadocs for totally safe objects. j.l.String has same mantra --
> >> and it is safe for any way of publishing. Does you mean, I should
> >> explicitly add "safe even for publishing via data race" in docs? But I
> >> can't remember any such phrase in JDK docs.
> >
> > I don't recall anything in the JDK docs that mention being
> "totally safe"
> > regardless of publication mechanism. Some classes, eg String, have been
> > defined such that they do have that property (for security reasons). In
> > general neither "thread-safe" nor "immutable" imply
> > safe-for-unsynchronized-publication.
> >
> > Java Concurrency In Practice (jcip.net) does define additional potential
> > annotations, where @Immutable would indeed capture the requirement of
> > safe-for-unsynchronized-publication.
> >
> > David
> > -----
> >
> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> > Ruslan Cheremin writes:
> >> >> Well, Path javadoc explicitly says "immutable and safe for
> >> >> multithreaded use". Although it is not strictly defined in java what
> >> >> exactly means "safe for multithreaded use" -- does it mean safe for
> >> >> publishing via data race, among others? -- I suppose, it
> should be. Am
> >> >> I wrong here?
> >> >
> >> > "safe for multi-threaded use" does not generally imply that it
> >> is safe to
> >> > publish instances without synchronization of some form.
> >> >
> >> > David
> >> > -----
> >> >
> >> >> From other side, File.toPath javadoc explicitly says what "returned
> >> >> instance must be the same for every invocation", so sync block is
> >> >> required here for mutual exclusion on initialization phase. Without
> >> >> this requirement it is also safe to live without sync block, afaik.
> >> >>
> >> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> > Ruslan Cheremin writes:
> >> >> >>
> >> >> >> First of all, Path is immutable, so DCL is safe here even without
> >> >> >> volatile. Volatile here is not required from my point of view.
> >> >> >
> >> >> > Without the volatile the Path implementation (Path is an
> >> >> interface) must be
> >> >> > such that an instance of Path can be safely published without
> >> >> any additional
> >> >> > forms of synchronization. Immutability does not in itself
> >> >> ensure that. You
> >> >> > would have to examine the actual implementation class.
> >> >> >
> >> >> > David Holmes
> >> >> > ------------
> >> >> >
> >> >> >>
> >> >> >>
> >> >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >> > Hi Richard,
> >> >> >> >
> >> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> >> locking is correct in this case. It would have been a bug
> >> >> prior to Java 5.
> >> >> >> >
> >> >> >> > Best regards,
> >> >> >> >
> >> >> >> > Dmitry Vyazelenko
> >> >> >> >
> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >> <richard.warburton at gmail.com> wrote:
> >> >> >> >
> >> >> >> >> Hello,
> >> >> >> >>
> >> >> >> >> The current implementation of java.io.File::toPath [0]
> >> appears to be
> >> >> >> >> using the double checked locking pattern:
> >> >> >> >>
> >> >> >> >>     public Path toPath() {
> >> >> >> >>         Path result = filePath;
> >> >> >> >>         if (result == null) {
> >> >> >> >>             synchronized (this) {
> >> >> >> >>                 result = filePath;
> >> >> >> >>                 if (result == null) {
> >> >> >> >>                     result =
> >> FileSystems.getDefault().getPath(path);
> >> >> >> >>                     filePath = result;
> >> >> >> >>                 }
> >> >> >> >>             }
> >> >> >> >>         }
> >> >> >> >>         return result;
> >> >> >> >>     }
> >> >> >> >>
> >> >> >> >> I was going to report the bug, but I'm a little
> uncertain of the
> >> >> >> >> interaction between the local variable 'result' and DCL
> >> since I've
> >> >> >> >> previously only seen the checking condition on the
> shared field
> >> >> >> >> itself.  Can someone here either confirm that its a bug or
> >> >> explain how
> >> >> >> >> the 'result' variable is fixing things?
> >> >> >> >>
> >> >> >> >> regards,
> >> >> >> >>
> >> >> >> >>  Richard
> >> >> >> >>
> >> >> >> >> [0] See the end of
> >> >> >> >>
> >> >> >>
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >> ses/java/io/File.java
> >> >> >> >> _______________________________________________
> >> >> >> >> Concurrency-interest mailing list
> >> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> _______________________________________________
> >> >> >> Concurrency-interest mailing list
> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >>
> >> >> >
> >> >>
> >> >
> >>
> >
>


From hans.boehm at hp.com  Mon Aug 13 19:58:31 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Mon, 13 Aug 2012 23:58:31 +0000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHzJPEq-AxjzYoEQFny5qpOaFWq+h=dY-Q3rjw1qaYsJJKn3WA@mail.gmail.com>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
	<CAOwENiKx=5ktY64HuzKffVjrEhn9cKsxEStfjzSM2qG0vGq4Tg@mail.gmail.com>
	<5029759E.4070601@laposte.net>
	<CAHzJPEq-AxjzYoEQFny5qpOaFWq+h=dY-Q3rjw1qaYsJJKn3WA@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F5FCC6@G4W3296.americas.hpqcorp.net>

I tend to think in terms of several useful levels of thread-safety:



1. Immutable, as defined below.  Untrusted code can create one, and it will always look the same to every observer.  There is no danger of a security check seeing one value and a later action seeing another.  Needed for String and the like.



2. "Thread-safe".  If I'm handed one by untrusted code, I shouldn't believe it.  But method calls are linearizable, and the right happens-before relationships are introduced.  I can assume such an object is not communicated via a race, since I don't care how it behaves with untrusted code.  A lot of j.u.c. classes fit here, I think, as does Vector.



3. "Behaves like built-ins".  Concurrent calls to "read" methods or to different objects behave correctly.  Concurrent calls on the same object, when at least one logically modifies the object is a bug.  Normal default behavior for ordinary collections, e.g. ArrayList, though many of them may have some additional, more specific, guarantees.  The client protects these with locks, as would an int.



4. Really, seriously thread-unsafe.  Accesses static fields behind the scenes without locking, modifies the data structure for logically read-only operations (think splay trees), etc.



I think all of those are useful.  (In particular, 3 is incredibly useful, and really needs a better name.)  I'm not sure how many more are.



Hans




From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Joe Bowbeer
Sent: Monday, August 13, 2012 3:02 PM
To: concurrency-interest
Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK

For completeness, here is the documentation for the @Immutable annotation from JCiP, which is more heavily laden than the standard definition, and leaves nothing to the imagination of paranoid programmers:

http://jcip.net/annotations/doc/net/jcip/annotations/Immutable.html

The class to which this annotation is applied is immutable. This means that its state cannot be seen to change by callers, which implies that

  *   all public fields are final,

  *   all public final reference fields refer to other immutable objects, and

  *   constructors and methods do not publish references to any internal state which is potentially mutable by the implementation.

Immutable objects may still have internal mutable state for purposes of performance optimization; some state variables may be lazily computed, so long as they are computed from immutable state and that callers cannot tell the difference.
Immutable objects are inherently thread-safe; they may be passed between threads or published without synchronization.


--Joe

On Mon, Aug 13, 2012 at 2:46 PM, Wolfgang Baltes wrote:
Immutability and thread safety should be considered essentially orthogonal concepts. However, the final keyword can be useful in both.

Immutability just means that the object cannot be changed after instantiation. There are several ways to achieve this, the most obvious ones are a) to make a data fields final, and b) not to provide a method that changes the values of data fields.

Thread safe publishing means that, when an object reference is shared between threads, all threads see the object only in the same state as the thread which has last modified (or instantiated) the object. There are different ways to accomplish this, the most obvious ones being to declare a fields final or volatile. Final provides the guarantee that a field can safely be published to other threads after the constructor that assigns the value is finished. If there are multiple fields, than only those that are marked final are covered by the guarantee. This is different from volatile, where instructions - such as writes to non volatile fields - that appear in the code before a write to a volatile field, are guaranteed to be executed before the first subsequent read of that volatile field, no matter in which thread this read instruction occurs. In the latter case, a non volatile field which is never modified by any method may also appear as immutable and be published in a thread safe manner.

Hence, marking a field final makes it immutable and publishable in a thread safe manner, if the reference to the object that holds the field is published after the constructor is finished.

Wolfgang.



On 2012-08-13 13:20, Ruslan Cheremin wrote:
Yes, and it is my point -- it's confusing to say "immutable" (which
form of?), confusing to say "thread safe" (in which multithreaded use
case it is safe?) and even more confusing to say both "immutable and
thread-safe" -- because actually there is (==I know) only two ways to
reach thread-safe immutability in java: "all fields final", or "all
methods sync-ed, including constructors" -- and the second one is very
rare.

For me "immutable and thread safe" seems to be equivalent to
"thread-safe immutable", which, in turn, implies safety for data race
publication. How can I claim object as "thread safe immutable", if I
can see in several states in multithreaded env.?


2012/8/13 Yuval Shavit:
This class is immutable but not thread-safe absent safe publication:

public class MyImmutable {
     private long val; // not marked final or volatile
     public MyImmutable(long val) {
         this.val = val;
     }

     public int getValue() {
         return val;
     }
}

In the absence of safe publication, a thread is allowed to see:

     - val's default value (0)
     - the value passed to the constructor
     - a word tear in which val contains only the high or low word from the
value passed to the constructor


On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin wrote:
For me it is confusing: java has only one way to have really immutable
object, and this way also gives you a total thread safety even for
data race based publication. But then docs refer object as "immutable
and thread-safe" -- we still can't assume it to be really thread-safe?

It's a pity, especially because true immutability gives us some
chances of performance optimization. As in this case -- we do not
really need .path to be volatile here, if we would assume Path to be
truly immutable. volatility here required only for ensuring safe
publishing.

2012/8/13 David Holmes:
Ruslan Cheremin writes:>
But is there a way to define "safe for data race publishing"? I as
far, as I remember, "immutable and thread-safe" is standard mantra in
JDK javadocs for totally safe objects. j.l.String has same mantra --
and it is safe for any way of publishing. Does you mean, I should
explicitly add "safe even for publishing via data race" in docs? But I
can't remember any such phrase in JDK docs.
I don't recall anything in the JDK docs that mention being "totally
safe"
regardless of publication mechanism. Some classes, eg String, have been
defined such that they do have that property (for security reasons). In
general neither "thread-safe" nor "immutable" imply
safe-for-unsynchronized-publication.

Java Concurrency In Practice (jcip.net<http://jcip.net>) does define additional potential
annotations, where @Immutable would indeed capture the requirement of
safe-for-unsynchronized-publication.

David

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120813/aff6b099/attachment-0001.html>

From dl at cs.oswego.edu  Tue Aug 14 09:44:06 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 14 Aug 2012 09:44:06 -0400
Subject: [concurrency-interest] ConcurrentHashMap bulk parallel
	operations
In-Reply-To: <50292692.401@cs.oswego.edu>
References: <50292692.401@cs.oswego.edu>
Message-ID: <502A5626.6020607@cs.oswego.edu>


A few small follow-ups:

* One minor usage casualty of the initial merges of jsr166e/j.u.c vs
the old jsr166y is that you may now need to specifically import
particular classes such as ForkJoinPool if you previously used
import * conventions. Sorry.

* While preliminary performance checks are promising, beware that
the very first parallel task execution time can be terrible.
Really terrible. A lot of code needs compiling, threads
need to  be constructed, memory needs to be reserved, etc,
to get going. Hopefully some of this will improve.

* The CHM.Parallel methods deal only with operating on
a CHM once you have one. There are not any parallel-build
methods -- these are out of scope for this class. But
if you have some parallel operations in any other classes
(which are planned for JDK8), it is very easy to use them
to populate a CHM just using a forEach with action
mychm.putIfAbsent(x) (or put, or computeIfAbsent or
whatever).

-Doug


From tim at peierls.net  Tue Aug 14 09:59:27 2012
From: tim at peierls.net (Tim Peierls)
Date: Tue, 14 Aug 2012 09:59:27 -0400
Subject: [concurrency-interest] ConcurrentHashMap bulk parallel
	operations
In-Reply-To: <502A5626.6020607@cs.oswego.edu>
References: <50292692.401@cs.oswego.edu>
	<502A5626.6020607@cs.oswego.edu>
Message-ID: <CA+F8eeRkWw_KMR2rW-7kxOu4T_-_ntF9J=J_jOX46uTWczEEiQ@mail.gmail.com>

On Tue, Aug 14, 2012 at 9:44 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> * While preliminary performance checks are promising, beware that
> the very first parallel task execution time can be terrible.
> Really terrible. A lot of code needs compiling, threads
> need to  be constructed, memory needs to be reserved, etc,
> to get going. Hopefully some of this will improve.
>

First for the JVM? for the CHM classloader? for the CHM instance?

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/1ddbc46c/attachment.html>

From yshavit at akiban.com  Tue Aug 14 10:02:41 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Tue, 14 Aug 2012 10:02:41 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F5FCC6@G4W3296.americas.hpqcorp.net>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
	<CAOwENiKx=5ktY64HuzKffVjrEhn9cKsxEStfjzSM2qG0vGq4Tg@mail.gmail.com>
	<5029759E.4070601@laposte.net>
	<CAHzJPEq-AxjzYoEQFny5qpOaFWq+h=dY-Q3rjw1qaYsJJKn3WA@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F5FCC6@G4W3296.americas.hpqcorp.net>
Message-ID: <CAC2Zdp09XUZ7Ecr1NrJKy-q6dH72k2jJoRvS8gENeO9FwcShQQ@mail.gmail.com>

Except that, as I understand it, #3 doesn't exist. The non-threadsafe
collections aren't threadsafe even if the only concurrent actions are read
methods, because of memory visibility. Specifically, if you have:

   - publish ArrayList to threads A and B
   - modify ArrayList (when A and B happen to not be reading it, but
without locking to ensure that)
   - A and B read ArrayList

... then that is *not* safe, because A and B are allowed to see only some
of the action performed by step 2. For instance, maybe they see the list's
size incremented, but don't see changes to its array. Or maybe they see
everything in the ArrayList correctly, but don't see correct state in an
object they read from it.

(I'm assuming that you meant by option #3 that there aren't concurrent
writes, but that you don't enforce this via a lock. If you enforce it via a
lock, you've externally synchronized the object and everything's fine...
but in that case, the object's threadsafety-ness doesn't matter.)

On Mon, Aug 13, 2012 at 7:58 PM, Boehm, Hans <hans.boehm at hp.com> wrote:

>  I tend to think in terms of several useful levels of thread-safety:****
>
> ** **
>
> 1. Immutable, as defined below.  Untrusted code can create one, and it
> will always look the same to every observer.  There is no danger of a
> security check seeing one value and a later action seeing another.  Needed
> for String and the like.****
>
> ** **
>
> 2. "Thread-safe".  If I'm handed one by untrusted code, I shouldn't
> believe it.  But method calls are linearizable, and the right
> happens-before relationships are introduced.  I can assume such an object
> is not communicated via a race, since I don't care how it behaves with
> untrusted code.  A lot of j.u.c. classes fit here, I think, as does Vector.
> ****
>
> ** **
>
> 3. "Behaves like built-ins".  Concurrent calls to "read" methods or to
> different objects behave correctly.  Concurrent calls on the same object,
> when at least one logically modifies the object is a bug.  Normal default
> behavior for ordinary collections, e.g. ArrayList, though many of them may
> have some additional, more specific, guarantees.  The client protects these
> with locks, as would an int.****
>
> ** **
>
> 4. Really, seriously thread-unsafe.  Accesses static fields behind the
> scenes without locking, modifies the data structure for logically read-only
> operations (think splay trees), etc.****
>
> ** **
>
> I think all of those are useful.  (In particular, 3 is incredibly useful,
> and really needs a better name.)  I'm not sure how many more are.****
>
> ** **
>
> Hans****
>
> ** **
>
> ** **
>
> ** **
>
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Joe Bowbeer
> *Sent:* Monday, August 13, 2012 3:02 PM
> *To:* concurrency-interest
>
> *Subject:* Re: [concurrency-interest] Double Checked Locking in OpenJDK***
> *
>
>  ** **
>
> For completeness, here is the documentation for the @Immutable annotation
> from JCiP, which is more heavily laden than the standard definition, and
> leaves nothing to the imagination of paranoid programmers:****
>
> ** **
>
> http://jcip.net/annotations/doc/net/jcip/annotations/Immutable.html****
>
> ** **
>
> The class to which this annotation is applied is immutable. This means
> that its state cannot be seen to change by callers, which implies that****
>
>    - all public fields are final,****
>
>
>    - all public final reference fields refer to other immutable objects,
>    and****
>
>
>    - constructors and methods do not publish references to any internal
>    state which is potentially mutable by the implementation.****
>
>
> Immutable objects may still have internal mutable state for purposes of
> performance optimization; some state variables may be lazily computed, so
> long as they are computed from immutable state and that callers cannot tell
> the difference.
> Immutable objects are inherently thread-safe; they may be passed between
> threads or published without synchronization.****
>
>  ** **
>
> ** **
>
> --Joe****
>
> ** **
>
> On Mon, Aug 13, 2012 at 2:46 PM, Wolfgang Baltes wrote:****
>
> Immutability and thread safety should be considered essentially orthogonal
> concepts. However, the final keyword can be useful in both.
>
> Immutability just means that the object cannot be changed after
> instantiation. There are several ways to achieve this, the most obvious
> ones are a) to make a data fields final, and b) not to provide a method
> that changes the values of data fields.
>
> Thread safe publishing means that, when an object reference is shared
> between threads, all threads see the object only in the same state as the
> thread which has last modified (or instantiated) the object. There are
> different ways to accomplish this, the most obvious ones being to declare a
> fields final or volatile. Final provides the guarantee that a field can
> safely be published to other threads after the constructor that assigns the
> value is finished. If there are multiple fields, than only those that are
> marked final are covered by the guarantee. This is different from volatile,
> where instructions - such as writes to non volatile fields - that appear in
> the code before a write to a volatile field, are guaranteed to be executed
> before the first subsequent read of that volatile field, no matter in which
> thread this read instruction occurs. In the latter case, a non volatile
> field which is never modified by any method may also appear as immutable
> and be published in a thread safe manner.
>
> Hence, marking a field final makes it immutable and publishable in a
> thread safe manner, if the reference to the object that holds the field is
> published after the constructor is finished.
>
> Wolfgang.****
>
>
>
>
> On 2012-08-13 13:20, Ruslan Cheremin wrote:****
>
> Yes, and it is my point -- it's confusing to say "immutable" (which
> form of?), confusing to say "thread safe" (in which multithreaded use
> case it is safe?) and even more confusing to say both "immutable and
> thread-safe" -- because actually there is (==I know) only two ways to
> reach thread-safe immutability in java: "all fields final", or "all
> methods sync-ed, including constructors" -- and the second one is very
> rare.
>
> For me "immutable and thread safe" seems to be equivalent to
> "thread-safe immutable", which, in turn, implies safety for data race
> publication. How can I claim object as "thread safe immutable", if I
> can see in several states in multithreaded env.?
>
>
> 2012/8/13 Yuval Shavit:****
>
> This class is immutable but not thread-safe absent safe publication:
>
> public class MyImmutable {
>      private long val; // not marked final or volatile
>      public MyImmutable(long val) {
>          this.val = val;
>      }
>
>      public int getValue() {
>          return val;
>      }
> }
>
> In the absence of safe publication, a thread is allowed to see:
>
>      - val's default value (0)
>      - the value passed to the constructor
>      - a word tear in which val contains only the high or low word from the
> value passed to the constructor
>
>
> On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin wrote:****
>
> For me it is confusing: java has only one way to have really immutable
> object, and this way also gives you a total thread safety even for
> data race based publication. But then docs refer object as "immutable
> and thread-safe" -- we still can't assume it to be really thread-safe?
>
> It's a pity, especially because true immutability gives us some
> chances of performance optimization. As in this case -- we do not
> really need .path to be volatile here, if we would assume Path to be
> truly immutable. volatility here required only for ensuring safe
> publishing.
>
> 2012/8/13 David Holmes:****
>
> Ruslan Cheremin writes:>****
>
> But is there a way to define "safe for data race publishing"? I as
> far, as I remember, "immutable and thread-safe" is standard mantra in
> JDK javadocs for totally safe objects. j.l.String has same mantra --
> and it is safe for any way of publishing. Does you mean, I should
> explicitly add "safe even for publishing via data race" in docs? But I
> can't remember any such phrase in JDK docs.****
>
> I don't recall anything in the JDK docs that mention being "totally
> safe"
> regardless of publication mechanism. Some classes, eg String, have been
> defined such that they do have that property (for security reasons). In
> general neither "thread-safe" nor "immutable" imply
> safe-for-unsynchronized-publication.
>
> Java Concurrency In Practice (jcip.net) does define additional potential
> annotations, where @Immutable would indeed capture the requirement of
> safe-for-unsynchronized-publication.
>
> David****
>
>    ** **
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/2fcc4659/attachment-0001.html>

From dl at cs.oswego.edu  Tue Aug 14 10:11:26 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 14 Aug 2012 10:11:26 -0400
Subject: [concurrency-interest] ConcurrentHashMap bulk
	parallel	operations
In-Reply-To: <CA+F8eeRkWw_KMR2rW-7kxOu4T_-_ntF9J=J_jOX46uTWczEEiQ@mail.gmail.com>
References: <50292692.401@cs.oswego.edu>	<502A5626.6020607@cs.oswego.edu>
	<CA+F8eeRkWw_KMR2rW-7kxOu4T_-_ntF9J=J_jOX46uTWczEEiQ@mail.gmail.com>
Message-ID: <502A5C8E.5090605@cs.oswego.edu>

On 08/14/12 09:59, Tim Peierls wrote:
> On Tue, Aug 14, 2012 at 9:44 AM, Doug Lea <dl at cs.oswego.edu
> <mailto:dl at cs.oswego.edu>> wrote:
>
>     * While preliminary performance checks are promising, beware that
>     the very first parallel task execution time can be terrible.
>     Really terrible. A lot of code needs compiling, threads
>     need to  be constructed, memory needs to be reserved, etc,
>     to get going. Hopefully some of this will improve.
>
>
> First for the JVM? for the CHM classloader? for the CHM instance?
>

The worst case is for "All of the above". Others generally less so.
Here's an example run of an in-progress test program that just
computes sums in different ways in a CHM with about 10M elements:

Sequential:
   time:    1.331
First parallel run:
   time:    8.189
Next few runs:
   time:    0.064
   time:    0.064
   time:    0.047
   time:    0.044
...
(stays around the same time from there)
Now switch to a different (more expensive) sum function:
   time:    1.214
   time:    0.080
   time:    0.075
...


-Doug

From forax at univ-mlv.fr  Tue Aug 14 10:42:55 2012
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Tue, 14 Aug 2012 16:42:55 +0200
Subject: [concurrency-interest] ConcurrentHashMap bulk
	parallel	operations
In-Reply-To: <502A5C8E.5090605@cs.oswego.edu>
References: <50292692.401@cs.oswego.edu>	<502A5626.6020607@cs.oswego.edu>
	<CA+F8eeRkWw_KMR2rW-7kxOu4T_-_ntF9J=J_jOX46uTWczEEiQ@mail.gmail.com>
	<502A5C8E.5090605@cs.oswego.edu>
Message-ID: <502A63EF.2090601@univ-mlv.fr>

On 08/14/2012 04:11 PM, Doug Lea wrote:
> On 08/14/12 09:59, Tim Peierls wrote:
>> On Tue, Aug 14, 2012 at 9:44 AM, Doug Lea <dl at cs.oswego.edu
>> <mailto:dl at cs.oswego.edu>> wrote:
>>
>>     * While preliminary performance checks are promising, beware that
>>     the very first parallel task execution time can be terrible.
>>     Really terrible. A lot of code needs compiling, threads
>>     need to  be constructed, memory needs to be reserved, etc,
>>     to get going. Hopefully some of this will improve.
>>
>>
>> First for the JVM? for the CHM classloader? for the CHM instance?
>>
>
> The worst case is for "All of the above". Others generally less so.
> Here's an example run of an in-progress test program that just
> computes sums in different ways in a CHM with about 10M elements:
>
> Sequential:
>   time:    1.331
> First parallel run:
>   time:    8.189
> Next few runs:
>   time:    0.064
>   time:    0.064
>   time:    0.047
>   time:    0.044
> ...
> (stays around the same time from there)
> Now switch to a different (more expensive) sum function:
>   time:    1.214
>   time:    0.080
>   time:    0.075
> ...

Doug, can you do the same test but instead of switching to a more 
expensive sum function,
just switch to the same function but declared in an other inner class, 
and then switch again
to the same function declared in a third inner class.

>
>
> -Doug

R?mi


From dl at cs.oswego.edu  Tue Aug 14 11:33:13 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 14 Aug 2012 11:33:13 -0400
Subject: [concurrency-interest] ConcurrentHashMap
	bulk	parallel	operations
In-Reply-To: <502A63EF.2090601@univ-mlv.fr>
References: <50292692.401@cs.oswego.edu>	<502A5626.6020607@cs.oswego.edu>	<CA+F8eeRkWw_KMR2rW-7kxOu4T_-_ntF9J=J_jOX46uTWczEEiQ@mail.gmail.com>	<502A5C8E.5090605@cs.oswego.edu>
	<502A63EF.2090601@univ-mlv.fr>
Message-ID: <502A6FB9.2060204@cs.oswego.edu>

On 08/14/12 10:42, R?mi Forax wrote:

> Doug, can you do the same test but instead of switching to a more expensive sum
> function,
> just switch to the same function but declared in an other inner class, and then
> switch again
> to the same function declared in a third inner class.

Sure. Here's a variant that first does x + y:
    long psum = pm.reduceValuesToLong((x) ->x.longValue(), 0L,
                                                 (x,y) -> x + y);
then y + x:
             long psum = pm.reduceValuesToLong((x) ->x.longValue(), 0L,
                                                 (x,y) -> y + x);
then explicit function-objects "pls"
             long psum = pm.reduceValuesToLong(toLong, 0L, longPlus);
then back to x+y

Then just for algorithmic comparison, one that doesn't
bother with reduction, but instead just uses a forEach into a LongAdder:
             pm.forEachValue((x) -> adr.add(x.longValue()));

All running on current jdk8-lambda binary build on linux 64XNehalem
with a  ConcurrentHashMapV8<Long, Long> with random long keys.
There are a few other setup etc differences with the
version of the program I showed results before (including
those reducing GC impact during 1st parallel run, which
otherwise accentuate the terribleness.)

seq time   1.081
seq time   1.115
par x+y time   3.137
par x+y time   0.048
par x+y time   0.503
par x+y time   0.035
par x+y time   0.036
par x+y time   0.034
par x+y time   0.034
par x+y time   0.034
par x+y time   0.033
par x+y time   0.033
par y+x time   0.481
par y+x time   0.038
par y+x time   0.037
par y+x time   0.038
par y+x time   0.036
par y+x time   0.037
par y+x time   0.037
par y+x time   0.036
par y+x time   0.037
par y+x time   0.038
par pls time   0.734
par pls time   0.045
par pls time   0.041
par pls time   0.044
par pls time   0.043
par pls time   0.041
par pls time   0.051
par pls time   0.042
par pls time   0.042
par pls time   0.042
par x+y time   0.062
par x+y time   0.042
par x+y time   0.041
par x+y time   0.043
par x+y time   0.042
par x+y time   0.042
par x+y time   0.042
par x+y time   0.042
par x+y time   0.041
par x+y time   0.043
par adr time   0.866
par adr time   0.066
par adr time   0.071
par adr time   0.062
par adr time   0.063
par adr time   0.066
par adr time   0.068
par adr time   0.074
par adr time   0.067
par adr time   0.072



From hans.boehm at hp.com  Tue Aug 14 13:29:38 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Tue, 14 Aug 2012 17:29:38 +0000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAC2Zdp09XUZ7Ecr1NrJKy-q6dH72k2jJoRvS8gENeO9FwcShQQ@mail.gmail.com>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
	<CAOwENiKx=5ktY64HuzKffVjrEhn9cKsxEStfjzSM2qG0vGq4Tg@mail.gmail.com>
	<5029759E.4070601@laposte.net>
	<CAHzJPEq-AxjzYoEQFny5qpOaFWq+h=dY-Q3rjw1qaYsJJKn3WA@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F5FCC6@G4W3296.americas.hpqcorp.net>
	<CAC2Zdp09XUZ7Ecr1NrJKy-q6dH72k2jJoRvS8gENeO9FwcShQQ@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60075@G4W3296.americas.hpqcorp.net>

In the setting that you describe, there is no ordering enforced between "modify ArrayList" and "read ArrayList".  Hence (modulo one or two obscure corner cases that aren't quite handled correctly), there is an alternate schedule in which they occur concurrently.  Hence there can be a high level data race on the ArrayList, and this is a client bug.  Don't do that.  It is perfectly safe to use if you follow the rules and avoid the data race.

I'm not sure I characterized 3 very well in a Java context, since Java built-in types sort-of have stronger properties.  A better characterization is probably "safely usable in code that doesn't have high level data races on the class".

Hans

From: Yuval Shavit [mailto:yshavit at akiban.com]
Sent: Tuesday, August 14, 2012 7:03 AM
To: Boehm, Hans
Cc: Joe Bowbeer; concurrency-interest
Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK

Except that, as I understand it, #3 doesn't exist. The non-threadsafe collections aren't threadsafe even if the only concurrent actions are read methods, because of memory visibility. Specifically, if you have:

   - publish ArrayList to threads A and B
   - modify ArrayList (when A and B happen to not be reading it, but without locking to ensure that)
   - A and B read ArrayList

... then that is *not* safe, because A and B are allowed to see only some of the action performed by step 2. For instance, maybe they see the list's size incremented, but don't see changes to its array. Or maybe they see everything in the ArrayList correctly, but don't see correct state in an object they read from it.

(I'm assuming that you meant by option #3 that there aren't concurrent writes, but that you don't enforce this via a lock. If you enforce it via a lock, you've externally synchronized the object and everything's fine... but in that case, the object's threadsafety-ness doesn't matter.)
On Mon, Aug 13, 2012 at 7:58 PM, Boehm, Hans <hans.boehm at hp.com<mailto:hans.boehm at hp.com>> wrote:

I tend to think in terms of several useful levels of thread-safety:



1. Immutable, as defined below.  Untrusted code can create one, and it will always look the same to every observer.  There is no danger of a security check seeing one value and a later action seeing another.  Needed for String and the like.



2. "Thread-safe".  If I'm handed one by untrusted code, I shouldn't believe it.  But method calls are linearizable, and the right happens-before relationships are introduced.  I can assume such an object is not communicated via a race, since I don't care how it behaves with untrusted code.  A lot of j.u.c. classes fit here, I think, as does Vector.



3. "Behaves like built-ins".  Concurrent calls to "read" methods or to different objects behave correctly.  Concurrent calls on the same object, when at least one logically modifies the object is a bug.  Normal default behavior for ordinary collections, e.g. ArrayList, though many of them may have some additional, more specific, guarantees.  The client protects these with locks, as would an int.



4. Really, seriously thread-unsafe.  Accesses static fields behind the scenes without locking, modifies the data structure for logically read-only operations (think splay trees), etc.



I think all of those are useful.  (In particular, 3 is incredibly useful, and really needs a better name.)  I'm not sure how many more are.



Hans




From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu>] On Behalf Of Joe Bowbeer
Sent: Monday, August 13, 2012 3:02 PM
To: concurrency-interest

Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK

For completeness, here is the documentation for the @Immutable annotation from JCiP, which is more heavily laden than the standard definition, and leaves nothing to the imagination of paranoid programmers:

http://jcip.net/annotations/doc/net/jcip/annotations/Immutable.html

The class to which this annotation is applied is immutable. This means that its state cannot be seen to change by callers, which implies that

  *   all public fields are final,

  *   all public final reference fields refer to other immutable objects, and

  *   constructors and methods do not publish references to any internal state which is potentially mutable by the implementation.

Immutable objects may still have internal mutable state for purposes of performance optimization; some state variables may be lazily computed, so long as they are computed from immutable state and that callers cannot tell the difference.
Immutable objects are inherently thread-safe; they may be passed between threads or published without synchronization.


--Joe

On Mon, Aug 13, 2012 at 2:46 PM, Wolfgang Baltes wrote:
Immutability and thread safety should be considered essentially orthogonal concepts. However, the final keyword can be useful in both.

Immutability just means that the object cannot be changed after instantiation. There are several ways to achieve this, the most obvious ones are a) to make a data fields final, and b) not to provide a method that changes the values of data fields.

Thread safe publishing means that, when an object reference is shared between threads, all threads see the object only in the same state as the thread which has last modified (or instantiated) the object. There are different ways to accomplish this, the most obvious ones being to declare a fields final or volatile. Final provides the guarantee that a field can safely be published to other threads after the constructor that assigns the value is finished. If there are multiple fields, than only those that are marked final are covered by the guarantee. This is different from volatile, where instructions - such as writes to non volatile fields - that appear in the code before a write to a volatile field, are guaranteed to be executed before the first subsequent read of that volatile field, no matter in which thread this read instruction occurs. In the latter case, a non volatile field which is never modified by any method may also appear as immutable and be published in a thread safe manner.

Hence, marking a field final makes it immutable and publishable in a thread safe manner, if the reference to the object that holds the field is published after the constructor is finished.

Wolfgang.



On 2012-08-13 13:20, Ruslan Cheremin wrote:
Yes, and it is my point -- it's confusing to say "immutable" (which
form of?), confusing to say "thread safe" (in which multithreaded use
case it is safe?) and even more confusing to say both "immutable and
thread-safe" -- because actually there is (==I know) only two ways to
reach thread-safe immutability in java: "all fields final", or "all
methods sync-ed, including constructors" -- and the second one is very
rare.

For me "immutable and thread safe" seems to be equivalent to
"thread-safe immutable", which, in turn, implies safety for data race
publication. How can I claim object as "thread safe immutable", if I
can see in several states in multithreaded env.?


2012/8/13 Yuval Shavit:
This class is immutable but not thread-safe absent safe publication:

public class MyImmutable {
     private long val; // not marked final or volatile
     public MyImmutable(long val) {
         this.val = val;
     }

     public int getValue() {
         return val;
     }
}

In the absence of safe publication, a thread is allowed to see:

     - val's default value (0)
     - the value passed to the constructor
     - a word tear in which val contains only the high or low word from the
value passed to the constructor


On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin wrote:
For me it is confusing: java has only one way to have really immutable
object, and this way also gives you a total thread safety even for
data race based publication. But then docs refer object as "immutable
and thread-safe" -- we still can't assume it to be really thread-safe?

It's a pity, especially because true immutability gives us some
chances of performance optimization. As in this case -- we do not
really need .path to be volatile here, if we would assume Path to be
truly immutable. volatility here required only for ensuring safe
publishing.

2012/8/13 David Holmes:
Ruslan Cheremin writes:>
But is there a way to define "safe for data race publishing"? I as
far, as I remember, "immutable and thread-safe" is standard mantra in
JDK javadocs for totally safe objects. j.l.String has same mantra --
and it is safe for any way of publishing. Does you mean, I should
explicitly add "safe even for publishing via data race" in docs? But I
can't remember any such phrase in JDK docs.
I don't recall anything in the JDK docs that mention being "totally
safe"
regardless of publication mechanism. Some classes, eg String, have been
defined such that they do have that property (for security reasons). In
general neither "thread-safe" nor "immutable" imply
safe-for-unsynchronized-publication.

Java Concurrency In Practice (jcip.net<http://jcip.net>) does define additional potential
annotations, where @Immutable would indeed capture the requirement of
safe-for-unsynchronized-publication.

David


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/831a68f2/attachment-0001.html>

From yshavit at akiban.com  Tue Aug 14 14:10:00 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Tue, 14 Aug 2012 14:10:00 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60075@G4W3296.americas.hpqcorp.net>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
	<CAOwENiKx=5ktY64HuzKffVjrEhn9cKsxEStfjzSM2qG0vGq4Tg@mail.gmail.com>
	<5029759E.4070601@laposte.net>
	<CAHzJPEq-AxjzYoEQFny5qpOaFWq+h=dY-Q3rjw1qaYsJJKn3WA@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F5FCC6@G4W3296.americas.hpqcorp.net>
	<CAC2Zdp09XUZ7Ecr1NrJKy-q6dH72k2jJoRvS8gENeO9FwcShQQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60075@G4W3296.americas.hpqcorp.net>
Message-ID: <CAC2Zdp3-fOSmPe3oQ0whY4JeNiNkKfXK0qqgFvPRUVhEiGD=sA@mail.gmail.com>

I don't understand what you mean by scenario #3, then. What would a simple
example look like, concretely?

On Tue, Aug 14, 2012 at 1:29 PM, Boehm, Hans <hans.boehm at hp.com> wrote:

>  In the setting that you describe, there is no ordering enforced between
> ?modify ArrayList? and ?read ArrayList?.  Hence (modulo one or two obscure
> corner cases that aren?t quite handled correctly), there is an alternate
> schedule in which they occur concurrently.  Hence there can be a high level
> data race on the ArrayList, and this is a client bug.  Don?t do that.  It
> is perfectly safe to use if you follow the rules and avoid the data race.*
> ***
>
> ** **
>
> I?m not sure I characterized 3 very well in a Java context, since Java
> built-in types sort-of have stronger properties.  A better characterization
> is probably ?safely usable in code that doesn?t have high level data races
> on the class?.****
>
> ** **
>
> Hans****
>
> ** **
>
> *From:* Yuval Shavit [mailto:yshavit at akiban.com]
> *Sent:* Tuesday, August 14, 2012 7:03 AM
> *To:* Boehm, Hans
> *Cc:* Joe Bowbeer; concurrency-interest
>
> *Subject:* Re: [concurrency-interest] Double Checked Locking in OpenJDK***
> *
>
>  ** **
>
> Except that, as I understand it, #3 doesn't exist. The non-threadsafe
> collections aren't threadsafe even if the only concurrent actions are read
> methods, because of memory visibility. Specifically, if you have:****
>
> ** **
>
>    - publish ArrayList to threads A and B****
>
>    - modify ArrayList (when A and B happen to not be reading it, but
> without locking to ensure that)****
>
>    - A and B read ArrayList****
>
> ** **
>
> ... then that is *not* safe, because A and B are allowed to see only some
> of the action performed by step 2. For instance, maybe they see the list's
> size incremented, but don't see changes to its array. Or maybe they see
> everything in the ArrayList correctly, but don't see correct state in an
> object they read from it.****
>
> ** **
>
> (I'm assuming that you meant by option #3 that there aren't concurrent
> writes, but that you don't enforce this via a lock. If you enforce it via a
> lock, you've externally synchronized the object and everything's fine...
> but in that case, the object's threadsafety-ness doesn't matter.)****
>
> On Mon, Aug 13, 2012 at 7:58 PM, Boehm, Hans <hans.boehm at hp.com> wrote:***
> *
>
> I tend to think in terms of several useful levels of thread-safety:****
>
>  ****
>
> 1. Immutable, as defined below.  Untrusted code can create one, and it
> will always look the same to every observer.  There is no danger of a
> security check seeing one value and a later action seeing another.  Needed
> for String and the like.****
>
>  ****
>
> 2. "Thread-safe".  If I'm handed one by untrusted code, I shouldn't
> believe it.  But method calls are linearizable, and the right
> happens-before relationships are introduced.  I can assume such an object
> is not communicated via a race, since I don't care how it behaves with
> untrusted code.  A lot of j.u.c. classes fit here, I think, as does Vector.
> ****
>
>  ****
>
> 3. "Behaves like built-ins".  Concurrent calls to "read" methods or to
> different objects behave correctly.  Concurrent calls on the same object,
> when at least one logically modifies the object is a bug.  Normal default
> behavior for ordinary collections, e.g. ArrayList, though many of them may
> have some additional, more specific, guarantees.  The client protects these
> with locks, as would an int.****
>
>  ****
>
> 4. Really, seriously thread-unsafe.  Accesses static fields behind the
> scenes without locking, modifies the data structure for logically read-only
> operations (think splay trees), etc.****
>
>  ****
>
> I think all of those are useful.  (In particular, 3 is incredibly useful,
> and really needs a better name.)  I'm not sure how many more are.****
>
>  ****
>
> Hans****
>
>  ****
>
>  ****
>
>  ****
>
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Joe Bowbeer
> *Sent:* Monday, August 13, 2012 3:02 PM
> *To:* concurrency-interest****
>
>
> *Subject:* Re: [concurrency-interest] Double Checked Locking in OpenJDK***
> *
>
>  ****
>
> For completeness, here is the documentation for the @Immutable annotation
> from JCiP, which is more heavily laden than the standard definition, and
> leaves nothing to the imagination of paranoid programmers:****
>
>  ****
>
> http://jcip.net/annotations/doc/net/jcip/annotations/Immutable.html****
>
>  ****
>
> The class to which this annotation is applied is immutable. This means
> that its state cannot be seen to change by callers, which implies that****
>
>    - all public fields are final,****
>
>
>    - all public final reference fields refer to other immutable objects,
>    and****
>
>
>    - constructors and methods do not publish references to any internal
>    state which is potentially mutable by the implementation.****
>
>
> Immutable objects may still have internal mutable state for purposes of
> performance optimization; some state variables may be lazily computed, so
> long as they are computed from immutable state and that callers cannot tell
> the difference.
> Immutable objects are inherently thread-safe; they may be passed between
> threads or published without synchronization.****
>
>   ****
>
>  ****
>
> --Joe****
>
>  ****
>
> On Mon, Aug 13, 2012 at 2:46 PM, Wolfgang Baltes wrote:****
>
> Immutability and thread safety should be considered essentially orthogonal
> concepts. However, the final keyword can be useful in both.
>
> Immutability just means that the object cannot be changed after
> instantiation. There are several ways to achieve this, the most obvious
> ones are a) to make a data fields final, and b) not to provide a method
> that changes the values of data fields.
>
> Thread safe publishing means that, when an object reference is shared
> between threads, all threads see the object only in the same state as the
> thread which has last modified (or instantiated) the object. There are
> different ways to accomplish this, the most obvious ones being to declare a
> fields final or volatile. Final provides the guarantee that a field can
> safely be published to other threads after the constructor that assigns the
> value is finished. If there are multiple fields, than only those that are
> marked final are covered by the guarantee. This is different from volatile,
> where instructions - such as writes to non volatile fields - that appear in
> the code before a write to a volatile field, are guaranteed to be executed
> before the first subsequent read of that volatile field, no matter in which
> thread this read instruction occurs. In the latter case, a non volatile
> field which is never modified by any method may also appear as immutable
> and be published in a thread safe manner.
>
> Hence, marking a field final makes it immutable and publishable in a
> thread safe manner, if the reference to the object that holds the field is
> published after the constructor is finished.
>
> Wolfgang.****
>
>
>
>
> On 2012-08-13 13:20, Ruslan Cheremin wrote:****
>
> Yes, and it is my point -- it's confusing to say "immutable" (which
> form of?), confusing to say "thread safe" (in which multithreaded use
> case it is safe?) and even more confusing to say both "immutable and
> thread-safe" -- because actually there is (==I know) only two ways to
> reach thread-safe immutability in java: "all fields final", or "all
> methods sync-ed, including constructors" -- and the second one is very
> rare.
>
> For me "immutable and thread safe" seems to be equivalent to
> "thread-safe immutable", which, in turn, implies safety for data race
> publication. How can I claim object as "thread safe immutable", if I
> can see in several states in multithreaded env.?
>
>
> 2012/8/13 Yuval Shavit:****
>
> This class is immutable but not thread-safe absent safe publication:
>
> public class MyImmutable {
>      private long val; // not marked final or volatile
>      public MyImmutable(long val) {
>          this.val = val;
>      }
>
>      public int getValue() {
>          return val;
>      }
> }
>
> In the absence of safe publication, a thread is allowed to see:
>
>      - val's default value (0)
>      - the value passed to the constructor
>      - a word tear in which val contains only the high or low word from the
> value passed to the constructor
>
>
> On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin wrote:****
>
> For me it is confusing: java has only one way to have really immutable
> object, and this way also gives you a total thread safety even for
> data race based publication. But then docs refer object as "immutable
> and thread-safe" -- we still can't assume it to be really thread-safe?
>
> It's a pity, especially because true immutability gives us some
> chances of performance optimization. As in this case -- we do not
> really need .path to be volatile here, if we would assume Path to be
> truly immutable. volatility here required only for ensuring safe
> publishing.
>
> 2012/8/13 David Holmes:****
>
> Ruslan Cheremin writes:>****
>
> But is there a way to define "safe for data race publishing"? I as
> far, as I remember, "immutable and thread-safe" is standard mantra in
> JDK javadocs for totally safe objects. j.l.String has same mantra --
> and it is safe for any way of publishing. Does you mean, I should
> explicitly add "safe even for publishing via data race" in docs? But I
> can't remember any such phrase in JDK docs.****
>
> I don't recall anything in the JDK docs that mention being "totally
> safe"
> regardless of publication mechanism. Some classes, eg String, have been
> defined such that they do have that property (for security reasons). In
> general neither "thread-safe" nor "immutable" imply
> safe-for-unsynchronized-publication.
>
> Java Concurrency In Practice (jcip.net) does define additional potential
> annotations, where @Immutable would indeed capture the requirement of
> safe-for-unsynchronized-publication.
>
> David****
>
>     ****
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest****
>
> ** **
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/512a8347/attachment-0001.html>

From hans.boehm at hp.com  Tue Aug 14 14:32:27 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Tue, 14 Aug 2012 18:32:27 +0000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAC2Zdp3-fOSmPe3oQ0whY4JeNiNkKfXK0qqgFvPRUVhEiGD=sA@mail.gmail.com>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
	<CAOwENiKx=5ktY64HuzKffVjrEhn9cKsxEStfjzSM2qG0vGq4Tg@mail.gmail.com>
	<5029759E.4070601@laposte.net>
	<CAHzJPEq-AxjzYoEQFny5qpOaFWq+h=dY-Q3rjw1qaYsJJKn3WA@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F5FCC6@G4W3296.americas.hpqcorp.net>
	<CAC2Zdp09XUZ7Ecr1NrJKy-q6dH72k2jJoRvS8gENeO9FwcShQQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60075@G4W3296.americas.hpqcorp.net>
	<CAC2Zdp3-fOSmPe3oQ0whY4JeNiNkKfXK0qqgFvPRUVhEiGD=sA@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60113@G4W3296.americas.hpqcorp.net>

Let's say I have two ArrayLists a and b.  I have multiple threads accessing them, protecting accesses to a and accesses to b with two separate ReadWriteLocks rwla and rwlb.  Since ArrayLists are (presumably) safe in sense 3, a program that guards all read accesses to a with rwla.readLock() guards all write accesses to a with rwla.writeLock(), and similarly for b, is well-synchronized, and hence guarantees sequential consistency, etc., just as if a and b were, say declared as double.

This is an important property, which I think we assume all the time.  But there are other natural classes for which it doesn't hold, e,g.


-          If a and b where completely unsynchronized splay trees.  The problem here is that two reads to a create a data race.

-          If ArrayList kept a global count of the total number of elements in all ArrayLists, and that count were not somehow synchronized.  In that case a write access to a in parallel with a write access to b would create a data race.  (This is contrived.  This usually happens in real life due to static caches, reference counting for copy optimization, or the like.)

The current ArrayList spec implies by example that it is thread-safe in sense (3).  It would be nice if it could actually state that.

Hans

From: Yuval Shavit [mailto:yshavit at akiban.com]
Sent: Tuesday, August 14, 2012 11:10 AM
To: Boehm, Hans
Cc: Joe Bowbeer; concurrency-interest
Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK

I don't understand what you mean by scenario #3, then. What would a simple example look like, concretely?
On Tue, Aug 14, 2012 at 1:29 PM, Boehm, Hans <hans.boehm at hp.com<mailto:hans.boehm at hp.com>> wrote:
In the setting that you describe, there is no ordering enforced between "modify ArrayList" and "read ArrayList".  Hence (modulo one or two obscure corner cases that aren't quite handled correctly), there is an alternate schedule in which they occur concurrently.  Hence there can be a high level data race on the ArrayList, and this is a client bug.  Don't do that.  It is perfectly safe to use if you follow the rules and avoid the data race.

I'm not sure I characterized 3 very well in a Java context, since Java built-in types sort-of have stronger properties.  A better characterization is probably "safely usable in code that doesn't have high level data races on the class".

Hans

From: Yuval Shavit [mailto:yshavit at akiban.com<mailto:yshavit at akiban.com>]
Sent: Tuesday, August 14, 2012 7:03 AM
To: Boehm, Hans
Cc: Joe Bowbeer; concurrency-interest

Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK

Except that, as I understand it, #3 doesn't exist. The non-threadsafe collections aren't threadsafe even if the only concurrent actions are read methods, because of memory visibility. Specifically, if you have:

   - publish ArrayList to threads A and B
   - modify ArrayList (when A and B happen to not be reading it, but without locking to ensure that)
   - A and B read ArrayList

... then that is *not* safe, because A and B are allowed to see only some of the action performed by step 2. For instance, maybe they see the list's size incremented, but don't see changes to its array. Or maybe they see everything in the ArrayList correctly, but don't see correct state in an object they read from it.

(I'm assuming that you meant by option #3 that there aren't concurrent writes, but that you don't enforce this via a lock. If you enforce it via a lock, you've externally synchronized the object and everything's fine... but in that case, the object's threadsafety-ness doesn't matter.)
On Mon, Aug 13, 2012 at 7:58 PM, Boehm, Hans <hans.boehm at hp.com<mailto:hans.boehm at hp.com>> wrote:

I tend to think in terms of several useful levels of thread-safety:



1. Immutable, as defined below.  Untrusted code can create one, and it will always look the same to every observer.  There is no danger of a security check seeing one value and a later action seeing another.  Needed for String and the like.



2. "Thread-safe".  If I'm handed one by untrusted code, I shouldn't believe it.  But method calls are linearizable, and the right happens-before relationships are introduced.  I can assume such an object is not communicated via a race, since I don't care how it behaves with untrusted code.  A lot of j.u.c. classes fit here, I think, as does Vector.



3. "Behaves like built-ins".  Concurrent calls to "read" methods or to different objects behave correctly.  Concurrent calls on the same object, when at least one logically modifies the object is a bug.  Normal default behavior for ordinary collections, e.g. ArrayList, though many of them may have some additional, more specific, guarantees.  The client protects these with locks, as would an int.



4. Really, seriously thread-unsafe.  Accesses static fields behind the scenes without locking, modifies the data structure for logically read-only operations (think splay trees), etc.



I think all of those are useful.  (In particular, 3 is incredibly useful, and really needs a better name.)  I'm not sure how many more are.



Hans




From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu>] On Behalf Of Joe Bowbeer
Sent: Monday, August 13, 2012 3:02 PM
To: concurrency-interest

Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK

For completeness, here is the documentation for the @Immutable annotation from JCiP, which is more heavily laden than the standard definition, and leaves nothing to the imagination of paranoid programmers:

http://jcip.net/annotations/doc/net/jcip/annotations/Immutable.html

The class to which this annotation is applied is immutable. This means that its state cannot be seen to change by callers, which implies that

  *   all public fields are final,

  *   all public final reference fields refer to other immutable objects, and

  *   constructors and methods do not publish references to any internal state which is potentially mutable by the implementation.

Immutable objects may still have internal mutable state for purposes of performance optimization; some state variables may be lazily computed, so long as they are computed from immutable state and that callers cannot tell the difference.
Immutable objects are inherently thread-safe; they may be passed between threads or published without synchronization.


--Joe

On Mon, Aug 13, 2012 at 2:46 PM, Wolfgang Baltes wrote:
Immutability and thread safety should be considered essentially orthogonal concepts. However, the final keyword can be useful in both.

Immutability just means that the object cannot be changed after instantiation. There are several ways to achieve this, the most obvious ones are a) to make a data fields final, and b) not to provide a method that changes the values of data fields.

Thread safe publishing means that, when an object reference is shared between threads, all threads see the object only in the same state as the thread which has last modified (or instantiated) the object. There are different ways to accomplish this, the most obvious ones being to declare a fields final or volatile. Final provides the guarantee that a field can safely be published to other threads after the constructor that assigns the value is finished. If there are multiple fields, than only those that are marked final are covered by the guarantee. This is different from volatile, where instructions - such as writes to non volatile fields - that appear in the code before a write to a volatile field, are guaranteed to be executed before the first subsequent read of that volatile field, no matter in which thread this read instruction occurs. In the latter case, a non volatile field which is never modified by any method may also appear as immutable and be published in a thread safe manner.

Hence, marking a field final makes it immutable and publishable in a thread safe manner, if the reference to the object that holds the field is published after the constructor is finished.

Wolfgang.



On 2012-08-13 13:20, Ruslan Cheremin wrote:
Yes, and it is my point -- it's confusing to say "immutable" (which
form of?), confusing to say "thread safe" (in which multithreaded use
case it is safe?) and even more confusing to say both "immutable and
thread-safe" -- because actually there is (==I know) only two ways to
reach thread-safe immutability in java: "all fields final", or "all
methods sync-ed, including constructors" -- and the second one is very
rare.

For me "immutable and thread safe" seems to be equivalent to
"thread-safe immutable", which, in turn, implies safety for data race
publication. How can I claim object as "thread safe immutable", if I
can see in several states in multithreaded env.?


2012/8/13 Yuval Shavit:
This class is immutable but not thread-safe absent safe publication:

public class MyImmutable {
     private long val; // not marked final or volatile
     public MyImmutable(long val) {
         this.val = val;
     }

     public int getValue() {
         return val;
     }
}

In the absence of safe publication, a thread is allowed to see:

     - val's default value (0)
     - the value passed to the constructor
     - a word tear in which val contains only the high or low word from the
value passed to the constructor


On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin wrote:
For me it is confusing: java has only one way to have really immutable
object, and this way also gives you a total thread safety even for
data race based publication. But then docs refer object as "immutable
and thread-safe" -- we still can't assume it to be really thread-safe?

It's a pity, especially because true immutability gives us some
chances of performance optimization. As in this case -- we do not
really need .path to be volatile here, if we would assume Path to be
truly immutable. volatility here required only for ensuring safe
publishing.

2012/8/13 David Holmes:
Ruslan Cheremin writes:>
But is there a way to define "safe for data race publishing"? I as
far, as I remember, "immutable and thread-safe" is standard mantra in
JDK javadocs for totally safe objects. j.l.String has same mantra --
and it is safe for any way of publishing. Does you mean, I should
explicitly add "safe even for publishing via data race" in docs? But I
can't remember any such phrase in JDK docs.
I don't recall anything in the JDK docs that mention being "totally
safe"
regardless of publication mechanism. Some classes, eg String, have been
defined such that they do have that property (for security reasons). In
general neither "thread-safe" nor "immutable" imply
safe-for-unsynchronized-publication.

Java Concurrency In Practice (jcip.net<http://jcip.net>) does define additional potential
annotations, where @Immutable would indeed capture the requirement of
safe-for-unsynchronized-publication.

David


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/f7a630a6/attachment-0001.html>

From nathan.reynolds at oracle.com  Tue Aug 14 14:58:56 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 14 Aug 2012 11:58:56 -0700
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
Message-ID: <502A9FF0.2000904@oracle.com>

We seem to be splitting two notions (i.e thread-safe and safe 
publication) when they should be combined in a sense.  Typically, when 
we say thread-safe we talk about the operations performed on the object 
after it was constructed (and its contents are globally visible).  
However, we need to consider that executing the constructor is modifying 
the state of the object.  It requires the same mechanisms that the rest 
of the class uses to ensure thread-safety.  Even though, there is only 1 
thread executing the constructor, a proper releasing of a lock or some 
other happens-before construct is required to ensure that the memory 
updates by the thread are made globally visible before the object is 
accessed by another thread. This is what we are calling safe 
publication.  So, safe publication is a subset of thread-safety except 
it is limited to what happens after the constructor is called and before 
the object is used by multiple threads.

A beautifully-written class can be thread-safe with respect to calling 
its member methods but not thread-safe with respect to calling its 
constructor.  It is this latter case that many stumble upon because they 
think that constructors are inherently thread-safe because they are 
executed single-threadedly.  What they fail to realize is that the 
execution of a constructor can overlap with the execution of other code 
from the view point of what is happening in memory.  This same problem 
applies to more rare case of regular methods which can be proven to 
execute in a single thread but don't use synchronization before multiple 
threads start accessing the shared data.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 8/13/2012 4:08 PM, David Holmes wrote:
> Ruslan Cheremin writes:
>> For me it is confusing: java has only one way to have really immutable
>> object, and this way also gives you a total thread safety even for
>> data race based publication. But then docs refer object as "immutable
>> and thread-safe" -- we still can't assume it to be really thread-safe?
> It is better/simpler to isolate the notion of thread-safety and safe
> publication. Thread-safety comes into play after you have safely shared an
> object. The means by which you safely share an object is orthogonal to how
> the object itself is made thread-safe.
>
> The means by which an object is shared has to involve shared mutable state,
> and use of shared mutable state always needs some form of synchronization
> (either implicit eg due to static initialization; or explicit by using
> volatile or synchronized getter/setter methods).
>
> David
> -----
>
>> It's a pity, especially because true immutability gives us some
>> chances of performance optimization. As in this case -- we do not
>> really need .path to be volatile here, if we would assume Path to be
>> truly immutable. volatility here required only for ensuring safe
>> publishing.
>>
>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>> Ruslan Cheremin writes:>
>>>> But is there a way to define "safe for data race publishing"? I as
>>>> far, as I remember, "immutable and thread-safe" is standard mantra in
>>>> JDK javadocs for totally safe objects. j.l.String has same mantra --
>>>> and it is safe for any way of publishing. Does you mean, I should
>>>> explicitly add "safe even for publishing via data race" in docs? But I
>>>> can't remember any such phrase in JDK docs.
>>> I don't recall anything in the JDK docs that mention being
>> "totally safe"
>>> regardless of publication mechanism. Some classes, eg String, have been
>>> defined such that they do have that property (for security reasons). In
>>> general neither "thread-safe" nor "immutable" imply
>>> safe-for-unsynchronized-publication.
>>>
>>> Java Concurrency In Practice (jcip.net) does define additional potential
>>> annotations, where @Immutable would indeed capture the requirement of
>>> safe-for-unsynchronized-publication.
>>>
>>> David
>>> -----
>>>
>>>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>>> Ruslan Cheremin writes:
>>>>>> Well, Path javadoc explicitly says "immutable and safe for
>>>>>> multithreaded use". Although it is not strictly defined in java what
>>>>>> exactly means "safe for multithreaded use" -- does it mean safe for
>>>>>> publishing via data race, among others? -- I suppose, it
>> should be. Am
>>>>>> I wrong here?
>>>>> "safe for multi-threaded use" does not generally imply that it
>>>> is safe to
>>>>> publish instances without synchronization of some form.
>>>>>
>>>>> David
>>>>> -----
>>>>>
>>>>>>  From other side, File.toPath javadoc explicitly says what "returned
>>>>>> instance must be the same for every invocation", so sync block is
>>>>>> required here for mutual exclusion on initialization phase. Without
>>>>>> this requirement it is also safe to live without sync block, afaik.
>>>>>>
>>>>>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>>>>> Ruslan Cheremin writes:
>>>>>>>> First of all, Path is immutable, so DCL is safe here even without
>>>>>>>> volatile. Volatile here is not required from my point of view.
>>>>>>> Without the volatile the Path implementation (Path is an
>>>>>> interface) must be
>>>>>>> such that an instance of Path can be safely published without
>>>>>> any additional
>>>>>>> forms of synchronization. Immutability does not in itself
>>>>>> ensure that. You
>>>>>>> would have to examine the actual implementation class.
>>>>>>>
>>>>>>> David Holmes
>>>>>>> ------------
>>>>>>>
>>>>>>>>
>>>>>>>> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>>>>>>>>> Hi Richard,
>>>>>>>>>
>>>>>>>>> The variable "filePath" is volatile, so the double-checked
>>>>>>>> locking is correct in this case. It would have been a bug
>>>>>> prior to Java 5.
>>>>>>>>> Best regards,
>>>>>>>>>
>>>>>>>>> Dmitry Vyazelenko
>>>>>>>>>
>>>>>>>>> On Aug 12, 2012, at 21:35 , Richard Warburton
>>>>>>>> <richard.warburton at gmail.com> wrote:
>>>>>>>>>> Hello,
>>>>>>>>>>
>>>>>>>>>> The current implementation of java.io.File::toPath [0]
>>>> appears to be
>>>>>>>>>> using the double checked locking pattern:
>>>>>>>>>>
>>>>>>>>>>      public Path toPath() {
>>>>>>>>>>          Path result = filePath;
>>>>>>>>>>          if (result == null) {
>>>>>>>>>>              synchronized (this) {
>>>>>>>>>>                  result = filePath;
>>>>>>>>>>                  if (result == null) {
>>>>>>>>>>                      result =
>>>> FileSystems.getDefault().getPath(path);
>>>>>>>>>>                      filePath = result;
>>>>>>>>>>                  }
>>>>>>>>>>              }
>>>>>>>>>>          }
>>>>>>>>>>          return result;
>>>>>>>>>>      }
>>>>>>>>>>
>>>>>>>>>> I was going to report the bug, but I'm a little
>> uncertain of the
>>>>>>>>>> interaction between the local variable 'result' and DCL
>>>> since I've
>>>>>>>>>> previously only seen the checking condition on the
>> shared field
>>>>>>>>>> itself.  Can someone here either confirm that its a bug or
>>>>>> explain how
>>>>>>>>>> the 'result' variable is fixing things?
>>>>>>>>>>
>>>>>>>>>> regards,
>>>>>>>>>>
>>>>>>>>>>   Richard
>>>>>>>>>>
>>>>>>>>>> [0] See the end of
>>>>>>>>>>
>> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>>>>>>>> ses/java/io/File.java
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/90bea371/attachment.html>

From viktor.klang at gmail.com  Tue Aug 14 15:08:23 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Tue, 14 Aug 2012 21:08:23 +0200
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <502A9FF0.2000904@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
Message-ID: <CANPzfU-oyHO_zceULWAE73OMrk1NTDMqrPzNyiMvJ5L8OFgPNg@mail.gmail.com>

On Tue, Aug 14, 2012 at 8:58 PM, Nathan Reynolds <nathan.reynolds at oracle.com
> wrote:

>  We seem to be splitting two notions (i.e thread-safe and safe
> publication) when they should be combined in a sense.  Typically, when we
> say thread-safe we talk about the operations performed on the object after
> it was constructed (and its contents are globally visible).  However, we
> need to consider that executing the constructor is modifying the state of
> the object.  It requires the same mechanisms that the rest of the class
> uses to ensure thread-safety.  Even though, there is only 1 thread
> executing the constructor, a proper releasing of a lock or some other
> happens-before construct is required to ensure that the memory updates by
> the thread are made globally visible before the object is accessed by
> another thread.  This is what we are calling safe publication.  So, safe
> publication is a subset of thread-safety except it is limited to what
> happens after the constructor is called and before the object is used by
> multiple threads.
>
> A beautifully-written class can be thread-safe with respect to calling its
> member methods but not thread-safe with respect to calling its
> constructor.  It is this latter case that many stumble upon because they
> think that constructors are inherently thread-safe because they are
> executed single-threadedly.  What they fail to realize is that the
> execution of a constructor can overlap with the execution of other code
> from the view point of what is happening in memory.  This same problem
> applies to more rare case of regular methods which can be proven to execute
> in a single thread but don't use synchronization before multiple threads
> start accessing the shared data.
>

Has there been any experimentation/papers on multiphased constructors
(where the identity is withheld until all memory cells are written)?

Cheers,
?


>
>
>  Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Consulting Member of Technical Staff |
> 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>  On 8/13/2012 4:08 PM, David Holmes wrote:
>
> Ruslan Cheremin writes:
>
>  For me it is confusing: java has only one way to have really immutable
> object, and this way also gives you a total thread safety even for
> data race based publication. But then docs refer object as "immutable
> and thread-safe" -- we still can't assume it to be really thread-safe?
>
>  It is better/simpler to isolate the notion of thread-safety and safe
> publication. Thread-safety comes into play after you have safely shared an
> object. The means by which you safely share an object is orthogonal to how
> the object itself is made thread-safe.
>
> The means by which an object is shared has to involve shared mutable state,
> and use of shared mutable state always needs some form of synchronization
> (either implicit eg due to static initialization; or explicit by using
> volatile or synchronized getter/setter methods).
>
> David
> -----
>
>
>  It's a pity, especially because true immutability gives us some
> chances of performance optimization. As in this case -- we do not
> really need .path to be volatile here, if we would assume Path to be
> truly immutable. volatility here required only for ensuring safe
> publishing.
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au> <davidcholmes at aapt.net.au>:
>
>  Ruslan Cheremin writes:>
>
>  But is there a way to define "safe for data race publishing"? I as
> far, as I remember, "immutable and thread-safe" is standard mantra in
> JDK javadocs for totally safe objects. j.l.String has same mantra --
> and it is safe for any way of publishing. Does you mean, I should
> explicitly add "safe even for publishing via data race" in docs? But I
> can't remember any such phrase in JDK docs.
>
>  I don't recall anything in the JDK docs that mention being
>
>  "totally safe"
>
>  regardless of publication mechanism. Some classes, eg String, have been
> defined such that they do have that property (for security reasons). In
> general neither "thread-safe" nor "immutable" imply
> safe-for-unsynchronized-publication.
>
> Java Concurrency In Practice (jcip.net) does define additional potential
> annotations, where @Immutable would indeed capture the requirement of
> safe-for-unsynchronized-publication.
>
> David
> -----
>
>
>  2012/8/13 David Holmes <davidcholmes at aapt.net.au> <davidcholmes at aapt.net.au>:
>
>  Ruslan Cheremin writes:
>
>  Well, Path javadoc explicitly says "immutable and safe for
> multithreaded use". Although it is not strictly defined in java what
> exactly means "safe for multithreaded use" -- does it mean safe for
> publishing via data race, among others? -- I suppose, it
>
>   should be. Am
>
>   I wrong here?
>
>  "safe for multi-threaded use" does not generally imply that it
>
>  is safe to
>
>  publish instances without synchronization of some form.
>
> David
> -----
>
>
>  From other side, File.toPath javadoc explicitly says what "returned
> instance must be the same for every invocation", so sync block is
> required here for mutual exclusion on initialization phase. Without
> this requirement it is also safe to live without sync block, afaik.
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au> <davidcholmes at aapt.net.au>:
>
>  Ruslan Cheremin writes:
>
>  First of all, Path is immutable, so DCL is safe here even without
> volatile. Volatile here is not required from my point of view.
>
>  Without the volatile the Path implementation (Path is an
>
>  interface) must be
>
>  such that an instance of Path can be safely published without
>
>  any additional
>
>  forms of synchronization. Immutability does not in itself
>
>  ensure that. You
>
>  would have to examine the actual implementation class.
>
> David Holmes
> ------------
>
>
>  2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com> <vyazelenko at yahoo.com>:
>
>  Hi Richard,
>
> The variable "filePath" is volatile, so the double-checked
>
>  locking is correct in this case. It would have been a bug
>
>  prior to Java 5.
>
>   Best regards,
>
> Dmitry Vyazelenko
>
> On Aug 12, 2012, at 21:35 , Richard Warburton
>
>  <richard.warburton at gmail.com> <richard.warburton at gmail.com> wrote:
>
>   Hello,
>
> The current implementation of java.io.File::toPath [0]
>
>    appears to be
>
>    using the double checked locking pattern:
>
>     public Path toPath() {
>         Path result = filePath;
>         if (result == null) {
>             synchronized (this) {
>                 result = filePath;
>                 if (result == null) {
>                     result =
>
>    FileSystems.getDefault().getPath(path);
>
>                        filePath = result;
>                 }
>             }
>         }
>         return result;
>     }
>
> I was going to report the bug, but I'm a little
>
>     uncertain of the
>
>     interaction between the local variable 'result' and DCL
>
>    since I've
>
>    previously only seen the checking condition on the
>
>     shared field
>
>     itself.  Can someone here either confirm that its a bug or
>
>   explain how
>
>   the 'result' variable is fixing things?
>
> regards,
>
>  Richard
>
> [0] See the end of
>
>
>      hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>
>    ses/java/io/File.java
>
>  _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>  _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>  _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>        _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/f37a8784/attachment-0001.html>

From zhong.j.yu at gmail.com  Tue Aug 14 15:25:19 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Tue, 14 Aug 2012 14:25:19 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
Message-ID: <CACuKZqGM4Be-pcN2ypHqigKhVtAO=u1qP+b=Q0Zm5ziqqO6Xyw@mail.gmail.com>

Many java users do use the term "immutable" to mean "thread-safe
immutable" (the 2nd term is from JLS7 section 17.5).

If we strengthen JMM just a little bit, by extending the memory
semantics of final fields to all fields, then there won't be this kind
of confusions - as long as an object is unmodified after construction,
it is thread-safe immutable, and all of its publications are safe
publications.

The only objection (from David Holmes) was that the final field
semantics could be expensive on some platforms. But final fields have
always been promoted without mentioning any downsides, therefore that
argument probably doesn't have many sympathizers.

Zhong Yu

On Mon, Aug 13, 2012 at 2:51 PM, Yuval Shavit <yshavit at akiban.com> wrote:
> This class is immutable but not thread-safe absent safe publication:
>
> public class MyImmutable {
>     private long val; // not marked final or volatile
>     public MyImmutable(long val) {
>         this.val = val;
>     }
>
>     public int getValue() {
>         return val;
>     }
> }
>
> In the absence of safe publication, a thread is allowed to see:
>
>     - val's default value (0)
>     - the value passed to the constructor
>     - a word tear in which val contains only the high or low word from the
> value passed to the constructor
>
>
> On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin <cheremin at gmail.com> wrote:
>>
>> For me it is confusing: java has only one way to have really immutable
>> object, and this way also gives you a total thread safety even for
>> data race based publication. But then docs refer object as "immutable
>> and thread-safe" -- we still can't assume it to be really thread-safe?
>>
>> It's a pity, especially because true immutability gives us some
>> chances of performance optimization. As in this case -- we do not
>> really need .path to be volatile here, if we would assume Path to be
>> truly immutable. volatility here required only for ensuring safe
>> publishing.
>>
>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> > Ruslan Cheremin writes:>
>> >> But is there a way to define "safe for data race publishing"? I as
>> >> far, as I remember, "immutable and thread-safe" is standard mantra in
>> >> JDK javadocs for totally safe objects. j.l.String has same mantra --
>> >> and it is safe for any way of publishing. Does you mean, I should
>> >> explicitly add "safe even for publishing via data race" in docs? But I
>> >> can't remember any such phrase in JDK docs.
>> >
>> > I don't recall anything in the JDK docs that mention being "totally
>> > safe"
>> > regardless of publication mechanism. Some classes, eg String, have been
>> > defined such that they do have that property (for security reasons). In
>> > general neither "thread-safe" nor "immutable" imply
>> > safe-for-unsynchronized-publication.
>> >
>> > Java Concurrency In Practice (jcip.net) does define additional potential
>> > annotations, where @Immutable would indeed capture the requirement of
>> > safe-for-unsynchronized-publication.
>> >
>> > David
>> > -----
>> >
>> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> > Ruslan Cheremin writes:
>> >> >> Well, Path javadoc explicitly says "immutable and safe for
>> >> >> multithreaded use". Although it is not strictly defined in java what
>> >> >> exactly means "safe for multithreaded use" -- does it mean safe for
>> >> >> publishing via data race, among others? -- I suppose, it should be.
>> >> >> Am
>> >> >> I wrong here?
>> >> >
>> >> > "safe for multi-threaded use" does not generally imply that it
>> >> is safe to
>> >> > publish instances without synchronization of some form.
>> >> >
>> >> > David
>> >> > -----
>> >> >
>> >> >> From other side, File.toPath javadoc explicitly says what "returned
>> >> >> instance must be the same for every invocation", so sync block is
>> >> >> required here for mutual exclusion on initialization phase. Without
>> >> >> this requirement it is also safe to live without sync block, afaik.
>> >> >>
>> >> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> > Ruslan Cheremin writes:
>> >> >> >>
>> >> >> >> First of all, Path is immutable, so DCL is safe here even without
>> >> >> >> volatile. Volatile here is not required from my point of view.
>> >> >> >
>> >> >> > Without the volatile the Path implementation (Path is an
>> >> >> interface) must be
>> >> >> > such that an instance of Path can be safely published without
>> >> >> any additional
>> >> >> > forms of synchronization. Immutability does not in itself
>> >> >> ensure that. You
>> >> >> > would have to examine the actual implementation class.
>> >> >> >
>> >> >> > David Holmes
>> >> >> > ------------
>> >> >> >
>> >> >> >>
>> >> >> >>
>> >> >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> >> >> > Hi Richard,
>> >> >> >> >
>> >> >> >> > The variable "filePath" is volatile, so the double-checked
>> >> >> >> locking is correct in this case. It would have been a bug
>> >> >> prior to Java 5.
>> >> >> >> >
>> >> >> >> > Best regards,
>> >> >> >> >
>> >> >> >> > Dmitry Vyazelenko
>> >> >> >> >
>> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >> >> <richard.warburton at gmail.com> wrote:
>> >> >> >> >
>> >> >> >> >> Hello,
>> >> >> >> >>
>> >> >> >> >> The current implementation of java.io.File::toPath [0]
>> >> appears to be
>> >> >> >> >> using the double checked locking pattern:
>> >> >> >> >>
>> >> >> >> >>     public Path toPath() {
>> >> >> >> >>         Path result = filePath;
>> >> >> >> >>         if (result == null) {
>> >> >> >> >>             synchronized (this) {
>> >> >> >> >>                 result = filePath;
>> >> >> >> >>                 if (result == null) {
>> >> >> >> >>                     result =
>> >> FileSystems.getDefault().getPath(path);
>> >> >> >> >>                     filePath = result;
>> >> >> >> >>                 }
>> >> >> >> >>             }
>> >> >> >> >>         }
>> >> >> >> >>         return result;
>> >> >> >> >>     }
>> >> >> >> >>
>> >> >> >> >> I was going to report the bug, but I'm a little uncertain of
>> >> >> >> >> the
>> >> >> >> >> interaction between the local variable 'result' and DCL
>> >> since I've
>> >> >> >> >> previously only seen the checking condition on the shared
>> >> >> >> >> field
>> >> >> >> >> itself.  Can someone here either confirm that its a bug or
>> >> >> explain how
>> >> >> >> >> the 'result' variable is fixing things?
>> >> >> >> >>
>> >> >> >> >> regards,
>> >> >> >> >>
>> >> >> >> >>  Richard
>> >> >> >> >>
>> >> >> >> >> [0] See the end of
>> >> >> >> >>
>> >> >> >>
>> >> >> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> >> >> ses/java/io/File.java
>> >> >> >> >> _______________________________________________
>> >> >> >> >> Concurrency-interest mailing list
>> >> >> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> _______________________________________________
>> >> >> >> Concurrency-interest mailing list
>> >> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >>
>> >> >> >
>> >> >>
>> >> >
>> >>
>> >
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From zhong.j.yu at gmail.com  Tue Aug 14 15:36:08 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Tue, 14 Aug 2012 14:36:08 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <502A9FF0.2000904@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
Message-ID: <CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>

>From a user's point of view, shouldn't constructors be special though?
An object shouldn't be considered in existence until its construction
is done; it is pathological that some outsider can observe a partially
constructed object. Life is simpler if we can eliminate that
possibility (unless `this` is leaked inside constructor)

Zhong Yu

On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
<nathan.reynolds at oracle.com> wrote:
> We seem to be splitting two notions (i.e thread-safe and safe publication)
> when they should be combined in a sense.  Typically, when we say thread-safe
> we talk about the operations performed on the object after it was
> constructed (and its contents are globally visible).  However, we need to
> consider that executing the constructor is modifying the state of the
> object.  It requires the same mechanisms that the rest of the class uses to
> ensure thread-safety.  Even though, there is only 1 thread executing the
> constructor, a proper releasing of a lock or some other happens-before
> construct is required to ensure that the memory updates by the thread are
> made globally visible before the object is accessed by another thread.  This
> is what we are calling safe publication.  So, safe publication is a subset
> of thread-safety except it is limited to what happens after the constructor
> is called and before the object is used by multiple threads.
>
> A beautifully-written class can be thread-safe with respect to calling its
> member methods but not thread-safe with respect to calling its constructor.
> It is this latter case that many stumble upon because they think that
> constructors are inherently thread-safe because they are executed
> single-threadedly.  What they fail to realize is that the execution of a
> constructor can overlap with the execution of other code from the view point
> of what is happening in memory.  This same problem applies to more rare case
> of regular methods which can be proven to execute in a single thread but
> don't use synchronization before multiple threads start accessing the shared
> data.
>
> Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering | Server Technology
> On 8/13/2012 4:08 PM, David Holmes wrote:
>
> Ruslan Cheremin writes:
>
> For me it is confusing: java has only one way to have really immutable
> object, and this way also gives you a total thread safety even for
> data race based publication. But then docs refer object as "immutable
> and thread-safe" -- we still can't assume it to be really thread-safe?
>
> It is better/simpler to isolate the notion of thread-safety and safe
> publication. Thread-safety comes into play after you have safely shared an
> object. The means by which you safely share an object is orthogonal to how
> the object itself is made thread-safe.
>
> The means by which an object is shared has to involve shared mutable state,
> and use of shared mutable state always needs some form of synchronization
> (either implicit eg due to static initialization; or explicit by using
> volatile or synchronized getter/setter methods).
>
> David
> -----
>
> It's a pity, especially because true immutability gives us some
> chances of performance optimization. As in this case -- we do not
> really need .path to be volatile here, if we would assume Path to be
> truly immutable. volatility here required only for ensuring safe
> publishing.
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>
> Ruslan Cheremin writes:>
>
> But is there a way to define "safe for data race publishing"? I as
> far, as I remember, "immutable and thread-safe" is standard mantra in
> JDK javadocs for totally safe objects. j.l.String has same mantra --
> and it is safe for any way of publishing. Does you mean, I should
> explicitly add "safe even for publishing via data race" in docs? But I
> can't remember any such phrase in JDK docs.
>
> I don't recall anything in the JDK docs that mention being
>
> "totally safe"
>
> regardless of publication mechanism. Some classes, eg String, have been
> defined such that they do have that property (for security reasons). In
> general neither "thread-safe" nor "immutable" imply
> safe-for-unsynchronized-publication.
>
> Java Concurrency In Practice (jcip.net) does define additional potential
> annotations, where @Immutable would indeed capture the requirement of
> safe-for-unsynchronized-publication.
>
> David
> -----
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>
> Ruslan Cheremin writes:
>
> Well, Path javadoc explicitly says "immutable and safe for
> multithreaded use". Although it is not strictly defined in java what
> exactly means "safe for multithreaded use" -- does it mean safe for
> publishing via data race, among others? -- I suppose, it
>
> should be. Am
>
> I wrong here?
>
> "safe for multi-threaded use" does not generally imply that it
>
> is safe to
>
> publish instances without synchronization of some form.
>
> David
> -----
>
> From other side, File.toPath javadoc explicitly says what "returned
> instance must be the same for every invocation", so sync block is
> required here for mutual exclusion on initialization phase. Without
> this requirement it is also safe to live without sync block, afaik.
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>
> Ruslan Cheremin writes:
>
> First of all, Path is immutable, so DCL is safe here even without
> volatile. Volatile here is not required from my point of view.
>
> Without the volatile the Path implementation (Path is an
>
> interface) must be
>
> such that an instance of Path can be safely published without
>
> any additional
>
> forms of synchronization. Immutability does not in itself
>
> ensure that. You
>
> would have to examine the actual implementation class.
>
> David Holmes
> ------------
>
>
> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>
> Hi Richard,
>
> The variable "filePath" is volatile, so the double-checked
>
> locking is correct in this case. It would have been a bug
>
> prior to Java 5.
>
> Best regards,
>
> Dmitry Vyazelenko
>
> On Aug 12, 2012, at 21:35 , Richard Warburton
>
> <richard.warburton at gmail.com> wrote:
>
> Hello,
>
> The current implementation of java.io.File::toPath [0]
>
> appears to be
>
> using the double checked locking pattern:
>
>     public Path toPath() {
>         Path result = filePath;
>         if (result == null) {
>             synchronized (this) {
>                 result = filePath;
>                 if (result == null) {
>                     result =
>
> FileSystems.getDefault().getPath(path);
>
>                     filePath = result;
>                 }
>             }
>         }
>         return result;
>     }
>
> I was going to report the bug, but I'm a little
>
> uncertain of the
>
> interaction between the local variable 'result' and DCL
>
> since I've
>
> previously only seen the checking condition on the
>
> shared field
>
> itself.  Can someone here either confirm that its a bug or
>
> explain how
>
> the 'result' variable is fixing things?
>
> regards,
>
>  Richard
>
> [0] See the end of
>
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>
> ses/java/io/File.java
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From vitalyd at gmail.com  Tue Aug 14 15:42:30 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 14 Aug 2012 15:42:30 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
Message-ID: <CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>

This is only an issue when publishing unsafely.  Allowing treating
constructors as regular methods is a good thing as it gives the compiler a
chance to optimize code, which everyone likes and benefits from.

Sent from my phone
On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:

> From a user's point of view, shouldn't constructors be special though?
> An object shouldn't be considered in existence until its construction
> is done; it is pathological that some outsider can observe a partially
> constructed object. Life is simpler if we can eliminate that
> possibility (unless `this` is leaked inside constructor)
>
> Zhong Yu
>
> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
> <nathan.reynolds at oracle.com> wrote:
> > We seem to be splitting two notions (i.e thread-safe and safe
> publication)
> > when they should be combined in a sense.  Typically, when we say
> thread-safe
> > we talk about the operations performed on the object after it was
> > constructed (and its contents are globally visible).  However, we need to
> > consider that executing the constructor is modifying the state of the
> > object.  It requires the same mechanisms that the rest of the class uses
> to
> > ensure thread-safety.  Even though, there is only 1 thread executing the
> > constructor, a proper releasing of a lock or some other happens-before
> > construct is required to ensure that the memory updates by the thread are
> > made globally visible before the object is accessed by another thread.
>  This
> > is what we are calling safe publication.  So, safe publication is a
> subset
> > of thread-safety except it is limited to what happens after the
> constructor
> > is called and before the object is used by multiple threads.
> >
> > A beautifully-written class can be thread-safe with respect to calling
> its
> > member methods but not thread-safe with respect to calling its
> constructor.
> > It is this latter case that many stumble upon because they think that
> > constructors are inherently thread-safe because they are executed
> > single-threadedly.  What they fail to realize is that the execution of a
> > constructor can overlap with the execution of other code from the view
> point
> > of what is happening in memory.  This same problem applies to more rare
> case
> > of regular methods which can be proven to execute in a single thread but
> > don't use synchronization before multiple threads start accessing the
> shared
> > data.
> >
> > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> > Oracle PSR Engineering | Server Technology
> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >
> > Ruslan Cheremin writes:
> >
> > For me it is confusing: java has only one way to have really immutable
> > object, and this way also gives you a total thread safety even for
> > data race based publication. But then docs refer object as "immutable
> > and thread-safe" -- we still can't assume it to be really thread-safe?
> >
> > It is better/simpler to isolate the notion of thread-safety and safe
> > publication. Thread-safety comes into play after you have safely shared
> an
> > object. The means by which you safely share an object is orthogonal to
> how
> > the object itself is made thread-safe.
> >
> > The means by which an object is shared has to involve shared mutable
> state,
> > and use of shared mutable state always needs some form of synchronization
> > (either implicit eg due to static initialization; or explicit by using
> > volatile or synchronized getter/setter methods).
> >
> > David
> > -----
> >
> > It's a pity, especially because true immutability gives us some
> > chances of performance optimization. As in this case -- we do not
> > really need .path to be volatile here, if we would assume Path to be
> > truly immutable. volatility here required only for ensuring safe
> > publishing.
> >
> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >
> > Ruslan Cheremin writes:>
> >
> > But is there a way to define "safe for data race publishing"? I as
> > far, as I remember, "immutable and thread-safe" is standard mantra in
> > JDK javadocs for totally safe objects. j.l.String has same mantra --
> > and it is safe for any way of publishing. Does you mean, I should
> > explicitly add "safe even for publishing via data race" in docs? But I
> > can't remember any such phrase in JDK docs.
> >
> > I don't recall anything in the JDK docs that mention being
> >
> > "totally safe"
> >
> > regardless of publication mechanism. Some classes, eg String, have been
> > defined such that they do have that property (for security reasons). In
> > general neither "thread-safe" nor "immutable" imply
> > safe-for-unsynchronized-publication.
> >
> > Java Concurrency In Practice (jcip.net) does define additional potential
> > annotations, where @Immutable would indeed capture the requirement of
> > safe-for-unsynchronized-publication.
> >
> > David
> > -----
> >
> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >
> > Ruslan Cheremin writes:
> >
> > Well, Path javadoc explicitly says "immutable and safe for
> > multithreaded use". Although it is not strictly defined in java what
> > exactly means "safe for multithreaded use" -- does it mean safe for
> > publishing via data race, among others? -- I suppose, it
> >
> > should be. Am
> >
> > I wrong here?
> >
> > "safe for multi-threaded use" does not generally imply that it
> >
> > is safe to
> >
> > publish instances without synchronization of some form.
> >
> > David
> > -----
> >
> > From other side, File.toPath javadoc explicitly says what "returned
> > instance must be the same for every invocation", so sync block is
> > required here for mutual exclusion on initialization phase. Without
> > this requirement it is also safe to live without sync block, afaik.
> >
> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >
> > Ruslan Cheremin writes:
> >
> > First of all, Path is immutable, so DCL is safe here even without
> > volatile. Volatile here is not required from my point of view.
> >
> > Without the volatile the Path implementation (Path is an
> >
> > interface) must be
> >
> > such that an instance of Path can be safely published without
> >
> > any additional
> >
> > forms of synchronization. Immutability does not in itself
> >
> > ensure that. You
> >
> > would have to examine the actual implementation class.
> >
> > David Holmes
> > ------------
> >
> >
> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >
> > Hi Richard,
> >
> > The variable "filePath" is volatile, so the double-checked
> >
> > locking is correct in this case. It would have been a bug
> >
> > prior to Java 5.
> >
> > Best regards,
> >
> > Dmitry Vyazelenko
> >
> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >
> > <richard.warburton at gmail.com> wrote:
> >
> > Hello,
> >
> > The current implementation of java.io.File::toPath [0]
> >
> > appears to be
> >
> > using the double checked locking pattern:
> >
> >     public Path toPath() {
> >         Path result = filePath;
> >         if (result == null) {
> >             synchronized (this) {
> >                 result = filePath;
> >                 if (result == null) {
> >                     result =
> >
> > FileSystems.getDefault().getPath(path);
> >
> >                     filePath = result;
> >                 }
> >             }
> >         }
> >         return result;
> >     }
> >
> > I was going to report the bug, but I'm a little
> >
> > uncertain of the
> >
> > interaction between the local variable 'result' and DCL
> >
> > since I've
> >
> > previously only seen the checking condition on the
> >
> > shared field
> >
> > itself.  Can someone here either confirm that its a bug or
> >
> > explain how
> >
> > the 'result' variable is fixing things?
> >
> > regards,
> >
> >  Richard
> >
> > [0] See the end of
> >
> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >
> > ses/java/io/File.java
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/2753b274/attachment-0001.html>

From zhong.j.yu at gmail.com  Tue Aug 14 15:47:11 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Tue, 14 Aug 2012 14:47:11 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
Message-ID: <CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>

Are `final` fields a problem to compiler optimization?

You can't have both ways.

Either `final` field semantics is good and cheap, therefore it should
be extended to all fields.

Or there is some downsides with 'final' field semantics, so we
shouldn't encourage people to apply `final` whenever they can. Lets
hear those downsides.

Zhong Yu

On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> This is only an issue when publishing unsafely.  Allowing treating
> constructors as regular methods is a good thing as it gives the compiler a
> chance to optimize code, which everyone likes and benefits from.
>
> Sent from my phone
>
> On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>
>> From a user's point of view, shouldn't constructors be special though?
>> An object shouldn't be considered in existence until its construction
>> is done; it is pathological that some outsider can observe a partially
>> constructed object. Life is simpler if we can eliminate that
>> possibility (unless `this` is leaked inside constructor)
>>
>> Zhong Yu
>>
>> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
>> <nathan.reynolds at oracle.com> wrote:
>> > We seem to be splitting two notions (i.e thread-safe and safe
>> > publication)
>> > when they should be combined in a sense.  Typically, when we say
>> > thread-safe
>> > we talk about the operations performed on the object after it was
>> > constructed (and its contents are globally visible).  However, we need
>> > to
>> > consider that executing the constructor is modifying the state of the
>> > object.  It requires the same mechanisms that the rest of the class uses
>> > to
>> > ensure thread-safety.  Even though, there is only 1 thread executing the
>> > constructor, a proper releasing of a lock or some other happens-before
>> > construct is required to ensure that the memory updates by the thread
>> > are
>> > made globally visible before the object is accessed by another thread.
>> > This
>> > is what we are calling safe publication.  So, safe publication is a
>> > subset
>> > of thread-safety except it is limited to what happens after the
>> > constructor
>> > is called and before the object is used by multiple threads.
>> >
>> > A beautifully-written class can be thread-safe with respect to calling
>> > its
>> > member methods but not thread-safe with respect to calling its
>> > constructor.
>> > It is this latter case that many stumble upon because they think that
>> > constructors are inherently thread-safe because they are executed
>> > single-threadedly.  What they fail to realize is that the execution of a
>> > constructor can overlap with the execution of other code from the view
>> > point
>> > of what is happening in memory.  This same problem applies to more rare
>> > case
>> > of regular methods which can be proven to execute in a single thread but
>> > don't use synchronization before multiple threads start accessing the
>> > shared
>> > data.
>> >
>> > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
>> > Oracle PSR Engineering | Server Technology
>> > On 8/13/2012 4:08 PM, David Holmes wrote:
>> >
>> > Ruslan Cheremin writes:
>> >
>> > For me it is confusing: java has only one way to have really immutable
>> > object, and this way also gives you a total thread safety even for
>> > data race based publication. But then docs refer object as "immutable
>> > and thread-safe" -- we still can't assume it to be really thread-safe?
>> >
>> > It is better/simpler to isolate the notion of thread-safety and safe
>> > publication. Thread-safety comes into play after you have safely shared
>> > an
>> > object. The means by which you safely share an object is orthogonal to
>> > how
>> > the object itself is made thread-safe.
>> >
>> > The means by which an object is shared has to involve shared mutable
>> > state,
>> > and use of shared mutable state always needs some form of
>> > synchronization
>> > (either implicit eg due to static initialization; or explicit by using
>> > volatile or synchronized getter/setter methods).
>> >
>> > David
>> > -----
>> >
>> > It's a pity, especially because true immutability gives us some
>> > chances of performance optimization. As in this case -- we do not
>> > really need .path to be volatile here, if we would assume Path to be
>> > truly immutable. volatility here required only for ensuring safe
>> > publishing.
>> >
>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >
>> > Ruslan Cheremin writes:>
>> >
>> > But is there a way to define "safe for data race publishing"? I as
>> > far, as I remember, "immutable and thread-safe" is standard mantra in
>> > JDK javadocs for totally safe objects. j.l.String has same mantra --
>> > and it is safe for any way of publishing. Does you mean, I should
>> > explicitly add "safe even for publishing via data race" in docs? But I
>> > can't remember any such phrase in JDK docs.
>> >
>> > I don't recall anything in the JDK docs that mention being
>> >
>> > "totally safe"
>> >
>> > regardless of publication mechanism. Some classes, eg String, have been
>> > defined such that they do have that property (for security reasons). In
>> > general neither "thread-safe" nor "immutable" imply
>> > safe-for-unsynchronized-publication.
>> >
>> > Java Concurrency In Practice (jcip.net) does define additional potential
>> > annotations, where @Immutable would indeed capture the requirement of
>> > safe-for-unsynchronized-publication.
>> >
>> > David
>> > -----
>> >
>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >
>> > Ruslan Cheremin writes:
>> >
>> > Well, Path javadoc explicitly says "immutable and safe for
>> > multithreaded use". Although it is not strictly defined in java what
>> > exactly means "safe for multithreaded use" -- does it mean safe for
>> > publishing via data race, among others? -- I suppose, it
>> >
>> > should be. Am
>> >
>> > I wrong here?
>> >
>> > "safe for multi-threaded use" does not generally imply that it
>> >
>> > is safe to
>> >
>> > publish instances without synchronization of some form.
>> >
>> > David
>> > -----
>> >
>> > From other side, File.toPath javadoc explicitly says what "returned
>> > instance must be the same for every invocation", so sync block is
>> > required here for mutual exclusion on initialization phase. Without
>> > this requirement it is also safe to live without sync block, afaik.
>> >
>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >
>> > Ruslan Cheremin writes:
>> >
>> > First of all, Path is immutable, so DCL is safe here even without
>> > volatile. Volatile here is not required from my point of view.
>> >
>> > Without the volatile the Path implementation (Path is an
>> >
>> > interface) must be
>> >
>> > such that an instance of Path can be safely published without
>> >
>> > any additional
>> >
>> > forms of synchronization. Immutability does not in itself
>> >
>> > ensure that. You
>> >
>> > would have to examine the actual implementation class.
>> >
>> > David Holmes
>> > ------------
>> >
>> >
>> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >
>> > Hi Richard,
>> >
>> > The variable "filePath" is volatile, so the double-checked
>> >
>> > locking is correct in this case. It would have been a bug
>> >
>> > prior to Java 5.
>> >
>> > Best regards,
>> >
>> > Dmitry Vyazelenko
>> >
>> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >
>> > <richard.warburton at gmail.com> wrote:
>> >
>> > Hello,
>> >
>> > The current implementation of java.io.File::toPath [0]
>> >
>> > appears to be
>> >
>> > using the double checked locking pattern:
>> >
>> >     public Path toPath() {
>> >         Path result = filePath;
>> >         if (result == null) {
>> >             synchronized (this) {
>> >                 result = filePath;
>> >                 if (result == null) {
>> >                     result =
>> >
>> > FileSystems.getDefault().getPath(path);
>> >
>> >                     filePath = result;
>> >                 }
>> >             }
>> >         }
>> >         return result;
>> >     }
>> >
>> > I was going to report the bug, but I'm a little
>> >
>> > uncertain of the
>> >
>> > interaction between the local variable 'result' and DCL
>> >
>> > since I've
>> >
>> > previously only seen the checking condition on the
>> >
>> > shared field
>> >
>> > itself.  Can someone here either confirm that its a bug or
>> >
>> > explain how
>> >
>> > the 'result' variable is fixing things?
>> >
>> > regards,
>> >
>> >  Richard
>> >
>> > [0] See the end of
>> >
>> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >
>> > ses/java/io/File.java
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From vitalyd at gmail.com  Tue Aug 14 15:47:31 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 14 Aug 2012 15:47:31 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqGM4Be-pcN2ypHqigKhVtAO=u1qP+b=Q0Zm5ziqqO6Xyw@mail.gmail.com>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
	<CACuKZqGM4Be-pcN2ypHqigKhVtAO=u1qP+b=Q0Zm5ziqqO6Xyw@mail.gmail.com>
Message-ID: <CAHjP37Hxjthco=_Rc4Ly-2MFV6JRuNhsamknU3Xv=FHn4KywjQ@mail.gmail.com>

The MS CLR treats ordinary stores like that (implicit StoreStore barrier)
but then they don't support the same number of architectures as the jvm, so
they can get away with it without any complaining that it's hampering
performance on their platform. :)

Sent from my phone
On Aug 14, 2012 3:27 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:

> Many java users do use the term "immutable" to mean "thread-safe
> immutable" (the 2nd term is from JLS7 section 17.5).
>
> If we strengthen JMM just a little bit, by extending the memory
> semantics of final fields to all fields, then there won't be this kind
> of confusions - as long as an object is unmodified after construction,
> it is thread-safe immutable, and all of its publications are safe
> publications.
>
> The only objection (from David Holmes) was that the final field
> semantics could be expensive on some platforms. But final fields have
> always been promoted without mentioning any downsides, therefore that
> argument probably doesn't have many sympathizers.
>
> Zhong Yu
>
> On Mon, Aug 13, 2012 at 2:51 PM, Yuval Shavit <yshavit at akiban.com> wrote:
> > This class is immutable but not thread-safe absent safe publication:
> >
> > public class MyImmutable {
> >     private long val; // not marked final or volatile
> >     public MyImmutable(long val) {
> >         this.val = val;
> >     }
> >
> >     public int getValue() {
> >         return val;
> >     }
> > }
> >
> > In the absence of safe publication, a thread is allowed to see:
> >
> >     - val's default value (0)
> >     - the value passed to the constructor
> >     - a word tear in which val contains only the high or low word from
> the
> > value passed to the constructor
> >
> >
> > On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin <cheremin at gmail.com>
> wrote:
> >>
> >> For me it is confusing: java has only one way to have really immutable
> >> object, and this way also gives you a total thread safety even for
> >> data race based publication. But then docs refer object as "immutable
> >> and thread-safe" -- we still can't assume it to be really thread-safe?
> >>
> >> It's a pity, especially because true immutability gives us some
> >> chances of performance optimization. As in this case -- we do not
> >> really need .path to be volatile here, if we would assume Path to be
> >> truly immutable. volatility here required only for ensuring safe
> >> publishing.
> >>
> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> > Ruslan Cheremin writes:>
> >> >> But is there a way to define "safe for data race publishing"? I as
> >> >> far, as I remember, "immutable and thread-safe" is standard mantra in
> >> >> JDK javadocs for totally safe objects. j.l.String has same mantra --
> >> >> and it is safe for any way of publishing. Does you mean, I should
> >> >> explicitly add "safe even for publishing via data race" in docs? But
> I
> >> >> can't remember any such phrase in JDK docs.
> >> >
> >> > I don't recall anything in the JDK docs that mention being "totally
> >> > safe"
> >> > regardless of publication mechanism. Some classes, eg String, have
> been
> >> > defined such that they do have that property (for security reasons).
> In
> >> > general neither "thread-safe" nor "immutable" imply
> >> > safe-for-unsynchronized-publication.
> >> >
> >> > Java Concurrency In Practice (jcip.net) does define additional
> potential
> >> > annotations, where @Immutable would indeed capture the requirement of
> >> > safe-for-unsynchronized-publication.
> >> >
> >> > David
> >> > -----
> >> >
> >> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> > Ruslan Cheremin writes:
> >> >> >> Well, Path javadoc explicitly says "immutable and safe for
> >> >> >> multithreaded use". Although it is not strictly defined in java
> what
> >> >> >> exactly means "safe for multithreaded use" -- does it mean safe
> for
> >> >> >> publishing via data race, among others? -- I suppose, it should
> be.
> >> >> >> Am
> >> >> >> I wrong here?
> >> >> >
> >> >> > "safe for multi-threaded use" does not generally imply that it
> >> >> is safe to
> >> >> > publish instances without synchronization of some form.
> >> >> >
> >> >> > David
> >> >> > -----
> >> >> >
> >> >> >> From other side, File.toPath javadoc explicitly says what
> "returned
> >> >> >> instance must be the same for every invocation", so sync block is
> >> >> >> required here for mutual exclusion on initialization phase.
> Without
> >> >> >> this requirement it is also safe to live without sync block,
> afaik.
> >> >> >>
> >> >> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >>
> >> >> >> >> First of all, Path is immutable, so DCL is safe here even
> without
> >> >> >> >> volatile. Volatile here is not required from my point of view.
> >> >> >> >
> >> >> >> > Without the volatile the Path implementation (Path is an
> >> >> >> interface) must be
> >> >> >> > such that an instance of Path can be safely published without
> >> >> >> any additional
> >> >> >> > forms of synchronization. Immutability does not in itself
> >> >> >> ensure that. You
> >> >> >> > would have to examine the actual implementation class.
> >> >> >> >
> >> >> >> > David Holmes
> >> >> >> > ------------
> >> >> >> >
> >> >> >> >>
> >> >> >> >>
> >> >> >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >> >> > Hi Richard,
> >> >> >> >> >
> >> >> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> >> >> locking is correct in this case. It would have been a bug
> >> >> >> prior to Java 5.
> >> >> >> >> >
> >> >> >> >> > Best regards,
> >> >> >> >> >
> >> >> >> >> > Dmitry Vyazelenko
> >> >> >> >> >
> >> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >> >> <richard.warburton at gmail.com> wrote:
> >> >> >> >> >
> >> >> >> >> >> Hello,
> >> >> >> >> >>
> >> >> >> >> >> The current implementation of java.io.File::toPath [0]
> >> >> appears to be
> >> >> >> >> >> using the double checked locking pattern:
> >> >> >> >> >>
> >> >> >> >> >>     public Path toPath() {
> >> >> >> >> >>         Path result = filePath;
> >> >> >> >> >>         if (result == null) {
> >> >> >> >> >>             synchronized (this) {
> >> >> >> >> >>                 result = filePath;
> >> >> >> >> >>                 if (result == null) {
> >> >> >> >> >>                     result =
> >> >> FileSystems.getDefault().getPath(path);
> >> >> >> >> >>                     filePath = result;
> >> >> >> >> >>                 }
> >> >> >> >> >>             }
> >> >> >> >> >>         }
> >> >> >> >> >>         return result;
> >> >> >> >> >>     }
> >> >> >> >> >>
> >> >> >> >> >> I was going to report the bug, but I'm a little uncertain of
> >> >> >> >> >> the
> >> >> >> >> >> interaction between the local variable 'result' and DCL
> >> >> since I've
> >> >> >> >> >> previously only seen the checking condition on the shared
> >> >> >> >> >> field
> >> >> >> >> >> itself.  Can someone here either confirm that its a bug or
> >> >> >> explain how
> >> >> >> >> >> the 'result' variable is fixing things?
> >> >> >> >> >>
> >> >> >> >> >> regards,
> >> >> >> >> >>
> >> >> >> >> >>  Richard
> >> >> >> >> >>
> >> >> >> >> >> [0] See the end of
> >> >> >> >> >>
> >> >> >> >>
> >> >> >> >>
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >> >> ses/java/io/File.java
> >> >> >> >> >> _______________________________________________
> >> >> >> >> >> Concurrency-interest mailing list
> >> >> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >> >
> >> >> >> >> >
> >> >> >> >> > _______________________________________________
> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >> _______________________________________________
> >> >> >> >> Concurrency-interest mailing list
> >> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >>
> >> >> >> >
> >> >> >>
> >> >> >
> >> >>
> >> >
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/ca7ea53b/attachment-0001.html>

From vitalyd at gmail.com  Tue Aug 14 15:52:13 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 14 Aug 2012 15:52:13 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
Message-ID: <CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>

Yes, presumably on some archs with very weak memory order it could cause
some performance impact.  On TSO, it's just a compiler barrier preventing
code motion that would publish the reference before constructor completes,
but on those weak archs it could also mean a hardware fence.  Whether the
tradeoff is worth it in general or not is debatable.  You can't have it
both ways, I agree, but the jvm and JMM give you options and guidance on
how to do the "right" thing.

Sent from my phone
On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:

> Are `final` fields a problem to compiler optimization?
>
> You can't have both ways.
>
> Either `final` field semantics is good and cheap, therefore it should
> be extended to all fields.
>
> Or there is some downsides with 'final' field semantics, so we
> shouldn't encourage people to apply `final` whenever they can. Lets
> hear those downsides.
>
> Zhong Yu
>
> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
> > This is only an issue when publishing unsafely.  Allowing treating
> > constructors as regular methods is a good thing as it gives the compiler
> a
> > chance to optimize code, which everyone likes and benefits from.
> >
> > Sent from my phone
> >
> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >>
> >> From a user's point of view, shouldn't constructors be special though?
> >> An object shouldn't be considered in existence until its construction
> >> is done; it is pathological that some outsider can observe a partially
> >> constructed object. Life is simpler if we can eliminate that
> >> possibility (unless `this` is leaked inside constructor)
> >>
> >> Zhong Yu
> >>
> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
> >> <nathan.reynolds at oracle.com> wrote:
> >> > We seem to be splitting two notions (i.e thread-safe and safe
> >> > publication)
> >> > when they should be combined in a sense.  Typically, when we say
> >> > thread-safe
> >> > we talk about the operations performed on the object after it was
> >> > constructed (and its contents are globally visible).  However, we need
> >> > to
> >> > consider that executing the constructor is modifying the state of the
> >> > object.  It requires the same mechanisms that the rest of the class
> uses
> >> > to
> >> > ensure thread-safety.  Even though, there is only 1 thread executing
> the
> >> > constructor, a proper releasing of a lock or some other happens-before
> >> > construct is required to ensure that the memory updates by the thread
> >> > are
> >> > made globally visible before the object is accessed by another thread.
> >> > This
> >> > is what we are calling safe publication.  So, safe publication is a
> >> > subset
> >> > of thread-safety except it is limited to what happens after the
> >> > constructor
> >> > is called and before the object is used by multiple threads.
> >> >
> >> > A beautifully-written class can be thread-safe with respect to calling
> >> > its
> >> > member methods but not thread-safe with respect to calling its
> >> > constructor.
> >> > It is this latter case that many stumble upon because they think that
> >> > constructors are inherently thread-safe because they are executed
> >> > single-threadedly.  What they fail to realize is that the execution
> of a
> >> > constructor can overlap with the execution of other code from the view
> >> > point
> >> > of what is happening in memory.  This same problem applies to more
> rare
> >> > case
> >> > of regular methods which can be proven to execute in a single thread
> but
> >> > don't use synchronization before multiple threads start accessing the
> >> > shared
> >> > data.
> >> >
> >> > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> >> > Oracle PSR Engineering | Server Technology
> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >> >
> >> > Ruslan Cheremin writes:
> >> >
> >> > For me it is confusing: java has only one way to have really immutable
> >> > object, and this way also gives you a total thread safety even for
> >> > data race based publication. But then docs refer object as "immutable
> >> > and thread-safe" -- we still can't assume it to be really thread-safe?
> >> >
> >> > It is better/simpler to isolate the notion of thread-safety and safe
> >> > publication. Thread-safety comes into play after you have safely
> shared
> >> > an
> >> > object. The means by which you safely share an object is orthogonal to
> >> > how
> >> > the object itself is made thread-safe.
> >> >
> >> > The means by which an object is shared has to involve shared mutable
> >> > state,
> >> > and use of shared mutable state always needs some form of
> >> > synchronization
> >> > (either implicit eg due to static initialization; or explicit by using
> >> > volatile or synchronized getter/setter methods).
> >> >
> >> > David
> >> > -----
> >> >
> >> > It's a pity, especially because true immutability gives us some
> >> > chances of performance optimization. As in this case -- we do not
> >> > really need .path to be volatile here, if we would assume Path to be
> >> > truly immutable. volatility here required only for ensuring safe
> >> > publishing.
> >> >
> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >
> >> > Ruslan Cheremin writes:>
> >> >
> >> > But is there a way to define "safe for data race publishing"? I as
> >> > far, as I remember, "immutable and thread-safe" is standard mantra in
> >> > JDK javadocs for totally safe objects. j.l.String has same mantra --
> >> > and it is safe for any way of publishing. Does you mean, I should
> >> > explicitly add "safe even for publishing via data race" in docs? But I
> >> > can't remember any such phrase in JDK docs.
> >> >
> >> > I don't recall anything in the JDK docs that mention being
> >> >
> >> > "totally safe"
> >> >
> >> > regardless of publication mechanism. Some classes, eg String, have
> been
> >> > defined such that they do have that property (for security reasons).
> In
> >> > general neither "thread-safe" nor "immutable" imply
> >> > safe-for-unsynchronized-publication.
> >> >
> >> > Java Concurrency In Practice (jcip.net) does define additional
> potential
> >> > annotations, where @Immutable would indeed capture the requirement of
> >> > safe-for-unsynchronized-publication.
> >> >
> >> > David
> >> > -----
> >> >
> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >
> >> > Ruslan Cheremin writes:
> >> >
> >> > Well, Path javadoc explicitly says "immutable and safe for
> >> > multithreaded use". Although it is not strictly defined in java what
> >> > exactly means "safe for multithreaded use" -- does it mean safe for
> >> > publishing via data race, among others? -- I suppose, it
> >> >
> >> > should be. Am
> >> >
> >> > I wrong here?
> >> >
> >> > "safe for multi-threaded use" does not generally imply that it
> >> >
> >> > is safe to
> >> >
> >> > publish instances without synchronization of some form.
> >> >
> >> > David
> >> > -----
> >> >
> >> > From other side, File.toPath javadoc explicitly says what "returned
> >> > instance must be the same for every invocation", so sync block is
> >> > required here for mutual exclusion on initialization phase. Without
> >> > this requirement it is also safe to live without sync block, afaik.
> >> >
> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >
> >> > Ruslan Cheremin writes:
> >> >
> >> > First of all, Path is immutable, so DCL is safe here even without
> >> > volatile. Volatile here is not required from my point of view.
> >> >
> >> > Without the volatile the Path implementation (Path is an
> >> >
> >> > interface) must be
> >> >
> >> > such that an instance of Path can be safely published without
> >> >
> >> > any additional
> >> >
> >> > forms of synchronization. Immutability does not in itself
> >> >
> >> > ensure that. You
> >> >
> >> > would have to examine the actual implementation class.
> >> >
> >> > David Holmes
> >> > ------------
> >> >
> >> >
> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >
> >> > Hi Richard,
> >> >
> >> > The variable "filePath" is volatile, so the double-checked
> >> >
> >> > locking is correct in this case. It would have been a bug
> >> >
> >> > prior to Java 5.
> >> >
> >> > Best regards,
> >> >
> >> > Dmitry Vyazelenko
> >> >
> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >
> >> > <richard.warburton at gmail.com> wrote:
> >> >
> >> > Hello,
> >> >
> >> > The current implementation of java.io.File::toPath [0]
> >> >
> >> > appears to be
> >> >
> >> > using the double checked locking pattern:
> >> >
> >> >     public Path toPath() {
> >> >         Path result = filePath;
> >> >         if (result == null) {
> >> >             synchronized (this) {
> >> >                 result = filePath;
> >> >                 if (result == null) {
> >> >                     result =
> >> >
> >> > FileSystems.getDefault().getPath(path);
> >> >
> >> >                     filePath = result;
> >> >                 }
> >> >             }
> >> >         }
> >> >         return result;
> >> >     }
> >> >
> >> > I was going to report the bug, but I'm a little
> >> >
> >> > uncertain of the
> >> >
> >> > interaction between the local variable 'result' and DCL
> >> >
> >> > since I've
> >> >
> >> > previously only seen the checking condition on the
> >> >
> >> > shared field
> >> >
> >> > itself.  Can someone here either confirm that its a bug or
> >> >
> >> > explain how
> >> >
> >> > the 'result' variable is fixing things?
> >> >
> >> > regards,
> >> >
> >> >  Richard
> >> >
> >> > [0] See the end of
> >> >
> >> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >
> >> > ses/java/io/File.java
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> >
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/d545c40d/attachment.html>

From zhong.j.yu at gmail.com  Tue Aug 14 15:58:44 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Tue, 14 Aug 2012 14:58:44 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
Message-ID: <CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>

On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> Yes, presumably on some archs with very weak memory order it could cause
> some performance impact.  On TSO, it's just a compiler barrier preventing
> code motion that would publish the reference before constructor completes,
> but on those weak archs it could also mean a hardware fence.  Whether the
> tradeoff is worth it in general or not is debatable.  You can't have it both
> ways, I agree, but the jvm and JMM give you options and guidance on how to
> do the "right" thing.

If I'm writing a Java library, containing a Point(x,y) class, which is
immutable (in the narrower sense), should I use final fields or not?
What's the "right" thing to do?

If the answer is platform dependent, oh well.

Zhong Yu

>
> Sent from my phone
>
> On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>
>> Are `final` fields a problem to compiler optimization?
>>
>> You can't have both ways.
>>
>> Either `final` field semantics is good and cheap, therefore it should
>> be extended to all fields.
>>
>> Or there is some downsides with 'final' field semantics, so we
>> shouldn't encourage people to apply `final` whenever they can. Lets
>> hear those downsides.
>>
>> Zhong Yu
>>
>> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>> > This is only an issue when publishing unsafely.  Allowing treating
>> > constructors as regular methods is a good thing as it gives the compiler
>> > a
>> > chance to optimize code, which everyone likes and benefits from.
>> >
>> > Sent from my phone
>> >
>> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>> >>
>> >> From a user's point of view, shouldn't constructors be special though?
>> >> An object shouldn't be considered in existence until its construction
>> >> is done; it is pathological that some outsider can observe a partially
>> >> constructed object. Life is simpler if we can eliminate that
>> >> possibility (unless `this` is leaked inside constructor)
>> >>
>> >> Zhong Yu
>> >>
>> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
>> >> <nathan.reynolds at oracle.com> wrote:
>> >> > We seem to be splitting two notions (i.e thread-safe and safe
>> >> > publication)
>> >> > when they should be combined in a sense.  Typically, when we say
>> >> > thread-safe
>> >> > we talk about the operations performed on the object after it was
>> >> > constructed (and its contents are globally visible).  However, we
>> >> > need
>> >> > to
>> >> > consider that executing the constructor is modifying the state of the
>> >> > object.  It requires the same mechanisms that the rest of the class
>> >> > uses
>> >> > to
>> >> > ensure thread-safety.  Even though, there is only 1 thread executing
>> >> > the
>> >> > constructor, a proper releasing of a lock or some other
>> >> > happens-before
>> >> > construct is required to ensure that the memory updates by the thread
>> >> > are
>> >> > made globally visible before the object is accessed by another
>> >> > thread.
>> >> > This
>> >> > is what we are calling safe publication.  So, safe publication is a
>> >> > subset
>> >> > of thread-safety except it is limited to what happens after the
>> >> > constructor
>> >> > is called and before the object is used by multiple threads.
>> >> >
>> >> > A beautifully-written class can be thread-safe with respect to
>> >> > calling
>> >> > its
>> >> > member methods but not thread-safe with respect to calling its
>> >> > constructor.
>> >> > It is this latter case that many stumble upon because they think that
>> >> > constructors are inherently thread-safe because they are executed
>> >> > single-threadedly.  What they fail to realize is that the execution
>> >> > of a
>> >> > constructor can overlap with the execution of other code from the
>> >> > view
>> >> > point
>> >> > of what is happening in memory.  This same problem applies to more
>> >> > rare
>> >> > case
>> >> > of regular methods which can be proven to execute in a single thread
>> >> > but
>> >> > don't use synchronization before multiple threads start accessing the
>> >> > shared
>> >> > data.
>> >> >
>> >> > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
>> >> > Oracle PSR Engineering | Server Technology
>> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
>> >> >
>> >> > Ruslan Cheremin writes:
>> >> >
>> >> > For me it is confusing: java has only one way to have really
>> >> > immutable
>> >> > object, and this way also gives you a total thread safety even for
>> >> > data race based publication. But then docs refer object as "immutable
>> >> > and thread-safe" -- we still can't assume it to be really
>> >> > thread-safe?
>> >> >
>> >> > It is better/simpler to isolate the notion of thread-safety and safe
>> >> > publication. Thread-safety comes into play after you have safely
>> >> > shared
>> >> > an
>> >> > object. The means by which you safely share an object is orthogonal
>> >> > to
>> >> > how
>> >> > the object itself is made thread-safe.
>> >> >
>> >> > The means by which an object is shared has to involve shared mutable
>> >> > state,
>> >> > and use of shared mutable state always needs some form of
>> >> > synchronization
>> >> > (either implicit eg due to static initialization; or explicit by
>> >> > using
>> >> > volatile or synchronized getter/setter methods).
>> >> >
>> >> > David
>> >> > -----
>> >> >
>> >> > It's a pity, especially because true immutability gives us some
>> >> > chances of performance optimization. As in this case -- we do not
>> >> > really need .path to be volatile here, if we would assume Path to be
>> >> > truly immutable. volatility here required only for ensuring safe
>> >> > publishing.
>> >> >
>> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >
>> >> > Ruslan Cheremin writes:>
>> >> >
>> >> > But is there a way to define "safe for data race publishing"? I as
>> >> > far, as I remember, "immutable and thread-safe" is standard mantra in
>> >> > JDK javadocs for totally safe objects. j.l.String has same mantra --
>> >> > and it is safe for any way of publishing. Does you mean, I should
>> >> > explicitly add "safe even for publishing via data race" in docs? But
>> >> > I
>> >> > can't remember any such phrase in JDK docs.
>> >> >
>> >> > I don't recall anything in the JDK docs that mention being
>> >> >
>> >> > "totally safe"
>> >> >
>> >> > regardless of publication mechanism. Some classes, eg String, have
>> >> > been
>> >> > defined such that they do have that property (for security reasons).
>> >> > In
>> >> > general neither "thread-safe" nor "immutable" imply
>> >> > safe-for-unsynchronized-publication.
>> >> >
>> >> > Java Concurrency In Practice (jcip.net) does define additional
>> >> > potential
>> >> > annotations, where @Immutable would indeed capture the requirement of
>> >> > safe-for-unsynchronized-publication.
>> >> >
>> >> > David
>> >> > -----
>> >> >
>> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >
>> >> > Ruslan Cheremin writes:
>> >> >
>> >> > Well, Path javadoc explicitly says "immutable and safe for
>> >> > multithreaded use". Although it is not strictly defined in java what
>> >> > exactly means "safe for multithreaded use" -- does it mean safe for
>> >> > publishing via data race, among others? -- I suppose, it
>> >> >
>> >> > should be. Am
>> >> >
>> >> > I wrong here?
>> >> >
>> >> > "safe for multi-threaded use" does not generally imply that it
>> >> >
>> >> > is safe to
>> >> >
>> >> > publish instances without synchronization of some form.
>> >> >
>> >> > David
>> >> > -----
>> >> >
>> >> > From other side, File.toPath javadoc explicitly says what "returned
>> >> > instance must be the same for every invocation", so sync block is
>> >> > required here for mutual exclusion on initialization phase. Without
>> >> > this requirement it is also safe to live without sync block, afaik.
>> >> >
>> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >
>> >> > Ruslan Cheremin writes:
>> >> >
>> >> > First of all, Path is immutable, so DCL is safe here even without
>> >> > volatile. Volatile here is not required from my point of view.
>> >> >
>> >> > Without the volatile the Path implementation (Path is an
>> >> >
>> >> > interface) must be
>> >> >
>> >> > such that an instance of Path can be safely published without
>> >> >
>> >> > any additional
>> >> >
>> >> > forms of synchronization. Immutability does not in itself
>> >> >
>> >> > ensure that. You
>> >> >
>> >> > would have to examine the actual implementation class.
>> >> >
>> >> > David Holmes
>> >> > ------------
>> >> >
>> >> >
>> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> >
>> >> > Hi Richard,
>> >> >
>> >> > The variable "filePath" is volatile, so the double-checked
>> >> >
>> >> > locking is correct in this case. It would have been a bug
>> >> >
>> >> > prior to Java 5.
>> >> >
>> >> > Best regards,
>> >> >
>> >> > Dmitry Vyazelenko
>> >> >
>> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >
>> >> > <richard.warburton at gmail.com> wrote:
>> >> >
>> >> > Hello,
>> >> >
>> >> > The current implementation of java.io.File::toPath [0]
>> >> >
>> >> > appears to be
>> >> >
>> >> > using the double checked locking pattern:
>> >> >
>> >> >     public Path toPath() {
>> >> >         Path result = filePath;
>> >> >         if (result == null) {
>> >> >             synchronized (this) {
>> >> >                 result = filePath;
>> >> >                 if (result == null) {
>> >> >                     result =
>> >> >
>> >> > FileSystems.getDefault().getPath(path);
>> >> >
>> >> >                     filePath = result;
>> >> >                 }
>> >> >             }
>> >> >         }
>> >> >         return result;
>> >> >     }
>> >> >
>> >> > I was going to report the bug, but I'm a little
>> >> >
>> >> > uncertain of the
>> >> >
>> >> > interaction between the local variable 'result' and DCL
>> >> >
>> >> > since I've
>> >> >
>> >> > previously only seen the checking condition on the
>> >> >
>> >> > shared field
>> >> >
>> >> > itself.  Can someone here either confirm that its a bug or
>> >> >
>> >> > explain how
>> >> >
>> >> > the 'result' variable is fixing things?
>> >> >
>> >> > regards,
>> >> >
>> >> >  Richard
>> >> >
>> >> > [0] See the end of
>> >> >
>> >> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> >
>> >> > ses/java/io/File.java
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> >
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From stanimir at riflexo.com  Tue Aug 14 16:03:30 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Tue, 14 Aug 2012 23:03:30 +0300
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqGM4Be-pcN2ypHqigKhVtAO=u1qP+b=Q0Zm5ziqqO6Xyw@mail.gmail.com>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>
	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>
	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
	<CACuKZqGM4Be-pcN2ypHqigKhVtAO=u1qP+b=Q0Zm5ziqqO6Xyw@mail.gmail.com>
Message-ID: <CAEJX8ord=bcfO9mZe6skF5ucnfZry3Q902RwbciKLYf3XJJ4OA@mail.gmail.com>

On Tue, Aug 14, 2012 at 10:25 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> Many java users do use the term "immutable" to mean "thread-safe
> immutable" (the 2nd term is from JLS7 section 17.5).
>
> If we strengthen JMM just a little bit, by extending the memory
> semantics of final fields to all fields, then there won't be this kind
> of confusions - as long as an object is unmodified after construction,
> it is thread-safe immutable, and all of its publications are safe
> publications.
>
>
The extra strength comes w/ a store-store fence which is not free on a
non-TSO archiectures. I'd be strongly against.
It's useful only w/ unsafe publication as well.  Alternative cases like
publication via lazySet is an option too.

The only objection (from David Holmes) was that the final field
> semantics could be expensive on some platforms. But final fields have
> always been promoted without mentioning any downsides, therefore that
> argument probably doesn't have many sympathizers.
>
First, it doesn't matter on x86 and Sparc-TSO, so many people are not even
concerned and if you try to squeeze each bit of performace, esp when
non-concurrent code is involved dumping the final fields is a common wisdom
if you consult the generated assembler. Imagine spotting memory fences when
no concurrent code is involved...



Stanimir


> On Mon, Aug 13, 2012 at 2:51 PM, Yuval Shavit <yshavit at akiban.com> wrote:
> > This class is immutable but not thread-safe absent safe publication:
> >
> > public class MyImmutable {
> >     private long val; // not marked final or volatile
> >     public MyImmutable(long val) {
> >         this.val = val;
> >     }
> >
> >     public int getValue() {
> >         return val;
> >     }
> > }
> >
> > In the absence of safe publication, a thread is allowed to see:
> >
> >     - val's default value (0)
> >     - the value passed to the constructor
> >     - a word tear in which val contains only the high or low word from
> the
> > value passed to the constructor
> >
> >
> > On Mon, Aug 13, 2012 at 3:39 PM, Ruslan Cheremin <cheremin at gmail.com>
> wrote:
> >>
> >> For me it is confusing: java has only one way to have really immutable
> >> object, and this way also gives you a total thread safety even for
> >> data race based publication. But then docs refer object as "immutable
> >> and thread-safe" -- we still can't assume it to be really thread-safe?
> >>
> >> It's a pity, especially because true immutability gives us some
> >> chances of performance optimization. As in this case -- we do not
> >> really need .path to be volatile here, if we would assume Path to be
> >> truly immutable. volatility here required only for ensuring safe
> >> publishing.
> >>
> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> > Ruslan Cheremin writes:>
> >> >> But is there a way to define "safe for data race publishing"? I as
> >> >> far, as I remember, "immutable and thread-safe" is standard mantra in
> >> >> JDK javadocs for totally safe objects. j.l.String has same mantra --
> >> >> and it is safe for any way of publishing. Does you mean, I should
> >> >> explicitly add "safe even for publishing via data race" in docs? But
> I
> >> >> can't remember any such phrase in JDK docs.
> >> >
> >> > I don't recall anything in the JDK docs that mention being "totally
> >> > safe"
> >> > regardless of publication mechanism. Some classes, eg String, have
> been
> >> > defined such that they do have that property (for security reasons).
> In
> >> > general neither "thread-safe" nor "immutable" imply
> >> > safe-for-unsynchronized-publication.
> >> >
> >> > Java Concurrency In Practice (jcip.net) does define additional
> potential
> >> > annotations, where @Immutable would indeed capture the requirement of
> >> > safe-for-unsynchronized-publication.
> >> >
> >> > David
> >> > -----
> >> >
> >> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> > Ruslan Cheremin writes:
> >> >> >> Well, Path javadoc explicitly says "immutable and safe for
> >> >> >> multithreaded use". Although it is not strictly defined in java
> what
> >> >> >> exactly means "safe for multithreaded use" -- does it mean safe
> for
> >> >> >> publishing via data race, among others? -- I suppose, it should
> be.
> >> >> >> Am
> >> >> >> I wrong here?
> >> >> >
> >> >> > "safe for multi-threaded use" does not generally imply that it
> >> >> is safe to
> >> >> > publish instances without synchronization of some form.
> >> >> >
> >> >> > David
> >> >> > -----
> >> >> >
> >> >> >> From other side, File.toPath javadoc explicitly says what
> "returned
> >> >> >> instance must be the same for every invocation", so sync block is
> >> >> >> required here for mutual exclusion on initialization phase.
> Without
> >> >> >> this requirement it is also safe to live without sync block,
> afaik.
> >> >> >>
> >> >> >> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >>
> >> >> >> >> First of all, Path is immutable, so DCL is safe here even
> without
> >> >> >> >> volatile. Volatile here is not required from my point of view.
> >> >> >> >
> >> >> >> > Without the volatile the Path implementation (Path is an
> >> >> >> interface) must be
> >> >> >> > such that an instance of Path can be safely published without
> >> >> >> any additional
> >> >> >> > forms of synchronization. Immutability does not in itself
> >> >> >> ensure that. You
> >> >> >> > would have to examine the actual implementation class.
> >> >> >> >
> >> >> >> > David Holmes
> >> >> >> > ------------
> >> >> >> >
> >> >> >> >>
> >> >> >> >>
> >> >> >> >> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >> >> > Hi Richard,
> >> >> >> >> >
> >> >> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> >> >> locking is correct in this case. It would have been a bug
> >> >> >> prior to Java 5.
> >> >> >> >> >
> >> >> >> >> > Best regards,
> >> >> >> >> >
> >> >> >> >> > Dmitry Vyazelenko
> >> >> >> >> >
> >> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >> >> <richard.warburton at gmail.com> wrote:
> >> >> >> >> >
> >> >> >> >> >> Hello,
> >> >> >> >> >>
> >> >> >> >> >> The current implementation of java.io.File::toPath [0]
> >> >> appears to be
> >> >> >> >> >> using the double checked locking pattern:
> >> >> >> >> >>
> >> >> >> >> >>     public Path toPath() {
> >> >> >> >> >>         Path result = filePath;
> >> >> >> >> >>         if (result == null) {
> >> >> >> >> >>             synchronized (this) {
> >> >> >> >> >>                 result = filePath;
> >> >> >> >> >>                 if (result == null) {
> >> >> >> >> >>                     result =
> >> >> FileSystems.getDefault().getPath(path);
> >> >> >> >> >>                     filePath = result;
> >> >> >> >> >>                 }
> >> >> >> >> >>             }
> >> >> >> >> >>         }
> >> >> >> >> >>         return result;
> >> >> >> >> >>     }
> >> >> >> >> >>
> >> >> >> >> >> I was going to report the bug, but I'm a little uncertain of
> >> >> >> >> >> the
> >> >> >> >> >> interaction between the local variable 'result' and DCL
> >> >> since I've
> >> >> >> >> >> previously only seen the checking condition on the shared
> >> >> >> >> >> field
> >> >> >> >> >> itself.  Can someone here either confirm that its a bug or
> >> >> >> explain how
> >> >> >> >> >> the 'result' variable is fixing things?
> >> >> >> >> >>
> >> >> >> >> >> regards,
> >> >> >> >> >>
> >> >> >> >> >>  Richard
> >> >> >> >> >>
> >> >> >> >> >> [0] See the end of
> >> >> >> >> >>
> >> >> >> >>
> >> >> >> >>
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >> >> ses/java/io/File.java
> >> >> >> >> >> _______________________________________________
> >> >> >> >> >> Concurrency-interest mailing list
> >> >> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >> >
> >> >> >> >> >
> >> >> >> >> > _______________________________________________
> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >> _______________________________________________
> >> >> >> >> Concurrency-interest mailing list
> >> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >>
> >> >> >> >
> >> >> >>
> >> >> >
> >> >>
> >> >
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/1adea116/attachment.html>

From dl at cs.oswego.edu  Tue Aug 14 16:07:41 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 14 Aug 2012 16:07:41 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqGM4Be-pcN2ypHqigKhVtAO=u1qP+b=Q0Zm5ziqqO6Xyw@mail.gmail.com>
References: <CAOwENiLzx1EPSpvfoZh+q8XmpkR8=wtJbyQ+jGCV5FU-bzBy3A@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCIEAMJGAA.davidcholmes@aapt.net.au>	<CAOwENiL0pyHxxiSTMm3Ln+vm5-c+C157Y7LMXCLGhXeo3C1vsw@mail.gmail.com>	<CAC2Zdp03SNG47xrv2YmoAnS_fMg9LeFvt46vH5o2Y1PDXddW8w@mail.gmail.com>
	<CACuKZqGM4Be-pcN2ypHqigKhVtAO=u1qP+b=Q0Zm5ziqqO6Xyw@mail.gmail.com>
Message-ID: <502AB00D.9060009@cs.oswego.edu>

On 08/14/12 15:25, Zhong Yu wrote:

> If we strengthen JMM just a little bit, by extending the memory
> semantics of final fields to all fields, then there won't be this kind
> of confusions - as long as an object is unmodified after construction,
> it is thread-safe immutable, and all of its publications are safe
> publications.
>
> The only objection (from David Holmes) was that the final field
> semantics could be expensive on some platforms. But final fields have
> always been promoted without mentioning any downsides, therefore that
> argument probably doesn't have many sympathizers.

Some of us are reading these posts with a huge sense of deja vu.
These issues were debated back in the early days of JSR133.
The decision about which way to go on this is still controversial.
Here's a summary off the top of my head:

The two main points for prohibiting reorderings of field assignments
with assignments using reference of the constructed objects remain:

1. It's the obvious thing that anyone who thinks about
concurrency and objects would first expect. Not doing it
leads to errors because people can't keep senseless-looking rules
in their heads all the time.

2. Instruction-level implementation is free on TSO (x86/sparc) and
the added compiler reordering constraints don't seem to detectably
hurt code (and might even improve it sometimes).

And the main two points for allowing them except in the
case of final fields (i.e., the current rules):

1. Most (but not all) of the cases where the rule would come into
play that do not entail final fields are racy/buggy anyway, so
relying on it will often lead to other errors.

2. Instruction-level implementation on some machines is very
expensive. The DEC Alpha was the killer example long ago. POWER
and ARM remain expensive. The upcoming ARMV8/ARM64 much less so.

-Doug

From vitalyd at gmail.com  Tue Aug 14 16:09:23 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 14 Aug 2012 16:09:23 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
Message-ID: <CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>

You should use final for its semantic meaning/code clarity unless you
yourself are publishing it unsafely in your library.  If users of your lib
are sharing this class, they need to provide the required
synchronization/hand off.  That's my personal view (and I always try to use
final as much as possible, but mostly for clarity/code semantics).

For people running the jvm on an arch where final is not just compiler
barrier, I agree it's a bit of a problem - really, final should not carry
both java semantic and JMM meaning, but I can see why that was done.

Sent from my phone
On Aug 14, 2012 3:58 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:

> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
> > Yes, presumably on some archs with very weak memory order it could cause
> > some performance impact.  On TSO, it's just a compiler barrier preventing
> > code motion that would publish the reference before constructor
> completes,
> > but on those weak archs it could also mean a hardware fence.  Whether the
> > tradeoff is worth it in general or not is debatable.  You can't have it
> both
> > ways, I agree, but the jvm and JMM give you options and guidance on how
> to
> > do the "right" thing.
>
> If I'm writing a Java library, containing a Point(x,y) class, which is
> immutable (in the narrower sense), should I use final fields or not?
> What's the "right" thing to do?
>
> If the answer is platform dependent, oh well.
>
> Zhong Yu
>
> >
> > Sent from my phone
> >
> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >>
> >> Are `final` fields a problem to compiler optimization?
> >>
> >> You can't have both ways.
> >>
> >> Either `final` field semantics is good and cheap, therefore it should
> >> be extended to all fields.
> >>
> >> Or there is some downsides with 'final' field semantics, so we
> >> shouldn't encourage people to apply `final` whenever they can. Lets
> >> hear those downsides.
> >>
> >> Zhong Yu
> >>
> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <vitalyd at gmail.com>
> >> wrote:
> >> > This is only an issue when publishing unsafely.  Allowing treating
> >> > constructors as regular methods is a good thing as it gives the
> compiler
> >> > a
> >> > chance to optimize code, which everyone likes and benefits from.
> >> >
> >> > Sent from my phone
> >> >
> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >> >>
> >> >> From a user's point of view, shouldn't constructors be special
> though?
> >> >> An object shouldn't be considered in existence until its construction
> >> >> is done; it is pathological that some outsider can observe a
> partially
> >> >> constructed object. Life is simpler if we can eliminate that
> >> >> possibility (unless `this` is leaked inside constructor)
> >> >>
> >> >> Zhong Yu
> >> >>
> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
> >> >> <nathan.reynolds at oracle.com> wrote:
> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
> >> >> > publication)
> >> >> > when they should be combined in a sense.  Typically, when we say
> >> >> > thread-safe
> >> >> > we talk about the operations performed on the object after it was
> >> >> > constructed (and its contents are globally visible).  However, we
> >> >> > need
> >> >> > to
> >> >> > consider that executing the constructor is modifying the state of
> the
> >> >> > object.  It requires the same mechanisms that the rest of the class
> >> >> > uses
> >> >> > to
> >> >> > ensure thread-safety.  Even though, there is only 1 thread
> executing
> >> >> > the
> >> >> > constructor, a proper releasing of a lock or some other
> >> >> > happens-before
> >> >> > construct is required to ensure that the memory updates by the
> thread
> >> >> > are
> >> >> > made globally visible before the object is accessed by another
> >> >> > thread.
> >> >> > This
> >> >> > is what we are calling safe publication.  So, safe publication is a
> >> >> > subset
> >> >> > of thread-safety except it is limited to what happens after the
> >> >> > constructor
> >> >> > is called and before the object is used by multiple threads.
> >> >> >
> >> >> > A beautifully-written class can be thread-safe with respect to
> >> >> > calling
> >> >> > its
> >> >> > member methods but not thread-safe with respect to calling its
> >> >> > constructor.
> >> >> > It is this latter case that many stumble upon because they think
> that
> >> >> > constructors are inherently thread-safe because they are executed
> >> >> > single-threadedly.  What they fail to realize is that the execution
> >> >> > of a
> >> >> > constructor can overlap with the execution of other code from the
> >> >> > view
> >> >> > point
> >> >> > of what is happening in memory.  This same problem applies to more
> >> >> > rare
> >> >> > case
> >> >> > of regular methods which can be proven to execute in a single
> thread
> >> >> > but
> >> >> > don't use synchronization before multiple threads start accessing
> the
> >> >> > shared
> >> >> > data.
> >> >> >
> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> 602.333.9091
> >> >> > Oracle PSR Engineering | Server Technology
> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >> >> >
> >> >> > Ruslan Cheremin writes:
> >> >> >
> >> >> > For me it is confusing: java has only one way to have really
> >> >> > immutable
> >> >> > object, and this way also gives you a total thread safety even for
> >> >> > data race based publication. But then docs refer object as
> "immutable
> >> >> > and thread-safe" -- we still can't assume it to be really
> >> >> > thread-safe?
> >> >> >
> >> >> > It is better/simpler to isolate the notion of thread-safety and
> safe
> >> >> > publication. Thread-safety comes into play after you have safely
> >> >> > shared
> >> >> > an
> >> >> > object. The means by which you safely share an object is orthogonal
> >> >> > to
> >> >> > how
> >> >> > the object itself is made thread-safe.
> >> >> >
> >> >> > The means by which an object is shared has to involve shared
> mutable
> >> >> > state,
> >> >> > and use of shared mutable state always needs some form of
> >> >> > synchronization
> >> >> > (either implicit eg due to static initialization; or explicit by
> >> >> > using
> >> >> > volatile or synchronized getter/setter methods).
> >> >> >
> >> >> > David
> >> >> > -----
> >> >> >
> >> >> > It's a pity, especially because true immutability gives us some
> >> >> > chances of performance optimization. As in this case -- we do not
> >> >> > really need .path to be volatile here, if we would assume Path to
> be
> >> >> > truly immutable. volatility here required only for ensuring safe
> >> >> > publishing.
> >> >> >
> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >
> >> >> > Ruslan Cheremin writes:>
> >> >> >
> >> >> > But is there a way to define "safe for data race publishing"? I as
> >> >> > far, as I remember, "immutable and thread-safe" is standard mantra
> in
> >> >> > JDK javadocs for totally safe objects. j.l.String has same mantra
> --
> >> >> > and it is safe for any way of publishing. Does you mean, I should
> >> >> > explicitly add "safe even for publishing via data race" in docs?
> But
> >> >> > I
> >> >> > can't remember any such phrase in JDK docs.
> >> >> >
> >> >> > I don't recall anything in the JDK docs that mention being
> >> >> >
> >> >> > "totally safe"
> >> >> >
> >> >> > regardless of publication mechanism. Some classes, eg String, have
> >> >> > been
> >> >> > defined such that they do have that property (for security
> reasons).
> >> >> > In
> >> >> > general neither "thread-safe" nor "immutable" imply
> >> >> > safe-for-unsynchronized-publication.
> >> >> >
> >> >> > Java Concurrency In Practice (jcip.net) does define additional
> >> >> > potential
> >> >> > annotations, where @Immutable would indeed capture the requirement
> of
> >> >> > safe-for-unsynchronized-publication.
> >> >> >
> >> >> > David
> >> >> > -----
> >> >> >
> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >
> >> >> > Ruslan Cheremin writes:
> >> >> >
> >> >> > Well, Path javadoc explicitly says "immutable and safe for
> >> >> > multithreaded use". Although it is not strictly defined in java
> what
> >> >> > exactly means "safe for multithreaded use" -- does it mean safe for
> >> >> > publishing via data race, among others? -- I suppose, it
> >> >> >
> >> >> > should be. Am
> >> >> >
> >> >> > I wrong here?
> >> >> >
> >> >> > "safe for multi-threaded use" does not generally imply that it
> >> >> >
> >> >> > is safe to
> >> >> >
> >> >> > publish instances without synchronization of some form.
> >> >> >
> >> >> > David
> >> >> > -----
> >> >> >
> >> >> > From other side, File.toPath javadoc explicitly says what "returned
> >> >> > instance must be the same for every invocation", so sync block is
> >> >> > required here for mutual exclusion on initialization phase. Without
> >> >> > this requirement it is also safe to live without sync block, afaik.
> >> >> >
> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >
> >> >> > Ruslan Cheremin writes:
> >> >> >
> >> >> > First of all, Path is immutable, so DCL is safe here even without
> >> >> > volatile. Volatile here is not required from my point of view.
> >> >> >
> >> >> > Without the volatile the Path implementation (Path is an
> >> >> >
> >> >> > interface) must be
> >> >> >
> >> >> > such that an instance of Path can be safely published without
> >> >> >
> >> >> > any additional
> >> >> >
> >> >> > forms of synchronization. Immutability does not in itself
> >> >> >
> >> >> > ensure that. You
> >> >> >
> >> >> > would have to examine the actual implementation class.
> >> >> >
> >> >> > David Holmes
> >> >> > ------------
> >> >> >
> >> >> >
> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >
> >> >> > Hi Richard,
> >> >> >
> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> >
> >> >> > locking is correct in this case. It would have been a bug
> >> >> >
> >> >> > prior to Java 5.
> >> >> >
> >> >> > Best regards,
> >> >> >
> >> >> > Dmitry Vyazelenko
> >> >> >
> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >
> >> >> > <richard.warburton at gmail.com> wrote:
> >> >> >
> >> >> > Hello,
> >> >> >
> >> >> > The current implementation of java.io.File::toPath [0]
> >> >> >
> >> >> > appears to be
> >> >> >
> >> >> > using the double checked locking pattern:
> >> >> >
> >> >> >     public Path toPath() {
> >> >> >         Path result = filePath;
> >> >> >         if (result == null) {
> >> >> >             synchronized (this) {
> >> >> >                 result = filePath;
> >> >> >                 if (result == null) {
> >> >> >                     result =
> >> >> >
> >> >> > FileSystems.getDefault().getPath(path);
> >> >> >
> >> >> >                     filePath = result;
> >> >> >                 }
> >> >> >             }
> >> >> >         }
> >> >> >         return result;
> >> >> >     }
> >> >> >
> >> >> > I was going to report the bug, but I'm a little
> >> >> >
> >> >> > uncertain of the
> >> >> >
> >> >> > interaction between the local variable 'result' and DCL
> >> >> >
> >> >> > since I've
> >> >> >
> >> >> > previously only seen the checking condition on the
> >> >> >
> >> >> > shared field
> >> >> >
> >> >> > itself.  Can someone here either confirm that its a bug or
> >> >> >
> >> >> > explain how
> >> >> >
> >> >> > the 'result' variable is fixing things?
> >> >> >
> >> >> > regards,
> >> >> >
> >> >> >  Richard
> >> >> >
> >> >> > [0] See the end of
> >> >> >
> >> >> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >
> >> >> > ses/java/io/File.java
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> >
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> _______________________________________________
> >> >> Concurrency-interest mailing list
> >> >> Concurrency-interest at cs.oswego.edu
> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/091441f3/attachment-0001.html>

From cheremin at gmail.com  Tue Aug 14 16:09:36 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Wed, 15 Aug 2012 00:09:36 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <502A9FF0.2000904@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
Message-ID: <CAOwENiJEcFKhz80eBBLypYqAhGSnhMO6dsT=Yppce+y=pW1iaA@mail.gmail.com>

Yes, Nathan, thank you for explanation -- this is exactly what I want
to emphase. Constructor is not something generally different from
ordinary method -- it just a method which gives fields initial values.
Commonly used 'thread-safety' notation usually focus on abstraction of
"atomic execution" of methods -- this abstraction is broken in
mutithreaded by default, and 'thread-safe' is the way to say the
object makes special efforts to return it back. But there is also
(usually implicitly assumed) abstraction of atomic initialization --
which is also leaks in multithreaded. And why it should have separate
notation of 'safe initialization' or 'safe publication'? From my point
of view, it just a concrete example of thread-safety.

Yes, sometimes it can be useful to have an object which is thread-safe
for use but not thread-safe for publishing. But it is special case
which should be outlined in docs (thread-safe with exceptions: ... ).
I think, generally thread-safety should mean both, the methods and
publication safety.

2012/8/14 Nathan Reynolds <nathan.reynolds at oracle.com>:
> We seem to be splitting two notions (i.e thread-safe and safe publication)
> when they should be combined in a sense.  Typically, when we say thread-safe
> we talk about the operations performed on the object after it was
> constructed (and its contents are globally visible).  However, we need to
> consider that executing the constructor is modifying the state of the
> object.  It requires the same mechanisms that the rest of the class uses to
> ensure thread-safety.  Even though, there is only 1 thread executing the
> constructor, a proper releasing of a lock or some other happens-before
> construct is required to ensure that the memory updates by the thread are
> made globally visible before the object is accessed by another thread.  This
> is what we are calling safe publication.  So, safe publication is a subset
> of thread-safety except it is limited to what happens after the constructor
> is called and before the object is used by multiple threads.
>
> A beautifully-written class can be thread-safe with respect to calling its
> member methods but not thread-safe with respect to calling its constructor.
> It is this latter case that many stumble upon because they think that
> constructors are inherently thread-safe because they are executed
> single-threadedly.  What they fail to realize is that the execution of a
> constructor can overlap with the execution of other code from the view point
> of what is happening in memory.  This same problem applies to more rare case
> of regular methods which can be proven to execute in a single thread but
> don't use synchronization before multiple threads start accessing the shared
> data.
>
> Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering | Server Technology
> On 8/13/2012 4:08 PM, David Holmes wrote:
>
> Ruslan Cheremin writes:
>
> For me it is confusing: java has only one way to have really immutable
> object, and this way also gives you a total thread safety even for
> data race based publication. But then docs refer object as "immutable
> and thread-safe" -- we still can't assume it to be really thread-safe?
>
> It is better/simpler to isolate the notion of thread-safety and safe
> publication. Thread-safety comes into play after you have safely shared an
> object. The means by which you safely share an object is orthogonal to how
> the object itself is made thread-safe.
>
> The means by which an object is shared has to involve shared mutable state,
> and use of shared mutable state always needs some form of synchronization
> (either implicit eg due to static initialization; or explicit by using
> volatile or synchronized getter/setter methods).
>
> David
> -----
>
> It's a pity, especially because true immutability gives us some
> chances of performance optimization. As in this case -- we do not
> really need .path to be volatile here, if we would assume Path to be
> truly immutable. volatility here required only for ensuring safe
> publishing.
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>
> Ruslan Cheremin writes:>
>
> But is there a way to define "safe for data race publishing"? I as
> far, as I remember, "immutable and thread-safe" is standard mantra in
> JDK javadocs for totally safe objects. j.l.String has same mantra --
> and it is safe for any way of publishing. Does you mean, I should
> explicitly add "safe even for publishing via data race" in docs? But I
> can't remember any such phrase in JDK docs.
>
> I don't recall anything in the JDK docs that mention being
>
> "totally safe"
>
> regardless of publication mechanism. Some classes, eg String, have been
> defined such that they do have that property (for security reasons). In
> general neither "thread-safe" nor "immutable" imply
> safe-for-unsynchronized-publication.
>
> Java Concurrency In Practice (jcip.net) does define additional potential
> annotations, where @Immutable would indeed capture the requirement of
> safe-for-unsynchronized-publication.
>
> David
> -----
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>
> Ruslan Cheremin writes:
>
> Well, Path javadoc explicitly says "immutable and safe for
> multithreaded use". Although it is not strictly defined in java what
> exactly means "safe for multithreaded use" -- does it mean safe for
> publishing via data race, among others? -- I suppose, it
>
> should be. Am
>
> I wrong here?
>
> "safe for multi-threaded use" does not generally imply that it
>
> is safe to
>
> publish instances without synchronization of some form.
>
> David
> -----
>
> From other side, File.toPath javadoc explicitly says what "returned
> instance must be the same for every invocation", so sync block is
> required here for mutual exclusion on initialization phase. Without
> this requirement it is also safe to live without sync block, afaik.
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>
> Ruslan Cheremin writes:
>
> First of all, Path is immutable, so DCL is safe here even without
> volatile. Volatile here is not required from my point of view.
>
> Without the volatile the Path implementation (Path is an
>
> interface) must be
>
> such that an instance of Path can be safely published without
>
> any additional
>
> forms of synchronization. Immutability does not in itself
>
> ensure that. You
>
> would have to examine the actual implementation class.
>
> David Holmes
> ------------
>
>
> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>
> Hi Richard,
>
> The variable "filePath" is volatile, so the double-checked
>
> locking is correct in this case. It would have been a bug
>
> prior to Java 5.
>
> Best regards,
>
> Dmitry Vyazelenko
>
> On Aug 12, 2012, at 21:35 , Richard Warburton
>
> <richard.warburton at gmail.com> wrote:
>
> Hello,
>
> The current implementation of java.io.File::toPath [0]
>
> appears to be
>
> using the double checked locking pattern:
>
>     public Path toPath() {
>         Path result = filePath;
>         if (result == null) {
>             synchronized (this) {
>                 result = filePath;
>                 if (result == null) {
>                     result =
>
> FileSystems.getDefault().getPath(path);
>
>                     filePath = result;
>                 }
>             }
>         }
>         return result;
>     }
>
> I was going to report the bug, but I'm a little
>
> uncertain of the
>
> interaction between the local variable 'result' and DCL
>
> since I've
>
> previously only seen the checking condition on the
>
> shared field
>
> itself.  Can someone here either confirm that its a bug or
>
> explain how
>
> the 'result' variable is fixing things?
>
> regards,
>
>  Richard
>
> [0] See the end of
>
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>
> ses/java/io/File.java
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From stanimir at riflexo.com  Tue Aug 14 16:12:38 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Tue, 14 Aug 2012 23:12:38 +0300
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
Message-ID: <CAEJX8ooixrfW8KVom_J2ZhDg=2e+VBZMDcY35CCMi-W=kFE52Q@mail.gmail.com>

On Tue, Aug 14, 2012 at 10:58 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
> > Yes, presumably on some archs with very weak memory order it could cause
> > some performance impact.  On TSO, it's just a compiler barrier preventing
> > code motion that would publish the reference before constructor
> completes,
> > but on those weak archs it could also mean a hardware fence.  Whether the
> > tradeoff is worth it in general or not is debatable.  You can't have it
> both
> > ways, I agree, but the jvm and JMM give you options and guidance on how
> to
> > do the "right" thing.
>
> If I'm writing a Java library, containing a Point(x,y) class, which is
> immutable (in the narrower sense), should I use final fields or not?
> What's the "right" thing to do?
>
> If you greatly care about performance and since Java doesn't have struct
alikes (yet) and you are going to have tons of Point(s), just 2
double[]/int[] to reduce the cache misses/indirections - i.e. that's
another option how to organize your code.
OTOH if you choose more OO aproach it's still up to you - you have an
option to make it look "better" w/ final fields or forgo 'em potentionally
saving store-store on PowerPC.

That reminds me the keyword 'const' is unsed and potetially can be what
"final" is for fields but w/o memory/compiler barriers.

Stanimir

> >
> > Sent from my phone
> >
> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >>
> >> Are `final` fields a problem to compiler optimization?
> >>
> >> You can't have both ways.
> >>
> >> Either `final` field semantics is good and cheap, therefore it should
> >> be extended to all fields.
> >>
> >> Or there is some downsides with 'final' field semantics, so we
> >> shouldn't encourage people to apply `final` whenever they can. Lets
> >> hear those downsides.
> >>
> >> Zhong Yu
> >>
> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <vitalyd at gmail.com>
> >> wrote:
> >> > This is only an issue when publishing unsafely.  Allowing treating
> >> > constructors as regular methods is a good thing as it gives the
> compiler
> >> > a
> >> > chance to optimize code, which everyone likes and benefits from.
> >> >
> >> > Sent from my phone
> >> >
> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >> >>
> >> >> From a user's point of view, shouldn't constructors be special
> though?
> >> >> An object shouldn't be considered in existence until its construction
> >> >> is done; it is pathological that some outsider can observe a
> partially
> >> >> constructed object. Life is simpler if we can eliminate that
> >> >> possibility (unless `this` is leaked inside constructor)
> >> >>
> >> >> Zhong Yu
> >> >>
> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
> >> >> <nathan.reynolds at oracle.com> wrote:
> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
> >> >> > publication)
> >> >> > when they should be combined in a sense.  Typically, when we say
> >> >> > thread-safe
> >> >> > we talk about the operations performed on the object after it was
> >> >> > constructed (and its contents are globally visible).  However, we
> >> >> > need
> >> >> > to
> >> >> > consider that executing the constructor is modifying the state of
> the
> >> >> > object.  It requires the same mechanisms that the rest of the class
> >> >> > uses
> >> >> > to
> >> >> > ensure thread-safety.  Even though, there is only 1 thread
> executing
> >> >> > the
> >> >> > constructor, a proper releasing of a lock or some other
> >> >> > happens-before
> >> >> > construct is required to ensure that the memory updates by the
> thread
> >> >> > are
> >> >> > made globally visible before the object is accessed by another
> >> >> > thread.
> >> >> > This
> >> >> > is what we are calling safe publication.  So, safe publication is a
> >> >> > subset
> >> >> > of thread-safety except it is limited to what happens after the
> >> >> > constructor
> >> >> > is called and before the object is used by multiple threads.
> >> >> >
> >> >> > A beautifully-written class can be thread-safe with respect to
> >> >> > calling
> >> >> > its
> >> >> > member methods but not thread-safe with respect to calling its
> >> >> > constructor.
> >> >> > It is this latter case that many stumble upon because they think
> that
> >> >> > constructors are inherently thread-safe because they are executed
> >> >> > single-threadedly.  What they fail to realize is that the execution
> >> >> > of a
> >> >> > constructor can overlap with the execution of other code from the
> >> >> > view
> >> >> > point
> >> >> > of what is happening in memory.  This same problem applies to more
> >> >> > rare
> >> >> > case
> >> >> > of regular methods which can be proven to execute in a single
> thread
> >> >> > but
> >> >> > don't use synchronization before multiple threads start accessing
> the
> >> >> > shared
> >> >> > data.
> >> >> >
> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> 602.333.9091
> >> >> > Oracle PSR Engineering | Server Technology
> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >> >> >
> >> >> > Ruslan Cheremin writes:
> >> >> >
> >> >> > For me it is confusing: java has only one way to have really
> >> >> > immutable
> >> >> > object, and this way also gives you a total thread safety even for
> >> >> > data race based publication. But then docs refer object as
> "immutable
> >> >> > and thread-safe" -- we still can't assume it to be really
> >> >> > thread-safe?
> >> >> >
> >> >> > It is better/simpler to isolate the notion of thread-safety and
> safe
> >> >> > publication. Thread-safety comes into play after you have safely
> >> >> > shared
> >> >> > an
> >> >> > object. The means by which you safely share an object is orthogonal
> >> >> > to
> >> >> > how
> >> >> > the object itself is made thread-safe.
> >> >> >
> >> >> > The means by which an object is shared has to involve shared
> mutable
> >> >> > state,
> >> >> > and use of shared mutable state always needs some form of
> >> >> > synchronization
> >> >> > (either implicit eg due to static initialization; or explicit by
> >> >> > using
> >> >> > volatile or synchronized getter/setter methods).
> >> >> >
> >> >> > David
> >> >> > -----
> >> >> >
> >> >> > It's a pity, especially because true immutability gives us some
> >> >> > chances of performance optimization. As in this case -- we do not
> >> >> > really need .path to be volatile here, if we would assume Path to
> be
> >> >> > truly immutable. volatility here required only for ensuring safe
> >> >> > publishing.
> >> >> >
> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >
> >> >> > Ruslan Cheremin writes:>
> >> >> >
> >> >> > But is there a way to define "safe for data race publishing"? I as
> >> >> > far, as I remember, "immutable and thread-safe" is standard mantra
> in
> >> >> > JDK javadocs for totally safe objects. j.l.String has same mantra
> --
> >> >> > and it is safe for any way of publishing. Does you mean, I should
> >> >> > explicitly add "safe even for publishing via data race" in docs?
> But
> >> >> > I
> >> >> > can't remember any such phrase in JDK docs.
> >> >> >
> >> >> > I don't recall anything in the JDK docs that mention being
> >> >> >
> >> >> > "totally safe"
> >> >> >
> >> >> > regardless of publication mechanism. Some classes, eg String, have
> >> >> > been
> >> >> > defined such that they do have that property (for security
> reasons).
> >> >> > In
> >> >> > general neither "thread-safe" nor "immutable" imply
> >> >> > safe-for-unsynchronized-publication.
> >> >> >
> >> >> > Java Concurrency In Practice (jcip.net) does define additional
> >> >> > potential
> >> >> > annotations, where @Immutable would indeed capture the requirement
> of
> >> >> > safe-for-unsynchronized-publication.
> >> >> >
> >> >> > David
> >> >> > -----
> >> >> >
> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >
> >> >> > Ruslan Cheremin writes:
> >> >> >
> >> >> > Well, Path javadoc explicitly says "immutable and safe for
> >> >> > multithreaded use". Although it is not strictly defined in java
> what
> >> >> > exactly means "safe for multithreaded use" -- does it mean safe for
> >> >> > publishing via data race, among others? -- I suppose, it
> >> >> >
> >> >> > should be. Am
> >> >> >
> >> >> > I wrong here?
> >> >> >
> >> >> > "safe for multi-threaded use" does not generally imply that it
> >> >> >
> >> >> > is safe to
> >> >> >
> >> >> > publish instances without synchronization of some form.
> >> >> >
> >> >> > David
> >> >> > -----
> >> >> >
> >> >> > From other side, File.toPath javadoc explicitly says what "returned
> >> >> > instance must be the same for every invocation", so sync block is
> >> >> > required here for mutual exclusion on initialization phase. Without
> >> >> > this requirement it is also safe to live without sync block, afaik.
> >> >> >
> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >
> >> >> > Ruslan Cheremin writes:
> >> >> >
> >> >> > First of all, Path is immutable, so DCL is safe here even without
> >> >> > volatile. Volatile here is not required from my point of view.
> >> >> >
> >> >> > Without the volatile the Path implementation (Path is an
> >> >> >
> >> >> > interface) must be
> >> >> >
> >> >> > such that an instance of Path can be safely published without
> >> >> >
> >> >> > any additional
> >> >> >
> >> >> > forms of synchronization. Immutability does not in itself
> >> >> >
> >> >> > ensure that. You
> >> >> >
> >> >> > would have to examine the actual implementation class.
> >> >> >
> >> >> > David Holmes
> >> >> > ------------
> >> >> >
> >> >> >
> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >
> >> >> > Hi Richard,
> >> >> >
> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> >
> >> >> > locking is correct in this case. It would have been a bug
> >> >> >
> >> >> > prior to Java 5.
> >> >> >
> >> >> > Best regards,
> >> >> >
> >> >> > Dmitry Vyazelenko
> >> >> >
> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >
> >> >> > <richard.warburton at gmail.com> wrote:
> >> >> >
> >> >> > Hello,
> >> >> >
> >> >> > The current implementation of java.io.File::toPath [0]
> >> >> >
> >> >> > appears to be
> >> >> >
> >> >> > using the double checked locking pattern:
> >> >> >
> >> >> >     public Path toPath() {
> >> >> >         Path result = filePath;
> >> >> >         if (result == null) {
> >> >> >             synchronized (this) {
> >> >> >                 result = filePath;
> >> >> >                 if (result == null) {
> >> >> >                     result =
> >> >> >
> >> >> > FileSystems.getDefault().getPath(path);
> >> >> >
> >> >> >                     filePath = result;
> >> >> >                 }
> >> >> >             }
> >> >> >         }
> >> >> >         return result;
> >> >> >     }
> >> >> >
> >> >> > I was going to report the bug, but I'm a little
> >> >> >
> >> >> > uncertain of the
> >> >> >
> >> >> > interaction between the local variable 'result' and DCL
> >> >> >
> >> >> > since I've
> >> >> >
> >> >> > previously only seen the checking condition on the
> >> >> >
> >> >> > shared field
> >> >> >
> >> >> > itself.  Can someone here either confirm that its a bug or
> >> >> >
> >> >> > explain how
> >> >> >
> >> >> > the 'result' variable is fixing things?
> >> >> >
> >> >> > regards,
> >> >> >
> >> >> >  Richard
> >> >> >
> >> >> > [0] See the end of
> >> >> >
> >> >> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >
> >> >> > ses/java/io/File.java
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> >
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> _______________________________________________
> >> >> Concurrency-interest mailing list
> >> >> Concurrency-interest at cs.oswego.edu
> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/162faa94/attachment-0001.html>

From vitalyd at gmail.com  Tue Aug 14 16:24:22 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 14 Aug 2012 16:24:22 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAEJX8ooixrfW8KVom_J2ZhDg=2e+VBZMDcY35CCMi-W=kFE52Q@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAEJX8ooixrfW8KVom_J2ZhDg=2e+VBZMDcY35CCMi-W=kFE52Q@mail.gmail.com>
Message-ID: <CAHjP37GwWMHcgwAHJWpo=i7HdTydf5t43e2HQhHYivM7WNnwcg@mail.gmail.com>

Your point about "const" reminded me that I agree with Joe Duffy on his
take [1] on the fact that annotating a field as volatile or final (he talks
about volatile, but the point can be extended to final) doesn't really
belong to the field; the type of order required is determined at the point
of access, not declaration.  I think c++11 got this part quite right.

[1] http://www.bluebytesoftware.com/blog/2010/12/04/SayonaraVolatile.aspx

Sent from my phone
On Aug 14, 2012 4:12 PM, "Stanimir Simeonoff" <stanimir at riflexo.com> wrote:

>
>
> On Tue, Aug 14, 2012 at 10:58 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>
>> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>> > Yes, presumably on some archs with very weak memory order it could cause
>> > some performance impact.  On TSO, it's just a compiler barrier
>> preventing
>> > code motion that would publish the reference before constructor
>> completes,
>> > but on those weak archs it could also mean a hardware fence.  Whether
>> the
>> > tradeoff is worth it in general or not is debatable.  You can't have it
>> both
>> > ways, I agree, but the jvm and JMM give you options and guidance on how
>> to
>> > do the "right" thing.
>>
>> If I'm writing a Java library, containing a Point(x,y) class, which is
>> immutable (in the narrower sense), should I use final fields or not?
>> What's the "right" thing to do?
>>
>> If you greatly care about performance and since Java doesn't have struct
> alikes (yet) and you are going to have tons of Point(s), just 2
> double[]/int[] to reduce the cache misses/indirections - i.e. that's
> another option how to organize your code.
> OTOH if you choose more OO aproach it's still up to you - you have an
> option to make it look "better" w/ final fields or forgo 'em potentionally
> saving store-store on PowerPC.
>
> That reminds me the keyword 'const' is unsed and potetially can be what
> "final" is for fields but w/o memory/compiler barriers.
>
> Stanimir
>
>> >
>> > Sent from my phone
>> >
>> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>> >>
>> >> Are `final` fields a problem to compiler optimization?
>> >>
>> >> You can't have both ways.
>> >>
>> >> Either `final` field semantics is good and cheap, therefore it should
>> >> be extended to all fields.
>> >>
>> >> Or there is some downsides with 'final' field semantics, so we
>> >> shouldn't encourage people to apply `final` whenever they can. Lets
>> >> hear those downsides.
>> >>
>> >> Zhong Yu
>> >>
>> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> >> wrote:
>> >> > This is only an issue when publishing unsafely.  Allowing treating
>> >> > constructors as regular methods is a good thing as it gives the
>> compiler
>> >> > a
>> >> > chance to optimize code, which everyone likes and benefits from.
>> >> >
>> >> > Sent from my phone
>> >> >
>> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>> >> >>
>> >> >> From a user's point of view, shouldn't constructors be special
>> though?
>> >> >> An object shouldn't be considered in existence until its
>> construction
>> >> >> is done; it is pathological that some outsider can observe a
>> partially
>> >> >> constructed object. Life is simpler if we can eliminate that
>> >> >> possibility (unless `this` is leaked inside constructor)
>> >> >>
>> >> >> Zhong Yu
>> >> >>
>> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
>> >> >> <nathan.reynolds at oracle.com> wrote:
>> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
>> >> >> > publication)
>> >> >> > when they should be combined in a sense.  Typically, when we say
>> >> >> > thread-safe
>> >> >> > we talk about the operations performed on the object after it was
>> >> >> > constructed (and its contents are globally visible).  However, we
>> >> >> > need
>> >> >> > to
>> >> >> > consider that executing the constructor is modifying the state of
>> the
>> >> >> > object.  It requires the same mechanisms that the rest of the
>> class
>> >> >> > uses
>> >> >> > to
>> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>> executing
>> >> >> > the
>> >> >> > constructor, a proper releasing of a lock or some other
>> >> >> > happens-before
>> >> >> > construct is required to ensure that the memory updates by the
>> thread
>> >> >> > are
>> >> >> > made globally visible before the object is accessed by another
>> >> >> > thread.
>> >> >> > This
>> >> >> > is what we are calling safe publication.  So, safe publication is
>> a
>> >> >> > subset
>> >> >> > of thread-safety except it is limited to what happens after the
>> >> >> > constructor
>> >> >> > is called and before the object is used by multiple threads.
>> >> >> >
>> >> >> > A beautifully-written class can be thread-safe with respect to
>> >> >> > calling
>> >> >> > its
>> >> >> > member methods but not thread-safe with respect to calling its
>> >> >> > constructor.
>> >> >> > It is this latter case that many stumble upon because they think
>> that
>> >> >> > constructors are inherently thread-safe because they are executed
>> >> >> > single-threadedly.  What they fail to realize is that the
>> execution
>> >> >> > of a
>> >> >> > constructor can overlap with the execution of other code from the
>> >> >> > view
>> >> >> > point
>> >> >> > of what is happening in memory.  This same problem applies to more
>> >> >> > rare
>> >> >> > case
>> >> >> > of regular methods which can be proven to execute in a single
>> thread
>> >> >> > but
>> >> >> > don't use synchronization before multiple threads start accessing
>> the
>> >> >> > shared
>> >> >> > data.
>> >> >> >
>> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>> 602.333.9091
>> >> >> > Oracle PSR Engineering | Server Technology
>> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:
>> >> >> >
>> >> >> > For me it is confusing: java has only one way to have really
>> >> >> > immutable
>> >> >> > object, and this way also gives you a total thread safety even for
>> >> >> > data race based publication. But then docs refer object as
>> "immutable
>> >> >> > and thread-safe" -- we still can't assume it to be really
>> >> >> > thread-safe?
>> >> >> >
>> >> >> > It is better/simpler to isolate the notion of thread-safety and
>> safe
>> >> >> > publication. Thread-safety comes into play after you have safely
>> >> >> > shared
>> >> >> > an
>> >> >> > object. The means by which you safely share an object is
>> orthogonal
>> >> >> > to
>> >> >> > how
>> >> >> > the object itself is made thread-safe.
>> >> >> >
>> >> >> > The means by which an object is shared has to involve shared
>> mutable
>> >> >> > state,
>> >> >> > and use of shared mutable state always needs some form of
>> >> >> > synchronization
>> >> >> > (either implicit eg due to static initialization; or explicit by
>> >> >> > using
>> >> >> > volatile or synchronized getter/setter methods).
>> >> >> >
>> >> >> > David
>> >> >> > -----
>> >> >> >
>> >> >> > It's a pity, especially because true immutability gives us some
>> >> >> > chances of performance optimization. As in this case -- we do not
>> >> >> > really need .path to be volatile here, if we would assume Path to
>> be
>> >> >> > truly immutable. volatility here required only for ensuring safe
>> >> >> > publishing.
>> >> >> >
>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:>
>> >> >> >
>> >> >> > But is there a way to define "safe for data race publishing"? I as
>> >> >> > far, as I remember, "immutable and thread-safe" is standard
>> mantra in
>> >> >> > JDK javadocs for totally safe objects. j.l.String has same mantra
>> --
>> >> >> > and it is safe for any way of publishing. Does you mean, I should
>> >> >> > explicitly add "safe even for publishing via data race" in docs?
>> But
>> >> >> > I
>> >> >> > can't remember any such phrase in JDK docs.
>> >> >> >
>> >> >> > I don't recall anything in the JDK docs that mention being
>> >> >> >
>> >> >> > "totally safe"
>> >> >> >
>> >> >> > regardless of publication mechanism. Some classes, eg String, have
>> >> >> > been
>> >> >> > defined such that they do have that property (for security
>> reasons).
>> >> >> > In
>> >> >> > general neither "thread-safe" nor "immutable" imply
>> >> >> > safe-for-unsynchronized-publication.
>> >> >> >
>> >> >> > Java Concurrency In Practice (jcip.net) does define additional
>> >> >> > potential
>> >> >> > annotations, where @Immutable would indeed capture the
>> requirement of
>> >> >> > safe-for-unsynchronized-publication.
>> >> >> >
>> >> >> > David
>> >> >> > -----
>> >> >> >
>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:
>> >> >> >
>> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>> >> >> > multithreaded use". Although it is not strictly defined in java
>> what
>> >> >> > exactly means "safe for multithreaded use" -- does it mean safe
>> for
>> >> >> > publishing via data race, among others? -- I suppose, it
>> >> >> >
>> >> >> > should be. Am
>> >> >> >
>> >> >> > I wrong here?
>> >> >> >
>> >> >> > "safe for multi-threaded use" does not generally imply that it
>> >> >> >
>> >> >> > is safe to
>> >> >> >
>> >> >> > publish instances without synchronization of some form.
>> >> >> >
>> >> >> > David
>> >> >> > -----
>> >> >> >
>> >> >> > From other side, File.toPath javadoc explicitly says what
>> "returned
>> >> >> > instance must be the same for every invocation", so sync block is
>> >> >> > required here for mutual exclusion on initialization phase.
>> Without
>> >> >> > this requirement it is also safe to live without sync block,
>> afaik.
>> >> >> >
>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:
>> >> >> >
>> >> >> > First of all, Path is immutable, so DCL is safe here even without
>> >> >> > volatile. Volatile here is not required from my point of view.
>> >> >> >
>> >> >> > Without the volatile the Path implementation (Path is an
>> >> >> >
>> >> >> > interface) must be
>> >> >> >
>> >> >> > such that an instance of Path can be safely published without
>> >> >> >
>> >> >> > any additional
>> >> >> >
>> >> >> > forms of synchronization. Immutability does not in itself
>> >> >> >
>> >> >> > ensure that. You
>> >> >> >
>> >> >> > would have to examine the actual implementation class.
>> >> >> >
>> >> >> > David Holmes
>> >> >> > ------------
>> >> >> >
>> >> >> >
>> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> >> >
>> >> >> > Hi Richard,
>> >> >> >
>> >> >> > The variable "filePath" is volatile, so the double-checked
>> >> >> >
>> >> >> > locking is correct in this case. It would have been a bug
>> >> >> >
>> >> >> > prior to Java 5.
>> >> >> >
>> >> >> > Best regards,
>> >> >> >
>> >> >> > Dmitry Vyazelenko
>> >> >> >
>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >> >
>> >> >> > <richard.warburton at gmail.com> wrote:
>> >> >> >
>> >> >> > Hello,
>> >> >> >
>> >> >> > The current implementation of java.io.File::toPath [0]
>> >> >> >
>> >> >> > appears to be
>> >> >> >
>> >> >> > using the double checked locking pattern:
>> >> >> >
>> >> >> >     public Path toPath() {
>> >> >> >         Path result = filePath;
>> >> >> >         if (result == null) {
>> >> >> >             synchronized (this) {
>> >> >> >                 result = filePath;
>> >> >> >                 if (result == null) {
>> >> >> >                     result =
>> >> >> >
>> >> >> > FileSystems.getDefault().getPath(path);
>> >> >> >
>> >> >> >                     filePath = result;
>> >> >> >                 }
>> >> >> >             }
>> >> >> >         }
>> >> >> >         return result;
>> >> >> >     }
>> >> >> >
>> >> >> > I was going to report the bug, but I'm a little
>> >> >> >
>> >> >> > uncertain of the
>> >> >> >
>> >> >> > interaction between the local variable 'result' and DCL
>> >> >> >
>> >> >> > since I've
>> >> >> >
>> >> >> > previously only seen the checking condition on the
>> >> >> >
>> >> >> > shared field
>> >> >> >
>> >> >> > itself.  Can someone here either confirm that its a bug or
>> >> >> >
>> >> >> > explain how
>> >> >> >
>> >> >> > the 'result' variable is fixing things?
>> >> >> >
>> >> >> > regards,
>> >> >> >
>> >> >> >  Richard
>> >> >> >
>> >> >> > [0] See the end of
>> >> >> >
>> >> >> >
>> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> >> >
>> >> >> > ses/java/io/File.java
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> >
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> _______________________________________________
>> >> >> Concurrency-interest mailing list
>> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/8b97d8b1/attachment-0001.html>

From stanimir at riflexo.com  Tue Aug 14 16:31:09 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Tue, 14 Aug 2012 23:31:09 +0300
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37GwWMHcgwAHJWpo=i7HdTydf5t43e2HQhHYivM7WNnwcg@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAEJX8ooixrfW8KVom_J2ZhDg=2e+VBZMDcY35CCMi-W=kFE52Q@mail.gmail.com>
	<CAHjP37GwWMHcgwAHJWpo=i7HdTydf5t43e2HQhHYivM7WNnwcg@mail.gmail.com>
Message-ID: <CAEJX8ornkHoTTFobpi3o1_CvSH7poSv_FS9y1GOS-GbP6pyYww@mail.gmail.com>

On Tue, Aug 14, 2012 at 11:24 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:

> Your point about "const" reminded me that I agree with Joe Duffy on his
> take [1] on the fact that annotating a field as volatile or final (he talks
> about volatile, but the point can be extended to final) doesn't really
> belong to the field; the type of order required is determined at the point
> of access, not declaration.  I think c++11 got this part quite right.
>
> [1] http://www.bluebytesoftware.com/blog/2010/12/04/SayonaraVolatile.aspx
>
> Yeah, the one about the *"bastardized"* volatile :) Remember it clearly.
However it's way too late to modify Java to accommodate for. Having only
AtomicXXX built-in types, impl. via intrinsics would have been much better
as code like
volatile X x;
if (x!=null && x.foo()) x.bar();

would be significantly easier to spot during writing cycle for most of the
people.

Stanimir

Sent from my phone
> On Aug 14, 2012 4:12 PM, "Stanimir Simeonoff" <stanimir at riflexo.com>
> wrote:
>
>>
>>
>> On Tue, Aug 14, 2012 at 10:58 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>
>>> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>> wrote:
>>> > Yes, presumably on some archs with very weak memory order it could
>>> cause
>>> > some performance impact.  On TSO, it's just a compiler barrier
>>> preventing
>>> > code motion that would publish the reference before constructor
>>> completes,
>>> > but on those weak archs it could also mean a hardware fence.  Whether
>>> the
>>> > tradeoff is worth it in general or not is debatable.  You can't have
>>> it both
>>> > ways, I agree, but the jvm and JMM give you options and guidance on
>>> how to
>>> > do the "right" thing.
>>>
>>> If I'm writing a Java library, containing a Point(x,y) class, which is
>>> immutable (in the narrower sense), should I use final fields or not?
>>> What's the "right" thing to do?
>>>
>>> If you greatly care about performance and since Java doesn't have struct
>> alikes (yet) and you are going to have tons of Point(s), just 2
>> double[]/int[] to reduce the cache misses/indirections - i.e. that's
>> another option how to organize your code.
>> OTOH if you choose more OO aproach it's still up to you - you have an
>> option to make it look "better" w/ final fields or forgo 'em potentionally
>> saving store-store on PowerPC.
>>
>> That reminds me the keyword 'const' is unsed and potetially can be what
>> "final" is for fields but w/o memory/compiler barriers.
>>
>> Stanimir
>>
>>> >
>>> > Sent from my phone
>>> >
>>> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>> >>
>>> >> Are `final` fields a problem to compiler optimization?
>>> >>
>>> >> You can't have both ways.
>>> >>
>>> >> Either `final` field semantics is good and cheap, therefore it should
>>> >> be extended to all fields.
>>> >>
>>> >> Or there is some downsides with 'final' field semantics, so we
>>> >> shouldn't encourage people to apply `final` whenever they can. Lets
>>> >> hear those downsides.
>>> >>
>>> >> Zhong Yu
>>> >>
>>> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <vitalyd at gmail.com
>>> >
>>> >> wrote:
>>> >> > This is only an issue when publishing unsafely.  Allowing treating
>>> >> > constructors as regular methods is a good thing as it gives the
>>> compiler
>>> >> > a
>>> >> > chance to optimize code, which everyone likes and benefits from.
>>> >> >
>>> >> > Sent from my phone
>>> >> >
>>> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>> >> >>
>>> >> >> From a user's point of view, shouldn't constructors be special
>>> though?
>>> >> >> An object shouldn't be considered in existence until its
>>> construction
>>> >> >> is done; it is pathological that some outsider can observe a
>>> partially
>>> >> >> constructed object. Life is simpler if we can eliminate that
>>> >> >> possibility (unless `this` is leaked inside constructor)
>>> >> >>
>>> >> >> Zhong Yu
>>> >> >>
>>> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
>>> >> >> <nathan.reynolds at oracle.com> wrote:
>>> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
>>> >> >> > publication)
>>> >> >> > when they should be combined in a sense.  Typically, when we say
>>> >> >> > thread-safe
>>> >> >> > we talk about the operations performed on the object after it was
>>> >> >> > constructed (and its contents are globally visible).  However, we
>>> >> >> > need
>>> >> >> > to
>>> >> >> > consider that executing the constructor is modifying the state
>>> of the
>>> >> >> > object.  It requires the same mechanisms that the rest of the
>>> class
>>> >> >> > uses
>>> >> >> > to
>>> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>>> executing
>>> >> >> > the
>>> >> >> > constructor, a proper releasing of a lock or some other
>>> >> >> > happens-before
>>> >> >> > construct is required to ensure that the memory updates by the
>>> thread
>>> >> >> > are
>>> >> >> > made globally visible before the object is accessed by another
>>> >> >> > thread.
>>> >> >> > This
>>> >> >> > is what we are calling safe publication.  So, safe publication
>>> is a
>>> >> >> > subset
>>> >> >> > of thread-safety except it is limited to what happens after the
>>> >> >> > constructor
>>> >> >> > is called and before the object is used by multiple threads.
>>> >> >> >
>>> >> >> > A beautifully-written class can be thread-safe with respect to
>>> >> >> > calling
>>> >> >> > its
>>> >> >> > member methods but not thread-safe with respect to calling its
>>> >> >> > constructor.
>>> >> >> > It is this latter case that many stumble upon because they think
>>> that
>>> >> >> > constructors are inherently thread-safe because they are executed
>>> >> >> > single-threadedly.  What they fail to realize is that the
>>> execution
>>> >> >> > of a
>>> >> >> > constructor can overlap with the execution of other code from the
>>> >> >> > view
>>> >> >> > point
>>> >> >> > of what is happening in memory.  This same problem applies to
>>> more
>>> >> >> > rare
>>> >> >> > case
>>> >> >> > of regular methods which can be proven to execute in a single
>>> thread
>>> >> >> > but
>>> >> >> > don't use synchronization before multiple threads start
>>> accessing the
>>> >> >> > shared
>>> >> >> > data.
>>> >> >> >
>>> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>>> 602.333.9091
>>> >> >> > Oracle PSR Engineering | Server Technology
>>> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
>>> >> >> >
>>> >> >> > Ruslan Cheremin writes:
>>> >> >> >
>>> >> >> > For me it is confusing: java has only one way to have really
>>> >> >> > immutable
>>> >> >> > object, and this way also gives you a total thread safety even
>>> for
>>> >> >> > data race based publication. But then docs refer object as
>>> "immutable
>>> >> >> > and thread-safe" -- we still can't assume it to be really
>>> >> >> > thread-safe?
>>> >> >> >
>>> >> >> > It is better/simpler to isolate the notion of thread-safety and
>>> safe
>>> >> >> > publication. Thread-safety comes into play after you have safely
>>> >> >> > shared
>>> >> >> > an
>>> >> >> > object. The means by which you safely share an object is
>>> orthogonal
>>> >> >> > to
>>> >> >> > how
>>> >> >> > the object itself is made thread-safe.
>>> >> >> >
>>> >> >> > The means by which an object is shared has to involve shared
>>> mutable
>>> >> >> > state,
>>> >> >> > and use of shared mutable state always needs some form of
>>> >> >> > synchronization
>>> >> >> > (either implicit eg due to static initialization; or explicit by
>>> >> >> > using
>>> >> >> > volatile or synchronized getter/setter methods).
>>> >> >> >
>>> >> >> > David
>>> >> >> > -----
>>> >> >> >
>>> >> >> > It's a pity, especially because true immutability gives us some
>>> >> >> > chances of performance optimization. As in this case -- we do not
>>> >> >> > really need .path to be volatile here, if we would assume Path
>>> to be
>>> >> >> > truly immutable. volatility here required only for ensuring safe
>>> >> >> > publishing.
>>> >> >> >
>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>> >> >> >
>>> >> >> > Ruslan Cheremin writes:>
>>> >> >> >
>>> >> >> > But is there a way to define "safe for data race publishing"? I
>>> as
>>> >> >> > far, as I remember, "immutable and thread-safe" is standard
>>> mantra in
>>> >> >> > JDK javadocs for totally safe objects. j.l.String has same
>>> mantra --
>>> >> >> > and it is safe for any way of publishing. Does you mean, I should
>>> >> >> > explicitly add "safe even for publishing via data race" in docs?
>>> But
>>> >> >> > I
>>> >> >> > can't remember any such phrase in JDK docs.
>>> >> >> >
>>> >> >> > I don't recall anything in the JDK docs that mention being
>>> >> >> >
>>> >> >> > "totally safe"
>>> >> >> >
>>> >> >> > regardless of publication mechanism. Some classes, eg String,
>>> have
>>> >> >> > been
>>> >> >> > defined such that they do have that property (for security
>>> reasons).
>>> >> >> > In
>>> >> >> > general neither "thread-safe" nor "immutable" imply
>>> >> >> > safe-for-unsynchronized-publication.
>>> >> >> >
>>> >> >> > Java Concurrency In Practice (jcip.net) does define additional
>>> >> >> > potential
>>> >> >> > annotations, where @Immutable would indeed capture the
>>> requirement of
>>> >> >> > safe-for-unsynchronized-publication.
>>> >> >> >
>>> >> >> > David
>>> >> >> > -----
>>> >> >> >
>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>> >> >> >
>>> >> >> > Ruslan Cheremin writes:
>>> >> >> >
>>> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>>> >> >> > multithreaded use". Although it is not strictly defined in java
>>> what
>>> >> >> > exactly means "safe for multithreaded use" -- does it mean safe
>>> for
>>> >> >> > publishing via data race, among others? -- I suppose, it
>>> >> >> >
>>> >> >> > should be. Am
>>> >> >> >
>>> >> >> > I wrong here?
>>> >> >> >
>>> >> >> > "safe for multi-threaded use" does not generally imply that it
>>> >> >> >
>>> >> >> > is safe to
>>> >> >> >
>>> >> >> > publish instances without synchronization of some form.
>>> >> >> >
>>> >> >> > David
>>> >> >> > -----
>>> >> >> >
>>> >> >> > From other side, File.toPath javadoc explicitly says what
>>> "returned
>>> >> >> > instance must be the same for every invocation", so sync block is
>>> >> >> > required here for mutual exclusion on initialization phase.
>>> Without
>>> >> >> > this requirement it is also safe to live without sync block,
>>> afaik.
>>> >> >> >
>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>> >> >> >
>>> >> >> > Ruslan Cheremin writes:
>>> >> >> >
>>> >> >> > First of all, Path is immutable, so DCL is safe here even without
>>> >> >> > volatile. Volatile here is not required from my point of view.
>>> >> >> >
>>> >> >> > Without the volatile the Path implementation (Path is an
>>> >> >> >
>>> >> >> > interface) must be
>>> >> >> >
>>> >> >> > such that an instance of Path can be safely published without
>>> >> >> >
>>> >> >> > any additional
>>> >> >> >
>>> >> >> > forms of synchronization. Immutability does not in itself
>>> >> >> >
>>> >> >> > ensure that. You
>>> >> >> >
>>> >> >> > would have to examine the actual implementation class.
>>> >> >> >
>>> >> >> > David Holmes
>>> >> >> > ------------
>>> >> >> >
>>> >> >> >
>>> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>>> >> >> >
>>> >> >> > Hi Richard,
>>> >> >> >
>>> >> >> > The variable "filePath" is volatile, so the double-checked
>>> >> >> >
>>> >> >> > locking is correct in this case. It would have been a bug
>>> >> >> >
>>> >> >> > prior to Java 5.
>>> >> >> >
>>> >> >> > Best regards,
>>> >> >> >
>>> >> >> > Dmitry Vyazelenko
>>> >> >> >
>>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>>> >> >> >
>>> >> >> > <richard.warburton at gmail.com> wrote:
>>> >> >> >
>>> >> >> > Hello,
>>> >> >> >
>>> >> >> > The current implementation of java.io.File::toPath [0]
>>> >> >> >
>>> >> >> > appears to be
>>> >> >> >
>>> >> >> > using the double checked locking pattern:
>>> >> >> >
>>> >> >> >     public Path toPath() {
>>> >> >> >         Path result = filePath;
>>> >> >> >         if (result == null) {
>>> >> >> >             synchronized (this) {
>>> >> >> >                 result = filePath;
>>> >> >> >                 if (result == null) {
>>> >> >> >                     result =
>>> >> >> >
>>> >> >> > FileSystems.getDefault().getPath(path);
>>> >> >> >
>>> >> >> >                     filePath = result;
>>> >> >> >                 }
>>> >> >> >             }
>>> >> >> >         }
>>> >> >> >         return result;
>>> >> >> >     }
>>> >> >> >
>>> >> >> > I was going to report the bug, but I'm a little
>>> >> >> >
>>> >> >> > uncertain of the
>>> >> >> >
>>> >> >> > interaction between the local variable 'result' and DCL
>>> >> >> >
>>> >> >> > since I've
>>> >> >> >
>>> >> >> > previously only seen the checking condition on the
>>> >> >> >
>>> >> >> > shared field
>>> >> >> >
>>> >> >> > itself.  Can someone here either confirm that its a bug or
>>> >> >> >
>>> >> >> > explain how
>>> >> >> >
>>> >> >> > the 'result' variable is fixing things?
>>> >> >> >
>>> >> >> > regards,
>>> >> >> >
>>> >> >> >  Richard
>>> >> >> >
>>> >> >> > [0] See the end of
>>> >> >> >
>>> >> >> >
>>> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>>> >> >> >
>>> >> >> > ses/java/io/File.java
>>> >> >> >
>>> >> >> > _______________________________________________
>>> >> >> > Concurrency-interest mailing list
>>> >> >> > Concurrency-interest at cs.oswego.edu
>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >> >> >
>>> >> >> > _______________________________________________
>>> >> >> > Concurrency-interest mailing list
>>> >> >> > Concurrency-interest at cs.oswego.edu
>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >> >> >
>>> >> >> > _______________________________________________
>>> >> >> > Concurrency-interest mailing list
>>> >> >> > Concurrency-interest at cs.oswego.edu
>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >> >> >
>>> >> >> > _______________________________________________
>>> >> >> > Concurrency-interest mailing list
>>> >> >> > Concurrency-interest at cs.oswego.edu
>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >> >> >
>>> >> >> >
>>> >> >> >
>>> >> >> > _______________________________________________
>>> >> >> > Concurrency-interest mailing list
>>> >> >> > Concurrency-interest at cs.oswego.edu
>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >> >> >
>>> >> >> _______________________________________________
>>> >> >> Concurrency-interest mailing list
>>> >> >> Concurrency-interest at cs.oswego.edu
>>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/5975d462/attachment-0001.html>

From vitalyd at gmail.com  Tue Aug 14 16:33:45 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 14 Aug 2012 16:33:45 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAEJX8ornkHoTTFobpi3o1_CvSH7poSv_FS9y1GOS-GbP6pyYww@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAEJX8ooixrfW8KVom_J2ZhDg=2e+VBZMDcY35CCMi-W=kFE52Q@mail.gmail.com>
	<CAHjP37GwWMHcgwAHJWpo=i7HdTydf5t43e2HQhHYivM7WNnwcg@mail.gmail.com>
	<CAEJX8ornkHoTTFobpi3o1_CvSH7poSv_FS9y1GOS-GbP6pyYww@mail.gmail.com>
Message-ID: <CAHjP37EWN+orpnm6d0NgkGfoXaghbtabHF=C6jEGiypC-pYMcA@mail.gmail.com>

Really need value types/structs in the jvm to lower the cost of such
abstractions (and numerous other ones too).  Is there even a remote chance
we'll see that in this lifetime? :)

Sent from my phone
On Aug 14, 2012 4:31 PM, "Stanimir Simeonoff" <stanimir at riflexo.com> wrote:

>
>
> On Tue, Aug 14, 2012 at 11:24 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>
>> Your point about "const" reminded me that I agree with Joe Duffy on his
>> take [1] on the fact that annotating a field as volatile or final (he talks
>> about volatile, but the point can be extended to final) doesn't really
>> belong to the field; the type of order required is determined at the point
>> of access, not declaration.  I think c++11 got this part quite right.
>>
>> [1] http://www.bluebytesoftware.com/blog/2010/12/04/SayonaraVolatile.aspx
>>
>> Yeah, the one about the *"bastardized"* volatile :) Remember it
> clearly.  However it's way too late to modify Java to accommodate for.
> Having only AtomicXXX built-in types, impl. via intrinsics would have been
> much better as code like
> volatile X x;
> if (x!=null && x.foo()) x.bar();
>
> would be significantly easier to spot during writing cycle for most of the
> people.
>
> Stanimir
>
> Sent from my phone
>> On Aug 14, 2012 4:12 PM, "Stanimir Simeonoff" <stanimir at riflexo.com>
>> wrote:
>>
>>>
>>>
>>> On Tue, Aug 14, 2012 at 10:58 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>
>>>> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>>> wrote:
>>>> > Yes, presumably on some archs with very weak memory order it could
>>>> cause
>>>> > some performance impact.  On TSO, it's just a compiler barrier
>>>> preventing
>>>> > code motion that would publish the reference before constructor
>>>> completes,
>>>> > but on those weak archs it could also mean a hardware fence.  Whether
>>>> the
>>>> > tradeoff is worth it in general or not is debatable.  You can't have
>>>> it both
>>>> > ways, I agree, but the jvm and JMM give you options and guidance on
>>>> how to
>>>> > do the "right" thing.
>>>>
>>>> If I'm writing a Java library, containing a Point(x,y) class, which is
>>>> immutable (in the narrower sense), should I use final fields or not?
>>>> What's the "right" thing to do?
>>>>
>>>> If you greatly care about performance and since Java doesn't have
>>> struct alikes (yet) and you are going to have tons of Point(s), just 2
>>> double[]/int[] to reduce the cache misses/indirections - i.e. that's
>>> another option how to organize your code.
>>> OTOH if you choose more OO aproach it's still up to you - you have an
>>> option to make it look "better" w/ final fields or forgo 'em potentionally
>>> saving store-store on PowerPC.
>>>
>>> That reminds me the keyword 'const' is unsed and potetially can be what
>>> "final" is for fields but w/o memory/compiler barriers.
>>>
>>> Stanimir
>>>
>>>> >
>>>> > Sent from my phone
>>>> >
>>>> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>>> >>
>>>> >> Are `final` fields a problem to compiler optimization?
>>>> >>
>>>> >> You can't have both ways.
>>>> >>
>>>> >> Either `final` field semantics is good and cheap, therefore it should
>>>> >> be extended to all fields.
>>>> >>
>>>> >> Or there is some downsides with 'final' field semantics, so we
>>>> >> shouldn't encourage people to apply `final` whenever they can. Lets
>>>> >> hear those downsides.
>>>> >>
>>>> >> Zhong Yu
>>>> >>
>>>> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <
>>>> vitalyd at gmail.com>
>>>> >> wrote:
>>>> >> > This is only an issue when publishing unsafely.  Allowing treating
>>>> >> > constructors as regular methods is a good thing as it gives the
>>>> compiler
>>>> >> > a
>>>> >> > chance to optimize code, which everyone likes and benefits from.
>>>> >> >
>>>> >> > Sent from my phone
>>>> >> >
>>>> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>>> >> >>
>>>> >> >> From a user's point of view, shouldn't constructors be special
>>>> though?
>>>> >> >> An object shouldn't be considered in existence until its
>>>> construction
>>>> >> >> is done; it is pathological that some outsider can observe a
>>>> partially
>>>> >> >> constructed object. Life is simpler if we can eliminate that
>>>> >> >> possibility (unless `this` is leaked inside constructor)
>>>> >> >>
>>>> >> >> Zhong Yu
>>>> >> >>
>>>> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
>>>> >> >> <nathan.reynolds at oracle.com> wrote:
>>>> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
>>>> >> >> > publication)
>>>> >> >> > when they should be combined in a sense.  Typically, when we say
>>>> >> >> > thread-safe
>>>> >> >> > we talk about the operations performed on the object after it
>>>> was
>>>> >> >> > constructed (and its contents are globally visible).  However,
>>>> we
>>>> >> >> > need
>>>> >> >> > to
>>>> >> >> > consider that executing the constructor is modifying the state
>>>> of the
>>>> >> >> > object.  It requires the same mechanisms that the rest of the
>>>> class
>>>> >> >> > uses
>>>> >> >> > to
>>>> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>>>> executing
>>>> >> >> > the
>>>> >> >> > constructor, a proper releasing of a lock or some other
>>>> >> >> > happens-before
>>>> >> >> > construct is required to ensure that the memory updates by the
>>>> thread
>>>> >> >> > are
>>>> >> >> > made globally visible before the object is accessed by another
>>>> >> >> > thread.
>>>> >> >> > This
>>>> >> >> > is what we are calling safe publication.  So, safe publication
>>>> is a
>>>> >> >> > subset
>>>> >> >> > of thread-safety except it is limited to what happens after the
>>>> >> >> > constructor
>>>> >> >> > is called and before the object is used by multiple threads.
>>>> >> >> >
>>>> >> >> > A beautifully-written class can be thread-safe with respect to
>>>> >> >> > calling
>>>> >> >> > its
>>>> >> >> > member methods but not thread-safe with respect to calling its
>>>> >> >> > constructor.
>>>> >> >> > It is this latter case that many stumble upon because they
>>>> think that
>>>> >> >> > constructors are inherently thread-safe because they are
>>>> executed
>>>> >> >> > single-threadedly.  What they fail to realize is that the
>>>> execution
>>>> >> >> > of a
>>>> >> >> > constructor can overlap with the execution of other code from
>>>> the
>>>> >> >> > view
>>>> >> >> > point
>>>> >> >> > of what is happening in memory.  This same problem applies to
>>>> more
>>>> >> >> > rare
>>>> >> >> > case
>>>> >> >> > of regular methods which can be proven to execute in a single
>>>> thread
>>>> >> >> > but
>>>> >> >> > don't use synchronization before multiple threads start
>>>> accessing the
>>>> >> >> > shared
>>>> >> >> > data.
>>>> >> >> >
>>>> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>>>> 602.333.9091
>>>> >> >> > Oracle PSR Engineering | Server Technology
>>>> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
>>>> >> >> >
>>>> >> >> > Ruslan Cheremin writes:
>>>> >> >> >
>>>> >> >> > For me it is confusing: java has only one way to have really
>>>> >> >> > immutable
>>>> >> >> > object, and this way also gives you a total thread safety even
>>>> for
>>>> >> >> > data race based publication. But then docs refer object as
>>>> "immutable
>>>> >> >> > and thread-safe" -- we still can't assume it to be really
>>>> >> >> > thread-safe?
>>>> >> >> >
>>>> >> >> > It is better/simpler to isolate the notion of thread-safety and
>>>> safe
>>>> >> >> > publication. Thread-safety comes into play after you have safely
>>>> >> >> > shared
>>>> >> >> > an
>>>> >> >> > object. The means by which you safely share an object is
>>>> orthogonal
>>>> >> >> > to
>>>> >> >> > how
>>>> >> >> > the object itself is made thread-safe.
>>>> >> >> >
>>>> >> >> > The means by which an object is shared has to involve shared
>>>> mutable
>>>> >> >> > state,
>>>> >> >> > and use of shared mutable state always needs some form of
>>>> >> >> > synchronization
>>>> >> >> > (either implicit eg due to static initialization; or explicit by
>>>> >> >> > using
>>>> >> >> > volatile or synchronized getter/setter methods).
>>>> >> >> >
>>>> >> >> > David
>>>> >> >> > -----
>>>> >> >> >
>>>> >> >> > It's a pity, especially because true immutability gives us some
>>>> >> >> > chances of performance optimization. As in this case -- we do
>>>> not
>>>> >> >> > really need .path to be volatile here, if we would assume Path
>>>> to be
>>>> >> >> > truly immutable. volatility here required only for ensuring safe
>>>> >> >> > publishing.
>>>> >> >> >
>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>> >> >> >
>>>> >> >> > Ruslan Cheremin writes:>
>>>> >> >> >
>>>> >> >> > But is there a way to define "safe for data race publishing"? I
>>>> as
>>>> >> >> > far, as I remember, "immutable and thread-safe" is standard
>>>> mantra in
>>>> >> >> > JDK javadocs for totally safe objects. j.l.String has same
>>>> mantra --
>>>> >> >> > and it is safe for any way of publishing. Does you mean, I
>>>> should
>>>> >> >> > explicitly add "safe even for publishing via data race" in
>>>> docs? But
>>>> >> >> > I
>>>> >> >> > can't remember any such phrase in JDK docs.
>>>> >> >> >
>>>> >> >> > I don't recall anything in the JDK docs that mention being
>>>> >> >> >
>>>> >> >> > "totally safe"
>>>> >> >> >
>>>> >> >> > regardless of publication mechanism. Some classes, eg String,
>>>> have
>>>> >> >> > been
>>>> >> >> > defined such that they do have that property (for security
>>>> reasons).
>>>> >> >> > In
>>>> >> >> > general neither "thread-safe" nor "immutable" imply
>>>> >> >> > safe-for-unsynchronized-publication.
>>>> >> >> >
>>>> >> >> > Java Concurrency In Practice (jcip.net) does define additional
>>>> >> >> > potential
>>>> >> >> > annotations, where @Immutable would indeed capture the
>>>> requirement of
>>>> >> >> > safe-for-unsynchronized-publication.
>>>> >> >> >
>>>> >> >> > David
>>>> >> >> > -----
>>>> >> >> >
>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>> >> >> >
>>>> >> >> > Ruslan Cheremin writes:
>>>> >> >> >
>>>> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>>>> >> >> > multithreaded use". Although it is not strictly defined in java
>>>> what
>>>> >> >> > exactly means "safe for multithreaded use" -- does it mean safe
>>>> for
>>>> >> >> > publishing via data race, among others? -- I suppose, it
>>>> >> >> >
>>>> >> >> > should be. Am
>>>> >> >> >
>>>> >> >> > I wrong here?
>>>> >> >> >
>>>> >> >> > "safe for multi-threaded use" does not generally imply that it
>>>> >> >> >
>>>> >> >> > is safe to
>>>> >> >> >
>>>> >> >> > publish instances without synchronization of some form.
>>>> >> >> >
>>>> >> >> > David
>>>> >> >> > -----
>>>> >> >> >
>>>> >> >> > From other side, File.toPath javadoc explicitly says what
>>>> "returned
>>>> >> >> > instance must be the same for every invocation", so sync block
>>>> is
>>>> >> >> > required here for mutual exclusion on initialization phase.
>>>> Without
>>>> >> >> > this requirement it is also safe to live without sync block,
>>>> afaik.
>>>> >> >> >
>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>> >> >> >
>>>> >> >> > Ruslan Cheremin writes:
>>>> >> >> >
>>>> >> >> > First of all, Path is immutable, so DCL is safe here even
>>>> without
>>>> >> >> > volatile. Volatile here is not required from my point of view.
>>>> >> >> >
>>>> >> >> > Without the volatile the Path implementation (Path is an
>>>> >> >> >
>>>> >> >> > interface) must be
>>>> >> >> >
>>>> >> >> > such that an instance of Path can be safely published without
>>>> >> >> >
>>>> >> >> > any additional
>>>> >> >> >
>>>> >> >> > forms of synchronization. Immutability does not in itself
>>>> >> >> >
>>>> >> >> > ensure that. You
>>>> >> >> >
>>>> >> >> > would have to examine the actual implementation class.
>>>> >> >> >
>>>> >> >> > David Holmes
>>>> >> >> > ------------
>>>> >> >> >
>>>> >> >> >
>>>> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>>>> >> >> >
>>>> >> >> > Hi Richard,
>>>> >> >> >
>>>> >> >> > The variable "filePath" is volatile, so the double-checked
>>>> >> >> >
>>>> >> >> > locking is correct in this case. It would have been a bug
>>>> >> >> >
>>>> >> >> > prior to Java 5.
>>>> >> >> >
>>>> >> >> > Best regards,
>>>> >> >> >
>>>> >> >> > Dmitry Vyazelenko
>>>> >> >> >
>>>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>>>> >> >> >
>>>> >> >> > <richard.warburton at gmail.com> wrote:
>>>> >> >> >
>>>> >> >> > Hello,
>>>> >> >> >
>>>> >> >> > The current implementation of java.io.File::toPath [0]
>>>> >> >> >
>>>> >> >> > appears to be
>>>> >> >> >
>>>> >> >> > using the double checked locking pattern:
>>>> >> >> >
>>>> >> >> >     public Path toPath() {
>>>> >> >> >         Path result = filePath;
>>>> >> >> >         if (result == null) {
>>>> >> >> >             synchronized (this) {
>>>> >> >> >                 result = filePath;
>>>> >> >> >                 if (result == null) {
>>>> >> >> >                     result =
>>>> >> >> >
>>>> >> >> > FileSystems.getDefault().getPath(path);
>>>> >> >> >
>>>> >> >> >                     filePath = result;
>>>> >> >> >                 }
>>>> >> >> >             }
>>>> >> >> >         }
>>>> >> >> >         return result;
>>>> >> >> >     }
>>>> >> >> >
>>>> >> >> > I was going to report the bug, but I'm a little
>>>> >> >> >
>>>> >> >> > uncertain of the
>>>> >> >> >
>>>> >> >> > interaction between the local variable 'result' and DCL
>>>> >> >> >
>>>> >> >> > since I've
>>>> >> >> >
>>>> >> >> > previously only seen the checking condition on the
>>>> >> >> >
>>>> >> >> > shared field
>>>> >> >> >
>>>> >> >> > itself.  Can someone here either confirm that its a bug or
>>>> >> >> >
>>>> >> >> > explain how
>>>> >> >> >
>>>> >> >> > the 'result' variable is fixing things?
>>>> >> >> >
>>>> >> >> > regards,
>>>> >> >> >
>>>> >> >> >  Richard
>>>> >> >> >
>>>> >> >> > [0] See the end of
>>>> >> >> >
>>>> >> >> >
>>>> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>>>> >> >> >
>>>> >> >> > ses/java/io/File.java
>>>> >> >> >
>>>> >> >> > _______________________________________________
>>>> >> >> > Concurrency-interest mailing list
>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >> >> >
>>>> >> >> > _______________________________________________
>>>> >> >> > Concurrency-interest mailing list
>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >> >> >
>>>> >> >> > _______________________________________________
>>>> >> >> > Concurrency-interest mailing list
>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >> >> >
>>>> >> >> > _______________________________________________
>>>> >> >> > Concurrency-interest mailing list
>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >> >> >
>>>> >> >> >
>>>> >> >> >
>>>> >> >> > _______________________________________________
>>>> >> >> > Concurrency-interest mailing list
>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >> >> >
>>>> >> >> _______________________________________________
>>>> >> >> Concurrency-interest mailing list
>>>> >> >> Concurrency-interest at cs.oswego.edu
>>>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/b714777a/attachment-0001.html>

From cheremin at gmail.com  Tue Aug 14 16:47:33 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Wed, 15 Aug 2012 00:47:33 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37EWN+orpnm6d0NgkGfoXaghbtabHF=C6jEGiypC-pYMcA@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAEJX8ooixrfW8KVom_J2ZhDg=2e+VBZMDcY35CCMi-W=kFE52Q@mail.gmail.com>
	<CAHjP37GwWMHcgwAHJWpo=i7HdTydf5t43e2HQhHYivM7WNnwcg@mail.gmail.com>
	<CAEJX8ornkHoTTFobpi3o1_CvSH7poSv_FS9y1GOS-GbP6pyYww@mail.gmail.com>
	<CAHjP37EWN+orpnm6d0NgkGfoXaghbtabHF=C6jEGiypC-pYMcA@mail.gmail.com>
Message-ID: <CAOwENi+TdvQwCUXYe=5u4LM7D51a2M=BQqCViZhKSsHiZtw-Tw@mail.gmail.com>

Although I frequently see the cases where structs would be useful for
optimization purposes, I think it is generally bad idea to introduce
them in java. It would be good idea 10 years ago, but now? I'm pretty
sure it should (and can) be done on JIT level. Escape analyze is the
first step.

2012/8/15 Vitaly Davidovich <vitalyd at gmail.com>:
> Really need value types/structs in the jvm to lower the cost of such
> abstractions (and numerous other ones too).  Is there even a remote chance
> we'll see that in this lifetime? :)
>
> Sent from my phone
>
> On Aug 14, 2012 4:31 PM, "Stanimir Simeonoff" <stanimir at riflexo.com> wrote:
>>
>>
>>
>> On Tue, Aug 14, 2012 at 11:24 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>>>
>>> Your point about "const" reminded me that I agree with Joe Duffy on his
>>> take [1] on the fact that annotating a field as volatile or final (he talks
>>> about volatile, but the point can be extended to final) doesn't really
>>> belong to the field; the type of order required is determined at the point
>>> of access, not declaration.  I think c++11 got this part quite right.
>>>
>>> [1] http://www.bluebytesoftware.com/blog/2010/12/04/SayonaraVolatile.aspx
>>
>> Yeah, the one about the "bastardized" volatile :) Remember it clearly.
>> However it's way too late to modify Java to accommodate for. Having only
>> AtomicXXX built-in types, impl. via intrinsics would have been much better
>> as code like
>> volatile X x;
>> if (x!=null && x.foo()) x.bar();
>>
>> would be significantly easier to spot during writing cycle for most of the
>> people.
>>
>> Stanimir
>>
>>> Sent from my phone
>>>
>>> On Aug 14, 2012 4:12 PM, "Stanimir Simeonoff" <stanimir at riflexo.com>
>>> wrote:
>>>>
>>>>
>>>>
>>>> On Tue, Aug 14, 2012 at 10:58 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>>>
>>>>> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>>>> wrote:
>>>>> > Yes, presumably on some archs with very weak memory order it could
>>>>> > cause
>>>>> > some performance impact.  On TSO, it's just a compiler barrier
>>>>> > preventing
>>>>> > code motion that would publish the reference before constructor
>>>>> > completes,
>>>>> > but on those weak archs it could also mean a hardware fence.  Whether
>>>>> > the
>>>>> > tradeoff is worth it in general or not is debatable.  You can't have
>>>>> > it both
>>>>> > ways, I agree, but the jvm and JMM give you options and guidance on
>>>>> > how to
>>>>> > do the "right" thing.
>>>>>
>>>>> If I'm writing a Java library, containing a Point(x,y) class, which is
>>>>> immutable (in the narrower sense), should I use final fields or not?
>>>>> What's the "right" thing to do?
>>>>>
>>>> If you greatly care about performance and since Java doesn't have struct
>>>> alikes (yet) and you are going to have tons of Point(s), just 2
>>>> double[]/int[] to reduce the cache misses/indirections - i.e. that's another
>>>> option how to organize your code.
>>>> OTOH if you choose more OO aproach it's still up to you - you have an
>>>> option to make it look "better" w/ final fields or forgo 'em potentionally
>>>> saving store-store on PowerPC.
>>>>
>>>> That reminds me the keyword 'const' is unsed and potetially can be what
>>>> "final" is for fields but w/o memory/compiler barriers.
>>>>
>>>> Stanimir
>>>>>
>>>>> >
>>>>> > Sent from my phone
>>>>> >
>>>>> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>>>> >>
>>>>> >> Are `final` fields a problem to compiler optimization?
>>>>> >>
>>>>> >> You can't have both ways.
>>>>> >>
>>>>> >> Either `final` field semantics is good and cheap, therefore it
>>>>> >> should
>>>>> >> be extended to all fields.
>>>>> >>
>>>>> >> Or there is some downsides with 'final' field semantics, so we
>>>>> >> shouldn't encourage people to apply `final` whenever they can. Lets
>>>>> >> hear those downsides.
>>>>> >>
>>>>> >> Zhong Yu
>>>>> >>
>>>>> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich
>>>>> >> <vitalyd at gmail.com>
>>>>> >> wrote:
>>>>> >> > This is only an issue when publishing unsafely.  Allowing treating
>>>>> >> > constructors as regular methods is a good thing as it gives the
>>>>> >> > compiler
>>>>> >> > a
>>>>> >> > chance to optimize code, which everyone likes and benefits from.
>>>>> >> >
>>>>> >> > Sent from my phone
>>>>> >> >
>>>>> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>>>> >> >>
>>>>> >> >> From a user's point of view, shouldn't constructors be special
>>>>> >> >> though?
>>>>> >> >> An object shouldn't be considered in existence until its
>>>>> >> >> construction
>>>>> >> >> is done; it is pathological that some outsider can observe a
>>>>> >> >> partially
>>>>> >> >> constructed object. Life is simpler if we can eliminate that
>>>>> >> >> possibility (unless `this` is leaked inside constructor)
>>>>> >> >>
>>>>> >> >> Zhong Yu
>>>>> >> >>
>>>>> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
>>>>> >> >> <nathan.reynolds at oracle.com> wrote:
>>>>> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
>>>>> >> >> > publication)
>>>>> >> >> > when they should be combined in a sense.  Typically, when we
>>>>> >> >> > say
>>>>> >> >> > thread-safe
>>>>> >> >> > we talk about the operations performed on the object after it
>>>>> >> >> > was
>>>>> >> >> > constructed (and its contents are globally visible).  However,
>>>>> >> >> > we
>>>>> >> >> > need
>>>>> >> >> > to
>>>>> >> >> > consider that executing the constructor is modifying the state
>>>>> >> >> > of the
>>>>> >> >> > object.  It requires the same mechanisms that the rest of the
>>>>> >> >> > class
>>>>> >> >> > uses
>>>>> >> >> > to
>>>>> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>>>>> >> >> > executing
>>>>> >> >> > the
>>>>> >> >> > constructor, a proper releasing of a lock or some other
>>>>> >> >> > happens-before
>>>>> >> >> > construct is required to ensure that the memory updates by the
>>>>> >> >> > thread
>>>>> >> >> > are
>>>>> >> >> > made globally visible before the object is accessed by another
>>>>> >> >> > thread.
>>>>> >> >> > This
>>>>> >> >> > is what we are calling safe publication.  So, safe publication
>>>>> >> >> > is a
>>>>> >> >> > subset
>>>>> >> >> > of thread-safety except it is limited to what happens after the
>>>>> >> >> > constructor
>>>>> >> >> > is called and before the object is used by multiple threads.
>>>>> >> >> >
>>>>> >> >> > A beautifully-written class can be thread-safe with respect to
>>>>> >> >> > calling
>>>>> >> >> > its
>>>>> >> >> > member methods but not thread-safe with respect to calling its
>>>>> >> >> > constructor.
>>>>> >> >> > It is this latter case that many stumble upon because they
>>>>> >> >> > think that
>>>>> >> >> > constructors are inherently thread-safe because they are
>>>>> >> >> > executed
>>>>> >> >> > single-threadedly.  What they fail to realize is that the
>>>>> >> >> > execution
>>>>> >> >> > of a
>>>>> >> >> > constructor can overlap with the execution of other code from
>>>>> >> >> > the
>>>>> >> >> > view
>>>>> >> >> > point
>>>>> >> >> > of what is happening in memory.  This same problem applies to
>>>>> >> >> > more
>>>>> >> >> > rare
>>>>> >> >> > case
>>>>> >> >> > of regular methods which can be proven to execute in a single
>>>>> >> >> > thread
>>>>> >> >> > but
>>>>> >> >> > don't use synchronization before multiple threads start
>>>>> >> >> > accessing the
>>>>> >> >> > shared
>>>>> >> >> > data.
>>>>> >> >> >
>>>>> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>>>>> >> >> > 602.333.9091
>>>>> >> >> > Oracle PSR Engineering | Server Technology
>>>>> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
>>>>> >> >> >
>>>>> >> >> > Ruslan Cheremin writes:
>>>>> >> >> >
>>>>> >> >> > For me it is confusing: java has only one way to have really
>>>>> >> >> > immutable
>>>>> >> >> > object, and this way also gives you a total thread safety even
>>>>> >> >> > for
>>>>> >> >> > data race based publication. But then docs refer object as
>>>>> >> >> > "immutable
>>>>> >> >> > and thread-safe" -- we still can't assume it to be really
>>>>> >> >> > thread-safe?
>>>>> >> >> >
>>>>> >> >> > It is better/simpler to isolate the notion of thread-safety and
>>>>> >> >> > safe
>>>>> >> >> > publication. Thread-safety comes into play after you have
>>>>> >> >> > safely
>>>>> >> >> > shared
>>>>> >> >> > an
>>>>> >> >> > object. The means by which you safely share an object is
>>>>> >> >> > orthogonal
>>>>> >> >> > to
>>>>> >> >> > how
>>>>> >> >> > the object itself is made thread-safe.
>>>>> >> >> >
>>>>> >> >> > The means by which an object is shared has to involve shared
>>>>> >> >> > mutable
>>>>> >> >> > state,
>>>>> >> >> > and use of shared mutable state always needs some form of
>>>>> >> >> > synchronization
>>>>> >> >> > (either implicit eg due to static initialization; or explicit
>>>>> >> >> > by
>>>>> >> >> > using
>>>>> >> >> > volatile or synchronized getter/setter methods).
>>>>> >> >> >
>>>>> >> >> > David
>>>>> >> >> > -----
>>>>> >> >> >
>>>>> >> >> > It's a pity, especially because true immutability gives us some
>>>>> >> >> > chances of performance optimization. As in this case -- we do
>>>>> >> >> > not
>>>>> >> >> > really need .path to be volatile here, if we would assume Path
>>>>> >> >> > to be
>>>>> >> >> > truly immutable. volatility here required only for ensuring
>>>>> >> >> > safe
>>>>> >> >> > publishing.
>>>>> >> >> >
>>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>>> >> >> >
>>>>> >> >> > Ruslan Cheremin writes:>
>>>>> >> >> >
>>>>> >> >> > But is there a way to define "safe for data race publishing"? I
>>>>> >> >> > as
>>>>> >> >> > far, as I remember, "immutable and thread-safe" is standard
>>>>> >> >> > mantra in
>>>>> >> >> > JDK javadocs for totally safe objects. j.l.String has same
>>>>> >> >> > mantra --
>>>>> >> >> > and it is safe for any way of publishing. Does you mean, I
>>>>> >> >> > should
>>>>> >> >> > explicitly add "safe even for publishing via data race" in
>>>>> >> >> > docs? But
>>>>> >> >> > I
>>>>> >> >> > can't remember any such phrase in JDK docs.
>>>>> >> >> >
>>>>> >> >> > I don't recall anything in the JDK docs that mention being
>>>>> >> >> >
>>>>> >> >> > "totally safe"
>>>>> >> >> >
>>>>> >> >> > regardless of publication mechanism. Some classes, eg String,
>>>>> >> >> > have
>>>>> >> >> > been
>>>>> >> >> > defined such that they do have that property (for security
>>>>> >> >> > reasons).
>>>>> >> >> > In
>>>>> >> >> > general neither "thread-safe" nor "immutable" imply
>>>>> >> >> > safe-for-unsynchronized-publication.
>>>>> >> >> >
>>>>> >> >> > Java Concurrency In Practice (jcip.net) does define additional
>>>>> >> >> > potential
>>>>> >> >> > annotations, where @Immutable would indeed capture the
>>>>> >> >> > requirement of
>>>>> >> >> > safe-for-unsynchronized-publication.
>>>>> >> >> >
>>>>> >> >> > David
>>>>> >> >> > -----
>>>>> >> >> >
>>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>>> >> >> >
>>>>> >> >> > Ruslan Cheremin writes:
>>>>> >> >> >
>>>>> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>>>>> >> >> > multithreaded use". Although it is not strictly defined in java
>>>>> >> >> > what
>>>>> >> >> > exactly means "safe for multithreaded use" -- does it mean safe
>>>>> >> >> > for
>>>>> >> >> > publishing via data race, among others? -- I suppose, it
>>>>> >> >> >
>>>>> >> >> > should be. Am
>>>>> >> >> >
>>>>> >> >> > I wrong here?
>>>>> >> >> >
>>>>> >> >> > "safe for multi-threaded use" does not generally imply that it
>>>>> >> >> >
>>>>> >> >> > is safe to
>>>>> >> >> >
>>>>> >> >> > publish instances without synchronization of some form.
>>>>> >> >> >
>>>>> >> >> > David
>>>>> >> >> > -----
>>>>> >> >> >
>>>>> >> >> > From other side, File.toPath javadoc explicitly says what
>>>>> >> >> > "returned
>>>>> >> >> > instance must be the same for every invocation", so sync block
>>>>> >> >> > is
>>>>> >> >> > required here for mutual exclusion on initialization phase.
>>>>> >> >> > Without
>>>>> >> >> > this requirement it is also safe to live without sync block,
>>>>> >> >> > afaik.
>>>>> >> >> >
>>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>>> >> >> >
>>>>> >> >> > Ruslan Cheremin writes:
>>>>> >> >> >
>>>>> >> >> > First of all, Path is immutable, so DCL is safe here even
>>>>> >> >> > without
>>>>> >> >> > volatile. Volatile here is not required from my point of view.
>>>>> >> >> >
>>>>> >> >> > Without the volatile the Path implementation (Path is an
>>>>> >> >> >
>>>>> >> >> > interface) must be
>>>>> >> >> >
>>>>> >> >> > such that an instance of Path can be safely published without
>>>>> >> >> >
>>>>> >> >> > any additional
>>>>> >> >> >
>>>>> >> >> > forms of synchronization. Immutability does not in itself
>>>>> >> >> >
>>>>> >> >> > ensure that. You
>>>>> >> >> >
>>>>> >> >> > would have to examine the actual implementation class.
>>>>> >> >> >
>>>>> >> >> > David Holmes
>>>>> >> >> > ------------
>>>>> >> >> >
>>>>> >> >> >
>>>>> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>>>>> >> >> >
>>>>> >> >> > Hi Richard,
>>>>> >> >> >
>>>>> >> >> > The variable "filePath" is volatile, so the double-checked
>>>>> >> >> >
>>>>> >> >> > locking is correct in this case. It would have been a bug
>>>>> >> >> >
>>>>> >> >> > prior to Java 5.
>>>>> >> >> >
>>>>> >> >> > Best regards,
>>>>> >> >> >
>>>>> >> >> > Dmitry Vyazelenko
>>>>> >> >> >
>>>>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>>>>> >> >> >
>>>>> >> >> > <richard.warburton at gmail.com> wrote:
>>>>> >> >> >
>>>>> >> >> > Hello,
>>>>> >> >> >
>>>>> >> >> > The current implementation of java.io.File::toPath [0]
>>>>> >> >> >
>>>>> >> >> > appears to be
>>>>> >> >> >
>>>>> >> >> > using the double checked locking pattern:
>>>>> >> >> >
>>>>> >> >> >     public Path toPath() {
>>>>> >> >> >         Path result = filePath;
>>>>> >> >> >         if (result == null) {
>>>>> >> >> >             synchronized (this) {
>>>>> >> >> >                 result = filePath;
>>>>> >> >> >                 if (result == null) {
>>>>> >> >> >                     result =
>>>>> >> >> >
>>>>> >> >> > FileSystems.getDefault().getPath(path);
>>>>> >> >> >
>>>>> >> >> >                     filePath = result;
>>>>> >> >> >                 }
>>>>> >> >> >             }
>>>>> >> >> >         }
>>>>> >> >> >         return result;
>>>>> >> >> >     }
>>>>> >> >> >
>>>>> >> >> > I was going to report the bug, but I'm a little
>>>>> >> >> >
>>>>> >> >> > uncertain of the
>>>>> >> >> >
>>>>> >> >> > interaction between the local variable 'result' and DCL
>>>>> >> >> >
>>>>> >> >> > since I've
>>>>> >> >> >
>>>>> >> >> > previously only seen the checking condition on the
>>>>> >> >> >
>>>>> >> >> > shared field
>>>>> >> >> >
>>>>> >> >> > itself.  Can someone here either confirm that its a bug or
>>>>> >> >> >
>>>>> >> >> > explain how
>>>>> >> >> >
>>>>> >> >> > the 'result' variable is fixing things?
>>>>> >> >> >
>>>>> >> >> > regards,
>>>>> >> >> >
>>>>> >> >> >  Richard
>>>>> >> >> >
>>>>> >> >> > [0] See the end of
>>>>> >> >> >
>>>>> >> >> >
>>>>> >> >> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>>>>> >> >> >
>>>>> >> >> > ses/java/io/File.java
>>>>> >> >> >
>>>>> >> >> > _______________________________________________
>>>>> >> >> > Concurrency-interest mailing list
>>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> >> >> >
>>>>> >> >> > _______________________________________________
>>>>> >> >> > Concurrency-interest mailing list
>>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> >> >> >
>>>>> >> >> > _______________________________________________
>>>>> >> >> > Concurrency-interest mailing list
>>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> >> >> >
>>>>> >> >> > _______________________________________________
>>>>> >> >> > Concurrency-interest mailing list
>>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> >> >> >
>>>>> >> >> >
>>>>> >> >> >
>>>>> >> >> > _______________________________________________
>>>>> >> >> > Concurrency-interest mailing list
>>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> >> >> >
>>>>> >> >> _______________________________________________
>>>>> >> >> Concurrency-interest mailing list
>>>>> >> >> Concurrency-interest at cs.oswego.edu
>>>>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From zhong.j.yu at gmail.com  Tue Aug 14 17:02:56 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Tue, 14 Aug 2012 16:02:56 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
Message-ID: <CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>

Lesson I learned from this thread:

do *not* write thread-safe immutable class, unless there's a good reason.

One good reason is double checked locking without volatile.

Zhong Yu

On Tue, Aug 14, 2012 at 3:09 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> You should use final for its semantic meaning/code clarity unless you
> yourself are publishing it unsafely in your library.  If users of your lib
> are sharing this class, they need to provide the required
> synchronization/hand off.  That's my personal view (and I always try to use
> final as much as possible, but mostly for clarity/code semantics).
>
> For people running the jvm on an arch where final is not just compiler
> barrier, I agree it's a bit of a problem - really, final should not carry
> both java semantic and JMM meaning, but I can see why that was done.
>
> Sent from my phone
>
> On Aug 14, 2012 3:58 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>
>> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>> > Yes, presumably on some archs with very weak memory order it could cause
>> > some performance impact.  On TSO, it's just a compiler barrier
>> > preventing
>> > code motion that would publish the reference before constructor
>> > completes,
>> > but on those weak archs it could also mean a hardware fence.  Whether
>> > the
>> > tradeoff is worth it in general or not is debatable.  You can't have it
>> > both
>> > ways, I agree, but the jvm and JMM give you options and guidance on how
>> > to
>> > do the "right" thing.
>>
>> If I'm writing a Java library, containing a Point(x,y) class, which is
>> immutable (in the narrower sense), should I use final fields or not?
>> What's the "right" thing to do?
>>
>> If the answer is platform dependent, oh well.
>>
>> Zhong Yu
>>
>> >
>> > Sent from my phone
>> >
>> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>> >>
>> >> Are `final` fields a problem to compiler optimization?
>> >>
>> >> You can't have both ways.
>> >>
>> >> Either `final` field semantics is good and cheap, therefore it should
>> >> be extended to all fields.
>> >>
>> >> Or there is some downsides with 'final' field semantics, so we
>> >> shouldn't encourage people to apply `final` whenever they can. Lets
>> >> hear those downsides.
>> >>
>> >> Zhong Yu
>> >>
>> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> >> wrote:
>> >> > This is only an issue when publishing unsafely.  Allowing treating
>> >> > constructors as regular methods is a good thing as it gives the
>> >> > compiler
>> >> > a
>> >> > chance to optimize code, which everyone likes and benefits from.
>> >> >
>> >> > Sent from my phone
>> >> >
>> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>> >> >>
>> >> >> From a user's point of view, shouldn't constructors be special
>> >> >> though?
>> >> >> An object shouldn't be considered in existence until its
>> >> >> construction
>> >> >> is done; it is pathological that some outsider can observe a
>> >> >> partially
>> >> >> constructed object. Life is simpler if we can eliminate that
>> >> >> possibility (unless `this` is leaked inside constructor)
>> >> >>
>> >> >> Zhong Yu
>> >> >>
>> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
>> >> >> <nathan.reynolds at oracle.com> wrote:
>> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
>> >> >> > publication)
>> >> >> > when they should be combined in a sense.  Typically, when we say
>> >> >> > thread-safe
>> >> >> > we talk about the operations performed on the object after it was
>> >> >> > constructed (and its contents are globally visible).  However, we
>> >> >> > need
>> >> >> > to
>> >> >> > consider that executing the constructor is modifying the state of
>> >> >> > the
>> >> >> > object.  It requires the same mechanisms that the rest of the
>> >> >> > class
>> >> >> > uses
>> >> >> > to
>> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>> >> >> > executing
>> >> >> > the
>> >> >> > constructor, a proper releasing of a lock or some other
>> >> >> > happens-before
>> >> >> > construct is required to ensure that the memory updates by the
>> >> >> > thread
>> >> >> > are
>> >> >> > made globally visible before the object is accessed by another
>> >> >> > thread.
>> >> >> > This
>> >> >> > is what we are calling safe publication.  So, safe publication is
>> >> >> > a
>> >> >> > subset
>> >> >> > of thread-safety except it is limited to what happens after the
>> >> >> > constructor
>> >> >> > is called and before the object is used by multiple threads.
>> >> >> >
>> >> >> > A beautifully-written class can be thread-safe with respect to
>> >> >> > calling
>> >> >> > its
>> >> >> > member methods but not thread-safe with respect to calling its
>> >> >> > constructor.
>> >> >> > It is this latter case that many stumble upon because they think
>> >> >> > that
>> >> >> > constructors are inherently thread-safe because they are executed
>> >> >> > single-threadedly.  What they fail to realize is that the
>> >> >> > execution
>> >> >> > of a
>> >> >> > constructor can overlap with the execution of other code from the
>> >> >> > view
>> >> >> > point
>> >> >> > of what is happening in memory.  This same problem applies to more
>> >> >> > rare
>> >> >> > case
>> >> >> > of regular methods which can be proven to execute in a single
>> >> >> > thread
>> >> >> > but
>> >> >> > don't use synchronization before multiple threads start accessing
>> >> >> > the
>> >> >> > shared
>> >> >> > data.
>> >> >> >
>> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>> >> >> > 602.333.9091
>> >> >> > Oracle PSR Engineering | Server Technology
>> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:
>> >> >> >
>> >> >> > For me it is confusing: java has only one way to have really
>> >> >> > immutable
>> >> >> > object, and this way also gives you a total thread safety even for
>> >> >> > data race based publication. But then docs refer object as
>> >> >> > "immutable
>> >> >> > and thread-safe" -- we still can't assume it to be really
>> >> >> > thread-safe?
>> >> >> >
>> >> >> > It is better/simpler to isolate the notion of thread-safety and
>> >> >> > safe
>> >> >> > publication. Thread-safety comes into play after you have safely
>> >> >> > shared
>> >> >> > an
>> >> >> > object. The means by which you safely share an object is
>> >> >> > orthogonal
>> >> >> > to
>> >> >> > how
>> >> >> > the object itself is made thread-safe.
>> >> >> >
>> >> >> > The means by which an object is shared has to involve shared
>> >> >> > mutable
>> >> >> > state,
>> >> >> > and use of shared mutable state always needs some form of
>> >> >> > synchronization
>> >> >> > (either implicit eg due to static initialization; or explicit by
>> >> >> > using
>> >> >> > volatile or synchronized getter/setter methods).
>> >> >> >
>> >> >> > David
>> >> >> > -----
>> >> >> >
>> >> >> > It's a pity, especially because true immutability gives us some
>> >> >> > chances of performance optimization. As in this case -- we do not
>> >> >> > really need .path to be volatile here, if we would assume Path to
>> >> >> > be
>> >> >> > truly immutable. volatility here required only for ensuring safe
>> >> >> > publishing.
>> >> >> >
>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:>
>> >> >> >
>> >> >> > But is there a way to define "safe for data race publishing"? I as
>> >> >> > far, as I remember, "immutable and thread-safe" is standard mantra
>> >> >> > in
>> >> >> > JDK javadocs for totally safe objects. j.l.String has same mantra
>> >> >> > --
>> >> >> > and it is safe for any way of publishing. Does you mean, I should
>> >> >> > explicitly add "safe even for publishing via data race" in docs?
>> >> >> > But
>> >> >> > I
>> >> >> > can't remember any such phrase in JDK docs.
>> >> >> >
>> >> >> > I don't recall anything in the JDK docs that mention being
>> >> >> >
>> >> >> > "totally safe"
>> >> >> >
>> >> >> > regardless of publication mechanism. Some classes, eg String, have
>> >> >> > been
>> >> >> > defined such that they do have that property (for security
>> >> >> > reasons).
>> >> >> > In
>> >> >> > general neither "thread-safe" nor "immutable" imply
>> >> >> > safe-for-unsynchronized-publication.
>> >> >> >
>> >> >> > Java Concurrency In Practice (jcip.net) does define additional
>> >> >> > potential
>> >> >> > annotations, where @Immutable would indeed capture the requirement
>> >> >> > of
>> >> >> > safe-for-unsynchronized-publication.
>> >> >> >
>> >> >> > David
>> >> >> > -----
>> >> >> >
>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:
>> >> >> >
>> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>> >> >> > multithreaded use". Although it is not strictly defined in java
>> >> >> > what
>> >> >> > exactly means "safe for multithreaded use" -- does it mean safe
>> >> >> > for
>> >> >> > publishing via data race, among others? -- I suppose, it
>> >> >> >
>> >> >> > should be. Am
>> >> >> >
>> >> >> > I wrong here?
>> >> >> >
>> >> >> > "safe for multi-threaded use" does not generally imply that it
>> >> >> >
>> >> >> > is safe to
>> >> >> >
>> >> >> > publish instances without synchronization of some form.
>> >> >> >
>> >> >> > David
>> >> >> > -----
>> >> >> >
>> >> >> > From other side, File.toPath javadoc explicitly says what
>> >> >> > "returned
>> >> >> > instance must be the same for every invocation", so sync block is
>> >> >> > required here for mutual exclusion on initialization phase.
>> >> >> > Without
>> >> >> > this requirement it is also safe to live without sync block,
>> >> >> > afaik.
>> >> >> >
>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:
>> >> >> >
>> >> >> > First of all, Path is immutable, so DCL is safe here even without
>> >> >> > volatile. Volatile here is not required from my point of view.
>> >> >> >
>> >> >> > Without the volatile the Path implementation (Path is an
>> >> >> >
>> >> >> > interface) must be
>> >> >> >
>> >> >> > such that an instance of Path can be safely published without
>> >> >> >
>> >> >> > any additional
>> >> >> >
>> >> >> > forms of synchronization. Immutability does not in itself
>> >> >> >
>> >> >> > ensure that. You
>> >> >> >
>> >> >> > would have to examine the actual implementation class.
>> >> >> >
>> >> >> > David Holmes
>> >> >> > ------------
>> >> >> >
>> >> >> >
>> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> >> >
>> >> >> > Hi Richard,
>> >> >> >
>> >> >> > The variable "filePath" is volatile, so the double-checked
>> >> >> >
>> >> >> > locking is correct in this case. It would have been a bug
>> >> >> >
>> >> >> > prior to Java 5.
>> >> >> >
>> >> >> > Best regards,
>> >> >> >
>> >> >> > Dmitry Vyazelenko
>> >> >> >
>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >> >
>> >> >> > <richard.warburton at gmail.com> wrote:
>> >> >> >
>> >> >> > Hello,
>> >> >> >
>> >> >> > The current implementation of java.io.File::toPath [0]
>> >> >> >
>> >> >> > appears to be
>> >> >> >
>> >> >> > using the double checked locking pattern:
>> >> >> >
>> >> >> >     public Path toPath() {
>> >> >> >         Path result = filePath;
>> >> >> >         if (result == null) {
>> >> >> >             synchronized (this) {
>> >> >> >                 result = filePath;
>> >> >> >                 if (result == null) {
>> >> >> >                     result =
>> >> >> >
>> >> >> > FileSystems.getDefault().getPath(path);
>> >> >> >
>> >> >> >                     filePath = result;
>> >> >> >                 }
>> >> >> >             }
>> >> >> >         }
>> >> >> >         return result;
>> >> >> >     }
>> >> >> >
>> >> >> > I was going to report the bug, but I'm a little
>> >> >> >
>> >> >> > uncertain of the
>> >> >> >
>> >> >> > interaction between the local variable 'result' and DCL
>> >> >> >
>> >> >> > since I've
>> >> >> >
>> >> >> > previously only seen the checking condition on the
>> >> >> >
>> >> >> > shared field
>> >> >> >
>> >> >> > itself.  Can someone here either confirm that its a bug or
>> >> >> >
>> >> >> > explain how
>> >> >> >
>> >> >> > the 'result' variable is fixing things?
>> >> >> >
>> >> >> > regards,
>> >> >> >
>> >> >> >  Richard
>> >> >> >
>> >> >> > [0] See the end of
>> >> >> >
>> >> >> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> >> >
>> >> >> > ses/java/io/File.java
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> >
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> _______________________________________________
>> >> >> Concurrency-interest mailing list
>> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From vitalyd at gmail.com  Tue Aug 14 17:03:17 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 14 Aug 2012 17:03:17 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENi+TdvQwCUXYe=5u4LM7D51a2M=BQqCViZhKSsHiZtw-Tw@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAEJX8ooixrfW8KVom_J2ZhDg=2e+VBZMDcY35CCMi-W=kFE52Q@mail.gmail.com>
	<CAHjP37GwWMHcgwAHJWpo=i7HdTydf5t43e2HQhHYivM7WNnwcg@mail.gmail.com>
	<CAEJX8ornkHoTTFobpi3o1_CvSH7poSv_FS9y1GOS-GbP6pyYww@mail.gmail.com>
	<CAHjP37EWN+orpnm6d0NgkGfoXaghbtabHF=C6jEGiypC-pYMcA@mail.gmail.com>
	<CAOwENi+TdvQwCUXYe=5u4LM7D51a2M=BQqCViZhKSsHiZtw-Tw@mail.gmail.com>
Message-ID: <CAHjP37G4m7Ot44MTyDTLYf7zXzYjEzpNYorA9sV9O-FAxd4YDg@mail.gmail.com>

In a perfect world with a "sufficiently smart compiler" we can punt this to
the JIT.  However, it's not just the fact that structs could be stack
allocated (or even inline with its host object on the heap - EA doesn't
even come into play here, as far as I know) but their value type semantics
would be useful in certain cases as well.

It would indeed be a large undertaking now, but would certainly be very
useful and a lot of people would be quite happy.

Sent from my phone
On Aug 14, 2012 4:47 PM, "Ruslan Cheremin" <cheremin at gmail.com> wrote:

> Although I frequently see the cases where structs would be useful for
> optimization purposes, I think it is generally bad idea to introduce
> them in java. It would be good idea 10 years ago, but now? I'm pretty
> sure it should (and can) be done on JIT level. Escape analyze is the
> first step.
>
> 2012/8/15 Vitaly Davidovich <vitalyd at gmail.com>:
> > Really need value types/structs in the jvm to lower the cost of such
> > abstractions (and numerous other ones too).  Is there even a remote
> chance
> > we'll see that in this lifetime? :)
> >
> > Sent from my phone
> >
> > On Aug 14, 2012 4:31 PM, "Stanimir Simeonoff" <stanimir at riflexo.com>
> wrote:
> >>
> >>
> >>
> >> On Tue, Aug 14, 2012 at 11:24 PM, Vitaly Davidovich <vitalyd at gmail.com>
> >> wrote:
> >>>
> >>> Your point about "const" reminded me that I agree with Joe Duffy on his
> >>> take [1] on the fact that annotating a field as volatile or final (he
> talks
> >>> about volatile, but the point can be extended to final) doesn't really
> >>> belong to the field; the type of order required is determined at the
> point
> >>> of access, not declaration.  I think c++11 got this part quite right.
> >>>
> >>> [1]
> http://www.bluebytesoftware.com/blog/2010/12/04/SayonaraVolatile.aspx
> >>
> >> Yeah, the one about the "bastardized" volatile :) Remember it clearly.
> >> However it's way too late to modify Java to accommodate for. Having only
> >> AtomicXXX built-in types, impl. via intrinsics would have been much
> better
> >> as code like
> >> volatile X x;
> >> if (x!=null && x.foo()) x.bar();
> >>
> >> would be significantly easier to spot during writing cycle for most of
> the
> >> people.
> >>
> >> Stanimir
> >>
> >>> Sent from my phone
> >>>
> >>> On Aug 14, 2012 4:12 PM, "Stanimir Simeonoff" <stanimir at riflexo.com>
> >>> wrote:
> >>>>
> >>>>
> >>>>
> >>>> On Tue, Aug 14, 2012 at 10:58 PM, Zhong Yu <zhong.j.yu at gmail.com>
> wrote:
> >>>>>
> >>>>> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <
> vitalyd at gmail.com>
> >>>>> wrote:
> >>>>> > Yes, presumably on some archs with very weak memory order it could
> >>>>> > cause
> >>>>> > some performance impact.  On TSO, it's just a compiler barrier
> >>>>> > preventing
> >>>>> > code motion that would publish the reference before constructor
> >>>>> > completes,
> >>>>> > but on those weak archs it could also mean a hardware fence.
>  Whether
> >>>>> > the
> >>>>> > tradeoff is worth it in general or not is debatable.  You can't
> have
> >>>>> > it both
> >>>>> > ways, I agree, but the jvm and JMM give you options and guidance on
> >>>>> > how to
> >>>>> > do the "right" thing.
> >>>>>
> >>>>> If I'm writing a Java library, containing a Point(x,y) class, which
> is
> >>>>> immutable (in the narrower sense), should I use final fields or not?
> >>>>> What's the "right" thing to do?
> >>>>>
> >>>> If you greatly care about performance and since Java doesn't have
> struct
> >>>> alikes (yet) and you are going to have tons of Point(s), just 2
> >>>> double[]/int[] to reduce the cache misses/indirections - i.e. that's
> another
> >>>> option how to organize your code.
> >>>> OTOH if you choose more OO aproach it's still up to you - you have an
> >>>> option to make it look "better" w/ final fields or forgo 'em
> potentionally
> >>>> saving store-store on PowerPC.
> >>>>
> >>>> That reminds me the keyword 'const' is unsed and potetially can be
> what
> >>>> "final" is for fields but w/o memory/compiler barriers.
> >>>>
> >>>> Stanimir
> >>>>>
> >>>>> >
> >>>>> > Sent from my phone
> >>>>> >
> >>>>> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >>>>> >>
> >>>>> >> Are `final` fields a problem to compiler optimization?
> >>>>> >>
> >>>>> >> You can't have both ways.
> >>>>> >>
> >>>>> >> Either `final` field semantics is good and cheap, therefore it
> >>>>> >> should
> >>>>> >> be extended to all fields.
> >>>>> >>
> >>>>> >> Or there is some downsides with 'final' field semantics, so we
> >>>>> >> shouldn't encourage people to apply `final` whenever they can.
> Lets
> >>>>> >> hear those downsides.
> >>>>> >>
> >>>>> >> Zhong Yu
> >>>>> >>
> >>>>> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich
> >>>>> >> <vitalyd at gmail.com>
> >>>>> >> wrote:
> >>>>> >> > This is only an issue when publishing unsafely.  Allowing
> treating
> >>>>> >> > constructors as regular methods is a good thing as it gives the
> >>>>> >> > compiler
> >>>>> >> > a
> >>>>> >> > chance to optimize code, which everyone likes and benefits from.
> >>>>> >> >
> >>>>> >> > Sent from my phone
> >>>>> >> >
> >>>>> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com>
> wrote:
> >>>>> >> >>
> >>>>> >> >> From a user's point of view, shouldn't constructors be special
> >>>>> >> >> though?
> >>>>> >> >> An object shouldn't be considered in existence until its
> >>>>> >> >> construction
> >>>>> >> >> is done; it is pathological that some outsider can observe a
> >>>>> >> >> partially
> >>>>> >> >> constructed object. Life is simpler if we can eliminate that
> >>>>> >> >> possibility (unless `this` is leaked inside constructor)
> >>>>> >> >>
> >>>>> >> >> Zhong Yu
> >>>>> >> >>
> >>>>> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
> >>>>> >> >> <nathan.reynolds at oracle.com> wrote:
> >>>>> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
> >>>>> >> >> > publication)
> >>>>> >> >> > when they should be combined in a sense.  Typically, when we
> >>>>> >> >> > say
> >>>>> >> >> > thread-safe
> >>>>> >> >> > we talk about the operations performed on the object after it
> >>>>> >> >> > was
> >>>>> >> >> > constructed (and its contents are globally visible).
>  However,
> >>>>> >> >> > we
> >>>>> >> >> > need
> >>>>> >> >> > to
> >>>>> >> >> > consider that executing the constructor is modifying the
> state
> >>>>> >> >> > of the
> >>>>> >> >> > object.  It requires the same mechanisms that the rest of the
> >>>>> >> >> > class
> >>>>> >> >> > uses
> >>>>> >> >> > to
> >>>>> >> >> > ensure thread-safety.  Even though, there is only 1 thread
> >>>>> >> >> > executing
> >>>>> >> >> > the
> >>>>> >> >> > constructor, a proper releasing of a lock or some other
> >>>>> >> >> > happens-before
> >>>>> >> >> > construct is required to ensure that the memory updates by
> the
> >>>>> >> >> > thread
> >>>>> >> >> > are
> >>>>> >> >> > made globally visible before the object is accessed by
> another
> >>>>> >> >> > thread.
> >>>>> >> >> > This
> >>>>> >> >> > is what we are calling safe publication.  So, safe
> publication
> >>>>> >> >> > is a
> >>>>> >> >> > subset
> >>>>> >> >> > of thread-safety except it is limited to what happens after
> the
> >>>>> >> >> > constructor
> >>>>> >> >> > is called and before the object is used by multiple threads.
> >>>>> >> >> >
> >>>>> >> >> > A beautifully-written class can be thread-safe with respect
> to
> >>>>> >> >> > calling
> >>>>> >> >> > its
> >>>>> >> >> > member methods but not thread-safe with respect to calling
> its
> >>>>> >> >> > constructor.
> >>>>> >> >> > It is this latter case that many stumble upon because they
> >>>>> >> >> > think that
> >>>>> >> >> > constructors are inherently thread-safe because they are
> >>>>> >> >> > executed
> >>>>> >> >> > single-threadedly.  What they fail to realize is that the
> >>>>> >> >> > execution
> >>>>> >> >> > of a
> >>>>> >> >> > constructor can overlap with the execution of other code from
> >>>>> >> >> > the
> >>>>> >> >> > view
> >>>>> >> >> > point
> >>>>> >> >> > of what is happening in memory.  This same problem applies to
> >>>>> >> >> > more
> >>>>> >> >> > rare
> >>>>> >> >> > case
> >>>>> >> >> > of regular methods which can be proven to execute in a single
> >>>>> >> >> > thread
> >>>>> >> >> > but
> >>>>> >> >> > don't use synchronization before multiple threads start
> >>>>> >> >> > accessing the
> >>>>> >> >> > shared
> >>>>> >> >> > data.
> >>>>> >> >> >
> >>>>> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> >>>>> >> >> > 602.333.9091
> >>>>> >> >> > Oracle PSR Engineering | Server Technology
> >>>>> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >>>>> >> >> >
> >>>>> >> >> > Ruslan Cheremin writes:
> >>>>> >> >> >
> >>>>> >> >> > For me it is confusing: java has only one way to have really
> >>>>> >> >> > immutable
> >>>>> >> >> > object, and this way also gives you a total thread safety
> even
> >>>>> >> >> > for
> >>>>> >> >> > data race based publication. But then docs refer object as
> >>>>> >> >> > "immutable
> >>>>> >> >> > and thread-safe" -- we still can't assume it to be really
> >>>>> >> >> > thread-safe?
> >>>>> >> >> >
> >>>>> >> >> > It is better/simpler to isolate the notion of thread-safety
> and
> >>>>> >> >> > safe
> >>>>> >> >> > publication. Thread-safety comes into play after you have
> >>>>> >> >> > safely
> >>>>> >> >> > shared
> >>>>> >> >> > an
> >>>>> >> >> > object. The means by which you safely share an object is
> >>>>> >> >> > orthogonal
> >>>>> >> >> > to
> >>>>> >> >> > how
> >>>>> >> >> > the object itself is made thread-safe.
> >>>>> >> >> >
> >>>>> >> >> > The means by which an object is shared has to involve shared
> >>>>> >> >> > mutable
> >>>>> >> >> > state,
> >>>>> >> >> > and use of shared mutable state always needs some form of
> >>>>> >> >> > synchronization
> >>>>> >> >> > (either implicit eg due to static initialization; or explicit
> >>>>> >> >> > by
> >>>>> >> >> > using
> >>>>> >> >> > volatile or synchronized getter/setter methods).
> >>>>> >> >> >
> >>>>> >> >> > David
> >>>>> >> >> > -----
> >>>>> >> >> >
> >>>>> >> >> > It's a pity, especially because true immutability gives us
> some
> >>>>> >> >> > chances of performance optimization. As in this case -- we do
> >>>>> >> >> > not
> >>>>> >> >> > really need .path to be volatile here, if we would assume
> Path
> >>>>> >> >> > to be
> >>>>> >> >> > truly immutable. volatility here required only for ensuring
> >>>>> >> >> > safe
> >>>>> >> >> > publishing.
> >>>>> >> >> >
> >>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >>>>> >> >> >
> >>>>> >> >> > Ruslan Cheremin writes:>
> >>>>> >> >> >
> >>>>> >> >> > But is there a way to define "safe for data race
> publishing"? I
> >>>>> >> >> > as
> >>>>> >> >> > far, as I remember, "immutable and thread-safe" is standard
> >>>>> >> >> > mantra in
> >>>>> >> >> > JDK javadocs for totally safe objects. j.l.String has same
> >>>>> >> >> > mantra --
> >>>>> >> >> > and it is safe for any way of publishing. Does you mean, I
> >>>>> >> >> > should
> >>>>> >> >> > explicitly add "safe even for publishing via data race" in
> >>>>> >> >> > docs? But
> >>>>> >> >> > I
> >>>>> >> >> > can't remember any such phrase in JDK docs.
> >>>>> >> >> >
> >>>>> >> >> > I don't recall anything in the JDK docs that mention being
> >>>>> >> >> >
> >>>>> >> >> > "totally safe"
> >>>>> >> >> >
> >>>>> >> >> > regardless of publication mechanism. Some classes, eg String,
> >>>>> >> >> > have
> >>>>> >> >> > been
> >>>>> >> >> > defined such that they do have that property (for security
> >>>>> >> >> > reasons).
> >>>>> >> >> > In
> >>>>> >> >> > general neither "thread-safe" nor "immutable" imply
> >>>>> >> >> > safe-for-unsynchronized-publication.
> >>>>> >> >> >
> >>>>> >> >> > Java Concurrency In Practice (jcip.net) does define
> additional
> >>>>> >> >> > potential
> >>>>> >> >> > annotations, where @Immutable would indeed capture the
> >>>>> >> >> > requirement of
> >>>>> >> >> > safe-for-unsynchronized-publication.
> >>>>> >> >> >
> >>>>> >> >> > David
> >>>>> >> >> > -----
> >>>>> >> >> >
> >>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >>>>> >> >> >
> >>>>> >> >> > Ruslan Cheremin writes:
> >>>>> >> >> >
> >>>>> >> >> > Well, Path javadoc explicitly says "immutable and safe for
> >>>>> >> >> > multithreaded use". Although it is not strictly defined in
> java
> >>>>> >> >> > what
> >>>>> >> >> > exactly means "safe for multithreaded use" -- does it mean
> safe
> >>>>> >> >> > for
> >>>>> >> >> > publishing via data race, among others? -- I suppose, it
> >>>>> >> >> >
> >>>>> >> >> > should be. Am
> >>>>> >> >> >
> >>>>> >> >> > I wrong here?
> >>>>> >> >> >
> >>>>> >> >> > "safe for multi-threaded use" does not generally imply that
> it
> >>>>> >> >> >
> >>>>> >> >> > is safe to
> >>>>> >> >> >
> >>>>> >> >> > publish instances without synchronization of some form.
> >>>>> >> >> >
> >>>>> >> >> > David
> >>>>> >> >> > -----
> >>>>> >> >> >
> >>>>> >> >> > From other side, File.toPath javadoc explicitly says what
> >>>>> >> >> > "returned
> >>>>> >> >> > instance must be the same for every invocation", so sync
> block
> >>>>> >> >> > is
> >>>>> >> >> > required here for mutual exclusion on initialization phase.
> >>>>> >> >> > Without
> >>>>> >> >> > this requirement it is also safe to live without sync block,
> >>>>> >> >> > afaik.
> >>>>> >> >> >
> >>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >>>>> >> >> >
> >>>>> >> >> > Ruslan Cheremin writes:
> >>>>> >> >> >
> >>>>> >> >> > First of all, Path is immutable, so DCL is safe here even
> >>>>> >> >> > without
> >>>>> >> >> > volatile. Volatile here is not required from my point of
> view.
> >>>>> >> >> >
> >>>>> >> >> > Without the volatile the Path implementation (Path is an
> >>>>> >> >> >
> >>>>> >> >> > interface) must be
> >>>>> >> >> >
> >>>>> >> >> > such that an instance of Path can be safely published without
> >>>>> >> >> >
> >>>>> >> >> > any additional
> >>>>> >> >> >
> >>>>> >> >> > forms of synchronization. Immutability does not in itself
> >>>>> >> >> >
> >>>>> >> >> > ensure that. You
> >>>>> >> >> >
> >>>>> >> >> > would have to examine the actual implementation class.
> >>>>> >> >> >
> >>>>> >> >> > David Holmes
> >>>>> >> >> > ------------
> >>>>> >> >> >
> >>>>> >> >> >
> >>>>> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >>>>> >> >> >
> >>>>> >> >> > Hi Richard,
> >>>>> >> >> >
> >>>>> >> >> > The variable "filePath" is volatile, so the double-checked
> >>>>> >> >> >
> >>>>> >> >> > locking is correct in this case. It would have been a bug
> >>>>> >> >> >
> >>>>> >> >> > prior to Java 5.
> >>>>> >> >> >
> >>>>> >> >> > Best regards,
> >>>>> >> >> >
> >>>>> >> >> > Dmitry Vyazelenko
> >>>>> >> >> >
> >>>>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >>>>> >> >> >
> >>>>> >> >> > <richard.warburton at gmail.com> wrote:
> >>>>> >> >> >
> >>>>> >> >> > Hello,
> >>>>> >> >> >
> >>>>> >> >> > The current implementation of java.io.File::toPath [0]
> >>>>> >> >> >
> >>>>> >> >> > appears to be
> >>>>> >> >> >
> >>>>> >> >> > using the double checked locking pattern:
> >>>>> >> >> >
> >>>>> >> >> >     public Path toPath() {
> >>>>> >> >> >         Path result = filePath;
> >>>>> >> >> >         if (result == null) {
> >>>>> >> >> >             synchronized (this) {
> >>>>> >> >> >                 result = filePath;
> >>>>> >> >> >                 if (result == null) {
> >>>>> >> >> >                     result =
> >>>>> >> >> >
> >>>>> >> >> > FileSystems.getDefault().getPath(path);
> >>>>> >> >> >
> >>>>> >> >> >                     filePath = result;
> >>>>> >> >> >                 }
> >>>>> >> >> >             }
> >>>>> >> >> >         }
> >>>>> >> >> >         return result;
> >>>>> >> >> >     }
> >>>>> >> >> >
> >>>>> >> >> > I was going to report the bug, but I'm a little
> >>>>> >> >> >
> >>>>> >> >> > uncertain of the
> >>>>> >> >> >
> >>>>> >> >> > interaction between the local variable 'result' and DCL
> >>>>> >> >> >
> >>>>> >> >> > since I've
> >>>>> >> >> >
> >>>>> >> >> > previously only seen the checking condition on the
> >>>>> >> >> >
> >>>>> >> >> > shared field
> >>>>> >> >> >
> >>>>> >> >> > itself.  Can someone here either confirm that its a bug or
> >>>>> >> >> >
> >>>>> >> >> > explain how
> >>>>> >> >> >
> >>>>> >> >> > the 'result' variable is fixing things?
> >>>>> >> >> >
> >>>>> >> >> > regards,
> >>>>> >> >> >
> >>>>> >> >> >  Richard
> >>>>> >> >> >
> >>>>> >> >> > [0] See the end of
> >>>>> >> >> >
> >>>>> >> >> >
> >>>>> >> >> >
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >>>>> >> >> >
> >>>>> >> >> > ses/java/io/File.java
> >>>>> >> >> >
> >>>>> >> >> > _______________________________________________
> >>>>> >> >> > Concurrency-interest mailing list
> >>>>> >> >> > Concurrency-interest at cs.oswego.edu
> >>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>> >> >> >
> >>>>> >> >> > _______________________________________________
> >>>>> >> >> > Concurrency-interest mailing list
> >>>>> >> >> > Concurrency-interest at cs.oswego.edu
> >>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>> >> >> >
> >>>>> >> >> > _______________________________________________
> >>>>> >> >> > Concurrency-interest mailing list
> >>>>> >> >> > Concurrency-interest at cs.oswego.edu
> >>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>> >> >> >
> >>>>> >> >> > _______________________________________________
> >>>>> >> >> > Concurrency-interest mailing list
> >>>>> >> >> > Concurrency-interest at cs.oswego.edu
> >>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>> >> >> >
> >>>>> >> >> >
> >>>>> >> >> >
> >>>>> >> >> > _______________________________________________
> >>>>> >> >> > Concurrency-interest mailing list
> >>>>> >> >> > Concurrency-interest at cs.oswego.edu
> >>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>> >> >> >
> >>>>> >> >> _______________________________________________
> >>>>> >> >> Concurrency-interest mailing list
> >>>>> >> >> Concurrency-interest at cs.oswego.edu
> >>>>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>> _______________________________________________
> >>>>> Concurrency-interest mailing list
> >>>>> Concurrency-interest at cs.oswego.edu
> >>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>
> >>>>
> >>
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/013a7d0b/attachment-0001.html>

From stanimir at riflexo.com  Tue Aug 14 17:05:56 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Wed, 15 Aug 2012 00:05:56 +0300
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENi+TdvQwCUXYe=5u4LM7D51a2M=BQqCViZhKSsHiZtw-Tw@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAEJX8ooixrfW8KVom_J2ZhDg=2e+VBZMDcY35CCMi-W=kFE52Q@mail.gmail.com>
	<CAHjP37GwWMHcgwAHJWpo=i7HdTydf5t43e2HQhHYivM7WNnwcg@mail.gmail.com>
	<CAEJX8ornkHoTTFobpi3o1_CvSH7poSv_FS9y1GOS-GbP6pyYww@mail.gmail.com>
	<CAHjP37EWN+orpnm6d0NgkGfoXaghbtabHF=C6jEGiypC-pYMcA@mail.gmail.com>
	<CAOwENi+TdvQwCUXYe=5u4LM7D51a2M=BQqCViZhKSsHiZtw-Tw@mail.gmail.com>
Message-ID: <CAEJX8oq8uThwgmCb7wzvXg=-u4rfUh=CKoSkguN=SmCe=SV7AQ@mail.gmail.com>

I am not sure how deep EA can go, struct saves the object header and
indirection. EA can't help when the object escapes for real. Actually I'd
not care about the cases where EA can be applied directly.
Structs are interesting when applied over DirectBuffers, though. The latter
is necessary to communicate to native code and stuff like OpenGL.

Stanimir

On Tue, Aug 14, 2012 at 11:47 PM, Ruslan Cheremin
<cherermin at gmail.com<cheremin at gmail.com>
> wrote:

> Although I frequently see the cases where structs would be useful for
> optimization purposes, I think it is generally bad idea to introduce
> them in java. It would be good idea 10 years ago, but now? I'm pretty
> sure it should (and can) be done on JIT level. Escape analyze is the
> first step.
>
> 2012/8/15 Vitaly Davidovich <vitalyd at gmail.com>:
> > Really need value types/structs in the jvm to lower the cost of such
> > abstractions (and numerous other ones too).  Is there even a remote
> chance
> > we'll see that in this lifetime? :)
> >
> > Sent from my phone
> >
> > On Aug 14, 2012 4:31 PM, "Stanimir Simeonoff" <stanimir at riflexo.com>
> wrote:
> >>
> >>
> >>
> >> On Tue, Aug 14, 2012 at 11:24 PM, Vitaly Davidovich <vitalyd at gmail.com>
> >> wrote:
> >>>
> >>> Your point about "const" reminded me that I agree with Joe Duffy on his
> >>> take [1] on the fact that annotating a field as volatile or final (he
> talks
> >>> about volatile, but the point can be extended to final) doesn't really
> >>> belong to the field; the type of order required is determined at the
> point
> >>> of access, not declaration.  I think c++11 got this part quite right.
> >>>
> >>> [1]
> http://www.bluebytesoftware.com/blog/2010/12/04/SayonaraVolatile.aspx
> >>
> >> Yeah, the one about the "bastardized" volatile :) Remember it clearly.
> >> However it's way too late to modify Java to accommodate for. Having only
> >> AtomicXXX built-in types, impl. via intrinsics would have been much
> better
> >> as code like
> >> volatile X x;
> >> if (x!=null && x.foo()) x.bar();
> >>
> >> would be significantly easier to spot during writing cycle for most of
> the
> >> people.
> >>
> >> Stanimir
> >>
> >>> Sent from my phone
> >>>
> >>> On Aug 14, 2012 4:12 PM, "Stanimir Simeonoff" <stanimir at riflexo.com>
> >>> wrote:
> >>>>
> >>>>
> >>>>
> >>>> On Tue, Aug 14, 2012 at 10:58 PM, Zhong Yu <zhong.j.yu at gmail.com>
> wrote:
> >>>>>
> >>>>> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <
> vitalyd at gmail.com>
> >>>>> wrote:
> >>>>> > Yes, presumably on some archs with very weak memory order it could
> >>>>> > cause
> >>>>> > some performance impact.  On TSO, it's just a compiler barrier
> >>>>> > preventing
> >>>>> > code motion that would publish the reference before constructor
> >>>>> > completes,
> >>>>> > but on those weak archs it could also mean a hardware fence.
>  Whether
> >>>>> > the
> >>>>> > tradeoff is worth it in general or not is debatable.  You can't
> have
> >>>>> > it both
> >>>>> > ways, I agree, but the jvm and JMM give you options and guidance on
> >>>>> > how to
> >>>>> > do the "right" thing.
> >>>>>
> >>>>> If I'm writing a Java library, containing a Point(x,y) class, which
> is
> >>>>> immutable (in the narrower sense), should I use final fields or not?
> >>>>> What's the "right" thing to do?
> >>>>>
> >>>> If you greatly care about performance and since Java doesn't have
> struct
> >>>> alikes (yet) and you are going to have tons of Point(s), just 2
> >>>> double[]/int[] to reduce the cache misses/indirections - i.e. that's
> another
> >>>> option how to organize your code.
> >>>> OTOH if you choose more OO aproach it's still up to you - you have an
> >>>> option to make it look "better" w/ final fields or forgo 'em
> potentionally
> >>>> saving store-store on PowerPC.
> >>>>
> >>>> That reminds me the keyword 'const' is unsed and potetially can be
> what
> >>>> "final" is for fields but w/o memory/compiler barriers.
> >>>>
> >>>> Stanimir
> >>>>>
> >>>>> >
> >>>>> > Sent from my phone
> >>>>> >
> >>>>> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >>>>> >>
> >>>>> >> Are `final` fields a problem to compiler optimization?
> >>>>> >>
> >>>>> >> You can't have both ways.
> >>>>> >>
> >>>>> >> Either `final` field semantics is good and cheap, therefore it
> >>>>> >> should
> >>>>> >> be extended to all fields.
> >>>>> >>
> >>>>> >> Or there is some downsides with 'final' field semantics, so we
> >>>>> >> shouldn't encourage people to apply `final` whenever they can.
> Lets
> >>>>> >> hear those downsides.
> >>>>> >>
> >>>>> >> Zhong Yu
> >>>>> >>
> >>>>> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich
> >>>>> >> <vitalyd at gmail.com>
> >>>>> >> wrote:
> >>>>> >> > This is only an issue when publishing unsafely.  Allowing
> treating
> >>>>> >> > constructors as regular methods is a good thing as it gives the
> >>>>> >> > compiler
> >>>>> >> > a
> >>>>> >> > chance to optimize code, which everyone likes and benefits from.
> >>>>> >> >
> >>>>> >> > Sent from my phone
> >>>>> >> >
> >>>>> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com>
> wrote:
> >>>>> >> >>
> >>>>> >> >> From a user's point of view, shouldn't constructors be special
> >>>>> >> >> though?
> >>>>> >> >> An object shouldn't be considered in existence until its
> >>>>> >> >> construction
> >>>>> >> >> is done; it is pathological that some outsider can observe a
> >>>>> >> >> partially
> >>>>> >> >> constructed object. Life is simpler if we can eliminate that
> >>>>> >> >> possibility (unless `this` is leaked inside constructor)
> >>>>> >> >>
> >>>>> >> >> Zhong Yu
> >>>>> >> >>
> >>>>> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
> >>>>> >> >> <nathan.reynolds at oracle.com> wrote:
> >>>>> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
> >>>>> >> >> > publication)
> >>>>> >> >> > when they should be combined in a sense.  Typically, when we
> >>>>> >> >> > say
> >>>>> >> >> > thread-safe
> >>>>> >> >> > we talk about the operations performed on the object after it
> >>>>> >> >> > was
> >>>>> >> >> > constructed (and its contents are globally visible).
>  However,
> >>>>> >> >> > we
> >>>>> >> >> > need
> >>>>> >> >> > to
> >>>>> >> >> > consider that executing the constructor is modifying the
> state
> >>>>> >> >> > of the
> >>>>> >> >> > object.  It requires the same mechanisms that the rest of the
> >>>>> >> >> > class
> >>>>> >> >> > uses
> >>>>> >> >> > to
> >>>>> >> >> > ensure thread-safety.  Even though, there is only 1 thread
> >>>>> >> >> > executing
> >>>>> >> >> > the
> >>>>> >> >> > constructor, a proper releasing of a lock or some other
> >>>>> >> >> > happens-before
> >>>>> >> >> > construct is required to ensure that the memory updates by
> the
> >>>>> >> >> > thread
> >>>>> >> >> > are
> >>>>> >> >> > made globally visible before the object is accessed by
> another
> >>>>> >> >> > thread.
> >>>>> >> >> > This
> >>>>> >> >> > is what we are calling safe publication.  So, safe
> publication
> >>>>> >> >> > is a
> >>>>> >> >> > subset
> >>>>> >> >> > of thread-safety except it is limited to what happens after
> the
> >>>>> >> >> > constructor
> >>>>> >> >> > is called and before the object is used by multiple threads.
> >>>>> >> >> >
> >>>>> >> >> > A beautifully-written class can be thread-safe with respect
> to
> >>>>> >> >> > calling
> >>>>> >> >> > its
> >>>>> >> >> > member methods but not thread-safe with respect to calling
> its
> >>>>> >> >> > constructor.
> >>>>> >> >> > It is this latter case that many stumble upon because they
> >>>>> >> >> > think that
> >>>>> >> >> > constructors are inherently thread-safe because they are
> >>>>> >> >> > executed
> >>>>> >> >> > single-threadedly.  What they fail to realize is that the
> >>>>> >> >> > execution
> >>>>> >> >> > of a
> >>>>> >> >> > constructor can overlap with the execution of other code from
> >>>>> >> >> > the
> >>>>> >> >> > view
> >>>>> >> >> > point
> >>>>> >> >> > of what is happening in memory.  This same problem applies to
> >>>>> >> >> > more
> >>>>> >> >> > rare
> >>>>> >> >> > case
> >>>>> >> >> > of regular methods which can be proven to execute in a single
> >>>>> >> >> > thread
> >>>>> >> >> > but
> >>>>> >> >> > don't use synchronization before multiple threads start
> >>>>> >> >> > accessing the
> >>>>> >> >> > shared
> >>>>> >> >> > data.
> >>>>> >> >> >
> >>>>> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> >>>>> >> >> > 602.333.9091
> >>>>> >> >> > Oracle PSR Engineering | Server Technology
> >>>>> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >>>>> >> >> >
> >>>>> >> >> > Ruslan Cheremin writes:
> >>>>> >> >> >
> >>>>> >> >> > For me it is confusing: java has only one way to have really
> >>>>> >> >> > immutable
> >>>>> >> >> > object, and this way also gives you a total thread safety
> even
> >>>>> >> >> > for
> >>>>> >> >> > data race based publication. But then docs refer object as
> >>>>> >> >> > "immutable
> >>>>> >> >> > and thread-safe" -- we still can't assume it to be really
> >>>>> >> >> > thread-safe?
> >>>>> >> >> >
> >>>>> >> >> > It is better/simpler to isolate the notion of thread-safety
> and
> >>>>> >> >> > safe
> >>>>> >> >> > publication. Thread-safety comes into play after you have
> >>>>> >> >> > safely
> >>>>> >> >> > shared
> >>>>> >> >> > an
> >>>>> >> >> > object. The means by which you safely share an object is
> >>>>> >> >> > orthogonal
> >>>>> >> >> > to
> >>>>> >> >> > how
> >>>>> >> >> > the object itself is made thread-safe.
> >>>>> >> >> >
> >>>>> >> >> > The means by which an object is shared has to involve shared
> >>>>> >> >> > mutable
> >>>>> >> >> > state,
> >>>>> >> >> > and use of shared mutable state always needs some form of
> >>>>> >> >> > synchronization
> >>>>> >> >> > (either implicit eg due to static initialization; or explicit
> >>>>> >> >> > by
> >>>>> >> >> > using
> >>>>> >> >> > volatile or synchronized getter/setter methods).
> >>>>> >> >> >
> >>>>> >> >> > David
> >>>>> >> >> > -----
> >>>>> >> >> >
> >>>>> >> >> > It's a pity, especially because true immutability gives us
> some
> >>>>> >> >> > chances of performance optimization. As in this case -- we do
> >>>>> >> >> > not
> >>>>> >> >> > really need .path to be volatile here, if we would assume
> Path
> >>>>> >> >> > to be
> >>>>> >> >> > truly immutable. volatility here required only for ensuring
> >>>>> >> >> > safe
> >>>>> >> >> > publishing.
> >>>>> >> >> >
> >>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >>>>> >> >> >
> >>>>> >> >> > Ruslan Cheremin writes:>
> >>>>> >> >> >
> >>>>> >> >> > But is there a way to define "safe for data race
> publishing"? I
> >>>>> >> >> > as
> >>>>> >> >> > far, as I remember, "immutable and thread-safe" is standard
> >>>>> >> >> > mantra in
> >>>>> >> >> > JDK javadocs for totally safe objects. j.l.String has same
> >>>>> >> >> > mantra --
> >>>>> >> >> > and it is safe for any way of publishing. Does you mean, I
> >>>>> >> >> > should
> >>>>> >> >> > explicitly add "safe even for publishing via data race" in
> >>>>> >> >> > docs? But
> >>>>> >> >> > I
> >>>>> >> >> > can't remember any such phrase in JDK docs.
> >>>>> >> >> >
> >>>>> >> >> > I don't recall anything in the JDK docs that mention being
> >>>>> >> >> >
> >>>>> >> >> > "totally safe"
> >>>>> >> >> >
> >>>>> >> >> > regardless of publication mechanism. Some classes, eg String,
> >>>>> >> >> > have
> >>>>> >> >> > been
> >>>>> >> >> > defined such that they do have that property (for security
> >>>>> >> >> > reasons).
> >>>>> >> >> > In
> >>>>> >> >> > general neither "thread-safe" nor "immutable" imply
> >>>>> >> >> > safe-for-unsynchronized-publication.
> >>>>> >> >> >
> >>>>> >> >> > Java Concurrency In Practice (jcip.net) does define
> additional
> >>>>> >> >> > potential
> >>>>> >> >> > annotations, where @Immutable would indeed capture the
> >>>>> >> >> > requirement of
> >>>>> >> >> > safe-for-unsynchronized-publication.
> >>>>> >> >> >
> >>>>> >> >> > David
> >>>>> >> >> > -----
> >>>>> >> >> >
> >>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >>>>> >> >> >
> >>>>> >> >> > Ruslan Cheremin writes:
> >>>>> >> >> >
> >>>>> >> >> > Well, Path javadoc explicitly says "immutable and safe for
> >>>>> >> >> > multithreaded use". Although it is not strictly defined in
> java
> >>>>> >> >> > what
> >>>>> >> >> > exactly means "safe for multithreaded use" -- does it mean
> safe
> >>>>> >> >> > for
> >>>>> >> >> > publishing via data race, among others? -- I suppose, it
> >>>>> >> >> >
> >>>>> >> >> > should be. Am
> >>>>> >> >> >
> >>>>> >> >> > I wrong here?
> >>>>> >> >> >
> >>>>> >> >> > "safe for multi-threaded use" does not generally imply that
> it
> >>>>> >> >> >
> >>>>> >> >> > is safe to
> >>>>> >> >> >
> >>>>> >> >> > publish instances without synchronization of some form.
> >>>>> >> >> >
> >>>>> >> >> > David
> >>>>> >> >> > -----
> >>>>> >> >> >
> >>>>> >> >> > From other side, File.toPath javadoc explicitly says what
> >>>>> >> >> > "returned
> >>>>> >> >> > instance must be the same for every invocation", so sync
> block
> >>>>> >> >> > is
> >>>>> >> >> > required here for mutual exclusion on initialization phase.
> >>>>> >> >> > Without
> >>>>> >> >> > this requirement it is also safe to live without sync block,
> >>>>> >> >> > afaik.
> >>>>> >> >> >
> >>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >>>>> >> >> >
> >>>>> >> >> > Ruslan Cheremin writes:
> >>>>> >> >> >
> >>>>> >> >> > First of all, Path is immutable, so DCL is safe here even
> >>>>> >> >> > without
> >>>>> >> >> > volatile. Volatile here is not required from my point of
> view.
> >>>>> >> >> >
> >>>>> >> >> > Without the volatile the Path implementation (Path is an
> >>>>> >> >> >
> >>>>> >> >> > interface) must be
> >>>>> >> >> >
> >>>>> >> >> > such that an instance of Path can be safely published without
> >>>>> >> >> >
> >>>>> >> >> > any additional
> >>>>> >> >> >
> >>>>> >> >> > forms of synchronization. Immutability does not in itself
> >>>>> >> >> >
> >>>>> >> >> > ensure that. You
> >>>>> >> >> >
> >>>>> >> >> > would have to examine the actual implementation class.
> >>>>> >> >> >
> >>>>> >> >> > David Holmes
> >>>>> >> >> > ------------
> >>>>> >> >> >
> >>>>> >> >> >
> >>>>> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >>>>> >> >> >
> >>>>> >> >> > Hi Richard,
> >>>>> >> >> >
> >>>>> >> >> > The variable "filePath" is volatile, so the double-checked
> >>>>> >> >> >
> >>>>> >> >> > locking is correct in this case. It would have been a bug
> >>>>> >> >> >
> >>>>> >> >> > prior to Java 5.
> >>>>> >> >> >
> >>>>> >> >> > Best regards,
> >>>>> >> >> >
> >>>>> >> >> > Dmitry Vyazelenko
> >>>>> >> >> >
> >>>>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >>>>> >> >> >
> >>>>> >> >> > <richard.warburton at gmail.com> wrote:
> >>>>> >> >> >
> >>>>> >> >> > Hello,
> >>>>> >> >> >
> >>>>> >> >> > The current implementation of java.io.File::toPath [0]
> >>>>> >> >> >
> >>>>> >> >> > appears to be
> >>>>> >> >> >
> >>>>> >> >> > using the double checked locking pattern:
> >>>>> >> >> >
> >>>>> >> >> >     public Path toPath() {
> >>>>> >> >> >         Path result = filePath;
> >>>>> >> >> >         if (result == null) {
> >>>>> >> >> >             synchronized (this) {
> >>>>> >> >> >                 result = filePath;
> >>>>> >> >> >                 if (result == null) {
> >>>>> >> >> >                     result =
> >>>>> >> >> >
> >>>>> >> >> > FileSystems.getDefault().getPath(path);
> >>>>> >> >> >
> >>>>> >> >> >                     filePath = result;
> >>>>> >> >> >                 }
> >>>>> >> >> >             }
> >>>>> >> >> >         }
> >>>>> >> >> >         return result;
> >>>>> >> >> >     }
> >>>>> >> >> >
> >>>>> >> >> > I was going to report the bug, but I'm a little
> >>>>> >> >> >
> >>>>> >> >> > uncertain of the
> >>>>> >> >> >
> >>>>> >> >> > interaction between the local variable 'result' and DCL
> >>>>> >> >> >
> >>>>> >> >> > since I've
> >>>>> >> >> >
> >>>>> >> >> > previously only seen the checking condition on the
> >>>>> >> >> >
> >>>>> >> >> > shared field
> >>>>> >> >> >
> >>>>> >> >> > itself.  Can someone here either confirm that its a bug or
> >>>>> >> >> >
> >>>>> >> >> > explain how
> >>>>> >> >> >
> >>>>> >> >> > the 'result' variable is fixing things?
> >>>>> >> >> >
> >>>>> >> >> > regards,
> >>>>> >> >> >
> >>>>> >> >> >  Richard
> >>>>> >> >> >
> >>>>> >> >> > [0] See the end of
> >>>>> >> >> >
> >>>>> >> >> >
> >>>>> >> >> >
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >>>>> >> >> >
> >>>>> >> >> > ses/java/io/File.java
> >>>>> >> >> >
> >>>>> >> >> > _______________________________________________
> >>>>> >> >> > Concurrency-interest mailing list
> >>>>> >> >> > Concurrency-interest at cs.oswego.edu
> >>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>> >> >> >
> >>>>> >> >> > _______________________________________________
> >>>>> >> >> > Concurrency-interest mailing list
> >>>>> >> >> > Concurrency-interest at cs.oswego.edu
> >>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>> >> >> >
> >>>>> >> >> > _______________________________________________
> >>>>> >> >> > Concurrency-interest mailing list
> >>>>> >> >> > Concurrency-interest at cs.oswego.edu
> >>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>> >> >> >
> >>>>> >> >> > _______________________________________________
> >>>>> >> >> > Concurrency-interest mailing list
> >>>>> >> >> > Concurrency-interest at cs.oswego.edu
> >>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>> >> >> >
> >>>>> >> >> >
> >>>>> >> >> >
> >>>>> >> >> > _______________________________________________
> >>>>> >> >> > Concurrency-interest mailing list
> >>>>> >> >> > Concurrency-interest at cs.oswego.edu
> >>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>> >> >> >
> >>>>> >> >> _______________________________________________
> >>>>> >> >> Concurrency-interest mailing list
> >>>>> >> >> Concurrency-interest at cs.oswego.edu
> >>>>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>> _______________________________________________
> >>>>> Concurrency-interest mailing list
> >>>>> Concurrency-interest at cs.oswego.edu
> >>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>
> >>>>
> >>
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/56763c17/attachment-0001.html>

From forax at univ-mlv.fr  Tue Aug 14 17:58:21 2012
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Tue, 14 Aug 2012 23:58:21 +0200
Subject: [concurrency-interest] ConcurrentHashMap
	bulk	parallel	operations
In-Reply-To: <502A6FB9.2060204@cs.oswego.edu>
References: <50292692.401@cs.oswego.edu>	<502A5626.6020607@cs.oswego.edu>	<CA+F8eeRkWw_KMR2rW-7kxOu4T_-_ntF9J=J_jOX46uTWczEEiQ@mail.gmail.com>	<502A5C8E.5090605@cs.oswego.edu>
	<502A63EF.2090601@univ-mlv.fr> <502A6FB9.2060204@cs.oswego.edu>
Message-ID: <502AC9FD.3040902@univ-mlv.fr>

On 08/14/2012 05:33 PM, Doug Lea wrote:
> On 08/14/12 10:42, R?mi Forax wrote:
>
>> Doug, can you do the same test but instead of switching to a more 
>> expensive sum
>> function,
>> just switch to the same function but declared in an other inner 
>> class, and then
>> switch again
>> to the same function declared in a third inner class.
>
> Sure. Here's a variant that first does x + y:
>    long psum = pm.reduceValuesToLong((x) ->x.longValue(), 0L,
>                                                 (x,y) -> x + y);
> then y + x:
>             long psum = pm.reduceValuesToLong((x) ->x.longValue(), 0L,
>                                                 (x,y) -> y + x);
> then explicit function-objects "pls"
>             long psum = pm.reduceValuesToLong(toLong, 0L, longPlus);
> then back to x+y
>
> Then just for algorithmic comparison, one that doesn't
> bother with reduction, but instead just uses a forEach into a LongAdder:
>             pm.forEachValue((x) -> adr.add(x.longValue()));
>
> All running on current jdk8-lambda binary build on linux 64XNehalem
> with a  ConcurrentHashMapV8<Long, Long> with random long keys.
> There are a few other setup etc differences with the
> version of the program I showed results before (including
> those reducing GC impact during 1st parallel run, which
> otherwise accentuate the terribleness.)

That's amazing, you can see the opt/deopt dance done by Hotspot in 
reduceValuesToLong and
the resulting profile pollution that decrease the perf.
Note that is not the worst case, the worst case is when a lambda do 
boxing because the VM will not able to remove it due to the profile 
pollution, in that case you end up with an allocation in your tight loop.

>
> seq time   1.081
> seq time   1.115
> par x+y time   3.137
> par x+y time   0.048
> par x+y time   0.503
> par x+y time   0.035 <- one guard is installed (monomorphic)
> par x+y time   0.036
> par x+y time   0.034
> par x+y time   0.034
> par x+y time   0.034
> par x+y time   0.033
> par x+y time   0.033
> par y+x time   0.481 <- deoptimization, there is two lambda now
> par y+x time   0.038 <- two guards now (bimorphic)
> par y+x time   0.037
> par y+x time   0.038
> par y+x time   0.036
> par y+x time   0.037
> par y+x time   0.037
> par y+x time   0.036
> par y+x time   0.037
> par y+x time   0.038
> par pls time   0.734 <- deoptimization, there is more than two lambda
> par pls time   0.045 <- give up, do a vtable call (polymorphic)
> par pls time   0.041
> par pls time   0.044
> par pls time   0.043
> par pls time   0.041
> par pls time   0.051
> par pls time   0.042
> par pls time   0.042
> par pls time   0.042
> par x+y time   0.062 <- new lambda, still a vtable call, no deopt
> par x+y time   0.042
> par x+y time   0.041
> par x+y time   0.043
> par x+y time   0.042
> par x+y time   0.042
> par x+y time   0.042
> par x+y time   0.042
> par x+y time   0.041
> par x+y time   0.043

R?mi


From vitalyd at gmail.com  Tue Aug 14 18:36:03 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 14 Aug 2012 18:36:03 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
Message-ID: <CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>

I think the lesson should be avoid data races - period. :) if you find a
case where you can justify it (i.e. profiling/testing guided) then consider
it.  I bet there will be few and far in between cases like that.

Sent from my phone
On Aug 14, 2012 5:02 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:

> Lesson I learned from this thread:
>
> do *not* write thread-safe immutable class, unless there's a good reason.
>
> One good reason is double checked locking without volatile.
>
> Zhong Yu
>
> On Tue, Aug 14, 2012 at 3:09 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
> > You should use final for its semantic meaning/code clarity unless you
> > yourself are publishing it unsafely in your library.  If users of your
> lib
> > are sharing this class, they need to provide the required
> > synchronization/hand off.  That's my personal view (and I always try to
> use
> > final as much as possible, but mostly for clarity/code semantics).
> >
> > For people running the jvm on an arch where final is not just compiler
> > barrier, I agree it's a bit of a problem - really, final should not carry
> > both java semantic and JMM meaning, but I can see why that was done.
> >
> > Sent from my phone
> >
> > On Aug 14, 2012 3:58 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >>
> >> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <vitalyd at gmail.com>
> >> wrote:
> >> > Yes, presumably on some archs with very weak memory order it could
> cause
> >> > some performance impact.  On TSO, it's just a compiler barrier
> >> > preventing
> >> > code motion that would publish the reference before constructor
> >> > completes,
> >> > but on those weak archs it could also mean a hardware fence.  Whether
> >> > the
> >> > tradeoff is worth it in general or not is debatable.  You can't have
> it
> >> > both
> >> > ways, I agree, but the jvm and JMM give you options and guidance on
> how
> >> > to
> >> > do the "right" thing.
> >>
> >> If I'm writing a Java library, containing a Point(x,y) class, which is
> >> immutable (in the narrower sense), should I use final fields or not?
> >> What's the "right" thing to do?
> >>
> >> If the answer is platform dependent, oh well.
> >>
> >> Zhong Yu
> >>
> >> >
> >> > Sent from my phone
> >> >
> >> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >> >>
> >> >> Are `final` fields a problem to compiler optimization?
> >> >>
> >> >> You can't have both ways.
> >> >>
> >> >> Either `final` field semantics is good and cheap, therefore it should
> >> >> be extended to all fields.
> >> >>
> >> >> Or there is some downsides with 'final' field semantics, so we
> >> >> shouldn't encourage people to apply `final` whenever they can. Lets
> >> >> hear those downsides.
> >> >>
> >> >> Zhong Yu
> >> >>
> >> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <
> vitalyd at gmail.com>
> >> >> wrote:
> >> >> > This is only an issue when publishing unsafely.  Allowing treating
> >> >> > constructors as regular methods is a good thing as it gives the
> >> >> > compiler
> >> >> > a
> >> >> > chance to optimize code, which everyone likes and benefits from.
> >> >> >
> >> >> > Sent from my phone
> >> >> >
> >> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >> >> >>
> >> >> >> From a user's point of view, shouldn't constructors be special
> >> >> >> though?
> >> >> >> An object shouldn't be considered in existence until its
> >> >> >> construction
> >> >> >> is done; it is pathological that some outsider can observe a
> >> >> >> partially
> >> >> >> constructed object. Life is simpler if we can eliminate that
> >> >> >> possibility (unless `this` is leaked inside constructor)
> >> >> >>
> >> >> >> Zhong Yu
> >> >> >>
> >> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
> >> >> >> <nathan.reynolds at oracle.com> wrote:
> >> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
> >> >> >> > publication)
> >> >> >> > when they should be combined in a sense.  Typically, when we say
> >> >> >> > thread-safe
> >> >> >> > we talk about the operations performed on the object after it
> was
> >> >> >> > constructed (and its contents are globally visible).  However,
> we
> >> >> >> > need
> >> >> >> > to
> >> >> >> > consider that executing the constructor is modifying the state
> of
> >> >> >> > the
> >> >> >> > object.  It requires the same mechanisms that the rest of the
> >> >> >> > class
> >> >> >> > uses
> >> >> >> > to
> >> >> >> > ensure thread-safety.  Even though, there is only 1 thread
> >> >> >> > executing
> >> >> >> > the
> >> >> >> > constructor, a proper releasing of a lock or some other
> >> >> >> > happens-before
> >> >> >> > construct is required to ensure that the memory updates by the
> >> >> >> > thread
> >> >> >> > are
> >> >> >> > made globally visible before the object is accessed by another
> >> >> >> > thread.
> >> >> >> > This
> >> >> >> > is what we are calling safe publication.  So, safe publication
> is
> >> >> >> > a
> >> >> >> > subset
> >> >> >> > of thread-safety except it is limited to what happens after the
> >> >> >> > constructor
> >> >> >> > is called and before the object is used by multiple threads.
> >> >> >> >
> >> >> >> > A beautifully-written class can be thread-safe with respect to
> >> >> >> > calling
> >> >> >> > its
> >> >> >> > member methods but not thread-safe with respect to calling its
> >> >> >> > constructor.
> >> >> >> > It is this latter case that many stumble upon because they think
> >> >> >> > that
> >> >> >> > constructors are inherently thread-safe because they are
> executed
> >> >> >> > single-threadedly.  What they fail to realize is that the
> >> >> >> > execution
> >> >> >> > of a
> >> >> >> > constructor can overlap with the execution of other code from
> the
> >> >> >> > view
> >> >> >> > point
> >> >> >> > of what is happening in memory.  This same problem applies to
> more
> >> >> >> > rare
> >> >> >> > case
> >> >> >> > of regular methods which can be proven to execute in a single
> >> >> >> > thread
> >> >> >> > but
> >> >> >> > don't use synchronization before multiple threads start
> accessing
> >> >> >> > the
> >> >> >> > shared
> >> >> >> > data.
> >> >> >> >
> >> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> >> >> >> > 602.333.9091
> >> >> >> > Oracle PSR Engineering | Server Technology
> >> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >> >> >> >
> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >
> >> >> >> > For me it is confusing: java has only one way to have really
> >> >> >> > immutable
> >> >> >> > object, and this way also gives you a total thread safety even
> for
> >> >> >> > data race based publication. But then docs refer object as
> >> >> >> > "immutable
> >> >> >> > and thread-safe" -- we still can't assume it to be really
> >> >> >> > thread-safe?
> >> >> >> >
> >> >> >> > It is better/simpler to isolate the notion of thread-safety and
> >> >> >> > safe
> >> >> >> > publication. Thread-safety comes into play after you have safely
> >> >> >> > shared
> >> >> >> > an
> >> >> >> > object. The means by which you safely share an object is
> >> >> >> > orthogonal
> >> >> >> > to
> >> >> >> > how
> >> >> >> > the object itself is made thread-safe.
> >> >> >> >
> >> >> >> > The means by which an object is shared has to involve shared
> >> >> >> > mutable
> >> >> >> > state,
> >> >> >> > and use of shared mutable state always needs some form of
> >> >> >> > synchronization
> >> >> >> > (either implicit eg due to static initialization; or explicit by
> >> >> >> > using
> >> >> >> > volatile or synchronized getter/setter methods).
> >> >> >> >
> >> >> >> > David
> >> >> >> > -----
> >> >> >> >
> >> >> >> > It's a pity, especially because true immutability gives us some
> >> >> >> > chances of performance optimization. As in this case -- we do
> not
> >> >> >> > really need .path to be volatile here, if we would assume Path
> to
> >> >> >> > be
> >> >> >> > truly immutable. volatility here required only for ensuring safe
> >> >> >> > publishing.
> >> >> >> >
> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >
> >> >> >> > Ruslan Cheremin writes:>
> >> >> >> >
> >> >> >> > But is there a way to define "safe for data race publishing"? I
> as
> >> >> >> > far, as I remember, "immutable and thread-safe" is standard
> mantra
> >> >> >> > in
> >> >> >> > JDK javadocs for totally safe objects. j.l.String has same
> mantra
> >> >> >> > --
> >> >> >> > and it is safe for any way of publishing. Does you mean, I
> should
> >> >> >> > explicitly add "safe even for publishing via data race" in docs?
> >> >> >> > But
> >> >> >> > I
> >> >> >> > can't remember any such phrase in JDK docs.
> >> >> >> >
> >> >> >> > I don't recall anything in the JDK docs that mention being
> >> >> >> >
> >> >> >> > "totally safe"
> >> >> >> >
> >> >> >> > regardless of publication mechanism. Some classes, eg String,
> have
> >> >> >> > been
> >> >> >> > defined such that they do have that property (for security
> >> >> >> > reasons).
> >> >> >> > In
> >> >> >> > general neither "thread-safe" nor "immutable" imply
> >> >> >> > safe-for-unsynchronized-publication.
> >> >> >> >
> >> >> >> > Java Concurrency In Practice (jcip.net) does define additional
> >> >> >> > potential
> >> >> >> > annotations, where @Immutable would indeed capture the
> requirement
> >> >> >> > of
> >> >> >> > safe-for-unsynchronized-publication.
> >> >> >> >
> >> >> >> > David
> >> >> >> > -----
> >> >> >> >
> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >
> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >
> >> >> >> > Well, Path javadoc explicitly says "immutable and safe for
> >> >> >> > multithreaded use". Although it is not strictly defined in java
> >> >> >> > what
> >> >> >> > exactly means "safe for multithreaded use" -- does it mean safe
> >> >> >> > for
> >> >> >> > publishing via data race, among others? -- I suppose, it
> >> >> >> >
> >> >> >> > should be. Am
> >> >> >> >
> >> >> >> > I wrong here?
> >> >> >> >
> >> >> >> > "safe for multi-threaded use" does not generally imply that it
> >> >> >> >
> >> >> >> > is safe to
> >> >> >> >
> >> >> >> > publish instances without synchronization of some form.
> >> >> >> >
> >> >> >> > David
> >> >> >> > -----
> >> >> >> >
> >> >> >> > From other side, File.toPath javadoc explicitly says what
> >> >> >> > "returned
> >> >> >> > instance must be the same for every invocation", so sync block
> is
> >> >> >> > required here for mutual exclusion on initialization phase.
> >> >> >> > Without
> >> >> >> > this requirement it is also safe to live without sync block,
> >> >> >> > afaik.
> >> >> >> >
> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >
> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >
> >> >> >> > First of all, Path is immutable, so DCL is safe here even
> without
> >> >> >> > volatile. Volatile here is not required from my point of view.
> >> >> >> >
> >> >> >> > Without the volatile the Path implementation (Path is an
> >> >> >> >
> >> >> >> > interface) must be
> >> >> >> >
> >> >> >> > such that an instance of Path can be safely published without
> >> >> >> >
> >> >> >> > any additional
> >> >> >> >
> >> >> >> > forms of synchronization. Immutability does not in itself
> >> >> >> >
> >> >> >> > ensure that. You
> >> >> >> >
> >> >> >> > would have to examine the actual implementation class.
> >> >> >> >
> >> >> >> > David Holmes
> >> >> >> > ------------
> >> >> >> >
> >> >> >> >
> >> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >> >
> >> >> >> > Hi Richard,
> >> >> >> >
> >> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> >> >
> >> >> >> > locking is correct in this case. It would have been a bug
> >> >> >> >
> >> >> >> > prior to Java 5.
> >> >> >> >
> >> >> >> > Best regards,
> >> >> >> >
> >> >> >> > Dmitry Vyazelenko
> >> >> >> >
> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >> >
> >> >> >> > <richard.warburton at gmail.com> wrote:
> >> >> >> >
> >> >> >> > Hello,
> >> >> >> >
> >> >> >> > The current implementation of java.io.File::toPath [0]
> >> >> >> >
> >> >> >> > appears to be
> >> >> >> >
> >> >> >> > using the double checked locking pattern:
> >> >> >> >
> >> >> >> >     public Path toPath() {
> >> >> >> >         Path result = filePath;
> >> >> >> >         if (result == null) {
> >> >> >> >             synchronized (this) {
> >> >> >> >                 result = filePath;
> >> >> >> >                 if (result == null) {
> >> >> >> >                     result =
> >> >> >> >
> >> >> >> > FileSystems.getDefault().getPath(path);
> >> >> >> >
> >> >> >> >                     filePath = result;
> >> >> >> >                 }
> >> >> >> >             }
> >> >> >> >         }
> >> >> >> >         return result;
> >> >> >> >     }
> >> >> >> >
> >> >> >> > I was going to report the bug, but I'm a little
> >> >> >> >
> >> >> >> > uncertain of the
> >> >> >> >
> >> >> >> > interaction between the local variable 'result' and DCL
> >> >> >> >
> >> >> >> > since I've
> >> >> >> >
> >> >> >> > previously only seen the checking condition on the
> >> >> >> >
> >> >> >> > shared field
> >> >> >> >
> >> >> >> > itself.  Can someone here either confirm that its a bug or
> >> >> >> >
> >> >> >> > explain how
> >> >> >> >
> >> >> >> > the 'result' variable is fixing things?
> >> >> >> >
> >> >> >> > regards,
> >> >> >> >
> >> >> >> >  Richard
> >> >> >> >
> >> >> >> > [0] See the end of
> >> >> >> >
> >> >> >> >
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >> >
> >> >> >> > ses/java/io/File.java
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> >
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> _______________________________________________
> >> >> >> Concurrency-interest mailing list
> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/38b57bac/attachment-0001.html>

From raould at gmail.com  Tue Aug 14 18:49:25 2012
From: raould at gmail.com (Raoul Duke)
Date: Tue, 14 Aug 2012 15:49:25 -0700
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
Message-ID: <CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>

On Tue, Aug 14, 2012 at 3:36 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> I think the lesson should be avoid data races - period. :) if you find a
> case where you can justify it (i.e. profiling/testing guided) then consider
> it.  I bet there will be few and far in between cases like that.

sincere, if vulgar, question: as a run-of-the-mill Joe Average
programmer, how the heck do i even know that i've managed to avoid
them? and if i do manage to avoid them, have i not just basically
walked into potential, hiding, secret, waiting until after i ship to
show up, deadlockville? (all in all, shared-mutable-state-concurrency
seems pretty bad.)

sincerely.

From nathan.reynolds at oracle.com  Tue Aug 14 18:59:16 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 14 Aug 2012 15:59:16 -0700
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
Message-ID: <502AD844.7060804@oracle.com>

I would hope the average programmer would simply need to know they 
should use synchronized blocks when accessing shared state.  If the lock 
becomes contended, then the experts will have to step in and figure out 
how to get rid of the lock and deal with all of these issues.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 8/14/2012 3:49 PM, Raoul Duke wrote:
> On Tue, Aug 14, 2012 at 3:36 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>> I think the lesson should be avoid data races - period. :) if you find a
>> case where you can justify it (i.e. profiling/testing guided) then consider
>> it.  I bet there will be few and far in between cases like that.
> sincere, if vulgar, question: as a run-of-the-mill Joe Average
> programmer, how the heck do i even know that i've managed to avoid
> them? and if i do manage to avoid them, have i not just basically
> walked into potential, hiding, secret, waiting until after i ship to
> show up, deadlockville? (all in all, shared-mutable-state-concurrency
> seems pretty bad.)
>
> sincerely.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/51147bfa/attachment.html>

From vitalyd at gmail.com  Tue Aug 14 19:09:15 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 14 Aug 2012 19:09:15 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
Message-ID: <CAHjP37E+KfATRYjTX_-_t8x3zDTTmHKjRiwuvcYTmGtgGiPLrA@mail.gmail.com>

Data race has a specific meaning in the context of the JMM; since the model
is defined (unlike, say, C++ prior to the latest standard), one should work
within it.

Your question seems to also ask about proper concurrency in general (e.g.
deadlock can happen due to lock ordering issues and not memory model
related issues).  I don't think there's a simple solution other than:

1) learn as much as possible about JMM and available concurrency constructs
in java
2) try to minimize shared state as a general principle
3) prefer immutable objects (in the "normal" sense, not the data racy stuff
discussed here)

I agree that shared state concurrency is hard (no other option in java at
the moment), but it gets really hard when one tries to "optimize" things by
adding data races.  So, trying to keep it simple and optimizing judiciously
is a good path, IMHO.

Again, luckily a memory model exists in java and behavior is well defined
when you don't try to be tricky, so it's mostly a function of learning the
platform tools and sticking to well-defined behavior.

P.S. I also think having a good mental model of how hardware/compiler works
is a great aid in letting make more sense in why things are done the way
they are rather than trying to simply memorize things.

Sent from my phone
On Aug 14, 2012 6:52 PM, "Raoul Duke" <raould at gmail.com> wrote:

> On Tue, Aug 14, 2012 at 3:36 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
> > I think the lesson should be avoid data races - period. :) if you find a
> > case where you can justify it (i.e. profiling/testing guided) then
> consider
> > it.  I bet there will be few and far in between cases like that.
>
> sincere, if vulgar, question: as a run-of-the-mill Joe Average
> programmer, how the heck do i even know that i've managed to avoid
> them? and if i do manage to avoid them, have i not just basically
> walked into potential, hiding, secret, waiting until after i ship to
> show up, deadlockville? (all in all, shared-mutable-state-concurrency
> seems pretty bad.)
>
> sincerely.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/856a6c87/attachment.html>

From viktor.klang at gmail.com  Tue Aug 14 19:11:51 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 15 Aug 2012 01:11:51 +0200
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <502AD844.7060804@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
	<502AD844.7060804@oracle.com>
Message-ID: <CANPzfU_XsBmf4BvSzp2Hz12pZ3c0KCAxM-+Mg_QoWQkYTyNfCw@mail.gmail.com>

On Wed, Aug 15, 2012 at 12:59 AM, Nathan Reynolds <
nathan.reynolds at oracle.com> wrote:

>  I would hope the average programmer would simply need to know they
> should use synchronized blocks when accessing shared state.  If the lock
> becomes contended, then the experts will have to step in and figure out how
> to get rid of the lock and deal with all of these issues.
>

Unfortunately the sad fact is that when you as an "expert" come into a
codebase loitered with synchronized statements, it's completely
demoralizing trying to untangle it since most people do not know when or
why to use them.

Cheers,
?


>
>
>  Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Consulting Member of Technical Staff |
> 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>  On 8/14/2012 3:49 PM, Raoul Duke wrote:
>
> On Tue, Aug 14, 2012 at 3:36 PM, Vitaly Davidovich <vitalyd at gmail.com> <vitalyd at gmail.com> wrote:
>
>  I think the lesson should be avoid data races - period. :) if you find a
> case where you can justify it (i.e. profiling/testing guided) then consider
> it.  I bet there will be few and far in between cases like that.
>
>  sincere, if vulgar, question: as a run-of-the-mill Joe Average
> programmer, how the heck do i even know that i've managed to avoid
> them? and if i do manage to avoid them, have i not just basically
> walked into potential, hiding, secret, waiting until after i ship to
> show up, deadlockville? (all in all, shared-mutable-state-concurrency
> seems pretty bad.)
>
> sincerely.
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/f64b1ce1/attachment.html>

From vitalyd at gmail.com  Tue Aug 14 19:15:46 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 14 Aug 2012 19:15:46 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37E+KfATRYjTX_-_t8x3zDTTmHKjRiwuvcYTmGtgGiPLrA@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
	<CAHjP37E+KfATRYjTX_-_t8x3zDTTmHKjRiwuvcYTmGtgGiPLrA@mail.gmail.com>
Message-ID: <CAHjP37FBj8J_xsfWwQtqt8MDLBBM1_OBHbV0isJ7X9Ny=TaDYw@mail.gmail.com>

Left out another suggestion: instead of trying to scale via threads, can
scale via multiple instances of the app (applies to servers only, really).
This isn't as economical with jvm based apps as native ones, but may be an
option in some cases.

Sent from my phone
On Aug 14, 2012 7:09 PM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:

> Data race has a specific meaning in the context of the JMM; since the
> model is defined (unlike, say, C++ prior to the latest standard), one
> should work within it.
>
> Your question seems to also ask about proper concurrency in general (e.g.
> deadlock can happen due to lock ordering issues and not memory model
> related issues).  I don't think there's a simple solution other than:
>
> 1) learn as much as possible about JMM and available concurrency
> constructs in java
> 2) try to minimize shared state as a general principle
> 3) prefer immutable objects (in the "normal" sense, not the data racy
> stuff discussed here)
>
> I agree that shared state concurrency is hard (no other option in java at
> the moment), but it gets really hard when one tries to "optimize" things by
> adding data races.  So, trying to keep it simple and optimizing judiciously
> is a good path, IMHO.
>
> Again, luckily a memory model exists in java and behavior is well defined
> when you don't try to be tricky, so it's mostly a function of learning the
> platform tools and sticking to well-defined behavior.
>
> P.S. I also think having a good mental model of how hardware/compiler
> works is a great aid in letting make more sense in why things are done the
> way they are rather than trying to simply memorize things.
>
> Sent from my phone
> On Aug 14, 2012 6:52 PM, "Raoul Duke" <raould at gmail.com> wrote:
>
>> On Tue, Aug 14, 2012 at 3:36 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>> > I think the lesson should be avoid data races - period. :) if you find a
>> > case where you can justify it (i.e. profiling/testing guided) then
>> consider
>> > it.  I bet there will be few and far in between cases like that.
>>
>> sincere, if vulgar, question: as a run-of-the-mill Joe Average
>> programmer, how the heck do i even know that i've managed to avoid
>> them? and if i do manage to avoid them, have i not just basically
>> walked into potential, hiding, secret, waiting until after i ship to
>> show up, deadlockville? (all in all, shared-mutable-state-concurrency
>> seems pretty bad.)
>>
>> sincerely.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/004a7ef2/attachment-0001.html>

From vitalyd at gmail.com  Tue Aug 14 19:19:06 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 14 Aug 2012 19:19:06 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CANPzfU_XsBmf4BvSzp2Hz12pZ3c0KCAxM-+Mg_QoWQkYTyNfCw@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
	<502AD844.7060804@oracle.com>
	<CANPzfU_XsBmf4BvSzp2Hz12pZ3c0KCAxM-+Mg_QoWQkYTyNfCw@mail.gmail.com>
Message-ID: <CAHjP37GHDn3xbfRAuTfDeJD5C3QNNAe1+kw_xkFXfrGYVeUnTg@mail.gmail.com>

This is a general problem - can have a tangled mess of single threaded code.

Luckily, the jvm is a nice platform with good tooling for dealing with
threading issues, certainly better than a lot of others.

Sent from my phone
On Aug 14, 2012 7:13 PM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:

>
>
> On Wed, Aug 15, 2012 at 12:59 AM, Nathan Reynolds <
> nathan.reynolds at oracle.com> wrote:
>
>>  I would hope the average programmer would simply need to know they
>> should use synchronized blocks when accessing shared state.  If the lock
>> becomes contended, then the experts will have to step in and figure out how
>> to get rid of the lock and deal with all of these issues.
>>
>
> Unfortunately the sad fact is that when you as an "expert" come into a
> codebase loitered with synchronized statements, it's completely
> demoralizing trying to untangle it since most people do not know when or
> why to use them.
>
> Cheers,
> ?
>
>
>>
>>
>>  Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Consulting Member of Technical Staff |
>> 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>  On 8/14/2012 3:49 PM, Raoul Duke wrote:
>>
>> On Tue, Aug 14, 2012 at 3:36 PM, Vitaly Davidovich <vitalyd at gmail.com> <vitalyd at gmail.com> wrote:
>>
>>  I think the lesson should be avoid data races - period. :) if you find a
>> case where you can justify it (i.e. profiling/testing guided) then consider
>> it.  I bet there will be few and far in between cases like that.
>>
>>  sincere, if vulgar, question: as a run-of-the-mill Joe Average
>> programmer, how the heck do i even know that i've managed to avoid
>> them? and if i do manage to avoid them, have i not just basically
>> walked into potential, hiding, secret, waiting until after i ship to
>> show up, deadlockville? (all in all, shared-mutable-state-concurrency
>> seems pretty bad.)
>>
>> sincerely.
>> _______________________________________________
>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> --
> Viktor Klang
>
> Akka Tech Lead
> Typesafe <http://www.typesafe.com/> - The software stack for applications
> that scale
>
> Twitter: @viktorklang
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/652e2c55/attachment.html>

From viktor.klang at gmail.com  Tue Aug 14 19:24:10 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 15 Aug 2012 01:24:10 +0200
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37FBj8J_xsfWwQtqt8MDLBBM1_OBHbV0isJ7X9Ny=TaDYw@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
	<CAHjP37E+KfATRYjTX_-_t8x3zDTTmHKjRiwuvcYTmGtgGiPLrA@mail.gmail.com>
	<CAHjP37FBj8J_xsfWwQtqt8MDLBBM1_OBHbV0isJ7X9Ny=TaDYw@mail.gmail.com>
Message-ID: <CANPzfU81a2wre0LQ81kmwkjMjKAQHbcDY0P-d8tBO-CrW6BWBg@mail.gmail.com>

On Wed, Aug 15, 2012 at 1:15 AM, Vitaly Davidovich <vitalyd at gmail.com>wrote:

> Left out another suggestion: instead of trying to scale via threads, can
> scale via multiple instances of the app (applies to servers only, really).
> This isn't as economical with jvm based apps as native ones, but may be an
> option in some cases.
>
There are actually some nice higher-level abstractions for
concurrency/parallelism on the jvm...

Cheers,
?



> Sent from my phone
> On Aug 14, 2012 7:09 PM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:
>
>> Data race has a specific meaning in the context of the JMM; since the
>> model is defined (unlike, say, C++ prior to the latest standard), one
>> should work within it.
>>
>> Your question seems to also ask about proper concurrency in general (e.g.
>> deadlock can happen due to lock ordering issues and not memory model
>> related issues).  I don't think there's a simple solution other than:
>>
>> 1) learn as much as possible about JMM and available concurrency
>> constructs in java
>> 2) try to minimize shared state as a general principle
>> 3) prefer immutable objects (in the "normal" sense, not the data racy
>> stuff discussed here)
>>
>> I agree that shared state concurrency is hard (no other option in java at
>> the moment), but it gets really hard when one tries to "optimize" things by
>> adding data races.  So, trying to keep it simple and optimizing judiciously
>> is a good path, IMHO.
>>
>> Again, luckily a memory model exists in java and behavior is well defined
>> when you don't try to be tricky, so it's mostly a function of learning the
>> platform tools and sticking to well-defined behavior.
>>
>> P.S. I also think having a good mental model of how hardware/compiler
>> works is a great aid in letting make more sense in why things are done the
>> way they are rather than trying to simply memorize things.
>>
>> Sent from my phone
>> On Aug 14, 2012 6:52 PM, "Raoul Duke" <raould at gmail.com> wrote:
>>
>>> On Tue, Aug 14, 2012 at 3:36 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>> wrote:
>>> > I think the lesson should be avoid data races - period. :) if you find
>>> a
>>> > case where you can justify it (i.e. profiling/testing guided) then
>>> consider
>>> > it.  I bet there will be few and far in between cases like that.
>>>
>>> sincere, if vulgar, question: as a run-of-the-mill Joe Average
>>> programmer, how the heck do i even know that i've managed to avoid
>>> them? and if i do manage to avoid them, have i not just basically
>>> walked into potential, hiding, secret, waiting until after i ship to
>>> show up, deadlockville? (all in all, shared-mutable-state-concurrency
>>> seems pretty bad.)
>>>
>>> sincerely.
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/e8ff3b1a/attachment.html>

From raould at gmail.com  Tue Aug 14 19:26:12 2012
From: raould at gmail.com (Raoul Duke)
Date: Tue, 14 Aug 2012 16:26:12 -0700
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CANPzfU81a2wre0LQ81kmwkjMjKAQHbcDY0P-d8tBO-CrW6BWBg@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
	<CAHjP37E+KfATRYjTX_-_t8x3zDTTmHKjRiwuvcYTmGtgGiPLrA@mail.gmail.com>
	<CAHjP37FBj8J_xsfWwQtqt8MDLBBM1_OBHbV0isJ7X9Ny=TaDYw@mail.gmail.com>
	<CANPzfU81a2wre0LQ81kmwkjMjKAQHbcDY0P-d8tBO-CrW6BWBg@mail.gmail.com>
Message-ID: <CAJ7XQb6YxjeiKzBmbQg32_v9kVi9bvF5XdynbphnZY2fz89WxQ@mail.gmail.com>

On Tue, Aug 14, 2012 at 4:24 PM, ?iktor ?lang <viktor.klang at gmail.com> wrote:
> There are actually some nice higher-level abstractions for
> concurrency/parallelism on the jvm...

will you be here all week? :-)

http://doc.akka.io/docs/akka/1.3.1/java/dataflow.html


From nathan.reynolds at oracle.com  Tue Aug 14 19:37:28 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 14 Aug 2012 16:37:28 -0700
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37GHDn3xbfRAuTfDeJD5C3QNNAe1+kw_xkFXfrGYVeUnTg@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
	<502AD844.7060804@oracle.com>
	<CANPzfU_XsBmf4BvSzp2Hz12pZ3c0KCAxM-+Mg_QoWQkYTyNfCw@mail.gmail.com>
	<CAHjP37GHDn3xbfRAuTfDeJD5C3QNNAe1+kw_xkFXfrGYVeUnTg@mail.gmail.com>
Message-ID: <502AE138.8090005@oracle.com>

I would rather face having to untangle synchronized blocks than deal 
with race conditions.  Race conditions tend to be found in production 
systems or in load tests.  They are always very difficult to diagnose 
let alone repeat.  In fact, most engineers won't even bother with them 
if you can't reproduce it repeatedly.  I can deal with untangling 
synchronized blocks.  All of the information I need is in the code.  It 
might require a lot of time to get my head around the problem, though.  
In one case, we simply removed the contended synchronized block and 
everything worked just fine!

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 8/14/2012 4:19 PM, Vitaly Davidovich wrote:
>
> This is a general problem - can have a tangled mess of single threaded 
> code.
>
> Luckily, the jvm is a nice platform with good tooling for dealing with 
> threading issues, certainly better than a lot of others.
>
> Sent from my phone
>
> On Aug 14, 2012 7:13 PM, "?iktor ?lang" <viktor.klang at gmail.com 
> <mailto:viktor.klang at gmail.com>> wrote:
>
>
>
>     On Wed, Aug 15, 2012 at 12:59 AM, Nathan Reynolds
>     <nathan.reynolds at oracle.com <mailto:nathan.reynolds at oracle.com>>
>     wrote:
>
>         I would hope the average programmer would simply need to know
>         they should use synchronized blocks when accessing shared
>         state.  If the lock becomes contended, then the experts will
>         have to step in and figure out how to get rid of the lock and
>         deal with all of these issues.
>
>
>     Unfortunately the sad fact is that when you as an "expert" come
>     into a codebase loitered with synchronized statements, it's
>     completely demoralizing trying to untangle it since most people do
>     not know when or why to use them.
>
>     Cheers,
>     ?
>
>
>
>         Nathan Reynolds
>         <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>         | Consulting Member of Technical Staff | 602.333.9091
>         <tel:602.333.9091>
>         Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>         Technology
>         On 8/14/2012 3:49 PM, Raoul Duke wrote:
>>         On Tue, Aug 14, 2012 at 3:36 PM, Vitaly Davidovich<vitalyd at gmail.com>  <mailto:vitalyd at gmail.com>  wrote:
>>>         I think the lesson should be avoid data races - period. :) if you find a
>>>         case where you can justify it (i.e. profiling/testing guided) then consider
>>>         it.  I bet there will be few and far in between cases like that.
>>         sincere, if vulgar, question: as a run-of-the-mill Joe Average
>>         programmer, how the heck do i even know that i've managed to avoid
>>         them? and if i do manage to avoid them, have i not just basically
>>         walked into potential, hiding, secret, waiting until after i ship to
>>         show up, deadlockville? (all in all, shared-mutable-state-concurrency
>>         seems pretty bad.)
>>
>>         sincerely.
>>         _______________________________________________
>>         Concurrency-interest mailing list
>>         Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>         _______________________________________________
>         Concurrency-interest mailing list
>         Concurrency-interest at cs.oswego.edu
>         <mailto:Concurrency-interest at cs.oswego.edu>
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>     -- 
>     Viktor Klang
>
>     Akka Tech Lead
>     Typesafe <http://www.typesafe.com/>- The software stack for
>     applications that scale
>
>     Twitter: @viktorklang
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120814/a201cbc8/attachment-0001.html>

From viktor.klang at gmail.com  Tue Aug 14 19:41:07 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 15 Aug 2012 01:41:07 +0200
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAJ7XQb6YxjeiKzBmbQg32_v9kVi9bvF5XdynbphnZY2fz89WxQ@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
	<CAHjP37E+KfATRYjTX_-_t8x3zDTTmHKjRiwuvcYTmGtgGiPLrA@mail.gmail.com>
	<CAHjP37FBj8J_xsfWwQtqt8MDLBBM1_OBHbV0isJ7X9Ny=TaDYw@mail.gmail.com>
	<CANPzfU81a2wre0LQ81kmwkjMjKAQHbcDY0P-d8tBO-CrW6BWBg@mail.gmail.com>
	<CAJ7XQb6YxjeiKzBmbQg32_v9kVi9bvF5XdynbphnZY2fz89WxQ@mail.gmail.com>
Message-ID: <CANPzfU-4-toCn0fJiY4cPqekEqxqMzOW07iQe2QfBjY2+d1egQ@mail.gmail.com>

On Wed, Aug 15, 2012 at 1:26 AM, Raoul Duke <raould at gmail.com> wrote:

> On Tue, Aug 14, 2012 at 4:24 PM, ?iktor ?lang <viktor.klang at gmail.com>
> wrote:
> > There are actually some nice higher-level abstractions for
> > concurrency/parallelism on the jvm...
>
> will you be here all week? :-)
>
> http://doc.akka.io/docs/akka/1.3.1/java/dataflow.html
>

Hah, I just reimplemented Dataflow using implicit value classes and
delimited continuations for Akka 2.1

Cheers,
?

-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/075db3e2/attachment.html>

From hans.boehm at hp.com  Tue Aug 14 20:01:18 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 15 Aug 2012 00:01:18 +0000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F6036C@G4W3296.americas.hpqcorp.net>

Indeed.  My view is that we need special final field semantics primarily to deal with untrusted code, where you don't have the control to guarantee there are no data races.  There has to be a way for untrusted code to pass a string to a library in a way that guarantees the string won't change between the time a security manager looks at it and the time it's used as a file name.  Thus we have to be able to construct classes that are fully immutable, no matter how badly the client mistreats them.  Final fields give you a way to do that without adding tons of overhead to a class like String.

If you can avoid data races, do.

Hans

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Vitaly Davidovich
Sent: Tuesday, August 14, 2012 3:36 PM
To: Zhong Yu
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK


I think the lesson should be avoid data races - period. :) if you find a case where you can justify it (i.e. profiling/testing guided) then consider it.  I bet there will be few and far in between cases like that.

Sent from my phone
On Aug 14, 2012 5:02 PM, "Zhong Yu" <zhong.j.yu at gmail.com<mailto:zhong.j.yu at gmail.com>> wrote:
Lesson I learned from this thread:

do *not* write thread-safe immutable class, unless there's a good reason.

One good reason is double checked locking without volatile.

Zhong Yu

On Tue, Aug 14, 2012 at 3:09 PM, Vitaly Davidovich <vitalyd at gmail.com<mailto:vitalyd at gmail.com>> wrote:
> You should use final for its semantic meaning/code clarity unless you
> yourself are publishing it unsafely in your library.  If users of your lib
> are sharing this class, they need to provide the required
> synchronization/hand off.  That's my personal view (and I always try to use
> final as much as possible, but mostly for clarity/code semantics).
>
> For people running the jvm on an arch where final is not just compiler
> barrier, I agree it's a bit of a problem - really, final should not carry
> both java semantic and JMM meaning, but I can see why that was done.
>
> Sent from my phone
>
> On Aug 14, 2012 3:58 PM, "Zhong Yu" <zhong.j.yu at gmail.com<mailto:zhong.j.yu at gmail.com>> wrote:
>>
>> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <vitalyd at gmail.com<mailto:vitalyd at gmail.com>>
>> wrote:
>> > Yes, presumably on some archs with very weak memory order it could cause
>> > some performance impact.  On TSO, it's just a compiler barrier
>> > preventing
>> > code motion that would publish the reference before constructor
>> > completes,
>> > but on those weak archs it could also mean a hardware fence.  Whether
>> > the
>> > tradeoff is worth it in general or not is debatable.  You can't have it
>> > both
>> > ways, I agree, but the jvm and JMM give you options and guidance on how
>> > to
>> > do the "right" thing.
>>
>> If I'm writing a Java library, containing a Point(x,y) class, which is
>> immutable (in the narrower sense), should I use final fields or not?
>> What's the "right" thing to do?
>>
>> If the answer is platform dependent, oh well.
>>
>> Zhong Yu
>>
>> >
>> > Sent from my phone
>> >
>> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com<mailto:zhong.j.yu at gmail.com>> wrote:
>> >>
>> >> Are `final` fields a problem to compiler optimization?
>> >>
>> >> You can't have both ways.
>> >>
>> >> Either `final` field semantics is good and cheap, therefore it should
>> >> be extended to all fields.
>> >>
>> >> Or there is some downsides with 'final' field semantics, so we
>> >> shouldn't encourage people to apply `final` whenever they can. Lets
>> >> hear those downsides.
>> >>
>> >> Zhong Yu
>> >>
>> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <vitalyd at gmail.com<mailto:vitalyd at gmail.com>>
>> >> wrote:
>> >> > This is only an issue when publishing unsafely.  Allowing treating
>> >> > constructors as regular methods is a good thing as it gives the
>> >> > compiler
>> >> > a
>> >> > chance to optimize code, which everyone likes and benefits from.
>> >> >
>> >> > Sent from my phone
>> >> >
>> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com<mailto:zhong.j.yu at gmail.com>> wrote:
>> >> >>
>> >> >> From a user's point of view, shouldn't constructors be special
>> >> >> though?
>> >> >> An object shouldn't be considered in existence until its
>> >> >> construction
>> >> >> is done; it is pathological that some outsider can observe a
>> >> >> partially
>> >> >> constructed object. Life is simpler if we can eliminate that
>> >> >> possibility (unless `this` is leaked inside constructor)
>> >> >>
>> >> >> Zhong Yu
>> >> >>
>> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
>> >> >> <nathan.reynolds at oracle.com<mailto:nathan.reynolds at oracle.com>> wrote:
>> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
>> >> >> > publication)
>> >> >> > when they should be combined in a sense.  Typically, when we say
>> >> >> > thread-safe
>> >> >> > we talk about the operations performed on the object after it was
>> >> >> > constructed (and its contents are globally visible).  However, we
>> >> >> > need
>> >> >> > to
>> >> >> > consider that executing the constructor is modifying the state of
>> >> >> > the
>> >> >> > object.  It requires the same mechanisms that the rest of the
>> >> >> > class
>> >> >> > uses
>> >> >> > to
>> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>> >> >> > executing
>> >> >> > the
>> >> >> > constructor, a proper releasing of a lock or some other
>> >> >> > happens-before
>> >> >> > construct is required to ensure that the memory updates by the
>> >> >> > thread
>> >> >> > are
>> >> >> > made globally visible before the object is accessed by another
>> >> >> > thread.
>> >> >> > This
>> >> >> > is what we are calling safe publication.  So, safe publication is
>> >> >> > a
>> >> >> > subset
>> >> >> > of thread-safety except it is limited to what happens after the
>> >> >> > constructor
>> >> >> > is called and before the object is used by multiple threads.
>> >> >> >
>> >> >> > A beautifully-written class can be thread-safe with respect to
>> >> >> > calling
>> >> >> > its
>> >> >> > member methods but not thread-safe with respect to calling its
>> >> >> > constructor.
>> >> >> > It is this latter case that many stumble upon because they think
>> >> >> > that
>> >> >> > constructors are inherently thread-safe because they are executed
>> >> >> > single-threadedly.  What they fail to realize is that the
>> >> >> > execution
>> >> >> > of a
>> >> >> > constructor can overlap with the execution of other code from the
>> >> >> > view
>> >> >> > point
>> >> >> > of what is happening in memory.  This same problem applies to more
>> >> >> > rare
>> >> >> > case
>> >> >> > of regular methods which can be proven to execute in a single
>> >> >> > thread
>> >> >> > but
>> >> >> > don't use synchronization before multiple threads start accessing
>> >> >> > the
>> >> >> > shared
>> >> >> > data.
>> >> >> >
>> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>> >> >> > 602.333.9091<tel:602.333.9091>
>> >> >> > Oracle PSR Engineering | Server Technology
>> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:
>> >> >> >
>> >> >> > For me it is confusing: java has only one way to have really
>> >> >> > immutable
>> >> >> > object, and this way also gives you a total thread safety even for
>> >> >> > data race based publication. But then docs refer object as
>> >> >> > "immutable
>> >> >> > and thread-safe" -- we still can't assume it to be really
>> >> >> > thread-safe?
>> >> >> >
>> >> >> > It is better/simpler to isolate the notion of thread-safety and
>> >> >> > safe
>> >> >> > publication. Thread-safety comes into play after you have safely
>> >> >> > shared
>> >> >> > an
>> >> >> > object. The means by which you safely share an object is
>> >> >> > orthogonal
>> >> >> > to
>> >> >> > how
>> >> >> > the object itself is made thread-safe.
>> >> >> >
>> >> >> > The means by which an object is shared has to involve shared
>> >> >> > mutable
>> >> >> > state,
>> >> >> > and use of shared mutable state always needs some form of
>> >> >> > synchronization
>> >> >> > (either implicit eg due to static initialization; or explicit by
>> >> >> > using
>> >> >> > volatile or synchronized getter/setter methods).
>> >> >> >
>> >> >> > David
>> >> >> > -----
>> >> >> >
>> >> >> > It's a pity, especially because true immutability gives us some
>> >> >> > chances of performance optimization. As in this case -- we do not
>> >> >> > really need .path to be volatile here, if we would assume Path to
>> >> >> > be
>> >> >> > truly immutable. volatility here required only for ensuring safe
>> >> >> > publishing.
>> >> >> >
>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au<mailto:davidcholmes at aapt.net.au>>:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:>
>> >> >> >
>> >> >> > But is there a way to define "safe for data race publishing"? I as
>> >> >> > far, as I remember, "immutable and thread-safe" is standard mantra
>> >> >> > in
>> >> >> > JDK javadocs for totally safe objects. j.l.String has same mantra
>> >> >> > --
>> >> >> > and it is safe for any way of publishing. Does you mean, I should
>> >> >> > explicitly add "safe even for publishing via data race" in docs?
>> >> >> > But
>> >> >> > I
>> >> >> > can't remember any such phrase in JDK docs.
>> >> >> >
>> >> >> > I don't recall anything in the JDK docs that mention being
>> >> >> >
>> >> >> > "totally safe"
>> >> >> >
>> >> >> > regardless of publication mechanism. Some classes, eg String, have
>> >> >> > been
>> >> >> > defined such that they do have that property (for security
>> >> >> > reasons).
>> >> >> > In
>> >> >> > general neither "thread-safe" nor "immutable" imply
>> >> >> > safe-for-unsynchronized-publication.
>> >> >> >
>> >> >> > Java Concurrency In Practice (jcip.net<http://jcip.net>) does define additional
>> >> >> > potential
>> >> >> > annotations, where @Immutable would indeed capture the requirement
>> >> >> > of
>> >> >> > safe-for-unsynchronized-publication.
>> >> >> >
>> >> >> > David
>> >> >> > -----
>> >> >> >
>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au<mailto:davidcholmes at aapt.net.au>>:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:
>> >> >> >
>> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>> >> >> > multithreaded use". Although it is not strictly defined in java
>> >> >> > what
>> >> >> > exactly means "safe for multithreaded use" -- does it mean safe
>> >> >> > for
>> >> >> > publishing via data race, among others? -- I suppose, it
>> >> >> >
>> >> >> > should be. Am
>> >> >> >
>> >> >> > I wrong here?
>> >> >> >
>> >> >> > "safe for multi-threaded use" does not generally imply that it
>> >> >> >
>> >> >> > is safe to
>> >> >> >
>> >> >> > publish instances without synchronization of some form.
>> >> >> >
>> >> >> > David
>> >> >> > -----
>> >> >> >
>> >> >> > From other side, File.toPath javadoc explicitly says what
>> >> >> > "returned
>> >> >> > instance must be the same for every invocation", so sync block is
>> >> >> > required here for mutual exclusion on initialization phase.
>> >> >> > Without
>> >> >> > this requirement it is also safe to live without sync block,
>> >> >> > afaik.
>> >> >> >
>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au<mailto:davidcholmes at aapt.net.au>>:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:
>> >> >> >
>> >> >> > First of all, Path is immutable, so DCL is safe here even without
>> >> >> > volatile. Volatile here is not required from my point of view.
>> >> >> >
>> >> >> > Without the volatile the Path implementation (Path is an
>> >> >> >
>> >> >> > interface) must be
>> >> >> >
>> >> >> > such that an instance of Path can be safely published without
>> >> >> >
>> >> >> > any additional
>> >> >> >
>> >> >> > forms of synchronization. Immutability does not in itself
>> >> >> >
>> >> >> > ensure that. You
>> >> >> >
>> >> >> > would have to examine the actual implementation class.
>> >> >> >
>> >> >> > David Holmes
>> >> >> > ------------
>> >> >> >
>> >> >> >
>> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com<mailto:vyazelenko at yahoo.com>>:
>> >> >> >
>> >> >> > Hi Richard,
>> >> >> >
>> >> >> > The variable "filePath" is volatile, so the double-checked
>> >> >> >
>> >> >> > locking is correct in this case. It would have been a bug
>> >> >> >
>> >> >> > prior to Java 5.
>> >> >> >
>> >> >> > Best regards,
>> >> >> >
>> >> >> > Dmitry Vyazelenko
>> >> >> >
>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >> >
>> >> >> > <richard.warburton at gmail.com<mailto:richard.warburton at gmail.com>> wrote:
>> >> >> >
>> >> >> > Hello,
>> >> >> >
>> >> >> > The current implementation of java.io.File::toPath [0]
>> >> >> >
>> >> >> > appears to be
>> >> >> >
>> >> >> > using the double checked locking pattern:
>> >> >> >
>> >> >> >     public Path toPath() {
>> >> >> >         Path result = filePath;
>> >> >> >         if (result == null) {
>> >> >> >             synchronized (this) {
>> >> >> >                 result = filePath;
>> >> >> >                 if (result == null) {
>> >> >> >                     result =
>> >> >> >
>> >> >> > FileSystems.getDefault().getPath(path);
>> >> >> >
>> >> >> >                     filePath = result;
>> >> >> >                 }
>> >> >> >             }
>> >> >> >         }
>> >> >> >         return result;
>> >> >> >     }
>> >> >> >
>> >> >> > I was going to report the bug, but I'm a little
>> >> >> >
>> >> >> > uncertain of the
>> >> >> >
>> >> >> > interaction between the local variable 'result' and DCL
>> >> >> >
>> >> >> > since I've
>> >> >> >
>> >> >> > previously only seen the checking condition on the
>> >> >> >
>> >> >> > shared field
>> >> >> >
>> >> >> > itself.  Can someone here either confirm that its a bug or
>> >> >> >
>> >> >> > explain how
>> >> >> >
>> >> >> > the 'result' variable is fixing things?
>> >> >> >
>> >> >> > regards,
>> >> >> >
>> >> >> >  Richard
>> >> >> >
>> >> >> > [0] See the end of
>> >> >> >
>> >> >> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas<http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas>
>> >> >> >
>> >> >> > ses/java/io/File.java
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> >
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> _______________________________________________
>> >> >> Concurrency-interest mailing list
>> >> >> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/c403781d/attachment-0001.html>

From hans.boehm at hp.com  Tue Aug 14 20:05:35 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 15 Aug 2012 00:05:35 +0000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<CAJ7XQb5LFD2cM3B25=SvkTZ4qpn7ho5qGhNVjgwHLPYWeTt=Pg@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60379@G4W3296.americas.hpqcorp.net>

I think we need to get to the point where we routinely run (dynamic) race detectors, at least during testing.  Yet another reason to avoid intentional data races which will make it hard to make sense out of the results.

Hans

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Raoul Duke
> Sent: Tuesday, August 14, 2012 3:49 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> 
> On Tue, Aug 14, 2012 at 3:36 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
> > I think the lesson should be avoid data races - period. :) if you
> find a
> > case where you can justify it (i.e. profiling/testing guided) then
> consider
> > it.  I bet there will be few and far in between cases like that.
> 
> sincere, if vulgar, question: as a run-of-the-mill Joe Average
> programmer, how the heck do i even know that i've managed to avoid
> them? and if i do manage to avoid them, have i not just basically
> walked into potential, hiding, secret, waiting until after i ship to
> show up, deadlockville? (all in all, shared-mutable-state-concurrency
> seems pretty bad.)
> 
> sincerely.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From freish at 163.com  Tue Aug 14 20:16:55 2012
From: freish at 163.com (freish)
Date: Wed, 15 Aug 2012 08:16:55 +0800 (CST)
Subject: [concurrency-interest] some questions with ThreadPoolExecutor
Message-ID: <1e2ce181.1f32.13927a3e293.Coremail.freish@163.com>

hi,all


I am reading the source code of ThreadPoolExecutor,I've found something interesting,but I am not sure whether it is reasonable or unreasonable.the detail is as bellow:


in class ThreadPoolExecutor$Worker's run method:


public void run() {
try {
Runnable task = firstTask;
firstTask = null;
while (task != null || (task = getTask()) != null) {
runTask(task);
task = null;
}
} finall y {
workerDone(this);
}
}


I find that if the current thread is going to die,most of the time no new thread is created to replace the dead one.The workerDone method source code:


void workerDone(Worker w) {
final ReentrantLock mainLock = this.mainLock;
mainLock.lock();
try {
completedTaskCount += w.completedTasks;
workers.remove(w);
if (--poolSize == 0)
tryTerminate();
} finally {
mainLock.unlock();
}
}


and tryTerminate:


private void tryTerminate() {
if (poolSize == 0) {
int state = runState;
if (state < STOP && !workQueue.isEmpty()) {
state = RUNNING; // disable termination check below
Thread t = addThread(null);
if (t != null)
t.start();
}
if (state == STOP || state == SHUTDOWN) {
runState = TERMINATED;
termination.signalAll();
terminated();
}
}
}


in the tryTerminate method,there is a new thread created in some condition.But in workerDone,only if the poolSize is 0 can the tryTerminate method be invoked.Then there is a scene:
if I have a thread pool with a unlimited BlockingQueue and corePoolSize equals 5,and I invoke the pool's execute method in a loop to submit 10 tasks. Each task will be executing for 5 seconds. but the first 5 tasks will be throw an RuntimeException after 5 seconds's execution.Then how many threads in the pool will execute the last 5 tasks?
as the code above,I guess only one. I've also writen some simple code to test th is:


import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;


public class TestThreadPool {
private static final ExecutorService pool = Executors.newFixedThreadPool(5);
public static void main(String[] args) throws InterruptedException {
for(int i=0; i<10; i++) {
pool.execute(new MyTask(i));
}
for(int i=0; i<40; i++) {
System.out.println(((ThreadPoolExecutor)pool).getPoolSize());
Thread.sleep(1 000L);
}
pool.shutdown();
}
static class MyTask implements Runnable {
private int num;
public MyTask(int index) {
this.num = index;
}
public void run() {
try {
Thread.sleep(5000L);
System.out.println("task " + num + " executed by " + Thread.currentThread());
} catch (InterruptedException e) {
e.printStackTrace();
}
if(num < 5) {
throw new RuntimeExcepti on("task " + num + ",executed by " + Thread.currentThread());
}
}
}
}


Yes,the last five tasks are executed in only one thread.It seems like a bug of the class ThreadPoolExecutor,after all,it is a pool.Should we add a catch clause in the ThreadPoolExecutor$Worker's run method and do sth in it?
I am not sure whether there are some reasons for this behavor. 












Thank you


---------
Ticmy


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/f7f58d96/attachment.html>

From raould at gmail.com  Tue Aug 14 20:17:05 2012
From: raould at gmail.com (Raoul Duke)
Date: Tue, 14 Aug 2012 17:17:05 -0700
Subject: [concurrency-interest] debugging alternatives (was Re: Double
 Checked Locking in OpenJDK)
Message-ID: <CAJ7XQb5KQDZ8VYbzCPuhViaYM3ww3r-CXENXqvr6m9sBcbFztQ@mail.gmail.com>

> head around the problem, though.  In one case, we simply removed the
> contended synchronized block and everything worked just fine!

<pessimist>er, and you knew that it did not introduce data races? did
you test it, or did you only prove it right? oh wait, we can't test to
prove a negative.</pessimist>

:-)

From zhong.j.yu at gmail.com  Tue Aug 14 20:46:23 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Tue, 14 Aug 2012 19:46:23 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F6036C@G4W3296.americas.hpqcorp.net>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6036C@G4W3296.americas.hpqcorp.net>
Message-ID: <CACuKZqEhBXCaE190T0P2RahrzjTFYX_Tw+T6U=mUnxF3+r3mMg@mail.gmail.com>

Lazy initialization is a common use case. Using thread-safe immutable
objects to avoid a `volatile` read is simple and well understood,
though it contains data race. I would say it is a common, useful and
justifiable data race.

You can argue that a volatile read isn't that expensive, lazy
initialization with volatile variable won't have any detectable
performance degrading on 99.99% systems. That may be true. But we
don't justify each choice of a concurrency tool by "profiling/testing"
real world scenario - seriously, who can afford that?

Zhong Yu

On Tue, Aug 14, 2012 at 7:01 PM, Boehm, Hans <hans.boehm at hp.com> wrote:
> Indeed.  My view is that we need special final field semantics primarily to
> deal with untrusted code, where you don?t have the control to guarantee
> there are no data races.  There has to be a way for untrusted code to pass a
> string to a library in a way that guarantees the string won?t change between
> the time a security manager looks at it and the time it?s used as a file
> name.  Thus we have to be able to construct classes that are fully
> immutable, no matter how badly the client mistreats them.  Final fields give
> you a way to do that without adding tons of overhead to a class like String.
>
>
>
> If you can avoid data races, do.
>
>
>
> Hans
>
>
>
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Vitaly
> Davidovich
> Sent: Tuesday, August 14, 2012 3:36 PM
> To: Zhong Yu
> Cc: concurrency-interest at cs.oswego.edu
>
>
> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>
>
>
> I think the lesson should be avoid data races - period. :) if you find a
> case where you can justify it (i.e. profiling/testing guided) then consider
> it.  I bet there will be few and far in between cases like that.
>
> Sent from my phone
>
> On Aug 14, 2012 5:02 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>
> Lesson I learned from this thread:
>
> do *not* write thread-safe immutable class, unless there's a good reason.
>
> One good reason is double checked locking without volatile.
>
> Zhong Yu
>
> On Tue, Aug 14, 2012 at 3:09 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
>> You should use final for its semantic meaning/code clarity unless you
>> yourself are publishing it unsafely in your library.  If users of your lib
>> are sharing this class, they need to provide the required
>> synchronization/hand off.  That's my personal view (and I always try to
>> use
>> final as much as possible, but mostly for clarity/code semantics).
>>
>> For people running the jvm on an arch where final is not just compiler
>> barrier, I agree it's a bit of a problem - really, final should not carry
>> both java semantic and JMM meaning, but I can see why that was done.
>>
>> Sent from my phone
>>
>> On Aug 14, 2012 3:58 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>>
>>> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>> wrote:
>>> > Yes, presumably on some archs with very weak memory order it could
>>> > cause
>>> > some performance impact.  On TSO, it's just a compiler barrier
>>> > preventing
>>> > code motion that would publish the reference before constructor
>>> > completes,
>>> > but on those weak archs it could also mean a hardware fence.  Whether
>>> > the
>>> > tradeoff is worth it in general or not is debatable.  You can't have it
>>> > both
>>> > ways, I agree, but the jvm and JMM give you options and guidance on how
>>> > to
>>> > do the "right" thing.
>>>
>>> If I'm writing a Java library, containing a Point(x,y) class, which is
>>> immutable (in the narrower sense), should I use final fields or not?
>>> What's the "right" thing to do?
>>>
>>> If the answer is platform dependent, oh well.
>>>
>>> Zhong Yu
>>>
>>> >
>>> > Sent from my phone
>>> >
>>> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>> >>
>>> >> Are `final` fields a problem to compiler optimization?
>>> >>
>>> >> You can't have both ways.
>>> >>
>>> >> Either `final` field semantics is good and cheap, therefore it should
>>> >> be extended to all fields.
>>> >>
>>> >> Or there is some downsides with 'final' field semantics, so we
>>> >> shouldn't encourage people to apply `final` whenever they can. Lets
>>> >> hear those downsides.
>>> >>
>>> >> Zhong Yu
>>> >>
>>> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>> >> wrote:
>>> >> > This is only an issue when publishing unsafely.  Allowing treating
>>> >> > constructors as regular methods is a good thing as it gives the
>>> >> > compiler
>>> >> > a
>>> >> > chance to optimize code, which everyone likes and benefits from.
>>> >> >
>>> >> > Sent from my phone
>>> >> >
>>> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>> >> >>
>>> >> >> From a user's point of view, shouldn't constructors be special
>>> >> >> though?
>>> >> >> An object shouldn't be considered in existence until its
>>> >> >> construction
>>> >> >> is done; it is pathological that some outsider can observe a
>>> >> >> partially
>>> >> >> constructed object. Life is simpler if we can eliminate that
>>> >> >> possibility (unless `this` is leaked inside constructor)
>>> >> >>
>>> >> >> Zhong Yu
>>> >> >>
>>> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
>>> >> >> <nathan.reynolds at oracle.com> wrote:
>>> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
>>> >> >> > publication)
>>> >> >> > when they should be combined in a sense.  Typically, when we say
>>> >> >> > thread-safe
>>> >> >> > we talk about the operations performed on the object after it was
>>> >> >> > constructed (and its contents are globally visible).  However, we
>>> >> >> > need
>>> >> >> > to
>>> >> >> > consider that executing the constructor is modifying the state of
>>> >> >> > the
>>> >> >> > object.  It requires the same mechanisms that the rest of the
>>> >> >> > class
>>> >> >> > uses
>>> >> >> > to
>>> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>>> >> >> > executing
>>> >> >> > the
>>> >> >> > constructor, a proper releasing of a lock or some other
>>> >> >> > happens-before
>>> >> >> > construct is required to ensure that the memory updates by the
>>> >> >> > thread
>>> >> >> > are
>>> >> >> > made globally visible before the object is accessed by another
>>> >> >> > thread.
>>> >> >> > This
>>> >> >> > is what we are calling safe publication.  So, safe publication is
>>> >> >> > a
>>> >> >> > subset
>>> >> >> > of thread-safety except it is limited to what happens after the
>>> >> >> > constructor
>>> >> >> > is called and before the object is used by multiple threads.
>>> >> >> >
>>> >> >> > A beautifully-written class can be thread-safe with respect to
>>> >> >> > calling
>>> >> >> > its
>>> >> >> > member methods but not thread-safe with respect to calling its
>>> >> >> > constructor.
>>> >> >> > It is this latter case that many stumble upon because they think
>>> >> >> > that
>>> >> >> > constructors are inherently thread-safe because they are executed
>>> >> >> > single-threadedly.  What they fail to realize is that the
>>> >> >> > execution
>>> >> >> > of a
>>> >> >> > constructor can overlap with the execution of other code from the
>>> >> >> > view
>>> >> >> > point
>>> >> >> > of what is happening in memory.  This same problem applies to
>>> >> >> > more
>>> >> >> > rare
>>> >> >> > case
>>> >> >> > of regular methods which can be proven to execute in a single
>>> >> >> > thread
>>> >> >> > but
>>> >> >> > don't use synchronization before multiple threads start accessing
>>> >> >> > the
>>> >> >> > shared
>>> >> >> > data.
>>> >> >> >
>>> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>>> >> >> > 602.333.9091
>>> >> >> > Oracle PSR Engineering | Server Technology
>>> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
>>> >> >> >
>>> >> >> > Ruslan Cheremin writes:
>>> >> >> >
>>> >> >> > For me it is confusing: java has only one way to have really
>>> >> >> > immutable
>>> >> >> > object, and this way also gives you a total thread safety even
>>> >> >> > for
>>> >> >> > data race based publication. But then docs refer object as
>>> >> >> > "immutable
>>> >> >> > and thread-safe" -- we still can't assume it to be really
>>> >> >> > thread-safe?
>>> >> >> >
>>> >> >> > It is better/simpler to isolate the notion of thread-safety and
>>> >> >> > safe
>>> >> >> > publication. Thread-safety comes into play after you have safely
>>> >> >> > shared
>>> >> >> > an
>>> >> >> > object. The means by which you safely share an object is
>>> >> >> > orthogonal
>>> >> >> > to
>>> >> >> > how
>>> >> >> > the object itself is made thread-safe.
>>> >> >> >
>>> >> >> > The means by which an object is shared has to involve shared
>>> >> >> > mutable
>>> >> >> > state,
>>> >> >> > and use of shared mutable state always needs some form of
>>> >> >> > synchronization
>>> >> >> > (either implicit eg due to static initialization; or explicit by
>>> >> >> > using
>>> >> >> > volatile or synchronized getter/setter methods).
>>> >> >> >
>>> >> >> > David
>>> >> >> > -----
>>> >> >> >
>>> >> >> > It's a pity, especially because true immutability gives us some
>>> >> >> > chances of performance optimization. As in this case -- we do not
>>> >> >> > really need .path to be volatile here, if we would assume Path to
>>> >> >> > be
>>> >> >> > truly immutable. volatility here required only for ensuring safe
>>> >> >> > publishing.
>>> >> >> >
>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>> >> >> >
>>> >> >> > Ruslan Cheremin writes:>
>>> >> >> >
>>> >> >> > But is there a way to define "safe for data race publishing"? I
>>> >> >> > as
>>> >> >> > far, as I remember, "immutable and thread-safe" is standard
>>> >> >> > mantra
>>> >> >> > in
>>> >> >> > JDK javadocs for totally safe objects. j.l.String has same mantra
>>> >> >> > --
>>> >> >> > and it is safe for any way of publishing. Does you mean, I should
>>> >> >> > explicitly add "safe even for publishing via data race" in docs?
>>> >> >> > But
>>> >> >> > I
>>> >> >> > can't remember any such phrase in JDK docs.
>>> >> >> >
>>> >> >> > I don't recall anything in the JDK docs that mention being
>>> >> >> >
>>> >> >> > "totally safe"
>>> >> >> >
>>> >> >> > regardless of publication mechanism. Some classes, eg String,
>>> >> >> > have
>>> >> >> > been
>>> >> >> > defined such that they do have that property (for security
>>> >> >> > reasons).
>>> >> >> > In
>>> >> >> > general neither "thread-safe" nor "immutable" imply
>>> >> >> > safe-for-unsynchronized-publication.
>>> >> >> >
>>> >> >> > Java Concurrency In Practice (jcip.net) does define additional
>>> >> >> > potential
>>> >> >> > annotations, where @Immutable would indeed capture the
>>> >> >> > requirement
>>> >> >> > of
>>> >> >> > safe-for-unsynchronized-publication.
>>> >> >> >
>>> >> >> > David
>>> >> >> > -----
>>> >> >> >
>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>> >> >> >
>>> >> >> > Ruslan Cheremin writes:
>>> >> >> >
>>> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>>> >> >> > multithreaded use". Although it is not strictly defined in java
>>> >> >> > what
>>> >> >> > exactly means "safe for multithreaded use" -- does it mean safe
>>> >> >> > for
>>> >> >> > publishing via data race, among others? -- I suppose, it
>>> >> >> >
>>> >> >> > should be. Am
>>> >> >> >
>>> >> >> > I wrong here?
>>> >> >> >
>>> >> >> > "safe for multi-threaded use" does not generally imply that it
>>> >> >> >
>>> >> >> > is safe to
>>> >> >> >
>>> >> >> > publish instances without synchronization of some form.
>>> >> >> >
>>> >> >> > David
>>> >> >> > -----
>>> >> >> >
>>> >> >> > From other side, File.toPath javadoc explicitly says what
>>> >> >> > "returned
>>> >> >> > instance must be the same for every invocation", so sync block is
>>> >> >> > required here for mutual exclusion on initialization phase.
>>> >> >> > Without
>>> >> >> > this requirement it is also safe to live without sync block,
>>> >> >> > afaik.
>>> >> >> >
>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>> >> >> >
>>> >> >> > Ruslan Cheremin writes:
>>> >> >> >
>>> >> >> > First of all, Path is immutable, so DCL is safe here even without
>>> >> >> > volatile. Volatile here is not required from my point of view.
>>> >> >> >
>>> >> >> > Without the volatile the Path implementation (Path is an
>>> >> >> >
>>> >> >> > interface) must be
>>> >> >> >
>>> >> >> > such that an instance of Path can be safely published without
>>> >> >> >
>>> >> >> > any additional
>>> >> >> >
>>> >> >> > forms of synchronization. Immutability does not in itself
>>> >> >> >
>>> >> >> > ensure that. You
>>> >> >> >
>>> >> >> > would have to examine the actual implementation class.
>>> >> >> >
>>> >> >> > David Holmes
>>> >> >> > ------------
>>> >> >> >
>>> >> >> >
>>> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>>> >> >> >
>>> >> >> > Hi Richard,
>>> >> >> >
>>> >> >> > The variable "filePath" is volatile, so the double-checked
>>> >> >> >
>>> >> >> > locking is correct in this case. It would have been a bug
>>> >> >> >
>>> >> >> > prior to Java 5.
>>> >> >> >
>>> >> >> > Best regards,
>>> >> >> >
>>> >> >> > Dmitry Vyazelenko
>>> >> >> >
>>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>>> >> >> >
>>> >> >> > <richard.warburton at gmail.com> wrote:
>>> >> >> >
>>> >> >> > Hello,
>>> >> >> >
>>> >> >> > The current implementation of java.io.File::toPath [0]
>>> >> >> >
>>> >> >> > appears to be
>>> >> >> >
>>> >> >> > using the double checked locking pattern:
>>> >> >> >
>>> >> >> >     public Path toPath() {
>>> >> >> >         Path result = filePath;
>>> >> >> >         if (result == null) {
>>> >> >> >             synchronized (this) {
>>> >> >> >                 result = filePath;
>>> >> >> >                 if (result == null) {
>>> >> >> >                     result =
>>> >> >> >
>>> >> >> > FileSystems.getDefault().getPath(path);
>>> >> >> >
>>> >> >> >                     filePath = result;
>>> >> >> >                 }
>>> >> >> >             }
>>> >> >> >         }
>>> >> >> >         return result;
>>> >> >> >     }
>>> >> >> >
>>> >> >> > I was going to report the bug, but I'm a little
>>> >> >> >
>>> >> >> > uncertain of the
>>> >> >> >
>>> >> >> > interaction between the local variable 'result' and DCL
>>> >> >> >
>>> >> >> > since I've
>>> >> >> >
>>> >> >> > previously only seen the checking condition on the
>>> >> >> >
>>> >> >> > shared field
>>> >> >> >
>>> >> >> > itself.  Can someone here either confirm that its a bug or
>>> >> >> >
>>> >> >> > explain how
>>> >> >> >
>>> >> >> > the 'result' variable is fixing things?
>>> >> >> >
>>> >> >> > regards,
>>> >> >> >
>>> >> >> >  Richard
>>> >> >> >
>>> >> >> > [0] See the end of
>>> >> >> >
>>> >> >> >
>>> >> >> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>>> >> >> >
>>> >> >> > ses/java/io/File.java
>>> >> >> >
>>> >> >> > _______________________________________________
>>> >> >> > Concurrency-interest mailing list
>>> >> >> > Concurrency-interest at cs.oswego.edu
>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >> >> >
>>> >> >> > _______________________________________________
>>> >> >> > Concurrency-interest mailing list
>>> >> >> > Concurrency-interest at cs.oswego.edu
>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >> >> >
>>> >> >> > _______________________________________________
>>> >> >> > Concurrency-interest mailing list
>>> >> >> > Concurrency-interest at cs.oswego.edu
>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >> >> >
>>> >> >> > _______________________________________________
>>> >> >> > Concurrency-interest mailing list
>>> >> >> > Concurrency-interest at cs.oswego.edu
>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >> >> >
>>> >> >> >
>>> >> >> >
>>> >> >> > _______________________________________________
>>> >> >> > Concurrency-interest mailing list
>>> >> >> > Concurrency-interest at cs.oswego.edu
>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >> >> >
>>> >> >> _______________________________________________
>>> >> >> Concurrency-interest mailing list
>>> >> >> Concurrency-interest at cs.oswego.edu
>>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From hans.boehm at hp.com  Tue Aug 14 21:31:41 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 15 Aug 2012 01:31:41 +0000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqEhBXCaE190T0P2RahrzjTFYX_Tw+T6U=mUnxF3+r3mMg@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6036C@G4W3296.americas.hpqcorp.net>
	<CACuKZqEhBXCaE190T0P2RahrzjTFYX_Tw+T6U=mUnxF3+r3mMg@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60474@G4W3296.americas.hpqcorp.net>

Good point.  It may be unavoidable in some cases.  (And I think we need an annotation to have data race checkers ignore such things.)  But it still strikes me as quite brittle, and not something most programmers should be playing with:

1. We know the current JMM semantics for data races are not correct.  We don't really know what the correct semantics are.  Probably this idiom won't break with standard compilers.  But we've been surprised before.

2. Its correctness relies on very subtle properties of the interface to the lazily initialized object.  If we have a get() method that lazily initializes and returns a field, I think it's crucial that the caller of get() has no way to tell whether it was the initializing thread, or whether another thread was.  Otherwise the absence of sequential consistency becomes apparent to the caller.  Adding an is_initialized() method breaks things in similar ways. 

If this were undetectable on 99.99% of systems, I would certainly argue against it.  But I'm not sure that's true on current ARM systems.  (It is on x86.) Nonetheless, I think it only makes sense only if there are good reasons to believe it may be performance critical.

Hans

> -----Original Message-----
> From: Zhong Yu [mailto:zhong.j.yu at gmail.com]
> Sent: Tuesday, August 14, 2012 5:46 PM
> To: Boehm, Hans
> Cc: Vitaly Davidovich; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> 
> Lazy initialization is a common use case. Using thread-safe immutable
> objects to avoid a `volatile` read is simple and well understood,
> though it contains data race. I would say it is a common, useful and
> justifiable data race.
> 
> You can argue that a volatile read isn't that expensive, lazy
> initialization with volatile variable won't have any detectable
> performance degrading on 99.99% systems. That may be true. But we
> don't justify each choice of a concurrency tool by "profiling/testing"
> real world scenario - seriously, who can afford that?
> 
> Zhong Yu
> 
> On Tue, Aug 14, 2012 at 7:01 PM, Boehm, Hans <hans.boehm at hp.com> wrote:
> > Indeed.  My view is that we need special final field semantics
> primarily to
> > deal with untrusted code, where you don't have the control to
> guarantee
> > there are no data races.  There has to be a way for untrusted code to
> pass a
> > string to a library in a way that guarantees the string won't change
> between
> > the time a security manager looks at it and the time it's used as a
> file
> > name.  Thus we have to be able to construct classes that are fully
> > immutable, no matter how badly the client mistreats them.  Final
> fields give
> > you a way to do that without adding tons of overhead to a class like
> String.
> >
> >
> >
> > If you can avoid data races, do.
> >
> >
> >
> > Hans
> >
> >
> >
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of
> Vitaly
> > Davidovich
> > Sent: Tuesday, August 14, 2012 3:36 PM
> > To: Zhong Yu
> > Cc: concurrency-interest at cs.oswego.edu
> >
> >
> > Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> >
> >
> >
> > I think the lesson should be avoid data races - period. :) if you
> find a
> > case where you can justify it (i.e. profiling/testing guided) then
> consider
> > it.  I bet there will be few and far in between cases like that.
> >
> > Sent from my phone
> >
> > On Aug 14, 2012 5:02 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >
> > Lesson I learned from this thread:
> >
> > do *not* write thread-safe immutable class, unless there's a good
> reason.
> >
> > One good reason is double checked locking without volatile.
> >
> > Zhong Yu
> >
> > On Tue, Aug 14, 2012 at 3:09 PM, Vitaly Davidovich
> <vitalyd at gmail.com>
> > wrote:
> >> You should use final for its semantic meaning/code clarity unless
> you
> >> yourself are publishing it unsafely in your library.  If users of
> your lib
> >> are sharing this class, they need to provide the required
> >> synchronization/hand off.  That's my personal view (and I always try
> to
> >> use
> >> final as much as possible, but mostly for clarity/code semantics).
> >>
> >> For people running the jvm on an arch where final is not just
> compiler
> >> barrier, I agree it's a bit of a problem - really, final should not
> carry
> >> both java semantic and JMM meaning, but I can see why that was done.
> >>
> >> Sent from my phone
> >>
> >> On Aug 14, 2012 3:58 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >>>
> >>> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich
> <vitalyd at gmail.com>
> >>> wrote:
> >>> > Yes, presumably on some archs with very weak memory order it
> could
> >>> > cause
> >>> > some performance impact.  On TSO, it's just a compiler barrier
> >>> > preventing
> >>> > code motion that would publish the reference before constructor
> >>> > completes,
> >>> > but on those weak archs it could also mean a hardware fence.
> Whether
> >>> > the
> >>> > tradeoff is worth it in general or not is debatable.  You can't
> have it
> >>> > both
> >>> > ways, I agree, but the jvm and JMM give you options and guidance
> on how
> >>> > to
> >>> > do the "right" thing.
> >>>
> >>> If I'm writing a Java library, containing a Point(x,y) class, which
> is
> >>> immutable (in the narrower sense), should I use final fields or
> not?
> >>> What's the "right" thing to do?
> >>>
> >>> If the answer is platform dependent, oh well.
> >>>
> >>> Zhong Yu
> >>>
> >>> >
> >>> > Sent from my phone
> >>> >
> >>> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
> >>> >>
> >>> >> Are `final` fields a problem to compiler optimization?
> >>> >>
> >>> >> You can't have both ways.
> >>> >>
> >>> >> Either `final` field semantics is good and cheap, therefore it
> should
> >>> >> be extended to all fields.
> >>> >>
> >>> >> Or there is some downsides with 'final' field semantics, so we
> >>> >> shouldn't encourage people to apply `final` whenever they can.
> Lets
> >>> >> hear those downsides.
> >>> >>
> >>> >> Zhong Yu
> >>> >>
> >>> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich
> <vitalyd at gmail.com>
> >>> >> wrote:
> >>> >> > This is only an issue when publishing unsafely.  Allowing
> treating
> >>> >> > constructors as regular methods is a good thing as it gives
> the
> >>> >> > compiler
> >>> >> > a
> >>> >> > chance to optimize code, which everyone likes and benefits
> from.
> >>> >> >
> >>> >> > Sent from my phone
> >>> >> >
> >>> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com>
> wrote:
> >>> >> >>
> >>> >> >> From a user's point of view, shouldn't constructors be
> special
> >>> >> >> though?
> >>> >> >> An object shouldn't be considered in existence until its
> >>> >> >> construction
> >>> >> >> is done; it is pathological that some outsider can observe a
> >>> >> >> partially
> >>> >> >> constructed object. Life is simpler if we can eliminate that
> >>> >> >> possibility (unless `this` is leaked inside constructor)
> >>> >> >>
> >>> >> >> Zhong Yu
> >>> >> >>
> >>> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
> >>> >> >> <nathan.reynolds at oracle.com> wrote:
> >>> >> >> > We seem to be splitting two notions (i.e thread-safe and
> safe
> >>> >> >> > publication)
> >>> >> >> > when they should be combined in a sense.  Typically, when
> we say
> >>> >> >> > thread-safe
> >>> >> >> > we talk about the operations performed on the object after
> it was
> >>> >> >> > constructed (and its contents are globally visible).
> However, we
> >>> >> >> > need
> >>> >> >> > to
> >>> >> >> > consider that executing the constructor is modifying the
> state of
> >>> >> >> > the
> >>> >> >> > object.  It requires the same mechanisms that the rest of
> the
> >>> >> >> > class
> >>> >> >> > uses
> >>> >> >> > to
> >>> >> >> > ensure thread-safety.  Even though, there is only 1 thread
> >>> >> >> > executing
> >>> >> >> > the
> >>> >> >> > constructor, a proper releasing of a lock or some other
> >>> >> >> > happens-before
> >>> >> >> > construct is required to ensure that the memory updates by
> the
> >>> >> >> > thread
> >>> >> >> > are
> >>> >> >> > made globally visible before the object is accessed by
> another
> >>> >> >> > thread.
> >>> >> >> > This
> >>> >> >> > is what we are calling safe publication.  So, safe
> publication is
> >>> >> >> > a
> >>> >> >> > subset
> >>> >> >> > of thread-safety except it is limited to what happens after
> the
> >>> >> >> > constructor
> >>> >> >> > is called and before the object is used by multiple
> threads.
> >>> >> >> >
> >>> >> >> > A beautifully-written class can be thread-safe with respect
> to
> >>> >> >> > calling
> >>> >> >> > its
> >>> >> >> > member methods but not thread-safe with respect to calling
> its
> >>> >> >> > constructor.
> >>> >> >> > It is this latter case that many stumble upon because they
> think
> >>> >> >> > that
> >>> >> >> > constructors are inherently thread-safe because they are
> executed
> >>> >> >> > single-threadedly.  What they fail to realize is that the
> >>> >> >> > execution
> >>> >> >> > of a
> >>> >> >> > constructor can overlap with the execution of other code
> from the
> >>> >> >> > view
> >>> >> >> > point
> >>> >> >> > of what is happening in memory.  This same problem applies
> to
> >>> >> >> > more
> >>> >> >> > rare
> >>> >> >> > case
> >>> >> >> > of regular methods which can be proven to execute in a
> single
> >>> >> >> > thread
> >>> >> >> > but
> >>> >> >> > don't use synchronization before multiple threads start
> accessing
> >>> >> >> > the
> >>> >> >> > shared
> >>> >> >> > data.
> >>> >> >> >
> >>> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> >>> >> >> > 602.333.9091
> >>> >> >> > Oracle PSR Engineering | Server Technology
> >>> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >>> >> >> >
> >>> >> >> > Ruslan Cheremin writes:
> >>> >> >> >
> >>> >> >> > For me it is confusing: java has only one way to have
> really
> >>> >> >> > immutable
> >>> >> >> > object, and this way also gives you a total thread safety
> even
> >>> >> >> > for
> >>> >> >> > data race based publication. But then docs refer object as
> >>> >> >> > "immutable
> >>> >> >> > and thread-safe" -- we still can't assume it to be really
> >>> >> >> > thread-safe?
> >>> >> >> >
> >>> >> >> > It is better/simpler to isolate the notion of thread-safety
> and
> >>> >> >> > safe
> >>> >> >> > publication. Thread-safety comes into play after you have
> safely
> >>> >> >> > shared
> >>> >> >> > an
> >>> >> >> > object. The means by which you safely share an object is
> >>> >> >> > orthogonal
> >>> >> >> > to
> >>> >> >> > how
> >>> >> >> > the object itself is made thread-safe.
> >>> >> >> >
> >>> >> >> > The means by which an object is shared has to involve
> shared
> >>> >> >> > mutable
> >>> >> >> > state,
> >>> >> >> > and use of shared mutable state always needs some form of
> >>> >> >> > synchronization
> >>> >> >> > (either implicit eg due to static initialization; or
> explicit by
> >>> >> >> > using
> >>> >> >> > volatile or synchronized getter/setter methods).
> >>> >> >> >
> >>> >> >> > David
> >>> >> >> > -----
> >>> >> >> >
> >>> >> >> > It's a pity, especially because true immutability gives us
> some
> >>> >> >> > chances of performance optimization. As in this case -- we
> do not
> >>> >> >> > really need .path to be volatile here, if we would assume
> Path to
> >>> >> >> > be
> >>> >> >> > truly immutable. volatility here required only for ensuring
> safe
> >>> >> >> > publishing.
> >>> >> >> >
> >>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >>> >> >> >
> >>> >> >> > Ruslan Cheremin writes:>
> >>> >> >> >
> >>> >> >> > But is there a way to define "safe for data race
> publishing"? I
> >>> >> >> > as
> >>> >> >> > far, as I remember, "immutable and thread-safe" is standard
> >>> >> >> > mantra
> >>> >> >> > in
> >>> >> >> > JDK javadocs for totally safe objects. j.l.String has same
> mantra
> >>> >> >> > --
> >>> >> >> > and it is safe for any way of publishing. Does you mean, I
> should
> >>> >> >> > explicitly add "safe even for publishing via data race" in
> docs?
> >>> >> >> > But
> >>> >> >> > I
> >>> >> >> > can't remember any such phrase in JDK docs.
> >>> >> >> >
> >>> >> >> > I don't recall anything in the JDK docs that mention being
> >>> >> >> >
> >>> >> >> > "totally safe"
> >>> >> >> >
> >>> >> >> > regardless of publication mechanism. Some classes, eg
> String,
> >>> >> >> > have
> >>> >> >> > been
> >>> >> >> > defined such that they do have that property (for security
> >>> >> >> > reasons).
> >>> >> >> > In
> >>> >> >> > general neither "thread-safe" nor "immutable" imply
> >>> >> >> > safe-for-unsynchronized-publication.
> >>> >> >> >
> >>> >> >> > Java Concurrency In Practice (jcip.net) does define
> additional
> >>> >> >> > potential
> >>> >> >> > annotations, where @Immutable would indeed capture the
> >>> >> >> > requirement
> >>> >> >> > of
> >>> >> >> > safe-for-unsynchronized-publication.
> >>> >> >> >
> >>> >> >> > David
> >>> >> >> > -----
> >>> >> >> >
> >>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >>> >> >> >
> >>> >> >> > Ruslan Cheremin writes:
> >>> >> >> >
> >>> >> >> > Well, Path javadoc explicitly says "immutable and safe for
> >>> >> >> > multithreaded use". Although it is not strictly defined in
> java
> >>> >> >> > what
> >>> >> >> > exactly means "safe for multithreaded use" -- does it mean
> safe
> >>> >> >> > for
> >>> >> >> > publishing via data race, among others? -- I suppose, it
> >>> >> >> >
> >>> >> >> > should be. Am
> >>> >> >> >
> >>> >> >> > I wrong here?
> >>> >> >> >
> >>> >> >> > "safe for multi-threaded use" does not generally imply that
> it
> >>> >> >> >
> >>> >> >> > is safe to
> >>> >> >> >
> >>> >> >> > publish instances without synchronization of some form.
> >>> >> >> >
> >>> >> >> > David
> >>> >> >> > -----
> >>> >> >> >
> >>> >> >> > From other side, File.toPath javadoc explicitly says what
> >>> >> >> > "returned
> >>> >> >> > instance must be the same for every invocation", so sync
> block is
> >>> >> >> > required here for mutual exclusion on initialization phase.
> >>> >> >> > Without
> >>> >> >> > this requirement it is also safe to live without sync
> block,
> >>> >> >> > afaik.
> >>> >> >> >
> >>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >>> >> >> >
> >>> >> >> > Ruslan Cheremin writes:
> >>> >> >> >
> >>> >> >> > First of all, Path is immutable, so DCL is safe here even
> without
> >>> >> >> > volatile. Volatile here is not required from my point of
> view.
> >>> >> >> >
> >>> >> >> > Without the volatile the Path implementation (Path is an
> >>> >> >> >
> >>> >> >> > interface) must be
> >>> >> >> >
> >>> >> >> > such that an instance of Path can be safely published
> without
> >>> >> >> >
> >>> >> >> > any additional
> >>> >> >> >
> >>> >> >> > forms of synchronization. Immutability does not in itself
> >>> >> >> >
> >>> >> >> > ensure that. You
> >>> >> >> >
> >>> >> >> > would have to examine the actual implementation class.
> >>> >> >> >
> >>> >> >> > David Holmes
> >>> >> >> > ------------
> >>> >> >> >
> >>> >> >> >
> >>> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >>> >> >> >
> >>> >> >> > Hi Richard,
> >>> >> >> >
> >>> >> >> > The variable "filePath" is volatile, so the double-checked
> >>> >> >> >
> >>> >> >> > locking is correct in this case. It would have been a bug
> >>> >> >> >
> >>> >> >> > prior to Java 5.
> >>> >> >> >
> >>> >> >> > Best regards,
> >>> >> >> >
> >>> >> >> > Dmitry Vyazelenko
> >>> >> >> >
> >>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >>> >> >> >
> >>> >> >> > <richard.warburton at gmail.com> wrote:
> >>> >> >> >
> >>> >> >> > Hello,
> >>> >> >> >
> >>> >> >> > The current implementation of java.io.File::toPath [0]
> >>> >> >> >
> >>> >> >> > appears to be
> >>> >> >> >
> >>> >> >> > using the double checked locking pattern:
> >>> >> >> >
> >>> >> >> >     public Path toPath() {
> >>> >> >> >         Path result = filePath;
> >>> >> >> >         if (result == null) {
> >>> >> >> >             synchronized (this) {
> >>> >> >> >                 result = filePath;
> >>> >> >> >                 if (result == null) {
> >>> >> >> >                     result =
> >>> >> >> >
> >>> >> >> > FileSystems.getDefault().getPath(path);
> >>> >> >> >
> >>> >> >> >                     filePath = result;
> >>> >> >> >                 }
> >>> >> >> >             }
> >>> >> >> >         }
> >>> >> >> >         return result;
> >>> >> >> >     }
> >>> >> >> >
> >>> >> >> > I was going to report the bug, but I'm a little
> >>> >> >> >
> >>> >> >> > uncertain of the
> >>> >> >> >
> >>> >> >> > interaction between the local variable 'result' and DCL
> >>> >> >> >
> >>> >> >> > since I've
> >>> >> >> >
> >>> >> >> > previously only seen the checking condition on the
> >>> >> >> >
> >>> >> >> > shared field
> >>> >> >> >
> >>> >> >> > itself.  Can someone here either confirm that its a bug or
> >>> >> >> >
> >>> >> >> > explain how
> >>> >> >> >
> >>> >> >> > the 'result' variable is fixing things?
> >>> >> >> >
> >>> >> >> > regards,
> >>> >> >> >
> >>> >> >> >  Richard
> >>> >> >> >
> >>> >> >> > [0] See the end of
> >>> >> >> >
> >>> >> >> >
> >>> >> >> >
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >>> >> >> >
> >>> >> >> > ses/java/io/File.java
> >>> >> >> >
> >>> >> >> > _______________________________________________
> >>> >> >> > Concurrency-interest mailing list
> >>> >> >> > Concurrency-interest at cs.oswego.edu
> >>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>> >> >> >
> >>> >> >> > _______________________________________________
> >>> >> >> > Concurrency-interest mailing list
> >>> >> >> > Concurrency-interest at cs.oswego.edu
> >>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>> >> >> >
> >>> >> >> > _______________________________________________
> >>> >> >> > Concurrency-interest mailing list
> >>> >> >> > Concurrency-interest at cs.oswego.edu
> >>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>> >> >> >
> >>> >> >> > _______________________________________________
> >>> >> >> > Concurrency-interest mailing list
> >>> >> >> > Concurrency-interest at cs.oswego.edu
> >>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>> >> >> >
> >>> >> >> >
> >>> >> >> >
> >>> >> >> > _______________________________________________
> >>> >> >> > Concurrency-interest mailing list
> >>> >> >> > Concurrency-interest at cs.oswego.edu
> >>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>> >> >> >
> >>> >> >> _______________________________________________
> >>> >> >> Concurrency-interest mailing list
> >>> >> >> Concurrency-interest at cs.oswego.edu
> >>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From jwesleysmith at atlassian.com  Wed Aug 15 02:22:53 2012
From: jwesleysmith at atlassian.com (Jed Wesley-Smith)
Date: Wed, 15 Aug 2012 16:22:53 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqEhBXCaE190T0P2RahrzjTFYX_Tw+T6U=mUnxF3+r3mMg@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCEEBBJGAA.davidcholmes@aapt.net.au>
	<502A9FF0.2000904@oracle.com>
	<CACuKZqHFD7x8Ax+_RvLh8zE0Ly9+bKSZ4KY-SrsHDha1ZzFGUQ@mail.gmail.com>
	<CAHjP37E-aCL5up6_5xZu6ejkaFY6gfv9bf1mPCdV6sn3Z2=FmQ@mail.gmail.com>
	<CACuKZqGFCEYYwKN382am+kSOh+QXu-tLRL1fBciuTANju-QSBA@mail.gmail.com>
	<CAHjP37FKFEPrXTkTPq=GZq_1zTetBNRK13C3WyFXRe4cH=M=nQ@mail.gmail.com>
	<CACuKZqEWaM0izXMx8G=DTi3O=mDAws92VTW=YkpCjVtqqVH8-Q@mail.gmail.com>
	<CAHjP37GxXkgjjqsNSRAmmXf+RBieQU8LONeB2qDV6he9MPg0EA@mail.gmail.com>
	<CACuKZqH1CAcrcx7hfjzF0PM6w81h0sCq=81YUpZQBX_Woc8VAw@mail.gmail.com>
	<CAHjP37FBa88X+nspyxMrnCzRv_Q2kMV-K7TAPd5ZTtqzSz3ntQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6036C@G4W3296.americas.hpqcorp.net>
	<CACuKZqEhBXCaE190T0P2RahrzjTFYX_Tw+T6U=mUnxF3+r3mMg@mail.gmail.com>
Message-ID: <CAKh+yi9kTJzf=Er-XSsTBVeXQFZAP_spcWZMr0nVXjZWZV5WDQ@mail.gmail.com>

For lazy initialization it'd be nice to have something similar to:

https://bitbucket.org/atlassian/atlassian-util-concurrent/src/master/src/main/java/com/atlassian/util/concurrent/LazyReference.java

available as standard lib (caveat, I wrote that).

This avoids needing to worry about the implementation detail, you
basically specify the semantics.

cheers,
jed.

On 15 August 2012 10:46, Zhong Yu <zhong.j.yu at gmail.com> wrote:
> Lazy initialization is a common use case. Using thread-safe immutable
> objects to avoid a `volatile` read is simple and well understood,
> though it contains data race. I would say it is a common, useful and
> justifiable data race.
>
> You can argue that a volatile read isn't that expensive, lazy
> initialization with volatile variable won't have any detectable
> performance degrading on 99.99% systems. That may be true. But we
> don't justify each choice of a concurrency tool by "profiling/testing"
> real world scenario - seriously, who can afford that?
>
> Zhong Yu
>
> On Tue, Aug 14, 2012 at 7:01 PM, Boehm, Hans <hans.boehm at hp.com> wrote:
>> Indeed.  My view is that we need special final field semantics primarily to
>> deal with untrusted code, where you don?t have the control to guarantee
>> there are no data races.  There has to be a way for untrusted code to pass a
>> string to a library in a way that guarantees the string won?t change between
>> the time a security manager looks at it and the time it?s used as a file
>> name.  Thus we have to be able to construct classes that are fully
>> immutable, no matter how badly the client mistreats them.  Final fields give
>> you a way to do that without adding tons of overhead to a class like String.
>>
>>
>>
>> If you can avoid data races, do.
>>
>>
>>
>> Hans
>>
>>
>>
>> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Vitaly
>> Davidovich
>> Sent: Tuesday, August 14, 2012 3:36 PM
>> To: Zhong Yu
>> Cc: concurrency-interest at cs.oswego.edu
>>
>>
>> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>>
>>
>>
>> I think the lesson should be avoid data races - period. :) if you find a
>> case where you can justify it (i.e. profiling/testing guided) then consider
>> it.  I bet there will be few and far in between cases like that.
>>
>> Sent from my phone
>>
>> On Aug 14, 2012 5:02 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>
>> Lesson I learned from this thread:
>>
>> do *not* write thread-safe immutable class, unless there's a good reason.
>>
>> One good reason is double checked locking without volatile.
>>
>> Zhong Yu
>>
>> On Tue, Aug 14, 2012 at 3:09 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>>> You should use final for its semantic meaning/code clarity unless you
>>> yourself are publishing it unsafely in your library.  If users of your lib
>>> are sharing this class, they need to provide the required
>>> synchronization/hand off.  That's my personal view (and I always try to
>>> use
>>> final as much as possible, but mostly for clarity/code semantics).
>>>
>>> For people running the jvm on an arch where final is not just compiler
>>> barrier, I agree it's a bit of a problem - really, final should not carry
>>> both java semantic and JMM meaning, but I can see why that was done.
>>>
>>> Sent from my phone
>>>
>>> On Aug 14, 2012 3:58 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>>>
>>>> On Tue, Aug 14, 2012 at 2:52 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>>> wrote:
>>>> > Yes, presumably on some archs with very weak memory order it could
>>>> > cause
>>>> > some performance impact.  On TSO, it's just a compiler barrier
>>>> > preventing
>>>> > code motion that would publish the reference before constructor
>>>> > completes,
>>>> > but on those weak archs it could also mean a hardware fence.  Whether
>>>> > the
>>>> > tradeoff is worth it in general or not is debatable.  You can't have it
>>>> > both
>>>> > ways, I agree, but the jvm and JMM give you options and guidance on how
>>>> > to
>>>> > do the "right" thing.
>>>>
>>>> If I'm writing a Java library, containing a Point(x,y) class, which is
>>>> immutable (in the narrower sense), should I use final fields or not?
>>>> What's the "right" thing to do?
>>>>
>>>> If the answer is platform dependent, oh well.
>>>>
>>>> Zhong Yu
>>>>
>>>> >
>>>> > Sent from my phone
>>>> >
>>>> > On Aug 14, 2012 3:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>>> >>
>>>> >> Are `final` fields a problem to compiler optimization?
>>>> >>
>>>> >> You can't have both ways.
>>>> >>
>>>> >> Either `final` field semantics is good and cheap, therefore it should
>>>> >> be extended to all fields.
>>>> >>
>>>> >> Or there is some downsides with 'final' field semantics, so we
>>>> >> shouldn't encourage people to apply `final` whenever they can. Lets
>>>> >> hear those downsides.
>>>> >>
>>>> >> Zhong Yu
>>>> >>
>>>> >> On Tue, Aug 14, 2012 at 2:42 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>>> >> wrote:
>>>> >> > This is only an issue when publishing unsafely.  Allowing treating
>>>> >> > constructors as regular methods is a good thing as it gives the
>>>> >> > compiler
>>>> >> > a
>>>> >> > chance to optimize code, which everyone likes and benefits from.
>>>> >> >
>>>> >> > Sent from my phone
>>>> >> >
>>>> >> > On Aug 14, 2012 3:39 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>>>> >> >>
>>>> >> >> From a user's point of view, shouldn't constructors be special
>>>> >> >> though?
>>>> >> >> An object shouldn't be considered in existence until its
>>>> >> >> construction
>>>> >> >> is done; it is pathological that some outsider can observe a
>>>> >> >> partially
>>>> >> >> constructed object. Life is simpler if we can eliminate that
>>>> >> >> possibility (unless `this` is leaked inside constructor)
>>>> >> >>
>>>> >> >> Zhong Yu
>>>> >> >>
>>>> >> >> On Tue, Aug 14, 2012 at 1:58 PM, Nathan Reynolds
>>>> >> >> <nathan.reynolds at oracle.com> wrote:
>>>> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
>>>> >> >> > publication)
>>>> >> >> > when they should be combined in a sense.  Typically, when we say
>>>> >> >> > thread-safe
>>>> >> >> > we talk about the operations performed on the object after it was
>>>> >> >> > constructed (and its contents are globally visible).  However, we
>>>> >> >> > need
>>>> >> >> > to
>>>> >> >> > consider that executing the constructor is modifying the state of
>>>> >> >> > the
>>>> >> >> > object.  It requires the same mechanisms that the rest of the
>>>> >> >> > class
>>>> >> >> > uses
>>>> >> >> > to
>>>> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>>>> >> >> > executing
>>>> >> >> > the
>>>> >> >> > constructor, a proper releasing of a lock or some other
>>>> >> >> > happens-before
>>>> >> >> > construct is required to ensure that the memory updates by the
>>>> >> >> > thread
>>>> >> >> > are
>>>> >> >> > made globally visible before the object is accessed by another
>>>> >> >> > thread.
>>>> >> >> > This
>>>> >> >> > is what we are calling safe publication.  So, safe publication is
>>>> >> >> > a
>>>> >> >> > subset
>>>> >> >> > of thread-safety except it is limited to what happens after the
>>>> >> >> > constructor
>>>> >> >> > is called and before the object is used by multiple threads.
>>>> >> >> >
>>>> >> >> > A beautifully-written class can be thread-safe with respect to
>>>> >> >> > calling
>>>> >> >> > its
>>>> >> >> > member methods but not thread-safe with respect to calling its
>>>> >> >> > constructor.
>>>> >> >> > It is this latter case that many stumble upon because they think
>>>> >> >> > that
>>>> >> >> > constructors are inherently thread-safe because they are executed
>>>> >> >> > single-threadedly.  What they fail to realize is that the
>>>> >> >> > execution
>>>> >> >> > of a
>>>> >> >> > constructor can overlap with the execution of other code from the
>>>> >> >> > view
>>>> >> >> > point
>>>> >> >> > of what is happening in memory.  This same problem applies to
>>>> >> >> > more
>>>> >> >> > rare
>>>> >> >> > case
>>>> >> >> > of regular methods which can be proven to execute in a single
>>>> >> >> > thread
>>>> >> >> > but
>>>> >> >> > don't use synchronization before multiple threads start accessing
>>>> >> >> > the
>>>> >> >> > shared
>>>> >> >> > data.
>>>> >> >> >
>>>> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>>>> >> >> > 602.333.9091
>>>> >> >> > Oracle PSR Engineering | Server Technology
>>>> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
>>>> >> >> >
>>>> >> >> > Ruslan Cheremin writes:
>>>> >> >> >
>>>> >> >> > For me it is confusing: java has only one way to have really
>>>> >> >> > immutable
>>>> >> >> > object, and this way also gives you a total thread safety even
>>>> >> >> > for
>>>> >> >> > data race based publication. But then docs refer object as
>>>> >> >> > "immutable
>>>> >> >> > and thread-safe" -- we still can't assume it to be really
>>>> >> >> > thread-safe?
>>>> >> >> >
>>>> >> >> > It is better/simpler to isolate the notion of thread-safety and
>>>> >> >> > safe
>>>> >> >> > publication. Thread-safety comes into play after you have safely
>>>> >> >> > shared
>>>> >> >> > an
>>>> >> >> > object. The means by which you safely share an object is
>>>> >> >> > orthogonal
>>>> >> >> > to
>>>> >> >> > how
>>>> >> >> > the object itself is made thread-safe.
>>>> >> >> >
>>>> >> >> > The means by which an object is shared has to involve shared
>>>> >> >> > mutable
>>>> >> >> > state,
>>>> >> >> > and use of shared mutable state always needs some form of
>>>> >> >> > synchronization
>>>> >> >> > (either implicit eg due to static initialization; or explicit by
>>>> >> >> > using
>>>> >> >> > volatile or synchronized getter/setter methods).
>>>> >> >> >
>>>> >> >> > David
>>>> >> >> > -----
>>>> >> >> >
>>>> >> >> > It's a pity, especially because true immutability gives us some
>>>> >> >> > chances of performance optimization. As in this case -- we do not
>>>> >> >> > really need .path to be volatile here, if we would assume Path to
>>>> >> >> > be
>>>> >> >> > truly immutable. volatility here required only for ensuring safe
>>>> >> >> > publishing.
>>>> >> >> >
>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>> >> >> >
>>>> >> >> > Ruslan Cheremin writes:>
>>>> >> >> >
>>>> >> >> > But is there a way to define "safe for data race publishing"? I
>>>> >> >> > as
>>>> >> >> > far, as I remember, "immutable and thread-safe" is standard
>>>> >> >> > mantra
>>>> >> >> > in
>>>> >> >> > JDK javadocs for totally safe objects. j.l.String has same mantra
>>>> >> >> > --
>>>> >> >> > and it is safe for any way of publishing. Does you mean, I should
>>>> >> >> > explicitly add "safe even for publishing via data race" in docs?
>>>> >> >> > But
>>>> >> >> > I
>>>> >> >> > can't remember any such phrase in JDK docs.
>>>> >> >> >
>>>> >> >> > I don't recall anything in the JDK docs that mention being
>>>> >> >> >
>>>> >> >> > "totally safe"
>>>> >> >> >
>>>> >> >> > regardless of publication mechanism. Some classes, eg String,
>>>> >> >> > have
>>>> >> >> > been
>>>> >> >> > defined such that they do have that property (for security
>>>> >> >> > reasons).
>>>> >> >> > In
>>>> >> >> > general neither "thread-safe" nor "immutable" imply
>>>> >> >> > safe-for-unsynchronized-publication.
>>>> >> >> >
>>>> >> >> > Java Concurrency In Practice (jcip.net) does define additional
>>>> >> >> > potential
>>>> >> >> > annotations, where @Immutable would indeed capture the
>>>> >> >> > requirement
>>>> >> >> > of
>>>> >> >> > safe-for-unsynchronized-publication.
>>>> >> >> >
>>>> >> >> > David
>>>> >> >> > -----
>>>> >> >> >
>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>> >> >> >
>>>> >> >> > Ruslan Cheremin writes:
>>>> >> >> >
>>>> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>>>> >> >> > multithreaded use". Although it is not strictly defined in java
>>>> >> >> > what
>>>> >> >> > exactly means "safe for multithreaded use" -- does it mean safe
>>>> >> >> > for
>>>> >> >> > publishing via data race, among others? -- I suppose, it
>>>> >> >> >
>>>> >> >> > should be. Am
>>>> >> >> >
>>>> >> >> > I wrong here?
>>>> >> >> >
>>>> >> >> > "safe for multi-threaded use" does not generally imply that it
>>>> >> >> >
>>>> >> >> > is safe to
>>>> >> >> >
>>>> >> >> > publish instances without synchronization of some form.
>>>> >> >> >
>>>> >> >> > David
>>>> >> >> > -----
>>>> >> >> >
>>>> >> >> > From other side, File.toPath javadoc explicitly says what
>>>> >> >> > "returned
>>>> >> >> > instance must be the same for every invocation", so sync block is
>>>> >> >> > required here for mutual exclusion on initialization phase.
>>>> >> >> > Without
>>>> >> >> > this requirement it is also safe to live without sync block,
>>>> >> >> > afaik.
>>>> >> >> >
>>>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>> >> >> >
>>>> >> >> > Ruslan Cheremin writes:
>>>> >> >> >
>>>> >> >> > First of all, Path is immutable, so DCL is safe here even without
>>>> >> >> > volatile. Volatile here is not required from my point of view.
>>>> >> >> >
>>>> >> >> > Without the volatile the Path implementation (Path is an
>>>> >> >> >
>>>> >> >> > interface) must be
>>>> >> >> >
>>>> >> >> > such that an instance of Path can be safely published without
>>>> >> >> >
>>>> >> >> > any additional
>>>> >> >> >
>>>> >> >> > forms of synchronization. Immutability does not in itself
>>>> >> >> >
>>>> >> >> > ensure that. You
>>>> >> >> >
>>>> >> >> > would have to examine the actual implementation class.
>>>> >> >> >
>>>> >> >> > David Holmes
>>>> >> >> > ------------
>>>> >> >> >
>>>> >> >> >
>>>> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>>>> >> >> >
>>>> >> >> > Hi Richard,
>>>> >> >> >
>>>> >> >> > The variable "filePath" is volatile, so the double-checked
>>>> >> >> >
>>>> >> >> > locking is correct in this case. It would have been a bug
>>>> >> >> >
>>>> >> >> > prior to Java 5.
>>>> >> >> >
>>>> >> >> > Best regards,
>>>> >> >> >
>>>> >> >> > Dmitry Vyazelenko
>>>> >> >> >
>>>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>>>> >> >> >
>>>> >> >> > <richard.warburton at gmail.com> wrote:
>>>> >> >> >
>>>> >> >> > Hello,
>>>> >> >> >
>>>> >> >> > The current implementation of java.io.File::toPath [0]
>>>> >> >> >
>>>> >> >> > appears to be
>>>> >> >> >
>>>> >> >> > using the double checked locking pattern:
>>>> >> >> >
>>>> >> >> >     public Path toPath() {
>>>> >> >> >         Path result = filePath;
>>>> >> >> >         if (result == null) {
>>>> >> >> >             synchronized (this) {
>>>> >> >> >                 result = filePath;
>>>> >> >> >                 if (result == null) {
>>>> >> >> >                     result =
>>>> >> >> >
>>>> >> >> > FileSystems.getDefault().getPath(path);
>>>> >> >> >
>>>> >> >> >                     filePath = result;
>>>> >> >> >                 }
>>>> >> >> >             }
>>>> >> >> >         }
>>>> >> >> >         return result;
>>>> >> >> >     }
>>>> >> >> >
>>>> >> >> > I was going to report the bug, but I'm a little
>>>> >> >> >
>>>> >> >> > uncertain of the
>>>> >> >> >
>>>> >> >> > interaction between the local variable 'result' and DCL
>>>> >> >> >
>>>> >> >> > since I've
>>>> >> >> >
>>>> >> >> > previously only seen the checking condition on the
>>>> >> >> >
>>>> >> >> > shared field
>>>> >> >> >
>>>> >> >> > itself.  Can someone here either confirm that its a bug or
>>>> >> >> >
>>>> >> >> > explain how
>>>> >> >> >
>>>> >> >> > the 'result' variable is fixing things?
>>>> >> >> >
>>>> >> >> > regards,
>>>> >> >> >
>>>> >> >> >  Richard
>>>> >> >> >
>>>> >> >> > [0] See the end of
>>>> >> >> >
>>>> >> >> >
>>>> >> >> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>>>> >> >> >
>>>> >> >> > ses/java/io/File.java
>>>> >> >> >
>>>> >> >> > _______________________________________________
>>>> >> >> > Concurrency-interest mailing list
>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >> >> >
>>>> >> >> > _______________________________________________
>>>> >> >> > Concurrency-interest mailing list
>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >> >> >
>>>> >> >> > _______________________________________________
>>>> >> >> > Concurrency-interest mailing list
>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >> >> >
>>>> >> >> > _______________________________________________
>>>> >> >> > Concurrency-interest mailing list
>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >> >> >
>>>> >> >> >
>>>> >> >> >
>>>> >> >> > _______________________________________________
>>>> >> >> > Concurrency-interest mailing list
>>>> >> >> > Concurrency-interest at cs.oswego.edu
>>>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >> >> >
>>>> >> >> _______________________________________________
>>>> >> >> Concurrency-interest mailing list
>>>> >> >> Concurrency-interest at cs.oswego.edu
>>>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From davidcholmes at aapt.net.au  Wed Aug 15 03:32:57 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 15 Aug 2012 17:32:57 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <502A9FF0.2000904@oracle.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>

Nathan,

The reason to keep them distinct is because in general the mechanisms for
safe publication are external to the class, while those for thread-safety
are internal. It is only an edge case where use of synchronized in a
constructor can achieve safe-publication.

People have to recognize that sharing an object requires shared mutable
state, and the number one tenet of concurrent programming is that access to
shared mutable state has to be synchronized (in a general sense not
specifically use of 'synchronized' keyword).

Making every object safely publishable could be done, but for 99% of objects
it would be a waste of effort. Programs without data races don't have issues
with unsafe publication.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan
Reynolds
  Sent: Wednesday, 15 August 2012 4:59 AM
  To: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK


  We seem to be splitting two notions (i.e thread-safe and safe publication)
when they should be combined in a sense.  Typically, when we say thread-safe
we talk about the operations performed on the object after it was
constructed (and its contents are globally visible).  However, we need to
consider that executing the constructor is modifying the state of the
object.  It requires the same mechanisms that the rest of the class uses to
ensure thread-safety.  Even though, there is only 1 thread executing the
constructor, a proper releasing of a lock or some other happens-before
construct is required to ensure that the memory updates by the thread are
made globally visible before the object is accessed by another thread.  This
is what we are calling safe publication.  So, safe publication is a subset
of thread-safety except it is limited to what happens after the constructor
is called and before the object is used by multiple threads.

  A beautifully-written class can be thread-safe with respect to calling its
member methods but not thread-safe with respect to calling its constructor.
It is this latter case that many stumble upon because they think that
constructors are inherently thread-safe because they are executed
single-threadedly.  What they fail to realize is that the execution of a
constructor can overlap with the execution of other code from the view point
of what is happening in memory.  This same problem applies to more rare case
of regular methods which can be proven to execute in a single thread but
don't use synchronization before multiple threads start accessing the shared
data.


  Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
  Oracle PSR Engineering | Server Technology

  On 8/13/2012 4:08 PM, David Holmes wrote:

Ruslan Cheremin writes:
For me it is confusing: java has only one way to have really immutable
object, and this way also gives you a total thread safety even for
data race based publication. But then docs refer object as "immutable
and thread-safe" -- we still can't assume it to be really thread-safe?
It is better/simpler to isolate the notion of thread-safety and safe
publication. Thread-safety comes into play after you have safely shared an
object. The means by which you safely share an object is orthogonal to how
the object itself is made thread-safe.

The means by which an object is shared has to involve shared mutable state,
and use of shared mutable state always needs some form of synchronization
(either implicit eg due to static initialization; or explicit by using
volatile or synchronized getter/setter methods).

David
-----

It's a pity, especially because true immutability gives us some
chances of performance optimization. As in this case -- we do not
really need .path to be volatile here, if we would assume Path to be
truly immutable. volatility here required only for ensuring safe
publishing.

2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
Ruslan Cheremin writes:>
But is there a way to define "safe for data race publishing"? I as
far, as I remember, "immutable and thread-safe" is standard mantra in
JDK javadocs for totally safe objects. j.l.String has same mantra --
and it is safe for any way of publishing. Does you mean, I should
explicitly add "safe even for publishing via data race" in docs? But I
can't remember any such phrase in JDK docs.
I don't recall anything in the JDK docs that mention being
"totally safe"
regardless of publication mechanism. Some classes, eg String, have been
defined such that they do have that property (for security reasons). In
general neither "thread-safe" nor "immutable" imply
safe-for-unsynchronized-publication.

Java Concurrency In Practice (jcip.net) does define additional potential
annotations, where @Immutable would indeed capture the requirement of
safe-for-unsynchronized-publication.

David
-----

2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
Ruslan Cheremin writes:
Well, Path javadoc explicitly says "immutable and safe for
multithreaded use". Although it is not strictly defined in java what
exactly means "safe for multithreaded use" -- does it mean safe for
publishing via data race, among others? -- I suppose, it
should be. Am
I wrong here?
"safe for multi-threaded use" does not generally imply that it
is safe to
publish instances without synchronization of some form.

David
-----

>From other side, File.toPath javadoc explicitly says what "returned
instance must be the same for every invocation", so sync block is
required here for mutual exclusion on initialization phase. Without
this requirement it is also safe to live without sync block, afaik.

2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
Ruslan Cheremin writes:
First of all, Path is immutable, so DCL is safe here even without
volatile. Volatile here is not required from my point of view.
Without the volatile the Path implementation (Path is an
interface) must be
such that an instance of Path can be safely published without
any additional
forms of synchronization. Immutability does not in itself
ensure that. You
would have to examine the actual implementation class.

David Holmes
------------


2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
Hi Richard,

The variable "filePath" is volatile, so the double-checked
locking is correct in this case. It would have been a bug
prior to Java 5.
Best regards,

Dmitry Vyazelenko

On Aug 12, 2012, at 21:35 , Richard Warburton
<richard.warburton at gmail.com> wrote:
Hello,

The current implementation of java.io.File::toPath [0]
appears to be
using the double checked locking pattern:

    public Path toPath() {
        Path result = filePath;
        if (result == null) {
            synchronized (this) {
                result = filePath;
                if (result == null) {
                    result =
FileSystems.getDefault().getPath(path);
                    filePath = result;
                }
            }
        }
        return result;
    }

I was going to report the bug, but I'm a little
uncertain of the
interaction between the local variable 'result' and DCL
since I've
previously only seen the checking condition on the
shared field
itself.  Can someone here either confirm that its a bug or
explain how
the 'result' variable is fixing things?

regards,

 Richard

[0] See the end of

hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
ses/java/io/File.java
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/71186c95/attachment.html>

From jeffhain at rocketmail.com  Wed Aug 15 06:03:42 2012
From: jeffhain at rocketmail.com (Jeff Hain)
Date: Wed, 15 Aug 2012 11:03:42 +0100 (BST)
Subject: [concurrency-interest] some questions with ThreadPoolExecutor
In-Reply-To: <1e2ce181.1f32.13927a3e293.Coremail.freish@163.com>
References: <1e2ce181.1f32.13927a3e293.Coremail.freish@163.com>
Message-ID: <1345025022.77493.YahooMailNeo@web132106.mail.ird.yahoo.com>

Hi.

Your ThreadPoolExecutor code looks like from a very old version.


>Yes,the last five tasks are executed in only one thread.

It shouldn't be that much of a problem if the pool is terminating.

-Jeff
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/6a8c8f0d/attachment-0001.html>

From freish at 163.com  Wed Aug 15 09:26:19 2012
From: freish at 163.com (freish)
Date: Wed, 15 Aug 2012 21:26:19 +0800 (CST)
Subject: [concurrency-interest] some questions with ThreadPoolExecutor
In-Reply-To: <1e2ce181.1f32.13927a3e293.Coremail.freish@163.com>
References: <1e2ce181.1f32.13927a3e293.Coremail.freish@163.com>
Message-ID: <1cd68e18.11974.1392a769bea.Coremail.freish@163.com>


perhaps it is really a bug.  In jdk1.7,there is no such problem.And I find that ThreadPoolExecutor is rewriten in jdk1.7.



Another problem with jdk1.6 and previous is as below:


import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
 
public class TestSetCorePoolSize {
    public static void main(String[] args) throws InterruptedException {
        final ThreadPoolExecutor pool = (ThreadPoolExecutor)Executors.newFixedThreadPool(5);
        pool.prestartAllCoreThreads();
        //waiting for threads in pool started
        new Thread(){
            public void run() {
                try {
                    Thread.sleep(6000L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                pool.setCorePoolSize(3);
                System.out.println("set corePoolSize:3");
            }
        }.start();
        for(int i=0; i<30; i++) {
            System.out.println("poolSize:" + ((ThreadPoolExecutor)pool).getPoolSize());
            Thread.sleep(1000L);
        }
        pool.shutdown();
    }
}




after setCorePoolSize called, the pool size won't become 3. But in jdk1.7,it is 3.and this is a reasonable behavor.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/478ae55c/attachment.html>

From freish at 163.com  Wed Aug 15 09:35:11 2012
From: freish at 163.com (freish)
Date: Wed, 15 Aug 2012 21:35:11 +0800 (CST)
Subject: [concurrency-interest] some questions with ThreadPoolExecutor
In-Reply-To: <1345025022.77493.YahooMailNeo@web132106.mail.ird.yahoo.com>
References: <1e2ce181.1f32.13927a3e293.Coremail.freish@163.com>
	<1345025022.77493.YahooMailNeo@web132106.mail.ird.yahoo.com>
Message-ID: <64c07d11.11b1e.1392a7eb727.Coremail.freish@163.com>

the source code is from jdk1.6_0_26.


Sometimes we submit a set of tasks to the pool and don't use the pool any more and wait for the tasks finished,but if exception is thrown from some of the tasks,the pool size will decrease?this will case the tasks execute  in serial mode,and this will affect the concurrency,perhaps increase the program execution time.


there is no such problem in jdk1.7.


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/4182d4a4/attachment.html>

From cheremin at gmail.com  Wed Aug 15 12:49:30 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Wed, 15 Aug 2012 20:49:30 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>

> The reason to keep them distinct is because in general the mechanisms for
> safe publication are external to the class, while those for thread-safety
> are internal. It is only an edge case where use of synchronized in a
> constructor can achieve safe-publication.

Well, actually I do not understand your point. If I use some kind of
synchronization to make methods of my object thread-safe -- can't I
also apply same thing to constructor? For me, it makes the thing only
clearer. Object can be thread-safe -- and it is totally thread safe.
Object can require external synchronization for correct multithreaded
use -- and it requires the sync for publishing and for usage also.

>From my point of view, the distinction you talking about is more
historically reasoned. "Sync method if you want it to be thread-safe"
is commonly learned mantra, but "take care of initialization also" is
not so common. More information about it, more education, more
different code samples with outlined "here is the dragons" will change
the situation, I sure, it just have to be highlighted more often.


> People have to recognize that sharing an object requires shared mutable
> state, and the number one tenet of concurrent programming is that access to
> shared mutable state has to be synchronized (in a general sense not
> specifically use of 'synchronized' keyword).
>
> Making every object safely publishable could be done, but for 99% of objects
> it would be a waste of effort. Programs without data races don't have issues
> with unsafe publication.
>
> David
>
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan
> Reynolds
> Sent: Wednesday, 15 August 2012 4:59 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>
> We seem to be splitting two notions (i.e thread-safe and safe publication)
> when they should be combined in a sense.  Typically, when we say thread-safe
> we talk about the operations performed on the object after it was
> constructed (and its contents are globally visible).  However, we need to
> consider that executing the constructor is modifying the state of the
> object.  It requires the same mechanisms that the rest of the class uses to
> ensure thread-safety.  Even though, there is only 1 thread executing the
> constructor, a proper releasing of a lock or some other happens-before
> construct is required to ensure that the memory updates by the thread are
> made globally visible before the object is accessed by another thread.  This
> is what we are calling safe publication.  So, safe publication is a subset
> of thread-safety except it is limited to what happens after the constructor
> is called and before the object is used by multiple threads.
>
> A beautifully-written class can be thread-safe with respect to calling its
> member methods but not thread-safe with respect to calling its constructor.
> It is this latter case that many stumble upon because they think that
> constructors are inherently thread-safe because they are executed
> single-threadedly.  What they fail to realize is that the execution of a
> constructor can overlap with the execution of other code from the view point
> of what is happening in memory.  This same problem applies to more rare case
> of regular methods which can be proven to execute in a single thread but
> don't use synchronization before multiple threads start accessing the shared
> data.
>
> Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering | Server Technology
> On 8/13/2012 4:08 PM, David Holmes wrote:
>
> Ruslan Cheremin writes:
>
> For me it is confusing: java has only one way to have really immutable
> object, and this way also gives you a total thread safety even for
> data race based publication. But then docs refer object as "immutable
> and thread-safe" -- we still can't assume it to be really thread-safe?
>
> It is better/simpler to isolate the notion of thread-safety and safe
> publication. Thread-safety comes into play after you have safely shared an
> object. The means by which you safely share an object is orthogonal to how
> the object itself is made thread-safe.
>
> The means by which an object is shared has to involve shared mutable state,
> and use of shared mutable state always needs some form of synchronization
> (either implicit eg due to static initialization; or explicit by using
> volatile or synchronized getter/setter methods).
>
> David
> -----
>
> It's a pity, especially because true immutability gives us some
> chances of performance optimization. As in this case -- we do not
> really need .path to be volatile here, if we would assume Path to be
> truly immutable. volatility here required only for ensuring safe
> publishing.
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>
> Ruslan Cheremin writes:>
>
> But is there a way to define "safe for data race publishing"? I as
> far, as I remember, "immutable and thread-safe" is standard mantra in
> JDK javadocs for totally safe objects. j.l.String has same mantra --
> and it is safe for any way of publishing. Does you mean, I should
> explicitly add "safe even for publishing via data race" in docs? But I
> can't remember any such phrase in JDK docs.
>
> I don't recall anything in the JDK docs that mention being
>
> "totally safe"
>
> regardless of publication mechanism. Some classes, eg String, have been
> defined such that they do have that property (for security reasons). In
> general neither "thread-safe" nor "immutable" imply
> safe-for-unsynchronized-publication.
>
> Java Concurrency In Practice (jcip.net) does define additional potential
> annotations, where @Immutable would indeed capture the requirement of
> safe-for-unsynchronized-publication.
>
> David
> -----
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>
> Ruslan Cheremin writes:
>
> Well, Path javadoc explicitly says "immutable and safe for
> multithreaded use". Although it is not strictly defined in java what
> exactly means "safe for multithreaded use" -- does it mean safe for
> publishing via data race, among others? -- I suppose, it
>
> should be. Am
>
> I wrong here?
>
> "safe for multi-threaded use" does not generally imply that it
>
> is safe to
>
> publish instances without synchronization of some form.
>
> David
> -----
>
> From other side, File.toPath javadoc explicitly says what "returned
> instance must be the same for every invocation", so sync block is
> required here for mutual exclusion on initialization phase. Without
> this requirement it is also safe to live without sync block, afaik.
>
> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>
> Ruslan Cheremin writes:
>
> First of all, Path is immutable, so DCL is safe here even without
> volatile. Volatile here is not required from my point of view.
>
> Without the volatile the Path implementation (Path is an
>
> interface) must be
>
> such that an instance of Path can be safely published without
>
> any additional
>
> forms of synchronization. Immutability does not in itself
>
> ensure that. You
>
> would have to examine the actual implementation class.
>
> David Holmes
> ------------
>
> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>
> Hi Richard,
>
> The variable "filePath" is volatile, so the double-checked
>
> locking is correct in this case. It would have been a bug
>
> prior to Java 5.
>
> Best regards,
>
> Dmitry Vyazelenko
>
> On Aug 12, 2012, at 21:35 , Richard Warburton
>
> <richard.warburton at gmail.com> wrote:
>
> Hello,
>
> The current implementation of java.io.File::toPath [0]
>
> appears to be
>
> using the double checked locking pattern:
>
>     public Path toPath() {
>         Path result = filePath;
>         if (result == null) {
>             synchronized (this) {
>                 result = filePath;
>                 if (result == null) {
>                     result =
>
> FileSystems.getDefault().getPath(path);
>
>                     filePath = result;
>                 }
>             }
>         }
>         return result;
>     }
>
> I was going to report the bug, but I'm a little
>
> uncertain of the
>
> interaction between the local variable 'result' and DCL
>
> since I've
>
> previously only seen the checking condition on the
>
> shared field
>
> itself.  Can someone here either confirm that its a bug or
>
> explain how
>
> the 'result' variable is fixing things?
>
> regards,
>
>  Richard
>
> [0] See the end of
>
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>
> ses/java/io/File.java
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From yshavit at akiban.com  Wed Aug 15 12:58:45 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Wed, 15 Aug 2012 12:58:45 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
Message-ID: <CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>

There was a discussion here a few months ago about synchronizing
constructors -- I had asked why it's not allowed, and the discussion hit on
some of the similar points brought up in this thread.

But to your point specifically, synchronizing a constructor (via
"synchronized(this) {...}" surrounding its body) still doesn't give you
full thread safety (even assuming immutability after the constructor -- but
without final fields). It ensures that a thread can observe the object
either fully constructed *or* with all its fields having their default
values. In other words, even if your constructor is synchronized on the
same object your getter is, a thread could observe a field as it was before
the constructor was invoked.

http://markmail.org/message/mav53xzo4bqu7udw

On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin <cheremin at gmail.com>wrote:

> > The reason to keep them distinct is because in general the mechanisms for
> > safe publication are external to the class, while those for thread-safety
> > are internal. It is only an edge case where use of synchronized in a
> > constructor can achieve safe-publication.
>
> Well, actually I do not understand your point. If I use some kind of
> synchronization to make methods of my object thread-safe -- can't I
> also apply same thing to constructor? For me, it makes the thing only
> clearer. Object can be thread-safe -- and it is totally thread safe.
> Object can require external synchronization for correct multithreaded
> use -- and it requires the sync for publishing and for usage also.
>
> From my point of view, the distinction you talking about is more
> historically reasoned. "Sync method if you want it to be thread-safe"
> is commonly learned mantra, but "take care of initialization also" is
> not so common. More information about it, more education, more
> different code samples with outlined "here is the dragons" will change
> the situation, I sure, it just have to be highlighted more often.
>
>
> > People have to recognize that sharing an object requires shared mutable
> > state, and the number one tenet of concurrent programming is that access
> to
> > shared mutable state has to be synchronized (in a general sense not
> > specifically use of 'synchronized' keyword).
> >
> > Making every object safely publishable could be done, but for 99% of
> objects
> > it would be a waste of effort. Programs without data races don't have
> issues
> > with unsafe publication.
> >
> > David
> >
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan
> > Reynolds
> > Sent: Wednesday, 15 August 2012 4:59 AM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> >
> > We seem to be splitting two notions (i.e thread-safe and safe
> publication)
> > when they should be combined in a sense.  Typically, when we say
> thread-safe
> > we talk about the operations performed on the object after it was
> > constructed (and its contents are globally visible).  However, we need to
> > consider that executing the constructor is modifying the state of the
> > object.  It requires the same mechanisms that the rest of the class uses
> to
> > ensure thread-safety.  Even though, there is only 1 thread executing the
> > constructor, a proper releasing of a lock or some other happens-before
> > construct is required to ensure that the memory updates by the thread are
> > made globally visible before the object is accessed by another thread.
>  This
> > is what we are calling safe publication.  So, safe publication is a
> subset
> > of thread-safety except it is limited to what happens after the
> constructor
> > is called and before the object is used by multiple threads.
> >
> > A beautifully-written class can be thread-safe with respect to calling
> its
> > member methods but not thread-safe with respect to calling its
> constructor.
> > It is this latter case that many stumble upon because they think that
> > constructors are inherently thread-safe because they are executed
> > single-threadedly.  What they fail to realize is that the execution of a
> > constructor can overlap with the execution of other code from the view
> point
> > of what is happening in memory.  This same problem applies to more rare
> case
> > of regular methods which can be proven to execute in a single thread but
> > don't use synchronization before multiple threads start accessing the
> shared
> > data.
> >
> > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> > Oracle PSR Engineering | Server Technology
> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >
> > Ruslan Cheremin writes:
> >
> > For me it is confusing: java has only one way to have really immutable
> > object, and this way also gives you a total thread safety even for
> > data race based publication. But then docs refer object as "immutable
> > and thread-safe" -- we still can't assume it to be really thread-safe?
> >
> > It is better/simpler to isolate the notion of thread-safety and safe
> > publication. Thread-safety comes into play after you have safely shared
> an
> > object. The means by which you safely share an object is orthogonal to
> how
> > the object itself is made thread-safe.
> >
> > The means by which an object is shared has to involve shared mutable
> state,
> > and use of shared mutable state always needs some form of synchronization
> > (either implicit eg due to static initialization; or explicit by using
> > volatile or synchronized getter/setter methods).
> >
> > David
> > -----
> >
> > It's a pity, especially because true immutability gives us some
> > chances of performance optimization. As in this case -- we do not
> > really need .path to be volatile here, if we would assume Path to be
> > truly immutable. volatility here required only for ensuring safe
> > publishing.
> >
> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >
> > Ruslan Cheremin writes:>
> >
> > But is there a way to define "safe for data race publishing"? I as
> > far, as I remember, "immutable and thread-safe" is standard mantra in
> > JDK javadocs for totally safe objects. j.l.String has same mantra --
> > and it is safe for any way of publishing. Does you mean, I should
> > explicitly add "safe even for publishing via data race" in docs? But I
> > can't remember any such phrase in JDK docs.
> >
> > I don't recall anything in the JDK docs that mention being
> >
> > "totally safe"
> >
> > regardless of publication mechanism. Some classes, eg String, have been
> > defined such that they do have that property (for security reasons). In
> > general neither "thread-safe" nor "immutable" imply
> > safe-for-unsynchronized-publication.
> >
> > Java Concurrency In Practice (jcip.net) does define additional potential
> > annotations, where @Immutable would indeed capture the requirement of
> > safe-for-unsynchronized-publication.
> >
> > David
> > -----
> >
> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >
> > Ruslan Cheremin writes:
> >
> > Well, Path javadoc explicitly says "immutable and safe for
> > multithreaded use". Although it is not strictly defined in java what
> > exactly means "safe for multithreaded use" -- does it mean safe for
> > publishing via data race, among others? -- I suppose, it
> >
> > should be. Am
> >
> > I wrong here?
> >
> > "safe for multi-threaded use" does not generally imply that it
> >
> > is safe to
> >
> > publish instances without synchronization of some form.
> >
> > David
> > -----
> >
> > From other side, File.toPath javadoc explicitly says what "returned
> > instance must be the same for every invocation", so sync block is
> > required here for mutual exclusion on initialization phase. Without
> > this requirement it is also safe to live without sync block, afaik.
> >
> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >
> > Ruslan Cheremin writes:
> >
> > First of all, Path is immutable, so DCL is safe here even without
> > volatile. Volatile here is not required from my point of view.
> >
> > Without the volatile the Path implementation (Path is an
> >
> > interface) must be
> >
> > such that an instance of Path can be safely published without
> >
> > any additional
> >
> > forms of synchronization. Immutability does not in itself
> >
> > ensure that. You
> >
> > would have to examine the actual implementation class.
> >
> > David Holmes
> > ------------
> >
> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >
> > Hi Richard,
> >
> > The variable "filePath" is volatile, so the double-checked
> >
> > locking is correct in this case. It would have been a bug
> >
> > prior to Java 5.
> >
> > Best regards,
> >
> > Dmitry Vyazelenko
> >
> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >
> > <richard.warburton at gmail.com> wrote:
> >
> > Hello,
> >
> > The current implementation of java.io.File::toPath [0]
> >
> > appears to be
> >
> > using the double checked locking pattern:
> >
> >     public Path toPath() {
> >         Path result = filePath;
> >         if (result == null) {
> >             synchronized (this) {
> >                 result = filePath;
> >                 if (result == null) {
> >                     result =
> >
> > FileSystems.getDefault().getPath(path);
> >
> >                     filePath = result;
> >                 }
> >             }
> >         }
> >         return result;
> >     }
> >
> > I was going to report the bug, but I'm a little
> >
> > uncertain of the
> >
> > interaction between the local variable 'result' and DCL
> >
> > since I've
> >
> > previously only seen the checking condition on the
> >
> > shared field
> >
> > itself.  Can someone here either confirm that its a bug or
> >
> > explain how
> >
> > the 'result' variable is fixing things?
> >
> > regards,
> >
> >  Richard
> >
> > [0] See the end of
> >
> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >
> > ses/java/io/File.java
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/1f21f383/attachment-0001.html>

From martinrb at google.com  Wed Aug 15 13:42:17 2012
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 15 Aug 2012 10:42:17 -0700
Subject: [concurrency-interest] some questions with ThreadPoolExecutor
In-Reply-To: <64c07d11.11b1e.1392a7eb727.Coremail.freish@163.com>
References: <1e2ce181.1f32.13927a3e293.Coremail.freish@163.com>
	<1345025022.77493.YahooMailNeo@web132106.mail.ird.yahoo.com>
	<64c07d11.11b1e.1392a7eb727.Coremail.freish@163.com>
Message-ID: <CA+kOe098=ETuWZBfzSf9ZZVXvsf7piPuMYKA9VW=BFd4_2+8XQ@mail.gmail.com>

On Wed, Aug 15, 2012 at 6:35 AM, freish <freish at 163.com> wrote:

> the source code is from jdk1.6_0_26.
>

You could check out the code in openjdk6, for comparison.


> Sometimes we submit a set of tasks to the pool and don't use the pool any
> more and wait for the tasks finished,but if exception is thrown from some
> of the tasks,the pool size will decrease?this will case the tasks execute
>  in serial mode,and this will affect the concurrency,perhaps increase the
> program execution time.
>

There have been many fixes to TPE over the years, but your problem doesn't
sound familiar.



> there is no such problem in jdk1.7.
>

You can either upgrade to 1.7, or you can probably use the latest
implementation in a jdk6, e.g. with -Xbootclasspath/p:
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/481a56e5/attachment.html>

From zhong.j.yu at gmail.com  Wed Aug 15 13:55:34 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Wed, 15 Aug 2012 12:55:34 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
Message-ID: <CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>

I thought the conclusion of that thread is that synchronizing
constructor has the desired merit - if all constructors and methods
are synchronized, a non-creating thread won't observe the zero/partial
state of the object, even if the object reference is published
unsafely.

(One guy, who shall remain nameless, muddied the water with some
mistaken statements of weaker memory guarantee. He has been corrected)

Zhong Yu

On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit <yshavit at akiban.com> wrote:
> There was a discussion here a few months ago about synchronizing
> constructors -- I had asked why it's not allowed, and the discussion hit on
> some of the similar points brought up in this thread.
>
> But to your point specifically, synchronizing a constructor (via
> "synchronized(this) {...}" surrounding its body) still doesn't give you full
> thread safety (even assuming immutability after the constructor -- but
> without final fields). It ensures that a thread can observe the object
> either fully constructed *or* with all its fields having their default
> values. In other words, even if your constructor is synchronized on the same
> object your getter is, a thread could observe a field as it was before the
> constructor was invoked.
>
> http://markmail.org/message/mav53xzo4bqu7udw
>
>
> On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin <cheremin at gmail.com>
> wrote:
>>
>> > The reason to keep them distinct is because in general the mechanisms
>> > for
>> > safe publication are external to the class, while those for
>> > thread-safety
>> > are internal. It is only an edge case where use of synchronized in a
>> > constructor can achieve safe-publication.
>>
>> Well, actually I do not understand your point. If I use some kind of
>> synchronization to make methods of my object thread-safe -- can't I
>> also apply same thing to constructor? For me, it makes the thing only
>> clearer. Object can be thread-safe -- and it is totally thread safe.
>> Object can require external synchronization for correct multithreaded
>> use -- and it requires the sync for publishing and for usage also.
>>
>> From my point of view, the distinction you talking about is more
>> historically reasoned. "Sync method if you want it to be thread-safe"
>> is commonly learned mantra, but "take care of initialization also" is
>> not so common. More information about it, more education, more
>> different code samples with outlined "here is the dragons" will change
>> the situation, I sure, it just have to be highlighted more often.
>>
>>
>> > People have to recognize that sharing an object requires shared mutable
>> > state, and the number one tenet of concurrent programming is that access
>> > to
>> > shared mutable state has to be synchronized (in a general sense not
>> > specifically use of 'synchronized' keyword).
>> >
>> > Making every object safely publishable could be done, but for 99% of
>> > objects
>> > it would be a waste of effort. Programs without data races don't have
>> > issues
>> > with unsafe publication.
>> >
>> > David
>> >
>> > -----Original Message-----
>> > From: concurrency-interest-bounces at cs.oswego.edu
>> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan
>> > Reynolds
>> > Sent: Wednesday, 15 August 2012 4:59 AM
>> > To: concurrency-interest at cs.oswego.edu
>> > Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>> >
>> > We seem to be splitting two notions (i.e thread-safe and safe
>> > publication)
>> > when they should be combined in a sense.  Typically, when we say
>> > thread-safe
>> > we talk about the operations performed on the object after it was
>> > constructed (and its contents are globally visible).  However, we need
>> > to
>> > consider that executing the constructor is modifying the state of the
>> > object.  It requires the same mechanisms that the rest of the class uses
>> > to
>> > ensure thread-safety.  Even though, there is only 1 thread executing the
>> > constructor, a proper releasing of a lock or some other happens-before
>> > construct is required to ensure that the memory updates by the thread
>> > are
>> > made globally visible before the object is accessed by another thread.
>> > This
>> > is what we are calling safe publication.  So, safe publication is a
>> > subset
>> > of thread-safety except it is limited to what happens after the
>> > constructor
>> > is called and before the object is used by multiple threads.
>> >
>> > A beautifully-written class can be thread-safe with respect to calling
>> > its
>> > member methods but not thread-safe with respect to calling its
>> > constructor.
>> > It is this latter case that many stumble upon because they think that
>> > constructors are inherently thread-safe because they are executed
>> > single-threadedly.  What they fail to realize is that the execution of a
>> > constructor can overlap with the execution of other code from the view
>> > point
>> > of what is happening in memory.  This same problem applies to more rare
>> > case
>> > of regular methods which can be proven to execute in a single thread but
>> > don't use synchronization before multiple threads start accessing the
>> > shared
>> > data.
>> >
>> > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
>> > Oracle PSR Engineering | Server Technology
>> > On 8/13/2012 4:08 PM, David Holmes wrote:
>> >
>> > Ruslan Cheremin writes:
>> >
>> > For me it is confusing: java has only one way to have really immutable
>> > object, and this way also gives you a total thread safety even for
>> > data race based publication. But then docs refer object as "immutable
>> > and thread-safe" -- we still can't assume it to be really thread-safe?
>> >
>> > It is better/simpler to isolate the notion of thread-safety and safe
>> > publication. Thread-safety comes into play after you have safely shared
>> > an
>> > object. The means by which you safely share an object is orthogonal to
>> > how
>> > the object itself is made thread-safe.
>> >
>> > The means by which an object is shared has to involve shared mutable
>> > state,
>> > and use of shared mutable state always needs some form of
>> > synchronization
>> > (either implicit eg due to static initialization; or explicit by using
>> > volatile or synchronized getter/setter methods).
>> >
>> > David
>> > -----
>> >
>> > It's a pity, especially because true immutability gives us some
>> > chances of performance optimization. As in this case -- we do not
>> > really need .path to be volatile here, if we would assume Path to be
>> > truly immutable. volatility here required only for ensuring safe
>> > publishing.
>> >
>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >
>> > Ruslan Cheremin writes:>
>> >
>> > But is there a way to define "safe for data race publishing"? I as
>> > far, as I remember, "immutable and thread-safe" is standard mantra in
>> > JDK javadocs for totally safe objects. j.l.String has same mantra --
>> > and it is safe for any way of publishing. Does you mean, I should
>> > explicitly add "safe even for publishing via data race" in docs? But I
>> > can't remember any such phrase in JDK docs.
>> >
>> > I don't recall anything in the JDK docs that mention being
>> >
>> > "totally safe"
>> >
>> > regardless of publication mechanism. Some classes, eg String, have been
>> > defined such that they do have that property (for security reasons). In
>> > general neither "thread-safe" nor "immutable" imply
>> > safe-for-unsynchronized-publication.
>> >
>> > Java Concurrency In Practice (jcip.net) does define additional potential
>> > annotations, where @Immutable would indeed capture the requirement of
>> > safe-for-unsynchronized-publication.
>> >
>> > David
>> > -----
>> >
>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >
>> > Ruslan Cheremin writes:
>> >
>> > Well, Path javadoc explicitly says "immutable and safe for
>> > multithreaded use". Although it is not strictly defined in java what
>> > exactly means "safe for multithreaded use" -- does it mean safe for
>> > publishing via data race, among others? -- I suppose, it
>> >
>> > should be. Am
>> >
>> > I wrong here?
>> >
>> > "safe for multi-threaded use" does not generally imply that it
>> >
>> > is safe to
>> >
>> > publish instances without synchronization of some form.
>> >
>> > David
>> > -----
>> >
>> > From other side, File.toPath javadoc explicitly says what "returned
>> > instance must be the same for every invocation", so sync block is
>> > required here for mutual exclusion on initialization phase. Without
>> > this requirement it is also safe to live without sync block, afaik.
>> >
>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >
>> > Ruslan Cheremin writes:
>> >
>> > First of all, Path is immutable, so DCL is safe here even without
>> > volatile. Volatile here is not required from my point of view.
>> >
>> > Without the volatile the Path implementation (Path is an
>> >
>> > interface) must be
>> >
>> > such that an instance of Path can be safely published without
>> >
>> > any additional
>> >
>> > forms of synchronization. Immutability does not in itself
>> >
>> > ensure that. You
>> >
>> > would have to examine the actual implementation class.
>> >
>> > David Holmes
>> > ------------
>> >
>> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >
>> > Hi Richard,
>> >
>> > The variable "filePath" is volatile, so the double-checked
>> >
>> > locking is correct in this case. It would have been a bug
>> >
>> > prior to Java 5.
>> >
>> > Best regards,
>> >
>> > Dmitry Vyazelenko
>> >
>> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >
>> > <richard.warburton at gmail.com> wrote:
>> >
>> > Hello,
>> >
>> > The current implementation of java.io.File::toPath [0]
>> >
>> > appears to be
>> >
>> > using the double checked locking pattern:
>> >
>> >     public Path toPath() {
>> >         Path result = filePath;
>> >         if (result == null) {
>> >             synchronized (this) {
>> >                 result = filePath;
>> >                 if (result == null) {
>> >                     result =
>> >
>> > FileSystems.getDefault().getPath(path);
>> >
>> >                     filePath = result;
>> >                 }
>> >             }
>> >         }
>> >         return result;
>> >     }
>> >
>> > I was going to report the bug, but I'm a little
>> >
>> > uncertain of the
>> >
>> > interaction between the local variable 'result' and DCL
>> >
>> > since I've
>> >
>> > previously only seen the checking condition on the
>> >
>> > shared field
>> >
>> > itself.  Can someone here either confirm that its a bug or
>> >
>> > explain how
>> >
>> > the 'result' variable is fixing things?
>> >
>> > regards,
>> >
>> >  Richard
>> >
>> > [0] See the end of
>> >
>> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >
>> > ses/java/io/File.java
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From nathan.reynolds at oracle.com  Wed Aug 15 14:55:44 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Wed, 15 Aug 2012 11:55:44 -0700
Subject: [concurrency-interest] debugging alternatives (was Re: Double
 Checked Locking in OpenJDK)
In-Reply-To: <CAJ7XQb5KQDZ8VYbzCPuhViaYM3ww3r-CXENXqvr6m9sBcbFztQ@mail.gmail.com>
References: <CAJ7XQb5KQDZ8VYbzCPuhViaYM3ww3r-CXENXqvr6m9sBcbFztQ@mail.gmail.com>
Message-ID: <502BF0B0.8010409@oracle.com>

We pounded it with a load test as hard as possible.  We had several 
people independently review the code.  We were then scared to death when 
it shipped.  :)

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 8/14/2012 5:17 PM, Raoul Duke wrote:
>> head around the problem, though.  In one case, we simply removed the
>> contended synchronized block and everything worked just fine!
> <pessimist>er, and you knew that it did not introduce data races? did
> you test it, or did you only prove it right? oh wait, we can't test to
> prove a negative.</pessimist>
>
> :-)
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/9988ff3a/attachment.html>

From hans.boehm at hp.com  Wed Aug 15 15:51:09 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 15 Aug 2012 19:51:09 +0000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>

Agreed.

But, echoing David, I think, I'm not at all sure I see where this thread is going.  We've established that

a) You can make a class safe against racy publication by synchronizing the constructor along with all other methods (or by using an immutable class with final fields).

b) There are (rather brittle and obscure) use cases in which racy publication gives you better performance on architectures like ARM, though not x86, currently at the cost of confusing data race detectors.

But to me it seems like taking advanatage of (b) is a fairly undesirable, though perhaps occasionally unavoidable, hack.  And I can't see why it would possibly be a win if you have to synchronize all method calls to make it work.

Does anyone have a use case in mind where the whole picture we're discussing actually makes sense?  It might help to focus this discussion.

Hans

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
> Sent: Wednesday, August 15, 2012 10:56 AM
> To: Yuval Shavit
> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> 
> I thought the conclusion of that thread is that synchronizing
> constructor has the desired merit - if all constructors and methods
> are synchronized, a non-creating thread won't observe the zero/partial
> state of the object, even if the object reference is published
> unsafely.
> 
> (One guy, who shall remain nameless, muddied the water with some
> mistaken statements of weaker memory guarantee. He has been corrected)
> 
> Zhong Yu
> 
> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit <yshavit at akiban.com>
> wrote:
> > There was a discussion here a few months ago about synchronizing
> > constructors -- I had asked why it's not allowed, and the discussion
> hit on
> > some of the similar points brought up in this thread.
> >
> > But to your point specifically, synchronizing a constructor (via
> > "synchronized(this) {...}" surrounding its body) still doesn't give
> you full
> > thread safety (even assuming immutability after the constructor --
> but
> > without final fields). It ensures that a thread can observe the
> object
> > either fully constructed *or* with all its fields having their
> default
> > values. In other words, even if your constructor is synchronized on
> the same
> > object your getter is, a thread could observe a field as it was
> before the
> > constructor was invoked.
> >
> > http://markmail.org/message/mav53xzo4bqu7udw
> >
> >
> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
> <cheremin at gmail.com>
> > wrote:
> >>
> >> > The reason to keep them distinct is because in general the
> mechanisms
> >> > for
> >> > safe publication are external to the class, while those for
> >> > thread-safety
> >> > are internal. It is only an edge case where use of synchronized in
> a
> >> > constructor can achieve safe-publication.
> >>
> >> Well, actually I do not understand your point. If I use some kind of
> >> synchronization to make methods of my object thread-safe -- can't I
> >> also apply same thing to constructor? For me, it makes the thing
> only
> >> clearer. Object can be thread-safe -- and it is totally thread safe.
> >> Object can require external synchronization for correct
> multithreaded
> >> use -- and it requires the sync for publishing and for usage also.
> >>
> >> From my point of view, the distinction you talking about is more
> >> historically reasoned. "Sync method if you want it to be thread-
> safe"
> >> is commonly learned mantra, but "take care of initialization also"
> is
> >> not so common. More information about it, more education, more
> >> different code samples with outlined "here is the dragons" will
> change
> >> the situation, I sure, it just have to be highlighted more often.
> >>
> >>
> >> > People have to recognize that sharing an object requires shared
> mutable
> >> > state, and the number one tenet of concurrent programming is that
> access
> >> > to
> >> > shared mutable state has to be synchronized (in a general sense
> not
> >> > specifically use of 'synchronized' keyword).
> >> >
> >> > Making every object safely publishable could be done, but for 99%
> of
> >> > objects
> >> > it would be a waste of effort. Programs without data races don't
> have
> >> > issues
> >> > with unsafe publication.
> >> >
> >> > David
> >> >
> >> > -----Original Message-----
> >> > From: concurrency-interest-bounces at cs.oswego.edu
> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
> Nathan
> >> > Reynolds
> >> > Sent: Wednesday, 15 August 2012 4:59 AM
> >> > To: concurrency-interest at cs.oswego.edu
> >> > Subject: Re: [concurrency-interest] Double Checked Locking in
> OpenJDK
> >> >
> >> > We seem to be splitting two notions (i.e thread-safe and safe
> >> > publication)
> >> > when they should be combined in a sense.  Typically, when we say
> >> > thread-safe
> >> > we talk about the operations performed on the object after it was
> >> > constructed (and its contents are globally visible).  However, we
> need
> >> > to
> >> > consider that executing the constructor is modifying the state of
> the
> >> > object.  It requires the same mechanisms that the rest of the
> class uses
> >> > to
> >> > ensure thread-safety.  Even though, there is only 1 thread
> executing the
> >> > constructor, a proper releasing of a lock or some other happens-
> before
> >> > construct is required to ensure that the memory updates by the
> thread
> >> > are
> >> > made globally visible before the object is accessed by another
> thread.
> >> > This
> >> > is what we are calling safe publication.  So, safe publication is
> a
> >> > subset
> >> > of thread-safety except it is limited to what happens after the
> >> > constructor
> >> > is called and before the object is used by multiple threads.
> >> >
> >> > A beautifully-written class can be thread-safe with respect to
> calling
> >> > its
> >> > member methods but not thread-safe with respect to calling its
> >> > constructor.
> >> > It is this latter case that many stumble upon because they think
> that
> >> > constructors are inherently thread-safe because they are executed
> >> > single-threadedly.  What they fail to realize is that the
> execution of a
> >> > constructor can overlap with the execution of other code from the
> view
> >> > point
> >> > of what is happening in memory.  This same problem applies to more
> rare
> >> > case
> >> > of regular methods which can be proven to execute in a single
> thread but
> >> > don't use synchronization before multiple threads start accessing
> the
> >> > shared
> >> > data.
> >> >
> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> 602.333.9091
> >> > Oracle PSR Engineering | Server Technology
> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >> >
> >> > Ruslan Cheremin writes:
> >> >
> >> > For me it is confusing: java has only one way to have really
> immutable
> >> > object, and this way also gives you a total thread safety even for
> >> > data race based publication. But then docs refer object as
> "immutable
> >> > and thread-safe" -- we still can't assume it to be really thread-
> safe?
> >> >
> >> > It is better/simpler to isolate the notion of thread-safety and
> safe
> >> > publication. Thread-safety comes into play after you have safely
> shared
> >> > an
> >> > object. The means by which you safely share an object is
> orthogonal to
> >> > how
> >> > the object itself is made thread-safe.
> >> >
> >> > The means by which an object is shared has to involve shared
> mutable
> >> > state,
> >> > and use of shared mutable state always needs some form of
> >> > synchronization
> >> > (either implicit eg due to static initialization; or explicit by
> using
> >> > volatile or synchronized getter/setter methods).
> >> >
> >> > David
> >> > -----
> >> >
> >> > It's a pity, especially because true immutability gives us some
> >> > chances of performance optimization. As in this case -- we do not
> >> > really need .path to be volatile here, if we would assume Path to
> be
> >> > truly immutable. volatility here required only for ensuring safe
> >> > publishing.
> >> >
> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >
> >> > Ruslan Cheremin writes:>
> >> >
> >> > But is there a way to define "safe for data race publishing"? I as
> >> > far, as I remember, "immutable and thread-safe" is standard mantra
> in
> >> > JDK javadocs for totally safe objects. j.l.String has same mantra
> --
> >> > and it is safe for any way of publishing. Does you mean, I should
> >> > explicitly add "safe even for publishing via data race" in docs?
> But I
> >> > can't remember any such phrase in JDK docs.
> >> >
> >> > I don't recall anything in the JDK docs that mention being
> >> >
> >> > "totally safe"
> >> >
> >> > regardless of publication mechanism. Some classes, eg String, have
> been
> >> > defined such that they do have that property (for security
> reasons). In
> >> > general neither "thread-safe" nor "immutable" imply
> >> > safe-for-unsynchronized-publication.
> >> >
> >> > Java Concurrency In Practice (jcip.net) does define additional
> potential
> >> > annotations, where @Immutable would indeed capture the requirement
> of
> >> > safe-for-unsynchronized-publication.
> >> >
> >> > David
> >> > -----
> >> >
> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >
> >> > Ruslan Cheremin writes:
> >> >
> >> > Well, Path javadoc explicitly says "immutable and safe for
> >> > multithreaded use". Although it is not strictly defined in java
> what
> >> > exactly means "safe for multithreaded use" -- does it mean safe
> for
> >> > publishing via data race, among others? -- I suppose, it
> >> >
> >> > should be. Am
> >> >
> >> > I wrong here?
> >> >
> >> > "safe for multi-threaded use" does not generally imply that it
> >> >
> >> > is safe to
> >> >
> >> > publish instances without synchronization of some form.
> >> >
> >> > David
> >> > -----
> >> >
> >> > From other side, File.toPath javadoc explicitly says what
> "returned
> >> > instance must be the same for every invocation", so sync block is
> >> > required here for mutual exclusion on initialization phase.
> Without
> >> > this requirement it is also safe to live without sync block,
> afaik.
> >> >
> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >
> >> > Ruslan Cheremin writes:
> >> >
> >> > First of all, Path is immutable, so DCL is safe here even without
> >> > volatile. Volatile here is not required from my point of view.
> >> >
> >> > Without the volatile the Path implementation (Path is an
> >> >
> >> > interface) must be
> >> >
> >> > such that an instance of Path can be safely published without
> >> >
> >> > any additional
> >> >
> >> > forms of synchronization. Immutability does not in itself
> >> >
> >> > ensure that. You
> >> >
> >> > would have to examine the actual implementation class.
> >> >
> >> > David Holmes
> >> > ------------
> >> >
> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >
> >> > Hi Richard,
> >> >
> >> > The variable "filePath" is volatile, so the double-checked
> >> >
> >> > locking is correct in this case. It would have been a bug
> >> >
> >> > prior to Java 5.
> >> >
> >> > Best regards,
> >> >
> >> > Dmitry Vyazelenko
> >> >
> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >
> >> > <richard.warburton at gmail.com> wrote:
> >> >
> >> > Hello,
> >> >
> >> > The current implementation of java.io.File::toPath [0]
> >> >
> >> > appears to be
> >> >
> >> > using the double checked locking pattern:
> >> >
> >> >     public Path toPath() {
> >> >         Path result = filePath;
> >> >         if (result == null) {
> >> >             synchronized (this) {
> >> >                 result = filePath;
> >> >                 if (result == null) {
> >> >                     result =
> >> >
> >> > FileSystems.getDefault().getPath(path);
> >> >
> >> >                     filePath = result;
> >> >                 }
> >> >             }
> >> >         }
> >> >         return result;
> >> >     }
> >> >
> >> > I was going to report the bug, but I'm a little
> >> >
> >> > uncertain of the
> >> >
> >> > interaction between the local variable 'result' and DCL
> >> >
> >> > since I've
> >> >
> >> > previously only seen the checking condition on the
> >> >
> >> > shared field
> >> >
> >> > itself.  Can someone here either confirm that its a bug or
> >> >
> >> > explain how
> >> >
> >> > the 'result' variable is fixing things?
> >> >
> >> > regards,
> >> >
> >> >  Richard
> >> >
> >> > [0] See the end of
> >> >
> >> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >
> >> > ses/java/io/File.java
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> >
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From cheremin at gmail.com  Wed Aug 15 15:56:39 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Wed, 15 Aug 2012 23:56:39 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
Message-ID: <CAOwENi+stm6i-GGz+TqNo=EpUWhskV7WUisWFO4f4_fmZm2jQQ@mail.gmail.com>

Yes, it was an interesting discussion, and as result object with
synchronized methods and constructor can be published unsafe (i.e.
other thread can obtain reference to partially initialized object),
but this patrially initialized state can't be observed, since all
access going via sync-ed methods, which will block until
initialization finish.

So, staying away from the unsual and so strange and even ugly notation
of locking in constructor, making object self-safe-publishing is not
anything more complex, then making thread-safe method. Am I missed
something?

2012/8/15 Zhong Yu <zhong.j.yu at gmail.com>:
> I thought the conclusion of that thread is that synchronizing
> constructor has the desired merit - if all constructors and methods
> are synchronized, a non-creating thread won't observe the zero/partial
> state of the object, even if the object reference is published
> unsafely.
>
> (One guy, who shall remain nameless, muddied the water with some
> mistaken statements of weaker memory guarantee. He has been corrected)
>
> Zhong Yu
>
> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit <yshavit at akiban.com> wrote:
>> There was a discussion here a few months ago about synchronizing
>> constructors -- I had asked why it's not allowed, and the discussion hit on
>> some of the similar points brought up in this thread.
>>
>> But to your point specifically, synchronizing a constructor (via
>> "synchronized(this) {...}" surrounding its body) still doesn't give you full
>> thread safety (even assuming immutability after the constructor -- but
>> without final fields). It ensures that a thread can observe the object
>> either fully constructed *or* with all its fields having their default
>> values. In other words, even if your constructor is synchronized on the same
>> object your getter is, a thread could observe a field as it was before the
>> constructor was invoked.
>>
>> http://markmail.org/message/mav53xzo4bqu7udw
>>
>>
>> On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin <cheremin at gmail.com>
>> wrote:
>>>
>>> > The reason to keep them distinct is because in general the mechanisms
>>> > for
>>> > safe publication are external to the class, while those for
>>> > thread-safety
>>> > are internal. It is only an edge case where use of synchronized in a
>>> > constructor can achieve safe-publication.
>>>
>>> Well, actually I do not understand your point. If I use some kind of
>>> synchronization to make methods of my object thread-safe -- can't I
>>> also apply same thing to constructor? For me, it makes the thing only
>>> clearer. Object can be thread-safe -- and it is totally thread safe.
>>> Object can require external synchronization for correct multithreaded
>>> use -- and it requires the sync for publishing and for usage also.
>>>
>>> From my point of view, the distinction you talking about is more
>>> historically reasoned. "Sync method if you want it to be thread-safe"
>>> is commonly learned mantra, but "take care of initialization also" is
>>> not so common. More information about it, more education, more
>>> different code samples with outlined "here is the dragons" will change
>>> the situation, I sure, it just have to be highlighted more often.
>>>
>>>
>>> > People have to recognize that sharing an object requires shared mutable
>>> > state, and the number one tenet of concurrent programming is that access
>>> > to
>>> > shared mutable state has to be synchronized (in a general sense not
>>> > specifically use of 'synchronized' keyword).
>>> >
>>> > Making every object safely publishable could be done, but for 99% of
>>> > objects
>>> > it would be a waste of effort. Programs without data races don't have
>>> > issues
>>> > with unsafe publication.
>>> >
>>> > David
>>> >
>>> > -----Original Message-----
>>> > From: concurrency-interest-bounces at cs.oswego.edu
>>> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan
>>> > Reynolds
>>> > Sent: Wednesday, 15 August 2012 4:59 AM
>>> > To: concurrency-interest at cs.oswego.edu
>>> > Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>>> >
>>> > We seem to be splitting two notions (i.e thread-safe and safe
>>> > publication)
>>> > when they should be combined in a sense.  Typically, when we say
>>> > thread-safe
>>> > we talk about the operations performed on the object after it was
>>> > constructed (and its contents are globally visible).  However, we need
>>> > to
>>> > consider that executing the constructor is modifying the state of the
>>> > object.  It requires the same mechanisms that the rest of the class uses
>>> > to
>>> > ensure thread-safety.  Even though, there is only 1 thread executing the
>>> > constructor, a proper releasing of a lock or some other happens-before
>>> > construct is required to ensure that the memory updates by the thread
>>> > are
>>> > made globally visible before the object is accessed by another thread.
>>> > This
>>> > is what we are calling safe publication.  So, safe publication is a
>>> > subset
>>> > of thread-safety except it is limited to what happens after the
>>> > constructor
>>> > is called and before the object is used by multiple threads.
>>> >
>>> > A beautifully-written class can be thread-safe with respect to calling
>>> > its
>>> > member methods but not thread-safe with respect to calling its
>>> > constructor.
>>> > It is this latter case that many stumble upon because they think that
>>> > constructors are inherently thread-safe because they are executed
>>> > single-threadedly.  What they fail to realize is that the execution of a
>>> > constructor can overlap with the execution of other code from the view
>>> > point
>>> > of what is happening in memory.  This same problem applies to more rare
>>> > case
>>> > of regular methods which can be proven to execute in a single thread but
>>> > don't use synchronization before multiple threads start accessing the
>>> > shared
>>> > data.
>>> >
>>> > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
>>> > Oracle PSR Engineering | Server Technology
>>> > On 8/13/2012 4:08 PM, David Holmes wrote:
>>> >
>>> > Ruslan Cheremin writes:
>>> >
>>> > For me it is confusing: java has only one way to have really immutable
>>> > object, and this way also gives you a total thread safety even for
>>> > data race based publication. But then docs refer object as "immutable
>>> > and thread-safe" -- we still can't assume it to be really thread-safe?
>>> >
>>> > It is better/simpler to isolate the notion of thread-safety and safe
>>> > publication. Thread-safety comes into play after you have safely shared
>>> > an
>>> > object. The means by which you safely share an object is orthogonal to
>>> > how
>>> > the object itself is made thread-safe.
>>> >
>>> > The means by which an object is shared has to involve shared mutable
>>> > state,
>>> > and use of shared mutable state always needs some form of
>>> > synchronization
>>> > (either implicit eg due to static initialization; or explicit by using
>>> > volatile or synchronized getter/setter methods).
>>> >
>>> > David
>>> > -----
>>> >
>>> > It's a pity, especially because true immutability gives us some
>>> > chances of performance optimization. As in this case -- we do not
>>> > really need .path to be volatile here, if we would assume Path to be
>>> > truly immutable. volatility here required only for ensuring safe
>>> > publishing.
>>> >
>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>> >
>>> > Ruslan Cheremin writes:>
>>> >
>>> > But is there a way to define "safe for data race publishing"? I as
>>> > far, as I remember, "immutable and thread-safe" is standard mantra in
>>> > JDK javadocs for totally safe objects. j.l.String has same mantra --
>>> > and it is safe for any way of publishing. Does you mean, I should
>>> > explicitly add "safe even for publishing via data race" in docs? But I
>>> > can't remember any such phrase in JDK docs.
>>> >
>>> > I don't recall anything in the JDK docs that mention being
>>> >
>>> > "totally safe"
>>> >
>>> > regardless of publication mechanism. Some classes, eg String, have been
>>> > defined such that they do have that property (for security reasons). In
>>> > general neither "thread-safe" nor "immutable" imply
>>> > safe-for-unsynchronized-publication.
>>> >
>>> > Java Concurrency In Practice (jcip.net) does define additional potential
>>> > annotations, where @Immutable would indeed capture the requirement of
>>> > safe-for-unsynchronized-publication.
>>> >
>>> > David
>>> > -----
>>> >
>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>> >
>>> > Ruslan Cheremin writes:
>>> >
>>> > Well, Path javadoc explicitly says "immutable and safe for
>>> > multithreaded use". Although it is not strictly defined in java what
>>> > exactly means "safe for multithreaded use" -- does it mean safe for
>>> > publishing via data race, among others? -- I suppose, it
>>> >
>>> > should be. Am
>>> >
>>> > I wrong here?
>>> >
>>> > "safe for multi-threaded use" does not generally imply that it
>>> >
>>> > is safe to
>>> >
>>> > publish instances without synchronization of some form.
>>> >
>>> > David
>>> > -----
>>> >
>>> > From other side, File.toPath javadoc explicitly says what "returned
>>> > instance must be the same for every invocation", so sync block is
>>> > required here for mutual exclusion on initialization phase. Without
>>> > this requirement it is also safe to live without sync block, afaik.
>>> >
>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>> >
>>> > Ruslan Cheremin writes:
>>> >
>>> > First of all, Path is immutable, so DCL is safe here even without
>>> > volatile. Volatile here is not required from my point of view.
>>> >
>>> > Without the volatile the Path implementation (Path is an
>>> >
>>> > interface) must be
>>> >
>>> > such that an instance of Path can be safely published without
>>> >
>>> > any additional
>>> >
>>> > forms of synchronization. Immutability does not in itself
>>> >
>>> > ensure that. You
>>> >
>>> > would have to examine the actual implementation class.
>>> >
>>> > David Holmes
>>> > ------------
>>> >
>>> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>>> >
>>> > Hi Richard,
>>> >
>>> > The variable "filePath" is volatile, so the double-checked
>>> >
>>> > locking is correct in this case. It would have been a bug
>>> >
>>> > prior to Java 5.
>>> >
>>> > Best regards,
>>> >
>>> > Dmitry Vyazelenko
>>> >
>>> > On Aug 12, 2012, at 21:35 , Richard Warburton
>>> >
>>> > <richard.warburton at gmail.com> wrote:
>>> >
>>> > Hello,
>>> >
>>> > The current implementation of java.io.File::toPath [0]
>>> >
>>> > appears to be
>>> >
>>> > using the double checked locking pattern:
>>> >
>>> >     public Path toPath() {
>>> >         Path result = filePath;
>>> >         if (result == null) {
>>> >             synchronized (this) {
>>> >                 result = filePath;
>>> >                 if (result == null) {
>>> >                     result =
>>> >
>>> > FileSystems.getDefault().getPath(path);
>>> >
>>> >                     filePath = result;
>>> >                 }
>>> >             }
>>> >         }
>>> >         return result;
>>> >     }
>>> >
>>> > I was going to report the bug, but I'm a little
>>> >
>>> > uncertain of the
>>> >
>>> > interaction between the local variable 'result' and DCL
>>> >
>>> > since I've
>>> >
>>> > previously only seen the checking condition on the
>>> >
>>> > shared field
>>> >
>>> > itself.  Can someone here either confirm that its a bug or
>>> >
>>> > explain how
>>> >
>>> > the 'result' variable is fixing things?
>>> >
>>> > regards,
>>> >
>>> >  Richard
>>> >
>>> > [0] See the end of
>>> >
>>> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>>> >
>>> > ses/java/io/File.java
>>> >
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >
>>> >
>>> >
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>

From cheremin at gmail.com  Wed Aug 15 16:19:57 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Thu, 16 Aug 2012 00:19:57 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
Message-ID: <CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>

As far, as I can see, there is two directions. One is what
"thread-safe" notation in it's commonly used form -- then applied only
to methods, and not to initialization/publication -- is confusing, and
there is little reason to exclude construction/publication from thread
safety protocol by default. My point, among others, is that "immutable
and thread safe" should be interpreted as "thread safe even for unsafe
publishing". And this, for example, gives us the chance to remove
volatile specification in File.path field we started from :)

Second direction is about construction/publication as specifically
different from the methods. E.g. it even may have additional safety
guarantee -- like "publication is always safe". I can see some reasons
here, since constructor is the only one method, which is guaranteed to
be called only once on object lifecycle, and so we, possible, can
restrict some compiler/CPUs optimization in it with little influence
on overall application performance -- but it throws away all troubles
with unsafe publishing.



2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
> Agreed.
>
> But, echoing David, I think, I'm not at all sure I see where this thread is going.  We've established that
>
> a) You can make a class safe against racy publication by synchronizing the constructor along with all other methods (or by using an immutable class with final fields).
>
> b) There are (rather brittle and obscure) use cases in which racy publication gives you better performance on architectures like ARM, though not x86, currently at the cost of confusing data race detectors.
>
> But to me it seems like taking advanatage of (b) is a fairly undesirable, though perhaps occasionally unavoidable, hack.  And I can't see why it would possibly be a win if you have to synchronize all method calls to make it work.
>
> Does anyone have a use case in mind where the whole picture we're discussing actually makes sense?  It might help to focus this discussion.
>
> Hans
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
>> Sent: Wednesday, August 15, 2012 10:56 AM
>> To: Yuval Shavit
>> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
>> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>>
>> I thought the conclusion of that thread is that synchronizing
>> constructor has the desired merit - if all constructors and methods
>> are synchronized, a non-creating thread won't observe the zero/partial
>> state of the object, even if the object reference is published
>> unsafely.
>>
>> (One guy, who shall remain nameless, muddied the water with some
>> mistaken statements of weaker memory guarantee. He has been corrected)
>>
>> Zhong Yu
>>
>> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit <yshavit at akiban.com>
>> wrote:
>> > There was a discussion here a few months ago about synchronizing
>> > constructors -- I had asked why it's not allowed, and the discussion
>> hit on
>> > some of the similar points brought up in this thread.
>> >
>> > But to your point specifically, synchronizing a constructor (via
>> > "synchronized(this) {...}" surrounding its body) still doesn't give
>> you full
>> > thread safety (even assuming immutability after the constructor --
>> but
>> > without final fields). It ensures that a thread can observe the
>> object
>> > either fully constructed *or* with all its fields having their
>> default
>> > values. In other words, even if your constructor is synchronized on
>> the same
>> > object your getter is, a thread could observe a field as it was
>> before the
>> > constructor was invoked.
>> >
>> > http://markmail.org/message/mav53xzo4bqu7udw
>> >
>> >
>> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
>> <cheremin at gmail.com>
>> > wrote:
>> >>
>> >> > The reason to keep them distinct is because in general the
>> mechanisms
>> >> > for
>> >> > safe publication are external to the class, while those for
>> >> > thread-safety
>> >> > are internal. It is only an edge case where use of synchronized in
>> a
>> >> > constructor can achieve safe-publication.
>> >>
>> >> Well, actually I do not understand your point. If I use some kind of
>> >> synchronization to make methods of my object thread-safe -- can't I
>> >> also apply same thing to constructor? For me, it makes the thing
>> only
>> >> clearer. Object can be thread-safe -- and it is totally thread safe.
>> >> Object can require external synchronization for correct
>> multithreaded
>> >> use -- and it requires the sync for publishing and for usage also.
>> >>
>> >> From my point of view, the distinction you talking about is more
>> >> historically reasoned. "Sync method if you want it to be thread-
>> safe"
>> >> is commonly learned mantra, but "take care of initialization also"
>> is
>> >> not so common. More information about it, more education, more
>> >> different code samples with outlined "here is the dragons" will
>> change
>> >> the situation, I sure, it just have to be highlighted more often.
>> >>
>> >>
>> >> > People have to recognize that sharing an object requires shared
>> mutable
>> >> > state, and the number one tenet of concurrent programming is that
>> access
>> >> > to
>> >> > shared mutable state has to be synchronized (in a general sense
>> not
>> >> > specifically use of 'synchronized' keyword).
>> >> >
>> >> > Making every object safely publishable could be done, but for 99%
>> of
>> >> > objects
>> >> > it would be a waste of effort. Programs without data races don't
>> have
>> >> > issues
>> >> > with unsafe publication.
>> >> >
>> >> > David
>> >> >
>> >> > -----Original Message-----
>> >> > From: concurrency-interest-bounces at cs.oswego.edu
>> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
>> Nathan
>> >> > Reynolds
>> >> > Sent: Wednesday, 15 August 2012 4:59 AM
>> >> > To: concurrency-interest at cs.oswego.edu
>> >> > Subject: Re: [concurrency-interest] Double Checked Locking in
>> OpenJDK
>> >> >
>> >> > We seem to be splitting two notions (i.e thread-safe and safe
>> >> > publication)
>> >> > when they should be combined in a sense.  Typically, when we say
>> >> > thread-safe
>> >> > we talk about the operations performed on the object after it was
>> >> > constructed (and its contents are globally visible).  However, we
>> need
>> >> > to
>> >> > consider that executing the constructor is modifying the state of
>> the
>> >> > object.  It requires the same mechanisms that the rest of the
>> class uses
>> >> > to
>> >> > ensure thread-safety.  Even though, there is only 1 thread
>> executing the
>> >> > constructor, a proper releasing of a lock or some other happens-
>> before
>> >> > construct is required to ensure that the memory updates by the
>> thread
>> >> > are
>> >> > made globally visible before the object is accessed by another
>> thread.
>> >> > This
>> >> > is what we are calling safe publication.  So, safe publication is
>> a
>> >> > subset
>> >> > of thread-safety except it is limited to what happens after the
>> >> > constructor
>> >> > is called and before the object is used by multiple threads.
>> >> >
>> >> > A beautifully-written class can be thread-safe with respect to
>> calling
>> >> > its
>> >> > member methods but not thread-safe with respect to calling its
>> >> > constructor.
>> >> > It is this latter case that many stumble upon because they think
>> that
>> >> > constructors are inherently thread-safe because they are executed
>> >> > single-threadedly.  What they fail to realize is that the
>> execution of a
>> >> > constructor can overlap with the execution of other code from the
>> view
>> >> > point
>> >> > of what is happening in memory.  This same problem applies to more
>> rare
>> >> > case
>> >> > of regular methods which can be proven to execute in a single
>> thread but
>> >> > don't use synchronization before multiple threads start accessing
>> the
>> >> > shared
>> >> > data.
>> >> >
>> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>> 602.333.9091
>> >> > Oracle PSR Engineering | Server Technology
>> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
>> >> >
>> >> > Ruslan Cheremin writes:
>> >> >
>> >> > For me it is confusing: java has only one way to have really
>> immutable
>> >> > object, and this way also gives you a total thread safety even for
>> >> > data race based publication. But then docs refer object as
>> "immutable
>> >> > and thread-safe" -- we still can't assume it to be really thread-
>> safe?
>> >> >
>> >> > It is better/simpler to isolate the notion of thread-safety and
>> safe
>> >> > publication. Thread-safety comes into play after you have safely
>> shared
>> >> > an
>> >> > object. The means by which you safely share an object is
>> orthogonal to
>> >> > how
>> >> > the object itself is made thread-safe.
>> >> >
>> >> > The means by which an object is shared has to involve shared
>> mutable
>> >> > state,
>> >> > and use of shared mutable state always needs some form of
>> >> > synchronization
>> >> > (either implicit eg due to static initialization; or explicit by
>> using
>> >> > volatile or synchronized getter/setter methods).
>> >> >
>> >> > David
>> >> > -----
>> >> >
>> >> > It's a pity, especially because true immutability gives us some
>> >> > chances of performance optimization. As in this case -- we do not
>> >> > really need .path to be volatile here, if we would assume Path to
>> be
>> >> > truly immutable. volatility here required only for ensuring safe
>> >> > publishing.
>> >> >
>> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >
>> >> > Ruslan Cheremin writes:>
>> >> >
>> >> > But is there a way to define "safe for data race publishing"? I as
>> >> > far, as I remember, "immutable and thread-safe" is standard mantra
>> in
>> >> > JDK javadocs for totally safe objects. j.l.String has same mantra
>> --
>> >> > and it is safe for any way of publishing. Does you mean, I should
>> >> > explicitly add "safe even for publishing via data race" in docs?
>> But I
>> >> > can't remember any such phrase in JDK docs.
>> >> >
>> >> > I don't recall anything in the JDK docs that mention being
>> >> >
>> >> > "totally safe"
>> >> >
>> >> > regardless of publication mechanism. Some classes, eg String, have
>> been
>> >> > defined such that they do have that property (for security
>> reasons). In
>> >> > general neither "thread-safe" nor "immutable" imply
>> >> > safe-for-unsynchronized-publication.
>> >> >
>> >> > Java Concurrency In Practice (jcip.net) does define additional
>> potential
>> >> > annotations, where @Immutable would indeed capture the requirement
>> of
>> >> > safe-for-unsynchronized-publication.
>> >> >
>> >> > David
>> >> > -----
>> >> >
>> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >
>> >> > Ruslan Cheremin writes:
>> >> >
>> >> > Well, Path javadoc explicitly says "immutable and safe for
>> >> > multithreaded use". Although it is not strictly defined in java
>> what
>> >> > exactly means "safe for multithreaded use" -- does it mean safe
>> for
>> >> > publishing via data race, among others? -- I suppose, it
>> >> >
>> >> > should be. Am
>> >> >
>> >> > I wrong here?
>> >> >
>> >> > "safe for multi-threaded use" does not generally imply that it
>> >> >
>> >> > is safe to
>> >> >
>> >> > publish instances without synchronization of some form.
>> >> >
>> >> > David
>> >> > -----
>> >> >
>> >> > From other side, File.toPath javadoc explicitly says what
>> "returned
>> >> > instance must be the same for every invocation", so sync block is
>> >> > required here for mutual exclusion on initialization phase.
>> Without
>> >> > this requirement it is also safe to live without sync block,
>> afaik.
>> >> >
>> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >
>> >> > Ruslan Cheremin writes:
>> >> >
>> >> > First of all, Path is immutable, so DCL is safe here even without
>> >> > volatile. Volatile here is not required from my point of view.
>> >> >
>> >> > Without the volatile the Path implementation (Path is an
>> >> >
>> >> > interface) must be
>> >> >
>> >> > such that an instance of Path can be safely published without
>> >> >
>> >> > any additional
>> >> >
>> >> > forms of synchronization. Immutability does not in itself
>> >> >
>> >> > ensure that. You
>> >> >
>> >> > would have to examine the actual implementation class.
>> >> >
>> >> > David Holmes
>> >> > ------------
>> >> >
>> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> >
>> >> > Hi Richard,
>> >> >
>> >> > The variable "filePath" is volatile, so the double-checked
>> >> >
>> >> > locking is correct in this case. It would have been a bug
>> >> >
>> >> > prior to Java 5.
>> >> >
>> >> > Best regards,
>> >> >
>> >> > Dmitry Vyazelenko
>> >> >
>> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >
>> >> > <richard.warburton at gmail.com> wrote:
>> >> >
>> >> > Hello,
>> >> >
>> >> > The current implementation of java.io.File::toPath [0]
>> >> >
>> >> > appears to be
>> >> >
>> >> > using the double checked locking pattern:
>> >> >
>> >> >     public Path toPath() {
>> >> >         Path result = filePath;
>> >> >         if (result == null) {
>> >> >             synchronized (this) {
>> >> >                 result = filePath;
>> >> >                 if (result == null) {
>> >> >                     result =
>> >> >
>> >> > FileSystems.getDefault().getPath(path);
>> >> >
>> >> >                     filePath = result;
>> >> >                 }
>> >> >             }
>> >> >         }
>> >> >         return result;
>> >> >     }
>> >> >
>> >> > I was going to report the bug, but I'm a little
>> >> >
>> >> > uncertain of the
>> >> >
>> >> > interaction between the local variable 'result' and DCL
>> >> >
>> >> > since I've
>> >> >
>> >> > previously only seen the checking condition on the
>> >> >
>> >> > shared field
>> >> >
>> >> > itself.  Can someone here either confirm that its a bug or
>> >> >
>> >> > explain how
>> >> >
>> >> > the 'result' variable is fixing things?
>> >> >
>> >> > regards,
>> >> >
>> >> >  Richard
>> >> >
>> >> > [0] See the end of
>> >> >
>> >> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> >
>> >> > ses/java/io/File.java
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> >
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From hans.boehm at hp.com  Wed Aug 15 16:39:53 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 15 Aug 2012 20:39:53 +0000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>

> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> 
> As far, as I can see, there is two directions. One is what
> "thread-safe" notation in it's commonly used form -- then applied only
> to methods, and not to initialization/publication -- is confusing, and
> there is little reason to exclude construction/publication from thread
> safety protocol by default. My point, among others, is that "immutable
> and thread safe" should be interpreted as "thread safe even for unsafe
> publishing". And this, for example, gives us the chance to remove
> volatile specification in File.path field we started from :)
It seems to me that there's a huge difference here.  Synchronization in the constructor only matters in the presence of other dubious programming practices:  Either a reference to the object has to escape before the constructor finishes, or the reference has to be communicated to another thread in a racy manner.  (And the former is a special case under control of the class itself.)  There are strong reasons to avoid both in the vast majority of code.  On the other hand, perfectly normal code will routinely rely on the thread-safety of non-constructor methods all the time.
 
> 
> Second direction is about construction/publication as specifically
> different from the methods. E.g. it even may have additional safety
> guarantee -- like "publication is always safe". I can see some reasons
> here, since constructor is the only one method, which is guaranteed to
> be called only once on object lifecycle, and so we, possible, can
> restrict some compiler/CPUs optimization in it with little influence
> on overall application performance -- but it throws away all troubles
> with unsafe publishing.
I think we're still generally using "unsafe publishing" to mean either of the two dubious practices I mentioned above, though here we're presumably talking about racy publication after the constructor completes.  The problem is that in general racy publication is already a really bad practice, because the user has to understand the ugly details of the Java memory model, which nobody really does.  Racy publication is a data race, and hence you can no longer reason in terms of sequential consistency, synchronization-free regions become nonatomic, and generally all our intuition about behavior of threads and reasoning about threads goes out the window, even if you can still reason about the integrity of your class.  There are one or two special cases, notably lazy initialization of an immutable object, where you might succeed in hiding all that mess behind a library API, but in general that's hard.  So the question in my mind is whether you want to provide those added guarantees to support those one or two cases, or whether you want to limit those guarantees to situations, notably those involving final fields, where they're essential for the security model.  We currently have the latter.

Hans
> 
> 
> 
> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
> > Agreed.
> >
> > But, echoing David, I think, I'm not at all sure I see where this
> thread is going.  We've established that
> >
> > a) You can make a class safe against racy publication by
> synchronizing the constructor along with all other methods (or by using
> an immutable class with final fields).
> >
> > b) There are (rather brittle and obscure) use cases in which racy
> publication gives you better performance on architectures like ARM,
> though not x86, currently at the cost of confusing data race detectors.
> >
> > But to me it seems like taking advanatage of (b) is a fairly
> undesirable, though perhaps occasionally unavoidable, hack.  And I
> can't see why it would possibly be a win if you have to synchronize all
> method calls to make it work.
> >
> > Does anyone have a use case in mind where the whole picture we're
> discussing actually makes sense?  It might help to focus this
> discussion.
> >
> > Hans
> >
> >> -----Original Message-----
> >> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-
> >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
> >> Sent: Wednesday, August 15, 2012 10:56 AM
> >> To: Yuval Shavit
> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> >> Subject: Re: [concurrency-interest] Double Checked Locking in
> OpenJDK
> >>
> >> I thought the conclusion of that thread is that synchronizing
> >> constructor has the desired merit - if all constructors and methods
> >> are synchronized, a non-creating thread won't observe the
> zero/partial
> >> state of the object, even if the object reference is published
> >> unsafely.
> >>
> >> (One guy, who shall remain nameless, muddied the water with some
> >> mistaken statements of weaker memory guarantee. He has been
> corrected)
> >>
> >> Zhong Yu
> >>
> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit <yshavit at akiban.com>
> >> wrote:
> >> > There was a discussion here a few months ago about synchronizing
> >> > constructors -- I had asked why it's not allowed, and the
> discussion
> >> hit on
> >> > some of the similar points brought up in this thread.
> >> >
> >> > But to your point specifically, synchronizing a constructor (via
> >> > "synchronized(this) {...}" surrounding its body) still doesn't
> give
> >> you full
> >> > thread safety (even assuming immutability after the constructor --
> >> but
> >> > without final fields). It ensures that a thread can observe the
> >> object
> >> > either fully constructed *or* with all its fields having their
> >> default
> >> > values. In other words, even if your constructor is synchronized
> on
> >> the same
> >> > object your getter is, a thread could observe a field as it was
> >> before the
> >> > constructor was invoked.
> >> >
> >> > http://markmail.org/message/mav53xzo4bqu7udw
> >> >
> >> >
> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
> >> <cheremin at gmail.com>
> >> > wrote:
> >> >>
> >> >> > The reason to keep them distinct is because in general the
> >> mechanisms
> >> >> > for
> >> >> > safe publication are external to the class, while those for
> >> >> > thread-safety
> >> >> > are internal. It is only an edge case where use of synchronized
> in
> >> a
> >> >> > constructor can achieve safe-publication.
> >> >>
> >> >> Well, actually I do not understand your point. If I use some kind
> of
> >> >> synchronization to make methods of my object thread-safe -- can't
> I
> >> >> also apply same thing to constructor? For me, it makes the thing
> >> only
> >> >> clearer. Object can be thread-safe -- and it is totally thread
> safe.
> >> >> Object can require external synchronization for correct
> >> multithreaded
> >> >> use -- and it requires the sync for publishing and for usage
> also.
> >> >>
> >> >> From my point of view, the distinction you talking about is more
> >> >> historically reasoned. "Sync method if you want it to be thread-
> >> safe"
> >> >> is commonly learned mantra, but "take care of initialization
> also"
> >> is
> >> >> not so common. More information about it, more education, more
> >> >> different code samples with outlined "here is the dragons" will
> >> change
> >> >> the situation, I sure, it just have to be highlighted more often.
> >> >>
> >> >>
> >> >> > People have to recognize that sharing an object requires shared
> >> mutable
> >> >> > state, and the number one tenet of concurrent programming is
> that
> >> access
> >> >> > to
> >> >> > shared mutable state has to be synchronized (in a general sense
> >> not
> >> >> > specifically use of 'synchronized' keyword).
> >> >> >
> >> >> > Making every object safely publishable could be done, but for
> 99%
> >> of
> >> >> > objects
> >> >> > it would be a waste of effort. Programs without data races
> don't
> >> have
> >> >> > issues
> >> >> > with unsafe publication.
> >> >> >
> >> >> > David
> >> >> >
> >> >> > -----Original Message-----
> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
> >> Nathan
> >> >> > Reynolds
> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
> >> >> > To: concurrency-interest at cs.oswego.edu
> >> >> > Subject: Re: [concurrency-interest] Double Checked Locking in
> >> OpenJDK
> >> >> >
> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
> >> >> > publication)
> >> >> > when they should be combined in a sense.  Typically, when we
> say
> >> >> > thread-safe
> >> >> > we talk about the operations performed on the object after it
> was
> >> >> > constructed (and its contents are globally visible).  However,
> we
> >> need
> >> >> > to
> >> >> > consider that executing the constructor is modifying the state
> of
> >> the
> >> >> > object.  It requires the same mechanisms that the rest of the
> >> class uses
> >> >> > to
> >> >> > ensure thread-safety.  Even though, there is only 1 thread
> >> executing the
> >> >> > constructor, a proper releasing of a lock or some other
> happens-
> >> before
> >> >> > construct is required to ensure that the memory updates by the
> >> thread
> >> >> > are
> >> >> > made globally visible before the object is accessed by another
> >> thread.
> >> >> > This
> >> >> > is what we are calling safe publication.  So, safe publication
> is
> >> a
> >> >> > subset
> >> >> > of thread-safety except it is limited to what happens after the
> >> >> > constructor
> >> >> > is called and before the object is used by multiple threads.
> >> >> >
> >> >> > A beautifully-written class can be thread-safe with respect to
> >> calling
> >> >> > its
> >> >> > member methods but not thread-safe with respect to calling its
> >> >> > constructor.
> >> >> > It is this latter case that many stumble upon because they
> think
> >> that
> >> >> > constructors are inherently thread-safe because they are
> executed
> >> >> > single-threadedly.  What they fail to realize is that the
> >> execution of a
> >> >> > constructor can overlap with the execution of other code from
> the
> >> view
> >> >> > point
> >> >> > of what is happening in memory.  This same problem applies to
> more
> >> rare
> >> >> > case
> >> >> > of regular methods which can be proven to execute in a single
> >> thread but
> >> >> > don't use synchronization before multiple threads start
> accessing
> >> the
> >> >> > shared
> >> >> > data.
> >> >> >
> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> >> 602.333.9091
> >> >> > Oracle PSR Engineering | Server Technology
> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >> >> >
> >> >> > Ruslan Cheremin writes:
> >> >> >
> >> >> > For me it is confusing: java has only one way to have really
> >> immutable
> >> >> > object, and this way also gives you a total thread safety even
> for
> >> >> > data race based publication. But then docs refer object as
> >> "immutable
> >> >> > and thread-safe" -- we still can't assume it to be really
> thread-
> >> safe?
> >> >> >
> >> >> > It is better/simpler to isolate the notion of thread-safety and
> >> safe
> >> >> > publication. Thread-safety comes into play after you have
> safely
> >> shared
> >> >> > an
> >> >> > object. The means by which you safely share an object is
> >> orthogonal to
> >> >> > how
> >> >> > the object itself is made thread-safe.
> >> >> >
> >> >> > The means by which an object is shared has to involve shared
> >> mutable
> >> >> > state,
> >> >> > and use of shared mutable state always needs some form of
> >> >> > synchronization
> >> >> > (either implicit eg due to static initialization; or explicit
> by
> >> using
> >> >> > volatile or synchronized getter/setter methods).
> >> >> >
> >> >> > David
> >> >> > -----
> >> >> >
> >> >> > It's a pity, especially because true immutability gives us some
> >> >> > chances of performance optimization. As in this case -- we do
> not
> >> >> > really need .path to be volatile here, if we would assume Path
> to
> >> be
> >> >> > truly immutable. volatility here required only for ensuring
> safe
> >> >> > publishing.
> >> >> >
> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >
> >> >> > Ruslan Cheremin writes:>
> >> >> >
> >> >> > But is there a way to define "safe for data race publishing"? I
> as
> >> >> > far, as I remember, "immutable and thread-safe" is standard
> mantra
> >> in
> >> >> > JDK javadocs for totally safe objects. j.l.String has same
> mantra
> >> --
> >> >> > and it is safe for any way of publishing. Does you mean, I
> should
> >> >> > explicitly add "safe even for publishing via data race" in
> docs?
> >> But I
> >> >> > can't remember any such phrase in JDK docs.
> >> >> >
> >> >> > I don't recall anything in the JDK docs that mention being
> >> >> >
> >> >> > "totally safe"
> >> >> >
> >> >> > regardless of publication mechanism. Some classes, eg String,
> have
> >> been
> >> >> > defined such that they do have that property (for security
> >> reasons). In
> >> >> > general neither "thread-safe" nor "immutable" imply
> >> >> > safe-for-unsynchronized-publication.
> >> >> >
> >> >> > Java Concurrency In Practice (jcip.net) does define additional
> >> potential
> >> >> > annotations, where @Immutable would indeed capture the
> requirement
> >> of
> >> >> > safe-for-unsynchronized-publication.
> >> >> >
> >> >> > David
> >> >> > -----
> >> >> >
> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >
> >> >> > Ruslan Cheremin writes:
> >> >> >
> >> >> > Well, Path javadoc explicitly says "immutable and safe for
> >> >> > multithreaded use". Although it is not strictly defined in java
> >> what
> >> >> > exactly means "safe for multithreaded use" -- does it mean safe
> >> for
> >> >> > publishing via data race, among others? -- I suppose, it
> >> >> >
> >> >> > should be. Am
> >> >> >
> >> >> > I wrong here?
> >> >> >
> >> >> > "safe for multi-threaded use" does not generally imply that it
> >> >> >
> >> >> > is safe to
> >> >> >
> >> >> > publish instances without synchronization of some form.
> >> >> >
> >> >> > David
> >> >> > -----
> >> >> >
> >> >> > From other side, File.toPath javadoc explicitly says what
> >> "returned
> >> >> > instance must be the same for every invocation", so sync block
> is
> >> >> > required here for mutual exclusion on initialization phase.
> >> Without
> >> >> > this requirement it is also safe to live without sync block,
> >> afaik.
> >> >> >
> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >
> >> >> > Ruslan Cheremin writes:
> >> >> >
> >> >> > First of all, Path is immutable, so DCL is safe here even
> without
> >> >> > volatile. Volatile here is not required from my point of view.
> >> >> >
> >> >> > Without the volatile the Path implementation (Path is an
> >> >> >
> >> >> > interface) must be
> >> >> >
> >> >> > such that an instance of Path can be safely published without
> >> >> >
> >> >> > any additional
> >> >> >
> >> >> > forms of synchronization. Immutability does not in itself
> >> >> >
> >> >> > ensure that. You
> >> >> >
> >> >> > would have to examine the actual implementation class.
> >> >> >
> >> >> > David Holmes
> >> >> > ------------
> >> >> >
> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >
> >> >> > Hi Richard,
> >> >> >
> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> >
> >> >> > locking is correct in this case. It would have been a bug
> >> >> >
> >> >> > prior to Java 5.
> >> >> >
> >> >> > Best regards,
> >> >> >
> >> >> > Dmitry Vyazelenko
> >> >> >
> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >
> >> >> > <richard.warburton at gmail.com> wrote:
> >> >> >
> >> >> > Hello,
> >> >> >
> >> >> > The current implementation of java.io.File::toPath [0]
> >> >> >
> >> >> > appears to be
> >> >> >
> >> >> > using the double checked locking pattern:
> >> >> >
> >> >> >     public Path toPath() {
> >> >> >         Path result = filePath;
> >> >> >         if (result == null) {
> >> >> >             synchronized (this) {
> >> >> >                 result = filePath;
> >> >> >                 if (result == null) {
> >> >> >                     result =
> >> >> >
> >> >> > FileSystems.getDefault().getPath(path);
> >> >> >
> >> >> >                     filePath = result;
> >> >> >                 }
> >> >> >             }
> >> >> >         }
> >> >> >         return result;
> >> >> >     }
> >> >> >
> >> >> > I was going to report the bug, but I'm a little
> >> >> >
> >> >> > uncertain of the
> >> >> >
> >> >> > interaction between the local variable 'result' and DCL
> >> >> >
> >> >> > since I've
> >> >> >
> >> >> > previously only seen the checking condition on the
> >> >> >
> >> >> > shared field
> >> >> >
> >> >> > itself.  Can someone here either confirm that its a bug or
> >> >> >
> >> >> > explain how
> >> >> >
> >> >> > the 'result' variable is fixing things?
> >> >> >
> >> >> > regards,
> >> >> >
> >> >> >  Richard
> >> >> >
> >> >> > [0] See the end of
> >> >> >
> >> >> >
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >
> >> >> > ses/java/io/File.java
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> >
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> _______________________________________________
> >> >> Concurrency-interest mailing list
> >> >> Concurrency-interest at cs.oswego.edu
> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> >
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From raould at gmail.com  Wed Aug 15 16:59:14 2012
From: raould at gmail.com (Raoul Duke)
Date: Wed, 15 Aug 2012 13:59:14 -0700
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
Message-ID: <CAJ7XQb6vSh18cL4anQdHfgeEZvm0akEK9rFVv-L-MTyRvORFTw@mail.gmail.com>

thank you for saying that :-)

On Wed, Aug 15, 2012 at 1:39 PM, Boehm, Hans <hans.boehm at hp.com> wrote:
> The problem is that in general racy publication is already a really bad practice, because the user has to understand the ugly details of the Java memory model, which nobody really does.

From yshavit at akiban.com  Wed Aug 15 17:05:13 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Wed, 15 Aug 2012 17:05:13 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
Message-ID: <CAC2Zdp067842v9RwCKSaig-vosxTUX84n=RgxyPue7bHC31Huw@mail.gmail.com>

I agree. If I may hazard a more succinct way of phrasing it:

There are two variants of "thread safe": thread safe assuming safe initial
publication, and thread safe even in the absence of safe publication. We
have to pick one as the default, for when we just want the shorthand
"thread safe" without qualification. Although one could argue that the
latter is more purely thread safe, the counter argument is that the former
is more useful in day-to-day programming.

On Wed, Aug 15, 2012 at 4:39 PM, Boehm, Hans <hans.boehm at hp.com> wrote:

> > From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> >
> > As far, as I can see, there is two directions. One is what
> > "thread-safe" notation in it's commonly used form -- then applied only
> > to methods, and not to initialization/publication -- is confusing, and
> > there is little reason to exclude construction/publication from thread
> > safety protocol by default. My point, among others, is that "immutable
> > and thread safe" should be interpreted as "thread safe even for unsafe
> > publishing". And this, for example, gives us the chance to remove
> > volatile specification in File.path field we started from :)
> It seems to me that there's a huge difference here.  Synchronization in
> the constructor only matters in the presence of other dubious programming
> practices:  Either a reference to the object has to escape before the
> constructor finishes, or the reference has to be communicated to another
> thread in a racy manner.  (And the former is a special case under control
> of the class itself.)  There are strong reasons to avoid both in the vast
> majority of code.  On the other hand, perfectly normal code will routinely
> rely on the thread-safety of non-constructor methods all the time.
>
> >
> > Second direction is about construction/publication as specifically
> > different from the methods. E.g. it even may have additional safety
> > guarantee -- like "publication is always safe". I can see some reasons
> > here, since constructor is the only one method, which is guaranteed to
> > be called only once on object lifecycle, and so we, possible, can
> > restrict some compiler/CPUs optimization in it with little influence
> > on overall application performance -- but it throws away all troubles
> > with unsafe publishing.
> I think we're still generally using "unsafe publishing" to mean either of
> the two dubious practices I mentioned above, though here we're presumably
> talking about racy publication after the constructor completes.  The
> problem is that in general racy publication is already a really bad
> practice, because the user has to understand the ugly details of the Java
> memory model, which nobody really does.  Racy publication is a data race,
> and hence you can no longer reason in terms of sequential consistency,
> synchronization-free regions become nonatomic, and generally all our
> intuition about behavior of threads and reasoning about threads goes out
> the window, even if you can still reason about the integrity of your class.
>  There are one or two special cases, notably lazy initialization of an
> immutable object, where you might succeed in hiding all that mess behind a
> library API, but in general that's hard.  So the question in my mind is
> whether you want to provide those added guarantees to support those one or
> two cases, or whether you want to limit those guarantees to situations,
> notably those involving final fields, where they're essential for the
> security model.  We currently have the latter.
>
> Hans
> >
> >
> >
> > 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
> > > Agreed.
> > >
> > > But, echoing David, I think, I'm not at all sure I see where this
> > thread is going.  We've established that
> > >
> > > a) You can make a class safe against racy publication by
> > synchronizing the constructor along with all other methods (or by using
> > an immutable class with final fields).
> > >
> > > b) There are (rather brittle and obscure) use cases in which racy
> > publication gives you better performance on architectures like ARM,
> > though not x86, currently at the cost of confusing data race detectors.
> > >
> > > But to me it seems like taking advanatage of (b) is a fairly
> > undesirable, though perhaps occasionally unavoidable, hack.  And I
> > can't see why it would possibly be a win if you have to synchronize all
> > method calls to make it work.
> > >
> > > Does anyone have a use case in mind where the whole picture we're
> > discussing actually makes sense?  It might help to focus this
> > discussion.
> > >
> > > Hans
> > >
> > >> -----Original Message-----
> > >> From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-
> > >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
> > >> Sent: Wednesday, August 15, 2012 10:56 AM
> > >> To: Yuval Shavit
> > >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> > >> Subject: Re: [concurrency-interest] Double Checked Locking in
> > OpenJDK
> > >>
> > >> I thought the conclusion of that thread is that synchronizing
> > >> constructor has the desired merit - if all constructors and methods
> > >> are synchronized, a non-creating thread won't observe the
> > zero/partial
> > >> state of the object, even if the object reference is published
> > >> unsafely.
> > >>
> > >> (One guy, who shall remain nameless, muddied the water with some
> > >> mistaken statements of weaker memory guarantee. He has been
> > corrected)
> > >>
> > >> Zhong Yu
> > >>
> > >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit <yshavit at akiban.com>
> > >> wrote:
> > >> > There was a discussion here a few months ago about synchronizing
> > >> > constructors -- I had asked why it's not allowed, and the
> > discussion
> > >> hit on
> > >> > some of the similar points brought up in this thread.
> > >> >
> > >> > But to your point specifically, synchronizing a constructor (via
> > >> > "synchronized(this) {...}" surrounding its body) still doesn't
> > give
> > >> you full
> > >> > thread safety (even assuming immutability after the constructor --
> > >> but
> > >> > without final fields). It ensures that a thread can observe the
> > >> object
> > >> > either fully constructed *or* with all its fields having their
> > >> default
> > >> > values. In other words, even if your constructor is synchronized
> > on
> > >> the same
> > >> > object your getter is, a thread could observe a field as it was
> > >> before the
> > >> > constructor was invoked.
> > >> >
> > >> > http://markmail.org/message/mav53xzo4bqu7udw
> > >> >
> > >> >
> > >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
> > >> <cheremin at gmail.com>
> > >> > wrote:
> > >> >>
> > >> >> > The reason to keep them distinct is because in general the
> > >> mechanisms
> > >> >> > for
> > >> >> > safe publication are external to the class, while those for
> > >> >> > thread-safety
> > >> >> > are internal. It is only an edge case where use of synchronized
> > in
> > >> a
> > >> >> > constructor can achieve safe-publication.
> > >> >>
> > >> >> Well, actually I do not understand your point. If I use some kind
> > of
> > >> >> synchronization to make methods of my object thread-safe -- can't
> > I
> > >> >> also apply same thing to constructor? For me, it makes the thing
> > >> only
> > >> >> clearer. Object can be thread-safe -- and it is totally thread
> > safe.
> > >> >> Object can require external synchronization for correct
> > >> multithreaded
> > >> >> use -- and it requires the sync for publishing and for usage
> > also.
> > >> >>
> > >> >> From my point of view, the distinction you talking about is more
> > >> >> historically reasoned. "Sync method if you want it to be thread-
> > >> safe"
> > >> >> is commonly learned mantra, but "take care of initialization
> > also"
> > >> is
> > >> >> not so common. More information about it, more education, more
> > >> >> different code samples with outlined "here is the dragons" will
> > >> change
> > >> >> the situation, I sure, it just have to be highlighted more often.
> > >> >>
> > >> >>
> > >> >> > People have to recognize that sharing an object requires shared
> > >> mutable
> > >> >> > state, and the number one tenet of concurrent programming is
> > that
> > >> access
> > >> >> > to
> > >> >> > shared mutable state has to be synchronized (in a general sense
> > >> not
> > >> >> > specifically use of 'synchronized' keyword).
> > >> >> >
> > >> >> > Making every object safely publishable could be done, but for
> > 99%
> > >> of
> > >> >> > objects
> > >> >> > it would be a waste of effort. Programs without data races
> > don't
> > >> have
> > >> >> > issues
> > >> >> > with unsafe publication.
> > >> >> >
> > >> >> > David
> > >> >> >
> > >> >> > -----Original Message-----
> > >> >> > From: concurrency-interest-bounces at cs.oswego.edu
> > >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
> > >> Nathan
> > >> >> > Reynolds
> > >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
> > >> >> > To: concurrency-interest at cs.oswego.edu
> > >> >> > Subject: Re: [concurrency-interest] Double Checked Locking in
> > >> OpenJDK
> > >> >> >
> > >> >> > We seem to be splitting two notions (i.e thread-safe and safe
> > >> >> > publication)
> > >> >> > when they should be combined in a sense.  Typically, when we
> > say
> > >> >> > thread-safe
> > >> >> > we talk about the operations performed on the object after it
> > was
> > >> >> > constructed (and its contents are globally visible).  However,
> > we
> > >> need
> > >> >> > to
> > >> >> > consider that executing the constructor is modifying the state
> > of
> > >> the
> > >> >> > object.  It requires the same mechanisms that the rest of the
> > >> class uses
> > >> >> > to
> > >> >> > ensure thread-safety.  Even though, there is only 1 thread
> > >> executing the
> > >> >> > constructor, a proper releasing of a lock or some other
> > happens-
> > >> before
> > >> >> > construct is required to ensure that the memory updates by the
> > >> thread
> > >> >> > are
> > >> >> > made globally visible before the object is accessed by another
> > >> thread.
> > >> >> > This
> > >> >> > is what we are calling safe publication.  So, safe publication
> > is
> > >> a
> > >> >> > subset
> > >> >> > of thread-safety except it is limited to what happens after the
> > >> >> > constructor
> > >> >> > is called and before the object is used by multiple threads.
> > >> >> >
> > >> >> > A beautifully-written class can be thread-safe with respect to
> > >> calling
> > >> >> > its
> > >> >> > member methods but not thread-safe with respect to calling its
> > >> >> > constructor.
> > >> >> > It is this latter case that many stumble upon because they
> > think
> > >> that
> > >> >> > constructors are inherently thread-safe because they are
> > executed
> > >> >> > single-threadedly.  What they fail to realize is that the
> > >> execution of a
> > >> >> > constructor can overlap with the execution of other code from
> > the
> > >> view
> > >> >> > point
> > >> >> > of what is happening in memory.  This same problem applies to
> > more
> > >> rare
> > >> >> > case
> > >> >> > of regular methods which can be proven to execute in a single
> > >> thread but
> > >> >> > don't use synchronization before multiple threads start
> > accessing
> > >> the
> > >> >> > shared
> > >> >> > data.
> > >> >> >
> > >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> > >> 602.333.9091
> > >> >> > Oracle PSR Engineering | Server Technology
> > >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
> > >> >> >
> > >> >> > Ruslan Cheremin writes:
> > >> >> >
> > >> >> > For me it is confusing: java has only one way to have really
> > >> immutable
> > >> >> > object, and this way also gives you a total thread safety even
> > for
> > >> >> > data race based publication. But then docs refer object as
> > >> "immutable
> > >> >> > and thread-safe" -- we still can't assume it to be really
> > thread-
> > >> safe?
> > >> >> >
> > >> >> > It is better/simpler to isolate the notion of thread-safety and
> > >> safe
> > >> >> > publication. Thread-safety comes into play after you have
> > safely
> > >> shared
> > >> >> > an
> > >> >> > object. The means by which you safely share an object is
> > >> orthogonal to
> > >> >> > how
> > >> >> > the object itself is made thread-safe.
> > >> >> >
> > >> >> > The means by which an object is shared has to involve shared
> > >> mutable
> > >> >> > state,
> > >> >> > and use of shared mutable state always needs some form of
> > >> >> > synchronization
> > >> >> > (either implicit eg due to static initialization; or explicit
> > by
> > >> using
> > >> >> > volatile or synchronized getter/setter methods).
> > >> >> >
> > >> >> > David
> > >> >> > -----
> > >> >> >
> > >> >> > It's a pity, especially because true immutability gives us some
> > >> >> > chances of performance optimization. As in this case -- we do
> > not
> > >> >> > really need .path to be volatile here, if we would assume Path
> > to
> > >> be
> > >> >> > truly immutable. volatility here required only for ensuring
> > safe
> > >> >> > publishing.
> > >> >> >
> > >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >> >> >
> > >> >> > Ruslan Cheremin writes:>
> > >> >> >
> > >> >> > But is there a way to define "safe for data race publishing"? I
> > as
> > >> >> > far, as I remember, "immutable and thread-safe" is standard
> > mantra
> > >> in
> > >> >> > JDK javadocs for totally safe objects. j.l.String has same
> > mantra
> > >> --
> > >> >> > and it is safe for any way of publishing. Does you mean, I
> > should
> > >> >> > explicitly add "safe even for publishing via data race" in
> > docs?
> > >> But I
> > >> >> > can't remember any such phrase in JDK docs.
> > >> >> >
> > >> >> > I don't recall anything in the JDK docs that mention being
> > >> >> >
> > >> >> > "totally safe"
> > >> >> >
> > >> >> > regardless of publication mechanism. Some classes, eg String,
> > have
> > >> been
> > >> >> > defined such that they do have that property (for security
> > >> reasons). In
> > >> >> > general neither "thread-safe" nor "immutable" imply
> > >> >> > safe-for-unsynchronized-publication.
> > >> >> >
> > >> >> > Java Concurrency In Practice (jcip.net) does define additional
> > >> potential
> > >> >> > annotations, where @Immutable would indeed capture the
> > requirement
> > >> of
> > >> >> > safe-for-unsynchronized-publication.
> > >> >> >
> > >> >> > David
> > >> >> > -----
> > >> >> >
> > >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >> >> >
> > >> >> > Ruslan Cheremin writes:
> > >> >> >
> > >> >> > Well, Path javadoc explicitly says "immutable and safe for
> > >> >> > multithreaded use". Although it is not strictly defined in java
> > >> what
> > >> >> > exactly means "safe for multithreaded use" -- does it mean safe
> > >> for
> > >> >> > publishing via data race, among others? -- I suppose, it
> > >> >> >
> > >> >> > should be. Am
> > >> >> >
> > >> >> > I wrong here?
> > >> >> >
> > >> >> > "safe for multi-threaded use" does not generally imply that it
> > >> >> >
> > >> >> > is safe to
> > >> >> >
> > >> >> > publish instances without synchronization of some form.
> > >> >> >
> > >> >> > David
> > >> >> > -----
> > >> >> >
> > >> >> > From other side, File.toPath javadoc explicitly says what
> > >> "returned
> > >> >> > instance must be the same for every invocation", so sync block
> > is
> > >> >> > required here for mutual exclusion on initialization phase.
> > >> Without
> > >> >> > this requirement it is also safe to live without sync block,
> > >> afaik.
> > >> >> >
> > >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >> >> >
> > >> >> > Ruslan Cheremin writes:
> > >> >> >
> > >> >> > First of all, Path is immutable, so DCL is safe here even
> > without
> > >> >> > volatile. Volatile here is not required from my point of view.
> > >> >> >
> > >> >> > Without the volatile the Path implementation (Path is an
> > >> >> >
> > >> >> > interface) must be
> > >> >> >
> > >> >> > such that an instance of Path can be safely published without
> > >> >> >
> > >> >> > any additional
> > >> >> >
> > >> >> > forms of synchronization. Immutability does not in itself
> > >> >> >
> > >> >> > ensure that. You
> > >> >> >
> > >> >> > would have to examine the actual implementation class.
> > >> >> >
> > >> >> > David Holmes
> > >> >> > ------------
> > >> >> >
> > >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> > >> >> >
> > >> >> > Hi Richard,
> > >> >> >
> > >> >> > The variable "filePath" is volatile, so the double-checked
> > >> >> >
> > >> >> > locking is correct in this case. It would have been a bug
> > >> >> >
> > >> >> > prior to Java 5.
> > >> >> >
> > >> >> > Best regards,
> > >> >> >
> > >> >> > Dmitry Vyazelenko
> > >> >> >
> > >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> > >> >> >
> > >> >> > <richard.warburton at gmail.com> wrote:
> > >> >> >
> > >> >> > Hello,
> > >> >> >
> > >> >> > The current implementation of java.io.File::toPath [0]
> > >> >> >
> > >> >> > appears to be
> > >> >> >
> > >> >> > using the double checked locking pattern:
> > >> >> >
> > >> >> >     public Path toPath() {
> > >> >> >         Path result = filePath;
> > >> >> >         if (result == null) {
> > >> >> >             synchronized (this) {
> > >> >> >                 result = filePath;
> > >> >> >                 if (result == null) {
> > >> >> >                     result =
> > >> >> >
> > >> >> > FileSystems.getDefault().getPath(path);
> > >> >> >
> > >> >> >                     filePath = result;
> > >> >> >                 }
> > >> >> >             }
> > >> >> >         }
> > >> >> >         return result;
> > >> >> >     }
> > >> >> >
> > >> >> > I was going to report the bug, but I'm a little
> > >> >> >
> > >> >> > uncertain of the
> > >> >> >
> > >> >> > interaction between the local variable 'result' and DCL
> > >> >> >
> > >> >> > since I've
> > >> >> >
> > >> >> > previously only seen the checking condition on the
> > >> >> >
> > >> >> > shared field
> > >> >> >
> > >> >> > itself.  Can someone here either confirm that its a bug or
> > >> >> >
> > >> >> > explain how
> > >> >> >
> > >> >> > the 'result' variable is fixing things?
> > >> >> >
> > >> >> > regards,
> > >> >> >
> > >> >> >  Richard
> > >> >> >
> > >> >> > [0] See the end of
> > >> >> >
> > >> >> >
> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> > >> >> >
> > >> >> > ses/java/io/File.java
> > >> >> >
> > >> >> > _______________________________________________
> > >> >> > Concurrency-interest mailing list
> > >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >
> > >> >> > _______________________________________________
> > >> >> > Concurrency-interest mailing list
> > >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >
> > >> >> > _______________________________________________
> > >> >> > Concurrency-interest mailing list
> > >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >
> > >> >> > _______________________________________________
> > >> >> > Concurrency-interest mailing list
> > >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >
> > >> >> >
> > >> >> >
> > >> >> > _______________________________________________
> > >> >> > Concurrency-interest mailing list
> > >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >
> > >> >> _______________________________________________
> > >> >> Concurrency-interest mailing list
> > >> >> Concurrency-interest at cs.oswego.edu
> > >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >
> > >> >
> > >> >
> > >> > _______________________________________________
> > >> > Concurrency-interest mailing list
> > >> > Concurrency-interest at cs.oswego.edu
> > >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >
> > >> _______________________________________________
> > >> Concurrency-interest mailing list
> > >> Concurrency-interest at cs.oswego.edu
> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/737f2f91/attachment-0001.html>

From cheremin at gmail.com  Wed Aug 15 17:19:26 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Thu, 16 Aug 2012 01:19:26 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
Message-ID: <CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>

Well, I understand your point.

But this lead me to another interesting question -- why data races is
so outlaw? Yes, I understand, it is hard to write correct code with
them (by the way, can you give the link about errors in JMM spec about
data race you've mention above?), but can we scale really well with
sequentially consistent execution only? I mean, in large-scale
distributed systems design weakening consistency often gives great
performance benefits. AndwWhen I think about something like 786-cores
(skip the brand) box, it seems for me there could be many chances to
improve performance using racy code. Am I miss something here?

2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
>> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
>>
>> As far, as I can see, there is two directions. One is what
>> "thread-safe" notation in it's commonly used form -- then applied only
>> to methods, and not to initialization/publication -- is confusing, and
>> there is little reason to exclude construction/publication from thread
>> safety protocol by default. My point, among others, is that "immutable
>> and thread safe" should be interpreted as "thread safe even for unsafe
>> publishing". And this, for example, gives us the chance to remove
>> volatile specification in File.path field we started from :)
> It seems to me that there's a huge difference here.  Synchronization in the constructor only matters in the presence of other dubious programming practices:  Either a reference to the object has to escape before the constructor finishes, or the reference has to be communicated to another thread in a racy manner.  (And the former is a special case under control of the class itself.)  There are strong reasons to avoid both in the vast majority of code.  On the other hand, perfectly normal code will routinely rely on the thread-safety of non-constructor methods all the time.
>
>>
>> Second direction is about construction/publication as specifically
>> different from the methods. E.g. it even may have additional safety
>> guarantee -- like "publication is always safe". I can see some reasons
>> here, since constructor is the only one method, which is guaranteed to
>> be called only once on object lifecycle, and so we, possible, can
>> restrict some compiler/CPUs optimization in it with little influence
>> on overall application performance -- but it throws away all troubles
>> with unsafe publishing.
> I think we're still generally using "unsafe publishing" to mean either of the two dubious practices I mentioned above, though here we're presumably talking about racy publication after the constructor completes.  The problem is that in general racy publication is already a really bad practice, because the user has to understand the ugly details of the Java memory model, which nobody really does.  Racy publication is a data race, and hence you can no longer reason in terms of sequential consistency, synchronization-free regions become nonatomic, and generally all our intuition about behavior of threads and reasoning about threads goes out the window, even if you can still reason about the integrity of your class.  There are one or two special cases, notably lazy initialization of an immutable object, where you might succeed in hiding all that mess behind a library API, but in general that's hard.  So the question in my mind is whether you want to provide those added guarantees to support those one or two cases, or whether you want to limit those guarantees to situations, notably those involving final fields, where they're essential for the security model.  We currently have the latter.
>
> Hans
>>
>>
>>
>> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
>> > Agreed.
>> >
>> > But, echoing David, I think, I'm not at all sure I see where this
>> thread is going.  We've established that
>> >
>> > a) You can make a class safe against racy publication by
>> synchronizing the constructor along with all other methods (or by using
>> an immutable class with final fields).
>> >
>> > b) There are (rather brittle and obscure) use cases in which racy
>> publication gives you better performance on architectures like ARM,
>> though not x86, currently at the cost of confusing data race detectors.
>> >
>> > But to me it seems like taking advanatage of (b) is a fairly
>> undesirable, though perhaps occasionally unavoidable, hack.  And I
>> can't see why it would possibly be a win if you have to synchronize all
>> method calls to make it work.
>> >
>> > Does anyone have a use case in mind where the whole picture we're
>> discussing actually makes sense?  It might help to focus this
>> discussion.
>> >
>> > Hans
>> >
>> >> -----Original Message-----
>> >> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-
>> >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
>> >> Sent: Wednesday, August 15, 2012 10:56 AM
>> >> To: Yuval Shavit
>> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
>> >> Subject: Re: [concurrency-interest] Double Checked Locking in
>> OpenJDK
>> >>
>> >> I thought the conclusion of that thread is that synchronizing
>> >> constructor has the desired merit - if all constructors and methods
>> >> are synchronized, a non-creating thread won't observe the
>> zero/partial
>> >> state of the object, even if the object reference is published
>> >> unsafely.
>> >>
>> >> (One guy, who shall remain nameless, muddied the water with some
>> >> mistaken statements of weaker memory guarantee. He has been
>> corrected)
>> >>
>> >> Zhong Yu
>> >>
>> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit <yshavit at akiban.com>
>> >> wrote:
>> >> > There was a discussion here a few months ago about synchronizing
>> >> > constructors -- I had asked why it's not allowed, and the
>> discussion
>> >> hit on
>> >> > some of the similar points brought up in this thread.
>> >> >
>> >> > But to your point specifically, synchronizing a constructor (via
>> >> > "synchronized(this) {...}" surrounding its body) still doesn't
>> give
>> >> you full
>> >> > thread safety (even assuming immutability after the constructor --
>> >> but
>> >> > without final fields). It ensures that a thread can observe the
>> >> object
>> >> > either fully constructed *or* with all its fields having their
>> >> default
>> >> > values. In other words, even if your constructor is synchronized
>> on
>> >> the same
>> >> > object your getter is, a thread could observe a field as it was
>> >> before the
>> >> > constructor was invoked.
>> >> >
>> >> > http://markmail.org/message/mav53xzo4bqu7udw
>> >> >
>> >> >
>> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
>> >> <cheremin at gmail.com>
>> >> > wrote:
>> >> >>
>> >> >> > The reason to keep them distinct is because in general the
>> >> mechanisms
>> >> >> > for
>> >> >> > safe publication are external to the class, while those for
>> >> >> > thread-safety
>> >> >> > are internal. It is only an edge case where use of synchronized
>> in
>> >> a
>> >> >> > constructor can achieve safe-publication.
>> >> >>
>> >> >> Well, actually I do not understand your point. If I use some kind
>> of
>> >> >> synchronization to make methods of my object thread-safe -- can't
>> I
>> >> >> also apply same thing to constructor? For me, it makes the thing
>> >> only
>> >> >> clearer. Object can be thread-safe -- and it is totally thread
>> safe.
>> >> >> Object can require external synchronization for correct
>> >> multithreaded
>> >> >> use -- and it requires the sync for publishing and for usage
>> also.
>> >> >>
>> >> >> From my point of view, the distinction you talking about is more
>> >> >> historically reasoned. "Sync method if you want it to be thread-
>> >> safe"
>> >> >> is commonly learned mantra, but "take care of initialization
>> also"
>> >> is
>> >> >> not so common. More information about it, more education, more
>> >> >> different code samples with outlined "here is the dragons" will
>> >> change
>> >> >> the situation, I sure, it just have to be highlighted more often.
>> >> >>
>> >> >>
>> >> >> > People have to recognize that sharing an object requires shared
>> >> mutable
>> >> >> > state, and the number one tenet of concurrent programming is
>> that
>> >> access
>> >> >> > to
>> >> >> > shared mutable state has to be synchronized (in a general sense
>> >> not
>> >> >> > specifically use of 'synchronized' keyword).
>> >> >> >
>> >> >> > Making every object safely publishable could be done, but for
>> 99%
>> >> of
>> >> >> > objects
>> >> >> > it would be a waste of effort. Programs without data races
>> don't
>> >> have
>> >> >> > issues
>> >> >> > with unsafe publication.
>> >> >> >
>> >> >> > David
>> >> >> >
>> >> >> > -----Original Message-----
>> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
>> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
>> >> Nathan
>> >> >> > Reynolds
>> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
>> >> >> > To: concurrency-interest at cs.oswego.edu
>> >> >> > Subject: Re: [concurrency-interest] Double Checked Locking in
>> >> OpenJDK
>> >> >> >
>> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
>> >> >> > publication)
>> >> >> > when they should be combined in a sense.  Typically, when we
>> say
>> >> >> > thread-safe
>> >> >> > we talk about the operations performed on the object after it
>> was
>> >> >> > constructed (and its contents are globally visible).  However,
>> we
>> >> need
>> >> >> > to
>> >> >> > consider that executing the constructor is modifying the state
>> of
>> >> the
>> >> >> > object.  It requires the same mechanisms that the rest of the
>> >> class uses
>> >> >> > to
>> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>> >> executing the
>> >> >> > constructor, a proper releasing of a lock or some other
>> happens-
>> >> before
>> >> >> > construct is required to ensure that the memory updates by the
>> >> thread
>> >> >> > are
>> >> >> > made globally visible before the object is accessed by another
>> >> thread.
>> >> >> > This
>> >> >> > is what we are calling safe publication.  So, safe publication
>> is
>> >> a
>> >> >> > subset
>> >> >> > of thread-safety except it is limited to what happens after the
>> >> >> > constructor
>> >> >> > is called and before the object is used by multiple threads.
>> >> >> >
>> >> >> > A beautifully-written class can be thread-safe with respect to
>> >> calling
>> >> >> > its
>> >> >> > member methods but not thread-safe with respect to calling its
>> >> >> > constructor.
>> >> >> > It is this latter case that many stumble upon because they
>> think
>> >> that
>> >> >> > constructors are inherently thread-safe because they are
>> executed
>> >> >> > single-threadedly.  What they fail to realize is that the
>> >> execution of a
>> >> >> > constructor can overlap with the execution of other code from
>> the
>> >> view
>> >> >> > point
>> >> >> > of what is happening in memory.  This same problem applies to
>> more
>> >> rare
>> >> >> > case
>> >> >> > of regular methods which can be proven to execute in a single
>> >> thread but
>> >> >> > don't use synchronization before multiple threads start
>> accessing
>> >> the
>> >> >> > shared
>> >> >> > data.
>> >> >> >
>> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>> >> 602.333.9091
>> >> >> > Oracle PSR Engineering | Server Technology
>> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:
>> >> >> >
>> >> >> > For me it is confusing: java has only one way to have really
>> >> immutable
>> >> >> > object, and this way also gives you a total thread safety even
>> for
>> >> >> > data race based publication. But then docs refer object as
>> >> "immutable
>> >> >> > and thread-safe" -- we still can't assume it to be really
>> thread-
>> >> safe?
>> >> >> >
>> >> >> > It is better/simpler to isolate the notion of thread-safety and
>> >> safe
>> >> >> > publication. Thread-safety comes into play after you have
>> safely
>> >> shared
>> >> >> > an
>> >> >> > object. The means by which you safely share an object is
>> >> orthogonal to
>> >> >> > how
>> >> >> > the object itself is made thread-safe.
>> >> >> >
>> >> >> > The means by which an object is shared has to involve shared
>> >> mutable
>> >> >> > state,
>> >> >> > and use of shared mutable state always needs some form of
>> >> >> > synchronization
>> >> >> > (either implicit eg due to static initialization; or explicit
>> by
>> >> using
>> >> >> > volatile or synchronized getter/setter methods).
>> >> >> >
>> >> >> > David
>> >> >> > -----
>> >> >> >
>> >> >> > It's a pity, especially because true immutability gives us some
>> >> >> > chances of performance optimization. As in this case -- we do
>> not
>> >> >> > really need .path to be volatile here, if we would assume Path
>> to
>> >> be
>> >> >> > truly immutable. volatility here required only for ensuring
>> safe
>> >> >> > publishing.
>> >> >> >
>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:>
>> >> >> >
>> >> >> > But is there a way to define "safe for data race publishing"? I
>> as
>> >> >> > far, as I remember, "immutable and thread-safe" is standard
>> mantra
>> >> in
>> >> >> > JDK javadocs for totally safe objects. j.l.String has same
>> mantra
>> >> --
>> >> >> > and it is safe for any way of publishing. Does you mean, I
>> should
>> >> >> > explicitly add "safe even for publishing via data race" in
>> docs?
>> >> But I
>> >> >> > can't remember any such phrase in JDK docs.
>> >> >> >
>> >> >> > I don't recall anything in the JDK docs that mention being
>> >> >> >
>> >> >> > "totally safe"
>> >> >> >
>> >> >> > regardless of publication mechanism. Some classes, eg String,
>> have
>> >> been
>> >> >> > defined such that they do have that property (for security
>> >> reasons). In
>> >> >> > general neither "thread-safe" nor "immutable" imply
>> >> >> > safe-for-unsynchronized-publication.
>> >> >> >
>> >> >> > Java Concurrency In Practice (jcip.net) does define additional
>> >> potential
>> >> >> > annotations, where @Immutable would indeed capture the
>> requirement
>> >> of
>> >> >> > safe-for-unsynchronized-publication.
>> >> >> >
>> >> >> > David
>> >> >> > -----
>> >> >> >
>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:
>> >> >> >
>> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>> >> >> > multithreaded use". Although it is not strictly defined in java
>> >> what
>> >> >> > exactly means "safe for multithreaded use" -- does it mean safe
>> >> for
>> >> >> > publishing via data race, among others? -- I suppose, it
>> >> >> >
>> >> >> > should be. Am
>> >> >> >
>> >> >> > I wrong here?
>> >> >> >
>> >> >> > "safe for multi-threaded use" does not generally imply that it
>> >> >> >
>> >> >> > is safe to
>> >> >> >
>> >> >> > publish instances without synchronization of some form.
>> >> >> >
>> >> >> > David
>> >> >> > -----
>> >> >> >
>> >> >> > From other side, File.toPath javadoc explicitly says what
>> >> "returned
>> >> >> > instance must be the same for every invocation", so sync block
>> is
>> >> >> > required here for mutual exclusion on initialization phase.
>> >> Without
>> >> >> > this requirement it is also safe to live without sync block,
>> >> afaik.
>> >> >> >
>> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >
>> >> >> > Ruslan Cheremin writes:
>> >> >> >
>> >> >> > First of all, Path is immutable, so DCL is safe here even
>> without
>> >> >> > volatile. Volatile here is not required from my point of view.
>> >> >> >
>> >> >> > Without the volatile the Path implementation (Path is an
>> >> >> >
>> >> >> > interface) must be
>> >> >> >
>> >> >> > such that an instance of Path can be safely published without
>> >> >> >
>> >> >> > any additional
>> >> >> >
>> >> >> > forms of synchronization. Immutability does not in itself
>> >> >> >
>> >> >> > ensure that. You
>> >> >> >
>> >> >> > would have to examine the actual implementation class.
>> >> >> >
>> >> >> > David Holmes
>> >> >> > ------------
>> >> >> >
>> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> >> >
>> >> >> > Hi Richard,
>> >> >> >
>> >> >> > The variable "filePath" is volatile, so the double-checked
>> >> >> >
>> >> >> > locking is correct in this case. It would have been a bug
>> >> >> >
>> >> >> > prior to Java 5.
>> >> >> >
>> >> >> > Best regards,
>> >> >> >
>> >> >> > Dmitry Vyazelenko
>> >> >> >
>> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >> >
>> >> >> > <richard.warburton at gmail.com> wrote:
>> >> >> >
>> >> >> > Hello,
>> >> >> >
>> >> >> > The current implementation of java.io.File::toPath [0]
>> >> >> >
>> >> >> > appears to be
>> >> >> >
>> >> >> > using the double checked locking pattern:
>> >> >> >
>> >> >> >     public Path toPath() {
>> >> >> >         Path result = filePath;
>> >> >> >         if (result == null) {
>> >> >> >             synchronized (this) {
>> >> >> >                 result = filePath;
>> >> >> >                 if (result == null) {
>> >> >> >                     result =
>> >> >> >
>> >> >> > FileSystems.getDefault().getPath(path);
>> >> >> >
>> >> >> >                     filePath = result;
>> >> >> >                 }
>> >> >> >             }
>> >> >> >         }
>> >> >> >         return result;
>> >> >> >     }
>> >> >> >
>> >> >> > I was going to report the bug, but I'm a little
>> >> >> >
>> >> >> > uncertain of the
>> >> >> >
>> >> >> > interaction between the local variable 'result' and DCL
>> >> >> >
>> >> >> > since I've
>> >> >> >
>> >> >> > previously only seen the checking condition on the
>> >> >> >
>> >> >> > shared field
>> >> >> >
>> >> >> > itself.  Can someone here either confirm that its a bug or
>> >> >> >
>> >> >> > explain how
>> >> >> >
>> >> >> > the 'result' variable is fixing things?
>> >> >> >
>> >> >> > regards,
>> >> >> >
>> >> >> >  Richard
>> >> >> >
>> >> >> > [0] See the end of
>> >> >> >
>> >> >> >
>> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> >> >
>> >> >> > ses/java/io/File.java
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> >
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> _______________________________________________
>> >> >> Concurrency-interest mailing list
>> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> >
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From nathan.reynolds at oracle.com  Wed Aug 15 18:42:16 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Wed, 15 Aug 2012 15:42:16 -0700
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
Message-ID: <502C25C8.3000104@oracle.com>

Discussion happening in hardware and software arenas to allow data races 
and errors and have probably correct results.  Right now, there are few 
in the academic world working on this.  Of course, quantum computers 
will behave this way, but I am not talking about that.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 8/15/2012 2:19 PM, Ruslan Cheremin wrote:
> Well, I understand your point.
>
> But this lead me to another interesting question -- why data races is
> so outlaw? Yes, I understand, it is hard to write correct code with
> them (by the way, can you give the link about errors in JMM spec about
> data race you've mention above?), but can we scale really well with
> sequentially consistent execution only? I mean, in large-scale
> distributed systems design weakening consistency often gives great
> performance benefits. AndwWhen I think about something like 786-cores
> (skip the brand) box, it seems for me there could be many chances to
> improve performance using racy code. Am I miss something here?
>
> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
>>> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
>>>
>>> As far, as I can see, there is two directions. One is what
>>> "thread-safe" notation in it's commonly used form -- then applied only
>>> to methods, and not to initialization/publication -- is confusing, and
>>> there is little reason to exclude construction/publication from thread
>>> safety protocol by default. My point, among others, is that "immutable
>>> and thread safe" should be interpreted as "thread safe even for unsafe
>>> publishing". And this, for example, gives us the chance to remove
>>> volatile specification in File.path field we started from :)
>> It seems to me that there's a huge difference here.  Synchronization in the constructor only matters in the presence of other dubious programming practices:  Either a reference to the object has to escape before the constructor finishes, or the reference has to be communicated to another thread in a racy manner.  (And the former is a special case under control of the class itself.)  There are strong reasons to avoid both in the vast majority of code.  On the other hand, perfectly normal code will routinely rely on the thread-safety of non-constructor methods all the time.
>>
>>> Second direction is about construction/publication as specifically
>>> different from the methods. E.g. it even may have additional safety
>>> guarantee -- like "publication is always safe". I can see some reasons
>>> here, since constructor is the only one method, which is guaranteed to
>>> be called only once on object lifecycle, and so we, possible, can
>>> restrict some compiler/CPUs optimization in it with little influence
>>> on overall application performance -- but it throws away all troubles
>>> with unsafe publishing.
>> I think we're still generally using "unsafe publishing" to mean either of the two dubious practices I mentioned above, though here we're presumably talking about racy publication after the constructor completes.  The problem is that in general racy publication is already a really bad practice, because the user has to understand the ugly details of the Java memory model, which nobody really does.  Racy publication is a data race, and hence you can no longer reason in terms of sequential consistency, synchronization-free regions become nonatomic, and generally all our intuition about behavior of threads and reasoning about threads goes out the window, even if you can still reason about the integrity of your class.  There are one or two special cases, notably lazy initialization of an immutable object, where you might succeed in hiding all that mess behind a library API, but in general that's hard.  So the question in my mind is whether you want to provide those added guarant!
>   ees to support those one or two cases, or whether you want to limit those guarantees to situations, notably those involving final fields, where they're essential for the security model.  We currently have the latter.
>> Hans
>>>
>>>
>>> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
>>>> Agreed.
>>>>
>>>> But, echoing David, I think, I'm not at all sure I see where this
>>> thread is going.  We've established that
>>>> a) You can make a class safe against racy publication by
>>> synchronizing the constructor along with all other methods (or by using
>>> an immutable class with final fields).
>>>> b) There are (rather brittle and obscure) use cases in which racy
>>> publication gives you better performance on architectures like ARM,
>>> though not x86, currently at the cost of confusing data race detectors.
>>>> But to me it seems like taking advanatage of (b) is a fairly
>>> undesirable, though perhaps occasionally unavoidable, hack.  And I
>>> can't see why it would possibly be a win if you have to synchronize all
>>> method calls to make it work.
>>>> Does anyone have a use case in mind where the whole picture we're
>>> discussing actually makes sense?  It might help to focus this
>>> discussion.
>>>> Hans
>>>>
>>>>> -----Original Message-----
>>>>> From: concurrency-interest-bounces at cs.oswego.edu
>>> [mailto:concurrency-
>>>>> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
>>>>> Sent: Wednesday, August 15, 2012 10:56 AM
>>>>> To: Yuval Shavit
>>>>> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
>>>>> Subject: Re: [concurrency-interest] Double Checked Locking in
>>> OpenJDK
>>>>> I thought the conclusion of that thread is that synchronizing
>>>>> constructor has the desired merit - if all constructors and methods
>>>>> are synchronized, a non-creating thread won't observe the
>>> zero/partial
>>>>> state of the object, even if the object reference is published
>>>>> unsafely.
>>>>>
>>>>> (One guy, who shall remain nameless, muddied the water with some
>>>>> mistaken statements of weaker memory guarantee. He has been
>>> corrected)
>>>>> Zhong Yu
>>>>>
>>>>> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit <yshavit at akiban.com>
>>>>> wrote:
>>>>>> There was a discussion here a few months ago about synchronizing
>>>>>> constructors -- I had asked why it's not allowed, and the
>>> discussion
>>>>> hit on
>>>>>> some of the similar points brought up in this thread.
>>>>>>
>>>>>> But to your point specifically, synchronizing a constructor (via
>>>>>> "synchronized(this) {...}" surrounding its body) still doesn't
>>> give
>>>>> you full
>>>>>> thread safety (even assuming immutability after the constructor --
>>>>> but
>>>>>> without final fields). It ensures that a thread can observe the
>>>>> object
>>>>>> either fully constructed *or* with all its fields having their
>>>>> default
>>>>>> values. In other words, even if your constructor is synchronized
>>> on
>>>>> the same
>>>>>> object your getter is, a thread could observe a field as it was
>>>>> before the
>>>>>> constructor was invoked.
>>>>>>
>>>>>> http://markmail.org/message/mav53xzo4bqu7udw
>>>>>>
>>>>>>
>>>>>> On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
>>>>> <cheremin at gmail.com>
>>>>>> wrote:
>>>>>>>> The reason to keep them distinct is because in general the
>>>>> mechanisms
>>>>>>>> for
>>>>>>>> safe publication are external to the class, while those for
>>>>>>>> thread-safety
>>>>>>>> are internal. It is only an edge case where use of synchronized
>>> in
>>>>> a
>>>>>>>> constructor can achieve safe-publication.
>>>>>>> Well, actually I do not understand your point. If I use some kind
>>> of
>>>>>>> synchronization to make methods of my object thread-safe -- can't
>>> I
>>>>>>> also apply same thing to constructor? For me, it makes the thing
>>>>> only
>>>>>>> clearer. Object can be thread-safe -- and it is totally thread
>>> safe.
>>>>>>> Object can require external synchronization for correct
>>>>> multithreaded
>>>>>>> use -- and it requires the sync for publishing and for usage
>>> also.
>>>>>>>  From my point of view, the distinction you talking about is more
>>>>>>> historically reasoned. "Sync method if you want it to be thread-
>>>>> safe"
>>>>>>> is commonly learned mantra, but "take care of initialization
>>> also"
>>>>> is
>>>>>>> not so common. More information about it, more education, more
>>>>>>> different code samples with outlined "here is the dragons" will
>>>>> change
>>>>>>> the situation, I sure, it just have to be highlighted more often.
>>>>>>>
>>>>>>>
>>>>>>>> People have to recognize that sharing an object requires shared
>>>>> mutable
>>>>>>>> state, and the number one tenet of concurrent programming is
>>> that
>>>>> access
>>>>>>>> to
>>>>>>>> shared mutable state has to be synchronized (in a general sense
>>>>> not
>>>>>>>> specifically use of 'synchronized' keyword).
>>>>>>>>
>>>>>>>> Making every object safely publishable could be done, but for
>>> 99%
>>>>> of
>>>>>>>> objects
>>>>>>>> it would be a waste of effort. Programs without data races
>>> don't
>>>>> have
>>>>>>>> issues
>>>>>>>> with unsafe publication.
>>>>>>>>
>>>>>>>> David
>>>>>>>>
>>>>>>>> -----Original Message-----
>>>>>>>> From: concurrency-interest-bounces at cs.oswego.edu
>>>>>>>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
>>>>> Nathan
>>>>>>>> Reynolds
>>>>>>>> Sent: Wednesday, 15 August 2012 4:59 AM
>>>>>>>> To: concurrency-interest at cs.oswego.edu
>>>>>>>> Subject: Re: [concurrency-interest] Double Checked Locking in
>>>>> OpenJDK
>>>>>>>> We seem to be splitting two notions (i.e thread-safe and safe
>>>>>>>> publication)
>>>>>>>> when they should be combined in a sense.  Typically, when we
>>> say
>>>>>>>> thread-safe
>>>>>>>> we talk about the operations performed on the object after it
>>> was
>>>>>>>> constructed (and its contents are globally visible).  However,
>>> we
>>>>> need
>>>>>>>> to
>>>>>>>> consider that executing the constructor is modifying the state
>>> of
>>>>> the
>>>>>>>> object.  It requires the same mechanisms that the rest of the
>>>>> class uses
>>>>>>>> to
>>>>>>>> ensure thread-safety.  Even though, there is only 1 thread
>>>>> executing the
>>>>>>>> constructor, a proper releasing of a lock or some other
>>> happens-
>>>>> before
>>>>>>>> construct is required to ensure that the memory updates by the
>>>>> thread
>>>>>>>> are
>>>>>>>> made globally visible before the object is accessed by another
>>>>> thread.
>>>>>>>> This
>>>>>>>> is what we are calling safe publication.  So, safe publication
>>> is
>>>>> a
>>>>>>>> subset
>>>>>>>> of thread-safety except it is limited to what happens after the
>>>>>>>> constructor
>>>>>>>> is called and before the object is used by multiple threads.
>>>>>>>>
>>>>>>>> A beautifully-written class can be thread-safe with respect to
>>>>> calling
>>>>>>>> its
>>>>>>>> member methods but not thread-safe with respect to calling its
>>>>>>>> constructor.
>>>>>>>> It is this latter case that many stumble upon because they
>>> think
>>>>> that
>>>>>>>> constructors are inherently thread-safe because they are
>>> executed
>>>>>>>> single-threadedly.  What they fail to realize is that the
>>>>> execution of a
>>>>>>>> constructor can overlap with the execution of other code from
>>> the
>>>>> view
>>>>>>>> point
>>>>>>>> of what is happening in memory.  This same problem applies to
>>> more
>>>>> rare
>>>>>>>> case
>>>>>>>> of regular methods which can be proven to execute in a single
>>>>> thread but
>>>>>>>> don't use synchronization before multiple threads start
>>> accessing
>>>>> the
>>>>>>>> shared
>>>>>>>> data.
>>>>>>>>
>>>>>>>> Nathan Reynolds | Consulting Member of Technical Staff |
>>>>> 602.333.9091
>>>>>>>> Oracle PSR Engineering | Server Technology
>>>>>>>> On 8/13/2012 4:08 PM, David Holmes wrote:
>>>>>>>>
>>>>>>>> Ruslan Cheremin writes:
>>>>>>>>
>>>>>>>> For me it is confusing: java has only one way to have really
>>>>> immutable
>>>>>>>> object, and this way also gives you a total thread safety even
>>> for
>>>>>>>> data race based publication. But then docs refer object as
>>>>> "immutable
>>>>>>>> and thread-safe" -- we still can't assume it to be really
>>> thread-
>>>>> safe?
>>>>>>>> It is better/simpler to isolate the notion of thread-safety and
>>>>> safe
>>>>>>>> publication. Thread-safety comes into play after you have
>>> safely
>>>>> shared
>>>>>>>> an
>>>>>>>> object. The means by which you safely share an object is
>>>>> orthogonal to
>>>>>>>> how
>>>>>>>> the object itself is made thread-safe.
>>>>>>>>
>>>>>>>> The means by which an object is shared has to involve shared
>>>>> mutable
>>>>>>>> state,
>>>>>>>> and use of shared mutable state always needs some form of
>>>>>>>> synchronization
>>>>>>>> (either implicit eg due to static initialization; or explicit
>>> by
>>>>> using
>>>>>>>> volatile or synchronized getter/setter methods).
>>>>>>>>
>>>>>>>> David
>>>>>>>> -----
>>>>>>>>
>>>>>>>> It's a pity, especially because true immutability gives us some
>>>>>>>> chances of performance optimization. As in this case -- we do
>>> not
>>>>>>>> really need .path to be volatile here, if we would assume Path
>>> to
>>>>> be
>>>>>>>> truly immutable. volatility here required only for ensuring
>>> safe
>>>>>>>> publishing.
>>>>>>>>
>>>>>>>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>>>>>>
>>>>>>>> Ruslan Cheremin writes:>
>>>>>>>>
>>>>>>>> But is there a way to define "safe for data race publishing"? I
>>> as
>>>>>>>> far, as I remember, "immutable and thread-safe" is standard
>>> mantra
>>>>> in
>>>>>>>> JDK javadocs for totally safe objects. j.l.String has same
>>> mantra
>>>>> --
>>>>>>>> and it is safe for any way of publishing. Does you mean, I
>>> should
>>>>>>>> explicitly add "safe even for publishing via data race" in
>>> docs?
>>>>> But I
>>>>>>>> can't remember any such phrase in JDK docs.
>>>>>>>>
>>>>>>>> I don't recall anything in the JDK docs that mention being
>>>>>>>>
>>>>>>>> "totally safe"
>>>>>>>>
>>>>>>>> regardless of publication mechanism. Some classes, eg String,
>>> have
>>>>> been
>>>>>>>> defined such that they do have that property (for security
>>>>> reasons). In
>>>>>>>> general neither "thread-safe" nor "immutable" imply
>>>>>>>> safe-for-unsynchronized-publication.
>>>>>>>>
>>>>>>>> Java Concurrency In Practice (jcip.net) does define additional
>>>>> potential
>>>>>>>> annotations, where @Immutable would indeed capture the
>>> requirement
>>>>> of
>>>>>>>> safe-for-unsynchronized-publication.
>>>>>>>>
>>>>>>>> David
>>>>>>>> -----
>>>>>>>>
>>>>>>>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>>>>>>
>>>>>>>> Ruslan Cheremin writes:
>>>>>>>>
>>>>>>>> Well, Path javadoc explicitly says "immutable and safe for
>>>>>>>> multithreaded use". Although it is not strictly defined in java
>>>>> what
>>>>>>>> exactly means "safe for multithreaded use" -- does it mean safe
>>>>> for
>>>>>>>> publishing via data race, among others? -- I suppose, it
>>>>>>>>
>>>>>>>> should be. Am
>>>>>>>>
>>>>>>>> I wrong here?
>>>>>>>>
>>>>>>>> "safe for multi-threaded use" does not generally imply that it
>>>>>>>>
>>>>>>>> is safe to
>>>>>>>>
>>>>>>>> publish instances without synchronization of some form.
>>>>>>>>
>>>>>>>> David
>>>>>>>> -----
>>>>>>>>
>>>>>>>>  From other side, File.toPath javadoc explicitly says what
>>>>> "returned
>>>>>>>> instance must be the same for every invocation", so sync block
>>> is
>>>>>>>> required here for mutual exclusion on initialization phase.
>>>>> Without
>>>>>>>> this requirement it is also safe to live without sync block,
>>>>> afaik.
>>>>>>>> 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>>>>>>
>>>>>>>> Ruslan Cheremin writes:
>>>>>>>>
>>>>>>>> First of all, Path is immutable, so DCL is safe here even
>>> without
>>>>>>>> volatile. Volatile here is not required from my point of view.
>>>>>>>>
>>>>>>>> Without the volatile the Path implementation (Path is an
>>>>>>>>
>>>>>>>> interface) must be
>>>>>>>>
>>>>>>>> such that an instance of Path can be safely published without
>>>>>>>>
>>>>>>>> any additional
>>>>>>>>
>>>>>>>> forms of synchronization. Immutability does not in itself
>>>>>>>>
>>>>>>>> ensure that. You
>>>>>>>>
>>>>>>>> would have to examine the actual implementation class.
>>>>>>>>
>>>>>>>> David Holmes
>>>>>>>> ------------
>>>>>>>>
>>>>>>>> 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>>>>>>>>
>>>>>>>> Hi Richard,
>>>>>>>>
>>>>>>>> The variable "filePath" is volatile, so the double-checked
>>>>>>>>
>>>>>>>> locking is correct in this case. It would have been a bug
>>>>>>>>
>>>>>>>> prior to Java 5.
>>>>>>>>
>>>>>>>> Best regards,
>>>>>>>>
>>>>>>>> Dmitry Vyazelenko
>>>>>>>>
>>>>>>>> On Aug 12, 2012, at 21:35 , Richard Warburton
>>>>>>>>
>>>>>>>> <richard.warburton at gmail.com> wrote:
>>>>>>>>
>>>>>>>> Hello,
>>>>>>>>
>>>>>>>> The current implementation of java.io.File::toPath [0]
>>>>>>>>
>>>>>>>> appears to be
>>>>>>>>
>>>>>>>> using the double checked locking pattern:
>>>>>>>>
>>>>>>>>      public Path toPath() {
>>>>>>>>          Path result = filePath;
>>>>>>>>          if (result == null) {
>>>>>>>>              synchronized (this) {
>>>>>>>>                  result = filePath;
>>>>>>>>                  if (result == null) {
>>>>>>>>                      result =
>>>>>>>>
>>>>>>>> FileSystems.getDefault().getPath(path);
>>>>>>>>
>>>>>>>>                      filePath = result;
>>>>>>>>                  }
>>>>>>>>              }
>>>>>>>>          }
>>>>>>>>          return result;
>>>>>>>>      }
>>>>>>>>
>>>>>>>> I was going to report the bug, but I'm a little
>>>>>>>>
>>>>>>>> uncertain of the
>>>>>>>>
>>>>>>>> interaction between the local variable 'result' and DCL
>>>>>>>>
>>>>>>>> since I've
>>>>>>>>
>>>>>>>> previously only seen the checking condition on the
>>>>>>>>
>>>>>>>> shared field
>>>>>>>>
>>>>>>>> itself.  Can someone here either confirm that its a bug or
>>>>>>>>
>>>>>>>> explain how
>>>>>>>>
>>>>>>>> the 'result' variable is fixing things?
>>>>>>>>
>>>>>>>> regards,
>>>>>>>>
>>>>>>>>   Richard
>>>>>>>>
>>>>>>>> [0] See the end of
>>>>>>>>
>>>>>>>>
>>> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>>>>>>>> ses/java/io/File.java
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/db10b003/attachment-0001.html>

From vitalyd at gmail.com  Wed Aug 15 18:51:44 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 15 Aug 2012 18:51:44 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
Message-ID: <CAHjP37H15G7E3PZaYDGkhkhOC0K7JJd4-JKaF2y3r3tGOfXEcg@mail.gmail.com>

This is a big open question: how do you scale on hugely parallel hardware?
The answer will most likely lie in the spectrum of minimizing all sharing.
Let's say you didn't even care about data races but were to simply share
memory via ordinary stores - no memory barriers whatsoever.  Even in this
case, performance on a hugely parallel machine will drop off a cliff due to
cache invalidations.  Possible hardware advancement/assistance aside, the
answer will be to minimize sharing altogether.  It's a hard problem.

Sent from my phone
On Aug 15, 2012 5:22 PM, "Ruslan Cheremin" <cheremin at gmail.com> wrote:

> Well, I understand your point.
>
> But this lead me to another interesting question -- why data races is
> so outlaw? Yes, I understand, it is hard to write correct code with
> them (by the way, can you give the link about errors in JMM spec about
> data race you've mention above?), but can we scale really well with
> sequentially consistent execution only? I mean, in large-scale
> distributed systems design weakening consistency often gives great
> performance benefits. AndwWhen I think about something like 786-cores
> (skip the brand) box, it seems for me there could be many chances to
> improve performance using racy code. Am I miss something here?
>
> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> >>
> >> As far, as I can see, there is two directions. One is what
> >> "thread-safe" notation in it's commonly used form -- then applied only
> >> to methods, and not to initialization/publication -- is confusing, and
> >> there is little reason to exclude construction/publication from thread
> >> safety protocol by default. My point, among others, is that "immutable
> >> and thread safe" should be interpreted as "thread safe even for unsafe
> >> publishing". And this, for example, gives us the chance to remove
> >> volatile specification in File.path field we started from :)
> > It seems to me that there's a huge difference here.  Synchronization in
> the constructor only matters in the presence of other dubious programming
> practices:  Either a reference to the object has to escape before the
> constructor finishes, or the reference has to be communicated to another
> thread in a racy manner.  (And the former is a special case under control
> of the class itself.)  There are strong reasons to avoid both in the vast
> majority of code.  On the other hand, perfectly normal code will routinely
> rely on the thread-safety of non-constructor methods all the time.
> >
> >>
> >> Second direction is about construction/publication as specifically
> >> different from the methods. E.g. it even may have additional safety
> >> guarantee -- like "publication is always safe". I can see some reasons
> >> here, since constructor is the only one method, which is guaranteed to
> >> be called only once on object lifecycle, and so we, possible, can
> >> restrict some compiler/CPUs optimization in it with little influence
> >> on overall application performance -- but it throws away all troubles
> >> with unsafe publishing.
> > I think we're still generally using "unsafe publishing" to mean either
> of the two dubious practices I mentioned above, though here we're
> presumably talking about racy publication after the constructor completes.
>  The problem is that in general racy publication is already a really bad
> practice, because the user has to understand the ugly details of the Java
> memory model, which nobody really does.  Racy publication is a data race,
> and hence you can no longer reason in terms of sequential consistency,
> synchronization-free regions become nonatomic, and generally all our
> intuition about behavior of threads and reasoning about threads goes out
> the window, even if you can still reason about the integrity of your class.
>  There are one or two special cases, notably lazy initialization of an
> immutable object, where you might succeed in hiding all that mess behind a
> library API, but in general that's hard.  So the question in my mind is
> whether you want to provide those added guarant!
>  ees to support those one or two cases, or whether you want to limit those
> guarantees to situations, notably those involving final fields, where
> they're essential for the security model.  We currently have the latter.
> >
> > Hans
> >>
> >>
> >>
> >> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
> >> > Agreed.
> >> >
> >> > But, echoing David, I think, I'm not at all sure I see where this
> >> thread is going.  We've established that
> >> >
> >> > a) You can make a class safe against racy publication by
> >> synchronizing the constructor along with all other methods (or by using
> >> an immutable class with final fields).
> >> >
> >> > b) There are (rather brittle and obscure) use cases in which racy
> >> publication gives you better performance on architectures like ARM,
> >> though not x86, currently at the cost of confusing data race detectors.
> >> >
> >> > But to me it seems like taking advanatage of (b) is a fairly
> >> undesirable, though perhaps occasionally unavoidable, hack.  And I
> >> can't see why it would possibly be a win if you have to synchronize all
> >> method calls to make it work.
> >> >
> >> > Does anyone have a use case in mind where the whole picture we're
> >> discussing actually makes sense?  It might help to focus this
> >> discussion.
> >> >
> >> > Hans
> >> >
> >> >> -----Original Message-----
> >> >> From: concurrency-interest-bounces at cs.oswego.edu
> >> [mailto:concurrency-
> >> >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
> >> >> Sent: Wednesday, August 15, 2012 10:56 AM
> >> >> To: Yuval Shavit
> >> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> >> >> Subject: Re: [concurrency-interest] Double Checked Locking in
> >> OpenJDK
> >> >>
> >> >> I thought the conclusion of that thread is that synchronizing
> >> >> constructor has the desired merit - if all constructors and methods
> >> >> are synchronized, a non-creating thread won't observe the
> >> zero/partial
> >> >> state of the object, even if the object reference is published
> >> >> unsafely.
> >> >>
> >> >> (One guy, who shall remain nameless, muddied the water with some
> >> >> mistaken statements of weaker memory guarantee. He has been
> >> corrected)
> >> >>
> >> >> Zhong Yu
> >> >>
> >> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit <yshavit at akiban.com>
> >> >> wrote:
> >> >> > There was a discussion here a few months ago about synchronizing
> >> >> > constructors -- I had asked why it's not allowed, and the
> >> discussion
> >> >> hit on
> >> >> > some of the similar points brought up in this thread.
> >> >> >
> >> >> > But to your point specifically, synchronizing a constructor (via
> >> >> > "synchronized(this) {...}" surrounding its body) still doesn't
> >> give
> >> >> you full
> >> >> > thread safety (even assuming immutability after the constructor --
> >> >> but
> >> >> > without final fields). It ensures that a thread can observe the
> >> >> object
> >> >> > either fully constructed *or* with all its fields having their
> >> >> default
> >> >> > values. In other words, even if your constructor is synchronized
> >> on
> >> >> the same
> >> >> > object your getter is, a thread could observe a field as it was
> >> >> before the
> >> >> > constructor was invoked.
> >> >> >
> >> >> > http://markmail.org/message/mav53xzo4bqu7udw
> >> >> >
> >> >> >
> >> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
> >> >> <cheremin at gmail.com>
> >> >> > wrote:
> >> >> >>
> >> >> >> > The reason to keep them distinct is because in general the
> >> >> mechanisms
> >> >> >> > for
> >> >> >> > safe publication are external to the class, while those for
> >> >> >> > thread-safety
> >> >> >> > are internal. It is only an edge case where use of synchronized
> >> in
> >> >> a
> >> >> >> > constructor can achieve safe-publication.
> >> >> >>
> >> >> >> Well, actually I do not understand your point. If I use some kind
> >> of
> >> >> >> synchronization to make methods of my object thread-safe -- can't
> >> I
> >> >> >> also apply same thing to constructor? For me, it makes the thing
> >> >> only
> >> >> >> clearer. Object can be thread-safe -- and it is totally thread
> >> safe.
> >> >> >> Object can require external synchronization for correct
> >> >> multithreaded
> >> >> >> use -- and it requires the sync for publishing and for usage
> >> also.
> >> >> >>
> >> >> >> From my point of view, the distinction you talking about is more
> >> >> >> historically reasoned. "Sync method if you want it to be thread-
> >> >> safe"
> >> >> >> is commonly learned mantra, but "take care of initialization
> >> also"
> >> >> is
> >> >> >> not so common. More information about it, more education, more
> >> >> >> different code samples with outlined "here is the dragons" will
> >> >> change
> >> >> >> the situation, I sure, it just have to be highlighted more often.
> >> >> >>
> >> >> >>
> >> >> >> > People have to recognize that sharing an object requires shared
> >> >> mutable
> >> >> >> > state, and the number one tenet of concurrent programming is
> >> that
> >> >> access
> >> >> >> > to
> >> >> >> > shared mutable state has to be synchronized (in a general sense
> >> >> not
> >> >> >> > specifically use of 'synchronized' keyword).
> >> >> >> >
> >> >> >> > Making every object safely publishable could be done, but for
> >> 99%
> >> >> of
> >> >> >> > objects
> >> >> >> > it would be a waste of effort. Programs without data races
> >> don't
> >> >> have
> >> >> >> > issues
> >> >> >> > with unsafe publication.
> >> >> >> >
> >> >> >> > David
> >> >> >> >
> >> >> >> > -----Original Message-----
> >> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
> >> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
> >> >> Nathan
> >> >> >> > Reynolds
> >> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
> >> >> >> > To: concurrency-interest at cs.oswego.edu
> >> >> >> > Subject: Re: [concurrency-interest] Double Checked Locking in
> >> >> OpenJDK
> >> >> >> >
> >> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
> >> >> >> > publication)
> >> >> >> > when they should be combined in a sense.  Typically, when we
> >> say
> >> >> >> > thread-safe
> >> >> >> > we talk about the operations performed on the object after it
> >> was
> >> >> >> > constructed (and its contents are globally visible).  However,
> >> we
> >> >> need
> >> >> >> > to
> >> >> >> > consider that executing the constructor is modifying the state
> >> of
> >> >> the
> >> >> >> > object.  It requires the same mechanisms that the rest of the
> >> >> class uses
> >> >> >> > to
> >> >> >> > ensure thread-safety.  Even though, there is only 1 thread
> >> >> executing the
> >> >> >> > constructor, a proper releasing of a lock or some other
> >> happens-
> >> >> before
> >> >> >> > construct is required to ensure that the memory updates by the
> >> >> thread
> >> >> >> > are
> >> >> >> > made globally visible before the object is accessed by another
> >> >> thread.
> >> >> >> > This
> >> >> >> > is what we are calling safe publication.  So, safe publication
> >> is
> >> >> a
> >> >> >> > subset
> >> >> >> > of thread-safety except it is limited to what happens after the
> >> >> >> > constructor
> >> >> >> > is called and before the object is used by multiple threads.
> >> >> >> >
> >> >> >> > A beautifully-written class can be thread-safe with respect to
> >> >> calling
> >> >> >> > its
> >> >> >> > member methods but not thread-safe with respect to calling its
> >> >> >> > constructor.
> >> >> >> > It is this latter case that many stumble upon because they
> >> think
> >> >> that
> >> >> >> > constructors are inherently thread-safe because they are
> >> executed
> >> >> >> > single-threadedly.  What they fail to realize is that the
> >> >> execution of a
> >> >> >> > constructor can overlap with the execution of other code from
> >> the
> >> >> view
> >> >> >> > point
> >> >> >> > of what is happening in memory.  This same problem applies to
> >> more
> >> >> rare
> >> >> >> > case
> >> >> >> > of regular methods which can be proven to execute in a single
> >> >> thread but
> >> >> >> > don't use synchronization before multiple threads start
> >> accessing
> >> >> the
> >> >> >> > shared
> >> >> >> > data.
> >> >> >> >
> >> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> >> >> 602.333.9091
> >> >> >> > Oracle PSR Engineering | Server Technology
> >> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >> >> >> >
> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >
> >> >> >> > For me it is confusing: java has only one way to have really
> >> >> immutable
> >> >> >> > object, and this way also gives you a total thread safety even
> >> for
> >> >> >> > data race based publication. But then docs refer object as
> >> >> "immutable
> >> >> >> > and thread-safe" -- we still can't assume it to be really
> >> thread-
> >> >> safe?
> >> >> >> >
> >> >> >> > It is better/simpler to isolate the notion of thread-safety and
> >> >> safe
> >> >> >> > publication. Thread-safety comes into play after you have
> >> safely
> >> >> shared
> >> >> >> > an
> >> >> >> > object. The means by which you safely share an object is
> >> >> orthogonal to
> >> >> >> > how
> >> >> >> > the object itself is made thread-safe.
> >> >> >> >
> >> >> >> > The means by which an object is shared has to involve shared
> >> >> mutable
> >> >> >> > state,
> >> >> >> > and use of shared mutable state always needs some form of
> >> >> >> > synchronization
> >> >> >> > (either implicit eg due to static initialization; or explicit
> >> by
> >> >> using
> >> >> >> > volatile or synchronized getter/setter methods).
> >> >> >> >
> >> >> >> > David
> >> >> >> > -----
> >> >> >> >
> >> >> >> > It's a pity, especially because true immutability gives us some
> >> >> >> > chances of performance optimization. As in this case -- we do
> >> not
> >> >> >> > really need .path to be volatile here, if we would assume Path
> >> to
> >> >> be
> >> >> >> > truly immutable. volatility here required only for ensuring
> >> safe
> >> >> >> > publishing.
> >> >> >> >
> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >
> >> >> >> > Ruslan Cheremin writes:>
> >> >> >> >
> >> >> >> > But is there a way to define "safe for data race publishing"? I
> >> as
> >> >> >> > far, as I remember, "immutable and thread-safe" is standard
> >> mantra
> >> >> in
> >> >> >> > JDK javadocs for totally safe objects. j.l.String has same
> >> mantra
> >> >> --
> >> >> >> > and it is safe for any way of publishing. Does you mean, I
> >> should
> >> >> >> > explicitly add "safe even for publishing via data race" in
> >> docs?
> >> >> But I
> >> >> >> > can't remember any such phrase in JDK docs.
> >> >> >> >
> >> >> >> > I don't recall anything in the JDK docs that mention being
> >> >> >> >
> >> >> >> > "totally safe"
> >> >> >> >
> >> >> >> > regardless of publication mechanism. Some classes, eg String,
> >> have
> >> >> been
> >> >> >> > defined such that they do have that property (for security
> >> >> reasons). In
> >> >> >> > general neither "thread-safe" nor "immutable" imply
> >> >> >> > safe-for-unsynchronized-publication.
> >> >> >> >
> >> >> >> > Java Concurrency In Practice (jcip.net) does define additional
> >> >> potential
> >> >> >> > annotations, where @Immutable would indeed capture the
> >> requirement
> >> >> of
> >> >> >> > safe-for-unsynchronized-publication.
> >> >> >> >
> >> >> >> > David
> >> >> >> > -----
> >> >> >> >
> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >
> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >
> >> >> >> > Well, Path javadoc explicitly says "immutable and safe for
> >> >> >> > multithreaded use". Although it is not strictly defined in java
> >> >> what
> >> >> >> > exactly means "safe for multithreaded use" -- does it mean safe
> >> >> for
> >> >> >> > publishing via data race, among others? -- I suppose, it
> >> >> >> >
> >> >> >> > should be. Am
> >> >> >> >
> >> >> >> > I wrong here?
> >> >> >> >
> >> >> >> > "safe for multi-threaded use" does not generally imply that it
> >> >> >> >
> >> >> >> > is safe to
> >> >> >> >
> >> >> >> > publish instances without synchronization of some form.
> >> >> >> >
> >> >> >> > David
> >> >> >> > -----
> >> >> >> >
> >> >> >> > From other side, File.toPath javadoc explicitly says what
> >> >> "returned
> >> >> >> > instance must be the same for every invocation", so sync block
> >> is
> >> >> >> > required here for mutual exclusion on initialization phase.
> >> >> Without
> >> >> >> > this requirement it is also safe to live without sync block,
> >> >> afaik.
> >> >> >> >
> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >
> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >
> >> >> >> > First of all, Path is immutable, so DCL is safe here even
> >> without
> >> >> >> > volatile. Volatile here is not required from my point of view.
> >> >> >> >
> >> >> >> > Without the volatile the Path implementation (Path is an
> >> >> >> >
> >> >> >> > interface) must be
> >> >> >> >
> >> >> >> > such that an instance of Path can be safely published without
> >> >> >> >
> >> >> >> > any additional
> >> >> >> >
> >> >> >> > forms of synchronization. Immutability does not in itself
> >> >> >> >
> >> >> >> > ensure that. You
> >> >> >> >
> >> >> >> > would have to examine the actual implementation class.
> >> >> >> >
> >> >> >> > David Holmes
> >> >> >> > ------------
> >> >> >> >
> >> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >> >
> >> >> >> > Hi Richard,
> >> >> >> >
> >> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> >> >
> >> >> >> > locking is correct in this case. It would have been a bug
> >> >> >> >
> >> >> >> > prior to Java 5.
> >> >> >> >
> >> >> >> > Best regards,
> >> >> >> >
> >> >> >> > Dmitry Vyazelenko
> >> >> >> >
> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >> >
> >> >> >> > <richard.warburton at gmail.com> wrote:
> >> >> >> >
> >> >> >> > Hello,
> >> >> >> >
> >> >> >> > The current implementation of java.io.File::toPath [0]
> >> >> >> >
> >> >> >> > appears to be
> >> >> >> >
> >> >> >> > using the double checked locking pattern:
> >> >> >> >
> >> >> >> >     public Path toPath() {
> >> >> >> >         Path result = filePath;
> >> >> >> >         if (result == null) {
> >> >> >> >             synchronized (this) {
> >> >> >> >                 result = filePath;
> >> >> >> >                 if (result == null) {
> >> >> >> >                     result =
> >> >> >> >
> >> >> >> > FileSystems.getDefault().getPath(path);
> >> >> >> >
> >> >> >> >                     filePath = result;
> >> >> >> >                 }
> >> >> >> >             }
> >> >> >> >         }
> >> >> >> >         return result;
> >> >> >> >     }
> >> >> >> >
> >> >> >> > I was going to report the bug, but I'm a little
> >> >> >> >
> >> >> >> > uncertain of the
> >> >> >> >
> >> >> >> > interaction between the local variable 'result' and DCL
> >> >> >> >
> >> >> >> > since I've
> >> >> >> >
> >> >> >> > previously only seen the checking condition on the
> >> >> >> >
> >> >> >> > shared field
> >> >> >> >
> >> >> >> > itself.  Can someone here either confirm that its a bug or
> >> >> >> >
> >> >> >> > explain how
> >> >> >> >
> >> >> >> > the 'result' variable is fixing things?
> >> >> >> >
> >> >> >> > regards,
> >> >> >> >
> >> >> >> >  Richard
> >> >> >> >
> >> >> >> > [0] See the end of
> >> >> >> >
> >> >> >> >
> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >> >
> >> >> >> > ses/java/io/File.java
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> >
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> _______________________________________________
> >> >> >> Concurrency-interest mailing list
> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> >
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> _______________________________________________
> >> >> Concurrency-interest mailing list
> >> >> Concurrency-interest at cs.oswego.edu
> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/cf68921a/attachment-0001.html>

From nathan.reynolds at oracle.com  Wed Aug 15 19:11:08 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Wed, 15 Aug 2012 16:11:08 -0700
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37H15G7E3PZaYDGkhkhOC0K7JJd4-JKaF2y3r3tGOfXEcg@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
	<CAHjP37H15G7E3PZaYDGkhkhOC0K7JJd4-JKaF2y3r3tGOfXEcg@mail.gmail.com>
Message-ID: <502C2C8C.8070908@oracle.com>

Some companies when running published benchmarks will use CPU affinity 
masks to force each process to run only on one processor socket.  There 
still might be multiple processes allowed to run on the socket.  This 
minimizes the impact from cache invalidations and NUMA but increases 
complexity.  I think this is the beginning of the "spectrum of 
minimizing all sharing".

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 8/15/2012 3:51 PM, Vitaly Davidovich wrote:
>
> This is a big open question: how do you scale on hugely parallel 
> hardware? The answer will most likely lie in the spectrum of 
> minimizing all sharing.  Let's say you didn't even care about data 
> races but were to simply share memory via ordinary stores - no memory 
> barriers whatsoever.  Even in this case, performance on a hugely 
> parallel machine will drop off a cliff due to cache invalidations.  
> Possible hardware advancement/assistance aside, the answer will be to 
> minimize sharing altogether.  It's a hard problem.
>
> Sent from my phone
>
> On Aug 15, 2012 5:22 PM, "Ruslan Cheremin" <cheremin at gmail.com 
> <mailto:cheremin at gmail.com>> wrote:
>
>     Well, I understand your point.
>
>     But this lead me to another interesting question -- why data races is
>     so outlaw? Yes, I understand, it is hard to write correct code with
>     them (by the way, can you give the link about errors in JMM spec about
>     data race you've mention above?), but can we scale really well with
>     sequentially consistent execution only? I mean, in large-scale
>     distributed systems design weakening consistency often gives great
>     performance benefits. AndwWhen I think about something like 786-cores
>     (skip the brand) box, it seems for me there could be many chances to
>     improve performance using racy code. Am I miss something here?
>
>     2012/8/16 Boehm, Hans <hans.boehm at hp.com <mailto:hans.boehm at hp.com>>:
>     >> From: Ruslan Cheremin [mailto:cheremin at gmail.com
>     <mailto:cheremin at gmail.com>]
>     >>
>     >> As far, as I can see, there is two directions. One is what
>     >> "thread-safe" notation in it's commonly used form -- then
>     applied only
>     >> to methods, and not to initialization/publication -- is
>     confusing, and
>     >> there is little reason to exclude construction/publication from
>     thread
>     >> safety protocol by default. My point, among others, is that
>     "immutable
>     >> and thread safe" should be interpreted as "thread safe even for
>     unsafe
>     >> publishing". And this, for example, gives us the chance to remove
>     >> volatile specification in File.path field we started from :)
>     > It seems to me that there's a huge difference here.
>      Synchronization in the constructor only matters in the presence
>     of other dubious programming practices:  Either a reference to the
>     object has to escape before the constructor finishes, or the
>     reference has to be communicated to another thread in a racy
>     manner.  (And the former is a special case under control of the
>     class itself.)  There are strong reasons to avoid both in the vast
>     majority of code.  On the other hand, perfectly normal code will
>     routinely rely on the thread-safety of non-constructor methods all
>     the time.
>     >
>     >>
>     >> Second direction is about construction/publication as specifically
>     >> different from the methods. E.g. it even may have additional safety
>     >> guarantee -- like "publication is always safe". I can see some
>     reasons
>     >> here, since constructor is the only one method, which is
>     guaranteed to
>     >> be called only once on object lifecycle, and so we, possible, can
>     >> restrict some compiler/CPUs optimization in it with little
>     influence
>     >> on overall application performance -- but it throws away all
>     troubles
>     >> with unsafe publishing.
>     > I think we're still generally using "unsafe publishing" to mean
>     either of the two dubious practices I mentioned above, though here
>     we're presumably talking about racy publication after the
>     constructor completes.  The problem is that in general racy
>     publication is already a really bad practice, because the user has
>     to understand the ugly details of the Java memory model, which
>     nobody really does.  Racy publication is a data race, and hence
>     you can no longer reason in terms of sequential consistency,
>     synchronization-free regions become nonatomic, and generally all
>     our intuition about behavior of threads and reasoning about
>     threads goes out the window, even if you can still reason about
>     the integrity of your class.  There are one or two special cases,
>     notably lazy initialization of an immutable object, where you
>     might succeed in hiding all that mess behind a library API, but in
>     general that's hard.  So the question in my mind is whether you
>     want to provide those added guarant!
>      ees to support those one or two cases, or whether you want to
>     limit those guarantees to situations, notably those involving
>     final fields, where they're essential for the security model.  We
>     currently have the latter.
>     >
>     > Hans
>     >>
>     >>
>     >>
>     >> 2012/8/15 Boehm, Hans <hans.boehm at hp.com
>     <mailto:hans.boehm at hp.com>>:
>     >> > Agreed.
>     >> >
>     >> > But, echoing David, I think, I'm not at all sure I see where this
>     >> thread is going.  We've established that
>     >> >
>     >> > a) You can make a class safe against racy publication by
>     >> synchronizing the constructor along with all other methods (or
>     by using
>     >> an immutable class with final fields).
>     >> >
>     >> > b) There are (rather brittle and obscure) use cases in which racy
>     >> publication gives you better performance on architectures like ARM,
>     >> though not x86, currently at the cost of confusing data race
>     detectors.
>     >> >
>     >> > But to me it seems like taking advanatage of (b) is a fairly
>     >> undesirable, though perhaps occasionally unavoidable, hack.  And I
>     >> can't see why it would possibly be a win if you have to
>     synchronize all
>     >> method calls to make it work.
>     >> >
>     >> > Does anyone have a use case in mind where the whole picture we're
>     >> discussing actually makes sense?  It might help to focus this
>     >> discussion.
>     >> >
>     >> > Hans
>     >> >
>     >> >> -----Original Message-----
>     >> >> From: concurrency-interest-bounces at cs.oswego.edu
>     <mailto:concurrency-interest-bounces at cs.oswego.edu>
>     >> [mailto:concurrency- <mailto:concurrency->
>     >> >> interest-bounces at cs.oswego.edu
>     <mailto:interest-bounces at cs.oswego.edu>] On Behalf Of Zhong Yu
>     >> >> Sent: Wednesday, August 15, 2012 10:56 AM
>     >> >> To: Yuval Shavit
>     >> >> Cc: concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>; dholmes at ieee.org
>     <mailto:dholmes at ieee.org>
>     >> >> Subject: Re: [concurrency-interest] Double Checked Locking in
>     >> OpenJDK
>     >> >>
>     >> >> I thought the conclusion of that thread is that synchronizing
>     >> >> constructor has the desired merit - if all constructors and
>     methods
>     >> >> are synchronized, a non-creating thread won't observe the
>     >> zero/partial
>     >> >> state of the object, even if the object reference is published
>     >> >> unsafely.
>     >> >>
>     >> >> (One guy, who shall remain nameless, muddied the water with some
>     >> >> mistaken statements of weaker memory guarantee. He has been
>     >> corrected)
>     >> >>
>     >> >> Zhong Yu
>     >> >>
>     >> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
>     <yshavit at akiban.com <mailto:yshavit at akiban.com>>
>     >> >> wrote:
>     >> >> > There was a discussion here a few months ago about
>     synchronizing
>     >> >> > constructors -- I had asked why it's not allowed, and the
>     >> discussion
>     >> >> hit on
>     >> >> > some of the similar points brought up in this thread.
>     >> >> >
>     >> >> > But to your point specifically, synchronizing a
>     constructor (via
>     >> >> > "synchronized(this) {...}" surrounding its body) still doesn't
>     >> give
>     >> >> you full
>     >> >> > thread safety (even assuming immutability after the
>     constructor --
>     >> >> but
>     >> >> > without final fields). It ensures that a thread can
>     observe the
>     >> >> object
>     >> >> > either fully constructed *or* with all its fields having their
>     >> >> default
>     >> >> > values. In other words, even if your constructor is
>     synchronized
>     >> on
>     >> >> the same
>     >> >> > object your getter is, a thread could observe a field as
>     it was
>     >> >> before the
>     >> >> > constructor was invoked.
>     >> >> >
>     >> >> > http://markmail.org/message/mav53xzo4bqu7udw
>     >> >> >
>     >> >> >
>     >> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
>     >> >> <cheremin at gmail.com <mailto:cheremin at gmail.com>>
>     >> >> > wrote:
>     >> >> >>
>     >> >> >> > The reason to keep them distinct is because in general the
>     >> >> mechanisms
>     >> >> >> > for
>     >> >> >> > safe publication are external to the class, while those for
>     >> >> >> > thread-safety
>     >> >> >> > are internal. It is only an edge case where use of
>     synchronized
>     >> in
>     >> >> a
>     >> >> >> > constructor can achieve safe-publication.
>     >> >> >>
>     >> >> >> Well, actually I do not understand your point. If I use
>     some kind
>     >> of
>     >> >> >> synchronization to make methods of my object thread-safe
>     -- can't
>     >> I
>     >> >> >> also apply same thing to constructor? For me, it makes
>     the thing
>     >> >> only
>     >> >> >> clearer. Object can be thread-safe -- and it is totally
>     thread
>     >> safe.
>     >> >> >> Object can require external synchronization for correct
>     >> >> multithreaded
>     >> >> >> use -- and it requires the sync for publishing and for usage
>     >> also.
>     >> >> >>
>     >> >> >> From my point of view, the distinction you talking about
>     is more
>     >> >> >> historically reasoned. "Sync method if you want it to be
>     thread-
>     >> >> safe"
>     >> >> >> is commonly learned mantra, but "take care of initialization
>     >> also"
>     >> >> is
>     >> >> >> not so common. More information about it, more education,
>     more
>     >> >> >> different code samples with outlined "here is the
>     dragons" will
>     >> >> change
>     >> >> >> the situation, I sure, it just have to be highlighted
>     more often.
>     >> >> >>
>     >> >> >>
>     >> >> >> > People have to recognize that sharing an object
>     requires shared
>     >> >> mutable
>     >> >> >> > state, and the number one tenet of concurrent
>     programming is
>     >> that
>     >> >> access
>     >> >> >> > to
>     >> >> >> > shared mutable state has to be synchronized (in a
>     general sense
>     >> >> not
>     >> >> >> > specifically use of 'synchronized' keyword).
>     >> >> >> >
>     >> >> >> > Making every object safely publishable could be done,
>     but for
>     >> 99%
>     >> >> of
>     >> >> >> > objects
>     >> >> >> > it would be a waste of effort. Programs without data races
>     >> don't
>     >> >> have
>     >> >> >> > issues
>     >> >> >> > with unsafe publication.
>     >> >> >> >
>     >> >> >> > David
>     >> >> >> >
>     >> >> >> > -----Original Message-----
>     >> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
>     <mailto:concurrency-interest-bounces at cs.oswego.edu>
>     >> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu
>     <mailto:concurrency-interest-bounces at cs.oswego.edu>]On Behalf Of
>     >> >> Nathan
>     >> >> >> > Reynolds
>     >> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
>     >> >> >> > To: concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>
>     >> >> >> > Subject: Re: [concurrency-interest] Double Checked
>     Locking in
>     >> >> OpenJDK
>     >> >> >> >
>     >> >> >> > We seem to be splitting two notions (i.e thread-safe
>     and safe
>     >> >> >> > publication)
>     >> >> >> > when they should be combined in a sense.  Typically,
>     when we
>     >> say
>     >> >> >> > thread-safe
>     >> >> >> > we talk about the operations performed on the object
>     after it
>     >> was
>     >> >> >> > constructed (and its contents are globally visible).
>      However,
>     >> we
>     >> >> need
>     >> >> >> > to
>     >> >> >> > consider that executing the constructor is modifying
>     the state
>     >> of
>     >> >> the
>     >> >> >> > object.  It requires the same mechanisms that the rest
>     of the
>     >> >> class uses
>     >> >> >> > to
>     >> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>     >> >> executing the
>     >> >> >> > constructor, a proper releasing of a lock or some other
>     >> happens-
>     >> >> before
>     >> >> >> > construct is required to ensure that the memory updates
>     by the
>     >> >> thread
>     >> >> >> > are
>     >> >> >> > made globally visible before the object is accessed by
>     another
>     >> >> thread.
>     >> >> >> > This
>     >> >> >> > is what we are calling safe publication.  So, safe
>     publication
>     >> is
>     >> >> a
>     >> >> >> > subset
>     >> >> >> > of thread-safety except it is limited to what happens
>     after the
>     >> >> >> > constructor
>     >> >> >> > is called and before the object is used by multiple
>     threads.
>     >> >> >> >
>     >> >> >> > A beautifully-written class can be thread-safe with
>     respect to
>     >> >> calling
>     >> >> >> > its
>     >> >> >> > member methods but not thread-safe with respect to
>     calling its
>     >> >> >> > constructor.
>     >> >> >> > It is this latter case that many stumble upon because they
>     >> think
>     >> >> that
>     >> >> >> > constructors are inherently thread-safe because they are
>     >> executed
>     >> >> >> > single-threadedly.  What they fail to realize is that the
>     >> >> execution of a
>     >> >> >> > constructor can overlap with the execution of other
>     code from
>     >> the
>     >> >> view
>     >> >> >> > point
>     >> >> >> > of what is happening in memory.  This same problem
>     applies to
>     >> more
>     >> >> rare
>     >> >> >> > case
>     >> >> >> > of regular methods which can be proven to execute in a
>     single
>     >> >> thread but
>     >> >> >> > don't use synchronization before multiple threads start
>     >> accessing
>     >> >> the
>     >> >> >> > shared
>     >> >> >> > data.
>     >> >> >> >
>     >> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>     >> >> 602.333.9091 <tel:602.333.9091>
>     >> >> >> > Oracle PSR Engineering | Server Technology
>     >> >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
>     >> >> >> >
>     >> >> >> > Ruslan Cheremin writes:
>     >> >> >> >
>     >> >> >> > For me it is confusing: java has only one way to have
>     really
>     >> >> immutable
>     >> >> >> > object, and this way also gives you a total thread
>     safety even
>     >> for
>     >> >> >> > data race based publication. But then docs refer object as
>     >> >> "immutable
>     >> >> >> > and thread-safe" -- we still can't assume it to be really
>     >> thread-
>     >> >> safe?
>     >> >> >> >
>     >> >> >> > It is better/simpler to isolate the notion of
>     thread-safety and
>     >> >> safe
>     >> >> >> > publication. Thread-safety comes into play after you have
>     >> safely
>     >> >> shared
>     >> >> >> > an
>     >> >> >> > object. The means by which you safely share an object is
>     >> >> orthogonal to
>     >> >> >> > how
>     >> >> >> > the object itself is made thread-safe.
>     >> >> >> >
>     >> >> >> > The means by which an object is shared has to involve
>     shared
>     >> >> mutable
>     >> >> >> > state,
>     >> >> >> > and use of shared mutable state always needs some form of
>     >> >> >> > synchronization
>     >> >> >> > (either implicit eg due to static initialization; or
>     explicit
>     >> by
>     >> >> using
>     >> >> >> > volatile or synchronized getter/setter methods).
>     >> >> >> >
>     >> >> >> > David
>     >> >> >> > -----
>     >> >> >> >
>     >> >> >> > It's a pity, especially because true immutability gives
>     us some
>     >> >> >> > chances of performance optimization. As in this case --
>     we do
>     >> not
>     >> >> >> > really need .path to be volatile here, if we would
>     assume Path
>     >> to
>     >> >> be
>     >> >> >> > truly immutable. volatility here required only for ensuring
>     >> safe
>     >> >> >> > publishing.
>     >> >> >> >
>     >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au
>     <mailto:davidcholmes at aapt.net.au>>:
>     >> >> >> >
>     >> >> >> > Ruslan Cheremin writes:>
>     >> >> >> >
>     >> >> >> > But is there a way to define "safe for data race
>     publishing"? I
>     >> as
>     >> >> >> > far, as I remember, "immutable and thread-safe" is standard
>     >> mantra
>     >> >> in
>     >> >> >> > JDK javadocs for totally safe objects. j.l.String has same
>     >> mantra
>     >> >> --
>     >> >> >> > and it is safe for any way of publishing. Does you mean, I
>     >> should
>     >> >> >> > explicitly add "safe even for publishing via data race" in
>     >> docs?
>     >> >> But I
>     >> >> >> > can't remember any such phrase in JDK docs.
>     >> >> >> >
>     >> >> >> > I don't recall anything in the JDK docs that mention being
>     >> >> >> >
>     >> >> >> > "totally safe"
>     >> >> >> >
>     >> >> >> > regardless of publication mechanism. Some classes, eg
>     String,
>     >> have
>     >> >> been
>     >> >> >> > defined such that they do have that property (for security
>     >> >> reasons). In
>     >> >> >> > general neither "thread-safe" nor "immutable" imply
>     >> >> >> > safe-for-unsynchronized-publication.
>     >> >> >> >
>     >> >> >> > Java Concurrency In Practice (jcip.net
>     <http://jcip.net>) does define additional
>     >> >> potential
>     >> >> >> > annotations, where @Immutable would indeed capture the
>     >> requirement
>     >> >> of
>     >> >> >> > safe-for-unsynchronized-publication.
>     >> >> >> >
>     >> >> >> > David
>     >> >> >> > -----
>     >> >> >> >
>     >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au
>     <mailto:davidcholmes at aapt.net.au>>:
>     >> >> >> >
>     >> >> >> > Ruslan Cheremin writes:
>     >> >> >> >
>     >> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>     >> >> >> > multithreaded use". Although it is not strictly defined
>     in java
>     >> >> what
>     >> >> >> > exactly means "safe for multithreaded use" -- does it
>     mean safe
>     >> >> for
>     >> >> >> > publishing via data race, among others? -- I suppose, it
>     >> >> >> >
>     >> >> >> > should be. Am
>     >> >> >> >
>     >> >> >> > I wrong here?
>     >> >> >> >
>     >> >> >> > "safe for multi-threaded use" does not generally imply
>     that it
>     >> >> >> >
>     >> >> >> > is safe to
>     >> >> >> >
>     >> >> >> > publish instances without synchronization of some form.
>     >> >> >> >
>     >> >> >> > David
>     >> >> >> > -----
>     >> >> >> >
>     >> >> >> > From other side, File.toPath javadoc explicitly says what
>     >> >> "returned
>     >> >> >> > instance must be the same for every invocation", so
>     sync block
>     >> is
>     >> >> >> > required here for mutual exclusion on initialization phase.
>     >> >> Without
>     >> >> >> > this requirement it is also safe to live without sync
>     block,
>     >> >> afaik.
>     >> >> >> >
>     >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au
>     <mailto:davidcholmes at aapt.net.au>>:
>     >> >> >> >
>     >> >> >> > Ruslan Cheremin writes:
>     >> >> >> >
>     >> >> >> > First of all, Path is immutable, so DCL is safe here even
>     >> without
>     >> >> >> > volatile. Volatile here is not required from my point
>     of view.
>     >> >> >> >
>     >> >> >> > Without the volatile the Path implementation (Path is an
>     >> >> >> >
>     >> >> >> > interface) must be
>     >> >> >> >
>     >> >> >> > such that an instance of Path can be safely published
>     without
>     >> >> >> >
>     >> >> >> > any additional
>     >> >> >> >
>     >> >> >> > forms of synchronization. Immutability does not in itself
>     >> >> >> >
>     >> >> >> > ensure that. You
>     >> >> >> >
>     >> >> >> > would have to examine the actual implementation class.
>     >> >> >> >
>     >> >> >> > David Holmes
>     >> >> >> > ------------
>     >> >> >> >
>     >> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com
>     <mailto:vyazelenko at yahoo.com>>:
>     >> >> >> >
>     >> >> >> > Hi Richard,
>     >> >> >> >
>     >> >> >> > The variable "filePath" is volatile, so the double-checked
>     >> >> >> >
>     >> >> >> > locking is correct in this case. It would have been a bug
>     >> >> >> >
>     >> >> >> > prior to Java 5.
>     >> >> >> >
>     >> >> >> > Best regards,
>     >> >> >> >
>     >> >> >> > Dmitry Vyazelenko
>     >> >> >> >
>     >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>     >> >> >> >
>     >> >> >> > <richard.warburton at gmail.com
>     <mailto:richard.warburton at gmail.com>> wrote:
>     >> >> >> >
>     >> >> >> > Hello,
>     >> >> >> >
>     >> >> >> > The current implementation of java.io.File::toPath [0]
>     >> >> >> >
>     >> >> >> > appears to be
>     >> >> >> >
>     >> >> >> > using the double checked locking pattern:
>     >> >> >> >
>     >> >> >> >     public Path toPath() {
>     >> >> >> >         Path result = filePath;
>     >> >> >> >         if (result == null) {
>     >> >> >> >             synchronized (this) {
>     >> >> >> >                 result = filePath;
>     >> >> >> >                 if (result == null) {
>     >> >> >> >                     result =
>     >> >> >> >
>     >> >> >> > FileSystems.getDefault().getPath(path);
>     >> >> >> >
>     >> >> >> >                     filePath = result;
>     >> >> >> >                 }
>     >> >> >> >             }
>     >> >> >> >         }
>     >> >> >> >         return result;
>     >> >> >> >     }
>     >> >> >> >
>     >> >> >> > I was going to report the bug, but I'm a little
>     >> >> >> >
>     >> >> >> > uncertain of the
>     >> >> >> >
>     >> >> >> > interaction between the local variable 'result' and DCL
>     >> >> >> >
>     >> >> >> > since I've
>     >> >> >> >
>     >> >> >> > previously only seen the checking condition on the
>     >> >> >> >
>     >> >> >> > shared field
>     >> >> >> >
>     >> >> >> > itself.  Can someone here either confirm that its a bug or
>     >> >> >> >
>     >> >> >> > explain how
>     >> >> >> >
>     >> >> >> > the 'result' variable is fixing things?
>     >> >> >> >
>     >> >> >> > regards,
>     >> >> >> >
>     >> >> >> >  Richard
>     >> >> >> >
>     >> >> >> > [0] See the end of
>     >> >> >> >
>     >> >> >> >
>     >>
>     hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>     <http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas>
>     >> >> >> >
>     >> >> >> > ses/java/io/File.java
>     >> >> >> >
>     >> >> >> > _______________________________________________
>     >> >> >> > Concurrency-interest mailing list
>     >> >> >> > Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >> >> >> >
>     >> >> >> > _______________________________________________
>     >> >> >> > Concurrency-interest mailing list
>     >> >> >> > Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >> >> >> >
>     >> >> >> > _______________________________________________
>     >> >> >> > Concurrency-interest mailing list
>     >> >> >> > Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >> >> >> >
>     >> >> >> > _______________________________________________
>     >> >> >> > Concurrency-interest mailing list
>     >> >> >> > Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >> >> >> >
>     >> >> >> >
>     >> >> >> >
>     >> >> >> > _______________________________________________
>     >> >> >> > Concurrency-interest mailing list
>     >> >> >> > Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >> >> >> >
>     >> >> >> _______________________________________________
>     >> >> >> Concurrency-interest mailing list
>     >> >> >> Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >> >> >
>     >> >> >
>     >> >> >
>     >> >> > _______________________________________________
>     >> >> > Concurrency-interest mailing list
>     >> >> > Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >> >> >
>     >> >> _______________________________________________
>     >> >> Concurrency-interest mailing list
>     >> >> Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >> >
>     >> > _______________________________________________
>     >> > Concurrency-interest mailing list
>     >> > Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/63d734af/attachment-0001.html>

From davidcholmes at aapt.net.au  Wed Aug 15 19:21:04 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 16 Aug 2012 09:21:04 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEECEJGAA.davidcholmes@aapt.net.au>

Ruslan Cheremin writes:
>
> > The reason to keep them distinct is because in general the
> > mechanisms for safe publication are external to the class,
> > while those for thread-safety are internal. It is only an
> > edge case where use of synchronized in a constructor can
> > achieve safe-publication.
>
> Well, actually I do not understand your point. If I use some kind of
> synchronization to make methods of my object thread-safe -- can't I
> also apply same thing to constructor? For me, it makes the thing only
> clearer. Object can be thread-safe -- and it is totally thread safe.
> Object can require external synchronization for correct multithreaded
> use -- and it requires the sync for publishing and for usage also.

You have to be able to establish the necessary happens-before relationships
between the end of construction, publication and use.

If thread-safe means you've created a "monitor" where only one method
invocation can proceed at a time and all methods are synchronized, then
synchronized in the constructor will construction happens-before use, and
the publication mechanism is not relevant.

If all your fields are final or volatile then you also have no issue with
publication.

Otherwise you have a bit more work to do. Relying on safe-publication to
introduce the happens-before ordering allows you to use simpler, more
natural, and likely more performant code in your thread-safe class.

David
-----


> From my point of view, the distinction you talking about is more
> historically reasoned. "Sync method if you want it to be thread-safe"
> is commonly learned mantra, but "take care of initialization also" is
> not so common. More information about it, more education, more
> different code samples with outlined "here is the dragons" will change
> the situation, I sure, it just have to be highlighted more often.
>
>
> > People have to recognize that sharing an object requires shared mutable
> > state, and the number one tenet of concurrent programming is
> that access to
> > shared mutable state has to be synchronized (in a general sense not
> > specifically use of 'synchronized' keyword).
> >
> > Making every object safely publishable could be done, but for
> 99% of objects
> > it would be a waste of effort. Programs without data races
> don't have issues
> > with unsafe publication.
> >
> > David
> >
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan
> > Reynolds
> > Sent: Wednesday, 15 August 2012 4:59 AM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> >
> > We seem to be splitting two notions (i.e thread-safe and safe
> publication)
> > when they should be combined in a sense.  Typically, when we
> say thread-safe
> > we talk about the operations performed on the object after it was
> > constructed (and its contents are globally visible).  However,
> we need to
> > consider that executing the constructor is modifying the state of the
> > object.  It requires the same mechanisms that the rest of the
> class uses to
> > ensure thread-safety.  Even though, there is only 1 thread executing the
> > constructor, a proper releasing of a lock or some other happens-before
> > construct is required to ensure that the memory updates by the
> thread are
> > made globally visible before the object is accessed by another
> thread.  This
> > is what we are calling safe publication.  So, safe publication
> is a subset
> > of thread-safety except it is limited to what happens after the
> constructor
> > is called and before the object is used by multiple threads.
> >
> > A beautifully-written class can be thread-safe with respect to
> calling its
> > member methods but not thread-safe with respect to calling its
> constructor.
> > It is this latter case that many stumble upon because they think that
> > constructors are inherently thread-safe because they are executed
> > single-threadedly.  What they fail to realize is that the execution of a
> > constructor can overlap with the execution of other code from
> the view point
> > of what is happening in memory.  This same problem applies to
> more rare case
> > of regular methods which can be proven to execute in a single thread but
> > don't use synchronization before multiple threads start
> accessing the shared
> > data.
> >
> > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> > Oracle PSR Engineering | Server Technology
> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >
> > Ruslan Cheremin writes:
> >
> > For me it is confusing: java has only one way to have really immutable
> > object, and this way also gives you a total thread safety even for
> > data race based publication. But then docs refer object as "immutable
> > and thread-safe" -- we still can't assume it to be really thread-safe?
> >
> > It is better/simpler to isolate the notion of thread-safety and safe
> > publication. Thread-safety comes into play after you have
> safely shared an
> > object. The means by which you safely share an object is
> orthogonal to how
> > the object itself is made thread-safe.
> >
> > The means by which an object is shared has to involve shared
> mutable state,
> > and use of shared mutable state always needs some form of
> synchronization
> > (either implicit eg due to static initialization; or explicit by using
> > volatile or synchronized getter/setter methods).
> >
> > David
> > -----
> >
> > It's a pity, especially because true immutability gives us some
> > chances of performance optimization. As in this case -- we do not
> > really need .path to be volatile here, if we would assume Path to be
> > truly immutable. volatility here required only for ensuring safe
> > publishing.
> >
> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >
> > Ruslan Cheremin writes:>
> >
> > But is there a way to define "safe for data race publishing"? I as
> > far, as I remember, "immutable and thread-safe" is standard mantra in
> > JDK javadocs for totally safe objects. j.l.String has same mantra --
> > and it is safe for any way of publishing. Does you mean, I should
> > explicitly add "safe even for publishing via data race" in docs? But I
> > can't remember any such phrase in JDK docs.
> >
> > I don't recall anything in the JDK docs that mention being
> >
> > "totally safe"
> >
> > regardless of publication mechanism. Some classes, eg String, have been
> > defined such that they do have that property (for security reasons). In
> > general neither "thread-safe" nor "immutable" imply
> > safe-for-unsynchronized-publication.
> >
> > Java Concurrency In Practice (jcip.net) does define additional potential
> > annotations, where @Immutable would indeed capture the requirement of
> > safe-for-unsynchronized-publication.
> >
> > David
> > -----
> >
> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >
> > Ruslan Cheremin writes:
> >
> > Well, Path javadoc explicitly says "immutable and safe for
> > multithreaded use". Although it is not strictly defined in java what
> > exactly means "safe for multithreaded use" -- does it mean safe for
> > publishing via data race, among others? -- I suppose, it
> >
> > should be. Am
> >
> > I wrong here?
> >
> > "safe for multi-threaded use" does not generally imply that it
> >
> > is safe to
> >
> > publish instances without synchronization of some form.
> >
> > David
> > -----
> >
> > From other side, File.toPath javadoc explicitly says what "returned
> > instance must be the same for every invocation", so sync block is
> > required here for mutual exclusion on initialization phase. Without
> > this requirement it is also safe to live without sync block, afaik.
> >
> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >
> > Ruslan Cheremin writes:
> >
> > First of all, Path is immutable, so DCL is safe here even without
> > volatile. Volatile here is not required from my point of view.
> >
> > Without the volatile the Path implementation (Path is an
> >
> > interface) must be
> >
> > such that an instance of Path can be safely published without
> >
> > any additional
> >
> > forms of synchronization. Immutability does not in itself
> >
> > ensure that. You
> >
> > would have to examine the actual implementation class.
> >
> > David Holmes
> > ------------
> >
> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >
> > Hi Richard,
> >
> > The variable "filePath" is volatile, so the double-checked
> >
> > locking is correct in this case. It would have been a bug
> >
> > prior to Java 5.
> >
> > Best regards,
> >
> > Dmitry Vyazelenko
> >
> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >
> > <richard.warburton at gmail.com> wrote:
> >
> > Hello,
> >
> > The current implementation of java.io.File::toPath [0]
> >
> > appears to be
> >
> > using the double checked locking pattern:
> >
> >     public Path toPath() {
> >         Path result = filePath;
> >         if (result == null) {
> >             synchronized (this) {
> >                 result = filePath;
> >                 if (result == null) {
> >                     result =
> >
> > FileSystems.getDefault().getPath(path);
> >
> >                     filePath = result;
> >                 }
> >             }
> >         }
> >         return result;
> >     }
> >
> > I was going to report the bug, but I'm a little
> >
> > uncertain of the
> >
> > interaction between the local variable 'result' and DCL
> >
> > since I've
> >
> > previously only seen the checking condition on the
> >
> > shared field
> >
> > itself.  Can someone here either confirm that its a bug or
> >
> > explain how
> >
> > the 'result' variable is fixing things?
> >
> > regards,
> >
> >  Richard
> >
> > [0] See the end of
> >
> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >
> > ses/java/io/File.java
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>


From davidcholmes at aapt.net.au  Wed Aug 15 19:30:40 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 16 Aug 2012 09:30:40 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAC2Zdp067842v9RwCKSaig-vosxTUX84n=RgxyPue7bHC31Huw@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEECFJGAA.davidcholmes@aapt.net.au>

The former is also the historical default. People have been writing
thread-safe code since before unsafe-publication was even a possibility.

It is unfortunate that hardware conspired to add add this additional axis of
complexity to concurrent programming, but it did and it takes everyone by
surprise. The average programmer does not want to have to worry about this
level of detail, but hiding it completely has not been practical to date.

David
  -----Original Message-----
  From: Yuval Shavit [mailto:yshavit at akiban.com]
  Sent: Thursday, 16 August 2012 7:05 AM
  To: Boehm, Hans
  Cc: Ruslan Cheremin; Zhong Yu; concurrency-interest at cs.oswego.edu;
dholmes at ieee.org
  Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK


  I agree. If I may hazard a more succinct way of phrasing it:


  There are two variants of "thread safe": thread safe assuming safe initial
publication, and thread safe even in the absence of safe publication. We
have to pick one as the default, for when we just want the shorthand "thread
safe" without qualification. Although one could argue that the latter is
more purely thread safe, the counter argument is that the former is more
useful in day-to-day programming.


  On Wed, Aug 15, 2012 at 4:39 PM, Boehm, Hans <hans.boehm at hp.com> wrote:

    > From: Ruslan Cheremin [mailto:cheremin at gmail.com]

    >
    > As far, as I can see, there is two directions. One is what
    > "thread-safe" notation in it's commonly used form -- then applied only
    > to methods, and not to initialization/publication -- is confusing, and
    > there is little reason to exclude construction/publication from thread
    > safety protocol by default. My point, among others, is that "immutable
    > and thread safe" should be interpreted as "thread safe even for unsafe
    > publishing". And this, for example, gives us the chance to remove
    > volatile specification in File.path field we started from :)

    It seems to me that there's a huge difference here.  Synchronization in
the constructor only matters in the presence of other dubious programming
practices:  Either a reference to the object has to escape before the
constructor finishes, or the reference has to be communicated to another
thread in a racy manner.  (And the former is a special case under control of
the class itself.)  There are strong reasons to avoid both in the vast
majority of code.  On the other hand, perfectly normal code will routinely
rely on the thread-safety of non-constructor methods all the time.


    >
    > Second direction is about construction/publication as specifically
    > different from the methods. E.g. it even may have additional safety
    > guarantee -- like "publication is always safe". I can see some reasons
    > here, since constructor is the only one method, which is guaranteed to
    > be called only once on object lifecycle, and so we, possible, can
    > restrict some compiler/CPUs optimization in it with little influence
    > on overall application performance -- but it throws away all troubles
    > with unsafe publishing.

    I think we're still generally using "unsafe publishing" to mean either
of the two dubious practices I mentioned above, though here we're presumably
talking about racy publication after the constructor completes.  The problem
is that in general racy publication is already a really bad practice,
because the user has to understand the ugly details of the Java memory
model, which nobody really does.  Racy publication is a data race, and hence
you can no longer reason in terms of sequential consistency,
synchronization-free regions become nonatomic, and generally all our
intuition about behavior of threads and reasoning about threads goes out the
window, even if you can still reason about the integrity of your class.
There are one or two special cases, notably lazy initialization of an
immutable object, where you might succeed in hiding all that mess behind a
library API, but in general that's hard.  So the question in my mind is
whether you want to provide those added guarantees to support those one or
two cases, or whether you want to limit those guarantees to situations,
notably those involving final fields, where they're essential for the
security model.  We currently have the latter.

    Hans

    >
    >
    >
    > 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
    > > Agreed.
    > >
    > > But, echoing David, I think, I'm not at all sure I see where this
    > thread is going.  We've established that
    > >
    > > a) You can make a class safe against racy publication by
    > synchronizing the constructor along with all other methods (or by
using
    > an immutable class with final fields).
    > >
    > > b) There are (rather brittle and obscure) use cases in which racy
    > publication gives you better performance on architectures like ARM,
    > though not x86, currently at the cost of confusing data race
detectors.
    > >
    > > But to me it seems like taking advanatage of (b) is a fairly
    > undesirable, though perhaps occasionally unavoidable, hack.  And I
    > can't see why it would possibly be a win if you have to synchronize
all
    > method calls to make it work.
    > >
    > > Does anyone have a use case in mind where the whole picture we're
    > discussing actually makes sense?  It might help to focus this
    > discussion.
    > >
    > > Hans
    > >
    > >> -----Original Message-----
    > >> From: concurrency-interest-bounces at cs.oswego.edu
    > [mailto:concurrency-
    > >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
    > >> Sent: Wednesday, August 15, 2012 10:56 AM
    > >> To: Yuval Shavit
    > >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
    > >> Subject: Re: [concurrency-interest] Double Checked Locking in
    > OpenJDK
    > >>
    > >> I thought the conclusion of that thread is that synchronizing
    > >> constructor has the desired merit - if all constructors and methods
    > >> are synchronized, a non-creating thread won't observe the
    > zero/partial
    > >> state of the object, even if the object reference is published
    > >> unsafely.
    > >>
    > >> (One guy, who shall remain nameless, muddied the water with some
    > >> mistaken statements of weaker memory guarantee. He has been
    > corrected)
    > >>
    > >> Zhong Yu
    > >>
    > >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit <yshavit at akiban.com>
    > >> wrote:
    > >> > There was a discussion here a few months ago about synchronizing
    > >> > constructors -- I had asked why it's not allowed, and the
    > discussion
    > >> hit on
    > >> > some of the similar points brought up in this thread.
    > >> >
    > >> > But to your point specifically, synchronizing a constructor (via
    > >> > "synchronized(this) {...}" surrounding its body) still doesn't
    > give
    > >> you full
    > >> > thread safety (even assuming immutability after the
constructor --
    > >> but
    > >> > without final fields). It ensures that a thread can observe the
    > >> object
    > >> > either fully constructed *or* with all its fields having their
    > >> default
    > >> > values. In other words, even if your constructor is synchronized
    > on
    > >> the same
    > >> > object your getter is, a thread could observe a field as it was
    > >> before the
    > >> > constructor was invoked.
    > >> >
    > >> > http://markmail.org/message/mav53xzo4bqu7udw
    > >> >
    > >> >
    > >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
    > >> <cheremin at gmail.com>
    > >> > wrote:
    > >> >>
    > >> >> > The reason to keep them distinct is because in general the
    > >> mechanisms
    > >> >> > for
    > >> >> > safe publication are external to the class, while those for
    > >> >> > thread-safety
    > >> >> > are internal. It is only an edge case where use of
synchronized
    > in
    > >> a
    > >> >> > constructor can achieve safe-publication.
    > >> >>
    > >> >> Well, actually I do not understand your point. If I use some
kind
    > of
    > >> >> synchronization to make methods of my object thread-safe --
can't
    > I
    > >> >> also apply same thing to constructor? For me, it makes the thing
    > >> only
    > >> >> clearer. Object can be thread-safe -- and it is totally thread
    > safe.
    > >> >> Object can require external synchronization for correct
    > >> multithreaded
    > >> >> use -- and it requires the sync for publishing and for usage
    > also.
    > >> >>
    > >> >> From my point of view, the distinction you talking about is more
    > >> >> historically reasoned. "Sync method if you want it to be thread-
    > >> safe"
    > >> >> is commonly learned mantra, but "take care of initialization
    > also"
    > >> is
    > >> >> not so common. More information about it, more education, more
    > >> >> different code samples with outlined "here is the dragons" will
    > >> change
    > >> >> the situation, I sure, it just have to be highlighted more
often.
    > >> >>
    > >> >>
    > >> >> > People have to recognize that sharing an object requires
shared
    > >> mutable
    > >> >> > state, and the number one tenet of concurrent programming is
    > that
    > >> access
    > >> >> > to
    > >> >> > shared mutable state has to be synchronized (in a general
sense
    > >> not
    > >> >> > specifically use of 'synchronized' keyword).
    > >> >> >
    > >> >> > Making every object safely publishable could be done, but for
    > 99%
    > >> of
    > >> >> > objects
    > >> >> > it would be a waste of effort. Programs without data races
    > don't
    > >> have
    > >> >> > issues
    > >> >> > with unsafe publication.
    > >> >> >
    > >> >> > David
    > >> >> >
    > >> >> > -----Original Message-----
    > >> >> > From: concurrency-interest-bounces at cs.oswego.edu
    > >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
Of
    > >> Nathan
    > >> >> > Reynolds
    > >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
    > >> >> > To: concurrency-interest at cs.oswego.edu
    > >> >> > Subject: Re: [concurrency-interest] Double Checked Locking in
    > >> OpenJDK
    > >> >> >
    > >> >> > We seem to be splitting two notions (i.e thread-safe and safe
    > >> >> > publication)
    > >> >> > when they should be combined in a sense.  Typically, when we
    > say
    > >> >> > thread-safe
    > >> >> > we talk about the operations performed on the object after it
    > was
    > >> >> > constructed (and its contents are globally visible).  However,
    > we
    > >> need
    > >> >> > to
    > >> >> > consider that executing the constructor is modifying the state
    > of
    > >> the
    > >> >> > object.  It requires the same mechanisms that the rest of the
    > >> class uses
    > >> >> > to
    > >> >> > ensure thread-safety.  Even though, there is only 1 thread
    > >> executing the
    > >> >> > constructor, a proper releasing of a lock or some other
    > happens-
    > >> before
    > >> >> > construct is required to ensure that the memory updates by the
    > >> thread
    > >> >> > are
    > >> >> > made globally visible before the object is accessed by another
    > >> thread.
    > >> >> > This
    > >> >> > is what we are calling safe publication.  So, safe publication
    > is
    > >> a
    > >> >> > subset
    > >> >> > of thread-safety except it is limited to what happens after
the
    > >> >> > constructor
    > >> >> > is called and before the object is used by multiple threads.
    > >> >> >
    > >> >> > A beautifully-written class can be thread-safe with respect to
    > >> calling
    > >> >> > its
    > >> >> > member methods but not thread-safe with respect to calling its
    > >> >> > constructor.
    > >> >> > It is this latter case that many stumble upon because they
    > think
    > >> that
    > >> >> > constructors are inherently thread-safe because they are
    > executed
    > >> >> > single-threadedly.  What they fail to realize is that the
    > >> execution of a
    > >> >> > constructor can overlap with the execution of other code from
    > the
    > >> view
    > >> >> > point
    > >> >> > of what is happening in memory.  This same problem applies to
    > more
    > >> rare
    > >> >> > case
    > >> >> > of regular methods which can be proven to execute in a single
    > >> thread but
    > >> >> > don't use synchronization before multiple threads start
    > accessing
    > >> the
    > >> >> > shared
    > >> >> > data.
    > >> >> >
    > >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
    > >> 602.333.9091
    > >> >> > Oracle PSR Engineering | Server Technology
    > >> >> > On 8/13/2012 4:08 PM, David Holmes wrote:
    > >> >> >
    > >> >> > Ruslan Cheremin writes:
    > >> >> >
    > >> >> > For me it is confusing: java has only one way to have really
    > >> immutable
    > >> >> > object, and this way also gives you a total thread safety even
    > for
    > >> >> > data race based publication. But then docs refer object as
    > >> "immutable
    > >> >> > and thread-safe" -- we still can't assume it to be really
    > thread-
    > >> safe?
    > >> >> >
    > >> >> > It is better/simpler to isolate the notion of thread-safety
and
    > >> safe
    > >> >> > publication. Thread-safety comes into play after you have
    > safely
    > >> shared
    > >> >> > an
    > >> >> > object. The means by which you safely share an object is
    > >> orthogonal to
    > >> >> > how
    > >> >> > the object itself is made thread-safe.
    > >> >> >
    > >> >> > The means by which an object is shared has to involve shared
    > >> mutable
    > >> >> > state,
    > >> >> > and use of shared mutable state always needs some form of
    > >> >> > synchronization
    > >> >> > (either implicit eg due to static initialization; or explicit
    > by
    > >> using
    > >> >> > volatile or synchronized getter/setter methods).
    > >> >> >
    > >> >> > David
    > >> >> > -----
    > >> >> >
    > >> >> > It's a pity, especially because true immutability gives us
some
    > >> >> > chances of performance optimization. As in this case -- we do
    > not
    > >> >> > really need .path to be volatile here, if we would assume Path
    > to
    > >> be
    > >> >> > truly immutable. volatility here required only for ensuring
    > safe
    > >> >> > publishing.
    > >> >> >
    > >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
    > >> >> >
    > >> >> > Ruslan Cheremin writes:>
    > >> >> >
    > >> >> > But is there a way to define "safe for data race publishing"?
I
    > as
    > >> >> > far, as I remember, "immutable and thread-safe" is standard
    > mantra
    > >> in
    > >> >> > JDK javadocs for totally safe objects. j.l.String has same
    > mantra
    > >> --
    > >> >> > and it is safe for any way of publishing. Does you mean, I
    > should
    > >> >> > explicitly add "safe even for publishing via data race" in
    > docs?
    > >> But I
    > >> >> > can't remember any such phrase in JDK docs.
    > >> >> >
    > >> >> > I don't recall anything in the JDK docs that mention being
    > >> >> >
    > >> >> > "totally safe"
    > >> >> >
    > >> >> > regardless of publication mechanism. Some classes, eg String,
    > have
    > >> been
    > >> >> > defined such that they do have that property (for security
    > >> reasons). In
    > >> >> > general neither "thread-safe" nor "immutable" imply
    > >> >> > safe-for-unsynchronized-publication.
    > >> >> >
    > >> >> > Java Concurrency In Practice (jcip.net) does define additional
    > >> potential
    > >> >> > annotations, where @Immutable would indeed capture the
    > requirement
    > >> of
    > >> >> > safe-for-unsynchronized-publication.
    > >> >> >
    > >> >> > David
    > >> >> > -----
    > >> >> >
    > >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
    > >> >> >
    > >> >> > Ruslan Cheremin writes:
    > >> >> >
    > >> >> > Well, Path javadoc explicitly says "immutable and safe for
    > >> >> > multithreaded use". Although it is not strictly defined in
java
    > >> what
    > >> >> > exactly means "safe for multithreaded use" -- does it mean
safe
    > >> for
    > >> >> > publishing via data race, among others? -- I suppose, it
    > >> >> >
    > >> >> > should be. Am
    > >> >> >
    > >> >> > I wrong here?
    > >> >> >
    > >> >> > "safe for multi-threaded use" does not generally imply that it
    > >> >> >
    > >> >> > is safe to
    > >> >> >
    > >> >> > publish instances without synchronization of some form.
    > >> >> >
    > >> >> > David
    > >> >> > -----
    > >> >> >
    > >> >> > From other side, File.toPath javadoc explicitly says what
    > >> "returned
    > >> >> > instance must be the same for every invocation", so sync block
    > is
    > >> >> > required here for mutual exclusion on initialization phase.
    > >> Without
    > >> >> > this requirement it is also safe to live without sync block,
    > >> afaik.
    > >> >> >
    > >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
    > >> >> >
    > >> >> > Ruslan Cheremin writes:
    > >> >> >
    > >> >> > First of all, Path is immutable, so DCL is safe here even
    > without
    > >> >> > volatile. Volatile here is not required from my point of view.
    > >> >> >
    > >> >> > Without the volatile the Path implementation (Path is an
    > >> >> >
    > >> >> > interface) must be
    > >> >> >
    > >> >> > such that an instance of Path can be safely published without
    > >> >> >
    > >> >> > any additional
    > >> >> >
    > >> >> > forms of synchronization. Immutability does not in itself
    > >> >> >
    > >> >> > ensure that. You
    > >> >> >
    > >> >> > would have to examine the actual implementation class.
    > >> >> >
    > >> >> > David Holmes
    > >> >> > ------------
    > >> >> >
    > >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
    > >> >> >
    > >> >> > Hi Richard,
    > >> >> >
    > >> >> > The variable "filePath" is volatile, so the double-checked
    > >> >> >
    > >> >> > locking is correct in this case. It would have been a bug
    > >> >> >
    > >> >> > prior to Java 5.
    > >> >> >
    > >> >> > Best regards,
    > >> >> >
    > >> >> > Dmitry Vyazelenko
    > >> >> >
    > >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
    > >> >> >
    > >> >> > <richard.warburton at gmail.com> wrote:
    > >> >> >
    > >> >> > Hello,
    > >> >> >
    > >> >> > The current implementation of java.io.File::toPath [0]
    > >> >> >
    > >> >> > appears to be
    > >> >> >
    > >> >> > using the double checked locking pattern:
    > >> >> >
    > >> >> >     public Path toPath() {
    > >> >> >         Path result = filePath;
    > >> >> >         if (result == null) {
    > >> >> >             synchronized (this) {
    > >> >> >                 result = filePath;
    > >> >> >                 if (result == null) {
    > >> >> >                     result =
    > >> >> >
    > >> >> > FileSystems.getDefault().getPath(path);
    > >> >> >
    > >> >> >                     filePath = result;
    > >> >> >                 }
    > >> >> >             }
    > >> >> >         }
    > >> >> >         return result;
    > >> >> >     }
    > >> >> >
    > >> >> > I was going to report the bug, but I'm a little
    > >> >> >
    > >> >> > uncertain of the
    > >> >> >
    > >> >> > interaction between the local variable 'result' and DCL
    > >> >> >
    > >> >> > since I've
    > >> >> >
    > >> >> > previously only seen the checking condition on the
    > >> >> >
    > >> >> > shared field
    > >> >> >
    > >> >> > itself.  Can someone here either confirm that its a bug or
    > >> >> >
    > >> >> > explain how
    > >> >> >
    > >> >> > the 'result' variable is fixing things?
    > >> >> >
    > >> >> > regards,
    > >> >> >
    > >> >> >  Richard
    > >> >> >
    > >> >> > [0] See the end of
    > >> >> >
    > >> >> >
    > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
    > >> >> >
    > >> >> > ses/java/io/File.java
    > >> >> >
    > >> >> > _______________________________________________
    > >> >> > Concurrency-interest mailing list
    > >> >> > Concurrency-interest at cs.oswego.edu
    > >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >> >> >
    > >> >> > _______________________________________________
    > >> >> > Concurrency-interest mailing list
    > >> >> > Concurrency-interest at cs.oswego.edu
    > >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >> >> >
    > >> >> > _______________________________________________
    > >> >> > Concurrency-interest mailing list
    > >> >> > Concurrency-interest at cs.oswego.edu
    > >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >> >> >
    > >> >> > _______________________________________________
    > >> >> > Concurrency-interest mailing list
    > >> >> > Concurrency-interest at cs.oswego.edu
    > >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >> >> >
    > >> >> >
    > >> >> >
    > >> >> > _______________________________________________
    > >> >> > Concurrency-interest mailing list
    > >> >> > Concurrency-interest at cs.oswego.edu
    > >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >> >> >
    > >> >> _______________________________________________
    > >> >> Concurrency-interest mailing list
    > >> >> Concurrency-interest at cs.oswego.edu
    > >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >> >
    > >> >
    > >> >
    > >> > _______________________________________________
    > >> > Concurrency-interest mailing list
    > >> > Concurrency-interest at cs.oswego.edu
    > >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >> >
    > >> _______________________________________________
    > >> Concurrency-interest mailing list
    > >> Concurrency-interest at cs.oswego.edu
    > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >
    > > _______________________________________________
    > > Concurrency-interest mailing list
    > > Concurrency-interest at cs.oswego.edu
    > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120816/753bd3dc/attachment-0001.html>

From davidcholmes at aapt.net.au  Wed Aug 15 19:33:41 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 16 Aug 2012 09:33:41 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEECEJGAA.davidcholmes@aapt.net.au>
Message-ID: <NFBBKALFDCPFIDBNKAPCMECFJGAA.davidcholmes@aapt.net.au>

Typo:

I wrote:
>
> Ruslan Cheremin writes:
> >
> > > The reason to keep them distinct is because in general the
> > > mechanisms for safe publication are external to the class,
> > > while those for thread-safety are internal. It is only an
> > > edge case where use of synchronized in a constructor can
> > > achieve safe-publication.
> >
> > Well, actually I do not understand your point. If I use some kind of
> > synchronization to make methods of my object thread-safe -- can't I
> > also apply same thing to constructor? For me, it makes the thing only
> > clearer. Object can be thread-safe -- and it is totally thread safe.
> > Object can require external synchronization for correct multithreaded
> > use -- and it requires the sync for publishing and for usage also.
>
> You have to be able to establish the necessary happens-before
> relationships between the end of construction, publication and use.
>
> If thread-safe means you've created a "monitor" where only one method
> invocation can proceed at a time and all methods are synchronized, then
> synchronized in the constructor will construction happens-before use, and
> the publication mechanism is not relevant.

That should say "will _ensure_ construction happens-before use"

David


> If all your fields are final or volatile then you also have no issue with
> publication.
>
> Otherwise you have a bit more work to do. Relying on safe-publication to
> introduce the happens-before ordering allows you to use simpler, more
> natural, and likely more performant code in your thread-safe class.
>
> David
> -----
>
>
> > From my point of view, the distinction you talking about is more
> > historically reasoned. "Sync method if you want it to be thread-safe"
> > is commonly learned mantra, but "take care of initialization also" is
> > not so common. More information about it, more education, more
> > different code samples with outlined "here is the dragons" will change
> > the situation, I sure, it just have to be highlighted more often.
> >
> >
> > > People have to recognize that sharing an object requires
> shared mutable
> > > state, and the number one tenet of concurrent programming is
> > that access to
> > > shared mutable state has to be synchronized (in a general sense not
> > > specifically use of 'synchronized' keyword).
> > >
> > > Making every object safely publishable could be done, but for
> > 99% of objects
> > > it would be a waste of effort. Programs without data races
> > don't have issues
> > > with unsafe publication.
> > >
> > > David
> > >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan
> > > Reynolds
> > > Sent: Wednesday, 15 August 2012 4:59 AM
> > > To: concurrency-interest at cs.oswego.edu
> > > Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> > >
> > > We seem to be splitting two notions (i.e thread-safe and safe
> > publication)
> > > when they should be combined in a sense.  Typically, when we
> > say thread-safe
> > > we talk about the operations performed on the object after it was
> > > constructed (and its contents are globally visible).  However,
> > we need to
> > > consider that executing the constructor is modifying the state of the
> > > object.  It requires the same mechanisms that the rest of the
> > class uses to
> > > ensure thread-safety.  Even though, there is only 1 thread
> executing the
> > > constructor, a proper releasing of a lock or some other happens-before
> > > construct is required to ensure that the memory updates by the
> > thread are
> > > made globally visible before the object is accessed by another
> > thread.  This
> > > is what we are calling safe publication.  So, safe publication
> > is a subset
> > > of thread-safety except it is limited to what happens after the
> > constructor
> > > is called and before the object is used by multiple threads.
> > >
> > > A beautifully-written class can be thread-safe with respect to
> > calling its
> > > member methods but not thread-safe with respect to calling its
> > constructor.
> > > It is this latter case that many stumble upon because they think that
> > > constructors are inherently thread-safe because they are executed
> > > single-threadedly.  What they fail to realize is that the
> execution of a
> > > constructor can overlap with the execution of other code from
> > the view point
> > > of what is happening in memory.  This same problem applies to
> > more rare case
> > > of regular methods which can be proven to execute in a single
> thread but
> > > don't use synchronization before multiple threads start
> > accessing the shared
> > > data.
> > >
> > > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> > > Oracle PSR Engineering | Server Technology
> > > On 8/13/2012 4:08 PM, David Holmes wrote:
> > >
> > > Ruslan Cheremin writes:
> > >
> > > For me it is confusing: java has only one way to have really immutable
> > > object, and this way also gives you a total thread safety even for
> > > data race based publication. But then docs refer object as "immutable
> > > and thread-safe" -- we still can't assume it to be really thread-safe?
> > >
> > > It is better/simpler to isolate the notion of thread-safety and safe
> > > publication. Thread-safety comes into play after you have
> > safely shared an
> > > object. The means by which you safely share an object is
> > orthogonal to how
> > > the object itself is made thread-safe.
> > >
> > > The means by which an object is shared has to involve shared
> > mutable state,
> > > and use of shared mutable state always needs some form of
> > synchronization
> > > (either implicit eg due to static initialization; or explicit by using
> > > volatile or synchronized getter/setter methods).
> > >
> > > David
> > > -----
> > >
> > > It's a pity, especially because true immutability gives us some
> > > chances of performance optimization. As in this case -- we do not
> > > really need .path to be volatile here, if we would assume Path to be
> > > truly immutable. volatility here required only for ensuring safe
> > > publishing.
> > >
> > > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >
> > > Ruslan Cheremin writes:>
> > >
> > > But is there a way to define "safe for data race publishing"? I as
> > > far, as I remember, "immutable and thread-safe" is standard mantra in
> > > JDK javadocs for totally safe objects. j.l.String has same mantra --
> > > and it is safe for any way of publishing. Does you mean, I should
> > > explicitly add "safe even for publishing via data race" in docs? But I
> > > can't remember any such phrase in JDK docs.
> > >
> > > I don't recall anything in the JDK docs that mention being
> > >
> > > "totally safe"
> > >
> > > regardless of publication mechanism. Some classes, eg String,
> have been
> > > defined such that they do have that property (for security
> reasons). In
> > > general neither "thread-safe" nor "immutable" imply
> > > safe-for-unsynchronized-publication.
> > >
> > > Java Concurrency In Practice (jcip.net) does define
> additional potential
> > > annotations, where @Immutable would indeed capture the requirement of
> > > safe-for-unsynchronized-publication.
> > >
> > > David
> > > -----
> > >
> > > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >
> > > Ruslan Cheremin writes:
> > >
> > > Well, Path javadoc explicitly says "immutable and safe for
> > > multithreaded use". Although it is not strictly defined in java what
> > > exactly means "safe for multithreaded use" -- does it mean safe for
> > > publishing via data race, among others? -- I suppose, it
> > >
> > > should be. Am
> > >
> > > I wrong here?
> > >
> > > "safe for multi-threaded use" does not generally imply that it
> > >
> > > is safe to
> > >
> > > publish instances without synchronization of some form.
> > >
> > > David
> > > -----
> > >
> > > From other side, File.toPath javadoc explicitly says what "returned
> > > instance must be the same for every invocation", so sync block is
> > > required here for mutual exclusion on initialization phase. Without
> > > this requirement it is also safe to live without sync block, afaik.
> > >
> > > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >
> > > Ruslan Cheremin writes:
> > >
> > > First of all, Path is immutable, so DCL is safe here even without
> > > volatile. Volatile here is not required from my point of view.
> > >
> > > Without the volatile the Path implementation (Path is an
> > >
> > > interface) must be
> > >
> > > such that an instance of Path can be safely published without
> > >
> > > any additional
> > >
> > > forms of synchronization. Immutability does not in itself
> > >
> > > ensure that. You
> > >
> > > would have to examine the actual implementation class.
> > >
> > > David Holmes
> > > ------------
> > >
> > > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> > >
> > > Hi Richard,
> > >
> > > The variable "filePath" is volatile, so the double-checked
> > >
> > > locking is correct in this case. It would have been a bug
> > >
> > > prior to Java 5.
> > >
> > > Best regards,
> > >
> > > Dmitry Vyazelenko
> > >
> > > On Aug 12, 2012, at 21:35 , Richard Warburton
> > >
> > > <richard.warburton at gmail.com> wrote:
> > >
> > > Hello,
> > >
> > > The current implementation of java.io.File::toPath [0]
> > >
> > > appears to be
> > >
> > > using the double checked locking pattern:
> > >
> > >     public Path toPath() {
> > >         Path result = filePath;
> > >         if (result == null) {
> > >             synchronized (this) {
> > >                 result = filePath;
> > >                 if (result == null) {
> > >                     result =
> > >
> > > FileSystems.getDefault().getPath(path);
> > >
> > >                     filePath = result;
> > >                 }
> > >             }
> > >         }
> > >         return result;
> > >     }
> > >
> > > I was going to report the bug, but I'm a little
> > >
> > > uncertain of the
> > >
> > > interaction between the local variable 'result' and DCL
> > >
> > > since I've
> > >
> > > previously only seen the checking condition on the
> > >
> > > shared field
> > >
> > > itself.  Can someone here either confirm that its a bug or
> > >
> > > explain how
> > >
> > > the 'result' variable is fixing things?
> > >
> > > regards,
> > >
> > >  Richard
> > >
> > > [0] See the end of
> > >
> > > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> > >
> > > ses/java/io/File.java
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From zhong.j.yu at gmail.com  Wed Aug 15 19:35:29 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Wed, 15 Aug 2012 18:35:29 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENi+stm6i-GGz+TqNo=EpUWhskV7WUisWFO4f4_fmZm2jQQ@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<CAOwENi+stm6i-GGz+TqNo=EpUWhskV7WUisWFO4f4_fmZm2jQQ@mail.gmail.com>
Message-ID: <CACuKZqEVRssbk-MudNPmJjvuuFA_mszxs6HGGU-8ketQPjX7fQ@mail.gmail.com>

Any use case for unsafe publication of a mutable thread-safe object?

If a use case does exist, there is a way to do it without
synchronizing constructor:

    local_var = new Vector();  // not synchronized
    local_var.size();  // call a synchronized method
    shared_var = local_var;  // unsafe publication

therefore synchronized constructor still isn't necessary.

Though, aesthetically, one might prefer to do synchronization in
constructors the same way it's done in instance methods, if the
overhead isn't a concern.

Zhong Yu

On Wed, Aug 15, 2012 at 2:56 PM, Ruslan Cheremin <cheremin at gmail.com> wrote:
> Yes, it was an interesting discussion, and as result object with
> synchronized methods and constructor can be published unsafe (i.e.
> other thread can obtain reference to partially initialized object),
> but this patrially initialized state can't be observed, since all
> access going via sync-ed methods, which will block until
> initialization finish.
>
> So, staying away from the unsual and so strange and even ugly notation
> of locking in constructor, making object self-safe-publishing is not
> anything more complex, then making thread-safe method. Am I missed
> something?
>
> 2012/8/15 Zhong Yu <zhong.j.yu at gmail.com>:
>> I thought the conclusion of that thread is that synchronizing
>> constructor has the desired merit - if all constructors and methods
>> are synchronized, a non-creating thread won't observe the zero/partial
>> state of the object, even if the object reference is published
>> unsafely.
>>
>> (One guy, who shall remain nameless, muddied the water with some
>> mistaken statements of weaker memory guarantee. He has been corrected)
>>
>> Zhong Yu
>>
>> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit <yshavit at akiban.com> wrote:
>>> There was a discussion here a few months ago about synchronizing
>>> constructors -- I had asked why it's not allowed, and the discussion hit on
>>> some of the similar points brought up in this thread.
>>>
>>> But to your point specifically, synchronizing a constructor (via
>>> "synchronized(this) {...}" surrounding its body) still doesn't give you full
>>> thread safety (even assuming immutability after the constructor -- but
>>> without final fields). It ensures that a thread can observe the object
>>> either fully constructed *or* with all its fields having their default
>>> values. In other words, even if your constructor is synchronized on the same
>>> object your getter is, a thread could observe a field as it was before the
>>> constructor was invoked.
>>>
>>> http://markmail.org/message/mav53xzo4bqu7udw
>>>
>>>
>>> On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin <cheremin at gmail.com>
>>> wrote:
>>>>
>>>> > The reason to keep them distinct is because in general the mechanisms
>>>> > for
>>>> > safe publication are external to the class, while those for
>>>> > thread-safety
>>>> > are internal. It is only an edge case where use of synchronized in a
>>>> > constructor can achieve safe-publication.
>>>>
>>>> Well, actually I do not understand your point. If I use some kind of
>>>> synchronization to make methods of my object thread-safe -- can't I
>>>> also apply same thing to constructor? For me, it makes the thing only
>>>> clearer. Object can be thread-safe -- and it is totally thread safe.
>>>> Object can require external synchronization for correct multithreaded
>>>> use -- and it requires the sync for publishing and for usage also.
>>>>
>>>> From my point of view, the distinction you talking about is more
>>>> historically reasoned. "Sync method if you want it to be thread-safe"
>>>> is commonly learned mantra, but "take care of initialization also" is
>>>> not so common. More information about it, more education, more
>>>> different code samples with outlined "here is the dragons" will change
>>>> the situation, I sure, it just have to be highlighted more often.
>>>>
>>>>
>>>> > People have to recognize that sharing an object requires shared mutable
>>>> > state, and the number one tenet of concurrent programming is that access
>>>> > to
>>>> > shared mutable state has to be synchronized (in a general sense not
>>>> > specifically use of 'synchronized' keyword).
>>>> >
>>>> > Making every object safely publishable could be done, but for 99% of
>>>> > objects
>>>> > it would be a waste of effort. Programs without data races don't have
>>>> > issues
>>>> > with unsafe publication.
>>>> >
>>>> > David
>>>> >
>>>> > -----Original Message-----
>>>> > From: concurrency-interest-bounces at cs.oswego.edu
>>>> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan
>>>> > Reynolds
>>>> > Sent: Wednesday, 15 August 2012 4:59 AM
>>>> > To: concurrency-interest at cs.oswego.edu
>>>> > Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>>>> >
>>>> > We seem to be splitting two notions (i.e thread-safe and safe
>>>> > publication)
>>>> > when they should be combined in a sense.  Typically, when we say
>>>> > thread-safe
>>>> > we talk about the operations performed on the object after it was
>>>> > constructed (and its contents are globally visible).  However, we need
>>>> > to
>>>> > consider that executing the constructor is modifying the state of the
>>>> > object.  It requires the same mechanisms that the rest of the class uses
>>>> > to
>>>> > ensure thread-safety.  Even though, there is only 1 thread executing the
>>>> > constructor, a proper releasing of a lock or some other happens-before
>>>> > construct is required to ensure that the memory updates by the thread
>>>> > are
>>>> > made globally visible before the object is accessed by another thread.
>>>> > This
>>>> > is what we are calling safe publication.  So, safe publication is a
>>>> > subset
>>>> > of thread-safety except it is limited to what happens after the
>>>> > constructor
>>>> > is called and before the object is used by multiple threads.
>>>> >
>>>> > A beautifully-written class can be thread-safe with respect to calling
>>>> > its
>>>> > member methods but not thread-safe with respect to calling its
>>>> > constructor.
>>>> > It is this latter case that many stumble upon because they think that
>>>> > constructors are inherently thread-safe because they are executed
>>>> > single-threadedly.  What they fail to realize is that the execution of a
>>>> > constructor can overlap with the execution of other code from the view
>>>> > point
>>>> > of what is happening in memory.  This same problem applies to more rare
>>>> > case
>>>> > of regular methods which can be proven to execute in a single thread but
>>>> > don't use synchronization before multiple threads start accessing the
>>>> > shared
>>>> > data.
>>>> >
>>>> > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
>>>> > Oracle PSR Engineering | Server Technology
>>>> > On 8/13/2012 4:08 PM, David Holmes wrote:
>>>> >
>>>> > Ruslan Cheremin writes:
>>>> >
>>>> > For me it is confusing: java has only one way to have really immutable
>>>> > object, and this way also gives you a total thread safety even for
>>>> > data race based publication. But then docs refer object as "immutable
>>>> > and thread-safe" -- we still can't assume it to be really thread-safe?
>>>> >
>>>> > It is better/simpler to isolate the notion of thread-safety and safe
>>>> > publication. Thread-safety comes into play after you have safely shared
>>>> > an
>>>> > object. The means by which you safely share an object is orthogonal to
>>>> > how
>>>> > the object itself is made thread-safe.
>>>> >
>>>> > The means by which an object is shared has to involve shared mutable
>>>> > state,
>>>> > and use of shared mutable state always needs some form of
>>>> > synchronization
>>>> > (either implicit eg due to static initialization; or explicit by using
>>>> > volatile or synchronized getter/setter methods).
>>>> >
>>>> > David
>>>> > -----
>>>> >
>>>> > It's a pity, especially because true immutability gives us some
>>>> > chances of performance optimization. As in this case -- we do not
>>>> > really need .path to be volatile here, if we would assume Path to be
>>>> > truly immutable. volatility here required only for ensuring safe
>>>> > publishing.
>>>> >
>>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>> >
>>>> > Ruslan Cheremin writes:>
>>>> >
>>>> > But is there a way to define "safe for data race publishing"? I as
>>>> > far, as I remember, "immutable and thread-safe" is standard mantra in
>>>> > JDK javadocs for totally safe objects. j.l.String has same mantra --
>>>> > and it is safe for any way of publishing. Does you mean, I should
>>>> > explicitly add "safe even for publishing via data race" in docs? But I
>>>> > can't remember any such phrase in JDK docs.
>>>> >
>>>> > I don't recall anything in the JDK docs that mention being
>>>> >
>>>> > "totally safe"
>>>> >
>>>> > regardless of publication mechanism. Some classes, eg String, have been
>>>> > defined such that they do have that property (for security reasons). In
>>>> > general neither "thread-safe" nor "immutable" imply
>>>> > safe-for-unsynchronized-publication.
>>>> >
>>>> > Java Concurrency In Practice (jcip.net) does define additional potential
>>>> > annotations, where @Immutable would indeed capture the requirement of
>>>> > safe-for-unsynchronized-publication.
>>>> >
>>>> > David
>>>> > -----
>>>> >
>>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>> >
>>>> > Ruslan Cheremin writes:
>>>> >
>>>> > Well, Path javadoc explicitly says "immutable and safe for
>>>> > multithreaded use". Although it is not strictly defined in java what
>>>> > exactly means "safe for multithreaded use" -- does it mean safe for
>>>> > publishing via data race, among others? -- I suppose, it
>>>> >
>>>> > should be. Am
>>>> >
>>>> > I wrong here?
>>>> >
>>>> > "safe for multi-threaded use" does not generally imply that it
>>>> >
>>>> > is safe to
>>>> >
>>>> > publish instances without synchronization of some form.
>>>> >
>>>> > David
>>>> > -----
>>>> >
>>>> > From other side, File.toPath javadoc explicitly says what "returned
>>>> > instance must be the same for every invocation", so sync block is
>>>> > required here for mutual exclusion on initialization phase. Without
>>>> > this requirement it is also safe to live without sync block, afaik.
>>>> >
>>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>>>> >
>>>> > Ruslan Cheremin writes:
>>>> >
>>>> > First of all, Path is immutable, so DCL is safe here even without
>>>> > volatile. Volatile here is not required from my point of view.
>>>> >
>>>> > Without the volatile the Path implementation (Path is an
>>>> >
>>>> > interface) must be
>>>> >
>>>> > such that an instance of Path can be safely published without
>>>> >
>>>> > any additional
>>>> >
>>>> > forms of synchronization. Immutability does not in itself
>>>> >
>>>> > ensure that. You
>>>> >
>>>> > would have to examine the actual implementation class.
>>>> >
>>>> > David Holmes
>>>> > ------------
>>>> >
>>>> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>>>> >
>>>> > Hi Richard,
>>>> >
>>>> > The variable "filePath" is volatile, so the double-checked
>>>> >
>>>> > locking is correct in this case. It would have been a bug
>>>> >
>>>> > prior to Java 5.
>>>> >
>>>> > Best regards,
>>>> >
>>>> > Dmitry Vyazelenko
>>>> >
>>>> > On Aug 12, 2012, at 21:35 , Richard Warburton
>>>> >
>>>> > <richard.warburton at gmail.com> wrote:
>>>> >
>>>> > Hello,
>>>> >
>>>> > The current implementation of java.io.File::toPath [0]
>>>> >
>>>> > appears to be
>>>> >
>>>> > using the double checked locking pattern:
>>>> >
>>>> >     public Path toPath() {
>>>> >         Path result = filePath;
>>>> >         if (result == null) {
>>>> >             synchronized (this) {
>>>> >                 result = filePath;
>>>> >                 if (result == null) {
>>>> >                     result =
>>>> >
>>>> > FileSystems.getDefault().getPath(path);
>>>> >
>>>> >                     filePath = result;
>>>> >                 }
>>>> >             }
>>>> >         }
>>>> >         return result;
>>>> >     }
>>>> >
>>>> > I was going to report the bug, but I'm a little
>>>> >
>>>> > uncertain of the
>>>> >
>>>> > interaction between the local variable 'result' and DCL
>>>> >
>>>> > since I've
>>>> >
>>>> > previously only seen the checking condition on the
>>>> >
>>>> > shared field
>>>> >
>>>> > itself.  Can someone here either confirm that its a bug or
>>>> >
>>>> > explain how
>>>> >
>>>> > the 'result' variable is fixing things?
>>>> >
>>>> > regards,
>>>> >
>>>> >  Richard
>>>> >
>>>> > [0] See the end of
>>>> >
>>>> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>>>> >
>>>> > ses/java/io/File.java
>>>> >
>>>> > _______________________________________________
>>>> > Concurrency-interest mailing list
>>>> > Concurrency-interest at cs.oswego.edu
>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >
>>>> > _______________________________________________
>>>> > Concurrency-interest mailing list
>>>> > Concurrency-interest at cs.oswego.edu
>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >
>>>> > _______________________________________________
>>>> > Concurrency-interest mailing list
>>>> > Concurrency-interest at cs.oswego.edu
>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >
>>>> > _______________________________________________
>>>> > Concurrency-interest mailing list
>>>> > Concurrency-interest at cs.oswego.edu
>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >
>>>> >
>>>> >
>>>> > _______________________________________________
>>>> > Concurrency-interest mailing list
>>>> > Concurrency-interest at cs.oswego.edu
>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>

From vitalyd at gmail.com  Wed Aug 15 19:42:26 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 15 Aug 2012 19:42:26 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEECEJGAA.davidcholmes@aapt.net.au>
References: <CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCEECEJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAHjP37HGobSufGXWhQwc8ETyTytb3pwWtsqP2HT5Bgqt7ee_uw@mail.gmail.com>

If all your fields are final or volatile then you also have no issue with
> publication.


Volatile wouldn't help either as it won't prevent the possible reordering
of the assignment to the reference.  Final (or Unsafe.putXXXOrdered) is the
only solution (outside of synchronizing the constructor and the whole class
:)).

On Aug 15, 2012 7:28 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:

> Ruslan Cheremin writes:
> >
> > > The reason to keep them distinct is because in general the
> > > mechanisms for safe publication are external to the class,
> > > while those for thread-safety are internal. It is only an
> > > edge case where use of synchronized in a constructor can
> > > achieve safe-publication.
> >
> > Well, actually I do not understand your point. If I use some kind of
> > synchronization to make methods of my object thread-safe -- can't I
> > also apply same thing to constructor? For me, it makes the thing only
> > clearer. Object can be thread-safe -- and it is totally thread safe.
> > Object can require external synchronization for correct multithreaded
> > use -- and it requires the sync for publishing and for usage also.
>
> You have to be able to establish the necessary happens-before relationships
> between the end of construction, publication and use.
>
> If thread-safe means you've created a "monitor" where only one method
> invocation can proceed at a time and all methods are synchronized, then
> synchronized in the constructor will construction happens-before use, and
> the publication mechanism is not relevant.
>
> If all your fields are final or volatile then you also have no issue with
> publication.
>
> Otherwise you have a bit more work to do. Relying on safe-publication to
> introduce the happens-before ordering allows you to use simpler, more
> natural, and likely more performant code in your thread-safe class.
>
> David
> -----
>
>
> > From my point of view, the distinction you talking about is more
> > historically reasoned. "Sync method if you want it to be thread-safe"
> > is commonly learned mantra, but "take care of initialization also" is
> > not so common. More information about it, more education, more
> > different code samples with outlined "here is the dragons" will change
> > the situation, I sure, it just have to be highlighted more often.
> >
> >
> > > People have to recognize that sharing an object requires shared mutable
> > > state, and the number one tenet of concurrent programming is
> > that access to
> > > shared mutable state has to be synchronized (in a general sense not
> > > specifically use of 'synchronized' keyword).
> > >
> > > Making every object safely publishable could be done, but for
> > 99% of objects
> > > it would be a waste of effort. Programs without data races
> > don't have issues
> > > with unsafe publication.
> > >
> > > David
> > >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan
> > > Reynolds
> > > Sent: Wednesday, 15 August 2012 4:59 AM
> > > To: concurrency-interest at cs.oswego.edu
> > > Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> > >
> > > We seem to be splitting two notions (i.e thread-safe and safe
> > publication)
> > > when they should be combined in a sense.  Typically, when we
> > say thread-safe
> > > we talk about the operations performed on the object after it was
> > > constructed (and its contents are globally visible).  However,
> > we need to
> > > consider that executing the constructor is modifying the state of the
> > > object.  It requires the same mechanisms that the rest of the
> > class uses to
> > > ensure thread-safety.  Even though, there is only 1 thread executing
> the
> > > constructor, a proper releasing of a lock or some other happens-before
> > > construct is required to ensure that the memory updates by the
> > thread are
> > > made globally visible before the object is accessed by another
> > thread.  This
> > > is what we are calling safe publication.  So, safe publication
> > is a subset
> > > of thread-safety except it is limited to what happens after the
> > constructor
> > > is called and before the object is used by multiple threads.
> > >
> > > A beautifully-written class can be thread-safe with respect to
> > calling its
> > > member methods but not thread-safe with respect to calling its
> > constructor.
> > > It is this latter case that many stumble upon because they think that
> > > constructors are inherently thread-safe because they are executed
> > > single-threadedly.  What they fail to realize is that the execution of
> a
> > > constructor can overlap with the execution of other code from
> > the view point
> > > of what is happening in memory.  This same problem applies to
> > more rare case
> > > of regular methods which can be proven to execute in a single thread
> but
> > > don't use synchronization before multiple threads start
> > accessing the shared
> > > data.
> > >
> > > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> > > Oracle PSR Engineering | Server Technology
> > > On 8/13/2012 4:08 PM, David Holmes wrote:
> > >
> > > Ruslan Cheremin writes:
> > >
> > > For me it is confusing: java has only one way to have really immutable
> > > object, and this way also gives you a total thread safety even for
> > > data race based publication. But then docs refer object as "immutable
> > > and thread-safe" -- we still can't assume it to be really thread-safe?
> > >
> > > It is better/simpler to isolate the notion of thread-safety and safe
> > > publication. Thread-safety comes into play after you have
> > safely shared an
> > > object. The means by which you safely share an object is
> > orthogonal to how
> > > the object itself is made thread-safe.
> > >
> > > The means by which an object is shared has to involve shared
> > mutable state,
> > > and use of shared mutable state always needs some form of
> > synchronization
> > > (either implicit eg due to static initialization; or explicit by using
> > > volatile or synchronized getter/setter methods).
> > >
> > > David
> > > -----
> > >
> > > It's a pity, especially because true immutability gives us some
> > > chances of performance optimization. As in this case -- we do not
> > > really need .path to be volatile here, if we would assume Path to be
> > > truly immutable. volatility here required only for ensuring safe
> > > publishing.
> > >
> > > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >
> > > Ruslan Cheremin writes:>
> > >
> > > But is there a way to define "safe for data race publishing"? I as
> > > far, as I remember, "immutable and thread-safe" is standard mantra in
> > > JDK javadocs for totally safe objects. j.l.String has same mantra --
> > > and it is safe for any way of publishing. Does you mean, I should
> > > explicitly add "safe even for publishing via data race" in docs? But I
> > > can't remember any such phrase in JDK docs.
> > >
> > > I don't recall anything in the JDK docs that mention being
> > >
> > > "totally safe"
> > >
> > > regardless of publication mechanism. Some classes, eg String, have been
> > > defined such that they do have that property (for security reasons). In
> > > general neither "thread-safe" nor "immutable" imply
> > > safe-for-unsynchronized-publication.
> > >
> > > Java Concurrency In Practice (jcip.net) does define additional
> potential
> > > annotations, where @Immutable would indeed capture the requirement of
> > > safe-for-unsynchronized-publication.
> > >
> > > David
> > > -----
> > >
> > > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >
> > > Ruslan Cheremin writes:
> > >
> > > Well, Path javadoc explicitly says "immutable and safe for
> > > multithreaded use". Although it is not strictly defined in java what
> > > exactly means "safe for multithreaded use" -- does it mean safe for
> > > publishing via data race, among others? -- I suppose, it
> > >
> > > should be. Am
> > >
> > > I wrong here?
> > >
> > > "safe for multi-threaded use" does not generally imply that it
> > >
> > > is safe to
> > >
> > > publish instances without synchronization of some form.
> > >
> > > David
> > > -----
> > >
> > > From other side, File.toPath javadoc explicitly says what "returned
> > > instance must be the same for every invocation", so sync block is
> > > required here for mutual exclusion on initialization phase. Without
> > > this requirement it is also safe to live without sync block, afaik.
> > >
> > > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >
> > > Ruslan Cheremin writes:
> > >
> > > First of all, Path is immutable, so DCL is safe here even without
> > > volatile. Volatile here is not required from my point of view.
> > >
> > > Without the volatile the Path implementation (Path is an
> > >
> > > interface) must be
> > >
> > > such that an instance of Path can be safely published without
> > >
> > > any additional
> > >
> > > forms of synchronization. Immutability does not in itself
> > >
> > > ensure that. You
> > >
> > > would have to examine the actual implementation class.
> > >
> > > David Holmes
> > > ------------
> > >
> > > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> > >
> > > Hi Richard,
> > >
> > > The variable "filePath" is volatile, so the double-checked
> > >
> > > locking is correct in this case. It would have been a bug
> > >
> > > prior to Java 5.
> > >
> > > Best regards,
> > >
> > > Dmitry Vyazelenko
> > >
> > > On Aug 12, 2012, at 21:35 , Richard Warburton
> > >
> > > <richard.warburton at gmail.com> wrote:
> > >
> > > Hello,
> > >
> > > The current implementation of java.io.File::toPath [0]
> > >
> > > appears to be
> > >
> > > using the double checked locking pattern:
> > >
> > >     public Path toPath() {
> > >         Path result = filePath;
> > >         if (result == null) {
> > >             synchronized (this) {
> > >                 result = filePath;
> > >                 if (result == null) {
> > >                     result =
> > >
> > > FileSystems.getDefault().getPath(path);
> > >
> > >                     filePath = result;
> > >                 }
> > >             }
> > >         }
> > >         return result;
> > >     }
> > >
> > > I was going to report the bug, but I'm a little
> > >
> > > uncertain of the
> > >
> > > interaction between the local variable 'result' and DCL
> > >
> > > since I've
> > >
> > > previously only seen the checking condition on the
> > >
> > > shared field
> > >
> > > itself.  Can someone here either confirm that its a bug or
> > >
> > > explain how
> > >
> > > the 'result' variable is fixing things?
> > >
> > > regards,
> > >
> > >  Richard
> > >
> > > [0] See the end of
> > >
> > > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> > >
> > > ses/java/io/File.java
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/ae964b0f/attachment-0001.html>

From davidcholmes at aapt.net.au  Wed Aug 15 19:44:08 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 16 Aug 2012 09:44:08 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqEVRssbk-MudNPmJjvuuFA_mszxs6HGGU-8ketQPjX7fQ@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIECGJGAA.davidcholmes@aapt.net.au>

Zhong Yu writes:
>
> Any use case for unsafe publication of a mutable thread-safe object?
>
> If a use case does exist, there is a way to do it without
> synchronizing constructor:
>
>     local_var = new Vector();  // not synchronized
>     local_var.size();  // call a synchronized method
>     shared_var = local_var;  // unsafe publication
>
> therefore synchronized constructor still isn't necessary.

The above is turning unsafe publication into safe-publication.

As I said in other email the whole issue here is to ensure that construction
happens-before use. In the sharing case publication has to occur prior to
use. That means you either tackle the problem directly, by ensuring
construction happens-before use (ie with synchronized constructor on fully
synchronized object). Or you establish that construction happens-before
publication and publication happens-before use aka you use safe-publication
mechanisms.

David
------


> Though, aesthetically, one might prefer to do synchronization in
> constructors the same way it's done in instance methods, if the
> overhead isn't a concern.
>
> Zhong Yu
>
> On Wed, Aug 15, 2012 at 2:56 PM, Ruslan Cheremin
> <cheremin at gmail.com> wrote:
> > Yes, it was an interesting discussion, and as result object with
> > synchronized methods and constructor can be published unsafe (i.e.
> > other thread can obtain reference to partially initialized object),
> > but this patrially initialized state can't be observed, since all
> > access going via sync-ed methods, which will block until
> > initialization finish.
> >
> > So, staying away from the unsual and so strange and even ugly notation
> > of locking in constructor, making object self-safe-publishing is not
> > anything more complex, then making thread-safe method. Am I missed
> > something?
> >
> > 2012/8/15 Zhong Yu <zhong.j.yu at gmail.com>:
> >> I thought the conclusion of that thread is that synchronizing
> >> constructor has the desired merit - if all constructors and methods
> >> are synchronized, a non-creating thread won't observe the zero/partial
> >> state of the object, even if the object reference is published
> >> unsafely.
> >>
> >> (One guy, who shall remain nameless, muddied the water with some
> >> mistaken statements of weaker memory guarantee. He has been corrected)
> >>
> >> Zhong Yu
> >>
> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
> <yshavit at akiban.com> wrote:
> >>> There was a discussion here a few months ago about synchronizing
> >>> constructors -- I had asked why it's not allowed, and the
> discussion hit on
> >>> some of the similar points brought up in this thread.
> >>>
> >>> But to your point specifically, synchronizing a constructor (via
> >>> "synchronized(this) {...}" surrounding its body) still
> doesn't give you full
> >>> thread safety (even assuming immutability after the constructor -- but
> >>> without final fields). It ensures that a thread can observe the object
> >>> either fully constructed *or* with all its fields having their default
> >>> values. In other words, even if your constructor is
> synchronized on the same
> >>> object your getter is, a thread could observe a field as it
> was before the
> >>> constructor was invoked.
> >>>
> >>> http://markmail.org/message/mav53xzo4bqu7udw
> >>>
> >>>
> >>> On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin <cheremin at gmail.com>
> >>> wrote:
> >>>>
> >>>> > The reason to keep them distinct is because in general the
> mechanisms
> >>>> > for
> >>>> > safe publication are external to the class, while those for
> >>>> > thread-safety
> >>>> > are internal. It is only an edge case where use of
> synchronized in a
> >>>> > constructor can achieve safe-publication.
> >>>>
> >>>> Well, actually I do not understand your point. If I use some kind of
> >>>> synchronization to make methods of my object thread-safe -- can't I
> >>>> also apply same thing to constructor? For me, it makes the thing only
> >>>> clearer. Object can be thread-safe -- and it is totally thread safe.
> >>>> Object can require external synchronization for correct multithreaded
> >>>> use -- and it requires the sync for publishing and for usage also.
> >>>>
> >>>> From my point of view, the distinction you talking about is more
> >>>> historically reasoned. "Sync method if you want it to be thread-safe"
> >>>> is commonly learned mantra, but "take care of initialization also" is
> >>>> not so common. More information about it, more education, more
> >>>> different code samples with outlined "here is the dragons"
> will change
> >>>> the situation, I sure, it just have to be highlighted more often.
> >>>>
> >>>>
> >>>> > People have to recognize that sharing an object requires
> shared mutable
> >>>> > state, and the number one tenet of concurrent programming
> is that access
> >>>> > to
> >>>> > shared mutable state has to be synchronized (in a general sense not
> >>>> > specifically use of 'synchronized' keyword).
> >>>> >
> >>>> > Making every object safely publishable could be done, but
> for 99% of
> >>>> > objects
> >>>> > it would be a waste of effort. Programs without data races
> don't have
> >>>> > issues
> >>>> > with unsafe publication.
> >>>> >
> >>>> > David
> >>>> >
> >>>> > -----Original Message-----
> >>>> > From: concurrency-interest-bounces at cs.oswego.edu
> >>>> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On
> Behalf Of Nathan
> >>>> > Reynolds
> >>>> > Sent: Wednesday, 15 August 2012 4:59 AM
> >>>> > To: concurrency-interest at cs.oswego.edu
> >>>> > Subject: Re: [concurrency-interest] Double Checked Locking
> in OpenJDK
> >>>> >
> >>>> > We seem to be splitting two notions (i.e thread-safe and safe
> >>>> > publication)
> >>>> > when they should be combined in a sense.  Typically, when we say
> >>>> > thread-safe
> >>>> > we talk about the operations performed on the object after it was
> >>>> > constructed (and its contents are globally visible).
> However, we need
> >>>> > to
> >>>> > consider that executing the constructor is modifying the
> state of the
> >>>> > object.  It requires the same mechanisms that the rest of
> the class uses
> >>>> > to
> >>>> > ensure thread-safety.  Even though, there is only 1 thread
> executing the
> >>>> > constructor, a proper releasing of a lock or some other
> happens-before
> >>>> > construct is required to ensure that the memory updates by
> the thread
> >>>> > are
> >>>> > made globally visible before the object is accessed by
> another thread.
> >>>> > This
> >>>> > is what we are calling safe publication.  So, safe publication is a
> >>>> > subset
> >>>> > of thread-safety except it is limited to what happens after the
> >>>> > constructor
> >>>> > is called and before the object is used by multiple threads.
> >>>> >
> >>>> > A beautifully-written class can be thread-safe with
> respect to calling
> >>>> > its
> >>>> > member methods but not thread-safe with respect to calling its
> >>>> > constructor.
> >>>> > It is this latter case that many stumble upon because they
> think that
> >>>> > constructors are inherently thread-safe because they are executed
> >>>> > single-threadedly.  What they fail to realize is that the
> execution of a
> >>>> > constructor can overlap with the execution of other code
> from the view
> >>>> > point
> >>>> > of what is happening in memory.  This same problem applies
> to more rare
> >>>> > case
> >>>> > of regular methods which can be proven to execute in a
> single thread but
> >>>> > don't use synchronization before multiple threads start
> accessing the
> >>>> > shared
> >>>> > data.
> >>>> >
> >>>> > Nathan Reynolds | Consulting Member of Technical Staff |
> 602.333.9091
> >>>> > Oracle PSR Engineering | Server Technology
> >>>> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >>>> >
> >>>> > Ruslan Cheremin writes:
> >>>> >
> >>>> > For me it is confusing: java has only one way to have
> really immutable
> >>>> > object, and this way also gives you a total thread safety even for
> >>>> > data race based publication. But then docs refer object as
> "immutable
> >>>> > and thread-safe" -- we still can't assume it to be really
> thread-safe?
> >>>> >
> >>>> > It is better/simpler to isolate the notion of
> thread-safety and safe
> >>>> > publication. Thread-safety comes into play after you have
> safely shared
> >>>> > an
> >>>> > object. The means by which you safely share an object is
> orthogonal to
> >>>> > how
> >>>> > the object itself is made thread-safe.
> >>>> >
> >>>> > The means by which an object is shared has to involve
> shared mutable
> >>>> > state,
> >>>> > and use of shared mutable state always needs some form of
> >>>> > synchronization
> >>>> > (either implicit eg due to static initialization; or
> explicit by using
> >>>> > volatile or synchronized getter/setter methods).
> >>>> >
> >>>> > David
> >>>> > -----
> >>>> >
> >>>> > It's a pity, especially because true immutability gives us some
> >>>> > chances of performance optimization. As in this case -- we do not
> >>>> > really need .path to be volatile here, if we would assume
> Path to be
> >>>> > truly immutable. volatility here required only for ensuring safe
> >>>> > publishing.
> >>>> >
> >>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >>>> >
> >>>> > Ruslan Cheremin writes:>
> >>>> >
> >>>> > But is there a way to define "safe for data race publishing"? I as
> >>>> > far, as I remember, "immutable and thread-safe" is
> standard mantra in
> >>>> > JDK javadocs for totally safe objects. j.l.String has same
> mantra --
> >>>> > and it is safe for any way of publishing. Does you mean, I should
> >>>> > explicitly add "safe even for publishing via data race" in
> docs? But I
> >>>> > can't remember any such phrase in JDK docs.
> >>>> >
> >>>> > I don't recall anything in the JDK docs that mention being
> >>>> >
> >>>> > "totally safe"
> >>>> >
> >>>> > regardless of publication mechanism. Some classes, eg
> String, have been
> >>>> > defined such that they do have that property (for security
> reasons). In
> >>>> > general neither "thread-safe" nor "immutable" imply
> >>>> > safe-for-unsynchronized-publication.
> >>>> >
> >>>> > Java Concurrency In Practice (jcip.net) does define
> additional potential
> >>>> > annotations, where @Immutable would indeed capture the
> requirement of
> >>>> > safe-for-unsynchronized-publication.
> >>>> >
> >>>> > David
> >>>> > -----
> >>>> >
> >>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >>>> >
> >>>> > Ruslan Cheremin writes:
> >>>> >
> >>>> > Well, Path javadoc explicitly says "immutable and safe for
> >>>> > multithreaded use". Although it is not strictly defined in
> java what
> >>>> > exactly means "safe for multithreaded use" -- does it mean safe for
> >>>> > publishing via data race, among others? -- I suppose, it
> >>>> >
> >>>> > should be. Am
> >>>> >
> >>>> > I wrong here?
> >>>> >
> >>>> > "safe for multi-threaded use" does not generally imply that it
> >>>> >
> >>>> > is safe to
> >>>> >
> >>>> > publish instances without synchronization of some form.
> >>>> >
> >>>> > David
> >>>> > -----
> >>>> >
> >>>> > From other side, File.toPath javadoc explicitly says what "returned
> >>>> > instance must be the same for every invocation", so sync block is
> >>>> > required here for mutual exclusion on initialization phase. Without
> >>>> > this requirement it is also safe to live without sync block, afaik.
> >>>> >
> >>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >>>> >
> >>>> > Ruslan Cheremin writes:
> >>>> >
> >>>> > First of all, Path is immutable, so DCL is safe here even without
> >>>> > volatile. Volatile here is not required from my point of view.
> >>>> >
> >>>> > Without the volatile the Path implementation (Path is an
> >>>> >
> >>>> > interface) must be
> >>>> >
> >>>> > such that an instance of Path can be safely published without
> >>>> >
> >>>> > any additional
> >>>> >
> >>>> > forms of synchronization. Immutability does not in itself
> >>>> >
> >>>> > ensure that. You
> >>>> >
> >>>> > would have to examine the actual implementation class.
> >>>> >
> >>>> > David Holmes
> >>>> > ------------
> >>>> >
> >>>> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >>>> >
> >>>> > Hi Richard,
> >>>> >
> >>>> > The variable "filePath" is volatile, so the double-checked
> >>>> >
> >>>> > locking is correct in this case. It would have been a bug
> >>>> >
> >>>> > prior to Java 5.
> >>>> >
> >>>> > Best regards,
> >>>> >
> >>>> > Dmitry Vyazelenko
> >>>> >
> >>>> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >>>> >
> >>>> > <richard.warburton at gmail.com> wrote:
> >>>> >
> >>>> > Hello,
> >>>> >
> >>>> > The current implementation of java.io.File::toPath [0]
> >>>> >
> >>>> > appears to be
> >>>> >
> >>>> > using the double checked locking pattern:
> >>>> >
> >>>> >     public Path toPath() {
> >>>> >         Path result = filePath;
> >>>> >         if (result == null) {
> >>>> >             synchronized (this) {
> >>>> >                 result = filePath;
> >>>> >                 if (result == null) {
> >>>> >                     result =
> >>>> >
> >>>> > FileSystems.getDefault().getPath(path);
> >>>> >
> >>>> >                     filePath = result;
> >>>> >                 }
> >>>> >             }
> >>>> >         }
> >>>> >         return result;
> >>>> >     }
> >>>> >
> >>>> > I was going to report the bug, but I'm a little
> >>>> >
> >>>> > uncertain of the
> >>>> >
> >>>> > interaction between the local variable 'result' and DCL
> >>>> >
> >>>> > since I've
> >>>> >
> >>>> > previously only seen the checking condition on the
> >>>> >
> >>>> > shared field
> >>>> >
> >>>> > itself.  Can someone here either confirm that its a bug or
> >>>> >
> >>>> > explain how
> >>>> >
> >>>> > the 'result' variable is fixing things?
> >>>> >
> >>>> > regards,
> >>>> >
> >>>> >  Richard
> >>>> >
> >>>> > [0] See the end of
> >>>> >
> >>>> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >>>> >
> >>>> > ses/java/io/File.java
> >>>> >
> >>>> > _______________________________________________
> >>>> > Concurrency-interest mailing list
> >>>> > Concurrency-interest at cs.oswego.edu
> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>> >
> >>>> > _______________________________________________
> >>>> > Concurrency-interest mailing list
> >>>> > Concurrency-interest at cs.oswego.edu
> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>> >
> >>>> > _______________________________________________
> >>>> > Concurrency-interest mailing list
> >>>> > Concurrency-interest at cs.oswego.edu
> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>> >
> >>>> > _______________________________________________
> >>>> > Concurrency-interest mailing list
> >>>> > Concurrency-interest at cs.oswego.edu
> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>> >
> >>>> >
> >>>> >
> >>>> > _______________________________________________
> >>>> > Concurrency-interest mailing list
> >>>> > Concurrency-interest at cs.oswego.edu
> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>> >
> >>>> _______________________________________________
> >>>> Concurrency-interest mailing list
> >>>> Concurrency-interest at cs.oswego.edu
> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>
> >>>
> >>>
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>
>


From zhong.j.yu at gmail.com  Wed Aug 15 19:47:25 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Wed, 15 Aug 2012 18:47:25 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEECEJGAA.davidcholmes@aapt.net.au>
References: <CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCEECEJGAA.davidcholmes@aapt.net.au>
Message-ID: <CACuKZqGjN3OxW2CPoh9rpAxGwdkzubMpJ2X0Tx7JyyB=D4K9VQ@mail.gmail.com>

On Wed, Aug 15, 2012 at 6:21 PM, David Holmes <davidcholmes at aapt.net.au> wrote:
> Ruslan Cheremin writes:
>>
>> > The reason to keep them distinct is because in general the
>> > mechanisms for safe publication are external to the class,
>> > while those for thread-safety are internal. It is only an
>> > edge case where use of synchronized in a constructor can
>> > achieve safe-publication.
>>
>> Well, actually I do not understand your point. If I use some kind of
>> synchronization to make methods of my object thread-safe -- can't I
>> also apply same thing to constructor? For me, it makes the thing only
>> clearer. Object can be thread-safe -- and it is totally thread safe.
>> Object can require external synchronization for correct multithreaded
>> use -- and it requires the sync for publishing and for usage also.
>
> You have to be able to establish the necessary happens-before relationships
> between the end of construction, publication and use.
>
> If thread-safe means you've created a "monitor" where only one method
> invocation can proceed at a time and all methods are synchronized, then
> synchronized in the constructor will construction happens-before use, and
> the publication mechanism is not relevant.
>
> If all your fields are final or volatile then you also have no issue with
> publication.

Example why volatile does not guarantee that.

    class Foo
        volatile x = 42;

    // thread 1
    foo = new Foo();  // unsafe pub

    // thread 2
    r = foo;
    if(r!=null)
        print(r.x);  // may print "0"

> Otherwise you have a bit more work to do. Relying on safe-publication to
> introduce the happens-before ordering allows you to use simpler, more
> natural, and likely more performant code in your thread-safe class.
>
> David
> -----
>
>
>> From my point of view, the distinction you talking about is more
>> historically reasoned. "Sync method if you want it to be thread-safe"
>> is commonly learned mantra, but "take care of initialization also" is
>> not so common. More information about it, more education, more
>> different code samples with outlined "here is the dragons" will change
>> the situation, I sure, it just have to be highlighted more often.
>>
>>
>> > People have to recognize that sharing an object requires shared mutable
>> > state, and the number one tenet of concurrent programming is
>> that access to
>> > shared mutable state has to be synchronized (in a general sense not
>> > specifically use of 'synchronized' keyword).
>> >
>> > Making every object safely publishable could be done, but for
>> 99% of objects
>> > it would be a waste of effort. Programs without data races
>> don't have issues
>> > with unsafe publication.
>> >
>> > David
>> >
>> > -----Original Message-----
>> > From: concurrency-interest-bounces at cs.oswego.edu
>> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan
>> > Reynolds
>> > Sent: Wednesday, 15 August 2012 4:59 AM
>> > To: concurrency-interest at cs.oswego.edu
>> > Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>> >
>> > We seem to be splitting two notions (i.e thread-safe and safe
>> publication)
>> > when they should be combined in a sense.  Typically, when we
>> say thread-safe
>> > we talk about the operations performed on the object after it was
>> > constructed (and its contents are globally visible).  However,
>> we need to
>> > consider that executing the constructor is modifying the state of the
>> > object.  It requires the same mechanisms that the rest of the
>> class uses to
>> > ensure thread-safety.  Even though, there is only 1 thread executing the
>> > constructor, a proper releasing of a lock or some other happens-before
>> > construct is required to ensure that the memory updates by the
>> thread are
>> > made globally visible before the object is accessed by another
>> thread.  This
>> > is what we are calling safe publication.  So, safe publication
>> is a subset
>> > of thread-safety except it is limited to what happens after the
>> constructor
>> > is called and before the object is used by multiple threads.
>> >
>> > A beautifully-written class can be thread-safe with respect to
>> calling its
>> > member methods but not thread-safe with respect to calling its
>> constructor.
>> > It is this latter case that many stumble upon because they think that
>> > constructors are inherently thread-safe because they are executed
>> > single-threadedly.  What they fail to realize is that the execution of a
>> > constructor can overlap with the execution of other code from
>> the view point
>> > of what is happening in memory.  This same problem applies to
>> more rare case
>> > of regular methods which can be proven to execute in a single thread but
>> > don't use synchronization before multiple threads start
>> accessing the shared
>> > data.
>> >
>> > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
>> > Oracle PSR Engineering | Server Technology
>> > On 8/13/2012 4:08 PM, David Holmes wrote:
>> >
>> > Ruslan Cheremin writes:
>> >
>> > For me it is confusing: java has only one way to have really immutable
>> > object, and this way also gives you a total thread safety even for
>> > data race based publication. But then docs refer object as "immutable
>> > and thread-safe" -- we still can't assume it to be really thread-safe?
>> >
>> > It is better/simpler to isolate the notion of thread-safety and safe
>> > publication. Thread-safety comes into play after you have
>> safely shared an
>> > object. The means by which you safely share an object is
>> orthogonal to how
>> > the object itself is made thread-safe.
>> >
>> > The means by which an object is shared has to involve shared
>> mutable state,
>> > and use of shared mutable state always needs some form of
>> synchronization
>> > (either implicit eg due to static initialization; or explicit by using
>> > volatile or synchronized getter/setter methods).
>> >
>> > David
>> > -----
>> >
>> > It's a pity, especially because true immutability gives us some
>> > chances of performance optimization. As in this case -- we do not
>> > really need .path to be volatile here, if we would assume Path to be
>> > truly immutable. volatility here required only for ensuring safe
>> > publishing.
>> >
>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >
>> > Ruslan Cheremin writes:>
>> >
>> > But is there a way to define "safe for data race publishing"? I as
>> > far, as I remember, "immutable and thread-safe" is standard mantra in
>> > JDK javadocs for totally safe objects. j.l.String has same mantra --
>> > and it is safe for any way of publishing. Does you mean, I should
>> > explicitly add "safe even for publishing via data race" in docs? But I
>> > can't remember any such phrase in JDK docs.
>> >
>> > I don't recall anything in the JDK docs that mention being
>> >
>> > "totally safe"
>> >
>> > regardless of publication mechanism. Some classes, eg String, have been
>> > defined such that they do have that property (for security reasons). In
>> > general neither "thread-safe" nor "immutable" imply
>> > safe-for-unsynchronized-publication.
>> >
>> > Java Concurrency In Practice (jcip.net) does define additional potential
>> > annotations, where @Immutable would indeed capture the requirement of
>> > safe-for-unsynchronized-publication.
>> >
>> > David
>> > -----
>> >
>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >
>> > Ruslan Cheremin writes:
>> >
>> > Well, Path javadoc explicitly says "immutable and safe for
>> > multithreaded use". Although it is not strictly defined in java what
>> > exactly means "safe for multithreaded use" -- does it mean safe for
>> > publishing via data race, among others? -- I suppose, it
>> >
>> > should be. Am
>> >
>> > I wrong here?
>> >
>> > "safe for multi-threaded use" does not generally imply that it
>> >
>> > is safe to
>> >
>> > publish instances without synchronization of some form.
>> >
>> > David
>> > -----
>> >
>> > From other side, File.toPath javadoc explicitly says what "returned
>> > instance must be the same for every invocation", so sync block is
>> > required here for mutual exclusion on initialization phase. Without
>> > this requirement it is also safe to live without sync block, afaik.
>> >
>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >
>> > Ruslan Cheremin writes:
>> >
>> > First of all, Path is immutable, so DCL is safe here even without
>> > volatile. Volatile here is not required from my point of view.
>> >
>> > Without the volatile the Path implementation (Path is an
>> >
>> > interface) must be
>> >
>> > such that an instance of Path can be safely published without
>> >
>> > any additional
>> >
>> > forms of synchronization. Immutability does not in itself
>> >
>> > ensure that. You
>> >
>> > would have to examine the actual implementation class.
>> >
>> > David Holmes
>> > ------------
>> >
>> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >
>> > Hi Richard,
>> >
>> > The variable "filePath" is volatile, so the double-checked
>> >
>> > locking is correct in this case. It would have been a bug
>> >
>> > prior to Java 5.
>> >
>> > Best regards,
>> >
>> > Dmitry Vyazelenko
>> >
>> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >
>> > <richard.warburton at gmail.com> wrote:
>> >
>> > Hello,
>> >
>> > The current implementation of java.io.File::toPath [0]
>> >
>> > appears to be
>> >
>> > using the double checked locking pattern:
>> >
>> >     public Path toPath() {
>> >         Path result = filePath;
>> >         if (result == null) {
>> >             synchronized (this) {
>> >                 result = filePath;
>> >                 if (result == null) {
>> >                     result =
>> >
>> > FileSystems.getDefault().getPath(path);
>> >
>> >                     filePath = result;
>> >                 }
>> >             }
>> >         }
>> >         return result;
>> >     }
>> >
>> > I was going to report the bug, but I'm a little
>> >
>> > uncertain of the
>> >
>> > interaction between the local variable 'result' and DCL
>> >
>> > since I've
>> >
>> > previously only seen the checking condition on the
>> >
>> > shared field
>> >
>> > itself.  Can someone here either confirm that its a bug or
>> >
>> > explain how
>> >
>> > the 'result' variable is fixing things?
>> >
>> > regards,
>> >
>> >  Richard
>> >
>> > [0] See the end of
>> >
>> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >
>> > ses/java/io/File.java
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From davidcholmes at aapt.net.au  Wed Aug 15 19:51:12 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 16 Aug 2012 09:51:12 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37HGobSufGXWhQwc8ETyTytb3pwWtsqP2HT5Bgqt7ee_uw@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEECHJGAA.davidcholmes@aapt.net.au>

I stand corrected.

My previous characterization that the issue is that construction
happens-before use, was not accounting that the publication part is always
critical and so we must ensure that construction happens-before publication
which happens-before use.

Note that synchronized constructor also does not prevent assignment to the
reference being reordered with assignments in the constructor, but the
mutual exclusion aspect prevents that from being a problem.

Thanks,
David

  -----Original Message-----
  From: Vitaly Davidovich [mailto:vitalyd at gmail.com]
  Sent: Thursday, 16 August 2012 9:42 AM
  To: dholmes at ieee.org
  Cc: Ruslan Cheremin; concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK



    If all your fields are final or volatile then you also have no issue
with
    publication.


  Volatile wouldn't help either as it won't prevent the possible reordering
of the assignment to the reference.  Final (or Unsafe.putXXXOrdered) is the
only solution (outside of synchronizing the constructor and the whole class
:)).

  On Aug 15, 2012 7:28 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:

    Ruslan Cheremin writes:
    >
    > > The reason to keep them distinct is because in general the
    > > mechanisms for safe publication are external to the class,
    > > while those for thread-safety are internal. It is only an
    > > edge case where use of synchronized in a constructor can
    > > achieve safe-publication.
    >
    > Well, actually I do not understand your point. If I use some kind of
    > synchronization to make methods of my object thread-safe -- can't I
    > also apply same thing to constructor? For me, it makes the thing only
    > clearer. Object can be thread-safe -- and it is totally thread safe.
    > Object can require external synchronization for correct multithreaded
    > use -- and it requires the sync for publishing and for usage also.

    You have to be able to establish the necessary happens-before
relationships
    between the end of construction, publication and use.

    If thread-safe means you've created a "monitor" where only one method
    invocation can proceed at a time and all methods are synchronized, then
    synchronized in the constructor will construction happens-before use,
and
    the publication mechanism is not relevant.

    If all your fields are final or volatile then you also have no issue
with
    publication.

    Otherwise you have a bit more work to do. Relying on safe-publication to
    introduce the happens-before ordering allows you to use simpler, more
    natural, and likely more performant code in your thread-safe class.

    David
    -----


    > From my point of view, the distinction you talking about is more
    > historically reasoned. "Sync method if you want it to be thread-safe"
    > is commonly learned mantra, but "take care of initialization also" is
    > not so common. More information about it, more education, more
    > different code samples with outlined "here is the dragons" will change
    > the situation, I sure, it just have to be highlighted more often.
    >
    >
    > > People have to recognize that sharing an object requires shared
mutable
    > > state, and the number one tenet of concurrent programming is
    > that access to
    > > shared mutable state has to be synchronized (in a general sense not
    > > specifically use of 'synchronized' keyword).
    > >
    > > Making every object safely publishable could be done, but for
    > 99% of objects
    > > it would be a waste of effort. Programs without data races
    > don't have issues
    > > with unsafe publication.
    > >
    > > David
    > >
    > > -----Original Message-----
    > > From: concurrency-interest-bounces at cs.oswego.edu
    > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
Nathan
    > > Reynolds
    > > Sent: Wednesday, 15 August 2012 4:59 AM
    > > To: concurrency-interest at cs.oswego.edu
    > > Subject: Re: [concurrency-interest] Double Checked Locking in
OpenJDK
    > >
    > > We seem to be splitting two notions (i.e thread-safe and safe
    > publication)
    > > when they should be combined in a sense.  Typically, when we
    > say thread-safe
    > > we talk about the operations performed on the object after it was
    > > constructed (and its contents are globally visible).  However,
    > we need to
    > > consider that executing the constructor is modifying the state of
the
    > > object.  It requires the same mechanisms that the rest of the
    > class uses to
    > > ensure thread-safety.  Even though, there is only 1 thread executing
the
    > > constructor, a proper releasing of a lock or some other
happens-before
    > > construct is required to ensure that the memory updates by the
    > thread are
    > > made globally visible before the object is accessed by another
    > thread.  This
    > > is what we are calling safe publication.  So, safe publication
    > is a subset
    > > of thread-safety except it is limited to what happens after the
    > constructor
    > > is called and before the object is used by multiple threads.
    > >
    > > A beautifully-written class can be thread-safe with respect to
    > calling its
    > > member methods but not thread-safe with respect to calling its
    > constructor.
    > > It is this latter case that many stumble upon because they think
that
    > > constructors are inherently thread-safe because they are executed
    > > single-threadedly.  What they fail to realize is that the execution
of a
    > > constructor can overlap with the execution of other code from
    > the view point
    > > of what is happening in memory.  This same problem applies to
    > more rare case
    > > of regular methods which can be proven to execute in a single thread
but
    > > don't use synchronization before multiple threads start
    > accessing the shared
    > > data.
    > >
    > > Nathan Reynolds | Consulting Member of Technical Staff |
602.333.9091
    > > Oracle PSR Engineering | Server Technology
    > > On 8/13/2012 4:08 PM, David Holmes wrote:
    > >
    > > Ruslan Cheremin writes:
    > >
    > > For me it is confusing: java has only one way to have really
immutable
    > > object, and this way also gives you a total thread safety even for
    > > data race based publication. But then docs refer object as
"immutable
    > > and thread-safe" -- we still can't assume it to be really
thread-safe?
    > >
    > > It is better/simpler to isolate the notion of thread-safety and safe
    > > publication. Thread-safety comes into play after you have
    > safely shared an
    > > object. The means by which you safely share an object is
    > orthogonal to how
    > > the object itself is made thread-safe.
    > >
    > > The means by which an object is shared has to involve shared
    > mutable state,
    > > and use of shared mutable state always needs some form of
    > synchronization
    > > (either implicit eg due to static initialization; or explicit by
using
    > > volatile or synchronized getter/setter methods).
    > >
    > > David
    > > -----
    > >
    > > It's a pity, especially because true immutability gives us some
    > > chances of performance optimization. As in this case -- we do not
    > > really need .path to be volatile here, if we would assume Path to be
    > > truly immutable. volatility here required only for ensuring safe
    > > publishing.
    > >
    > > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
    > >
    > > Ruslan Cheremin writes:>
    > >
    > > But is there a way to define "safe for data race publishing"? I as
    > > far, as I remember, "immutable and thread-safe" is standard mantra
in
    > > JDK javadocs for totally safe objects. j.l.String has same mantra --
    > > and it is safe for any way of publishing. Does you mean, I should
    > > explicitly add "safe even for publishing via data race" in docs? But
I
    > > can't remember any such phrase in JDK docs.
    > >
    > > I don't recall anything in the JDK docs that mention being
    > >
    > > "totally safe"
    > >
    > > regardless of publication mechanism. Some classes, eg String, have
been
    > > defined such that they do have that property (for security reasons).
In
    > > general neither "thread-safe" nor "immutable" imply
    > > safe-for-unsynchronized-publication.
    > >
    > > Java Concurrency In Practice (jcip.net) does define additional
potential
    > > annotations, where @Immutable would indeed capture the requirement
of
    > > safe-for-unsynchronized-publication.
    > >
    > > David
    > > -----
    > >
    > > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
    > >
    > > Ruslan Cheremin writes:
    > >
    > > Well, Path javadoc explicitly says "immutable and safe for
    > > multithreaded use". Although it is not strictly defined in java what
    > > exactly means "safe for multithreaded use" -- does it mean safe for
    > > publishing via data race, among others? -- I suppose, it
    > >
    > > should be. Am
    > >
    > > I wrong here?
    > >
    > > "safe for multi-threaded use" does not generally imply that it
    > >
    > > is safe to
    > >
    > > publish instances without synchronization of some form.
    > >
    > > David
    > > -----
    > >
    > > From other side, File.toPath javadoc explicitly says what "returned
    > > instance must be the same for every invocation", so sync block is
    > > required here for mutual exclusion on initialization phase. Without
    > > this requirement it is also safe to live without sync block, afaik.
    > >
    > > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
    > >
    > > Ruslan Cheremin writes:
    > >
    > > First of all, Path is immutable, so DCL is safe here even without
    > > volatile. Volatile here is not required from my point of view.
    > >
    > > Without the volatile the Path implementation (Path is an
    > >
    > > interface) must be
    > >
    > > such that an instance of Path can be safely published without
    > >
    > > any additional
    > >
    > > forms of synchronization. Immutability does not in itself
    > >
    > > ensure that. You
    > >
    > > would have to examine the actual implementation class.
    > >
    > > David Holmes
    > > ------------
    > >
    > > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
    > >
    > > Hi Richard,
    > >
    > > The variable "filePath" is volatile, so the double-checked
    > >
    > > locking is correct in this case. It would have been a bug
    > >
    > > prior to Java 5.
    > >
    > > Best regards,
    > >
    > > Dmitry Vyazelenko
    > >
    > > On Aug 12, 2012, at 21:35 , Richard Warburton
    > >
    > > <richard.warburton at gmail.com> wrote:
    > >
    > > Hello,
    > >
    > > The current implementation of java.io.File::toPath [0]
    > >
    > > appears to be
    > >
    > > using the double checked locking pattern:
    > >
    > >     public Path toPath() {
    > >         Path result = filePath;
    > >         if (result == null) {
    > >             synchronized (this) {
    > >                 result = filePath;
    > >                 if (result == null) {
    > >                     result =
    > >
    > > FileSystems.getDefault().getPath(path);
    > >
    > >                     filePath = result;
    > >                 }
    > >             }
    > >         }
    > >         return result;
    > >     }
    > >
    > > I was going to report the bug, but I'm a little
    > >
    > > uncertain of the
    > >
    > > interaction between the local variable 'result' and DCL
    > >
    > > since I've
    > >
    > > previously only seen the checking condition on the
    > >
    > > shared field
    > >
    > > itself.  Can someone here either confirm that its a bug or
    > >
    > > explain how
    > >
    > > the 'result' variable is fixing things?
    > >
    > > regards,
    > >
    > >  Richard
    > >
    > > [0] See the end of
    > >
    > > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
    > >
    > > ses/java/io/File.java
    > >
    > > _______________________________________________
    > > Concurrency-interest mailing list
    > > Concurrency-interest at cs.oswego.edu
    > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >
    > > _______________________________________________
    > > Concurrency-interest mailing list
    > > Concurrency-interest at cs.oswego.edu
    > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >
    > > _______________________________________________
    > > Concurrency-interest mailing list
    > > Concurrency-interest at cs.oswego.edu
    > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >
    > > _______________________________________________
    > > Concurrency-interest mailing list
    > > Concurrency-interest at cs.oswego.edu
    > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >
    > >
    > >
    > > _______________________________________________
    > > Concurrency-interest mailing list
    > > Concurrency-interest at cs.oswego.edu
    > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >
    >

    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at cs.oswego.edu
    http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120816/87d4a7de/attachment-0001.html>

From zhong.j.yu at gmail.com  Wed Aug 15 19:58:57 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Wed, 15 Aug 2012 18:58:57 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIECGJGAA.davidcholmes@aapt.net.au>
References: <CACuKZqEVRssbk-MudNPmJjvuuFA_mszxs6HGGU-8ketQPjX7fQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIECGJGAA.davidcholmes@aapt.net.au>
Message-ID: <CACuKZqEKPVJhLzWWVT64ZErwK+qLqwuAMTxpXvH1wVeoEm-mdQ@mail.gmail.com>

I'm not sure about the proper definition of safe/unsafe publication.

In any case, it's not easy to prove (on JMM rules) that the sync block
in the creation thread is ordered before the sync blocks in other
threads, so it's probably not worthwhile to contemplate such tricks.

On Wed, Aug 15, 2012 at 6:44 PM, David Holmes <davidcholmes at aapt.net.au> wrote:
> Zhong Yu writes:
>>
>> Any use case for unsafe publication of a mutable thread-safe object?
>>
>> If a use case does exist, there is a way to do it without
>> synchronizing constructor:
>>
>>     local_var = new Vector();  // not synchronized
>>     local_var.size();  // call a synchronized method
>>     shared_var = local_var;  // unsafe publication
>>
>> therefore synchronized constructor still isn't necessary.
>
> The above is turning unsafe publication into safe-publication.
>
> As I said in other email the whole issue here is to ensure that construction
> happens-before use. In the sharing case publication has to occur prior to
> use. That means you either tackle the problem directly, by ensuring
> construction happens-before use (ie with synchronized constructor on fully
> synchronized object). Or you establish that construction happens-before
> publication and publication happens-before use aka you use safe-publication
> mechanisms.
>
> David
> ------
>
>
>> Though, aesthetically, one might prefer to do synchronization in
>> constructors the same way it's done in instance methods, if the
>> overhead isn't a concern.
>>
>> Zhong Yu
>>
>> On Wed, Aug 15, 2012 at 2:56 PM, Ruslan Cheremin
>> <cheremin at gmail.com> wrote:
>> > Yes, it was an interesting discussion, and as result object with
>> > synchronized methods and constructor can be published unsafe (i.e.
>> > other thread can obtain reference to partially initialized object),
>> > but this patrially initialized state can't be observed, since all
>> > access going via sync-ed methods, which will block until
>> > initialization finish.
>> >
>> > So, staying away from the unsual and so strange and even ugly notation
>> > of locking in constructor, making object self-safe-publishing is not
>> > anything more complex, then making thread-safe method. Am I missed
>> > something?
>> >
>> > 2012/8/15 Zhong Yu <zhong.j.yu at gmail.com>:
>> >> I thought the conclusion of that thread is that synchronizing
>> >> constructor has the desired merit - if all constructors and methods
>> >> are synchronized, a non-creating thread won't observe the zero/partial
>> >> state of the object, even if the object reference is published
>> >> unsafely.
>> >>
>> >> (One guy, who shall remain nameless, muddied the water with some
>> >> mistaken statements of weaker memory guarantee. He has been corrected)
>> >>
>> >> Zhong Yu
>> >>
>> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
>> <yshavit at akiban.com> wrote:
>> >>> There was a discussion here a few months ago about synchronizing
>> >>> constructors -- I had asked why it's not allowed, and the
>> discussion hit on
>> >>> some of the similar points brought up in this thread.
>> >>>
>> >>> But to your point specifically, synchronizing a constructor (via
>> >>> "synchronized(this) {...}" surrounding its body) still
>> doesn't give you full
>> >>> thread safety (even assuming immutability after the constructor -- but
>> >>> without final fields). It ensures that a thread can observe the object
>> >>> either fully constructed *or* with all its fields having their default
>> >>> values. In other words, even if your constructor is
>> synchronized on the same
>> >>> object your getter is, a thread could observe a field as it
>> was before the
>> >>> constructor was invoked.
>> >>>
>> >>> http://markmail.org/message/mav53xzo4bqu7udw
>> >>>
>> >>>
>> >>> On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin <cheremin at gmail.com>
>> >>> wrote:
>> >>>>
>> >>>> > The reason to keep them distinct is because in general the
>> mechanisms
>> >>>> > for
>> >>>> > safe publication are external to the class, while those for
>> >>>> > thread-safety
>> >>>> > are internal. It is only an edge case where use of
>> synchronized in a
>> >>>> > constructor can achieve safe-publication.
>> >>>>
>> >>>> Well, actually I do not understand your point. If I use some kind of
>> >>>> synchronization to make methods of my object thread-safe -- can't I
>> >>>> also apply same thing to constructor? For me, it makes the thing only
>> >>>> clearer. Object can be thread-safe -- and it is totally thread safe.
>> >>>> Object can require external synchronization for correct multithreaded
>> >>>> use -- and it requires the sync for publishing and for usage also.
>> >>>>
>> >>>> From my point of view, the distinction you talking about is more
>> >>>> historically reasoned. "Sync method if you want it to be thread-safe"
>> >>>> is commonly learned mantra, but "take care of initialization also" is
>> >>>> not so common. More information about it, more education, more
>> >>>> different code samples with outlined "here is the dragons"
>> will change
>> >>>> the situation, I sure, it just have to be highlighted more often.
>> >>>>
>> >>>>
>> >>>> > People have to recognize that sharing an object requires
>> shared mutable
>> >>>> > state, and the number one tenet of concurrent programming
>> is that access
>> >>>> > to
>> >>>> > shared mutable state has to be synchronized (in a general sense not
>> >>>> > specifically use of 'synchronized' keyword).
>> >>>> >
>> >>>> > Making every object safely publishable could be done, but
>> for 99% of
>> >>>> > objects
>> >>>> > it would be a waste of effort. Programs without data races
>> don't have
>> >>>> > issues
>> >>>> > with unsafe publication.
>> >>>> >
>> >>>> > David
>> >>>> >
>> >>>> > -----Original Message-----
>> >>>> > From: concurrency-interest-bounces at cs.oswego.edu
>> >>>> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On
>> Behalf Of Nathan
>> >>>> > Reynolds
>> >>>> > Sent: Wednesday, 15 August 2012 4:59 AM
>> >>>> > To: concurrency-interest at cs.oswego.edu
>> >>>> > Subject: Re: [concurrency-interest] Double Checked Locking
>> in OpenJDK
>> >>>> >
>> >>>> > We seem to be splitting two notions (i.e thread-safe and safe
>> >>>> > publication)
>> >>>> > when they should be combined in a sense.  Typically, when we say
>> >>>> > thread-safe
>> >>>> > we talk about the operations performed on the object after it was
>> >>>> > constructed (and its contents are globally visible).
>> However, we need
>> >>>> > to
>> >>>> > consider that executing the constructor is modifying the
>> state of the
>> >>>> > object.  It requires the same mechanisms that the rest of
>> the class uses
>> >>>> > to
>> >>>> > ensure thread-safety.  Even though, there is only 1 thread
>> executing the
>> >>>> > constructor, a proper releasing of a lock or some other
>> happens-before
>> >>>> > construct is required to ensure that the memory updates by
>> the thread
>> >>>> > are
>> >>>> > made globally visible before the object is accessed by
>> another thread.
>> >>>> > This
>> >>>> > is what we are calling safe publication.  So, safe publication is a
>> >>>> > subset
>> >>>> > of thread-safety except it is limited to what happens after the
>> >>>> > constructor
>> >>>> > is called and before the object is used by multiple threads.
>> >>>> >
>> >>>> > A beautifully-written class can be thread-safe with
>> respect to calling
>> >>>> > its
>> >>>> > member methods but not thread-safe with respect to calling its
>> >>>> > constructor.
>> >>>> > It is this latter case that many stumble upon because they
>> think that
>> >>>> > constructors are inherently thread-safe because they are executed
>> >>>> > single-threadedly.  What they fail to realize is that the
>> execution of a
>> >>>> > constructor can overlap with the execution of other code
>> from the view
>> >>>> > point
>> >>>> > of what is happening in memory.  This same problem applies
>> to more rare
>> >>>> > case
>> >>>> > of regular methods which can be proven to execute in a
>> single thread but
>> >>>> > don't use synchronization before multiple threads start
>> accessing the
>> >>>> > shared
>> >>>> > data.
>> >>>> >
>> >>>> > Nathan Reynolds | Consulting Member of Technical Staff |
>> 602.333.9091
>> >>>> > Oracle PSR Engineering | Server Technology
>> >>>> > On 8/13/2012 4:08 PM, David Holmes wrote:
>> >>>> >
>> >>>> > Ruslan Cheremin writes:
>> >>>> >
>> >>>> > For me it is confusing: java has only one way to have
>> really immutable
>> >>>> > object, and this way also gives you a total thread safety even for
>> >>>> > data race based publication. But then docs refer object as
>> "immutable
>> >>>> > and thread-safe" -- we still can't assume it to be really
>> thread-safe?
>> >>>> >
>> >>>> > It is better/simpler to isolate the notion of
>> thread-safety and safe
>> >>>> > publication. Thread-safety comes into play after you have
>> safely shared
>> >>>> > an
>> >>>> > object. The means by which you safely share an object is
>> orthogonal to
>> >>>> > how
>> >>>> > the object itself is made thread-safe.
>> >>>> >
>> >>>> > The means by which an object is shared has to involve
>> shared mutable
>> >>>> > state,
>> >>>> > and use of shared mutable state always needs some form of
>> >>>> > synchronization
>> >>>> > (either implicit eg due to static initialization; or
>> explicit by using
>> >>>> > volatile or synchronized getter/setter methods).
>> >>>> >
>> >>>> > David
>> >>>> > -----
>> >>>> >
>> >>>> > It's a pity, especially because true immutability gives us some
>> >>>> > chances of performance optimization. As in this case -- we do not
>> >>>> > really need .path to be volatile here, if we would assume
>> Path to be
>> >>>> > truly immutable. volatility here required only for ensuring safe
>> >>>> > publishing.
>> >>>> >
>> >>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >>>> >
>> >>>> > Ruslan Cheremin writes:>
>> >>>> >
>> >>>> > But is there a way to define "safe for data race publishing"? I as
>> >>>> > far, as I remember, "immutable and thread-safe" is
>> standard mantra in
>> >>>> > JDK javadocs for totally safe objects. j.l.String has same
>> mantra --
>> >>>> > and it is safe for any way of publishing. Does you mean, I should
>> >>>> > explicitly add "safe even for publishing via data race" in
>> docs? But I
>> >>>> > can't remember any such phrase in JDK docs.
>> >>>> >
>> >>>> > I don't recall anything in the JDK docs that mention being
>> >>>> >
>> >>>> > "totally safe"
>> >>>> >
>> >>>> > regardless of publication mechanism. Some classes, eg
>> String, have been
>> >>>> > defined such that they do have that property (for security
>> reasons). In
>> >>>> > general neither "thread-safe" nor "immutable" imply
>> >>>> > safe-for-unsynchronized-publication.
>> >>>> >
>> >>>> > Java Concurrency In Practice (jcip.net) does define
>> additional potential
>> >>>> > annotations, where @Immutable would indeed capture the
>> requirement of
>> >>>> > safe-for-unsynchronized-publication.
>> >>>> >
>> >>>> > David
>> >>>> > -----
>> >>>> >
>> >>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >>>> >
>> >>>> > Ruslan Cheremin writes:
>> >>>> >
>> >>>> > Well, Path javadoc explicitly says "immutable and safe for
>> >>>> > multithreaded use". Although it is not strictly defined in
>> java what
>> >>>> > exactly means "safe for multithreaded use" -- does it mean safe for
>> >>>> > publishing via data race, among others? -- I suppose, it
>> >>>> >
>> >>>> > should be. Am
>> >>>> >
>> >>>> > I wrong here?
>> >>>> >
>> >>>> > "safe for multi-threaded use" does not generally imply that it
>> >>>> >
>> >>>> > is safe to
>> >>>> >
>> >>>> > publish instances without synchronization of some form.
>> >>>> >
>> >>>> > David
>> >>>> > -----
>> >>>> >
>> >>>> > From other side, File.toPath javadoc explicitly says what "returned
>> >>>> > instance must be the same for every invocation", so sync block is
>> >>>> > required here for mutual exclusion on initialization phase. Without
>> >>>> > this requirement it is also safe to live without sync block, afaik.
>> >>>> >
>> >>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >>>> >
>> >>>> > Ruslan Cheremin writes:
>> >>>> >
>> >>>> > First of all, Path is immutable, so DCL is safe here even without
>> >>>> > volatile. Volatile here is not required from my point of view.
>> >>>> >
>> >>>> > Without the volatile the Path implementation (Path is an
>> >>>> >
>> >>>> > interface) must be
>> >>>> >
>> >>>> > such that an instance of Path can be safely published without
>> >>>> >
>> >>>> > any additional
>> >>>> >
>> >>>> > forms of synchronization. Immutability does not in itself
>> >>>> >
>> >>>> > ensure that. You
>> >>>> >
>> >>>> > would have to examine the actual implementation class.
>> >>>> >
>> >>>> > David Holmes
>> >>>> > ------------
>> >>>> >
>> >>>> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >>>> >
>> >>>> > Hi Richard,
>> >>>> >
>> >>>> > The variable "filePath" is volatile, so the double-checked
>> >>>> >
>> >>>> > locking is correct in this case. It would have been a bug
>> >>>> >
>> >>>> > prior to Java 5.
>> >>>> >
>> >>>> > Best regards,
>> >>>> >
>> >>>> > Dmitry Vyazelenko
>> >>>> >
>> >>>> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >>>> >
>> >>>> > <richard.warburton at gmail.com> wrote:
>> >>>> >
>> >>>> > Hello,
>> >>>> >
>> >>>> > The current implementation of java.io.File::toPath [0]
>> >>>> >
>> >>>> > appears to be
>> >>>> >
>> >>>> > using the double checked locking pattern:
>> >>>> >
>> >>>> >     public Path toPath() {
>> >>>> >         Path result = filePath;
>> >>>> >         if (result == null) {
>> >>>> >             synchronized (this) {
>> >>>> >                 result = filePath;
>> >>>> >                 if (result == null) {
>> >>>> >                     result =
>> >>>> >
>> >>>> > FileSystems.getDefault().getPath(path);
>> >>>> >
>> >>>> >                     filePath = result;
>> >>>> >                 }
>> >>>> >             }
>> >>>> >         }
>> >>>> >         return result;
>> >>>> >     }
>> >>>> >
>> >>>> > I was going to report the bug, but I'm a little
>> >>>> >
>> >>>> > uncertain of the
>> >>>> >
>> >>>> > interaction between the local variable 'result' and DCL
>> >>>> >
>> >>>> > since I've
>> >>>> >
>> >>>> > previously only seen the checking condition on the
>> >>>> >
>> >>>> > shared field
>> >>>> >
>> >>>> > itself.  Can someone here either confirm that its a bug or
>> >>>> >
>> >>>> > explain how
>> >>>> >
>> >>>> > the 'result' variable is fixing things?
>> >>>> >
>> >>>> > regards,
>> >>>> >
>> >>>> >  Richard
>> >>>> >
>> >>>> > [0] See the end of
>> >>>> >
>> >>>> > hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >>>> >
>> >>>> > ses/java/io/File.java
>> >>>> >
>> >>>> > _______________________________________________
>> >>>> > Concurrency-interest mailing list
>> >>>> > Concurrency-interest at cs.oswego.edu
>> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>> >
>> >>>> > _______________________________________________
>> >>>> > Concurrency-interest mailing list
>> >>>> > Concurrency-interest at cs.oswego.edu
>> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>> >
>> >>>> > _______________________________________________
>> >>>> > Concurrency-interest mailing list
>> >>>> > Concurrency-interest at cs.oswego.edu
>> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>> >
>> >>>> > _______________________________________________
>> >>>> > Concurrency-interest mailing list
>> >>>> > Concurrency-interest at cs.oswego.edu
>> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>> >
>> >>>> >
>> >>>> >
>> >>>> > _______________________________________________
>> >>>> > Concurrency-interest mailing list
>> >>>> > Concurrency-interest at cs.oswego.edu
>> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>> >
>> >>>> _______________________________________________
>> >>>> Concurrency-interest mailing list
>> >>>> Concurrency-interest at cs.oswego.edu
>> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>
>> >>>
>> >>>
>> >>> _______________________________________________
>> >>> Concurrency-interest mailing list
>> >>> Concurrency-interest at cs.oswego.edu
>> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>
>>
>

From davidcholmes at aapt.net.au  Wed Aug 15 20:09:49 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 16 Aug 2012 10:09:49 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqEKPVJhLzWWVT64ZErwK+qLqwuAMTxpXvH1wVeoEm-mdQ@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAECIJGAA.davidcholmes@aapt.net.au>

Zhong Yu writes:
>
> I'm not sure about the proper definition of safe/unsafe publication.

safe-publication simply means that you are guaranteed to see the values set
by the construction process. (Assuming  noone is concurrently changing
them).

> In any case, it's not easy to prove (on JMM rules) that the sync block
> in the creation thread is ordered before the sync blocks in other
> threads, so it's probably not worthwhile to contemplate such tricks.

Informally the asignment to shared_var can move inside the sync-block in
size, but can't move before size() (roach-motel rules). This is the same as
what can happen with a synchronized constructor. The mutual exclusion
(needed on all methods) ensures no other thread can access shared_var.m()
for some method m(), until after size() completes and releases the monitor
lock.

David

> On Wed, Aug 15, 2012 at 6:44 PM, David Holmes
> <davidcholmes at aapt.net.au> wrote:
> > Zhong Yu writes:
> >>
> >> Any use case for unsafe publication of a mutable thread-safe object?
> >>
> >> If a use case does exist, there is a way to do it without
> >> synchronizing constructor:
> >>
> >>     local_var = new Vector();  // not synchronized
> >>     local_var.size();  // call a synchronized method
> >>     shared_var = local_var;  // unsafe publication
> >>
> >> therefore synchronized constructor still isn't necessary.
> >
> > The above is turning unsafe publication into safe-publication.
> >
> > As I said in other email the whole issue here is to ensure that
> construction
> > happens-before use. In the sharing case publication has to
> occur prior to
> > use. That means you either tackle the problem directly, by ensuring
> > construction happens-before use (ie with synchronized
> constructor on fully
> > synchronized object). Or you establish that construction happens-before
> > publication and publication happens-before use aka you use
> safe-publication
> > mechanisms.
> >
> > David
> > ------
> >
> >
> >> Though, aesthetically, one might prefer to do synchronization in
> >> constructors the same way it's done in instance methods, if the
> >> overhead isn't a concern.
> >>
> >> Zhong Yu
> >>
> >> On Wed, Aug 15, 2012 at 2:56 PM, Ruslan Cheremin
> >> <cheremin at gmail.com> wrote:
> >> > Yes, it was an interesting discussion, and as result object with
> >> > synchronized methods and constructor can be published unsafe (i.e.
> >> > other thread can obtain reference to partially initialized object),
> >> > but this patrially initialized state can't be observed, since all
> >> > access going via sync-ed methods, which will block until
> >> > initialization finish.
> >> >
> >> > So, staying away from the unsual and so strange and even
> ugly notation
> >> > of locking in constructor, making object self-safe-publishing is not
> >> > anything more complex, then making thread-safe method. Am I missed
> >> > something?
> >> >
> >> > 2012/8/15 Zhong Yu <zhong.j.yu at gmail.com>:
> >> >> I thought the conclusion of that thread is that synchronizing
> >> >> constructor has the desired merit - if all constructors and methods
> >> >> are synchronized, a non-creating thread won't observe the
> zero/partial
> >> >> state of the object, even if the object reference is published
> >> >> unsafely.
> >> >>
> >> >> (One guy, who shall remain nameless, muddied the water with some
> >> >> mistaken statements of weaker memory guarantee. He has been
> corrected)
> >> >>
> >> >> Zhong Yu
> >> >>
> >> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
> >> <yshavit at akiban.com> wrote:
> >> >>> There was a discussion here a few months ago about synchronizing
> >> >>> constructors -- I had asked why it's not allowed, and the
> >> discussion hit on
> >> >>> some of the similar points brought up in this thread.
> >> >>>
> >> >>> But to your point specifically, synchronizing a constructor (via
> >> >>> "synchronized(this) {...}" surrounding its body) still
> >> doesn't give you full
> >> >>> thread safety (even assuming immutability after the
> constructor -- but
> >> >>> without final fields). It ensures that a thread can
> observe the object
> >> >>> either fully constructed *or* with all its fields having
> their default
> >> >>> values. In other words, even if your constructor is
> >> synchronized on the same
> >> >>> object your getter is, a thread could observe a field as it
> >> was before the
> >> >>> constructor was invoked.
> >> >>>
> >> >>> http://markmail.org/message/mav53xzo4bqu7udw
> >> >>>
> >> >>>
> >> >>> On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
> <cheremin at gmail.com>
> >> >>> wrote:
> >> >>>>
> >> >>>> > The reason to keep them distinct is because in general the
> >> mechanisms
> >> >>>> > for
> >> >>>> > safe publication are external to the class, while those for
> >> >>>> > thread-safety
> >> >>>> > are internal. It is only an edge case where use of
> >> synchronized in a
> >> >>>> > constructor can achieve safe-publication.
> >> >>>>
> >> >>>> Well, actually I do not understand your point. If I use
> some kind of
> >> >>>> synchronization to make methods of my object thread-safe
> -- can't I
> >> >>>> also apply same thing to constructor? For me, it makes
> the thing only
> >> >>>> clearer. Object can be thread-safe -- and it is totally
> thread safe.
> >> >>>> Object can require external synchronization for correct
> multithreaded
> >> >>>> use -- and it requires the sync for publishing and for usage also.
> >> >>>>
> >> >>>> From my point of view, the distinction you talking about is more
> >> >>>> historically reasoned. "Sync method if you want it to be
> thread-safe"
> >> >>>> is commonly learned mantra, but "take care of
> initialization also" is
> >> >>>> not so common. More information about it, more education, more
> >> >>>> different code samples with outlined "here is the dragons"
> >> will change
> >> >>>> the situation, I sure, it just have to be highlighted more often.
> >> >>>>
> >> >>>>
> >> >>>> > People have to recognize that sharing an object requires
> >> shared mutable
> >> >>>> > state, and the number one tenet of concurrent programming
> >> is that access
> >> >>>> > to
> >> >>>> > shared mutable state has to be synchronized (in a
> general sense not
> >> >>>> > specifically use of 'synchronized' keyword).
> >> >>>> >
> >> >>>> > Making every object safely publishable could be done, but
> >> for 99% of
> >> >>>> > objects
> >> >>>> > it would be a waste of effort. Programs without data races
> >> don't have
> >> >>>> > issues
> >> >>>> > with unsafe publication.
> >> >>>> >
> >> >>>> > David
> >> >>>> >
> >> >>>> > -----Original Message-----
> >> >>>> > From: concurrency-interest-bounces at cs.oswego.edu
> >> >>>> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On
> >> Behalf Of Nathan
> >> >>>> > Reynolds
> >> >>>> > Sent: Wednesday, 15 August 2012 4:59 AM
> >> >>>> > To: concurrency-interest at cs.oswego.edu
> >> >>>> > Subject: Re: [concurrency-interest] Double Checked Locking
> >> in OpenJDK
> >> >>>> >
> >> >>>> > We seem to be splitting two notions (i.e thread-safe and safe
> >> >>>> > publication)
> >> >>>> > when they should be combined in a sense.  Typically, when we say
> >> >>>> > thread-safe
> >> >>>> > we talk about the operations performed on the object
> after it was
> >> >>>> > constructed (and its contents are globally visible).
> >> However, we need
> >> >>>> > to
> >> >>>> > consider that executing the constructor is modifying the
> >> state of the
> >> >>>> > object.  It requires the same mechanisms that the rest of
> >> the class uses
> >> >>>> > to
> >> >>>> > ensure thread-safety.  Even though, there is only 1 thread
> >> executing the
> >> >>>> > constructor, a proper releasing of a lock or some other
> >> happens-before
> >> >>>> > construct is required to ensure that the memory updates by
> >> the thread
> >> >>>> > are
> >> >>>> > made globally visible before the object is accessed by
> >> another thread.
> >> >>>> > This
> >> >>>> > is what we are calling safe publication.  So, safe
> publication is a
> >> >>>> > subset
> >> >>>> > of thread-safety except it is limited to what happens after the
> >> >>>> > constructor
> >> >>>> > is called and before the object is used by multiple threads.
> >> >>>> >
> >> >>>> > A beautifully-written class can be thread-safe with
> >> respect to calling
> >> >>>> > its
> >> >>>> > member methods but not thread-safe with respect to calling its
> >> >>>> > constructor.
> >> >>>> > It is this latter case that many stumble upon because they
> >> think that
> >> >>>> > constructors are inherently thread-safe because they
> are executed
> >> >>>> > single-threadedly.  What they fail to realize is that the
> >> execution of a
> >> >>>> > constructor can overlap with the execution of other code
> >> from the view
> >> >>>> > point
> >> >>>> > of what is happening in memory.  This same problem applies
> >> to more rare
> >> >>>> > case
> >> >>>> > of regular methods which can be proven to execute in a
> >> single thread but
> >> >>>> > don't use synchronization before multiple threads start
> >> accessing the
> >> >>>> > shared
> >> >>>> > data.
> >> >>>> >
> >> >>>> > Nathan Reynolds | Consulting Member of Technical Staff |
> >> 602.333.9091
> >> >>>> > Oracle PSR Engineering | Server Technology
> >> >>>> > On 8/13/2012 4:08 PM, David Holmes wrote:
> >> >>>> >
> >> >>>> > Ruslan Cheremin writes:
> >> >>>> >
> >> >>>> > For me it is confusing: java has only one way to have
> >> really immutable
> >> >>>> > object, and this way also gives you a total thread
> safety even for
> >> >>>> > data race based publication. But then docs refer object as
> >> "immutable
> >> >>>> > and thread-safe" -- we still can't assume it to be really
> >> thread-safe?
> >> >>>> >
> >> >>>> > It is better/simpler to isolate the notion of
> >> thread-safety and safe
> >> >>>> > publication. Thread-safety comes into play after you have
> >> safely shared
> >> >>>> > an
> >> >>>> > object. The means by which you safely share an object is
> >> orthogonal to
> >> >>>> > how
> >> >>>> > the object itself is made thread-safe.
> >> >>>> >
> >> >>>> > The means by which an object is shared has to involve
> >> shared mutable
> >> >>>> > state,
> >> >>>> > and use of shared mutable state always needs some form of
> >> >>>> > synchronization
> >> >>>> > (either implicit eg due to static initialization; or
> >> explicit by using
> >> >>>> > volatile or synchronized getter/setter methods).
> >> >>>> >
> >> >>>> > David
> >> >>>> > -----
> >> >>>> >
> >> >>>> > It's a pity, especially because true immutability gives us some
> >> >>>> > chances of performance optimization. As in this case --
> we do not
> >> >>>> > really need .path to be volatile here, if we would assume
> >> Path to be
> >> >>>> > truly immutable. volatility here required only for ensuring safe
> >> >>>> > publishing.
> >> >>>> >
> >> >>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >>>> >
> >> >>>> > Ruslan Cheremin writes:>
> >> >>>> >
> >> >>>> > But is there a way to define "safe for data race
> publishing"? I as
> >> >>>> > far, as I remember, "immutable and thread-safe" is
> >> standard mantra in
> >> >>>> > JDK javadocs for totally safe objects. j.l.String has same
> >> mantra --
> >> >>>> > and it is safe for any way of publishing. Does you
> mean, I should
> >> >>>> > explicitly add "safe even for publishing via data race" in
> >> docs? But I
> >> >>>> > can't remember any such phrase in JDK docs.
> >> >>>> >
> >> >>>> > I don't recall anything in the JDK docs that mention being
> >> >>>> >
> >> >>>> > "totally safe"
> >> >>>> >
> >> >>>> > regardless of publication mechanism. Some classes, eg
> >> String, have been
> >> >>>> > defined such that they do have that property (for security
> >> reasons). In
> >> >>>> > general neither "thread-safe" nor "immutable" imply
> >> >>>> > safe-for-unsynchronized-publication.
> >> >>>> >
> >> >>>> > Java Concurrency In Practice (jcip.net) does define
> >> additional potential
> >> >>>> > annotations, where @Immutable would indeed capture the
> >> requirement of
> >> >>>> > safe-for-unsynchronized-publication.
> >> >>>> >
> >> >>>> > David
> >> >>>> > -----
> >> >>>> >
> >> >>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >>>> >
> >> >>>> > Ruslan Cheremin writes:
> >> >>>> >
> >> >>>> > Well, Path javadoc explicitly says "immutable and safe for
> >> >>>> > multithreaded use". Although it is not strictly defined in
> >> java what
> >> >>>> > exactly means "safe for multithreaded use" -- does it
> mean safe for
> >> >>>> > publishing via data race, among others? -- I suppose, it
> >> >>>> >
> >> >>>> > should be. Am
> >> >>>> >
> >> >>>> > I wrong here?
> >> >>>> >
> >> >>>> > "safe for multi-threaded use" does not generally imply that it
> >> >>>> >
> >> >>>> > is safe to
> >> >>>> >
> >> >>>> > publish instances without synchronization of some form.
> >> >>>> >
> >> >>>> > David
> >> >>>> > -----
> >> >>>> >
> >> >>>> > From other side, File.toPath javadoc explicitly says
> what "returned
> >> >>>> > instance must be the same for every invocation", so
> sync block is
> >> >>>> > required here for mutual exclusion on initialization
> phase. Without
> >> >>>> > this requirement it is also safe to live without sync
> block, afaik.
> >> >>>> >
> >> >>>> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >>>> >
> >> >>>> > Ruslan Cheremin writes:
> >> >>>> >
> >> >>>> > First of all, Path is immutable, so DCL is safe here
> even without
> >> >>>> > volatile. Volatile here is not required from my point of view.
> >> >>>> >
> >> >>>> > Without the volatile the Path implementation (Path is an
> >> >>>> >
> >> >>>> > interface) must be
> >> >>>> >
> >> >>>> > such that an instance of Path can be safely published without
> >> >>>> >
> >> >>>> > any additional
> >> >>>> >
> >> >>>> > forms of synchronization. Immutability does not in itself
> >> >>>> >
> >> >>>> > ensure that. You
> >> >>>> >
> >> >>>> > would have to examine the actual implementation class.
> >> >>>> >
> >> >>>> > David Holmes
> >> >>>> > ------------
> >> >>>> >
> >> >>>> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >>>> >
> >> >>>> > Hi Richard,
> >> >>>> >
> >> >>>> > The variable "filePath" is volatile, so the double-checked
> >> >>>> >
> >> >>>> > locking is correct in this case. It would have been a bug
> >> >>>> >
> >> >>>> > prior to Java 5.
> >> >>>> >
> >> >>>> > Best regards,
> >> >>>> >
> >> >>>> > Dmitry Vyazelenko
> >> >>>> >
> >> >>>> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >>>> >
> >> >>>> > <richard.warburton at gmail.com> wrote:
> >> >>>> >
> >> >>>> > Hello,
> >> >>>> >
> >> >>>> > The current implementation of java.io.File::toPath [0]
> >> >>>> >
> >> >>>> > appears to be
> >> >>>> >
> >> >>>> > using the double checked locking pattern:
> >> >>>> >
> >> >>>> >     public Path toPath() {
> >> >>>> >         Path result = filePath;
> >> >>>> >         if (result == null) {
> >> >>>> >             synchronized (this) {
> >> >>>> >                 result = filePath;
> >> >>>> >                 if (result == null) {
> >> >>>> >                     result =
> >> >>>> >
> >> >>>> > FileSystems.getDefault().getPath(path);
> >> >>>> >
> >> >>>> >                     filePath = result;
> >> >>>> >                 }
> >> >>>> >             }
> >> >>>> >         }
> >> >>>> >         return result;
> >> >>>> >     }
> >> >>>> >
> >> >>>> > I was going to report the bug, but I'm a little
> >> >>>> >
> >> >>>> > uncertain of the
> >> >>>> >
> >> >>>> > interaction between the local variable 'result' and DCL
> >> >>>> >
> >> >>>> > since I've
> >> >>>> >
> >> >>>> > previously only seen the checking condition on the
> >> >>>> >
> >> >>>> > shared field
> >> >>>> >
> >> >>>> > itself.  Can someone here either confirm that its a bug or
> >> >>>> >
> >> >>>> > explain how
> >> >>>> >
> >> >>>> > the 'result' variable is fixing things?
> >> >>>> >
> >> >>>> > regards,
> >> >>>> >
> >> >>>> >  Richard
> >> >>>> >
> >> >>>> > [0] See the end of
> >> >>>> >
> >> >>>> >
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >>>> >
> >> >>>> > ses/java/io/File.java
> >> >>>> >
> >> >>>> > _______________________________________________
> >> >>>> > Concurrency-interest mailing list
> >> >>>> > Concurrency-interest at cs.oswego.edu
> >> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>>> >
> >> >>>> > _______________________________________________
> >> >>>> > Concurrency-interest mailing list
> >> >>>> > Concurrency-interest at cs.oswego.edu
> >> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>>> >
> >> >>>> > _______________________________________________
> >> >>>> > Concurrency-interest mailing list
> >> >>>> > Concurrency-interest at cs.oswego.edu
> >> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>>> >
> >> >>>> > _______________________________________________
> >> >>>> > Concurrency-interest mailing list
> >> >>>> > Concurrency-interest at cs.oswego.edu
> >> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>>> >
> >> >>>> >
> >> >>>> >
> >> >>>> > _______________________________________________
> >> >>>> > Concurrency-interest mailing list
> >> >>>> > Concurrency-interest at cs.oswego.edu
> >> >>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>>> >
> >> >>>> _______________________________________________
> >> >>>> Concurrency-interest mailing list
> >> >>>> Concurrency-interest at cs.oswego.edu
> >> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>>
> >> >>>
> >> >>>
> >> >>> _______________________________________________
> >> >>> Concurrency-interest mailing list
> >> >>> Concurrency-interest at cs.oswego.edu
> >> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >>>
> >>
> >
>


From cpovirk at google.com  Wed Aug 15 20:50:45 2012
From: cpovirk at google.com (Chris Povirk)
Date: Wed, 15 Aug 2012 20:50:45 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIECGJGAA.davidcholmes@aapt.net.au>
References: <CACuKZqEVRssbk-MudNPmJjvuuFA_mszxs6HGGU-8ketQPjX7fQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIECGJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAEvq2nqdQ4qzCjNc3nbi0BBJ8VzOr7ya-EmbtanZRzHGOj4_nQ@mail.gmail.com>

>> If a use case does exist, there is a way to do it without
>> synchronizing constructor:
>>
>>     local_var = new Vector();  // not synchronized
>>     local_var.size();  // call a synchronized method
>>     shared_var = local_var;  // unsafe publication
>>
>> therefore synchronized constructor still isn't necessary.
>
> The above is turning unsafe publication into safe-publication.

I'm still confused about this solution.  "Call a synchronized method"
feels to me like "write synchronized (x) {}": The "roach motel" model
suggests that it should work, but I don't understand how it introduces
a happens-before relationship.  I can see one difference between the
two: With "call a synchronized method," we're at least entering a
synchronized block in both the reader thread and the writer thread,
but my impression is that that's not enough, either.  Or would this
really work?

local = new Vector();
synchronized (local) {}
shared = local;

// other thread:
local = shared;
if (local != null) {
  synchronized (local) {}
  // safe to use local now?
}

From davidcholmes at aapt.net.au  Wed Aug 15 20:59:25 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 16 Aug 2012 10:59:25 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAEvq2nqdQ4qzCjNc3nbi0BBJ8VzOr7ya-EmbtanZRzHGOj4_nQ@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAECJJGAA.davidcholmes@aapt.net.au>

Chris,

The critical part is that you are synchronizing on the same object - the
vector. That is what gives the correct happens-before relationship.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Chris
> Povirk
> Sent: Thursday, 16 August 2012 10:51 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>
>
> >> If a use case does exist, there is a way to do it without
> >> synchronizing constructor:
> >>
> >>     local_var = new Vector();  // not synchronized
> >>     local_var.size();  // call a synchronized method
> >>     shared_var = local_var;  // unsafe publication
> >>
> >> therefore synchronized constructor still isn't necessary.
> >
> > The above is turning unsafe publication into safe-publication.
>
> I'm still confused about this solution.  "Call a synchronized method"
> feels to me like "write synchronized (x) {}": The "roach motel" model
> suggests that it should work, but I don't understand how it introduces
> a happens-before relationship.  I can see one difference between the
> two: With "call a synchronized method," we're at least entering a
> synchronized block in both the reader thread and the writer thread,
> but my impression is that that's not enough, either.  Or would this
> really work?
>
> local = new Vector();
> synchronized (local) {}
> shared = local;
>
> // other thread:
> local = shared;
> if (local != null) {
>   synchronized (local) {}
>   // safe to use local now?
> }
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From cpovirk at google.com  Wed Aug 15 21:25:21 2012
From: cpovirk at google.com (Chris Povirk)
Date: Wed, 15 Aug 2012 21:25:21 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAECJJGAA.davidcholmes@aapt.net.au>
References: <CAEvq2nqdQ4qzCjNc3nbi0BBJ8VzOr7ya-EmbtanZRzHGOj4_nQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAECJJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAEvq2npfVFfnr96nxXfFcT4BoE48hSR8mySiGia7uPGUmFsB3w@mail.gmail.com>

Thanks, that's definitely part of the picture.  My memory-model
knowledge is very rusty, and it was never great, so here's one more
round of questions.  First, I'll spell out some in-thread
happens-before relationships:

> local = new Vector();
> synchronized (local) {}
> shared = local;

construction happens before synchronized block
synchronized block happens before write
(=> construction happens before write)

> // other thread:
> local = shared;
> if (local != null) {
>   synchronized (local) {}
>   // safe to use local now?
> }

read happens before synchronized block
synchronized block happens before use of local
(=> read happens before use of local)

The other thing that we want is for the write to happen before the
read.  If it does, then we have construction HB write HB read HB use,
and we're fine.  But the only cross-thread happens-before
relationships I can imagine are conditional: *If* the writer's
synchronized block happens before the reader's synchronized block,
then yes, construction happens before use.  But if the *reader*'s
synchronized block happens before the *writer*'s synchronized block,
then all bets are off.  Or does that somehow guarantee that *none* of
the writes from the writer thread are visible to the reader,
guaranteeing that the reader can't see an incompletely initialized
object by guaranteeing that it can't see the object at all?  Another
(more likely?) possibility is that the writer's synchronized block is
guaranteed to happen before the reader's, but I don't know enough
rules to justify that.  Or is there a third option?

Thanks again.

From davidcholmes at aapt.net.au  Wed Aug 15 21:42:42 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 16 Aug 2012 11:42:42 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAEvq2npfVFfnr96nxXfFcT4BoE48hSR8mySiGia7uPGUmFsB3w@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMECJJGAA.davidcholmes@aapt.net.au>

Chris Povirk writes:
> 
> Thanks, that's definitely part of the picture.  My memory-model
> knowledge is very rusty, and it was never great, so here's one more
> round of questions.  First, I'll spell out some in-thread
> happens-before relationships:
> 
> > local = new Vector();
> > synchronized (local) {}
> > shared = local;
> 
> construction happens before synchronized block
> synchronized block happens before write
> (=> construction happens before write)

Nope. construction happens-before end of synchronized block. write also happens-before end of synchronized block. roach-motel rules allow everything to be moved into the sync block.
 
> > // other thread:
> > local = shared;
> > if (local != null) {
> >   synchronized (local) {}
> >   // safe to use local now?
> > }
> 
> read happens before synchronized block
> synchronized block happens before use of local
> (=> read happens before use of local)

Again use of object could be moved inside the sync-block. But sync-block here can not be entered until after other thread releases the lock. So that establishes the happens-before ordering:

everything in writer thread happens-before release of lock
release of lock happens-before acquire of lock in second thread
acquire of lock happens-before use of object
=> everything in writer thread happens-before use of object

> The other thing that we want is for the write to happen before the
> read.  If it does, then we have construction HB write HB read HB use,
> and we're fine.  But the only cross-thread happens-before
> relationships I can imagine are conditional: *If* the writer's
> synchronized block happens before the reader's synchronized block,
> then yes, construction happens before use.  But if the *reader*'s
> synchronized block happens before the *writer*'s synchronized block,
> then all bets are off.  Or does that somehow guarantee that *none* of
> the writes from the writer thread are visible to the reader,
> guaranteeing that the reader can't see an incompletely initialized
> object by guaranteeing that it can't see the object at all?  Another
> (more likely?) possibility is that the writer's synchronized block is
> guaranteed to happen before the reader's, but I don't know enough
> rules to justify that.  Or is there a third option?

The above paragraph is confusing to me. The reader thread won't attempt to execute its sync block unless it sees the write to shared. The write to shared happens after the writer thread acquires the lock (and maybe after it releases it). So the reader will only attempt to acquire the lock once the writes have progressed to the point where shared was written, but it can't actually acquire the lock until all the writes are completed.

Hope that clarifies.

David
-----

> Thanks again.
> 



From vitalyd at gmail.com  Wed Aug 15 21:51:13 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 15 Aug 2012 21:51:13 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMECJJGAA.davidcholmes@aapt.net.au>
References: <CAEvq2npfVFfnr96nxXfFcT4BoE48hSR8mySiGia7uPGUmFsB3w@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCMECJJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAHjP37HjOq7JnY7dXmLgZ6PzrtY_4f7w+CLHOKMPeTKWL3pNCQ@mail.gmail.com>

Exactly.  The key observation is that the write to "shared" cannot move
*before* the lock acquisition in the writer thread -- it can only either
stay after the monitor is released or move into the critical section; this
is because a monitor enter is just like a volatile read in JMM semantics,
which precludes subsequent stores (or loads, for that matter) from moving
before the monitor enter.  If this weren't the case, then we'd have a data
race again.  So the code as written is strange, but works :).

On Wed, Aug 15, 2012 at 9:42 PM, David Holmes <davidcholmes at aapt.net.au>wrote:

> Chris Povirk writes:
> >
> > Thanks, that's definitely part of the picture.  My memory-model
> > knowledge is very rusty, and it was never great, so here's one more
> > round of questions.  First, I'll spell out some in-thread
> > happens-before relationships:
> >
> > > local = new Vector();
> > > synchronized (local) {}
> > > shared = local;
> >
> > construction happens before synchronized block
> > synchronized block happens before write
> > (=> construction happens before write)
>
> Nope. construction happens-before end of synchronized block. write also
> happens-before end of synchronized block. roach-motel rules allow
> everything to be moved into the sync block.
>
> > > // other thread:
> > > local = shared;
> > > if (local != null) {
> > >   synchronized (local) {}
> > >   // safe to use local now?
> > > }
> >
> > read happens before synchronized block
> > synchronized block happens before use of local
> > (=> read happens before use of local)
>
> Again use of object could be moved inside the sync-block. But sync-block
> here can not be entered until after other thread releases the lock. So that
> establishes the happens-before ordering:
>
> everything in writer thread happens-before release of lock
> release of lock happens-before acquire of lock in second thread
> acquire of lock happens-before use of object
> => everything in writer thread happens-before use of object
>
> > The other thing that we want is for the write to happen before the
> > read.  If it does, then we have construction HB write HB read HB use,
> > and we're fine.  But the only cross-thread happens-before
> > relationships I can imagine are conditional: *If* the writer's
> > synchronized block happens before the reader's synchronized block,
> > then yes, construction happens before use.  But if the *reader*'s
> > synchronized block happens before the *writer*'s synchronized block,
> > then all bets are off.  Or does that somehow guarantee that *none* of
> > the writes from the writer thread are visible to the reader,
> > guaranteeing that the reader can't see an incompletely initialized
> > object by guaranteeing that it can't see the object at all?  Another
> > (more likely?) possibility is that the writer's synchronized block is
> > guaranteed to happen before the reader's, but I don't know enough
> > rules to justify that.  Or is there a third option?
>
> The above paragraph is confusing to me. The reader thread won't attempt to
> execute its sync block unless it sees the write to shared. The write to
> shared happens after the writer thread acquires the lock (and maybe after
> it releases it). So the reader will only attempt to acquire the lock once
> the writes have progressed to the point where shared was written, but it
> can't actually acquire the lock until all the writes are completed.
>
> Hope that clarifies.
>
> David
> -----
>
> > Thanks again.
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120815/e6968e0f/attachment.html>

From cpovirk at google.com  Wed Aug 15 22:03:19 2012
From: cpovirk at google.com (Chris Povirk)
Date: Wed, 15 Aug 2012 22:03:19 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMECJJGAA.davidcholmes@aapt.net.au>
References: <CAEvq2npfVFfnr96nxXfFcT4BoE48hSR8mySiGia7uPGUmFsB3w@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCMECJJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAEvq2np4QUOA_s+wZUcWnZapAzQUv=QwCyUkuCUCmUWxp7uVjA@mail.gmail.com>

>> > local = new Vector();
>> > synchronized (local) {}
>> > shared = local;
>>
>> construction happens before synchronized block
>> synchronized block happens before write
>> (=> construction happens before write)
>
> Nope. construction happens-before end of synchronized block. write also happens-before end of synchronized block. roach-motel rules allow everything to be moved into the sync block.

True, I am being imprecise in treating the synchronized block as a
single action.
> Again use of object could be moved inside the sync-block. But sync-block here can not be entered until after other thread releases the lock. So that establishes the happens-before ordering:
>
> everything in writer thread happens-before release of lock
> release of lock happens-before acquire of lock in second thread
> acquire of lock happens-before use of object
> => everything in writer thread happens-before use of object

I'm on board with this except for one part, which is apparently the
part where my thinking is too confusing for you to help me :)

"But sync-block here can not be entered until after other thread
releases the lock."

I agree that the threads can't be in the synchronized block at the
same time.  What I don't understand is what prevents the reader thread
from entering its block before the writer thread enters its block.
You give an explanation here:

> The above paragraph is confusing to me. The reader thread won't attempt to execute its sync block unless it sees the write to shared. The write to shared happens after the writer thread acquires the lock (and maybe after it releases it). So the reader will only attempt to acquire the lock once the writes have progressed to the point where shared was written, but it can't actually acquire the lock until all the writes are completed.

But does the mere fact that the reader thread sees the write to shared
establish a happens-before relationship between the read and the
write?  Surely it can't, or else it would be safe to publish the
object with no synchronized blocks at all... I think...?


From zhong.j.yu at gmail.com  Wed Aug 15 22:05:11 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Wed, 15 Aug 2012 21:05:11 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAEvq2npfVFfnr96nxXfFcT4BoE48hSR8mySiGia7uPGUmFsB3w@mail.gmail.com>
References: <CAEvq2nqdQ4qzCjNc3nbi0BBJ8VzOr7ya-EmbtanZRzHGOj4_nQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAECJJGAA.davidcholmes@aapt.net.au>
	<CAEvq2npfVFfnr96nxXfFcT4BoE48hSR8mySiGia7uPGUmFsB3w@mail.gmail.com>
Message-ID: <CACuKZqHQF3mnDait0EMn1G_uqnzadh3AzvNzqbdSt+Lyg3ubVA@mail.gmail.com>

A more formal proof: we have 4 actions to consider here

sync1
write

read
sync2

(6 actions really - each sync contains lock+unlock)

Either sync1 is ordered before sync2, or sync2 before sync1. [1]

Suppose sync2 is ordered before sync1, there is hb(sync2,sync1),
therefore there is hb(read, write).  [2]

Therefore the read is not allowed to observed the write. [3]

The read must observe one of the writes. [4]

The only other write is the null-ing of the field. Therefore the read
must observe null. Which is contradictory to (local!=null)

Therefore it must be false that sync2 is ordered before sync1.

[1] http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.4
[2] http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5
[3] http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5-500
[4] http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.7

Zhong Yu

On Wed, Aug 15, 2012 at 8:25 PM, Chris Povirk <cpovirk at google.com> wrote:
> Thanks, that's definitely part of the picture.  My memory-model
> knowledge is very rusty, and it was never great, so here's one more
> round of questions.  First, I'll spell out some in-thread
> happens-before relationships:
>
>> local = new Vector();
>> synchronized (local) {}
>> shared = local;
>
> construction happens before synchronized block
> synchronized block happens before write
> (=> construction happens before write)
>
>> // other thread:
>> local = shared;
>> if (local != null) {
>>   synchronized (local) {}
>>   // safe to use local now?
>> }
>
> read happens before synchronized block
> synchronized block happens before use of local
> (=> read happens before use of local)
>
> The other thing that we want is for the write to happen before the
> read.  If it does, then we have construction HB write HB read HB use,
> and we're fine.  But the only cross-thread happens-before
> relationships I can imagine are conditional: *If* the writer's
> synchronized block happens before the reader's synchronized block,
> then yes, construction happens before use.  But if the *reader*'s
> synchronized block happens before the *writer*'s synchronized block,
> then all bets are off.  Or does that somehow guarantee that *none* of
> the writes from the writer thread are visible to the reader,
> guaranteeing that the reader can't see an incompletely initialized
> object by guaranteeing that it can't see the object at all?  Another
> (more likely?) possibility is that the writer's synchronized block is
> guaranteed to happen before the reader's, but I don't know enough
> rules to justify that.  Or is there a third option?
>
> Thanks again.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From cpovirk at google.com  Wed Aug 15 22:08:22 2012
From: cpovirk at google.com (Chris Povirk)
Date: Wed, 15 Aug 2012 22:08:22 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqHQF3mnDait0EMn1G_uqnzadh3AzvNzqbdSt+Lyg3ubVA@mail.gmail.com>
References: <CAEvq2nqdQ4qzCjNc3nbi0BBJ8VzOr7ya-EmbtanZRzHGOj4_nQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAECJJGAA.davidcholmes@aapt.net.au>
	<CAEvq2npfVFfnr96nxXfFcT4BoE48hSR8mySiGia7uPGUmFsB3w@mail.gmail.com>
	<CACuKZqHQF3mnDait0EMn1G_uqnzadh3AzvNzqbdSt+Lyg3ubVA@mail.gmail.com>
Message-ID: <CAEvq2npGUHBtU596D3m2Jx-g+NWvh+CpFZoDO2ZF+VH+enSu9A@mail.gmail.com>

> Therefore the read is not allowed to observed the write. [3]

Thanks, I was just looking at that part of the spec, and I think that
this is the piece I was missing.

From davidcholmes at aapt.net.au  Wed Aug 15 22:13:41 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 16 Aug 2012 12:13:41 +1000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAEvq2np4QUOA_s+wZUcWnZapAzQUv=QwCyUkuCUCmUWxp7uVjA@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAECLJGAA.davidcholmes@aapt.net.au>

Chris,

Until the writer thread has entered its sync block it can not write to shared. So if the reader thread sees shared as non-null then the write must have happened and the sync block must have (at least) been entered.

Of course it is not guaranteed that the reader thread will see a non-null value of shared.

David

> -----Original Message-----
> From: Chris Povirk [mailto:cpovirk at google.com]
> Sent: Thursday, 16 August 2012 12:03 PM
> To: dholmes at ieee.org
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> 
> 
> >> > local = new Vector();
> >> > synchronized (local) {}
> >> > shared = local;
> >>
> >> construction happens before synchronized block
> >> synchronized block happens before write
> >> (=> construction happens before write)
> >
> > Nope. construction happens-before end of synchronized block. 
> write also happens-before end of synchronized block. roach-motel 
> rules allow everything to be moved into the sync block.
> 
> True, I am being imprecise in treating the synchronized block as a
> single action.
> > Again use of object could be moved inside the sync-block. But 
> sync-block here can not be entered until after other thread 
> releases the lock. So that establishes the happens-before ordering:
> >
> > everything in writer thread happens-before release of lock
> > release of lock happens-before acquire of lock in second thread
> > acquire of lock happens-before use of object
> > => everything in writer thread happens-before use of object
> 
> I'm on board with this except for one part, which is apparently the
> part where my thinking is too confusing for you to help me :)
> 
> "But sync-block here can not be entered until after other thread
> releases the lock."
> 
> I agree that the threads can't be in the synchronized block at the
> same time.  What I don't understand is what prevents the reader thread
> from entering its block before the writer thread enters its block.
> You give an explanation here:
> 
> > The above paragraph is confusing to me. The reader thread won't 
> attempt to execute its sync block unless it sees the write to 
> shared. The write to shared happens after the writer thread 
> acquires the lock (and maybe after it releases it). So the reader 
> will only attempt to acquire the lock once the writes have 
> progressed to the point where shared was written, but it can't 
> actually acquire the lock until all the writes are completed.
> 
> But does the mere fact that the reader thread sees the write to shared
> establish a happens-before relationship between the read and the
> write?  Surely it can't, or else it would be safe to publish the
> object with no synchronized blocks at all... I think...?
> 



From gergg at cox.net  Wed Aug 15 22:38:00 2012
From: gergg at cox.net (Gregg Wonderly)
Date: Wed, 15 Aug 2012 21:38:00 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAECLJGAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCAECLJGAA.davidcholmes@aapt.net.au>
Message-ID: <F6430234-CD72-40B1-9B97-3111CACBEE76@cox.net>

I think that there could be some confusion happening here different than what the experts are confronting with their explanations.  I think that the terminology "happens before", could be misleading without being defined relative to "is ordered before" and "is ordered after" in program execution.

Order of execution between two threads can only happen when they purposely negotiate the order through shared state.

The "happens before" terminology relates to visibility of change, not which value you see when, across threads.  The subtlety of this example looks at the shared state of shared == null vs shared == new Vector().  But, its necessary to also understand program execution order is not guaranteed by any action of these two blocks of code, and that's why David says below, 

"Of course it is not guaranteed that the reader thread will see a non-null value of shared."

It's only guaranteed that the initialization of the Vector value is completed before it is assigned to the shared variable by the "happens before" created by the synchronized(local){} code segment.

A semaphore or other shared state and a "wait for state change" would have to occur, for the reader thread to be guaranteed to see a non-null value.

Is there away to talk about the visibility created by "happens before", with better terminology that would make developers more able to not slide into thoughts about "order of execution"?

Gregg Wonderly

On Aug 15, 2012, at 9:13 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:

> Chris,
> 
> Until the writer thread has entered its sync block it can not write to shared. So if the reader thread sees shared as non-null then the write must have happened and the sync block must have (at least) been entered.
> 
> Of course it is not guaranteed that the reader thread will see a non-null value of shared.
> 
> David
> 
>> -----Original Message-----
>> From: Chris Povirk [mailto:cpovirk at google.com]
>> Sent: Thursday, 16 August 2012 12:03 PM
>> To: dholmes at ieee.org
>> Cc: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>> 
>> 
>>>>> local = new Vector();
>>>>> synchronized (local) {}
>>>>> shared = local;
>>>> 
>>>> construction happens before synchronized block
>>>> synchronized block happens before write
>>>> (=> construction happens before write)
>>> 
>>> Nope. construction happens-before end of synchronized block. 
>> write also happens-before end of synchronized block. roach-motel 
>> rules allow everything to be moved into the sync block.
>> 
>> True, I am being imprecise in treating the synchronized block as a
>> single action.
>>> Again use of object could be moved inside the sync-block. But 
>> sync-block here can not be entered until after other thread 
>> releases the lock. So that establishes the happens-before ordering:
>>> 
>>> everything in writer thread happens-before release of lock
>>> release of lock happens-before acquire of lock in second thread
>>> acquire of lock happens-before use of object
>>> => everything in writer thread happens-before use of object
>> 
>> I'm on board with this except for one part, which is apparently the
>> part where my thinking is too confusing for you to help me :)
>> 
>> "But sync-block here can not be entered until after other thread
>> releases the lock."
>> 
>> I agree that the threads can't be in the synchronized block at the
>> same time.  What I don't understand is what prevents the reader thread
>> from entering its block before the writer thread enters its block.
>> You give an explanation here:
>> 
>>> The above paragraph is confusing to me. The reader thread won't 
>> attempt to execute its sync block unless it sees the write to 
>> shared. The write to shared happens after the writer thread 
>> acquires the lock (and maybe after it releases it). So the reader 
>> will only attempt to acquire the lock once the writes have 
>> progressed to the point where shared was written, but it can't 
>> actually acquire the lock until all the writes are completed.
>> 
>> But does the mere fact that the reader thread sees the write to shared
>> establish a happens-before relationship between the read and the
>> write?  Surely it can't, or else it would be safe to publish the
>> object with no synchronized blocks at all... I think...?
>> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From hans.boehm at hp.com  Thu Aug 16 00:44:37 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu, 16 Aug 2012 04:44:37 +0000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>

The standard reference for the JMM problems is Sevcik and Aspinall, "On validity of program transformations in the Java Memory Model", ECOOP 2008.  I became convinced in a java memory model discussion a couple of years ago or so (also including Jaroslav Sevcik) that that's not the only problem, but it is a serious problem.

I'm unconvinced that removing the synchronization to prevent data races generally improves scalability in the normal sense.  Improving or removing coarser-grained synchronization clearly can.  On x86, fences in particular seem to be executed entirely locally; they add significant overhead at low core counts.  Based on limited experiments, they become increasingly insignificant as you reach other scaling limits, e.g. memory bandwidth.  This is consistent with the usual intuition that fences wait for store buffers to drain.  Even more limited experiments on POWER were, to my surprise, also largely consistent with that.  For a recent experiment I ran in support of a workshop submission, this even tends to be true for acquiring locks solely to avoid data races.  The difference between synchronized and racy performance DECREASED dramatically with the number of threads/cores.

This doesn't mean that synchronization to avoid data races is entirely free, but only that it's cost doesn't increase, and often decreases with scale.  Doug may well have run more careful experiments around this.

Hans

> -----Original Message-----
> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> Sent: Wednesday, August 15, 2012 2:19 PM
> To: Boehm, Hans
> Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
> dholmes at ieee.org
> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> 
> Well, I understand your point.
> 
> But this lead me to another interesting question -- why data races is so
> outlaw? Yes, I understand, it is hard to write correct code with them (by the
> way, can you give the link about errors in JMM spec about data race you've
> mention above?), but can we scale really well with sequentially consistent
> execution only? I mean, in large-scale distributed systems design weakening
> consistency often gives great performance benefits. AndwWhen I think
> about something like 786-cores (skip the brand) box, it seems for me there
> could be many chances to improve performance using racy code. Am I miss
> something here?
> 
> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> >>
> >> As far, as I can see, there is two directions. One is what
> >> "thread-safe" notation in it's commonly used form -- then applied
> >> only to methods, and not to initialization/publication -- is
> >> confusing, and there is little reason to exclude
> >> construction/publication from thread safety protocol by default. My
> >> point, among others, is that "immutable and thread safe" should be
> >> interpreted as "thread safe even for unsafe publishing". And this,
> >> for example, gives us the chance to remove volatile specification in
> >> File.path field we started from :)
> > It seems to me that there's a huge difference here.  Synchronization in the
> constructor only matters in the presence of other dubious programming
> practices:  Either a reference to the object has to escape before the
> constructor finishes, or the reference has to be communicated to another
> thread in a racy manner.  (And the former is a special case under control of
> the class itself.)  There are strong reasons to avoid both in the vast majority
> of code.  On the other hand, perfectly normal code will routinely rely on the
> thread-safety of non-constructor methods all the time.
> >
> >>
> >> Second direction is about construction/publication as specifically
> >> different from the methods. E.g. it even may have additional safety
> >> guarantee -- like "publication is always safe". I can see some
> >> reasons here, since constructor is the only one method, which is
> >> guaranteed to be called only once on object lifecycle, and so we,
> >> possible, can restrict some compiler/CPUs optimization in it with
> >> little influence on overall application performance -- but it throws
> >> away all troubles with unsafe publishing.
> > I think we're still generally using "unsafe publishing" to mean either of the
> two dubious practices I mentioned above, though here we're presumably
> talking about racy publication after the constructor completes.  The problem
> is that in general racy publication is already a really bad practice, because the
> user has to understand the ugly details of the Java memory model, which
> nobody really does.  Racy publication is a data race, and hence you can no
> longer reason in terms of sequential consistency, synchronization-free
> regions become nonatomic, and generally all our intuition about behavior of
> threads and reasoning about threads goes out the window, even if you can
> still reason about the integrity of your class.  There are one or two special
> cases, notably lazy initialization of an immutable object, where you might
> succeed in hiding all that mess behind a library API, but in general that's hard.
> So the question in my mind is whether you want to provide those added
> guarantees to support those one or two cases, or whether you want to limit
> those guarantees to situations, notably those involving final fields, where
> they're essential for the security model.  We currently have the latter.
> >
> > Hans
> >>
> >>
> >>
> >> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
> >> > Agreed.
> >> >
> >> > But, echoing David, I think, I'm not at all sure I see where this
> >> thread is going.  We've established that
> >> >
> >> > a) You can make a class safe against racy publication by
> >> synchronizing the constructor along with all other methods (or by
> >> using an immutable class with final fields).
> >> >
> >> > b) There are (rather brittle and obscure) use cases in which racy
> >> publication gives you better performance on architectures like ARM,
> >> though not x86, currently at the cost of confusing data race detectors.
> >> >
> >> > But to me it seems like taking advanatage of (b) is a fairly
> >> undesirable, though perhaps occasionally unavoidable, hack.  And I
> >> can't see why it would possibly be a win if you have to synchronize
> >> all method calls to make it work.
> >> >
> >> > Does anyone have a use case in mind where the whole picture we're
> >> discussing actually makes sense?  It might help to focus this
> >> discussion.
> >> >
> >> > Hans
> >> >
> >> >> -----Original Message-----
> >> >> From: concurrency-interest-bounces at cs.oswego.edu
> >> [mailto:concurrency-
> >> >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
> >> >> Sent: Wednesday, August 15, 2012 10:56 AM
> >> >> To: Yuval Shavit
> >> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> >> >> Subject: Re: [concurrency-interest] Double Checked Locking in
> >> OpenJDK
> >> >>
> >> >> I thought the conclusion of that thread is that synchronizing
> >> >> constructor has the desired merit - if all constructors and
> >> >> methods are synchronized, a non-creating thread won't observe the
> >> zero/partial
> >> >> state of the object, even if the object reference is published
> >> >> unsafely.
> >> >>
> >> >> (One guy, who shall remain nameless, muddied the water with some
> >> >> mistaken statements of weaker memory guarantee. He has been
> >> corrected)
> >> >>
> >> >> Zhong Yu
> >> >>
> >> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
> >> >> <yshavit at akiban.com>
> >> >> wrote:
> >> >> > There was a discussion here a few months ago about synchronizing
> >> >> > constructors -- I had asked why it's not allowed, and the
> >> discussion
> >> >> hit on
> >> >> > some of the similar points brought up in this thread.
> >> >> >
> >> >> > But to your point specifically, synchronizing a constructor (via
> >> >> > "synchronized(this) {...}" surrounding its body) still doesn't
> >> give
> >> >> you full
> >> >> > thread safety (even assuming immutability after the constructor
> >> >> > --
> >> >> but
> >> >> > without final fields). It ensures that a thread can observe the
> >> >> object
> >> >> > either fully constructed *or* with all its fields having their
> >> >> default
> >> >> > values. In other words, even if your constructor is synchronized
> >> on
> >> >> the same
> >> >> > object your getter is, a thread could observe a field as it was
> >> >> before the
> >> >> > constructor was invoked.
> >> >> >
> >> >> > http://markmail.org/message/mav53xzo4bqu7udw
> >> >> >
> >> >> >
> >> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
> >> >> <cheremin at gmail.com>
> >> >> > wrote:
> >> >> >>
> >> >> >> > The reason to keep them distinct is because in general the
> >> >> mechanisms
> >> >> >> > for
> >> >> >> > safe publication are external to the class, while those for
> >> >> >> > thread-safety are internal. It is only an edge case where use
> >> >> >> > of synchronized
> >> in
> >> >> a
> >> >> >> > constructor can achieve safe-publication.
> >> >> >>
> >> >> >> Well, actually I do not understand your point. If I use some
> >> >> >> kind
> >> of
> >> >> >> synchronization to make methods of my object thread-safe --
> >> >> >> can't
> >> I
> >> >> >> also apply same thing to constructor? For me, it makes the
> >> >> >> thing
> >> >> only
> >> >> >> clearer. Object can be thread-safe -- and it is totally thread
> >> safe.
> >> >> >> Object can require external synchronization for correct
> >> >> multithreaded
> >> >> >> use -- and it requires the sync for publishing and for usage
> >> also.
> >> >> >>
> >> >> >> From my point of view, the distinction you talking about is
> >> >> >> more historically reasoned. "Sync method if you want it to be
> >> >> >> thread-
> >> >> safe"
> >> >> >> is commonly learned mantra, but "take care of initialization
> >> also"
> >> >> is
> >> >> >> not so common. More information about it, more education, more
> >> >> >> different code samples with outlined "here is the dragons" will
> >> >> change
> >> >> >> the situation, I sure, it just have to be highlighted more often.
> >> >> >>
> >> >> >>
> >> >> >> > People have to recognize that sharing an object requires
> >> >> >> > shared
> >> >> mutable
> >> >> >> > state, and the number one tenet of concurrent programming is
> >> that
> >> >> access
> >> >> >> > to
> >> >> >> > shared mutable state has to be synchronized (in a general
> >> >> >> > sense
> >> >> not
> >> >> >> > specifically use of 'synchronized' keyword).
> >> >> >> >
> >> >> >> > Making every object safely publishable could be done, but for
> >> 99%
> >> >> of
> >> >> >> > objects
> >> >> >> > it would be a waste of effort. Programs without data races
> >> don't
> >> >> have
> >> >> >> > issues
> >> >> >> > with unsafe publication.
> >> >> >> >
> >> >> >> > David
> >> >> >> >
> >> >> >> > -----Original Message-----
> >> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
> >> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
> >> >> >> > Of
> >> >> Nathan
> >> >> >> > Reynolds
> >> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
> >> >> >> > To: concurrency-interest at cs.oswego.edu
> >> >> >> > Subject: Re: [concurrency-interest] Double Checked Locking in
> >> >> OpenJDK
> >> >> >> >
> >> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
> >> >> >> > publication)
> >> >> >> > when they should be combined in a sense.  Typically, when we
> >> say
> >> >> >> > thread-safe
> >> >> >> > we talk about the operations performed on the object after it
> >> was
> >> >> >> > constructed (and its contents are globally visible).
> >> >> >> > However,
> >> we
> >> >> need
> >> >> >> > to
> >> >> >> > consider that executing the constructor is modifying the
> >> >> >> > state
> >> of
> >> >> the
> >> >> >> > object.  It requires the same mechanisms that the rest of the
> >> >> class uses
> >> >> >> > to
> >> >> >> > ensure thread-safety.  Even though, there is only 1 thread
> >> >> executing the
> >> >> >> > constructor, a proper releasing of a lock or some other
> >> happens-
> >> >> before
> >> >> >> > construct is required to ensure that the memory updates by
> >> >> >> > the
> >> >> thread
> >> >> >> > are
> >> >> >> > made globally visible before the object is accessed by
> >> >> >> > another
> >> >> thread.
> >> >> >> > This
> >> >> >> > is what we are calling safe publication.  So, safe
> >> >> >> > publication
> >> is
> >> >> a
> >> >> >> > subset
> >> >> >> > of thread-safety except it is limited to what happens after
> >> >> >> > the constructor is called and before the object is used by
> >> >> >> > multiple threads.
> >> >> >> >
> >> >> >> > A beautifully-written class can be thread-safe with respect
> >> >> >> > to
> >> >> calling
> >> >> >> > its
> >> >> >> > member methods but not thread-safe with respect to calling
> >> >> >> > its constructor.
> >> >> >> > It is this latter case that many stumble upon because they
> >> think
> >> >> that
> >> >> >> > constructors are inherently thread-safe because they are
> >> executed
> >> >> >> > single-threadedly.  What they fail to realize is that the
> >> >> execution of a
> >> >> >> > constructor can overlap with the execution of other code from
> >> the
> >> >> view
> >> >> >> > point
> >> >> >> > of what is happening in memory.  This same problem applies to
> >> more
> >> >> rare
> >> >> >> > case
> >> >> >> > of regular methods which can be proven to execute in a single
> >> >> thread but
> >> >> >> > don't use synchronization before multiple threads start
> >> accessing
> >> >> the
> >> >> >> > shared
> >> >> >> > data.
> >> >> >> >
> >> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> >> >> 602.333.9091
> >> >> >> > Oracle PSR Engineering | Server Technology On 8/13/2012 4:08
> >> >> >> > PM, David Holmes wrote:
> >> >> >> >
> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >
> >> >> >> > For me it is confusing: java has only one way to have really
> >> >> immutable
> >> >> >> > object, and this way also gives you a total thread safety
> >> >> >> > even
> >> for
> >> >> >> > data race based publication. But then docs refer object as
> >> >> "immutable
> >> >> >> > and thread-safe" -- we still can't assume it to be really
> >> thread-
> >> >> safe?
> >> >> >> >
> >> >> >> > It is better/simpler to isolate the notion of thread-safety
> >> >> >> > and
> >> >> safe
> >> >> >> > publication. Thread-safety comes into play after you have
> >> safely
> >> >> shared
> >> >> >> > an
> >> >> >> > object. The means by which you safely share an object is
> >> >> orthogonal to
> >> >> >> > how
> >> >> >> > the object itself is made thread-safe.
> >> >> >> >
> >> >> >> > The means by which an object is shared has to involve shared
> >> >> mutable
> >> >> >> > state,
> >> >> >> > and use of shared mutable state always needs some form of
> >> >> >> > synchronization (either implicit eg due to static
> >> >> >> > initialization; or explicit
> >> by
> >> >> using
> >> >> >> > volatile or synchronized getter/setter methods).
> >> >> >> >
> >> >> >> > David
> >> >> >> > -----
> >> >> >> >
> >> >> >> > It's a pity, especially because true immutability gives us
> >> >> >> > some chances of performance optimization. As in this case --
> >> >> >> > we do
> >> not
> >> >> >> > really need .path to be volatile here, if we would assume
> >> >> >> > Path
> >> to
> >> >> be
> >> >> >> > truly immutable. volatility here required only for ensuring
> >> safe
> >> >> >> > publishing.
> >> >> >> >
> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >
> >> >> >> > Ruslan Cheremin writes:>
> >> >> >> >
> >> >> >> > But is there a way to define "safe for data race publishing"?
> >> >> >> > I
> >> as
> >> >> >> > far, as I remember, "immutable and thread-safe" is standard
> >> mantra
> >> >> in
> >> >> >> > JDK javadocs for totally safe objects. j.l.String has same
> >> mantra
> >> >> --
> >> >> >> > and it is safe for any way of publishing. Does you mean, I
> >> should
> >> >> >> > explicitly add "safe even for publishing via data race" in
> >> docs?
> >> >> But I
> >> >> >> > can't remember any such phrase in JDK docs.
> >> >> >> >
> >> >> >> > I don't recall anything in the JDK docs that mention being
> >> >> >> >
> >> >> >> > "totally safe"
> >> >> >> >
> >> >> >> > regardless of publication mechanism. Some classes, eg String,
> >> have
> >> >> been
> >> >> >> > defined such that they do have that property (for security
> >> >> reasons). In
> >> >> >> > general neither "thread-safe" nor "immutable" imply
> >> >> >> > safe-for-unsynchronized-publication.
> >> >> >> >
> >> >> >> > Java Concurrency In Practice (jcip.net) does define
> >> >> >> > additional
> >> >> potential
> >> >> >> > annotations, where @Immutable would indeed capture the
> >> requirement
> >> >> of
> >> >> >> > safe-for-unsynchronized-publication.
> >> >> >> >
> >> >> >> > David
> >> >> >> > -----
> >> >> >> >
> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >
> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >
> >> >> >> > Well, Path javadoc explicitly says "immutable and safe for
> >> >> >> > multithreaded use". Although it is not strictly defined in
> >> >> >> > java
> >> >> what
> >> >> >> > exactly means "safe for multithreaded use" -- does it mean
> >> >> >> > safe
> >> >> for
> >> >> >> > publishing via data race, among others? -- I suppose, it
> >> >> >> >
> >> >> >> > should be. Am
> >> >> >> >
> >> >> >> > I wrong here?
> >> >> >> >
> >> >> >> > "safe for multi-threaded use" does not generally imply that
> >> >> >> > it
> >> >> >> >
> >> >> >> > is safe to
> >> >> >> >
> >> >> >> > publish instances without synchronization of some form.
> >> >> >> >
> >> >> >> > David
> >> >> >> > -----
> >> >> >> >
> >> >> >> > From other side, File.toPath javadoc explicitly says what
> >> >> "returned
> >> >> >> > instance must be the same for every invocation", so sync
> >> >> >> > block
> >> is
> >> >> >> > required here for mutual exclusion on initialization phase.
> >> >> Without
> >> >> >> > this requirement it is also safe to live without sync block,
> >> >> afaik.
> >> >> >> >
> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >
> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >
> >> >> >> > First of all, Path is immutable, so DCL is safe here even
> >> without
> >> >> >> > volatile. Volatile here is not required from my point of view.
> >> >> >> >
> >> >> >> > Without the volatile the Path implementation (Path is an
> >> >> >> >
> >> >> >> > interface) must be
> >> >> >> >
> >> >> >> > such that an instance of Path can be safely published without
> >> >> >> >
> >> >> >> > any additional
> >> >> >> >
> >> >> >> > forms of synchronization. Immutability does not in itself
> >> >> >> >
> >> >> >> > ensure that. You
> >> >> >> >
> >> >> >> > would have to examine the actual implementation class.
> >> >> >> >
> >> >> >> > David Holmes
> >> >> >> > ------------
> >> >> >> >
> >> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >> >
> >> >> >> > Hi Richard,
> >> >> >> >
> >> >> >> > The variable "filePath" is volatile, so the double-checked
> >> >> >> >
> >> >> >> > locking is correct in this case. It would have been a bug
> >> >> >> >
> >> >> >> > prior to Java 5.
> >> >> >> >
> >> >> >> > Best regards,
> >> >> >> >
> >> >> >> > Dmitry Vyazelenko
> >> >> >> >
> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >> >
> >> >> >> > <richard.warburton at gmail.com> wrote:
> >> >> >> >
> >> >> >> > Hello,
> >> >> >> >
> >> >> >> > The current implementation of java.io.File::toPath [0]
> >> >> >> >
> >> >> >> > appears to be
> >> >> >> >
> >> >> >> > using the double checked locking pattern:
> >> >> >> >
> >> >> >> >     public Path toPath() {
> >> >> >> >         Path result = filePath;
> >> >> >> >         if (result == null) {
> >> >> >> >             synchronized (this) {
> >> >> >> >                 result = filePath;
> >> >> >> >                 if (result == null) {
> >> >> >> >                     result =
> >> >> >> >
> >> >> >> > FileSystems.getDefault().getPath(path);
> >> >> >> >
> >> >> >> >                     filePath = result;
> >> >> >> >                 }
> >> >> >> >             }
> >> >> >> >         }
> >> >> >> >         return result;
> >> >> >> >     }
> >> >> >> >
> >> >> >> > I was going to report the bug, but I'm a little
> >> >> >> >
> >> >> >> > uncertain of the
> >> >> >> >
> >> >> >> > interaction between the local variable 'result' and DCL
> >> >> >> >
> >> >> >> > since I've
> >> >> >> >
> >> >> >> > previously only seen the checking condition on the
> >> >> >> >
> >> >> >> > shared field
> >> >> >> >
> >> >> >> > itself.  Can someone here either confirm that its a bug or
> >> >> >> >
> >> >> >> > explain how
> >> >> >> >
> >> >> >> > the 'result' variable is fixing things?
> >> >> >> >
> >> >> >> > regards,
> >> >> >> >
> >> >> >> >  Richard
> >> >> >> >
> >> >> >> > [0] See the end of
> >> >> >> >
> >> >> >> >
> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >> >
> >> >> >> > ses/java/io/File.java
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> >
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> _______________________________________________
> >> >> >> Concurrency-interest mailing list
> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> >
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> _______________________________________________
> >> >> Concurrency-interest mailing list
> >> >> Concurrency-interest at cs.oswego.edu
> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From zhong.j.yu at gmail.com  Thu Aug 16 02:10:33 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Thu, 16 Aug 2012 01:10:33 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
Message-ID: <CACuKZqEuJTpGOcTnjdLWRQXwTMg0snqEkpZ4S9Xg1_Kj440bUQ@mail.gmail.com>

We are probably discussing two very different types of programs that
require different considerations:

Type 1: many writes, many reads; the result of a read affects next write.

It's best to be data race free here, where all writes and reads are on
a single hb() chain, so that state change can be reasoned. Even 1
stray write will create great havoc and make it impossible to reason.

Execution cost can be dominated by writes.

Type 2: one write, many reads.

Even if there's data race, it is still possible to reason the program,
since it's inherently much*much simpler. Yes, any read may or may not
see the write, that's just 2 choices, there's no exponential
explosion.

The write is negligible in execution cost.

Given the tools we have in JMM, data race is acceptable to reduce read
cost in this program.

Actually in the case of lazy initialization with final fields, it's
dubious whether we should still brand it as data race - the final
field semantics practically establishes a hb(w,r)-ish relationship.

Zhong Yu

On Wed, Aug 15, 2012 at 11:44 PM, Boehm, Hans <hans.boehm at hp.com> wrote:
> The standard reference for the JMM problems is Sevcik and Aspinall, "On validity of program transformations in the Java Memory Model", ECOOP 2008.  I became convinced in a java memory model discussion a couple of years ago or so (also including Jaroslav Sevcik) that that's not the only problem, but it is a serious problem.
>
> I'm unconvinced that removing the synchronization to prevent data races generally improves scalability in the normal sense.  Improving or removing coarser-grained synchronization clearly can.  On x86, fences in particular seem to be executed entirely locally; they add significant overhead at low core counts.  Based on limited experiments, they become increasingly insignificant as you reach other scaling limits, e.g. memory bandwidth.  This is consistent with the usual intuition that fences wait for store buffers to drain.  Even more limited experiments on POWER were, to my surprise, also largely consistent with that.  For a recent experiment I ran in support of a workshop submission, this even tends to be true for acquiring locks solely to avoid data races.  The difference between synchronized and racy performance DECREASED dramatically with the number of threads/cores.
>
> This doesn't mean that synchronization to avoid data races is entirely free, but only that it's cost doesn't increase, and often decreases with scale.  Doug may well have run more careful experiments around this.
>
> Hans
>
>> -----Original Message-----
>> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
>> Sent: Wednesday, August 15, 2012 2:19 PM
>> To: Boehm, Hans
>> Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
>> dholmes at ieee.org
>> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>>
>> Well, I understand your point.
>>
>> But this lead me to another interesting question -- why data races is so
>> outlaw? Yes, I understand, it is hard to write correct code with them (by the
>> way, can you give the link about errors in JMM spec about data race you've
>> mention above?), but can we scale really well with sequentially consistent
>> execution only? I mean, in large-scale distributed systems design weakening
>> consistency often gives great performance benefits. AndwWhen I think
>> about something like 786-cores (skip the brand) box, it seems for me there
>> could be many chances to improve performance using racy code. Am I miss
>> something here?
>>
>> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
>> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
>> >>
>> >> As far, as I can see, there is two directions. One is what
>> >> "thread-safe" notation in it's commonly used form -- then applied
>> >> only to methods, and not to initialization/publication -- is
>> >> confusing, and there is little reason to exclude
>> >> construction/publication from thread safety protocol by default. My
>> >> point, among others, is that "immutable and thread safe" should be
>> >> interpreted as "thread safe even for unsafe publishing". And this,
>> >> for example, gives us the chance to remove volatile specification in
>> >> File.path field we started from :)
>> > It seems to me that there's a huge difference here.  Synchronization in the
>> constructor only matters in the presence of other dubious programming
>> practices:  Either a reference to the object has to escape before the
>> constructor finishes, or the reference has to be communicated to another
>> thread in a racy manner.  (And the former is a special case under control of
>> the class itself.)  There are strong reasons to avoid both in the vast majority
>> of code.  On the other hand, perfectly normal code will routinely rely on the
>> thread-safety of non-constructor methods all the time.
>> >
>> >>
>> >> Second direction is about construction/publication as specifically
>> >> different from the methods. E.g. it even may have additional safety
>> >> guarantee -- like "publication is always safe". I can see some
>> >> reasons here, since constructor is the only one method, which is
>> >> guaranteed to be called only once on object lifecycle, and so we,
>> >> possible, can restrict some compiler/CPUs optimization in it with
>> >> little influence on overall application performance -- but it throws
>> >> away all troubles with unsafe publishing.
>> > I think we're still generally using "unsafe publishing" to mean either of the
>> two dubious practices I mentioned above, though here we're presumably
>> talking about racy publication after the constructor completes.  The problem
>> is that in general racy publication is already a really bad practice, because the
>> user has to understand the ugly details of the Java memory model, which
>> nobody really does.  Racy publication is a data race, and hence you can no
>> longer reason in terms of sequential consistency, synchronization-free
>> regions become nonatomic, and generally all our intuition about behavior of
>> threads and reasoning about threads goes out the window, even if you can
>> still reason about the integrity of your class.  There are one or two special
>> cases, notably lazy initialization of an immutable object, where you might
>> succeed in hiding all that mess behind a library API, but in general that's hard.
>> So the question in my mind is whether you want to provide those added
>> guarantees to support those one or two cases, or whether you want to limit
>> those guarantees to situations, notably those involving final fields, where
>> they're essential for the security model.  We currently have the latter.
>> >
>> > Hans
>> >>
>> >>
>> >>
>> >> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
>> >> > Agreed.
>> >> >
>> >> > But, echoing David, I think, I'm not at all sure I see where this
>> >> thread is going.  We've established that
>> >> >
>> >> > a) You can make a class safe against racy publication by
>> >> synchronizing the constructor along with all other methods (or by
>> >> using an immutable class with final fields).
>> >> >
>> >> > b) There are (rather brittle and obscure) use cases in which racy
>> >> publication gives you better performance on architectures like ARM,
>> >> though not x86, currently at the cost of confusing data race detectors.
>> >> >
>> >> > But to me it seems like taking advanatage of (b) is a fairly
>> >> undesirable, though perhaps occasionally unavoidable, hack.  And I
>> >> can't see why it would possibly be a win if you have to synchronize
>> >> all method calls to make it work.
>> >> >
>> >> > Does anyone have a use case in mind where the whole picture we're
>> >> discussing actually makes sense?  It might help to focus this
>> >> discussion.
>> >> >
>> >> > Hans
>> >> >
>> >> >> -----Original Message-----
>> >> >> From: concurrency-interest-bounces at cs.oswego.edu
>> >> [mailto:concurrency-
>> >> >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
>> >> >> Sent: Wednesday, August 15, 2012 10:56 AM
>> >> >> To: Yuval Shavit
>> >> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
>> >> >> Subject: Re: [concurrency-interest] Double Checked Locking in
>> >> OpenJDK
>> >> >>
>> >> >> I thought the conclusion of that thread is that synchronizing
>> >> >> constructor has the desired merit - if all constructors and
>> >> >> methods are synchronized, a non-creating thread won't observe the
>> >> zero/partial
>> >> >> state of the object, even if the object reference is published
>> >> >> unsafely.
>> >> >>
>> >> >> (One guy, who shall remain nameless, muddied the water with some
>> >> >> mistaken statements of weaker memory guarantee. He has been
>> >> corrected)
>> >> >>
>> >> >> Zhong Yu
>> >> >>
>> >> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
>> >> >> <yshavit at akiban.com>
>> >> >> wrote:
>> >> >> > There was a discussion here a few months ago about synchronizing
>> >> >> > constructors -- I had asked why it's not allowed, and the
>> >> discussion
>> >> >> hit on
>> >> >> > some of the similar points brought up in this thread.
>> >> >> >
>> >> >> > But to your point specifically, synchronizing a constructor (via
>> >> >> > "synchronized(this) {...}" surrounding its body) still doesn't
>> >> give
>> >> >> you full
>> >> >> > thread safety (even assuming immutability after the constructor
>> >> >> > --
>> >> >> but
>> >> >> > without final fields). It ensures that a thread can observe the
>> >> >> object
>> >> >> > either fully constructed *or* with all its fields having their
>> >> >> default
>> >> >> > values. In other words, even if your constructor is synchronized
>> >> on
>> >> >> the same
>> >> >> > object your getter is, a thread could observe a field as it was
>> >> >> before the
>> >> >> > constructor was invoked.
>> >> >> >
>> >> >> > http://markmail.org/message/mav53xzo4bqu7udw
>> >> >> >
>> >> >> >
>> >> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
>> >> >> <cheremin at gmail.com>
>> >> >> > wrote:
>> >> >> >>
>> >> >> >> > The reason to keep them distinct is because in general the
>> >> >> mechanisms
>> >> >> >> > for
>> >> >> >> > safe publication are external to the class, while those for
>> >> >> >> > thread-safety are internal. It is only an edge case where use
>> >> >> >> > of synchronized
>> >> in
>> >> >> a
>> >> >> >> > constructor can achieve safe-publication.
>> >> >> >>
>> >> >> >> Well, actually I do not understand your point. If I use some
>> >> >> >> kind
>> >> of
>> >> >> >> synchronization to make methods of my object thread-safe --
>> >> >> >> can't
>> >> I
>> >> >> >> also apply same thing to constructor? For me, it makes the
>> >> >> >> thing
>> >> >> only
>> >> >> >> clearer. Object can be thread-safe -- and it is totally thread
>> >> safe.
>> >> >> >> Object can require external synchronization for correct
>> >> >> multithreaded
>> >> >> >> use -- and it requires the sync for publishing and for usage
>> >> also.
>> >> >> >>
>> >> >> >> From my point of view, the distinction you talking about is
>> >> >> >> more historically reasoned. "Sync method if you want it to be
>> >> >> >> thread-
>> >> >> safe"
>> >> >> >> is commonly learned mantra, but "take care of initialization
>> >> also"
>> >> >> is
>> >> >> >> not so common. More information about it, more education, more
>> >> >> >> different code samples with outlined "here is the dragons" will
>> >> >> change
>> >> >> >> the situation, I sure, it just have to be highlighted more often.
>> >> >> >>
>> >> >> >>
>> >> >> >> > People have to recognize that sharing an object requires
>> >> >> >> > shared
>> >> >> mutable
>> >> >> >> > state, and the number one tenet of concurrent programming is
>> >> that
>> >> >> access
>> >> >> >> > to
>> >> >> >> > shared mutable state has to be synchronized (in a general
>> >> >> >> > sense
>> >> >> not
>> >> >> >> > specifically use of 'synchronized' keyword).
>> >> >> >> >
>> >> >> >> > Making every object safely publishable could be done, but for
>> >> 99%
>> >> >> of
>> >> >> >> > objects
>> >> >> >> > it would be a waste of effort. Programs without data races
>> >> don't
>> >> >> have
>> >> >> >> > issues
>> >> >> >> > with unsafe publication.
>> >> >> >> >
>> >> >> >> > David
>> >> >> >> >
>> >> >> >> > -----Original Message-----
>> >> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
>> >> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
>> >> >> >> > Of
>> >> >> Nathan
>> >> >> >> > Reynolds
>> >> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
>> >> >> >> > To: concurrency-interest at cs.oswego.edu
>> >> >> >> > Subject: Re: [concurrency-interest] Double Checked Locking in
>> >> >> OpenJDK
>> >> >> >> >
>> >> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
>> >> >> >> > publication)
>> >> >> >> > when they should be combined in a sense.  Typically, when we
>> >> say
>> >> >> >> > thread-safe
>> >> >> >> > we talk about the operations performed on the object after it
>> >> was
>> >> >> >> > constructed (and its contents are globally visible).
>> >> >> >> > However,
>> >> we
>> >> >> need
>> >> >> >> > to
>> >> >> >> > consider that executing the constructor is modifying the
>> >> >> >> > state
>> >> of
>> >> >> the
>> >> >> >> > object.  It requires the same mechanisms that the rest of the
>> >> >> class uses
>> >> >> >> > to
>> >> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>> >> >> executing the
>> >> >> >> > constructor, a proper releasing of a lock or some other
>> >> happens-
>> >> >> before
>> >> >> >> > construct is required to ensure that the memory updates by
>> >> >> >> > the
>> >> >> thread
>> >> >> >> > are
>> >> >> >> > made globally visible before the object is accessed by
>> >> >> >> > another
>> >> >> thread.
>> >> >> >> > This
>> >> >> >> > is what we are calling safe publication.  So, safe
>> >> >> >> > publication
>> >> is
>> >> >> a
>> >> >> >> > subset
>> >> >> >> > of thread-safety except it is limited to what happens after
>> >> >> >> > the constructor is called and before the object is used by
>> >> >> >> > multiple threads.
>> >> >> >> >
>> >> >> >> > A beautifully-written class can be thread-safe with respect
>> >> >> >> > to
>> >> >> calling
>> >> >> >> > its
>> >> >> >> > member methods but not thread-safe with respect to calling
>> >> >> >> > its constructor.
>> >> >> >> > It is this latter case that many stumble upon because they
>> >> think
>> >> >> that
>> >> >> >> > constructors are inherently thread-safe because they are
>> >> executed
>> >> >> >> > single-threadedly.  What they fail to realize is that the
>> >> >> execution of a
>> >> >> >> > constructor can overlap with the execution of other code from
>> >> the
>> >> >> view
>> >> >> >> > point
>> >> >> >> > of what is happening in memory.  This same problem applies to
>> >> more
>> >> >> rare
>> >> >> >> > case
>> >> >> >> > of regular methods which can be proven to execute in a single
>> >> >> thread but
>> >> >> >> > don't use synchronization before multiple threads start
>> >> accessing
>> >> >> the
>> >> >> >> > shared
>> >> >> >> > data.
>> >> >> >> >
>> >> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>> >> >> 602.333.9091
>> >> >> >> > Oracle PSR Engineering | Server Technology On 8/13/2012 4:08
>> >> >> >> > PM, David Holmes wrote:
>> >> >> >> >
>> >> >> >> > Ruslan Cheremin writes:
>> >> >> >> >
>> >> >> >> > For me it is confusing: java has only one way to have really
>> >> >> immutable
>> >> >> >> > object, and this way also gives you a total thread safety
>> >> >> >> > even
>> >> for
>> >> >> >> > data race based publication. But then docs refer object as
>> >> >> "immutable
>> >> >> >> > and thread-safe" -- we still can't assume it to be really
>> >> thread-
>> >> >> safe?
>> >> >> >> >
>> >> >> >> > It is better/simpler to isolate the notion of thread-safety
>> >> >> >> > and
>> >> >> safe
>> >> >> >> > publication. Thread-safety comes into play after you have
>> >> safely
>> >> >> shared
>> >> >> >> > an
>> >> >> >> > object. The means by which you safely share an object is
>> >> >> orthogonal to
>> >> >> >> > how
>> >> >> >> > the object itself is made thread-safe.
>> >> >> >> >
>> >> >> >> > The means by which an object is shared has to involve shared
>> >> >> mutable
>> >> >> >> > state,
>> >> >> >> > and use of shared mutable state always needs some form of
>> >> >> >> > synchronization (either implicit eg due to static
>> >> >> >> > initialization; or explicit
>> >> by
>> >> >> using
>> >> >> >> > volatile or synchronized getter/setter methods).
>> >> >> >> >
>> >> >> >> > David
>> >> >> >> > -----
>> >> >> >> >
>> >> >> >> > It's a pity, especially because true immutability gives us
>> >> >> >> > some chances of performance optimization. As in this case --
>> >> >> >> > we do
>> >> not
>> >> >> >> > really need .path to be volatile here, if we would assume
>> >> >> >> > Path
>> >> to
>> >> >> be
>> >> >> >> > truly immutable. volatility here required only for ensuring
>> >> safe
>> >> >> >> > publishing.
>> >> >> >> >
>> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >> >
>> >> >> >> > Ruslan Cheremin writes:>
>> >> >> >> >
>> >> >> >> > But is there a way to define "safe for data race publishing"?
>> >> >> >> > I
>> >> as
>> >> >> >> > far, as I remember, "immutable and thread-safe" is standard
>> >> mantra
>> >> >> in
>> >> >> >> > JDK javadocs for totally safe objects. j.l.String has same
>> >> mantra
>> >> >> --
>> >> >> >> > and it is safe for any way of publishing. Does you mean, I
>> >> should
>> >> >> >> > explicitly add "safe even for publishing via data race" in
>> >> docs?
>> >> >> But I
>> >> >> >> > can't remember any such phrase in JDK docs.
>> >> >> >> >
>> >> >> >> > I don't recall anything in the JDK docs that mention being
>> >> >> >> >
>> >> >> >> > "totally safe"
>> >> >> >> >
>> >> >> >> > regardless of publication mechanism. Some classes, eg String,
>> >> have
>> >> >> been
>> >> >> >> > defined such that they do have that property (for security
>> >> >> reasons). In
>> >> >> >> > general neither "thread-safe" nor "immutable" imply
>> >> >> >> > safe-for-unsynchronized-publication.
>> >> >> >> >
>> >> >> >> > Java Concurrency In Practice (jcip.net) does define
>> >> >> >> > additional
>> >> >> potential
>> >> >> >> > annotations, where @Immutable would indeed capture the
>> >> requirement
>> >> >> of
>> >> >> >> > safe-for-unsynchronized-publication.
>> >> >> >> >
>> >> >> >> > David
>> >> >> >> > -----
>> >> >> >> >
>> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >> >
>> >> >> >> > Ruslan Cheremin writes:
>> >> >> >> >
>> >> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>> >> >> >> > multithreaded use". Although it is not strictly defined in
>> >> >> >> > java
>> >> >> what
>> >> >> >> > exactly means "safe for multithreaded use" -- does it mean
>> >> >> >> > safe
>> >> >> for
>> >> >> >> > publishing via data race, among others? -- I suppose, it
>> >> >> >> >
>> >> >> >> > should be. Am
>> >> >> >> >
>> >> >> >> > I wrong here?
>> >> >> >> >
>> >> >> >> > "safe for multi-threaded use" does not generally imply that
>> >> >> >> > it
>> >> >> >> >
>> >> >> >> > is safe to
>> >> >> >> >
>> >> >> >> > publish instances without synchronization of some form.
>> >> >> >> >
>> >> >> >> > David
>> >> >> >> > -----
>> >> >> >> >
>> >> >> >> > From other side, File.toPath javadoc explicitly says what
>> >> >> "returned
>> >> >> >> > instance must be the same for every invocation", so sync
>> >> >> >> > block
>> >> is
>> >> >> >> > required here for mutual exclusion on initialization phase.
>> >> >> Without
>> >> >> >> > this requirement it is also safe to live without sync block,
>> >> >> afaik.
>> >> >> >> >
>> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >> >
>> >> >> >> > Ruslan Cheremin writes:
>> >> >> >> >
>> >> >> >> > First of all, Path is immutable, so DCL is safe here even
>> >> without
>> >> >> >> > volatile. Volatile here is not required from my point of view.
>> >> >> >> >
>> >> >> >> > Without the volatile the Path implementation (Path is an
>> >> >> >> >
>> >> >> >> > interface) must be
>> >> >> >> >
>> >> >> >> > such that an instance of Path can be safely published without
>> >> >> >> >
>> >> >> >> > any additional
>> >> >> >> >
>> >> >> >> > forms of synchronization. Immutability does not in itself
>> >> >> >> >
>> >> >> >> > ensure that. You
>> >> >> >> >
>> >> >> >> > would have to examine the actual implementation class.
>> >> >> >> >
>> >> >> >> > David Holmes
>> >> >> >> > ------------
>> >> >> >> >
>> >> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> >> >> >
>> >> >> >> > Hi Richard,
>> >> >> >> >
>> >> >> >> > The variable "filePath" is volatile, so the double-checked
>> >> >> >> >
>> >> >> >> > locking is correct in this case. It would have been a bug
>> >> >> >> >
>> >> >> >> > prior to Java 5.
>> >> >> >> >
>> >> >> >> > Best regards,
>> >> >> >> >
>> >> >> >> > Dmitry Vyazelenko
>> >> >> >> >
>> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >> >> >
>> >> >> >> > <richard.warburton at gmail.com> wrote:
>> >> >> >> >
>> >> >> >> > Hello,
>> >> >> >> >
>> >> >> >> > The current implementation of java.io.File::toPath [0]
>> >> >> >> >
>> >> >> >> > appears to be
>> >> >> >> >
>> >> >> >> > using the double checked locking pattern:
>> >> >> >> >
>> >> >> >> >     public Path toPath() {
>> >> >> >> >         Path result = filePath;
>> >> >> >> >         if (result == null) {
>> >> >> >> >             synchronized (this) {
>> >> >> >> >                 result = filePath;
>> >> >> >> >                 if (result == null) {
>> >> >> >> >                     result =
>> >> >> >> >
>> >> >> >> > FileSystems.getDefault().getPath(path);
>> >> >> >> >
>> >> >> >> >                     filePath = result;
>> >> >> >> >                 }
>> >> >> >> >             }
>> >> >> >> >         }
>> >> >> >> >         return result;
>> >> >> >> >     }
>> >> >> >> >
>> >> >> >> > I was going to report the bug, but I'm a little
>> >> >> >> >
>> >> >> >> > uncertain of the
>> >> >> >> >
>> >> >> >> > interaction between the local variable 'result' and DCL
>> >> >> >> >
>> >> >> >> > since I've
>> >> >> >> >
>> >> >> >> > previously only seen the checking condition on the
>> >> >> >> >
>> >> >> >> > shared field
>> >> >> >> >
>> >> >> >> > itself.  Can someone here either confirm that its a bug or
>> >> >> >> >
>> >> >> >> > explain how
>> >> >> >> >
>> >> >> >> > the 'result' variable is fixing things?
>> >> >> >> >
>> >> >> >> > regards,
>> >> >> >> >
>> >> >> >> >  Richard
>> >> >> >> >
>> >> >> >> > [0] See the end of
>> >> >> >> >
>> >> >> >> >
>> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> >> >> >
>> >> >> >> > ses/java/io/File.java
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> >
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> _______________________________________________
>> >> >> >> Concurrency-interest mailing list
>> >> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> >
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> _______________________________________________
>> >> >> Concurrency-interest mailing list
>> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From dl at cs.oswego.edu  Thu Aug 16 06:25:00 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 16 Aug 2012 06:25:00 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CACuKZqEuJTpGOcTnjdLWRQXwTMg0snqEkpZ4S9Xg1_Kj440bUQ@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
	<CACuKZqEuJTpGOcTnjdLWRQXwTMg0snqEkpZ4S9Xg1_Kj440bUQ@mail.gmail.com>
Message-ID: <502CCA7C.7090504@cs.oswego.edu>

On 08/16/12 02:10, Zhong Yu wrote:
> We are probably discussing two very different types of programs that require
> different considerations:

There are *many* cases, some of which have more efficient solutions
than others. You are not likely to find too many simple slogans
beyond:

1. When possible, use design patterns that allow
java.util.concurrent (and/or other libraries/frameworks) to do
all the work for you in ensuring correctness and efficiency
without you dealing with it at all. (Simple examples include
Producer/Consumers and registries based on ConcurrentHashMaps.)

2. Otherwise, when possible, keep objects/data isolated within
threads/tasks.

3. Otherwise, when possible, stay within the bounds of simple
idioms including: final fields for immutable data; AtomicX's
(with compareAndSet) for reliably updatable single variables,
latches/phasers for barriers, etc.

4. Use locks (either library-based or builtin) for most
everything else.

There are and always will be cases that fall outside these.
Concurrent/parallel programming is at least as diverse as
any other aspect of programming, and just about any
style/approach can be made to work great, although some
with a lot more care and opportunity for error than others.

> On Wed, Aug 15, 2012 at 11:44 PM, Boehm, Hans<hans.boehm at hp.com>  wrote:

>> This doesn't mean that synchronization to avoid data races is entirely
>> free, but only that it's cost doesn't increase, and often decreases with
>> scale.  Doug may well have run more careful experiments around this.

Right; see above. It's hard to generalize beyond the observation
that, with sufficiently fine-grained control, sync is rarely the
main bottleneck, mainly because efficient combinations of immutability,
publication idioms, CAS, blocking sync, etc become available.
But that over-reliance on coarse-grained locking is a common
performance/scalability problem in Java programs.

-Doug

From vitalyd at gmail.com  Thu Aug 16 07:51:07 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 16 Aug 2012 07:51:07 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
Message-ID: <CAHjP37ET3jg5OjdXw8SDfv39HEqsjqG-N8w5DW9VtTSbkrCeeQ@mail.gmail.com>

Hans, your point about memory bandwidth being an issue on systems with very
large core counts is a very important one to keep in mind.  As I mentioned
earlier, even ordinary stores (i.e. sharing) becomes a big scalability
issue.  Dave Dice had a blog post some time back comparing performance of
sharing via CAS vs ordinary stores (I think on a large Niagara machine) and
they both fell off a cliff with similar numbers.  CAS performance seems to
be improving with almost every new Intel (maybe others) arch, so
scalability issues start boiling down to general mem bandwidth.

At this point, one needs to start ensuring that they minimize sharing
altogether, specifically many writers, and other low level things start
coming into play as well (e.g. gc/allocator being NUMA aware).

Sent from my phone
On Aug 16, 2012 12:50 AM, "Boehm, Hans" <hans.boehm at hp.com> wrote:

> The standard reference for the JMM problems is Sevcik and Aspinall, "On
> validity of program transformations in the Java Memory Model", ECOOP 2008.
>  I became convinced in a java memory model discussion a couple of years ago
> or so (also including Jaroslav Sevcik) that that's not the only problem,
> but it is a serious problem.
>
> I'm unconvinced that removing the synchronization to prevent data races
> generally improves scalability in the normal sense.  Improving or removing
> coarser-grained synchronization clearly can.  On x86, fences in particular
> seem to be executed entirely locally; they add significant overhead at low
> core counts.  Based on limited experiments, they become increasingly
> insignificant as you reach other scaling limits, e.g. memory bandwidth.
>  This is consistent with the usual intuition that fences wait for store
> buffers to drain.  Even more limited experiments on POWER were, to my
> surprise, also largely consistent with that.  For a recent experiment I ran
> in support of a workshop submission, this even tends to be true for
> acquiring locks solely to avoid data races.  The difference between
> synchronized and racy performance DECREASED dramatically with the number of
> threads/cores.
>
> This doesn't mean that synchronization to avoid data races is entirely
> free, but only that it's cost doesn't increase, and often decreases with
> scale.  Doug may well have run more careful experiments around this.
>
> Hans
>
> > -----Original Message-----
> > From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> > Sent: Wednesday, August 15, 2012 2:19 PM
> > To: Boehm, Hans
> > Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
> > dholmes at ieee.org
> > Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> >
> > Well, I understand your point.
> >
> > But this lead me to another interesting question -- why data races is so
> > outlaw? Yes, I understand, it is hard to write correct code with them
> (by the
> > way, can you give the link about errors in JMM spec about data race
> you've
> > mention above?), but can we scale really well with sequentially
> consistent
> > execution only? I mean, in large-scale distributed systems design
> weakening
> > consistency often gives great performance benefits. AndwWhen I think
> > about something like 786-cores (skip the brand) box, it seems for me
> there
> > could be many chances to improve performance using racy code. Am I miss
> > something here?
> >
> > 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
> > >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> > >>
> > >> As far, as I can see, there is two directions. One is what
> > >> "thread-safe" notation in it's commonly used form -- then applied
> > >> only to methods, and not to initialization/publication -- is
> > >> confusing, and there is little reason to exclude
> > >> construction/publication from thread safety protocol by default. My
> > >> point, among others, is that "immutable and thread safe" should be
> > >> interpreted as "thread safe even for unsafe publishing". And this,
> > >> for example, gives us the chance to remove volatile specification in
> > >> File.path field we started from :)
> > > It seems to me that there's a huge difference here.  Synchronization
> in the
> > constructor only matters in the presence of other dubious programming
> > practices:  Either a reference to the object has to escape before the
> > constructor finishes, or the reference has to be communicated to another
> > thread in a racy manner.  (And the former is a special case under
> control of
> > the class itself.)  There are strong reasons to avoid both in the vast
> majority
> > of code.  On the other hand, perfectly normal code will routinely rely
> on the
> > thread-safety of non-constructor methods all the time.
> > >
> > >>
> > >> Second direction is about construction/publication as specifically
> > >> different from the methods. E.g. it even may have additional safety
> > >> guarantee -- like "publication is always safe". I can see some
> > >> reasons here, since constructor is the only one method, which is
> > >> guaranteed to be called only once on object lifecycle, and so we,
> > >> possible, can restrict some compiler/CPUs optimization in it with
> > >> little influence on overall application performance -- but it throws
> > >> away all troubles with unsafe publishing.
> > > I think we're still generally using "unsafe publishing" to mean either
> of the
> > two dubious practices I mentioned above, though here we're presumably
> > talking about racy publication after the constructor completes.  The
> problem
> > is that in general racy publication is already a really bad practice,
> because the
> > user has to understand the ugly details of the Java memory model, which
> > nobody really does.  Racy publication is a data race, and hence you can
> no
> > longer reason in terms of sequential consistency, synchronization-free
> > regions become nonatomic, and generally all our intuition about behavior
> of
> > threads and reasoning about threads goes out the window, even if you can
> > still reason about the integrity of your class.  There are one or two
> special
> > cases, notably lazy initialization of an immutable object, where you
> might
> > succeed in hiding all that mess behind a library API, but in general
> that's hard.
> > So the question in my mind is whether you want to provide those added
> > guarantees to support those one or two cases, or whether you want to
> limit
> > those guarantees to situations, notably those involving final fields,
> where
> > they're essential for the security model.  We currently have the latter.
> > >
> > > Hans
> > >>
> > >>
> > >>
> > >> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
> > >> > Agreed.
> > >> >
> > >> > But, echoing David, I think, I'm not at all sure I see where this
> > >> thread is going.  We've established that
> > >> >
> > >> > a) You can make a class safe against racy publication by
> > >> synchronizing the constructor along with all other methods (or by
> > >> using an immutable class with final fields).
> > >> >
> > >> > b) There are (rather brittle and obscure) use cases in which racy
> > >> publication gives you better performance on architectures like ARM,
> > >> though not x86, currently at the cost of confusing data race
> detectors.
> > >> >
> > >> > But to me it seems like taking advanatage of (b) is a fairly
> > >> undesirable, though perhaps occasionally unavoidable, hack.  And I
> > >> can't see why it would possibly be a win if you have to synchronize
> > >> all method calls to make it work.
> > >> >
> > >> > Does anyone have a use case in mind where the whole picture we're
> > >> discussing actually makes sense?  It might help to focus this
> > >> discussion.
> > >> >
> > >> > Hans
> > >> >
> > >> >> -----Original Message-----
> > >> >> From: concurrency-interest-bounces at cs.oswego.edu
> > >> [mailto:concurrency-
> > >> >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
> > >> >> Sent: Wednesday, August 15, 2012 10:56 AM
> > >> >> To: Yuval Shavit
> > >> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> > >> >> Subject: Re: [concurrency-interest] Double Checked Locking in
> > >> OpenJDK
> > >> >>
> > >> >> I thought the conclusion of that thread is that synchronizing
> > >> >> constructor has the desired merit - if all constructors and
> > >> >> methods are synchronized, a non-creating thread won't observe the
> > >> zero/partial
> > >> >> state of the object, even if the object reference is published
> > >> >> unsafely.
> > >> >>
> > >> >> (One guy, who shall remain nameless, muddied the water with some
> > >> >> mistaken statements of weaker memory guarantee. He has been
> > >> corrected)
> > >> >>
> > >> >> Zhong Yu
> > >> >>
> > >> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
> > >> >> <yshavit at akiban.com>
> > >> >> wrote:
> > >> >> > There was a discussion here a few months ago about synchronizing
> > >> >> > constructors -- I had asked why it's not allowed, and the
> > >> discussion
> > >> >> hit on
> > >> >> > some of the similar points brought up in this thread.
> > >> >> >
> > >> >> > But to your point specifically, synchronizing a constructor (via
> > >> >> > "synchronized(this) {...}" surrounding its body) still doesn't
> > >> give
> > >> >> you full
> > >> >> > thread safety (even assuming immutability after the constructor
> > >> >> > --
> > >> >> but
> > >> >> > without final fields). It ensures that a thread can observe the
> > >> >> object
> > >> >> > either fully constructed *or* with all its fields having their
> > >> >> default
> > >> >> > values. In other words, even if your constructor is synchronized
> > >> on
> > >> >> the same
> > >> >> > object your getter is, a thread could observe a field as it was
> > >> >> before the
> > >> >> > constructor was invoked.
> > >> >> >
> > >> >> > http://markmail.org/message/mav53xzo4bqu7udw
> > >> >> >
> > >> >> >
> > >> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
> > >> >> <cheremin at gmail.com>
> > >> >> > wrote:
> > >> >> >>
> > >> >> >> > The reason to keep them distinct is because in general the
> > >> >> mechanisms
> > >> >> >> > for
> > >> >> >> > safe publication are external to the class, while those for
> > >> >> >> > thread-safety are internal. It is only an edge case where use
> > >> >> >> > of synchronized
> > >> in
> > >> >> a
> > >> >> >> > constructor can achieve safe-publication.
> > >> >> >>
> > >> >> >> Well, actually I do not understand your point. If I use some
> > >> >> >> kind
> > >> of
> > >> >> >> synchronization to make methods of my object thread-safe --
> > >> >> >> can't
> > >> I
> > >> >> >> also apply same thing to constructor? For me, it makes the
> > >> >> >> thing
> > >> >> only
> > >> >> >> clearer. Object can be thread-safe -- and it is totally thread
> > >> safe.
> > >> >> >> Object can require external synchronization for correct
> > >> >> multithreaded
> > >> >> >> use -- and it requires the sync for publishing and for usage
> > >> also.
> > >> >> >>
> > >> >> >> From my point of view, the distinction you talking about is
> > >> >> >> more historically reasoned. "Sync method if you want it to be
> > >> >> >> thread-
> > >> >> safe"
> > >> >> >> is commonly learned mantra, but "take care of initialization
> > >> also"
> > >> >> is
> > >> >> >> not so common. More information about it, more education, more
> > >> >> >> different code samples with outlined "here is the dragons" will
> > >> >> change
> > >> >> >> the situation, I sure, it just have to be highlighted more
> often.
> > >> >> >>
> > >> >> >>
> > >> >> >> > People have to recognize that sharing an object requires
> > >> >> >> > shared
> > >> >> mutable
> > >> >> >> > state, and the number one tenet of concurrent programming is
> > >> that
> > >> >> access
> > >> >> >> > to
> > >> >> >> > shared mutable state has to be synchronized (in a general
> > >> >> >> > sense
> > >> >> not
> > >> >> >> > specifically use of 'synchronized' keyword).
> > >> >> >> >
> > >> >> >> > Making every object safely publishable could be done, but for
> > >> 99%
> > >> >> of
> > >> >> >> > objects
> > >> >> >> > it would be a waste of effort. Programs without data races
> > >> don't
> > >> >> have
> > >> >> >> > issues
> > >> >> >> > with unsafe publication.
> > >> >> >> >
> > >> >> >> > David
> > >> >> >> >
> > >> >> >> > -----Original Message-----
> > >> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
> > >> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
> > >> >> >> > Of
> > >> >> Nathan
> > >> >> >> > Reynolds
> > >> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
> > >> >> >> > To: concurrency-interest at cs.oswego.edu
> > >> >> >> > Subject: Re: [concurrency-interest] Double Checked Locking in
> > >> >> OpenJDK
> > >> >> >> >
> > >> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
> > >> >> >> > publication)
> > >> >> >> > when they should be combined in a sense.  Typically, when we
> > >> say
> > >> >> >> > thread-safe
> > >> >> >> > we talk about the operations performed on the object after it
> > >> was
> > >> >> >> > constructed (and its contents are globally visible).
> > >> >> >> > However,
> > >> we
> > >> >> need
> > >> >> >> > to
> > >> >> >> > consider that executing the constructor is modifying the
> > >> >> >> > state
> > >> of
> > >> >> the
> > >> >> >> > object.  It requires the same mechanisms that the rest of the
> > >> >> class uses
> > >> >> >> > to
> > >> >> >> > ensure thread-safety.  Even though, there is only 1 thread
> > >> >> executing the
> > >> >> >> > constructor, a proper releasing of a lock or some other
> > >> happens-
> > >> >> before
> > >> >> >> > construct is required to ensure that the memory updates by
> > >> >> >> > the
> > >> >> thread
> > >> >> >> > are
> > >> >> >> > made globally visible before the object is accessed by
> > >> >> >> > another
> > >> >> thread.
> > >> >> >> > This
> > >> >> >> > is what we are calling safe publication.  So, safe
> > >> >> >> > publication
> > >> is
> > >> >> a
> > >> >> >> > subset
> > >> >> >> > of thread-safety except it is limited to what happens after
> > >> >> >> > the constructor is called and before the object is used by
> > >> >> >> > multiple threads.
> > >> >> >> >
> > >> >> >> > A beautifully-written class can be thread-safe with respect
> > >> >> >> > to
> > >> >> calling
> > >> >> >> > its
> > >> >> >> > member methods but not thread-safe with respect to calling
> > >> >> >> > its constructor.
> > >> >> >> > It is this latter case that many stumble upon because they
> > >> think
> > >> >> that
> > >> >> >> > constructors are inherently thread-safe because they are
> > >> executed
> > >> >> >> > single-threadedly.  What they fail to realize is that the
> > >> >> execution of a
> > >> >> >> > constructor can overlap with the execution of other code from
> > >> the
> > >> >> view
> > >> >> >> > point
> > >> >> >> > of what is happening in memory.  This same problem applies to
> > >> more
> > >> >> rare
> > >> >> >> > case
> > >> >> >> > of regular methods which can be proven to execute in a single
> > >> >> thread but
> > >> >> >> > don't use synchronization before multiple threads start
> > >> accessing
> > >> >> the
> > >> >> >> > shared
> > >> >> >> > data.
> > >> >> >> >
> > >> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> > >> >> 602.333.9091
> > >> >> >> > Oracle PSR Engineering | Server Technology On 8/13/2012 4:08
> > >> >> >> > PM, David Holmes wrote:
> > >> >> >> >
> > >> >> >> > Ruslan Cheremin writes:
> > >> >> >> >
> > >> >> >> > For me it is confusing: java has only one way to have really
> > >> >> immutable
> > >> >> >> > object, and this way also gives you a total thread safety
> > >> >> >> > even
> > >> for
> > >> >> >> > data race based publication. But then docs refer object as
> > >> >> "immutable
> > >> >> >> > and thread-safe" -- we still can't assume it to be really
> > >> thread-
> > >> >> safe?
> > >> >> >> >
> > >> >> >> > It is better/simpler to isolate the notion of thread-safety
> > >> >> >> > and
> > >> >> safe
> > >> >> >> > publication. Thread-safety comes into play after you have
> > >> safely
> > >> >> shared
> > >> >> >> > an
> > >> >> >> > object. The means by which you safely share an object is
> > >> >> orthogonal to
> > >> >> >> > how
> > >> >> >> > the object itself is made thread-safe.
> > >> >> >> >
> > >> >> >> > The means by which an object is shared has to involve shared
> > >> >> mutable
> > >> >> >> > state,
> > >> >> >> > and use of shared mutable state always needs some form of
> > >> >> >> > synchronization (either implicit eg due to static
> > >> >> >> > initialization; or explicit
> > >> by
> > >> >> using
> > >> >> >> > volatile or synchronized getter/setter methods).
> > >> >> >> >
> > >> >> >> > David
> > >> >> >> > -----
> > >> >> >> >
> > >> >> >> > It's a pity, especially because true immutability gives us
> > >> >> >> > some chances of performance optimization. As in this case --
> > >> >> >> > we do
> > >> not
> > >> >> >> > really need .path to be volatile here, if we would assume
> > >> >> >> > Path
> > >> to
> > >> >> be
> > >> >> >> > truly immutable. volatility here required only for ensuring
> > >> safe
> > >> >> >> > publishing.
> > >> >> >> >
> > >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >> >> >> >
> > >> >> >> > Ruslan Cheremin writes:>
> > >> >> >> >
> > >> >> >> > But is there a way to define "safe for data race publishing"?
> > >> >> >> > I
> > >> as
> > >> >> >> > far, as I remember, "immutable and thread-safe" is standard
> > >> mantra
> > >> >> in
> > >> >> >> > JDK javadocs for totally safe objects. j.l.String has same
> > >> mantra
> > >> >> --
> > >> >> >> > and it is safe for any way of publishing. Does you mean, I
> > >> should
> > >> >> >> > explicitly add "safe even for publishing via data race" in
> > >> docs?
> > >> >> But I
> > >> >> >> > can't remember any such phrase in JDK docs.
> > >> >> >> >
> > >> >> >> > I don't recall anything in the JDK docs that mention being
> > >> >> >> >
> > >> >> >> > "totally safe"
> > >> >> >> >
> > >> >> >> > regardless of publication mechanism. Some classes, eg String,
> > >> have
> > >> >> been
> > >> >> >> > defined such that they do have that property (for security
> > >> >> reasons). In
> > >> >> >> > general neither "thread-safe" nor "immutable" imply
> > >> >> >> > safe-for-unsynchronized-publication.
> > >> >> >> >
> > >> >> >> > Java Concurrency In Practice (jcip.net) does define
> > >> >> >> > additional
> > >> >> potential
> > >> >> >> > annotations, where @Immutable would indeed capture the
> > >> requirement
> > >> >> of
> > >> >> >> > safe-for-unsynchronized-publication.
> > >> >> >> >
> > >> >> >> > David
> > >> >> >> > -----
> > >> >> >> >
> > >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >> >> >> >
> > >> >> >> > Ruslan Cheremin writes:
> > >> >> >> >
> > >> >> >> > Well, Path javadoc explicitly says "immutable and safe for
> > >> >> >> > multithreaded use". Although it is not strictly defined in
> > >> >> >> > java
> > >> >> what
> > >> >> >> > exactly means "safe for multithreaded use" -- does it mean
> > >> >> >> > safe
> > >> >> for
> > >> >> >> > publishing via data race, among others? -- I suppose, it
> > >> >> >> >
> > >> >> >> > should be. Am
> > >> >> >> >
> > >> >> >> > I wrong here?
> > >> >> >> >
> > >> >> >> > "safe for multi-threaded use" does not generally imply that
> > >> >> >> > it
> > >> >> >> >
> > >> >> >> > is safe to
> > >> >> >> >
> > >> >> >> > publish instances without synchronization of some form.
> > >> >> >> >
> > >> >> >> > David
> > >> >> >> > -----
> > >> >> >> >
> > >> >> >> > From other side, File.toPath javadoc explicitly says what
> > >> >> "returned
> > >> >> >> > instance must be the same for every invocation", so sync
> > >> >> >> > block
> > >> is
> > >> >> >> > required here for mutual exclusion on initialization phase.
> > >> >> Without
> > >> >> >> > this requirement it is also safe to live without sync block,
> > >> >> afaik.
> > >> >> >> >
> > >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >> >> >> >
> > >> >> >> > Ruslan Cheremin writes:
> > >> >> >> >
> > >> >> >> > First of all, Path is immutable, so DCL is safe here even
> > >> without
> > >> >> >> > volatile. Volatile here is not required from my point of view.
> > >> >> >> >
> > >> >> >> > Without the volatile the Path implementation (Path is an
> > >> >> >> >
> > >> >> >> > interface) must be
> > >> >> >> >
> > >> >> >> > such that an instance of Path can be safely published without
> > >> >> >> >
> > >> >> >> > any additional
> > >> >> >> >
> > >> >> >> > forms of synchronization. Immutability does not in itself
> > >> >> >> >
> > >> >> >> > ensure that. You
> > >> >> >> >
> > >> >> >> > would have to examine the actual implementation class.
> > >> >> >> >
> > >> >> >> > David Holmes
> > >> >> >> > ------------
> > >> >> >> >
> > >> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> > >> >> >> >
> > >> >> >> > Hi Richard,
> > >> >> >> >
> > >> >> >> > The variable "filePath" is volatile, so the double-checked
> > >> >> >> >
> > >> >> >> > locking is correct in this case. It would have been a bug
> > >> >> >> >
> > >> >> >> > prior to Java 5.
> > >> >> >> >
> > >> >> >> > Best regards,
> > >> >> >> >
> > >> >> >> > Dmitry Vyazelenko
> > >> >> >> >
> > >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> > >> >> >> >
> > >> >> >> > <richard.warburton at gmail.com> wrote:
> > >> >> >> >
> > >> >> >> > Hello,
> > >> >> >> >
> > >> >> >> > The current implementation of java.io.File::toPath [0]
> > >> >> >> >
> > >> >> >> > appears to be
> > >> >> >> >
> > >> >> >> > using the double checked locking pattern:
> > >> >> >> >
> > >> >> >> >     public Path toPath() {
> > >> >> >> >         Path result = filePath;
> > >> >> >> >         if (result == null) {
> > >> >> >> >             synchronized (this) {
> > >> >> >> >                 result = filePath;
> > >> >> >> >                 if (result == null) {
> > >> >> >> >                     result =
> > >> >> >> >
> > >> >> >> > FileSystems.getDefault().getPath(path);
> > >> >> >> >
> > >> >> >> >                     filePath = result;
> > >> >> >> >                 }
> > >> >> >> >             }
> > >> >> >> >         }
> > >> >> >> >         return result;
> > >> >> >> >     }
> > >> >> >> >
> > >> >> >> > I was going to report the bug, but I'm a little
> > >> >> >> >
> > >> >> >> > uncertain of the
> > >> >> >> >
> > >> >> >> > interaction between the local variable 'result' and DCL
> > >> >> >> >
> > >> >> >> > since I've
> > >> >> >> >
> > >> >> >> > previously only seen the checking condition on the
> > >> >> >> >
> > >> >> >> > shared field
> > >> >> >> >
> > >> >> >> > itself.  Can someone here either confirm that its a bug or
> > >> >> >> >
> > >> >> >> > explain how
> > >> >> >> >
> > >> >> >> > the 'result' variable is fixing things?
> > >> >> >> >
> > >> >> >> > regards,
> > >> >> >> >
> > >> >> >> >  Richard
> > >> >> >> >
> > >> >> >> > [0] See the end of
> > >> >> >> >
> > >> >> >> >
> > >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> > >> >> >> >
> > >> >> >> > ses/java/io/File.java
> > >> >> >> >
> > >> >> >> > _______________________________________________
> > >> >> >> > Concurrency-interest mailing list
> > >> >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >> >
> > >> >> >> > _______________________________________________
> > >> >> >> > Concurrency-interest mailing list
> > >> >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >> >
> > >> >> >> > _______________________________________________
> > >> >> >> > Concurrency-interest mailing list
> > >> >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >> >
> > >> >> >> > _______________________________________________
> > >> >> >> > Concurrency-interest mailing list
> > >> >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >> >
> > >> >> >> >
> > >> >> >> >
> > >> >> >> > _______________________________________________
> > >> >> >> > Concurrency-interest mailing list
> > >> >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >> >
> > >> >> >> _______________________________________________
> > >> >> >> Concurrency-interest mailing list
> > >> >> >> Concurrency-interest at cs.oswego.edu
> > >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >
> > >> >> >
> > >> >> >
> > >> >> > _______________________________________________
> > >> >> > Concurrency-interest mailing list
> > >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >
> > >> >> _______________________________________________
> > >> >> Concurrency-interest mailing list
> > >> >> Concurrency-interest at cs.oswego.edu
> > >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >
> > >> > _______________________________________________
> > >> > Concurrency-interest mailing list
> > >> > Concurrency-interest at cs.oswego.edu
> > >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120816/af75c0f8/attachment-0001.html>

From vitalyd at gmail.com  Thu Aug 16 08:09:28 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 16 Aug 2012 08:09:28 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37ET3jg5OjdXw8SDfv39HEqsjqG-N8w5DW9VtTSbkrCeeQ@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
	<CAHjP37ET3jg5OjdXw8SDfv39HEqsjqG-N8w5DW9VtTSbkrCeeQ@mail.gmail.com>
Message-ID: <CAHjP37G59z=gnAy+6L5tZRP=WWiT72dFZbtQKE=rdexC7S54sw@mail.gmail.com>

By the way, memory as a bottleneck is the main reason why java needs
structs, IMHO.  Developers need the ability to avoid the heap (particularly
on x64 where the default stack sizes are quite large) as well as allow
allocating allocating a struct inline with a host object to exploit cache
locality.

Sent from my phone
On Aug 16, 2012 7:51 AM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:

> Hans, your point about memory bandwidth being an issue on systems with
> very large core counts is a very important one to keep in mind.  As I
> mentioned earlier, even ordinary stores (i.e. sharing) becomes a big
> scalability issue.  Dave Dice had a blog post some time back comparing
> performance of sharing via CAS vs ordinary stores (I think on a large
> Niagara machine) and they both fell off a cliff with similar numbers.  CAS
> performance seems to be improving with almost every new Intel (maybe
> others) arch, so scalability issues start boiling down to general mem
> bandwidth.
>
> At this point, one needs to start ensuring that they minimize sharing
> altogether, specifically many writers, and other low level things start
> coming into play as well (e.g. gc/allocator being NUMA aware).
>
> Sent from my phone
> On Aug 16, 2012 12:50 AM, "Boehm, Hans" <hans.boehm at hp.com> wrote:
>
>> The standard reference for the JMM problems is Sevcik and Aspinall, "On
>> validity of program transformations in the Java Memory Model", ECOOP 2008.
>>  I became convinced in a java memory model discussion a couple of years ago
>> or so (also including Jaroslav Sevcik) that that's not the only problem,
>> but it is a serious problem.
>>
>> I'm unconvinced that removing the synchronization to prevent data races
>> generally improves scalability in the normal sense.  Improving or removing
>> coarser-grained synchronization clearly can.  On x86, fences in particular
>> seem to be executed entirely locally; they add significant overhead at low
>> core counts.  Based on limited experiments, they become increasingly
>> insignificant as you reach other scaling limits, e.g. memory bandwidth.
>>  This is consistent with the usual intuition that fences wait for store
>> buffers to drain.  Even more limited experiments on POWER were, to my
>> surprise, also largely consistent with that.  For a recent experiment I ran
>> in support of a workshop submission, this even tends to be true for
>> acquiring locks solely to avoid data races.  The difference between
>> synchronized and racy performance DECREASED dramatically with the number of
>> threads/cores.
>>
>> This doesn't mean that synchronization to avoid data races is entirely
>> free, but only that it's cost doesn't increase, and often decreases with
>> scale.  Doug may well have run more careful experiments around this.
>>
>> Hans
>>
>> > -----Original Message-----
>> > From: Ruslan Cheremin [mailto:cheremin at gmail.com]
>> > Sent: Wednesday, August 15, 2012 2:19 PM
>> > To: Boehm, Hans
>> > Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
>> > dholmes at ieee.org
>> > Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>> >
>> > Well, I understand your point.
>> >
>> > But this lead me to another interesting question -- why data races is so
>> > outlaw? Yes, I understand, it is hard to write correct code with them
>> (by the
>> > way, can you give the link about errors in JMM spec about data race
>> you've
>> > mention above?), but can we scale really well with sequentially
>> consistent
>> > execution only? I mean, in large-scale distributed systems design
>> weakening
>> > consistency often gives great performance benefits. AndwWhen I think
>> > about something like 786-cores (skip the brand) box, it seems for me
>> there
>> > could be many chances to improve performance using racy code. Am I miss
>> > something here?
>> >
>> > 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
>> > >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
>> > >>
>> > >> As far, as I can see, there is two directions. One is what
>> > >> "thread-safe" notation in it's commonly used form -- then applied
>> > >> only to methods, and not to initialization/publication -- is
>> > >> confusing, and there is little reason to exclude
>> > >> construction/publication from thread safety protocol by default. My
>> > >> point, among others, is that "immutable and thread safe" should be
>> > >> interpreted as "thread safe even for unsafe publishing". And this,
>> > >> for example, gives us the chance to remove volatile specification in
>> > >> File.path field we started from :)
>> > > It seems to me that there's a huge difference here.  Synchronization
>> in the
>> > constructor only matters in the presence of other dubious programming
>> > practices:  Either a reference to the object has to escape before the
>> > constructor finishes, or the reference has to be communicated to another
>> > thread in a racy manner.  (And the former is a special case under
>> control of
>> > the class itself.)  There are strong reasons to avoid both in the vast
>> majority
>> > of code.  On the other hand, perfectly normal code will routinely rely
>> on the
>> > thread-safety of non-constructor methods all the time.
>> > >
>> > >>
>> > >> Second direction is about construction/publication as specifically
>> > >> different from the methods. E.g. it even may have additional safety
>> > >> guarantee -- like "publication is always safe". I can see some
>> > >> reasons here, since constructor is the only one method, which is
>> > >> guaranteed to be called only once on object lifecycle, and so we,
>> > >> possible, can restrict some compiler/CPUs optimization in it with
>> > >> little influence on overall application performance -- but it throws
>> > >> away all troubles with unsafe publishing.
>> > > I think we're still generally using "unsafe publishing" to mean
>> either of the
>> > two dubious practices I mentioned above, though here we're presumably
>> > talking about racy publication after the constructor completes.  The
>> problem
>> > is that in general racy publication is already a really bad practice,
>> because the
>> > user has to understand the ugly details of the Java memory model, which
>> > nobody really does.  Racy publication is a data race, and hence you can
>> no
>> > longer reason in terms of sequential consistency, synchronization-free
>> > regions become nonatomic, and generally all our intuition about
>> behavior of
>> > threads and reasoning about threads goes out the window, even if you can
>> > still reason about the integrity of your class.  There are one or two
>> special
>> > cases, notably lazy initialization of an immutable object, where you
>> might
>> > succeed in hiding all that mess behind a library API, but in general
>> that's hard.
>> > So the question in my mind is whether you want to provide those added
>> > guarantees to support those one or two cases, or whether you want to
>> limit
>> > those guarantees to situations, notably those involving final fields,
>> where
>> > they're essential for the security model.  We currently have the latter.
>> > >
>> > > Hans
>> > >>
>> > >>
>> > >>
>> > >> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
>> > >> > Agreed.
>> > >> >
>> > >> > But, echoing David, I think, I'm not at all sure I see where this
>> > >> thread is going.  We've established that
>> > >> >
>> > >> > a) You can make a class safe against racy publication by
>> > >> synchronizing the constructor along with all other methods (or by
>> > >> using an immutable class with final fields).
>> > >> >
>> > >> > b) There are (rather brittle and obscure) use cases in which racy
>> > >> publication gives you better performance on architectures like ARM,
>> > >> though not x86, currently at the cost of confusing data race
>> detectors.
>> > >> >
>> > >> > But to me it seems like taking advanatage of (b) is a fairly
>> > >> undesirable, though perhaps occasionally unavoidable, hack.  And I
>> > >> can't see why it would possibly be a win if you have to synchronize
>> > >> all method calls to make it work.
>> > >> >
>> > >> > Does anyone have a use case in mind where the whole picture we're
>> > >> discussing actually makes sense?  It might help to focus this
>> > >> discussion.
>> > >> >
>> > >> > Hans
>> > >> >
>> > >> >> -----Original Message-----
>> > >> >> From: concurrency-interest-bounces at cs.oswego.edu
>> > >> [mailto:concurrency-
>> > >> >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
>> > >> >> Sent: Wednesday, August 15, 2012 10:56 AM
>> > >> >> To: Yuval Shavit
>> > >> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
>> > >> >> Subject: Re: [concurrency-interest] Double Checked Locking in
>> > >> OpenJDK
>> > >> >>
>> > >> >> I thought the conclusion of that thread is that synchronizing
>> > >> >> constructor has the desired merit - if all constructors and
>> > >> >> methods are synchronized, a non-creating thread won't observe the
>> > >> zero/partial
>> > >> >> state of the object, even if the object reference is published
>> > >> >> unsafely.
>> > >> >>
>> > >> >> (One guy, who shall remain nameless, muddied the water with some
>> > >> >> mistaken statements of weaker memory guarantee. He has been
>> > >> corrected)
>> > >> >>
>> > >> >> Zhong Yu
>> > >> >>
>> > >> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
>> > >> >> <yshavit at akiban.com>
>> > >> >> wrote:
>> > >> >> > There was a discussion here a few months ago about synchronizing
>> > >> >> > constructors -- I had asked why it's not allowed, and the
>> > >> discussion
>> > >> >> hit on
>> > >> >> > some of the similar points brought up in this thread.
>> > >> >> >
>> > >> >> > But to your point specifically, synchronizing a constructor (via
>> > >> >> > "synchronized(this) {...}" surrounding its body) still doesn't
>> > >> give
>> > >> >> you full
>> > >> >> > thread safety (even assuming immutability after the constructor
>> > >> >> > --
>> > >> >> but
>> > >> >> > without final fields). It ensures that a thread can observe the
>> > >> >> object
>> > >> >> > either fully constructed *or* with all its fields having their
>> > >> >> default
>> > >> >> > values. In other words, even if your constructor is synchronized
>> > >> on
>> > >> >> the same
>> > >> >> > object your getter is, a thread could observe a field as it was
>> > >> >> before the
>> > >> >> > constructor was invoked.
>> > >> >> >
>> > >> >> > http://markmail.org/message/mav53xzo4bqu7udw
>> > >> >> >
>> > >> >> >
>> > >> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
>> > >> >> <cheremin at gmail.com>
>> > >> >> > wrote:
>> > >> >> >>
>> > >> >> >> > The reason to keep them distinct is because in general the
>> > >> >> mechanisms
>> > >> >> >> > for
>> > >> >> >> > safe publication are external to the class, while those for
>> > >> >> >> > thread-safety are internal. It is only an edge case where use
>> > >> >> >> > of synchronized
>> > >> in
>> > >> >> a
>> > >> >> >> > constructor can achieve safe-publication.
>> > >> >> >>
>> > >> >> >> Well, actually I do not understand your point. If I use some
>> > >> >> >> kind
>> > >> of
>> > >> >> >> synchronization to make methods of my object thread-safe --
>> > >> >> >> can't
>> > >> I
>> > >> >> >> also apply same thing to constructor? For me, it makes the
>> > >> >> >> thing
>> > >> >> only
>> > >> >> >> clearer. Object can be thread-safe -- and it is totally thread
>> > >> safe.
>> > >> >> >> Object can require external synchronization for correct
>> > >> >> multithreaded
>> > >> >> >> use -- and it requires the sync for publishing and for usage
>> > >> also.
>> > >> >> >>
>> > >> >> >> From my point of view, the distinction you talking about is
>> > >> >> >> more historically reasoned. "Sync method if you want it to be
>> > >> >> >> thread-
>> > >> >> safe"
>> > >> >> >> is commonly learned mantra, but "take care of initialization
>> > >> also"
>> > >> >> is
>> > >> >> >> not so common. More information about it, more education, more
>> > >> >> >> different code samples with outlined "here is the dragons" will
>> > >> >> change
>> > >> >> >> the situation, I sure, it just have to be highlighted more
>> often.
>> > >> >> >>
>> > >> >> >>
>> > >> >> >> > People have to recognize that sharing an object requires
>> > >> >> >> > shared
>> > >> >> mutable
>> > >> >> >> > state, and the number one tenet of concurrent programming is
>> > >> that
>> > >> >> access
>> > >> >> >> > to
>> > >> >> >> > shared mutable state has to be synchronized (in a general
>> > >> >> >> > sense
>> > >> >> not
>> > >> >> >> > specifically use of 'synchronized' keyword).
>> > >> >> >> >
>> > >> >> >> > Making every object safely publishable could be done, but for
>> > >> 99%
>> > >> >> of
>> > >> >> >> > objects
>> > >> >> >> > it would be a waste of effort. Programs without data races
>> > >> don't
>> > >> >> have
>> > >> >> >> > issues
>> > >> >> >> > with unsafe publication.
>> > >> >> >> >
>> > >> >> >> > David
>> > >> >> >> >
>> > >> >> >> > -----Original Message-----
>> > >> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
>> > >> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
>> > >> >> >> > Of
>> > >> >> Nathan
>> > >> >> >> > Reynolds
>> > >> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
>> > >> >> >> > To: concurrency-interest at cs.oswego.edu
>> > >> >> >> > Subject: Re: [concurrency-interest] Double Checked Locking in
>> > >> >> OpenJDK
>> > >> >> >> >
>> > >> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
>> > >> >> >> > publication)
>> > >> >> >> > when they should be combined in a sense.  Typically, when we
>> > >> say
>> > >> >> >> > thread-safe
>> > >> >> >> > we talk about the operations performed on the object after it
>> > >> was
>> > >> >> >> > constructed (and its contents are globally visible).
>> > >> >> >> > However,
>> > >> we
>> > >> >> need
>> > >> >> >> > to
>> > >> >> >> > consider that executing the constructor is modifying the
>> > >> >> >> > state
>> > >> of
>> > >> >> the
>> > >> >> >> > object.  It requires the same mechanisms that the rest of the
>> > >> >> class uses
>> > >> >> >> > to
>> > >> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>> > >> >> executing the
>> > >> >> >> > constructor, a proper releasing of a lock or some other
>> > >> happens-
>> > >> >> before
>> > >> >> >> > construct is required to ensure that the memory updates by
>> > >> >> >> > the
>> > >> >> thread
>> > >> >> >> > are
>> > >> >> >> > made globally visible before the object is accessed by
>> > >> >> >> > another
>> > >> >> thread.
>> > >> >> >> > This
>> > >> >> >> > is what we are calling safe publication.  So, safe
>> > >> >> >> > publication
>> > >> is
>> > >> >> a
>> > >> >> >> > subset
>> > >> >> >> > of thread-safety except it is limited to what happens after
>> > >> >> >> > the constructor is called and before the object is used by
>> > >> >> >> > multiple threads.
>> > >> >> >> >
>> > >> >> >> > A beautifully-written class can be thread-safe with respect
>> > >> >> >> > to
>> > >> >> calling
>> > >> >> >> > its
>> > >> >> >> > member methods but not thread-safe with respect to calling
>> > >> >> >> > its constructor.
>> > >> >> >> > It is this latter case that many stumble upon because they
>> > >> think
>> > >> >> that
>> > >> >> >> > constructors are inherently thread-safe because they are
>> > >> executed
>> > >> >> >> > single-threadedly.  What they fail to realize is that the
>> > >> >> execution of a
>> > >> >> >> > constructor can overlap with the execution of other code from
>> > >> the
>> > >> >> view
>> > >> >> >> > point
>> > >> >> >> > of what is happening in memory.  This same problem applies to
>> > >> more
>> > >> >> rare
>> > >> >> >> > case
>> > >> >> >> > of regular methods which can be proven to execute in a single
>> > >> >> thread but
>> > >> >> >> > don't use synchronization before multiple threads start
>> > >> accessing
>> > >> >> the
>> > >> >> >> > shared
>> > >> >> >> > data.
>> > >> >> >> >
>> > >> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>> > >> >> 602.333.9091
>> > >> >> >> > Oracle PSR Engineering | Server Technology On 8/13/2012 4:08
>> > >> >> >> > PM, David Holmes wrote:
>> > >> >> >> >
>> > >> >> >> > Ruslan Cheremin writes:
>> > >> >> >> >
>> > >> >> >> > For me it is confusing: java has only one way to have really
>> > >> >> immutable
>> > >> >> >> > object, and this way also gives you a total thread safety
>> > >> >> >> > even
>> > >> for
>> > >> >> >> > data race based publication. But then docs refer object as
>> > >> >> "immutable
>> > >> >> >> > and thread-safe" -- we still can't assume it to be really
>> > >> thread-
>> > >> >> safe?
>> > >> >> >> >
>> > >> >> >> > It is better/simpler to isolate the notion of thread-safety
>> > >> >> >> > and
>> > >> >> safe
>> > >> >> >> > publication. Thread-safety comes into play after you have
>> > >> safely
>> > >> >> shared
>> > >> >> >> > an
>> > >> >> >> > object. The means by which you safely share an object is
>> > >> >> orthogonal to
>> > >> >> >> > how
>> > >> >> >> > the object itself is made thread-safe.
>> > >> >> >> >
>> > >> >> >> > The means by which an object is shared has to involve shared
>> > >> >> mutable
>> > >> >> >> > state,
>> > >> >> >> > and use of shared mutable state always needs some form of
>> > >> >> >> > synchronization (either implicit eg due to static
>> > >> >> >> > initialization; or explicit
>> > >> by
>> > >> >> using
>> > >> >> >> > volatile or synchronized getter/setter methods).
>> > >> >> >> >
>> > >> >> >> > David
>> > >> >> >> > -----
>> > >> >> >> >
>> > >> >> >> > It's a pity, especially because true immutability gives us
>> > >> >> >> > some chances of performance optimization. As in this case --
>> > >> >> >> > we do
>> > >> not
>> > >> >> >> > really need .path to be volatile here, if we would assume
>> > >> >> >> > Path
>> > >> to
>> > >> >> be
>> > >> >> >> > truly immutable. volatility here required only for ensuring
>> > >> safe
>> > >> >> >> > publishing.
>> > >> >> >> >
>> > >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> > >> >> >> >
>> > >> >> >> > Ruslan Cheremin writes:>
>> > >> >> >> >
>> > >> >> >> > But is there a way to define "safe for data race publishing"?
>> > >> >> >> > I
>> > >> as
>> > >> >> >> > far, as I remember, "immutable and thread-safe" is standard
>> > >> mantra
>> > >> >> in
>> > >> >> >> > JDK javadocs for totally safe objects. j.l.String has same
>> > >> mantra
>> > >> >> --
>> > >> >> >> > and it is safe for any way of publishing. Does you mean, I
>> > >> should
>> > >> >> >> > explicitly add "safe even for publishing via data race" in
>> > >> docs?
>> > >> >> But I
>> > >> >> >> > can't remember any such phrase in JDK docs.
>> > >> >> >> >
>> > >> >> >> > I don't recall anything in the JDK docs that mention being
>> > >> >> >> >
>> > >> >> >> > "totally safe"
>> > >> >> >> >
>> > >> >> >> > regardless of publication mechanism. Some classes, eg String,
>> > >> have
>> > >> >> been
>> > >> >> >> > defined such that they do have that property (for security
>> > >> >> reasons). In
>> > >> >> >> > general neither "thread-safe" nor "immutable" imply
>> > >> >> >> > safe-for-unsynchronized-publication.
>> > >> >> >> >
>> > >> >> >> > Java Concurrency In Practice (jcip.net) does define
>> > >> >> >> > additional
>> > >> >> potential
>> > >> >> >> > annotations, where @Immutable would indeed capture the
>> > >> requirement
>> > >> >> of
>> > >> >> >> > safe-for-unsynchronized-publication.
>> > >> >> >> >
>> > >> >> >> > David
>> > >> >> >> > -----
>> > >> >> >> >
>> > >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> > >> >> >> >
>> > >> >> >> > Ruslan Cheremin writes:
>> > >> >> >> >
>> > >> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>> > >> >> >> > multithreaded use". Although it is not strictly defined in
>> > >> >> >> > java
>> > >> >> what
>> > >> >> >> > exactly means "safe for multithreaded use" -- does it mean
>> > >> >> >> > safe
>> > >> >> for
>> > >> >> >> > publishing via data race, among others? -- I suppose, it
>> > >> >> >> >
>> > >> >> >> > should be. Am
>> > >> >> >> >
>> > >> >> >> > I wrong here?
>> > >> >> >> >
>> > >> >> >> > "safe for multi-threaded use" does not generally imply that
>> > >> >> >> > it
>> > >> >> >> >
>> > >> >> >> > is safe to
>> > >> >> >> >
>> > >> >> >> > publish instances without synchronization of some form.
>> > >> >> >> >
>> > >> >> >> > David
>> > >> >> >> > -----
>> > >> >> >> >
>> > >> >> >> > From other side, File.toPath javadoc explicitly says what
>> > >> >> "returned
>> > >> >> >> > instance must be the same for every invocation", so sync
>> > >> >> >> > block
>> > >> is
>> > >> >> >> > required here for mutual exclusion on initialization phase.
>> > >> >> Without
>> > >> >> >> > this requirement it is also safe to live without sync block,
>> > >> >> afaik.
>> > >> >> >> >
>> > >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> > >> >> >> >
>> > >> >> >> > Ruslan Cheremin writes:
>> > >> >> >> >
>> > >> >> >> > First of all, Path is immutable, so DCL is safe here even
>> > >> without
>> > >> >> >> > volatile. Volatile here is not required from my point of
>> view.
>> > >> >> >> >
>> > >> >> >> > Without the volatile the Path implementation (Path is an
>> > >> >> >> >
>> > >> >> >> > interface) must be
>> > >> >> >> >
>> > >> >> >> > such that an instance of Path can be safely published without
>> > >> >> >> >
>> > >> >> >> > any additional
>> > >> >> >> >
>> > >> >> >> > forms of synchronization. Immutability does not in itself
>> > >> >> >> >
>> > >> >> >> > ensure that. You
>> > >> >> >> >
>> > >> >> >> > would have to examine the actual implementation class.
>> > >> >> >> >
>> > >> >> >> > David Holmes
>> > >> >> >> > ------------
>> > >> >> >> >
>> > >> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> > >> >> >> >
>> > >> >> >> > Hi Richard,
>> > >> >> >> >
>> > >> >> >> > The variable "filePath" is volatile, so the double-checked
>> > >> >> >> >
>> > >> >> >> > locking is correct in this case. It would have been a bug
>> > >> >> >> >
>> > >> >> >> > prior to Java 5.
>> > >> >> >> >
>> > >> >> >> > Best regards,
>> > >> >> >> >
>> > >> >> >> > Dmitry Vyazelenko
>> > >> >> >> >
>> > >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> > >> >> >> >
>> > >> >> >> > <richard.warburton at gmail.com> wrote:
>> > >> >> >> >
>> > >> >> >> > Hello,
>> > >> >> >> >
>> > >> >> >> > The current implementation of java.io.File::toPath [0]
>> > >> >> >> >
>> > >> >> >> > appears to be
>> > >> >> >> >
>> > >> >> >> > using the double checked locking pattern:
>> > >> >> >> >
>> > >> >> >> >     public Path toPath() {
>> > >> >> >> >         Path result = filePath;
>> > >> >> >> >         if (result == null) {
>> > >> >> >> >             synchronized (this) {
>> > >> >> >> >                 result = filePath;
>> > >> >> >> >                 if (result == null) {
>> > >> >> >> >                     result =
>> > >> >> >> >
>> > >> >> >> > FileSystems.getDefault().getPath(path);
>> > >> >> >> >
>> > >> >> >> >                     filePath = result;
>> > >> >> >> >                 }
>> > >> >> >> >             }
>> > >> >> >> >         }
>> > >> >> >> >         return result;
>> > >> >> >> >     }
>> > >> >> >> >
>> > >> >> >> > I was going to report the bug, but I'm a little
>> > >> >> >> >
>> > >> >> >> > uncertain of the
>> > >> >> >> >
>> > >> >> >> > interaction between the local variable 'result' and DCL
>> > >> >> >> >
>> > >> >> >> > since I've
>> > >> >> >> >
>> > >> >> >> > previously only seen the checking condition on the
>> > >> >> >> >
>> > >> >> >> > shared field
>> > >> >> >> >
>> > >> >> >> > itself.  Can someone here either confirm that its a bug or
>> > >> >> >> >
>> > >> >> >> > explain how
>> > >> >> >> >
>> > >> >> >> > the 'result' variable is fixing things?
>> > >> >> >> >
>> > >> >> >> > regards,
>> > >> >> >> >
>> > >> >> >> >  Richard
>> > >> >> >> >
>> > >> >> >> > [0] See the end of
>> > >> >> >> >
>> > >> >> >> >
>> > >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> > >> >> >> >
>> > >> >> >> > ses/java/io/File.java
>> > >> >> >> >
>> > >> >> >> > _______________________________________________
>> > >> >> >> > Concurrency-interest mailing list
>> > >> >> >> > Concurrency-interest at cs.oswego.edu
>> > >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > >> >> >> >
>> > >> >> >> > _______________________________________________
>> > >> >> >> > Concurrency-interest mailing list
>> > >> >> >> > Concurrency-interest at cs.oswego.edu
>> > >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > >> >> >> >
>> > >> >> >> > _______________________________________________
>> > >> >> >> > Concurrency-interest mailing list
>> > >> >> >> > Concurrency-interest at cs.oswego.edu
>> > >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > >> >> >> >
>> > >> >> >> > _______________________________________________
>> > >> >> >> > Concurrency-interest mailing list
>> > >> >> >> > Concurrency-interest at cs.oswego.edu
>> > >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > >> >> >> >
>> > >> >> >> >
>> > >> >> >> >
>> > >> >> >> > _______________________________________________
>> > >> >> >> > Concurrency-interest mailing list
>> > >> >> >> > Concurrency-interest at cs.oswego.edu
>> > >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > >> >> >> >
>> > >> >> >> _______________________________________________
>> > >> >> >> Concurrency-interest mailing list
>> > >> >> >> Concurrency-interest at cs.oswego.edu
>> > >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > >> >> >
>> > >> >> >
>> > >> >> >
>> > >> >> > _______________________________________________
>> > >> >> > Concurrency-interest mailing list
>> > >> >> > Concurrency-interest at cs.oswego.edu
>> > >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > >> >> >
>> > >> >> _______________________________________________
>> > >> >> Concurrency-interest mailing list
>> > >> >> Concurrency-interest at cs.oswego.edu
>> > >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > >> >
>> > >> > _______________________________________________
>> > >> > Concurrency-interest mailing list
>> > >> > Concurrency-interest at cs.oswego.edu
>> > >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120816/582cbc2b/attachment-0001.html>

From dl at cs.oswego.edu  Thu Aug 16 08:42:19 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 16 Aug 2012 08:42:19 -0400
Subject: [concurrency-interest] Parameterized CountedCompleters
Message-ID: <502CEAAB.8040809@cs.oswego.edu>


While the most common use cases for CountedCompleters are for
void actions, there is no good reason to force them to be.
Several people have wanted to use result-bearing forms, so
they now support this.

They now can/should/must be declared as CountedCompleter<T>,
and you can override method getRawResult to return any appropriate
result that will be relayed to any call to invoke, join, etc.

Unlike the case of RecursiveTask<T>, we have no idea how you are
representing result values, so the protected setRawResult(T x)
method is by default a no-op. You can override this if desired
to do some sort of result maintenance, but typically won't.

This turns out to be a binary-compatible change, so there's
no need to adjust existing usages immediately. And it is even
source compatible, although will encounter may "raw type"
compiler warnings.

At some point, you'll want to replace
   class MyCC extends CountedCompleter
with
   class MyCC extends CountedCompleter<Void>

and constructors of form
   MyCC(CountedCompleter p, ...) { super(p); ...}
with
   MyCC(CountedCompleter<?> p, ...) { super(p); ...}
and similarly for any other methods accepting CountedCompleters).

This change is now in jsr166y, jsr166e, and j.u.c jars and sources.

-Doug


From gergg at cox.net  Thu Aug 16 11:22:15 2012
From: gergg at cox.net (Gregg Wonderly)
Date: Thu, 16 Aug 2012 10:22:15 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
Message-ID: <AB159BFA-5F4D-446B-9755-0AE66EDD1EC9@cox.net>


On Aug 15, 2012, at 11:44 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:

> The standard reference for the JMM problems is Sevcik and Aspinall, "On validity of program transformations in the Java Memory Model", ECOOP 2008.  I became convinced in a java memory model discussion a couple of years ago or so (also including Jaroslav Sevcik) that that's not the only problem, but it is a serious problem.
> 
> I'm unconvinced that removing the synchronization to prevent data races generally improves scalability in the normal sense.  Improving or removing coarser-grained synchronization clearly can.  On x86, fences in particular seem to be executed entirely locally; they add significant overhead at low core counts.  Based on limited experiments, they become increasingly insignificant as you reach other scaling limits, e.g. memory bandwidth.  This is consistent with the usual intuition that fences wait for store buffers to drain.  Even more limited experiments on POWER were, to my surprise, also largely consistent with that.  For a recent experiment I ran in support of a workshop submission, this even tends to be true for acquiring locks solely to avoid data races.  The difference between synchronized and racy performance DECREASED dramatically with the number of threads/cores.
> 
> This doesn't mean that synchronization to avoid data races is entirely free, but only that it's cost doesn't increase, and often decreases with scale.  Doug may well have run more careful experiments around this.

This just seems to be a visible result of latency being hidden by parallelization.  In network applications, this is of course the way that throughput improves.  But, ultimately, it does not change the performance of per item processing.  Any latency in the flow of execution, ultimately dictates what the throughput can be.

The number of cores is not infinite and so the "cost doesn't increase" seems a bit of a stretch.  It doesn't increase until the number of cores and the latency reach an imbalance that raises the latency back into view.

Gregg Wonderly

From cheremin at gmail.com  Thu Aug 16 15:56:21 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Thu, 16 Aug 2012 23:56:21 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
Message-ID: <CAOwENiJL3CaXFN=YAu334NbSy8rg8JabkVNH7HA6Po=+-XxUXQ@mail.gmail.com>

Thank you for reference, Hans.

About synchronization -- I was very surprised to read your results.
Well, yes, uncontended synchronization is just a matter of fences,
which has small influence on memory bandwidth. But it seems for me to
be true only with hardware coherency. Currently we'll have only
limited store buffer which keep "yet out of sync" writes, and allows
some -- limited -- number of optimization, like write combining and
write-read forwarding. So, fence, which forces buffer to drain, only
prevent exactly this limited number of optimization -- ok, I see how
it can be not a bid deal. But if all data in L1 can stay out of sync
until eviction? Delaying sync here as long as possible could -- from
my point of view -- reduce interconnect traffic impressively. And in
this case fence can be big performance killer. The more cached data
can be out of sync, the more is the cost of fences which forces the
sync -- am I miss something?



2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
> The standard reference for the JMM problems is Sevcik and Aspinall, "On validity of program transformations in the Java Memory Model", ECOOP 2008.  I became convinced in a java memory model discussion a couple of years ago or so (also including Jaroslav Sevcik) that that's not the only problem, but it is a serious problem.
>
> I'm unconvinced that removing the synchronization to prevent data races generally improves scalability in the normal sense.  Improving or removing coarser-grained synchronization clearly can.  On x86, fences in particular seem to be executed entirely locally; they add significant overhead at low core counts.  Based on limited experiments, they become increasingly insignificant as you reach other scaling limits, e.g. memory bandwidth.  This is consistent with the usual intuition that fences wait for store buffers to drain.  Even more limited experiments on POWER were, to my surprise, also largely consistent with that.  For a recent experiment I ran in support of a workshop submission, this even tends to be true for acquiring locks solely to avoid data races.  The difference between synchronized and racy performance DECREASED dramatically with the number of threads/cores.
>
> This doesn't mean that synchronization to avoid data races is entirely free, but only that it's cost doesn't increase, and often decreases with scale.  Doug may well have run more careful experiments around this.
>
> Hans
>
>> -----Original Message-----
>> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
>> Sent: Wednesday, August 15, 2012 2:19 PM
>> To: Boehm, Hans
>> Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
>> dholmes at ieee.org
>> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>>
>> Well, I understand your point.
>>
>> But this lead me to another interesting question -- why data races is so
>> outlaw? Yes, I understand, it is hard to write correct code with them (by the
>> way, can you give the link about errors in JMM spec about data race you've
>> mention above?), but can we scale really well with sequentially consistent
>> execution only? I mean, in large-scale distributed systems design weakening
>> consistency often gives great performance benefits. AndwWhen I think
>> about something like 786-cores (skip the brand) box, it seems for me there
>> could be many chances to improve performance using racy code. Am I miss
>> something here?
>>
>> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
>> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
>> >>
>> >> As far, as I can see, there is two directions. One is what
>> >> "thread-safe" notation in it's commonly used form -- then applied
>> >> only to methods, and not to initialization/publication -- is
>> >> confusing, and there is little reason to exclude
>> >> construction/publication from thread safety protocol by default. My
>> >> point, among others, is that "immutable and thread safe" should be
>> >> interpreted as "thread safe even for unsafe publishing". And this,
>> >> for example, gives us the chance to remove volatile specification in
>> >> File.path field we started from :)
>> > It seems to me that there's a huge difference here.  Synchronization in the
>> constructor only matters in the presence of other dubious programming
>> practices:  Either a reference to the object has to escape before the
>> constructor finishes, or the reference has to be communicated to another
>> thread in a racy manner.  (And the former is a special case under control of
>> the class itself.)  There are strong reasons to avoid both in the vast majority
>> of code.  On the other hand, perfectly normal code will routinely rely on the
>> thread-safety of non-constructor methods all the time.
>> >
>> >>
>> >> Second direction is about construction/publication as specifically
>> >> different from the methods. E.g. it even may have additional safety
>> >> guarantee -- like "publication is always safe". I can see some
>> >> reasons here, since constructor is the only one method, which is
>> >> guaranteed to be called only once on object lifecycle, and so we,
>> >> possible, can restrict some compiler/CPUs optimization in it with
>> >> little influence on overall application performance -- but it throws
>> >> away all troubles with unsafe publishing.
>> > I think we're still generally using "unsafe publishing" to mean either of the
>> two dubious practices I mentioned above, though here we're presumably
>> talking about racy publication after the constructor completes.  The problem
>> is that in general racy publication is already a really bad practice, because the
>> user has to understand the ugly details of the Java memory model, which
>> nobody really does.  Racy publication is a data race, and hence you can no
>> longer reason in terms of sequential consistency, synchronization-free
>> regions become nonatomic, and generally all our intuition about behavior of
>> threads and reasoning about threads goes out the window, even if you can
>> still reason about the integrity of your class.  There are one or two special
>> cases, notably lazy initialization of an immutable object, where you might
>> succeed in hiding all that mess behind a library API, but in general that's hard.
>> So the question in my mind is whether you want to provide those added
>> guarantees to support those one or two cases, or whether you want to limit
>> those guarantees to situations, notably those involving final fields, where
>> they're essential for the security model.  We currently have the latter.
>> >
>> > Hans
>> >>
>> >>
>> >>
>> >> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
>> >> > Agreed.
>> >> >
>> >> > But, echoing David, I think, I'm not at all sure I see where this
>> >> thread is going.  We've established that
>> >> >
>> >> > a) You can make a class safe against racy publication by
>> >> synchronizing the constructor along with all other methods (or by
>> >> using an immutable class with final fields).
>> >> >
>> >> > b) There are (rather brittle and obscure) use cases in which racy
>> >> publication gives you better performance on architectures like ARM,
>> >> though not x86, currently at the cost of confusing data race detectors.
>> >> >
>> >> > But to me it seems like taking advanatage of (b) is a fairly
>> >> undesirable, though perhaps occasionally unavoidable, hack.  And I
>> >> can't see why it would possibly be a win if you have to synchronize
>> >> all method calls to make it work.
>> >> >
>> >> > Does anyone have a use case in mind where the whole picture we're
>> >> discussing actually makes sense?  It might help to focus this
>> >> discussion.
>> >> >
>> >> > Hans
>> >> >
>> >> >> -----Original Message-----
>> >> >> From: concurrency-interest-bounces at cs.oswego.edu
>> >> [mailto:concurrency-
>> >> >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
>> >> >> Sent: Wednesday, August 15, 2012 10:56 AM
>> >> >> To: Yuval Shavit
>> >> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
>> >> >> Subject: Re: [concurrency-interest] Double Checked Locking in
>> >> OpenJDK
>> >> >>
>> >> >> I thought the conclusion of that thread is that synchronizing
>> >> >> constructor has the desired merit - if all constructors and
>> >> >> methods are synchronized, a non-creating thread won't observe the
>> >> zero/partial
>> >> >> state of the object, even if the object reference is published
>> >> >> unsafely.
>> >> >>
>> >> >> (One guy, who shall remain nameless, muddied the water with some
>> >> >> mistaken statements of weaker memory guarantee. He has been
>> >> corrected)
>> >> >>
>> >> >> Zhong Yu
>> >> >>
>> >> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
>> >> >> <yshavit at akiban.com>
>> >> >> wrote:
>> >> >> > There was a discussion here a few months ago about synchronizing
>> >> >> > constructors -- I had asked why it's not allowed, and the
>> >> discussion
>> >> >> hit on
>> >> >> > some of the similar points brought up in this thread.
>> >> >> >
>> >> >> > But to your point specifically, synchronizing a constructor (via
>> >> >> > "synchronized(this) {...}" surrounding its body) still doesn't
>> >> give
>> >> >> you full
>> >> >> > thread safety (even assuming immutability after the constructor
>> >> >> > --
>> >> >> but
>> >> >> > without final fields). It ensures that a thread can observe the
>> >> >> object
>> >> >> > either fully constructed *or* with all its fields having their
>> >> >> default
>> >> >> > values. In other words, even if your constructor is synchronized
>> >> on
>> >> >> the same
>> >> >> > object your getter is, a thread could observe a field as it was
>> >> >> before the
>> >> >> > constructor was invoked.
>> >> >> >
>> >> >> > http://markmail.org/message/mav53xzo4bqu7udw
>> >> >> >
>> >> >> >
>> >> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
>> >> >> <cheremin at gmail.com>
>> >> >> > wrote:
>> >> >> >>
>> >> >> >> > The reason to keep them distinct is because in general the
>> >> >> mechanisms
>> >> >> >> > for
>> >> >> >> > safe publication are external to the class, while those for
>> >> >> >> > thread-safety are internal. It is only an edge case where use
>> >> >> >> > of synchronized
>> >> in
>> >> >> a
>> >> >> >> > constructor can achieve safe-publication.
>> >> >> >>
>> >> >> >> Well, actually I do not understand your point. If I use some
>> >> >> >> kind
>> >> of
>> >> >> >> synchronization to make methods of my object thread-safe --
>> >> >> >> can't
>> >> I
>> >> >> >> also apply same thing to constructor? For me, it makes the
>> >> >> >> thing
>> >> >> only
>> >> >> >> clearer. Object can be thread-safe -- and it is totally thread
>> >> safe.
>> >> >> >> Object can require external synchronization for correct
>> >> >> multithreaded
>> >> >> >> use -- and it requires the sync for publishing and for usage
>> >> also.
>> >> >> >>
>> >> >> >> From my point of view, the distinction you talking about is
>> >> >> >> more historically reasoned. "Sync method if you want it to be
>> >> >> >> thread-
>> >> >> safe"
>> >> >> >> is commonly learned mantra, but "take care of initialization
>> >> also"
>> >> >> is
>> >> >> >> not so common. More information about it, more education, more
>> >> >> >> different code samples with outlined "here is the dragons" will
>> >> >> change
>> >> >> >> the situation, I sure, it just have to be highlighted more often.
>> >> >> >>
>> >> >> >>
>> >> >> >> > People have to recognize that sharing an object requires
>> >> >> >> > shared
>> >> >> mutable
>> >> >> >> > state, and the number one tenet of concurrent programming is
>> >> that
>> >> >> access
>> >> >> >> > to
>> >> >> >> > shared mutable state has to be synchronized (in a general
>> >> >> >> > sense
>> >> >> not
>> >> >> >> > specifically use of 'synchronized' keyword).
>> >> >> >> >
>> >> >> >> > Making every object safely publishable could be done, but for
>> >> 99%
>> >> >> of
>> >> >> >> > objects
>> >> >> >> > it would be a waste of effort. Programs without data races
>> >> don't
>> >> >> have
>> >> >> >> > issues
>> >> >> >> > with unsafe publication.
>> >> >> >> >
>> >> >> >> > David
>> >> >> >> >
>> >> >> >> > -----Original Message-----
>> >> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
>> >> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
>> >> >> >> > Of
>> >> >> Nathan
>> >> >> >> > Reynolds
>> >> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
>> >> >> >> > To: concurrency-interest at cs.oswego.edu
>> >> >> >> > Subject: Re: [concurrency-interest] Double Checked Locking in
>> >> >> OpenJDK
>> >> >> >> >
>> >> >> >> > We seem to be splitting two notions (i.e thread-safe and safe
>> >> >> >> > publication)
>> >> >> >> > when they should be combined in a sense.  Typically, when we
>> >> say
>> >> >> >> > thread-safe
>> >> >> >> > we talk about the operations performed on the object after it
>> >> was
>> >> >> >> > constructed (and its contents are globally visible).
>> >> >> >> > However,
>> >> we
>> >> >> need
>> >> >> >> > to
>> >> >> >> > consider that executing the constructor is modifying the
>> >> >> >> > state
>> >> of
>> >> >> the
>> >> >> >> > object.  It requires the same mechanisms that the rest of the
>> >> >> class uses
>> >> >> >> > to
>> >> >> >> > ensure thread-safety.  Even though, there is only 1 thread
>> >> >> executing the
>> >> >> >> > constructor, a proper releasing of a lock or some other
>> >> happens-
>> >> >> before
>> >> >> >> > construct is required to ensure that the memory updates by
>> >> >> >> > the
>> >> >> thread
>> >> >> >> > are
>> >> >> >> > made globally visible before the object is accessed by
>> >> >> >> > another
>> >> >> thread.
>> >> >> >> > This
>> >> >> >> > is what we are calling safe publication.  So, safe
>> >> >> >> > publication
>> >> is
>> >> >> a
>> >> >> >> > subset
>> >> >> >> > of thread-safety except it is limited to what happens after
>> >> >> >> > the constructor is called and before the object is used by
>> >> >> >> > multiple threads.
>> >> >> >> >
>> >> >> >> > A beautifully-written class can be thread-safe with respect
>> >> >> >> > to
>> >> >> calling
>> >> >> >> > its
>> >> >> >> > member methods but not thread-safe with respect to calling
>> >> >> >> > its constructor.
>> >> >> >> > It is this latter case that many stumble upon because they
>> >> think
>> >> >> that
>> >> >> >> > constructors are inherently thread-safe because they are
>> >> executed
>> >> >> >> > single-threadedly.  What they fail to realize is that the
>> >> >> execution of a
>> >> >> >> > constructor can overlap with the execution of other code from
>> >> the
>> >> >> view
>> >> >> >> > point
>> >> >> >> > of what is happening in memory.  This same problem applies to
>> >> more
>> >> >> rare
>> >> >> >> > case
>> >> >> >> > of regular methods which can be proven to execute in a single
>> >> >> thread but
>> >> >> >> > don't use synchronization before multiple threads start
>> >> accessing
>> >> >> the
>> >> >> >> > shared
>> >> >> >> > data.
>> >> >> >> >
>> >> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>> >> >> 602.333.9091
>> >> >> >> > Oracle PSR Engineering | Server Technology On 8/13/2012 4:08
>> >> >> >> > PM, David Holmes wrote:
>> >> >> >> >
>> >> >> >> > Ruslan Cheremin writes:
>> >> >> >> >
>> >> >> >> > For me it is confusing: java has only one way to have really
>> >> >> immutable
>> >> >> >> > object, and this way also gives you a total thread safety
>> >> >> >> > even
>> >> for
>> >> >> >> > data race based publication. But then docs refer object as
>> >> >> "immutable
>> >> >> >> > and thread-safe" -- we still can't assume it to be really
>> >> thread-
>> >> >> safe?
>> >> >> >> >
>> >> >> >> > It is better/simpler to isolate the notion of thread-safety
>> >> >> >> > and
>> >> >> safe
>> >> >> >> > publication. Thread-safety comes into play after you have
>> >> safely
>> >> >> shared
>> >> >> >> > an
>> >> >> >> > object. The means by which you safely share an object is
>> >> >> orthogonal to
>> >> >> >> > how
>> >> >> >> > the object itself is made thread-safe.
>> >> >> >> >
>> >> >> >> > The means by which an object is shared has to involve shared
>> >> >> mutable
>> >> >> >> > state,
>> >> >> >> > and use of shared mutable state always needs some form of
>> >> >> >> > synchronization (either implicit eg due to static
>> >> >> >> > initialization; or explicit
>> >> by
>> >> >> using
>> >> >> >> > volatile or synchronized getter/setter methods).
>> >> >> >> >
>> >> >> >> > David
>> >> >> >> > -----
>> >> >> >> >
>> >> >> >> > It's a pity, especially because true immutability gives us
>> >> >> >> > some chances of performance optimization. As in this case --
>> >> >> >> > we do
>> >> not
>> >> >> >> > really need .path to be volatile here, if we would assume
>> >> >> >> > Path
>> >> to
>> >> >> be
>> >> >> >> > truly immutable. volatility here required only for ensuring
>> >> safe
>> >> >> >> > publishing.
>> >> >> >> >
>> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >> >
>> >> >> >> > Ruslan Cheremin writes:>
>> >> >> >> >
>> >> >> >> > But is there a way to define "safe for data race publishing"?
>> >> >> >> > I
>> >> as
>> >> >> >> > far, as I remember, "immutable and thread-safe" is standard
>> >> mantra
>> >> >> in
>> >> >> >> > JDK javadocs for totally safe objects. j.l.String has same
>> >> mantra
>> >> >> --
>> >> >> >> > and it is safe for any way of publishing. Does you mean, I
>> >> should
>> >> >> >> > explicitly add "safe even for publishing via data race" in
>> >> docs?
>> >> >> But I
>> >> >> >> > can't remember any such phrase in JDK docs.
>> >> >> >> >
>> >> >> >> > I don't recall anything in the JDK docs that mention being
>> >> >> >> >
>> >> >> >> > "totally safe"
>> >> >> >> >
>> >> >> >> > regardless of publication mechanism. Some classes, eg String,
>> >> have
>> >> >> been
>> >> >> >> > defined such that they do have that property (for security
>> >> >> reasons). In
>> >> >> >> > general neither "thread-safe" nor "immutable" imply
>> >> >> >> > safe-for-unsynchronized-publication.
>> >> >> >> >
>> >> >> >> > Java Concurrency In Practice (jcip.net) does define
>> >> >> >> > additional
>> >> >> potential
>> >> >> >> > annotations, where @Immutable would indeed capture the
>> >> requirement
>> >> >> of
>> >> >> >> > safe-for-unsynchronized-publication.
>> >> >> >> >
>> >> >> >> > David
>> >> >> >> > -----
>> >> >> >> >
>> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >> >
>> >> >> >> > Ruslan Cheremin writes:
>> >> >> >> >
>> >> >> >> > Well, Path javadoc explicitly says "immutable and safe for
>> >> >> >> > multithreaded use". Although it is not strictly defined in
>> >> >> >> > java
>> >> >> what
>> >> >> >> > exactly means "safe for multithreaded use" -- does it mean
>> >> >> >> > safe
>> >> >> for
>> >> >> >> > publishing via data race, among others? -- I suppose, it
>> >> >> >> >
>> >> >> >> > should be. Am
>> >> >> >> >
>> >> >> >> > I wrong here?
>> >> >> >> >
>> >> >> >> > "safe for multi-threaded use" does not generally imply that
>> >> >> >> > it
>> >> >> >> >
>> >> >> >> > is safe to
>> >> >> >> >
>> >> >> >> > publish instances without synchronization of some form.
>> >> >> >> >
>> >> >> >> > David
>> >> >> >> > -----
>> >> >> >> >
>> >> >> >> > From other side, File.toPath javadoc explicitly says what
>> >> >> "returned
>> >> >> >> > instance must be the same for every invocation", so sync
>> >> >> >> > block
>> >> is
>> >> >> >> > required here for mutual exclusion on initialization phase.
>> >> >> Without
>> >> >> >> > this requirement it is also safe to live without sync block,
>> >> >> afaik.
>> >> >> >> >
>> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >> >
>> >> >> >> > Ruslan Cheremin writes:
>> >> >> >> >
>> >> >> >> > First of all, Path is immutable, so DCL is safe here even
>> >> without
>> >> >> >> > volatile. Volatile here is not required from my point of view.
>> >> >> >> >
>> >> >> >> > Without the volatile the Path implementation (Path is an
>> >> >> >> >
>> >> >> >> > interface) must be
>> >> >> >> >
>> >> >> >> > such that an instance of Path can be safely published without
>> >> >> >> >
>> >> >> >> > any additional
>> >> >> >> >
>> >> >> >> > forms of synchronization. Immutability does not in itself
>> >> >> >> >
>> >> >> >> > ensure that. You
>> >> >> >> >
>> >> >> >> > would have to examine the actual implementation class.
>> >> >> >> >
>> >> >> >> > David Holmes
>> >> >> >> > ------------
>> >> >> >> >
>> >> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> >> >> >
>> >> >> >> > Hi Richard,
>> >> >> >> >
>> >> >> >> > The variable "filePath" is volatile, so the double-checked
>> >> >> >> >
>> >> >> >> > locking is correct in this case. It would have been a bug
>> >> >> >> >
>> >> >> >> > prior to Java 5.
>> >> >> >> >
>> >> >> >> > Best regards,
>> >> >> >> >
>> >> >> >> > Dmitry Vyazelenko
>> >> >> >> >
>> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >> >> >
>> >> >> >> > <richard.warburton at gmail.com> wrote:
>> >> >> >> >
>> >> >> >> > Hello,
>> >> >> >> >
>> >> >> >> > The current implementation of java.io.File::toPath [0]
>> >> >> >> >
>> >> >> >> > appears to be
>> >> >> >> >
>> >> >> >> > using the double checked locking pattern:
>> >> >> >> >
>> >> >> >> >     public Path toPath() {
>> >> >> >> >         Path result = filePath;
>> >> >> >> >         if (result == null) {
>> >> >> >> >             synchronized (this) {
>> >> >> >> >                 result = filePath;
>> >> >> >> >                 if (result == null) {
>> >> >> >> >                     result =
>> >> >> >> >
>> >> >> >> > FileSystems.getDefault().getPath(path);
>> >> >> >> >
>> >> >> >> >                     filePath = result;
>> >> >> >> >                 }
>> >> >> >> >             }
>> >> >> >> >         }
>> >> >> >> >         return result;
>> >> >> >> >     }
>> >> >> >> >
>> >> >> >> > I was going to report the bug, but I'm a little
>> >> >> >> >
>> >> >> >> > uncertain of the
>> >> >> >> >
>> >> >> >> > interaction between the local variable 'result' and DCL
>> >> >> >> >
>> >> >> >> > since I've
>> >> >> >> >
>> >> >> >> > previously only seen the checking condition on the
>> >> >> >> >
>> >> >> >> > shared field
>> >> >> >> >
>> >> >> >> > itself.  Can someone here either confirm that its a bug or
>> >> >> >> >
>> >> >> >> > explain how
>> >> >> >> >
>> >> >> >> > the 'result' variable is fixing things?
>> >> >> >> >
>> >> >> >> > regards,
>> >> >> >> >
>> >> >> >> >  Richard
>> >> >> >> >
>> >> >> >> > [0] See the end of
>> >> >> >> >
>> >> >> >> >
>> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> >> >> >
>> >> >> >> > ses/java/io/File.java
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> >
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> _______________________________________________
>> >> >> >> Concurrency-interest mailing list
>> >> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> >
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> _______________________________________________
>> >> >> Concurrency-interest mailing list
>> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From hans.boehm at hp.com  Thu Aug 16 17:17:17 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu, 16 Aug 2012 21:17:17 +0000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENiJL3CaXFN=YAu334NbSy8rg8JabkVNH7HA6Po=+-XxUXQ@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
	<CAOwENiJL3CaXFN=YAu334NbSy8rg8JabkVNH7HA6Po=+-XxUXQ@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60F39@G4W3296.americas.hpqcorp.net>

That's very different from the way current architectures work.  Once something is in L1, it's essentially visible to everyone, because it's subject to the cache coherency protocol.  If I write a value, it may stay only in my L1 for a long time, but if another processor asks for that cache line, it needs to talk to me.  Most, though not all, architectures guarantee cache coherence, i.e. that accesses to a single variable look sequentially consistent.  I think that changing this gets you into the realm of very different machine language memory models, which I'm not sure are reasonably programmable.  If you allowed writes to the same location by different processors to stay unsynchronized until later, how do you then resolve the conflict?  I think this gets into really tricky issues very quickly.

Hans

> -----Original Message-----
> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> Sent: Thursday, August 16, 2012 12:56 PM
> To: Boehm, Hans
> Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
> dholmes at ieee.org
> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> 
> Thank you for reference, Hans.
> 
> About synchronization -- I was very surprised to read your results.
> Well, yes, uncontended synchronization is just a matter of fences,
> which has small influence on memory bandwidth. But it seems for me to
> be true only with hardware coherency. Currently we'll have only
> limited store buffer which keep "yet out of sync" writes, and allows
> some -- limited -- number of optimization, like write combining and
> write-read forwarding. So, fence, which forces buffer to drain, only
> prevent exactly this limited number of optimization -- ok, I see how
> it can be not a bid deal. But if all data in L1 can stay out of sync
> until eviction? Delaying sync here as long as possible could -- from
> my point of view -- reduce interconnect traffic impressively. And in
> this case fence can be big performance killer. The more cached data
> can be out of sync, the more is the cost of fences which forces the
> sync -- am I miss something?
> 
> 
> 
> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
> > The standard reference for the JMM problems is Sevcik and Aspinall,
> "On validity of program transformations in the Java Memory Model",
> ECOOP 2008.  I became convinced in a java memory model discussion a
> couple of years ago or so (also including Jaroslav Sevcik) that that's
> not the only problem, but it is a serious problem.
> >
> > I'm unconvinced that removing the synchronization to prevent data
> races generally improves scalability in the normal sense.  Improving or
> removing coarser-grained synchronization clearly can.  On x86, fences
> in particular seem to be executed entirely locally; they add
> significant overhead at low core counts.  Based on limited experiments,
> they become increasingly insignificant as you reach other scaling
> limits, e.g. memory bandwidth.  This is consistent with the usual
> intuition that fences wait for store buffers to drain.  Even more
> limited experiments on POWER were, to my surprise, also largely
> consistent with that.  For a recent experiment I ran in support of a
> workshop submission, this even tends to be true for acquiring locks
> solely to avoid data races.  The difference between synchronized and
> racy performance DECREASED dramatically with the number of
> threads/cores.
> >
> > This doesn't mean that synchronization to avoid data races is
> entirely free, but only that it's cost doesn't increase, and often
> decreases with scale.  Doug may well have run more careful experiments
> around this.
> >
> > Hans
> >
> >> -----Original Message-----
> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> >> Sent: Wednesday, August 15, 2012 2:19 PM
> >> To: Boehm, Hans
> >> Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
> >> dholmes at ieee.org
> >> Subject: Re: [concurrency-interest] Double Checked Locking in
> OpenJDK
> >>
> >> Well, I understand your point.
> >>
> >> But this lead me to another interesting question -- why data races
> is so
> >> outlaw? Yes, I understand, it is hard to write correct code with
> them (by the
> >> way, can you give the link about errors in JMM spec about data race
> you've
> >> mention above?), but can we scale really well with sequentially
> consistent
> >> execution only? I mean, in large-scale distributed systems design
> weakening
> >> consistency often gives great performance benefits. AndwWhen I think
> >> about something like 786-cores (skip the brand) box, it seems for me
> there
> >> could be many chances to improve performance using racy code. Am I
> miss
> >> something here?
> >>
> >> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
> >> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> >> >>
> >> >> As far, as I can see, there is two directions. One is what
> >> >> "thread-safe" notation in it's commonly used form -- then applied
> >> >> only to methods, and not to initialization/publication -- is
> >> >> confusing, and there is little reason to exclude
> >> >> construction/publication from thread safety protocol by default.
> My
> >> >> point, among others, is that "immutable and thread safe" should
> be
> >> >> interpreted as "thread safe even for unsafe publishing". And
> this,
> >> >> for example, gives us the chance to remove volatile specification
> in
> >> >> File.path field we started from :)
> >> > It seems to me that there's a huge difference here.
> Synchronization in the
> >> constructor only matters in the presence of other dubious
> programming
> >> practices:  Either a reference to the object has to escape before
> the
> >> constructor finishes, or the reference has to be communicated to
> another
> >> thread in a racy manner.  (And the former is a special case under
> control of
> >> the class itself.)  There are strong reasons to avoid both in the
> vast majority
> >> of code.  On the other hand, perfectly normal code will routinely
> rely on the
> >> thread-safety of non-constructor methods all the time.
> >> >
> >> >>
> >> >> Second direction is about construction/publication as
> specifically
> >> >> different from the methods. E.g. it even may have additional
> safety
> >> >> guarantee -- like "publication is always safe". I can see some
> >> >> reasons here, since constructor is the only one method, which is
> >> >> guaranteed to be called only once on object lifecycle, and so we,
> >> >> possible, can restrict some compiler/CPUs optimization in it with
> >> >> little influence on overall application performance -- but it
> throws
> >> >> away all troubles with unsafe publishing.
> >> > I think we're still generally using "unsafe publishing" to mean
> either of the
> >> two dubious practices I mentioned above, though here we're
> presumably
> >> talking about racy publication after the constructor completes.  The
> problem
> >> is that in general racy publication is already a really bad
> practice, because the
> >> user has to understand the ugly details of the Java memory model,
> which
> >> nobody really does.  Racy publication is a data race, and hence you
> can no
> >> longer reason in terms of sequential consistency, synchronization-
> free
> >> regions become nonatomic, and generally all our intuition about
> behavior of
> >> threads and reasoning about threads goes out the window, even if you
> can
> >> still reason about the integrity of your class.  There are one or
> two special
> >> cases, notably lazy initialization of an immutable object, where you
> might
> >> succeed in hiding all that mess behind a library API, but in general
> that's hard.
> >> So the question in my mind is whether you want to provide those
> added
> >> guarantees to support those one or two cases, or whether you want to
> limit
> >> those guarantees to situations, notably those involving final
> fields, where
> >> they're essential for the security model.  We currently have the
> latter.
> >> >
> >> > Hans
> >> >>
> >> >>
> >> >>
> >> >> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
> >> >> > Agreed.
> >> >> >
> >> >> > But, echoing David, I think, I'm not at all sure I see where
> this
> >> >> thread is going.  We've established that
> >> >> >
> >> >> > a) You can make a class safe against racy publication by
> >> >> synchronizing the constructor along with all other methods (or by
> >> >> using an immutable class with final fields).
> >> >> >
> >> >> > b) There are (rather brittle and obscure) use cases in which
> racy
> >> >> publication gives you better performance on architectures like
> ARM,
> >> >> though not x86, currently at the cost of confusing data race
> detectors.
> >> >> >
> >> >> > But to me it seems like taking advanatage of (b) is a fairly
> >> >> undesirable, though perhaps occasionally unavoidable, hack.  And
> I
> >> >> can't see why it would possibly be a win if you have to
> synchronize
> >> >> all method calls to make it work.
> >> >> >
> >> >> > Does anyone have a use case in mind where the whole picture
> we're
> >> >> discussing actually makes sense?  It might help to focus this
> >> >> discussion.
> >> >> >
> >> >> > Hans
> >> >> >
> >> >> >> -----Original Message-----
> >> >> >> From: concurrency-interest-bounces at cs.oswego.edu
> >> >> [mailto:concurrency-
> >> >> >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
> >> >> >> Sent: Wednesday, August 15, 2012 10:56 AM
> >> >> >> To: Yuval Shavit
> >> >> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> >> >> >> Subject: Re: [concurrency-interest] Double Checked Locking in
> >> >> OpenJDK
> >> >> >>
> >> >> >> I thought the conclusion of that thread is that synchronizing
> >> >> >> constructor has the desired merit - if all constructors and
> >> >> >> methods are synchronized, a non-creating thread won't observe
> the
> >> >> zero/partial
> >> >> >> state of the object, even if the object reference is published
> >> >> >> unsafely.
> >> >> >>
> >> >> >> (One guy, who shall remain nameless, muddied the water with
> some
> >> >> >> mistaken statements of weaker memory guarantee. He has been
> >> >> corrected)
> >> >> >>
> >> >> >> Zhong Yu
> >> >> >>
> >> >> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
> >> >> >> <yshavit at akiban.com>
> >> >> >> wrote:
> >> >> >> > There was a discussion here a few months ago about
> synchronizing
> >> >> >> > constructors -- I had asked why it's not allowed, and the
> >> >> discussion
> >> >> >> hit on
> >> >> >> > some of the similar points brought up in this thread.
> >> >> >> >
> >> >> >> > But to your point specifically, synchronizing a constructor
> (via
> >> >> >> > "synchronized(this) {...}" surrounding its body) still
> doesn't
> >> >> give
> >> >> >> you full
> >> >> >> > thread safety (even assuming immutability after the
> constructor
> >> >> >> > --
> >> >> >> but
> >> >> >> > without final fields). It ensures that a thread can observe
> the
> >> >> >> object
> >> >> >> > either fully constructed *or* with all its fields having
> their
> >> >> >> default
> >> >> >> > values. In other words, even if your constructor is
> synchronized
> >> >> on
> >> >> >> the same
> >> >> >> > object your getter is, a thread could observe a field as it
> was
> >> >> >> before the
> >> >> >> > constructor was invoked.
> >> >> >> >
> >> >> >> > http://markmail.org/message/mav53xzo4bqu7udw
> >> >> >> >
> >> >> >> >
> >> >> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
> >> >> >> <cheremin at gmail.com>
> >> >> >> > wrote:
> >> >> >> >>
> >> >> >> >> > The reason to keep them distinct is because in general
> the
> >> >> >> mechanisms
> >> >> >> >> > for
> >> >> >> >> > safe publication are external to the class, while those
> for
> >> >> >> >> > thread-safety are internal. It is only an edge case where
> use
> >> >> >> >> > of synchronized
> >> >> in
> >> >> >> a
> >> >> >> >> > constructor can achieve safe-publication.
> >> >> >> >>
> >> >> >> >> Well, actually I do not understand your point. If I use
> some
> >> >> >> >> kind
> >> >> of
> >> >> >> >> synchronization to make methods of my object thread-safe --
> >> >> >> >> can't
> >> >> I
> >> >> >> >> also apply same thing to constructor? For me, it makes the
> >> >> >> >> thing
> >> >> >> only
> >> >> >> >> clearer. Object can be thread-safe -- and it is totally
> thread
> >> >> safe.
> >> >> >> >> Object can require external synchronization for correct
> >> >> >> multithreaded
> >> >> >> >> use -- and it requires the sync for publishing and for
> usage
> >> >> also.
> >> >> >> >>
> >> >> >> >> From my point of view, the distinction you talking about is
> >> >> >> >> more historically reasoned. "Sync method if you want it to
> be
> >> >> >> >> thread-
> >> >> >> safe"
> >> >> >> >> is commonly learned mantra, but "take care of
> initialization
> >> >> also"
> >> >> >> is
> >> >> >> >> not so common. More information about it, more education,
> more
> >> >> >> >> different code samples with outlined "here is the dragons"
> will
> >> >> >> change
> >> >> >> >> the situation, I sure, it just have to be highlighted more
> often.
> >> >> >> >>
> >> >> >> >>
> >> >> >> >> > People have to recognize that sharing an object requires
> >> >> >> >> > shared
> >> >> >> mutable
> >> >> >> >> > state, and the number one tenet of concurrent programming
> is
> >> >> that
> >> >> >> access
> >> >> >> >> > to
> >> >> >> >> > shared mutable state has to be synchronized (in a general
> >> >> >> >> > sense
> >> >> >> not
> >> >> >> >> > specifically use of 'synchronized' keyword).
> >> >> >> >> >
> >> >> >> >> > Making every object safely publishable could be done, but
> for
> >> >> 99%
> >> >> >> of
> >> >> >> >> > objects
> >> >> >> >> > it would be a waste of effort. Programs without data
> races
> >> >> don't
> >> >> >> have
> >> >> >> >> > issues
> >> >> >> >> > with unsafe publication.
> >> >> >> >> >
> >> >> >> >> > David
> >> >> >> >> >
> >> >> >> >> > -----Original Message-----
> >> >> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
> >> >> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On
> Behalf
> >> >> >> >> > Of
> >> >> >> Nathan
> >> >> >> >> > Reynolds
> >> >> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
> >> >> >> >> > To: concurrency-interest at cs.oswego.edu
> >> >> >> >> > Subject: Re: [concurrency-interest] Double Checked
> Locking in
> >> >> >> OpenJDK
> >> >> >> >> >
> >> >> >> >> > We seem to be splitting two notions (i.e thread-safe and
> safe
> >> >> >> >> > publication)
> >> >> >> >> > when they should be combined in a sense.  Typically, when
> we
> >> >> say
> >> >> >> >> > thread-safe
> >> >> >> >> > we talk about the operations performed on the object
> after it
> >> >> was
> >> >> >> >> > constructed (and its contents are globally visible).
> >> >> >> >> > However,
> >> >> we
> >> >> >> need
> >> >> >> >> > to
> >> >> >> >> > consider that executing the constructor is modifying the
> >> >> >> >> > state
> >> >> of
> >> >> >> the
> >> >> >> >> > object.  It requires the same mechanisms that the rest of
> the
> >> >> >> class uses
> >> >> >> >> > to
> >> >> >> >> > ensure thread-safety.  Even though, there is only 1
> thread
> >> >> >> executing the
> >> >> >> >> > constructor, a proper releasing of a lock or some other
> >> >> happens-
> >> >> >> before
> >> >> >> >> > construct is required to ensure that the memory updates
> by
> >> >> >> >> > the
> >> >> >> thread
> >> >> >> >> > are
> >> >> >> >> > made globally visible before the object is accessed by
> >> >> >> >> > another
> >> >> >> thread.
> >> >> >> >> > This
> >> >> >> >> > is what we are calling safe publication.  So, safe
> >> >> >> >> > publication
> >> >> is
> >> >> >> a
> >> >> >> >> > subset
> >> >> >> >> > of thread-safety except it is limited to what happens
> after
> >> >> >> >> > the constructor is called and before the object is used
> by
> >> >> >> >> > multiple threads.
> >> >> >> >> >
> >> >> >> >> > A beautifully-written class can be thread-safe with
> respect
> >> >> >> >> > to
> >> >> >> calling
> >> >> >> >> > its
> >> >> >> >> > member methods but not thread-safe with respect to
> calling
> >> >> >> >> > its constructor.
> >> >> >> >> > It is this latter case that many stumble upon because
> they
> >> >> think
> >> >> >> that
> >> >> >> >> > constructors are inherently thread-safe because they are
> >> >> executed
> >> >> >> >> > single-threadedly.  What they fail to realize is that the
> >> >> >> execution of a
> >> >> >> >> > constructor can overlap with the execution of other code
> from
> >> >> the
> >> >> >> view
> >> >> >> >> > point
> >> >> >> >> > of what is happening in memory.  This same problem
> applies to
> >> >> more
> >> >> >> rare
> >> >> >> >> > case
> >> >> >> >> > of regular methods which can be proven to execute in a
> single
> >> >> >> thread but
> >> >> >> >> > don't use synchronization before multiple threads start
> >> >> accessing
> >> >> >> the
> >> >> >> >> > shared
> >> >> >> >> > data.
> >> >> >> >> >
> >> >> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
> >> >> >> 602.333.9091
> >> >> >> >> > Oracle PSR Engineering | Server Technology On 8/13/2012
> 4:08
> >> >> >> >> > PM, David Holmes wrote:
> >> >> >> >> >
> >> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >> >
> >> >> >> >> > For me it is confusing: java has only one way to have
> really
> >> >> >> immutable
> >> >> >> >> > object, and this way also gives you a total thread safety
> >> >> >> >> > even
> >> >> for
> >> >> >> >> > data race based publication. But then docs refer object
> as
> >> >> >> "immutable
> >> >> >> >> > and thread-safe" -- we still can't assume it to be really
> >> >> thread-
> >> >> >> safe?
> >> >> >> >> >
> >> >> >> >> > It is better/simpler to isolate the notion of thread-
> safety
> >> >> >> >> > and
> >> >> >> safe
> >> >> >> >> > publication. Thread-safety comes into play after you have
> >> >> safely
> >> >> >> shared
> >> >> >> >> > an
> >> >> >> >> > object. The means by which you safely share an object is
> >> >> >> orthogonal to
> >> >> >> >> > how
> >> >> >> >> > the object itself is made thread-safe.
> >> >> >> >> >
> >> >> >> >> > The means by which an object is shared has to involve
> shared
> >> >> >> mutable
> >> >> >> >> > state,
> >> >> >> >> > and use of shared mutable state always needs some form of
> >> >> >> >> > synchronization (either implicit eg due to static
> >> >> >> >> > initialization; or explicit
> >> >> by
> >> >> >> using
> >> >> >> >> > volatile or synchronized getter/setter methods).
> >> >> >> >> >
> >> >> >> >> > David
> >> >> >> >> > -----
> >> >> >> >> >
> >> >> >> >> > It's a pity, especially because true immutability gives
> us
> >> >> >> >> > some chances of performance optimization. As in this case
> --
> >> >> >> >> > we do
> >> >> not
> >> >> >> >> > really need .path to be volatile here, if we would assume
> >> >> >> >> > Path
> >> >> to
> >> >> >> be
> >> >> >> >> > truly immutable. volatility here required only for
> ensuring
> >> >> safe
> >> >> >> >> > publishing.
> >> >> >> >> >
> >> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >> >
> >> >> >> >> > Ruslan Cheremin writes:>
> >> >> >> >> >
> >> >> >> >> > But is there a way to define "safe for data race
> publishing"?
> >> >> >> >> > I
> >> >> as
> >> >> >> >> > far, as I remember, "immutable and thread-safe" is
> standard
> >> >> mantra
> >> >> >> in
> >> >> >> >> > JDK javadocs for totally safe objects. j.l.String has
> same
> >> >> mantra
> >> >> >> --
> >> >> >> >> > and it is safe for any way of publishing. Does you mean,
> I
> >> >> should
> >> >> >> >> > explicitly add "safe even for publishing via data race"
> in
> >> >> docs?
> >> >> >> But I
> >> >> >> >> > can't remember any such phrase in JDK docs.
> >> >> >> >> >
> >> >> >> >> > I don't recall anything in the JDK docs that mention
> being
> >> >> >> >> >
> >> >> >> >> > "totally safe"
> >> >> >> >> >
> >> >> >> >> > regardless of publication mechanism. Some classes, eg
> String,
> >> >> have
> >> >> >> been
> >> >> >> >> > defined such that they do have that property (for
> security
> >> >> >> reasons). In
> >> >> >> >> > general neither "thread-safe" nor "immutable" imply
> >> >> >> >> > safe-for-unsynchronized-publication.
> >> >> >> >> >
> >> >> >> >> > Java Concurrency In Practice (jcip.net) does define
> >> >> >> >> > additional
> >> >> >> potential
> >> >> >> >> > annotations, where @Immutable would indeed capture the
> >> >> requirement
> >> >> >> of
> >> >> >> >> > safe-for-unsynchronized-publication.
> >> >> >> >> >
> >> >> >> >> > David
> >> >> >> >> > -----
> >> >> >> >> >
> >> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >> >
> >> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >> >
> >> >> >> >> > Well, Path javadoc explicitly says "immutable and safe
> for
> >> >> >> >> > multithreaded use". Although it is not strictly defined
> in
> >> >> >> >> > java
> >> >> >> what
> >> >> >> >> > exactly means "safe for multithreaded use" -- does it
> mean
> >> >> >> >> > safe
> >> >> >> for
> >> >> >> >> > publishing via data race, among others? -- I suppose, it
> >> >> >> >> >
> >> >> >> >> > should be. Am
> >> >> >> >> >
> >> >> >> >> > I wrong here?
> >> >> >> >> >
> >> >> >> >> > "safe for multi-threaded use" does not generally imply
> that
> >> >> >> >> > it
> >> >> >> >> >
> >> >> >> >> > is safe to
> >> >> >> >> >
> >> >> >> >> > publish instances without synchronization of some form.
> >> >> >> >> >
> >> >> >> >> > David
> >> >> >> >> > -----
> >> >> >> >> >
> >> >> >> >> > From other side, File.toPath javadoc explicitly says what
> >> >> >> "returned
> >> >> >> >> > instance must be the same for every invocation", so sync
> >> >> >> >> > block
> >> >> is
> >> >> >> >> > required here for mutual exclusion on initialization
> phase.
> >> >> >> Without
> >> >> >> >> > this requirement it is also safe to live without sync
> block,
> >> >> >> afaik.
> >> >> >> >> >
> >> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >> >
> >> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >> >
> >> >> >> >> > First of all, Path is immutable, so DCL is safe here even
> >> >> without
> >> >> >> >> > volatile. Volatile here is not required from my point of
> view.
> >> >> >> >> >
> >> >> >> >> > Without the volatile the Path implementation (Path is an
> >> >> >> >> >
> >> >> >> >> > interface) must be
> >> >> >> >> >
> >> >> >> >> > such that an instance of Path can be safely published
> without
> >> >> >> >> >
> >> >> >> >> > any additional
> >> >> >> >> >
> >> >> >> >> > forms of synchronization. Immutability does not in itself
> >> >> >> >> >
> >> >> >> >> > ensure that. You
> >> >> >> >> >
> >> >> >> >> > would have to examine the actual implementation class.
> >> >> >> >> >
> >> >> >> >> > David Holmes
> >> >> >> >> > ------------
> >> >> >> >> >
> >> >> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >> >> >
> >> >> >> >> > Hi Richard,
> >> >> >> >> >
> >> >> >> >> > The variable "filePath" is volatile, so the double-
> checked
> >> >> >> >> >
> >> >> >> >> > locking is correct in this case. It would have been a bug
> >> >> >> >> >
> >> >> >> >> > prior to Java 5.
> >> >> >> >> >
> >> >> >> >> > Best regards,
> >> >> >> >> >
> >> >> >> >> > Dmitry Vyazelenko
> >> >> >> >> >
> >> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >> >> >
> >> >> >> >> > <richard.warburton at gmail.com> wrote:
> >> >> >> >> >
> >> >> >> >> > Hello,
> >> >> >> >> >
> >> >> >> >> > The current implementation of java.io.File::toPath [0]
> >> >> >> >> >
> >> >> >> >> > appears to be
> >> >> >> >> >
> >> >> >> >> > using the double checked locking pattern:
> >> >> >> >> >
> >> >> >> >> >     public Path toPath() {
> >> >> >> >> >         Path result = filePath;
> >> >> >> >> >         if (result == null) {
> >> >> >> >> >             synchronized (this) {
> >> >> >> >> >                 result = filePath;
> >> >> >> >> >                 if (result == null) {
> >> >> >> >> >                     result =
> >> >> >> >> >
> >> >> >> >> > FileSystems.getDefault().getPath(path);
> >> >> >> >> >
> >> >> >> >> >                     filePath = result;
> >> >> >> >> >                 }
> >> >> >> >> >             }
> >> >> >> >> >         }
> >> >> >> >> >         return result;
> >> >> >> >> >     }
> >> >> >> >> >
> >> >> >> >> > I was going to report the bug, but I'm a little
> >> >> >> >> >
> >> >> >> >> > uncertain of the
> >> >> >> >> >
> >> >> >> >> > interaction between the local variable 'result' and DCL
> >> >> >> >> >
> >> >> >> >> > since I've
> >> >> >> >> >
> >> >> >> >> > previously only seen the checking condition on the
> >> >> >> >> >
> >> >> >> >> > shared field
> >> >> >> >> >
> >> >> >> >> > itself.  Can someone here either confirm that its a bug
> or
> >> >> >> >> >
> >> >> >> >> > explain how
> >> >> >> >> >
> >> >> >> >> > the 'result' variable is fixing things?
> >> >> >> >> >
> >> >> >> >> > regards,
> >> >> >> >> >
> >> >> >> >> >  Richard
> >> >> >> >> >
> >> >> >> >> > [0] See the end of
> >> >> >> >> >
> >> >> >> >> >
> >> >>
> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >> >> >
> >> >> >> >> > ses/java/io/File.java
> >> >> >> >> >
> >> >> >> >> > _______________________________________________
> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> interest
> >> >> >> >> >
> >> >> >> >> > _______________________________________________
> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> interest
> >> >> >> >> >
> >> >> >> >> > _______________________________________________
> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> interest
> >> >> >> >> >
> >> >> >> >> > _______________________________________________
> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> interest
> >> >> >> >> >
> >> >> >> >> >
> >> >> >> >> >
> >> >> >> >> > _______________________________________________
> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> interest
> >> >> >> >> >
> >> >> >> >> _______________________________________________
> >> >> >> >> Concurrency-interest mailing list
> >> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> >
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> _______________________________________________
> >> >> >> Concurrency-interest mailing list
> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >
> >> >> > _______________________________________________
> >> >> > Concurrency-interest mailing list
> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From cheremin at gmail.com  Thu Aug 16 17:46:42 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Fri, 17 Aug 2012 01:46:42 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F60F39@G4W3296.americas.hpqcorp.net>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
	<CAOwENiJL3CaXFN=YAu334NbSy8rg8JabkVNH7HA6Po=+-XxUXQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60F39@G4W3296.americas.hpqcorp.net>
Message-ID: <CAOwENi+=tHa6aeuW8-C3EUDK8Dd-ACXLr92XgpYOpJ8PJznouw@mail.gmail.com>

Well, but why does it more tricky then now? It's just [L1,L2,L3,RAM]
who is subject to hardware coherence, but there is still some "memory"
atop of it -- e.g. registers, store buffers. They are not sync-ed
implicitly, you need explicitly store register in memory location, and
issue appropriate fence (strong enough to force store buffers flash)
to this value become visible to others. What is the difference between
this, and having all, say, L1 to behave same way -- does not sync
until eviction or explicit fence of some kind?

May be I'm asking about some well-known things, but I was sure
hardware cache coherence was an engineer solution to marketing problem
-- simplify switching from vertical Ghz race to horizontal multicores
race. I've thought hw-cc implementation become more complex and less
effective with number of cores growing -- doesn't it?

2012/8/17 Boehm, Hans <hans.boehm at hp.com>:
> That's very different from the way current architectures work.  Once something is in L1, it's essentially visible to everyone, because it's subject to the cache coherency protocol.  If I write a value, it may stay only in my L1 for a long time, but if another processor asks for that cache line, it needs to talk to me.  Most, though not all, architectures guarantee cache coherence, i.e. that accesses to a single variable look sequentially consistent.  I think that changing this gets you into the realm of very different machine language memory models, which I'm not sure are reasonably programmable.  If you allowed writes to the same location by different processors to stay unsynchronized until later, how do you then resolve the conflict?  I think this gets into really tricky issues very quickly.
>
> Hans
>
>> -----Original Message-----
>> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
>> Sent: Thursday, August 16, 2012 12:56 PM
>> To: Boehm, Hans
>> Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
>> dholmes at ieee.org
>> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
>>
>> Thank you for reference, Hans.
>>
>> About synchronization -- I was very surprised to read your results.
>> Well, yes, uncontended synchronization is just a matter of fences,
>> which has small influence on memory bandwidth. But it seems for me to
>> be true only with hardware coherency. Currently we'll have only
>> limited store buffer which keep "yet out of sync" writes, and allows
>> some -- limited -- number of optimization, like write combining and
>> write-read forwarding. So, fence, which forces buffer to drain, only
>> prevent exactly this limited number of optimization -- ok, I see how
>> it can be not a bid deal. But if all data in L1 can stay out of sync
>> until eviction? Delaying sync here as long as possible could -- from
>> my point of view -- reduce interconnect traffic impressively. And in
>> this case fence can be big performance killer. The more cached data
>> can be out of sync, the more is the cost of fences which forces the
>> sync -- am I miss something?
>>
>>
>>
>> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
>> > The standard reference for the JMM problems is Sevcik and Aspinall,
>> "On validity of program transformations in the Java Memory Model",
>> ECOOP 2008.  I became convinced in a java memory model discussion a
>> couple of years ago or so (also including Jaroslav Sevcik) that that's
>> not the only problem, but it is a serious problem.
>> >
>> > I'm unconvinced that removing the synchronization to prevent data
>> races generally improves scalability in the normal sense.  Improving or
>> removing coarser-grained synchronization clearly can.  On x86, fences
>> in particular seem to be executed entirely locally; they add
>> significant overhead at low core counts.  Based on limited experiments,
>> they become increasingly insignificant as you reach other scaling
>> limits, e.g. memory bandwidth.  This is consistent with the usual
>> intuition that fences wait for store buffers to drain.  Even more
>> limited experiments on POWER were, to my surprise, also largely
>> consistent with that.  For a recent experiment I ran in support of a
>> workshop submission, this even tends to be true for acquiring locks
>> solely to avoid data races.  The difference between synchronized and
>> racy performance DECREASED dramatically with the number of
>> threads/cores.
>> >
>> > This doesn't mean that synchronization to avoid data races is
>> entirely free, but only that it's cost doesn't increase, and often
>> decreases with scale.  Doug may well have run more careful experiments
>> around this.
>> >
>> > Hans
>> >
>> >> -----Original Message-----
>> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
>> >> Sent: Wednesday, August 15, 2012 2:19 PM
>> >> To: Boehm, Hans
>> >> Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
>> >> dholmes at ieee.org
>> >> Subject: Re: [concurrency-interest] Double Checked Locking in
>> OpenJDK
>> >>
>> >> Well, I understand your point.
>> >>
>> >> But this lead me to another interesting question -- why data races
>> is so
>> >> outlaw? Yes, I understand, it is hard to write correct code with
>> them (by the
>> >> way, can you give the link about errors in JMM spec about data race
>> you've
>> >> mention above?), but can we scale really well with sequentially
>> consistent
>> >> execution only? I mean, in large-scale distributed systems design
>> weakening
>> >> consistency often gives great performance benefits. AndwWhen I think
>> >> about something like 786-cores (skip the brand) box, it seems for me
>> there
>> >> could be many chances to improve performance using racy code. Am I
>> miss
>> >> something here?
>> >>
>> >> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
>> >> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
>> >> >>
>> >> >> As far, as I can see, there is two directions. One is what
>> >> >> "thread-safe" notation in it's commonly used form -- then applied
>> >> >> only to methods, and not to initialization/publication -- is
>> >> >> confusing, and there is little reason to exclude
>> >> >> construction/publication from thread safety protocol by default.
>> My
>> >> >> point, among others, is that "immutable and thread safe" should
>> be
>> >> >> interpreted as "thread safe even for unsafe publishing". And
>> this,
>> >> >> for example, gives us the chance to remove volatile specification
>> in
>> >> >> File.path field we started from :)
>> >> > It seems to me that there's a huge difference here.
>> Synchronization in the
>> >> constructor only matters in the presence of other dubious
>> programming
>> >> practices:  Either a reference to the object has to escape before
>> the
>> >> constructor finishes, or the reference has to be communicated to
>> another
>> >> thread in a racy manner.  (And the former is a special case under
>> control of
>> >> the class itself.)  There are strong reasons to avoid both in the
>> vast majority
>> >> of code.  On the other hand, perfectly normal code will routinely
>> rely on the
>> >> thread-safety of non-constructor methods all the time.
>> >> >
>> >> >>
>> >> >> Second direction is about construction/publication as
>> specifically
>> >> >> different from the methods. E.g. it even may have additional
>> safety
>> >> >> guarantee -- like "publication is always safe". I can see some
>> >> >> reasons here, since constructor is the only one method, which is
>> >> >> guaranteed to be called only once on object lifecycle, and so we,
>> >> >> possible, can restrict some compiler/CPUs optimization in it with
>> >> >> little influence on overall application performance -- but it
>> throws
>> >> >> away all troubles with unsafe publishing.
>> >> > I think we're still generally using "unsafe publishing" to mean
>> either of the
>> >> two dubious practices I mentioned above, though here we're
>> presumably
>> >> talking about racy publication after the constructor completes.  The
>> problem
>> >> is that in general racy publication is already a really bad
>> practice, because the
>> >> user has to understand the ugly details of the Java memory model,
>> which
>> >> nobody really does.  Racy publication is a data race, and hence you
>> can no
>> >> longer reason in terms of sequential consistency, synchronization-
>> free
>> >> regions become nonatomic, and generally all our intuition about
>> behavior of
>> >> threads and reasoning about threads goes out the window, even if you
>> can
>> >> still reason about the integrity of your class.  There are one or
>> two special
>> >> cases, notably lazy initialization of an immutable object, where you
>> might
>> >> succeed in hiding all that mess behind a library API, but in general
>> that's hard.
>> >> So the question in my mind is whether you want to provide those
>> added
>> >> guarantees to support those one or two cases, or whether you want to
>> limit
>> >> those guarantees to situations, notably those involving final
>> fields, where
>> >> they're essential for the security model.  We currently have the
>> latter.
>> >> >
>> >> > Hans
>> >> >>
>> >> >>
>> >> >>
>> >> >> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
>> >> >> > Agreed.
>> >> >> >
>> >> >> > But, echoing David, I think, I'm not at all sure I see where
>> this
>> >> >> thread is going.  We've established that
>> >> >> >
>> >> >> > a) You can make a class safe against racy publication by
>> >> >> synchronizing the constructor along with all other methods (or by
>> >> >> using an immutable class with final fields).
>> >> >> >
>> >> >> > b) There are (rather brittle and obscure) use cases in which
>> racy
>> >> >> publication gives you better performance on architectures like
>> ARM,
>> >> >> though not x86, currently at the cost of confusing data race
>> detectors.
>> >> >> >
>> >> >> > But to me it seems like taking advanatage of (b) is a fairly
>> >> >> undesirable, though perhaps occasionally unavoidable, hack.  And
>> I
>> >> >> can't see why it would possibly be a win if you have to
>> synchronize
>> >> >> all method calls to make it work.
>> >> >> >
>> >> >> > Does anyone have a use case in mind where the whole picture
>> we're
>> >> >> discussing actually makes sense?  It might help to focus this
>> >> >> discussion.
>> >> >> >
>> >> >> > Hans
>> >> >> >
>> >> >> >> -----Original Message-----
>> >> >> >> From: concurrency-interest-bounces at cs.oswego.edu
>> >> >> [mailto:concurrency-
>> >> >> >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
>> >> >> >> Sent: Wednesday, August 15, 2012 10:56 AM
>> >> >> >> To: Yuval Shavit
>> >> >> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
>> >> >> >> Subject: Re: [concurrency-interest] Double Checked Locking in
>> >> >> OpenJDK
>> >> >> >>
>> >> >> >> I thought the conclusion of that thread is that synchronizing
>> >> >> >> constructor has the desired merit - if all constructors and
>> >> >> >> methods are synchronized, a non-creating thread won't observe
>> the
>> >> >> zero/partial
>> >> >> >> state of the object, even if the object reference is published
>> >> >> >> unsafely.
>> >> >> >>
>> >> >> >> (One guy, who shall remain nameless, muddied the water with
>> some
>> >> >> >> mistaken statements of weaker memory guarantee. He has been
>> >> >> corrected)
>> >> >> >>
>> >> >> >> Zhong Yu
>> >> >> >>
>> >> >> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
>> >> >> >> <yshavit at akiban.com>
>> >> >> >> wrote:
>> >> >> >> > There was a discussion here a few months ago about
>> synchronizing
>> >> >> >> > constructors -- I had asked why it's not allowed, and the
>> >> >> discussion
>> >> >> >> hit on
>> >> >> >> > some of the similar points brought up in this thread.
>> >> >> >> >
>> >> >> >> > But to your point specifically, synchronizing a constructor
>> (via
>> >> >> >> > "synchronized(this) {...}" surrounding its body) still
>> doesn't
>> >> >> give
>> >> >> >> you full
>> >> >> >> > thread safety (even assuming immutability after the
>> constructor
>> >> >> >> > --
>> >> >> >> but
>> >> >> >> > without final fields). It ensures that a thread can observe
>> the
>> >> >> >> object
>> >> >> >> > either fully constructed *or* with all its fields having
>> their
>> >> >> >> default
>> >> >> >> > values. In other words, even if your constructor is
>> synchronized
>> >> >> on
>> >> >> >> the same
>> >> >> >> > object your getter is, a thread could observe a field as it
>> was
>> >> >> >> before the
>> >> >> >> > constructor was invoked.
>> >> >> >> >
>> >> >> >> > http://markmail.org/message/mav53xzo4bqu7udw
>> >> >> >> >
>> >> >> >> >
>> >> >> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
>> >> >> >> <cheremin at gmail.com>
>> >> >> >> > wrote:
>> >> >> >> >>
>> >> >> >> >> > The reason to keep them distinct is because in general
>> the
>> >> >> >> mechanisms
>> >> >> >> >> > for
>> >> >> >> >> > safe publication are external to the class, while those
>> for
>> >> >> >> >> > thread-safety are internal. It is only an edge case where
>> use
>> >> >> >> >> > of synchronized
>> >> >> in
>> >> >> >> a
>> >> >> >> >> > constructor can achieve safe-publication.
>> >> >> >> >>
>> >> >> >> >> Well, actually I do not understand your point. If I use
>> some
>> >> >> >> >> kind
>> >> >> of
>> >> >> >> >> synchronization to make methods of my object thread-safe --
>> >> >> >> >> can't
>> >> >> I
>> >> >> >> >> also apply same thing to constructor? For me, it makes the
>> >> >> >> >> thing
>> >> >> >> only
>> >> >> >> >> clearer. Object can be thread-safe -- and it is totally
>> thread
>> >> >> safe.
>> >> >> >> >> Object can require external synchronization for correct
>> >> >> >> multithreaded
>> >> >> >> >> use -- and it requires the sync for publishing and for
>> usage
>> >> >> also.
>> >> >> >> >>
>> >> >> >> >> From my point of view, the distinction you talking about is
>> >> >> >> >> more historically reasoned. "Sync method if you want it to
>> be
>> >> >> >> >> thread-
>> >> >> >> safe"
>> >> >> >> >> is commonly learned mantra, but "take care of
>> initialization
>> >> >> also"
>> >> >> >> is
>> >> >> >> >> not so common. More information about it, more education,
>> more
>> >> >> >> >> different code samples with outlined "here is the dragons"
>> will
>> >> >> >> change
>> >> >> >> >> the situation, I sure, it just have to be highlighted more
>> often.
>> >> >> >> >>
>> >> >> >> >>
>> >> >> >> >> > People have to recognize that sharing an object requires
>> >> >> >> >> > shared
>> >> >> >> mutable
>> >> >> >> >> > state, and the number one tenet of concurrent programming
>> is
>> >> >> that
>> >> >> >> access
>> >> >> >> >> > to
>> >> >> >> >> > shared mutable state has to be synchronized (in a general
>> >> >> >> >> > sense
>> >> >> >> not
>> >> >> >> >> > specifically use of 'synchronized' keyword).
>> >> >> >> >> >
>> >> >> >> >> > Making every object safely publishable could be done, but
>> for
>> >> >> 99%
>> >> >> >> of
>> >> >> >> >> > objects
>> >> >> >> >> > it would be a waste of effort. Programs without data
>> races
>> >> >> don't
>> >> >> >> have
>> >> >> >> >> > issues
>> >> >> >> >> > with unsafe publication.
>> >> >> >> >> >
>> >> >> >> >> > David
>> >> >> >> >> >
>> >> >> >> >> > -----Original Message-----
>> >> >> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
>> >> >> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On
>> Behalf
>> >> >> >> >> > Of
>> >> >> >> Nathan
>> >> >> >> >> > Reynolds
>> >> >> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
>> >> >> >> >> > To: concurrency-interest at cs.oswego.edu
>> >> >> >> >> > Subject: Re: [concurrency-interest] Double Checked
>> Locking in
>> >> >> >> OpenJDK
>> >> >> >> >> >
>> >> >> >> >> > We seem to be splitting two notions (i.e thread-safe and
>> safe
>> >> >> >> >> > publication)
>> >> >> >> >> > when they should be combined in a sense.  Typically, when
>> we
>> >> >> say
>> >> >> >> >> > thread-safe
>> >> >> >> >> > we talk about the operations performed on the object
>> after it
>> >> >> was
>> >> >> >> >> > constructed (and its contents are globally visible).
>> >> >> >> >> > However,
>> >> >> we
>> >> >> >> need
>> >> >> >> >> > to
>> >> >> >> >> > consider that executing the constructor is modifying the
>> >> >> >> >> > state
>> >> >> of
>> >> >> >> the
>> >> >> >> >> > object.  It requires the same mechanisms that the rest of
>> the
>> >> >> >> class uses
>> >> >> >> >> > to
>> >> >> >> >> > ensure thread-safety.  Even though, there is only 1
>> thread
>> >> >> >> executing the
>> >> >> >> >> > constructor, a proper releasing of a lock or some other
>> >> >> happens-
>> >> >> >> before
>> >> >> >> >> > construct is required to ensure that the memory updates
>> by
>> >> >> >> >> > the
>> >> >> >> thread
>> >> >> >> >> > are
>> >> >> >> >> > made globally visible before the object is accessed by
>> >> >> >> >> > another
>> >> >> >> thread.
>> >> >> >> >> > This
>> >> >> >> >> > is what we are calling safe publication.  So, safe
>> >> >> >> >> > publication
>> >> >> is
>> >> >> >> a
>> >> >> >> >> > subset
>> >> >> >> >> > of thread-safety except it is limited to what happens
>> after
>> >> >> >> >> > the constructor is called and before the object is used
>> by
>> >> >> >> >> > multiple threads.
>> >> >> >> >> >
>> >> >> >> >> > A beautifully-written class can be thread-safe with
>> respect
>> >> >> >> >> > to
>> >> >> >> calling
>> >> >> >> >> > its
>> >> >> >> >> > member methods but not thread-safe with respect to
>> calling
>> >> >> >> >> > its constructor.
>> >> >> >> >> > It is this latter case that many stumble upon because
>> they
>> >> >> think
>> >> >> >> that
>> >> >> >> >> > constructors are inherently thread-safe because they are
>> >> >> executed
>> >> >> >> >> > single-threadedly.  What they fail to realize is that the
>> >> >> >> execution of a
>> >> >> >> >> > constructor can overlap with the execution of other code
>> from
>> >> >> the
>> >> >> >> view
>> >> >> >> >> > point
>> >> >> >> >> > of what is happening in memory.  This same problem
>> applies to
>> >> >> more
>> >> >> >> rare
>> >> >> >> >> > case
>> >> >> >> >> > of regular methods which can be proven to execute in a
>> single
>> >> >> >> thread but
>> >> >> >> >> > don't use synchronization before multiple threads start
>> >> >> accessing
>> >> >> >> the
>> >> >> >> >> > shared
>> >> >> >> >> > data.
>> >> >> >> >> >
>> >> >> >> >> > Nathan Reynolds | Consulting Member of Technical Staff |
>> >> >> >> 602.333.9091
>> >> >> >> >> > Oracle PSR Engineering | Server Technology On 8/13/2012
>> 4:08
>> >> >> >> >> > PM, David Holmes wrote:
>> >> >> >> >> >
>> >> >> >> >> > Ruslan Cheremin writes:
>> >> >> >> >> >
>> >> >> >> >> > For me it is confusing: java has only one way to have
>> really
>> >> >> >> immutable
>> >> >> >> >> > object, and this way also gives you a total thread safety
>> >> >> >> >> > even
>> >> >> for
>> >> >> >> >> > data race based publication. But then docs refer object
>> as
>> >> >> >> "immutable
>> >> >> >> >> > and thread-safe" -- we still can't assume it to be really
>> >> >> thread-
>> >> >> >> safe?
>> >> >> >> >> >
>> >> >> >> >> > It is better/simpler to isolate the notion of thread-
>> safety
>> >> >> >> >> > and
>> >> >> >> safe
>> >> >> >> >> > publication. Thread-safety comes into play after you have
>> >> >> safely
>> >> >> >> shared
>> >> >> >> >> > an
>> >> >> >> >> > object. The means by which you safely share an object is
>> >> >> >> orthogonal to
>> >> >> >> >> > how
>> >> >> >> >> > the object itself is made thread-safe.
>> >> >> >> >> >
>> >> >> >> >> > The means by which an object is shared has to involve
>> shared
>> >> >> >> mutable
>> >> >> >> >> > state,
>> >> >> >> >> > and use of shared mutable state always needs some form of
>> >> >> >> >> > synchronization (either implicit eg due to static
>> >> >> >> >> > initialization; or explicit
>> >> >> by
>> >> >> >> using
>> >> >> >> >> > volatile or synchronized getter/setter methods).
>> >> >> >> >> >
>> >> >> >> >> > David
>> >> >> >> >> > -----
>> >> >> >> >> >
>> >> >> >> >> > It's a pity, especially because true immutability gives
>> us
>> >> >> >> >> > some chances of performance optimization. As in this case
>> --
>> >> >> >> >> > we do
>> >> >> not
>> >> >> >> >> > really need .path to be volatile here, if we would assume
>> >> >> >> >> > Path
>> >> >> to
>> >> >> >> be
>> >> >> >> >> > truly immutable. volatility here required only for
>> ensuring
>> >> >> safe
>> >> >> >> >> > publishing.
>> >> >> >> >> >
>> >> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >> >> >
>> >> >> >> >> > Ruslan Cheremin writes:>
>> >> >> >> >> >
>> >> >> >> >> > But is there a way to define "safe for data race
>> publishing"?
>> >> >> >> >> > I
>> >> >> as
>> >> >> >> >> > far, as I remember, "immutable and thread-safe" is
>> standard
>> >> >> mantra
>> >> >> >> in
>> >> >> >> >> > JDK javadocs for totally safe objects. j.l.String has
>> same
>> >> >> mantra
>> >> >> >> --
>> >> >> >> >> > and it is safe for any way of publishing. Does you mean,
>> I
>> >> >> should
>> >> >> >> >> > explicitly add "safe even for publishing via data race"
>> in
>> >> >> docs?
>> >> >> >> But I
>> >> >> >> >> > can't remember any such phrase in JDK docs.
>> >> >> >> >> >
>> >> >> >> >> > I don't recall anything in the JDK docs that mention
>> being
>> >> >> >> >> >
>> >> >> >> >> > "totally safe"
>> >> >> >> >> >
>> >> >> >> >> > regardless of publication mechanism. Some classes, eg
>> String,
>> >> >> have
>> >> >> >> been
>> >> >> >> >> > defined such that they do have that property (for
>> security
>> >> >> >> reasons). In
>> >> >> >> >> > general neither "thread-safe" nor "immutable" imply
>> >> >> >> >> > safe-for-unsynchronized-publication.
>> >> >> >> >> >
>> >> >> >> >> > Java Concurrency In Practice (jcip.net) does define
>> >> >> >> >> > additional
>> >> >> >> potential
>> >> >> >> >> > annotations, where @Immutable would indeed capture the
>> >> >> requirement
>> >> >> >> of
>> >> >> >> >> > safe-for-unsynchronized-publication.
>> >> >> >> >> >
>> >> >> >> >> > David
>> >> >> >> >> > -----
>> >> >> >> >> >
>> >> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >> >> >
>> >> >> >> >> > Ruslan Cheremin writes:
>> >> >> >> >> >
>> >> >> >> >> > Well, Path javadoc explicitly says "immutable and safe
>> for
>> >> >> >> >> > multithreaded use". Although it is not strictly defined
>> in
>> >> >> >> >> > java
>> >> >> >> what
>> >> >> >> >> > exactly means "safe for multithreaded use" -- does it
>> mean
>> >> >> >> >> > safe
>> >> >> >> for
>> >> >> >> >> > publishing via data race, among others? -- I suppose, it
>> >> >> >> >> >
>> >> >> >> >> > should be. Am
>> >> >> >> >> >
>> >> >> >> >> > I wrong here?
>> >> >> >> >> >
>> >> >> >> >> > "safe for multi-threaded use" does not generally imply
>> that
>> >> >> >> >> > it
>> >> >> >> >> >
>> >> >> >> >> > is safe to
>> >> >> >> >> >
>> >> >> >> >> > publish instances without synchronization of some form.
>> >> >> >> >> >
>> >> >> >> >> > David
>> >> >> >> >> > -----
>> >> >> >> >> >
>> >> >> >> >> > From other side, File.toPath javadoc explicitly says what
>> >> >> >> "returned
>> >> >> >> >> > instance must be the same for every invocation", so sync
>> >> >> >> >> > block
>> >> >> is
>> >> >> >> >> > required here for mutual exclusion on initialization
>> phase.
>> >> >> >> Without
>> >> >> >> >> > this requirement it is also safe to live without sync
>> block,
>> >> >> >> afaik.
>> >> >> >> >> >
>> >> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
>> >> >> >> >> >
>> >> >> >> >> > Ruslan Cheremin writes:
>> >> >> >> >> >
>> >> >> >> >> > First of all, Path is immutable, so DCL is safe here even
>> >> >> without
>> >> >> >> >> > volatile. Volatile here is not required from my point of
>> view.
>> >> >> >> >> >
>> >> >> >> >> > Without the volatile the Path implementation (Path is an
>> >> >> >> >> >
>> >> >> >> >> > interface) must be
>> >> >> >> >> >
>> >> >> >> >> > such that an instance of Path can be safely published
>> without
>> >> >> >> >> >
>> >> >> >> >> > any additional
>> >> >> >> >> >
>> >> >> >> >> > forms of synchronization. Immutability does not in itself
>> >> >> >> >> >
>> >> >> >> >> > ensure that. You
>> >> >> >> >> >
>> >> >> >> >> > would have to examine the actual implementation class.
>> >> >> >> >> >
>> >> >> >> >> > David Holmes
>> >> >> >> >> > ------------
>> >> >> >> >> >
>> >> >> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
>> >> >> >> >> >
>> >> >> >> >> > Hi Richard,
>> >> >> >> >> >
>> >> >> >> >> > The variable "filePath" is volatile, so the double-
>> checked
>> >> >> >> >> >
>> >> >> >> >> > locking is correct in this case. It would have been a bug
>> >> >> >> >> >
>> >> >> >> >> > prior to Java 5.
>> >> >> >> >> >
>> >> >> >> >> > Best regards,
>> >> >> >> >> >
>> >> >> >> >> > Dmitry Vyazelenko
>> >> >> >> >> >
>> >> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
>> >> >> >> >> >
>> >> >> >> >> > <richard.warburton at gmail.com> wrote:
>> >> >> >> >> >
>> >> >> >> >> > Hello,
>> >> >> >> >> >
>> >> >> >> >> > The current implementation of java.io.File::toPath [0]
>> >> >> >> >> >
>> >> >> >> >> > appears to be
>> >> >> >> >> >
>> >> >> >> >> > using the double checked locking pattern:
>> >> >> >> >> >
>> >> >> >> >> >     public Path toPath() {
>> >> >> >> >> >         Path result = filePath;
>> >> >> >> >> >         if (result == null) {
>> >> >> >> >> >             synchronized (this) {
>> >> >> >> >> >                 result = filePath;
>> >> >> >> >> >                 if (result == null) {
>> >> >> >> >> >                     result =
>> >> >> >> >> >
>> >> >> >> >> > FileSystems.getDefault().getPath(path);
>> >> >> >> >> >
>> >> >> >> >> >                     filePath = result;
>> >> >> >> >> >                 }
>> >> >> >> >> >             }
>> >> >> >> >> >         }
>> >> >> >> >> >         return result;
>> >> >> >> >> >     }
>> >> >> >> >> >
>> >> >> >> >> > I was going to report the bug, but I'm a little
>> >> >> >> >> >
>> >> >> >> >> > uncertain of the
>> >> >> >> >> >
>> >> >> >> >> > interaction between the local variable 'result' and DCL
>> >> >> >> >> >
>> >> >> >> >> > since I've
>> >> >> >> >> >
>> >> >> >> >> > previously only seen the checking condition on the
>> >> >> >> >> >
>> >> >> >> >> > shared field
>> >> >> >> >> >
>> >> >> >> >> > itself.  Can someone here either confirm that its a bug
>> or
>> >> >> >> >> >
>> >> >> >> >> > explain how
>> >> >> >> >> >
>> >> >> >> >> > the 'result' variable is fixing things?
>> >> >> >> >> >
>> >> >> >> >> > regards,
>> >> >> >> >> >
>> >> >> >> >> >  Richard
>> >> >> >> >> >
>> >> >> >> >> > [0] See the end of
>> >> >> >> >> >
>> >> >> >> >> >
>> >> >>
>> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
>> >> >> >> >> >
>> >> >> >> >> > ses/java/io/File.java
>> >> >> >> >> >
>> >> >> >> >> > _______________________________________________
>> >> >> >> >> > Concurrency-interest mailing list
>> >> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
>> interest
>> >> >> >> >> >
>> >> >> >> >> > _______________________________________________
>> >> >> >> >> > Concurrency-interest mailing list
>> >> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
>> interest
>> >> >> >> >> >
>> >> >> >> >> > _______________________________________________
>> >> >> >> >> > Concurrency-interest mailing list
>> >> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
>> interest
>> >> >> >> >> >
>> >> >> >> >> > _______________________________________________
>> >> >> >> >> > Concurrency-interest mailing list
>> >> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
>> interest
>> >> >> >> >> >
>> >> >> >> >> >
>> >> >> >> >> >
>> >> >> >> >> > _______________________________________________
>> >> >> >> >> > Concurrency-interest mailing list
>> >> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
>> interest
>> >> >> >> >> >
>> >> >> >> >> _______________________________________________
>> >> >> >> >> Concurrency-interest mailing list
>> >> >> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> >
>> >> >> >> >
>> >> >> >> > _______________________________________________
>> >> >> >> > Concurrency-interest mailing list
>> >> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >> >
>> >> >> >> _______________________________________________
>> >> >> >> Concurrency-interest mailing list
>> >> >> >> Concurrency-interest at cs.oswego.edu
>> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >> >
>> >> >> > _______________________________________________
>> >> >> > Concurrency-interest mailing list
>> >> >> > Concurrency-interest at cs.oswego.edu
>> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From vitalyd at gmail.com  Thu Aug 16 19:40:14 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 16 Aug 2012 19:40:14 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENi+=tHa6aeuW8-C3EUDK8Dd-ACXLr92XgpYOpJ8PJznouw@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
	<CAOwENiJL3CaXFN=YAu334NbSy8rg8JabkVNH7HA6Po=+-XxUXQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60F39@G4W3296.americas.hpqcorp.net>
	<CAOwENi+=tHa6aeuW8-C3EUDK8Dd-ACXLr92XgpYOpJ8PJznouw@mail.gmail.com>
Message-ID: <CAHjP37G+enVX-2VcnJTDNMdVpRA3fPCyi5V4r+L5V_gRnjZiTQ@mail.gmail.com>

Store buffer writes are still part of cache coherency, they just don't
publish the value to L1 right away.  The point of the store buffer is that
if CPU 1 needs to write to cache line A but doesn't have the line in its L1
(let's not forget that a write has to do a load as well), it can drop the
write in the store buffer while cache controller fetches it - this is to
avoid a stall.  If line is already in L1 it can store directly to it (and
bypass store buffer), possibly causing invalidate requests to be sent out.

I guess my point is that the store buffer is still built on top of cache
coherence and not some random bit of independent functionality.  If we say
that we'd like to turn off cache coherence, it's going to be the wild wild
west :).  You can sort of do this today with non-temporal writes, but you
better know what you're doing at that point.

Sent from my phone
On Aug 16, 2012 5:55 PM, "Ruslan Cheremin" <cheremin at gmail.com> wrote:
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120816/c23faca6/attachment.html>

From hans.boehm at hp.com  Thu Aug 16 19:11:48 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu, 16 Aug 2012 23:11:48 +0000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENi+=tHa6aeuW8-C3EUDK8Dd-ACXLr92XgpYOpJ8PJznouw@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
	<CAOwENiJL3CaXFN=YAu334NbSy8rg8JabkVNH7HA6Po=+-XxUXQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60F39@G4W3296.americas.hpqcorp.net>
	<CAOwENi+=tHa6aeuW8-C3EUDK8Dd-ACXLr92XgpYOpJ8PJznouw@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F6104C@G4W3296.americas.hpqcorp.net>

Good point.  You might conceivably be able to treat the L1 cache as part of the store buffer, though I think there are a lot of detailed issues:

- To preserve a TSO-like consistency model, I think you would need to replicate the L1 cache for each hardware thread, and somehow preserve the order of evictions to L2.  Context switches would probably need to flush L1 (bad?). I'm not sure about implications on other more complicated consistency models.

- Fences, when you do need them, become really expensive, many thousands of cycles, rather than a dozen, or a few dozen.

- The progress issues we now theorize about (do we really know that store buffers get flushed in finite time, so that e.g. a spin lock release becomes visible?) become much more real.

I'm not an expert on hardware cache coherence costs, but my impression is the architects don't entirely agree.  Current standard algorithms don't scale that well, but as far as I can tell it's hard to turn that into a convincing lower bound argument.  And there are shipping cache coherent multi-socket machines that support much larger core counts than we currently have on a chip.  They're expensive, but it's hard for me to separate fundamental hardware cost from economy of scale (smaller market for really big machines) issues.

Hans

> -----Original Message-----
> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> Sent: Thursday, August 16, 2012 2:47 PM
> To: Boehm, Hans
> Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
> dholmes at ieee.org
> Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> 
> Well, but why does it more tricky then now? It's just [L1,L2,L3,RAM]
> who is subject to hardware coherence, but there is still some "memory"
> atop of it -- e.g. registers, store buffers. They are not sync-ed
> implicitly, you need explicitly store register in memory location, and
> issue appropriate fence (strong enough to force store buffers flash)
> to this value become visible to others. What is the difference between
> this, and having all, say, L1 to behave same way -- does not sync
> until eviction or explicit fence of some kind?
> 
> May be I'm asking about some well-known things, but I was sure
> hardware cache coherence was an engineer solution to marketing problem
> -- simplify switching from vertical Ghz race to horizontal multicores
> race. I've thought hw-cc implementation become more complex and less
> effective with number of cores growing -- doesn't it?
> 
> 2012/8/17 Boehm, Hans <hans.boehm at hp.com>:
> > That's very different from the way current architectures work.  Once
> something is in L1, it's essentially visible to everyone, because it's
> subject to the cache coherency protocol.  If I write a value, it may
> stay only in my L1 for a long time, but if another processor asks for
> that cache line, it needs to talk to me.  Most, though not all,
> architectures guarantee cache coherence, i.e. that accesses to a single
> variable look sequentially consistent.  I think that changing this gets
> you into the realm of very different machine language memory models,
> which I'm not sure are reasonably programmable.  If you allowed writes
> to the same location by different processors to stay unsynchronized
> until later, how do you then resolve the conflict?  I think this gets
> into really tricky issues very quickly.
> >
> > Hans
> >
> >> -----Original Message-----
> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> >> Sent: Thursday, August 16, 2012 12:56 PM
> >> To: Boehm, Hans
> >> Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
> >> dholmes at ieee.org
> >> Subject: Re: [concurrency-interest] Double Checked Locking in
> OpenJDK
> >>
> >> Thank you for reference, Hans.
> >>
> >> About synchronization -- I was very surprised to read your results.
> >> Well, yes, uncontended synchronization is just a matter of fences,
> >> which has small influence on memory bandwidth. But it seems for me
> to
> >> be true only with hardware coherency. Currently we'll have only
> >> limited store buffer which keep "yet out of sync" writes, and allows
> >> some -- limited -- number of optimization, like write combining and
> >> write-read forwarding. So, fence, which forces buffer to drain, only
> >> prevent exactly this limited number of optimization -- ok, I see how
> >> it can be not a bid deal. But if all data in L1 can stay out of sync
> >> until eviction? Delaying sync here as long as possible could -- from
> >> my point of view -- reduce interconnect traffic impressively. And in
> >> this case fence can be big performance killer. The more cached data
> >> can be out of sync, the more is the cost of fences which forces the
> >> sync -- am I miss something?
> >>
> >>
> >>
> >> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
> >> > The standard reference for the JMM problems is Sevcik and
> Aspinall,
> >> "On validity of program transformations in the Java Memory Model",
> >> ECOOP 2008.  I became convinced in a java memory model discussion a
> >> couple of years ago or so (also including Jaroslav Sevcik) that
> that's
> >> not the only problem, but it is a serious problem.
> >> >
> >> > I'm unconvinced that removing the synchronization to prevent data
> >> races generally improves scalability in the normal sense.  Improving
> or
> >> removing coarser-grained synchronization clearly can.  On x86,
> fences
> >> in particular seem to be executed entirely locally; they add
> >> significant overhead at low core counts.  Based on limited
> experiments,
> >> they become increasingly insignificant as you reach other scaling
> >> limits, e.g. memory bandwidth.  This is consistent with the usual
> >> intuition that fences wait for store buffers to drain.  Even more
> >> limited experiments on POWER were, to my surprise, also largely
> >> consistent with that.  For a recent experiment I ran in support of a
> >> workshop submission, this even tends to be true for acquiring locks
> >> solely to avoid data races.  The difference between synchronized and
> >> racy performance DECREASED dramatically with the number of
> >> threads/cores.
> >> >
> >> > This doesn't mean that synchronization to avoid data races is
> >> entirely free, but only that it's cost doesn't increase, and often
> >> decreases with scale.  Doug may well have run more careful
> experiments
> >> around this.
> >> >
> >> > Hans
> >> >
> >> >> -----Original Message-----
> >> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> >> >> Sent: Wednesday, August 15, 2012 2:19 PM
> >> >> To: Boehm, Hans
> >> >> Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
> >> >> dholmes at ieee.org
> >> >> Subject: Re: [concurrency-interest] Double Checked Locking in
> >> OpenJDK
> >> >>
> >> >> Well, I understand your point.
> >> >>
> >> >> But this lead me to another interesting question -- why data
> races
> >> is so
> >> >> outlaw? Yes, I understand, it is hard to write correct code with
> >> them (by the
> >> >> way, can you give the link about errors in JMM spec about data
> race
> >> you've
> >> >> mention above?), but can we scale really well with sequentially
> >> consistent
> >> >> execution only? I mean, in large-scale distributed systems design
> >> weakening
> >> >> consistency often gives great performance benefits. AndwWhen I
> think
> >> >> about something like 786-cores (skip the brand) box, it seems for
> me
> >> there
> >> >> could be many chances to improve performance using racy code. Am
> I
> >> miss
> >> >> something here?
> >> >>
> >> >> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
> >> >> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> >> >> >>
> >> >> >> As far, as I can see, there is two directions. One is what
> >> >> >> "thread-safe" notation in it's commonly used form -- then
> applied
> >> >> >> only to methods, and not to initialization/publication -- is
> >> >> >> confusing, and there is little reason to exclude
> >> >> >> construction/publication from thread safety protocol by
> default.
> >> My
> >> >> >> point, among others, is that "immutable and thread safe"
> should
> >> be
> >> >> >> interpreted as "thread safe even for unsafe publishing". And
> >> this,
> >> >> >> for example, gives us the chance to remove volatile
> specification
> >> in
> >> >> >> File.path field we started from :)
> >> >> > It seems to me that there's a huge difference here.
> >> Synchronization in the
> >> >> constructor only matters in the presence of other dubious
> >> programming
> >> >> practices:  Either a reference to the object has to escape before
> >> the
> >> >> constructor finishes, or the reference has to be communicated to
> >> another
> >> >> thread in a racy manner.  (And the former is a special case under
> >> control of
> >> >> the class itself.)  There are strong reasons to avoid both in the
> >> vast majority
> >> >> of code.  On the other hand, perfectly normal code will routinely
> >> rely on the
> >> >> thread-safety of non-constructor methods all the time.
> >> >> >
> >> >> >>
> >> >> >> Second direction is about construction/publication as
> >> specifically
> >> >> >> different from the methods. E.g. it even may have additional
> >> safety
> >> >> >> guarantee -- like "publication is always safe". I can see some
> >> >> >> reasons here, since constructor is the only one method, which
> is
> >> >> >> guaranteed to be called only once on object lifecycle, and so
> we,
> >> >> >> possible, can restrict some compiler/CPUs optimization in it
> with
> >> >> >> little influence on overall application performance -- but it
> >> throws
> >> >> >> away all troubles with unsafe publishing.
> >> >> > I think we're still generally using "unsafe publishing" to mean
> >> either of the
> >> >> two dubious practices I mentioned above, though here we're
> >> presumably
> >> >> talking about racy publication after the constructor completes.
> The
> >> problem
> >> >> is that in general racy publication is already a really bad
> >> practice, because the
> >> >> user has to understand the ugly details of the Java memory model,
> >> which
> >> >> nobody really does.  Racy publication is a data race, and hence
> you
> >> can no
> >> >> longer reason in terms of sequential consistency,
> synchronization-
> >> free
> >> >> regions become nonatomic, and generally all our intuition about
> >> behavior of
> >> >> threads and reasoning about threads goes out the window, even if
> you
> >> can
> >> >> still reason about the integrity of your class.  There are one or
> >> two special
> >> >> cases, notably lazy initialization of an immutable object, where
> you
> >> might
> >> >> succeed in hiding all that mess behind a library API, but in
> general
> >> that's hard.
> >> >> So the question in my mind is whether you want to provide those
> >> added
> >> >> guarantees to support those one or two cases, or whether you want
> to
> >> limit
> >> >> those guarantees to situations, notably those involving final
> >> fields, where
> >> >> they're essential for the security model.  We currently have the
> >> latter.
> >> >> >
> >> >> > Hans
> >> >> >>
> >> >> >>
> >> >> >>
> >> >> >> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
> >> >> >> > Agreed.
> >> >> >> >
> >> >> >> > But, echoing David, I think, I'm not at all sure I see where
> >> this
> >> >> >> thread is going.  We've established that
> >> >> >> >
> >> >> >> > a) You can make a class safe against racy publication by
> >> >> >> synchronizing the constructor along with all other methods (or
> by
> >> >> >> using an immutable class with final fields).
> >> >> >> >
> >> >> >> > b) There are (rather brittle and obscure) use cases in which
> >> racy
> >> >> >> publication gives you better performance on architectures like
> >> ARM,
> >> >> >> though not x86, currently at the cost of confusing data race
> >> detectors.
> >> >> >> >
> >> >> >> > But to me it seems like taking advanatage of (b) is a fairly
> >> >> >> undesirable, though perhaps occasionally unavoidable, hack.
> And
> >> I
> >> >> >> can't see why it would possibly be a win if you have to
> >> synchronize
> >> >> >> all method calls to make it work.
> >> >> >> >
> >> >> >> > Does anyone have a use case in mind where the whole picture
> >> we're
> >> >> >> discussing actually makes sense?  It might help to focus this
> >> >> >> discussion.
> >> >> >> >
> >> >> >> > Hans
> >> >> >> >
> >> >> >> >> -----Original Message-----
> >> >> >> >> From: concurrency-interest-bounces at cs.oswego.edu
> >> >> >> [mailto:concurrency-
> >> >> >> >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
> >> >> >> >> Sent: Wednesday, August 15, 2012 10:56 AM
> >> >> >> >> To: Yuval Shavit
> >> >> >> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> >> >> >> >> Subject: Re: [concurrency-interest] Double Checked Locking
> in
> >> >> >> OpenJDK
> >> >> >> >>
> >> >> >> >> I thought the conclusion of that thread is that
> synchronizing
> >> >> >> >> constructor has the desired merit - if all constructors and
> >> >> >> >> methods are synchronized, a non-creating thread won't
> observe
> >> the
> >> >> >> zero/partial
> >> >> >> >> state of the object, even if the object reference is
> published
> >> >> >> >> unsafely.
> >> >> >> >>
> >> >> >> >> (One guy, who shall remain nameless, muddied the water with
> >> some
> >> >> >> >> mistaken statements of weaker memory guarantee. He has been
> >> >> >> corrected)
> >> >> >> >>
> >> >> >> >> Zhong Yu
> >> >> >> >>
> >> >> >> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
> >> >> >> >> <yshavit at akiban.com>
> >> >> >> >> wrote:
> >> >> >> >> > There was a discussion here a few months ago about
> >> synchronizing
> >> >> >> >> > constructors -- I had asked why it's not allowed, and the
> >> >> >> discussion
> >> >> >> >> hit on
> >> >> >> >> > some of the similar points brought up in this thread.
> >> >> >> >> >
> >> >> >> >> > But to your point specifically, synchronizing a
> constructor
> >> (via
> >> >> >> >> > "synchronized(this) {...}" surrounding its body) still
> >> doesn't
> >> >> >> give
> >> >> >> >> you full
> >> >> >> >> > thread safety (even assuming immutability after the
> >> constructor
> >> >> >> >> > --
> >> >> >> >> but
> >> >> >> >> > without final fields). It ensures that a thread can
> observe
> >> the
> >> >> >> >> object
> >> >> >> >> > either fully constructed *or* with all its fields having
> >> their
> >> >> >> >> default
> >> >> >> >> > values. In other words, even if your constructor is
> >> synchronized
> >> >> >> on
> >> >> >> >> the same
> >> >> >> >> > object your getter is, a thread could observe a field as
> it
> >> was
> >> >> >> >> before the
> >> >> >> >> > constructor was invoked.
> >> >> >> >> >
> >> >> >> >> > http://markmail.org/message/mav53xzo4bqu7udw
> >> >> >> >> >
> >> >> >> >> >
> >> >> >> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
> >> >> >> >> <cheremin at gmail.com>
> >> >> >> >> > wrote:
> >> >> >> >> >>
> >> >> >> >> >> > The reason to keep them distinct is because in general
> >> the
> >> >> >> >> mechanisms
> >> >> >> >> >> > for
> >> >> >> >> >> > safe publication are external to the class, while
> those
> >> for
> >> >> >> >> >> > thread-safety are internal. It is only an edge case
> where
> >> use
> >> >> >> >> >> > of synchronized
> >> >> >> in
> >> >> >> >> a
> >> >> >> >> >> > constructor can achieve safe-publication.
> >> >> >> >> >>
> >> >> >> >> >> Well, actually I do not understand your point. If I use
> >> some
> >> >> >> >> >> kind
> >> >> >> of
> >> >> >> >> >> synchronization to make methods of my object thread-safe
> --
> >> >> >> >> >> can't
> >> >> >> I
> >> >> >> >> >> also apply same thing to constructor? For me, it makes
> the
> >> >> >> >> >> thing
> >> >> >> >> only
> >> >> >> >> >> clearer. Object can be thread-safe -- and it is totally
> >> thread
> >> >> >> safe.
> >> >> >> >> >> Object can require external synchronization for correct
> >> >> >> >> multithreaded
> >> >> >> >> >> use -- and it requires the sync for publishing and for
> >> usage
> >> >> >> also.
> >> >> >> >> >>
> >> >> >> >> >> From my point of view, the distinction you talking about
> is
> >> >> >> >> >> more historically reasoned. "Sync method if you want it
> to
> >> be
> >> >> >> >> >> thread-
> >> >> >> >> safe"
> >> >> >> >> >> is commonly learned mantra, but "take care of
> >> initialization
> >> >> >> also"
> >> >> >> >> is
> >> >> >> >> >> not so common. More information about it, more
> education,
> >> more
> >> >> >> >> >> different code samples with outlined "here is the
> dragons"
> >> will
> >> >> >> >> change
> >> >> >> >> >> the situation, I sure, it just have to be highlighted
> more
> >> often.
> >> >> >> >> >>
> >> >> >> >> >>
> >> >> >> >> >> > People have to recognize that sharing an object
> requires
> >> >> >> >> >> > shared
> >> >> >> >> mutable
> >> >> >> >> >> > state, and the number one tenet of concurrent
> programming
> >> is
> >> >> >> that
> >> >> >> >> access
> >> >> >> >> >> > to
> >> >> >> >> >> > shared mutable state has to be synchronized (in a
> general
> >> >> >> >> >> > sense
> >> >> >> >> not
> >> >> >> >> >> > specifically use of 'synchronized' keyword).
> >> >> >> >> >> >
> >> >> >> >> >> > Making every object safely publishable could be done,
> but
> >> for
> >> >> >> 99%
> >> >> >> >> of
> >> >> >> >> >> > objects
> >> >> >> >> >> > it would be a waste of effort. Programs without data
> >> races
> >> >> >> don't
> >> >> >> >> have
> >> >> >> >> >> > issues
> >> >> >> >> >> > with unsafe publication.
> >> >> >> >> >> >
> >> >> >> >> >> > David
> >> >> >> >> >> >
> >> >> >> >> >> > -----Original Message-----
> >> >> >> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
> >> >> >> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On
> >> Behalf
> >> >> >> >> >> > Of
> >> >> >> >> Nathan
> >> >> >> >> >> > Reynolds
> >> >> >> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
> >> >> >> >> >> > To: concurrency-interest at cs.oswego.edu
> >> >> >> >> >> > Subject: Re: [concurrency-interest] Double Checked
> >> Locking in
> >> >> >> >> OpenJDK
> >> >> >> >> >> >
> >> >> >> >> >> > We seem to be splitting two notions (i.e thread-safe
> and
> >> safe
> >> >> >> >> >> > publication)
> >> >> >> >> >> > when they should be combined in a sense.  Typically,
> when
> >> we
> >> >> >> say
> >> >> >> >> >> > thread-safe
> >> >> >> >> >> > we talk about the operations performed on the object
> >> after it
> >> >> >> was
> >> >> >> >> >> > constructed (and its contents are globally visible).
> >> >> >> >> >> > However,
> >> >> >> we
> >> >> >> >> need
> >> >> >> >> >> > to
> >> >> >> >> >> > consider that executing the constructor is modifying
> the
> >> >> >> >> >> > state
> >> >> >> of
> >> >> >> >> the
> >> >> >> >> >> > object.  It requires the same mechanisms that the rest
> of
> >> the
> >> >> >> >> class uses
> >> >> >> >> >> > to
> >> >> >> >> >> > ensure thread-safety.  Even though, there is only 1
> >> thread
> >> >> >> >> executing the
> >> >> >> >> >> > constructor, a proper releasing of a lock or some
> other
> >> >> >> happens-
> >> >> >> >> before
> >> >> >> >> >> > construct is required to ensure that the memory
> updates
> >> by
> >> >> >> >> >> > the
> >> >> >> >> thread
> >> >> >> >> >> > are
> >> >> >> >> >> > made globally visible before the object is accessed by
> >> >> >> >> >> > another
> >> >> >> >> thread.
> >> >> >> >> >> > This
> >> >> >> >> >> > is what we are calling safe publication.  So, safe
> >> >> >> >> >> > publication
> >> >> >> is
> >> >> >> >> a
> >> >> >> >> >> > subset
> >> >> >> >> >> > of thread-safety except it is limited to what happens
> >> after
> >> >> >> >> >> > the constructor is called and before the object is
> used
> >> by
> >> >> >> >> >> > multiple threads.
> >> >> >> >> >> >
> >> >> >> >> >> > A beautifully-written class can be thread-safe with
> >> respect
> >> >> >> >> >> > to
> >> >> >> >> calling
> >> >> >> >> >> > its
> >> >> >> >> >> > member methods but not thread-safe with respect to
> >> calling
> >> >> >> >> >> > its constructor.
> >> >> >> >> >> > It is this latter case that many stumble upon because
> >> they
> >> >> >> think
> >> >> >> >> that
> >> >> >> >> >> > constructors are inherently thread-safe because they
> are
> >> >> >> executed
> >> >> >> >> >> > single-threadedly.  What they fail to realize is that
> the
> >> >> >> >> execution of a
> >> >> >> >> >> > constructor can overlap with the execution of other
> code
> >> from
> >> >> >> the
> >> >> >> >> view
> >> >> >> >> >> > point
> >> >> >> >> >> > of what is happening in memory.  This same problem
> >> applies to
> >> >> >> more
> >> >> >> >> rare
> >> >> >> >> >> > case
> >> >> >> >> >> > of regular methods which can be proven to execute in a
> >> single
> >> >> >> >> thread but
> >> >> >> >> >> > don't use synchronization before multiple threads
> start
> >> >> >> accessing
> >> >> >> >> the
> >> >> >> >> >> > shared
> >> >> >> >> >> > data.
> >> >> >> >> >> >
> >> >> >> >> >> > Nathan Reynolds | Consulting Member of Technical Staff
> |
> >> >> >> >> 602.333.9091
> >> >> >> >> >> > Oracle PSR Engineering | Server Technology On
> 8/13/2012
> >> 4:08
> >> >> >> >> >> > PM, David Holmes wrote:
> >> >> >> >> >> >
> >> >> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >> >> >
> >> >> >> >> >> > For me it is confusing: java has only one way to have
> >> really
> >> >> >> >> immutable
> >> >> >> >> >> > object, and this way also gives you a total thread
> safety
> >> >> >> >> >> > even
> >> >> >> for
> >> >> >> >> >> > data race based publication. But then docs refer
> object
> >> as
> >> >> >> >> "immutable
> >> >> >> >> >> > and thread-safe" -- we still can't assume it to be
> really
> >> >> >> thread-
> >> >> >> >> safe?
> >> >> >> >> >> >
> >> >> >> >> >> > It is better/simpler to isolate the notion of thread-
> >> safety
> >> >> >> >> >> > and
> >> >> >> >> safe
> >> >> >> >> >> > publication. Thread-safety comes into play after you
> have
> >> >> >> safely
> >> >> >> >> shared
> >> >> >> >> >> > an
> >> >> >> >> >> > object. The means by which you safely share an object
> is
> >> >> >> >> orthogonal to
> >> >> >> >> >> > how
> >> >> >> >> >> > the object itself is made thread-safe.
> >> >> >> >> >> >
> >> >> >> >> >> > The means by which an object is shared has to involve
> >> shared
> >> >> >> >> mutable
> >> >> >> >> >> > state,
> >> >> >> >> >> > and use of shared mutable state always needs some form
> of
> >> >> >> >> >> > synchronization (either implicit eg due to static
> >> >> >> >> >> > initialization; or explicit
> >> >> >> by
> >> >> >> >> using
> >> >> >> >> >> > volatile or synchronized getter/setter methods).
> >> >> >> >> >> >
> >> >> >> >> >> > David
> >> >> >> >> >> > -----
> >> >> >> >> >> >
> >> >> >> >> >> > It's a pity, especially because true immutability
> gives
> >> us
> >> >> >> >> >> > some chances of performance optimization. As in this
> case
> >> --
> >> >> >> >> >> > we do
> >> >> >> not
> >> >> >> >> >> > really need .path to be volatile here, if we would
> assume
> >> >> >> >> >> > Path
> >> >> >> to
> >> >> >> >> be
> >> >> >> >> >> > truly immutable. volatility here required only for
> >> ensuring
> >> >> >> safe
> >> >> >> >> >> > publishing.
> >> >> >> >> >> >
> >> >> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >> >> >
> >> >> >> >> >> > Ruslan Cheremin writes:>
> >> >> >> >> >> >
> >> >> >> >> >> > But is there a way to define "safe for data race
> >> publishing"?
> >> >> >> >> >> > I
> >> >> >> as
> >> >> >> >> >> > far, as I remember, "immutable and thread-safe" is
> >> standard
> >> >> >> mantra
> >> >> >> >> in
> >> >> >> >> >> > JDK javadocs for totally safe objects. j.l.String has
> >> same
> >> >> >> mantra
> >> >> >> >> --
> >> >> >> >> >> > and it is safe for any way of publishing. Does you
> mean,
> >> I
> >> >> >> should
> >> >> >> >> >> > explicitly add "safe even for publishing via data
> race"
> >> in
> >> >> >> docs?
> >> >> >> >> But I
> >> >> >> >> >> > can't remember any such phrase in JDK docs.
> >> >> >> >> >> >
> >> >> >> >> >> > I don't recall anything in the JDK docs that mention
> >> being
> >> >> >> >> >> >
> >> >> >> >> >> > "totally safe"
> >> >> >> >> >> >
> >> >> >> >> >> > regardless of publication mechanism. Some classes, eg
> >> String,
> >> >> >> have
> >> >> >> >> been
> >> >> >> >> >> > defined such that they do have that property (for
> >> security
> >> >> >> >> reasons). In
> >> >> >> >> >> > general neither "thread-safe" nor "immutable" imply
> >> >> >> >> >> > safe-for-unsynchronized-publication.
> >> >> >> >> >> >
> >> >> >> >> >> > Java Concurrency In Practice (jcip.net) does define
> >> >> >> >> >> > additional
> >> >> >> >> potential
> >> >> >> >> >> > annotations, where @Immutable would indeed capture the
> >> >> >> requirement
> >> >> >> >> of
> >> >> >> >> >> > safe-for-unsynchronized-publication.
> >> >> >> >> >> >
> >> >> >> >> >> > David
> >> >> >> >> >> > -----
> >> >> >> >> >> >
> >> >> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >> >> >
> >> >> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >> >> >
> >> >> >> >> >> > Well, Path javadoc explicitly says "immutable and safe
> >> for
> >> >> >> >> >> > multithreaded use". Although it is not strictly
> defined
> >> in
> >> >> >> >> >> > java
> >> >> >> >> what
> >> >> >> >> >> > exactly means "safe for multithreaded use" -- does it
> >> mean
> >> >> >> >> >> > safe
> >> >> >> >> for
> >> >> >> >> >> > publishing via data race, among others? -- I suppose,
> it
> >> >> >> >> >> >
> >> >> >> >> >> > should be. Am
> >> >> >> >> >> >
> >> >> >> >> >> > I wrong here?
> >> >> >> >> >> >
> >> >> >> >> >> > "safe for multi-threaded use" does not generally imply
> >> that
> >> >> >> >> >> > it
> >> >> >> >> >> >
> >> >> >> >> >> > is safe to
> >> >> >> >> >> >
> >> >> >> >> >> > publish instances without synchronization of some
> form.
> >> >> >> >> >> >
> >> >> >> >> >> > David
> >> >> >> >> >> > -----
> >> >> >> >> >> >
> >> >> >> >> >> > From other side, File.toPath javadoc explicitly says
> what
> >> >> >> >> "returned
> >> >> >> >> >> > instance must be the same for every invocation", so
> sync
> >> >> >> >> >> > block
> >> >> >> is
> >> >> >> >> >> > required here for mutual exclusion on initialization
> >> phase.
> >> >> >> >> Without
> >> >> >> >> >> > this requirement it is also safe to live without sync
> >> block,
> >> >> >> >> afaik.
> >> >> >> >> >> >
> >> >> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> >> >> >> >> >> >
> >> >> >> >> >> > Ruslan Cheremin writes:
> >> >> >> >> >> >
> >> >> >> >> >> > First of all, Path is immutable, so DCL is safe here
> even
> >> >> >> without
> >> >> >> >> >> > volatile. Volatile here is not required from my point
> of
> >> view.
> >> >> >> >> >> >
> >> >> >> >> >> > Without the volatile the Path implementation (Path is
> an
> >> >> >> >> >> >
> >> >> >> >> >> > interface) must be
> >> >> >> >> >> >
> >> >> >> >> >> > such that an instance of Path can be safely published
> >> without
> >> >> >> >> >> >
> >> >> >> >> >> > any additional
> >> >> >> >> >> >
> >> >> >> >> >> > forms of synchronization. Immutability does not in
> itself
> >> >> >> >> >> >
> >> >> >> >> >> > ensure that. You
> >> >> >> >> >> >
> >> >> >> >> >> > would have to examine the actual implementation class.
> >> >> >> >> >> >
> >> >> >> >> >> > David Holmes
> >> >> >> >> >> > ------------
> >> >> >> >> >> >
> >> >> >> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> >> >> >> >> >> >
> >> >> >> >> >> > Hi Richard,
> >> >> >> >> >> >
> >> >> >> >> >> > The variable "filePath" is volatile, so the double-
> >> checked
> >> >> >> >> >> >
> >> >> >> >> >> > locking is correct in this case. It would have been a
> bug
> >> >> >> >> >> >
> >> >> >> >> >> > prior to Java 5.
> >> >> >> >> >> >
> >> >> >> >> >> > Best regards,
> >> >> >> >> >> >
> >> >> >> >> >> > Dmitry Vyazelenko
> >> >> >> >> >> >
> >> >> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> >> >> >> >> >> >
> >> >> >> >> >> > <richard.warburton at gmail.com> wrote:
> >> >> >> >> >> >
> >> >> >> >> >> > Hello,
> >> >> >> >> >> >
> >> >> >> >> >> > The current implementation of java.io.File::toPath [0]
> >> >> >> >> >> >
> >> >> >> >> >> > appears to be
> >> >> >> >> >> >
> >> >> >> >> >> > using the double checked locking pattern:
> >> >> >> >> >> >
> >> >> >> >> >> >     public Path toPath() {
> >> >> >> >> >> >         Path result = filePath;
> >> >> >> >> >> >         if (result == null) {
> >> >> >> >> >> >             synchronized (this) {
> >> >> >> >> >> >                 result = filePath;
> >> >> >> >> >> >                 if (result == null) {
> >> >> >> >> >> >                     result =
> >> >> >> >> >> >
> >> >> >> >> >> > FileSystems.getDefault().getPath(path);
> >> >> >> >> >> >
> >> >> >> >> >> >                     filePath = result;
> >> >> >> >> >> >                 }
> >> >> >> >> >> >             }
> >> >> >> >> >> >         }
> >> >> >> >> >> >         return result;
> >> >> >> >> >> >     }
> >> >> >> >> >> >
> >> >> >> >> >> > I was going to report the bug, but I'm a little
> >> >> >> >> >> >
> >> >> >> >> >> > uncertain of the
> >> >> >> >> >> >
> >> >> >> >> >> > interaction between the local variable 'result' and
> DCL
> >> >> >> >> >> >
> >> >> >> >> >> > since I've
> >> >> >> >> >> >
> >> >> >> >> >> > previously only seen the checking condition on the
> >> >> >> >> >> >
> >> >> >> >> >> > shared field
> >> >> >> >> >> >
> >> >> >> >> >> > itself.  Can someone here either confirm that its a
> bug
> >> or
> >> >> >> >> >> >
> >> >> >> >> >> > explain how
> >> >> >> >> >> >
> >> >> >> >> >> > the 'result' variable is fixing things?
> >> >> >> >> >> >
> >> >> >> >> >> > regards,
> >> >> >> >> >> >
> >> >> >> >> >> >  Richard
> >> >> >> >> >> >
> >> >> >> >> >> > [0] See the end of
> >> >> >> >> >> >
> >> >> >> >> >> >
> >> >> >>
> >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> >> >> >> >> >> >
> >> >> >> >> >> > ses/java/io/File.java
> >> >> >> >> >> >
> >> >> >> >> >> > _______________________________________________
> >> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> >> interest
> >> >> >> >> >> >
> >> >> >> >> >> > _______________________________________________
> >> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> >> interest
> >> >> >> >> >> >
> >> >> >> >> >> > _______________________________________________
> >> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> >> interest
> >> >> >> >> >> >
> >> >> >> >> >> > _______________________________________________
> >> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> >> interest
> >> >> >> >> >> >
> >> >> >> >> >> >
> >> >> >> >> >> >
> >> >> >> >> >> > _______________________________________________
> >> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> >> interest
> >> >> >> >> >> >
> >> >> >> >> >> _______________________________________________
> >> >> >> >> >> Concurrency-interest mailing list
> >> >> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-
> interest
> >> >> >> >> >
> >> >> >> >> >
> >> >> >> >> >
> >> >> >> >> > _______________________________________________
> >> >> >> >> > Concurrency-interest mailing list
> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> interest
> >> >> >> >> >
> >> >> >> >> _______________________________________________
> >> >> >> >> Concurrency-interest mailing list
> >> >> >> >> Concurrency-interest at cs.oswego.edu
> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >> >> >
> >> >> >> > _______________________________________________
> >> >> >> > Concurrency-interest mailing list
> >> >> >> > Concurrency-interest at cs.oswego.edu
> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From vitalyd at gmail.com  Thu Aug 16 20:00:57 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 16 Aug 2012 20:00:57 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F6104C@G4W3296.americas.hpqcorp.net>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
	<CAOwENiJL3CaXFN=YAu334NbSy8rg8JabkVNH7HA6Po=+-XxUXQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60F39@G4W3296.americas.hpqcorp.net>
	<CAOwENi+=tHa6aeuW8-C3EUDK8Dd-ACXLr92XgpYOpJ8PJznouw@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6104C@G4W3296.americas.hpqcorp.net>
Message-ID: <CAHjP37HzwZbcGzTP3OB=6Gw4Jr2Mtu=ZysXEsbL7+8wgsgc7qw@mail.gmail.com>

NUMA and faster interconnects between the nodes (e.g Intel's QPI) seem to
be hw manufacturers' strategy at the moment.  I have a hard time imagining
that someone like Intel will ditch cache coherence to support hugely
parallel machines - seems like they'll need to continue finding
new/improved ways to scale within it.  Will definitely be interesting to
see ...

Sent from my phone
On Aug 16, 2012 7:48 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:

> Good point.  You might conceivably be able to treat the L1 cache as part
> of the store buffer, though I think there are a lot of detailed issues:
>
> - To preserve a TSO-like consistency model, I think you would need to
> replicate the L1 cache for each hardware thread, and somehow preserve the
> order of evictions to L2.  Context switches would probably need to flush L1
> (bad?). I'm not sure about implications on other more complicated
> consistency models.
>
> - Fences, when you do need them, become really expensive, many thousands
> of cycles, rather than a dozen, or a few dozen.
>
> - The progress issues we now theorize about (do we really know that store
> buffers get flushed in finite time, so that e.g. a spin lock release
> becomes visible?) become much more real.
>
> I'm not an expert on hardware cache coherence costs, but my impression is
> the architects don't entirely agree.  Current standard algorithms don't
> scale that well, but as far as I can tell it's hard to turn that into a
> convincing lower bound argument.  And there are shipping cache coherent
> multi-socket machines that support much larger core counts than we
> currently have on a chip.  They're expensive, but it's hard for me to
> separate fundamental hardware cost from economy of scale (smaller market
> for really big machines) issues.
>
> Hans
>
> > -----Original Message-----
> > From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> > Sent: Thursday, August 16, 2012 2:47 PM
> > To: Boehm, Hans
> > Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
> > dholmes at ieee.org
> > Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK
> >
> > Well, but why does it more tricky then now? It's just [L1,L2,L3,RAM]
> > who is subject to hardware coherence, but there is still some "memory"
> > atop of it -- e.g. registers, store buffers. They are not sync-ed
> > implicitly, you need explicitly store register in memory location, and
> > issue appropriate fence (strong enough to force store buffers flash)
> > to this value become visible to others. What is the difference between
> > this, and having all, say, L1 to behave same way -- does not sync
> > until eviction or explicit fence of some kind?
> >
> > May be I'm asking about some well-known things, but I was sure
> > hardware cache coherence was an engineer solution to marketing problem
> > -- simplify switching from vertical Ghz race to horizontal multicores
> > race. I've thought hw-cc implementation become more complex and less
> > effective with number of cores growing -- doesn't it?
> >
> > 2012/8/17 Boehm, Hans <hans.boehm at hp.com>:
> > > That's very different from the way current architectures work.  Once
> > something is in L1, it's essentially visible to everyone, because it's
> > subject to the cache coherency protocol.  If I write a value, it may
> > stay only in my L1 for a long time, but if another processor asks for
> > that cache line, it needs to talk to me.  Most, though not all,
> > architectures guarantee cache coherence, i.e. that accesses to a single
> > variable look sequentially consistent.  I think that changing this gets
> > you into the realm of very different machine language memory models,
> > which I'm not sure are reasonably programmable.  If you allowed writes
> > to the same location by different processors to stay unsynchronized
> > until later, how do you then resolve the conflict?  I think this gets
> > into really tricky issues very quickly.
> > >
> > > Hans
> > >
> > >> -----Original Message-----
> > >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> > >> Sent: Thursday, August 16, 2012 12:56 PM
> > >> To: Boehm, Hans
> > >> Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
> > >> dholmes at ieee.org
> > >> Subject: Re: [concurrency-interest] Double Checked Locking in
> > OpenJDK
> > >>
> > >> Thank you for reference, Hans.
> > >>
> > >> About synchronization -- I was very surprised to read your results.
> > >> Well, yes, uncontended synchronization is just a matter of fences,
> > >> which has small influence on memory bandwidth. But it seems for me
> > to
> > >> be true only with hardware coherency. Currently we'll have only
> > >> limited store buffer which keep "yet out of sync" writes, and allows
> > >> some -- limited -- number of optimization, like write combining and
> > >> write-read forwarding. So, fence, which forces buffer to drain, only
> > >> prevent exactly this limited number of optimization -- ok, I see how
> > >> it can be not a bid deal. But if all data in L1 can stay out of sync
> > >> until eviction? Delaying sync here as long as possible could -- from
> > >> my point of view -- reduce interconnect traffic impressively. And in
> > >> this case fence can be big performance killer. The more cached data
> > >> can be out of sync, the more is the cost of fences which forces the
> > >> sync -- am I miss something?
> > >>
> > >>
> > >>
> > >> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
> > >> > The standard reference for the JMM problems is Sevcik and
> > Aspinall,
> > >> "On validity of program transformations in the Java Memory Model",
> > >> ECOOP 2008.  I became convinced in a java memory model discussion a
> > >> couple of years ago or so (also including Jaroslav Sevcik) that
> > that's
> > >> not the only problem, but it is a serious problem.
> > >> >
> > >> > I'm unconvinced that removing the synchronization to prevent data
> > >> races generally improves scalability in the normal sense.  Improving
> > or
> > >> removing coarser-grained synchronization clearly can.  On x86,
> > fences
> > >> in particular seem to be executed entirely locally; they add
> > >> significant overhead at low core counts.  Based on limited
> > experiments,
> > >> they become increasingly insignificant as you reach other scaling
> > >> limits, e.g. memory bandwidth.  This is consistent with the usual
> > >> intuition that fences wait for store buffers to drain.  Even more
> > >> limited experiments on POWER were, to my surprise, also largely
> > >> consistent with that.  For a recent experiment I ran in support of a
> > >> workshop submission, this even tends to be true for acquiring locks
> > >> solely to avoid data races.  The difference between synchronized and
> > >> racy performance DECREASED dramatically with the number of
> > >> threads/cores.
> > >> >
> > >> > This doesn't mean that synchronization to avoid data races is
> > >> entirely free, but only that it's cost doesn't increase, and often
> > >> decreases with scale.  Doug may well have run more careful
> > experiments
> > >> around this.
> > >> >
> > >> > Hans
> > >> >
> > >> >> -----Original Message-----
> > >> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> > >> >> Sent: Wednesday, August 15, 2012 2:19 PM
> > >> >> To: Boehm, Hans
> > >> >> Cc: Zhong Yu; Yuval Shavit; concurrency-interest at cs.oswego.edu;
> > >> >> dholmes at ieee.org
> > >> >> Subject: Re: [concurrency-interest] Double Checked Locking in
> > >> OpenJDK
> > >> >>
> > >> >> Well, I understand your point.
> > >> >>
> > >> >> But this lead me to another interesting question -- why data
> > races
> > >> is so
> > >> >> outlaw? Yes, I understand, it is hard to write correct code with
> > >> them (by the
> > >> >> way, can you give the link about errors in JMM spec about data
> > race
> > >> you've
> > >> >> mention above?), but can we scale really well with sequentially
> > >> consistent
> > >> >> execution only? I mean, in large-scale distributed systems design
> > >> weakening
> > >> >> consistency often gives great performance benefits. AndwWhen I
> > think
> > >> >> about something like 786-cores (skip the brand) box, it seems for
> > me
> > >> there
> > >> >> could be many chances to improve performance using racy code. Am
> > I
> > >> miss
> > >> >> something here?
> > >> >>
> > >> >> 2012/8/16 Boehm, Hans <hans.boehm at hp.com>:
> > >> >> >> From: Ruslan Cheremin [mailto:cheremin at gmail.com]
> > >> >> >>
> > >> >> >> As far, as I can see, there is two directions. One is what
> > >> >> >> "thread-safe" notation in it's commonly used form -- then
> > applied
> > >> >> >> only to methods, and not to initialization/publication -- is
> > >> >> >> confusing, and there is little reason to exclude
> > >> >> >> construction/publication from thread safety protocol by
> > default.
> > >> My
> > >> >> >> point, among others, is that "immutable and thread safe"
> > should
> > >> be
> > >> >> >> interpreted as "thread safe even for unsafe publishing". And
> > >> this,
> > >> >> >> for example, gives us the chance to remove volatile
> > specification
> > >> in
> > >> >> >> File.path field we started from :)
> > >> >> > It seems to me that there's a huge difference here.
> > >> Synchronization in the
> > >> >> constructor only matters in the presence of other dubious
> > >> programming
> > >> >> practices:  Either a reference to the object has to escape before
> > >> the
> > >> >> constructor finishes, or the reference has to be communicated to
> > >> another
> > >> >> thread in a racy manner.  (And the former is a special case under
> > >> control of
> > >> >> the class itself.)  There are strong reasons to avoid both in the
> > >> vast majority
> > >> >> of code.  On the other hand, perfectly normal code will routinely
> > >> rely on the
> > >> >> thread-safety of non-constructor methods all the time.
> > >> >> >
> > >> >> >>
> > >> >> >> Second direction is about construction/publication as
> > >> specifically
> > >> >> >> different from the methods. E.g. it even may have additional
> > >> safety
> > >> >> >> guarantee -- like "publication is always safe". I can see some
> > >> >> >> reasons here, since constructor is the only one method, which
> > is
> > >> >> >> guaranteed to be called only once on object lifecycle, and so
> > we,
> > >> >> >> possible, can restrict some compiler/CPUs optimization in it
> > with
> > >> >> >> little influence on overall application performance -- but it
> > >> throws
> > >> >> >> away all troubles with unsafe publishing.
> > >> >> > I think we're still generally using "unsafe publishing" to mean
> > >> either of the
> > >> >> two dubious practices I mentioned above, though here we're
> > >> presumably
> > >> >> talking about racy publication after the constructor completes.
> > The
> > >> problem
> > >> >> is that in general racy publication is already a really bad
> > >> practice, because the
> > >> >> user has to understand the ugly details of the Java memory model,
> > >> which
> > >> >> nobody really does.  Racy publication is a data race, and hence
> > you
> > >> can no
> > >> >> longer reason in terms of sequential consistency,
> > synchronization-
> > >> free
> > >> >> regions become nonatomic, and generally all our intuition about
> > >> behavior of
> > >> >> threads and reasoning about threads goes out the window, even if
> > you
> > >> can
> > >> >> still reason about the integrity of your class.  There are one or
> > >> two special
> > >> >> cases, notably lazy initialization of an immutable object, where
> > you
> > >> might
> > >> >> succeed in hiding all that mess behind a library API, but in
> > general
> > >> that's hard.
> > >> >> So the question in my mind is whether you want to provide those
> > >> added
> > >> >> guarantees to support those one or two cases, or whether you want
> > to
> > >> limit
> > >> >> those guarantees to situations, notably those involving final
> > >> fields, where
> > >> >> they're essential for the security model.  We currently have the
> > >> latter.
> > >> >> >
> > >> >> > Hans
> > >> >> >>
> > >> >> >>
> > >> >> >>
> > >> >> >> 2012/8/15 Boehm, Hans <hans.boehm at hp.com>:
> > >> >> >> > Agreed.
> > >> >> >> >
> > >> >> >> > But, echoing David, I think, I'm not at all sure I see where
> > >> this
> > >> >> >> thread is going.  We've established that
> > >> >> >> >
> > >> >> >> > a) You can make a class safe against racy publication by
> > >> >> >> synchronizing the constructor along with all other methods (or
> > by
> > >> >> >> using an immutable class with final fields).
> > >> >> >> >
> > >> >> >> > b) There are (rather brittle and obscure) use cases in which
> > >> racy
> > >> >> >> publication gives you better performance on architectures like
> > >> ARM,
> > >> >> >> though not x86, currently at the cost of confusing data race
> > >> detectors.
> > >> >> >> >
> > >> >> >> > But to me it seems like taking advanatage of (b) is a fairly
> > >> >> >> undesirable, though perhaps occasionally unavoidable, hack.
> > And
> > >> I
> > >> >> >> can't see why it would possibly be a win if you have to
> > >> synchronize
> > >> >> >> all method calls to make it work.
> > >> >> >> >
> > >> >> >> > Does anyone have a use case in mind where the whole picture
> > >> we're
> > >> >> >> discussing actually makes sense?  It might help to focus this
> > >> >> >> discussion.
> > >> >> >> >
> > >> >> >> > Hans
> > >> >> >> >
> > >> >> >> >> -----Original Message-----
> > >> >> >> >> From: concurrency-interest-bounces at cs.oswego.edu
> > >> >> >> [mailto:concurrency-
> > >> >> >> >> interest-bounces at cs.oswego.edu] On Behalf Of Zhong Yu
> > >> >> >> >> Sent: Wednesday, August 15, 2012 10:56 AM
> > >> >> >> >> To: Yuval Shavit
> > >> >> >> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> > >> >> >> >> Subject: Re: [concurrency-interest] Double Checked Locking
> > in
> > >> >> >> OpenJDK
> > >> >> >> >>
> > >> >> >> >> I thought the conclusion of that thread is that
> > synchronizing
> > >> >> >> >> constructor has the desired merit - if all constructors and
> > >> >> >> >> methods are synchronized, a non-creating thread won't
> > observe
> > >> the
> > >> >> >> zero/partial
> > >> >> >> >> state of the object, even if the object reference is
> > published
> > >> >> >> >> unsafely.
> > >> >> >> >>
> > >> >> >> >> (One guy, who shall remain nameless, muddied the water with
> > >> some
> > >> >> >> >> mistaken statements of weaker memory guarantee. He has been
> > >> >> >> corrected)
> > >> >> >> >>
> > >> >> >> >> Zhong Yu
> > >> >> >> >>
> > >> >> >> >> On Wed, Aug 15, 2012 at 11:58 AM, Yuval Shavit
> > >> >> >> >> <yshavit at akiban.com>
> > >> >> >> >> wrote:
> > >> >> >> >> > There was a discussion here a few months ago about
> > >> synchronizing
> > >> >> >> >> > constructors -- I had asked why it's not allowed, and the
> > >> >> >> discussion
> > >> >> >> >> hit on
> > >> >> >> >> > some of the similar points brought up in this thread.
> > >> >> >> >> >
> > >> >> >> >> > But to your point specifically, synchronizing a
> > constructor
> > >> (via
> > >> >> >> >> > "synchronized(this) {...}" surrounding its body) still
> > >> doesn't
> > >> >> >> give
> > >> >> >> >> you full
> > >> >> >> >> > thread safety (even assuming immutability after the
> > >> constructor
> > >> >> >> >> > --
> > >> >> >> >> but
> > >> >> >> >> > without final fields). It ensures that a thread can
> > observe
> > >> the
> > >> >> >> >> object
> > >> >> >> >> > either fully constructed *or* with all its fields having
> > >> their
> > >> >> >> >> default
> > >> >> >> >> > values. In other words, even if your constructor is
> > >> synchronized
> > >> >> >> on
> > >> >> >> >> the same
> > >> >> >> >> > object your getter is, a thread could observe a field as
> > it
> > >> was
> > >> >> >> >> before the
> > >> >> >> >> > constructor was invoked.
> > >> >> >> >> >
> > >> >> >> >> > http://markmail.org/message/mav53xzo4bqu7udw
> > >> >> >> >> >
> > >> >> >> >> >
> > >> >> >> >> > On Wed, Aug 15, 2012 at 12:49 PM, Ruslan Cheremin
> > >> >> >> >> <cheremin at gmail.com>
> > >> >> >> >> > wrote:
> > >> >> >> >> >>
> > >> >> >> >> >> > The reason to keep them distinct is because in general
> > >> the
> > >> >> >> >> mechanisms
> > >> >> >> >> >> > for
> > >> >> >> >> >> > safe publication are external to the class, while
> > those
> > >> for
> > >> >> >> >> >> > thread-safety are internal. It is only an edge case
> > where
> > >> use
> > >> >> >> >> >> > of synchronized
> > >> >> >> in
> > >> >> >> >> a
> > >> >> >> >> >> > constructor can achieve safe-publication.
> > >> >> >> >> >>
> > >> >> >> >> >> Well, actually I do not understand your point. If I use
> > >> some
> > >> >> >> >> >> kind
> > >> >> >> of
> > >> >> >> >> >> synchronization to make methods of my object thread-safe
> > --
> > >> >> >> >> >> can't
> > >> >> >> I
> > >> >> >> >> >> also apply same thing to constructor? For me, it makes
> > the
> > >> >> >> >> >> thing
> > >> >> >> >> only
> > >> >> >> >> >> clearer. Object can be thread-safe -- and it is totally
> > >> thread
> > >> >> >> safe.
> > >> >> >> >> >> Object can require external synchronization for correct
> > >> >> >> >> multithreaded
> > >> >> >> >> >> use -- and it requires the sync for publishing and for
> > >> usage
> > >> >> >> also.
> > >> >> >> >> >>
> > >> >> >> >> >> From my point of view, the distinction you talking about
> > is
> > >> >> >> >> >> more historically reasoned. "Sync method if you want it
> > to
> > >> be
> > >> >> >> >> >> thread-
> > >> >> >> >> safe"
> > >> >> >> >> >> is commonly learned mantra, but "take care of
> > >> initialization
> > >> >> >> also"
> > >> >> >> >> is
> > >> >> >> >> >> not so common. More information about it, more
> > education,
> > >> more
> > >> >> >> >> >> different code samples with outlined "here is the
> > dragons"
> > >> will
> > >> >> >> >> change
> > >> >> >> >> >> the situation, I sure, it just have to be highlighted
> > more
> > >> often.
> > >> >> >> >> >>
> > >> >> >> >> >>
> > >> >> >> >> >> > People have to recognize that sharing an object
> > requires
> > >> >> >> >> >> > shared
> > >> >> >> >> mutable
> > >> >> >> >> >> > state, and the number one tenet of concurrent
> > programming
> > >> is
> > >> >> >> that
> > >> >> >> >> access
> > >> >> >> >> >> > to
> > >> >> >> >> >> > shared mutable state has to be synchronized (in a
> > general
> > >> >> >> >> >> > sense
> > >> >> >> >> not
> > >> >> >> >> >> > specifically use of 'synchronized' keyword).
> > >> >> >> >> >> >
> > >> >> >> >> >> > Making every object safely publishable could be done,
> > but
> > >> for
> > >> >> >> 99%
> > >> >> >> >> of
> > >> >> >> >> >> > objects
> > >> >> >> >> >> > it would be a waste of effort. Programs without data
> > >> races
> > >> >> >> don't
> > >> >> >> >> have
> > >> >> >> >> >> > issues
> > >> >> >> >> >> > with unsafe publication.
> > >> >> >> >> >> >
> > >> >> >> >> >> > David
> > >> >> >> >> >> >
> > >> >> >> >> >> > -----Original Message-----
> > >> >> >> >> >> > From: concurrency-interest-bounces at cs.oswego.edu
> > >> >> >> >> >> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On
> > >> Behalf
> > >> >> >> >> >> > Of
> > >> >> >> >> Nathan
> > >> >> >> >> >> > Reynolds
> > >> >> >> >> >> > Sent: Wednesday, 15 August 2012 4:59 AM
> > >> >> >> >> >> > To: concurrency-interest at cs.oswego.edu
> > >> >> >> >> >> > Subject: Re: [concurrency-interest] Double Checked
> > >> Locking in
> > >> >> >> >> OpenJDK
> > >> >> >> >> >> >
> > >> >> >> >> >> > We seem to be splitting two notions (i.e thread-safe
> > and
> > >> safe
> > >> >> >> >> >> > publication)
> > >> >> >> >> >> > when they should be combined in a sense.  Typically,
> > when
> > >> we
> > >> >> >> say
> > >> >> >> >> >> > thread-safe
> > >> >> >> >> >> > we talk about the operations performed on the object
> > >> after it
> > >> >> >> was
> > >> >> >> >> >> > constructed (and its contents are globally visible).
> > >> >> >> >> >> > However,
> > >> >> >> we
> > >> >> >> >> need
> > >> >> >> >> >> > to
> > >> >> >> >> >> > consider that executing the constructor is modifying
> > the
> > >> >> >> >> >> > state
> > >> >> >> of
> > >> >> >> >> the
> > >> >> >> >> >> > object.  It requires the same mechanisms that the rest
> > of
> > >> the
> > >> >> >> >> class uses
> > >> >> >> >> >> > to
> > >> >> >> >> >> > ensure thread-safety.  Even though, there is only 1
> > >> thread
> > >> >> >> >> executing the
> > >> >> >> >> >> > constructor, a proper releasing of a lock or some
> > other
> > >> >> >> happens-
> > >> >> >> >> before
> > >> >> >> >> >> > construct is required to ensure that the memory
> > updates
> > >> by
> > >> >> >> >> >> > the
> > >> >> >> >> thread
> > >> >> >> >> >> > are
> > >> >> >> >> >> > made globally visible before the object is accessed by
> > >> >> >> >> >> > another
> > >> >> >> >> thread.
> > >> >> >> >> >> > This
> > >> >> >> >> >> > is what we are calling safe publication.  So, safe
> > >> >> >> >> >> > publication
> > >> >> >> is
> > >> >> >> >> a
> > >> >> >> >> >> > subset
> > >> >> >> >> >> > of thread-safety except it is limited to what happens
> > >> after
> > >> >> >> >> >> > the constructor is called and before the object is
> > used
> > >> by
> > >> >> >> >> >> > multiple threads.
> > >> >> >> >> >> >
> > >> >> >> >> >> > A beautifully-written class can be thread-safe with
> > >> respect
> > >> >> >> >> >> > to
> > >> >> >> >> calling
> > >> >> >> >> >> > its
> > >> >> >> >> >> > member methods but not thread-safe with respect to
> > >> calling
> > >> >> >> >> >> > its constructor.
> > >> >> >> >> >> > It is this latter case that many stumble upon because
> > >> they
> > >> >> >> think
> > >> >> >> >> that
> > >> >> >> >> >> > constructors are inherently thread-safe because they
> > are
> > >> >> >> executed
> > >> >> >> >> >> > single-threadedly.  What they fail to realize is that
> > the
> > >> >> >> >> execution of a
> > >> >> >> >> >> > constructor can overlap with the execution of other
> > code
> > >> from
> > >> >> >> the
> > >> >> >> >> view
> > >> >> >> >> >> > point
> > >> >> >> >> >> > of what is happening in memory.  This same problem
> > >> applies to
> > >> >> >> more
> > >> >> >> >> rare
> > >> >> >> >> >> > case
> > >> >> >> >> >> > of regular methods which can be proven to execute in a
> > >> single
> > >> >> >> >> thread but
> > >> >> >> >> >> > don't use synchronization before multiple threads
> > start
> > >> >> >> accessing
> > >> >> >> >> the
> > >> >> >> >> >> > shared
> > >> >> >> >> >> > data.
> > >> >> >> >> >> >
> > >> >> >> >> >> > Nathan Reynolds | Consulting Member of Technical Staff
> > |
> > >> >> >> >> 602.333.9091
> > >> >> >> >> >> > Oracle PSR Engineering | Server Technology On
> > 8/13/2012
> > >> 4:08
> > >> >> >> >> >> > PM, David Holmes wrote:
> > >> >> >> >> >> >
> > >> >> >> >> >> > Ruslan Cheremin writes:
> > >> >> >> >> >> >
> > >> >> >> >> >> > For me it is confusing: java has only one way to have
> > >> really
> > >> >> >> >> immutable
> > >> >> >> >> >> > object, and this way also gives you a total thread
> > safety
> > >> >> >> >> >> > even
> > >> >> >> for
> > >> >> >> >> >> > data race based publication. But then docs refer
> > object
> > >> as
> > >> >> >> >> "immutable
> > >> >> >> >> >> > and thread-safe" -- we still can't assume it to be
> > really
> > >> >> >> thread-
> > >> >> >> >> safe?
> > >> >> >> >> >> >
> > >> >> >> >> >> > It is better/simpler to isolate the notion of thread-
> > >> safety
> > >> >> >> >> >> > and
> > >> >> >> >> safe
> > >> >> >> >> >> > publication. Thread-safety comes into play after you
> > have
> > >> >> >> safely
> > >> >> >> >> shared
> > >> >> >> >> >> > an
> > >> >> >> >> >> > object. The means by which you safely share an object
> > is
> > >> >> >> >> orthogonal to
> > >> >> >> >> >> > how
> > >> >> >> >> >> > the object itself is made thread-safe.
> > >> >> >> >> >> >
> > >> >> >> >> >> > The means by which an object is shared has to involve
> > >> shared
> > >> >> >> >> mutable
> > >> >> >> >> >> > state,
> > >> >> >> >> >> > and use of shared mutable state always needs some form
> > of
> > >> >> >> >> >> > synchronization (either implicit eg due to static
> > >> >> >> >> >> > initialization; or explicit
> > >> >> >> by
> > >> >> >> >> using
> > >> >> >> >> >> > volatile or synchronized getter/setter methods).
> > >> >> >> >> >> >
> > >> >> >> >> >> > David
> > >> >> >> >> >> > -----
> > >> >> >> >> >> >
> > >> >> >> >> >> > It's a pity, especially because true immutability
> > gives
> > >> us
> > >> >> >> >> >> > some chances of performance optimization. As in this
> > case
> > >> --
> > >> >> >> >> >> > we do
> > >> >> >> not
> > >> >> >> >> >> > really need .path to be volatile here, if we would
> > assume
> > >> >> >> >> >> > Path
> > >> >> >> to
> > >> >> >> >> be
> > >> >> >> >> >> > truly immutable. volatility here required only for
> > >> ensuring
> > >> >> >> safe
> > >> >> >> >> >> > publishing.
> > >> >> >> >> >> >
> > >> >> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >> >> >> >> >> >
> > >> >> >> >> >> > Ruslan Cheremin writes:>
> > >> >> >> >> >> >
> > >> >> >> >> >> > But is there a way to define "safe for data race
> > >> publishing"?
> > >> >> >> >> >> > I
> > >> >> >> as
> > >> >> >> >> >> > far, as I remember, "immutable and thread-safe" is
> > >> standard
> > >> >> >> mantra
> > >> >> >> >> in
> > >> >> >> >> >> > JDK javadocs for totally safe objects. j.l.String has
> > >> same
> > >> >> >> mantra
> > >> >> >> >> --
> > >> >> >> >> >> > and it is safe for any way of publishing. Does you
> > mean,
> > >> I
> > >> >> >> should
> > >> >> >> >> >> > explicitly add "safe even for publishing via data
> > race"
> > >> in
> > >> >> >> docs?
> > >> >> >> >> But I
> > >> >> >> >> >> > can't remember any such phrase in JDK docs.
> > >> >> >> >> >> >
> > >> >> >> >> >> > I don't recall anything in the JDK docs that mention
> > >> being
> > >> >> >> >> >> >
> > >> >> >> >> >> > "totally safe"
> > >> >> >> >> >> >
> > >> >> >> >> >> > regardless of publication mechanism. Some classes, eg
> > >> String,
> > >> >> >> have
> > >> >> >> >> been
> > >> >> >> >> >> > defined such that they do have that property (for
> > >> security
> > >> >> >> >> reasons). In
> > >> >> >> >> >> > general neither "thread-safe" nor "immutable" imply
> > >> >> >> >> >> > safe-for-unsynchronized-publication.
> > >> >> >> >> >> >
> > >> >> >> >> >> > Java Concurrency In Practice (jcip.net) does define
> > >> >> >> >> >> > additional
> > >> >> >> >> potential
> > >> >> >> >> >> > annotations, where @Immutable would indeed capture the
> > >> >> >> requirement
> > >> >> >> >> of
> > >> >> >> >> >> > safe-for-unsynchronized-publication.
> > >> >> >> >> >> >
> > >> >> >> >> >> > David
> > >> >> >> >> >> > -----
> > >> >> >> >> >> >
> > >> >> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >> >> >> >> >> >
> > >> >> >> >> >> > Ruslan Cheremin writes:
> > >> >> >> >> >> >
> > >> >> >> >> >> > Well, Path javadoc explicitly says "immutable and safe
> > >> for
> > >> >> >> >> >> > multithreaded use". Although it is not strictly
> > defined
> > >> in
> > >> >> >> >> >> > java
> > >> >> >> >> what
> > >> >> >> >> >> > exactly means "safe for multithreaded use" -- does it
> > >> mean
> > >> >> >> >> >> > safe
> > >> >> >> >> for
> > >> >> >> >> >> > publishing via data race, among others? -- I suppose,
> > it
> > >> >> >> >> >> >
> > >> >> >> >> >> > should be. Am
> > >> >> >> >> >> >
> > >> >> >> >> >> > I wrong here?
> > >> >> >> >> >> >
> > >> >> >> >> >> > "safe for multi-threaded use" does not generally imply
> > >> that
> > >> >> >> >> >> > it
> > >> >> >> >> >> >
> > >> >> >> >> >> > is safe to
> > >> >> >> >> >> >
> > >> >> >> >> >> > publish instances without synchronization of some
> > form.
> > >> >> >> >> >> >
> > >> >> >> >> >> > David
> > >> >> >> >> >> > -----
> > >> >> >> >> >> >
> > >> >> >> >> >> > From other side, File.toPath javadoc explicitly says
> > what
> > >> >> >> >> "returned
> > >> >> >> >> >> > instance must be the same for every invocation", so
> > sync
> > >> >> >> >> >> > block
> > >> >> >> is
> > >> >> >> >> >> > required here for mutual exclusion on initialization
> > >> phase.
> > >> >> >> >> Without
> > >> >> >> >> >> > this requirement it is also safe to live without sync
> > >> block,
> > >> >> >> >> afaik.
> > >> >> >> >> >> >
> > >> >> >> >> >> > 2012/8/13 David Holmes <davidcholmes at aapt.net.au>:
> > >> >> >> >> >> >
> > >> >> >> >> >> > Ruslan Cheremin writes:
> > >> >> >> >> >> >
> > >> >> >> >> >> > First of all, Path is immutable, so DCL is safe here
> > even
> > >> >> >> without
> > >> >> >> >> >> > volatile. Volatile here is not required from my point
> > of
> > >> view.
> > >> >> >> >> >> >
> > >> >> >> >> >> > Without the volatile the Path implementation (Path is
> > an
> > >> >> >> >> >> >
> > >> >> >> >> >> > interface) must be
> > >> >> >> >> >> >
> > >> >> >> >> >> > such that an instance of Path can be safely published
> > >> without
> > >> >> >> >> >> >
> > >> >> >> >> >> > any additional
> > >> >> >> >> >> >
> > >> >> >> >> >> > forms of synchronization. Immutability does not in
> > itself
> > >> >> >> >> >> >
> > >> >> >> >> >> > ensure that. You
> > >> >> >> >> >> >
> > >> >> >> >> >> > would have to examine the actual implementation class.
> > >> >> >> >> >> >
> > >> >> >> >> >> > David Holmes
> > >> >> >> >> >> > ------------
> > >> >> >> >> >> >
> > >> >> >> >> >> > 2012/8/12 Dmitry Vyazelenko <vyazelenko at yahoo.com>:
> > >> >> >> >> >> >
> > >> >> >> >> >> > Hi Richard,
> > >> >> >> >> >> >
> > >> >> >> >> >> > The variable "filePath" is volatile, so the double-
> > >> checked
> > >> >> >> >> >> >
> > >> >> >> >> >> > locking is correct in this case. It would have been a
> > bug
> > >> >> >> >> >> >
> > >> >> >> >> >> > prior to Java 5.
> > >> >> >> >> >> >
> > >> >> >> >> >> > Best regards,
> > >> >> >> >> >> >
> > >> >> >> >> >> > Dmitry Vyazelenko
> > >> >> >> >> >> >
> > >> >> >> >> >> > On Aug 12, 2012, at 21:35 , Richard Warburton
> > >> >> >> >> >> >
> > >> >> >> >> >> > <richard.warburton at gmail.com> wrote:
> > >> >> >> >> >> >
> > >> >> >> >> >> > Hello,
> > >> >> >> >> >> >
> > >> >> >> >> >> > The current implementation of java.io.File::toPath [0]
> > >> >> >> >> >> >
> > >> >> >> >> >> > appears to be
> > >> >> >> >> >> >
> > >> >> >> >> >> > using the double checked locking pattern:
> > >> >> >> >> >> >
> > >> >> >> >> >> >     public Path toPath() {
> > >> >> >> >> >> >         Path result = filePath;
> > >> >> >> >> >> >         if (result == null) {
> > >> >> >> >> >> >             synchronized (this) {
> > >> >> >> >> >> >                 result = filePath;
> > >> >> >> >> >> >                 if (result == null) {
> > >> >> >> >> >> >                     result =
> > >> >> >> >> >> >
> > >> >> >> >> >> > FileSystems.getDefault().getPath(path);
> > >> >> >> >> >> >
> > >> >> >> >> >> >                     filePath = result;
> > >> >> >> >> >> >                 }
> > >> >> >> >> >> >             }
> > >> >> >> >> >> >         }
> > >> >> >> >> >> >         return result;
> > >> >> >> >> >> >     }
> > >> >> >> >> >> >
> > >> >> >> >> >> > I was going to report the bug, but I'm a little
> > >> >> >> >> >> >
> > >> >> >> >> >> > uncertain of the
> > >> >> >> >> >> >
> > >> >> >> >> >> > interaction between the local variable 'result' and
> > DCL
> > >> >> >> >> >> >
> > >> >> >> >> >> > since I've
> > >> >> >> >> >> >
> > >> >> >> >> >> > previously only seen the checking condition on the
> > >> >> >> >> >> >
> > >> >> >> >> >> > shared field
> > >> >> >> >> >> >
> > >> >> >> >> >> > itself.  Can someone here either confirm that its a
> > bug
> > >> or
> > >> >> >> >> >> >
> > >> >> >> >> >> > explain how
> > >> >> >> >> >> >
> > >> >> >> >> >> > the 'result' variable is fixing things?
> > >> >> >> >> >> >
> > >> >> >> >> >> > regards,
> > >> >> >> >> >> >
> > >> >> >> >> >> >  Richard
> > >> >> >> >> >> >
> > >> >> >> >> >> > [0] See the end of
> > >> >> >> >> >> >
> > >> >> >> >> >> >
> > >> >> >>
> > >> hg.openjdk.java.net/jdk8/jdk8/jdk/file/da8649489aff/src/share/clas
> > >> >> >> >> >> >
> > >> >> >> >> >> > ses/java/io/File.java
> > >> >> >> >> >> >
> > >> >> >> >> >> > _______________________________________________
> > >> >> >> >> >> > Concurrency-interest mailing list
> > >> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> > >> interest
> > >> >> >> >> >> >
> > >> >> >> >> >> > _______________________________________________
> > >> >> >> >> >> > Concurrency-interest mailing list
> > >> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> > >> interest
> > >> >> >> >> >> >
> > >> >> >> >> >> > _______________________________________________
> > >> >> >> >> >> > Concurrency-interest mailing list
> > >> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> > >> interest
> > >> >> >> >> >> >
> > >> >> >> >> >> > _______________________________________________
> > >> >> >> >> >> > Concurrency-interest mailing list
> > >> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> > >> interest
> > >> >> >> >> >> >
> > >> >> >> >> >> >
> > >> >> >> >> >> >
> > >> >> >> >> >> > _______________________________________________
> > >> >> >> >> >> > Concurrency-interest mailing list
> > >> >> >> >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> > >> interest
> > >> >> >> >> >> >
> > >> >> >> >> >> _______________________________________________
> > >> >> >> >> >> Concurrency-interest mailing list
> > >> >> >> >> >> Concurrency-interest at cs.oswego.edu
> > >> >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-
> > interest
> > >> >> >> >> >
> > >> >> >> >> >
> > >> >> >> >> >
> > >> >> >> >> > _______________________________________________
> > >> >> >> >> > Concurrency-interest mailing list
> > >> >> >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-
> > interest
> > >> >> >> >> >
> > >> >> >> >> _______________________________________________
> > >> >> >> >> Concurrency-interest mailing list
> > >> >> >> >> Concurrency-interest at cs.oswego.edu
> > >> >> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >> >> >
> > >> >> >> > _______________________________________________
> > >> >> >> > Concurrency-interest mailing list
> > >> >> >> > Concurrency-interest at cs.oswego.edu
> > >> >> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120816/8655605e/attachment-0001.html>

From uli at grepel.de  Fri Aug 17 03:04:43 2012
From: uli at grepel.de (Ulrich Grepel)
Date: Fri, 17 Aug 2012 09:04:43 +0200
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <mailman.206.1345161671.3055.concurrency-interest@cs.oswego.edu>
References: <mailman.206.1345161671.3055.concurrency-interest@cs.oswego.edu>
Message-ID: <502DED0B.9010200@grepel.de>

On 17.08.2012 02:01, concurrency-interest-request at cs.oswego.edu wrote:
> Date: Thu, 16 Aug 2012 20:00:57 -0400
> From: Vitaly Davidovich <vitalyd at gmail.com>
>
> NUMA and faster interconnects between the nodes (e.g Intel's QPI) seem to
> be hw manufacturers' strategy at the moment.  I have a hard time imagining
> that someone like Intel will ditch cache coherence to support hugely
> parallel machines - seems like they'll need to continue finding
> new/improved ways to scale within it.  Will definitely be interesting to
> see ...
>
Large scale parallel systems can be found in the supercomputing field. 
The single most important hardware issue there is interconnect speed and 
the single most important software issue is to try to minimize 
communication between all those threads.

If you've got hundreds of thousands or even millions of cores, all with 
local RAM, there's just no way to quickly synchronize caches or even 
RAM, so you won't have a synchronized memory model there, at least not 
across all cores. So with massive parallelism, the problem is will 
remain: syncing is expensive, so avoid it.

Transferring this into the Java world of the future we either hit a 
hardware wall - more cores aren't providing any additional performance - 
or a software wall - we need some extended NUMA concepts for Java 
threads. And this in a language which is somewhat still supposed to 
fulfill the "write once, run everywhere" paradigm.

What I could imagine for example is something akin to Thread Local 
Storage, but on a Cache Coherency Group ("CCG") level, something like 
"get me the CCG's instance of the cache". And some guarantee that, if 
desired, a thread remains in the CCG of the thread that started the 
second thread.

Syncing the various CCGs is a challenge however. If you're updating one 
of the CCG caches and want to propagate this to the other CCGs, you 
might run into the same kind of problems that distributed databases run 
into. See the CAP theorem - you can have two out of the following three: 
Consistency, Availability and Partition Tolerance.

Uli

From cheremin at gmail.com  Fri Aug 17 14:08:31 2012
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Fri, 17 Aug 2012 22:08:31 +0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <502DED0B.9010200@grepel.de>
References: <mailman.206.1345161671.3055.concurrency-interest@cs.oswego.edu>
	<502DED0B.9010200@grepel.de>
Message-ID: <CAOwENi+nxPa9myY9DX89b=_1erZMp5J5k3j=YvpF1wEoPeWrog@mail.gmail.com>

Yes, Ulrich, I have grid-like systems in my mind then talking about
perspective of weakening hardware coherence.

But, by any way, one does not need to look so far. As I've already
write, we already have some kind of
weak-consistent-not-automatically-coherent memory in todays Indel CPUs
-- in form of registers and store buffers. This is small layer atop of
coherent memory, but this layer is, as far as I know, critical for
overall performance, since it is important in hiding (well, sometimes
hiding) still noticeable memory latency. Not only main memory (or,
say, L3/2 cache latency), but also a QPI latency, if accessed memory
location is owned by another core, and need to be re-owned, for
example.

I see no reason why evolution of QPI will be somehow different from
evolution of memory itself. Leaving away chance for some kind of
hardware revolution (breakthrough, which would give us cheap and
ultimate fast memory/QPI), it seems for me like we'll have same
QPI-wall, as we've already have memory wall. I see no chance for QPI
being fast, wide, cheap, and scale to hundreds of CPUs same time. So
we'll still need some kind of weak consistent layer with explicit
flushing control to hide weakness of memory (and QPI, as part of
memory engine).

What I trying to say here: seems like we always will have strict
consistent but rather slow memory (with QPI), and quick but weak
consistent memory. Border between them could move -- now days servers
and desktops have tiny weak-consistent layer, while grids and clusters
have all its memory "weak consistent" (only explicitly synchronized).

And if my assumption are not too far from reality, it seems promising
(or at least interesting) to trying to investigate algorithms which
can exploit inconsistency, instead of trying to fight with it with
fences. I see much analogies with distributed systems here, there
"eventually consistent" design becoming de-facto standard today (the
CAP theorem Ulrich mention). Talking about race-based algorithms I
have this kind of design in my mind.

Do you know about any works in this direction? For now I see only one
promising example for exploiting eventually consistent approach -- the
sync-less cache for atomically published entities, like primitives
(except long/double sure) or immutable objects.

2012/8/17 Ulrich Grepel <uli at grepel.de>:
> On 17.08.2012 02:01, concurrency-interest-request at cs.oswego.edu wrote:
>>
>> Date: Thu, 16 Aug 2012 20:00:57 -0400
>> From: Vitaly Davidovich <vitalyd at gmail.com>
>>
>>
>> NUMA and faster interconnects between the nodes (e.g Intel's QPI) seem to
>> be hw manufacturers' strategy at the moment.  I have a hard time imagining
>> that someone like Intel will ditch cache coherence to support hugely
>> parallel machines - seems like they'll need to continue finding
>> new/improved ways to scale within it.  Will definitely be interesting to
>> see ...
>>
> Large scale parallel systems can be found in the supercomputing field. The
> single most important hardware issue there is interconnect speed and the
> single most important software issue is to try to minimize communication
> between all those threads.
>
> If you've got hundreds of thousands or even millions of cores, all with
> local RAM, there's just no way to quickly synchronize caches or even RAM, so
> you won't have a synchronized memory model there, at least not across all
> cores. So with massive parallelism, the problem is will remain: syncing is
> expensive, so avoid it.
>
> Transferring this into the Java world of the future we either hit a hardware
> wall - more cores aren't providing any additional performance - or a
> software wall - we need some extended NUMA concepts for Java threads. And
> this in a language which is somewhat still supposed to fulfill the "write
> once, run everywhere" paradigm.
>
> What I could imagine for example is something akin to Thread Local Storage,
> but on a Cache Coherency Group ("CCG") level, something like "get me the
> CCG's instance of the cache". And some guarantee that, if desired, a thread
> remains in the CCG of the thread that started the second thread.
>
> Syncing the various CCGs is a challenge however. If you're updating one of
> the CCG caches and want to propagate this to the other CCGs, you might run
> into the same kind of problems that distributed databases run into. See the
> CAP theorem - you can have two out of the following three: Consistency,
> Availability and Partition Tolerance.
>
> Uli
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From vitalyd at gmail.com  Fri Aug 17 16:00:48 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 17 Aug 2012 16:00:48 -0400
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENi+nxPa9myY9DX89b=_1erZMp5J5k3j=YvpF1wEoPeWrog@mail.gmail.com>
References: <mailman.206.1345161671.3055.concurrency-interest@cs.oswego.edu>
	<502DED0B.9010200@grepel.de>
	<CAOwENi+nxPa9myY9DX89b=_1erZMp5J5k3j=YvpF1wEoPeWrog@mail.gmail.com>
Message-ID: <CAHjP37GptLpmN8+0hs9QXsP7Bw7oAV07UMWe+WnKW0j=eMoknQ@mail.gmail.com>

I really don't see this happening (i.e. h/w manufacturers releasing
incoherent/manually coherent memory subsystems).  Putting technical
difficulty imposed on developing new software for such a thing, it's
impractical to think that existing software will be rewritten to work on
it.  Intel Itanium is a good example - nice ideas there for getting great
performance on it, but it put the burden on compiler writers to get it and
it proved too difficult in practice, and the platform is abandoned.

Sent from my phone
On Aug 17, 2012 2:08 PM, "Ruslan Cheremin" <cheremin at gmail.com> wrote:

> Yes, Ulrich, I have grid-like systems in my mind then talking about
> perspective of weakening hardware coherence.
>
> But, by any way, one does not need to look so far. As I've already
> write, we already have some kind of
> weak-consistent-not-automatically-coherent memory in todays Indel CPUs
> -- in form of registers and store buffers. This is small layer atop of
> coherent memory, but this layer is, as far as I know, critical for
> overall performance, since it is important in hiding (well, sometimes
> hiding) still noticeable memory latency. Not only main memory (or,
> say, L3/2 cache latency), but also a QPI latency, if accessed memory
> location is owned by another core, and need to be re-owned, for
> example.
>
> I see no reason why evolution of QPI will be somehow different from
> evolution of memory itself. Leaving away chance for some kind of
> hardware revolution (breakthrough, which would give us cheap and
> ultimate fast memory/QPI), it seems for me like we'll have same
> QPI-wall, as we've already have memory wall. I see no chance for QPI
> being fast, wide, cheap, and scale to hundreds of CPUs same time. So
> we'll still need some kind of weak consistent layer with explicit
> flushing control to hide weakness of memory (and QPI, as part of
> memory engine).
>
> What I trying to say here: seems like we always will have strict
> consistent but rather slow memory (with QPI), and quick but weak
> consistent memory. Border between them could move -- now days servers
> and desktops have tiny weak-consistent layer, while grids and clusters
> have all its memory "weak consistent" (only explicitly synchronized).
>
> And if my assumption are not too far from reality, it seems promising
> (or at least interesting) to trying to investigate algorithms which
> can exploit inconsistency, instead of trying to fight with it with
> fences. I see much analogies with distributed systems here, there
> "eventually consistent" design becoming de-facto standard today (the
> CAP theorem Ulrich mention). Talking about race-based algorithms I
> have this kind of design in my mind.
>
> Do you know about any works in this direction? For now I see only one
> promising example for exploiting eventually consistent approach -- the
> sync-less cache for atomically published entities, like primitives
> (except long/double sure) or immutable objects.
>
> 2012/8/17 Ulrich Grepel <uli at grepel.de>:
> > On 17.08.2012 02:01, concurrency-interest-request at cs.oswego.edu wrote:
> >>
> >> Date: Thu, 16 Aug 2012 20:00:57 -0400
> >> From: Vitaly Davidovich <vitalyd at gmail.com>
> >>
> >>
> >> NUMA and faster interconnects between the nodes (e.g Intel's QPI) seem
> to
> >> be hw manufacturers' strategy at the moment.  I have a hard time
> imagining
> >> that someone like Intel will ditch cache coherence to support hugely
> >> parallel machines - seems like they'll need to continue finding
> >> new/improved ways to scale within it.  Will definitely be interesting to
> >> see ...
> >>
> > Large scale parallel systems can be found in the supercomputing field.
> The
> > single most important hardware issue there is interconnect speed and the
> > single most important software issue is to try to minimize communication
> > between all those threads.
> >
> > If you've got hundreds of thousands or even millions of cores, all with
> > local RAM, there's just no way to quickly synchronize caches or even
> RAM, so
> > you won't have a synchronized memory model there, at least not across all
> > cores. So with massive parallelism, the problem is will remain: syncing
> is
> > expensive, so avoid it.
> >
> > Transferring this into the Java world of the future we either hit a
> hardware
> > wall - more cores aren't providing any additional performance - or a
> > software wall - we need some extended NUMA concepts for Java threads. And
> > this in a language which is somewhat still supposed to fulfill the "write
> > once, run everywhere" paradigm.
> >
> > What I could imagine for example is something akin to Thread Local
> Storage,
> > but on a Cache Coherency Group ("CCG") level, something like "get me the
> > CCG's instance of the cache". And some guarantee that, if desired, a
> thread
> > remains in the CCG of the thread that started the second thread.
> >
> > Syncing the various CCGs is a challenge however. If you're updating one
> of
> > the CCG caches and want to propagate this to the other CCGs, you might
> run
> > into the same kind of problems that distributed databases run into. See
> the
> > CAP theorem - you can have two out of the following three: Consistency,
> > Availability and Partition Tolerance.
> >
> > Uli
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/9113c6ed/attachment.html>

From hans.boehm at hp.com  Fri Aug 17 16:31:02 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Fri, 17 Aug 2012 20:31:02 +0000
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37GptLpmN8+0hs9QXsP7Bw7oAV07UMWe+WnKW0j=eMoknQ@mail.gmail.com>
References: <mailman.206.1345161671.3055.concurrency-interest@cs.oswego.edu>
	<502DED0B.9010200@grepel.de>
	<CAOwENi+nxPa9myY9DX89b=_1erZMp5J5k3j=YvpF1wEoPeWrog@mail.gmail.com>
	<CAHjP37GptLpmN8+0hs9QXsP7Bw7oAV07UMWe+WnKW0j=eMoknQ@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F6178E@G4W3296.americas.hpqcorp.net>

I agree with the conclusion about manual cache management, but not the Itanium analogy.  We really don't want to discuss Itanium, especially not at this time, on this mailing list.

Hans

From: Vitaly Davidovich [mailto:vitalyd at gmail.com]
Sent: Friday, August 17, 2012 1:01 PM
To: Ruslan Cheremin
Cc: Ulrich Grepel; Boehm, Hans; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Double Checked Locking in OpenJDK


I really don't see this happening (i.e. h/w manufacturers releasing incoherent/manually coherent memory subsystems).  Putting technical difficulty imposed on developing new software for such a thing, it's impractical to think that existing software will be rewritten to work on it.  Intel Itanium is a good example - nice ideas there for getting great performance on it, but it put the burden on compiler writers to get it and it proved too difficult in practice, and the platform is abandoned.

Sent from my phone
On Aug 17, 2012 2:08 PM, "Ruslan Cheremin" <cheremin at gmail.com<mailto:cheremin at gmail.com>> wrote:
Yes, Ulrich, I have grid-like systems in my mind then talking about
perspective of weakening hardware coherence.

But, by any way, one does not need to look so far. As I've already
write, we already have some kind of
weak-consistent-not-automatically-coherent memory in todays Indel CPUs
-- in form of registers and store buffers. This is small layer atop of
coherent memory, but this layer is, as far as I know, critical for
overall performance, since it is important in hiding (well, sometimes
hiding) still noticeable memory latency. Not only main memory (or,
say, L3/2 cache latency), but also a QPI latency, if accessed memory
location is owned by another core, and need to be re-owned, for
example.

I see no reason why evolution of QPI will be somehow different from
evolution of memory itself. Leaving away chance for some kind of
hardware revolution (breakthrough, which would give us cheap and
ultimate fast memory/QPI), it seems for me like we'll have same
QPI-wall, as we've already have memory wall. I see no chance for QPI
being fast, wide, cheap, and scale to hundreds of CPUs same time. So
we'll still need some kind of weak consistent layer with explicit
flushing control to hide weakness of memory (and QPI, as part of
memory engine).

What I trying to say here: seems like we always will have strict
consistent but rather slow memory (with QPI), and quick but weak
consistent memory. Border between them could move -- now days servers
and desktops have tiny weak-consistent layer, while grids and clusters
have all its memory "weak consistent" (only explicitly synchronized).

And if my assumption are not too far from reality, it seems promising
(or at least interesting) to trying to investigate algorithms which
can exploit inconsistency, instead of trying to fight with it with
fences. I see much analogies with distributed systems here, there
"eventually consistent" design becoming de-facto standard today (the
CAP theorem Ulrich mention). Talking about race-based algorithms I
have this kind of design in my mind.

Do you know about any works in this direction? For now I see only one
promising example for exploiting eventually consistent approach -- the
sync-less cache for atomically published entities, like primitives
(except long/double sure) or immutable objects.

2012/8/17 Ulrich Grepel <uli at grepel.de<mailto:uli at grepel.de>>:
> On 17.08.2012 02:01, concurrency-interest-request at cs.oswego.edu<mailto:concurrency-interest-request at cs.oswego.edu> wrote:
>>
>> Date: Thu, 16 Aug 2012 20:00:57 -0400
>> From: Vitaly Davidovich <vitalyd at gmail.com<mailto:vitalyd at gmail.com>>
>>
>>
>> NUMA and faster interconnects between the nodes (e.g Intel's QPI) seem to
>> be hw manufacturers' strategy at the moment.  I have a hard time imagining
>> that someone like Intel will ditch cache coherence to support hugely
>> parallel machines - seems like they'll need to continue finding
>> new/improved ways to scale within it.  Will definitely be interesting to
>> see ...
>>
> Large scale parallel systems can be found in the supercomputing field. The
> single most important hardware issue there is interconnect speed and the
> single most important software issue is to try to minimize communication
> between all those threads.
>
> If you've got hundreds of thousands or even millions of cores, all with
> local RAM, there's just no way to quickly synchronize caches or even RAM, so
> you won't have a synchronized memory model there, at least not across all
> cores. So with massive parallelism, the problem is will remain: syncing is
> expensive, so avoid it.
>
> Transferring this into the Java world of the future we either hit a hardware
> wall - more cores aren't providing any additional performance - or a
> software wall - we need some extended NUMA concepts for Java threads. And
> this in a language which is somewhat still supposed to fulfill the "write
> once, run everywhere" paradigm.
>
> What I could imagine for example is something akin to Thread Local Storage,
> but on a Cache Coherency Group ("CCG") level, something like "get me the
> CCG's instance of the cache". And some guarantee that, if desired, a thread
> remains in the CCG of the thread that started the second thread.
>
> Syncing the various CCGs is a challenge however. If you're updating one of
> the CCG caches and want to propagate this to the other CCGs, you might run
> into the same kind of problems that distributed databases run into. See the
> CAP theorem - you can have two out of the following three: Consistency,
> Availability and Partition Tolerance.
>
> Uli
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/3c06ac50/attachment-0001.html>

From mtopolnik at inge-mark.hr  Fri Aug 17 17:24:07 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Fri, 17 Aug 2012 23:24:07 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by volatile
In-Reply-To: <616A1C6D-148D-4971-B752-F085115F3DD5@inge-mark.hr>
References: <3CEE49F2-DFEB-4D8B-BCFD-4FBD2E16D200@inge-mark.hr>
	<616A1C6D-148D-4971-B752-F085115F3DD5@inge-mark.hr>
Message-ID: <B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>

Consider the following synchronization order of a program execution involving a total of two threads, R and W:

- thread R begins;

- thread R reads a volatile int sharedVar several times. Each time it reads the value 0;

- thread R completes;

- thread W begins;

- thread W writes the sharedVar several times. Each time it writes the value 1;

- thread W completes.

Now consider the wall-clock timing of the events:

- thread R reads 0 at t = {1, 4, 7, 10};
- thread W writes 1 at t = {0, 3, 6, 9}.

As far as the Java Memory Model is concerned, there is no contradiction between the synchronization order and the wall-clock times, as the JMM is wall-clock agnostic. However, I have yet to meet a single Java professional who wouldn't at least be very surprised to hear that the specification allows this.

I understand that the SMP architecture that dominates the world of computing today practically never takes these liberties and makes the volatile writes visible almost instantaneously. This may change at any time, however, especially with the advent of massively parrallel architectures that seem to be the future. For example, an optimization technique may choose to chunk many volatile writes together and make them visible in a single bulk operation. This can be safely done as long as there are no intervening read-y actions (targets of the synchronizes-with edges as defined by JLS/JSE7 17.4.4).

Now, my questions are:

1. Is there a loophole in my reasoning?

2. If there is no loophole, is there anything to worry about, given that practically 100% developers out there consider as guaranteed something that isn't?


-Marko





From vitalyd at gmail.com  Fri Aug 17 18:44:31 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 17 Aug 2012 18:44:31 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
References: <3CEE49F2-DFEB-4D8B-BCFD-4FBD2E16D200@inge-mark.hr>
	<616A1C6D-148D-4971-B752-F085115F3DD5@inge-mark.hr>
	<B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
Message-ID: <CAHjP37ENa7JCUEMx5YFT9kP4pgTb9cUV=0cSKo92J_vPnY+gdw@mail.gmail.com>

That's an interesting question.  I think you mean whether JVMs (at least in
the context of this mailing list) will attempt to perform such
optimizations? The CPU doesn't know what a volatile variable is - it's a
language construct, of course.

There's been some similar discussion here in the past.  One example is
whether a write is ever guaranteed to be observed - think cooperatively
scheduled system.  Or perhaps the store buffer is so large that the write
simply lingers there indefinitely; I think most people today assume that
this doesn't happen and that it ultimately gets drained (without explicit
fences, that is).

I will say that it's been stated all over the web that if you write a
volatile value in thread A and then read that value in thread B and those
things happen in that chronological order, that one will see the write from
A immediately (assume no other writers of that memory).  Technically, the
JMM doesn't require that in this case- it only imposes order with respect
to other operations, not timeliness.  However, I don't see how JVM vendors
can break this behavior, even if it conforms to today's JMM spec - there's
just too much potential pain to customers.

Hardware vendors have the same issue - too much change that's negatively
observed by software isn't going to fly.  They're much more likely to add
new optional instructions than to modify existing behavior.

Sent from my phone
On Aug 17, 2012 5:27 PM, "Marko Topolnik" <mtopolnik at inge-mark.hr> wrote:

> Consider the following synchronization order of a program execution
> involving a total of two threads, R and W:
>
> - thread R begins;
>
> - thread R reads a volatile int sharedVar several times. Each time it
> reads the value 0;
>
> - thread R completes;
>
> - thread W begins;
>
> - thread W writes the sharedVar several times. Each time it writes the
> value 1;
>
> - thread W completes.
>
> Now consider the wall-clock timing of the events:
>
> - thread R reads 0 at t = {1, 4, 7, 10};
> - thread W writes 1 at t = {0, 3, 6, 9}.
>
> As far as the Java Memory Model is concerned, there is no contradiction
> between the synchronization order and the wall-clock times, as the JMM is
> wall-clock agnostic. However, I have yet to meet a single Java professional
> who wouldn't at least be very surprised to hear that the specification
> allows this.
>
> I understand that the SMP architecture that dominates the world of
> computing today practically never takes these liberties and makes the
> volatile writes visible almost instantaneously. This may change at any
> time, however, especially with the advent of massively parrallel
> architectures that seem to be the future. For example, an optimization
> technique may choose to chunk many volatile writes together and make them
> visible in a single bulk operation. This can be safely done as long as
> there are no intervening read-y actions (targets of the synchronizes-with
> edges as defined by JLS/JSE7 17.4.4).
>
> Now, my questions are:
>
> 1. Is there a loophole in my reasoning?
>
> 2. If there is no loophole, is there anything to worry about, given that
> practically 100% developers out there consider as guaranteed something that
> isn't?
>
>
> -Marko
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/4d275121/attachment.html>

From nathan.reynolds at oracle.com  Fri Aug 17 18:46:43 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Fri, 17 Aug 2012 15:46:43 -0700
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
References: <3CEE49F2-DFEB-4D8B-BCFD-4FBD2E16D200@inge-mark.hr>
	<616A1C6D-148D-4971-B752-F085115F3DD5@inge-mark.hr>
	<B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
Message-ID: <502EC9D3.3010809@oracle.com>

 > I have yet to meet a single Java professional who wouldn't at least 
be very surprised to hear that the specification allows this.

Add me to the list of surprised.

Here's an excerpt from the specification.

A write to a volatile variable (?8.3.1.4) 
<http://docs.oracle.com/javase/specs/jls/se5.0/html/classes.html#36930> 
/v/ synchronizes-with all subsequent reads of /v/ by any thread (where 
subsequent is defined according to the synchronization order).

http://docs.oracle.com/javase/specs/jls/se5.0/html/memory.html#17.4.4

Doesn't this mean that R will always read 1 since the read occurs after 
the write?

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 8/17/2012 2:24 PM, Marko Topolnik wrote:
> Consider the following synchronization order of a program execution involving a total of two threads, R and W:
>
> - thread R begins;
>
> - thread R reads a volatile int sharedVar several times. Each time it reads the value 0;
>
> - thread R completes;
>
> - thread W begins;
>
> - thread W writes the sharedVar several times. Each time it writes the value 1;
>
> - thread W completes.
>
> Now consider the wall-clock timing of the events:
>
> - thread R reads 0 at t = {1, 4, 7, 10};
> - thread W writes 1 at t = {0, 3, 6, 9}.
>
> As far as the Java Memory Model is concerned, there is no contradiction between the synchronization order and the wall-clock times, as the JMM is wall-clock agnostic. However, I have yet to meet a single Java professional who wouldn't at least be very surprised to hear that the specification allows this.
>
> I understand that the SMP architecture that dominates the world of computing today practically never takes these liberties and makes the volatile writes visible almost instantaneously. This may change at any time, however, especially with the advent of massively parrallel architectures that seem to be the future. For example, an optimization technique may choose to chunk many volatile writes together and make them visible in a single bulk operation. This can be safely done as long as there are no intervening read-y actions (targets of the synchronizes-with edges as defined by JLS/JSE7 17.4.4).
>
> Now, my questions are:
>
> 1. Is there a loophole in my reasoning?
>
> 2. If there is no loophole, is there anything to worry about, given that practically 100% developers out there consider as guaranteed something that isn't?
>
>
> -Marko
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/4507301e/attachment.html>

From davidcholmes at aapt.net.au  Fri Aug 17 18:58:56 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 18 Aug 2012 08:58:56 +1000
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEDEJGAA.davidcholmes@aapt.net.au>

Hi Marko,

I think the "surprise" is only in the way you formulated this. Said another
way a write takes a finite amount of time from when the instruction starts
to execute to when the store is actually available for a read to see.
(Similarly a read takes a finite amount of time.) So depending on those two
times a read and write that happen "around the same time" may appear to have
occurred in either order. But when you program with threads you never know
the relative interleavings (or should never assume) so it makes no
difference how the program perceives the order compared to how some external
observer might perceive it.

As for your optimization to "chunk" volatile writes, I don't see a problem
here if you are basically asking if given:

w = 1;  // w is volatile
w = 2;
w = 3;

that this could be reduced to the last write alone? I see no reason why not.
Without some additional coordination between a reader thread and the writer
thread, reading w==3 is a legitimate outcome. If you are thinking about how
the hardware might chunk things then that is a different matter. We have to
use the hardware in a way that complies with the memory model - if the
hardware can't comply then you can't run Java on it.

David Holmes
------------

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
> Topolnik
> Sent: Saturday, 18 August 2012 7:24 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Relativity of guarantees provided by
> volatile
>
>
> Consider the following synchronization order of a program
> execution involving a total of two threads, R and W:
>
> - thread R begins;
>
> - thread R reads a volatile int sharedVar several times. Each
> time it reads the value 0;
>
> - thread R completes;
>
> - thread W begins;
>
> - thread W writes the sharedVar several times. Each time it
> writes the value 1;
>
> - thread W completes.
>
> Now consider the wall-clock timing of the events:
>
> - thread R reads 0 at t = {1, 4, 7, 10};
> - thread W writes 1 at t = {0, 3, 6, 9}.
>
> As far as the Java Memory Model is concerned, there is no
> contradiction between the synchronization order and the
> wall-clock times, as the JMM is wall-clock agnostic. However, I
> have yet to meet a single Java professional who wouldn't at least
> be very surprised to hear that the specification allows this.
>
> I understand that the SMP architecture that dominates the world
> of computing today practically never takes these liberties and
> makes the volatile writes visible almost instantaneously. This
> may change at any time, however, especially with the advent of
> massively parrallel architectures that seem to be the future. For
> example, an optimization technique may choose to chunk many
> volatile writes together and make them visible in a single bulk
> operation. This can be safely done as long as there are no
> intervening read-y actions (targets of the synchronizes-with
> edges as defined by JLS/JSE7 17.4.4).
>
> Now, my questions are:
>
> 1. Is there a loophole in my reasoning?
>
> 2. If there is no loophole, is there anything to worry about,
> given that practically 100% developers out there consider as
> guaranteed something that isn't?
>
>
> -Marko
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From vitalyd at gmail.com  Fri Aug 17 19:01:27 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 17 Aug 2012 19:01:27 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <502EC9D3.3010809@oracle.com>
References: <3CEE49F2-DFEB-4D8B-BCFD-4FBD2E16D200@inge-mark.hr>
	<616A1C6D-148D-4971-B752-F085115F3DD5@inge-mark.hr>
	<B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
	<502EC9D3.3010809@oracle.com>
Message-ID: <CAHjP37G30VfAvgX1r_hGbPLirUBNnrDA4wsriWvjx6KFz9aB7A@mail.gmail.com>

Is it ambiguous whether synchronizes with implies timeliness? I know we
treat it as such, as Mark mentioned, but is that mentioned somewhere in the
JMM?

Sent from my phone
On Aug 17, 2012 6:58 PM, "Nathan Reynolds" <nathan.reynolds at oracle.com>
wrote:

>  > I have yet to meet a single Java professional who wouldn't at least be
> very surprised to hear that the specification allows this.
>
> Add me to the list of surprised.
>
> Here's an excerpt from the specification.
>
> A write to a volatile variable (?8.3.1.4)<http://docs.oracle.com/javase/specs/jls/se5.0/html/classes.html#36930>
> *v* synchronizes-with all subsequent reads of *v* by any thread (where
> subsequent is defined according to the synchronization order).
>
> http://docs.oracle.com/javase/specs/jls/se5.0/html/memory.html#17.4.4
>
> Doesn't this mean that R will always read 1 since the read occurs after
> the write?
>
>  Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Consulting Member of Technical Staff |
> 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>  On 8/17/2012 2:24 PM, Marko Topolnik wrote:
>
> Consider the following synchronization order of a program execution involving a total of two threads, R and W:
>
> - thread R begins;
>
> - thread R reads a volatile int sharedVar several times. Each time it reads the value 0;
>
> - thread R completes;
>
> - thread W begins;
>
> - thread W writes the sharedVar several times. Each time it writes the value 1;
>
> - thread W completes.
>
> Now consider the wall-clock timing of the events:
>
> - thread R reads 0 at t = {1, 4, 7, 10};
> - thread W writes 1 at t = {0, 3, 6, 9}.
>
> As far as the Java Memory Model is concerned, there is no contradiction between the synchronization order and the wall-clock times, as the JMM is wall-clock agnostic. However, I have yet to meet a single Java professional who wouldn't at least be very surprised to hear that the specification allows this.
>
> I understand that the SMP architecture that dominates the world of computing today practically never takes these liberties and makes the volatile writes visible almost instantaneously. This may change at any time, however, especially with the advent of massively parrallel architectures that seem to be the future. For example, an optimization technique may choose to chunk many volatile writes together and make them visible in a single bulk operation. This can be safely done as long as there are no intervening read-y actions (targets of the synchronizes-with edges as defined by JLS/JSE7 17.4.4).
>
> Now, my questions are:
>
> 1. Is there a loophole in my reasoning?
>
> 2. If there is no loophole, is there anything to worry about, given that practically 100% developers out there consider as guaranteed something that isn't?
>
>
> -Marko
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/f3a56c07/attachment-0001.html>

From davidcholmes at aapt.net.au  Fri Aug 17 19:03:48 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 18 Aug 2012 09:03:48 +1000
Subject: [concurrency-interest] Relativity of guarantees provided
	byvolatile
In-Reply-To: <502EC9D3.3010809@oracle.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEDFJGAA.davidcholmes@aapt.net.au>

Nathan,

Is there a synchronization order here that indicates that the read occurs
after the write? "subsequent" is not defined by wall-clock time as
externally observed.

And to batch responses :) Hotspot's implementation requires that all writes
will become visible without need for explicit barriers/fences to force that.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan
Reynolds
  Sent: Saturday, 18 August 2012 8:47 AM
  To: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Relativity of guarantees provided
byvolatile


  > I have yet to meet a single Java professional who wouldn't at least be
very surprised to hear that the specification allows this.

  Add me to the list of surprised.

  Here's an excerpt from the specification.

  A write to a volatile variable (?8.3.1.4) v synchronizes-with all
subsequent reads of v by any thread (where subsequent is defined according
to the synchronization order).

  http://docs.oracle.com/javase/specs/jls/se5.0/html/memory.html#17.4.4

  Doesn't this mean that R will always read 1 since the read occurs after
the write?


  Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
  Oracle PSR Engineering | Server Technology

  On 8/17/2012 2:24 PM, Marko Topolnik wrote:

Consider the following synchronization order of a program execution
involving a total of two threads, R and W:

- thread R begins;

- thread R reads a volatile int sharedVar several times. Each time it reads
the value 0;

- thread R completes;

- thread W begins;

- thread W writes the sharedVar several times. Each time it writes the value
1;

- thread W completes.

Now consider the wall-clock timing of the events:

- thread R reads 0 at t = {1, 4, 7, 10};
- thread W writes 1 at t = {0, 3, 6, 9}.

As far as the Java Memory Model is concerned, there is no contradiction
between the synchronization order and the wall-clock times, as the JMM is
wall-clock agnostic. However, I have yet to meet a single Java professional
who wouldn't at least be very surprised to hear that the specification
allows this.

I understand that the SMP architecture that dominates the world of computing
today practically never takes these liberties and makes the volatile writes
visible almost instantaneously. This may change at any time, however,
especially with the advent of massively parrallel architectures that seem to
be the future. For example, an optimization technique may choose to chunk
many volatile writes together and make them visible in a single bulk
operation. This can be safely done as long as there are no intervening
read-y actions (targets of the synchronizes-with edges as defined by
JLS/JSE7 17.4.4).

Now, my questions are:

1. Is there a loophole in my reasoning?

2. If there is no loophole, is there anything to worry about, given that
practically 100% developers out there consider as guaranteed something that
isn't?


-Marko




_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120818/776e6b38/attachment.html>

From yshavit at akiban.com  Fri Aug 17 19:10:15 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Fri, 17 Aug 2012 19:10:15 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEDEJGAA.davidcholmes@aapt.net.au>
References: <B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
	<NFBBKALFDCPFIDBNKAPCMEDEJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAC2Zdp2j0wdS8305yHrxZDo-gk5RqudX7FuV4hNcEiwgF6+q1w@mail.gmail.com>

The more I think about Marko's problem, the more it bugs me. I don't think
it's that the three writes can be reduced to the last one -- it's that
there's no requirement for this to ever be seen. That is, given threads t1
and t2, such that by clock time:

   (A) t1: write to volatileField
   (B) t2:  read from volatileField

The JLS states that if A happens-before B, then B must see A. It defines
hb(A, B) as synchronized-with(A, B), which is true if t2 is subsequent to
t1. But "subsequent" isn't defined as clock time. It's left undefined in
JLS 17, except for twice in 17.4.4 in which it's defined as "according to
the synchronization order" -- which seems like a tautology!

In other words, I think it comes down to the definition of "subsequent,"
which is undefined. There's nothing preventing a JVM from deciding that
even though A happened before B in clock time, A is subsequent to B.

On Fri, Aug 17, 2012 at 6:58 PM, David Holmes <davidcholmes at aapt.net.au>wrote:

> Hi Marko,
>
> I think the "surprise" is only in the way you formulated this. Said another
> way a write takes a finite amount of time from when the instruction starts
> to execute to when the store is actually available for a read to see.
> (Similarly a read takes a finite amount of time.) So depending on those two
> times a read and write that happen "around the same time" may appear to
> have
> occurred in either order. But when you program with threads you never know
> the relative interleavings (or should never assume) so it makes no
> difference how the program perceives the order compared to how some
> external
> observer might perceive it.
>
> As for your optimization to "chunk" volatile writes, I don't see a problem
> here if you are basically asking if given:
>
> w = 1;  // w is volatile
> w = 2;
> w = 3;
>
> that this could be reduced to the last write alone? I see no reason why
> not.
> Without some additional coordination between a reader thread and the writer
> thread, reading w==3 is a legitimate outcome. If you are thinking about how
> the hardware might chunk things then that is a different matter. We have to
> use the hardware in a way that complies with the memory model - if the
> hardware can't comply then you can't run Java on it.
>
> David Holmes
> ------------
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
> > Topolnik
> > Sent: Saturday, 18 August 2012 7:24 AM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: [concurrency-interest] Relativity of guarantees provided by
> > volatile
> >
> >
> > Consider the following synchronization order of a program
> > execution involving a total of two threads, R and W:
> >
> > - thread R begins;
> >
> > - thread R reads a volatile int sharedVar several times. Each
> > time it reads the value 0;
> >
> > - thread R completes;
> >
> > - thread W begins;
> >
> > - thread W writes the sharedVar several times. Each time it
> > writes the value 1;
> >
> > - thread W completes.
> >
> > Now consider the wall-clock timing of the events:
> >
> > - thread R reads 0 at t = {1, 4, 7, 10};
> > - thread W writes 1 at t = {0, 3, 6, 9}.
> >
> > As far as the Java Memory Model is concerned, there is no
> > contradiction between the synchronization order and the
> > wall-clock times, as the JMM is wall-clock agnostic. However, I
> > have yet to meet a single Java professional who wouldn't at least
> > be very surprised to hear that the specification allows this.
> >
> > I understand that the SMP architecture that dominates the world
> > of computing today practically never takes these liberties and
> > makes the volatile writes visible almost instantaneously. This
> > may change at any time, however, especially with the advent of
> > massively parrallel architectures that seem to be the future. For
> > example, an optimization technique may choose to chunk many
> > volatile writes together and make them visible in a single bulk
> > operation. This can be safely done as long as there are no
> > intervening read-y actions (targets of the synchronizes-with
> > edges as defined by JLS/JSE7 17.4.4).
> >
> > Now, my questions are:
> >
> > 1. Is there a loophole in my reasoning?
> >
> > 2. If there is no loophole, is there anything to worry about,
> > given that practically 100% developers out there consider as
> > guaranteed something that isn't?
> >
> >
> > -Marko
> >
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/88d221e8/attachment.html>

From vitalyd at gmail.com  Fri Aug 17 19:11:59 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 17 Aug 2012 19:11:59 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEDEJGAA.davidcholmes@aapt.net.au>
References: <B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
	<NFBBKALFDCPFIDBNKAPCMEDEJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>

I don't think the writes to w can be reduced to just the last one as it
would violate the JMM.  R may only see the last one due to interleaving
though. Not sure if that's what you meant.

Sent from my phone
On Aug 17, 2012 7:03 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:

> Hi Marko,
>
> I think the "surprise" is only in the way you formulated this. Said another
> way a write takes a finite amount of time from when the instruction starts
> to execute to when the store is actually available for a read to see.
> (Similarly a read takes a finite amount of time.) So depending on those two
> times a read and write that happen "around the same time" may appear to
> have
> occurred in either order. But when you program with threads you never know
> the relative interleavings (or should never assume) so it makes no
> difference how the program perceives the order compared to how some
> external
> observer might perceive it.
>
> As for your optimization to "chunk" volatile writes, I don't see a problem
> here if you are basically asking if given:
>
> w = 1;  // w is volatile
> w = 2;
> w = 3;
>
> that this could be reduced to the last write alone? I see no reason why
> not.
> Without some additional coordination between a reader thread and the writer
> thread, reading w==3 is a legitimate outcome. If you are thinking about how
> the hardware might chunk things then that is a different matter. We have to
> use the hardware in a way that complies with the memory model - if the
> hardware can't comply then you can't run Java on it.
>
> David Holmes
> ------------
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
> > Topolnik
> > Sent: Saturday, 18 August 2012 7:24 AM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: [concurrency-interest] Relativity of guarantees provided by
> > volatile
> >
> >
> > Consider the following synchronization order of a program
> > execution involving a total of two threads, R and W:
> >
> > - thread R begins;
> >
> > - thread R reads a volatile int sharedVar several times. Each
> > time it reads the value 0;
> >
> > - thread R completes;
> >
> > - thread W begins;
> >
> > - thread W writes the sharedVar several times. Each time it
> > writes the value 1;
> >
> > - thread W completes.
> >
> > Now consider the wall-clock timing of the events:
> >
> > - thread R reads 0 at t = {1, 4, 7, 10};
> > - thread W writes 1 at t = {0, 3, 6, 9}.
> >
> > As far as the Java Memory Model is concerned, there is no
> > contradiction between the synchronization order and the
> > wall-clock times, as the JMM is wall-clock agnostic. However, I
> > have yet to meet a single Java professional who wouldn't at least
> > be very surprised to hear that the specification allows this.
> >
> > I understand that the SMP architecture that dominates the world
> > of computing today practically never takes these liberties and
> > makes the volatile writes visible almost instantaneously. This
> > may change at any time, however, especially with the advent of
> > massively parrallel architectures that seem to be the future. For
> > example, an optimization technique may choose to chunk many
> > volatile writes together and make them visible in a single bulk
> > operation. This can be safely done as long as there are no
> > intervening read-y actions (targets of the synchronizes-with
> > edges as defined by JLS/JSE7 17.4.4).
> >
> > Now, my questions are:
> >
> > 1. Is there a loophole in my reasoning?
> >
> > 2. If there is no loophole, is there anything to worry about,
> > given that practically 100% developers out there consider as
> > guaranteed something that isn't?
> >
> >
> > -Marko
> >
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/8d288f05/attachment-0001.html>

From davidcholmes at aapt.net.au  Fri Aug 17 19:16:34 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 18 Aug 2012 09:16:34 +1000
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CAC2Zdp2j0wdS8305yHrxZDo-gk5RqudX7FuV4hNcEiwgF6+q1w@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEDFJGAA.davidcholmes@aapt.net.au>

I think this is looking at things the wrong way. IF t2 is subsequent to t1
THEN the JMM says the read must see the write. The JMM doesn't, and can't
define "subsequent" in an abstract sense.

David
  -----Original Message-----
  From: Yuval Shavit [mailto:yshavit at akiban.com]
  Sent: Saturday, 18 August 2012 9:10 AM
  To: dholmes at ieee.org
  Cc: Marko Topolnik; concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Relativity of guarantees provided by
volatile


  The more I think about Marko's problem, the more it bugs me. I don't think
it's that the three writes can be reduced to the last one -- it's that
there's no requirement for this to ever be seen. That is, given threads t1
and t2, such that by clock time:


     (A) t1: write to volatileField
     (B) t2:  read from volatileField


  The JLS states that if A happens-before B, then B must see A. It defines
hb(A, B) as synchronized-with(A, B), which is true if t2 is subsequent to
t1. But "subsequent" isn't defined as clock time. It's left undefined in JLS
17, except for twice in 17.4.4 in which it's defined as "according to the
synchronization order" -- which seems like a tautology!


  In other words, I think it comes down to the definition of "subsequent,"
which is undefined. There's nothing preventing a JVM from deciding that even
though A happened before B in clock time, A is subsequent to B.


  On Fri, Aug 17, 2012 at 6:58 PM, David Holmes <davidcholmes at aapt.net.au>
wrote:

    Hi Marko,

    I think the "surprise" is only in the way you formulated this. Said
another
    way a write takes a finite amount of time from when the instruction
starts
    to execute to when the store is actually available for a read to see.
    (Similarly a read takes a finite amount of time.) So depending on those
two
    times a read and write that happen "around the same time" may appear to
have
    occurred in either order. But when you program with threads you never
know
    the relative interleavings (or should never assume) so it makes no
    difference how the program perceives the order compared to how some
external
    observer might perceive it.

    As for your optimization to "chunk" volatile writes, I don't see a
problem
    here if you are basically asking if given:

    w = 1;  // w is volatile
    w = 2;
    w = 3;

    that this could be reduced to the last write alone? I see no reason why
not.
    Without some additional coordination between a reader thread and the
writer
    thread, reading w==3 is a legitimate outcome. If you are thinking about
how
    the hardware might chunk things then that is a different matter. We have
to
    use the hardware in a way that complies with the memory model - if the
    hardware can't comply then you can't run Java on it.

    David Holmes
    ------------


    > -----Original Message-----
    > From: concurrency-interest-bounces at cs.oswego.edu
    > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
    > Topolnik
    > Sent: Saturday, 18 August 2012 7:24 AM
    > To: concurrency-interest at cs.oswego.edu
    > Subject: [concurrency-interest] Relativity of guarantees provided by
    > volatile
    >
    >
    > Consider the following synchronization order of a program
    > execution involving a total of two threads, R and W:
    >
    > - thread R begins;
    >
    > - thread R reads a volatile int sharedVar several times. Each
    > time it reads the value 0;
    >
    > - thread R completes;
    >
    > - thread W begins;
    >
    > - thread W writes the sharedVar several times. Each time it
    > writes the value 1;
    >
    > - thread W completes.
    >
    > Now consider the wall-clock timing of the events:
    >
    > - thread R reads 0 at t = {1, 4, 7, 10};
    > - thread W writes 1 at t = {0, 3, 6, 9}.
    >
    > As far as the Java Memory Model is concerned, there is no
    > contradiction between the synchronization order and the
    > wall-clock times, as the JMM is wall-clock agnostic. However, I
    > have yet to meet a single Java professional who wouldn't at least
    > be very surprised to hear that the specification allows this.
    >
    > I understand that the SMP architecture that dominates the world
    > of computing today practically never takes these liberties and
    > makes the volatile writes visible almost instantaneously. This
    > may change at any time, however, especially with the advent of
    > massively parrallel architectures that seem to be the future. For
    > example, an optimization technique may choose to chunk many
    > volatile writes together and make them visible in a single bulk
    > operation. This can be safely done as long as there are no
    > intervening read-y actions (targets of the synchronizes-with
    > edges as defined by JLS/JSE7 17.4.4).
    >
    > Now, my questions are:
    >
    > 1. Is there a loophole in my reasoning?
    >
    > 2. If there is no loophole, is there anything to worry about,
    > given that practically 100% developers out there consider as
    > guaranteed something that isn't?
    >
    >
    > -Marko
    >
    >
    >
    >
    > _______________________________________________
    > Concurrency-interest mailing list
    > Concurrency-interest at cs.oswego.edu
    > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    >

    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at cs.oswego.edu
    http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120818/4febd35c/attachment.html>

From davidcholmes at aapt.net.au  Fri Aug 17 19:19:43 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 18 Aug 2012 09:19:43 +1000
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>

How does it violate the JMM? There is nothing to establish that any read has
to have occurred prior to w=3. An external observer may say "hey if we'd
actually written w=1 at this point then the read would see 1" but that is
irrelevant. The program can not tell the other writes did not occur.

David
  -----Original Message-----
  From: Vitaly Davidovich [mailto:vitalyd at gmail.com]
  Sent: Saturday, 18 August 2012 9:12 AM
  To: dholmes at ieee.org
  Cc: Marko Topolnik; concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Relativity of guarantees provided by
volatile


  I don't think the writes to w can be reduced to just the last one as it
would violate the JMM.  R may only see the last one due to interleaving
though. Not sure if that's what you meant.

  Sent from my phone

  On Aug 17, 2012 7:03 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:

    Hi Marko,

    I think the "surprise" is only in the way you formulated this. Said
another
    way a write takes a finite amount of time from when the instruction
starts
    to execute to when the store is actually available for a read to see.
    (Similarly a read takes a finite amount of time.) So depending on those
two
    times a read and write that happen "around the same time" may appear to
have
    occurred in either order. But when you program with threads you never
know
    the relative interleavings (or should never assume) so it makes no
    difference how the program perceives the order compared to how some
external
    observer might perceive it.

    As for your optimization to "chunk" volatile writes, I don't see a
problem
    here if you are basically asking if given:

    w = 1;  // w is volatile
    w = 2;
    w = 3;

    that this could be reduced to the last write alone? I see no reason why
not.
    Without some additional coordination between a reader thread and the
writer
    thread, reading w==3 is a legitimate outcome. If you are thinking about
how
    the hardware might chunk things then that is a different matter. We have
to
    use the hardware in a way that complies with the memory model - if the
    hardware can't comply then you can't run Java on it.

    David Holmes
    ------------

    > -----Original Message-----
    > From: concurrency-interest-bounces at cs.oswego.edu
    > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
    > Topolnik
    > Sent: Saturday, 18 August 2012 7:24 AM
    > To: concurrency-interest at cs.oswego.edu
    > Subject: [concurrency-interest] Relativity of guarantees provided by
    > volatile
    >
    >
    > Consider the following synchronization order of a program
    > execution involving a total of two threads, R and W:
    >
    > - thread R begins;
    >
    > - thread R reads a volatile int sharedVar several times. Each
    > time it reads the value 0;
    >
    > - thread R completes;
    >
    > - thread W begins;
    >
    > - thread W writes the sharedVar several times. Each time it
    > writes the value 1;
    >
    > - thread W completes.
    >
    > Now consider the wall-clock timing of the events:
    >
    > - thread R reads 0 at t = {1, 4, 7, 10};
    > - thread W writes 1 at t = {0, 3, 6, 9}.
    >
    > As far as the Java Memory Model is concerned, there is no
    > contradiction between the synchronization order and the
    > wall-clock times, as the JMM is wall-clock agnostic. However, I
    > have yet to meet a single Java professional who wouldn't at least
    > be very surprised to hear that the specification allows this.
    >
    > I understand that the SMP architecture that dominates the world
    > of computing today practically never takes these liberties and
    > makes the volatile writes visible almost instantaneously. This
    > may change at any time, however, especially with the advent of
    > massively parrallel architectures that seem to be the future. For
    > example, an optimization technique may choose to chunk many
    > volatile writes together and make them visible in a single bulk
    > operation. This can be safely done as long as there are no
    > intervening read-y actions (targets of the synchronizes-with
    > edges as defined by JLS/JSE7 17.4.4).
    >
    > Now, my questions are:
    >
    > 1. Is there a loophole in my reasoning?
    >
    > 2. If there is no loophole, is there anything to worry about,
    > given that practically 100% developers out there consider as
    > guaranteed something that isn't?
    >
    >
    > -Marko
    >
    >
    >
    >
    > _______________________________________________
    > Concurrency-interest mailing list
    > Concurrency-interest at cs.oswego.edu
    > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    >

    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at cs.oswego.edu
    http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120818/e4e2567f/attachment-0001.html>

From vitalyd at gmail.com  Fri Aug 17 19:21:44 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 17 Aug 2012 19:21:44 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
Message-ID: <CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>

Two volatile writes emit a store-store barrier in between, which to me
means they cannot be collapsed and must be made visible in that order (on
non-TSO this would require a h/w fence).  In other words, I don't think
compiler can remove the redundant stores as if this was a non-volatile
field, where it's a perfectly valid (and good) optimization.

Sent from my phone
On Aug 17, 2012 7:18 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:

> **
> How does it violate the JMM? There is nothing to establish that any read
> has to have occurred prior to w=3. An external observer may say "hey if
> we'd actually written w=1 at this point then the read would see 1" but that
> is irrelevant. The program can not tell the other writes did not occur.
>
> David
>
> -----Original Message-----
> *From:* Vitaly Davidovich [mailto:vitalyd at gmail.com]
> *Sent:* Saturday, 18 August 2012 9:12 AM
> *To:* dholmes at ieee.org
> *Cc:* Marko Topolnik; concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Relativity of guarantees provided
> by volatile
>
> I don't think the writes to w can be reduced to just the last one as it
> would violate the JMM.  R may only see the last one due to interleaving
> though. Not sure if that's what you meant.
>
> Sent from my phone
> On Aug 17, 2012 7:03 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>
>> Hi Marko,
>>
>> I think the "surprise" is only in the way you formulated this. Said
>> another
>> way a write takes a finite amount of time from when the instruction starts
>> to execute to when the store is actually available for a read to see.
>> (Similarly a read takes a finite amount of time.) So depending on those
>> two
>> times a read and write that happen "around the same time" may appear to
>> have
>> occurred in either order. But when you program with threads you never know
>> the relative interleavings (or should never assume) so it makes no
>> difference how the program perceives the order compared to how some
>> external
>> observer might perceive it.
>>
>> As for your optimization to "chunk" volatile writes, I don't see a problem
>> here if you are basically asking if given:
>>
>> w = 1;  // w is volatile
>> w = 2;
>> w = 3;
>>
>> that this could be reduced to the last write alone? I see no reason why
>> not.
>> Without some additional coordination between a reader thread and the
>> writer
>> thread, reading w==3 is a legitimate outcome. If you are thinking about
>> how
>> the hardware might chunk things then that is a different matter. We have
>> to
>> use the hardware in a way that complies with the memory model - if the
>> hardware can't comply then you can't run Java on it.
>>
>> David Holmes
>> ------------
>>
>> > -----Original Message-----
>> > From: concurrency-interest-bounces at cs.oswego.edu
>> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
>> > Topolnik
>> > Sent: Saturday, 18 August 2012 7:24 AM
>> > To: concurrency-interest at cs.oswego.edu
>> > Subject: [concurrency-interest] Relativity of guarantees provided by
>> > volatile
>> >
>> >
>> > Consider the following synchronization order of a program
>> > execution involving a total of two threads, R and W:
>> >
>> > - thread R begins;
>> >
>> > - thread R reads a volatile int sharedVar several times. Each
>> > time it reads the value 0;
>> >
>> > - thread R completes;
>> >
>> > - thread W begins;
>> >
>> > - thread W writes the sharedVar several times. Each time it
>> > writes the value 1;
>> >
>> > - thread W completes.
>> >
>> > Now consider the wall-clock timing of the events:
>> >
>> > - thread R reads 0 at t = {1, 4, 7, 10};
>> > - thread W writes 1 at t = {0, 3, 6, 9}.
>> >
>> > As far as the Java Memory Model is concerned, there is no
>> > contradiction between the synchronization order and the
>> > wall-clock times, as the JMM is wall-clock agnostic. However, I
>> > have yet to meet a single Java professional who wouldn't at least
>> > be very surprised to hear that the specification allows this.
>> >
>> > I understand that the SMP architecture that dominates the world
>> > of computing today practically never takes these liberties and
>> > makes the volatile writes visible almost instantaneously. This
>> > may change at any time, however, especially with the advent of
>> > massively parrallel architectures that seem to be the future. For
>> > example, an optimization technique may choose to chunk many
>> > volatile writes together and make them visible in a single bulk
>> > operation. This can be safely done as long as there are no
>> > intervening read-y actions (targets of the synchronizes-with
>> > edges as defined by JLS/JSE7 17.4.4).
>> >
>> > Now, my questions are:
>> >
>> > 1. Is there a loophole in my reasoning?
>> >
>> > 2. If there is no loophole, is there anything to worry about,
>> > given that practically 100% developers out there consider as
>> > guaranteed something that isn't?
>> >
>> >
>> > -Marko
>> >
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/4d7acc63/attachment.html>

From nathan.reynolds at oracle.com  Fri Aug 17 19:25:17 2012
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Fri, 17 Aug 2012 16:25:17 -0700
Subject: [concurrency-interest] Relativity of guarantees provided
	byvolatile
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEDFJGAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCCEDFJGAA.davidcholmes@aapt.net.au>
Message-ID: <502ED2DD.1090607@oracle.com>

Hmm...  I am getting tripped up on JMM vs Intel memory model vs HotSpot 
implementation.

Dictionary.com says subsequent = occurring or coming later or after; 
following in order or succession.  Given that each read happens 1 unit 
of time after every write, I would think that the read is "subsequent" 
to the write.  In other words, once the write happens, then any read 
operation which starts execution after that point in time will be 
subsequent to the write and hence will see the effects of the write.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 8/17/2012 4:03 PM, David Holmes wrote:
> Nathan,
> Is there a synchronization order here that indicates that the read 
> occurs after the write? "subsequent" is not defined by wall-clock time 
> as externally observed.
> And to batch responses :) Hotspot's implementation requires that all 
> writes will become visible without need for explicit barriers/fences 
> to force that.
> David
>
>     -----Original Message-----
>     *From:* concurrency-interest-bounces at cs.oswego.edu
>     [mailto:concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of
>     *Nathan Reynolds
>     *Sent:* Saturday, 18 August 2012 8:47 AM
>     *To:* concurrency-interest at cs.oswego.edu
>     *Subject:* Re: [concurrency-interest] Relativity of guarantees
>     provided byvolatile
>
>     > I have yet to meet a single Java professional who wouldn't at
>     least be very surprised to hear that the specification allows this.
>
>     Add me to the list of surprised.
>
>     Here's an excerpt from the specification.
>
>     A write to a volatile variable (?8.3.1.4)
>     <http://docs.oracle.com/javase/specs/jls/se5.0/html/classes.html#36930>
>     /v/ synchronizes-with all subsequent reads of /v/ by any thread
>     (where subsequent is defined according to the synchronization order).
>
>     http://docs.oracle.com/javase/specs/jls/se5.0/html/memory.html#17.4.4
>
>     Doesn't this mean that R will always read 1 since the read occurs
>     after the write?
>
>     Nathan Reynolds
>     <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>     Consulting Member of Technical Staff | 602.333.9091
>     Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>     On 8/17/2012 2:24 PM, Marko Topolnik wrote:
>>     Consider the following synchronization order of a program execution involving a total of two threads, R and W:
>>
>>     - thread R begins;
>>
>>     - thread R reads a volatile int sharedVar several times. Each time it reads the value 0;
>>
>>     - thread R completes;
>>
>>     - thread W begins;
>>
>>     - thread W writes the sharedVar several times. Each time it writes the value 1;
>>
>>     - thread W completes.
>>
>>     Now consider the wall-clock timing of the events:
>>
>>     - thread R reads 0 at t = {1, 4, 7, 10};
>>     - thread W writes 1 at t = {0, 3, 6, 9}.
>>
>>     As far as the Java Memory Model is concerned, there is no contradiction between the synchronization order and the wall-clock times, as the JMM is wall-clock agnostic. However, I have yet to meet a single Java professional who wouldn't at least be very surprised to hear that the specification allows this.
>>
>>     I understand that the SMP architecture that dominates the world of computing today practically never takes these liberties and makes the volatile writes visible almost instantaneously. This may change at any time, however, especially with the advent of massively parrallel architectures that seem to be the future. For example, an optimization technique may choose to chunk many volatile writes together and make them visible in a single bulk operation. This can be safely done as long as there are no intervening read-y actions (targets of the synchronizes-with edges as defined by JLS/JSE7 17.4.4).
>>
>>     Now, my questions are:
>>
>>     1. Is there a loophole in my reasoning?
>>
>>     2. If there is no loophole, is there anything to worry about, given that practically 100% developers out there consider as guaranteed something that isn't?
>>
>>
>>     -Marko
>>
>>
>>
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/64369244/attachment-0001.html>

From davidcholmes at aapt.net.au  Fri Aug 17 19:28:55 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 18 Aug 2012 09:28:55 +1000
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEDHJGAA.davidcholmes@aapt.net.au>

Well we just have to agree to disagree. If nothing in the program order or
synchronization order establishes that a read must happen between a pair of
those writes, then the read need not happen until after the last write. As I
said externally you may be able to see that the optimization was performed
but the program can not tell - and that is what counts.

David
  -----Original Message-----
  From: Vitaly Davidovich [mailto:vitalyd at gmail.com]
  Sent: Saturday, 18 August 2012 9:22 AM
  To: dholmes at ieee.org
  Cc: Marko Topolnik; concurrency-interest at cs.oswego.edu
  Subject: RE: [concurrency-interest] Relativity of guarantees provided by
volatile


  Two volatile writes emit a store-store barrier in between, which to me
means they cannot be collapsed and must be made visible in that order (on
non-TSO this would require a h/w fence).  In other words, I don't think
compiler can remove the redundant stores as if this was a non-volatile
field, where it's a perfectly valid (and good) optimization.

  Sent from my phone

  On Aug 17, 2012 7:18 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:

    How does it violate the JMM? There is nothing to establish that any read
has to have occurred prior to w=3. An external observer may say "hey if we'd
actually written w=1 at this point then the read would see 1" but that is
irrelevant. The program can not tell the other writes did not occur.

    David
      -----Original Message-----
      From: Vitaly Davidovich [mailto:vitalyd at gmail.com]
      Sent: Saturday, 18 August 2012 9:12 AM
      To: dholmes at ieee.org
      Cc: Marko Topolnik; concurrency-interest at cs.oswego.edu
      Subject: Re: [concurrency-interest] Relativity of guarantees provided
by volatile


      I don't think the writes to w can be reduced to just the last one as
it would violate the JMM.  R may only see the last one due to interleaving
though. Not sure if that's what you meant.

      Sent from my phone

      On Aug 17, 2012 7:03 PM, "David Holmes" <davidcholmes at aapt.net.au>
wrote:

        Hi Marko,

        I think the "surprise" is only in the way you formulated this. Said
another
        way a write takes a finite amount of time from when the instruction
starts
        to execute to when the store is actually available for a read to
see.
        (Similarly a read takes a finite amount of time.) So depending on
those two
        times a read and write that happen "around the same time" may appear
to have
        occurred in either order. But when you program with threads you
never know
        the relative interleavings (or should never assume) so it makes no
        difference how the program perceives the order compared to how some
external
        observer might perceive it.

        As for your optimization to "chunk" volatile writes, I don't see a
problem
        here if you are basically asking if given:

        w = 1;  // w is volatile
        w = 2;
        w = 3;

        that this could be reduced to the last write alone? I see no reason
why not.
        Without some additional coordination between a reader thread and the
writer
        thread, reading w==3 is a legitimate outcome. If you are thinking
about how
        the hardware might chunk things then that is a different matter. We
have to
        use the hardware in a way that complies with the memory model - if
the
        hardware can't comply then you can't run Java on it.

        David Holmes
        ------------

        > -----Original Message-----
        > From: concurrency-interest-bounces at cs.oswego.edu
        > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
Marko
        > Topolnik
        > Sent: Saturday, 18 August 2012 7:24 AM
        > To: concurrency-interest at cs.oswego.edu
        > Subject: [concurrency-interest] Relativity of guarantees provided
by
        > volatile
        >
        >
        > Consider the following synchronization order of a program
        > execution involving a total of two threads, R and W:
        >
        > - thread R begins;
        >
        > - thread R reads a volatile int sharedVar several times. Each
        > time it reads the value 0;
        >
        > - thread R completes;
        >
        > - thread W begins;
        >
        > - thread W writes the sharedVar several times. Each time it
        > writes the value 1;
        >
        > - thread W completes.
        >
        > Now consider the wall-clock timing of the events:
        >
        > - thread R reads 0 at t = {1, 4, 7, 10};
        > - thread W writes 1 at t = {0, 3, 6, 9}.
        >
        > As far as the Java Memory Model is concerned, there is no
        > contradiction between the synchronization order and the
        > wall-clock times, as the JMM is wall-clock agnostic. However, I
        > have yet to meet a single Java professional who wouldn't at least
        > be very surprised to hear that the specification allows this.
        >
        > I understand that the SMP architecture that dominates the world
        > of computing today practically never takes these liberties and
        > makes the volatile writes visible almost instantaneously. This
        > may change at any time, however, especially with the advent of
        > massively parrallel architectures that seem to be the future. For
        > example, an optimization technique may choose to chunk many
        > volatile writes together and make them visible in a single bulk
        > operation. This can be safely done as long as there are no
        > intervening read-y actions (targets of the synchronizes-with
        > edges as defined by JLS/JSE7 17.4.4).
        >
        > Now, my questions are:
        >
        > 1. Is there a loophole in my reasoning?
        >
        > 2. If there is no loophole, is there anything to worry about,
        > given that practically 100% developers out there consider as
        > guaranteed something that isn't?
        >
        >
        > -Marko
        >
        >
        >
        >
        > _______________________________________________
        > Concurrency-interest mailing list
        > Concurrency-interest at cs.oswego.edu
        > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
        >

        _______________________________________________
        Concurrency-interest mailing list
        Concurrency-interest at cs.oswego.edu
        http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120818/512863f4/attachment.html>

From yshavit at akiban.com  Fri Aug 17 19:30:25 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Fri, 17 Aug 2012 19:30:25 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
Message-ID: <CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>

Sure, but it could decide that the execution order is [w1, w2, w3, r]. In
fact, as far as we know, the thread may have been scheduled such that that
was the clock-time ordering, too.

On Fri, Aug 17, 2012 at 7:21 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:

> Two volatile writes emit a store-store barrier in between, which to me
> means they cannot be collapsed and must be made visible in that order (on
> non-TSO this would require a h/w fence).  In other words, I don't think
> compiler can remove the redundant stores as if this was a non-volatile
> field, where it's a perfectly valid (and good) optimization.
>
> Sent from my phone
> On Aug 17, 2012 7:18 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>
>> **
>> How does it violate the JMM? There is nothing to establish that any read
>> has to have occurred prior to w=3. An external observer may say "hey if
>> we'd actually written w=1 at this point then the read would see 1" but that
>> is irrelevant. The program can not tell the other writes did not occur.
>>
>> David
>>
>> -----Original Message-----
>> *From:* Vitaly Davidovich [mailto:vitalyd at gmail.com]
>> *Sent:* Saturday, 18 August 2012 9:12 AM
>> *To:* dholmes at ieee.org
>> *Cc:* Marko Topolnik; concurrency-interest at cs.oswego.edu
>> *Subject:* Re: [concurrency-interest] Relativity of guarantees provided
>> by volatile
>>
>> I don't think the writes to w can be reduced to just the last one as it
>> would violate the JMM.  R may only see the last one due to interleaving
>> though. Not sure if that's what you meant.
>>
>> Sent from my phone
>> On Aug 17, 2012 7:03 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>>
>>> Hi Marko,
>>>
>>> I think the "surprise" is only in the way you formulated this. Said
>>> another
>>> way a write takes a finite amount of time from when the instruction
>>> starts
>>> to execute to when the store is actually available for a read to see.
>>> (Similarly a read takes a finite amount of time.) So depending on those
>>> two
>>> times a read and write that happen "around the same time" may appear to
>>> have
>>> occurred in either order. But when you program with threads you never
>>> know
>>> the relative interleavings (or should never assume) so it makes no
>>> difference how the program perceives the order compared to how some
>>> external
>>> observer might perceive it.
>>>
>>> As for your optimization to "chunk" volatile writes, I don't see a
>>> problem
>>> here if you are basically asking if given:
>>>
>>> w = 1;  // w is volatile
>>> w = 2;
>>> w = 3;
>>>
>>> that this could be reduced to the last write alone? I see no reason why
>>> not.
>>> Without some additional coordination between a reader thread and the
>>> writer
>>> thread, reading w==3 is a legitimate outcome. If you are thinking about
>>> how
>>> the hardware might chunk things then that is a different matter. We have
>>> to
>>> use the hardware in a way that complies with the memory model - if the
>>> hardware can't comply then you can't run Java on it.
>>>
>>> David Holmes
>>> ------------
>>>
>>> > -----Original Message-----
>>> > From: concurrency-interest-bounces at cs.oswego.edu
>>> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
>>> > Topolnik
>>> > Sent: Saturday, 18 August 2012 7:24 AM
>>> > To: concurrency-interest at cs.oswego.edu
>>> > Subject: [concurrency-interest] Relativity of guarantees provided by
>>> > volatile
>>> >
>>> >
>>> > Consider the following synchronization order of a program
>>> > execution involving a total of two threads, R and W:
>>> >
>>> > - thread R begins;
>>> >
>>> > - thread R reads a volatile int sharedVar several times. Each
>>> > time it reads the value 0;
>>> >
>>> > - thread R completes;
>>> >
>>> > - thread W begins;
>>> >
>>> > - thread W writes the sharedVar several times. Each time it
>>> > writes the value 1;
>>> >
>>> > - thread W completes.
>>> >
>>> > Now consider the wall-clock timing of the events:
>>> >
>>> > - thread R reads 0 at t = {1, 4, 7, 10};
>>> > - thread W writes 1 at t = {0, 3, 6, 9}.
>>> >
>>> > As far as the Java Memory Model is concerned, there is no
>>> > contradiction between the synchronization order and the
>>> > wall-clock times, as the JMM is wall-clock agnostic. However, I
>>> > have yet to meet a single Java professional who wouldn't at least
>>> > be very surprised to hear that the specification allows this.
>>> >
>>> > I understand that the SMP architecture that dominates the world
>>> > of computing today practically never takes these liberties and
>>> > makes the volatile writes visible almost instantaneously. This
>>> > may change at any time, however, especially with the advent of
>>> > massively parrallel architectures that seem to be the future. For
>>> > example, an optimization technique may choose to chunk many
>>> > volatile writes together and make them visible in a single bulk
>>> > operation. This can be safely done as long as there are no
>>> > intervening read-y actions (targets of the synchronizes-with
>>> > edges as defined by JLS/JSE7 17.4.4).
>>> >
>>> > Now, my questions are:
>>> >
>>> > 1. Is there a loophole in my reasoning?
>>> >
>>> > 2. If there is no loophole, is there anything to worry about,
>>> > given that practically 100% developers out there consider as
>>> > guaranteed something that isn't?
>>> >
>>> >
>>> > -Marko
>>> >
>>> >
>>> >
>>> >
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/c4556036/attachment-0001.html>

From davidcholmes at aapt.net.au  Fri Aug 17 19:34:21 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 18 Aug 2012 09:34:21 +1000
Subject: [concurrency-interest] Relativity of guarantees provided
	byvolatile
In-Reply-To: <502ED2DD.1090607@oracle.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEDHJGAA.davidcholmes@aapt.net.au>

"In other words, once the write happens, then any read operation which
starts execution after that point in time will be subsequent to the write
and hence will see the effects of the write."

EXACTLY! Once the write has happened the read is subsequent. But that isn't
the same as saying "once the write has started". The thing is, does "coming
after" mean "starting after" or "completing after"? I would argue completing
after. In fact I seem to recall that the full formal model for the JMM
assumed that instructions executed instantaneously, so that this kind of
discussion would not arise. If this discussion were on the JMM list where it
belongs someone may have already pointed that out. :) I may be
mis-remembering of course.

David

  -----Original Message-----
  From: Nathan Reynolds [mailto:nathan.reynolds at oracle.com]
  Sent: Saturday, 18 August 2012 9:25 AM
  To: dholmes at ieee.org
  Cc: David Holmes; concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Relativity of guarantees provided
byvolatile


  Hmm...  I am getting tripped up on JMM vs Intel memory model vs HotSpot
implementation.

  Dictionary.com says subsequent = occurring or coming later or after;
following in order or succession.  Given that each read happens 1 unit of
time after every write, I would think that the read is "subsequent" to the
write.  In other words, once the write happens, then any read operation
which starts execution after that point in time will be subsequent to the
write and hence will see the effects of the write.


  Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
  Oracle PSR Engineering | Server Technology

  On 8/17/2012 4:03 PM, David Holmes wrote:

    Nathan,

    Is there a synchronization order here that indicates that the read
occurs after the write? "subsequent" is not defined by wall-clock time as
externally observed.

    And to batch responses :) Hotspot's implementation requires that all
writes will become visible without need for explicit barriers/fences to
force that.

    David
      -----Original Message-----
      From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Nathan
Reynolds
      Sent: Saturday, 18 August 2012 8:47 AM
      To: concurrency-interest at cs.oswego.edu
      Subject: Re: [concurrency-interest] Relativity of guarantees provided
byvolatile


      > I have yet to meet a single Java professional who wouldn't at least
be very surprised to hear that the specification allows this.

      Add me to the list of surprised.

      Here's an excerpt from the specification.

      A write to a volatile variable (?8.3.1.4) v synchronizes-with all
subsequent reads of v by any thread (where subsequent is defined according
to the synchronization order).

      http://docs.oracle.com/javase/specs/jls/se5.0/html/memory.html#17.4.4

      Doesn't this mean that R will always read 1 since the read occurs
after the write?


      Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
      Oracle PSR Engineering | Server Technology

      On 8/17/2012 2:24 PM, Marko Topolnik wrote:

Consider the following synchronization order of a program execution
involving a total of two threads, R and W:

- thread R begins;

- thread R reads a volatile int sharedVar several times. Each time it reads
the value 0;

- thread R completes;

- thread W begins;

- thread W writes the sharedVar several times. Each time it writes the value
1;

- thread W completes.

Now consider the wall-clock timing of the events:

- thread R reads 0 at t = {1, 4, 7, 10};
- thread W writes 1 at t = {0, 3, 6, 9}.

As far as the Java Memory Model is concerned, there is no contradiction
between the synchronization order and the wall-clock times, as the JMM is
wall-clock agnostic. However, I have yet to meet a single Java professional
who wouldn't at least be very surprised to hear that the specification
allows this.

I understand that the SMP architecture that dominates the world of computing
today practically never takes these liberties and makes the volatile writes
visible almost instantaneously. This may change at any time, however,
especially with the advent of massively parrallel architectures that seem to
be the future. For example, an optimization technique may choose to chunk
many volatile writes together and make them visible in a single bulk
operation. This can be safely done as long as there are no intervening
read-y actions (targets of the synchronizes-with edges as defined by
JLS/JSE7 17.4.4).

Now, my questions are:

1. Is there a loophole in my reasoning?

2. If there is no loophole, is there anything to worry about, given that
practically 100% developers out there consider as guaranteed something that
isn't?


-Marko




_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120818/54577568/attachment.html>

From vitalyd at gmail.com  Fri Aug 17 19:41:20 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 17 Aug 2012 19:41:20 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
Message-ID: <CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>

David and you may be right in the theoretical aspect.  In practice, I can't
fathom how a JVM can do this type of analysis.  That's an issue that I have
with JMM's wording of happens-before -- it doesn't translate to reality, it
seems like.

Sent from my phone
On Aug 17, 2012 7:30 PM, "Yuval Shavit" <yshavit at akiban.com> wrote:

> Sure, but it could decide that the execution order is [w1, w2, w3, r]. In
> fact, as far as we know, the thread may have been scheduled such that that
> was the clock-time ordering, too.
>
> On Fri, Aug 17, 2012 at 7:21 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>
>> Two volatile writes emit a store-store barrier in between, which to me
>> means they cannot be collapsed and must be made visible in that order (on
>> non-TSO this would require a h/w fence).  In other words, I don't think
>> compiler can remove the redundant stores as if this was a non-volatile
>> field, where it's a perfectly valid (and good) optimization.
>>
>> Sent from my phone
>> On Aug 17, 2012 7:18 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>>
>>> **
>>> How does it violate the JMM? There is nothing to establish that any read
>>> has to have occurred prior to w=3. An external observer may say "hey if
>>> we'd actually written w=1 at this point then the read would see 1" but that
>>> is irrelevant. The program can not tell the other writes did not occur.
>>>
>>> David
>>>
>>> -----Original Message-----
>>> *From:* Vitaly Davidovich [mailto:vitalyd at gmail.com]
>>> *Sent:* Saturday, 18 August 2012 9:12 AM
>>> *To:* dholmes at ieee.org
>>> *Cc:* Marko Topolnik; concurrency-interest at cs.oswego.edu
>>> *Subject:* Re: [concurrency-interest] Relativity of guarantees provided
>>> by volatile
>>>
>>> I don't think the writes to w can be reduced to just the last one as it
>>> would violate the JMM.  R may only see the last one due to interleaving
>>> though. Not sure if that's what you meant.
>>>
>>> Sent from my phone
>>> On Aug 17, 2012 7:03 PM, "David Holmes" <davidcholmes at aapt.net.au>
>>> wrote:
>>>
>>>> Hi Marko,
>>>>
>>>> I think the "surprise" is only in the way you formulated this. Said
>>>> another
>>>> way a write takes a finite amount of time from when the instruction
>>>> starts
>>>> to execute to when the store is actually available for a read to see.
>>>> (Similarly a read takes a finite amount of time.) So depending on those
>>>> two
>>>> times a read and write that happen "around the same time" may appear to
>>>> have
>>>> occurred in either order. But when you program with threads you never
>>>> know
>>>> the relative interleavings (or should never assume) so it makes no
>>>> difference how the program perceives the order compared to how some
>>>> external
>>>> observer might perceive it.
>>>>
>>>> As for your optimization to "chunk" volatile writes, I don't see a
>>>> problem
>>>> here if you are basically asking if given:
>>>>
>>>> w = 1;  // w is volatile
>>>> w = 2;
>>>> w = 3;
>>>>
>>>> that this could be reduced to the last write alone? I see no reason why
>>>> not.
>>>> Without some additional coordination between a reader thread and the
>>>> writer
>>>> thread, reading w==3 is a legitimate outcome. If you are thinking about
>>>> how
>>>> the hardware might chunk things then that is a different matter. We
>>>> have to
>>>> use the hardware in a way that complies with the memory model - if the
>>>> hardware can't comply then you can't run Java on it.
>>>>
>>>> David Holmes
>>>> ------------
>>>>
>>>> > -----Original Message-----
>>>> > From: concurrency-interest-bounces at cs.oswego.edu
>>>> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
>>>> > Topolnik
>>>> > Sent: Saturday, 18 August 2012 7:24 AM
>>>> > To: concurrency-interest at cs.oswego.edu
>>>> > Subject: [concurrency-interest] Relativity of guarantees provided by
>>>> > volatile
>>>> >
>>>> >
>>>> > Consider the following synchronization order of a program
>>>> > execution involving a total of two threads, R and W:
>>>> >
>>>> > - thread R begins;
>>>> >
>>>> > - thread R reads a volatile int sharedVar several times. Each
>>>> > time it reads the value 0;
>>>> >
>>>> > - thread R completes;
>>>> >
>>>> > - thread W begins;
>>>> >
>>>> > - thread W writes the sharedVar several times. Each time it
>>>> > writes the value 1;
>>>> >
>>>> > - thread W completes.
>>>> >
>>>> > Now consider the wall-clock timing of the events:
>>>> >
>>>> > - thread R reads 0 at t = {1, 4, 7, 10};
>>>> > - thread W writes 1 at t = {0, 3, 6, 9}.
>>>> >
>>>> > As far as the Java Memory Model is concerned, there is no
>>>> > contradiction between the synchronization order and the
>>>> > wall-clock times, as the JMM is wall-clock agnostic. However, I
>>>> > have yet to meet a single Java professional who wouldn't at least
>>>> > be very surprised to hear that the specification allows this.
>>>> >
>>>> > I understand that the SMP architecture that dominates the world
>>>> > of computing today practically never takes these liberties and
>>>> > makes the volatile writes visible almost instantaneously. This
>>>> > may change at any time, however, especially with the advent of
>>>> > massively parrallel architectures that seem to be the future. For
>>>> > example, an optimization technique may choose to chunk many
>>>> > volatile writes together and make them visible in a single bulk
>>>> > operation. This can be safely done as long as there are no
>>>> > intervening read-y actions (targets of the synchronizes-with
>>>> > edges as defined by JLS/JSE7 17.4.4).
>>>> >
>>>> > Now, my questions are:
>>>> >
>>>> > 1. Is there a loophole in my reasoning?
>>>> >
>>>> > 2. If there is no loophole, is there anything to worry about,
>>>> > given that practically 100% developers out there consider as
>>>> > guaranteed something that isn't?
>>>> >
>>>> >
>>>> > -Marko
>>>> >
>>>> >
>>>> >
>>>> >
>>>> > _______________________________________________
>>>> > Concurrency-interest mailing list
>>>> > Concurrency-interest at cs.oswego.edu
>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> >
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/776a55f2/attachment-0001.html>

From zhong.j.yu at gmail.com  Fri Aug 17 19:41:51 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Fri, 17 Aug 2012 18:41:51 -0500
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
References: <3CEE49F2-DFEB-4D8B-BCFD-4FBD2E16D200@inge-mark.hr>
	<616A1C6D-148D-4971-B752-F085115F3DD5@inge-mark.hr>
	<B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
Message-ID: <CACuKZqGfPnCo0iPX9HPRfagqkQPQR8HnUxH=pP8z1D=naJKhUg@mail.gmail.com>

Actually we need to reverse engineer a synchronization order, from
values written and read. This is not always possible. For example,
thread W writes 1 then writes 2, and thread R reads 2 then reads 1.
(all volatile) There is no way to concoct a synchronization order
consistent with other JMM requirements. Therefore the example is
impossible under JMM.

Is OP's example possible under JMM? I think so, we can construct a
physical model that conforms to JMM but with a slow signal speed (say
data are delivered by USPS), and OP's example can be realized on it.

Zhong Yu

From yshavit at akiban.com  Fri Aug 17 19:48:36 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Fri, 17 Aug 2012 19:48:36 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
Message-ID: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>

(Resending -- I'd accidentally sent this only to Nathan)

So, Nathan, you're essentially saying that "subsequent" is defined in terms
of clock time. If we take that as the definition, then I agree that it
works as we'd all expect. Furthermore, I agree that that's the intuitive
definition, as well as the de-facto one. But it doesn't seem to be the one
explicitly defined by the JLS. (And if it is the one implicitly defined by
the JLS, I there's a serious bug waiting for any distributed-node JVM whose
nodes are traveling away from each other at relativistic speeds! ... though
I'm no physics expert.)

That said, 17.4.3 does imply that the reads will be viewable in a
wall-clock-sequential way, albeit informally

    Sequential consistency is a very strong guarantee that is made about
visibility and ordering in an execution of a program. Within a sequentially
consistent execution, there is a total order over all individual actions
(such as reads and writes) which is consistent with the order of the
program, and each individual action is atomic and is immediately visible to
every thread.

(emphasis on "is immediately visible")

On Fri, Aug 17, 2012 at 7:41 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:

> David and you may be right in the theoretical aspect.  In practice, I
> can't fathom how a JVM can do this type of analysis.  That's an issue that
> I have with JMM's wording of happens-before -- it doesn't translate to
> reality, it seems like.
>
> Sent from my phone
> On Aug 17, 2012 7:30 PM, "Yuval Shavit" <yshavit at akiban.com> wrote:
>
>> Sure, but it could decide that the execution order is [w1, w2, w3, r]. In
>> fact, as far as we know, the thread may have been scheduled such that that
>> was the clock-time ordering, too.
>>
>> On Fri, Aug 17, 2012 at 7:21 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>>
>>> Two volatile writes emit a store-store barrier in between, which to me
>>> means they cannot be collapsed and must be made visible in that order (on
>>> non-TSO this would require a h/w fence).  In other words, I don't think
>>> compiler can remove the redundant stores as if this was a non-volatile
>>> field, where it's a perfectly valid (and good) optimization.
>>>
>>> Sent from my phone
>>> On Aug 17, 2012 7:18 PM, "David Holmes" <davidcholmes at aapt.net.au>
>>> wrote:
>>>
>>>> **
>>>> How does it violate the JMM? There is nothing to establish that any
>>>> read has to have occurred prior to w=3. An external observer may say "hey
>>>> if we'd actually written w=1 at this point then the read would see 1" but
>>>> that is irrelevant. The program can not tell the other writes did not occur.
>>>>
>>>> David
>>>>
>>>> -----Original Message-----
>>>> *From:* Vitaly Davidovich [mailto:vitalyd at gmail.com]
>>>> *Sent:* Saturday, 18 August 2012 9:12 AM
>>>> *To:* dholmes at ieee.org
>>>> *Cc:* Marko Topolnik; concurrency-interest at cs.oswego.edu
>>>> *Subject:* Re: [concurrency-interest] Relativity of guarantees
>>>> provided by volatile
>>>>
>>>> I don't think the writes to w can be reduced to just the last one as it
>>>> would violate the JMM.  R may only see the last one due to interleaving
>>>> though. Not sure if that's what you meant.
>>>>
>>>> Sent from my phone
>>>> On Aug 17, 2012 7:03 PM, "David Holmes" <davidcholmes at aapt.net.au>
>>>> wrote:
>>>>
>>>>> Hi Marko,
>>>>>
>>>>> I think the "surprise" is only in the way you formulated this. Said
>>>>> another
>>>>> way a write takes a finite amount of time from when the instruction
>>>>> starts
>>>>> to execute to when the store is actually available for a read to see.
>>>>> (Similarly a read takes a finite amount of time.) So depending on
>>>>> those two
>>>>> times a read and write that happen "around the same time" may appear
>>>>> to have
>>>>> occurred in either order. But when you program with threads you never
>>>>> know
>>>>> the relative interleavings (or should never assume) so it makes no
>>>>> difference how the program perceives the order compared to how some
>>>>> external
>>>>> observer might perceive it.
>>>>>
>>>>> As for your optimization to "chunk" volatile writes, I don't see a
>>>>> problem
>>>>> here if you are basically asking if given:
>>>>>
>>>>> w = 1;  // w is volatile
>>>>> w = 2;
>>>>> w = 3;
>>>>>
>>>>> that this could be reduced to the last write alone? I see no reason
>>>>> why not.
>>>>> Without some additional coordination between a reader thread and the
>>>>> writer
>>>>> thread, reading w==3 is a legitimate outcome. If you are thinking
>>>>> about how
>>>>> the hardware might chunk things then that is a different matter. We
>>>>> have to
>>>>> use the hardware in a way that complies with the memory model - if the
>>>>> hardware can't comply then you can't run Java on it.
>>>>>
>>>>> David Holmes
>>>>> ------------
>>>>>
>>>>> > -----Original Message-----
>>>>> > From: concurrency-interest-bounces at cs.oswego.edu
>>>>> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
>>>>> Marko
>>>>> > Topolnik
>>>>> > Sent: Saturday, 18 August 2012 7:24 AM
>>>>> > To: concurrency-interest at cs.oswego.edu
>>>>> > Subject: [concurrency-interest] Relativity of guarantees provided by
>>>>> > volatile
>>>>> >
>>>>> >
>>>>> > Consider the following synchronization order of a program
>>>>> > execution involving a total of two threads, R and W:
>>>>> >
>>>>> > - thread R begins;
>>>>> >
>>>>> > - thread R reads a volatile int sharedVar several times. Each
>>>>> > time it reads the value 0;
>>>>> >
>>>>> > - thread R completes;
>>>>> >
>>>>> > - thread W begins;
>>>>> >
>>>>> > - thread W writes the sharedVar several times. Each time it
>>>>> > writes the value 1;
>>>>> >
>>>>> > - thread W completes.
>>>>> >
>>>>> > Now consider the wall-clock timing of the events:
>>>>> >
>>>>> > - thread R reads 0 at t = {1, 4, 7, 10};
>>>>> > - thread W writes 1 at t = {0, 3, 6, 9}.
>>>>> >
>>>>> > As far as the Java Memory Model is concerned, there is no
>>>>> > contradiction between the synchronization order and the
>>>>> > wall-clock times, as the JMM is wall-clock agnostic. However, I
>>>>> > have yet to meet a single Java professional who wouldn't at least
>>>>> > be very surprised to hear that the specification allows this.
>>>>> >
>>>>> > I understand that the SMP architecture that dominates the world
>>>>> > of computing today practically never takes these liberties and
>>>>> > makes the volatile writes visible almost instantaneously. This
>>>>> > may change at any time, however, especially with the advent of
>>>>> > massively parrallel architectures that seem to be the future. For
>>>>> > example, an optimization technique may choose to chunk many
>>>>> > volatile writes together and make them visible in a single bulk
>>>>> > operation. This can be safely done as long as there are no
>>>>> > intervening read-y actions (targets of the synchronizes-with
>>>>> > edges as defined by JLS/JSE7 17.4.4).
>>>>> >
>>>>> > Now, my questions are:
>>>>> >
>>>>> > 1. Is there a loophole in my reasoning?
>>>>> >
>>>>> > 2. If there is no loophole, is there anything to worry about,
>>>>> > given that practically 100% developers out there consider as
>>>>> > guaranteed something that isn't?
>>>>> >
>>>>> >
>>>>> > -Marko
>>>>> >
>>>>> >
>>>>> >
>>>>> >
>>>>> > _______________________________________________
>>>>> > Concurrency-interest mailing list
>>>>> > Concurrency-interest at cs.oswego.edu
>>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> >
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/adbb5590/attachment.html>

From davidcholmes at aapt.net.au  Fri Aug 17 20:03:20 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 18 Aug 2012 10:03:20 +1000
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEDJJGAA.davidcholmes@aapt.net.au>

Ah I knew there was something about "immediate" in there somewhere :) So if
instructions were immediate (ie they completed as soon as they started) then
wall clock observations would be consistent with actual executions. But on
real systems instructions are not immediate so you have to take the
completion of the instruction as the point at which to make a wall clock
observation.

Aside: as well as being atomic and immediate you also need to preclude two
instructions from executing simultaneously :)

David (now departing to enjoy the weekend :) )
  -----Original Message-----
  From: Yuval Shavit [mailto:yshavit at akiban.com]
  Sent: Saturday, 18 August 2012 9:49 AM
  To: Vitaly Davidovich
  Cc: dholmes at ieee.org; concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Relativity of guarantees provided by
volatile


  (Resending -- I'd accidentally sent this only to Nathan)


  So, Nathan, you're essentially saying that "subsequent" is defined in
terms of clock time. If we take that as the definition, then I agree that it
works as we'd all expect. Furthermore, I agree that that's the intuitive
definition, as well as the de-facto one. But it doesn't seem to be the one
explicitly defined by the JLS. (And if it is the one implicitly defined by
the JLS, I there's a serious bug waiting for any distributed-node JVM whose
nodes are traveling away from each other at relativistic speeds! ... though
I'm no physics expert.)


  That said, 17.4.3 does imply that the reads will be viewable in a
wall-clock-sequential way, albeit informally


      Sequential consistency is a very strong guarantee that is made about
visibility and ordering in an execution of a program. Within a sequentially
consistent execution, there is a total order over all individual actions
(such as reads and writes) which is consistent with the order of the
program, and each individual action is atomic and is immediately visible to
every thread.


  (emphasis on "is immediately visible")


  On Fri, Aug 17, 2012 at 7:41 PM, Vitaly Davidovich <vitalyd at gmail.com>
wrote:

    David and you may be right in the theoretical aspect.  In practice, I
can't fathom how a JVM can do this type of analysis.  That's an issue that I
have with JMM's wording of happens-before -- it doesn't translate to
reality, it seems like.

    Sent from my phone

    On Aug 17, 2012 7:30 PM, "Yuval Shavit" <yshavit at akiban.com> wrote:

      Sure, but it could decide that the execution order is [w1, w2, w3, r].
In fact, as far as we know, the thread may have been scheduled such that
that was the clock-time ordering, too.


      On Fri, Aug 17, 2012 at 7:21 PM, Vitaly Davidovich <vitalyd at gmail.com>
wrote:

        Two volatile writes emit a store-store barrier in between, which to
me means they cannot be collapsed and must be made visible in that order (on
non-TSO this would require a h/w fence).  In other words, I don't think
compiler can remove the redundant stores as if this was a non-volatile
field, where it's a perfectly valid (and good) optimization.

        Sent from my phone

        On Aug 17, 2012 7:18 PM, "David Holmes" <davidcholmes at aapt.net.au>
wrote:

          How does it violate the JMM? There is nothing to establish that
any read has to have occurred prior to w=3. An external observer may say
"hey if we'd actually written w=1 at this point then the read would see 1"
but that is irrelevant. The program can not tell the other writes did not
occur.

          David
            -----Original Message-----
            From: Vitaly Davidovich [mailto:vitalyd at gmail.com]
            Sent: Saturday, 18 August 2012 9:12 AM
            To: dholmes at ieee.org
            Cc: Marko Topolnik; concurrency-interest at cs.oswego.edu
            Subject: Re: [concurrency-interest] Relativity of guarantees
provided by volatile


            I don't think the writes to w can be reduced to just the last
one as it would violate the JMM.  R may only see the last one due to
interleaving though. Not sure if that's what you meant.

            Sent from my phone

            On Aug 17, 2012 7:03 PM, "David Holmes"
<davidcholmes at aapt.net.au> wrote:

              Hi Marko,

              I think the "surprise" is only in the way you formulated this.
Said another
              way a write takes a finite amount of time from when the
instruction starts
              to execute to when the store is actually available for a read
to see.
              (Similarly a read takes a finite amount of time.) So depending
on those two
              times a read and write that happen "around the same time" may
appear to have
              occurred in either order. But when you program with threads
you never know
              the relative interleavings (or should never assume) so it
makes no
              difference how the program perceives the order compared to how
some external
              observer might perceive it.

              As for your optimization to "chunk" volatile writes, I don't
see a problem
              here if you are basically asking if given:

              w = 1;  // w is volatile
              w = 2;
              w = 3;

              that this could be reduced to the last write alone? I see no
reason why not.
              Without some additional coordination between a reader thread
and the writer
              thread, reading w==3 is a legitimate outcome. If you are
thinking about how
              the hardware might chunk things then that is a different
matter. We have to
              use the hardware in a way that complies with the memory
model - if the
              hardware can't comply then you can't run Java on it.

              David Holmes
              ------------

              > -----Original Message-----
              > From: concurrency-interest-bounces at cs.oswego.edu
              > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
Of Marko
              > Topolnik
              > Sent: Saturday, 18 August 2012 7:24 AM
              > To: concurrency-interest at cs.oswego.edu
              > Subject: [concurrency-interest] Relativity of guarantees
provided by
              > volatile
              >
              >
              > Consider the following synchronization order of a program
              > execution involving a total of two threads, R and W:
              >
              > - thread R begins;
              >
              > - thread R reads a volatile int sharedVar several times.
Each
              > time it reads the value 0;
              >
              > - thread R completes;
              >
              > - thread W begins;
              >
              > - thread W writes the sharedVar several times. Each time it
              > writes the value 1;
              >
              > - thread W completes.
              >
              > Now consider the wall-clock timing of the events:
              >
              > - thread R reads 0 at t = {1, 4, 7, 10};
              > - thread W writes 1 at t = {0, 3, 6, 9}.
              >
              > As far as the Java Memory Model is concerned, there is no
              > contradiction between the synchronization order and the
              > wall-clock times, as the JMM is wall-clock agnostic.
However, I
              > have yet to meet a single Java professional who wouldn't at
least
              > be very surprised to hear that the specification allows
this.
              >
              > I understand that the SMP architecture that dominates the
world
              > of computing today practically never takes these liberties
and
              > makes the volatile writes visible almost instantaneously.
This
              > may change at any time, however, especially with the advent
of
              > massively parrallel architectures that seem to be the
future. For
              > example, an optimization technique may choose to chunk many
              > volatile writes together and make them visible in a single
bulk
              > operation. This can be safely done as long as there are no
              > intervening read-y actions (targets of the synchronizes-with
              > edges as defined by JLS/JSE7 17.4.4).
              >
              > Now, my questions are:
              >
              > 1. Is there a loophole in my reasoning?
              >
              > 2. If there is no loophole, is there anything to worry
about,
              > given that practically 100% developers out there consider as
              > guaranteed something that isn't?
              >
              >
              > -Marko
              >
              >
              >
              >
              > _______________________________________________
              > Concurrency-interest mailing list
              > Concurrency-interest at cs.oswego.edu
              > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
              >

              _______________________________________________
              Concurrency-interest mailing list
              Concurrency-interest at cs.oswego.edu
              http://cs.oswego.edu/mailman/listinfo/concurrency-interest


        _______________________________________________
        Concurrency-interest mailing list
        Concurrency-interest at cs.oswego.edu
        http://cs.oswego.edu/mailman/listinfo/concurrency-interest





-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120818/7bc384a5/attachment-0001.html>

From hans.boehm at hp.com  Fri Aug 17 21:21:46 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Sat, 18 Aug 2012 01:21:46 +0000
Subject: [concurrency-interest] Relativity of guarantees provided
	by	volatile
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEDJJGAA.davidcholmes@aapt.net.au>
References: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEDJJGAA.davidcholmes@aapt.net.au>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F6197D@G4W3296.americas.hpqcorp.net>

My reading is that "subsequent" in chapter 17 of the spec refers to synchronization order, except in one case in which it refers to a hypothetical sequentially consistent memory model.

I agree that the originally described behavior is allowed.   There's another complication here that can explain this behavior (as can delayed stores).  AFAIK, the spec does not clearly require that  "wall clock time" is perfectly synchronized across threads, and implementations may, for good reason, fail to ensure that, particularly in this case.  We had this discussion in connection with C++11, and that spec does require that a specific clock is consistent with happens-before.  But even that spec, which is strict enough to raise some controversy, isn't sufficient here, since there is no happens-before relation between the threads.

Hans

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David Holmes
Sent: Friday, August 17, 2012 5:03 PM
To: Yuval Shavit; Vitaly Davidovich
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Relativity of guarantees provided by volatile

Ah I knew there was something about "immediate" in there somewhere :) So if instructions were immediate (ie they completed as soon as they started) then wall clock observations would be consistent with actual executions. But on real systems instructions are not immediate so you have to take the completion of the instruction as the point at which to make a wall clock observation.

Aside: as well as being atomic and immediate you also need to preclude two instructions from executing simultaneously :)

David (now departing to enjoy the weekend :) )
-----Original Message-----
From: Yuval Shavit [mailto:yshavit at akiban.com]
Sent: Saturday, 18 August 2012 9:49 AM
To: Vitaly Davidovich
Cc: dholmes at ieee.org; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Relativity of guarantees provided by volatile
(Resending -- I'd accidentally sent this only to Nathan)
So, Nathan, you're essentially saying that "subsequent" is defined in terms of clock time. If we take that as the definition, then I agree that it works as we'd all expect. Furthermore, I agree that that's the intuitive definition, as well as the de-facto one. But it doesn't seem to be the one explicitly defined by the JLS. (And if it is the one implicitly defined by the JLS, I there's a serious bug waiting for any distributed-node JVM whose nodes are traveling away from each other at relativistic speeds! ... though I'm no physics expert.)

That said, 17.4.3 does imply that the reads will be viewable in a wall-clock-sequential way, albeit informally

    Sequential consistency is a very strong guarantee that is made about visibility and ordering in an execution of a program. Within a sequentially consistent execution, there is a total order over all individual actions (such as reads and writes) which is consistent with the order of the program, and each individual action is atomic and is immediately visible to every thread.

(emphasis on "is immediately visible")

On Fri, Aug 17, 2012 at 7:41 PM, Vitaly Davidovich <vitalyd at gmail.com<mailto:vitalyd at gmail.com>> wrote:

David and you may be right in the theoretical aspect.  In practice, I can't fathom how a JVM can do this type of analysis.  That's an issue that I have with JMM's wording of happens-before -- it doesn't translate to reality, it seems like.

Sent from my phone
On Aug 17, 2012 7:30 PM, "Yuval Shavit" <yshavit at akiban.com<mailto:yshavit at akiban.com>> wrote:
Sure, but it could decide that the execution order is [w1, w2, w3, r]. In fact, as far as we know, the thread may have been scheduled such that that was the clock-time ordering, too.
On Fri, Aug 17, 2012 at 7:21 PM, Vitaly Davidovich <vitalyd at gmail.com<mailto:vitalyd at gmail.com>> wrote:

Two volatile writes emit a store-store barrier in between, which to me means they cannot be collapsed and must be made visible in that order (on non-TSO this would require a h/w fence).  In other words, I don't think compiler can remove the redundant stores as if this was a non-volatile field, where it's a perfectly valid (and good) optimization.

Sent from my phone
On Aug 17, 2012 7:18 PM, "David Holmes" <davidcholmes at aapt.net.au<mailto:davidcholmes at aapt.net.au>> wrote:
How does it violate the JMM? There is nothing to establish that any read has to have occurred prior to w=3. An external observer may say "hey if we'd actually written w=1 at this point then the read would see 1" but that is irrelevant. The program can not tell the other writes did not occur.

David
-----Original Message-----
From: Vitaly Davidovich [mailto:vitalyd at gmail.com<mailto:vitalyd at gmail.com>]
Sent: Saturday, 18 August 2012 9:12 AM
To: dholmes at ieee.org<mailto:dholmes at ieee.org>
Cc: Marko Topolnik; concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Relativity of guarantees provided by volatile

I don't think the writes to w can be reduced to just the last one as it would violate the JMM.  R may only see the last one due to interleaving though. Not sure if that's what you meant.

Sent from my phone
On Aug 17, 2012 7:03 PM, "David Holmes" <davidcholmes at aapt.net.au<mailto:davidcholmes at aapt.net.au>> wrote:
Hi Marko,

I think the "surprise" is only in the way you formulated this. Said another
way a write takes a finite amount of time from when the instruction starts
to execute to when the store is actually available for a read to see.
(Similarly a read takes a finite amount of time.) So depending on those two
times a read and write that happen "around the same time" may appear to have
occurred in either order. But when you program with threads you never know
the relative interleavings (or should never assume) so it makes no
difference how the program perceives the order compared to how some external
observer might perceive it.

As for your optimization to "chunk" volatile writes, I don't see a problem
here if you are basically asking if given:

w = 1;  // w is volatile
w = 2;
w = 3;

that this could be reduced to the last write alone? I see no reason why not.
Without some additional coordination between a reader thread and the writer
thread, reading w==3 is a legitimate outcome. If you are thinking about how
the hardware might chunk things then that is a different matter. We have to
use the hardware in a way that complies with the memory model - if the
hardware can't comply then you can't run Java on it.

David Holmes
------------

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu>
> [mailto:concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu>]On Behalf Of Marko
> Topolnik
> Sent: Saturday, 18 August 2012 7:24 AM
> To: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
> Subject: [concurrency-interest] Relativity of guarantees provided by
> volatile
>
>
> Consider the following synchronization order of a program
> execution involving a total of two threads, R and W:
>
> - thread R begins;
>
> - thread R reads a volatile int sharedVar several times. Each
> time it reads the value 0;
>
> - thread R completes;
>
> - thread W begins;
>
> - thread W writes the sharedVar several times. Each time it
> writes the value 1;
>
> - thread W completes.
>
> Now consider the wall-clock timing of the events:
>
> - thread R reads 0 at t = {1, 4, 7, 10};
> - thread W writes 1 at t = {0, 3, 6, 9}.
>
> As far as the Java Memory Model is concerned, there is no
> contradiction between the synchronization order and the
> wall-clock times, as the JMM is wall-clock agnostic. However, I
> have yet to meet a single Java professional who wouldn't at least
> be very surprised to hear that the specification allows this.
>
> I understand that the SMP architecture that dominates the world
> of computing today practically never takes these liberties and
> makes the volatile writes visible almost instantaneously. This
> may change at any time, however, especially with the advent of
> massively parrallel architectures that seem to be the future. For
> example, an optimization technique may choose to chunk many
> volatile writes together and make them visible in a single bulk
> operation. This can be safely done as long as there are no
> intervening read-y actions (targets of the synchronizes-with
> edges as defined by JLS/JSE7 17.4.4).
>
> Now, my questions are:
>
> 1. Is there a loophole in my reasoning?
>
> 2. If there is no loophole, is there anything to worry about,
> given that practically 100% developers out there consider as
> guaranteed something that isn't?
>
>
> -Marko
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120818/9f1c2852/attachment.html>

From zhong.j.yu at gmail.com  Fri Aug 17 21:33:35 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Fri, 17 Aug 2012 20:33:35 -0500
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
Message-ID: <CACuKZqHvzx-3r_1WqEWj7PgMesqog6c6wvGUOKpe-zxQg_gdRA@mail.gmail.com>

Consider this physical model:

Each thread is a person Tx.

There's a person V managing all variables.

To make a write, Tx sends a paper mail to V. No return mail is
required, therefore a write is very short.

To make a read, Tx sends a paper mail to V, and waits for return mail.

The synchronization order is the order the mails received by V.

This seems to be a valid JMM model.

--

Now suppose thread R is very close to V, therefor reads are also very
short. (it's easier to talk about temporal order between short
actions) Suppose thread W is very far away from V.

To realize OP's example, consider the numbers are in hours, and route
W -> V takes 48 hours.

On Monday, W writes v=1, it reaches V on Wednesday. On Tuesday R reads
v=0. So the write is after read in sync order, yet write is before
read in temporal order(even considering relativity - all persons are
on Earth)

Therefore sync order doesn't have to be consistent with temporal order.

From yshavit at akiban.com  Fri Aug 17 21:39:50 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Fri, 17 Aug 2012 21:39:50 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F6197D@G4W3296.americas.hpqcorp.net>
References: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEDJJGAA.davidcholmes@aapt.net.au>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6197D@G4W3296.americas.hpqcorp.net>
Message-ID: <-5565563096132427032@unknownmsgid>

I was thinking about this on my way home, and I think Marko's initial
proposition is correct -- but that we shouldn't concern ourselves with it.

I still think it comes down to the meaning of "subsequent," but I think
wall-clock is not a good definition. In a multi-core machine, it's
conceivable that two actions would happen close enough that it's impossible
to tell which one happened first (by wall clock time). Forcing a consensus
about which came first would be expensive, and it would probably be
prohibitive on a many-core machine -- let alone a multi-node JVM (I was
only partially joking about that before).

So, what happens if we have some loose definition of "subsequent," probably
with transitivity and perhaps some other basic properties? If we do that,
then Marko's initial proposition holds. For instance, the JVM would be
allowed to have a while(someVolatileBool) thread go on forever, having been
determined to be subsequent all other actions.

But there are lots of things which the JVM is allowed to take its time on,
but shouldn't. I haven't read anything in the JLS that requires "int i = 1"
to complete before the heat death of the universe, and yet we would surely
file a bug if it were not nearly instantaneous.

I would argue that subsequent-ness is the same. There's nothing to prevent
the JLS from delaying actions in some horrid way (w.r.t. "subsequent" and
thus visibility), but we would surely file a bug if it were not extremely
quick on a single-node machine, and appropriately quick on a distributed
JVM.

On Aug 17, 2012, at 9:24 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:

  My reading is that ?subsequent? in chapter 17 of the spec refers to
synchronization order, except in one case in which it refers to a
hypothetical sequentially consistent memory model.



I agree that the originally described behavior is allowed.   There?s
another complication here that can explain this behavior (as can delayed
stores).  AFAIK, the spec does not clearly require that  ?wall clock time?
is perfectly synchronized across threads, and implementations may, for good
reason, fail to ensure that, particularly in this case.  We had this
discussion in connection with C++11, and that spec does require that a
specific clock is consistent with happens-before.  But even that spec,
which is strict enough to raise some controversy, isn?t sufficient here,
since there is no happens-before relation between the threads.



Hans



*From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *David Holmes
*Sent:* Friday, August 17, 2012 5:03 PM
*To:* Yuval Shavit; Vitaly Davidovich
*Cc:* concurrency-interest at cs.oswego.edu
*Subject:* Re: [concurrency-interest] Relativity of guarantees provided by
volatile



Ah I knew there was something about "immediate" in there somewhere :) So if
instructions were immediate (ie they completed as soon as they started)
then wall clock observations would be consistent with actual executions.
But on real systems instructions are not immediate so you have to take the
completion of the instruction as the point at which to make a wall clock
observation.



Aside: as well as being atomic and immediate you also need to preclude two
instructions from executing simultaneously :)



David (now departing to enjoy the weekend :) )

-----Original Message-----
*From:* Yuval Shavit [mailto:yshavit at akiban.com]
*Sent:* Saturday, 18 August 2012 9:49 AM
*To:* Vitaly Davidovich
*Cc:* dholmes at ieee.org; concurrency-interest at cs.oswego.edu
*Subject:* Re: [concurrency-interest] Relativity of guarantees provided by
volatile

(Resending -- I'd accidentally sent this only to Nathan)

So, Nathan, you're essentially saying that "subsequent" is defined in terms
of clock time. If we take that as the definition, then I agree that it
works as we'd all expect. Furthermore, I agree that that's the intuitive
definition, as well as the de-facto one. But it doesn't seem to be the one
explicitly defined by the JLS. (And if it is the one implicitly defined by
the JLS, I there's a serious bug waiting for any distributed-node JVM whose
nodes are traveling away from each other at relativistic speeds! ... though
I'm no physics expert.)



That said, 17.4.3 does imply that the reads will be viewable in a
wall-clock-sequential way, albeit informally



    Sequential consistency is a very strong guarantee that is made about
visibility and ordering in an execution of a program. Within a sequentially
consistent execution, there is a total order over all individual actions
(such as reads and writes) which is consistent with the order of the
program, and each individual action is atomic and is immediately visible to
every thread.



(emphasis on "is immediately visible")



On Fri, Aug 17, 2012 at 7:41 PM, Vitaly Davidovich <vitalyd at gmail.com>
wrote:

David and you may be right in the theoretical aspect.  In practice, I can't
fathom how a JVM can do this type of analysis.  That's an issue that I have
with JMM's wording of happens-before -- it doesn't translate to reality, it
seems like.

Sent from my phone

On Aug 17, 2012 7:30 PM, "Yuval Shavit" <yshavit at akiban.com> wrote:

Sure, but it could decide that the execution order is [w1, w2, w3, r]. In
fact, as far as we know, the thread may have been scheduled such that that
was the clock-time ordering, too.

On Fri, Aug 17, 2012 at 7:21 PM, Vitaly Davidovich <vitalyd at gmail.com>
wrote:

Two volatile writes emit a store-store barrier in between, which to me
means they cannot be collapsed and must be made visible in that order (on
non-TSO this would require a h/w fence).  In other words, I don't think
compiler can remove the redundant stores as if this was a non-volatile
field, where it's a perfectly valid (and good) optimization.

Sent from my phone

On Aug 17, 2012 7:18 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:

How does it violate the JMM? There is nothing to establish that any read
has to have occurred prior to w=3. An external observer may say "hey if
we'd actually written w=1 at this point then the read would see 1" but that
is irrelevant. The program can not tell the other writes did not occur.



David

-----Original Message-----
*From:* Vitaly Davidovich [mailto:vitalyd at gmail.com]
*Sent:* Saturday, 18 August 2012 9:12 AM
*To:* dholmes at ieee.org
*Cc:* Marko Topolnik; concurrency-interest at cs.oswego.edu
*Subject:* Re: [concurrency-interest] Relativity of guarantees provided by
volatile

I don't think the writes to w can be reduced to just the last one as it
would violate the JMM.  R may only see the last one due to interleaving
though. Not sure if that's what you meant.

Sent from my phone

On Aug 17, 2012 7:03 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:

Hi Marko,

I think the "surprise" is only in the way you formulated this. Said another
way a write takes a finite amount of time from when the instruction starts
to execute to when the store is actually available for a read to see.
(Similarly a read takes a finite amount of time.) So depending on those two
times a read and write that happen "around the same time" may appear to have
occurred in either order. But when you program with threads you never know
the relative interleavings (or should never assume) so it makes no
difference how the program perceives the order compared to how some external
observer might perceive it.

As for your optimization to "chunk" volatile writes, I don't see a problem
here if you are basically asking if given:

w = 1;  // w is volatile
w = 2;
w = 3;

that this could be reduced to the last write alone? I see no reason why not.
Without some additional coordination between a reader thread and the writer
thread, reading w==3 is a legitimate outcome. If you are thinking about how
the hardware might chunk things then that is a different matter. We have to
use the hardware in a way that complies with the memory model - if the
hardware can't comply then you can't run Java on it.

David Holmes
------------

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
> Topolnik
> Sent: Saturday, 18 August 2012 7:24 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Relativity of guarantees provided by
> volatile
>
>
> Consider the following synchronization order of a program
> execution involving a total of two threads, R and W:
>
> - thread R begins;
>
> - thread R reads a volatile int sharedVar several times. Each
> time it reads the value 0;
>
> - thread R completes;
>
> - thread W begins;
>
> - thread W writes the sharedVar several times. Each time it
> writes the value 1;
>
> - thread W completes.
>
> Now consider the wall-clock timing of the events:
>
> - thread R reads 0 at t = {1, 4, 7, 10};
> - thread W writes 1 at t = {0, 3, 6, 9}.
>
> As far as the Java Memory Model is concerned, there is no
> contradiction between the synchronization order and the
> wall-clock times, as the JMM is wall-clock agnostic. However, I
> have yet to meet a single Java professional who wouldn't at least
> be very surprised to hear that the specification allows this.
>
> I understand that the SMP architecture that dominates the world
> of computing today practically never takes these liberties and
> makes the volatile writes visible almost instantaneously. This
> may change at any time, however, especially with the advent of
> massively parrallel architectures that seem to be the future. For
> example, an optimization technique may choose to chunk many
> volatile writes together and make them visible in a single bulk
> operation. This can be safely done as long as there are no
> intervening read-y actions (targets of the synchronizes-with
> edges as defined by JLS/JSE7 17.4.4).
>
> Now, my questions are:
>
> 1. Is there a loophole in my reasoning?
>
> 2. If there is no loophole, is there anything to worry about,
> given that practically 100% developers out there consider as
> guaranteed something that isn't?
>
>
> -Marko
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120817/b289b64f/attachment-0001.html>

From zhong.j.yu at gmail.com  Fri Aug 17 21:42:54 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Fri, 17 Aug 2012 20:42:54 -0500
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CACuKZqHvzx-3r_1WqEWj7PgMesqog6c6wvGUOKpe-zxQg_gdRA@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<CACuKZqHvzx-3r_1WqEWj7PgMesqog6c6wvGUOKpe-zxQg_gdRA@mail.gmail.com>
Message-ID: <CACuKZqHfs_zeX0uR8ODJrysPZCcpx4eeHdVu2k0M-FjOjcn79w@mail.gmail.com>

On Fri, Aug 17, 2012 at 8:33 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
> Consider this physical model:
>
> Each thread is a person Tx.
>
> There's a person V managing all variables.
>
> To make a write, Tx sends a paper mail to V. No return mail is
> required, therefore a write is very short.
>
> To make a read, Tx sends a paper mail to V, and waits for return mail.
>
> The synchronization order is the order the mails received by V.
>
> This seems to be a valid JMM model.
>
> --
>
> Now suppose thread R is very close to V, therefor reads are also very
> short. (it's easier to talk about temporal order between short
> actions) Suppose thread W is very far away from V.
>
> To realize OP's example, consider the numbers are in hours, and route
> W -> V takes 48 hours.
>
> On Monday, W writes v=1, it reaches V on Wednesday. On Tuesday R reads
> v=0. So the write is after read in sync order, yet write is before
> read in temporal order(even considering relativity - all persons are
> on Earth)
>
> Therefore sync order doesn't have to be consistent with temporal order.

On the other hand, if w is before r in sync order, there's a causal
relationship, it seems necessary that, the beginning of w is before
the end of r in temporal order. So there may be some constraints
between the two orders.

From davidcholmes at aapt.net.au  Fri Aug 17 21:55:03 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 18 Aug 2012 11:55:03 +1000
Subject: [concurrency-interest] Relativity of guarantees provided
	byvolatile
In-Reply-To: <CACuKZqHvzx-3r_1WqEWj7PgMesqog6c6wvGUOKpe-zxQg_gdRA@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEDJJGAA.davidcholmes@aapt.net.au>

As I keep saying, for this to "make sense" you have to make temporal
measurements when an action completes.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Zhong Yu
> Sent: Saturday, 18 August 2012 11:34 AM
> To: Yuval Shavit
> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> Subject: Re: [concurrency-interest] Relativity of guarantees provided
> byvolatile
>
>
> Consider this physical model:
>
> Each thread is a person Tx.
>
> There's a person V managing all variables.
>
> To make a write, Tx sends a paper mail to V. No return mail is
> required, therefore a write is very short.
>
> To make a read, Tx sends a paper mail to V, and waits for return mail.
>
> The synchronization order is the order the mails received by V.
>
> This seems to be a valid JMM model.
>
> --
>
> Now suppose thread R is very close to V, therefor reads are also very
> short. (it's easier to talk about temporal order between short
> actions) Suppose thread W is very far away from V.
>
> To realize OP's example, consider the numbers are in hours, and route
> W -> V takes 48 hours.
>
> On Monday, W writes v=1, it reaches V on Wednesday. On Tuesday R reads
> v=0. So the write is after read in sync order, yet write is before
> read in temporal order(even considering relativity - all persons are
> on Earth)
>
> Therefore sync order doesn't have to be consistent with temporal order.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From zhong.j.yu at gmail.com  Fri Aug 17 22:20:31 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Fri, 17 Aug 2012 21:20:31 -0500
Subject: [concurrency-interest] Relativity of guarantees provided
	byvolatile
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEDJJGAA.davidcholmes@aapt.net.au>
References: <CACuKZqHvzx-3r_1WqEWj7PgMesqog6c6wvGUOKpe-zxQg_gdRA@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCOEDJJGAA.davidcholmes@aapt.net.au>
Message-ID: <CACuKZqFkPSbLACUK+WA=yoq3ChYC_QHZD3qBdJDaCpEE7LcyLQ@mail.gmail.com>

In the model, a write completes as soon as the mail is sent, the same
thread can immediately make another write. A read completes when the
return mail is received; the reading thread is suspended during the
wait.

The example is designed so that reads are short too, so we can treat
actions as points in time, to order them easily.

On Fri, Aug 17, 2012 at 8:55 PM, David Holmes <davidcholmes at aapt.net.au> wrote:
> As I keep saying, for this to "make sense" you have to make temporal
> measurements when an action completes.
>
> David
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Zhong Yu
>> Sent: Saturday, 18 August 2012 11:34 AM
>> To: Yuval Shavit
>> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
>> Subject: Re: [concurrency-interest] Relativity of guarantees provided
>> byvolatile
>>
>>
>> Consider this physical model:
>>
>> Each thread is a person Tx.
>>
>> There's a person V managing all variables.
>>
>> To make a write, Tx sends a paper mail to V. No return mail is
>> required, therefore a write is very short.
>>
>> To make a read, Tx sends a paper mail to V, and waits for return mail.
>>
>> The synchronization order is the order the mails received by V.
>>
>> This seems to be a valid JMM model.
>>
>> --
>>
>> Now suppose thread R is very close to V, therefor reads are also very
>> short. (it's easier to talk about temporal order between short
>> actions) Suppose thread W is very far away from V.
>>
>> To realize OP's example, consider the numbers are in hours, and route
>> W -> V takes 48 hours.
>>
>> On Monday, W writes v=1, it reaches V on Wednesday. On Tuesday R reads
>> v=0. So the write is after read in sync order, yet write is before
>> read in temporal order(even considering relativity - all persons are
>> on Earth)
>>
>> Therefore sync order doesn't have to be consistent with temporal order.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>

From davidcholmes at aapt.net.au  Fri Aug 17 22:29:39 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 18 Aug 2012 12:29:39 +1000
Subject: [concurrency-interest] Relativity of guarantees provided
	byvolatile
In-Reply-To: <CACuKZqFkPSbLACUK+WA=yoq3ChYC_QHZD3qBdJDaCpEE7LcyLQ@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEDKJGAA.davidcholmes@aapt.net.au>

Well that's your choice, but it makes more sense temporally to consider
completetion when the actual result of the action is available, in my
opinion.

David

> -----Original Message-----
> From: Zhong Yu [mailto:zhong.j.yu at gmail.com]
> Sent: Saturday, 18 August 2012 12:21 PM
> To: dholmes at ieee.org
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Relativity of guarantees provided
> byvolatile
>
>
> In the model, a write completes as soon as the mail is sent, the same
> thread can immediately make another write. A read completes when the
> return mail is received; the reading thread is suspended during the
> wait.
>
> The example is designed so that reads are short too, so we can treat
> actions as points in time, to order them easily.
>
> On Fri, Aug 17, 2012 at 8:55 PM, David Holmes
> <davidcholmes at aapt.net.au> wrote:
> > As I keep saying, for this to "make sense" you have to make temporal
> > measurements when an action completes.
> >
> > David
> >
> >> -----Original Message-----
> >> From: concurrency-interest-bounces at cs.oswego.edu
> >> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
> Of Zhong Yu
> >> Sent: Saturday, 18 August 2012 11:34 AM
> >> To: Yuval Shavit
> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> >> Subject: Re: [concurrency-interest] Relativity of guarantees provided
> >> byvolatile
> >>
> >>
> >> Consider this physical model:
> >>
> >> Each thread is a person Tx.
> >>
> >> There's a person V managing all variables.
> >>
> >> To make a write, Tx sends a paper mail to V. No return mail is
> >> required, therefore a write is very short.
> >>
> >> To make a read, Tx sends a paper mail to V, and waits for return mail.
> >>
> >> The synchronization order is the order the mails received by V.
> >>
> >> This seems to be a valid JMM model.
> >>
> >> --
> >>
> >> Now suppose thread R is very close to V, therefor reads are also very
> >> short. (it's easier to talk about temporal order between short
> >> actions) Suppose thread W is very far away from V.
> >>
> >> To realize OP's example, consider the numbers are in hours, and route
> >> W -> V takes 48 hours.
> >>
> >> On Monday, W writes v=1, it reaches V on Wednesday. On Tuesday R reads
> >> v=0. So the write is after read in sync order, yet write is before
> >> read in temporal order(even considering relativity - all persons are
> >> on Earth)
> >>
> >> Therefore sync order doesn't have to be consistent with temporal order.
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >
>


From zhong.j.yu at gmail.com  Sat Aug 18 00:41:53 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Fri, 17 Aug 2012 23:41:53 -0500
Subject: [concurrency-interest] Relativity of guarantees provided
	byvolatile
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEDKJGAA.davidcholmes@aapt.net.au>
References: <CACuKZqFkPSbLACUK+WA=yoq3ChYC_QHZD3qBdJDaCpEE7LcyLQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEDKJGAA.davidcholmes@aapt.net.au>
Message-ID: <CACuKZqF6mzWp2iCwZOo9eTa3LX8aV3iTYY4s-6Nof2bHg0MuyQ@mail.gmail.com>

On Fri, Aug 17, 2012 at 9:29 PM, David Holmes <davidcholmes at aapt.net.au> wrote:
> Well that's your choice, but it makes more sense temporally to consider
> completetion when the actual result of the action is available, in my
> opinion.

We can consider another model:

A write must wait for confirmation mail from V.

V receives a write Wi, updates its state to Vi, sends mails containing
Vi to all threads. The mail is also the confirmation mail to the
writer.

Threads locally cache the last Vi it receives. A read checks the
locally cached Vi only, therefore reads are very short.

Sync order can be defined mainly based on the 'i's of actions. This
also appears to be a valid JMM model.

Then we move V close to W, far away from R. On day#1, W writes v=1 to
V. That change reaches R on day#3. On day#2 R reads v=0. Once again,
we have read<write in sync order, yet write<read in temporal order.



>
> David
>
>> -----Original Message-----
>> From: Zhong Yu [mailto:zhong.j.yu at gmail.com]
>> Sent: Saturday, 18 August 2012 12:21 PM
>> To: dholmes at ieee.org
>> Cc: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Relativity of guarantees provided
>> byvolatile
>>
>>
>> In the model, a write completes as soon as the mail is sent, the same
>> thread can immediately make another write. A read completes when the
>> return mail is received; the reading thread is suspended during the
>> wait.
>>
>> The example is designed so that reads are short too, so we can treat
>> actions as points in time, to order them easily.
>>
>> On Fri, Aug 17, 2012 at 8:55 PM, David Holmes
>> <davidcholmes at aapt.net.au> wrote:
>> > As I keep saying, for this to "make sense" you have to make temporal
>> > measurements when an action completes.
>> >
>> > David
>> >
>> >> -----Original Message-----
>> >> From: concurrency-interest-bounces at cs.oswego.edu
>> >> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
>> Of Zhong Yu
>> >> Sent: Saturday, 18 August 2012 11:34 AM
>> >> To: Yuval Shavit
>> >> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
>> >> Subject: Re: [concurrency-interest] Relativity of guarantees provided
>> >> byvolatile
>> >>
>> >>
>> >> Consider this physical model:
>> >>
>> >> Each thread is a person Tx.
>> >>
>> >> There's a person V managing all variables.
>> >>
>> >> To make a write, Tx sends a paper mail to V. No return mail is
>> >> required, therefore a write is very short.
>> >>
>> >> To make a read, Tx sends a paper mail to V, and waits for return mail.
>> >>
>> >> The synchronization order is the order the mails received by V.
>> >>
>> >> This seems to be a valid JMM model.
>> >>
>> >> --
>> >>
>> >> Now suppose thread R is very close to V, therefor reads are also very
>> >> short. (it's easier to talk about temporal order between short
>> >> actions) Suppose thread W is very far away from V.
>> >>
>> >> To realize OP's example, consider the numbers are in hours, and route
>> >> W -> V takes 48 hours.
>> >>
>> >> On Monday, W writes v=1, it reaches V on Wednesday. On Tuesday R reads
>> >> v=0. So the write is after read in sync order, yet write is before
>> >> read in temporal order(even considering relativity - all persons are
>> >> on Earth)
>> >>
>> >> Therefore sync order doesn't have to be consistent with temporal order.
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>
>> >
>>
>

From yshavit at akiban.com  Sat Aug 18 01:00:23 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Sat, 18 Aug 2012 01:00:23 -0400
Subject: [concurrency-interest] Relativity of guarantees provided
	byvolatile
In-Reply-To: <CACuKZqF6mzWp2iCwZOo9eTa3LX8aV3iTYY4s-6Nof2bHg0MuyQ@mail.gmail.com>
References: <CACuKZqFkPSbLACUK+WA=yoq3ChYC_QHZD3qBdJDaCpEE7LcyLQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEDKJGAA.davidcholmes@aapt.net.au>
	<CACuKZqF6mzWp2iCwZOo9eTa3LX8aV3iTYY4s-6Nof2bHg0MuyQ@mail.gmail.com>
Message-ID: <-5933359067440987844@unknownmsgid>

On Aug 18, 2012, at 12:43 AM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> On Fri, Aug 17, 2012 at 9:29 PM, David Holmes <davidcholmes at aapt.net.au> wrote:
>> Well that's your choice, but it makes more sense temporally to consider
>> completetion when the actual result of the action is available, in my
>> opinion.
>
> We can consider another model:
>
> A write must wait for confirmation mail from V.
>
> V receives a write Wi, updates its state to Vi, sends mails containing
> Vi to all threads. The mail is also the confirmation mail to the
> writer.
>
> Threads locally cache the last Vi it receives. A read checks the
> locally cached Vi only, therefore reads are very short.
>
> Sync order can be defined mainly based on the 'i's of actions. This
> also appears to be a valid JMM model.
>
> Then we move V close to W, far away from R. On day#1, W writes v=1 to
> V. That change reaches R on day#3. On day#2 R reads v=0. Once again,
> we have read<write in sync order, yet write<read in temporal order.

Except that in this metaphor, if v is volatile, wouldn't R's read of v
on day 2 require sending V a note requesting v's value -- at which
point V know about the letter from W on day 1?

This model has V being the sole timekeeper. An action A' is subsequent
to another action A iff V processes A before A'. V seems like quite
the bottleneck here. In particular, two sets of actions, each with HB
relations within them but with no HBs between them, will both have to
synchronize on the same V.


>
>
>
>>
>> David
>>
>>> -----Original Message-----
>>> From: Zhong Yu [mailto:zhong.j.yu at gmail.com]
>>> Sent: Saturday, 18 August 2012 12:21 PM
>>> To: dholmes at ieee.org
>>> Cc: concurrency-interest at cs.oswego.edu
>>> Subject: Re: [concurrency-interest] Relativity of guarantees provided
>>> byvolatile
>>>
>>>
>>> In the model, a write completes as soon as the mail is sent, the same
>>> thread can immediately make another write. A read completes when the
>>> return mail is received; the reading thread is suspended during the
>>> wait.
>>>
>>> The example is designed so that reads are short too, so we can treat
>>> actions as points in time, to order them easily.
>>>
>>> On Fri, Aug 17, 2012 at 8:55 PM, David Holmes
>>> <davidcholmes at aapt.net.au> wrote:
>>>> As I keep saying, for this to "make sense" you have to make temporal
>>>> measurements when an action completes.
>>>>
>>>> David
>>>>
>>>>> -----Original Message-----
>>>>> From: concurrency-interest-bounces at cs.oswego.edu
>>>>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
>>> Of Zhong Yu
>>>>> Sent: Saturday, 18 August 2012 11:34 AM
>>>>> To: Yuval Shavit
>>>>> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
>>>>> Subject: Re: [concurrency-interest] Relativity of guarantees provided
>>>>> byvolatile
>>>>>
>>>>>
>>>>> Consider this physical model:
>>>>>
>>>>> Each thread is a person Tx.
>>>>>
>>>>> There's a person V managing all variables.
>>>>>
>>>>> To make a write, Tx sends a paper mail to V. No return mail is
>>>>> required, therefore a write is very short.
>>>>>
>>>>> To make a read, Tx sends a paper mail to V, and waits for return mail.
>>>>>
>>>>> The synchronization order is the order the mails received by V.
>>>>>
>>>>> This seems to be a valid JMM model.
>>>>>
>>>>> --
>>>>>
>>>>> Now suppose thread R is very close to V, therefor reads are also very
>>>>> short. (it's easier to talk about temporal order between short
>>>>> actions) Suppose thread W is very far away from V.
>>>>>
>>>>> To realize OP's example, consider the numbers are in hours, and route
>>>>> W -> V takes 48 hours.
>>>>>
>>>>> On Monday, W writes v=1, it reaches V on Wednesday. On Tuesday R reads
>>>>> v=0. So the write is after read in sync order, yet write is before
>>>>> read in temporal order(even considering relativity - all persons are
>>>>> on Earth)
>>>>>
>>>>> Therefore sync order doesn't have to be consistent with temporal order.
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From mtopolnik at inge-mark.hr  Sat Aug 18 03:35:12 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Sat, 18 Aug 2012 09:35:12 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <-5565563096132427032@unknownmsgid>
References: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEDJJGAA.davidcholmes@aapt.net.au>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6197D@G4W3296.americas.hpqcorp.net>
	<-5565563096132427032@unknownmsgid>
Message-ID: <D313DDEA-5670-4082-89FC-1D905B2280A0@inge-mark.hr>

In this e-mail I'm chunking my responses to several people due to the timezone differences... actually an excellent example to demonstrate my point.

I claim to have woken up ten minutes ago and read all the replies in this thread. I immediately started writing up my answer and will soon send it.

I could also have been following the thread through the night, writing up replies to several people, but in the end decided to chunk them together in a single post. Nobody can prove it, though.

In the end, all your posts happen-before this reply, but in the wall-clock sense parts of my reply may have been written 4 hours ago. Perhaps I just delayed its visibility to you until now. 


Nathan, the JLS is very careful to define what it means by "subsequent", for example 17.4.4: "where 'subsequent' is defined according to the synchronization order". Basically, if you take any real execution, note the wall-clock ordering of actions, and deduce the synchronization ordering from it, you can hold that sync order fixed and construct executions with wall-clock times shifted any way you like and the JLS will not give you a frown. Even the physical logic of cause-precedes-effect can be broken, the JLS won't care as long as there is a single, consistent synchronization order to it all.

Vitaly, a JVM could easily make sure that chunking is valid at least in the simple case where it can prove there's a section of code that makes a sequence of write-y actions with no intervening read-y action. I define write-y and read-y as the origin, respectively target, of a synchronizes-with edge as defined by the JLS. Of course, if you imagine a very specific hardware architecture, this may turn out not to be practical or lead to any performance advantages. But this discussion is not as specific as that.

Yuval, the existing semantics of volatile are very useful as they are, and when you add the informal promise of best effort towards timeliness, it's all you can realistically demand from an implementation. However, what is troubling is the belief of practically every developer out there that there's a hard realtime GUARANTEE of the instantaneous visibility of volatile writes.  The architectures of today prove them right, but if that changes, for all we know many existing programs may start to break. See by analogy what happened when early Java developers were assuming guarantees of in-order observance of inter-thread actions, where they were suddenly proven wrong by the next-generation, aggressively optimized JVMs. In fact, a great many devs even today assume such guarantees and keep writing faulty code.

For reference, you can also have a look at my answer on StackOverflow containing several complete Java examples that help make this discussion more concrete:

http://stackoverflow.com/a/11765634/1103872


-Marko


On 18. kol. 2012., at 03:39, Yuval Shavit wrote:

> I was thinking about this on my way home, and I think Marko's initial proposition is correct -- but that we shouldn't concern ourselves with it.
> 
> I still think it comes down to the meaning of "subsequent," but I think wall-clock is not a good definition. In a multi-core machine, it's conceivable that two actions would happen close enough that it's impossible to tell which one happened first (by wall clock time). Forcing a consensus about which came first would be expensive, and it would probably be prohibitive on a many-core machine -- let alone a multi-node JVM (I was only partially joking about that before).
> 
> So, what happens if we have some loose definition of "subsequent," probably with transitivity and perhaps some other basic properties? If we do that, then Marko's initial proposition holds. For instance, the JVM would be allowed to have a while(someVolatileBool) thread go on forever, having been determined to be subsequent all other actions.
> 
> But there are lots of things which the JVM is allowed to take its time on, but shouldn't. I haven't read anything in the JLS that requires "int i = 1" to complete before the heat death of the universe, and yet we would surely file a bug if it were not nearly instantaneous.
> 
> I would argue that subsequent-ness is the same. There's nothing to prevent the JLS from delaying actions in some horrid way (w.r.t. "subsequent" and thus visibility), but we would surely file a bug if it were not extremely quick on a single-node machine, and appropriately quick on a distributed JVM.
> 
> On Aug 17, 2012, at 9:24 PM, "Boehm, Hans" <hans.boehm at hp.com> wrote:
> 
>> My reading is that ?subsequent? in chapter 17 of the spec refers to synchronization order, except in one case in which it refers to a hypothetical sequentially consistent memory model.
>>  
>> I agree that the originally described behavior is allowed.   There?s another complication here that can explain this behavior (as can delayed stores).  AFAIK, the spec does not clearly require that  ?wall clock time? is perfectly synchronized across threads, and implementations may, for good reason, fail to ensure that, particularly in this case.  We had this discussion in connection with C++11, and that spec does require that a specific clock is consistent with happens-before.  But even that spec, which is strict enough to raise some controversy, isn?t sufficient here, since there is no happens-before relation between the threads.
>>  
>> Hans
>>  
>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David Holmes
>> Sent: Friday, August 17, 2012 5:03 PM
>> To: Yuval Shavit; Vitaly Davidovich
>> Cc: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Relativity of guarantees provided by volatile
>>  
>> Ah I knew there was something about "immediate" in there somewhere :) So if instructions were immediate (ie they completed as soon as they started) then wall clock observations would be consistent with actual executions. But on real systems instructions are not immediate so you have to take the completion of the instruction as the point at which to make a wall clock observation.
>>  
>> Aside: as well as being atomic and immediate you also need to preclude two instructions from executing simultaneously :)
>>  
>> David (now departing to enjoy the weekend :) )
>> -----Original Message-----
>> From: Yuval Shavit [mailto:yshavit at akiban.com]
>> Sent: Saturday, 18 August 2012 9:49 AM
>> To: Vitaly Davidovich
>> Cc: dholmes at ieee.org; concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Relativity of guarantees provided by volatile
>> 
>> (Resending -- I'd accidentally sent this only to Nathan)
>> 
>> So, Nathan, you're essentially saying that "subsequent" is defined in terms of clock time. If we take that as the definition, then I agree that it works as we'd all expect. Furthermore, I agree that that's the intuitive definition, as well as the de-facto one. But it doesn't seem to be the one explicitly defined by the JLS. (And if it is the one implicitly defined by the JLS, I there's a serious bug waiting for any distributed-node JVM whose nodes are traveling away from each other at relativistic speeds! ... though I'm no physics expert.)
>>  
>> That said, 17.4.3 does imply that the reads will be viewable in a wall-clock-sequential way, albeit informally
>>  
>>     Sequential consistency is a very strong guarantee that is made about visibility and ordering in an execution of a program. Within a sequentially consistent execution, there is a total order over all individual actions (such as reads and writes) which is consistent with the order of the program, and each individual action is atomic and is immediately visible to every thread.
>>  
>> (emphasis on "is immediately visible")
>>  
>> On Fri, Aug 17, 2012 at 7:41 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>> David and you may be right in the theoretical aspect.  In practice, I can't fathom how a JVM can do this type of analysis.  That's an issue that I have with JMM's wording of happens-before -- it doesn't translate to reality, it seems like.
>> 
>> Sent from my phone
>> 
>> On Aug 17, 2012 7:30 PM, "Yuval Shavit" <yshavit at akiban.com> wrote:
>> Sure, but it could decide that the execution order is [w1, w2, w3, r]. In fact, as far as we know, the thread may have been scheduled such that that was the clock-time ordering, too.
>> 
>> On Fri, Aug 17, 2012 at 7:21 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>> Two volatile writes emit a store-store barrier in between, which to me means they cannot be collapsed and must be made visible in that order (on non-TSO this would require a h/w fence).  In other words, I don't think compiler can remove the redundant stores as if this was a non-volatile field, where it's a perfectly valid (and good) optimization.
>> 
>> Sent from my phone
>> 
>> On Aug 17, 2012 7:18 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>> How does it violate the JMM? There is nothing to establish that any read has to have occurred prior to w=3. An external observer may say "hey if we'd actually written w=1 at this point then the read would see 1" but that is irrelevant. The program can not tell the other writes did not occur.
>>  
>> David
>> -----Original Message-----
>> From: Vitaly Davidovich [mailto:vitalyd at gmail.com]
>> Sent: Saturday, 18 August 2012 9:12 AM
>> To: dholmes at ieee.org
>> Cc: Marko Topolnik; concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Relativity of guarantees provided by volatile
>> 
>> I don't think the writes to w can be reduced to just the last one as it would violate the JMM.  R may only see the last one due to interleaving though. Not sure if that's what you meant.
>> 
>> Sent from my phone
>> 
>> On Aug 17, 2012 7:03 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>> Hi Marko,
>> 
>> I think the "surprise" is only in the way you formulated this. Said another
>> way a write takes a finite amount of time from when the instruction starts
>> to execute to when the store is actually available for a read to see.
>> (Similarly a read takes a finite amount of time.) So depending on those two
>> times a read and write that happen "around the same time" may appear to have
>> occurred in either order. But when you program with threads you never know
>> the relative interleavings (or should never assume) so it makes no
>> difference how the program perceives the order compared to how some external
>> observer might perceive it.
>> 
>> As for your optimization to "chunk" volatile writes, I don't see a problem
>> here if you are basically asking if given:
>> 
>> w = 1;  // w is volatile
>> w = 2;
>> w = 3;
>> 
>> that this could be reduced to the last write alone? I see no reason why not.
>> Without some additional coordination between a reader thread and the writer
>> thread, reading w==3 is a legitimate outcome. If you are thinking about how
>> the hardware might chunk things then that is a different matter. We have to
>> use the hardware in a way that complies with the memory model - if the
>> hardware can't comply then you can't run Java on it.
>> 
>> David Holmes
>> ------------
>> 
>> > -----Original Message-----
>> > From: concurrency-interest-bounces at cs.oswego.edu
>> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
>> > Topolnik
>> > Sent: Saturday, 18 August 2012 7:24 AM
>> > To: concurrency-interest at cs.oswego.edu
>> > Subject: [concurrency-interest] Relativity of guarantees provided by
>> > volatile
>> >
>> >
>> > Consider the following synchronization order of a program
>> > execution involving a total of two threads, R and W:
>> >
>> > - thread R begins;
>> >
>> > - thread R reads a volatile int sharedVar several times. Each
>> > time it reads the value 0;
>> >
>> > - thread R completes;
>> >
>> > - thread W begins;
>> >
>> > - thread W writes the sharedVar several times. Each time it
>> > writes the value 1;
>> >
>> > - thread W completes.
>> >
>> > Now consider the wall-clock timing of the events:
>> >
>> > - thread R reads 0 at t = {1, 4, 7, 10};
>> > - thread W writes 1 at t = {0, 3, 6, 9}.
>> >
>> > As far as the Java Memory Model is concerned, there is no
>> > contradiction between the synchronization order and the
>> > wall-clock times, as the JMM is wall-clock agnostic. However, I
>> > have yet to meet a single Java professional who wouldn't at least
>> > be very surprised to hear that the specification allows this.
>> >
>> > I understand that the SMP architecture that dominates the world
>> > of computing today practically never takes these liberties and
>> > makes the volatile writes visible almost instantaneously. This
>> > may change at any time, however, especially with the advent of
>> > massively parrallel architectures that seem to be the future. For
>> > example, an optimization technique may choose to chunk many
>> > volatile writes together and make them visible in a single bulk
>> > operation. This can be safely done as long as there are no
>> > intervening read-y actions (targets of the synchronizes-with
>> > edges as defined by JLS/JSE7 17.4.4).
>> >
>> > Now, my questions are:
>> >
>> > 1. Is there a loophole in my reasoning?
>> >
>> > 2. If there is no loophole, is there anything to worry about,
>> > given that practically 100% developers out there consider as
>> > guaranteed something that isn't?
>> >
>> >
>> > -Marko
>> >
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>>  
>>  
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From yshavit at akiban.com  Sat Aug 18 04:24:12 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Sat, 18 Aug 2012 04:24:12 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <D313DDEA-5670-4082-89FC-1D905B2280A0@inge-mark.hr>
References: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEDJJGAA.davidcholmes@aapt.net.au>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6197D@G4W3296.americas.hpqcorp.net>
	<-5565563096132427032@unknownmsgid>
	<D313DDEA-5670-4082-89FC-1D905B2280A0@inge-mark.hr>
Message-ID: <CAC2Zdp1Gqb_nO3qKtgQkMr78aJSbRbL-Y6w4Dbst2vmaH5_4Nw@mail.gmail.com>

On Sat, Aug 18, 2012 at 3:35 AM, Marko Topolnik <mtopolnik at inge-mark.hr>wrote:

> However, what is troubling is the belief of practically every developer
> out there that there's a hard realtime GUARANTEE of the instantaneous
> visibility of volatile writes.


Do they? I certainly believe that the read is going to see the write very
quickly, but a hard, realtime guarantee? Between the JIT, GC and other apps
that may hog CPU, I don't even depend on a realtime guarantee between "int
i = 5" and "i++".

With no evidence to back my claim, I suspect that most uses of volatiles
are for simple isDone checks or double-checked locking. The standard
patterns for both of those don't depend on a hard, realtime guarantee of
visibility. They both depend on the write being visible very quickly for
optimal performance (in the isDone case, for responsiveness of the cancel;
and in the DCL case, so that we don't need to lock the monitor), but
neither depends on it for correctness.

If my baseless claim is right, then when we have a zillion cores per
computer in a few years, I think you might see cancellations taking a few
milliseconds longer, and DCLs will needlessly grab a few more monitors. But
not many correctness issues.

There are of course more complex uses of volatiles, such as happens-before
piggybacking for lock-free algorithms. Those are easy to get wrong even
without delays to read actions, and hopefully the people who use volatiles
for those are very advanced programmers who know that "instantaneous
guarantee" and "multithreaded correctness" don't work well together. I
don't think you'd be able to exploit this so that two threads can both
remove the same element from a correct, lockless queue -- that would create
an inconsistent ordering where one is not allowed. And if the delay in
sequential ordering means that the queue looks empty forever to a sole
consumer thread, I would say we'd be within our rights to log a bug, JLS be
damned -- just as we would be if "int i = 5" took forever.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120818/6d61dd1b/attachment.html>

From mtopolnik at inge-mark.hr  Sat Aug 18 04:44:44 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Sat, 18 Aug 2012 10:44:44 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CAC2Zdp1Gqb_nO3qKtgQkMr78aJSbRbL-Y6w4Dbst2vmaH5_4Nw@mail.gmail.com>
References: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEDJJGAA.davidcholmes@aapt.net.au>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6197D@G4W3296.americas.hpqcorp.net>
	<-5565563096132427032@unknownmsgid>
	<D313DDEA-5670-4082-89FC-1D905B2280A0@inge-mark.hr>
	<CAC2Zdp1Gqb_nO3qKtgQkMr78aJSbRbL-Y6w4Dbst2vmaH5_4Nw@mail.gmail.com>
Message-ID: <D9886948-B721-4D87-9E5B-1E2F8CD1FA5C@inge-mark.hr>

On 18. kol. 2012., at 10:24, Yuval Shavit wrote:

> On Sat, Aug 18, 2012 at 3:35 AM, Marko Topolnik <mtopolnik at inge-mark.hr> wrote:
> However, what is troubling is the belief of practically every developer out there that there's a hard realtime GUARANTEE of the instantaneous visibility of volatile writes.
> 
> Do they? I certainly believe that the read is going to see the write very quickly, but a hard, realtime guarantee? Between the JIT, GC and other apps that may hog CPU, I don't even depend on a realtime guarantee between "int i = 5" and "i++".

Yes, my wording was too strong. I didn't mean "hard realtime", but a hard guarantee, as opposed to a soft promise of best effort. The volatile modifier gives you two things: a hard guarantee of proper observed ordering of actions, and a *hint* towards the timely publishing of a write. This is where confusion enters---take this typical argument: "Without the volatile modifier the reading thread is not guaranteed to ever observe a write to the var". Well guess what, with the modifier it still isn't *guaranteed* to ever observe it. This fact is very counterintuitive and many people would even religiously oppose it. I cannot escape the troubling feeling this gives me---a developer should have the right intuition about his code and shouldn't shake his head in disbelief when shown any piece of code and the output that code may legally produce. Somewhere down the line this must matter.

-Marko



From yshavit at akiban.com  Sat Aug 18 05:10:57 2012
From: yshavit at akiban.com (Yuval Shavit)
Date: Sat, 18 Aug 2012 05:10:57 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <D9886948-B721-4D87-9E5B-1E2F8CD1FA5C@inge-mark.hr>
References: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEDJJGAA.davidcholmes@aapt.net.au>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6197D@G4W3296.americas.hpqcorp.net>
	<-5565563096132427032@unknownmsgid>
	<D313DDEA-5670-4082-89FC-1D905B2280A0@inge-mark.hr>
	<CAC2Zdp1Gqb_nO3qKtgQkMr78aJSbRbL-Y6w4Dbst2vmaH5_4Nw@mail.gmail.com>
	<D9886948-B721-4D87-9E5B-1E2F8CD1FA5C@inge-mark.hr>
Message-ID: <CAC2Zdp1ZV52Qzusw0aNiZ-jm4ttjY1Zz2NfMvjn--Q2bf5UrsQ@mail.gmail.com>

So, I agree with you that people's wording assumes some sort of timely
visibility. And you're right that the reader isn't *guaranteed* to ever
observe the write, in the same way that I'm right that ++i on a local var
isn't *guaranteed* to take fewer than 7 years. I think a JVM which
exploited either non-guarantee would be up for a critical-importance
performance bug.

I also agree that the expectation of blink-of-an-eye coherency is one that
could well be challenged in the future. Taking my example of a
distributed-node JVM, if one node is in Austrialia and the other is in NYC,
and the volatile read is in a lockless whose HB edge also pulls in all the
data in some huge element in the queue (an in-memory cache of a DB table,
say) -- then I could imagine the reader chugging along for a few seconds
pretending not to see the write, until finally it and all its implications
are sync'ed across the network, at which point it finally sees the write
and everything implied by it (ie, the huge element). That may well surprise
some programmers and generate bug reports like "why is my write to a
one-byte boolean taking 15 seconds to be seen?" -- and when those questions
crop up on SO, people on this list are going to reap some major karma
points. ;-)

In summary:
   1) I agree that there's no guarantee for the write to ever be seen
   2) I agree that in the future, it may take some noticeable time for the
write to be seen
   3) I contend that if point 1 were exploited to the point of the write
not being seen in a reasonable timeframe (where "reasonable" depends on the
platform, includes some wiggle room, etc), that this would be a performance
(not correctness) bug against the JVM

Good night!

On Sat, Aug 18, 2012 at 4:44 AM, Marko Topolnik <mtopolnik at inge-mark.hr>wrote:

> On 18. kol. 2012., at 10:24, Yuval Shavit wrote:
>
> > On Sat, Aug 18, 2012 at 3:35 AM, Marko Topolnik <mtopolnik at inge-mark.hr>
> wrote:
> > However, what is troubling is the belief of practically every developer
> out there that there's a hard realtime GUARANTEE of the instantaneous
> visibility of volatile writes.
> >
> > Do they? I certainly believe that the read is going to see the write
> very quickly, but a hard, realtime guarantee? Between the JIT, GC and other
> apps that may hog CPU, I don't even depend on a realtime guarantee between
> "int i = 5" and "i++".
>
> Yes, my wording was too strong. I didn't mean "hard realtime", but a hard
> guarantee, as opposed to a soft promise of best effort. The volatile
> modifier gives you two things: a hard guarantee of proper observed ordering
> of actions, and a *hint* towards the timely publishing of a write. This is
> where confusion enters---take this typical argument: "Without the volatile
> modifier the reading thread is not guaranteed to ever observe a write to
> the var". Well guess what, with the modifier it still isn't *guaranteed* to
> ever observe it. This fact is very counterintuitive and many people would
> even religiously oppose it. I cannot escape the troubling feeling this
> gives me---a developer should have the right intuition about his code and
> shouldn't shake his head in disbelief when shown any piece of code and the
> output that code may legally produce. Somewhere down the line this must
> matter.
>
> -Marko
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120818/caf5cdf0/attachment-0001.html>

From davidcholmes at aapt.net.au  Sat Aug 18 05:27:53 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 18 Aug 2012 19:27:53 +1000
Subject: [concurrency-interest] Relativity of guarantees provided
	byvolatile
In-Reply-To: <D9886948-B721-4D87-9E5B-1E2F8CD1FA5C@inge-mark.hr>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEDMJGAA.davidcholmes@aapt.net.au>

I think this is getting a little extreme and esoteric. There is a basic
requirement that the JVM implement the Java language which means that a
putfield (for example) must update the field (a volatile one of course) -
which is a memory location. Similarly when the processor is requested to
write a value to a memory location then the value must get written to
memory. There are no time guarantees expressed about these actions but they
must happen for the JVM and the processor to be deemed to be working
correctly.

The actual latencies are a quality of implementation issue.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
> Topolnik
> Sent: Saturday, 18 August 2012 6:45 PM
> To: Yuval Shavit
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Relativity of guarantees provided
> byvolatile
>
>
> On 18. kol. 2012., at 10:24, Yuval Shavit wrote:
>
> > On Sat, Aug 18, 2012 at 3:35 AM, Marko Topolnik
> <mtopolnik at inge-mark.hr> wrote:
> > However, what is troubling is the belief of practically every
> developer out there that there's a hard realtime GUARANTEE of the
> instantaneous visibility of volatile writes.
> >
> > Do they? I certainly believe that the read is going to see the
> write very quickly, but a hard, realtime guarantee? Between the
> JIT, GC and other apps that may hog CPU, I don't even depend on a
> realtime guarantee between "int i = 5" and "i++".
>
> Yes, my wording was too strong. I didn't mean "hard realtime",
> but a hard guarantee, as opposed to a soft promise of best
> effort. The volatile modifier gives you two things: a hard
> guarantee of proper observed ordering of actions, and a *hint*
> towards the timely publishing of a write. This is where confusion
> enters---take this typical argument: "Without the volatile
> modifier the reading thread is not guaranteed to ever observe a
> write to the var". Well guess what, with the modifier it still
> isn't *guaranteed* to ever observe it. This fact is very
> counterintuitive and many people would even religiously oppose
> it. I cannot escape the troubling feeling this gives me---a
> developer should have the right intuition about his code and
> shouldn't shake his head in disbelief when shown any piece of
> code and the output that code may legally produce. Somewhere down
> the line this must matter.
>
> -Marko
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From mtopolnik at inge-mark.hr  Sat Aug 18 06:48:07 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Sat, 18 Aug 2012 12:48:07 +0200
Subject: [concurrency-interest] Relativity of guarantees provided
	byvolatile
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEDMJGAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCEEDMJGAA.davidcholmes@aapt.net.au>
Message-ID: <158D3C07-3D82-4FFF-8A42-54A9114212FF@inge-mark.hr>

Yes, we all agree on the fundamental points. I raised this question primarily to discuss the aspect of the disconnect between the public perception and the actual specification. What is generally overlooked is that a write action has no one-to-one correspondence with a single physical event, but with two events: (write done, write becomes visible). Since the JMM formal model is timeless, it doesn't have to bother with the distinction, but the name "happens-before" creates a powerful illusion that time is involved in the provided guarantees.

As I said, volatile has two disparate aspects: 

1. A guarantee of proper action ordering;

2. A best-effort promise of the action being published in a timely fashion.

Future software projects may tend to put increasing stress on this distinction, however, and demand different combinations than given by volatile. A case in point is the lazySet method of the AtomicXxx classes. The way I understand it, it gives all the guarantees of a write to a volatile, just without the promise of timeliness. Theoretically, a JVM that implemented volatile exactly as lazySet would still comply with the formal model. Whether it would completely fail at being useful is not clear-cut, though, and could depend on many subtle factors and trade-offs.


On 18. kol. 2012., at 11:27, David Holmes wrote:

> I think this is getting a little extreme and esoteric. There is a basic
> requirement that the JVM implement the Java language which means that a
> putfield (for example) must update the field (a volatile one of course) -
> which is a memory location. Similarly when the processor is requested to
> write a value to a memory location then the value must get written to
> memory. There are no time guarantees expressed about these actions but they
> must happen for the JVM and the processor to be deemed to be working
> correctly.
> 
> The actual latencies are a quality of implementation issue.
> 
> David
> 
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
>> Topolnik
>> Sent: Saturday, 18 August 2012 6:45 PM
>> To: Yuval Shavit
>> Cc: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Relativity of guarantees provided
>> byvolatile
>> 
>> 
>> On 18. kol. 2012., at 10:24, Yuval Shavit wrote:
>> 
>>> On Sat, Aug 18, 2012 at 3:35 AM, Marko Topolnik
>> <mtopolnik at inge-mark.hr> wrote:
>>> However, what is troubling is the belief of practically every
>> developer out there that there's a hard realtime GUARANTEE of the
>> instantaneous visibility of volatile writes.
>>> 
>>> Do they? I certainly believe that the read is going to see the
>> write very quickly, but a hard, realtime guarantee? Between the
>> JIT, GC and other apps that may hog CPU, I don't even depend on a
>> realtime guarantee between "int i = 5" and "i++".
>> 
>> Yes, my wording was too strong. I didn't mean "hard realtime",
>> but a hard guarantee, as opposed to a soft promise of best
>> effort. The volatile modifier gives you two things: a hard
>> guarantee of proper observed ordering of actions, and a *hint*
>> towards the timely publishing of a write. This is where confusion
>> enters---take this typical argument: "Without the volatile
>> modifier the reading thread is not guaranteed to ever observe a
>> write to the var". Well guess what, with the modifier it still
>> isn't *guaranteed* to ever observe it. This fact is very
>> counterintuitive and many people would even religiously oppose
>> it. I cannot escape the troubling feeling this gives me---a
>> developer should have the right intuition about his code and
>> shouldn't shake his head in disbelief when shown any piece of
>> code and the output that code may legally produce. Somewhere down
>> the line this must matter.
>> 
>> -Marko
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
> 



From gregg at cytetech.com  Sat Aug 18 08:25:55 2012
From: gregg at cytetech.com (Gregg Wonderly)
Date: Sat, 18 Aug 2012 07:25:55 -0500
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAHjP37G+enVX-2VcnJTDNMdVpRA3fPCyi5V4r+L5V_gRnjZiTQ@mail.gmail.com>
References: <502A9FF0.2000904@oracle.com>
	<NFBBKALFDCPFIDBNKAPCOEBPJGAA.davidcholmes@aapt.net.au>
	<CAOwENi++GF_FNSFs-DJSP5j-dA-RuVgxmgBn288eJaD+C15B0w@mail.gmail.com>
	<CAC2Zdp0ZYtPNU7HLszadSti12mO8JsKAYLPyBCv9_Kz8M9y_2w@mail.gmail.com>
	<CACuKZqG4iN1suMD2PVNVMwM4u8n21AvUNJ0NYeCt45-VUB_EvQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60753@G4W3296.americas.hpqcorp.net>
	<CAOwENiLm01VrWynD39F5O1=y0xoFeF6P=iPvSQratnh9b+-jNQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F607D1@G4W3296.americas.hpqcorp.net>
	<CAOwENiJLsMskOgmTveD_g=YRumMe-cYxu0OBQ=-A6w-t-ncXJw@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60B07@G4W3296.americas.hpqcorp.net>
	<CAOwENiJL3CaXFN=YAu334NbSy8rg8JabkVNH7HA6Po=+-XxUXQ@mail.gmail.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F60F39@G4W3296.americas.hpqcorp.net>
	<CAOwENi+=tHa6aeuW8-C3EUDK8Dd-ACXLr92XgpYOpJ8PJznouw@mail.gmail.com>
	<CAHjP37G+enVX-2VcnJTDNMdVpRA3fPCyi5V4r+L5V_gRnjZiTQ@mail.gmail.com>
Message-ID: <502F89D3.7000300@cytetech.com>

On 8/16/2012 6:40 PM, Vitaly Davidovich wrote:
> Store buffer writes are still part of cache coherency, they just don't publish
> the value to L1 right away.  The point of the store buffer is that if CPU 1
> needs to write to cache line A but doesn't have the line in its L1 (let's not
> forget that a write has to do a load as well), it can drop the write in the
> store buffer while cache controller fetches it - this is to avoid a stall.  If
> line is already in L1 it can store directly to it (and bypass store buffer),
> possibly causing invalidate requests to be sent out.

This bit of caching can create a temporal write ordering issue though, can it 
not?  The fact that the core doesn't wait for the cache line to appear, and then 
return with the write completed, implies that multiple threads which might 
perform writes on different cores may result in memory states which are not in 
line with the visible order of execution, because it depends on which cores 
cache coherency processing wins in the time to issue the read the line, 
including the thought that invalidation may occur nanoseconds after the line is 
retrieved.

Gregg


From uli at grepel.de  Sat Aug 18 08:35:18 2012
From: uli at grepel.de (Ulrich Grepel)
Date: Sat, 18 Aug 2012 14:35:18 +0200
Subject: [concurrency-interest] Double Checked Locking in OpenJDK
In-Reply-To: <CAOwENi+nxPa9myY9DX89b=_1erZMp5J5k3j=YvpF1wEoPeWrog@mail.gmail.com>
References: <mailman.206.1345161671.3055.concurrency-interest@cs.oswego.edu>
	<502DED0B.9010200@grepel.de>
	<CAOwENi+nxPa9myY9DX89b=_1erZMp5J5k3j=YvpF1wEoPeWrog@mail.gmail.com>
Message-ID: <502F8C06.6040803@grepel.de>


Am 17.08.2012 20:08, schrieb Ruslan Cheremin:
> Yes, Ulrich, I have grid-like systems in my mind then talking about
> perspective of weakening hardware coherence.
>
> But, by any way, one does not need to look so far. As I've already
> write, we already have some kind of
> weak-consistent-not-automatically-coherent memory in todays Indel CPUs
> -- in form of registers and store buffers. This is small layer atop of
> coherent memory, but this layer is, as far as I know, critical for
> overall performance, since it is important in hiding (well, sometimes
> hiding) still noticeable memory latency. Not only main memory (or,
> say, L3/2 cache latency), but also a QPI latency, if accessed memory
> location is owned by another core, and need to be re-owned, for
> example.
There's a big difference between registers and L1 cache - the registers 
are under full control of the compiler. Well, not really, looking at 
register renaming and all that stuff. But the compiler DOES know that 
when a register is stored into memory, that it CAN be seen by all other 
threads. Immediately. It doesn't actually have to be immediately stored 
into memory, not even L1 cache, it might reside in some write buffer for 
a while, but all other cores will, due to the cache synchronisation 
mechanisms, know about it IF they care about it.

L1 cache though is more or less completely transparent to the compiler. 
Besides some configuration things (like "do not use L1 at all for these 
memory locations, because they are I/O areas" or similar) that usually 
are under OS control, there's not much a compiler can do to force writes 
from L1 to main memory. So either we will have weak synchronisation, or 
we will have cache coherency, or we will at least have some new assembly 
instructions for flushing a cache line. Since many many CPUs from 8088 
(or at least 80386) to Core i7, plus AMD plus others, share their 
assembly instruction set, and since all of these have very different L1 
cache designs (from "none" to "write through" or "copy-back", n-way 
associative with varying "n") and different cache levels (why stop at 
L1?) it is unlikely that any such instructions will surface. The best 
thing we might get would be a huge register file ("huge" as in 1024 or 
more registers), all of them available to the application. But besides 
having a completely new architecture that causes other problems, such as 
long running context switches and, on top, a tradeoff between transistor 
count and performance. Transistors might be used for something else to 
gain performance, and larger register files will be slower.

> I see no reason why evolution of QPI will be somehow different from
> evolution of memory itself. Leaving away chance for some kind of
> hardware revolution (breakthrough, which would give us cheap and
> ultimate fast memory/QPI), it seems for me like we'll have same
> QPI-wall, as we've already have memory wall.
That wall is already there if you look at AMD's HT instead (see below). 
Also don't forget that main memory today has access times that will not 
allow the RAM chips to be significantly farther away than right next to 
the CPU on the same board. Physics, speed of light and all that stuff. 
So coordinating caches across distributed (as in "several racks in the 
data center") systems will never be as fast as coordinating a couple of 
local caches. Remember that for 1 ns access time you will have to travel 
from the CPU to RAM and back, which in vacuum would allow about 15cm 
distance minus reaction time of the RAM chips themselves. And vacuum is 
not available, we're talking about copper which reduces this to let's 
say 10cm which is what we find on current mainboards.

So for fast, big massively parallel systems we will never have one 
memory model with coherent caches and thus with the ability to live in 
one single process model synchronizing threads with something like locks.

> I see no chance for QPI
> being fast, wide, cheap, and scale to hundreds of CPUs same time. So
> we'll still need some kind of weak consistent layer with explicit
> flushing control to hide weakness of memory (and QPI, as part of
> memory engine).

QPI is similar to AMDs HT which has been around for 8 or 9 years now. 
Originally this was meant to scale well to many CPU sockets, but there's 
not that many systems using 8 Opteron CPUs around. Diminishing returns. 
HT is also used by Cray with their Seastar architecture which is HT on 
steroids (up to 32K nodes), but only as a very fast network 
interconnection, not for synchronizing RAM directly. For example:

http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/de/us/pubs/archive/36896.pdf

> What I trying to say here: seems like we always will have strict
> consistent but rather slow memory (with QPI), and quick but weak
> consistent memory. Border between them could move -- now days servers
> and desktops have tiny weak-consistent layer, while grids and clusters
> have all its memory "weak consistent" (only explicitly synchronized).
As I said, pure physics are in the way when trying to get a speedy 
grid/cluster system
with coherent memory.

> And if my assumption are not too far from reality, it seems promising
> (or at least interesting) to trying to investigate algorithms which
> can exploit inconsistency, instead of trying to fight with it with
> fences.
Exactly. Unfortunately, easy parallel programming has been on the wish 
list for ages, without any real advantage as in "works on its own and 
can be done by your average coder".

There's always some areas that lend themselves to parallelism, and there 
IS some progress in easying parallel programming, but as this whole 
discussion shows, it is still not easy going.

> Do you know about any works in this direction? For now I see only one
> promising example for exploiting eventually consistent approach -- the
> sync-less cache for atomically published entities, like primitives
> (except long/double sure) or immutable objects.
No, I don't, sorry.

Uli

From mtopolnik at inge-mark.hr  Sat Aug 18 09:02:29 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Sat, 18 Aug 2012 15:02:29 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
Message-ID: <1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>

Yuval, rereading the earlier posts I noticed this one from you:

> That said, 17.4.3 does imply that the reads will be viewable in a wall-clock-sequential way, albeit informally
> 
>     Sequential consistency is a very strong guarantee that is made about visibility and ordering in an execution of a program. Within a sequentially consistent execution, there is a total order over all individual actions (such as reads and writes) which is consistent with the order of the program, and each individual action is atomic and is immediately visible to every thread.
> 
> (emphasis on "is immediately visible")

The major point to note is that the JLS **does not** enforce sequential consistency! It even spells it out directly below your quote:

"If we were to use sequential consistency as our memory model, many of the compiler and processor optimizations that we have discussed would be illegal."

The whole model of happens-before revolves around making sequentially INCONSISTENT executions APPEAR to be consistent, as observed by all executing threads, thus allowing all the optimizations that are discussed on this mailing list.


-Marko



From kirk at kodewerk.com  Sat Aug 18 11:10:58 2012
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Sat, 18 Aug 2012 17:10:58 +0200
Subject: [concurrency-interest] Relativity of guarantees provided
	byvolatile
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEDFJGAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCCEDFJGAA.davidcholmes@aapt.net.au>
Message-ID: <A13941EA-A0E8-4C8F-9004-E8641B11916F@kodewerk.com>


On 2012-08-18, at 1:03 AM, David Holmes <davidcholmes at aapt.net.au> wrote:

> Nathan,
>  
> Is there a synchronization order here that indicates that the read occurs after the write? "subsequent" is not defined by wall-clock time as externally observed.

subsequent |?s?bs?kw?nt|
adjective
coming after something in time;

What we have is an intractable problem that is as old as stone tablets. At the hardware level, no matter how small the time quantum is, as long as instructions take more than 1 of them and we have multiple hardware threads, there will be a gap in time where there will be a non-zero probability that  a write hasn't finished and a read will have started. That yields a non-zero probability were no one will be able to provide any guarantee as to what any value will be read. At that point all you can say is that any calculation you perform will be speculative and as is the case with any speculative calculation, you're going to have to make assumption and then before you do anything else, you're going to have to revalidate those assumptions. In this case the assumption is that you're working with a stable value as defined by the JMM. And this problem will only get worse as we add more hardware threads. The only positive is that we're gradually moving to more hardware threads which means we're able to find and correct the most probable conditions thus eliminating them before we get to the next round.

Regards,
Kirk

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120818/a99c25dd/attachment-0001.html>

From wolfgang.baltes at laposte.net  Sat Aug 18 11:48:17 2012
From: wolfgang.baltes at laposte.net (Wolfgang Baltes)
Date: Sat, 18 Aug 2012 08:48:17 -0700
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
Message-ID: <502FB941.2050403@laposte.net>

The memory model is just that: a model. It is not a hardware spec, nor a 
prediction of what happens in which order in the future. It allows to 
interpret observations and draw some conclusions.

The simple programming model that all programmers assume is program 
order. For example, in the following lines, everyone can expect x to 
hold the value 1  and y the value 2.

int a = 1;
int b = 2;
int y = b;
int x = a;

However, we also know that optimizations can happen. So for example, 
there is no guarantee that a is set to 1 before b is set to 2. The only 
guarantee we have is that - once a write operation has appeared in 
program code - a (subsequent in program order) read operation is 
guaranteed to succeed with the expected value, independent of any 
optimization. In this example, we do not know when a is set to 1, except 
we know that whenever a is read after the assignment instruction in 
program order, a will have a value of 1. For example, an optimization 
could consist of reordering the write to a after y is assigned the value 
of b. This reordering would not be observable in this thread, and 
therefore does not change the reasoning of what the program 
accomplishes. The program order guarantee is there to allow the 
programmer to reason about a program in simple terms, such as "I put 
instructions in this order to achieve this result" and the program order 
rule guarantees that the result can be observed, no matter which 
optimizations are involved.

The memory model is nothing more than a similar guarantee regarding 
program order when multiple threads are involved. The memory model does 
not say what will happen sometimes in the future. It only allows to draw 
conclusions about what happened in the past >if< certain observations 
are made.

For example,

Thread A:
int a = 1;
volatile int b = 2;
int y = b;
int x = a;

Thread B:
y = b; // volatile read of b.
x = a;

If we apply the program order rule for single threads, we cannot be sure 
which value is assigned to x; is a set to 1 or does it have the value 0? 
Using the memory model, we expand the program order rules by the 
volatile rule: when thread B performs a volatile read, then there are 
certain guarantees as follows:
- When thread B reads the value of b and it finds 0, then the conclusion 
is that thread A has not reached its volatile write to b. Nothing else 
can be concluded.
- If thread B reads a value of 2 for b, then we are allowed to conclude 
that instructions of thread A that appear before the volatile write in 
program order have "happened-before". This rule allows us to conclude 
that >if< we observe a value of 2 for b, then we are sure to observe a 
value of 1 for variable a. (There is nothing in the memory model of 
 >when exactly< the value 1 has to be written to a, just that we can 
count on the observation.)

We have the JVM's guarantee that these conclusions are permitted, 
despite any optimizations that are ongoing. This makes concurrent 
programming almost as easy to reason about as single threaded programming.

However, in the example given, the memory model does not >predict< in 
any way whatsoever when thread B will reach the volatile read 
instruction relative in time to the volatile write in thread A.

Note also that the memory model does not deal with the extend in time 
that it takes to perform operations. For the examples above, it doesn't 
matter when assignment operations start, it only matters when they 
finish. And for reads, it only matters when they start. This is why the 
memory model uses the concept (and terminology) of synchronization: a 
trailing volatile write edge is considered synchronized with a leading 
read edge >if< the read operation observes the result of the write.

Wolfgang.


On 2012-08-18 06:02, Marko Topolnik wrote:
> Yuval, rereading the earlier posts I noticed this one from you:
>
>> That said, 17.4.3 does imply that the reads will be viewable in a wall-clock-sequential way, albeit informally
>>
>>      Sequential consistency is a very strong guarantee that is made about visibility and ordering in an execution of a program. Within a sequentially consistent execution, there is a total order over all individual actions (such as reads and writes) which is consistent with the order of the program, and each individual action is atomic and is immediately visible to every thread.
>>
>> (emphasis on "is immediately visible")
> The major point to note is that the JLS **does not** enforce sequential consistency! It even spells it out directly below your quote:
>
> "If we were to use sequential consistency as our memory model, many of the compiler and processor optimizations that we have discussed would be illegal."
>
> The whole model of happens-before revolves around making sequentially INCONSISTENT executions APPEAR to be consistent, as observed by all executing threads, thus allowing all the optimizations that are discussed on this mailing list.
>
>
> -Marko
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From jan.sture.nielsen at gmail.com  Sat Aug 18 12:13:36 2012
From: jan.sture.nielsen at gmail.com (Jan Nielsen)
Date: Sat, 18 Aug 2012 10:13:36 -0600
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
References: <3CEE49F2-DFEB-4D8B-BCFD-4FBD2E16D200@inge-mark.hr>
	<616A1C6D-148D-4971-B752-F085115F3DD5@inge-mark.hr>
	<B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
Message-ID: <CANxH4hH+UV0VF9guCdyk4LuE9pj_VU73gweQoGCYKJpzrmyQmw@mail.gmail.com>

On Fri, Aug 17, 2012 at 3:24 PM, Marko Topolnik <mtopolnik at inge-mark.hr>
 wrote:

> 2. If there is no loophole, is there anything to worry about, given that
> practically 100% developers out there consider as guaranteed something that
> isn't?


I'm part of the 99%. When I read: "A field may be declared volatile, in
which case the Java Memory Model ensures that all threads see a consistent
value for the variable" [1] I understand this to mean for volatile variable
's' updated in one thread and read from another, these scenarios are
possible:

   Thread0
0: volatile int s=0;

   Thread0  Thread1
-----------------
1: s=1
2:          s==1
3: s=2
4:          s==2
5: s=3
6:          s==3
-----------------
1:          s==1
2:          s==1
3:          s==1
4: s=1
5: s=2
6: s=3
-----------------
1: s=1
2: s=2
3: s=3
4:          s==3
5:          s==3
6:          s==3

[1] http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120818/13100b11/attachment.html>

From zhong.j.yu at gmail.com  Sat Aug 18 12:33:25 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Sat, 18 Aug 2012 11:33:25 -0500
Subject: [concurrency-interest] Relativity of guarantees provided
	byvolatile
In-Reply-To: <-5933359067440987844@unknownmsgid>
References: <CACuKZqFkPSbLACUK+WA=yoq3ChYC_QHZD3qBdJDaCpEE7LcyLQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEDKJGAA.davidcholmes@aapt.net.au>
	<CACuKZqF6mzWp2iCwZOo9eTa3LX8aV3iTYY4s-6Nof2bHg0MuyQ@mail.gmail.com>
	<-5933359067440987844@unknownmsgid>
Message-ID: <CACuKZqHmvyyPhKojmnYb2wkHmJODFfPnQMT7Ef=dQAPU1xiVrg@mail.gmail.com>

On Sat, Aug 18, 2012 at 12:00 AM, Yuval Shavit <yshavit at akiban.com> wrote:
> On Aug 18, 2012, at 12:43 AM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>
>> On Fri, Aug 17, 2012 at 9:29 PM, David Holmes <davidcholmes at aapt.net.au> wrote:
>>> Well that's your choice, but it makes more sense temporally to consider
>>> completetion when the actual result of the action is available, in my
>>> opinion.
>>
>> We can consider another model:
>>
>> A write must wait for confirmation mail from V.
>>
>> V receives a write Wi, updates its state to Vi, sends mails containing
>> Vi to all threads. The mail is also the confirmation mail to the
>> writer.
>>
>> Threads locally cache the last Vi it receives. A read checks the
>> locally cached Vi only, therefore reads are very short.
>>
>> Sync order can be defined mainly based on the 'i's of actions. This
>> also appears to be a valid JMM model.
>>
>> Then we move V close to W, far away from R. On day#1, W writes v=1 to
>> V. That change reaches R on day#3. On day#2 R reads v=0. Once again,
>> we have read<write in sync order, yet write<read in temporal order.
>
> Except that in this metaphor, if v is volatile, wouldn't R's read of v
> on day 2 require sending V a note requesting v's value -- at which
> point V know about the letter from W on day 1?

In my 2nd model, read only consults the local cache, so it's very fast.

> This model has V being the sole timekeeper. An action A' is subsequent
> to another action A iff V processes A before A'. V seems like quite
> the bottleneck here. In particular, two sets of actions, each with HB
> relations within them but with no HBs between them, will both have to
> synchronize on the same V.

I'm not trying to design a realistic model. I'm seeking a simple
physical model that conforms to JMM and demonstrate that OP's example
can be realized on this model, therefore OP's example is legal under
JMM; and in general, sync order and temporal order can differ.

However the discrepancy becomes less and less when the message
transmission speed approaches the speed of light, so we don't really
need to worry too much about it on real computer hardware.

>
>
>>
>>
>>
>>>
>>> David
>>>
>>>> -----Original Message-----
>>>> From: Zhong Yu [mailto:zhong.j.yu at gmail.com]
>>>> Sent: Saturday, 18 August 2012 12:21 PM
>>>> To: dholmes at ieee.org
>>>> Cc: concurrency-interest at cs.oswego.edu
>>>> Subject: Re: [concurrency-interest] Relativity of guarantees provided
>>>> byvolatile
>>>>
>>>>
>>>> In the model, a write completes as soon as the mail is sent, the same
>>>> thread can immediately make another write. A read completes when the
>>>> return mail is received; the reading thread is suspended during the
>>>> wait.
>>>>
>>>> The example is designed so that reads are short too, so we can treat
>>>> actions as points in time, to order them easily.
>>>>
>>>> On Fri, Aug 17, 2012 at 8:55 PM, David Holmes
>>>> <davidcholmes at aapt.net.au> wrote:
>>>>> As I keep saying, for this to "make sense" you have to make temporal
>>>>> measurements when an action completes.
>>>>>
>>>>> David
>>>>>
>>>>>> -----Original Message-----
>>>>>> From: concurrency-interest-bounces at cs.oswego.edu
>>>>>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
>>>> Of Zhong Yu
>>>>>> Sent: Saturday, 18 August 2012 11:34 AM
>>>>>> To: Yuval Shavit
>>>>>> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
>>>>>> Subject: Re: [concurrency-interest] Relativity of guarantees provided
>>>>>> byvolatile
>>>>>>
>>>>>>
>>>>>> Consider this physical model:
>>>>>>
>>>>>> Each thread is a person Tx.
>>>>>>
>>>>>> There's a person V managing all variables.
>>>>>>
>>>>>> To make a write, Tx sends a paper mail to V. No return mail is
>>>>>> required, therefore a write is very short.
>>>>>>
>>>>>> To make a read, Tx sends a paper mail to V, and waits for return mail.
>>>>>>
>>>>>> The synchronization order is the order the mails received by V.
>>>>>>
>>>>>> This seems to be a valid JMM model.
>>>>>>
>>>>>> --
>>>>>>
>>>>>> Now suppose thread R is very close to V, therefor reads are also very
>>>>>> short. (it's easier to talk about temporal order between short
>>>>>> actions) Suppose thread W is very far away from V.
>>>>>>
>>>>>> To realize OP's example, consider the numbers are in hours, and route
>>>>>> W -> V takes 48 hours.
>>>>>>
>>>>>> On Monday, W writes v=1, it reaches V on Wednesday. On Tuesday R reads
>>>>>> v=0. So the write is after read in sync order, yet write is before
>>>>>> read in temporal order(even considering relativity - all persons are
>>>>>> on Earth)
>>>>>>
>>>>>> Therefore sync order doesn't have to be consistent with temporal order.
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>
>>>>
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From mtopolnik at inge-mark.hr  Sat Aug 18 14:11:23 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Sat, 18 Aug 2012 20:11:23 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CANxH4hH+UV0VF9guCdyk4LuE9pj_VU73gweQoGCYKJpzrmyQmw@mail.gmail.com>
References: <3CEE49F2-DFEB-4D8B-BCFD-4FBD2E16D200@inge-mark.hr>
	<616A1C6D-148D-4971-B752-F085115F3DD5@inge-mark.hr>
	<B7C5CC7B-6488-43F8-A72B-A808F3D0C051@inge-mark.hr>
	<CANxH4hH+UV0VF9guCdyk4LuE9pj_VU73gweQoGCYKJpzrmyQmw@mail.gmail.com>
Message-ID: <4088E3FC-7369-4477-B7B3-4748231863AD@inge-mark.hr>

Jon,

the only thing you need to notice is that the rows in your table are sequenced by the synchronization order, which has nothing (at least formally) to do with the wall-clock timing order of the events, and especially: you show a write as a single event where in fact it is two events separated in time: the moment Thread0 writes a value and a later moment when Thread1 observes it is written. That later moment can be arbitrarily postponed as long as the overall happens-before is maintained. This can in the end create the behavior that I demonstrate in my original post.

That is why the JMM **does not** guarantee that Thread1 will observe at t=3 a write by Thread0 at t=0. It only guarantees that **when** it observes it, it will definitely also observe any writes preceding it, so it will see the actions of Thread0 as if they happened in program order.

-Marko

On 18. kol. 2012., at 18:13, Jan Nielsen wrote:

> On Fri, Aug 17, 2012 at 3:24 PM, Marko Topolnik <mtopolnik at inge-mark.hr> wrote:
> 2. If there is no loophole, is there anything to worry about, given that practically 100% developers out there consider as guaranteed something that isn't?
> 
> I'm part of the 99%. When I read: "A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable" [1] I understand this to mean for volatile variable 's' updated in one thread and read from another, these scenarios are possible:
> 
>    Thread0
> 0: volatile int s=0;
> 
>    Thread0  Thread1
> -----------------
> 1: s=1
> 2:          s==1
> 3: s=2
> 4:          s==2
> 5: s=3
> 6:          s==3
> -----------------
> 1:          s==1
> 2:          s==1
> 3:          s==1
> 4: s=1
> 5: s=2
> 6: s=3
> -----------------
> 1: s=1
> 2: s=2
> 3: s=3
> 4:          s==3
> 5:          s==3
> 6:          s==3
> 
> [1] http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From zhong.j.yu at gmail.com  Sat Aug 18 16:38:07 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Sat, 18 Aug 2012 15:38:07 -0500
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F6197D@G4W3296.americas.hpqcorp.net>
References: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEDJJGAA.davidcholmes@aapt.net.au>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6197D@G4W3296.americas.hpqcorp.net>
Message-ID: <CACuKZqG6Jx+gs8hBwLHwjRX5mS7DD4FeFNux-3fop6QkqQRV4g@mail.gmail.com>

On Fri, Aug 17, 2012 at 8:21 PM, Boehm, Hans <hans.boehm at hp.com> wrote:
> My reading is that ?subsequent? in chapter 17 of the spec refers to
> synchronization order, except in one case in which it refers to a
> hypothetical sequentially consistent memory model.
>
>
>
> I agree that the originally described behavior is allowed.   There?s another
> complication here that can explain this behavior (as can delayed stores).
> AFAIK, the spec does not clearly require that  ?wall clock time? is
> perfectly synchronized across threads, and implementations may, for good
> reason, fail to ensure that, particularly in this case.  We had this
> discussion in connection with C++11, and that spec does require that a
> specific clock is consistent with happens-before.  But even that spec, which
> is strict enough to raise some controversy, isn?t sufficient here, since
> there is no happens-before relation between the threads.

It seems imperative that, on any physical model of JMM, among
synchronization actions, if a happens-before b, then there's a causal
relationship from a to b, and it's necessary that
a.startTime<b.endTime (on any observer's clock). In that sense, the
term happens-before is literal after all?

In OP's example, there are so(r_i, w_j), but there's no hb(r_i, w_j),
therefore there's no temporal constraints, w_j can occur before r_i.
If there were something that established hb(r_i, w_j), then the
example is impossible under JMM.

Interestingly, JMM also defines r_i and w_j to be in a data race, even
though they are all volatile.

Could it be true that, if an execution is free of data race, it is
temporally consistent, i.e. its synchronization order is consistent
with temporal order.


>
>
>
> Hans
>
>
>
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
> Holmes
> Sent: Friday, August 17, 2012 5:03 PM
> To: Yuval Shavit; Vitaly Davidovich
> Cc: concurrency-interest at cs.oswego.edu
>
>
> Subject: Re: [concurrency-interest] Relativity of guarantees provided by
> volatile
>
>
>
> Ah I knew there was something about "immediate" in there somewhere :) So if
> instructions were immediate (ie they completed as soon as they started) then
> wall clock observations would be consistent with actual executions. But on
> real systems instructions are not immediate so you have to take the
> completion of the instruction as the point at which to make a wall clock
> observation.
>
>
>
> Aside: as well as being atomic and immediate you also need to preclude two
> instructions from executing simultaneously :)
>
>
>
> David (now departing to enjoy the weekend :) )
>
> -----Original Message-----
> From: Yuval Shavit [mailto:yshavit at akiban.com]
> Sent: Saturday, 18 August 2012 9:49 AM
> To: Vitaly Davidovich
> Cc: dholmes at ieee.org; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Relativity of guarantees provided by
> volatile
>
> (Resending -- I'd accidentally sent this only to Nathan)
>
> So, Nathan, you're essentially saying that "subsequent" is defined in terms
> of clock time. If we take that as the definition, then I agree that it works
> as we'd all expect. Furthermore, I agree that that's the intuitive
> definition, as well as the de-facto one. But it doesn't seem to be the one
> explicitly defined by the JLS. (And if it is the one implicitly defined by
> the JLS, I there's a serious bug waiting for any distributed-node JVM whose
> nodes are traveling away from each other at relativistic speeds! ... though
> I'm no physics expert.)
>
>
>
> That said, 17.4.3 does imply that the reads will be viewable in a
> wall-clock-sequential way, albeit informally
>
>
>
>     Sequential consistency is a very strong guarantee that is made about
> visibility and ordering in an execution of a program. Within a sequentially
> consistent execution, there is a total order over all individual actions
> (such as reads and writes) which is consistent with the order of the
> program, and each individual action is atomic and is immediately visible to
> every thread.
>
>
>
> (emphasis on "is immediately visible")
>
>
>
> On Fri, Aug 17, 2012 at 7:41 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
>
> David and you may be right in the theoretical aspect.  In practice, I can't
> fathom how a JVM can do this type of analysis.  That's an issue that I have
> with JMM's wording of happens-before -- it doesn't translate to reality, it
> seems like.
>
> Sent from my phone
>
> On Aug 17, 2012 7:30 PM, "Yuval Shavit" <yshavit at akiban.com> wrote:
>
> Sure, but it could decide that the execution order is [w1, w2, w3, r]. In
> fact, as far as we know, the thread may have been scheduled such that that
> was the clock-time ordering, too.
>
> On Fri, Aug 17, 2012 at 7:21 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
>
> Two volatile writes emit a store-store barrier in between, which to me means
> they cannot be collapsed and must be made visible in that order (on non-TSO
> this would require a h/w fence).  In other words, I don't think compiler can
> remove the redundant stores as if this was a non-volatile field, where it's
> a perfectly valid (and good) optimization.
>
> Sent from my phone
>
> On Aug 17, 2012 7:18 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>
> How does it violate the JMM? There is nothing to establish that any read has
> to have occurred prior to w=3. An external observer may say "hey if we'd
> actually written w=1 at this point then the read would see 1" but that is
> irrelevant. The program can not tell the other writes did not occur.
>
>
>
> David
>
> -----Original Message-----
> From: Vitaly Davidovich [mailto:vitalyd at gmail.com]
> Sent: Saturday, 18 August 2012 9:12 AM
> To: dholmes at ieee.org
> Cc: Marko Topolnik; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Relativity of guarantees provided by
> volatile
>
> I don't think the writes to w can be reduced to just the last one as it
> would violate the JMM.  R may only see the last one due to interleaving
> though. Not sure if that's what you meant.
>
> Sent from my phone
>
> On Aug 17, 2012 7:03 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>
> Hi Marko,
>
> I think the "surprise" is only in the way you formulated this. Said another
> way a write takes a finite amount of time from when the instruction starts
> to execute to when the store is actually available for a read to see.
> (Similarly a read takes a finite amount of time.) So depending on those two
> times a read and write that happen "around the same time" may appear to have
> occurred in either order. But when you program with threads you never know
> the relative interleavings (or should never assume) so it makes no
> difference how the program perceives the order compared to how some external
> observer might perceive it.
>
> As for your optimization to "chunk" volatile writes, I don't see a problem
> here if you are basically asking if given:
>
> w = 1;  // w is volatile
> w = 2;
> w = 3;
>
> that this could be reduced to the last write alone? I see no reason why not.
> Without some additional coordination between a reader thread and the writer
> thread, reading w==3 is a legitimate outcome. If you are thinking about how
> the hardware might chunk things then that is a different matter. We have to
> use the hardware in a way that complies with the memory model - if the
> hardware can't comply then you can't run Java on it.
>
> David Holmes
> ------------
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Marko
>> Topolnik
>> Sent: Saturday, 18 August 2012 7:24 AM
>> To: concurrency-interest at cs.oswego.edu
>> Subject: [concurrency-interest] Relativity of guarantees provided by
>> volatile
>>
>>
>> Consider the following synchronization order of a program
>> execution involving a total of two threads, R and W:
>>
>> - thread R begins;
>>
>> - thread R reads a volatile int sharedVar several times. Each
>> time it reads the value 0;
>>
>> - thread R completes;
>>
>> - thread W begins;
>>
>> - thread W writes the sharedVar several times. Each time it
>> writes the value 1;
>>
>> - thread W completes.
>>
>> Now consider the wall-clock timing of the events:
>>
>> - thread R reads 0 at t = {1, 4, 7, 10};
>> - thread W writes 1 at t = {0, 3, 6, 9}.
>>
>> As far as the Java Memory Model is concerned, there is no
>> contradiction between the synchronization order and the
>> wall-clock times, as the JMM is wall-clock agnostic. However, I
>> have yet to meet a single Java professional who wouldn't at least
>> be very surprised to hear that the specification allows this.
>>
>> I understand that the SMP architecture that dominates the world
>> of computing today practically never takes these liberties and
>> makes the volatile writes visible almost instantaneously. This
>> may change at any time, however, especially with the advent of
>> massively parrallel architectures that seem to be the future. For
>> example, an optimization technique may choose to chunk many
>> volatile writes together and make them visible in a single bulk
>> operation. This can be safely done as long as there are no
>> intervening read-y actions (targets of the synchronizes-with
>> edges as defined by JLS/JSE7 17.4.4).
>>
>> Now, my questions are:
>>
>> 1. Is there a loophole in my reasoning?
>>
>> 2. If there is no loophole, is there anything to worry about,
>> given that practically 100% developers out there consider as
>> guaranteed something that isn't?
>>
>>
>> -Marko
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From jeffhain at rocketmail.com  Sat Aug 18 17:00:53 2012
From: jeffhain at rocketmail.com (Jeff Hain)
Date: Sat, 18 Aug 2012 22:00:53 +0100 (BST)
Subject: [concurrency-interest]  Disruptor derivative
Message-ID: <1345323653.90119.YahooMailNeo@web132103.mail.ird.yahoo.com>

Hello.


For those interested in ring buffers, I have made a cross between
LMAX's Disruptor and JDK's ExecutorService - but in some ways
the baby differs from both parents.


It's in the library at:
http://code.google.com/p/jodk

This library also contains a few lower level concurrency utilities
its ring buffers make use of, and that you might find useful as well.


-Jeff
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120818/34e8e1b6/attachment.html>

From mtopolnik at inge-mark.hr  Sat Aug 18 17:50:52 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Sat, 18 Aug 2012 23:50:52 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CACuKZqG6Jx+gs8hBwLHwjRX5mS7DD4FeFNux-3fop6QkqQRV4g@mail.gmail.com>
References: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEDJJGAA.davidcholmes@aapt.net.au>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6197D@G4W3296.americas.hpqcorp.net>
	<CACuKZqG6Jx+gs8hBwLHwjRX5mS7DD4FeFNux-3fop6QkqQRV4g@mail.gmail.com>
Message-ID: <AC31E334-DF08-4EA2-9285-D3DB12A71C05@inge-mark.hr>

> It seems imperative that, on any physical model of JMM, among
> synchronization actions, if a happens-before b, then there's a causal
> relationship from a to b, and it's necessary that
> a.startTime<b.endTime (on any observer's clock). In that sense, the
> term happens-before is literal after all?

Although admittedly exotic, theoretically the JVM might _predict_ what a future action will write and let that value be read by another thread ahead of time, creating a happens-before that travels back through time without disrupting the JMM's stipulations.

> In OP's example, there are so(r_i, w_j), but there's no hb(r_i, w_j),
> therefore there's no temporal constraints, w_j can occur before r_i.
> If there were something that established hb(r_i, w_j), then the
> example is impossible under JMM.
> 
> Interestingly, JMM also defines r_i and w_j to be in a data race, even
> though they are all volatile.

This a very nice catch. Isn't in fact any read in a data race with all writes by another thread following the write it observed? That would make it impossible to write a program free of data races. In other words this sounds like a loophole in the definition of a data race.

> Could it be true that, if an execution is free of data race, it is
> temporally consistent, i.e. its synchronization order is consistent
> with temporal order.

I think that any synchronization order is temporally consistent, save for perversions like the one I mention above. Whether there are also data races shouldn't matter as they are not included in the synchronization order, anyway.

-Marko



From zhong.j.yu at gmail.com  Sat Aug 18 18:23:11 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Sat, 18 Aug 2012 17:23:11 -0500
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <AC31E334-DF08-4EA2-9285-D3DB12A71C05@inge-mark.hr>
References: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEDJJGAA.davidcholmes@aapt.net.au>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6197D@G4W3296.americas.hpqcorp.net>
	<CACuKZqG6Jx+gs8hBwLHwjRX5mS7DD4FeFNux-3fop6QkqQRV4g@mail.gmail.com>
	<AC31E334-DF08-4EA2-9285-D3DB12A71C05@inge-mark.hr>
Message-ID: <CACuKZqEHv9K2TSdAdqL8FJN-DkLbZ3HGeJDSGVFZM+=9DaxniA@mail.gmail.com>

On Sat, Aug 18, 2012 at 4:50 PM, Marko Topolnik <mtopolnik at inge-mark.hr> wrote:
>> It seems imperative that, on any physical model of JMM, among
>> synchronization actions, if a happens-before b, then there's a causal
>> relationship from a to b, and it's necessary that
>> a.startTime<b.endTime (on any observer's clock). In that sense, the
>> term happens-before is literal after all?
>
> Although admittedly exotic, theoretically the JVM might _predict_ what a future action will write and let that value be read by another thread ahead of time, creating a happens-before that travels back through time without disrupting the JMM's stipulations.

This is true. Probably more constraints on the physical model are
needed, e.g. a thread has no knowledge about the global program.

>
>> In OP's example, there are so(r_i, w_j), but there's no hb(r_i, w_j),
>> therefore there's no temporal constraints, w_j can occur before r_i.
>> If there were something that established hb(r_i, w_j), then the
>> example is impossible under JMM.
>>
>> Interestingly, JMM also defines r_i and w_j to be in a data race, even
>> though they are all volatile.
>
> This a very nice catch. Isn't in fact any read in a data race with all writes by another thread following the write it observed? That would make it impossible to write a program free of data races. In other words this sounds like a loophole in the definition of a data race.
>
>> Could it be true that, if an execution is free of data race, it is
>> temporally consistent, i.e. its synchronization order is consistent
>> with temporal order.
>
> I think that any synchronization order is temporally consistent, save for perversions like the one I mention above. Whether there are also data races shouldn't matter as they are not included in the synchronization order, anyway.
>
> -Marko
>


From james at inaseq.com  Mon Aug 20 06:58:41 2012
From: james at inaseq.com (James)
Date: Mon, 20 Aug 2012 06:58:41 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
Message-ID: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>

I'm wondering whether the BigDecimal constructors that take a MathContext parameter exhibit initialization safety.  As far as I can tell (and I could be very wrong), BigDecimal is relying on the volatile nature of the intVal reference to ensure the BigDecimal is effectively immutable.  However, the constructors that take a MathContext delegate to the following method, which alters other members after intVal:

    private void roundThis(MathContext mc) {
        BigDecimal rounded = doRound(this, mc);
        if (rounded == this)                 // wasn't rounded
            return;
        this.intVal     = rounded.intVal;
        this.intCompact = rounded.intCompact;
        this.scale      = rounded.scale;
        this.precision  = rounded.precision;
    }

Is this a potential issue for safe publication or am I missing something?
Is BigDecimal intended to exhibit initialization safety?

From skuksenko at gmail.com  Mon Aug 20 07:32:07 2012
From: skuksenko at gmail.com (Sergey Kuksenko)
Date: Mon, 20 Aug 2012 15:32:07 +0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
Message-ID: <CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>

Hi James,

- Look into jdk8 sources. New  BigDecimal has final fields (instead of
volatile).
- Could you explain what is the issue for safe publication in the old code
(look like everything is ok)?

On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:

> I'm wondering whether the BigDecimal constructors that take a MathContext
> parameter exhibit initialization safety.  As far as I can tell (and I could
> be very wrong), BigDecimal is relying on the volatile nature of the intVal
> reference to ensure the BigDecimal is effectively immutable.  However, the
> constructors that take a MathContext delegate to the following method,
> which alters other members after intVal:
>
>     private void roundThis(MathContext mc) {
>         BigDecimal rounded = doRound(this, mc);
>         if (rounded == this)                 // wasn't rounded
>             return;
>         this.intVal     = rounded.intVal;
>         this.intCompact = rounded.intCompact;
>         this.scale      = rounded.scale;
>         this.precision  = rounded.precision;
>     }
>
> Is this a potential issue for safe publication or am I missing something?
> Is BigDecimal intended to exhibit initialization safety?
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Best regards,
Sergey Kuksenko
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/7513d538/attachment.html>

From radhakrishnan.mohan at gmail.com  Mon Aug 20 07:35:05 2012
From: radhakrishnan.mohan at gmail.com (Mohan Radhakrishnan)
Date: Mon, 20 Aug 2012 17:05:05 +0530
Subject: [concurrency-interest] Parameterized CountedCompleters
In-Reply-To: <502CEAAB.8040809@cs.oswego.edu>
References: <502CEAAB.8040809@cs.oswego.edu>
Message-ID: <CAOoXFP_ZN1a+Ru=US06ibSRdbjfQG=0imsyVej8FOYM6o7VGJQ@mail.gmail.com>

Hi,

I have some questions from the perspective of a programmer using this. for
general development. Is the copied code the right template for using this ?
The example intends to receive replies from some hosts  accordign to a
simple order.
Should this  only be used with more number of forked tasks always and not
only a few  to take advantage of the original FJ's intention?

 from
https://wiki.engr.illinois.edu/download/attachments/202146190/DougLea_juc.pdf?version=1&modificationDate=1342124377000

   - The actual (sub)tasks are not recorded; just counts
   - But can easily record them yourself
   - Applicability
   - More well-behaved than RecursiveAction when tasks block ( Is there
   more explanation for why they are well behaved ? )


public class CountedCompleters {
    public CountedCompleters(){
        int procs = 0;
        if (procs == 0)
            procs = Runtime.getRuntime().availableProcessors();
        ForkJoinPool pool = new ForkJoinPool(procs);
        pool.invoke( new MasterSocketReceiver ( null ));
        System.out.println(pool);
        pool.shutdown();
    }

    static final class Completer extends CountedCompleter<Void> {
        Completer() {
            super(null, 1);
        }
        public final void compute() { }
        public final void onCompletion(CountedCompleter<?> t) {
            System.out.println( "Completed" );
        }
    }
    static final class MasterCompleter extends CountedCompleter<Void> {
        MasterCompleter() {
            super(null, 1);
        }
        public final void compute() { tryComplete(); }
    }
    static final class MasterSocketReceiver extends CountedCompleter<Void> {
        Completer c = null;
        MasterSocketReceiver(CountedCompleter<?> completer ) {
            super( completer );
        }
        public final void compute() {
            MasterSocketReceiver msr = new MasterSocketReceiver( new
MasterCompleter());
            msr.fork();
            SlaveSocketReceiver ssr = new SlaveSocketReceiver( new
Completer() );
            ssr.tryComplete();
            System.out.println( "MasterSocketReceiver" );
        }
    }

    static final class SlaveSocketReceiver extends CountedCompleter<Void> {
        SlaveSocketReceiver(CountedCompleter<?> completer ) {
            super( completer );
        }
        @Override
        public void compute() {
            //addToPendingCount(1);
            tryComplete();
            System.out.println( "SlaveSocketReceiver" );
        }
    }

}



On Thu, Aug 16, 2012 at 6:12 PM, Doug Lea <dl at cs.oswego.edu> wrote:

>
> While the most common use cases for CountedCompleters are for
> void actions, there is no good reason to force them to be.
> Several people have wanted to use result-bearing forms, so
> they now support this.
>
> They now can/should/must be declared as CountedCompleter<T>,
> and you can override method getRawResult to return any appropriate
> result that will be relayed to any call to invoke, join, etc.
>
> Unlike the case of RecursiveTask<T>, we have no idea how you are
> representing result values, so the protected setRawResult(T x)
> method is by default a no-op. You can override this if desired
> to do some sort of result maintenance, but typically won't.
>
> This turns out to be a binary-compatible change, so there's
> no need to adjust existing usages immediately. And it is even
> source compatible, although will encounter may "raw type"
> compiler warnings.
>
> At some point, you'll want to replace
>   class MyCC extends CountedCompleter
> with
>   class MyCC extends CountedCompleter<Void>
>
> and constructors of form
>   MyCC(CountedCompleter p, ...) { super(p); ...}
> with
>   MyCC(CountedCompleter<?> p, ...) { super(p); ...}
> and similarly for any other methods accepting CountedCompleters).
>
> This change is now in jsr166y, jsr166e, and j.u.c jars and sources.
>
> -Doug
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/514d27af/attachment.html>

From vitalyd at gmail.com  Mon Aug 20 07:45:24 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 20 Aug 2012 07:45:24 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
Message-ID: <CAHjP37HvpnqagdYXG7WVG5+Db3fke-fMCAacsr9c4xv5Mcx72A@mail.gmail.com>

I think James was talking about publishing via data race, in which case it
would indeed be a problem with that version.

Sent from my phone
On Aug 20, 2012 7:41 AM, "Sergey Kuksenko" <skuksenko at gmail.com> wrote:

> Hi James,
>
> - Look into jdk8 sources. New  BigDecimal has final fields (instead of
> volatile).
> - Could you explain what is the issue for safe publication in the old code
> (look like everything is ok)?
>
> On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
>
>> I'm wondering whether the BigDecimal constructors that take a MathContext
>> parameter exhibit initialization safety.  As far as I can tell (and I could
>> be very wrong), BigDecimal is relying on the volatile nature of the intVal
>> reference to ensure the BigDecimal is effectively immutable.  However, the
>> constructors that take a MathContext delegate to the following method,
>> which alters other members after intVal:
>>
>>     private void roundThis(MathContext mc) {
>>         BigDecimal rounded = doRound(this, mc);
>>         if (rounded == this)                 // wasn't rounded
>>             return;
>>         this.intVal     = rounded.intVal;
>>         this.intCompact = rounded.intCompact;
>>         this.scale      = rounded.scale;
>>         this.precision  = rounded.precision;
>>     }
>>
>> Is this a potential issue for safe publication or am I missing something?
>> Is BigDecimal intended to exhibit initialization safety?
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> --
> Best regards,
> Sergey Kuksenko
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/a51f1e70/attachment.html>

From james at inaseq.com  Mon Aug 20 07:49:34 2012
From: james at inaseq.com (James)
Date: Mon, 20 Aug 2012 07:49:34 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
Message-ID: <1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>

I have a system that processes a lot of Doubles.  From time to time I need the accuracy of BigDecimal math but creating a BigDecimal is relatively expensive so I only do it when needed.  Hence I use lazy initialization as shown below.

private Double price;  // although not final is effectively immutable and guaranteed non-null when used below
private transient BigDecimal priceBD;

public BigDecimal getPriceBD() {
if (priceBD == null) {
priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not required
}
return priceBD;
}

This particular construction method does not use one of the MathContext based constructors but it was while investigating the thread safety of this approach that I noticed that some of the constructors may not be safe.

My concern is whether using this technique a second thread might see a BigDecimal that is not fully initialized.  I'm pretty sure it can, but it wouldn't matter if the volatile intVal is enforcing happens-before in subsequent calls to the BigDecimal, however the constructors that delegate to the method mentioned do things after setting the intVal.

On 20 Aug 2012, at 12:32, Sergey Kuksenko <skuksenko at gmail.com<mailto:skuksenko at gmail.com>> wrote:

Hi James,

- Look into jdk8 sources. New  BigDecimal has final fields (instead of volatile).
- Could you explain what is the issue for safe publication in the old code (look like everything is ok)?

On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com<mailto:james at inaseq.com>> wrote:
I'm wondering whether the BigDecimal constructors that take a MathContext parameter exhibit initialization safety.  As far as I can tell (and I could be very wrong), BigDecimal is relying on the volatile nature of the intVal reference to ensure the BigDecimal is effectively immutable.  However, the constructors that take a MathContext delegate to the following method, which alters other members after intVal:

    private void roundThis(MathContext mc) {
        BigDecimal rounded = doRound(this, mc);
        if (rounded == this)                 // wasn't rounded
            return;
        this.intVal     = rounded.intVal;
        this.intCompact = rounded.intCompact;
        this.scale      = rounded.scale;
        this.precision  = rounded.precision;
    }

Is this a potential issue for safe publication or am I missing something?
Is BigDecimal intended to exhibit initialization safety?
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



--
Best regards,
Sergey Kuksenko

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/1d4ffd9a/attachment-0001.html>

From james at inaseq.com  Mon Aug 20 07:51:01 2012
From: james at inaseq.com (James)
Date: Mon, 20 Aug 2012 07:51:01 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CAHjP37HvpnqagdYXG7WVG5+Db3fke-fMCAacsr9c4xv5Mcx72A@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<CAHjP37HvpnqagdYXG7WVG5+Db3fke-fMCAacsr9c4xv5Mcx72A@mail.gmail.com>
Message-ID: <16D6AE82-F340-4E20-8404-9769289D9A48@inaseq.com>

Vitaly,

Am I correct that the constructors that don't delegate to this method are safe to publish without further protection?

On 20 Aug 2012, at 12:45, Vitaly Davidovich <vitalyd at gmail.com<mailto:vitalyd at gmail.com>> wrote:


I think James was talking about publishing via data race, in which case it would indeed be a problem with that version.

Sent from my phone

On Aug 20, 2012 7:41 AM, "Sergey Kuksenko" <skuksenko at gmail.com<mailto:skuksenko at gmail.com>> wrote:
Hi James,

- Look into jdk8 sources. New  BigDecimal has final fields (instead of volatile).
- Could you explain what is the issue for safe publication in the old code (look like everything is ok)?

On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com<mailto:james at inaseq.com>> wrote:
I'm wondering whether the BigDecimal constructors that take a MathContext parameter exhibit initialization safety.  As far as I can tell (and I could be very wrong), BigDecimal is relying on the volatile nature of the intVal reference to ensure the BigDecimal is effectively immutable.  However, the constructors that take a MathContext delegate to the following method, which alters other members after intVal:

    private void roundThis(MathContext mc) {
        BigDecimal rounded = doRound(this, mc);
        if (rounded == this)                 // wasn't rounded
            return;
        this.intVal     = rounded.intVal;
        this.intCompact = rounded.intCompact;
        this.scale      = rounded.scale;
        this.precision  = rounded.precision;
    }

Is this a potential issue for safe publication or am I missing something?
Is BigDecimal intended to exhibit initialization safety?
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



--
Best regards,
Sergey Kuksenko

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/9982ec9b/attachment.html>

From vitalyd at gmail.com  Mon Aug 20 07:53:16 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 20 Aug 2012 07:53:16 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <16D6AE82-F340-4E20-8404-9769289D9A48@inaseq.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<CAHjP37HvpnqagdYXG7WVG5+Db3fke-fMCAacsr9c4xv5Mcx72A@mail.gmail.com>
	<16D6AE82-F340-4E20-8404-9769289D9A48@inaseq.com>
Message-ID: <CAHjP37FJQ6S+YuEK-Ya5iRks0eHWW1VeAZchGZOhpL5czdH1yQ@mail.gmail.com>

Not really as those fields will need to be final, as in jdk 8 sounds like,
to allow publishing via data race.

Sent from my phone
On Aug 20, 2012 7:51 AM, "James" <james at inaseq.com> wrote:

> Vitaly,
>
> Am I correct that the constructors that don't delegate to this method are
> safe to publish without further protection?
>
> On 20 Aug 2012, at 12:45, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> I think James was talking about publishing via data race, in which case it
> would indeed be a problem with that version.
>
> Sent from my phone
> On Aug 20, 2012 7:41 AM, "Sergey Kuksenko" <skuksenko at gmail.com> wrote:
>
>> Hi James,
>>
>> - Look into jdk8 sources. New  BigDecimal has final fields (instead of
>> volatile).
>> - Could you explain what is the issue for safe publication in the old
>> code (look like everything is ok)?
>>
>> On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
>>
>>> I'm wondering whether the BigDecimal constructors that take a
>>> MathContext parameter exhibit initialization safety.  As far as I can tell
>>> (and I could be very wrong), BigDecimal is relying on the volatile nature
>>> of the intVal reference to ensure the BigDecimal is effectively immutable.
>>>  However, the constructors that take a MathContext delegate to the
>>> following method, which alters other members after intVal:
>>>
>>>     private void roundThis(MathContext mc) {
>>>         BigDecimal rounded = doRound(this, mc);
>>>         if (rounded == this)                 // wasn't rounded
>>>             return;
>>>         this.intVal     = rounded.intVal;
>>>         this.intCompact = rounded.intCompact;
>>>         this.scale      = rounded.scale;
>>>         this.precision  = rounded.precision;
>>>     }
>>>
>>> Is this a potential issue for safe publication or am I missing something?
>>> Is BigDecimal intended to exhibit initialization safety?
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>>
>> --
>> Best regards,
>> Sergey Kuksenko
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/bea31621/attachment.html>

From vitalyd at gmail.com  Mon Aug 20 07:55:15 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 20 Aug 2012 07:55:15 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
Message-ID: <CAHjP37EnZw3bmvd8=OmCyHS76UdxyiB_EdgYGArDRvsxfPFT1g@mail.gmail.com>

How are you publishing the BD instance to other threads?

Sent from my phone
On Aug 20, 2012 7:52 AM, "James" <james at inaseq.com> wrote:

> I have a system that processes a lot of Doubles.  From time to time I need
> the accuracy of BigDecimal math but creating a BigDecimal is relatively
> expensive so I only do it when needed.  Hence I use lazy initialization as
> shown below.
>
> private Double price;  // although not final is effectively immutable and
> guaranteed non-null when used below
> private transient BigDecimal priceBD;
>
> public BigDecimal getPriceBD() {
> if (priceBD == null) {
> priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
> required
> }
> return priceBD;
> }
>
> This particular construction method does not use one of the MathContext
> based constructors but it was while investigating the thread safety of this
> approach that I noticed that some of the constructors may not be safe.
>
> My concern is whether using this technique a second thread might see a
> BigDecimal that is not fully initialized.  I'm pretty sure it can, but it
> wouldn't matter if the volatile intVal is enforcing happens-before in
> subsequent calls to the BigDecimal, however the constructors that delegate
> to the method mentioned do things after setting the intVal.
>
> On 20 Aug 2012, at 12:32, Sergey Kuksenko <skuksenko at gmail.com> wrote:
>
> Hi James,
>
> - Look into jdk8 sources. New  BigDecimal has final fields (instead of
> volatile).
> - Could you explain what is the issue for safe publication in the old code
> (look like everything is ok)?
>
> On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
>
>> I'm wondering whether the BigDecimal constructors that take a MathContext
>> parameter exhibit initialization safety.  As far as I can tell (and I could
>> be very wrong), BigDecimal is relying on the volatile nature of the intVal
>> reference to ensure the BigDecimal is effectively immutable.  However, the
>> constructors that take a MathContext delegate to the following method,
>> which alters other members after intVal:
>>
>>     private void roundThis(MathContext mc) {
>>         BigDecimal rounded = doRound(this, mc);
>>         if (rounded == this)                 // wasn't rounded
>>             return;
>>         this.intVal     = rounded.intVal;
>>         this.intCompact = rounded.intCompact;
>>         this.scale      = rounded.scale;
>>         this.precision  = rounded.precision;
>>     }
>>
>> Is this a potential issue for safe publication or am I missing something?
>> Is BigDecimal intended to exhibit initialization safety?
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> --
> Best regards,
> Sergey Kuksenko
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/d3543939/attachment.html>

From vitalyd at gmail.com  Mon Aug 20 07:56:38 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 20 Aug 2012 07:56:38 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CAHjP37EnZw3bmvd8=OmCyHS76UdxyiB_EdgYGArDRvsxfPFT1g@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
	<CAHjP37EnZw3bmvd8=OmCyHS76UdxyiB_EdgYGArDRvsxfPFT1g@mail.gmail.com>
Message-ID: <CAHjP37FLqR2bRaO1=7WtCt_pOs+owfQSnTn8D7wbPFuip0fqJA@mail.gmail.com>

Nevermind, I missed the field.  Yeah, this may not work since it's a data
race.

Sent from my phone
On Aug 20, 2012 7:55 AM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:

> How are you publishing the BD instance to other threads?
>
> Sent from my phone
> On Aug 20, 2012 7:52 AM, "James" <james at inaseq.com> wrote:
>
>> I have a system that processes a lot of Doubles.  From time to time I
>> need the accuracy of BigDecimal math but creating a BigDecimal is
>> relatively expensive so I only do it when needed.  Hence I use lazy
>> initialization as shown below.
>>
>> private Double price;  // although not final is effectively immutable and
>> guaranteed non-null when used below
>> private transient BigDecimal priceBD;
>>
>> public BigDecimal getPriceBD() {
>> if (priceBD == null) {
>> priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
>> required
>>  }
>> return priceBD;
>> }
>>
>> This particular construction method does not use one of the MathContext
>> based constructors but it was while investigating the thread safety of this
>> approach that I noticed that some of the constructors may not be safe.
>>
>> My concern is whether using this technique a second thread might see a
>> BigDecimal that is not fully initialized.  I'm pretty sure it can, but it
>> wouldn't matter if the volatile intVal is enforcing happens-before in
>> subsequent calls to the BigDecimal, however the constructors that delegate
>> to the method mentioned do things after setting the intVal.
>>
>> On 20 Aug 2012, at 12:32, Sergey Kuksenko <skuksenko at gmail.com> wrote:
>>
>> Hi James,
>>
>> - Look into jdk8 sources. New  BigDecimal has final fields (instead of
>> volatile).
>> - Could you explain what is the issue for safe publication in the old
>> code (look like everything is ok)?
>>
>> On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
>>
>>> I'm wondering whether the BigDecimal constructors that take a
>>> MathContext parameter exhibit initialization safety.  As far as I can tell
>>> (and I could be very wrong), BigDecimal is relying on the volatile nature
>>> of the intVal reference to ensure the BigDecimal is effectively immutable.
>>>  However, the constructors that take a MathContext delegate to the
>>> following method, which alters other members after intVal:
>>>
>>>     private void roundThis(MathContext mc) {
>>>         BigDecimal rounded = doRound(this, mc);
>>>         if (rounded == this)                 // wasn't rounded
>>>             return;
>>>         this.intVal     = rounded.intVal;
>>>         this.intCompact = rounded.intCompact;
>>>         this.scale      = rounded.scale;
>>>         this.precision  = rounded.precision;
>>>     }
>>>
>>> Is this a potential issue for safe publication or am I missing something?
>>> Is BigDecimal intended to exhibit initialization safety?
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>>
>> --
>> Best regards,
>> Sergey Kuksenko
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/8531a848/attachment-0001.html>

From vitalyd at gmail.com  Mon Aug 20 07:59:08 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 20 Aug 2012 07:59:08 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CAHjP37FLqR2bRaO1=7WtCt_pOs+owfQSnTn8D7wbPFuip0fqJA@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
	<CAHjP37EnZw3bmvd8=OmCyHS76UdxyiB_EdgYGArDRvsxfPFT1g@mail.gmail.com>
	<CAHjP37FLqR2bRaO1=7WtCt_pOs+owfQSnTn8D7wbPFuip0fqJA@mail.gmail.com>
Message-ID: <CAHjP37E-rnQkXDzEZVmG-P1eGJ3a3o5LrW0kwcwneBwLbUbYiA@mail.gmail.com>

My suggestion is to use AtomicReference.lazySet for publishing like this,
if you can tolerate the extra memory overhead.

Sent from my phone
On Aug 20, 2012 7:56 AM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:

> Nevermind, I missed the field.  Yeah, this may not work since it's a data
> race.
>
> Sent from my phone
> On Aug 20, 2012 7:55 AM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:
>
>> How are you publishing the BD instance to other threads?
>>
>> Sent from my phone
>> On Aug 20, 2012 7:52 AM, "James" <james at inaseq.com> wrote:
>>
>>> I have a system that processes a lot of Doubles.  From time to time I
>>> need the accuracy of BigDecimal math but creating a BigDecimal is
>>> relatively expensive so I only do it when needed.  Hence I use lazy
>>> initialization as shown below.
>>>
>>> private Double price;  // although not final is effectively immutable
>>> and guaranteed non-null when used below
>>> private transient BigDecimal priceBD;
>>>
>>> public BigDecimal getPriceBD() {
>>> if (priceBD == null) {
>>> priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
>>> required
>>>  }
>>> return priceBD;
>>> }
>>>
>>> This particular construction method does not use one of the MathContext
>>> based constructors but it was while investigating the thread safety of this
>>> approach that I noticed that some of the constructors may not be safe.
>>>
>>> My concern is whether using this technique a second thread might see a
>>> BigDecimal that is not fully initialized.  I'm pretty sure it can, but it
>>> wouldn't matter if the volatile intVal is enforcing happens-before in
>>> subsequent calls to the BigDecimal, however the constructors that delegate
>>> to the method mentioned do things after setting the intVal.
>>>
>>> On 20 Aug 2012, at 12:32, Sergey Kuksenko <skuksenko at gmail.com> wrote:
>>>
>>> Hi James,
>>>
>>> - Look into jdk8 sources. New  BigDecimal has final fields (instead of
>>> volatile).
>>> - Could you explain what is the issue for safe publication in the old
>>> code (look like everything is ok)?
>>>
>>> On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
>>>
>>>> I'm wondering whether the BigDecimal constructors that take a
>>>> MathContext parameter exhibit initialization safety.  As far as I can tell
>>>> (and I could be very wrong), BigDecimal is relying on the volatile nature
>>>> of the intVal reference to ensure the BigDecimal is effectively immutable.
>>>>  However, the constructors that take a MathContext delegate to the
>>>> following method, which alters other members after intVal:
>>>>
>>>>     private void roundThis(MathContext mc) {
>>>>         BigDecimal rounded = doRound(this, mc);
>>>>         if (rounded == this)                 // wasn't rounded
>>>>             return;
>>>>         this.intVal     = rounded.intVal;
>>>>         this.intCompact = rounded.intCompact;
>>>>         this.scale      = rounded.scale;
>>>>         this.precision  = rounded.precision;
>>>>     }
>>>>
>>>> Is this a potential issue for safe publication or am I missing
>>>> something?
>>>> Is BigDecimal intended to exhibit initialization safety?
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>>
>>>
>>> --
>>> Best regards,
>>> Sergey Kuksenko
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/cf0a355d/attachment.html>

From vitalyd at gmail.com  Mon Aug 20 08:03:09 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 20 Aug 2012 08:03:09 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CAHjP37E-rnQkXDzEZVmG-P1eGJ3a3o5LrW0kwcwneBwLbUbYiA@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
	<CAHjP37EnZw3bmvd8=OmCyHS76UdxyiB_EdgYGArDRvsxfPFT1g@mail.gmail.com>
	<CAHjP37FLqR2bRaO1=7WtCt_pOs+owfQSnTn8D7wbPFuip0fqJA@mail.gmail.com>
	<CAHjP37E-rnQkXDzEZVmG-P1eGJ3a3o5LrW0kwcwneBwLbUbYiA@mail.gmail.com>
Message-ID: <CAHjP37H1yEEcd-4-oeKZVuxCgmyo=wfQKOek+q-kpxtk1d-ugA@mail.gmail.com>

And if mem overhead is an issue, can pull out the big gun,
Unsafe.putOrderedObject :).

Sent from my phone
On Aug 20, 2012 7:59 AM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:

> My suggestion is to use AtomicReference.lazySet for publishing like this,
> if you can tolerate the extra memory overhead.
>
> Sent from my phone
> On Aug 20, 2012 7:56 AM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:
>
>> Nevermind, I missed the field.  Yeah, this may not work since it's a data
>> race.
>>
>> Sent from my phone
>> On Aug 20, 2012 7:55 AM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:
>>
>>> How are you publishing the BD instance to other threads?
>>>
>>> Sent from my phone
>>> On Aug 20, 2012 7:52 AM, "James" <james at inaseq.com> wrote:
>>>
>>>> I have a system that processes a lot of Doubles.  From time to time I
>>>> need the accuracy of BigDecimal math but creating a BigDecimal is
>>>> relatively expensive so I only do it when needed.  Hence I use lazy
>>>> initialization as shown below.
>>>>
>>>> private Double price;  // although not final is effectively immutable
>>>> and guaranteed non-null when used below
>>>> private transient BigDecimal priceBD;
>>>>
>>>> public BigDecimal getPriceBD() {
>>>> if (priceBD == null) {
>>>> priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
>>>> required
>>>>  }
>>>> return priceBD;
>>>> }
>>>>
>>>> This particular construction method does not use one of the MathContext
>>>> based constructors but it was while investigating the thread safety of this
>>>> approach that I noticed that some of the constructors may not be safe.
>>>>
>>>> My concern is whether using this technique a second thread might see a
>>>> BigDecimal that is not fully initialized.  I'm pretty sure it can, but it
>>>> wouldn't matter if the volatile intVal is enforcing happens-before in
>>>> subsequent calls to the BigDecimal, however the constructors that delegate
>>>> to the method mentioned do things after setting the intVal.
>>>>
>>>> On 20 Aug 2012, at 12:32, Sergey Kuksenko <skuksenko at gmail.com> wrote:
>>>>
>>>> Hi James,
>>>>
>>>> - Look into jdk8 sources. New  BigDecimal has final fields (instead of
>>>> volatile).
>>>> - Could you explain what is the issue for safe publication in the old
>>>> code (look like everything is ok)?
>>>>
>>>> On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
>>>>
>>>>> I'm wondering whether the BigDecimal constructors that take a
>>>>> MathContext parameter exhibit initialization safety.  As far as I can tell
>>>>> (and I could be very wrong), BigDecimal is relying on the volatile nature
>>>>> of the intVal reference to ensure the BigDecimal is effectively immutable.
>>>>>  However, the constructors that take a MathContext delegate to the
>>>>> following method, which alters other members after intVal:
>>>>>
>>>>>     private void roundThis(MathContext mc) {
>>>>>         BigDecimal rounded = doRound(this, mc);
>>>>>         if (rounded == this)                 // wasn't rounded
>>>>>             return;
>>>>>         this.intVal     = rounded.intVal;
>>>>>         this.intCompact = rounded.intCompact;
>>>>>         this.scale      = rounded.scale;
>>>>>         this.precision  = rounded.precision;
>>>>>     }
>>>>>
>>>>> Is this a potential issue for safe publication or am I missing
>>>>> something?
>>>>> Is BigDecimal intended to exhibit initialization safety?
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>>
>>>>
>>>> --
>>>> Best regards,
>>>> Sergey Kuksenko
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/e27e6b5f/attachment.html>

From james at inaseq.com  Mon Aug 20 08:04:31 2012
From: james at inaseq.com (James)
Date: Mon, 20 Aug 2012 08:04:31 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CAHjP37E-rnQkXDzEZVmG-P1eGJ3a3o5LrW0kwcwneBwLbUbYiA@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
	<CAHjP37EnZw3bmvd8=OmCyHS76UdxyiB_EdgYGArDRvsxfPFT1g@mail.gmail.com>
	<CAHjP37FLqR2bRaO1=7WtCt_pOs+owfQSnTn8D7wbPFuip0fqJA@mail.gmail.com>
	<CAHjP37E-rnQkXDzEZVmG-P1eGJ3a3o5LrW0kwcwneBwLbUbYiA@mail.gmail.com>
Message-ID: <0D6D38DD-35FB-418F-A62E-7551230CCA5A@inaseq.com>

You'd prefer that over a synchronized block assuming low probability of contention?

On 20 Aug 2012, at 12:59, Vitaly Davidovich <vitalyd at gmail.com<mailto:vitalyd at gmail.com>> wrote:


My suggestion is to use AtomicReference.lazySet for publishing like this, if you can tolerate the extra memory overhead.

Sent from my phone

On Aug 20, 2012 7:56 AM, "Vitaly Davidovich" <vitalyd at gmail.com<mailto:vitalyd at gmail.com>> wrote:

Nevermind, I missed the field.  Yeah, this may not work since it's a data race.

Sent from my phone

On Aug 20, 2012 7:55 AM, "Vitaly Davidovich" <vitalyd at gmail.com<mailto:vitalyd at gmail.com>> wrote:

How are you publishing the BD instance to other threads?

Sent from my phone

On Aug 20, 2012 7:52 AM, "James" <james at inaseq.com<mailto:james at inaseq.com>> wrote:
I have a system that processes a lot of Doubles.  From time to time I need the accuracy of BigDecimal math but creating a BigDecimal is relatively expensive so I only do it when needed.  Hence I use lazy initialization as shown below.

private Double price;  // although not final is effectively immutable and guaranteed non-null when used below
private transient BigDecimal priceBD;

public BigDecimal getPriceBD() {
if (priceBD == null) {
priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not required
}
return priceBD;
}

This particular construction method does not use one of the MathContext based constructors but it was while investigating the thread safety of this approach that I noticed that some of the constructors may not be safe.

My concern is whether using this technique a second thread might see a BigDecimal that is not fully initialized.  I'm pretty sure it can, but it wouldn't matter if the volatile intVal is enforcing happens-before in subsequent calls to the BigDecimal, however the constructors that delegate to the method mentioned do things after setting the intVal.

On 20 Aug 2012, at 12:32, Sergey Kuksenko <skuksenko at gmail.com<mailto:skuksenko at gmail.com>> wrote:

Hi James,

- Look into jdk8 sources. New  BigDecimal has final fields (instead of volatile).
- Could you explain what is the issue for safe publication in the old code (look like everything is ok)?

On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com<mailto:james at inaseq.com>> wrote:
I'm wondering whether the BigDecimal constructors that take a MathContext parameter exhibit initialization safety.  As far as I can tell (and I could be very wrong), BigDecimal is relying on the volatile nature of the intVal reference to ensure the BigDecimal is effectively immutable.  However, the constructors that take a MathContext delegate to the following method, which alters other members after intVal:

    private void roundThis(MathContext mc) {
        BigDecimal rounded = doRound(this, mc);
        if (rounded == this)                 // wasn't rounded
            return;
        this.intVal     = rounded.intVal;
        this.intCompact = rounded.intCompact;
        this.scale      = rounded.scale;
        this.precision  = rounded.precision;
    }

Is this a potential issue for safe publication or am I missing something?
Is BigDecimal intended to exhibit initialization safety?
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



--
Best regards,
Sergey Kuksenko


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/115a2479/attachment-0001.html>

From skuksenko at gmail.com  Mon Aug 20 08:05:08 2012
From: skuksenko at gmail.com (Sergey Kuksenko)
Date: Mon, 20 Aug 2012 16:05:08 +0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CAHjP37HvpnqagdYXG7WVG5+Db3fke-fMCAacsr9c4xv5Mcx72A@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<CAHjP37HvpnqagdYXG7WVG5+Db3fke-fMCAacsr9c4xv5Mcx72A@mail.gmail.com>
Message-ID: <CAOBqY9D4ADBffUJqN65QJWogeFzP2x_AZWrXX40+7qRED5cK+w@mail.gmail.com>

Publishing via data race would be a problem with a lot classes. Just Don't
do it. :)

On Mon, Aug 20, 2012 at 3:45 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:

> I think James was talking about publishing via data race, in which case it
> would indeed be a problem with that version.
>
> Sent from my phone
> On Aug 20, 2012 7:41 AM, "Sergey Kuksenko" <skuksenko at gmail.com> wrote:
>
>> Hi James,
>>
>> - Look into jdk8 sources. New  BigDecimal has final fields (instead of
>> volatile).
>> - Could you explain what is the issue for safe publication in the old
>> code (look like everything is ok)?
>>
>> On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
>>
>>> I'm wondering whether the BigDecimal constructors that take a
>>> MathContext parameter exhibit initialization safety.  As far as I can tell
>>> (and I could be very wrong), BigDecimal is relying on the volatile nature
>>> of the intVal reference to ensure the BigDecimal is effectively immutable.
>>>  However, the constructors that take a MathContext delegate to the
>>> following method, which alters other members after intVal:
>>>
>>>     private void roundThis(MathContext mc) {
>>>         BigDecimal rounded = doRound(this, mc);
>>>         if (rounded == this)                 // wasn't rounded
>>>             return;
>>>         this.intVal     = rounded.intVal;
>>>         this.intCompact = rounded.intCompact;
>>>         this.scale      = rounded.scale;
>>>         this.precision  = rounded.precision;
>>>     }
>>>
>>> Is this a potential issue for safe publication or am I missing something?
>>> Is BigDecimal intended to exhibit initialization safety?
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>>
>> --
>> Best regards,
>> Sergey Kuksenko
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>


-- 
Best regards,
Sergey Kuksenko
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/10e8a0a3/attachment.html>

From vitalyd at gmail.com  Mon Aug 20 08:07:41 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 20 Aug 2012 08:07:41 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <0D6D38DD-35FB-418F-A62E-7551230CCA5A@inaseq.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
	<CAHjP37EnZw3bmvd8=OmCyHS76UdxyiB_EdgYGArDRvsxfPFT1g@mail.gmail.com>
	<CAHjP37FLqR2bRaO1=7WtCt_pOs+owfQSnTn8D7wbPFuip0fqJA@mail.gmail.com>
	<CAHjP37E-rnQkXDzEZVmG-P1eGJ3a3o5LrW0kwcwneBwLbUbYiA@mail.gmail.com>
	<0D6D38DD-35FB-418F-A62E-7551230CCA5A@inaseq.com>
Message-ID: <CAHjP37EwTnDKh-O=y5FARtHW6czrPmn-3EmHbD9oDS_NSVqLHw@mail.gmail.com>

I assumed you didn't do synchronized in the first place for contention
reasons :).  I'd go with synch - low contention is almost free in that case.

Sent from my phone
On Aug 20, 2012 8:04 AM, "James" <james at inaseq.com> wrote:

> You'd prefer that over a synchronized block assuming low probability of
> contention?
>
> On 20 Aug 2012, at 12:59, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> My suggestion is to use AtomicReference.lazySet for publishing like this,
> if you can tolerate the extra memory overhead.
>
> Sent from my phone
> On Aug 20, 2012 7:56 AM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:
>
>> Nevermind, I missed the field.  Yeah, this may not work since it's a data
>> race.
>>
>> Sent from my phone
>> On Aug 20, 2012 7:55 AM, "Vitaly Davidovich" <vitalyd at gmail.com> wrote:
>>
>>> How are you publishing the BD instance to other threads?
>>>
>>> Sent from my phone
>>> On Aug 20, 2012 7:52 AM, "James" <james at inaseq.com> wrote:
>>>
>>>> I have a system that processes a lot of Doubles.  From time to time I
>>>> need the accuracy of BigDecimal math but creating a BigDecimal is
>>>> relatively expensive so I only do it when needed.  Hence I use lazy
>>>> initialization as shown below.
>>>>
>>>> private Double price;  // although not final is effectively immutable
>>>> and guaranteed non-null when used below
>>>> private transient BigDecimal priceBD;
>>>>
>>>> public BigDecimal getPriceBD() {
>>>> if (priceBD == null) {
>>>> priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
>>>> required
>>>>  }
>>>> return priceBD;
>>>> }
>>>>
>>>> This particular construction method does not use one of the MathContext
>>>> based constructors but it was while investigating the thread safety of this
>>>> approach that I noticed that some of the constructors may not be safe.
>>>>
>>>> My concern is whether using this technique a second thread might see a
>>>> BigDecimal that is not fully initialized.  I'm pretty sure it can, but it
>>>> wouldn't matter if the volatile intVal is enforcing happens-before in
>>>> subsequent calls to the BigDecimal, however the constructors that delegate
>>>> to the method mentioned do things after setting the intVal.
>>>>
>>>> On 20 Aug 2012, at 12:32, Sergey Kuksenko <skuksenko at gmail.com> wrote:
>>>>
>>>> Hi James,
>>>>
>>>> - Look into jdk8 sources. New  BigDecimal has final fields (instead of
>>>> volatile).
>>>> - Could you explain what is the issue for safe publication in the old
>>>> code (look like everything is ok)?
>>>>
>>>> On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
>>>>
>>>>> I'm wondering whether the BigDecimal constructors that take a
>>>>> MathContext parameter exhibit initialization safety.  As far as I can tell
>>>>> (and I could be very wrong), BigDecimal is relying on the volatile nature
>>>>> of the intVal reference to ensure the BigDecimal is effectively immutable.
>>>>>  However, the constructors that take a MathContext delegate to the
>>>>> following method, which alters other members after intVal:
>>>>>
>>>>>     private void roundThis(MathContext mc) {
>>>>>         BigDecimal rounded = doRound(this, mc);
>>>>>         if (rounded == this)                 // wasn't rounded
>>>>>             return;
>>>>>         this.intVal     = rounded.intVal;
>>>>>         this.intCompact = rounded.intCompact;
>>>>>         this.scale      = rounded.scale;
>>>>>         this.precision  = rounded.precision;
>>>>>     }
>>>>>
>>>>> Is this a potential issue for safe publication or am I missing
>>>>> something?
>>>>> Is BigDecimal intended to exhibit initialization safety?
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>>
>>>>
>>>> --
>>>> Best regards,
>>>> Sergey Kuksenko
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/1ae39e60/attachment.html>

From vitalyd at gmail.com  Mon Aug 20 08:14:04 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 20 Aug 2012 08:14:04 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CAOBqY9D4ADBffUJqN65QJWogeFzP2x_AZWrXX40+7qRED5cK+w@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<CAHjP37HvpnqagdYXG7WVG5+Db3fke-fMCAacsr9c4xv5Mcx72A@mail.gmail.com>
	<CAOBqY9D4ADBffUJqN65QJWogeFzP2x_AZWrXX40+7qRED5cK+w@mail.gmail.com>
Message-ID: <CAHjP37GOmdf0wUO=7yV4Q2TPFCPy-zV64Z6GCMM7AOm2yf+_uA@mail.gmail.com>

Indeed, that seems to be the advice of this month on this list. :)

Sent from my phone
On Aug 20, 2012 8:05 AM, "Sergey Kuksenko" <skuksenko at gmail.com> wrote:

> Publishing via data race would be a problem with a lot classes. Just Don't
> do it. :)
>
> On Mon, Aug 20, 2012 at 3:45 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>
>> I think James was talking about publishing via data race, in which case
>> it would indeed be a problem with that version.
>>
>> Sent from my phone
>> On Aug 20, 2012 7:41 AM, "Sergey Kuksenko" <skuksenko at gmail.com> wrote:
>>
>>> Hi James,
>>>
>>> - Look into jdk8 sources. New  BigDecimal has final fields (instead of
>>> volatile).
>>> - Could you explain what is the issue for safe publication in the old
>>> code (look like everything is ok)?
>>>
>>> On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
>>>
>>>> I'm wondering whether the BigDecimal constructors that take a
>>>> MathContext parameter exhibit initialization safety.  As far as I can tell
>>>> (and I could be very wrong), BigDecimal is relying on the volatile nature
>>>> of the intVal reference to ensure the BigDecimal is effectively immutable.
>>>>  However, the constructors that take a MathContext delegate to the
>>>> following method, which alters other members after intVal:
>>>>
>>>>     private void roundThis(MathContext mc) {
>>>>         BigDecimal rounded = doRound(this, mc);
>>>>         if (rounded == this)                 // wasn't rounded
>>>>             return;
>>>>         this.intVal     = rounded.intVal;
>>>>         this.intCompact = rounded.intCompact;
>>>>         this.scale      = rounded.scale;
>>>>         this.precision  = rounded.precision;
>>>>     }
>>>>
>>>> Is this a potential issue for safe publication or am I missing
>>>> something?
>>>> Is BigDecimal intended to exhibit initialization safety?
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>>
>>>
>>> --
>>> Best regards,
>>> Sergey Kuksenko
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>
>
> --
> Best regards,
> Sergey Kuksenko
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/a20ad767/attachment-0001.html>

From dl at cs.oswego.edu  Mon Aug 20 10:49:09 2012
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 20 Aug 2012 10:49:09 -0400
Subject: [concurrency-interest] Parameterized CountedCompleters
In-Reply-To: <CAOoXFP_ZN1a+Ru=US06ibSRdbjfQG=0imsyVej8FOYM6o7VGJQ@mail.gmail.com>
References: <502CEAAB.8040809@cs.oswego.edu>
	<CAOoXFP_ZN1a+Ru=US06ibSRdbjfQG=0imsyVej8FOYM6o7VGJQ@mail.gmail.com>
Message-ID: <50324E65.6060007@cs.oswego.edu>

On 08/20/12 07:35, Mohan Radhakrishnan wrote:
> Hi,
> I have some questions from the perspective of a programmer using this. for
> general development. ...
> Applicability
> # More well-behaved than RecursiveAction when tasks block ( Is there more
> explanation for why they are well behaved ? )

Like other completion-based design patterns (google will find some
descriptions), the main problem they avoid in Future-based programming
is that if some task1 is blocked in IO, and some other task2
is joining task1 then task2 is also blocked. Eventually this can
tie up a lot of tasks/threads. The solution amounts to having task2 ask
task1 to do whatever task2 would have done after the join --
task2 is then no longer involved. CountedCompleters add one more
bit of control versus other completion  frameworks:
you can ask that a number of other tasks complete, not just
one, before performing the completion action. This enables recursive,
tree-style and other uses.


>          public final void compute() {
>              MasterSocketReceiver msr = new MasterSocketReceiver( new
> MasterCompleter());
>              msr.fork();
>              SlaveSocketReceiver ssr = new SlaveSocketReceiver( new Completer() );
>              ssr.tryComplete();
>              System.out.println( "MasterSocketReceiver" );
>          }
>      }

I don't offhand understand your intent here, but calling tryComplete
on some other task is very rarely appropriate.

-Doug

From zhong.j.yu at gmail.com  Mon Aug 20 13:58:04 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Mon, 20 Aug 2012 12:58:04 -0500
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
Message-ID: <CACuKZqHLSOa8zH3NAvNzcHmkV_+Eriy2MnEoRm2dD1OjhEpaYA@mail.gmail.com>

On Mon, Aug 20, 2012 at 6:49 AM, James <james at inaseq.com> wrote:
> I have a system that processes a lot of Doubles.  From time to time I need
> the accuracy of BigDecimal math but creating a BigDecimal is relatively
> expensive so I only do it when needed.  Hence I use lazy initialization as
> shown below.
>
> private Double price;  // although not final is effectively immutable and
> guaranteed non-null when used below
> private transient BigDecimal priceBD;
>
> public BigDecimal getPriceBD() {
> if (priceBD == null) {
> priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
> required
> }
> return priceBD;
> }

You may have omitted it for brevity, but a local variable is necessary
here for correctness. See String.hashCode()

> This particular construction method does not use one of the MathContext
> based constructors but it was while investigating the thread safety of this
> approach that I noticed that some of the constructors may not be safe.
>
> My concern is whether using this technique a second thread might see a
> BigDecimal that is not fully initialized.  I'm pretty sure it can, but it
> wouldn't matter if the volatile intVal is enforcing happens-before in
> subsequent calls to the BigDecimal, however the constructors that delegate
> to the method mentioned do things after setting the intVal.
>
> On 20 Aug 2012, at 12:32, Sergey Kuksenko <skuksenko at gmail.com> wrote:
>
> Hi James,
>
> - Look into jdk8 sources. New  BigDecimal has final fields (instead of
> volatile).
> - Could you explain what is the issue for safe publication in the old code
> (look like everything is ok)?
>
> On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
>>
>> I'm wondering whether the BigDecimal constructors that take a MathContext
>> parameter exhibit initialization safety.  As far as I can tell (and I could
>> be very wrong), BigDecimal is relying on the volatile nature of the intVal
>> reference to ensure the BigDecimal is effectively immutable.  However, the
>> constructors that take a MathContext delegate to the following method, which
>> alters other members after intVal:
>>
>>     private void roundThis(MathContext mc) {
>>         BigDecimal rounded = doRound(this, mc);
>>         if (rounded == this)                 // wasn't rounded
>>             return;
>>         this.intVal     = rounded.intVal;
>>         this.intCompact = rounded.intCompact;
>>         this.scale      = rounded.scale;
>>         this.precision  = rounded.precision;
>>     }
>>
>> Is this a potential issue for safe publication or am I missing something?
>> Is BigDecimal intended to exhibit initialization safety?
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> --
> Best regards,
> Sergey Kuksenko
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From zhong.j.yu at gmail.com  Mon Aug 20 14:01:41 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Mon, 20 Aug 2012 13:01:41 -0500
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CAHjP37GOmdf0wUO=7yV4Q2TPFCPy-zV64Z6GCMM7AOm2yf+_uA@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<CAHjP37HvpnqagdYXG7WVG5+Db3fke-fMCAacsr9c4xv5Mcx72A@mail.gmail.com>
	<CAOBqY9D4ADBffUJqN65QJWogeFzP2x_AZWrXX40+7qRED5cK+w@mail.gmail.com>
	<CAHjP37GOmdf0wUO=7yV4Q2TPFCPy-zV64Z6GCMM7AOm2yf+_uA@mail.gmail.com>
Message-ID: <CACuKZqHm6QoHWLFXrC2p_BpWTBZ0wdH1XDQUZ5V=qsYEiMpzHg@mail.gmail.com>

The advice is a little hard to follow, since both tricks, publish
through volatile reference, and publish immutable objects, contain
data race by JMM's definition.

On Mon, Aug 20, 2012 at 7:14 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> Indeed, that seems to be the advice of this month on this list. :)
>
> Sent from my phone
>
> On Aug 20, 2012 8:05 AM, "Sergey Kuksenko" <skuksenko at gmail.com> wrote:
>>
>> Publishing via data race would be a problem with a lot classes. Just Don't
>> do it. :)
>>
>> On Mon, Aug 20, 2012 at 3:45 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>>>
>>> I think James was talking about publishing via data race, in which case
>>> it would indeed be a problem with that version.
>>>
>>> Sent from my phone
>>>
>>> On Aug 20, 2012 7:41 AM, "Sergey Kuksenko" <skuksenko at gmail.com> wrote:
>>>>
>>>> Hi James,
>>>>
>>>> - Look into jdk8 sources. New  BigDecimal has final fields (instead of
>>>> volatile).
>>>> - Could you explain what is the issue for safe publication in the old
>>>> code (look like everything is ok)?
>>>>
>>>> On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
>>>>>
>>>>> I'm wondering whether the BigDecimal constructors that take a
>>>>> MathContext parameter exhibit initialization safety.  As far as I can tell
>>>>> (and I could be very wrong), BigDecimal is relying on the volatile nature of
>>>>> the intVal reference to ensure the BigDecimal is effectively immutable.
>>>>> However, the constructors that take a MathContext delegate to the following
>>>>> method, which alters other members after intVal:
>>>>>
>>>>>     private void roundThis(MathContext mc) {
>>>>>         BigDecimal rounded = doRound(this, mc);
>>>>>         if (rounded == this)                 // wasn't rounded
>>>>>             return;
>>>>>         this.intVal     = rounded.intVal;
>>>>>         this.intCompact = rounded.intCompact;
>>>>>         this.scale      = rounded.scale;
>>>>>         this.precision  = rounded.precision;
>>>>>     }
>>>>>
>>>>> Is this a potential issue for safe publication or am I missing
>>>>> something?
>>>>> Is BigDecimal intended to exhibit initialization safety?
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>
>>>>
>>>> --
>>>> Best regards,
>>>> Sergey Kuksenko
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>
>>
>>
>> --
>> Best regards,
>> Sergey Kuksenko
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From hans.boehm at hp.com  Mon Aug 20 14:46:35 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Mon, 20 Aug 2012 18:46:35 +0000
Subject: [concurrency-interest] Relativity of guarantees provided
	by	volatile
In-Reply-To: <1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>

> From: Marko Topolnik
> 
> Yuval, rereading the earlier posts I noticed this one from you:
> 
> > That said, 17.4.3 does imply that the reads will be viewable in a
> wall-clock-sequential way, albeit informally
> >
> >     Sequential consistency is a very strong guarantee that is made
> about visibility and ordering in an execution of a program. Within a
> sequentially consistent execution, there is a total order over all
> individual actions (such as reads and writes) which is consistent with
> the order of the program, and each individual action is atomic and is
> immediately visible to every thread.
> >
> > (emphasis on "is immediately visible")
> 
> The major point to note is that the JLS **does not** enforce sequential
> consistency! It even spells it out directly below your quote:
> 
> "If we were to use sequential consistency as our memory model, many of
> the compiler and processor optimizations that we have discussed would
> be illegal."
> 
> The whole model of happens-before revolves around making sequentially
> INCONSISTENT executions APPEAR to be consistent, as observed by all
> executing threads, thus allowing all the optimizations that are
> discussed on this mailing list.
> 
It is intended to promise sequential consistency in the absence of data races. And the program Marko posted originally was data-race-free.  However, I don't believe there is a guarantee that the total ordering implied by sequential consistency is consistent with any means of retrieving the current time.  At least I haven't found such a claim.  Time retrieved on different processors may be out-of-sync, and has no implication on synchronization order.  That by itself can explain the behavior of the program that started this discussion.

If we changed the specification of currentTimeMillis() or the like so that it was guaranteed to access a volatile variable regularly updated by a "timer" thread, then the originally proposed behavior would no longer be allowed, since it would be compatible with any synchronization order for both the original and timer variables.  The problem is that timers don't appear to play by the same rules as variables.  Whether or not they should is unclear to me.

Hans


From hans.boehm at hp.com  Mon Aug 20 14:53:12 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Mon, 20 Aug 2012 18:53:12 +0000
Subject: [concurrency-interest] Relativity of guarantees provided by
 volatile
In-Reply-To: <AC31E334-DF08-4EA2-9285-D3DB12A71C05@inge-mark.hr>
References: <CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEDJJGAA.davidcholmes@aapt.net.au>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F6197D@G4W3296.americas.hpqcorp.net>
	<CACuKZqG6Jx+gs8hBwLHwjRX5mS7DD4FeFNux-3fop6QkqQRV4g@mail.gmail.com>
	<AC31E334-DF08-4EA2-9285-D3DB12A71C05@inge-mark.hr>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F61EC7@G4W3296.americas.hpqcorp.net>

> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr]
> > Interestingly, JMM also defines r_i and w_j to be in a data race,
> even
> > though they are all volatile.
> 
> This a very nice catch. Isn't in fact any read in a data race with all
> writes by another thread following the write it observed? That would
> make it impossible to write a program free of data races. In other
> words this sounds like a loophole in the definition of a data race.
> 
That's a bug in the wording of the spec.  I have a vague recollection that it was pointed out before a couple of years ago, possibly even on this list.  It's one of these things that should really be fixed, but is waiting for a resolution of the harder Java memory model issues.

Hans


From vitalyd at gmail.com  Mon Aug 20 15:35:35 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 20 Aug 2012 15:35:35 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CACuKZqHm6QoHWLFXrC2p_BpWTBZ0wdH1XDQUZ5V=qsYEiMpzHg@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<CAHjP37HvpnqagdYXG7WVG5+Db3fke-fMCAacsr9c4xv5Mcx72A@mail.gmail.com>
	<CAOBqY9D4ADBffUJqN65QJWogeFzP2x_AZWrXX40+7qRED5cK+w@mail.gmail.com>
	<CAHjP37GOmdf0wUO=7yV4Q2TPFCPy-zV64Z6GCMM7AOm2yf+_uA@mail.gmail.com>
	<CACuKZqHm6QoHWLFXrC2p_BpWTBZ0wdH1XDQUZ5V=qsYEiMpzHg@mail.gmail.com>
Message-ID: <CAHjP37Gc_20CoyTsGdfxHFACcHjY2dbOCmDSqOdOEiee4L9tFw@mail.gmail.com>

Publishing through volatile reference is not a data race - a lot of jdk
classes publish safely via a write/read through volatile, it's a valid
hand-off technique.  Can you explain why you think it's a data race?

Sent from my phone
On Aug 20, 2012 2:01 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:

> The advice is a little hard to follow, since both tricks, publish
> through volatile reference, and publish immutable objects, contain
> data race by JMM's definition.
>
> On Mon, Aug 20, 2012 at 7:14 AM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
> > Indeed, that seems to be the advice of this month on this list. :)
> >
> > Sent from my phone
> >
> > On Aug 20, 2012 8:05 AM, "Sergey Kuksenko" <skuksenko at gmail.com> wrote:
> >>
> >> Publishing via data race would be a problem with a lot classes. Just
> Don't
> >> do it. :)
> >>
> >> On Mon, Aug 20, 2012 at 3:45 PM, Vitaly Davidovich <vitalyd at gmail.com>
> >> wrote:
> >>>
> >>> I think James was talking about publishing via data race, in which case
> >>> it would indeed be a problem with that version.
> >>>
> >>> Sent from my phone
> >>>
> >>> On Aug 20, 2012 7:41 AM, "Sergey Kuksenko" <skuksenko at gmail.com>
> wrote:
> >>>>
> >>>> Hi James,
> >>>>
> >>>> - Look into jdk8 sources. New  BigDecimal has final fields (instead of
> >>>> volatile).
> >>>> - Could you explain what is the issue for safe publication in the old
> >>>> code (look like everything is ok)?
> >>>>
> >>>> On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
> >>>>>
> >>>>> I'm wondering whether the BigDecimal constructors that take a
> >>>>> MathContext parameter exhibit initialization safety.  As far as I
> can tell
> >>>>> (and I could be very wrong), BigDecimal is relying on the volatile
> nature of
> >>>>> the intVal reference to ensure the BigDecimal is effectively
> immutable.
> >>>>> However, the constructors that take a MathContext delegate to the
> following
> >>>>> method, which alters other members after intVal:
> >>>>>
> >>>>>     private void roundThis(MathContext mc) {
> >>>>>         BigDecimal rounded = doRound(this, mc);
> >>>>>         if (rounded == this)                 // wasn't rounded
> >>>>>             return;
> >>>>>         this.intVal     = rounded.intVal;
> >>>>>         this.intCompact = rounded.intCompact;
> >>>>>         this.scale      = rounded.scale;
> >>>>>         this.precision  = rounded.precision;
> >>>>>     }
> >>>>>
> >>>>> Is this a potential issue for safe publication or am I missing
> >>>>> something?
> >>>>> Is BigDecimal intended to exhibit initialization safety?
> >>>>> _______________________________________________
> >>>>> Concurrency-interest mailing list
> >>>>> Concurrency-interest at cs.oswego.edu
> >>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>
> >>>>
> >>>>
> >>>>
> >>>> --
> >>>> Best regards,
> >>>> Sergey Kuksenko
> >>>>
> >>>> _______________________________________________
> >>>> Concurrency-interest mailing list
> >>>> Concurrency-interest at cs.oswego.edu
> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>
> >>
> >>
> >>
> >> --
> >> Best regards,
> >> Sergey Kuksenko
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/a8aece0a/attachment-0001.html>

From vitalyd at gmail.com  Mon Aug 20 15:41:49 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 20 Aug 2012 15:41:49 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CACuKZqHLSOa8zH3NAvNzcHmkV_+Eriy2MnEoRm2dD1OjhEpaYA@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
	<CACuKZqHLSOa8zH3NAvNzcHmkV_+Eriy2MnEoRm2dD1OjhEpaYA@mail.gmail.com>
Message-ID: <CAHjP37E_PuCLsy0W401zzMHK_hx=sTdB=O-oz3vF8b9k70zPFg@mail.gmail.com>

Missing local variable is a problem, but the fact that BD cannot be
published via data race is the primary issue.  If it was safe for such
publishing, missing local would become the main issue. :)

Sent from my phone
On Aug 20, 2012 2:08 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:

> On Mon, Aug 20, 2012 at 6:49 AM, James <james at inaseq.com> wrote:
> > I have a system that processes a lot of Doubles.  From time to time I
> need
> > the accuracy of BigDecimal math but creating a BigDecimal is relatively
> > expensive so I only do it when needed.  Hence I use lazy initialization
> as
> > shown below.
> >
> > private Double price;  // although not final is effectively immutable and
> > guaranteed non-null when used below
> > private transient BigDecimal priceBD;
> >
> > public BigDecimal getPriceBD() {
> > if (priceBD == null) {
> > priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
> > required
> > }
> > return priceBD;
> > }
>
> You may have omitted it for brevity, but a local variable is necessary
> here for correctness. See String.hashCode()
>
> > This particular construction method does not use one of the MathContext
> > based constructors but it was while investigating the thread safety of
> this
> > approach that I noticed that some of the constructors may not be safe.
> >
> > My concern is whether using this technique a second thread might see a
> > BigDecimal that is not fully initialized.  I'm pretty sure it can, but it
> > wouldn't matter if the volatile intVal is enforcing happens-before in
> > subsequent calls to the BigDecimal, however the constructors that
> delegate
> > to the method mentioned do things after setting the intVal.
> >
> > On 20 Aug 2012, at 12:32, Sergey Kuksenko <skuksenko at gmail.com> wrote:
> >
> > Hi James,
> >
> > - Look into jdk8 sources. New  BigDecimal has final fields (instead of
> > volatile).
> > - Could you explain what is the issue for safe publication in the old
> code
> > (look like everything is ok)?
> >
> > On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
> >>
> >> I'm wondering whether the BigDecimal constructors that take a
> MathContext
> >> parameter exhibit initialization safety.  As far as I can tell (and I
> could
> >> be very wrong), BigDecimal is relying on the volatile nature of the
> intVal
> >> reference to ensure the BigDecimal is effectively immutable.  However,
> the
> >> constructors that take a MathContext delegate to the following method,
> which
> >> alters other members after intVal:
> >>
> >>     private void roundThis(MathContext mc) {
> >>         BigDecimal rounded = doRound(this, mc);
> >>         if (rounded == this)                 // wasn't rounded
> >>             return;
> >>         this.intVal     = rounded.intVal;
> >>         this.intCompact = rounded.intCompact;
> >>         this.scale      = rounded.scale;
> >>         this.precision  = rounded.precision;
> >>     }
> >>
> >> Is this a potential issue for safe publication or am I missing
> something?
> >> Is BigDecimal intended to exhibit initialization safety?
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> >
> > --
> > Best regards,
> > Sergey Kuksenko
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120820/2b3412e9/attachment.html>

From hans.boehm at hp.com  Mon Aug 20 17:20:24 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Mon, 20 Aug 2012 21:20:24 +0000
Subject: [concurrency-interest] Relativity of guarantees provided by
 volatile
In-Reply-To: <CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>

> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr]
> 
> In the meantime I have read the JMM again very carefully. These are the
> relevant conclusions:
> 
> Sequential consistency is an idealization that is not guaranteed in any
> way. Real implementations virtually never produce sequentially
> consistent executions.
Sequential consistency is not normally defined to have anything to do with timing.  Thus I don't understand the above statement.
> 
> There is a guarantee that a properly synchronized program will APPEAR
> to execute with sequential consistency. This appearance is, however,
> limited only to the observed ordering of actions and nothing else. In
> particular, no time ordering is guaranteed, promised, or even implied.
Right.  But time ordering is not really observable.  Values returned by currentTimeMillis() and the like are observable, but the specification is, AFAICT, unclear about the extent to which those values have to reflect any kind of real "time ordering".  I suspect that, at least on some machines, they use per-processors timers that are not perfectly synchronized.

> 
> > If we changed the specification of currentTimeMillis() or the like so
> that it was guaranteed to access a volatile variable regularly updated
> by a "timer" thread, then the originally proposed behavior would no
> longer be allowed, since it would be compatible with any
> synchronization order for both the original and timer variables.  The
> problem is that timers don't appear to play by the same rules as
> variables.  Whether or not they should is unclear to me.
> 
> It would be very bad for performance if they played by those rules, I
> think. In particular, a volatile var involves two distinct concepts:
> 
> - a hard guarantee of proper happens-before ordering of actions on it;
> 
> - a soft **promise** of timely publishing of write actions.
> 
> So the volatile concept is by its nature much more about ordering than
> about timing.
Maybe.  Having a thread in the kernel update the time values and having it play by Java volatile rules when writing the time value actually doesn't sound that expensive for a low resolution timer.  You will probably get a cache miss on the timer location from every core after every update, so it is likely to be a problem for high resolution timers or very high core counts.
> 
> >> This a very nice catch. Isn't in fact any read in a data race with
> all
> >> writes by another thread following the write it observed? That would
> >> make it impossible to write a program free of data races. In other
> >> words this sounds like a loophole in the definition of a data race.
> > That's a bug in the wording of the spec.  I have a vague recollection
> that it was pointed out before a couple of years ago, possibly even on
> this list.  It's one of these things that should really be fixed, but
> is waiting for a resolution of the harder Java memory model issues.
> 
> If you could remember any detail that would help me find this in the
> archives, I would be very grateful. Just now I am composing another
> question on StackOverflow that deals with this particular definition in
> the JLS. I have already concluded beyond doubt that the wording is off,
> however it is not at all clear how to fix it. The problem is with the
> word "program" in that definition because a program is not the entity
> that contains data races, it is its execution.
> 
I wasn't immediately able to find it with a mail search.  I'll let you know if I do.  Sorry.  Unfortunately, I had a mail accident around January 2010, and it's hard for me to search earlier mail.  It may also have been on the memory model list.  Maybe someone else remembers?

Hans



From radhakrishnan.mohan at gmail.com  Tue Aug 21 04:00:58 2012
From: radhakrishnan.mohan at gmail.com (Mohan Radhakrishnan)
Date: Tue, 21 Aug 2012 13:30:58 +0530
Subject: [concurrency-interest] Parameterized CountedCompleters
In-Reply-To: <50324E65.6060007@cs.oswego.edu>
References: <502CEAAB.8040809@cs.oswego.edu>
	<CAOoXFP_ZN1a+Ru=US06ibSRdbjfQG=0imsyVej8FOYM6o7VGJQ@mail.gmail.com>
	<50324E65.6060007@cs.oswego.edu>
Message-ID: <CAOoXFP8bmkjccrueJzyM8nFJRtD6oqyadz9r+6rqkxk365XjDg@mail.gmail.com>

Thanks.. This could be the precedent.
http://threadingbuildingblocks.org/docs/help/reference/task_scheduler.htm


Mohan

On Mon, Aug 20, 2012 at 8:19 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 08/20/12 07:35, Mohan Radhakrishnan wrote:
>
>> Hi,
>> I have some questions from the perspective of a programmer using this. for
>> general development. ...
>> Applicability
>> # More well-behaved than RecursiveAction when tasks block ( Is there more
>>
>> explanation for why they are well behaved ? )
>>
>
> Like other completion-based design patterns (google will find some
> descriptions), the main problem they avoid in Future-based programming
> is that if some task1 is blocked in IO, and some other task2
> is joining task1 then task2 is also blocked. Eventually this can
> tie up a lot of tasks/threads. The solution amounts to having task2 ask
> task1 to do whatever task2 would have done after the join --
> task2 is then no longer involved. CountedCompleters add one more
> bit of control versus other completion  frameworks:
> you can ask that a number of other tasks complete, not just
> one, before performing the completion action. This enables recursive,
> tree-style and other uses.
>
>
>
>          public final void compute() {
>>              MasterSocketReceiver msr = new MasterSocketReceiver( new
>> MasterCompleter());
>>              msr.fork();
>>              SlaveSocketReceiver ssr = new SlaveSocketReceiver( new
>> Completer() );
>>              ssr.tryComplete();
>>              System.out.println( "MasterSocketReceiver" );
>>          }
>>      }
>>
>
> I don't offhand understand your intent here, but calling tryComplete
> on some other task is very rarely appropriate.
>
>
> -Doug
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120821/40cd8129/attachment.html>

From mtopolnik at inge-mark.hr  Tue Aug 21 04:12:27 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Tue, 21 Aug 2012 10:12:27 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
Message-ID: <4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>

On 20. kol. 2012., at 23:20, Boehm, Hans wrote:

>> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr]
>> 
>> In the meantime I have read the JMM again very carefully. These are the
>> relevant conclusions:
>> 
>> Sequential consistency is an idealization that is not guaranteed in any
>> way. Real implementations virtually never produce sequentially
>> consistent executions.
> Sequential consistency is not normally defined to have anything to do with timing.  Thus I don't understand the above statement.

JLS uses this phrase: "each individual action is atomic and is immediately visible to every thread." That "immediately" sounds timing-related, but on second reading this is not necessary: it just implies visibility to all the following actions in the execution order, and the execution order itself is still not required to be consistent with wall-clock time.

>> There is a guarantee that a properly synchronized program will APPEAR
>> to execute with sequential consistency. This appearance is, however,
>> limited only to the observed ordering of actions and nothing else. In
>> particular, no time ordering is guaranteed, promised, or even implied.
> Right.  But time ordering is not really observable.  Values returned by currentTimeMillis() and the like are observable, but the specification is, AFAICT, unclear about the extent to which those values have to reflect any kind of real "time ordering".  I suspect that, at least on some machines, they use per-processors timers that are not perfectly synchronized.

Let's say that they could in theory be reflecting the exact time. We don't have to descend into the gory details of specific CPUs. Imagine a CPU specifically built to allow precise wall-clock time observation.

>> If you could remember any detail that would help me find this in the
>> archives, I would be very grateful. Just now I am composing another
>> question on StackOverflow that deals with this particular definition in
>> the JLS. I have already concluded beyond doubt that the wording is off,
>> however it is not at all clear how to fix it. The problem is with the
>> word "program" in that definition because a program is not the entity
>> that contains data races, it is its execution.
>> 
> I wasn't immediately able to find it with a mail search.  I'll let you know if I do.  Sorry.  Unfortunately, I had a mail accident around January 2010, and it's hard for me to search earlier mail.  It may also have been on the memory model list.  Maybe someone else remembers?

In the meantime I was successful in my own search. It is indeed on the Memory Model list:

http://www.cs.umd.edu/~pugh/java/memoryModel/archive/2483.html

It says

"a data race should be defined as conflicting actions on *non-volatile* variables 
that are not ordered by happens-before". 

Only with that addition is the loophole closed and even the original paper by Jeremy Manson and Bill Pugh doesn't close it. The need for the special case stems from the fact that volatile actions are asymmetric, as opposed to synchronized blocks, in terms of the pairing between acquire and release actions. 

-Marko



From hans.boehm at hp.com  Tue Aug 21 14:03:06 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Tue, 21 Aug 2012 18:03:06 +0000
Subject: [concurrency-interest] Relativity of guarantees provided
	by	volatile
In-Reply-To: <4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>

> From: Marko Topolnik
> On 20. kol. 2012., at 23:20, Boehm, Hans wrote:
> > Right.  But time ordering is not really observable.  Values returned
> by currentTimeMillis() and the like are observable, but the
> specification is, AFAICT, unclear about the extent to which those
> values have to reflect any kind of real "time ordering".  I suspect
> that, at least on some machines, they use per-processors timers that
> are not perfectly synchronized.
> 
> Let's say that they could in theory be reflecting the exact time. We
> don't have to descend into the gory details of specific CPUs. Imagine a
> CPU specifically built to allow precise wall-clock time observation.

Then I think it depends on how the CPU makes that time available to clients.
If it does it in a way that's equivalent to regularly updating a volatile
variable that can be read by all threads, then timing should work as expected.
I think the current specification for the timing functions is effectively
much weaker, because it's silent on the issues.

I think that if we agree this is a problem, then it could be fixed by
updating the specifications for the timing functions, without touching the
memory model per se.  I'm not sure I understand the implementation
implications of that, so I'm neither advocating it, nor lobbying against it.
The C++ specification is somewhere in the middle, and I remain a bit nervous
about implementability there.

Hans


From mtopolnik at inge-mark.hr  Tue Aug 21 15:13:16 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Tue, 21 Aug 2012 21:13:16 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
Message-ID: <BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>

On 21. kol. 2012., at 20:03, Boehm, Hans wrote:
>> Let's say that they could in theory be reflecting the exact time. We
>> don't have to descend into the gory details of specific CPUs. Imagine a
>> CPU specifically built to allow precise wall-clock time observation.
> 
> Then I think it depends on how the CPU makes that time available to clients.
> If it does it in a way that's equivalent to regularly updating a volatile
> variable that can be read by all threads, then timing should work as expected.
> I think the current specification for the timing functions is effectively
> much weaker, because it's silent on the issues.
> 
> I think that if we agree this is a problem, then it could be fixed by
> updating the specifications for the timing functions, without touching the
> memory model per se.  I'm not sure I understand the implementation
> implications of that, so I'm neither advocating it, nor lobbying against it.
> The C++ specification is somewhere in the middle, and I remain a bit nervous
> about implementability there.


I feel that this issue is not about actually calling any timing functions, but about the expectations on the timeliness of the visibility of volatile writes. Currently the programmer is left with a very vague and uncertain "general expectation" that volatile writes will be made visible "as soon as possible". It reminds me of the contract for Runtime.gc(). 

From zhong.j.yu at gmail.com  Tue Aug 21 17:33:14 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Tue, 21 Aug 2012 16:33:14 -0500
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>
Message-ID: <CACuKZqFgoFuePECcNWB6htMuteRdi2dxc+YtT1GaFexuhS0RTQ@mail.gmail.com>

On Tue, Aug 21, 2012 at 2:13 PM, Marko Topolnik <mtopolnik at inge-mark.hr> wrote:
> On 21. kol. 2012., at 20:03, Boehm, Hans wrote:
>>> Let's say that they could in theory be reflecting the exact time. We
>>> don't have to descend into the gory details of specific CPUs. Imagine a
>>> CPU specifically built to allow precise wall-clock time observation.
>>
>> Then I think it depends on how the CPU makes that time available to clients.
>> If it does it in a way that's equivalent to regularly updating a volatile
>> variable that can be read by all threads, then timing should work as expected.
>> I think the current specification for the timing functions is effectively
>> much weaker, because it's silent on the issues.
>>
>> I think that if we agree this is a problem, then it could be fixed by
>> updating the specifications for the timing functions, without touching the
>> memory model per se.  I'm not sure I understand the implementation
>> implications of that, so I'm neither advocating it, nor lobbying against it.
>> The C++ specification is somewhere in the middle, and I remain a bit nervous
>> about implementability there.
>
>
> I feel that this issue is not about actually calling any timing functions, but about the expectations on the timeliness of the visibility of volatile writes. Currently the programmer is left with a very vague and uncertain "general expectation" that volatile writes will be made visible "as soon as possible".

Similar to your concern that consecutive volatile writes can be
compressed into the last write, it also seems true that consecutive
volatile reads can be compressed into the first read - exactly the
kind of optimization to be disabled by C's volatile. It's
inconceivable that any JVM will do such optimization on volatile
reads, it'll break lots of programs, e.g. busy waits.

Two reasonable physical constraints can prevent these oddities:

1. every synchronization action takes non-zero time.

2. upper limit on discrepancy between synchronization order and
temporal order: if A is before B in synchronization order, A cannot be
indefinitely later than B, A must occur before (B.time + T) where T is
the upper limit.


From mtopolnik at inge-mark.hr  Tue Aug 21 17:46:19 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Tue, 21 Aug 2012 23:46:19 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CACuKZqFgoFuePECcNWB6htMuteRdi2dxc+YtT1GaFexuhS0RTQ@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>
	<CACuKZqFgoFuePECcNWB6htMuteRdi2dxc+YtT1GaFexuhS0RTQ@mail.gmail.com>
Message-ID: <0B233EAE-5BD5-41F0-97E0-B6747F8FF2AF@inge-mark.hr>

> Similar to your concern that consecutive volatile writes can be
> compressed into the last write, it also seems true that consecutive
> volatile reads can be compressed into the first read - exactly the
> kind of optimization to be disabled by C's volatile. It's
> inconceivable that any JVM will do such optimization on volatile
> reads, it'll break lots of programs, e.g. busy waits.

Actually there is already a provision in the JMM (in the original paper, at least) that prevents a busy-waiting loop whose condition involves a volatile read to forever read a stale value. There can be only a finite number of such read actions. But, this is a small consolation, really. Most code DOES make a difference between "eternity minus one" and "right now".

-Marko




From hans.boehm at hp.com  Tue Aug 21 19:40:38 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Tue, 21 Aug 2012 23:40:38 +0000
Subject: [concurrency-interest] Relativity of guarantees provided by
 volatile
In-Reply-To: <0B233EAE-5BD5-41F0-97E0-B6747F8FF2AF@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>
	<CACuKZqFgoFuePECcNWB6htMuteRdi2dxc+YtT1GaFexuhS0RTQ@mail.gmail.com>
	<0B233EAE-5BD5-41F0-97E0-B6747F8FF2AF@inge-mark.hr>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F625A0@G4W3296.americas.hpqcorp.net>

> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr]
> 
> > Similar to your concern that consecutive volatile writes can be
> > compressed into the last write, it also seems true that consecutive
> > volatile reads can be compressed into the first read - exactly the
> > kind of optimization to be disabled by C's volatile. It's
> > inconceivable that any JVM will do such optimization on volatile
> > reads, it'll break lots of programs, e.g. busy waits.
> 
> Actually there is already a provision in the JMM (in the original
> paper, at least) that prevents a busy-waiting loop whose condition
> involves a volatile read to forever read a stale value. There can be
> only a finite number of such read actions. But, this is a small
> consolation, really. Most code DOES make a difference between "eternity
> minus one" and "right now".
> 
My recollection is that this is only sort of/mostly of true.  If your entire program consists of

Thread 1:
while (!flag) {}

Thread 2:
flag = true;

There is intentionally no requirement that thread 2 ever be scheduled.  If it's not, that looks a lot like flag having been read once.  If, on the other hand, thread 2 sets flag and then prints "Hello", and you see the "Hello", then I believe you are correct that thread 1 must terminate.

My own feeling is that (under the right safety conditions), it's OK to collapse a bounded, "short" sequence of volatile reads into one, but not an unbounded number.  Java "volatile" is not "C volatile".  C "volatile" is neither intended for, nor safe for, synchronization.  Java "volatile" is not intended for device register access, or for use with setjmp, or ...

Hans


From zhong.j.yu at gmail.com  Tue Aug 21 21:04:14 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Tue, 21 Aug 2012 20:04:14 -0500
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F625A0@G4W3296.americas.hpqcorp.net>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>
	<CACuKZqFgoFuePECcNWB6htMuteRdi2dxc+YtT1GaFexuhS0RTQ@mail.gmail.com>
	<0B233EAE-5BD5-41F0-97E0-B6747F8FF2AF@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F625A0@G4W3296.americas.hpqcorp.net>
Message-ID: <CACuKZqGxqOKbh0-CzNBVypr77sHcRZDPnG-ufSXaun9ZCyG0NA@mail.gmail.com>

On Tue, Aug 21, 2012 at 6:40 PM, Boehm, Hans <hans.boehm at hp.com> wrote:
>> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr]
>> Actually there is already a provision in the JMM (in the original
>> paper, at least) that prevents a busy-waiting loop whose condition
>> involves a volatile read to forever read a stale value. There can be
>> only a finite number of such read actions.

> My own feeling is that (under the right safety conditions), it's OK to collapse a bounded, "short" sequence of volatile reads into one, but not an unbounded number.

You guys make sense. For every action, there are only finite number of
actions that can be ordered before it.

From mtopolnik at inge-mark.hr  Wed Aug 22 02:39:14 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Wed, 22 Aug 2012 08:39:14 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F625A0@G4W3296.americas.hpqcorp.net>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>
	<CACuKZqFgoFuePECcNWB6htMuteRdi2dxc+YtT1GaFexuhS0RTQ@mail.gmail.com>
	<0B233EAE-5BD5-41F0-97E0-B6747F8FF2AF@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F625A0@G4W3296.americas.hpqcorp.net>
Message-ID: <268498F0-39BF-4699-B9A6-187D42C545A0@inge-mark.hr>


On 22. kol. 2012., at 01:40, Boehm, Hans wrote:
>> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr]
>> 
>>> Similar to your concern that consecutive volatile writes can be
>>> compressed into the last write, it also seems true that consecutive
>>> volatile reads can be compressed into the first read - exactly the
>>> kind of optimization to be disabled by C's volatile. It's
>>> inconceivable that any JVM will do such optimization on volatile
>>> reads, it'll break lots of programs, e.g. busy waits.
>> 
>> Actually there is already a provision in the JMM (in the original
>> paper, at least) that prevents a busy-waiting loop whose condition
>> involves a volatile read to forever read a stale value. There can be
>> only a finite number of such read actions. But, this is a small
>> consolation, really. Most code DOES make a difference between "eternity
>> minus one" and "right now".
>> 
> My recollection is that this is only sort of/mostly of true.  If your entire program consists of
> 
> Thread 1:
> while (!flag) {}
> 
> Thread 2:
> flag = true;
> 
> There is intentionally no requirement that thread 2 ever be scheduled.  If it's not, that looks a lot like flag having been read once.  If, on the other hand, thread 2 sets flag and then prints "Hello", and you see the "Hello", then I believe you are correct that thread 1 must terminate.

If thread 2 never gets scheduled then the value of the flag is not stale (that's what I said---"read a stale value"). This JMM provision precludes bunching together an infinite amount of busy-wait flag checks, all reading the stale false value.

-Marko



From vitalyd at gmail.com  Wed Aug 22 09:01:23 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 22 Aug 2012 09:01:23 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <268498F0-39BF-4699-B9A6-187D42C545A0@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>
	<CACuKZqFgoFuePECcNWB6htMuteRdi2dxc+YtT1GaFexuhS0RTQ@mail.gmail.com>
	<0B233EAE-5BD5-41F0-97E0-B6747F8FF2AF@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F625A0@G4W3296.americas.hpqcorp.net>
	<268498F0-39BF-4699-B9A6-187D42C545A0@inge-mark.hr>
Message-ID: <CAHjP37HHuQ3s=kATFth_A7a2RBcbVJ5mKewi_yERsHMdPNHNCA@mail.gmail.com>

If the JMM ever goes through a revision, it would be useful to state some
basic assumptions such as threads get a chance to run on a processor so
that "perverse" scenarios don't muddy the waters.

Also, as I mentioned earlier, I have an issue with the wording of a
happens-before edge.  For example, thread A writes volatile memory and
thread B reads that memory; but if there's no read, the JMM says nothing
about what should happen to the write.  I also don't understand how a
normal (i.e. non experimental/academic) JVM could even do this type of
analysis consistently (e.g. the volatile field is public/protected) if
we're not sacrificing performance.

I understand it's an abstract model and shouldn't be clouded with impl
details of JVM/os/hardware, but I don't know if that's a good or bad
thing.  It's bad enough that folks on this list have ambiguity over it, but
what's a compiler writer to do, for example? Maybe the JMM can be lowered
into something a bit more concrete?

Sent from my phone
On Aug 22, 2012 2:42 AM, "Marko Topolnik" <mtopolnik at inge-mark.hr> wrote:

>
> On 22. kol. 2012., at 01:40, Boehm, Hans wrote:
> >> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr]
> >>
> >>> Similar to your concern that consecutive volatile writes can be
> >>> compressed into the last write, it also seems true that consecutive
> >>> volatile reads can be compressed into the first read - exactly the
> >>> kind of optimization to be disabled by C's volatile. It's
> >>> inconceivable that any JVM will do such optimization on volatile
> >>> reads, it'll break lots of programs, e.g. busy waits.
> >>
> >> Actually there is already a provision in the JMM (in the original
> >> paper, at least) that prevents a busy-waiting loop whose condition
> >> involves a volatile read to forever read a stale value. There can be
> >> only a finite number of such read actions. But, this is a small
> >> consolation, really. Most code DOES make a difference between "eternity
> >> minus one" and "right now".
> >>
> > My recollection is that this is only sort of/mostly of true.  If your
> entire program consists of
> >
> > Thread 1:
> > while (!flag) {}
> >
> > Thread 2:
> > flag = true;
> >
> > There is intentionally no requirement that thread 2 ever be scheduled.
>  If it's not, that looks a lot like flag having been read once.  If, on the
> other hand, thread 2 sets flag and then prints "Hello", and you see the
> "Hello", then I believe you are correct that thread 1 must terminate.
>
> If thread 2 never gets scheduled then the value of the flag is not stale
> (that's what I said---"read a stale value"). This JMM provision precludes
> bunching together an infinite amount of busy-wait flag checks, all reading
> the stale false value.
>
> -Marko
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120822/63ac76e6/attachment.html>

From mtopolnik at inge-mark.hr  Wed Aug 22 09:24:16 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Wed, 22 Aug 2012 15:24:16 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
Message-ID: <40D1CAE6-7E3D-433E-8EBB-67E6C997DA4A@inge-mark.hr>

>> Let's say that they could in theory be reflecting the exact time. We
>> don't have to descend into the gory details of specific CPUs. Imagine a
>> CPU specifically built to allow precise wall-clock time observation.
> 
> Then I think it depends on how the CPU makes that time available to clients.
> If it does it in a way that's equivalent to regularly updating a volatile
> variable that can be read by all threads, then timing should work as expected.
> I think the current specification for the timing functions is effectively
> much weaker, because it's silent on the issues.
> 
> I think that if we agree this is a problem, then it could be fixed by
> updating the specifications for the timing functions, without touching the
> memory model per se.  I'm not sure I understand the implementation
> implications of that, so I'm neither advocating it, nor lobbying against it.
> The C++ specification is somewhere in the middle, and I remain a bit nervous
> about implementability there.


I have thought about this approach more carefully and the funny thing is, it still guarantees nothing. Please consider the following happens-before graph:


    Thread R                                  /--> Rr0 --> Rr1
                                  -----------+--------/
                                /            |
    Thread W        --> Rw0 -> Ww0 ---> Rw1 -+--> Ww1
                  /                /  ------/   
                 |                | /    
    Thread T    Wt0 -----------> Wt1


We have the Timer thread T, which writes the volatile variable "currentTime". Both threads R and W read that var. The rest is the same as in the opening post: W writes sharedVar, R reads sharedVar.

Analysis:

- T writes to currentTime with actions Wt0 and Wt1;

- W observes action Wt0 with the action Rw0;

- W writes to sharedVar with the action Ww0;

- W observes Wt1 with the action Rw1;

- R observes Wt1 with the action Rr0;

- R observes Ww0 with the action Rr1.

Conclusions:

- R first observes Wt1, then Ww0;

- W first commits Ww0, then observes Wt1.


Since there are no cycles in the graph, there is no contradiction.

-Marko



From zhong.j.yu at gmail.com  Wed Aug 22 13:00:06 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Wed, 22 Aug 2012 12:00:06 -0500
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <40D1CAE6-7E3D-433E-8EBB-67E6C997DA4A@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<40D1CAE6-7E3D-433E-8EBB-67E6C997DA4A@inge-mark.hr>
Message-ID: <CACuKZqEtdE+_k6Xgwy6gP6gmVBbmP+y_4tAYmN6GV73w6r-W7g@mail.gmail.com>

On Wed, Aug 22, 2012 at 8:24 AM, Marko Topolnik <mtopolnik at inge-mark.hr> wrote:
>>> Let's say that they could in theory be reflecting the exact time. We
>>> don't have to descend into the gory details of specific CPUs. Imagine a
>>> CPU specifically built to allow precise wall-clock time observation.
>>
>> Then I think it depends on how the CPU makes that time available to clients.
>> If it does it in a way that's equivalent to regularly updating a volatile
>> variable that can be read by all threads, then timing should work as expected.
>> I think the current specification for the timing functions is effectively
>> much weaker, because it's silent on the issues.
>>
>> I think that if we agree this is a problem, then it could be fixed by
>> updating the specifications for the timing functions, without touching the
>> memory model per se.  I'm not sure I understand the implementation
>> implications of that, so I'm neither advocating it, nor lobbying against it.
>> The C++ specification is somewhere in the middle, and I remain a bit nervous
>> about implementability there.
>
>
> I have thought about this approach more carefully and the funny thing is, it still guarantees nothing. Please consider the following happens-before graph:
>
>
>     Thread R                                  /--> Rr0 --> Rr1
>                                   -----------+--------/
>                                 /            |
>     Thread W        --> Rw0 -> Ww0 ---> Rw1 -+--> Ww1
>                   /                /  ------/
>                  |                | /
>     Thread T    Wt0 -----------> Wt1
>
>
> We have the Timer thread T, which writes the volatile variable "currentTime". Both threads R and W read that var. The rest is the same as in the opening post: W writes sharedVar, R reads sharedVar.
>
> Analysis:
>
> - T writes to currentTime with actions Wt0 and Wt1;
>
> - W observes action Wt0 with the action Rw0;
>
> - W writes to sharedVar with the action Ww0;
>
> - W observes Wt1 with the action Rw1;
>
> - R observes Wt1 with the action Rr0;
>
> - R observes Ww0 with the action Rr1.
>
> Conclusions:
>
> - R first observes Wt1, then Ww0;
>
> - W first commits Ww0, then observes Wt1.
>
>
> Since there are no cycles in the graph, there is no contradiction.

Suppose W writes v=1, then observes t=1; R observes t=2, then read v.
The last read cannot see v=0.

Therefore if R/W actions are sandwiched with reading the timing
variable, we will not detect any apparent timing paradoxes.

Since we are not talking about physical time (beyond JMM) any more,
instead just a variable (within JMM), JMM guarantees that any
execution of the program appears to be sequentially consistent.

From zhong.j.yu at gmail.com  Wed Aug 22 13:18:04 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Wed, 22 Aug 2012 12:18:04 -0500
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <268498F0-39BF-4699-B9A6-187D42C545A0@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>
	<CACuKZqFgoFuePECcNWB6htMuteRdi2dxc+YtT1GaFexuhS0RTQ@mail.gmail.com>
	<0B233EAE-5BD5-41F0-97E0-B6747F8FF2AF@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F625A0@G4W3296.americas.hpqcorp.net>
	<268498F0-39BF-4699-B9A6-187D42C545A0@inge-mark.hr>
Message-ID: <CACuKZqG2oWcxr_J=Q7enoKcKgWEsnr8BpOWAYYMDu7YF2mYsSg@mail.gmail.com>

On Wed, Aug 22, 2012 at 1:39 AM, Marko Topolnik <mtopolnik at inge-mark.hr> wrote:
>
> On 22. kol. 2012., at 01:40, Boehm, Hans wrote:
>>> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr]
>>>
>>>> Similar to your concern that consecutive volatile writes can be
>>>> compressed into the last write, it also seems true that consecutive
>>>> volatile reads can be compressed into the first read - exactly the
>>>> kind of optimization to be disabled by C's volatile. It's
>>>> inconceivable that any JVM will do such optimization on volatile
>>>> reads, it'll break lots of programs, e.g. busy waits.
>>>
>>> Actually there is already a provision in the JMM (in the original
>>> paper, at least) that prevents a busy-waiting loop whose condition
>>> involves a volatile read to forever read a stale value. There can be
>>> only a finite number of such read actions. But, this is a small
>>> consolation, really. Most code DOES make a difference between "eternity
>>> minus one" and "right now".
>>>
>> My recollection is that this is only sort of/mostly of true.  If your entire program consists of
>>
>> Thread 1:
>> while (!flag) {}
>>
>> Thread 2:
>> flag = true;
>>
>> There is intentionally no requirement that thread 2 ever be scheduled.  If it's not, that looks a lot like flag having been read once.  If, on the other hand, thread 2 sets flag and then prints "Hello", and you see the "Hello", then I believe you are correct that thread 1 must terminate.
>
> If thread 2 never gets scheduled then the value of the flag is not stale (that's what I said---"read a stale value"). This JMM provision

Can you give the reference to this provision? (I didn't see an
explicit one; though it's quite natural, since the set of actions
should be countable)

precludes bunching together an infinite amount of busy-wait flag
checks, all reading the stale false value.
>
> -Marko
>


From gregg at cytetech.com  Wed Aug 22 14:15:03 2012
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 22 Aug 2012 13:15:03 -0500
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CACuKZqG2oWcxr_J=Q7enoKcKgWEsnr8BpOWAYYMDu7YF2mYsSg@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>
	<CACuKZqFgoFuePECcNWB6htMuteRdi2dxc+YtT1GaFexuhS0RTQ@mail.gmail.com>
	<0B233EAE-5BD5-41F0-97E0-B6747F8FF2AF@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F625A0@G4W3296.americas.hpqcorp.net>
	<268498F0-39BF-4699-B9A6-187D42C545A0@inge-mark.hr>
	<CACuKZqG2oWcxr_J=Q7enoKcKgWEsnr8BpOWAYYMDu7YF2mYsSg@mail.gmail.com>
Message-ID: <503521A7.2070105@cytetech.com>

On 8/22/2012 12:18 PM, Zhong Yu wrote:
> On Wed, Aug 22, 2012 at 1:39 AM, Marko Topolnik <mtopolnik at inge-mark.hr> wrote:
>>
>> On 22. kol. 2012., at 01:40, Boehm, Hans wrote:
>>>> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr]
>>>>
>>>>> Similar to your concern that consecutive volatile writes can be
>>>>> compressed into the last write, it also seems true that consecutive
>>>>> volatile reads can be compressed into the first read - exactly the
>>>>> kind of optimization to be disabled by C's volatile. It's
>>>>> inconceivable that any JVM will do such optimization on volatile
>>>>> reads, it'll break lots of programs, e.g. busy waits.
>>>>
>>>> Actually there is already a provision in the JMM (in the original
>>>> paper, at least) that prevents a busy-waiting loop whose condition
>>>> involves a volatile read to forever read a stale value. There can be
>>>> only a finite number of such read actions. But, this is a small
>>>> consolation, really. Most code DOES make a difference between "eternity
>>>> minus one" and "right now".
>>>>
>>> My recollection is that this is only sort of/mostly of true.  If your entire program consists of
>>>
>>> Thread 1:
>>> while (!flag) {}
>>>
>>> Thread 2:
>>> flag = true;
>>>
>>> There is intentionally no requirement that thread 2 ever be scheduled.  If it's not, that looks a lot like flag having been read once.  If, on the other hand, thread 2 sets flag and then prints "Hello", and you see the "Hello", then I believe you are correct that thread 1 must terminate.
>>
>> If thread 2 never gets scheduled then the value of the flag is not stale (that's what I said---"read a stale value"). This JMM provision
>
> Can you give the reference to this provision? (I didn't see an
> explicit one; though it's quite natural, since the set of actions
> should be countable)
>
> precludes bunching together an infinite amount of busy-wait flag
> checks, all reading the stale false value.

Java provides for no guarantees that the host operating system will actually, 
effectively (for you), schedule any thread other than the current one, with any 
reliability.  It just states when a thread is running, this is the behavior you 
will perceive based on the JLS and JMM.

So, Thread.yield()'s necessity of use is unspecified.  But there were some early 
JVMs which did require the use of Thread.yield because the thread scheduling 
and/or os were not preemptive.

Gregg


From viktor.klang at gmail.com  Wed Aug 22 15:35:57 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 22 Aug 2012 21:35:57 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <503521A7.2070105@cytetech.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>
	<CACuKZqFgoFuePECcNWB6htMuteRdi2dxc+YtT1GaFexuhS0RTQ@mail.gmail.com>
	<0B233EAE-5BD5-41F0-97E0-B6747F8FF2AF@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F625A0@G4W3296.americas.hpqcorp.net>
	<268498F0-39BF-4699-B9A6-187D42C545A0@inge-mark.hr>
	<CACuKZqG2oWcxr_J=Q7enoKcKgWEsnr8BpOWAYYMDu7YF2mYsSg@mail.gmail.com>
	<503521A7.2070105@cytetech.com>
Message-ID: <CANPzfU81U0Hx0huw9SXFKJqZD26xF7Boo0+6ivMmpKX7vs+Cuw@mail.gmail.com>

On Wed, Aug 22, 2012 at 8:15 PM, Gregg Wonderly <gregg at cytetech.com> wrote:

> On 8/22/2012 12:18 PM, Zhong Yu wrote:
>
>> On Wed, Aug 22, 2012 at 1:39 AM, Marko Topolnik <mtopolnik at inge-mark.hr>
>> wrote:
>>
>>>
>>> On 22. kol. 2012., at 01:40, Boehm, Hans wrote:
>>>
>>>> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr**]
>>>>>
>>>>>  Similar to your concern that consecutive volatile writes can be
>>>>>> compressed into the last write, it also seems true that consecutive
>>>>>> volatile reads can be compressed into the first read - exactly the
>>>>>> kind of optimization to be disabled by C's volatile. It's
>>>>>> inconceivable that any JVM will do such optimization on volatile
>>>>>> reads, it'll break lots of programs, e.g. busy waits.
>>>>>>
>>>>>
>>>>> Actually there is already a provision in the JMM (in the original
>>>>> paper, at least) that prevents a busy-waiting loop whose condition
>>>>> involves a volatile read to forever read a stale value. There can be
>>>>> only a finite number of such read actions. But, this is a small
>>>>> consolation, really. Most code DOES make a difference between "eternity
>>>>> minus one" and "right now".
>>>>>
>>>>>  My recollection is that this is only sort of/mostly of true.  If your
>>>> entire program consists of
>>>>
>>>> Thread 1:
>>>> while (!flag) {}
>>>>
>>>> Thread 2:
>>>> flag = true;
>>>>
>>>> There is intentionally no requirement that thread 2 ever be scheduled.
>>>>  If it's not, that looks a lot like flag having been read once.  If, on the
>>>> other hand, thread 2 sets flag and then prints "Hello", and you see the
>>>> "Hello", then I believe you are correct that thread 1 must terminate.
>>>>
>>>
>>> If thread 2 never gets scheduled then the value of the flag is not stale
>>> (that's what I said---"read a stale value"). This JMM provision
>>>
>>
>> Can you give the reference to this provision? (I didn't see an
>> explicit one; though it's quite natural, since the set of actions
>> should be countable)
>>
>> precludes bunching together an infinite amount of busy-wait flag
>> checks, all reading the stale false value.
>>
>
> Java provides for no guarantees that the host operating system will
> actually, effectively (for you), schedule any thread other than the current
> one, with any reliability.  It just states when a thread is running, this
> is the behavior you will perceive based on the JLS and JMM.
>

Also, there is no way for the current Thread to know how much of cpu quanta
it has left. So one can never assume execution will be done.


>
> So, Thread.yield()'s necessity of use is unspecified.  But there were some
> early JVMs which did require the use of Thread.yield because the thread
> scheduling and/or os were not preemptive.
>
> Gregg
>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120822/21d3abb5/attachment.html>

From viktor.klang at gmail.com  Wed Aug 22 15:40:30 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 22 Aug 2012 21:40:30 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CACuKZqEtdE+_k6Xgwy6gP6gmVBbmP+y_4tAYmN6GV73w6r-W7g@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<40D1CAE6-7E3D-433E-8EBB-67E6C997DA4A@inge-mark.hr>
	<CACuKZqEtdE+_k6Xgwy6gP6gmVBbmP+y_4tAYmN6GV73w6r-W7g@mail.gmail.com>
Message-ID: <CANPzfU_Z6H8=9ZEp25RZrOvxniHb7C-tU4c0iU3+m4gvomQbXg@mail.gmail.com>

On Wed, Aug 22, 2012 at 7:00 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> On Wed, Aug 22, 2012 at 8:24 AM, Marko Topolnik <mtopolnik at inge-mark.hr>
> wrote:
> >>> Let's say that they could in theory be reflecting the exact time. We
> >>> don't have to descend into the gory details of specific CPUs. Imagine a
> >>> CPU specifically built to allow precise wall-clock time observation.
> >>
> >> Then I think it depends on how the CPU makes that time available to
> clients.
> >> If it does it in a way that's equivalent to regularly updating a
> volatile
> >> variable that can be read by all threads, then timing should work as
> expected.
> >> I think the current specification for the timing functions is
> effectively
> >> much weaker, because it's silent on the issues.
> >>
> >> I think that if we agree this is a problem, then it could be fixed by
> >> updating the specifications for the timing functions, without touching
> the
> >> memory model per se.  I'm not sure I understand the implementation
> >> implications of that, so I'm neither advocating it, nor lobbying
> against it.
> >> The C++ specification is somewhere in the middle, and I remain a bit
> nervous
> >> about implementability there.
> >
> >
> > I have thought about this approach more carefully and the funny thing
> is, it still guarantees nothing. Please consider the following
> happens-before graph:
> >
> >
> >     Thread R                                  /--> Rr0 --> Rr1
> >                                   -----------+--------/
> >                                 /            |
> >     Thread W        --> Rw0 -> Ww0 ---> Rw1 -+--> Ww1
> >                   /                /  ------/
> >                  |                | /
> >     Thread T    Wt0 -----------> Wt1
> >
> >
> > We have the Timer thread T, which writes the volatile variable
> "currentTime". Both threads R and W read that var. The rest is the same as
> in the opening post: W writes sharedVar, R reads sharedVar.
> >
> > Analysis:
> >
> > - T writes to currentTime with actions Wt0 and Wt1;
> >
> > - W observes action Wt0 with the action Rw0;
> >
> > - W writes to sharedVar with the action Ww0;
> >
> > - W observes Wt1 with the action Rw1;
> >
> > - R observes Wt1 with the action Rr0;
> >
> > - R observes Ww0 with the action Rr1.
> >
> > Conclusions:
> >
> > - R first observes Wt1, then Ww0;
> >
> > - W first commits Ww0, then observes Wt1.
> >
> >
> > Since there are no cycles in the graph, there is no contradiction.
>
> Suppose W writes v=1, then observes t=1; R observes t=2, then read v.
> The last read cannot see v=0.
>
> Therefore if R/W actions are sandwiched with reading the timing
> variable, we will not detect any apparent timing paradoxes.
>
> Since we are not talking about physical time (beyond JMM) any more,
> instead just a variable (within JMM), JMM guarantees that any
> execution of the program appears to be sequentially consistent.


So flush of any write to an address only has to be done just prior to any
read from that address by some other thread than the writer.
So given a program that only has one thread; flushes could effectively be
elided.

Cheers,
?


> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120822/47f82f7d/attachment-0001.html>

From vitalyd at gmail.com  Wed Aug 22 15:57:21 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 22 Aug 2012 15:57:21 -0400
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CANPzfU_Z6H8=9ZEp25RZrOvxniHb7C-tU4c0iU3+m4gvomQbXg@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<40D1CAE6-7E3D-433E-8EBB-67E6C997DA4A@inge-mark.hr>
	<CACuKZqEtdE+_k6Xgwy6gP6gmVBbmP+y_4tAYmN6GV73w6r-W7g@mail.gmail.com>
	<CANPzfU_Z6H8=9ZEp25RZrOvxniHb7C-tU4c0iU3+m4gvomQbXg@mail.gmail.com>
Message-ID: <CAHjP37EmHi9UOTxKtq9Ljc2ZvHqCS7wv_nbarPiHBgDgNxVimQ@mail.gmail.com>

A single threaded program may still migrate across processors, so OS will
do the flushing anyway.

Also, draining store buffer is not always an expensive operation.  Really
the scalability issue is sharing memory at all between lots of cores,
doesn't have to be volatile to cause problems.

Sent from my phone
On Aug 22, 2012 3:43 PM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:

>
>
> On Wed, Aug 22, 2012 at 7:00 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>
>> On Wed, Aug 22, 2012 at 8:24 AM, Marko Topolnik <mtopolnik at inge-mark.hr>
>> wrote:
>> >>> Let's say that they could in theory be reflecting the exact time. We
>> >>> don't have to descend into the gory details of specific CPUs. Imagine
>> a
>> >>> CPU specifically built to allow precise wall-clock time observation.
>> >>
>> >> Then I think it depends on how the CPU makes that time available to
>> clients.
>> >> If it does it in a way that's equivalent to regularly updating a
>> volatile
>> >> variable that can be read by all threads, then timing should work as
>> expected.
>> >> I think the current specification for the timing functions is
>> effectively
>> >> much weaker, because it's silent on the issues.
>> >>
>> >> I think that if we agree this is a problem, then it could be fixed by
>> >> updating the specifications for the timing functions, without touching
>> the
>> >> memory model per se.  I'm not sure I understand the implementation
>> >> implications of that, so I'm neither advocating it, nor lobbying
>> against it.
>> >> The C++ specification is somewhere in the middle, and I remain a bit
>> nervous
>> >> about implementability there.
>> >
>> >
>> > I have thought about this approach more carefully and the funny thing
>> is, it still guarantees nothing. Please consider the following
>> happens-before graph:
>> >
>> >
>> >     Thread R                                  /--> Rr0 --> Rr1
>> >                                   -----------+--------/
>> >                                 /            |
>> >     Thread W        --> Rw0 -> Ww0 ---> Rw1 -+--> Ww1
>> >                   /                /  ------/
>> >                  |                | /
>> >     Thread T    Wt0 -----------> Wt1
>> >
>> >
>> > We have the Timer thread T, which writes the volatile variable
>> "currentTime". Both threads R and W read that var. The rest is the same as
>> in the opening post: W writes sharedVar, R reads sharedVar.
>> >
>> > Analysis:
>> >
>> > - T writes to currentTime with actions Wt0 and Wt1;
>> >
>> > - W observes action Wt0 with the action Rw0;
>> >
>> > - W writes to sharedVar with the action Ww0;
>> >
>> > - W observes Wt1 with the action Rw1;
>> >
>> > - R observes Wt1 with the action Rr0;
>> >
>> > - R observes Ww0 with the action Rr1.
>> >
>> > Conclusions:
>> >
>> > - R first observes Wt1, then Ww0;
>> >
>> > - W first commits Ww0, then observes Wt1.
>> >
>> >
>> > Since there are no cycles in the graph, there is no contradiction.
>>
>> Suppose W writes v=1, then observes t=1; R observes t=2, then read v.
>> The last read cannot see v=0.
>>
>> Therefore if R/W actions are sandwiched with reading the timing
>> variable, we will not detect any apparent timing paradoxes.
>>
>> Since we are not talking about physical time (beyond JMM) any more,
>> instead just a variable (within JMM), JMM guarantees that any
>> execution of the program appears to be sequentially consistent.
>
>
> So flush of any write to an address only has to be done just prior to any
> read from that address by some other thread than the writer.
> So given a program that only has one thread; flushes could effectively be
> elided.
>
> Cheers,
> ?
>
>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> --
> Viktor Klang
>
> Akka Tech Lead
> Typesafe <http://www.typesafe.com/> - The software stack for applications
> that scale
>
> Twitter: @viktorklang
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120822/10573b37/attachment.html>

From viktor.klang at gmail.com  Wed Aug 22 16:08:02 2012
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 22 Aug 2012 22:08:02 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CAHjP37EmHi9UOTxKtq9Ljc2ZvHqCS7wv_nbarPiHBgDgNxVimQ@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<40D1CAE6-7E3D-433E-8EBB-67E6C997DA4A@inge-mark.hr>
	<CACuKZqEtdE+_k6Xgwy6gP6gmVBbmP+y_4tAYmN6GV73w6r-W7g@mail.gmail.com>
	<CANPzfU_Z6H8=9ZEp25RZrOvxniHb7C-tU4c0iU3+m4gvomQbXg@mail.gmail.com>
	<CAHjP37EmHi9UOTxKtq9Ljc2ZvHqCS7wv_nbarPiHBgDgNxVimQ@mail.gmail.com>
Message-ID: <CANPzfU-fyAwO5YA0BoP4mYShy4=-xuT0J9S-UNEb0ycZZwbKkw@mail.gmail.com>

On Wed, Aug 22, 2012 at 9:57 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:

> A single threaded program may still migrate across processors, so OS will
> do the flushing anyway.
>

Yes of course. Core migration will have to include packing the threads
belongings and ship them over to the new core.


> Also, draining store buffer is not always an expensive operation.  Really
> the scalability issue is sharing memory at all between lots of cores,
> doesn't have to be volatile to cause problems.
>
> Sent from my phone
> On Aug 22, 2012 3:43 PM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:
>
>>
>>
>> On Wed, Aug 22, 2012 at 7:00 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>
>>> On Wed, Aug 22, 2012 at 8:24 AM, Marko Topolnik <mtopolnik at inge-mark.hr>
>>> wrote:
>>> >>> Let's say that they could in theory be reflecting the exact time. We
>>> >>> don't have to descend into the gory details of specific CPUs.
>>> Imagine a
>>> >>> CPU specifically built to allow precise wall-clock time observation.
>>> >>
>>> >> Then I think it depends on how the CPU makes that time available to
>>> clients.
>>> >> If it does it in a way that's equivalent to regularly updating a
>>> volatile
>>> >> variable that can be read by all threads, then timing should work as
>>> expected.
>>> >> I think the current specification for the timing functions is
>>> effectively
>>> >> much weaker, because it's silent on the issues.
>>> >>
>>> >> I think that if we agree this is a problem, then it could be fixed by
>>> >> updating the specifications for the timing functions, without
>>> touching the
>>> >> memory model per se.  I'm not sure I understand the implementation
>>> >> implications of that, so I'm neither advocating it, nor lobbying
>>> against it.
>>> >> The C++ specification is somewhere in the middle, and I remain a bit
>>> nervous
>>> >> about implementability there.
>>> >
>>> >
>>> > I have thought about this approach more carefully and the funny thing
>>> is, it still guarantees nothing. Please consider the following
>>> happens-before graph:
>>> >
>>> >
>>> >     Thread R                                  /--> Rr0 --> Rr1
>>> >                                   -----------+--------/
>>> >                                 /            |
>>> >     Thread W        --> Rw0 -> Ww0 ---> Rw1 -+--> Ww1
>>> >                   /                /  ------/
>>> >                  |                | /
>>> >     Thread T    Wt0 -----------> Wt1
>>> >
>>> >
>>> > We have the Timer thread T, which writes the volatile variable
>>> "currentTime". Both threads R and W read that var. The rest is the same as
>>> in the opening post: W writes sharedVar, R reads sharedVar.
>>> >
>>> > Analysis:
>>> >
>>> > - T writes to currentTime with actions Wt0 and Wt1;
>>> >
>>> > - W observes action Wt0 with the action Rw0;
>>> >
>>> > - W writes to sharedVar with the action Ww0;
>>> >
>>> > - W observes Wt1 with the action Rw1;
>>> >
>>> > - R observes Wt1 with the action Rr0;
>>> >
>>> > - R observes Ww0 with the action Rr1.
>>> >
>>> > Conclusions:
>>> >
>>> > - R first observes Wt1, then Ww0;
>>> >
>>> > - W first commits Ww0, then observes Wt1.
>>> >
>>> >
>>> > Since there are no cycles in the graph, there is no contradiction.
>>>
>>> Suppose W writes v=1, then observes t=1; R observes t=2, then read v.
>>> The last read cannot see v=0.
>>>
>>> Therefore if R/W actions are sandwiched with reading the timing
>>> variable, we will not detect any apparent timing paradoxes.
>>>
>>> Since we are not talking about physical time (beyond JMM) any more,
>>> instead just a variable (within JMM), JMM guarantees that any
>>> execution of the program appears to be sequentially consistent.
>>
>>
>> So flush of any write to an address only has to be done just prior to any
>> read from that address by some other thread than the writer.
>> So given a program that only has one thread; flushes could effectively be
>> elided.
>>
>> Cheers,
>> ?
>>
>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>>
>> --
>> Viktor Klang
>>
>> Akka Tech Lead
>> Typesafe <http://www.typesafe.com/> - The software stack for
>> applications that scale
>>
>> Twitter: @viktorklang
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>


-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120822/95382658/attachment-0001.html>

From mtopolnik at inge-mark.hr  Wed Aug 22 17:44:07 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Wed, 22 Aug 2012 23:44:07 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CACuKZqEtdE+_k6Xgwy6gP6gmVBbmP+y_4tAYmN6GV73w6r-W7g@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<40D1CAE6-7E3D-433E-8EBB-67E6C997DA4A@inge-mark.hr>
	<CACuKZqEtdE+_k6Xgwy6gP6gmVBbmP+y_4tAYmN6GV73w6r-W7g@mail.gmail.com>
Message-ID: <8A7E6C23-57AF-44FF-882B-664A56B340C8@inge-mark.hr>

>> 
>> 
>>    Thread R                                  /--> Rr0 --> Rr1
>>                                  -----------+--------/
>>                                /            |
>>    Thread W        --> Rw0 -> Ww0 ---> Rw1 -+--> Ww1
>>                  /                /  ------/
>>                 |                | /
>>    Thread T    Wt0 -----------> Wt1
> 
> Suppose W writes v=1, then observes t=1; R observes t=2, then read v.
> The last read cannot see v=0.
> 
> Therefore if R/W actions are sandwiched with reading the timing
> variable, we will not detect any apparent timing paradoxes.
> 
> Since we are not talking about physical time (beyond JMM) any more,
> instead just a variable (within JMM), JMM guarantees that any
> execution of the program appears to be sequentially consistent.


I was trying to form a minimal example to demonstrate the point, it seems still lacking. Consider the following graph, now there's three wall-clock writes involved:


Thread R                                         /--> Rr0 --> Rr1
                              ------------------+---------/
                            /                   |
Thread W        --> Rw0 -> Ww0 ---> Rw1 -> Ww1  |
              /                /                |
             |                |                 |
Thread T    Wt0 -----------> Wt1 ------------> Wt2


Say Wt0 writes t = 0 ms, Wt1 writes t = 3 ms, Wt2 writes t = 6 ms.

Also say Ww0 writes zero and Ww1 writes one.

Thread W says "I wrote zero at t = 0 ms and one at t = 3 ms."

Thread R says "I read zero at t = 6 ms."

Note also the general pattern: there are no constraints imposed by the arrows from T to R on the arrows from W to R.

-Marko



From mtopolnik at inge-mark.hr  Wed Aug 22 17:51:45 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Wed, 22 Aug 2012 23:51:45 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CACuKZqG2oWcxr_J=Q7enoKcKgWEsnr8BpOWAYYMDu7YF2mYsSg@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>
	<CACuKZqFgoFuePECcNWB6htMuteRdi2dxc+YtT1GaFexuhS0RTQ@mail.gmail.com>
	<0B233EAE-5BD5-41F0-97E0-B6747F8FF2AF@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F625A0@G4W3296.americas.hpqcorp.net>
	<268498F0-39BF-4699-B9A6-187D42C545A0@inge-mark.hr>
	<CACuKZqG2oWcxr_J=Q7enoKcKgWEsnr8BpOWAYYMDu7YF2mYsSg@mail.gmail.com>
Message-ID: <69A9F05C-3580-4BD2-B38F-62A4226A01E6@inge-mark.hr>


On 22. kol. 2012., at 19:18, Zhong Yu wrote:

> On Wed, Aug 22, 2012 at 1:39 AM, Marko Topolnik <mtopolnik at inge-mark.hr> wrote:
>> 
>> On 22. kol. 2012., at 01:40, Boehm, Hans wrote:
>>>> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr]
>>>> 
>>>>> Similar to your concern that consecutive volatile writes can be
>>>>> compressed into the last write, it also seems true that consecutive
>>>>> volatile reads can be compressed into the first read - exactly the
>>>>> kind of optimization to be disabled by C's volatile. It's
>>>>> inconceivable that any JVM will do such optimization on volatile
>>>>> reads, it'll break lots of programs, e.g. busy waits.
>>>> 
>>>> Actually there is already a provision in the JMM (in the original
>>>> paper, at least) that prevents a busy-waiting loop whose condition
>>>> involves a volatile read to forever read a stale value. There can be
>>>> only a finite number of such read actions. But, this is a small
>>>> consolation, really. Most code DOES make a difference between "eternity
>>>> minus one" and "right now".
>>>> 
>>> My recollection is that this is only sort of/mostly of true.  If your entire program consists of
>>> 
>>> Thread 1:
>>> while (!flag) {}
>>> 
>>> Thread 2:
>>> flag = true;
>>> 
>>> There is intentionally no requirement that thread 2 ever be scheduled.  If it's not, that looks a lot like flag having been read once.  If, on the other hand, thread 2 sets flag and then prints "Hello", and you see the "Hello", then I believe you are correct that thread 1 must terminate.
>> 
>> If thread 2 never gets scheduled then the value of the flag is not stale (that's what I said---"read a stale value"). This JMM provision
> 
> Can you give the reference to this provision? (I didn't see an
> explicit one; though it's quite natural, since the set of actions
> should be countable)
> 
> precludes bunching together an infinite amount of busy-wait flag
> checks, all reading the stale false value.

This would be it:

http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.9

However, it is much clearer if you refer to Manson, Pugh, "The Java Memory Model", Section 7, and especially Figure 9.

http://rsim.cs.illinois.edu/Pubs/popl05.pdf


-Marko



From zhong.j.yu at gmail.com  Wed Aug 22 19:17:39 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Wed, 22 Aug 2012 18:17:39 -0500
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <8A7E6C23-57AF-44FF-882B-664A56B340C8@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<40D1CAE6-7E3D-433E-8EBB-67E6C997DA4A@inge-mark.hr>
	<CACuKZqEtdE+_k6Xgwy6gP6gmVBbmP+y_4tAYmN6GV73w6r-W7g@mail.gmail.com>
	<8A7E6C23-57AF-44FF-882B-664A56B340C8@inge-mark.hr>
Message-ID: <CACuKZqHcKtzfeOtj-Smv620iLrztLdDvMpauaHuJwX2CBprTBw@mail.gmail.com>

On Wed, Aug 22, 2012 at 4:44 PM, Marko Topolnik <mtopolnik at inge-mark.hr> wrote:
>>>
>>>
>>>    Thread R                                  /--> Rr0 --> Rr1
>>>                                  -----------+--------/
>>>                                /            |
>>>    Thread W        --> Rw0 -> Ww0 ---> Rw1 -+--> Ww1
>>>                  /                /  ------/
>>>                 |                | /
>>>    Thread T    Wt0 -----------> Wt1
>>
>> Suppose W writes v=1, then observes t=1; R observes t=2, then read v.
>> The last read cannot see v=0.
>>
>> Therefore if R/W actions are sandwiched with reading the timing
>> variable, we will not detect any apparent timing paradoxes.
>>
>> Since we are not talking about physical time (beyond JMM) any more,
>> instead just a variable (within JMM), JMM guarantees that any
>> execution of the program appears to be sequentially consistent.
>
>
> I was trying to form a minimal example to demonstrate the point, it seems still lacking. Consider the following graph, now there's three wall-clock writes involved:
>
>
> Thread R                                         /--> Rr0 --> Rr1
>                               ------------------+---------/
>                             /                   |
> Thread W        --> Rw0 -> Ww0 ---> Rw1 -> Ww1  |
>               /                /                |
>              |                |                 |
> Thread T    Wt0 -----------> Wt1 ------------> Wt2
>
>
> Say Wt0 writes t = 0 ms, Wt1 writes t = 3 ms, Wt2 writes t = 6 ms.
>
> Also say Ww0 writes zero and Ww1 writes one.
>
> Thread W says "I wrote zero at t = 0 ms and one at t = 3 ms."

W cannot say that, it's more like W wrote one after seeing t=3. That
is not inconsistent with R reading zero after seeing t=6.

Note that the clock precision is not good here. For example, there is
no paradox in "W wrote one before seeing t=6" and "R read zero after
seeing t=6", because "t=6" can be seen in an extended time window.

A real paradox would be "W wrote one before seeing t=3" and "R read
zero after seeing t=6", a timing error greater than clock precision.

JMM does not allow that paradox. If Rw2 sees t=3, Wt1<Rw2<Wt2 in sync
order, therefore Ww1<Rw2 <Wt2<Rr0<Rr1, therefore Ww0<Ww1<Rr1, that
forbids Rr1 seeing Ww0.

> Thread R says "I read zero at t = 6 ms."
>
> Note also the general pattern: there are no constraints imposed by the arrows from T to R on the arrows from W to R.

You missed the arrows from a read to the write that comes after:)

> -Marko
>

From hans.boehm at hp.com  Wed Aug 22 19:46:45 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 22 Aug 2012 23:46:45 +0000
Subject: [concurrency-interest] Relativity of guarantees provided by
 volatile
In-Reply-To: <8A7E6C23-57AF-44FF-882B-664A56B340C8@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<40D1CAE6-7E3D-433E-8EBB-67E6C997DA4A@inge-mark.hr>
	<CACuKZqEtdE+_k6Xgwy6gP6gmVBbmP+y_4tAYmN6GV73w6r-W7g@mail.gmail.com>
	<8A7E6C23-57AF-44FF-882B-664A56B340C8@inge-mark.hr>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F62AFF@G4W3296.americas.hpqcorp.net>



> -----Original Message-----
> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr]
> Sent: Wednesday, August 22, 2012 2:44 PM
> To: Zhong Yu
> Cc: Boehm, Hans; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Relativity of guarantees provided
> by volatile
> 
> >>
> >>
> >>    Thread R                                  /--> Rr0 --> Rr1
> >>                                  -----------+--------/
> >>                                /            |
> >>    Thread W        --> Rw0 -> Ww0 ---> Rw1 -+--> Ww1
> >>                  /                /  ------/
> >>                 |                | /
> >>    Thread T    Wt0 -----------> Wt1
> >
> > Suppose W writes v=1, then observes t=1; R observes t=2, then read v.
> > The last read cannot see v=0.
> >
> > Therefore if R/W actions are sandwiched with reading the timing
> > variable, we will not detect any apparent timing paradoxes.
> >
> > Since we are not talking about physical time (beyond JMM) any more,
> > instead just a variable (within JMM), JMM guarantees that any
> > execution of the program appears to be sequentially consistent.
> 
> 
> I was trying to form a minimal example to demonstrate the point, it
> seems still lacking. Consider the following graph, now there's three
> wall-clock writes involved:
> 
> 
> Thread R                                         /--> Rr0 --> Rr1
>                               ------------------+---------/
>                             /                   |
> Thread W        --> Rw0 -> Ww0 ---> Rw1 -> Ww1  |
>               /                /                |
>              |                |                 |
> Thread T    Wt0 -----------> Wt1 ------------> Wt2
> 
> 
> Say Wt0 writes t = 0 ms, Wt1 writes t = 3 ms, Wt2 writes t = 6 ms.
> 
> Also say Ww0 writes zero and Ww1 writes one.
> 
> Thread W says "I wrote zero at t = 0 ms and one at t = 3 ms."
> 
> Thread R says "I read zero at t = 6 ms."
> 
> Note also the general pattern: there are no constraints imposed by the
> arrows from T to R on the arrows from W to R.
> 
> -Marko
I'm having a bit of trouble interpreting your notation.  Rw1 refers to a timer read?  Why is this not exactly what you expect if Ww1 actually happened at 7 ms due to some scheduling delay?  Is it strange just because of the way you drew the diagram?  It seems to me that to be problematic, thread W would have to read the timer AFTER the second write, but that's no longer sequentially consistent.


Hans


From hans.boehm at hp.com  Wed Aug 22 23:05:52 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu, 23 Aug 2012 03:05:52 +0000
Subject: [concurrency-interest] Relativity of guarantees provided by
 volatile
In-Reply-To: <CAHjP37HHuQ3s=kATFth_A7a2RBcbVJ5mKewi_yERsHMdPNHNCA@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<BCFFCBF1-084B-4F1C-9433-52DE955A5427@inge-mark.hr>
	<CACuKZqFgoFuePECcNWB6htMuteRdi2dxc+YtT1GaFexuhS0RTQ@mail.gmail.com>
	<0B233EAE-5BD5-41F0-97E0-B6747F8FF2AF@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F625A0@G4W3296.americas.hpqcorp.net>
	<268498F0-39BF-4699-B9A6-187D42C545A0@inge-mark.hr>
	<CAHjP37HHuQ3s=kATFth_A7a2RBcbVJ5mKewi_yERsHMdPNHNCA@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F62BBD@G4W3296.americas.hpqcorp.net>

Progress guarantees were discussed during both the original JSR133 effort, and again in connection with the C++ memory model.  It is really hard to specify anything that is universally acceptable, and is reasonably easy to write down.  What about a special purpose embedded JVM that runs stored procedures in a database?  Do we want to require it to have a preemptive scheduler?  What does it mean to get a "chance to run" in the presence of standard library functions that acquire locks under the covers?  Can another thread calling those same functions repeatedly prevent it from making progress?  If so, do we now have to specify which locks are acquired by each library function?  What does it mean for a JVM to provide a progress guarantee when the hardware specifications don't (e.g. because they don't promise that store buffers drain in a bounded amount of time)?

In the case of C++11, we ended giving a vague guideline along the lines mentioned below, so that implementers knew what to strive for, but we ended up not making it binding on implementations, in part because we couldn't make it precise.

As far as the JMM itself is concerned, it's important to remember that hardware memory models vary a lot, and at least the 2005 variants were often less well defined, and even less comprehensible than the language level models.  I think that defining a memory model in terms of hardware translations, for example, is a completely lost cause.  We need to keep things at an abstract level.

Hans

From: Vitaly Davidovich [mailto:vitalyd at gmail.com]
Sent: Wednesday, August 22, 2012 6:01 AM
To: Marko Topolnik
Cc: concurrency-interest at cs.oswego.edu; Boehm, Hans
Subject: Re: [concurrency-interest] Relativity of guarantees provided by volatile


If the JMM ever goes through a revision, it would be useful to state some basic assumptions such as threads get a chance to run on a processor so that "perverse" scenarios don't muddy the waters.

Also, as I mentioned earlier, I have an issue with the wording of a happens-before edge.  For example, thread A writes volatile memory and thread B reads that memory; but if there's no read, the JMM says nothing about what should happen to the write.  I also don't understand how a normal (i.e. non experimental/academic) JVM could even do this type of analysis consistently (e.g. the volatile field is public/protected) if we're not sacrificing performance.

I understand it's an abstract model and shouldn't be clouded with impl details of JVM/os/hardware, but I don't know if that's a good or bad thing.  It's bad enough that folks on this list have ambiguity over it, but what's a compiler writer to do, for example? Maybe the JMM can be lowered into something a bit more concrete?

Sent from my phone
On Aug 22, 2012 2:42 AM, "Marko Topolnik" <mtopolnik at inge-mark.hr<mailto:mtopolnik at inge-mark.hr>> wrote:

On 22. kol. 2012., at 01:40, Boehm, Hans wrote:
>> From: Marko Topolnik [mailto:mtopolnik at inge-mark.hr<mailto:mtopolnik at inge-mark.hr>]
>>
>>> Similar to your concern that consecutive volatile writes can be
>>> compressed into the last write, it also seems true that consecutive
>>> volatile reads can be compressed into the first read - exactly the
>>> kind of optimization to be disabled by C's volatile. It's
>>> inconceivable that any JVM will do such optimization on volatile
>>> reads, it'll break lots of programs, e.g. busy waits.
>>
>> Actually there is already a provision in the JMM (in the original
>> paper, at least) that prevents a busy-waiting loop whose condition
>> involves a volatile read to forever read a stale value. There can be
>> only a finite number of such read actions. But, this is a small
>> consolation, really. Most code DOES make a difference between "eternity
>> minus one" and "right now".
>>
> My recollection is that this is only sort of/mostly of true.  If your entire program consists of
>
> Thread 1:
> while (!flag) {}
>
> Thread 2:
> flag = true;
>
> There is intentionally no requirement that thread 2 ever be scheduled.  If it's not, that looks a lot like flag having been read once.  If, on the other hand, thread 2 sets flag and then prints "Hello", and you see the "Hello", then I believe you are correct that thread 1 must terminate.

If thread 2 never gets scheduled then the value of the flag is not stale (that's what I said---"read a stale value"). This JMM provision precludes bunching together an infinite amount of busy-wait flag checks, all reading the stale false value.

-Marko


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120823/49ec6115/attachment-0001.html>

From mtopolnik at inge-mark.hr  Thu Aug 23 02:02:05 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Thu, 23 Aug 2012 08:02:05 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <CACuKZqHcKtzfeOtj-Smv620iLrztLdDvMpauaHuJwX2CBprTBw@mail.gmail.com>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEDGJGAA.davidcholmes@aapt.net.au>
	<CAHjP37EihoHF8GHR8w69gPj63gKZATAeCdW3S0oKuXZmqrdxVA@mail.gmail.com>
	<CAC2Zdp3zDgw7O15fRQNhMPOosDZtruT8AtMjBCNRMbyMoQ75hA@mail.gmail.com>
	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>
	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>
	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>
	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>
	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>
	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>
	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>
	<40D1CAE6-7E3D-433E-8EBB-67E6C997DA4A@inge-mark.hr>
	<CACuKZqEtdE+_k6Xgwy6gP6gmVBbmP+y_4tAYmN6GV73w6r-W7g@mail.gmail.com>
	<8A7E6C23-57AF-44FF-882B-664A56B340C8@inge-mark.hr>
	<CACuKZqHcKtzfeOtj-Smv620iLrztLdDvMpauaHuJwX2CBprTBw@mail.gmail.com>
Message-ID: <D0EBDA8D-939C-48DF-B8EE-BDEFCE95FFB0@inge-mark.hr>

On 23. kol. 2012., at 01:17, Zhong Yu wrote:

> On Wed, Aug 22, 2012 at 4:44 PM, Marko Topolnik <mtopolnik at inge-mark.hr> wrote:
>>>> 
>>>> 
>>>>   Thread R                                  /--> Rr0 --> Rr1
>>>>                                 -----------+--------/
>>>>                               /            |
>>>>   Thread W        --> Rw0 -> Ww0 ---> Rw1 -+--> Ww1
>>>>                 /                /  ------/
>>>>                |                | /
>>>>   Thread T    Wt0 -----------> Wt1
>>> 
>>> Suppose W writes v=1, then observes t=1; R observes t=2, then read v.
>>> The last read cannot see v=0.
>>> 
>>> Therefore if R/W actions are sandwiched with reading the timing
>>> variable, we will not detect any apparent timing paradoxes.
>>> 
>>> Since we are not talking about physical time (beyond JMM) any more,
>>> instead just a variable (within JMM), JMM guarantees that any
>>> execution of the program appears to be sequentially consistent.
>> 
>> 
>> I was trying to form a minimal example to demonstrate the point, it seems still lacking. Consider the following graph, now there's three wall-clock writes involved:
>> 
>> 
>> Thread R                                         /--> Rr0 --> Rr1
>>                              ------------------+---------/
>>                            /                   |
>> Thread W        --> Rw0 -> Ww0 ---> Rw1 -> Ww1  |
>>              /                /                |
>>             |                |                 |
>> Thread T    Wt0 -----------> Wt1 ------------> Wt2
>> 
>> 
>> Say Wt0 writes t = 0 ms, Wt1 writes t = 3 ms, Wt2 writes t = 6 ms.
>> 
>> Also say Ww0 writes zero and Ww1 writes one.
>> 
>> Thread W says "I wrote zero at t = 0 ms and one at t = 3 ms."
> 
> W cannot say that, it's more like W wrote one after seeing t=3. That
> is not inconsistent with R reading zero after seeing t=6.
> 
> Note that the clock precision is not good here. For example, there is
> no paradox in "W wrote one before seeing t=6" and "R read zero after
> seeing t=6", because "t=6" can be seen in an extended time window.
> 
> A real paradox would be "W wrote one before seeing t=3" and "R read
> zero after seeing t=6", a timing error greater than clock precision.
> 
> JMM does not allow that paradox. If Rw2 sees t=3, Wt1<Rw2<Wt2 in sync
> order, therefore Ww1<Rw2 <Wt2<Rr0<Rr1, therefore Ww0<Ww1<Rr1, that
> forbids Rr1 seeing Ww0.

This would be the situation you describe:

                                /--> Rrt6 --/-> Rrt9 --> Rv0
    ---------------------------+------------+--------/
  /                            |     ------/
Wv0 ---> Rwt3 -> Wv1 --> Rwt6  |    /
        /                /   --|   /
       |                | /       /
       T3 ------------> T6 ----> T9


Notice I've fixed the naming somewhat. 

T3, T6, T9 -- writes to currentTime
Rwt0, Rwt1 -- reads of currentTime by writing thread
Rrt1, Rrt2 -- reads of currentTime by reading thread
Wv0, Wv1   -- writes to the sharedVar
Rv0        -- read of the sharedVar

initially t = 0 ms;
T3 writes t = 3 ms;
T6 writes t = 6 ms;
T9 writes t = 9 ms.

The program outputs

Writing 0 at t = 0 ms
Writing 1 at t = 3 ms
Reading 0 at t = 9 ms


> 
>> Thread R says "I read zero at t = 6 ms."
>> 
>> Note also the general pattern: there are no constraints imposed by the arrows from T to R on the arrows from W to R.
> 
> You missed the arrows from a read to the write that comes after:)

Not sure what you mean, but there is no synchronizes-with edge going from a read to a write. No arrows extend from one thread reading to another thread writing.

-Marko




From andreas.lochbihler at kit.edu  Thu Aug 23 04:01:12 2012
From: andreas.lochbihler at kit.edu (Andreas Lochbihler)
Date: Thu, 23 Aug 2012 10:01:12 +0200
Subject: [concurrency-interest] Relativity of guarantees provided
	by	volatile
In-Reply-To: <D0EBDA8D-939C-48DF-B8EE-BDEFCE95FFB0@inge-mark.hr>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>	<40D1CAE6-7E3D-433E-8EBB-67E6C997DA4A@inge-mark.hr>	<CACuKZqEtdE+_k6Xgwy6gP6gmVBbmP+y_4tAYmN6GV73w6r-W7g@mail.gmail.com>	<8A7E6C23-57AF-44FF-882B-664A56B340C8@inge-mark.hr>	<CACuKZqHcKtzfeOtj-Smv620iLrztLdDvMpauaHuJwX2CBprTBw@mail.gmail.com>
	<D0EBDA8D-939C-48DF-B8EE-BDEFCE95FFB0@inge-mark.hr>
Message-ID: <5035E348.4080501@kit.edu>

Dear Marko,

On 23.08.2012 08:02, Marko Topolnik wrote:
> This would be the situation you describe:
>
>                                  /-->  Rrt6 --/->  Rrt9 -->  Rv0
>      ---------------------------+------------+--------/
>    /                            |     ------/
> Wv0 --->  Rwt3 ->  Wv1 -->  Rwt6  |    /
>          /                /   --|   /
>         |                | /       /
>         T3 ------------>  T6 ---->  T9
>
>
> Notice I've fixed the naming somewhat.
>
> T3, T6, T9 -- writes to currentTime
> Rwt0, Rwt1 -- reads of currentTime by writing thread
> Rrt1, Rrt2 -- reads of currentTime by reading thread
> Wv0, Wv1   -- writes to the sharedVar
> Rv0        -- read of the sharedVar
>
> initially t = 0 ms;
> T3 writes t = 3 ms;
> T6 writes t = 6 ms;
> T9 writes t = 9 ms.
>
> The program outputs
>
> Writing 0 at t = 0 ms
> Writing 1 at t = 3 ms
> Reading 0 at t = 9 ms

The JMM does not allow this output if sharedVar and currentTime are volatile, as 
the following reasoning shows: All actions in your example are synchronisation 
actions, i.e., they must be totally ordered by the synchronisation order, but 
there is none.

Assume for the sake of contradiction there was such a synchronisation order <so.
1. Wv0 <so Wv1 and Wv1 <so Rwt6 and Rrt9 <so Rv0 hold, because synchronisation 
order is consistent with program order.
2. Not T9 <so Rwt6, because otherwise, T9 would be an intervening write between 
T6 and Rwt6 since T6 <so T9 which contradicts well-formedness (JLS 17.4.7.5).
3. Hence Rwt6 <so T9 by totality of the synchronisation order.
4. T9 <so Rwt9, because Rwt9 sees T9, i.e., well-formedness forbids T9 <so Rwt9, 
and <so is total.
5. Wv1 <so Rwt9 by transitivity of 1., 3., 4.
6. Hence, Wv1 is an intervening write between Wv0 and Rv0 in the synchronisation 
order (since Wv0 <so Wv1 from 1.), which contradicts well-formedness (JLS 17.4.7.5).

Andreas

-- 
Karlsruher Institut f?r Technologie
IPD Snelting

Andreas Lochbihler
wissenschaftlicher Mitarbeiter
Am Fasanengarten 5, Geb. 50.34, Raum 025
76131 Karlsruhe

Telefon: +49 721 608-47399
Fax: +49 721 608-48457
E-Mail: andreas.lochbihler at kit.edu
http://pp.info.uni-karlsruhe.de
KIT - Universit?t des Landes Baden-W?rttemberg und nationales Forschungszentrum 
in der Helmholtz-Gemeinschaft

From mtopolnik at inge-mark.hr  Thu Aug 23 05:19:06 2012
From: mtopolnik at inge-mark.hr (Marko Topolnik)
Date: Thu, 23 Aug 2012 11:19:06 +0200
Subject: [concurrency-interest] Relativity of guarantees provided by
	volatile
In-Reply-To: <5035E348.4080501@kit.edu>
References: <CAHjP37F5k9_ZCeMie0Oj+ZfARRw3AnmHzBnkOScsuh8kg8KxKQ@mail.gmail.com>	<CAHjP37ETrPqGZNgciAOrPpQLyS_S0FDvTh=BpYdAPTFKVToFGA@mail.gmail.com>	<CAC2Zdp1zu0Nydu+NG9wKLCRdURi39JWTU9XzF5-0ciVUcMN7wQ@mail.gmail.com>	<1375E513-EBB8-480C-B130-FD444025C973@inge-mark.hr>	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61EB7@G4W3296.americas.hpqcorp.net>	<CE761819-199C-478F-A33B-8BAD7B0629FD@inge-mark.hr>	<A3E67C2071F49C4CBC4F17E6D77CDDD235F61FF3@G4W3296.americas.hpqcorp.net>	<36C569DA-4D19-4CE2-9DF5-1A9B6689D3E2@inge-mark.hr>	<4E3E6AC7-E65C-4A84-BD67-E0E11599F158@inge-mark.hr>	<A3E67C2071F49C4CBC4F17E6D77CDDD235F62339@G4W3296.americas.hpqcorp.net>	<40D1CAE6-7E3D-433E-8EBB-67E6C997DA4A@inge-mark.hr>	<CACuKZqEtdE+_k6Xgwy6gP6gmVBbmP+y_4tAYmN6GV73w6r-W7g@mail.gmail.com>	<8A7E6C23-57AF-44FF-882B-664A56B340C8@inge-mark.hr>	<CACuKZqHcKtzfeOtj-Smv620iLrztLdDvMpauaHuJwX2CBprTBw@mail.gmail.com>
	<D0EBDA8D-939C-48DF-B8EE-BDEFCE95FFB0@inge-mark.hr>
	<5035E348.4080501@kit.edu>
Message-ID: <2C7026F2-6FBA-432C-8BB5-6FD66BAC064A@inge-mark.hr>


On 23. kol. 2012., at 10:01, Andreas Lochbihler wrote:
> Dear Marko,
> 
> On 23.08.2012 08:02, Marko Topolnik wrote:
>> This would be the situation you describe:
>> 
>>                                 /-->  Rrt6 --/->  Rrt9 -->  Rv0
>>     ---------------------------+------------+--------/
>>   /                            |     ------/
>> Wv0 --->  Rwt3 ->  Wv1 -->  Rwt6  |    /
>>         /                /   --|   /
>>        |                | /       /
>>        T3 ------------>  T6 ---->  T9
>> 
>> 
>> Notice I've fixed the naming somewhat.
>> 
>> T3, T6, T9 -- writes to currentTime
>> Rwt0, Rwt1 -- reads of currentTime by writing thread
>> Rrt1, Rrt2 -- reads of currentTime by reading thread
>> Wv0, Wv1   -- writes to the sharedVar
>> Rv0        -- read of the sharedVar
>> 
>> initially t = 0 ms;
>> T3 writes t = 3 ms;
>> T6 writes t = 6 ms;
>> T9 writes t = 9 ms.
>> 
>> The program outputs
>> 
>> Writing 0 at t = 0 ms
>> Writing 1 at t = 3 ms
>> Reading 0 at t = 9 ms
> 
> The JMM does not allow this output if sharedVar and currentTime are volatile, as the following reasoning shows: All actions in your example are synchronisation actions, i.e., they must be totally ordered by the synchronisation order, but there is none.
> 
> Assume for the sake of contradiction there was such a synchronisation order <so.
> 1. Wv0 <so Wv1 and Wv1 <so Rwt6 and Rrt9 <so Rv0 hold, because synchronisation order is consistent with program order.
> 2. Not T9 <so Rwt6, because otherwise, T9 would be an intervening write between T6 and Rwt6 since T6 <so T9 which contradicts well-formedness (JLS 17.4.7.5).
> 3. Hence Rwt6 <so T9 by totality of the synchronisation order.
> 4. T9 <so Rwt9, because Rwt9 sees T9, i.e., well-formedness forbids T9 <so Rwt9, and <so is total.
> 5. Wv1 <so Rwt9 by transitivity of 1., 3., 4.
> 6. Hence, Wv1 is an intervening write between Wv0 and Rv0 in the synchronisation order (since Wv0 <so Wv1 from 1.), which contradicts well-formedness (JLS 17.4.7.5).
> 
> Andreas

You are right, my example disregards the constraints imposed by the total synchronization order.

-Marko




From radhakrishnan.mohan at gmail.com  Fri Aug 24 04:19:08 2012
From: radhakrishnan.mohan at gmail.com (Mohan Radhakrishnan)
Date: Fri, 24 Aug 2012 13:49:08 +0530
Subject: [concurrency-interest] Parameterized CountedCompleters
In-Reply-To: <CAOoXFP8bmkjccrueJzyM8nFJRtD6oqyadz9r+6rqkxk365XjDg@mail.gmail.com>
References: <502CEAAB.8040809@cs.oswego.edu>
	<CAOoXFP_ZN1a+Ru=US06ibSRdbjfQG=0imsyVej8FOYM6o7VGJQ@mail.gmail.com>
	<50324E65.6060007@cs.oswego.edu>
	<CAOoXFP8bmkjccrueJzyM8nFJRtD6oqyadz9r+6rqkxk365XjDg@mail.gmail.com>
Message-ID: <CAOoXFP_ZCe8DhYK2rcn7Z9LL-8Vb_ye3aYjUuRnpFfN3jbX6tg@mail.gmail.com>

Hi,
       The following JMockit test could be used to actually test IO in a
simpler way.

Thanks,
Mohan



 public final void compute() {
            MasterSocketReceiver msr = new MasterSocketReceiver( new
MasterCompleter());
            msr.fork();
            try {
                ms.send( socket );
            } catch (IOException e) {
                System.out.println( "Exception in compute");
            }
            System.out.println( "MasterSocketReceiver" );
            tryComplete();
        }



/*JMockit Test to mock a socket*/
public class CountedCompleterTest {
    MessageSender ms = new MessageSender();
    @Test
    public void test()
    {
       new MockUp<Socket>()
       {
          @Mock/*Unable to know how many threads are invoking*/
          void $init(String host, int port)
          {
          }
          @Mock/*Unable to know how many threads are invoking*/
          public OutputStream getOutputStream()
          {
             return new ByteArrayOutputStream();
          }
          @Mock/*Unable to know how many threads are invoking*/
          public InputStream getInputStream()
          {
             return new
ByteArrayInputStream("CountedCompleterTest\n".getBytes());
          }
          @Mock(minInvocations = 1)
          void close() {}

       };
        Socket connection = null;
        try {
            connection = new Socket("localhost", 80);
            ms.send( connection );
            BufferedReader bin = new BufferedReader( new InputStreamReader(
connection.getInputStream() ));
            System.out.println( "Read [" + bin.readLine() + "]");
        } catch (IOException e) {
            System.out.println( "IOException" );
        }finally{
            try {
                connection.close();
            } catch (IOException e) {
                System.out.println( "IOException" );
            }
        }
        new CountedCompleters( connection );/Set socket in the constructor*/
    }
}
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120824/d7039a1b/attachment.html>

From radhakrishnan.mohan at gmail.com  Fri Aug 24 05:06:39 2012
From: radhakrishnan.mohan at gmail.com (Mohan Radhakrishnan)
Date: Fri, 24 Aug 2012 14:36:39 +0530
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CAHjP37E_PuCLsy0W401zzMHK_hx=sTdB=O-oz3vF8b9k70zPFg@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
	<CACuKZqHLSOa8zH3NAvNzcHmkV_+Eriy2MnEoRm2dD1OjhEpaYA@mail.gmail.com>
	<CAHjP37E_PuCLsy0W401zzMHK_hx=sTdB=O-oz3vF8b9k70zPFg@mail.gmail.com>
Message-ID: <CAOoXFP9fNmO9iW1AMXQD1s6czLZgLF7i6hv2MQ4SiqOtyzjStA@mail.gmail.com>

Is there any type of tests recommended to identify such issues apart from
visual inspection ? Normal coders don't generally have a concurrency
perspective and there are threads everywhere.

Is there a particular test that can idendify this particular safe
publishing issue ? just run several threads ?

Thanks,
Mohan

On Tue, Aug 21, 2012 at 1:11 AM, Vitaly Davidovich <vitalyd at gmail.com>wrote:

> Missing local variable is a problem, but the fact that BD cannot be
> published via data race is the primary issue.  If it was safe for such
> publishing, missing local would become the main issue. :)
>
> Sent from my phone
>  On Aug 20, 2012 2:08 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>
>> On Mon, Aug 20, 2012 at 6:49 AM, James <james at inaseq.com> wrote:
>> > I have a system that processes a lot of Doubles.  From time to time I
>> need
>> > the accuracy of BigDecimal math but creating a BigDecimal is relatively
>> > expensive so I only do it when needed.  Hence I use lazy initialization
>> as
>> > shown below.
>> >
>> > private Double price;  // although not final is effectively immutable
>> and
>> > guaranteed non-null when used below
>> > private transient BigDecimal priceBD;
>> >
>> > public BigDecimal getPriceBD() {
>> > if (priceBD == null) {
>> > priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
>> > required
>> > }
>> > return priceBD;
>> > }
>>
>> You may have omitted it for brevity, but a local variable is necessary
>> here for correctness. See String.hashCode()
>>
>> > This particular construction method does not use one of the MathContext
>> > based constructors but it was while investigating the thread safety of
>> this
>> > approach that I noticed that some of the constructors may not be safe.
>> >
>> > My concern is whether using this technique a second thread might see a
>> > BigDecimal that is not fully initialized.  I'm pretty sure it can, but
>> it
>> > wouldn't matter if the volatile intVal is enforcing happens-before in
>> > subsequent calls to the BigDecimal, however the constructors that
>> delegate
>> > to the method mentioned do things after setting the intVal.
>> >
>> > On 20 Aug 2012, at 12:32, Sergey Kuksenko <skuksenko at gmail.com> wrote:
>> >
>> > Hi James,
>> >
>> > - Look into jdk8 sources. New  BigDecimal has final fields (instead of
>> > volatile).
>> > - Could you explain what is the issue for safe publication in the old
>> code
>> > (look like everything is ok)?
>> >
>> > On Mon, Aug 20, 2012 at 2:58 PM, James <james at inaseq.com> wrote:
>> >>
>> >> I'm wondering whether the BigDecimal constructors that take a
>> MathContext
>> >> parameter exhibit initialization safety.  As far as I can tell (and I
>> could
>> >> be very wrong), BigDecimal is relying on the volatile nature of the
>> intVal
>> >> reference to ensure the BigDecimal is effectively immutable.  However,
>> the
>> >> constructors that take a MathContext delegate to the following method,
>> which
>> >> alters other members after intVal:
>> >>
>> >>     private void roundThis(MathContext mc) {
>> >>         BigDecimal rounded = doRound(this, mc);
>> >>         if (rounded == this)                 // wasn't rounded
>> >>             return;
>> >>         this.intVal     = rounded.intVal;
>> >>         this.intCompact = rounded.intCompact;
>> >>         this.scale      = rounded.scale;
>> >>         this.precision  = rounded.precision;
>> >>     }
>> >>
>> >> Is this a potential issue for safe publication or am I missing
>> something?
>> >> Is BigDecimal intended to exhibit initialization safety?
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> >
>> >
>> >
>> > --
>> > Best regards,
>> > Sergey Kuksenko
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120824/acf994a5/attachment.html>

From Per.Mildner at sics.se  Sun Aug 26 06:27:55 2012
From: Per.Mildner at sics.se (Per Mildner)
Date: Sun, 26 Aug 2012 12:27:55 +0200
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CACuKZqHLSOa8zH3NAvNzcHmkV_+Eriy2MnEoRm2dD1OjhEpaYA@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
	<CACuKZqHLSOa8zH3NAvNzcHmkV_+Eriy2MnEoRm2dD1OjhEpaYA@mail.gmail.com>
Message-ID: <F0AB17F8-038A-42E3-A096-288E4304DEFD@sics.se>


On Aug 20, 2012, at 7:58 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> On Mon, Aug 20, 2012 at 6:49 AM, James <james at inaseq.com> wrote:
>> I have a system that processes a lot of Doubles.  From time to time I need
>> the accuracy of BigDecimal math but creating a BigDecimal is relatively
>> expensive so I only do it when needed.  Hence I use lazy initialization as
>> shown below.
>> 
>> private Double price;  // although not final is effectively immutable and
>> guaranteed non-null when used below
>> private transient BigDecimal priceBD;
>> 
>> public BigDecimal getPriceBD() {
>> if (priceBD == null) {
>> priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
>> required
>> }
>> return priceBD;
>> }
> 
> You may have omitted it for brevity, but a local variable is necessary
> here for correctness. See String.hashCode()

Where, and why, would a local variable help?

Also, I do not see how this relates to String.hashCode().

What am I missing?

For reference, String.java:
{
    ...
    private int hash; // Default to 0
    ...
    public int hashCode() {
        int h = hash;
        if (h == 0 && count > 0) {
            int off = offset;
            char val[] = value;
            int len = count;

            for (int i = 0; i < len; i++) {
                h = 31*h + val[off++];
            }
            hash = h;
        }
        return h;
    }
  ...
}

Regards,

Per Mildner
Per.Mildner at sics.se




From java at java4.info  Sun Aug 26 07:05:57 2012
From: java at java4.info (Florian Binder)
Date: Sun, 26 Aug 2012 13:05:57 +0200
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <F0AB17F8-038A-42E3-A096-288E4304DEFD@sics.se>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
	<CACuKZqHLSOa8zH3NAvNzcHmkV_+Eriy2MnEoRm2dD1OjhEpaYA@mail.gmail.com>
	<F0AB17F8-038A-42E3-A096-288E4304DEFD@sics.se>
Message-ID: <503A0315.1090409@java4.info>

I think the problem is with the constructor:

     public String(String original) {
         this.value = original.value;
         this.hash = original.hash;
     }

Since value is final, but hash not, it could happen that thread A is 
creating the string and thread B calls hashCode() before the hash is 
set. If you would not have the local variable h it could happen that 
thread A writes the hash while thread B is calculating it (is in the for 
loop). This would lead to a random hash.
But is not the compiler allowed to replace the local variable h with the 
field hash, since this does not change intra-thread semantic?

Regards,
Flo


Am 26.08.2012 12:27, schrieb Per Mildner:
> On Aug 20, 2012, at 7:58 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>
>> On Mon, Aug 20, 2012 at 6:49 AM, James <james at inaseq.com> wrote:
>>> I have a system that processes a lot of Doubles.  From time to time I need
>>> the accuracy of BigDecimal math but creating a BigDecimal is relatively
>>> expensive so I only do it when needed.  Hence I use lazy initialization as
>>> shown below.
>>>
>>> private Double price;  // although not final is effectively immutable and
>>> guaranteed non-null when used below
>>> private transient BigDecimal priceBD;
>>>
>>> public BigDecimal getPriceBD() {
>>> if (priceBD == null) {
>>> priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
>>> required
>>> }
>>> return priceBD;
>>> }
>> You may have omitted it for brevity, but a local variable is necessary
>> here for correctness. See String.hashCode()
> Where, and why, would a local variable help?
>
> Also, I do not see how this relates to String.hashCode().
>
> What am I missing?
>
> For reference, String.java:
> {
>      ...
>      private int hash; // Default to 0
>      ...
>      public int hashCode() {
>          int h = hash;
>          if (h == 0 && count > 0) {
>              int off = offset;
>              char val[] = value;
>              int len = count;
>
>              for (int i = 0; i < len; i++) {
>                  h = 31*h + val[off++];
>              }
>              hash = h;
>          }
>          return h;
>      }
>    ...
> }
>
> Regards,
>
> Per Mildner
> Per.Mildner at sics.se
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From stanimir at riflexo.com  Sun Aug 26 09:47:26 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Sun, 26 Aug 2012 16:47:26 +0300
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <503A0315.1090409@java4.info>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
	<CACuKZqHLSOa8zH3NAvNzcHmkV_+Eriy2MnEoRm2dD1OjhEpaYA@mail.gmail.com>
	<F0AB17F8-038A-42E3-A096-288E4304DEFD@sics.se>
	<503A0315.1090409@java4.info>
Message-ID: <CAEJX8orAFg6xyDEVQX_8heqhfajGGfrt5gGbK1RuJ9mZAc4aJg@mail.gmail.com>

> But is not the compiler allowed to replace the local variable h with the
> field hash, since this does not change intra-thread semantic?
>
> Imagine  val[off++] actually throws ArrayIndexOutOfBoundsExcepton, that
would lead to incorrect result, i.e. hash would be initialized while it
should have not been. Same w/ any other Error (like ThreadDeath).

Stanimir



>
> Am 26.08.2012 12:27, schrieb Per Mildner:
>
>  On Aug 20, 2012, at 7:58 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>
>>  On Mon, Aug 20, 2012 at 6:49 AM, James <james at inaseq.com> wrote:
>>>
>>>> I have a system that processes a lot of Doubles.  From time to time I
>>>> need
>>>> the accuracy of BigDecimal math but creating a BigDecimal is relatively
>>>> expensive so I only do it when needed.  Hence I use lazy initialization
>>>> as
>>>> shown below.
>>>>
>>>> private Double price;  // although not final is effectively immutable
>>>> and
>>>> guaranteed non-null when used below
>>>> private transient BigDecimal priceBD;
>>>>
>>>> public BigDecimal getPriceBD() {
>>>> if (priceBD == null) {
>>>> priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
>>>> required
>>>> }
>>>> return priceBD;
>>>> }
>>>>
>>> You may have omitted it for brevity, but a local variable is necessary
>>> here for correctness. See String.hashCode()
>>>
>> Where, and why, would a local variable help?
>>
>> Also, I do not see how this relates to String.hashCode().
>>
>> What am I missing?
>>
>> For reference, String.java:
>> {
>>      ...
>>      private int hash; // Default to 0
>>      ...
>>      public int hashCode() {
>>          int h = hash;
>>          if (h == 0 && count > 0) {
>>              int off = offset;
>>              char val[] = value;
>>              int len = count;
>>
>>              for (int i = 0; i < len; i++) {
>>                  h = 31*h + val[off++];
>>              }
>>              hash = h;
>>          }
>>          return h;
>>      }
>>    ...
>> }
>>
>> Regards,
>>
>> Per Mildner
>> Per.Mildner at sics.se
>>
>>
>>
>> ______________________________**_________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120826/e9a4d738/attachment.html>

From vitalyd at gmail.com  Sun Aug 26 10:18:37 2012
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Sun, 26 Aug 2012 10:18:37 -0400
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <F0AB17F8-038A-42E3-A096-288E4304DEFD@sics.se>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
	<CACuKZqHLSOa8zH3NAvNzcHmkV_+Eriy2MnEoRm2dD1OjhEpaYA@mail.gmail.com>
	<F0AB17F8-038A-42E3-A096-288E4304DEFD@sics.se>
Message-ID: <CAHjP37FMqdyMoW4ST3kqP=ek2hrCQ4SUPxLnJYxYb12BM=PT5g@mail.gmail.com>

Compiler can turn that code into:

BigDecimal tmp = priceBD;
if (priceBD == null)
{
       // init priceBD
        tmp = priceBD;
}
return tmp;

Imagine that thread 1 reads null into temp but then gets preempted and
thread 2 goes through and initializes priceBD.  When thread 1 resumes,
it'll see a non-null priceBD and then happily return a null, which breaks
the logic.

Reading and returning a temp yourself prevents this type of reordering.

Sent from my phone
On Aug 26, 2012 6:32 AM, "Per Mildner" <Per.Mildner at sics.se> wrote:

>
> On Aug 20, 2012, at 7:58 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>
> > On Mon, Aug 20, 2012 at 6:49 AM, James <james at inaseq.com> wrote:
> >> I have a system that processes a lot of Doubles.  From time to time I
> need
> >> the accuracy of BigDecimal math but creating a BigDecimal is relatively
> >> expensive so I only do it when needed.  Hence I use lazy initialization
> as
> >> shown below.
> >>
> >> private Double price;  // although not final is effectively immutable
> and
> >> guaranteed non-null when used below
> >> private transient BigDecimal priceBD;
> >>
> >> public BigDecimal getPriceBD() {
> >> if (priceBD == null) {
> >> priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
> >> required
> >> }
> >> return priceBD;
> >> }
> >
> > You may have omitted it for brevity, but a local variable is necessary
> > here for correctness. See String.hashCode()
>
> Where, and why, would a local variable help?
>
> Also, I do not see how this relates to String.hashCode().
>
> What am I missing?
>
> For reference, String.java:
> {
>     ...
>     private int hash; // Default to 0
>     ...
>     public int hashCode() {
>         int h = hash;
>         if (h == 0 && count > 0) {
>             int off = offset;
>             char val[] = value;
>             int len = count;
>
>             for (int i = 0; i < len; i++) {
>                 h = 31*h + val[off++];
>             }
>             hash = h;
>         }
>         return h;
>     }
>   ...
> }
>
> Regards,
>
> Per Mildner
> Per.Mildner at sics.se
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120826/1366bc7a/attachment.html>

From Per.Mildner at sics.se  Sun Aug 26 11:21:00 2012
From: Per.Mildner at sics.se (Per Mildner)
Date: Sun, 26 Aug 2012 17:21:00 +0200
Subject: [concurrency-interest] BigDecimal Safe Publication
In-Reply-To: <CAHjP37FMqdyMoW4ST3kqP=ek2hrCQ4SUPxLnJYxYb12BM=PT5g@mail.gmail.com>
References: <A84C3FE8-82D9-4037-93E0-6074CF7B4980@inaseq.com>
	<CAOBqY9B2b0x2+4d7Hj8rzrfhBi4gw5Zm7j9yMSwYY0Q23isQew@mail.gmail.com>
	<1F7CC375-641E-484A-8445-755851F506B4@inaseq.com>
	<CACuKZqHLSOa8zH3NAvNzcHmkV_+Eriy2MnEoRm2dD1OjhEpaYA@mail.gmail.com>
	<F0AB17F8-038A-42E3-A096-288E4304DEFD@sics.se>
	<CAHjP37FMqdyMoW4ST3kqP=ek2hrCQ4SUPxLnJYxYb12BM=PT5g@mail.gmail.com>
Message-ID: <DD10B8CD-F9F6-4C64-9FFD-5164AF5A3C1D@sics.se>


On Aug 26, 2012, at 4:18 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:

> Compiler can turn that code into:
> 
> BigDecimal tmp = priceBD;
> if (priceBD == null)
> {
>        // init priceBD
>         tmp = priceBD;
> }
> return tmp;
> 
> Imagine that thread 1 reads null into temp but then gets preempted and thread 2 goes through and initializes priceBD.  When thread 1 resumes, it'll see a non-null priceBD and then happily return a null, which breaks the logic.
> 
> Reading and returning a temp yourself prevents this type of reordering.

I see. Thanks.

> 
> Sent from my phone
> 
> On Aug 26, 2012 6:32 AM, "Per Mildner" <Per.Mildner at sics.se> wrote:
> 
> On Aug 20, 2012, at 7:58 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
> 
> > On Mon, Aug 20, 2012 at 6:49 AM, James <james at inaseq.com> wrote:
> >> I have a system that processes a lot of Doubles.  From time to time I need
> >> the accuracy of BigDecimal math but creating a BigDecimal is relatively
> >> expensive so I only do it when needed.  Hence I use lazy initialization as
> >> shown below.
> >>
> >> private Double price;  // although not final is effectively immutable and
> >> guaranteed non-null when used below
> >> private transient BigDecimal priceBD;
> >>
> >> public BigDecimal getPriceBD() {
> >> if (priceBD == null) {
> >> priceBD = BigDecimal.valueOf(price);  // strict singleton semantics not
> >> required
> >> }
> >> return priceBD;
> >> }
> >
> > You may have omitted it for brevity, but a local variable is necessary
> > here for correctness. See String.hashCode()
> 
> Where, and why, would a local variable help?
> 
> Also, I do not see how this relates to String.hashCode().
> 
> What am I missing?
> 
> For reference, String.java:
> {
>     ...
>     private int hash; // Default to 0
>     ...
>     public int hashCode() {
>         int h = hash;
>         if (h == 0 && count > 0) {
>             int off = offset;
>             char val[] = value;
>             int len = count;
> 
>             for (int i = 0; i < len; i++) {
>                 h = 31*h + val[off++];
>             }
>             hash = h;
>         }
>         return h;
>     }
>   ...
> }
> 
> Regards,
> 
> Per Mildner
> Per.Mildner at sics.se
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

Per Mildner
Per.Mildner at sics.se





From andrew_nuss at yahoo.com  Mon Aug 27 13:16:37 2012
From: andrew_nuss at yahoo.com (Andy Nuss)
Date: Mon, 27 Aug 2012 10:16:37 -0700 (PDT)
Subject: [concurrency-interest] jni effectively immutable "constructor"
	guarded by java volatile for safe publishing
Message-ID: <1346087797.66529.YahooMailNeo@web120305.mail.ne1.yahoo.com>

Hi,

1) I have a native function which passes several params and uses a native 
C++ constructor in-place constructor relative to a saved nio direct bytebuffer to create an object,? returning a long which is cast from 
the pointer to object.? This object's constructed values are effectively immutable in that only that native call sets the members of the obect.? The C++ object then can do work based on its constructed state.

2) java code that makes the above calls safely publishes the longified version of the C++ pointer (created above)
somewhere (without mutex) and changes a volatile variable to hopefully 
publish the memory changes made in the "constructor" above to other threads.

Now
 another java thread reads that volatile fence variable of 2), and then picks up 
that published long, and calls another native function that accesses 
that effectively immutable object in the C++ memory space to do some 
work.

Is that other thread guaranteed to see the fully constructed native 
object because of the Java Memory Model guarantees about volatiles and 
fences?? I would bet the answer is yes on some platforms, but I see that
 different chips work different ways with using fences, and was 
wondering about all platforms for which java is available.? I couldn't 
tell by googling whether the Java Memory Model made guarantees relative 
to changes in *all* memory, not just that of the virtual machine.? Maybe sun.misc.Unsafe might come to the rescue?

(By
 the way, I need to use mutexes in my native code too for the purpose of subdividing the nio bytebuffer of 1), and found that 
JNI MontorEnter() was extraordinarily slow, as are all callbacks into 
java code.? I saw somewhere that it is safe to use POSIX threads' or 
Windows threads' semaphores as long as during the critical section, 
there are no callbacks into jvm.? But I wonder if anyone can answer this other question?)

Andy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120827/ffaa9039/attachment.html>

From davidcholmes at aapt.net.au  Mon Aug 27 18:02:00 2012
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 28 Aug 2012 08:02:00 +1000
Subject: [concurrency-interest] jni effectively immutable
	"constructor"guarded by java volatile for safe publishing
In-Reply-To: <1346087797.66529.YahooMailNeo@web120305.mail.ne1.yahoo.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEHDJGAA.davidcholmes@aapt.net.au>

Hi Andy,

I don't think the JMM guarantees extend to anything outside the Java heap -
or more specifically it only applies to Java fields. In practice the
barriers/fences used today are coarse-grained and will affect all memory
equally (assuming you aren't using native mapping techniques to place shared
buffers in special memory locations!). In addition the transitions to/from
native code require their own barriers/fences to ensure the thread and the
VM have a consistent view of each other - this is the case in hotspot. Your
use of volatiles at the Java level then introduces additional happens-before
ordering. So I'd say that in practice this will work fine (as long as you
are using normal process memory), but nothing is guaranteeing you that.

To your second question, it is fine, in hotspot at least, to use native
synchronization objects, and you can call back into Java with no problem.
The usual caveat is that you are responsible for ensuring there are no
deadlocks introduced. This assumes regular Java code calling native methods
and the native methods using regular JNI calls to invoke Java methods.
Things can get problematic if you use (JVMTI) agents but for regular
Java/native code there are no special issues.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Andy Nuss
  Sent: Tuesday, 28 August 2012 3:17 AM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] jni effectively immutable
"constructor"guarded by java volatile for safe publishing


  Hi,


  1) I have a native function which passes several params and uses a native
C++ constructor in-place constructor relative to a saved nio direct
bytebuffer to create an object,  returning a long which is cast from the
pointer to object.  This object's constructed values are effectively
immutable in that only that native call sets the members of the obect.  The
C++ object then can do work based on its constructed state.

  2) java code that makes the above calls safely publishes the longified
version of the C++ pointer (created above) somewhere (without mutex) and
changes a volatile variable to hopefully publish the memory changes made in
the "constructor" above to other threads.

  Now another java thread reads that volatile fence variable of 2), and then
picks up that published long, and calls another native function that
accesses that effectively immutable object in the C++ memory space to do
some work.

  Is that other thread guaranteed to see the fully constructed native object
because of the Java Memory Model guarantees about volatiles and fences?  I
would bet the answer is yes on some platforms, but I see that different
chips work different ways with using fences, and was wondering about all
platforms for which java is available.  I couldn't tell by googling whether
the Java Memory Model made guarantees relative to changes in *all* memory,
not just that of the virtual machine.  Maybe sun.misc.Unsafe might come to
the rescue?

  (By the way, I need to use mutexes in my native code too for the purpose
of subdividing the nio bytebuffer of 1), and found that JNI MontorEnter()
was extraordinarily slow, as are all callbacks into java code.  I saw
somewhere that it is safe to use POSIX threads' or Windows threads'
semaphores as long as during the critical section, there are no callbacks
into jvm.  But I wonder if anyone can answer this other question?)


  Andy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120828/6c70d6a2/attachment.html>

From hans.boehm at hp.com  Mon Aug 27 18:18:37 2012
From: hans.boehm at hp.com (Boehm, Hans)
Date: Mon, 27 Aug 2012 22:18:37 +0000
Subject: [concurrency-interest] jni effectively
	immutable	"constructor"guarded by java volatile for safe publishing
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEHDJGAA.davidcholmes@aapt.net.au>
References: <1346087797.66529.YahooMailNeo@web120305.mail.ne1.yahoo.com>
	<NFBBKALFDCPFIDBNKAPCCEHDJGAA.davidcholmes@aapt.net.au>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD235F64000@G4W3296.americas.hpqcorp.net>

Some of us have definitely considered it a goal to ensure that Java, C, and C++ synchronization works together as expected, with Java synchronization providing the right visibility guarantees for C or C++ variables, and conversely.  In particular mixed language data-race-free programs should still be sequentially consistent unless you say otherwise.  I agree with David, that in a case like this, extremely unlikely to encounter problems, but there is no written guarantee of that.  In more esoteric cases (e.g. the often cited IRIW example, where one variable is a Java volatile variable, and the other a C++ atomic variable, accessed in native code), having the interaction work correctly requires that choices made by the C ABI are consistent with the choices made by JVM implementers.  I suspect that in some cases we're not there yet when it comes to these esoteric cases.  But that's unlikely to create practical problems.

Hans

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David Holmes
Sent: Monday, August 27, 2012 3:02 PM
To: Andy Nuss; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] jni effectively immutable "constructor"guarded by java volatile for safe publishing

Hi Andy,

I don't think the JMM guarantees extend to anything outside the Java heap - or more specifically it only applies to Java fields. In practice the barriers/fences used today are coarse-grained and will affect all memory equally (assuming you aren't using native mapping techniques to place shared buffers in special memory locations!). In addition the transitions to/from native code require their own barriers/fences to ensure the thread and the VM have a consistent view of each other - this is the case in hotspot. Your use of volatiles at the Java level then introduces additional happens-before ordering. So I'd say that in practice this will work fine (as long as you are using normal process memory), but nothing is guaranteeing you that.

To your second question, it is fine, in hotspot at least, to use native synchronization objects, and you can call back into Java with no problem. The usual caveat is that you are responsible for ensuring there are no deadlocks introduced. This assumes regular Java code calling native methods and the native methods using regular JNI calls to invoke Java methods. Things can get problematic if you use (JVMTI) agents but for regular Java/native code there are no special issues.

David Holmes
-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Andy Nuss
Sent: Tuesday, 28 August 2012 3:17 AM
To: concurrency-interest at cs.oswego.edu
Subject: [concurrency-interest] jni effectively immutable "constructor"guarded by java volatile for safe publishing
Hi,

1) I have a native function which passes several params and uses a native C++ constructor in-place constructor relative to a saved nio direct bytebuffer to create an object,  returning a long which is cast from the pointer to object.  This object's constructed values are effectively immutable in that only that native call sets the members of the obect.  The C++ object then can do work based on its constructed state.

2) java code that makes the above calls safely publishes the longified version of the C++ pointer (created above) somewhere (without mutex) and changes a volatile variable to hopefully publish the memory changes made in the "constructor" above to other threads.

Now another java thread reads that volatile fence variable of 2), and then picks up that published long, and calls another native function that accesses that effectively immutable object in the C++ memory space to do some work.

Is that other thread guaranteed to see the fully constructed native object because of the Java Memory Model guarantees about volatiles and fences?  I would bet the answer is yes on some platforms, but I see that different chips work different ways with using fences, and was wondering about all platforms for which java is available.  I couldn't tell by googling whether the Java Memory Model made guarantees relative to changes in *all* memory, not just that of the virtual machine.  Maybe sun.misc.Unsafe might come to the rescue?

(By the way, I need to use mutexes in my native code too for the purpose of subdividing the nio bytebuffer of 1), and found that JNI MontorEnter() was extraordinarily slow, as are all callbacks into java code.  I saw somewhere that it is safe to use POSIX threads' or Windows threads' semaphores as long as during the critical section, there are no callbacks into jvm.  But I wonder if anyone can answer this other question?)

Andy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120827/ac5ad5ca/attachment-0001.html>

From zhong.j.yu at gmail.com  Mon Aug 27 20:18:31 2012
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Mon, 27 Aug 2012 19:18:31 -0500
Subject: [concurrency-interest] jni effectively immutable "constructor"
 guarded by java volatile for safe publishing
In-Reply-To: <1346087797.66529.YahooMailNeo@web120305.mail.ne1.yahoo.com>
References: <1346087797.66529.YahooMailNeo@web120305.mail.ne1.yahoo.com>
Message-ID: <CACuKZqH6Rdqbugnuw7fErf+3FFMnyPyVg=WyWnb4MGBzTecgsQ@mail.gmail.com>

just curious - an object is created on a direct ByteBuffer, which
resides outside java heap. how would garbage collector treat the
object?

On Mon, Aug 27, 2012 at 12:16 PM, Andy Nuss <andrew_nuss at yahoo.com> wrote:
> Hi,
>
> 1) I have a native function which passes several params and uses a native
> C++ constructor in-place constructor relative to a saved nio direct
> bytebuffer to create an object,  returning a long which is cast from the
> pointer to object.  This object's constructed values are effectively
> immutable in that only that native call sets the members of the obect.  The
> C++ object then can do work based on its constructed state.
>
> 2) java code that makes the above calls safely publishes the longified
> version of the C++ pointer (created above) somewhere (without mutex) and
> changes a volatile variable to hopefully publish the memory changes made in
> the "constructor" above to other threads.
>
> Now another java thread reads that volatile fence variable of 2), and then
> picks up that published long, and calls another native function that
> accesses that effectively immutable object in the C++ memory space to do
> some work.
>
> Is that other thread guaranteed to see the fully constructed native object
> because of the Java Memory Model guarantees about volatiles and fences?  I
> would bet the answer is yes on some platforms, but I see that different
> chips work different ways with using fences, and was wondering about all
> platforms for which java is available.  I couldn't tell by googling whether
> the Java Memory Model made guarantees relative to changes in *all* memory,
> not just that of the virtual machine.  Maybe sun.misc.Unsafe might come to
> the rescue?
>
> (By the way, I need to use mutexes in my native code too for the purpose of
> subdividing the nio bytebuffer of 1), and found that JNI MontorEnter() was
> extraordinarily slow, as are all callbacks into java code.  I saw somewhere
> that it is safe to use POSIX threads' or Windows threads' semaphores as long
> as during the critical section, there are no callbacks into jvm.  But I
> wonder if anyone can answer this other question?)
>
> Andy
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From stanimir at riflexo.com  Mon Aug 27 21:26:00 2012
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Tue, 28 Aug 2012 04:26:00 +0300
Subject: [concurrency-interest] jni effectively immutable "constructor"
 guarded by java volatile for safe publishing
In-Reply-To: <CACuKZqH6Rdqbugnuw7fErf+3FFMnyPyVg=WyWnb4MGBzTecgsQ@mail.gmail.com>
References: <1346087797.66529.YahooMailNeo@web120305.mail.ne1.yahoo.com>
	<CACuKZqH6Rdqbugnuw7fErf+3FFMnyPyVg=WyWnb4MGBzTecgsQ@mail.gmail.com>
Message-ID: <CAEJX8opwPB5gZYGiaeq6ypyCtLCgLVHqUSR+uNHmZcfkBsVYMw@mail.gmail.com>

The direct buffer itself resides IN the java heap, it has a native C
pointer to (pre) allocated memory (malloc/mmap) outside the heap.
When there are no references left (sun.misc.Cleaner extends
PhantomReference) the finalizer thread frees the allocated memory
(free/munmap).

So basically the handling is left to phantom reference and clean-up code
(similar to finalization)

Stanimir

On Tue, Aug 28, 2012 at 3:18 AM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> just curious - an object is created on a direct ByteBuffer, which
> resides outside java heap. how would garbage collector treat the
> object?
>
> On Mon, Aug 27, 2012 at 12:16 PM, Andy Nuss <andrew_nuss at yahoo.com> wrote:
> > Hi,
> >
> > 1) I have a native function which passes several params and uses a native
> > C++ constructor in-place constructor relative to a saved nio direct
> > bytebuffer to create an object,  returning a long which is cast from the
> > pointer to object.  This object's constructed values are effectively
> > immutable in that only that native call sets the members of the obect.
>  The
> > C++ object then can do work based on its constructed state.
> >
> > 2) java code that makes the above calls safely publishes the longified
> > version of the C++ pointer (created above) somewhere (without mutex) and
> > changes a volatile variable to hopefully publish the memory changes made
> in
> > the "constructor" above to other threads.
> >
> > Now another java thread reads that volatile fence variable of 2), and
> then
> > picks up that published long, and calls another native function that
> > accesses that effectively immutable object in the C++ memory space to do
> > some work.
> >
> > Is that other thread guaranteed to see the fully constructed native
> object
> > because of the Java Memory Model guarantees about volatiles and fences?
>  I
> > would bet the answer is yes on some platforms, but I see that different
> > chips work different ways with using fences, and was wondering about all
> > platforms for which java is available.  I couldn't tell by googling
> whether
> > the Java Memory Model made guarantees relative to changes in *all*
> memory,
> > not just that of the virtual machine.  Maybe sun.misc.Unsafe might come
> to
> > the rescue?
> >
> > (By the way, I need to use mutexes in my native code too for the purpose
> of
> > subdividing the nio bytebuffer of 1), and found that JNI MontorEnter()
> was
> > extraordinarily slow, as are all callbacks into java code.  I saw
> somewhere
> > that it is safe to use POSIX threads' or Windows threads' semaphores as
> long
> > as during the critical section, there are no callbacks into jvm.  But I
> > wonder if anyone can answer this other question?)
> >
> > Andy
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20120828/23c8fd28/attachment.html>

From aleksey.shipilev at oracle.com  Tue Aug 28 04:36:09 2012
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Tue, 28 Aug 2012 12:36:09 +0400
Subject: [concurrency-interest] Parameterized CountedCompleters
In-Reply-To: <502CEAAB.8040809@cs.oswego.edu>
References: <502CEAAB.8040809@cs.oswego.edu>
Message-ID: <503C82F9.7090403@oracle.com>

Thanks Doug.

I had pulled this update to fjp-trace as well.

-Aleksey.

On 08/16/2012 04:42 PM, Doug Lea wrote:
> 
> While the most common use cases for CountedCompleters are for
> void actions, there is no good reason to force them to be.
> Several people have wanted to use result-bearing forms, so
> they now support this.
> 
> They now can/should/must be declared as CountedCompleter<T>,
> and you can override method getRawResult to return any appropriate
> result that will be relayed to any call to invoke, join, etc.
> 
> Unlike the case of RecursiveTask<T>, we have no idea how you are
> representing result values, so the protected setRawResult(T x)
> method is by default a no-op. You can override this if desired
> to do some sort of result maintenance, but typically won't.
> 
> This turns out to be a binary-compatible change, so there's
> no need to adjust existing usages immediately. And it is even
> source compatible, although will encounter may "raw type"
> compiler warnings.
> 
> At some point, you'll want to replace
>   class MyCC extends CountedCompleter
> with
>   class MyCC extends CountedCompleter<Void>
> 
> and constructors of form
>   MyCC(CountedCompleter p, ...) { super(p); ...}
> with
>   MyCC(CountedCompleter<?> p, ...) { super(p); ...}
> and similarly for any other methods accepting CountedCompleters).
> 
> This change is now in jsr166y, jsr166e, and j.u.c jars and sources.
> 
> -Doug
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


