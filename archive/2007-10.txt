From David.Biesack at sas.com  Mon Oct  1 15:22:33 2007
From: David.Biesack at sas.com (David J. Biesack)
Date: Mon, 1 Oct 2007 15:22:33 -0400 (EDT)
Subject: [concurrency-interest] JCiP Memoizer: should Computable throw
	Exception?
Message-ID: <200710011922.l91JMXUJ012622@cs.oswego.edu>


The specification of compute() in the Computable interface in JCiP 
(p. 103) does not throw a generic Exception, just InterruptedException:

    interface Computable<A, V> {
      V compute(A arg) InterruptedException;
    }

I note that in an earlier presentation by Tim Peierls
(www.javasig.com/Archive/lectures/JavaSIG-TigerConcurrency.ppt),
Computable is defined as

    interface Computable<A, V> {
      V compute(A arg) throws Exception;
    }

(similar to call() in Callable<V>). I'm curious if anyone knows
the reasons/history behind this difference; i.e. why it is not

    interface Computable<A, V> {
      V compute(A arg) throws Exception, InterruptedException;
    }

in the book. Many "computable" and cachable functions throw checked
exceptions. I realize that Memoizer catches the ExecutionException from the
FutureTask, but the lack of 'throws Exception' in the interface means
that Computable implementors must also launder checked exceptions.

I'd like to know if there are known framework/API/design problems with
defining Computable to throw Exception. I often avoid 'throws
Exception' but I recognize the utility in frameworks which allow such
callouts.

thanks

-- 
David J. Biesack     SAS Institute Inc.
(919) 531-7771       SAS Campus Drive
http://www.sas.com   Cary, NC 27513


From tim at peierls.net  Mon Oct  1 16:14:48 2007
From: tim at peierls.net (Tim Peierls)
Date: Mon, 1 Oct 2007 16:14:48 -0400
Subject: [concurrency-interest] JCiP Memoizer: should Computable throw
	Exception?
In-Reply-To: <200710011922.l91JMXUJ012622@cs.oswego.edu>
References: <200710011922.l91JMXUJ012622@cs.oswego.edu>
Message-ID: <63b4e4050710011314g4ca8bb83qa90b162119081a68@mail.gmail.com>

On 10/1/07, David J. Biesack <David.Biesack at sas.com> wrote:
>
> I note that in an earlier presentation by Tim Peierls
> (www.javasig.com/Archive/lectures/JavaSIG-TigerConcurrency.ppt),
> Computable is defined as
>
>     interface Computable<A, V> {
>       V compute(A arg) throws Exception;
>     }
>
> (similar to call() in Callable<V>). I'm curious if anyone knows
> the reasons/history behind this difference; i.e. why it is not
>
>     interface Computable<A, V> {
>       V compute(A arg) throws Exception, InterruptedException;
>     }
>
> in the book.


That Java SIG presentation was a preliminary version of the BoF that Joe
Bowbeer and I conducted a week or so later at JavaOne 2004. At some point in
between, we must have thought better of omitting the throws Exception clause
in Computable. It might have been a mistake, in retrospect.


Many "computable" and cachable functions throw checked
> exceptions. I realize that Memoizer catches the ExecutionException from
> the
> FutureTask, but the lack of 'throws Exception' in the interface means
> that Computable implementors must also launder checked exceptions.


Right. It's a pain.


I'd like to know if there are known framework/API/design problems with
> defining Computable to throw Exception. I often avoid 'throws
> Exception' but I recognize the utility in frameworks which allow such
> callouts.
>

My experience has been that, in "functional-ish" settings, checked
exceptions cause more trouble than they're worth, even (especially!) if you
get fancy with things like "<X extends Exception> ... throws X". What does
it mean to cache the result of a computation that throws a checked
exception? It's hard to reason about.

Maybe it's a sign of changing views on the subject that in Doug Lea's recent
work the abstract ForkJoinTask doesn't let you throw checked exceptions from
its compute method.

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071001/e82491d1/attachment.html 

From joe.bowbeer at gmail.com  Mon Oct  1 16:34:09 2007
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 1 Oct 2007 13:34:09 -0700
Subject: [concurrency-interest] JCiP Memoizer: should Computable throw
	Exception?
In-Reply-To: <200710011922.l91JMXUJ012622@cs.oswego.edu>
References: <200710011922.l91JMXUJ012622@cs.oswego.edu>
Message-ID: <31f2a7bd0710011334t59ad1adbn64976b36a7deaa83@mail.gmail.com>

David,

I defined Computable to throw Exception when Tim and I created the
original example for JavaOne a few years ago:

interface Computable<A, V> {
  V compute(A arg) throws Exception;
}

In this way, Computable is analogous to a Callable that accepts an argument.

But Brian and Tim changed this for the book to simplify the example.

That's one explanation, anyway:)

In fact, Tim and I adhere to different sides of the checked vs.
unchecked exception debate.  I prefer checked exceptions and I like to
maintain a distinction between Exception in my thread versus an
ExecutionException in a worker thread, whereas Tim is more likely to
finesse things using unchecked exceptions, and to unwrap
ExceptionExceptions and rethrow them as unchecked exceptions in the
current thread.

So Computable changes depending on who's writing about it.

--
Joe Bowbeer

On 10/1/07, David J. Biesack <David.Biesack at sas.com> wrote:
>
> The specification of compute() in the Computable interface in JCiP
> (p. 103) does not throw a generic Exception, just InterruptedException:
>
>     interface Computable<A, V> {
>       V compute(A arg) InterruptedException;
>     }
>
> I note that in an earlier presentation by Tim Peierls
> (www.javasig.com/Archive/lectures/JavaSIG-TigerConcurrency.ppt),
> Computable is defined as
>
>     interface Computable<A, V> {
>       V compute(A arg) throws Exception;
>     }
>
> (similar to call() in Callable<V>). I'm curious if anyone knows
> the reasons/history behind this difference; i.e. why it is not
>
>     interface Computable<A, V> {
>       V compute(A arg) throws Exception, InterruptedException;
>     }
>
> in the book. Many "computable" and cachable functions throw checked
> exceptions. I realize that Memoizer catches the ExecutionException from the
> FutureTask, but the lack of 'throws Exception' in the interface means
> that Computable implementors must also launder checked exceptions.
>
> I'd like to know if there are known framework/API/design problems with
> defining Computable to throw Exception. I often avoid 'throws
> Exception' but I recognize the utility in frameworks which allow such
> callouts.
>
> thanks
>
> --
> David J. Biesack     SAS Institute Inc.
> (919) 531-7771       SAS Campus Drive
> http://www.sas.com   Cary, NC 27513
>

From tim at peierls.net  Tue Oct  2 07:30:24 2007
From: tim at peierls.net (Tim Peierls)
Date: Tue, 2 Oct 2007 07:30:24 -0400
Subject: [concurrency-interest] JCiP Memoizer: should Computable throw
	Exception?
In-Reply-To: <31f2a7bd0710011334t59ad1adbn64976b36a7deaa83@mail.gmail.com>
References: <200710011922.l91JMXUJ012622@cs.oswego.edu>
	<31f2a7bd0710011334t59ad1adbn64976b36a7deaa83@mail.gmail.com>
Message-ID: <63b4e4050710020430u6d87235cq917f7e3021bfb384@mail.gmail.com>

On 10/1/07, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
>
> In fact, Tim and I adhere to different sides of the checked vs. unchecked
> exception debate.  I prefer checked exceptions and I like to maintain a
> distinction between Exception in my thread versus an ExecutionException in a
> worker thread, whereas Tim is more likely to finesse things using unchecked
> exceptions, and to unwrap ExceptionExceptions and rethrow them as unchecked
> exceptions in the current thread.


I should clarify my position: For tasks that may have side-effects, I'm all
in favor of checked exceptions. It's only for functional-ish tasks that I
try to avoid checked exceptions.

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071002/f26064f8/attachment.html 

From dl at cs.oswego.edu  Tue Oct  2 08:36:43 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 02 Oct 2007 08:36:43 -0400
Subject: [concurrency-interest] JCiP Memoizer: should Computable throw
 Exception?
In-Reply-To: <63b4e4050710020430u6d87235cq917f7e3021bfb384@mail.gmail.com>
References: <200710011922.l91JMXUJ012622@cs.oswego.edu>	<31f2a7bd0710011334t59ad1adbn64976b36a7deaa83@mail.gmail.com>
	<63b4e4050710020430u6d87235cq917f7e3021bfb384@mail.gmail.com>
Message-ID: <47023B5B.8010008@cs.oswego.edu>

Tim Peierls wrote:

> I should clarify my position: For tasks that may have side-effects, I'm 
> all in favor of checked exceptions. It's only for functional-ish tasks 
> that I try to avoid checked exceptions.
> 

As Tim mentioned, this policy is embedded in the upcoming forkjoin
package, which is designed for use only for independent parallel
computations -- no IO, no blocking, no shared resources. (Although
conveniently in most ways, these conventions are not strictly
enforced -- you can for example, add some print statements without
much disrupting the parallel control framework.)

We came upon this policy for a few intertwined reasons:
   * Empirically, checked exceptions are most commonly used
     in association with constructions that forkjoin doesn't support
     (mainly IO and blocking).
   * While the framework does correctly propagate all (unchecked)
     exceptions, we cannot provide a (usable) way for people to
     trap and handle intermediary exceptions, such as a failed reduce
     step midway up a computation tree -- all we can do is relay
     the exception upward.
   * As Tim also mentioned, our experience has been that under many
     if not most usages of Futures, requiring catches of
     ExecutionExceptions adds useless clutter.
     Although as Joe mentioned, often enough, this is useful clutter.
   * It is always possible to wrap code that throws a checked exception
     within a task that catches it, possibly invokes some intermediate
     handler, and then rethrows an unchecked one. So there is no net
     loss in power or functionality.

-Doug

From hanson.char at gmail.com  Tue Oct  2 15:11:43 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Tue, 2 Oct 2007 12:11:43 -0700
Subject: [concurrency-interest] Is
	java.security.MessageDigest.getInstance(String) thread safe ?
Message-ID: <ca53c8f80710021211i5e024d8bs71fce6125e0a50f@mail.gmail.com>

Hi,

I am trying to figure out if

  java.security.MessageDigest.getInstance(String)

is thead-safe.

Reading the code in jdk1.6, I can see significant effort made on the
implementation of MessageDigest.getIstance(String) that seems to be
related to thread-safety, like the use of ConcurrentHashMap in the
java.security.Security class, the use of ThreadLocal in
Providers.getProviderList, etc.

But the bottom line is, is the static factory method thread safe or
not ?  Anyone knows ?  Thanks in advance.

Hanson Char

From hanson.char at gmail.com  Tue Oct  2 15:40:16 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Tue, 2 Oct 2007 12:40:16 -0700
Subject: [concurrency-interest] Is
	java.security.MessageDigest.getInstance(String) thread safe ?
In-Reply-To: <ca53c8f80710021211i5e024d8bs71fce6125e0a50f@mail.gmail.com>
References: <ca53c8f80710021211i5e024d8bs71fce6125e0a50f@mail.gmail.com>
Message-ID: <ca53c8f80710021240m2ef39d2bld94bb6f287d368b2@mail.gmail.com>

Also, is

    MessageDigest.clone()

thread-safe ?  And since Object.clone() is a native method, is clone()
thead safe in general ?  (At least in the Sun's 1.6 jdk.)

Hanson Char

On 10/2/07, Hanson Char <hanson.char at gmail.com> wrote:
> Hi,
>
> I am trying to figure out if
>
>   java.security.MessageDigest.getInstance(String)
>
> is thead-safe.
>
> Reading the code in jdk1.6, I can see significant effort made on the
> implementation of MessageDigest.getIstance(String) that seems to be
> related to thread-safety, like the use of ConcurrentHashMap in the
> java.security.Security class, the use of ThreadLocal in
> Providers.getProviderList, etc.
>
> But the bottom line is, is the static factory method thread safe or
> not ?  Anyone knows ?  Thanks in advance.
>
> Hanson Char
>

From dcholmes at optusnet.com.au  Wed Oct  3 02:58:27 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 3 Oct 2007 16:58:27 +1000
Subject: [concurrency-interest]
	Isjava.security.MessageDigest.getInstance(String) thread safe ?
In-Reply-To: <ca53c8f80710021240m2ef39d2bld94bb6f287d368b2@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOENNHIAA.dcholmes@optusnet.com.au>

Hanson,

clone() is thread-safe only in the strictest safety sense: clone() must
correctly copy the values of all fields (even non-volatile long/double** !)
without producing garbage values. But there is no guarantee that the
resulting objects contains field values that existed simultaneously in the
original - i.e. there is no guarantee it is a consistent snapshot of the
original.

** there have been bugs in this area ... not sure of the details

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Hanson
> Char
> Sent: Wednesday, 3 October 2007 5:40 AM
> To: concurrency-interest
> Subject: Re: [concurrency-interest]
> Isjava.security.MessageDigest.getInstance(String) thread safe ?
>
>
> Also, is
>
>     MessageDigest.clone()
>
> thread-safe ?  And since Object.clone() is a native method, is clone()
> thead safe in general ?  (At least in the Sun's 1.6 jdk.)
>
> Hanson Char
>
> On 10/2/07, Hanson Char <hanson.char at gmail.com> wrote:
> > Hi,
> >
> > I am trying to figure out if
> >
> >   java.security.MessageDigest.getInstance(String)
> >
> > is thead-safe.
> >
> > Reading the code in jdk1.6, I can see significant effort made on the
> > implementation of MessageDigest.getIstance(String) that seems to be
> > related to thread-safety, like the use of ConcurrentHashMap in the
> > java.security.Security class, the use of ThreadLocal in
> > Providers.getProviderList, etc.
> >
> > But the bottom line is, is the static factory method thread safe or
> > not ?  Anyone knows ?  Thanks in advance.
> >
> > Hanson Char
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From jed at atlassian.com  Wed Oct  3 05:49:55 2007
From: jed at atlassian.com (Jed Wesley-Smith)
Date: Wed, 03 Oct 2007 19:49:55 +1000
Subject: [concurrency-interest] CopyOnWriteMap implementation
Message-ID: <470365C3.8070808@atlassian.com>

all,

I have written a CopyOnWriteMap implementation for our internal use, but 
I have been instructed not to use it for its original purpose and use a 
ReadWriteLock strategy instead (although I think the CopyOnWriteMap is 
superior in several ways, the cost of supporting a bespoke concurrent 
structure is potentially too high).

Anyway, I have been given permission to put it in to the public domain, 
along with tests - attached.

It works by delegating to any Map implementation that is supplied by a 
constructor injected CopyFunction object. The CopyFunction provides the 
Map copy(Map) implementation that returns the desired internal 
Hash/Tree/whatever map.

The main shortcoming it has compared to the 
java.util.CopyOnWriteArrayList is that it doesn't implement 
Serializable, and it delegates to an internal Map so is potentially a 
little slower although under HotSpot this should be eliminated.

Any and all feedback, holes, ideas appreciated. Somewhere to put this?

cheers,
jed.
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: CopyOnWriteMap.java
Url: /pipermail/attachments/20071003/d4fb12c5/attachment-0003.ksh 
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: TestCopyOnWriteMap.java
Url: /pipermail/attachments/20071003/d4fb12c5/attachment-0004.ksh 
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: LatchQueue.java
Url: /pipermail/attachments/20071003/d4fb12c5/attachment-0005.ksh 

From joe.bowbeer at gmail.com  Wed Oct  3 12:07:21 2007
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 3 Oct 2007 09:07:21 -0700
Subject: [concurrency-interest] CopyOnWriteMap implementation
In-Reply-To: <470365C3.8070808@atlassian.com>
References: <470365C3.8070808@atlassian.com>
Message-ID: <31f2a7bd0710030907r20965ee5o4dba69d803d50da5@mail.gmail.com>

On 10/3/07, Jed Wesley-Smith <jed at atlassian.com> wrote:
>
> I have written a CopyOnWriteMap implementation for our internal use.
>
> It works by delegating to any Map implementation that is supplied by a
> constructor injected CopyFunction object. The CopyFunction provides the
> Map copy(Map) implementation that returns the desired internal
> Hash/Tree/whatever map.
>
> Any and all feedback, holes, ideas appreciated. Somewhere to put this?
>

As we discussed on this list a couple weeks ago, all methods not
synchronized by your CopyOnWriteWrapper must be thread-safe.  In
particular, the get method must be thread-safe.

In Sun's Java 6, HashMap and TreeMap meet this requirement (at least
for 'get') but LinkedHashMap and WeakHashMap do not.

I can't tell from the "this implementation" note in HashMap and
TreeMap whether their 'get' methods are safe in all HashMap and
TreeMap implementations -- or just Sun's.

I suggest you add a note about this requirement to your documentation.

--Joe

From hanson.char at gmail.com  Wed Oct  3 13:06:43 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Wed, 3 Oct 2007 10:06:43 -0700
Subject: [concurrency-interest]
	Isjava.security.MessageDigest.getInstance(String) thread safe ?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOENNHIAA.dcholmes@optusnet.com.au>
References: <ca53c8f80710021240m2ef39d2bld94bb6f287d368b2@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCOENNHIAA.dcholmes@optusnet.com.au>
Message-ID: <ca53c8f80710031006p55dd302dv247c680cab00e723@mail.gmail.com>

The more I think about it, MessageDigest.getInstance(String) must be
thread-safe, or else it would be a bug, as there is nothing said about
how the factory method should be synchronized upon before invocation,
and therefore there is no guarantee as to how thread-safety can be
achieved in invoking this method.

Now this leads me to wonder why the MessageDigest supports the clone
method.  This seems to suggest the clone method performs faster than
the getInstance method, or else I can't see why the clone method is
necessary.

Thoughts ?

Hanson Char

On 10/2/07, David Holmes <dcholmes at optusnet.com.au> wrote:
> Hanson,
>
> clone() is thread-safe only in the strictest safety sense: clone() must
> correctly copy the values of all fields (even non-volatile long/double** !)
> without producing garbage values. But there is no guarantee that the
> resulting objects contains field values that existed simultaneously in the
> original - i.e. there is no guarantee it is a consistent snapshot of the
> original.
>
> ** there have been bugs in this area ... not sure of the details
>
> Cheers,
> David Holmes
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Hanson
> > Char
> > Sent: Wednesday, 3 October 2007 5:40 AM
> > To: concurrency-interest
> > Subject: Re: [concurrency-interest]
> > Isjava.security.MessageDigest.getInstance(String) thread safe ?
> >
> >
> > Also, is
> >
> >     MessageDigest.clone()
> >
> > thread-safe ?  And since Object.clone() is a native method, is clone()
> > thead safe in general ?  (At least in the Sun's 1.6 jdk.)
> >
> > Hanson Char
> >
> > On 10/2/07, Hanson Char <hanson.char at gmail.com> wrote:
> > > Hi,
> > >
> > > I am trying to figure out if
> > >
> > >   java.security.MessageDigest.getInstance(String)
> > >
> > > is thead-safe.
> > >
> > > Reading the code in jdk1.6, I can see significant effort made on the
> > > implementation of MessageDigest.getIstance(String) that seems to be
> > > related to thread-safety, like the use of ConcurrentHashMap in the
> > > java.security.Security class, the use of ThreadLocal in
> > > Providers.getProviderList, etc.
> > >
> > > But the bottom line is, is the static factory method thread safe or
> > > not ?  Anyone knows ?  Thanks in advance.
> > >
> > > Hanson Char

From dcholmes at optusnet.com.au  Wed Oct  3 19:40:26 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Thu, 4 Oct 2007 09:40:26 +1000
Subject: [concurrency-interest]
	Isjava.security.MessageDigest.getInstance(String) thread safe ?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOENNHIAA.dcholmes@optusnet.com.au>
Message-ID: <ABEHILABNFKEAJNKLENCCEEJCFAA.dcholmes@optusnet.com.au>

Hanson,

I must withdraw my statement: clone() does not have this basic safety
property. If long/double fields are accessed/updated in two stages (true for
long, probably not true for double) then there is no way that clone() can
guarantee to take a safe snapshot of the field's value.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of David
> Holmes
> Sent: Wednesday, 3 October 2007 4:58 PM
> To: Hanson Char; concurrency-interest
> Subject: Re:
> [concurrency-interest]Isjava.security.MessageDigest.getInstance(String)
> thread safe ?
>
>
> Hanson,
>
> clone() is thread-safe only in the strictest safety sense: clone() must
> correctly copy the values of all fields (even non-volatile
> long/double** !)
> without producing garbage values. But there is no guarantee that the
> resulting objects contains field values that existed simultaneously in the
> original - i.e. there is no guarantee it is a consistent snapshot of the
> original.
>
> ** there have been bugs in this area ... not sure of the details
>
> Cheers,
> David Holmes
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Hanson
> > Char
> > Sent: Wednesday, 3 October 2007 5:40 AM
> > To: concurrency-interest
> > Subject: Re: [concurrency-interest]
> > Isjava.security.MessageDigest.getInstance(String) thread safe ?
> >
> >
> > Also, is
> >
> >     MessageDigest.clone()
> >
> > thread-safe ?  And since Object.clone() is a native method, is clone()
> > thead safe in general ?  (At least in the Sun's 1.6 jdk.)
> >
> > Hanson Char
> >
> > On 10/2/07, Hanson Char <hanson.char at gmail.com> wrote:
> > > Hi,
> > >
> > > I am trying to figure out if
> > >
> > >   java.security.MessageDigest.getInstance(String)
> > >
> > > is thead-safe.
> > >
> > > Reading the code in jdk1.6, I can see significant effort made on the
> > > implementation of MessageDigest.getIstance(String) that seems to be
> > > related to thread-safety, like the use of ConcurrentHashMap in the
> > > java.security.Security class, the use of ThreadLocal in
> > > Providers.getProviderList, etc.
> > >
> > > But the bottom line is, is the static factory method thread safe or
> > > not ?  Anyone knows ?  Thanks in advance.
> > >
> > > Hanson Char
> > >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From jed at atlassian.com  Wed Oct  3 22:43:43 2007
From: jed at atlassian.com (Jed Wesley-Smith)
Date: Thu, 04 Oct 2007 12:43:43 +1000
Subject: [concurrency-interest] CopyOnWriteMap implementation
In-Reply-To: <31f2a7bd0710030907r20965ee5o4dba69d803d50da5@mail.gmail.com>
References: <470365C3.8070808@atlassian.com>
	<31f2a7bd0710030907r20965ee5o4dba69d803d50da5@mail.gmail.com>
Message-ID: <4704535F.5090100@atlassian.com>

Joe Bowbeer wrote:
> On 10/3/07, Jed Wesley-Smith <jed at atlassian.com> wrote:
>   
>> Any and all feedback, holes, ideas appreciated. Somewhere to put this?
>>     
> As we discussed on this list a couple weeks ago, all methods not
> synchronized by your CopyOnWriteWrapper must be thread-safe.  In
> particular, the get method must be thread-safe.
>
> In Sun's Java 6, HashMap and TreeMap meet this requirement (at least
> for 'get') but LinkedHashMap and WeakHashMap do not.
>
> I can't tell from the "this implementation" note in HashMap and
> TreeMap whether their 'get' methods are safe in all HashMap and
> TreeMap implementations -- or just Sun's.
>
> I suggest you add a note about this requirement to your documentation.
>   

Thanks Joe, good catch. Changed the class javadoc:

/**
 * A thread-safe variant of {@link Map} in which all mutative operations 
(the
 * "destructive" operations described by {@link Map} put, remove and so 
on) are
 * implemented by making a fresh copy of the underlying map.
 * <p>
 * This is ordinarily too costly, but may be <em>more</em> efficient than
 * alternatives when traversal operations vastly out-number mutations, 
and is
 * useful when you cannot or don't want to synchronise traversals, yet 
need to
 * preclude interference among concurrent threads. The "snapshot" style
 * iterators on the collections returned by {@link #entrySet()},
 * {@link #keySet()} and {@link #values()} use a reference to the 
internal map
 * at the point that the iterator was created. This array never changes 
during
 * the lifetime of the iterator, so interference is impossible and the 
iterator
 * is guaranteed not to throw <tt>ConcurrentModificationException</tt>. The
 * iterators will not reflect additions, removals, or changes to the 
list since
 * the iterator was created. Element-changing operations on iterators and
 * collections themselves (remove, set, and add) are not supported. These
 * methods throw {@link UnsupportedOperationException}.
 * <p>
 * The actual copy is performed by a supplied {@link CopyFunction} 
object. The
 * Factory is responsible for the underlying Map implementation (for 
instance a
 * HashMap, TreeMap, ListOrderedMap etc.) and therefore the semantics of 
what
 * this map will cope with as far as null keys and values, iteration 
ordering
 * etc.
 * <p>
 * There are supplied {@link Functions} for the common Collections 
{@link Map}
 * implementations.
 * <p>
 * <strong>Please note</strong> that the thread-safety guarantees are 
limited
 * to the thread-safety of the non-mutative (non-destructive) operations 
of the
 * underlying map implementation. For instance some implementations such as
 * {@link WeakHashMap} and {@link LinkedHashMap} are actually structurally
 * modified by the {@link #get(Object)} method and are therefore not 
suitable
 * candidates as delegates for this class.
 */




From rokmn3309 at hotmail.com  Thu Oct  4 00:09:55 2007
From: rokmn3309 at hotmail.com (=?ks_c_5601-1987?B?wMwgw7bIow==?=)
Date: Thu, 04 Oct 2007 04:09:55 +0000
Subject: [concurrency-interest] util.concurrent 1.3.4 install error(build
	failed)..
Message-ID: <BAY137-F240CA83BD83B4BD18BC346B3A80@phx.gbl>

hi..

 i tried my pc the util.concurrent 1.3.4 but bulid failed..

my machine is used , CentOS 4.4 and 1.4.2_14-b05

this is classpath..
CLASSPATH=./:/data/local/java/lib/tools.jar:/data/local/java/lib/dt.jar:/data/local/java/lib/htmlconverter.jar:/data/local/java/lib/Chart2D.jar:/data/local/java/lib/gnujaxp.jar:/data/local/java/lib/itext-2.0.1.jar:/data/local/java/lib/jcommon-1.0.9.jar:/data/local/java/lib/jfreechart-1.0.5-experimental.jar:/data/local/java/lib/jfreechart-1.0.5-swt.jar:/data/local/java/lib/jfreechart-1.0.5.jar:/data/local/java/lib/junit.jar:/data/local/java/lib/servlet.jar:/data/local/java/lib/swtgraphics2d.jar:/data/local/java/lib/mysql-connector-java-5.0.5-bin.jar


this is compile error message.
[root at test concurrent]# javac -d /data/local/java/lib/ ./*.java
[root at test concurrent]# javac -d /data/local/java/lib/ ./misc/*.java
./misc/CVBuffer.java:6: cannot resolve symbol
symbol  : class BoundedChannel
location: class EDU.oswego.cs.dl.util.concurrent.misc.CVBuffer
public class CVBuffer implements BoundedChannel {
                                 ^
./misc/CVBuffer.java:7: cannot resolve symbol
symbol  : class Mutex
location: class EDU.oswego.cs.dl.util.concurrent.misc.CVBuffer
  private final Mutex mutex;
                ^
./misc/CVBuffer.java:8: cannot resolve symbol
symbol  : class CondVar
location: class EDU.oswego.cs.dl.util.concurrent.misc.CVBuffer
  private final CondVar notFull;
                ^
./misc/CVBuffer.java:9: cannot resolve symbol
symbol  : class CondVar
location: class EDU.oswego.cs.dl.util.concurrent.misc.CVBuffer
  private final CondVar notEmpty;
                ^
./misc/FIFOSlot.java:7: cannot resolve symbol
symbol  : class BoundedChannel
location: class EDU.oswego.cs.dl.util.concurrent.misc.FIFOSlot
public class FIFOSlot implements BoundedChannel {
                                 ^
./misc/FIFOSlot.java:8: cannot resolve symbol
symbol  : class Slot
location: class EDU.oswego.cs.dl.util.concurrent.misc.FIFOSlot
  private final Slot slot_;
                ^
./misc/PipedChannel.java:26: cannot resolve symbol
symbol  : class SemaphoreControlledChannel
location: class EDU.oswego.cs.dl.util.concurrent.misc.PipedChannel
public class PipedChannel extends SemaphoreControlledChannel {
                                  ^
./misc/SwingWorker.java:115: cannot resolve symbol
symbol  : class ThreadFactoryUser
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
public abstract class SwingWorker extends ThreadFactoryUser
                                          ^
./misc/SwingWorker.java:119: cannot resolve symbol
symbol  : class ThreadFactory
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
    private static final ThreadFactory FACTORY = new ThreadFactory() {
                         ^
./misc/SwingWorker.java:128: cannot resolve symbol
symbol  : class FutureResult
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
    private final FutureResult result = new FutureResult();
                  ^
./misc/SwingWorker.java:156: cannot resolve symbol
symbol  : class ThreadFactory
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
    protected SwingWorker(ThreadFactory factory, long msecs) {
                          ^
./misc/SwingWorker.java:261: cannot resolve symbol
symbol  : class TimeoutException
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
    throws TimeoutException, InterruptedException, 
InvocationTargetException {
           ^
./misc/SynchronizationTimer.java:621: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
  final SynchronizedInt nextClassIdx_ = new SynchronizedInt(0);
        ^
./misc/SynchronizationTimer.java:622: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
  final SynchronizedInt nextThreadIdx_ = new SynchronizedInt(0);
        ^
./misc/SynchronizationTimer.java:1106: cannot resolve symbol
symbol  : class ClockDaemon
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
  ClockDaemon timeDaemon = new ClockDaemon();
  ^
./misc/SynchronizationTimer.java:1125: cannot resolve symbol
symbol  : class SynchronizedRef
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
  private final SynchronizedRef contention_ = new SynchronizedRef(null);
                ^
./misc/SynchronizationTimer.java:1126: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
  private final SynchronizedInt loopsPerTest_ = new SynchronizedInt(0);
                ^
./misc/SynchronizationTimer.java:1128: cannot resolve symbol
symbol  : class SynchronizedBoolean
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
  private final SynchronizedBoolean echoToSystemOut =
                ^
./misc/SynchronizationTimer.java:1134: cannot resolve symbol
symbol  : class WaitableInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
  private WaitableInt testNumber_ = new WaitableInt(1);
          ^
./misc/SynchronizationTimer.java:1146: cannot resolve symbol
symbol  : class SynchronizedBoolean
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
  private SynchronizedBoolean running_ = new SynchronizedBoolean(false);
          ^
./misc/SynchronizationTimer.java:1435: cannot resolve symbol
symbol  : class ThreadFactory
location: class EDU.oswego.cs.dl.util.concurrent.misc.Threads
class Threads implements ThreadFactory {
                         ^
./misc/SynchronizationTimer.java:1437: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.Threads
  static final SynchronizedInt activeThreads = new SynchronizedInt(0);
               ^
./misc/SynchronizationTimer.java:1441: cannot resolve symbol
symbol  : class PooledExecutor
location: class EDU.oswego.cs.dl.util.concurrent.misc.Threads
  static final PooledExecutor pool = new PooledExecutor();
               ^
./misc/SynchronizationTimer.java:1681: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
  static final SynchronizedInt computeLoops =
               ^
./misc/SynchronizationTimer.java:1683: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
  static final SynchronizedInt syncMode =
               ^
./misc/SynchronizationTimer.java:1685: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
  static final SynchronizedInt producerMode =
               ^
./misc/SynchronizationTimer.java:1687: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
  static final SynchronizedInt consumerMode =
               ^
./misc/SynchronizationTimer.java:1689: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
  static final SynchronizedInt bias =
               ^
./misc/SynchronizationTimer.java:1691: cannot resolve symbol
symbol  : class SynchronizedLong
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
  static final SynchronizedLong timeout =
               ^
./misc/SynchronizationTimer.java:1693: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
  static final SynchronizedInt exchangeParties =
               ^
./misc/SynchronizationTimer.java:1695: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
  static final SynchronizedInt sequenceNumber =
               ^
./misc/SynchronizationTimer.java:1697: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
  static final SynchronizedInt itersPerBarrier =
               ^
./misc/SynchronizationTimer.java:1700: cannot resolve symbol
symbol  : class Rendezvous
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
  static Rendezvous[] exchangers_;
         ^
./misc/SynchronizationTimer.java:1732: cannot resolve symbol
symbol  : class Rendezvous
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
  Rendezvous exchanger_ = null;
  ^
./misc/SynchronizationTimer.java:1734: cannot resolve symbol
symbol  : class Rendezvous
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
  synchronized Rendezvous getExchanger() {
               ^
./misc/SynchronizationTimer.java:1478: cannot resolve symbol
symbol  : class CyclicBarrier
location: class EDU.oswego.cs.dl.util.concurrent.misc.TestLoop
  final CyclicBarrier barrier;
        ^
./misc/SynchronizationTimer.java:1482: cannot resolve symbol
symbol  : class CyclicBarrier
location: class EDU.oswego.cs.dl.util.concurrent.misc.TestLoop
  public TestLoop(RNG sh, RNG pri, Fraction pshr, int it, CyclicBarrier br) 
{
                                                          ^
./misc/SynchronizationTimer.java:1588: cannot resolve symbol
symbol  : class Channel
location: class EDU.oswego.cs.dl.util.concurrent.misc.PCTestLoop
  final Channel primaryChannel;
        ^
./misc/SynchronizationTimer.java:1589: cannot resolve symbol
symbol  : class Channel
location: class EDU.oswego.cs.dl.util.concurrent.misc.PCTestLoop
  final Channel sharedChannel;
        ^
./misc/SynchronizationTimer.java:1592: cannot resolve symbol
symbol  : class CyclicBarrier
location: class EDU.oswego.cs.dl.util.concurrent.misc.PCTestLoop
    CyclicBarrier br, Channel shChan, Channel priChan) {
    ^
./misc/SynchronizationTimer.java:1592: cannot resolve symbol
symbol  : class Channel
location: class EDU.oswego.cs.dl.util.concurrent.misc.PCTestLoop
    CyclicBarrier br, Channel shChan, Channel priChan) {
                      ^
./misc/SynchronizationTimer.java:1592: cannot resolve symbol
symbol  : class Channel
location: class EDU.oswego.cs.dl.util.concurrent.misc.PCTestLoop
    CyclicBarrier br, Channel shChan, Channel priChan) {
                                      ^
./misc/SynchronizationTimer.java:1793: cannot resolve symbol
symbol  : class Callable
location: class EDU.oswego.cs.dl.util.concurrent.misc.GetFunction
class GetFunction implements Callable {
                             ^
./misc/SynchronizationTimer.java:1799: cannot resolve symbol
symbol  : class Callable
location: class EDU.oswego.cs.dl.util.concurrent.misc.NextFunction
class NextFunction implements Callable {
                              ^
./misc/SynchronizationTimer.java:1828: cannot resolve symbol
symbol  : class SynchronizedLong
location: class EDU.oswego.cs.dl.util.concurrent.misc.AClongRNG
  protected final SynchronizedLong acurrent_ =
                  ^
./misc/SynchronizationTimer.java:1858: cannot resolve symbol
symbol  : class SynchronizedLong
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchLongRNG
  protected final SynchronizedLong acurrent_ =
                  ^
./misc/SynchronizationTimer.java:1891: cannot resolve symbol
symbol  : class Sync
location: class EDU.oswego.cs.dl.util.concurrent.misc.SyncDelegatedRNG
  protected final Sync cond_;
                  ^
./misc/SynchronizationTimer.java:1892: cannot resolve symbol
symbol  : class Sync
location: class EDU.oswego.cs.dl.util.concurrent.misc.SyncDelegatedRNG
  public SyncDelegatedRNG(Sync c) {
                          ^
./misc/SynchronizationTimer.java:1976: cannot resolve symbol
symbol  : class ReadWriteLock
location: class EDU.oswego.cs.dl.util.concurrent.misc.RWLockRNG
  protected final ReadWriteLock lock_;
                  ^
./misc/SynchronizationTimer.java:1977: cannot resolve symbol
symbol  : class ReadWriteLock
location: class EDU.oswego.cs.dl.util.concurrent.misc.RWLockRNG
  public RWLockRNG(ReadWriteLock l) {
                   ^
./misc/SynchronizationTimer.java:2119: cannot resolve symbol
symbol  : class Executor
location: class EDU.oswego.cs.dl.util.concurrent.misc.ExecutorRNG
  Executor executor_;
  ^
./misc/SynchronizationTimer.java:2122: cannot resolve symbol
symbol  : class Executor
location: class EDU.oswego.cs.dl.util.concurrent.misc.ExecutorRNG
  synchronized void setExecutor(Executor e) { executor_ = e; }
                                ^
./misc/SynchronizationTimer.java:2123: cannot resolve symbol
symbol  : class Executor
location: class EDU.oswego.cs.dl.util.concurrent.misc.ExecutorRNG
  synchronized Executor getExecutor() { return executor_; }
               ^
./misc/SynchronizationTimer.java:2126: cannot resolve symbol
symbol  : class Callable
location: class EDU.oswego.cs.dl.util.concurrent.misc.ExecutorRNG
  Callable delegatedNext_ = null;
  ^
./misc/SynchronizationTimer.java:2134: cannot resolve symbol
symbol  : class Callable
location: class EDU.oswego.cs.dl.util.concurrent.misc.ExecutorRNG
  synchronized Callable delegatedNextFunction() {
               ^
./misc/SynchronizationTimer.java:2150: cannot resolve symbol
symbol  : class FutureResult
location: class EDU.oswego.cs.dl.util.concurrent.misc.ExecutorRNG
  FutureResult nextResult_ = null;
  ^
./misc/SynchronizationTimer.java:2194: cannot resolve symbol
symbol  : class QueuedExecutor
location: class EDU.oswego.cs.dl.util.concurrent.misc.QueuedExecutorRNG
  static final QueuedExecutor exec = new QueuedExecutor();
               ^
./misc/SynchronizationTimer.java:2203: cannot resolve symbol
symbol  : class Latch
location: class EDU.oswego.cs.dl.util.concurrent.misc.ForcedStartRunnable
  protected final Latch latch_ = new Latch();
                  ^
./misc/SynchronizationTimer.java:2208: cannot resolve symbol
symbol  : class Latch
location: class EDU.oswego.cs.dl.util.concurrent.misc.ForcedStartRunnable
  public Latch started() { return latch_; }
         ^
./misc/SynchronizationTimer.java:2217: cannot resolve symbol
symbol  : class ThreadedExecutor
location: class 
EDU.oswego.cs.dl.util.concurrent.misc.ForcedStartThreadedExecutor
class ForcedStartThreadedExecutor extends ThreadedExecutor {
                                          ^
./misc/SynchronizationTimer.java:2226: cannot resolve symbol
symbol  : class ThreadedExecutor
location: class EDU.oswego.cs.dl.util.concurrent.misc.ThreadedExecutorRNG
  static final ThreadedExecutor exec = new ThreadedExecutor();
               ^
./misc/SynchronizationTimer.java:2237: cannot resolve symbol
symbol  : class PooledExecutor
location: class EDU.oswego.cs.dl.util.concurrent.misc.PooledExecutorRNG
  static final PooledExecutor exec = Threads.pool;
               ^
./misc/SynchronizationTimer.java:2257: cannot resolve symbol
symbol  : class Channel
location: class EDU.oswego.cs.dl.util.concurrent.misc.ChanRNG
  public long producerNext(Channel c) throws InterruptedException {
                           ^
./misc/SynchronizationTimer.java:2283: cannot resolve symbol
symbol  : class Channel
location: class EDU.oswego.cs.dl.util.concurrent.misc.ChanRNG
  public long consumerNext(Channel c) throws InterruptedException {
                           ^
./misc/CVBuffer.java:17: cannot resolve symbol
symbol  : class Mutex
location: class EDU.oswego.cs.dl.util.concurrent.misc.CVBuffer
    mutex = new Mutex();
                ^
./misc/CVBuffer.java:18: cannot resolve symbol
symbol  : class CondVar
location: class EDU.oswego.cs.dl.util.concurrent.misc.CVBuffer
    notFull = new CondVar(mutex);
                  ^
./misc/CVBuffer.java:19: cannot resolve symbol
symbol  : class CondVar
location: class EDU.oswego.cs.dl.util.concurrent.misc.CVBuffer
    notEmpty = new CondVar(mutex);
                   ^
./misc/CVBuffer.java:23: cannot resolve symbol
symbol  : variable DefaultChannelCapacity
location: class EDU.oswego.cs.dl.util.concurrent.misc.CVBuffer
    this(DefaultChannelCapacity.get());
         ^
./misc/FIFOSlot.java:12: cannot resolve symbol
symbol  : class Slot
location: class EDU.oswego.cs.dl.util.concurrent.misc.FIFOSlot
      slot_ = new Slot(FIFOSemaphore.class);
                  ^
./misc/FIFOSlot.java:12: cannot resolve symbol
symbol  : class FIFOSemaphore
location: class EDU.oswego.cs.dl.util.concurrent.misc.FIFOSlot
      slot_ = new Slot(FIFOSemaphore.class);
                       ^
./misc/SwingWorker.java:119: cannot resolve symbol
symbol  : class ThreadFactory
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
    private static final ThreadFactory FACTORY = new ThreadFactory() {
                                                     ^
./misc/SwingWorker.java:128: cannot resolve symbol
symbol  : class FutureResult
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
    private final FutureResult result = new FutureResult();
                                            ^
./misc/SwingWorker.java:191: cannot resolve symbol
symbol  : class Callable
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
        Callable function = new Callable() {
        ^
./misc/SwingWorker.java:191: cannot resolve symbol
symbol  : class Callable
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
        Callable function = new Callable() {
                                ^
./misc/SwingWorker.java:206: cannot resolve symbol
symbol  : class TimedCallable
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
            TimedCallable tc = new TimedCallable(function, msecs);
            ^
./misc/SwingWorker.java:206: cannot resolve symbol
symbol  : class TimedCallable
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
            TimedCallable tc = new TimedCallable(function, msecs);
                                   ^
./misc/SwingWorker.java:207: cannot resolve symbol
symbol  : method getThreadFactory ()
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
            tc.setThreadFactory(getThreadFactory());
                                ^
./misc/SwingWorker.java:220: cannot resolve symbol
symbol  : method getThreadFactory ()
location: class EDU.oswego.cs.dl.util.concurrent.misc.SwingWorker
            thread = getThreadFactory().newThread(this);
                     ^
./misc/SynchronizationTimer.java:357: cannot resolve symbol
symbol  : class LinkedQueue
location: class 
EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer.TestedClass
                      LinkedQueue.class),
                      ^
./misc/SynchronizationTimer.java:360: cannot resolve symbol
symbol  : class WaitFreeQueue
location: class 
EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer.TestedClass
                      WaitFreeQueue.class),
                      ^
./misc/SynchronizationTimer.java:363: cannot resolve symbol
symbol  : class BoundedLinkedQueue
location: class 
EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer.TestedClass
                      BoundedLinkedQueue.class),
                      ^
./misc/SynchronizationTimer.java:365: cannot resolve symbol
symbol  : class BoundedBuffer
location: class 
EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer.TestedClass
                      BoundedBuffer.class),
                      ^
./misc/SynchronizationTimer.java:369: cannot resolve symbol
symbol  : class BoundedPriorityQueue
location: class 
EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer.TestedClass
                      BoundedPriorityQueue.class),
                      ^
./misc/SynchronizationTimer.java:371: cannot resolve symbol
symbol  : class Slot
location: class 
EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer.TestedClass
                      Slot.class),
                      ^
./misc/SynchronizationTimer.java:374: cannot resolve symbol
symbol  : class SynchronousChannel
location: class 
EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer.TestedClass
                      SynchronousChannel.class),
                      ^
./misc/SynchronizationTimer.java:621: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
  final SynchronizedInt nextClassIdx_ = new SynchronizedInt(0);
                                            ^
./misc/SynchronizationTimer.java:622: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
  final SynchronizedInt nextThreadIdx_ = new SynchronizedInt(0);
                                             ^
./misc/SynchronizationTimer.java:1129: cannot resolve symbol
symbol  : class SynchronizedBoolean
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
      new SynchronizedBoolean(false);
          ^
./misc/SynchronizationTimer.java:1684: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
    new SynchronizedInt(0, constructionLock);
        ^
./misc/SynchronizationTimer.java:1686: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
    new SynchronizedInt(0, constructionLock);
        ^
./misc/SynchronizationTimer.java:1688: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
    new SynchronizedInt(0, constructionLock);
        ^
./misc/SynchronizationTimer.java:1125: cannot resolve symbol
symbol  : class SynchronizedRef
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
  private final SynchronizedRef contention_ = new SynchronizedRef(null);
                                                  ^
./misc/SynchronizationTimer.java:1126: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
  private final SynchronizedInt loopsPerTest_ = new SynchronizedInt(0);
                                                    ^
./misc/SynchronizationTimer.java:1682: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
    new SynchronizedInt(16, constructionLock);
        ^
./misc/SynchronizationTimer.java:1698: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
    new SynchronizedInt(0, constructionLock);
        ^
./misc/SynchronizationTimer.java:1694: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
    new SynchronizedInt(1, constructionLock);
        ^
./misc/SynchronizationTimer.java:1690: cannot resolve symbol
symbol  : class SynchronizedInt
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
    new SynchronizedInt(0, constructionLock);
        ^
./misc/SynchronizationTimer.java:1063: cannot resolve symbol
symbol: variable DefaultChannelCapacity
        DefaultChannelCapacity.set(bufferCapacityChoices[idx]);
        ^
./misc/SynchronizationTimer.java:1068: cannot resolve symbol
symbol  : variable DefaultChannelCapacity
location: class EDU.oswego.cs.dl.util.concurrent.misc.SynchronizationTimer
    DefaultChannelCapacity.set(bufferCapacityChoices[3]);
    ^
./misc/SynchronizationTimer.java:1692: cannot resolve symbol
symbol  : class SynchronizedLong
location: class EDU.oswego.cs.dl.util.concurrent.misc.RNG
    new SynchronizedLong(100, constructionLock);
        ^
100 errors
[root at test concurrent]#

what is problem??
i dose download file and tar.gz excute and javac, 
more need???

_________________________________________________________________
?? ?? ?? ??? ?????? MSN ???? ?????. 
http://fortune.msn.co.kr/ 


From dawid.kurzyniec at gmail.com  Mon Oct  8 04:15:20 2007
From: dawid.kurzyniec at gmail.com (Dawid Kurzyniec)
Date: Mon, 8 Oct 2007 10:15:20 +0200
Subject: [concurrency-interest]
	Isjava.security.MessageDigest.getInstance(String) thread safe ?
In-Reply-To: <ca53c8f80710031006p55dd302dv247c680cab00e723@mail.gmail.com>
References: <ca53c8f80710021240m2ef39d2bld94bb6f287d368b2@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCOENNHIAA.dcholmes@optusnet.com.au>
	<ca53c8f80710031006p55dd302dv247c680cab00e723@mail.gmail.com>
Message-ID: <3cbaca580710080115i4f2e76aep7b98dd21e80af814@mail.gmail.com>

On 10/3/07, Hanson Char <hanson.char at gmail.com> wrote:
> The more I think about it, MessageDigest.getInstance(String) must be
> thread-safe, or else it would be a bug, as there is nothing said about
> how the factory method should be synchronized upon before invocation,
> and therefore there is no guarantee as to how thread-safety can be
> achieved in invoking this method.
>
> Now this leads me to wonder why the MessageDigest supports the clone
> method.  This seems to suggest the clone method performs faster than
> the getInstance method, or else I can't see why the clone method is
> necessary.

Clone() preserves internal digest state. digest() resets the state.
So, clone() is useful if you want to compute partial digests, for
instance:

md.update(buf, 0, 100);
md2 = md.clone();
partial_digest = md2.digest();
md.update(buf, 100, 100);
digest = md.digest();

I don't think you're supposed to use the clone from a different
thread. (On the other hand, I think it is sane to assume thread safety
of factory methods in this API).

--
Regards,
Dawid

From unmesh_joshi at hotmail.com  Mon Oct  8 09:50:57 2007
From: unmesh_joshi at hotmail.com (Unmesh joshi)
Date: Mon, 8 Oct 2007 13:50:57 +0000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <mailman.3.1191471017.15054.concurrency-interest@altair.cs.oswego.edu>
References: <mailman.3.1191471017.15054.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <BAY140-W22C66EA3D71BF5F0DBA40DEFA40@phx.gbl>


Hi,
 
Threadlocals are used in J2EE application servers to keep track of transaction context and security context. I was thinking of using it to pass execution context (which involves some user login and other context information) around in web application which involves servlets and other server side classes. (As discussed at http://www.theserverside.com/news/thread.tss?thread_id=41473).
I remember reading somewhere that Threadlocals can cause memory leaks if Threads are getting reused through thread pools. (Which is the case in J2EE application servers).
What way can Threadlocal cause memory leak? How Threadlocals behave with Classloaderes in J2EE? In what cases thread local usage is not recommended?
 
Thanks,
Unmesh
_________________________________________________________________
Get the new Windows Live Messenger!
http://get.live.com/messenger/overview
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071008/187f8b61/attachment.html 

From hanson.char at gmail.com  Mon Oct  8 12:46:15 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Mon, 8 Oct 2007 09:46:15 -0700
Subject: [concurrency-interest] Is java.lang.Enum.values() thread safe ?
Message-ID: <ca53c8f80710080946m3c8a7de0v9e44eef7d6648b38@mail.gmail.com>

Hi,

The static values() method of a specific Enum (subclass) in Java is
generated in the class file, but not defined in the API/javadoc.  I
would think such an important method must be thread safe, but is this
a fact ?

Thanks,
Hanson Char

From josh at bloch.us  Mon Oct  8 14:33:54 2007
From: josh at bloch.us (Joshua Bloch)
Date: Mon, 8 Oct 2007 11:33:54 -0700
Subject: [concurrency-interest] Is java.lang.Enum.values() thread safe ?
In-Reply-To: <ca53c8f80710080946m3c8a7de0v9e44eef7d6648b38@mail.gmail.com>
References: <ca53c8f80710080946m3c8a7de0v9e44eef7d6648b38@mail.gmail.com>
Message-ID: <b097ac510710081133i7bac36b4v4d3555c490578c97@mail.gmail.com>

Hanson,

Yes, it's a fact.  Perhaps it should be defined, but everything about enums
is immutable, so I assumed that everyone would know it was thread-safe.

       Josh


On 10/8/07, Hanson Char <hanson.char at gmail.com> wrote:
>
> Hi,
>
> The static values() method of a specific Enum (subclass) in Java is
> generated in the class file, but not defined in the API/javadoc.  I
> would think such an important method must be thread safe, but is this
> a fact ?
>
> Thanks,
> Hanson Char
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071008/11cef706/attachment.html 

From neal at gafter.com  Mon Oct  8 14:50:00 2007
From: neal at gafter.com (Neal Gafter)
Date: Mon, 8 Oct 2007 11:50:00 -0700
Subject: [concurrency-interest] Is java.lang.Enum.values() thread safe ?
In-Reply-To: <ca53c8f80710080946m3c8a7de0v9e44eef7d6648b38@mail.gmail.com>
References: <ca53c8f80710080946m3c8a7de0v9e44eef7d6648b38@mail.gmail.com>
Message-ID: <15e8b9d20710081150g5acc6432t6355c8648a737b56@mail.gmail.com>

Yes, an enum's values() method is thread safe if called after the enum class
has been initialized.  The implementation simply clones an array that was
created when the class was statically initialized.  Both values() and
valueOf(String) really should show up in the javadoc, but where will the
documentation text come from?

On 10/8/07, Hanson Char <hanson.char at gmail.com> wrote:
>
> Hi,
>
> The static values() method of a specific Enum (subclass) in Java is
> generated in the class file, but not defined in the API/javadoc.  I
> would think such an important method must be thread safe, but is this
> a fact ?
>
> Thanks,
> Hanson Char
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071008/d7d0cde3/attachment.html 

From Martin.Buchholz at Sun.COM  Mon Oct  8 15:17:29 2007
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Mon, 08 Oct 2007 12:17:29 -0700
Subject: [concurrency-interest] Thread safety of Maps (Was: copy on
 write semantics)
In-Reply-To: <31f2a7bd0710080758n67a2bb41n93f60bf429367c9d@mail.gmail.com>
References: <31f2a7bd0710080758n67a2bb41n93f60bf429367c9d@mail.gmail.com>
Message-ID: <470A8249.3010208@sun.com>



Joe Bowbeer wrote:
> From: Joe Bowbeer <joe.bowbeer at gmail.com>
> Date: Sep 17, 2007 2:18 PM
> Subject: Re: [concurrency-interest] copy on write semantics
> To: concurrency-interest <concurrency-interest at cs.oswego.edu>
> 
> I agree that some doc cleanup is in order.
> 
> 1. LinkedHashMap doc says:
> 
> "If multiple threads access a linked hash map concurrently, and at
> least one of the threads modifies the map structurally, it must be
> synchronized externally."
> 
> But it also says "a special constructor is provided to create a linked
> hash map whose order of iteration is the order in which its entries
> were last accessed".
> 
> So the first statement is wrong, right?

But the doc goes on to clarify that get() is a structural modification.

 * A structural modification is any operation that adds or deletes one
or more
 * mappings or, in the case of access-ordered linked hash maps, affects
 * iteration order.  In insertion-ordered linked hash maps, merely changing
 * the value associated with a key that is already contained in the map
is not
 * a structural modification.  <strong>In access-ordered linked hash maps,
 * merely querying the map with <tt>get</tt> is a structural
 * modification.</strong>)


> 2. WeakHashMap only says:
> 
> "Like most collection classes, this class is not synchronized."
> 
> Not very telling!

Yes, we need more docs here to explain what is safe and what is not.

WeakHashMaps are modified concurrently by the garbage collector,
but I hope that is safe, at least, since the GC does not perform
"structural modifications".

> 3. HashMap says:
> 
> "If multiple threads access a hash map concurrently, and at least one
> of the threads modifies the map structurally, it must be synchronized
> externally."

So this is fine, right?

There's been some work on WeakHashMap in jdk7

6425537: (coll) WeakHashMap thread safety
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6425537

6499848: (coll) WeakHashMap's HashIterator may skip entries
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6499848

> 4. Map makes no guarantees.

Which also seems fine.

In the absence of guarantees, users must synchronize all access
including read access, to all objects?

> --Joe
> 
> On 9/17/07, Boehm, Hans <hans.boehm at hp.com> wrote:
>>In my view, WeakHashMap is (hopefully) an outlier here, and is in serious
>>need of at least a documentation overhaul.  As I recall, this has been
>>previously discussed
>>
>>In general, containers should be safe for concurrent access if all accesses
>>are reads.  If a read access performs an update behind the scenes, either
>>that needs to be documented or, preferably, the container should do enough
>>synchronization internally to hide that fact.  It's certainly common to
>>create a data structure and then have multiple threads read it.  That can't
>>be allowed to fail.
>>
>>The next C++ standard is likely to contain this rule in a fairly explicit
>>form.  My assumption has always been that it was the intent for Java as
>>well, but just hasn't been written down very well, at least not that I have
>>found.  But I think it's critical to the usability of the language.

There has certainly been an attempt to document this for the core
unsynchronized collections, but as always we can do better.

Martin

From joe.bowbeer at gmail.com  Mon Oct  8 15:46:40 2007
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 8 Oct 2007 12:46:40 -0700
Subject: [concurrency-interest] Thread safety of Maps (Was: copy on
	write semantics)
In-Reply-To: <470A8249.3010208@sun.com>
References: <31f2a7bd0710080758n67a2bb41n93f60bf429367c9d@mail.gmail.com>
	<470A8249.3010208@sun.com>
Message-ID: <31f2a7bd0710081246x7bb77416ic841ea482dd03662@mail.gmail.com>

interleaved.

On 10/8/07, Martin Buchholz wrote:
>
> Joe Bowbeer wrote:
> > From: Joe Bowbeer <joe.bowbeer at gmail.com>
> > Date: Sep 17, 2007 2:18 PM
> > Subject: Re: [concurrency-interest] copy on write semantics
> > To: concurrency-interest <concurrency-interest at cs.oswego.edu>
> >
> > I agree that some doc cleanup is in order.
> >
> > 1. LinkedHashMap doc says:
> >
> > "If multiple threads access a linked hash map concurrently, and at
> > least one of the threads modifies the map structurally, it must be
> > synchronized externally."
> >
> > But it also says "a special constructor is provided to create a linked
> > hash map whose order of iteration is the order in which its entries
> > were last accessed".
> >
> > So the first statement is wrong, right?
>
> But the doc goes on to clarify that get() is a structural modification.
>

I missed that part, but it is right there.  With emphasis.


> > 3. HashMap says:
> >
> > "If multiple threads access a hash map concurrently, and at least one
> > of the threads modifies the map structurally, it must be synchronized
> > externally."
>
> So this is fine, right?
>

Seems so.  Though it's unclear to me what "this implementation" refers
to.  Is that the Hash implementation of Map, or Sun's implementation
of HashMap?


> There's been some work on WeakHashMap in jdk7
>
> 6425537: (coll) WeakHashMap thread safety
> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6425537
>
> 6499848: (coll) WeakHashMap's HashIterator may skip entries
> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6499848
>

So the fix was to add a lock to expungeStaleEntries, adding a lock
acquisition to every 'get'?

--Joe

From online at stolsvik.com  Mon Oct  8 16:00:18 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Mon, 08 Oct 2007 22:00:18 +0200
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <BAY140-W22C66EA3D71BF5F0DBA40DEFA40@phx.gbl>
References: <mailman.3.1191471017.15054.concurrency-interest@altair.cs.oswego.edu>
	<BAY140-W22C66EA3D71BF5F0DBA40DEFA40@phx.gbl>
Message-ID: <470A8C52.8030401@Stolsvik.com>

Unmesh joshi wrote:
> 
> Hi,
>  
> Threadlocals are used in J2EE application servers to keep track of 
> transaction context and security context. I was thinking of using it to 
> pass execution context (which involves some user login and other context 
> information) around in web application which involves servlets and other 
> server side classes. (As discussed at 
> http://www.theserverside.com/news/thread.tss?thread_id=41473).
> I remember reading somewhere that Threadlocals can cause memory leaks if 
> Threads are getting reused through thread pools. (Which is the case in 
> J2EE application servers).
> What way can Threadlocal cause memory leak? How Threadlocals behave with 
> Classloaderes in J2EE? In what cases thread local usage is not recommended?

Here's your fix of your information needs!

Vote for this! NOW!
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6254531

Technical low-down on the problem, and a fix:
http://www.jroller.com/tackline/entry/fixing_threadlocal

.. a quite involved "drop in ThreadLocal replacement" workaround:
http://www.jroller.com/tackline/entry/working_around_the_threadlocal_leak
   The problem here is that since ThreadLocals might be used in third 
party libraries, you quite possibly end up not being able to replace 
their usages..

(Those links all actually link to each other.. And if you follow links 
further, you'll get even more info..)

In what use cases: when you reuse thread(pools) and at the same time 
change class loaders to implement "reload" functionality. With that 
usage pattern, you will often have the old, reused threads hang onto 
hard references to all the old application instance's ThreadLocal 
values, and thereby also that instance's classes, not permitting these 
to be garbage collected.

So - it basically only happens for "containers" of different sorts, for 
example (and in particular!) Tomcat.
  (The Tomcat guys could easily have fixed it on their side, by either 
hacking into the innards of Thread (by introspection) and "wash" their 
ThreadLocal references, or make a brand new thread pool when any webapp 
is reloaded, letting the old threads die. However, Tomcat seems 
dictatorially lead by this nice chap from JBoss that instantly WONTFIXes 
bugs he personally isn't affected by, without considering the 
implications for others.)

Kind regards,
Endre.

From alarmnummer at gmail.com  Mon Oct  8 16:26:44 2007
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 8 Oct 2007 22:26:44 +0200
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <BAY140-W22C66EA3D71BF5F0DBA40DEFA40@phx.gbl>
References: <mailman.3.1191471017.15054.concurrency-interest@altair.cs.oswego.edu>
	<BAY140-W22C66EA3D71BF5F0DBA40DEFA40@phx.gbl>
Message-ID: <1466c1d60710081326k58faea5dr31a2004e4adb6a07@mail.gmail.com>

My guess is that the memory leak is a ThreadLocal that is not properly
cleaned, so the garbage collector doesn't collect the garbage (from a
garbage collector point of view it still is a valid object reference).

On 10/8/07, Unmesh joshi <unmesh_joshi at hotmail.com> wrote:
>
>
> Hi,
>
>  Threadlocals are used in J2EE application servers to keep track of
> transaction context and security context. I was thinking of using it to pass
> execution context (which involves some user login and other context
> information) around in web application which involves servlets and other
> server side classes. (As discussed at
> http://www.theserverside.com/news/thread.tss?thread_id=41473).
>  I remember reading somewhere that Threadlocals can cause memory leaks if
> Threads are getting reused through thread pools. (Which is the case in J2EE
> application servers).
>  What way can Threadlocal cause memory leak? How Threadlocals behave with
> Classloaderes in J2EE? In what cases thread local usage is not recommended?
>
>  Thanks,
>  Unmesh
>
> ________________________________
> Get the new Windows Live Messenger! Try it!
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From Martin.Buchholz at Sun.COM  Mon Oct  8 16:38:01 2007
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Mon, 08 Oct 2007 13:38:01 -0700
Subject: [concurrency-interest] Thread safety of Maps (Was: copy on
 write semantics)
In-Reply-To: <31f2a7bd0710081246x7bb77416ic841ea482dd03662@mail.gmail.com>
References: <31f2a7bd0710080758n67a2bb41n93f60bf429367c9d@mail.gmail.com>
	<470A8249.3010208@sun.com>
	<31f2a7bd0710081246x7bb77416ic841ea482dd03662@mail.gmail.com>
Message-ID: <470A9529.9040706@sun.com>



Joe Bowbeer wrote:

>>>3. HashMap says:
>>>
>>>"If multiple threads access a hash map concurrently, and at least one
>>>of the threads modifies the map structurally, it must be synchronized
>>>externally."
>>So this is fine, right?
>>
> 
> Seems so.  Though it's unclear to me what "this implementation" refers
> to.  Is that the Hash implementation of Map, or Sun's implementation
> of HashMap?

This has been a big spec problem.  Mostly, "this implementation"
refers to guarantees made by a concrete class implementing some
interface.  But there are counter-examples.

One big problem is that there is no way to mark text as non-normative.
Another is that there is no "platform guide" or a place for
notes specific to some implementation of the java se spec, which
would allow java se implementers to make guarantees about only their
implementation.

Because java does not have a standard preprocessor, implementors
are discouraged from using one, which means that it is difficult to
include platform-specific notes in the javadoc.

So sometimes I document something in the Evaluation section of a CR.
Better than nothing.

6511002: (process) Document the auto-quoting when creating a Windows
process; add winQuote
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6511002

Martin

> 
>>There's been some work on WeakHashMap in jdk7
>>
>>6425537: (coll) WeakHashMap thread safety
>>http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6425537
>>
>>6499848: (coll) WeakHashMap's HashIterator may skip entries
>>http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6499848
>>
> 
> So the fix was to add a lock to expungeStaleEntries, adding a lock
> acquisition to every 'get'?
> 
> --Joe

From mailinglist.taras.tielkes at gmail.com  Mon Oct  8 17:26:55 2007
From: mailinglist.taras.tielkes at gmail.com (Taras Tielkes)
Date: Mon, 08 Oct 2007 23:26:55 +0200
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <1466c1d60710081326k58faea5dr31a2004e4adb6a07@mail.gmail.com>
References: <mailman.3.1191471017.15054.concurrency-interest@altair.cs.oswego.edu>	<BAY140-W22C66EA3D71BF5F0DBA40DEFA40@phx.gbl>
	<1466c1d60710081326k58faea5dr31a2004e4adb6a07@mail.gmail.com>
Message-ID: <470AA09F.2070404@gmail.com>

Peter Veentjer wrote:
> My guess is that the memory leak is a ThreadLocal that is not properly
> cleaned, so the garbage collector doesn't collect the garbage (from a
> garbage collector point of view it still is a valid object reference).

ThreadLocal doesn't perform eager clean-up in the first place.

IIRC, there's a 'GoodCitizedThreadLocal' planned for 1.7. It has been 
discussed on this list a couple of times - I'm not sure what the current 
status is.

But there are tens of other ways to shoot yourself in the foot with 
ThreadLocals. For example: a webapp generates an image using Java2D, and 
sends it to the browser, encoded as PNG.

If it's the first in VM to use Java2D, the contextClassLoader will be 
copied to the Disposer thread started by the initializing Java2D 
subsystem. Since that one will only exit at VM shutdown, the webapp will 
never be unloaded.

To be fair, above example is from the 'once-during-VM-lifetime' category 
of ClassLoader leaks. However, it shares that catagory with many 
siblings - the util.logging subsystem exhibits an almost identical problem.

-tt


From larryr at saturn.sdsu.edu  Mon Oct  8 17:54:26 2007
From: larryr at saturn.sdsu.edu (Larry Riedel)
Date: Mon, 08 Oct 2007 14:54:26 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <BAY140-W22C66EA3D71BF5F0DBA40DEFA40@phx.gbl>
Message-ID: <1191880466.801090.6057.nullmailer@home35>


I hope I would not be anathema for saying it... my tendency
would be not to recommend using java.lang.ThreadLocal unless
there is no apparent (relatively clean) alternative (I still
think it would have been nice if Thread IDs could not be
reused).  I like the concept of thread-local variables,
if they were more a native part of the language and JVM.
Even so, I wonder how well that concept meshes with thread
pools where there will be, for example, different threads
representing the same "user" at different times.


Larry


From dcholmes at optusnet.com.au  Mon Oct  8 19:05:07 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 9 Oct 2007 09:05:07 +1000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <1191880466.801090.6057.nullmailer@home35>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>

Larry,

I wouldn't say that exactly but I would point out that this is a
THREAD-local. A ThreadLocal variable is managed on a per-thread basis, by
the Thread. It disappears when the Thread terminates, or when the Thread
explicitly clears it.

The problem - as per the eval of that bug report referenced - is that people
use ThreadLocal as a mechanism to implement something that is
"context"-local ( where "context" can be different things). The life-time of
a "context" is not tied to the lifetime of a Thread and hence you have a
mismatch there; but also the "identity" of a "context" is not necessarily
constrained to the same Thread, and that is an even worse mismatch.

People are using ThreadLocal for things that are not thread-local, in the
sense of how ThreadLocal was designed. Hence the problems. Changing
ThreadLocal might help alleviate some of the problems, but to me that's
somewhat missing the real problem. The applications that reuse threads in
different contexts should be the ones ensuring the threads are correctly
"configured", with respect to ThreadLocal, when they switch "contexts". For
the future we should look at how a ContextLocal variable might be defined.

Just my 2c.

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Larry
> Riedel
> Sent: Tuesday, 9 October 2007 7:54 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Threadlocals and memory leaks in
> J2EE
>
>
>
> I hope I would not be anathema for saying it... my tendency
> would be not to recommend using java.lang.ThreadLocal unless
> there is no apparent (relatively clean) alternative (I still
> think it would have been nice if Thread IDs could not be
> reused).  I like the concept of thread-local variables,
> if they were more a native part of the language and JVM.
> Even so, I wonder how well that concept meshes with thread
> pools where there will be, for example, different threads
> representing the same "user" at different times.
>
>
> Larry
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From kevinb at google.com  Mon Oct  8 19:10:29 2007
From: kevinb at google.com (kevin bourrillion)
Date: Mon, 8 Oct 2007 16:10:29 -0700
Subject: [concurrency-interest] Testing!
Message-ID: <108fcdeb0710081610r5776358fu7ba085adf2c136bd@mail.gmail.com>

Hello concurrency-interest,

I'm working on the Google Collections Library.  For most of its life we've
been focusing on the non-threadsafe implementations, but these days we're
really starting to ramp up our work on the concurrent stuff.  (For example,
I should be pushing out a ConcurrentMultiset for you to play with sometime
this week or next.)

And as we've started this, it's occurred to me that, hey -- I don't know how
to test this stuff!

I'd be really glad to hear about any known best approaches for aggressively
finding bugs in complex concurrent collections.  For example, how was
ConcurrentHashMap tested?

For now, I'm concerned with finding bugs; later our focus will move more
toward performance.

thanks!


-- 
Kevin Bourrillion @ Google
google-collections.googlecode.com
google-guice.googlecode.com
jsr-310.dev.java.net
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071008/fee6d0b5/attachment.html 

From larryr at saturn.sdsu.edu  Mon Oct  8 20:12:47 2007
From: larryr at saturn.sdsu.edu (Larry Riedel)
Date: Mon, 08 Oct 2007 17:12:47 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
Message-ID: <1191888767.155296.7270.nullmailer@home35>


> People are using ThreadLocal for things that are not thread-local,
> in the sense of how ThreadLocal was designed. Hence the
> problems. Changing ThreadLocal might help alleviate some of the
> problems, but to me that's somewhat missing the real problem.

I may not have been paying enough attention, but it was
not clear to me what practical problem the implementation
of java.lang.ThreadLocal that appeared in JDK 1.2 was
designed to solve.  At the time I had been hoping for
something very fast and seamless, implemented as some highly
optimized/tuned/platform-specific code inside the JVM,
rather than some Java code that does a lookup in a hash
table where the Thread object is a key, which is something
I as an application developer could do myself.  In other
words I had been hoping it was going to be provided as a
performance boost for applications that had already been
tuned as well as they could at the Java source code level,
and could get an extra boost by using per-Thread objects
to reduce the overhead in the JVM.  Performance for Java
applications was a much bigger problem back then.  In the
context of ClassLoader and ProtectionDomain and all the
stuff that goes along with the concept of a JVM as an
operating system running untrusted applications... I can see
ThreadLocal in that context as a security related feature
for some clever code to leverage.  It is not apparent to
me there are many situations for ordinary application
programmers where using ThreadLocal would be a better idea
than just using some sort of application level mapping.


Larry


From dhanji at gmail.com  Mon Oct  8 20:13:58 2007
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Tue, 9 Oct 2007 10:13:58 +1000
Subject: [concurrency-interest] Testing!
In-Reply-To: <108fcdeb0710081610r5776358fu7ba085adf2c136bd@mail.gmail.com>
References: <108fcdeb0710081610r5776358fu7ba085adf2c136bd@mail.gmail.com>
Message-ID: <aa067ea10710081713l6a80de81r54ac77e00f681917@mail.gmail.com>

Hi Kevin

You're probably already aware of these but Findbugs has some static
analysis to detect concurrency problems. There are also several
flavors of MultithreadedTestCase (extensions to Junit), this is one
that I have used (or modeled on) in the past:
http://www.cs.umd.edu/class/fall2006/cmsc433/p2/

There are probably more sophisticated ones out there...

Dhanji.

On 10/9/07, kevin bourrillion <kevinb at google.com> wrote:
> Hello concurrency-interest,
>
> I'm working on the Google Collections Library.  For most of its life we've
> been focusing on the non-threadsafe implementations, but these days we're
> really starting to ramp up our work on the concurrent stuff.  (For example,
> I should be pushing out a ConcurrentMultiset for you to play with sometime
> this week or next.)
>
> And as we've started this, it's occurred to me that, hey -- I don't know how
> to test this stuff!
>
> I'd be really glad to hear about any known best approaches for aggressively
> finding bugs in complex concurrent collections.  For example, how was
> ConcurrentHashMap tested?
>
> For now, I'm concerned with finding bugs; later our focus will move more
> toward performance.
>
> thanks!
>
>
> --
> Kevin Bourrillion @ Google
> google-collections.googlecode.com
> google-guice.googlecode.com
> jsr-310.dev.java.net
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From dcholmes at optusnet.com.au  Mon Oct  8 21:15:50 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 9 Oct 2007 11:15:50 +1000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <1191888767.155296.7270.nullmailer@home35>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEPHHIAA.dcholmes@optusnet.com.au>

Hi Larry,

> I may not have been paying enough attention, but it was
> not clear to me what practical problem the implementation
> of java.lang.ThreadLocal that appeared in JDK 1.2 was
> designed to solve.

Disclaimer: this is my opinion only, I wasn't involved in the design or
implementation of ThreadLocal.

The "implementation" wasn't trying to solve any problem. The API was
designed to provide a way to associate objects with threads. A ThreadLocal
is a substitute for a new field in Thread - necessary because the code that
wants to carry this information around often doesn't have the ability to
control the actual thread creation of the classes used therein.
ThreadLocal's are per-thread-global-variables. They are typically used when
the application can't customize the threads involved, and where passing the
"context" via the call-chain is just too ugly.

In my view that is all ThreadLocal is - a substitute for a field. If you
couldn't solve your problem by adding a field to Thread then ThreadLocal
isn't a solution for you either.

Yes application code could provide this sort of API itself, but why have
everyone reinvent the wheel - this is what libraries are for, so we have
ThreadLocal.

How ThreadLocal was implemented was (not to be trite) an implementation
issue. The original value->Thread mapping had problems with locking and
associated overhead. The inverted Thread->value mapping is much better. This
wasn't expected to be a factor on the critical-path of reasonable
applications.

Could this have been implemented at the VM level using platform specific
thread-local code? Perhaps - not sure what Windows supports. But if you can
get a reasonable solution at the Java level you try to avoid platform
specific code in the VM. Besides, how do OS level thread-locals work? Aren't
they just a lookup "map" too?

Cheers,
David Holmes


From aaron at mindwidgets.com  Mon Oct  8 21:44:34 2007
From: aaron at mindwidgets.com (aaron)
Date: Mon, 08 Oct 2007 21:44:34 -0400
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <1191888767.155296.7270.nullmailer@home35>
References: <1191888767.155296.7270.nullmailer@home35>
Message-ID: <470ADD02.3070309@mindwidgets.com>

Larry Riedel wrote:
>> People are using ThreadLocal for things that are not thread-local,
>> in the sense of how ThreadLocal was designed. Hence the
>> problems. Changing ThreadLocal might help alleviate some of the
>> problems, but to me that's somewhat missing the real problem.
>>     
>
> I may not have been paying enough attention, but it was
> not clear to me what practical problem the implementation
> of java.lang.ThreadLocal that appeared in JDK 1.2 was
> designed to solve.  At the time I had been hoping for
> something very fast and seamless, implemented as some highly
> optimized/tuned/platform-specific code inside the JVM,
> rather than some Java code that does a lookup in a hash
> table where the Thread object is a key, which is something
> I as an application developer could do myself.  In other
> words I had been hoping it was going to be provided as a
> performance boost for applications that had already been
> tuned as well as they could at the Java source code level,
> and could get an extra boost by using per-Thread objects
> to reduce the overhead in the JVM.  Performance for Java
> applications was a much bigger problem back then.  In the
> context of ClassLoader and ProtectionDomain and all the
> stuff that goes along with the concept of a JVM as an
> operating system running untrusted applications... I can see
> ThreadLocal in that context as a security related feature
> for some clever code to leverage.  It is not apparent to
> me there are many situations for ordinary application
> programmers where using ThreadLocal would be a better idea
> than just using some sort of application level mapping.
>
>
> Larry
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>   
Hi Larry,
  I've used ThreadLocals to cache SimpleDateFormat objects when a 
relatively small number of threads (pool of 10) used them heavily. I'm 
not sure if it would be considered a "good" or "bad" thing, but it was a 
quick way to get rid of the contention of a synchronized singleton 
without having to create many new SimpleDateFormat objects. I thought I 
would throw it out there as an example, and to sanity-check the approach.

Thanks,
Aaron

From larryr at saturn.sdsu.edu  Mon Oct  8 22:39:06 2007
From: larryr at saturn.sdsu.edu (Larry Riedel)
Date: Mon, 08 Oct 2007 19:39:06 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEPHHIAA.dcholmes@optusnet.com.au>
Message-ID: <1191897546.812861.8580.nullmailer@home35>


> The "implementation" wasn't trying to solve any problem. [...] In
> my view that is all ThreadLocal is - a substitute for a field. If
> you couldn't solve your problem by adding a field to Thread then
> ThreadLocal isn't a solution for you either. [...] Yes application
> code could provide this sort of API itself, but why have everyone
> reinvent the wheel - this is what libraries are for, so we have
> ThreadLocal. [...] How ThreadLocal was implemented was (not to
> be trite) an implementation issue. [...] Could this have been
> implemented at the VM level using platform specific thread-local
> code? Perhaps [...] But if you can get a reasonable solution at
> the Java level you try to avoid platform specific code in the VM.

My hope was that performance improvement was a major motivation
behind the introduction of ThreadLocal; if that is postulated,
then I think it follows that efficiency of the implementation
is a sine qua non.  My hope at the time was that ThreadLocal was 
going to be similar to something like in the 1997 paper from Doug
Schmidt etc all about "Thread Specific Storage", "An Object
Behavioral Pattern for Accessing per-Thread State Efficiently".
(http://www.cs.wustl.edu/~schmidt/PDF/TSS-pattern.pdf)

Excerpts:

    1 Intent
    Allows multiple threads to use one logically global access
    point to retrieve thread-specific data without incurring
    locking overhead for each access.
    [...]
    This pattern resolves the following forces:
    Efficiency:
        Thread-specific storage allows sequential methods within a
        thread to access thread-specific objects atomically without
        incurring locking overhead for each access.
    Simplify application programming:
        Thread-specific storage is simple for application programmers
        to use because system developers can make the use of
        thread-specific storage completely transparent at the
        source-code level via data abstraction or macros.
    Highly portable:
        Thread-specific storage is available on most multi-threaded
        OS platforms and can be implemented conveniently on platforms
        (such as VxWorks) that lack it.
   Therefore, regardless of whether an application runs in a single
   thread or multiple threads, there should be no additional overhead
   incurred and no changes to the code required to use the
   Thread-Specific Storage pattern.

I think within that context it might be more clear why I
was hoping for ThreadLocal to provide something which had
efficiency as a major motivation.  I also think the "ELF
Handling For Thread-Local Storage" document from Ulrich
Drepper helps give an indication of the significance of
efficiency when "thread-local" storage is discussed.
(http://people.redhat.com/drepper/tls.pdf)


Larry


From wojcicki at itee.uq.edu.au  Mon Oct  8 23:40:28 2007
From: wojcicki at itee.uq.edu.au (Margaret Wojcicki)
Date: Tue, 9 Oct 2007 13:40:28 +1000
Subject: [concurrency-interest] Testing!
In-Reply-To: <aa067ea10710081713l6a80de81r54ac77e00f681917@mail.gmail.com>
References: <108fcdeb0710081610r5776358fu7ba085adf2c136bd@mail.gmail.com>
	<aa067ea10710081713l6a80de81r54ac77e00f681917@mail.gmail.com>
Message-ID: <000001c80a26$23859090$4b406682@itee.uq.edu.au>

In addition to the approaches that Dhanji mentioned, the following tools
might of interest to you:
* another static analysis tool that can detect deadlocks and other
concurrency defects called Jlint (http://jlint.sourceforge.net/)
* a model-checker that you can run with your code called JavaPathFinder
(http://javapathfinder.sourceforge.net/) that detects deadlocks by default;
assertions can be used additionally to detect other defects
* dynamic analysis tools: ConTest
(http://www.alphaworks.ibm.com/tech/contest?open&S_TACT=105AGX59&S_CMP=GR&ca
=dgr-lnxw03awcontest) and ConAn (http://www.itee.uq.edu.au/~testcon/)
* concurrent desk-checking
(http://doi.ieeecomputersociety.org/10.1109/IPDPS.2004.1303337)
* MultithreadedTC
(http://www.cs.umd.edu/projects/PL/multithreadedtc/overview.html)
* and more...

To deal with the different capabilities of these V&V technologies, a method
has been developed that combines a number of these approaches for V&V of
concurrent components (TestCon -
http://www.itee.uq.edu.au/~testcon/_papers/conc_method_ccpe.pdf).  It is
currently being revised and evaluated.

There is also a section in Java Concurrency in Practice (http://jcip.net/)
that may be of interest to you (it includes performance testing as well).

Maggie

>-----Original Message-----
>From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>interest-bounces at cs.oswego.edu] On Behalf Of Dhanji R. Prasanna
>Sent: Tuesday, 9 October 2007 10:14 AM
>To: kevin bourrillion
>Cc: concurrency-interest at cs.oswego.edu; Google Collections Library -
>developer list
>Subject: Re: [concurrency-interest] Testing!
>
>Hi Kevin
>
>You're probably already aware of these but Findbugs has some static
>analysis to detect concurrency problems. There are also several
>flavors of MultithreadedTestCase (extensions to Junit), this is one
>that I have used (or modeled on) in the past:
>http://www.cs.umd.edu/class/fall2006/cmsc433/p2/
>
>There are probably more sophisticated ones out there...
>
>Dhanji.
>
>On 10/9/07, kevin bourrillion <kevinb at google.com> wrote:
>> Hello concurrency-interest,
>>
>> I'm working on the Google Collections Library.  For most of its life
>we've
>> been focusing on the non-threadsafe implementations, but these days we're
>> really starting to ramp up our work on the concurrent stuff.  (For
>example,
>> I should be pushing out a ConcurrentMultiset for you to play with
>sometime
>> this week or next.)
>>
>> And as we've started this, it's occurred to me that, hey -- I don't know
>how
>> to test this stuff!
>>
>> I'd be really glad to hear about any known best approaches for
>aggressively
>> finding bugs in complex concurrent collections.  For example, how was
>> ConcurrentHashMap tested?
>>
>> For now, I'm concerned with finding bugs; later our focus will move more
>> toward performance.
>>
>> thanks!
>>
>>
>> --
>> Kevin Bourrillion @ Google
>> google-collections.googlecode.com
>> google-guice.googlecode.com
>> jsr-310.dev.java.net
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at altair.cs.oswego.edu
>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest at altair.cs.oswego.edu
>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest



From dcholmes at optusnet.com.au  Mon Oct  8 23:43:48 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 9 Oct 2007 13:43:48 +1000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <1191897546.812861.8580.nullmailer@home35>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEPJHIAA.dcholmes@optusnet.com.au>

Larry Riedel writes:
> My hope was that performance improvement was a major motivation
> behind the introduction of ThreadLocal;

Performance improvement over what? An application specific version of
ThreadLocal? Or something else? I'm not clear what your baseline is here.

I think the API was created to meet a given functional need ie. as Doug
Schmidt wrote:

>     Allows multiple threads to use one logically global access
>     point to retrieve thread-specific data

The original implementation obviously didn't meet Doug Schmidt's efficiency
criteria of "without incurring locking overhead". But the later
implementation addressed that.

> I think within that context it might be more clear why I
> was hoping for ThreadLocal to provide something which had
> efficiency as a major motivation.  I also think the "ELF
> Handling For Thread-Local Storage" document from Ulrich
> Drepper helps give an indication of the significance of
> efficiency when "thread-local" storage is discussed.
> (http://people.redhat.com/drepper/tls.pdf)

Yeah that's interesting stuff - how you would like to do TLS "properly" with
language level integration, not just an API to a look-up table.

Cheers,
David Holmes


From carfield at carfield.com.hk  Mon Oct  8 23:53:42 2007
From: carfield at carfield.com.hk (Carfield Yim)
Date: Tue, 9 Oct 2007 11:53:42 +0800
Subject: [concurrency-interest] Testing!
In-Reply-To: <108fcdeb0710081610r5776358fu7ba085adf2c136bd@mail.gmail.com>
References: <108fcdeb0710081610r5776358fu7ba085adf2c136bd@mail.gmail.com>
Message-ID: <b4503c170710082053o16b126ddned6b8f4b0ad84f00@mail.gmail.com>

There is a chapter of the book "java concurrency in practice" call
"Testing Concurrent Programs", you can find the code at
http://jcip.net/listings.html

Other than that, wicket have a threadtest project for
http://svn.apache.org/repos/asf/wicket/trunk/testing/wicket-threadtest/
, not sure if that is useful for your case

On 10/9/07, kevin bourrillion <kevinb at google.com> wrote:
> Hello concurrency-interest,
>
> I'm working on the Google Collections Library.  For most of its life we've
> been focusing on the non-threadsafe implementations, but these days we're
> really starting to ramp up our work on the concurrent stuff.  (For example,
> I should be pushing out a ConcurrentMultiset for you to play with sometime
> this week or next.)
>
> And as we've started this, it's occurred to me that, hey -- I don't know how
> to test this stuff!
>
> I'd be really glad to hear about any known best approaches for aggressively
> finding bugs in complex concurrent collections.  For example, how was
> ConcurrentHashMap tested?
>
> For now, I'm concerned with finding bugs; later our focus will move more
> toward performance.
>
> thanks!
>
>
> --
> Kevin Bourrillion @ Google
> google-collections.googlecode.com
> google-guice.googlecode.com
> jsr-310.dev.java.net
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From josh at bloch.us  Tue Oct  9 01:40:28 2007
From: josh at bloch.us (Joshua Bloch)
Date: Mon, 8 Oct 2007 22:40:28 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <1191897546.812861.8580.nullmailer@home35>
References: <NFBBKALFDCPFIDBNKAPCGEPHHIAA.dcholmes@optusnet.com.au>
	<1191897546.812861.8580.nullmailer@home35>
Message-ID: <b097ac510710082240s71694f09o3ee84531fae4c6e@mail.gmail.com>

Folks,

This thread is littered with misinformation.  Java's ThreadLocal
implementation is very, very fast.  It has been completely re-written
several times, getting faster each time.  (Props to Doug Lea.) Larry
Riedel's description ("some Java code that does a lookup in a hashtable
where the Thread object is a key, which is something I as an application
developer could do myself.") is wrong on two counts: Only the
1.2implementation, which was a stopgap, was implemented as
per-ThreadLocal map
from thread to value.  And practically all application programmers could *
not* "do it themselves." I suggested adding thread locals to the platform
only after I saw the fourth broken implementation out of four independent
attempts.  Without naming names, these implementations were written by elite
systems programmers.

There is nothing inherently wrong with thread locals: They do not cause
memory leaks. They are not slow. They are more local than their
non-thread-local counterparts (i.e., they have better information hiding
properties).  They can be misused, of course, but so can most other
programming tools.

Whether thread locals are in the language or the libraries is largely a
matter of syntax.  In '97 I proposed adding thread locals to the language
(the threadlocal modifier), but there was insufficient support for this, so
I wrote the ThreadLocal API that we now use.

Larry says "It is not apparent to me there are many situations for ordinary
application programmers where using ThreadLocal would be a better idea than
just using some sort of application level mapping."  I am flabbergasted.
What makes Larry think that Joe Programmer's ThreadLocal implementation will
be better than the one that Doug and I wrote and carefully optimized? It
most certainly will not.

There are many compelling uses for thread locals.  Here are a few off the
top of my head:

(1) Genuine per-thread context, such as user id or transaction id.  Works
great.  Easy to clean up when the thread exits the scope.  No leaks.

(2) Per-thread instances for performance.  Aaron's SimpleDateFormat example
(above) is one example of this pattern.

(3) "Sleazing" values through callbacks that you don't control: sometimes
you must call a library method that calls back into your package.  At this
point, you need some context that you were unable to pass to yourself, due
to deficiencies in the library.  In this rare situation, thread locals can
be a lifesaver.

In all of these cases, thread locals are the right thing to use.  Can you
cause unintended object retention with thread locals?  Sure you can.   But
you can do this with arrays too. That doesn't mean that thread locals (or
arrays) are bad things.  Merely that you have to use them with some care.
The use of thread *pools* demands extreme care.  Sloppy use of thread pools
in combination with sloppy use of thread locals can cause unintended object
retention, as has been noted in many places.  But placing the blame on
thread locals is unwarranted.  Virtually all threading systems of which I'm
aware provide support for thread local variables.  There's a reason for
this: they are a fundamental part of the thread abstraction.

           Uappologetically yours,

           Josh
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071008/22062fcf/attachment.html 

From unmesh_joshi at hotmail.com  Tue Oct  9 04:31:31 2007
From: unmesh_joshi at hotmail.com (Unmesh joshi)
Date: Tue, 9 Oct 2007 08:31:31 +0000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <mailman.4.1191897555.27887.concurrency-interest@altair.cs.oswego.edu>
References: <mailman.4.1191897555.27887.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <BAY140-W41833A2885B97A02947DCCEFA50@phx.gbl>


Hi,>>People are using ThreadLocal for things that are not thread-local, in the>>sense of how ThreadLocal was designed. Hence the problems. Changing>>ThreadLocal might help alleviate some of the problems, but to me that's>.somewhat missing the real problem. The applications that reuse threads in>>different contexts should be the ones ensuring the threads are correctly>>"configured", with respect to ThreadLocal, when they switch "contexts". For>>the future we should look at how a ContextLocal variable might be defined. >>Just my 2c. >>>>Cheers,>>David HolmesI was reading a blog by Robert Martin at http://blog.objectmentor.com/articles/2007/09/04/thread-local-a-convenient-abomination. Here he states Jim Coplien saying ?An object is an abstraction of function. A thread is an abstraction of schedule.?An object is an abstraction of function. A thread is an abstraction of schedule." and how Unit of Work related variables are often wrongly assigned to ThreadLocal. In coming J2EE concurrency utilities, is there any work going on ContextLocal or UnitOfWorkLocal utilities?
 
Thanks,
Unmesh
_________________________________________________________________
Search from any Web page with powerful protection. Get the FREE Windows Live Toolbar Today!
http://toolbar.live.com/?mkt=en-in
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071009/288d3492/attachment.html 

From online at stolsvik.com  Tue Oct  9 05:14:29 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Tue, 09 Oct 2007 11:14:29 +0200
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <b097ac510710082240s71694f09o3ee84531fae4c6e@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEPHHIAA.dcholmes@optusnet.com.au>
	<1191897546.812861.8580.nullmailer@home35>
	<b097ac510710082240s71694f09o3ee84531fae4c6e@mail.gmail.com>
Message-ID: <470B4675.4080205@Stolsvik.com>

Hi.

I agree wholeheartedly that ThreadLocals are great stuff for many 
scenarios. For me, they make lots of sense for carrying some context 
forward through method calls whose signatures you cannot or will not 
change. And they're fast. And bla bla..

Great..

> In all of these cases, thread locals are the right thing to use.  Can 
> you cause unintended object retention with thread locals?  Sure you 
> can.   But you can do this with arrays too. That doesn't mean that 
> thread locals (or arrays) are bad things.  Merely that you have to use 
> them with some care.  The use of thread /pools/ demands extreme care.  
> Sloppy use of thread pools in combination with sloppy use of thread 
> locals can cause unintended object retention, as has been noted in many 
> places. 

Did you read the links in my post?

The point is so: Tomcat is a widely used Servlet Container. ThreadLocals 
works perfect for lots of stuff, and everyone is happy.
    However, when a "web application reload" happens, the CURRENT 
implementation of ThreadLocal will, given merely one non-nulled 
ThreadLocal, and given that Tomcat don't kill _all_ its "worker Threads" 
(the ones that have done service calls into the web app) upon any webapp 
reload, retain a strong chain to the ThreadLocal's values, hence to 
those object's classloader (which is the "now ditched" old webapp 
classloader), and hence all the loaded classes. (And I guess further: 
hence all those classes' ThreadLocals, which will ensure even better 
that their values aren't GCable, since the "cleaning efforts" of the 
ThreadLocal implementation will be even more hampered).

One can argue that the application should never let a Thread get out of 
the webapp scope with any webapp scoped ThreadLocal value still 
non-null. However, the specific user cannot control all usages of 
ThreadLocals: it might be in some third party code, or some Exception 
happens in some place where one didn't think of ThreadLocal cleanup (one 
doesn't tend to handle ThreadLocals with the same care as closing e.g. a 
SQL Connection, and even that isn't always done), or again, it happens 
in some third party code, where the ThreadLocal simply isn't available 
for cleanupping.

Even "java itself", as noted in a comment for bug 6254531, has lots of 
such usage that will lead to leak if loaded by a user classloader.

The key point here, is that the old implementation, a map keyed on 
Thread, didn't have this problem. The problem was introduced with the 
reimplementation for performance improvement that the 1.3 version came 
up with, since now the Thread object itself holds a strong reference to 
the value, and ditching all references to all objects, and all classes, 
and the classloader, WILL NOT any longer be enough to make sure GC can 
happen, since one also will have to let all Threads die, taking the 
ThreadLocal value references with them..

This last little point is the sole problem the OP referred to - and I 
cannot understand that this isn't an unintended consequence of the 
performance improvement reimplementation - it definitely is a regression 
compared to how the initial implementation worked, that much I hope 
anyone will agree to.

Thomas Hawtin ("Tackline" - see links) has apparently come up with some 
solution that will ensure that merely a ThreadLocal reference won't make 
the referenced value non GCable, which doesn't degrade performance (much).

Kind regards,
Endre.

From online at stolsvik.com  Tue Oct  9 06:13:35 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Tue, 09 Oct 2007 12:13:35 +0200
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <470B4675.4080205@Stolsvik.com>
References: <NFBBKALFDCPFIDBNKAPCGEPHHIAA.dcholmes@optusnet.com.au>
	<1191897546.812861.8580.nullmailer@home35>
	<b097ac510710082240s71694f09o3ee84531fae4c6e@mail.gmail.com>
	<470B4675.4080205@Stolsvik.com>
Message-ID: <470B544F.1000604@Stolsvik.com>

> 
> Thomas Hawtin ("Tackline" - see links) has apparently come up with some 
> solution that will ensure that merely a ThreadLocal reference won't make 
> the referenced value non GCable, which doesn't degrade performance (much).

I realize this came out wrong..! Of course, it is plenty enough that 
"merely a ThreadLocal" references a value - a ThreadLocal shall not work 
as a WeakReference or something like that.

The problem is that since the Thread holds a hard reference to the 
ThreadLocal value, an entire graph of objects, consisting of the value, 
its classloader, and all that classloader's loaded classes (with their 
static ThreadLocals again) will be retained, even though no object, 
class or classloader in this graph is still in active or actual use (the 
entire graph is really "loose", and should be GCable, wasn't it for this 
"not really" reference).

Regards,
Endre.

From unmesh_joshi at hotmail.com  Tue Oct  9 06:30:55 2007
From: unmesh_joshi at hotmail.com (Unmesh joshi)
Date: Tue, 9 Oct 2007 10:30:55 +0000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <470A8C52.8030401@Stolsvik.com>
References: <mailman.3.1191471017.15054.concurrency-interest@altair.cs.oswego.edu>
	<BAY140-W22C66EA3D71BF5F0DBA40DEFA40@phx.gbl> 
	<470A8C52.8030401@Stolsvik.com>
Message-ID: <BAY140-W3EC489D9829FC9876897DEFA50@phx.gbl>


Thanks Endre for useful links.
So I suppose if I use threadlocal which are not referring to any of the classes in my web module and not using hot deployment feature of app server, I am safe. 
I was planning to use threadlocal for saving some user specific context before a http request is handled by my server side classes and clean it up before sending the response. This way, it wont be needed to pass user context (userid and other useful information) to all the methods as parameter.
The example code might be like
RequestContextHolder {
 private static ThreadLocal threadLocal = new ThreadLocal();
 public static Map get() {
        return (Map)threadLocal.get(); }
 
 public static void set(Map context) {
          threadLocal.set(context); }
 
 public static void clearContext() {
       threadLocal.set(null);
 }
}
 
 
class FrontController {
 
 
    public void handleReqeuest(HttpRequst request.....) {
 
               Map requestContext = buildRequestContext(request);
               RequestContextHolder.set(requestContext);
                .....
               Response response = handleRequest(request);
               processResponse(response);
 
               RequestContextHolder.clearContext(); 
 
    }
    }
 
 
I can think of this as a very convinient when we need to access request context at many placed. This might be a bad practice to use RequestContext at various places rather than passing explicit parameters, but I think in certain scenarios, this might be very handy.
 
Is this a general practice to keep some kind of "execution context" in ThreadLocal?
 
Thanks,
Unmesh
 
P.S. I am not sending this email to whole of concurrency-interest> Date: Mon, 8 Oct 2007 22:00:18 +0200> From: online at stolsvik.com> Subject: Re: [concurrency-interest] Threadlocals and memory leaks in J2EE> To: unmesh_joshi at hotmail.com> CC: concurrency-interest at cs.oswego.edu> > Unmesh joshi wrote:> > > > Hi,> > > > Threadlocals are used in J2EE application servers to keep track of > > transaction context and security context. I was thinking of using it to > > pass execution context (which involves some user login and other context > > information) around in web application which involves servlets and other > > server side classes. (As discussed at > > http://www.theserverside.com/news/thread.tss?thread_id=41473).> > I remember reading somewhere that Threadlocals can cause memory leaks if > > Threads are getting reused through thread pools. (Which is the case in > > J2EE application servers).> > What way can Threadlocal cause memory leak? How Threadlocals behave with > > Classloaderes in J2EE? In what cases thread local usage is not recommended?> > Here's your fix of your information needs!> > Vote for this! NOW!> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6254531> > Technical low-down on the problem, and a fix:> http://www.jroller.com/tackline/entry/fixing_threadlocal> > .. a quite involved "drop in ThreadLocal replacement" workaround:> http://www.jroller.com/tackline/entry/working_around_the_threadlocal_leak> The problem here is that since ThreadLocals might be used in third > party libraries, you quite possibly end up not being able to replace > their usages..> > (Those links all actually link to each other.. And if you follow links > further, you'll get even more info..)> > In what use cases: when you reuse thread(pools) and at the same time > change class loaders to implement "reload" functionality. With that > usage pattern, you will often have the old, reused threads hang onto > hard references to all the old application instance's ThreadLocal > values, and thereby also that instance's classes, not permitting these > to be garbage collected.> > So - it basically only happens for "containers" of different sorts, for > example (and in particular!) Tomcat.> (The Tomcat guys could easily have fixed it on their side, by either > hacking into the innards of Thread (by introspection) and "wash" their > ThreadLocal references, or make a brand new thread pool when any webapp > is reloaded, letting the old threads die. However, Tomcat seems > dictatorially lead by this nice chap from JBoss that instantly WONTFIXes > bugs he personally isn't affected by, without considering the > implications for others.)> > Kind regards,> Endre.
_________________________________________________________________
Check out some new online services at Windows Live Ideas?so new they haven?t even been officially released yet.
http://www.msnspecials.in/windowslive/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071009/cbf13847/attachment.html 

From Eamonn.McManus at Sun.COM  Tue Oct  9 06:55:15 2007
From: Eamonn.McManus at Sun.COM (Eamonn McManus)
Date: Tue, 09 Oct 2007 12:55:15 +0200
Subject: [concurrency-interest] Is java.lang.Enum.values() thread safe ?
In-Reply-To: <15e8b9d20710081150g5acc6432t6355c8648a737b56@mail.gmail.com>
References: <ca53c8f80710080946m3c8a7de0v9e44eef7d6648b38@mail.gmail.com>
	<15e8b9d20710081150g5acc6432t6355c8648a737b56@mail.gmail.com>
Message-ID: <470B5E13.30001@sun.com>

An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071009/eb5665dd/attachment.html 

From gregg at cytetech.com  Tue Oct  9 09:24:02 2007
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 09 Oct 2007 08:24:02 -0500
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <1191880466.801090.6057.nullmailer@home35>
References: <1191880466.801090.6057.nullmailer@home35>
Message-ID: <470B80F2.4090107@cytetech.com>

Larry Riedel wrote:
> I hope I would not be anathema for saying it... my tendency
> would be not to recommend using java.lang.ThreadLocal unless
> there is no apparent (relatively clean) alternative (I still
> think it would have been nice if Thread IDs could not be
> reused).  I like the concept of thread-local variables,
> if they were more a native part of the language and JVM.
> Even so, I wonder how well that concept meshes with thread
> pools where there will be, for example, different threads
> representing the same "user" at different times.

I wonder if a context class loader, exposing a per-thread instance of 
ThreadLocal would not be a better solution?

One of the issues with context class loaders, is that the current uses and 
mechanics don't provide a chaining mechanism.  So, typically you find

final ClassLoader ld = Thread.currentThread().getContextClassLoader();
try {
	Thread.currentThread().setContextClassLoader( neededLoader );
	... some code...
} finally {
	Thread.currentThread().setContextClassLoader( ld );
}

when it would be great to have a closure like notation that allowed a context 
class loader to be "stacked" on top of a context class loading chain. For mobile 
code in clients, "neededLoader" is often just getClass().getClassLoader().  This 
is something which I believe should be a more formalized detail.  Especially 
since you have to set a context class loader on the AWT event thread, everywhere 
(I have a version of SwingWorker that does this for me).

The container/server could provide a context class loader for each thread, that 
provided the resolution of ThreadLocal.  Any other additional context would be 
stacked on top of that.

There are quite a few things about how the class loading subsystem works, which 
could use some attention to make containers (including AWT in a mobile code 
environment) have more infrastructure to rely on.

Gregg Wonderly

From gregg at cytetech.com  Tue Oct  9 11:49:17 2007
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 09 Oct 2007 10:49:17 -0500
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <1191888767.155296.7270.nullmailer@home35>
References: <1191888767.155296.7270.nullmailer@home35>
Message-ID: <470BA2FD.6070202@cytetech.com>

Larry Riedel wrote:
> It is not apparent to
> me there are many situations for ordinary application
> programmers where using ThreadLocal would be a better idea
> than just using some sort of application level mapping.

I think containers are using this as a shortcut way of not having to pass a 
context object around through all method signatures.  They could of instead, 
designed their API so that the user "thread" was manifested inside of a 
constructed object which could then expose new context information in fields or 
method signatures.

Java servlets have the request and response context enumerated in the API and 
this, for me, provides exposure in a way that clearly shows what context you are 
  executing in.

In many cases, I think Runnable gets used to often and the end result is that 
because an interface is the referred-to type, there is no room for expansion 
that subclassing would allow.

Gregg Wonderly

From larryr at saturn.sdsu.edu  Tue Oct  9 11:59:01 2007
From: larryr at saturn.sdsu.edu (Larry Riedel)
Date: Tue, 09 Oct 2007 08:59:01 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEPJHIAA.dcholmes@optusnet.com.au>
Message-ID: <1191945541.625791.9178.nullmailer@home35>


> > My hope was that performance improvement was a major
> > motivation behind the introduction of ThreadLocal;
> 
> Performance improvement over what?  An application specific
> version of ThreadLocal?  Or something else?

Improvement over using a Java hash table object which uses
the Thread object as a key... I would hesitate to call that
"thread local" though... rather than maybe just "per thread".


> how you would like to do TLS "properly" with language level
> integration, not just an API to a look-up table.

Virtual address, CPU cache, TLB... to me those are look-up
tables; for me it is a question of providing performance
improvement by leveraging faster lower level mechanisms by
taking advantage of simplifying assumptions (such as that no
locking is needed).

I have not thought much about how I would recommend implementing
it with language and JVM level support; off the top of my head,
I guess a relatively simple approach would be to have the
programmer specify a modifier like "threadlocal" for a variable,
which is similar to "volatile", and in that case the symbol
table entry for a ThreadLocal field in an object instance would
store a reference to a separate per-Thread structure, associated
with that class and instance, which has symbol table entries
for the real references, and the JVM would seamlessly take care
of the creation/destruction and the extra indirection; and of
course that indirection would at some level result in using some
sort of look-up table (eg in the MMU).


Larry


From gregg at cytetech.com  Tue Oct  9 13:32:19 2007
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 09 Oct 2007 12:32:19 -0500
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <BAY140-W41833A2885B97A02947DCCEFA50@phx.gbl>
References: <mailman.4.1191897555.27887.concurrency-interest@altair.cs.oswego.edu>
	<BAY140-W41833A2885B97A02947DCCEFA50@phx.gbl>
Message-ID: <470BBB23.3010506@cytetech.com>

Unmesh joshi wrote:
> In coming J2EE concurrency utilities, is there any work 
> going on ContextLocal or UnitOfWorkLocal utilities?/

I'd really like to see this "ContextLocal" stuff be supported through a context 
class loader mechanism so that the right context could become part of some other 
things related to mobile code and/or "plugged-in" code that containers typically 
accomidate.  If there was a stackable context classloader mechanism, than the 
container creating the execution context could put this context local stuff at 
the base of that stack, and the application could then modify and extend the 
classloading context as needed to include the use of code from multiple sources.

The Jini PreferredClassLoader and RMIClassLoaderSPI impl, ProferredClassProvider 
(and the ClassLoading class) make it easy for a code provider to designate the 
"platform" that they are relying on.

Unfortunately, the class loader mechanisms and threading, together create such a 
nightmarish view of class loading that it's doubly difficult to get it right.

Gregg Wonderly

From joe.bowbeer at gmail.com  Tue Oct  9 14:26:00 2007
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 9 Oct 2007 11:26:00 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
Message-ID: <31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>

On 10/8/07, David Holmes wrote:
>
> The problem - as per the eval of that bug report referenced - is that people
> use ThreadLocal as a mechanism to implement something that is
> "context"-local (where "context" can be different things).

Which leads to the thread-local guy and the thread-pool guy pointing
their finger at each other...

I like your analysis.

--Joe

From peter.kovacs.1.0rc at gmail.com  Tue Oct  9 16:25:59 2007
From: peter.kovacs.1.0rc at gmail.com (Peter Kovacs)
Date: Tue, 9 Oct 2007 22:25:59 +0200
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
Message-ID: <b6e8f2e80710091325q509be32cg5bcc3597f5e747d8@mail.gmail.com>

Very instructive indeed.

But strangely: is the conculsion that the use of ThreadLocal is
out-of-place except when used in Thread pools -- meaning that in the
majority of the cases where ThreadLocal currently is used some kind of
general context abstraction should be used instead? In other words:
ThreadLocal is a useful stand-in in many case, but is not the
conceptually correct solution. (Just like the hammer can be
efficiently used to drive a screw in, but...)

Thanks
P.

On 10/9/07, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> On 10/8/07, David Holmes wrote:
> >
> > The problem - as per the eval of that bug report referenced - is that people
> > use ThreadLocal as a mechanism to implement something that is
> > "context"-local (where "context" can be different things).
>
> Which leads to the thread-local guy and the thread-pool guy pointing
> their finger at each other...
>
> I like your analysis.
>
> --Joe
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From joe.bowbeer at gmail.com  Tue Oct  9 17:02:57 2007
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 9 Oct 2007 14:02:57 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <b6e8f2e80710091325q509be32cg5bcc3597f5e747d8@mail.gmail.com>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
	<b6e8f2e80710091325q509be32cg5bcc3597f5e747d8@mail.gmail.com>
Message-ID: <31f2a7bd0710091402p3c1e155dp1faa5c4e53da205b@mail.gmail.com>

On 10/9/07, Peter Kovacs wrote:
> Very instructive indeed.
>
> But strangely: is the conculsion that the use of ThreadLocal is
> out-of-place except when used in Thread pools -- meaning that in the
> majority of the cases where ThreadLocal currently is used some kind of
> general context abstraction should be used instead? In other words:
> ThreadLocal is a useful stand-in in many case, but is not the
> conceptually correct solution. (Just like the hammer can be
> efficiently used to drive a screw in, but...)
>
> Thanks
> P.
>

In applications where the threading model is a given, or the
application creates and manages its own threads, then its safe to use
thread-local for several different purposes -- as long as they're
compatible with the threading model.  If there's only one thread per
context (or one parent thread) then a thread-local can even serve as a
per-context global variable.

In applications and shared libraries where the threading model is
somewhat flexible, the uses for thread-local are more limited and,
judging from this discussion, not entirely trouble free (yet?).

As for thread locals and pools, ThreadLocal can be used in combination
with a ThreadPool in order to reduce contention among the worker
threads.  In my view this is an optimization that is a bit fragile,
but often worth the maintentance risk.

--
Joe Bowbeer


> On 10/9/07, Joe Bowbeer wrote:
> > On 10/8/07, David Holmes wrote:
> > >
> > > The problem - as per the eval of that bug report referenced - is that people
> > > use ThreadLocal as a mechanism to implement something that is
> > > "context"-local (where "context" can be different things).
> >
> > Which leads to the thread-local guy and the thread-pool guy pointing
> > their finger at each other...
> >
> > I like your analysis.
> >
> > --Joe
>

From dcholmes at optusnet.com.au  Tue Oct  9 18:45:20 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 10 Oct 2007 08:45:20 +1000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <b6e8f2e80710091325q509be32cg5bcc3597f5e747d8@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEPPHIAA.dcholmes@optusnet.com.au>

Peter Kovacs writes:
> But strangely: is the conculsion that the use of ThreadLocal is
> out-of-place except when used in Thread pools

Not at all - almost the opposite: ThreadLocal in non-pool threads a common,
correct usage. Using ThreadLocal in threads that are part of Thread pools
takes great care.

When "thread" and "context" map nicely in terms of identity and lifetime,
then a ThreadLocal can be used for what is more generally a "context-local"
variable. It is when "thread" and "context" don't map nicely that problems
arise.

But taking a step back, Unmesh stated that the problem originally being
reported was that the change in the implementation of ThreadLocal causes the
retention problem in "reloads". I can't quite see how the two
implementations differ in that regard - I was hoping Josh would jump back in
and challenge this comment too, but guess I'll have to do it (in another
email) :)

Cheers,
David Holmes


From dcholmes at optusnet.com.au  Tue Oct  9 18:51:51 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 10 Oct 2007 08:51:51 +1000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <470B4675.4080205@Stolsvik.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEPPHIAA.dcholmes@optusnet.com.au>

Endre,

Endre Stolsvik writes:
>     However, when a "web application reload" happens, the CURRENT
> implementation of ThreadLocal will, given merely one non-nulled
> ThreadLocal, and given that Tomcat don't kill _all_ its "worker Threads"
> (the ones that have done service calls into the web app) upon any webapp
> reload, retain a strong chain to the ThreadLocal's values, hence to
> those object's classloader (which is the "now ditched" old webapp
> classloader), and hence all the loaded classes.
> ...
> The key point here, is that the old implementation, a map keyed on
> Thread, didn't have this problem. The problem was introduced with the
> reimplementation for performance improvement that the 1.3 version came
> up with, since now the Thread object itself holds a strong reference to
> the value

I am missing something here. I don't see how the old way (per-Variable:
Thread->value) is different, in terms of retention, to the new way
(per-Thread: variable->value). Can you clarify the problem - thanks.

David Holmes


From dcholmes at optusnet.com.au  Tue Oct  9 18:53:37 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 10 Oct 2007 08:53:37 +1000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEPPHIAA.dcholmes@optusnet.com.au>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEAAHJAA.dcholmes@optusnet.com.au>

Sorry I meant Endre, not Unmesh.

David

> -----Original Message-----
> From: David Holmes [mailto:dcholmes at optusnet.com.au]
> Sent: Wednesday, 10 October 2007 8:45 AM
> To: Peter Kovacs
> Cc: concurrency-interest
> Subject: RE: [concurrency-interest] Threadlocals and memory leaks in
> J2EE
> 
> 
> Peter Kovacs writes:
> > But strangely: is the conculsion that the use of ThreadLocal is
> > out-of-place except when used in Thread pools
> 
> Not at all - almost the opposite: ThreadLocal in non-pool threads 
> a common, correct usage. Using ThreadLocal in threads that are 
> part of Thread pools takes great care.
> 
> When "thread" and "context" map nicely in terms of identity and 
> lifetime, then a ThreadLocal can be used for what is more 
> generally a "context-local" variable. It is when "thread" and 
> "context" don't map nicely that problems arise.
> 
> But taking a step back, Unmesh stated that the problem originally 
> being reported was that the change in the implementation of 
> ThreadLocal causes the retention problem in "reloads". I can't 
> quite see how the two implementations differ in that regard - I 
> was hoping Josh would jump back in and challenge this comment 
> too, but guess I'll have to do it (in another email) :)
> 
> Cheers,
> David Holmes
> 

From crazybob at crazybob.org  Tue Oct  9 19:10:51 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Tue, 9 Oct 2007 16:10:51 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEPPHIAA.dcholmes@optusnet.com.au>
References: <470B4675.4080205@Stolsvik.com>
	<NFBBKALFDCPFIDBNKAPCOEPPHIAA.dcholmes@optusnet.com.au>
Message-ID: <a74683f90710091610l43a8662yd0fffd109b838a87@mail.gmail.com>

On 10/9/07, David Holmes <dcholmes at optusnet.com.au> wrote:
>
> I am missing something here. I don't see how the old way (per-Variable:
> Thread->value) is different, in terms of retention, to the new way
> (per-Thread: variable->value). Can you clarify the problem - thanks.


David,

With the new model, as you know, Thread keeps a weak reference to the
ThreadLocal (key) and a strong reference to the value. If the value
inadvertently strongly references the ThreadLocal key, the entry will never
get cleaned up. A similar situation could arise in the old model if a value
strongly referenced the Thread.

It's very easy to accidentally create a strong reference between your value
and ThreadLocal instance. For example, say we have classes Foo and Bar which
are both loaded by MyClassLoader:

class Foo {
  static ThreadLocal<Bar> localBar = ...;
}

That code has a memory leak. If you get rid of all references to
MyClassLoader, it and all its classes should get GCed, but in this case, we
leak a strong reference:

  Thread -> Bar (localBar's value) -> MyClassLoader (Bar.getClass()) -> Foo
-> localBar

I also ran into this once when I inadvertently created a circular reference
by using an inner class:
http://crazybob.org/2006/02/threadlocal-memory-leak.html

Thanks,
Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071009/5bbd7718/attachment.html 

From crazybob at crazybob.org  Tue Oct  9 19:12:39 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Tue, 9 Oct 2007 16:12:39 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <a74683f90710091610l43a8662yd0fffd109b838a87@mail.gmail.com>
References: <470B4675.4080205@Stolsvik.com>
	<NFBBKALFDCPFIDBNKAPCOEPPHIAA.dcholmes@optusnet.com.au>
	<a74683f90710091610l43a8662yd0fffd109b838a87@mail.gmail.com>
Message-ID: <a74683f90710091612j421dbe50h8bb6994d0122c948@mail.gmail.com>

That said, the solution is simply to remove() your thread local values in a
finally block.

Bob

On 10/9/07, Bob Lee <crazybob at crazybob.org> wrote:
>
> On 10/9/07, David Holmes <dcholmes at optusnet.com.au> wrote:
> >
> > I am missing something here. I don't see how the old way (per-Variable:
> > Thread->value) is different, in terms of retention, to the new way
> > (per-Thread: variable->value). Can you clarify the problem - thanks.
>
>
> David,
>
> With the new model, as you know, Thread keeps a weak reference to the
> ThreadLocal (key) and a strong reference to the value. If the value
> inadvertently strongly references the ThreadLocal key, the entry will never
> get cleaned up. A similar situation could arise in the old model if a value
> strongly referenced the Thread.
>
> It's very easy to accidentally create a strong reference between your
> value and ThreadLocal instance. For example, say we have classes Foo and Bar
> which are both loaded by MyClassLoader:
>
> class Foo {
>   static ThreadLocal<Bar> localBar = ...;
> }
>
> That code has a memory leak. If you get rid of all references to
> MyClassLoader, it and all its classes should get GCed, but in this case, we
> leak a strong reference:
>
>   Thread -> Bar (localBar's value) -> MyClassLoader (Bar.getClass()) ->
> Foo -> localBar
>
> I also ran into this once when I inadvertently created a circular
> reference by using an inner class:
> http://crazybob.org/2006/02/threadlocal-memory-leak.html
>
> Thanks,
> Bob
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071009/cbdf6443/attachment-0001.html 

From dcholmes at optusnet.com.au  Tue Oct  9 19:33:32 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 10 Oct 2007 09:33:32 +1000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <a74683f90710091610l43a8662yd0fffd109b838a87@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEABHJAA.dcholmes@optusnet.com.au>

Thanks for the explanation Bob.

That's a nasty cycle: the WeakRef to the key isn't cleared because of the
strong-ref to the key via the value; and the value isn't cleared because the
WeakRef to the key isn't cleared. I don't suppose we can point the finger at
the GC folk and tell them they should be able to spot this? :) More
seriously if the relationship/dependency between the key and value could be
captured explicitly (say class WeakReferenceWithValue) then the cycle could
be broken.

Cheers,
David Holmes
  -----Original Message-----
  From: crazyboblee at gmail.com [mailto:crazyboblee at gmail.com]On Behalf Of Bob
Lee
  Sent: Wednesday, 10 October 2007 9:11 AM
  To: dholmes at ieee.org
  Cc: Endre Stolsvik; concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Threadlocals and memory leaks in J2EE


  On 10/9/07, David Holmes <dcholmes at optusnet.com.au> wrote:
    I am missing something here. I don't see how the old way (per-Variable:
    Thread->value) is different, in terms of retention, to the new way
    (per-Thread: variable->value). Can you clarify the problem - thanks.

  David,

  With the new model, as you know, Thread keeps a weak reference to the
ThreadLocal (key) and a strong reference to the value. If the value
inadvertently strongly references the ThreadLocal key, the entry will never
get cleaned up. A similar situation could arise in the old model if a value
strongly referenced the Thread.

  It's very easy to accidentally create a strong reference between your
value and ThreadLocal instance. For example, say we have classes Foo and Bar
which are both loaded by MyClassLoader:


  class Foo {
    static ThreadLocal<Bar> localBar = ...;
  }

  That code has a memory leak. If you get rid of all references to
MyClassLoader, it and all its classes should get GCed, but in this case, we
leak a strong reference:

    Thread -> Bar (localBar's value) -> MyClassLoader (Bar.getClass()) ->
Foo -> localBar

  I also ran into this once when I inadvertently created a circular
reference by using an inner class:
http://crazybob.org/2006/02/threadlocal-memory-leak.html

  Thanks,
  Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071010/8f64b2af/attachment.html 

From dcholmes at optusnet.com.au  Tue Oct  9 19:35:30 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 10 Oct 2007 09:35:30 +1000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <a74683f90710091612j421dbe50h8bb6994d0122c948@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEABHJAA.dcholmes@optusnet.com.au>

A finally block of what?

David
  -----Original Message-----
  From: crazyboblee at gmail.com [mailto:crazyboblee at gmail.com]On Behalf Of Bob
Lee
  Sent: Wednesday, 10 October 2007 9:13 AM
  To: dholmes at ieee.org
  Cc: Endre Stolsvik; concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Threadlocals and memory leaks in J2EE


  That said, the solution is simply to remove() your thread local values in
a finally block.

  Bob


  On 10/9/07, Bob Lee < crazybob at crazybob.org> wrote:
    On 10/9/07, David Holmes <dcholmes at optusnet.com.au> wrote:
      I am missing something here. I don't see how the old way
(per-Variable:
      Thread->value) is different, in terms of retention, to the new way
      (per-Thread: variable->value). Can you clarify the problem - thanks.

    David,

    With the new model, as you know, Thread keeps a weak reference to the
ThreadLocal (key) and a strong reference to the value. If the value
inadvertently strongly references the ThreadLocal key, the entry will never
get cleaned up. A similar situation could arise in the old model if a value
strongly referenced the Thread.

    It's very easy to accidentally create a strong reference between your
value and ThreadLocal instance. For example, say we have classes Foo and Bar
which are both loaded by MyClassLoader:


    class Foo {
      static ThreadLocal<Bar> localBar = ...;
    }

    That code has a memory leak. If you get rid of all references to
MyClassLoader, it and all its classes should get GCed, but in this case, we
leak a strong reference:

      Thread -> Bar (localBar's value) -> MyClassLoader (Bar.getClass()) ->
Foo -> localBar

    I also ran into this once when I inadvertently created a circular
reference by using an inner class:
http://crazybob.org/2006/02/threadlocal-memory-leak.html

    Thanks,
    Bob


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071010/2a644c03/attachment.html 

From crazybob at crazybob.org  Tue Oct  9 19:51:16 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Tue, 9 Oct 2007 16:51:16 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEABHJAA.dcholmes@optusnet.com.au>
References: <a74683f90710091612j421dbe50h8bb6994d0122c948@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCKEABHJAA.dcholmes@optusnet.com.au>
Message-ID: <a74683f90710091651v48eedef6kb3d6e8cbe89cb5d2@mail.gmail.com>

I just mean that in most use cases, you only need the thread local value set
for a specific scope. This code will never leak:

try {
  threadLocal.set(...);
  doSomething();
} finally {
  threadLocal.remove();
}

Josh's examples #1 and #3 fall into this category. I actually blogged about
some related patterns awhile back:
http://crazybob.org/2006/07/hard-core-java-threadlocal.html

Josh's example #2 poses a bit of a problem, but I've only ever used this
pattern for DateFormat objects, and DateFormat is loaded by the system
classloader, so memory leaks aren't an issue.

Bob

On 10/9/07, David Holmes <dcholmes at optusnet.com.au> wrote:
>
>  A finally block of what?
>
> David
>
> -----Original Message-----
> *From:* crazyboblee at gmail.com [mailto:crazyboblee at gmail.com]*On Behalf Of
> *Bob Lee
> *Sent:* Wednesday, 10 October 2007 9:13 AM
> *To:* dholmes at ieee.org
> *Cc:* Endre Stolsvik; concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Threadlocals and memory leaks in
> J2EE
>
> That said, the solution is simply to remove() your thread local values in
> a finally block.
>
> Bob
>
> On 10/9/07, Bob Lee < crazybob at crazybob.org> wrote:
> >
> > On 10/9/07, David Holmes <dcholmes at optusnet.com.au> wrote:
> > >
> > > I am missing something here. I don't see how the old way
> > > (per-Variable:
> > > Thread->value) is different, in terms of retention, to the new way
> > > (per-Thread: variable->value). Can you clarify the problem - thanks.
> >
> >
> > David,
> >
> > With the new model, as you know, Thread keeps a weak reference to the
> > ThreadLocal (key) and a strong reference to the value. If the value
> > inadvertently strongly references the ThreadLocal key, the entry will never
> > get cleaned up. A similar situation could arise in the old model if a value
> > strongly referenced the Thread.
> >
> > It's very easy to accidentally create a strong reference between your
> > value and ThreadLocal instance. For example, say we have classes Foo and Bar
> > which are both loaded by MyClassLoader:
> >
> > class Foo {
> >   static ThreadLocal<Bar> localBar = ...;
> > }
> >
> > That code has a memory leak. If you get rid of all references to
> > MyClassLoader, it and all its classes should get GCed, but in this case, we
> > leak a strong reference:
> >
> >   Thread -> Bar (localBar's value) -> MyClassLoader (Bar.getClass()) ->
> > Foo -> localBar
> >
> > I also ran into this once when I inadvertently created a circular
> > reference by using an inner class:
> > http://crazybob.org/2006/02/threadlocal-memory-leak.html
> >
> > Thanks,
> > Bob
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071009/ba6dd351/attachment.html 

From Martin.Buchholz at Sun.COM  Wed Oct 10 00:49:21 2007
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Tue, 09 Oct 2007 21:49:21 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks
Message-ID: <470C59D1.90409@sun.com>

Bob Lee wrote:

>That said, the solution is simply to remove() your thread local values in a
>finally block.

Hmmmm...

Bob has a way of saying things that make me think.

Suppose you wanted to save/restore a ThreadLocal.
Then you only want to remove() if the ThreadLocal had no value
previously.  But how can you tell, given that get() is all you've got?

In Emacs, there is only one thread, and each variable (symbol)
is like a ThreadLocal.  But Emacs has unboundp, makunbound,
and best of all, let, which allows Elisp programmers to forget
that all variables are actually globals.

Emacs is not exactly a paragon of programming virtue, but
can we usefully steal anything from it?

/** Does this ThreadLocal have a current value? */
boolean ThreadLocal.isSet()

/** Saves/Restores this ThreadLocal in this thread */
void ThreadLocal.let(CLOSURE)

/** Saves/Restores all ThreadLocals in this thread */
static void ThreadLocal.let(CLOSURE)

That said, I agree that in many cases calling remove()
in a finally block does exactly what you want.

This message is not an endorsement of any particular CLOSURE proposal.

Martin

From Martin.Buchholz at Sun.COM  Wed Oct 10 01:00:25 2007
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Tue, 09 Oct 2007 22:00:25 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
Message-ID: <470C5C69.3020207@sun.com>

Bob Lee wrote:

>That said, the solution is simply to remove() your thread local values in a
>finally block.

Still trying to digest Bob's sentence.

Some people have been complaining about RRWL's tracking of
read holds using ThreadLocals.

Let's capture that in a test case:

import java.util.concurrent.*;
import java.util.concurrent.locks.*;

public class RRWL {
    public static void main(String[] args) throws Throwable {
	final int threadCount = 1000;
	final ExecutorService es = Executors.newFixedThreadPool(threadCount);
	final ReadWriteLock[] rwls = new ReadWriteLock[1000];
	for (int i = 0; i < rwls.length; i++)
	    rwls[i] = new ReentrantReadWriteLock();
	for (int i = 0; i < threadCount; i++)
	    es.execute(new Runnable() { public void run() {
		for (int j = 0; j < rwls.length; j++) {
		    rwls[j].readLock().lock();
		    rwls[j].readLock().unlock();
		}}});
	es.shutdown();
	es.awaitTermination(1000L, TimeUnit.SECONDS);
    }
}

If you try to run this against JDK7 with a smallish heap,
you'll die with OOME.  Could it be that the solution is simply
to remove() our thread local values at strategic locations?

Let's try:

--- /tmp/geta28897	2007-10-09 21:40:38.100438400 -0700
+++ ReentrantReadWriteLock.java	2007-10-09 20:27:37.677509000 -0700
@@ -387,18 +387,21 @@
                 return false;
             setExclusiveOwnerThread(current);
             return true;
         }

         protected final boolean tryReleaseShared(int unused) {
             HoldCounter rh = cachedHoldCounter;
             Thread current = Thread.currentThread();
             if (rh == null || rh.tid != current.getId())
                 rh = readHolds.get();
-            if (rh.tryDecrement() <= 0)
+	    int prev = rh.tryDecrement();
+	    if (prev == 1) {
+		readHolds.remove();
+		cachedHoldCounter = null;
+	    } else if (prev <= 0)
                 throw new IllegalMonitorStateException();
             for (;;) {
                 int c = getState();
                 int nextc = c - SHARED_UNIT;
                 if (compareAndSetState(c, nextc))
                     return nextc == 0;
             }

Why, that seems to work.  Any reason not to do this?

Martin

From unmesh_joshi at hotmail.com  Wed Oct 10 01:32:46 2007
From: unmesh_joshi at hotmail.com (Unmesh joshi)
Date: Wed, 10 Oct 2007 05:32:46 +0000
Subject: [concurrency-interest] UnitOfWorkLocal or RequestContextLocal
	utilities
In-Reply-To: <mailman.10.1191971562.27887.concurrency-interest@altair.cs.oswego.edu>
References: <mailman.10.1191971562.27887.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <BAY140-W2687C1F506516BDEC10F17EFA60@phx.gbl>


Hi All,
I am starting this discussion to move discussion about ContextLocal abstraction from the issue of memory leak.
 
In discussion about ThreadLocal and Memory Leak, David Holmes pointed out that 
 
  "When "thread" and "context" map nicely in terms of identity and lifetime,   then a ThreadLocal can be used for what is more generally a "context-local"   variable. It is when "thread" and "context" don't map nicely that problems   arise"
 
Robert Martin also blogged about this at http://blog.objectmentor.com/articles/2007/09/04/thread-local-a-convenient-abomination
 
Do you think it will help to have UnitOfWorkLocal or RequestContextLocal utilities supported by frameworks which can encapsulate usage of threads? 
 
Can it be a nice candidate for J2EE concurrency utilities?
 
Thanks
Unmesh
 
 
 
_________________________________________________________________
Get the new Windows Live Messenger!
http://get.live.com/messenger/overview
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071010/bb1cce8e/attachment.html 

From dcholmes at optusnet.com.au  Wed Oct 10 01:38:21 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 10 Oct 2007 15:38:21 +1000
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470C5C69.3020207@sun.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>

Martin,

The change seems functionally correct and will not leak, but will there be
performance concerns? If a thread continually uses a RRWL then this change
will cause it to reinitialize the ThreadLocal on every usage of the RRWL.
That doesn't sound like a good thing.

Cheers,
David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Martin
> Buchholz
> Sent: Wednesday, 10 October 2007 3:00 PM
> To: concurrency-interest; Bob Lee
> Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
>
>
> Bob Lee wrote:
>
> >That said, the solution is simply to remove() your thread local
> values in a
> >finally block.
>
> Still trying to digest Bob's sentence.
>
> Some people have been complaining about RRWL's tracking of
> read holds using ThreadLocals.
>
> Let's capture that in a test case:
>
> import java.util.concurrent.*;
> import java.util.concurrent.locks.*;
>
> public class RRWL {
>     public static void main(String[] args) throws Throwable {
> 	final int threadCount = 1000;
> 	final ExecutorService es =
> Executors.newFixedThreadPool(threadCount);
> 	final ReadWriteLock[] rwls = new ReadWriteLock[1000];
> 	for (int i = 0; i < rwls.length; i++)
> 	    rwls[i] = new ReentrantReadWriteLock();
> 	for (int i = 0; i < threadCount; i++)
> 	    es.execute(new Runnable() { public void run() {
> 		for (int j = 0; j < rwls.length; j++) {
> 		    rwls[j].readLock().lock();
> 		    rwls[j].readLock().unlock();
> 		}}});
> 	es.shutdown();
> 	es.awaitTermination(1000L, TimeUnit.SECONDS);
>     }
> }
>
> If you try to run this against JDK7 with a smallish heap,
> you'll die with OOME.  Could it be that the solution is simply
> to remove() our thread local values at strategic locations?
>
> Let's try:
>
> --- /tmp/geta28897	2007-10-09 21:40:38.100438400 -0700
> +++ ReentrantReadWriteLock.java	2007-10-09 20:27:37.677509000 -0700
> @@ -387,18 +387,21 @@
>                  return false;
>              setExclusiveOwnerThread(current);
>              return true;
>          }
>
>          protected final boolean tryReleaseShared(int unused) {
>              HoldCounter rh = cachedHoldCounter;
>              Thread current = Thread.currentThread();
>              if (rh == null || rh.tid != current.getId())
>                  rh = readHolds.get();
> -            if (rh.tryDecrement() <= 0)
> +	    int prev = rh.tryDecrement();
> +	    if (prev == 1) {
> +		readHolds.remove();
> +		cachedHoldCounter = null;
> +	    } else if (prev <= 0)
>                  throw new IllegalMonitorStateException();
>              for (;;) {
>                  int c = getState();
>                  int nextc = c - SHARED_UNIT;
>                  if (compareAndSetState(c, nextc))
>                      return nextc == 0;
>              }
>
> Why, that seems to work.  Any reason not to do this?
>
> Martin
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From online at stolsvik.com  Wed Oct 10 01:42:36 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Wed, 10 Oct 2007 07:42:36 +0200
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
Message-ID: <470C664C.6020203@Stolsvik.com>

[I sent this answer Tue, 09 Oct 2007 22:46:26 +0200, but for some reason 
it hasn't come through.. Trying again..]

Joe Bowbeer wrote:
> On 10/8/07, David Holmes wrote:
>> The problem - as per the eval of that bug report referenced - is that people
>> use ThreadLocal as a mechanism to implement something that is
>> "context"-local (where "context" can be different things).
> 
> Which leads to the thread-local guy and the thread-pool guy pointing
> their finger at each other...
> 

I don't really agree with this.

The 1.2 implementation was simple and slow, but didn't have this problem
of retaining wholly unused graphs of objects. The new implementation can
be extended to get this feature back. It would then work very "java
like" - as with the notion of Garbage Collection and all that!

People are using ThreadLocal for interesting and appropriate purposes.
This little flaw isn't very problematic in most cases, except
particularly in the situation where new instances of already loaded
classes are created using a new classloader, and then all references to
the old classes and their instances are ditched - except for the strong
reference that Thread keeps to the values of ThreadLocals in the old
class instances. This results in a leak that no one can fix, since you
cannot ask the Thread to ditch their references.

Why not just implement such a fix if possible? That way at least a whole
bunch of webapp developers would be somewhat happier!

Endre.

PS: Do note that the problem manifests itself not only in the classic
reload scenario: e.g. if the startup procedure of your application use
some stuff that is never used afterwards, and this involved some
ThreadLocal stuff (maybe in some third-party library), then those
objects and their classes can not be unloaded, and your application will
have "lost" that bit of memory. It won't leak in the classical sense, as
it won't build up over time, but it is a complete waste nevertheless. If
you now implement some reload sceheme, you're into the leak territory.


From jmanson at cs.umd.edu  Wed Oct 10 01:51:47 2007
From: jmanson at cs.umd.edu (Jeremy Manson)
Date: Tue, 09 Oct 2007 22:51:47 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <BAY140-W41833A2885B97A02947DCCEFA50@phx.gbl>
References: <mailman.4.1191897555.27887.concurrency-interest@altair.cs.oswego.edu>
	<BAY140-W41833A2885B97A02947DCCEFA50@phx.gbl>
Message-ID: <470C6873.4050408@cs.umd.edu>

Unmesh joshi wrote:
> Hi,
>  >>People are using ThreadLocal for things that are not thread-local, in the
>  >>sense of how ThreadLocal was designed. Hence the problems. Changing
>  >>ThreadLocal might help alleviate some of the problems, but to me that's
>  >.somewhat missing the real problem. The applications that reuse threads in
>  >>different contexts should be the ones ensuring the threads are correctly
>  >>"configured", with respect to ThreadLocal, when they switch 
> "contexts". For
>  >>the future we should look at how a ContextLocal variable might be 
> defined.
>  >>Just my 2c.
>  >>
>  >>Cheers,
>  >>David Holmes
> I was reading a blog by Robert Martin at 
> http://blog.objectmentor.com/articles/2007/09/04/thread-local-a-convenient-abomination. 
> Here he states Jim Coplien saying /?An object is an abstraction of 
> function. A thread is an abstraction of schedule.?An object is an 
> abstraction of function. A thread is an abstraction of schedule." and 
> how Unit of Work related variables are often wrongly assigned to 
> ThreadLocal. In coming J2EE concurrency utilities, is there any work 
> going on ContextLocal or UnitOfWorkLocal utilities?/

This is worth some work.  The Context was what we had in mind when we 
added final-field-safe contexts to the JMM.  My next words were, "We 
should let people have ThreadLocals that are local to the 
final-field-safe contexts."  We never did anything about it, though.

					Jeremy

From online at stolsvik.com  Wed Oct 10 01:52:02 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Wed, 10 Oct 2007 07:52:02 +0200
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEABHJAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCGEABHJAA.dcholmes@optusnet.com.au>
Message-ID: <470C6882.3090804@Stolsvik.com>

David Holmes wrote:
> Thanks for the explanation Bob.
>  
> That's a nasty cycle: the WeakRef to the key isn't cleared because of 
> the strong-ref to the key via the value; and the value isn't cleared 
> because the WeakRef to the key isn't cleared. I don't suppose we can 
> point the finger at the GC folk and tell them they should be able to 
> spot this? :) More seriously if the relationship/dependency between the 
> key and value could be captured explicitly (say class 
> WeakReferenceWithValue) then the cycle could be broken.

Lots of mails, but do you read the background info at all?

The links I sent in my _initial_ reply to this thread contains all the 
information you need for this understanding.

Kind regards,
Endre.

From josh at bloch.us  Wed Oct 10 02:04:06 2007
From: josh at bloch.us (Joshua Bloch)
Date: Tue, 9 Oct 2007 23:04:06 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470C5C69.3020207@sun.com>
References: <470C5C69.3020207@sun.com>
Message-ID: <b097ac510710092304r5375e059mfd9c6d00bd29e339@mail.gmail.com>

Martin,

On 10/9/07, Martin Buchholz <Martin.Buchholz at sun.com> wrote:
...

> --- /tmp/geta28897      2007-10-09 21:40:38.100438400 -0700
> +++ ReentrantReadWriteLock.java 2007-10-09 20:27:37.677509000 -0700
> @@ -387,18 +387,21 @@
>                 return false;
>             setExclusiveOwnerThread(current);
>             return true;
>         }
>
>         protected final boolean tryReleaseShared(int unused) {
>             HoldCounter rh = cachedHoldCounter;
>             Thread current = Thread.currentThread();
>             if (rh == null || rh.tid != current.getId())
>                 rh = readHolds.get();
> -            if (rh.tryDecrement() <= 0)
> +           int prev = rh.tryDecrement();
> +           if (prev == 1) {
> +               readHolds.remove();
> +               cachedHoldCounter = null;
> +           } else if (prev <= 0)
>                 throw new IllegalMonitorStateException();
>             for (;;) {
>                 int c = getState();
>                 int nextc = c - SHARED_UNIT;
>                 if (compareAndSetState(c, nextc))
>                     return nextc == 0;
>             }
>
> Why, that seems to work.  Any reason not to do this?


It certainly solves the memory issue.  But it increases the cost of
repeatedly acquiring and releasing a read lock: Each time a thread releases
a read lock (i.e., reduces its hold count to zero) and reacquires it, the
proposed change results in an extra HoldCounter creation.  Is this a
worthwhile tradeoff?  Perhaps. But you could argue that it's aiding a rare
case (high value of # locks * # threads) at the expense of a common case
(few locks, few threads, repeated acquisition / release).

              Josh
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071009/807e6e28/attachment.html 

From dcholmes at optusnet.com.au  Wed Oct 10 02:35:21 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 10 Oct 2007 16:35:21 +1000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <470C6882.3090804@Stolsvik.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEAGHJAA.dcholmes@optusnet.com.au>

Endre Stolsvik writes:
> The links I sent in my _initial_ reply to this thread contains all the 
> information you need for this understanding.

They do indeed - sorry.

David Holmes

From josh at bloch.us  Wed Oct 10 02:43:41 2007
From: josh at bloch.us (Joshua Bloch)
Date: Tue, 9 Oct 2007 23:43:41 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <470C664C.6020203@Stolsvik.com>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
	<470C664C.6020203@Stolsvik.com>
Message-ID: <b097ac510710092343gbd3a2aasdc8b384f5b19a169@mail.gmail.com>

Endre,

On 10/9/07, Endre St?lsvik <online at stolsvik.com> wrote:

> The 1.2 implementation was simple and slow, but didn't have this problem
> of retaining wholly unused graphs of objects.


This is wrong.  The 1.2 implementation (which I wrote) was simple, slow,
massively oversynchronized, and *did* have the potential for retaining
wholly unused graphs of objects.  In this implementation, each ThreadLocal
had a WeakHashMap from Thread to value.  As Bob Lee said
previously  "[unintentional object retention] could arise if a value
strongly referenced the Thread."

It seems the problem you describe is primarily a case of thread pool abuse
by Tomcat.  As I'm fond of saying, a thread pool is like a used car lot.  If
you want a new car/thread, you have to pay for it. If you buy a used
car/thread, it may not be pristine. Apparently Tomcat screwed up in this
regard. (I'm no Tomcat expert; I'm basing this judgment on the information I
was able to glean from reading this thread.)

I do think the notion of generalized context-local variables, with explicit
support for context termination, is reasonable.  People have been talking
about this for some time, and now may be the time to consider it seriously.
While I agree that it would be nice if the system could GC thread-local
values in the case you describe (value strongly reference ThreadLocal), it
is not worth substantially slowing down the facility to rectify this.
Initially ThreadLocal was written to support a small number of thread-local
variables, consistent with common practice in the late '90s (e.g.,
in Pthreads).  But Java programmers made very heavy (perhaps too heavy) use
of ThreadLocal in the intervening years, so we sped it up repeatedly. We
cannot afford to slow it down. Users do not take kindly to severe
performance regressions.

            Josh
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071009/cd2b754c/attachment.html 

From Martin.Buchholz at Sun.COM  Wed Oct 10 03:41:56 2007
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Wed, 10 Oct 2007 00:41:56 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
Message-ID: <470C8244.60001@sun.com>



David Holmes wrote:
> Martin,
> 
> The change seems functionally correct and will not leak, but will there be
> performance concerns? If a thread continually uses a RRWL then this change
> will cause it to reinitialize the ThreadLocal on every usage of the RRWL.
> That doesn't sound like a good thing.

It's true that the change makes code that repeatedly acquires locks
slower.  But not that much slower -- we've been encouraged to
"Just let the GC do its job" -- at least for small objects.

The alternative of leaving permanent uncollectible junk lying about in
the ThreadLocal internal maps is too unpalatable.

Martin

> Cheers,
> David

From online at stolsvik.com  Wed Oct 10 04:09:19 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Wed, 10 Oct 2007 10:09:19 +0200
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <b097ac510710092343gbd3a2aasdc8b384f5b19a169@mail.gmail.com>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
	<470C664C.6020203@Stolsvik.com>
	<b097ac510710092343gbd3a2aasdc8b384f5b19a169@mail.gmail.com>
Message-ID: <470C88AF.6010307@Stolsvik.com>

Joshua Bloch wrote:
> Endre,
> 
> On 10/9/07, *Endre St?lsvik* <online at stolsvik.com 
> <mailto:online at stolsvik.com>> wrote:
> 
>     The 1.2 implementation was simple and slow, but didn't have this problem
>     of retaining wholly unused graphs of objects. 
> 
>  
> This is wrong.  The 1.2 implementation (which I wrote) was simple, slow, 
> massively oversynchronized, and /did/ have the potential for retaining 
> wholly unused graphs of objects.  In this implementation, each 
> ThreadLocal had a WeakHashMap from Thread to value.  As Bob Lee said 
> previously  "[unintentional object retention] could arise if a value 
> strongly referenced the Thread."

Okay, okay, but this obviously doesn't make nearly the same problems for 
folks as the current issue does.

> 
> It seems the problem you describe is primarily a case of thread pool 
> abuse by Tomcat.  As I'm fond of saying, a thread pool is like a used 
> car lot.  If you want a new car/thread, you have to pay for it. If you 
> buy a used car/thread, it may not be pristine. Apparently Tomcat screwed 
> up in this regard. (I'm no Tomcat expert; I'm basing this judgment on 
> the information I was able to glean from reading this thread.)

This is not Tomcat's problem per se. It isn't Tomcat that isn't cleaning 
up after itself. It is the webapp's code. However, as I've tried 
repeatedly to point out (obviously without getting through at all), the 
problem is that the user code (the webapp in question) might not be in a 
position to fix this.

And also, what you and others actually state is that to use ThreadLocals 
in your own code, you must handle them just as preciously as one does 
e.g. SQL Connections, with try-finally:close and all that. This seems 
extremely counter intuitive for "a simple ThreadLocal variable". And the 
particular issue at hand _can_ be fixed.

Google "java memory leak", and count the number of times people have 
ended up with variations of this extremely diffuse and very hard to 
track down bug.. And these are only the people that have lived through 
the experience to tell about it!
   Simply given that Servlets are a very common usage of Java, and that 
Tomcat is a very common Servlet Container, one can deduce that actually 
rather many developers are affected by this problem to some degree, 
merely through Tomcat.

Why not look into it?!

(Of course, as mentioned, Tomcat _could_ easily fix the particular 
problem by making a new Thread pool, ditching all the old threads. But 
the bug affects all such scenarios, not just Tomcat)

> 
> While I agree that it would be nice if the 
> system could GC thread-local values in the case you describe (value 
> strongly reference ThreadLocal), it is not worth substantially slowing 
> down the facility to rectify this.  Initially ThreadLocal was written to 
> support a small number of thread-local variables, consistent with common 
> practice in the late '90s ( e.g., in Pthreads).  But Java programmers 
> made very heavy (perhaps too heavy) use of ThreadLocal in the 
> intervening years, so we sped it up repeatedly. We cannot afford to slow 
> it down. Users do not take kindly to severe performance regressions.

Did you read the links?

Thomas Hawtin argues that his solution don't impose much of a penalty.

Here's a link to Sun's bug database:
   http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6254531

Please also read the "Evaluation" section that first brushed this off 
with "you're insane", then changed tone completely.

I quote "tackline" in a comment: "The performance argument is extremely 
weak, particularly with the patch supplied through the jdk-collaboration 
java.net project. get should run at around the same speed as the 
existing buggy code."

Why don't you at least sit down, check this through, and give a critique 
of this code?

PS: Sorry for sounding so exasperated - I just feel "everyone" are 
dodging the actual issue, and the potential for a solution. If there are 
no way the ThreadLocal can be fixed without a rather significant 
performance hit, then so be it. But at least let the experts look into 
it.. Meaning you!

PPS: Given the problem we are discussion (the particular "reload" 
issue), I would assume that also OSGi applications are affected by this? 
(I haven't gotten into OSGi yet, but from my so far shallow 
understanding, it uses classloaders to a large degree, and allows for 
unloading and reloading and all that..)

PPPS: Don't laugh to hard, but this feature could potentially be made 
system property configurable - one final static boolean could be 
initialized based on some sys prop on ThreadLocal load, and then either 
the larger, GC-able, somewhat slower structure, or the smaller, 
non-GCable, somewhat faster structure was selected?! Given how many 
other things, for example with Java 2D, are configurable this way, it 
wouldn't be _completely_ insane.. IMHO, of course.

PPPPS: Is there any reason that I have to log in to see the archives of 
this list?

Kind regards,
Endre.

From dl at cs.oswego.edu  Wed Oct 10 07:50:50 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 10 Oct 2007 07:50:50 -0400
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <470C664C.6020203@Stolsvik.com>
References: <1191880466.801090.6057.nullmailer@home35>	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
	<470C664C.6020203@Stolsvik.com>
Message-ID: <470CBC9A.3060108@cs.oswego.edu>


As the main author of current ThreadLocal implementation, I figure
I ought to say something. Here are a few somethings...

1. I agree with those who think that the problematic self-referential
usages are programming errors, or at least questionable practices.
But they are widespread, and worse,
their effects hurt people who have no control over their presence.
So something ought to be done to help them.

2. Last I left an exchange with Tom Hawtins about this last year,
it had occurred to me that some improvements to java.lang.ref
classes could lead to way to handle these cases that would have no
net performance loss, and maybe even an improvement.
But I haven't had a chance to pursue this.
I will try to somehow push up the priority of exploring this.

3. Stepping back a little, ThreadLocal is another one of those cases
that shows how hard it is to add a fundamental feature to an existing
language (they were added in 1.2) -- limitations seem to always
somehow show through. Not just in the case at hand, but also for
example that at a lower level, allocations should maintain
address locality among each thread's ThreadLocals. And just as
it is illegal to take the address of a local in Java and make
it accessible to other threads, it ought to be illegal to use
similar constructions to copy ref of a ThreadLocal into a static, etc.

-Doug



From josh at bloch.us  Wed Oct 10 11:40:02 2007
From: josh at bloch.us (Joshua Bloch)
Date: Wed, 10 Oct 2007 08:40:02 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470C8244.60001@sun.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
Message-ID: <b097ac510710100840w62b473eax27e0f5ee263098fb@mail.gmail.com>

Martin,

You may well be right.  But I'd get some performance numbers before doing
this. Paul Tyma did some interesting experiments that demonstrated that
RWLocks are already slower that one would like.  Perhaps Doug has some
clever ideas for making them faster and more GC friendly?

         Josh


On 10/10/07, Martin Buchholz <Martin.Buchholz at sun.com> wrote:
>
>
>
> David Holmes wrote:
> > Martin,
> >
> > The change seems functionally correct and will not leak, but will there
> be
> > performance concerns? If a thread continually uses a RRWL then this
> change
> > will cause it to reinitialize the ThreadLocal on every usage of the
> RRWL.
> > That doesn't sound like a good thing.
>
> It's true that the change makes code that repeatedly acquires locks
> slower.  But not that much slower -- we've been encouraged to
> "Just let the GC do its job" -- at least for small objects.
>
> The alternative of leaving permanent uncollectible junk lying about in
> the ThreadLocal internal maps is too unpalatable.
>
> Martin
>
> > Cheers,
> > David
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071010/e5c00dad/attachment.html 

From online at stolsvik.com  Wed Oct 10 11:38:44 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Wed, 10 Oct 2007 17:38:44 +0200
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <470CBC9A.3060108@cs.oswego.edu>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
	<470C664C.6020203@Stolsvik.com> <470CBC9A.3060108@cs.oswego.edu>
Message-ID: <470CF204.2050401@Stolsvik.com>

Hi!

Doug Lea wrote:
> As the main author of current ThreadLocal implementation, I figure
> I ought to say something. Here are a few somethings...

hehe!

> 
> 1. I agree with those who think that the problematic self-referential
> usages are programming errors, or at least questionable practices.

 > 3. .... And just as
 > it is illegal to take the address of a local in Java and make
 > it accessible to other threads, it ought to be illegal to use
 > similar constructions to copy ref of a ThreadLocal into a static, etc.

I'm a bit puzzled by these statements, as I read them to mean that you 
think ThreadLocals should never be declared in a static field?

I can't get this to rhyme with the javadoc stating "ThreadLocal 
instances are typically private static fields in classes that wish to 
associate state with a thread (e.g., a user ID or Transaction ID)."

A static ThreadLocal is pretty much self-referential right there, aren't 
they?

> But they are widespread, and worse,
> their effects hurt people who have no control over their presence.
> So something ought to be done to help them.
   ...
 > I will try to somehow push up the priority of exploring this.

This sounds really promising!

> 
> 2. Last I left an exchange with Tom Hawtins about this last year,
> it had occurred to me that some improvements to java.lang.ref
> classes could lead to way to handle these cases that would have no
> net performance loss, and maybe even an improvement.

.. and even more promising!

Thanks,
Endre.

From dl at cs.oswego.edu  Wed Oct 10 12:11:10 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 10 Oct 2007 12:11:10 -0400
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <b097ac510710100840w62b473eax27e0f5ee263098fb@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>	<470C8244.60001@sun.com>
	<b097ac510710100840w62b473eax27e0f5ee263098fb@mail.gmail.com>
Message-ID: <470CF99E.6030902@cs.oswego.edu>

Joshua Bloch wrote:
> Martin,
>  
> You may well be right.  But I'd get some performance numbers before 
> doing this. Paul Tyma did some interesting experiments that demonstrated 
> that RWLocks are already slower that one would like.  Perhaps Doug has 
> some clever ideas for making them faster and more GC friendly?

First, mostly as an aside, it is intrinsically impossible to make
any code using RWLocks as fast as a custom currently readable data
structure. The act of obtaining an RWLock itself adds contention.
(Rule of thumb for scalable performance: never write when all you want
to do is read.) That's why we have custom Concurrent* collections
rather than just using RWLocks around other collections.

The original Java5 version of RRWL did not use ThreadLocals but
suffered from a (planned) limitation that was the subject of
our first most-requested enhancement. Without ThreadLocals, you
cannot check read hold counts, so it is possible for
people to make uncaught unbalanced locking errors. We knew
that adding ThreadLocals here would add time/space, but
when trying it out, the damage was small enough (often only
a few percent) to make the judgement call to commit for Java6.
There are a few casualties though: Those few people out
there using millions of RRWLs see much bigger performance hits
than do those using them sporadically. Since "sporadic" is the
best guideline for when to use them, it still seems like the
right decision to include the better error checking and monitoring
support in Java6 versions.

If it came to it though, there are some possible
changes that might improve performance a little.
For example, hardwiring a table in class Thread that could
be used instead of ThreadLocals.
None of them seem very attractive or promising though.
This includes the ThreadLocal.remove idea when count hits zero.
As mentioned, this adds time in a common case for the sake
of possibly saving space in less common cases.

-Doug







From dl at cs.oswego.edu  Wed Oct 10 12:18:19 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 10 Oct 2007 12:18:19 -0400
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <470CF204.2050401@Stolsvik.com>
References: <1191880466.801090.6057.nullmailer@home35>	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>	<470C664C.6020203@Stolsvik.com>
	<470CBC9A.3060108@cs.oswego.edu> <470CF204.2050401@Stolsvik.com>
Message-ID: <470CFB4B.2010009@cs.oswego.edu>


> I'm a bit puzzled by these statements, as I read them to mean that you 
> think ThreadLocals should never be declared in a static field?
> 

No, I mean something like...
   ThreadLocal<Context> localContext = new ThreadLocal<Context>();
   static Context global;
   void f() {
      global = localContext.get(); // leaks per-thread into static
   }

Which hopefully no one ever does. However,
if this were strictly illegal, there is a chance
that underlying GC and other JVM support could be made
noticeably faster, knowing that thread-locals never escape
their threads.

-Doug


From Martin.Buchholz at Sun.COM  Wed Oct 10 12:21:28 2007
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Wed, 10 Oct 2007 09:21:28 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <b097ac510710100840w62b473eax27e0f5ee263098fb@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<b097ac510710100840w62b473eax27e0f5ee263098fb@mail.gmail.com>
Message-ID: <470CFC08.8070108@sun.com>

Here's a quick'n'dirty benchmark that does nothing
but read locking.  Bottom line: there are serious performance
problems on windows-x86, but not solaris-sparc, with
my proposed fix (my "concurrent" workspace).

It's yet another instance of an old problem --
how to schedule occasional global cleanup actions
so that the cleanup does get done,
while amortizing the cost.

-------------------------------------------
import java.util.concurrent.*;
import java.util.concurrent.locks.*;

public class RRWL2 {
    public static void main(String[] args) throws Throwable {
	final int threadCount = 10;
	final ExecutorService es = Executors.newFixedThreadPool(threadCount);
	final ReadWriteLock[] rwls = new ReadWriteLock[100];
	for (int i = 0; i < rwls.length; i++)
	    rwls[i] = new ReentrantReadWriteLock();
	for (int i = 0; i < threadCount; i++)
	    es.execute(new Runnable() { public void run() {
		for (int k = 0; k < 60000; k++) {
		    for (int j = 0; j < rwls.length; j++) {
			rwls[j].readLock().lock();
			rwls[j].readLock().unlock();
		    }}}});
	es.shutdown();
	es.awaitTermination(1000L, TimeUnit.SECONDS);
    }
}
-------------------------------------------

results on solaris-sparc:

 $ for f in -client -server; do for v in 6u3 dolphin concurrent; do echo
$v $f; time jver $v jr $f -XX:-UseVMInterruptibleIO  RRWL2; done; done
6u3 -client
==> javac -source 1.6 -Xlint:all RRWL2.java
==> java -client -XX:-UseVMInterruptibleIO -esa -ea RRWL2
jver $v jr $f -XX:-UseVMInterruptibleIO RRWL2  108.43s user 0.97s system
231% cpu 47.205 total
dolphin -client
==> javac -Xlint:all RRWL2.java
==> java -client -XX:-UseVMInterruptibleIO -esa -ea RRWL2
jver $v jr $f -XX:-UseVMInterruptibleIO RRWL2  80.69s user 0.48s system
190% cpu 42.622 total
concurrent -client
==> javac -Xlint:all RRWL2.java
==> java -client -XX:-UseVMInterruptibleIO -esa -ea RRWL2
jver $v jr $f -XX:-UseVMInterruptibleIO RRWL2  110.03s user 1.25s system
189% cpu 58.857 total
6u3 -server
==> javac -source 1.6 -Xlint:all RRWL2.java
==> java -server -XX:-UseVMInterruptibleIO -esa -ea RRWL2
jver $v jr $f -XX:-UseVMInterruptibleIO RRWL2  70.76s user 0.47s system
186% cpu 38.278 total
dolphin -server
==> javac -Xlint:all RRWL2.java
==> java -server -XX:-UseVMInterruptibleIO -esa -ea RRWL2
jver $v jr $f -XX:-UseVMInterruptibleIO RRWL2  73.54s user 0.49s system
191% cpu 38.657 total
concurrent -server
==> javac -Xlint:all RRWL2.java
==> java -server -XX:-UseVMInterruptibleIO -esa -ea RRWL2
jver $v jr $f -XX:-UseVMInterruptibleIO RRWL2  70.55s user 1.01s system
188% cpu 37.996 total

windows-x86 results:

$ for f in -client -server; do for v in 6u3 dolphin concurrent; do echo
$v $f; time jver $v jr $f -XX:-UseVMInterruptibleIO  RRWL2; done; done
6u3 -client
==> javac -source 1.6 -Xlint:all RRWL2.java
==> java -client -XX:-UseVMInterruptibleIO -esa -ea RRWL2
jver $v jr $f -XX:-UseVMInterruptibleIO RRWL2  0.31s user 0.15s system
3% cpu 13.515 total
dolphin -client
==> javac -Xlint:all RRWL2.java
==> java -client -XX:-UseVMInterruptibleIO -esa -ea RRWL2
jver $v jr $f -XX:-UseVMInterruptibleIO RRWL2  0.28s user 0.11s system
5% cpu 7.102 total
concurrent -client
==> javac -Xlint:all RRWL2.java
==> java -client -XX:-UseVMInterruptibleIO -esa -ea RRWL2
jver $v jr $f -XX:-UseVMInterruptibleIO RRWL2  0.32s user 0.10s system
2% cpu 18.527 total
6u3 -server
==> javac -source 1.6 -Xlint:all RRWL2.java
==> java -server -XX:-UseVMInterruptibleIO -esa -ea RRWL2
jver $v jr $f -XX:-UseVMInterruptibleIO RRWL2  0.28s user 0.15s system
4% cpu 10.126 total
dolphin -server
==> javac -Xlint:all RRWL2.java
==> java -server -XX:-UseVMInterruptibleIO -esa -ea RRWL2
jver $v jr $f -XX:-UseVMInterruptibleIO RRWL2  0.26s user 0.20s system
9% cpu 5.066 total
concurrent -server
==> javac -Xlint:all RRWL2.java
==> java -server -XX:-UseVMInterruptibleIO -esa -ea RRWL2
jver $v jr $f -XX:-UseVMInterruptibleIO RRWL2  0.31s user 0.14s system
2% cpu 15.958 total

Martin

Joshua Bloch wrote:
> Martin,
>  
> You may well be right.  But I'd get some performance numbers before
> doing this. Paul Tyma did some interesting experiments that demonstrated
> that RWLocks are already slower that one would like.  Perhaps Doug has
> some clever ideas for making them faster and more GC friendly?
>  
>          Josh
> 
>  
> On 10/10/07, *Martin Buchholz* <Martin.Buchholz at sun.com
> <mailto:Martin.Buchholz at sun.com>> wrote:
> 
> 
> 
>     David Holmes wrote:
>     > Martin,
>     >
>     > The change seems functionally correct and will not leak, but will
>     there be
>     > performance concerns? If a thread continually uses a RRWL then
>     this change
>     > will cause it to reinitialize the ThreadLocal on every usage of
>     the RRWL.
>     > That doesn't sound like a good thing.
> 
>     It's true that the change makes code that repeatedly acquires locks
>     slower.  But not that much slower -- we've been encouraged to
>     "Just let the GC do its job" -- at least for small objects.
> 
>     The alternative of leaving permanent uncollectible junk lying about in
>     the ThreadLocal internal maps is too unpalatable.
> 
>     Martin
> 
>     > Cheers,
>     > David
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at altair.cs.oswego.edu
>     <mailto:Concurrency-interest at altair.cs.oswego.edu>
>     http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 

From josh at bloch.us  Wed Oct 10 13:08:53 2007
From: josh at bloch.us (Joshua Bloch)
Date: Wed, 10 Oct 2007 10:08:53 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <470C88AF.6010307@Stolsvik.com>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
	<470C664C.6020203@Stolsvik.com>
	<b097ac510710092343gbd3a2aasdc8b384f5b19a169@mail.gmail.com>
	<470C88AF.6010307@Stolsvik.com>
Message-ID: <b097ac510710101008g6d87588et3c2ad07f45015f0@mail.gmail.com>

Endre,

 On 10/10/07, Endre St?lsvik <online at stolsvik.com> wrote
>
> > This is wrong.  The 1.2 implementation (which I wrote) was simple, slow,
> > massively oversynchronized, and did have the potential for retaining
> > wholly unused graphs of objects.
>
> Okay, okay, but this obviously doesn't make nearly the same problems for
> folks as the current issue does.
>

This is not clear.  We have many years of experience with the present
implementation.  If we had as many years experience with the previous
implementation, we'd likely find the problem equally prevalent.  That said,
the previous implementation wasn't even a contender.  It turns thread-local
accesses into concurrency hot spots!  That defeats the whole purpose of the
facility.  The 1.2 implementation really was a stopgap.  It's sole advantage
was that I could write it without modifying the Thread implementation.  As
soon as I had time to replace it with a plausible implementation, I did.
And Doug further improved on that implementation, resulting in a mechanism
where a thread-local access requires only a handful of machine
instructions.  That is as it should be.




>
> This is not Tomcat's problem per se. It isn't Tomcat that isn't cleaning
> up after itself. It is the webapp's code.


>From the proposed solution "make a brand new thread pool when any webapp is
reloaded" I assumed that it was the web app *framework* that was at fault,
and I assumed that the framework was part of Tomcat.  I have no familiarity
with this stack.  At any rate, the fault lies with whomever is creating the
thread pool.  If you provide a thread pool, you'd better make clear your
expectations regarding thread locals.  If you have any doubts as to your
users' abilities to abide by those expectations, you'd better replace the
thread pool at appropriate times.  As I said previously, you can't draw
threads from a pool and expect them to be functionally equivalent to new
threads.  It just doesn't work that way.  A thread pool is a compromise: you
save the cost of thread creation, and wind up with dirty threads.


> And also, what you and others actually state is that to use ThreadLocals
> in your own code, you must handle them just as preciously as one does
> e.g. SQL Connections, with try-finally:close and all that.


This really has little to do with thread locals.  If you have any resource
that goes away when you exit a scope, you have to clean up when you exit
that scope, and that's what try-finally blocks are for.  You have to use
them to close files, too, or you'll leak file descriptors and your program
may crash.  Thread locals are a red herring.



>   Simply given that Servlets are a very common usage of Java, and that
> Tomcat is a very common Servlet Container, one can deduce that actually
> rather many developers are affected by this problem to some degree,
> merely through Tomcat.  (Of course, as mentioned, Tomcat *could* easily
> fix the particular
> problem by making a new Thread pool, ditching all the old threads.)


I think you're admitting that this *is* Tomcat's problem.




>
> Did you read the links?
>
> Thomas Hawtin argues that his solution don't impose much of a penalty


Yes, I skimmed them.  I think Tom is wrong.  Doug concurs, and I trust Doug
in these matters.


Why don't you at least sit down, check this through, and give a critique
> of this code?


Doug has already done that, and he's more qualified to do it than I am.  But
do note that we are sympathetic to this issue, even though we see it as an
abuse of thread locals and thread pools.  If it is possible to rectify the
problem without harming the performance of well behaved applications, I
strongly suspect that we'll do it (where "we" probably amounts to "Doug").

          Regards,

          Josh
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071010/9da8a321/attachment.html 

From rob.griffin at quest.com  Wed Oct 10 18:16:30 2007
From: rob.griffin at quest.com (Rob Griffin)
Date: Thu, 11 Oct 2007 08:16:30 +1000
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470C8244.60001@sun.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
Message-ID: <0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>

How about another solution? Why not provide a method in the Thread for
it to clear the ThreadLocal map? This could be made to be callable only
in the thread itself so that there is no possibility of any other access
to the map. Then a call could be made to this method once a pooled
thread finishes running the task it was assigned.

Regards,

Rob Griffin.


-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Martin
Buchholz
Sent: Wednesday, 10 October 2007 5:42 PM
To: dholmes at ieee.org
Cc: concurrency-interest; Bob Lee
Subject: Re: [concurrency-interest] ReentrantReadWriteLocks and memory
leaks



David Holmes wrote:
> Martin,
> 
> The change seems functionally correct and will not leak, but will
there be
> performance concerns? If a thread continually uses a RRWL then this
change
> will cause it to reinitialize the ThreadLocal on every usage of the
RRWL.
> That doesn't sound like a good thing.

It's true that the change makes code that repeatedly acquires locks
slower.  But not that much slower -- we've been encouraged to
"Just let the GC do its job" -- at least for small objects.

The alternative of leaving permanent uncollectible junk lying about in
the ThreadLocal internal maps is too unpalatable.

Martin

> Cheers,
> David
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest



From josh at bloch.us  Wed Oct 10 18:41:43 2007
From: josh at bloch.us (Joshua Bloch)
Date: Wed, 10 Oct 2007 15:41:43 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
Message-ID: <b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>

Rob,

This is a suggestion that sounds good on the face of it, but is fatally
flawed.  It breaks the encapsulation guarantees provided by Java's access
control model.  This is a sacred trust between the language and its users.
Resetting a thread's thread local variables amounts to a global action with
the potential to destroy invariants in existing code.  The suggestion has
been made many times over the years, and each time it is closed as "will not
fix."

One possibility that *does* work is opt-in thread- (or better yet, context-)
local variables.  By using such a variable you are saying "I know that this
can be cleared by a privileged thread, and I can live with that."  Bob
Lee proposed this, and has code for it.

           Josh



On 10/10/07, Rob Griffin <rob.griffin at quest.com> wrote:
>
> How about another solution? Why not provide a method in the Thread for
> it to clear the ThreadLocal map? This could be made to be callable only
> in the thread itself so that there is no possibility of any other access
> to the map. Then a call could be made to this method once a pooled
> thread finishes running the task it was assigned.
>
> Regards,
>
> Rob Griffin.
>
>
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto: concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Martin
> Buchholz
> Sent: Wednesday, 10 October 2007 5:42 PM
> To: dholmes at ieee.org
> Cc: concurrency-interest; Bob Lee
> Subject: Re: [concurrency-interest] ReentrantReadWriteLocks and memory
> leaks
>
>
>
> David Holmes wrote:
> > Martin,
> >
> > The change seems functionally correct and will not leak, but will
> there be
> > performance concerns? If a thread continually uses a RRWL then this
> change
> > will cause it to reinitialize the ThreadLocal on every usage of the
> RRWL.
> > That doesn't sound like a good thing.
>
> It's true that the change makes code that repeatedly acquires locks
> slower.  But not that much slower -- we've been encouraged to
> "Just let the GC do its job" -- at least for small objects.
>
> The alternative of leaving permanent uncollectible junk lying about in
> the ThreadLocal internal maps is too unpalatable.
>
> Martin
>
> > Cheers,
> > David
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071010/222ed47b/attachment-0001.html 

From peter.jones at sun.com  Wed Oct 10 18:57:31 2007
From: peter.jones at sun.com (Peter Jones)
Date: Wed, 10 Oct 2007 18:57:31 -0400
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <470CBC9A.3060108@cs.oswego.edu>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
	<470C664C.6020203@Stolsvik.com> <470CBC9A.3060108@cs.oswego.edu>
Message-ID: <20071010225730.GA14070@east>

On Wed, Oct 10, 2007 at 07:50:50AM -0400, Doug Lea wrote:
> 
> 2. Last I left an exchange with Tom Hawtins about this last year,
> it had occurred to me that some improvements to java.lang.ref
> classes could lead to way to handle these cases that would have no
> net performance loss, and maybe even an improvement.
> But I haven't had a chance to pursue this.
> I will try to somehow push up the priority of exploring this.

If I understand correctly from skimming this thread, the "leak"
problem described for the current ThreadLocal implementation is a
variant of the general limitation underlying these RFEs:

    http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4429536
    http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6389107

which I believe could be solved with a java.lang.ref enhancement more
or less along these lines:

    http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4630118

I have longed for such a solution to this general limitation countless
times, not when using thread locals but for a variety of data
structures involving reference objects-- but the above RFEs have not
appeared to accumulate much interest, at least judging by SDN votes
and comments (lack thereof).  Adding any additional complexity to such
a fundamental VM/GC interface cannot be undertaken lightly of course,
but it would be delightful if the apparent interest in this
ThreadLocal case led to a more general solution.

-- Peter

From rob.griffin at quest.com  Wed Oct 10 19:45:58 2007
From: rob.griffin at quest.com (Rob Griffin)
Date: Thu, 11 Oct 2007 09:45:58 +1000
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
Message-ID: <0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>

Josh,

 

Yes I see that now. You could provide that guarantee with the existing
classes but only by breaking backwards compatibility by changing the
ThreadLocal get method signature. Give the Thread a 'pooled' state that
pool managers control, setting the state clears the ThreadLocal map.
When threads are taken from the pool for use the state is cleared. Calls
to ThreadLocal.get() throw an exception if the thread is in the pooled
state. 

 

For our system where we have been bitten by failure to remove
ThreadLocal variables I think the answer is not to use them.

 

Regards,

 

Rob Griffin.  

 

________________________________

From: jbloch at gmail.com [mailto:jbloch at gmail.com] On Behalf Of Joshua
Bloch
Sent: Thursday, 11 October 2007 8:42 AM
To: Rob Griffin
Cc: concurrency-interest
Subject: Re: [concurrency-interest] ReentrantReadWriteLocks and memory
leaks

 

Rob,

 

This is a suggestion that sounds good on the face of it, but is fatally
flawed.  It breaks the encapsulation guarantees provided by Java's
access control model.  This is a sacred trust between the language and
its users.  Resetting a thread's thread local variables amounts to a
global action with the potential to destroy invariants in existing code.
The suggestion has been made many times over the years, and each time it
is closed as "will not fix." 

 

One possibility that does work is opt-in thread- (or better yet,
context-) local variables.  By using such a variable you are saying "I
know that this can be cleared by a privileged thread, and I can live
with that."  Bob Lee proposed this, and has code for it. 

 

           Josh



 

On 10/10/07, Rob Griffin <rob.griffin at quest.com > wrote: 

How about another solution? Why not provide a method in the Thread for
it to clear the ThreadLocal map? This could be made to be callable only 
in the thread itself so that there is no possibility of any other access
to the map. Then a call could be made to this method once a pooled
thread finishes running the task it was assigned.

Regards,

Rob Griffin.


-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu 
[mailto: concurrency-interest-bounces at cs.oswego.edu
<mailto:concurrency-interest-bounces at cs.oswego.edu> ] On Behalf Of
Martin
Buchholz 
Sent: Wednesday, 10 October 2007 5:42 PM
To: dholmes at ieee.org
Cc: concurrency-interest; Bob Lee 
Subject: Re: [concurrency-interest] ReentrantReadWriteLocks and memory 
leaks



David Holmes wrote:
> Martin,
>
> The change seems functionally correct and will not leak, but will
there be 
> performance concerns? If a thread continually uses a RRWL then this 
change
> will cause it to reinitialize the ThreadLocal on every usage of the
RRWL.
> That doesn't sound like a good thing. 

It's true that the change makes code that repeatedly acquires locks 
slower.  But not that much slower -- we've been encouraged to
"Just let the GC do its job" -- at least for small objects. 

The alternative of leaving permanent uncollectible junk lying about in 
the ThreadLocal internal maps is too unpalatable.

Martin

> Cheers,
> David
_______________________________________________ 
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest 


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest 

 



-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071011/ad9e657d/attachment.html 

From crazybob at crazybob.org  Wed Oct 10 19:58:26 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Wed, 10 Oct 2007 16:58:26 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
Message-ID: <a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>

It seems to me that the simplest solution here would be for Tomcat et al to
do as Josh recommended and throw away its thread pool when you reload a web
app.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071010/171c804d/attachment.html 

From rob.griffin at quest.com  Wed Oct 10 20:38:24 2007
From: rob.griffin at quest.com (Rob Griffin)
Date: Thu, 11 Oct 2007 10:38:24 +1000
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
Message-ID: <0BAEFFA7AFADFD4497F50DD093687E07067FF55E@melmbxw01.prod.quest.corp>

Yeah, I've just been looking through the Java 6 source and I think the
answer might be not to use thread pooling at all! There are more than 40
classes using ThreadLocal in Java 6 and some never clear the variable/s.
Do you want a SAXImpl reference to be carried around forever just
because one thread did some XSLT once? It seems to be widely used
(misused?) in the XML support classes. 

 

Regards,

 

Rob Griffin.

 

________________________________

From: crazyboblee at gmail.com [mailto:crazyboblee at gmail.com] On Behalf Of
Bob Lee
Sent: Thursday, 11 October 2007 9:58 AM
To: Rob Griffin
Cc: Joshua Bloch; concurrency-interest
Subject: Re: [concurrency-interest] ReentrantReadWriteLocks and memory
leaks

 

It seems to me that the simplest solution here would be for Tomcat et al
to do as Josh recommended and throw away its thread pool when you reload
a web app.

Bob



-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071011/0f8362b7/attachment-0001.html 

From josh at bloch.us  Wed Oct 10 20:59:10 2007
From: josh at bloch.us (Joshua Bloch)
Date: Wed, 10 Oct 2007 17:59:10 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <0BAEFFA7AFADFD4497F50DD093687E07067FF55E@melmbxw01.prod.quest.corp>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF55E@melmbxw01.prod.quest.corp>
Message-ID: <b097ac510710101759h1d07b8c2wa3d3f8535530ec45@mail.gmail.com>

Or better yet, don't use XML;)

On 10/10/07, Rob Griffin <rob.griffin at quest.com> wrote:
>
>  Yeah, I've just been looking through the Java 6 source and I think the
> answer might be not to use thread pooling at all! There are more than 40
> classes using ThreadLocal in Java 6 and some never clear the variable/s. Do
> you want a SAXImpl reference to be carried around forever just because one
> thread did some XSLT once? It seems to be widely used (misused?) in the XML
> support classes.
>
>
>
> Regards,
>
>
>
> Rob Griffin.
>
>
>  ------------------------------
>
> *From:* crazyboblee at gmail.com [mailto:crazyboblee at gmail.com] *On Behalf Of
> *Bob Lee
> *Sent:* Thursday, 11 October 2007 9:58 AM
> *To:* Rob Griffin
> *Cc:* Joshua Bloch; concurrency-interest
> *Subject:* Re: [concurrency-interest] ReentrantReadWriteLocks and memory
> leaks
>
>
>
> It seems to me that the simplest solution here would be for Tomcat et al
> to do as Josh recommended and throw away its thread pool when you reload a
> web app.
>
> Bob
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071010/1d4e76f3/attachment.html 

From Martin.Buchholz at Sun.COM  Wed Oct 10 23:00:03 2007
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Wed, 10 Oct 2007 20:00:03 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <4bc396880710100938i7e853e6bs6edf3f404dddd781@mail.gmail.com>
References: <470C5C69.3020207@sun.com>
	<4bc396880710100938i7e853e6bs6edf3f404dddd781@mail.gmail.com>
Message-ID: <470D91B3.1060505@sun.com>



Bob Lee wrote:
> Is this thread local state really a big deal? 

IIRC, it was cited by someone as the reason not to upgrade to JDK6.

If the lock goes away,
> the thread local state goes away, right? In that sense, the thread
> local state is analogous to having a little more state in the lock
> object itself, and we could look at this change as trading speed for
> idle-time memory. I'd probably be inclined to boost my heap size and
> take the improved performance.

The memory cost is O(n * m),
where n is the number of RRWLs, and m is the number
of Threads which have ever held each lock in read mode.
Not a big deal if either n or m is small.
But I'm still inclined to think of it as a kind of memory leak.
I personally value footprint reduction higher than
other engineers.

Martin

From unmesh_joshi at hotmail.com  Wed Oct 10 23:17:30 2007
From: unmesh_joshi at hotmail.com (Unmesh joshi)
Date: Thu, 11 Oct 2007 03:17:30 +0000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <mailman.1.1192032000.20725.concurrency-interest@altair.cs.oswego.edu>
References: <mailman.1.1192032000.20725.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <BAY140-W6888839050A865866E58FEFA70@phx.gbl>


Hi,
 
I just came across 
http://chasethedevil.blogspot.com/2007/08/original-pattern-servletrequest-in.html
It looks like keeping request context in threadlocals is fairly common practice. GWT and Axis framework are using it.
In the "Context Object" pattern by Douglas Schmidt, passing context implicitly using thread local storage is mentioned as one of the arternatives.(http://www.cs.wustl.edu/~schmidt/PDF/Context-Object-Pattern.pdf)
For a person coming from this background or refering to these resources, it is very obvious to use Context Object pattern and keep it in thread local storage for propogating it across logical layers on the code.
 
Following is the code that I think very reasonable and helpful,
The example code might be likeRequestContextHolder { private static ThreadLocal threadLocal = new ThreadLocal(); public static Map get() {       return (Map)threadLocal.get(); } public static void set(Map context) {         threadLocal.set(context); } public static void clearContext() {      threadLocal.remove(); }}class FrontController {   public void handleReqeuest(HttpRequst request.....) {              Map requestContext = buildRequestContext(request);              RequestContextHolder.set(requestContext);               .....              Response response = handleRequest(request);              processResponse(response);              RequestContextHolder.clearContext();   }}
Thanks,
Unmesh
 
> ----------------------------------------------------------------------> > Message: 1> Date: Tue, 9 Oct 2007 23:43:41 -0700> From: "Joshua Bloch" <josh at bloch.us>> Subject: Re: [concurrency-interest] Threadlocals and memory leaks in> J2EE> To: " Endre St?lsvik " <online at stolsvik.com>> Cc: Joe Bowbeer <joe.bowbeer at gmail.com>, concurrency-interest> <concurrency-interest at cs.oswego.edu>> Message-ID:> <b097ac510710092343gbd3a2aasdc8b384f5b19a169 at mail.gmail.com>> Content-Type: text/plain; charset="iso-8859-1"> > Endre,> > On 10/9/07, Endre St?lsvik <online at stolsvik.com> wrote:> > > The 1.2 implementation was simple and slow, but didn't have this problem> > of retaining wholly unused graphs of objects.> > > This is wrong. The 1.2 implementation (which I wrote) was simple, slow,> massively oversynchronized, and *did* have the potential for retaining> wholly unused graphs of objects. In this implementation, each ThreadLocal> had a WeakHashMap from Thread to value. As Bob Lee said> previously "[unintentional object retention] could arise if a value> strongly referenced the Thread."> > It seems the problem you describe is primarily a case of thread pool abuse> by Tomcat. As I'm fond of saying, a thread pool is like a used car lot. If> you want a new car/thread, you have to pay for it. If you buy a used> car/thread, it may not be pristine. Apparently Tomcat screwed up in this> regard. (I'm no Tomcat expert; I'm basing this judgment on the information I> was able to glean from reading this thread.)> > I do think the notion of generalized context-local variables, with explicit> support for context termination, is reasonable. People have been talking> about this for some time, and now may be the time to consider it seriously.> While I agree that it would be nice if the system could GC thread-local> values in the case you describe (value strongly reference ThreadLocal), it> is not worth substantially slowing down the facility to rectify this.> Initially ThreadLocal was written to support a small number of thread-local> variables, consistent with common practice in the late '90s (e.g.,> in Pthreads). But Java programmers made very heavy (perhaps too heavy) use> of ThreadLocal in the intervening years, so we sped it up repeatedly. We> cannot afford to slow it down. Users do not take kindly to severe> performance regressions.> > Josh
_________________________________________________________________
Check out some new online services at Windows Live Ideas?so new they haven?t even been officially released yet.
http://www.msnspecials.in/windowslive/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071011/0432949b/attachment.html 

From crazybob at crazybob.org  Thu Oct 11 00:17:17 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Wed, 10 Oct 2007 21:17:17 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <BAY140-W6888839050A865866E58FEFA70@phx.gbl>
References: <mailman.1.1192032000.20725.concurrency-interest@altair.cs.oswego.edu>
	<BAY140-W6888839050A865866E58FEFA70@phx.gbl>
Message-ID: <a74683f90710102117l36b200afh74233d162f7cff4b@mail.gmail.com>

You should remove the thread local in a finally block. See
http://crazybob.org/2006/07/hard-core-java-threadlocal.html for examples.

Bob

On 10/10/07, Unmesh joshi <unmesh_joshi at hotmail.com> wrote:
>
> class FrontController {
>
>
>    public void handleReqeuest(HttpRequst request.....) {
>
>               Map requestContext = buildRequestContext(request);
>               RequestContextHolder.set(requestContext);
>                .....
>               Response response = handleRequest(request);
>               processResponse(response);
>
>               RequestContextHolder.clearContext();
>
>    }
>
> }
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071010/f454ff08/attachment.html 

From unmesh_joshi at hotmail.com  Thu Oct 11 00:30:13 2007
From: unmesh_joshi at hotmail.com (Unmesh joshi)
Date: Thu, 11 Oct 2007 04:30:13 +0000
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <a74683f90710102117l36b200afh74233d162f7cff4b@mail.gmail.com>
References: <mailman.1.1192032000.20725.concurrency-interest@altair.cs.oswego.edu>
	<BAY140-W6888839050A865866E58FEFA70@phx.gbl> 
	<a74683f90710102117l36b200afh74233d162f7cff4b@mail.gmail.com>
Message-ID: <BAY140-W21733B38BEBE353568557EFA70@phx.gbl>


Yes I should be using try-finally. Also, if I am using JDK1.4.2, where there is no remove method on threadlocal, threadloca.set(null), should also be Ok right?
Also, When I am not keeping value as object of any class in my web module (Keeping java.util.Map and only objects of string or other java.lang type in there), there is also no danger of having any memory leak on reload.
 
Thanks,
Unmesh


Date: Wed, 10 Oct 2007 21:17:17 -0700From: crazybob at crazybob.orgTo: unmesh_joshi at hotmail.comSubject: Re: [concurrency-interest] Threadlocals and memory leaks in J2EECC: concurrency-interest at cs.oswego.eduYou should remove the thread local in a finally block. See http://crazybob.org/2006/07/hard-core-java-threadlocal.html for examples.BobOn 10/10/07, Unmesh joshi <unmesh_joshi at hotmail.com> wrote: 


class FrontController {   public void handleReqeuest(HttpRequst request.....) {              Map requestContext = buildRequestContext(request);              RequestContextHolder.set (requestContext);               .....              Response response = handleRequest(request);              processResponse(response);              RequestContextHolder.clearContext();   }}
_________________________________________________________________
Check out some new online services at Windows Live Ideas?so new they haven?t even been officially released yet.
http://www.msnspecials.in/windowslive/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071011/a89eb5f8/attachment-0001.html 

From crazybob at crazybob.org  Thu Oct 11 01:20:50 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Wed, 10 Oct 2007 22:20:50 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470D91B3.1060505@sun.com>
References: <470C5C69.3020207@sun.com>
	<4bc396880710100938i7e853e6bs6edf3f404dddd781@mail.gmail.com>
	<470D91B3.1060505@sun.com>
Message-ID: <a74683f90710102220i5e84d5f2v6236195e573e2d98@mail.gmail.com>

On 10/10/07, Martin Buchholz <Martin.Buchholz at sun.com> wrote:
>
> The memory cost is O(n * m),
> where n is the number of RRWLs, and m is the number
> of Threads which have ever held each lock in read mode.


Doh. I was only thinking of O(n), so my analogy to state in the lock object
itself doesn't hold.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071010/05b97e0b/attachment.html 

From online at stolsvik.com  Thu Oct 11 04:28:08 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Thu, 11 Oct 2007 10:28:08 +0200
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
Message-ID: <470DDE98.8060902@Stolsvik.com>

Bob Lee wrote:
> It seems to me that the simplest solution here would be for Tomcat et al 
> to do as Josh recommended and throw away its thread pool when you reload 
> a web app.

As I believe I clearly mentioned in my first post to this Thread, this 
has been suggested to the Tomcat developers, I even think a number of 
times. Check out the Tomcat bugzilla, in particular any WONTFIXes and such.

I find it somewhat strange that this seems morphed into some discussion 
where Tomcat is the primary concern. It isn't, it is merely an example, 
but one that is very common, and has gotten lots of coverage, affects a 
lot of developers, and was on the same note as the OP.

As Rob Griffin points out, and Tom Hawtin describes in the Sun bug 
mentioned a couple of times, even "java itself" have a lot of these 
usages - Martin, Doug and Josh even points out that RRWL does the exact 
same thing: it doesn't "try-finally:remove" the ThreadLocal. One could 
then assume that this is a fairly common usage pattern, even though it, 
according to what I've come to understand from the authors of said 
features, is a clear error.

Rob Griffin said:

 > Yeah, I?ve just been looking through the Java 6 source and I think the
 > answer might be not to use thread pooling at all! There are more than
 > 40 classes using ThreadLocal in Java 6 and some never clear the
 > variable/s. Do you want a SAXImpl reference to be carried around
 > forever just because one thread did some XSLT once? It seems to be
 > widely used (misused?) in the XML support classes.

Exactly!

Here's Tom's list ".. of ThreadLocals, from the Java library itself, 
that would leak if they were loaded by a user class loader.":

( http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6254531 )
---------
com.sun.java.util.jar.pack.Utils.currentInstance
com.sun.jmx.snmp.ThreadContext.localContext
com.sun.org.apache.xml.internal.security.utils.CachedXPathAPIHolder.local
com.sun.org.apache.xml.internal.security.utils.CachedXPathAPIHolder.localDoc
com.sun.sql.QueryObjectGeneratorImpl.perThreadInstance
com.sun.tools.xjc.reader.Ring.instances
com.sun.xml.bind.v2.ClassFactory.tls
com.sun.xml.bind.v2.runtime.Coordinator.activeTable
com.sun.xml.messaging.saaj.util.transform.EfficientStreamingTransformer.effTransformer
com.sun.xml.ws.streaming.SourceReaderFactory.domStreamReader
com.sun.xml.ws.streaming.XMLStreamReaderFactory.fiStreamReader
com.sun.xml.ws.streaming.XMLStreamReaderFactory.xmlStreamReader
com.sun.xml.ws.streaming.XMLStreamWriterFactory.fiStreamWriter
java.util.TimeZone.defaultZoneTL
javax.management.QueryEval.server
sun.rmi.transport.tcp.TCPTransport.threadConnectionHandler
sun.rmi.transport.Transport.currentTransport
sun.security.jca.Providers.ProviderList

ClassFactory.tls is interesting in that it creates a WeakHashMap in 
which it appears that the value will always reference the key.
---------

The point here, Bob, is not Tomcat, but that ThreadLocal has an annoying 
"side feature". Your suggestion of try-finally is "rather" obvious 
(basically, handle a ThreadLocal as you do a Connection), but doesn't 
solve any problems here (please read early emails for reasons why, if 
you care).

I mentioned in some email "what about OSGi" - anyone have any thoughts here?

Thanks,
Endre.


From dl at cs.oswego.edu  Thu Oct 11 07:14:27 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 11 Oct 2007 07:14:27 -0400
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470D91B3.1060505@sun.com>
References: <470C5C69.3020207@sun.com>	<4bc396880710100938i7e853e6bs6edf3f404dddd781@mail.gmail.com>
	<470D91B3.1060505@sun.com>
Message-ID: <470E0593.9030706@cs.oswego.edu>

Martin Buchholz wrote:
> 
> Bob Lee wrote:
>> Is this thread local state really a big deal? 
> 
> IIRC, it was cited by someone as the reason not to upgrade to JDK6.
> 
> If the lock goes away,
>> the thread local state goes away, right? In that sense, the thread
>> local state is analogous to having a little more state in the lock
>> object itself, and we could look at this change as trading speed for
>> idle-time memory. I'd probably be inclined to boost my heap size and
>> take the improved performance.
> 
> The memory cost is O(n * m),
> where n is the number of RRWLs, and m is the number
> of Threads which have ever held each lock in read mode.

Note though that the space for those whose RRWLs have
become unreferenced will be reclaimed (eventually, when
new ThreadLocals are added). Some first-order improvements
in java.lang.ref stuff can speed up that "eventually".

-Doug



From blanshlu at netscape.net  Thu Oct 11 07:28:21 2007
From: blanshlu at netscape.net (Luke Blanshard)
Date: Thu, 11 Oct 2007 06:28:21 -0500
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470DDE98.8060902@Stolsvik.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>	<470C8244.60001@sun.com>	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
	<470DDE98.8060902@Stolsvik.com>
Message-ID: <470E08D5.5080201@netscape.net>

Endre St?lsvik wrote:
> Bob Lee wrote:
>   
>> It seems to me that the simplest solution here would be for Tomcat et al 
>> to do as Josh recommended and throw away its thread pool when you reload 
>> a web app.
>>     
> [...]
> The point here, Bob, is not Tomcat, but that ThreadLocal has an annoying 
> "side feature"...
>   


Doug Lea and (I think) David Holmes have mentioned in passing the only 
real solution to this: beef up the weak-reference facility so that the 
garbage collector can claim WeakHashMap entries where the value has a 
strong reference to the key.

I think all you would need is a new kind of reference that establishes a 
sort of virtual strong reference from the key to the value, in place of 
the current actual strong reference from the map to the value.  This 
way, if the map becomes the only holder of both key and value, they can 
both be claimed.

Call this new kind of reference a ContingentReference.  It takes a 
referent, the value in this case, and another reference object, the weak 
reference to the key in this case.  A contingent reference establishes a 
very weak connection to its referent, but it declares a strong 
connection between the other reference's referent (the key) and its 
referent (the value).

It doesn't seem like this introduces anything really new into the whole 
reference system, so it ought not to complicate the GC all that much.

Luke

From dl at cs.oswego.edu  Thu Oct 11 08:42:53 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 11 Oct 2007 08:42:53 -0400
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470E08D5.5080201@netscape.net>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>	<470C8244.60001@sun.com>	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>	<470DDE98.8060902@Stolsvik.com>
	<470E08D5.5080201@netscape.net>
Message-ID: <470E1A4D.4050201@cs.oswego.edu>

Luke Blanshard wrote:
> 
> Doug Lea and (I think) David Holmes have mentioned in passing the only 
> real solution to this: beef up the weak-reference facility so that the 
> garbage collector can claim WeakHashMap entries where the value has a 
> strong reference to the key.
> 
> I think all you would need is a new kind of reference that establishes a 
> sort of virtual strong reference from the key to the value, in place of 
> the current actual strong reference from the map to the value.  This 
> way, if the map becomes the only holder of both key and value, they can 
> both be claimed.

Yes. The CRs cited in Peter Jones's post include some further variants.

The main challenge here is that none of the GC, VM, or library
folks alone want to deal with the performance and complexity
that any of these solutions entail. Overuse of Weak refs in general
leads to GC slowdowns, poorer GC predictability, and tricky
special-casing inside collectors, and this would only
worsen these problems. A pure library solution (like Tom Hawtin's)
would be unacceptably slow, and in all well-behaved usages, waste
much more space than it saves. And embedding special knowledge of
ThreadLocals in compilers and other VM support would be a massive
undertaking.

So the only way out seems to be to find some sweet spot balancing
across these. This is unlikely to happen immediately, but definitely
worth pursuing.

-Doug

From dl at cs.oswego.edu  Thu Oct 11 09:12:34 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 11 Oct 2007 09:12:34 -0400
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
Message-ID: <470E2142.10001@cs.oswego.edu>

Rob Griffin wrote:
> How about another solution? Why not provide a method in the Thread for
> it to clear the ThreadLocal map? This could be made to be callable only
> in the thread itself so that there is no possibility of any other access
> to the map. Then a call could be made to this method once a pooled
> thread finishes running the task it was assigned.
> 

As Josh and others have mentioned, this is not acceptable in general.
But as a work-around of sorts in light of other prospects, it
would be possible to include such a capability in thread pool
classes (basically just ThreadPoolExecutor) that would clear
out ThreadLocals only for threads known to be in a pool.
For ThreadPoolExecutor, this could be supported within
a variant of afterExecute.

This does nothing to help problems with other existing usages,
and even this could not be incorporated until Java7 (because
it requires some support within ThreadLocal), but might be a good
enough to include unless/until progress is made on other Weak
ref fronts.

-Doug


From online at stolsvik.com  Tue Oct  9 16:46:26 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Tue, 09 Oct 2007 22:46:26 +0200
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
Message-ID: <470BE8A2.8030900@Stolsvik.com>

Joe Bowbeer wrote:
> On 10/8/07, David Holmes wrote:
>> The problem - as per the eval of that bug report referenced - is that people
>> use ThreadLocal as a mechanism to implement something that is
>> "context"-local (where "context" can be different things).
> 
> Which leads to the thread-local guy and the thread-pool guy pointing
> their finger at each other...

I don't really agree with this.

The 1.2 implementation was simple and slow, but didn't have this problem 
of retaining wholly unused graphs of objects. The new implementation can 
be extended to get this feature back. It would then work very "java 
like" - as with the notion of Garbage Collection and all that!

People are using ThreadLocal for interesting and appropriate purposes. 
This little flaw isn't very problematic in most cases, except 
particularly in the situation where new instances of already loaded 
classes are created using a new classloader, and then all references to 
the old classes and their instances are ditched - except for the strong 
reference that Thread keeps to the values of ThreadLocals in the old 
class instances. This results in a leak that no one can fix, since you 
cannot ask the Thread to ditch their references.

Why not just implement such a fix if possible? That way at least a whole 
bunch of webapp developers would be somewhat happier!

Endre.

PS: Do note that the problem manifests itself not only in the classic 
reload scenario: e.g. if the startup procedure of your application use 
some stuff that is never used afterwards, and this involved some 
ThreadLocal stuff (maybe in some third-party library), then those 
objects and their classes can not be unloaded, and your application will 
have "lost" that bit of memory. It won't leak in the classical sense, as 
it won't build up over time, but it is a complete waste nevertheless. If 
you now implement some reload sceheme, you're into the leak territory.

From online at stolsvik.com  Wed Oct 10 04:42:24 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Wed, 10 Oct 2007 10:42:24 +0200
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470C5C69.3020207@sun.com>
References: <470C5C69.3020207@sun.com>
Message-ID: <470C9070.6090908@Stolsvik.com>

> Some people have been complaining about RRWL's tracking of
> read holds using ThreadLocals.

Had RRWL had readLock() /** Returns _a_ read Lock */, you wouldn't have 
had to use ThreadLocal? But you might have ended up with more synching 
within the RRWL itself, between all the instances of Read lock, and the 
one instance of Write lock?

Kind regards,
Endre.

From josh at bloch.us  Thu Oct 11 14:19:56 2007
From: josh at bloch.us (Joshua Bloch)
Date: Thu, 11 Oct 2007 11:19:56 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470DDE98.8060902@Stolsvik.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
	<470DDE98.8060902@Stolsvik.com>
Message-ID: <b097ac510710111119i5ab7ad4eqe0c10f8fcb655c0f@mail.gmail.com>

Endre,


On 10/11/07, Endre St?lsvik <online at stolsvik.com> wrote:
>
> Bob Lee wrote:
> > It seems to me that the simplest solution here would be for Tomcat et al
> > to do as Josh recommended and throw away its thread pool when you reload
> > a web app.
>
> As I believe I clearly mentioned in my first post to this Thread, this
> has been suggested to the Tomcat developers, I even think a number of
> times. Check out the Tomcat bugzilla, in particular any WONTFIXes and
> such.


Someone should take this up with Tomcat, or ASF, if need be.  I'll ask
around.  As Doug says, it's the common programmer who is being hurt, and
that sucks.  We must do our best to fix it, but not by breaking the JDK.

Here's Tom's list ".. of ThreadLocals, from the Java library itself,
> that would leak if they were loaded by a user class loader.":


This is *deeply* confused.  I know of no realistic scenario under which
these classes will be loaded by a user class loader.  They're system classes
and they'll be loaded by the system (bootstrap) class loader.

         Josh
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071011/f1e00e6a/attachment.html 

From carfield at carfield.com.hk  Thu Oct 11 14:29:57 2007
From: carfield at carfield.com.hk (Carfield Yim)
Date: Fri, 12 Oct 2007 02:29:57 +0800
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <470BE8A2.8030900@Stolsvik.com>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
	<470BE8A2.8030900@Stolsvik.com>
Message-ID: <b4503c170710111129y5d247f33wd471508b964bf1c9@mail.gmail.com>

Hi, I am just a developer and not really good at concurrency handling.

The application I currently working on stored all preparedstatement in
a hashmap in order to maximum performance according to
http://download.oracle.com/otn_hosted_doc/timesten/603/TimesTen-Documentation/goodpractices.pdf
.

In order to prevent concurrency issue, we use threadlocal to hold that
map. I am not sure it is a proper usecase for threadlocal. However the
application probably don't hurt by memory problem because it run at a
very powerful machine and will restart everyday and there is not class
reloading.

The question I like to ask is, recently a developer like to using
custom thread scope in spring according to this
http://opensource.atlassian.com/projects/spring/browse/SPR-2581 , I
think this is smart move, but I still like to gather more comment
about using spring thread scope as this link mentioned. Because we
have other place copying similar pattern but not yet move to use
spring, just wonder should we do so.

From crazybob at crazybob.org  Thu Oct 11 14:53:43 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Thu, 11 Oct 2007 11:53:43 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <b4503c170710111129y5d247f33wd471508b964bf1c9@mail.gmail.com>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
	<470BE8A2.8030900@Stolsvik.com>
	<b4503c170710111129y5d247f33wd471508b964bf1c9@mail.gmail.com>
Message-ID: <a74683f90710111153p68c83fe5ref6a6b0bad223520@mail.gmail.com>

On 10/11/07, Carfield Yim <carfield at carfield.com.hk> wrote:
>
> The application I currently working on stored all preparedstatement in
> a hashmap in order to maximum performance according to
>
> http://download.oracle.com/otn_hosted_doc/timesten/603/TimesTen-Documentation/goodpractices.pdf


Do you use a connection pool? From my experience, most connection pools
already cache prepared statements for you (as they should). I also thought
prepared statements could be tied to a given connection, in which case you
would want to make the cache per connection, not per thread.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071011/cd16d666/attachment.html 

From larryr at saturn.sdsu.edu  Thu Oct 11 14:58:44 2007
From: larryr at saturn.sdsu.edu (Larry Riedel)
Date: Thu, 11 Oct 2007 11:58:44 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <b4503c170710111129y5d247f33wd471508b964bf1c9@mail.gmail.com>
Message-ID: <1192129124.859068.1351.nullmailer@home35>


> In order to prevent concurrency issue, we use threadlocal
> to hold that map. [...] recently a developer like to using
> custom thread scope in spring according to this
> http://opensource.atlassian.com/projects/spring/browse/SPR-2581,
> [...] I still like to gather more comment about using spring
> thread scope as this link mentioned.

If I am not going to have more than one Thread handling
a particular Request, or a particular Session, or a
particular Connection, etc, I usually just associate
the object with the Request, Session, Connection, etc,
rather than doing something with ThreadLocal, which to
me seems like a relatively arcane approach (or at least
couples me more to the implementation than I would like).


Larry


From online at stolsvik.com  Wed Oct 10 13:01:15 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Wed, 10 Oct 2007 19:01:15 +0200
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470C5C69.3020207@sun.com>
References: <470C5C69.3020207@sun.com>
Message-ID: <470D055B.4010103@Stolsvik.com>

[I obviously have some problems with my email..]

Martin Buchholz wrote:
> Some people have been complaining about RRWL's tracking of
> read holds using ThreadLocals.

Just out of curiosity: Had RRWL.readLock() been defined ala /** Returns 
_a_ read Lock */, where each Lock only could be used by one Thread at a 
time (like a normal ReentrantLock), you wouldn't have had this problem? 
But you might have ended up with more synching within the RRWL itself, 
between all the instances of Read lock, and the one instance of Write lock?
   I'm just curious why this somewhat magic type of read-Lock was 
chosen, instead of this simpler solution?

Kind regards,
Endre.

From rob.griffin at quest.com  Thu Oct 11 17:15:44 2007
From: rob.griffin at quest.com (Rob Griffin)
Date: Fri, 12 Oct 2007 07:15:44 +1000
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470E2142.10001@cs.oswego.edu>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<470E2142.10001@cs.oswego.edu>
Message-ID: <0BAEFFA7AFADFD4497F50DD093687E07067FF7C4@melmbxw01.prod.quest.corp>

Doug,

Another idea I had was to let threads in the pool terminate after they
reach a certain life time, thread euthanasia if you like. This has zero
impact on ThreadLocal. There is a cost of thread creation but the class
user could choose a life time that best balances that with memory clean
up or choose thread immortality if they like (this would have to be the
default I feel)

Regards,

Rob Griffin.


-----Original Message-----
From: Doug Lea [mailto:dl at cs.oswego.edu] 
Sent: Thursday, 11 October 2007 11:13 PM
To: Rob Griffin
Cc: concurrency-interest
Subject: Re: [concurrency-interest] ReentrantReadWriteLocks and memory
leaks

Rob Griffin wrote:
> How about another solution? Why not provide a method in the Thread for
> it to clear the ThreadLocal map? This could be made to be callable
only
> in the thread itself so that there is no possibility of any other
access
> to the map. Then a call could be made to this method once a pooled
> thread finishes running the task it was assigned.
> 

As Josh and others have mentioned, this is not acceptable in general.
But as a work-around of sorts in light of other prospects, it
would be possible to include such a capability in thread pool
classes (basically just ThreadPoolExecutor) that would clear
out ThreadLocals only for threads known to be in a pool.
For ThreadPoolExecutor, this could be supported within
a variant of afterExecute.

This does nothing to help problems with other existing usages,
and even this could not be incorporated until Java7 (because
it requires some support within ThreadLocal), but might be a good
enough to include unless/until progress is made on other Weak
ref fronts.

-Doug




From crazybob at crazybob.org  Thu Oct 11 17:51:40 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Thu, 11 Oct 2007 14:51:40 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470DDE98.8060902@Stolsvik.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
	<470DDE98.8060902@Stolsvik.com>
Message-ID: <a74683f90710111451y25efc46aqcc436e4cf715373e@mail.gmail.com>

On 10/11/07, Endre St?lsvik <online at stolsvik.com> wrote:
>
> As Rob Griffin points out, and Tom Hawtin describes in the Sun bug
> mentioned a couple of times, even "java itself" have a lot of these
> usages - Martin, Doug and Josh even points out that RRWL does the exact
> same thing: it doesn't "try-finally:remove" the ThreadLocal. One could
> then assume that this is a fairly common usage pattern, even though it,
> according to what I've come to understand from the authors of said
> features, is a clear error.


Ummmmm, none of those usages actually leak, do they? I guess you could argue
that they would leak if the same patterns were used in a different context,
but they're not in a different context, so the point is moot.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071011/c0a7b0bb/attachment-0001.html 

From dcholmes at optusnet.com.au  Thu Oct 11 18:58:46 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 12 Oct 2007 08:58:46 +1000
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <470D055B.4010103@Stolsvik.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEBEHJAA.dcholmes@optusnet.com.au>

Endre Stolsvik writes:
> Just out of curiosity: Had RRWL.readLock() been defined ala /** Returns
> _a_ read Lock */, where each Lock only could be used by one Thread at a
> time (like a normal ReentrantLock), you wouldn't have had this problem?
> ...
>    I'm just curious why this somewhat magic type of read-Lock was
> chosen, instead of this simpler solution?

How does this suggestion solve the leakage problem? The ReadLock itself
becomes the "thread-local". The current code retains a ThreadLocal
representing the per-thread read-count; your solution would seem to retain a
per-thread ReadLock (which would itself hold a count).

And people expect locks to be used by different threads so you'd have to
forward internally if the wrong thread tried to use a given lock.

David Holmes


From rob.griffin at quest.com  Thu Oct 11 19:57:08 2007
From: rob.griffin at quest.com (Rob Griffin)
Date: Fri, 12 Oct 2007 09:57:08 +1000
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <a74683f90710111451y25efc46aqcc436e4cf715373e@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
	<470DDE98.8060902@Stolsvik.com>
	<a74683f90710111451y25efc46aqcc436e4cf715373e@mail.gmail.com>
Message-ID: <0BAEFFA7AFADFD4497F50DD093687E07067FF83E@melmbxw01.prod.quest.corp>

Bob,

 

They sure do. They set the ThreadLocal value and never remove it or null it.

 

In com.sun.org.apache.xalan.internal.xsltc.trax.XSLTCSource the ThreadLocal variable isn't static which completely negates its purpose and compounds the leaks!!

 

In fact I've found quite a few non-static ThreadLocal variables.

 

Regards,

 

Rob Griffin.

 

________________________________

From: crazyboblee at gmail.com [mailto:crazyboblee at gmail.com] On Behalf Of Bob Lee
Sent: Friday, 12 October 2007 7:52 AM
To: Endre St?lsvik
Cc: Rob Griffin; Joshua Bloch; concurrency-interest
Subject: Re: [concurrency-interest] ReentrantReadWriteLocks and memory leaks

 

On 10/11/07, Endre St?lsvik <online at stolsvik.com> wrote:

	As Rob Griffin points out, and Tom Hawtin describes in the Sun bug
	mentioned a couple of times, even "java itself" have a lot of these
	usages - Martin, Doug and Josh even points out that RRWL does the exact 
	same thing: it doesn't "try-finally:remove" the ThreadLocal. One could
	then assume that this is a fairly common usage pattern, even though it,
	according to what I've come to understand from the authors of said 
	features, is a clear error.


Ummmmm, none of those usages actually leak, do they? I guess you could argue that they would leak if the same patterns were used in a different context, but they're not in a different context, so the point is moot. 

Bob

 

 



-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071012/fe3aa928/attachment.html 

From crazybob at crazybob.org  Thu Oct 11 20:09:25 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Thu, 11 Oct 2007 17:09:25 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <0BAEFFA7AFADFD4497F50DD093687E07067FF83E@melmbxw01.prod.quest.corp>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
	<470DDE98.8060902@Stolsvik.com>
	<a74683f90710111451y25efc46aqcc436e4cf715373e@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF83E@melmbxw01.prod.quest.corp>
Message-ID: <a74683f90710111709h2298c9a6v3598ea91454b7bcf@mail.gmail.com>

On 10/11/07, Rob Griffin <rob.griffin at quest.com> wrote:
>
> In com.sun.org.apache.xalan.internal.xsltc.trax.XSLTCSource the
> ThreadLocal variable isn't static which completely negates its purpose and
> compounds the leaks!!
>

Making ThreadLocals static doesn't negate their purpose. Actually, I think
it's better to limit their scope. For example, Guice doesn't use static
thread locals, and as a result you can use multiple injectors from the same
thread with no problems.

I also don't see the leak in XSLTCSource. If the XSLTCSource goes away, the
thread local state goes away.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071011/786bc3c7/attachment.html 

From rob.griffin at quest.com  Thu Oct 11 21:07:37 2007
From: rob.griffin at quest.com (Rob Griffin)
Date: Fri, 12 Oct 2007 11:07:37 +1000
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <a74683f90710111709h2298c9a6v3598ea91454b7bcf@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
	<470DDE98.8060902@Stolsvik.com>
	<a74683f90710111451y25efc46aqcc436e4cf715373e@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF83E@melmbxw01.prod.quest.corp>
	<a74683f90710111709h2298c9a6v3598ea91454b7bcf@mail.gmail.com>
Message-ID: <0BAEFFA7AFADFD4497F50DD093687E07067FF88F@melmbxw01.prod.quest.corp>

Bob,

 

I don't see the point of using non-static ThreadLocal variables. You need the variable instance to be able to retrieve the value, so you may as well use a plain instance variable. No?

I was wrong, XSLTCSource as it is coded doesn't leak because it uses an non-static ThreadLocal but I'm pretty sure the intention was to stash the SAXImpl instance away so that all instances of  XSLTCSource in the one thread shared it. Why else would you use a ThreadLocal? Making it static does cause it to leak because there is always a strong reference to the ThreadLocal instance then. 

 

Regards,

 

Rob Griffin.

________________________________

From: crazyboblee at gmail.com [mailto:crazyboblee at gmail.com] On Behalf Of Bob Lee
Sent: Friday, 12 October 2007 10:09 AM
To: Rob Griffin
Cc: Endre St?lsvik; Joshua Bloch; concurrency-interest
Subject: Re: [concurrency-interest] ReentrantReadWriteLocks and memory leaks

 

On 10/11/07, Rob Griffin <rob.griffin at quest.com> wrote:

	In com.sun.org.apache.xalan.internal.xsltc.trax.XSLTCSource the ThreadLocal variable isn't static which completely negates its purpose and compounds the leaks!!


Making ThreadLocals static doesn't negate their purpose. Actually, I think it's better to limit their scope. For example, Guice doesn't use static thread locals, and as a result you can use multiple injectors from the same thread with no problems. 

I also don't see the leak in XSLTCSource. If the XSLTCSource goes away, the thread local state goes away.

Bob

 



-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071012/c627b21d/attachment.html 

From crazybob at crazybob.org  Thu Oct 11 21:19:16 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Thu, 11 Oct 2007 18:19:16 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <0BAEFFA7AFADFD4497F50DD093687E07067FF88F@melmbxw01.prod.quest.corp>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
	<470DDE98.8060902@Stolsvik.com>
	<a74683f90710111451y25efc46aqcc436e4cf715373e@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF83E@melmbxw01.prod.quest.corp>
	<a74683f90710111709h2298c9a6v3598ea91454b7bcf@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF88F@melmbxw01.prod.quest.corp>
Message-ID: <a74683f90710111819r41ca09bdkfe56d49c5ee8a87f@mail.gmail.com>

On 10/11/07, Rob Griffin <rob.griffin at quest.com> wrote:
>
> I don't see the point of using non-static ThreadLocal variables. You need
> the variable instance to be able to retrieve the value, so you may as well
> use a plain instance variable. No?
>

Sometimes you want a value per thread per instance, not just a value per
thread. Your instance could be shared between multiple threads.

> I was wrong, XSLTCSource as it is coded doesn't leak because it uses an
> non-static ThreadLocal but I'm pretty sure the intention was to stash the
> SAXImpl instance away so that all instances of XSLTCSource in the one thread
> shared it. Why else would you use a ThreadLocal? Making it static does cause
> it to leak because there is always a strong reference to the ThreadLocal
> instance then.
>

But it's not static, and it doesn't leak.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071011/66ae408f/attachment-0001.html 

From gergg at cox.net  Thu Oct 11 21:27:48 2007
From: gergg at cox.net (Gregg Wonderly)
Date: Thu, 11 Oct 2007 20:27:48 -0500
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <0BAEFFA7AFADFD4497F50DD093687E07067FF7C4@melmbxw01.prod.quest.corp>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>	<470C8244.60001@sun.com>	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>	<470E2142.10001@cs.oswego.edu>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF7C4@melmbxw01.prod.quest.corp>
Message-ID: <470ECD94.8080208@cox.net>

Rob Griffin wrote:
> Another idea I had was to let threads in the pool terminate after they
> reach a certain life time, thread euthanasia if you like. This has zero
> impact on ThreadLocal. There is a cost of thread creation but the class
> user could choose a life time that best balances that with memory clean
> up or choose thread immortality if they like (this would have to be the
> default I feel)

I'm not sure if the thread pool executor has been fixed yet, but since was not 
originally protecting against RuntimeException killing threads (and making it 
unfunctional at that because it was not counting down the active thread count on 
thread death), I'd say that anything goes with thread lifetime.

Gregg Wonderly

From rob.griffin at quest.com  Thu Oct 11 21:34:50 2007
From: rob.griffin at quest.com (Rob Griffin)
Date: Fri, 12 Oct 2007 11:34:50 +1000
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <a74683f90710111819r41ca09bdkfe56d49c5ee8a87f@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
	<470DDE98.8060902@Stolsvik.com>
	<a74683f90710111451y25efc46aqcc436e4cf715373e@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF83E@melmbxw01.prod.quest.corp>
	<a74683f90710111709h2298c9a6v3598ea91454b7bcf@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF88F@melmbxw01.prod.quest.corp>
	<a74683f90710111819r41ca09bdkfe56d49c5ee8a87f@mail.gmail.com>
Message-ID: <0BAEFFA7AFADFD4497F50DD093687E07067FF8B5@melmbxw01.prod.quest.corp>

Ok, I get it now. That's not how I've conceived their usage at all.

 

________________________________

From: crazyboblee at gmail.com [mailto:crazyboblee at gmail.com] On Behalf Of
Bob Lee
Sent: Friday, 12 October 2007 11:19 AM
To: Rob Griffin
Cc: concurrency-interest
Subject: Re: [concurrency-interest] ReentrantReadWriteLocks and memory
leaks

 

On 10/11/07, Rob Griffin <rob.griffin at quest.com> wrote:

	I don't see the point of using non-static ThreadLocal variables.
You need the variable instance to be able to retrieve the value, so you
may as well use a plain instance variable. No?


Sometimes you want a value per thread per instance, not just a value per
thread. Your instance could be shared between multiple threads. 

	I was wrong, XSLTCSource as it is coded doesn't leak because it
uses an non-static ThreadLocal but I'm pretty sure the intention was to
stash the SAXImpl instance away so that all instances of XSLTCSource in
the one thread shared it. Why else would you use a ThreadLocal? Making
it static does cause it to leak because there is always a strong
reference to the ThreadLocal instance then.


But it's not static, and it doesn't leak.

Bob

 



-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071012/8491e550/attachment.html 

From crazybob at crazybob.org  Thu Oct 11 21:48:10 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Thu, 11 Oct 2007 18:48:10 -0700
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <0BAEFFA7AFADFD4497F50DD093687E07067FF8B5@melmbxw01.prod.quest.corp>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
	<470DDE98.8060902@Stolsvik.com>
	<a74683f90710111451y25efc46aqcc436e4cf715373e@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF83E@melmbxw01.prod.quest.corp>
	<a74683f90710111709h2298c9a6v3598ea91454b7bcf@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF88F@melmbxw01.prod.quest.corp>
	<a74683f90710111819r41ca09bdkfe56d49c5ee8a87f@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF8B5@melmbxw01.prod.quest.corp>
Message-ID: <a74683f90710111848y2881d24auc3e413e3f0a94fd9@mail.gmail.com>

On 10/11/07, Rob Griffin <rob.griffin at quest.com> wrote:
>
>  Ok, I get it now. That's not how I've conceived their usage at all.
>
You're not alone. Most times you don't want your thread local variable to be
static (not any more than you want any variable to be static at least), but
making it static does make it easier to think about--you have one less scope
dimension to worry about.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071011/02521ea4/attachment.html 

From dcholmes at optusnet.com.au  Thu Oct 11 22:16:37 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 12 Oct 2007 12:16:37 +1000
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <a74683f90710111848y2881d24auc3e413e3f0a94fd9@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEBIHJAA.dcholmes@optusnet.com.au>

Bob,

I'd have to disagree that "*most* times you don't want your thread local to
be static". Unless your ThreadLocal is defined as a local class which
maintains state relevant to the instance that holds the ThreadLocal, then a
per-instance ThreadLocal doesn't buy you anything - and its costs in memory:
an extra field and ThreadLocal instance per instance.

A static ThreadLocal is not "global" in the usual sense because the "value"
of interest is per-thread.

YMMV.

Cheers,
David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Bob Lee
  Sent: Friday, 12 October 2007 11:48 AM
  To: Rob Griffin
  Cc: concurrency-interest
  Subject: Re: [concurrency-interest] ReentrantReadWriteLocks and memory
leaks


  On 10/11/07, Rob Griffin <rob.griffin at quest.com> wrote:
    Ok, I get it now. That's not how I've conceived their usage at all.

  You're not alone. Most times you don't want your thread local variable to
be static (not any more than you want any variable to be static at least),
but making it static does make it easier to think about--you have one less
scope dimension to worry about.

  Bob




-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071012/559bece6/attachment.html 

From hanson.char at gmail.com  Fri Oct 12 03:31:14 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Fri, 12 Oct 2007 00:31:14 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks in J2EE
In-Reply-To: <470BE8A2.8030900@Stolsvik.com>
References: <1191880466.801090.6057.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCMEPFHIAA.dcholmes@optusnet.com.au>
	<31f2a7bd0710091126ua6419d3oe48cba017cf5e4a5@mail.gmail.com>
	<470BE8A2.8030900@Stolsvik.com>
Message-ID: <ca53c8f80710120031p64efb7bcvcee386beb29691ed@mail.gmail.com>

>On 10/9/07, Endre St?lsvik <online at stolsvik.com> wrote:
> ...This results in a leak that no one can fix, since you
> cannot ask the Thread to ditch their references.

Playing devil's advocate, I think you "can" ditch all thread locals
(and hence all the transitive references) of a thread - via
reflection.  Ugly but may work, if the security permits. :)

Hanson Char

    public static void ditchThreadLocals() throws Exception
    {
        Thread t = Thread.currentThread();
        String[] fnames = { "threadLocals", "inheritableThreadLocals" };

        for (String fname : fnames)
        {
            Field fThreadLocals = Thread.class.getDeclaredField(fname);
            fThreadLocals.setAccessible(true);
            fThreadLocals.set(t, null);
        }
    }


From online at stolsvik.com  Fri Oct 12 04:35:27 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Fri, 12 Oct 2007 10:35:27 +0200
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEBEHJAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCKEBEHJAA.dcholmes@optusnet.com.au>
Message-ID: <470F31CF.5080807@Stolsvik.com>

David Holmes wrote:
 >
> How does this suggestion solve the leakage problem?
> The ReadLock itself
> becomes the "thread-local". The current code retains a ThreadLocal
> representing the per-thread read-count; your solution would seem to retain a
> per-thread ReadLock (which would itself hold a count).

Yes - I got things confused. Obviously, creating a set of read locks as 
I suggested would serve an entirely different purpose compared to RRWL, 
as each of the created read locks would serialize thread access to that 
specific context..
   Sorry about that.

Thanks,
Endre.

From online at stolsvik.com  Fri Oct 12 04:59:45 2007
From: online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Fri, 12 Oct 2007 10:59:45 +0200
Subject: [concurrency-interest] ReentrantReadWriteLocks and memory leaks
In-Reply-To: <b097ac510710111119i5ab7ad4eqe0c10f8fcb655c0f@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEAFHJAA.dcholmes@optusnet.com.au>
	<470C8244.60001@sun.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF4B7@melmbxw01.prod.quest.corp>
	<b097ac510710101541g57c8113cq169baeb8a9f462a6@mail.gmail.com>
	<0BAEFFA7AFADFD4497F50DD093687E07067FF511@melmbxw01.prod.quest.corp>
	<a74683f90710101658h2a56c41ev4cf3284d0af9407@mail.gmail.com>
	<470DDE98.8060902@Stolsvik.com>
	<b097ac510710111119i5ab7ad4eqe0c10f8fcb655c0f@mail.gmail.com>
Message-ID: <470F3781.2010408@Stolsvik.com>

Joshua Bloch wrote:
>     Bob Lee wrote:
>      > It seems to me that the simplest solution here would be for
>     Tomcat et al
>      > to do as Josh recommended and throw away its thread pool when you
>     reload
>      > a web app.
> 
>     As I believe I clearly mentioned in my first post to this Thread, this
>     has been suggested to the Tomcat developers, I even think a number of
>     times. Check out the Tomcat bugzilla, in particular any WONTFIXes
>     and such. 
>  
> Someone should take this up with Tomcat, or ASF, if need be.  I'll ask 
> around.  As Doug says, it's the common programmer who is being hurt, and 
> that sucks.  We must do our best to fix it, but not by breaking the JDK.

I've come to understand that this isn't just a problem in the Tomcat 
setting - people have been bitten in other scenarios too..

Of course, don't _break_ the JDK! - but it would be great if it was 
possible to fix it there.

> 
>     Here's Tom's list ".. of ThreadLocals, from the Java library itself,
>     that would leak if they were loaded by a user class loader.": 
>  
> This is /deeply/ confused.  I know of no realistic scenario under which 
> these classes will be loaded by a user class loader.  They're system 
> classes and they'll be loaded by the system (bootstrap) class loader.

I believe it was shown as an example of libraries using ThreadLocals in 
this way. If any of these things were a user loaded library, it would 
have leaked. As long as "java itself" uses a publicly available 
construct in certain ways, one could maybe assume that it was ok to make 
use of the same feature in the same manner in some external library - 
but that would suddenly be programming errors, or at least questionable 
practices.

PS: A Spring wiki page about different memory leaks in java container 
environments:
http://opensource.atlassian.com/confluence/spring/pages/viewpage.action?pageId=2669

Endre.

From unmesh_joshi at hotmail.com  Fri Oct 12 15:21:35 2007
From: unmesh_joshi at hotmail.com (Unmesh joshi)
Date: Fri, 12 Oct 2007 19:21:35 +0000
Subject: [concurrency-interest] Threadlocals and memory leaks
In-Reply-To: <mailman.10.1191971562.27887.concurrency-interest@altair.cs.oswego.edu>
References: <mailman.10.1191971562.27887.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <BAY140-W4504EB0CE1B263BF6DC5CDEFA00@phx.gbl>



Hi Bob,
I got some confusion here. Will we be having a memory leak even if localBar value is getting overwritten on every reload? If on every reload, we are doing
 
localBar.set(new Bar());
 
It should overwrite previous value of localBar and then should not be leaking memory right?
 
Thanks,
Unmesh 
 
>>Message: 8Date: Tue, 9 Oct 2007 16:10:51 -0700From: "Bob Lee" >><crazybob at crazybob.org>Subject: Re: [concurrency-interest] Threadlocals and memory leaks  With the new model, as you know, Thread keeps a weak reference to theThreadLocal (key) and a strong reference to the value. If the valueinadvertently strongly references the ThreadLocal key, the entry will neverget cleaned up. A similar situation could arise in the old model if a valuestrongly referenced the Thread. It's very easy to accidentally create a strong reference between your valueand ThreadLocal instance.
For example, say we have classes Foo and Bar whichare both loaded by MyClassLoader: 
 
class Foo {
     static ThreadLocal<Bar> localBar = ...;
 
} 
That code has a memory leak. If you get rid of all references toMyClassLoader, it and all its classes should get GCed, 
but in this case, weleak a strong reference: Thread -> Bar (localBar's value) -> MyClassLoader (Bar.getClass()) -> Foo-> localBar I also ran into this once when I inadvertently created a circular referenceby using an inner class:http://crazybob.org/2006/02/threadlocal-memory-leak.html 
 
Thanks,Bob
_________________________________________________________________
Check out some new online services at Windows Live Ideas?so new they haven?t even been officially released yet.
http://www.msnspecials.in/windowslive/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071012/7073298e/attachment.html 

From crazybob at crazybob.org  Fri Oct 12 15:26:15 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Fri, 12 Oct 2007 12:26:15 -0700
Subject: [concurrency-interest] Threadlocals and memory leaks
In-Reply-To: <BAY140-W4504EB0CE1B263BF6DC5CDEFA00@phx.gbl>
References: <mailman.10.1191971562.27887.concurrency-interest@altair.cs.oswego.edu>
	<BAY140-W4504EB0CE1B263BF6DC5CDEFA00@phx.gbl>
Message-ID: <a74683f90710121226u217fdee7ieace2cce0c2fb2dc@mail.gmail.com>

On 10/12/07, Unmesh joshi <unmesh_joshi at hotmail.com> wrote:
>
>  Hi Bob,
> I got some confusion here. Will we be having a memory leak even
> if localBar value is getting overwritten on every reload? If on every
> reload, we are doing
>
> localBar.set(new Bar());
>
> It should overwrite previous value of localBar and then should not
> be leaking memory right?
>

If you reload your web application's classes and reuse the same threads, you
will definitely have a leak. You'll have a new Foo class and therefore a new
localBar instance, but the old localBar instance (as well as all of your old
web classes and their static state) will still be there.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071012/5ca0cc8b/attachment.html 

From xRoques at infovista.com  Thu Oct 25 06:04:58 2007
From: xRoques at infovista.com (beca)
Date: Thu, 25 Oct 2007 03:04:58 -0700 (PDT)
Subject: [concurrency-interest]  Fork/Join framework:Question
Message-ID: <13403630.post@talk.nabble.com>


Hi,

I plan to use the Fork/Join framework in order to redesign an application
using a huge number of thread pools.
And most of them or not bounded so, this application may start plenty of
threads.

So my goals is to use the fork/join framework in order to be able to split
the long task in some little tasks.

Unfortunately, these small tasks may execute some IO like:read/write into a
file. read/write into a DB ...

So as I guess that the ForkJoinWorkerThread should not sleep during the
execution of a task: I will have too type of pool. 

A ForkJoinPool executing all the tasks but as soon as a task needs to do an
IO It will create an AsyncAction executing the IO in another pool.

This other pool will be a classic pool ThreadPoolExecutor.

What do you think of that solution ?

Thanks in advance for your answer,

Beca.


-- 
View this message in context: http://www.nabble.com/Fork-Join-framework%3AQuestion-tf4689799.html#a13403630
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.


From tim at peierls.net  Thu Oct 25 11:19:38 2007
From: tim at peierls.net (Tim Peierls)
Date: Thu, 25 Oct 2007 11:19:38 -0400
Subject: [concurrency-interest] Fork/Join framework:Question
In-Reply-To: <13403630.post@talk.nabble.com>
References: <13403630.post@talk.nabble.com>
Message-ID: <63b4e4050710250819p1f0de2ffy95e6bee9fb07529a@mail.gmail.com>

ForkJoinPool is not a general-purpose thread pool. Better to use a
ThreadPoolExecutor (or several) for most of your application, reserving
ForkJoinPool for tasks that perform pure (or nearly pure) computation. As
you've probably seen already, the javadoc for
ForkJoinTask<http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/forkjoin/ForkJoinTask.html>says:

The computation defined in the compute method should not in general perform
> any other form of blocking synchronization, should not perform IO, and
> should be independent of other tasks. Minor breaches of these restrictions,
> for example using shared output streams, may be tolerable in practice, but
> frequent use will result in poor performance, and the potential to
> indefinitely stall if the number of threads not waiting for external
> synchronization becomes exhausted.


The sentence about "minor breaches" is not meant to encourage regular file
or DB I/O in ForkJoinTasks. It's meant to cover things like *occasional*
logging or coarse monitoring, where the risk of blocking is comfortably low.

Using an "AsyncAction" to execute I/O in a separate thread pool is still
potentially a blocking operation. (And how would you handle reads?)

--tim


On 10/25/07, beca <xRoques at infovista.com> wrote:
>
>
> Hi,
>
> I plan to use the Fork/Join framework in order to redesign an application
> using a huge number of thread pools.
> And most of them or not bounded so, this application may start plenty of
> threads.
>
> So my goals is to use the fork/join framework in order to be able to split
> the long task in some little tasks.
>
> Unfortunately, these small tasks may execute some IO like:read/write into
> a
> file. read/write into a DB ...
>
> So as I guess that the ForkJoinWorkerThread should not sleep during the
> execution of a task: I will have too type of pool.
>
> A ForkJoinPool executing all the tasks but as soon as a task needs to do
> an
> IO It will create an AsyncAction executing the IO in another pool.
>
> This other pool will be a classic pool ThreadPoolExecutor.
>
> What do you think of that solution ?
>
> Thanks in advance for your answer,
>
> Beca.
>
>
> --
> View this message in context:
> http://www.nabble.com/Fork-Join-framework%3AQuestion-tf4689799.html#a13403630
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071025/de339ffc/attachment.html 

From kevinb at google.com  Tue Oct 30 13:54:57 2007
From: kevinb at google.com (kevin bourrillion)
Date: Tue, 30 Oct 2007 10:54:57 -0700
Subject: [concurrency-interest] Annotations for declaring thread-safety
	properties of Java elements
Message-ID: <108fcdeb0710301054l3ea5a266g5eeb78ade7091f01@mail.gmail.com>

Hi folks.

I'm interested in cultivating best practices for documenting the
concurrency-related behavior of types, methods, and fields in a very
clear and precise way.  I really like the concept behind the
annotations described in JCIP, but has anyone put any thought and/or
work into fleshing out a more complete set of annotations?

@Immutable, @ThreadSafe and @NotThreadSafe are nice, but can only be
applied to types.  So they can't, for example, make any distinction
between a plain HashSet and a Collections.synchronizedSet() because
both are of type Set.

So I find myself wishing for annotations such as @ReturnsImmutable,
@ReturnsThreadSafe and @ReturnsNotThreadSafe, which could be applied
to a method to describe the properties of whatever object that method
returns.  This annotation could match or strengthen whatever
thread-safety assertion is made by the returned type (weakening the
guarantee would be nonsensical and an analyzer should probably emit a
warning).  Would these be good to have?

Next, consider a method which returns some result based on at least
one mutable parameter. Suppose the method is thread-safe, in that it
won't corrupt the state of any object.  It still feels necessary to
document in some clear way how this method behaves when any of its
parameters are being concurrently modified.  Is it...

- Safe? (will produce a reasonably 'correct' answer according to its spec)
- Unsafe? (might throw an exception, as documented in its
specification, but at least won't return a bad answer)
- Dangerous? (might give corrupted answer; its spec uses the "results
are undefined" weasel words)
- others....?

Is there value in being able to annotate method such as
ConcurrentHashMap.put() as @Atomic, and ConcurrentHashMap.putAll() as
@NotAtomic?  (I'm specifically asking about concurrent atomicity, but
there is the other issue of failure atomicity....)

If you could annotate methods which are allowed to mutate the state of
the instance as @Mutates, would this help in recognizing situations
where it may be safe to assume thread-safety via "effective
immutability"?  What about a method of a mutable type which is based
only on immutable data -- method which will always return the same
value/instance no matter what?  @Fixed?

I'll stop there.  I don't want to propose a slew of annotations just
for the fun of it; I really just want to find what feels like the
right level of precision at which I should annotate my own libraries
like the google collections, so that with tool support our users could
get some really helpful warnings.  I feel like it's quite a challenge
for even strong, intermediate developers to grasp the nuances of
"concurrency stuff", and by having clearly defined and documented
annotations used -- in good taste of course -- we can really help them
out.

Would love to hear ideas from the list.



On 10/23/07, kevin bourrillion <kevinb at google.com> wrote:
> Hello,
>
> I'm undertaking to rigorously document the API of the Google
> Collections Library (Java) to convey its concurrency-related
> guarantees in clear and precise terms.  I'd like to develop a set of
> annotations I can use for this, so that one day, our users can get
> informed by their static analysis tools of any suspicious code they
> write using our API.
>
> Background:  Java Concurrency In Practice.
> -----------------------------------------------------
>
> The idea came first from the book, "Java Concurrency In Practice."  In
> fact, the authors published their annotations in a JAR, which I
> checked in to third_party, before I realized that these only barely
> scratch the surface of what is really needed.  Let me quickly explain
> what these do before I move on to propose what else I think we need.
>
> The three primary JCIP annotations @Immutable, @ThreadSafe and
> @NotThreadSafe can be applied to any type (class, interface or enum).
> The meanings are:
>
>   * @Immutable: Any instance of this type is expected to be immutable.
> (Stateless counts as immutable, and is probably not worth
> distinguishing.)
>
>   * @ThreadSafe: Any instance of this type is expected to be
> thread-safe, but may or may not additionally be immutable.
>
>   * @NotThreadSafe: I assert nothing, but I want you to know that I at
> least thought about it.  (Static analysis tools should always treat
> @NotThreadSafe and the no-annotation case the same -- that is, aside
> from possibly recommending when there is no annotation that one be
> added!)
>
> When these annotations are applied to a *final* class, they take on a
> stronger meaning: they are a claim by the developer that the
> implementation *does* fulfill the criteria, not simply an expression
> that any subtype *should* fulfill them.
>
> Note that a non-instantiable class containing only static members is
> arguably a "type" all; I do not believe that any annotations are
> called for in this case.  The class should be final and have a
> private, do-nothing constructor.
>
> What's the use?
> --------------------
>
> We can already do a few things with only these annotations.  Our
> hypothetical static analyzer should raise a warning for any of the
> following scenarios:
>
>   * A class is marked @NotThreadSafe, or has no thread-safety
> annotation, but at least one supertype of this class is marked either
> @ThreadSafe or @Immutable.
>
>   * A class is marked @ThreadSafe, but at least one supertype is
> marked @Immutable.
>
> In short, a subtype cannot weaken the guarantee of a supertype,
> without producing a warning.  Adding a claim such as @Immutable to a
> type has a cascading effect to all subtypes; they must also add the
> same or stronger claim to avoid a warning.
>
> Then what?
> ------------------
>
> Well... that's it!  That's just about where the usefulness of the JCIP
> annotations runs out (there is also a @GuardedBy annotation, but this
> is used to document implementation, not API).
>
> I'd like to say "now the static analysis tools can warn if an instance
> not known to be thread-safe is published to multiple threads."
> However, this doesn't work; the analyzer has no way of knowing that
> 'new HashSet()' is unsafe while both Collections.synchronizedSet() and
> Collections.unmodifiableSet() are safe, because these all share the
> same type, Set.
>
> The same goes for a public static final field in CONSTANT_CASE; we'd
> like to make sure people don't do this for a mutable object, but we
> really can't.
>
> (I'm sure I'm missing some things that really can be done.)
>
> So now what?
>
> Method annotations
> ---------------------------
>
> To be used for methods with non-void, non-primitive return types:
>
>   * @ReturnsImmutable: Declares that the instance returned by any
> implementation of this method is expected to be immutable.
>
>   * @ReturnsThreadSafe: Declares that the instance returned by any
> implementation of this method is expected to be thread-safe, possibly
> immutable.
>
>   * @ReturnsNotThreadSafe: Declares nothing of the sort, thank you
> very much; don't spread it around.
>
> A method may not weaken the guarantee of a method it implements or
> overrides; only match it or strengthen it.  It also may strengthen any
> guarantee made by the *type* being returned (this is key to resolving
> the problem in the Set example above).  It makes no sense for it to
> claim to weaken the guarantee made by the type, so this should be
> flagged as a warning and fixed to avoid confusion.
>
> Just as the meaning of a type annotation is stronger when applied to a
> final class, the meaning of a method annotation becomes stronger when
> applied to a static method, final method, or method of a final class.
>
>   * @ThreadSafe.  Same annotation as above, but a slightly different
> meaning when applied to a method.  It's easiest to start by
> considering only what this annotation means when applied to a *static*
> method.  It means that the method will perform correctly regardless of
> any concurrent modifications happening to any of its *parameters*.
> Obviously, if all parameters are primitive or of @Immutable types,
> then the method is categorically @ThreadSafe (undecided whether the
> annotation should be used or elided in this case).  However, even one
> non- at Immutable parameter raises the question -- even if the parameter
> type is @ThreadSafe!  A simple example:
>
>   public static Object getLastElement(CopyOnWriteArrayList list) {
>     return list.get(list.size() - 1);
>   }
>
> COWAL is thread-safe, but the method is not.
>
> Considering how @ThreadSafe applies to instance methods is trickier,
> and I'll punt on it for now.
>
>   * @Atomic.  On a write operation, signifies that other threads are
> guaranteed not to observe the object in an intermediate state with
> part of the work of the method completed.  For example,
> ConcurrentHashMap.put(K,V) is atomic because no thread will ever
> observe a partially-created entry, such as one having the key set but
> the value still null.  ConcurrentHashMap.putAll(Map) is not atomic;
> another thread may observe only 42 of the entries having been added.
> [The term 'atomic' also carries implications for behavior in the face
> of an exception; you expect a failed atomic method call to leave the
> data in an untouched state, while a failed non-atomic call may have
> left the data corrupted. I'm not sure whether we want to incorporate
> or steer clear of that meaning for purposes of this annotation.]
>
>   * @Read, @Write. (Or to be precise, @WillNotModifyState and
> @MightModifyState.)  Obviously an @Immutable type may not have @Write
> methods, and a method may not be @Write if the method it overrides or
> implements is @Read.  These could potentially be used to understand
> when it's safe to exploit the "effective immutability" of a factually
> mutable instance; but I'm not sure.
>
> -------------
>
> You know, I've been typing this email all day, so let me just leave it
> at this for now, and see if any discussion comes of it.  dinner time!
>
> thanks for reading.
>
>
>
> --
> Kevin Bourrillion @ Google
> go/javalibraries
> google-collections.googlecode.com
> google-guice.googlecode.com
> jsr-310.dev.java.net
>


-- 
Kevin Bourrillion @ Google
go/javalibraries
google-collections.googlecode.com
google-guice.googlecode.com
jsr-310.dev.java.net

From tim at peierls.net  Tue Oct 30 15:00:41 2007
From: tim at peierls.net (Tim Peierls)
Date: Tue, 30 Oct 2007 15:00:41 -0400
Subject: [concurrency-interest] Annotations for declaring thread-safety
	properties of Java elements
In-Reply-To: <108fcdeb0710301054l3ea5a266g5eeb78ade7091f01@mail.gmail.com>
References: <108fcdeb0710301054l3ea5a266g5eeb78ade7091f01@mail.gmail.com>
Message-ID: <63b4e4050710301200s7b077b2pec6e34758f472164@mail.gmail.com>

Kevin,

The JCiP annotations are deliberately few. We were tempted to try to capture
a more complete semantics, and I vaguely recall that we even sketched out
something along these lines based on Doug Lea's concurrency property
"checklist" <http://gee.cs.oswego.edu/dl/cpj/prop.html>, but our primary
concern was to present a simple enough system that absolutely anyone could
hope to use it, not just motivated and talented library designers such as
yourself.

But that's no excuse, and you still want to document your library. If you
haven't already, take a look at the most recent proposal
<http://groups.csail.mit.edu/pag/jsr308/java-annotation-design.html> from
the ministry for putting things on top of other things (JSR 308). I think it
goes a long way towards answering your needs. For example, imagine that
Immutable were declared as follows:

@Documented
 @Target({TYPE, TYPEREF})  // currently only @Target(TYPE)
@Retention(RUNTIME)
public @interface Immutable {}

Then you have no need of @ReturnsThreadSafe, because you can annotate the
return type directly:

  static <E> @Immutable Set<E> immutableSet() { ... }

The JSR 308 proposal also includes hints about annotations like @ReadOnly,
though its scope does not extend to defining the semantics of these.

The big problem with all of this, of course, is that you can't annotate your
library with it, at least not officially, until Java 7 at the earliest. But
it might help guide you in devising an interim measure that stands a chance
of harmonizing with any later developments.

--tim

On 10/30/07, kevin bourrillion < kevinb at google.com> wrote:
>
> Hi folks.
>
> I'm interested in cultivating best practices for documenting the
> concurrency-related behavior of types, methods, and fields in a very
> clear and precise way.  I really like the concept behind the
> annotations described in JCIP, but has anyone put any thought and/or
> work into fleshing out a more complete set of annotations?
>
> @Immutable, @ThreadSafe and @NotThreadSafe are nice, but can only be
> applied to types.  So they can't, for example, make any distinction
> between a plain HashSet and a Collections.synchronizedSet() because
> both are of type Set.
>
> So I find myself wishing for annotations such as @ReturnsImmutable,
> @ReturnsThreadSafe and @ReturnsNotThreadSafe, which could be applied
> to a method to describe the properties of whatever object that method
> returns.  This annotation could match or strengthen whatever
> thread-safety assertion is made by the returned type (weakening the
> guarantee would be nonsensical and an analyzer should probably emit a
> warning).  Would these be good to have?
>
> Next, consider a method which returns some result based on at least
> one mutable parameter. Suppose the method is thread-safe, in that it
> won't corrupt the state of any object.  It still feels necessary to
> document in some clear way how this method behaves when any of its
> parameters are being concurrently modified.  Is it...
>
> - Safe? (will produce a reasonably 'correct' answer according to its spec)
> - Unsafe? (might throw an exception, as documented in its
> specification, but at least won't return a bad answer)
> - Dangerous? (might give corrupted answer; its spec uses the "results
> are undefined" weasel words)
> - others....?
>
> Is there value in being able to annotate method such as
> ConcurrentHashMap.put() as @Atomic, and ConcurrentHashMap.putAll() as
> @NotAtomic?  (I'm specifically asking about concurrent atomicity, but
> there is the other issue of failure atomicity....)
>
> If you could annotate methods which are allowed to mutate the state of
> the instance as @Mutates, would this help in recognizing situations
> where it may be safe to assume thread-safety via "effective
> immutability"?  What about a method of a mutable type which is based
> only on immutable data -- method which will always return the same
> value/instance no matter what?  @Fixed?
>
> I'll stop there.  I don't want to propose a slew of annotations just
> for the fun of it; I really just want to find what feels like the
> right level of precision at which I should annotate my own libraries
> like the google collections, so that with tool support our users could
> get some really helpful warnings.  I feel like it's quite a challenge
> for even strong, intermediate developers to grasp the nuances of
> "concurrency stuff", and by having clearly defined and documented
> annotations used -- in good taste of course -- we can really help them
> out.
>
> Would love to hear ideas from the list.
>
>
>
> On 10/23/07, kevin bourrillion <kevinb at google.com > wrote:
> > Hello,
> >
> > I'm undertaking to rigorously document the API of the Google
> > Collections Library (Java) to convey its concurrency-related
> > guarantees in clear and precise terms.  I'd like to develop a set of
> > annotations I can use for this, so that one day, our users can get
> > informed by their static analysis tools of any suspicious code they
> > write using our API.
> >
> > Background:  Java Concurrency In Practice.
> > -----------------------------------------------------
> >
> > The idea came first from the book, "Java Concurrency In Practice."  In
> > fact, the authors published their annotations in a JAR, which I
> > checked in to third_party, before I realized that these only barely
> > scratch the surface of what is really needed.  Let me quickly explain
> > what these do before I move on to propose what else I think we need.
> >
> > The three primary JCIP annotations @Immutable, @ThreadSafe and
> > @NotThreadSafe can be applied to any type (class, interface or enum).
> > The meanings are:
> >
> >   * @Immutable: Any instance of this type is expected to be immutable.
> > (Stateless counts as immutable, and is probably not worth
> > distinguishing.)
> >
> >   * @ThreadSafe: Any instance of this type is expected to be
> > thread-safe, but may or may not additionally be immutable.
> >
> >   * @NotThreadSafe: I assert nothing, but I want you to know that I at
> > least thought about it.  (Static analysis tools should always treat
> > @NotThreadSafe and the no-annotation case the same -- that is, aside
> > from possibly recommending when there is no annotation that one be
> > added!)
> >
> > When these annotations are applied to a *final* class, they take on a
> > stronger meaning: they are a claim by the developer that the
> > implementation *does* fulfill the criteria, not simply an expression
> > that any subtype *should* fulfill them.
> >
> > Note that a non-instantiable class containing only static members is
> > arguably a "type" all; I do not believe that any annotations are
> > called for in this case.  The class should be final and have a
> > private, do-nothing constructor.
> >
> > What's the use?
> > --------------------
> >
> > We can already do a few things with only these annotations.  Our
> > hypothetical static analyzer should raise a warning for any of the
> > following scenarios:
> >
> >   * A class is marked @NotThreadSafe, or has no thread-safety
> > annotation, but at least one supertype of this class is marked either
> > @ThreadSafe or @Immutable.
> >
> >   * A class is marked @ThreadSafe, but at least one supertype is
> > marked @Immutable.
> >
> > In short, a subtype cannot weaken the guarantee of a supertype,
> > without producing a warning.  Adding a claim such as @Immutable to a
> > type has a cascading effect to all subtypes; they must also add the
> > same or stronger claim to avoid a warning.
> >
> > Then what?
> > ------------------
> >
> > Well... that's it!  That's just about where the usefulness of the JCIP
> > annotations runs out (there is also a @GuardedBy annotation, but this
> > is used to document implementation, not API).
> >
> > I'd like to say "now the static analysis tools can warn if an instance
> > not known to be thread-safe is published to multiple threads."
> > However, this doesn't work; the analyzer has no way of knowing that
> > 'new HashSet()' is unsafe while both Collections.synchronizedSet () and
> > Collections.unmodifiableSet() are safe, because these all share the
> > same type, Set.
> >
> > The same goes for a public static final field in CONSTANT_CASE; we'd
> > like to make sure people don't do this for a mutable object, but we
> > really can't.
> >
> > (I'm sure I'm missing some things that really can be done.)
> >
> > So now what?
> >
> > Method annotations
> > ---------------------------
> >
> > To be used for methods with non-void, non-primitive return types:
> >
> >   * @ReturnsImmutable: Declares that the instance returned by any
> > implementation of this method is expected to be immutable.
> >
> >   * @ReturnsThreadSafe: Declares that the instance returned by any
> > implementation of this method is expected to be thread-safe, possibly
> > immutable.
> >
> >   * @ReturnsNotThreadSafe: Declares nothing of the sort, thank you
> > very much; don't spread it around.
> >
> > A method may not weaken the guarantee of a method it implements or
> > overrides; only match it or strengthen it.  It also may strengthen any
> > guarantee made by the *type* being returned (this is key to resolving
> > the problem in the Set example above).  It makes no sense for it to
> > claim to weaken the guarantee made by the type, so this should be
> > flagged as a warning and fixed to avoid confusion.
> >
> > Just as the meaning of a type annotation is stronger when applied to a
> > final class, the meaning of a method annotation becomes stronger when
> > applied to a static method, final method, or method of a final class.
> >
> >   * @ThreadSafe.  Same annotation as above, but a slightly different
> > meaning when applied to a method.  It's easiest to start by
> > considering only what this annotation means when applied to a *static*
> > method.  It means that the method will perform correctly regardless of
> > any concurrent modifications happening to any of its *parameters*.
> > Obviously, if all parameters are primitive or of @Immutable types,
> > then the method is categorically @ThreadSafe (undecided whether the
> > annotation should be used or elided in this case).  However, even one
> > non- at Immutable parameter raises the question -- even if the parameter
> > type is @ThreadSafe!  A simple example:
> >
> >   public static Object getLastElement(CopyOnWriteArrayList list) {
> >     return list.get(list.size() - 1);
> >   }
> >
> > COWAL is thread-safe, but the method is not.
> >
> > Considering how @ThreadSafe applies to instance methods is trickier,
> > and I'll punt on it for now.
> >
> >   * @Atomic.  On a write operation, signifies that other threads are
> > guaranteed not to observe the object in an intermediate state with
> > part of the work of the method completed.  For example,
> > ConcurrentHashMap.put(K,V) is atomic because no thread will ever
> > observe a partially-created entry, such as one having the key set but
> > the value still null.   ConcurrentHashMap.putAll(Map) is not atomic;
> > another thread may observe only 42 of the entries having been added.
> > [The term 'atomic' also carries implications for behavior in the face
> > of an exception; you expect a failed atomic method call to leave the
> > data in an untouched state, while a failed non-atomic call may have
> > left the data corrupted. I'm not sure whether we want to incorporate
> > or steer clear of that meaning for purposes of this annotation.]
> >
> >   * @Read, @Write. (Or to be precise, @WillNotModifyState and
> > @MightModifyState.)  Obviously an @Immutable type may not have @Write
> > methods, and a method may not be @Write if the method it overrides or
> > implements is @Read.  These could potentially be used to understand
> > when it's safe to exploit the "effective immutability" of a factually
> > mutable instance; but I'm not sure.
> >
> > -------------
> >
> > You know, I've been typing this email all day, so let me just leave it
> > at this for now, and see if any discussion comes of it.  dinner time!
> >
> > thanks for reading.
> >
> >
> >
> > --
> > Kevin Bourrillion @ Google
> > go/javalibraries
> > google-collections.googlecode.com
> > google-guice.googlecode.com
> > jsr-310.dev.java.net
> >
>
>
> --
> Kevin Bourrillion @ Google
> go/javalibraries
> google-collections.googlecode.com
> google-guice.googlecode.com
> jsr-310.dev.java.net
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071030/57b646b8/attachment-0001.html 

From tim at peierls.net  Tue Oct 30 15:03:00 2007
From: tim at peierls.net (Tim Peierls)
Date: Tue, 30 Oct 2007 15:03:00 -0400
Subject: [concurrency-interest] Annotations for declaring thread-safety
	properties of Java elements
In-Reply-To: <63b4e4050710301200s7b077b2pec6e34758f472164@mail.gmail.com>
References: <108fcdeb0710301054l3ea5a266g5eeb78ade7091f01@mail.gmail.com>
	<63b4e4050710301200s7b077b2pec6e34758f472164@mail.gmail.com>
Message-ID: <63b4e4050710301203n7f7dcb3er486a5f7e8e2873b4@mail.gmail.com>

On 10/30/07, Tim Peierls <tim at peierls.net> wrote:
>
> Then you have no need of @ReturnsThreadSafe,
>

Oops, I meant "Then you have no need of @ReturnsImmutable, ...".

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20071030/7e6d231b/attachment.html 

