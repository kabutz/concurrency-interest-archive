From gergg at cox.net  Tue Mar  1 16:49:35 2005
From: gergg at cox.net (Gregg Wonderly)
Date: Tue Mar  1 16:49:46 2005
Subject: [concurrency-interest] Threads best practices books/sites?
In-Reply-To: <1109541317.6724.19.camel@glowtoy.zipcon.net>
References: <1109541317.6724.19.camel@glowtoy.zipcon.net>
Message-ID: <4224E36F.4090304@cox.net>

Fred McLain wrote:
> Hey all,
> 
> I'm working on a fairly large (~1M LOC) project that far too many
> threads (30+).  We're running into an occasional deadlock situation and
> although I'm fairly competent in the basics (double checked locking,
> groups etc) I'm on the lookout for some books and or sites describing
> best practices for dealing with multi threaded Java applications.  I'm
> also interested in hearing about what tooling you've used to resolve or
> debug deadlocks, Eclipse just doesn't seem to be up to the task.  Most
> of our threading issues have to deal with device interfaces server side.

The best tool I have found is the stack backtrace.  You can see the 
state of all threads and see which locks they have.  The support in 
JDK5.0 makes it possible to do this remotely with Thread class supplied 
methods.

Gregg Wonderly
From dl at cs.oswego.edu  Fri Mar  4 12:16:59 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri Mar  4 12:17:01 2005
Subject: [concurrency-interest]  testcon testing framework
In-Reply-To: <16811.48399.153637.267404@altair.cs.oswego.edu>
References: <41AB82D9.6060103@mathcs.emory.edu>	<20041129234215.15669.qmail@home19.riedel.org>
	<16811.48399.153637.267404@altair.cs.oswego.edu>
Message-ID: <4228980B.4030809@cs.oswego.edu>

Luke Wildman of the University of Queensland (Australia) sent
me links to a project he and his students are doing to semi-automate
some kinds of tests of concurrent components. See
   http://www.itee.uq.edu.au/~testcon/
They even have a paper on applying this to some of the classes
in dl.util.concurrent (not the J2SE5 versions).
   http://www.itee.uq.edu.au/~testcon/_papers/interrupts-apsec2005.pdf

If anyone on this list wants to do something really helpful someday, you
might look into applying them to the J2SE5 java.util.concurrent
versions :-) Probably this would entail some creative work in
figuring out how to deal with new atomics and blocking support.

-Doug
From minnieh at corp.earthlink.net  Fri Mar  4 14:14:50 2005
From: minnieh at corp.earthlink.net (Minnie Haridasa)
Date: Fri Mar  4 14:15:25 2005
Subject: [concurrency-interest] Assigning threads in the Pool to a Thread Group
Message-ID: <000001c520ee$7057ba70$0401000a@sjclap022925>

 

Hi,

Is there a way to assign all the threads running in the Pooled Executor to a
Thread Group.

 

Currently, once I get a Runnable from the FutureTask.setter(.), I wrap it in
a Thread and assign that to thread group.

I would like make use of the UncaughtExceptions of the ThreadGroup to catch
mysterious "death" of my threads if any!!

 

Thank you,

Minnie

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050304/d28558d2/attachment.htm
From jozart at blarg.net  Fri Mar  4 15:12:43 2005
From: jozart at blarg.net (Joe Bowbeer)
Date: Fri Mar  4 15:10:59 2005
Subject: [concurrency-interest] Assigning threads in the Pool to a Thread
	Group
References: <000001c520ee$7057ba70$0401000a@sjclap022925>
Message-ID: <064f01c520f6$86b48bb0$0200a8c0@REPLICANT2>

Minnie Haridasa <minnieh@corp.earthlink.net> writes:
> Is there a way to assign all the threads running in the Pooled Executor
> to a Thread Group?


To specify the group, you should provide your own thread factory.

Look for ThreadFactory params in Executors factory methods and 
ThreadPoolExecutor constructors.


From jozart at blarg.net  Fri Mar  4 15:26:56 2005
From: jozart at blarg.net (Joe Bowbeer)
Date: Fri Mar  4 15:25:06 2005
Subject: [concurrency-interest] Assigning threads in the Pool to a Thread
	Group
Message-ID: <067401c520f8$82f268b0$0200a8c0@REPLICANT2>

I should add that, since you'll be using your own thread factory, you can 
directly handle uncaught exceptions at the thread level by setting your own 
uncaughtExceptionHandler -- rather than relying on handling at the 
threadGroup level.

See Thread.setUncaughtExceptionHandler

----- Original Message ----- 
From: "Joe Bowbeer" <jozart@blarg.net>
To: "Minnie Haridasa" <minnieh@corp.earthlink.net>; 
<concurrency-interest@altair.cs.oswego.edu>
Sent: Friday, March 04, 2005 12:12 PM
Subject: Re: [concurrency-interest] Assigning threads in the Pool to a 
Thread Group


Minnie Haridasa <minnieh@corp.earthlink.net> writes:
> Is there a way to assign all the threads running in the Pooled Executor
> to a Thread Group?


To specify the group, you should provide your own thread factory.

Look for ThreadFactory params in Executors factory methods and
ThreadPoolExecutor constructors.


From minnieh at corp.earthlink.net  Fri Mar  4 15:51:09 2005
From: minnieh at corp.earthlink.net (Minnie Haridasa)
Date: Fri Mar  4 15:51:39 2005
Subject: [concurrency-interest] Assigning threads in the Pool to a Thread
	Group
In-Reply-To: <067401c520f8$82f268b0$0200a8c0@REPLICANT2>
Message-ID: <000301c520fb$e50a3a20$3124500a@sjclap022925>

Thank you for the response.

Yes, I am aware of Thread.setUncaughtExceptionHandler but it is only
available in JDK1.5. We are currently on 1.4.


However, I am a little confused.
I create a Thread from a ThreadFactory implementation, assign a thread group
to it and give it to my PooledExecutor to run it. The threads in the Pool
execute my Thread that I created using ThreadFactory.

The Thread Factory threads belong to a thread group. How can I assume that
threads in the Pool also belong to the same group even though they are
executing the ThreadFactory threads. What thread group do the pooled threads
belong to?

Thank you. 
Minnie


-----Original Message-----
From: Joe Bowbeer [mailto:jozart@blarg.net] 
Sent: Friday, March 04, 2005 12:27 PM
To: Minnie Haridasa; concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest] Assigning threads in the Pool to a
Thread Group

I should add that, since you'll be using your own thread factory, you can 
directly handle uncaught exceptions at the thread level by setting your own 
uncaughtExceptionHandler -- rather than relying on handling at the 
threadGroup level.

See Thread.setUncaughtExceptionHandler

----- Original Message ----- 
From: "Joe Bowbeer" <jozart@blarg.net>
To: "Minnie Haridasa" <minnieh@corp.earthlink.net>; 
<concurrency-interest@altair.cs.oswego.edu>
Sent: Friday, March 04, 2005 12:12 PM
Subject: Re: [concurrency-interest] Assigning threads in the Pool to a 
Thread Group


Minnie Haridasa <minnieh@corp.earthlink.net> writes:
> Is there a way to assign all the threads running in the Pooled Executor
> to a Thread Group?


To specify the group, you should provide your own thread factory.

Look for ThreadFactory params in Executors factory methods and
ThreadPoolExecutor constructors.




From jozart at blarg.net  Fri Mar  4 16:03:20 2005
From: jozart at blarg.net (Joe Bowbeer)
Date: Fri Mar  4 16:01:30 2005
Subject: [concurrency-interest] Assigning threads in the Pool to a
	ThreadGroup
References: <000301c520fb$e50a3a20$3124500a@sjclap022925>
Message-ID: <06ac01c520fd$98b8a6a0$0200a8c0@REPLICANT2>

Minnie,

If you're using 1.4 then you definitely want to use threadGroups.

You provide a threadFactory to the executor so that it will use your factory 
to create its threads.

Then you submit Runnables to the executor, which executes them in its 
threads (created by your factory in the thread group of your choice).


While you can submit a Thread to an executor, it will be executed as a 
Runnable it is, rather than as a thread.  So its threadGroup is irrelevant 
anyway.


----- Original Message ----- 
From: "Minnie Haridasa" <minnieh@corp.earthlink.net>
To: "'Joe Bowbeer'" <jozart@blarg.net>; 
<concurrency-interest@altair.cs.oswego.edu>
Sent: Friday, March 04, 2005 12:51 PM
Subject: RE: [concurrency-interest] Assigning threads in the Pool to a 
ThreadGroup


Thank you for the response.

Yes, I am aware of Thread.setUncaughtExceptionHandler but it is only
available in JDK1.5. We are currently on 1.4.


However, I am a little confused.
I create a Thread from a ThreadFactory implementation, assign a thread group
to it and give it to my PooledExecutor to run it. The threads in the Pool
execute my Thread that I created using ThreadFactory.

The Thread Factory threads belong to a thread group. How can I assume that
threads in the Pool also belong to the same group even though they are
executing the ThreadFactory threads. What thread group do the pooled threads
belong to?

Thank you.
Minnie


-----Original Message-----
From: Joe Bowbeer [mailto:jozart@blarg.net]
Sent: Friday, March 04, 2005 12:27 PM
To: Minnie Haridasa; concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest] Assigning threads in the Pool to a
Thread Group

I should add that, since you'll be using your own thread factory, you can
directly handle uncaught exceptions at the thread level by setting your own
uncaughtExceptionHandler -- rather than relying on handling at the
threadGroup level.

See Thread.setUncaughtExceptionHandler

----- Original Message ----- 
From: "Joe Bowbeer" <jozart@blarg.net>
To: "Minnie Haridasa" <minnieh@corp.earthlink.net>;
<concurrency-interest@altair.cs.oswego.edu>
Sent: Friday, March 04, 2005 12:12 PM
Subject: Re: [concurrency-interest] Assigning threads in the Pool to a
Thread Group


Minnie Haridasa <minnieh@corp.earthlink.net> writes:
> Is there a way to assign all the threads running in the Pooled Executor
> to a Thread Group?


To specify the group, you should provide your own thread factory.

Look for ThreadFactory params in Executors factory methods and
ThreadPoolExecutor constructors.


From dawidk at mathcs.emory.edu  Fri Mar  4 19:58:38 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri Mar  4 19:58:47 2005
Subject: [concurrency-interest] Assigning threads in the Pool to a Thread
	Group
In-Reply-To: <000301c520fb$e50a3a20$3124500a@sjclap022925>
References: <000301c520fb$e50a3a20$3124500a@sjclap022925>
Message-ID: <4229043E.8040209@mathcs.emory.edu>

Minnie Haridasa wrote:

>Thank you for the response.
>
>Yes, I am aware of Thread.setUncaughtExceptionHandler but it is only
>available in JDK1.5. We are currently on 1.4.
>  
>
>However, I am a little confused.
>I create a Thread from a ThreadFactory implementation, assign a thread group
>to it and give it to my PooledExecutor to run it. The threads in the Pool
>execute my Thread that I created using ThreadFactory.
>  
>
Do you mean:

executor.execute(thread)

?

If so, it is a wrong way to do it. You should not pass _threads_ to 
executor; you should pass _tasks_ (runnables). The above only works 
because every thread implements runnable. But the behavior is probably 
different than what you expect: the run() method of your thread in this 
case is NOT executed by your thread; it is executed by some thread from 
the pool. In fact, your thread may not even be started.

What you want to do is to assign the thread factory to the 
PooledExecutor, so that every time when the pool needs to create a new 
thread, it creates it using your factory. You can do this using method 
"setThreadFactory()".

You may also want to take a look at:
http://www.mathcs.emory.edu/dcl/util/backport-util-concurrent/

Default behavior of ThreadPoolExecutor in java.util.concurrent (and the 
backported version) is to create all worker threads in the same thread 
group. See documentation on Executors.defaultThreadFactory() for details.

Regards,
Dawid


From yechielf at gigaspaces.com  Wed Mar  9 09:21:02 2005
From: yechielf at gigaspaces.com (Yechiel Feffer)
Date: Wed Mar  9 08:11:35 2005
Subject: [concurrency-interest] CompareAndSet as an "alternative" to locking
	?
Message-ID: <D166C96F43D1D611B8E3000255A0C48C605EF4@OFFICESRV>

Hi 
I have a question:
Say I have a number of threads (may be a large number) competing over
exclusive access to a   resource. The amount of time that each thread need
to have exclusiveness is very short- (3-4 Java attribute assignment commands
that need to be performed as one LUW).
Is it a  reasonable idea for such pattern to have an AtomicBoolean that will
indicate a gained-lock, setting it to true with CompareAndSet and
resetting it by each thread after its work is finished? Threads that fail to
establish CompareAndSet will retry and after several retries will perform
Thread.Yield() before resuming retries. Can it be more efficient than a lock
? 

Regrds,
Yechiel Fefer    

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050309/8b961839/attachment.htm
From dl at cs.oswego.edu  Wed Mar  9 08:29:23 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed Mar  9 08:29:26 2005
Subject: [concurrency-interest] CompareAndSet as an "alternative" to
	locking ?
In-Reply-To: <D166C96F43D1D611B8E3000255A0C48C605EF4@OFFICESRV>
References: <D166C96F43D1D611B8E3000255A0C48C605EF4@OFFICESRV>
Message-ID: <422EFA33.5000304@cs.oswego.edu>

Yechiel Feffer wrote:
> Hi
> I have a question:
> Say I have a number of threads (may be a large number) competing over  
> exclusive access to a   resource. The amount of time that each thread 
> need to have exclusiveness is very short- (3-4 Java attribute assignment 
> commands that need to be performed as one LUW).
> 
> Is it a  reasonable idea for such pattern to have an AtomicBoolean that 
> will indicate a gained-lock, setting it to true with CompareAndSet and
> 
> resetting it by each thread after its work is finished? Threads that 
> fail to establish CompareAndSet will retry and after several retries 
> will perform Thread.Yield() before resuming retries. Can it be more 
> efficient than a lock ?
> 

This is unlikely to be noticeably faster than using ReentrantLock,
which does pretty much the same thing in its fast paths, but also
knows how to cope if your assumptions are wrong and threads
should block.

If you need to push hard on micro-optimizing this,
you might be able to shave off a few nanoseconds
by instead using a version of the Mutex class code
shown in the AbstractQueuedSynchronizer class docs. (Hmm.
maybe we ought to just include Mutex in Mustang
rather than telling people to do this each time it
comes up.)

-Doug
From Rahul.Joshi at FMR.COM  Thu Mar 10 18:21:46 2005
From: Rahul.Joshi at FMR.COM (Joshi, Rahul)
Date: Thu Mar 10 18:22:00 2005
Subject: [concurrency-interest] LinkedBlockingQueue v/s
	PriorityBlockingQueue - implementation differences
Message-ID: <42BBD772AC30EA428B057864E203C999014F927D@MSGBOSCLF2WIN.DMN1.FMR.COM>

Hi,
I think we understand the functional differences of LinkedBlockingQueue
v/s PriorityBlockingQueue. When we walked through the implementation
code we found that both have a very different concurrency
implementation. Sometimes they confuse us a lot.

I think we do not understand it clearly and need help from someone. Lets
take 'take' method implementation as an example. LinkedBlockingQueue
uses takeGuard_ for synchronization where as PriorityBlockingQueue has
very different implementation using 'ReentrantLock' and 'Condition'.
Both has very different style of implementation.

Why there is a difference between implementation? Are we missing
something here? 

Thanks,
Rahul Joshi


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050310/82b4bd61/attachment.htm
From dholmes at dltech.com.au  Thu Mar 10 18:47:00 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Thu Mar 10 18:47:19 2005
Subject: [concurrency-interest] LinkedBlockingQueue
	v/sPriorityBlockingQueue - implementation differences
In-Reply-To: <42BBD772AC30EA428B057864E203C999014F927D@MSGBOSCLF2WIN.DMN1.FMR.COM>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEFMFHAA.dholmes@dltech.com.au>

LinkedBlockingQueue v/s PriorityBlockingQueue - implementation
differencesRahul,

I don't know what implementation you are looking at but LinkedBlockingQueue
uses ReentrantLock and Condition as well.

The key difference is that LinkedBlockingQueue can use the well known
two-lock algorithm for protecting the head and tail separately, for those
operations known to work on the head or the tail. Thus allowing greater
concurrency of put with take. Any operation not on the head or tail requires
both locks to be held.

In contrast PriorityBlockingQueue is a simple and direct use of a Lock and a
Condition protecting access to an underlying PriorityQueue.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of Joshi, Rahul
  Sent: Friday, 11 March 2005 9:22 AM
  To: concurrency-interest@altair.cs.oswego.edu
  Cc: Olin, Jordan; Kumar,Neeraj
  Subject: [concurrency-interest] LinkedBlockingQueue
v/sPriorityBlockingQueue - implementation differences


  Hi,
  I think we understand the functional differences of LinkedBlockingQueue
v/s PriorityBlockingQueue. When we walked through the implementation code we
found that both have a very different concurrency implementation. Sometimes
they confuse us a lot.

  I think we do not understand it clearly and need help from someone. Lets
take 'take' method implementation as an example. LinkedBlockingQueue uses
takeGuard_ for synchronization where as PriorityBlockingQueue has very
different implementation using 'ReentrantLock' and 'Condition'. Both has
very different style of implementation.

  Why there is a difference between implementation? Are we missing something
here?

  Thanks,
  Rahul Joshi


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050311/96340f09/attachment.htm
From dholmes at dltech.com.au  Thu Mar 10 21:11:14 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Thu Mar 10 21:11:46 2005
Subject: [concurrency-interest] LinkedBlockingQueue
	v/sPriorityBlockingQueue - implementation differences
In-Reply-To: <67DCA285A2D7754280D3B8E88EB548024C9504@MSGBOSCLB2WIN.DMN1.FMR.COM>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEGBFHAA.dholmes@dltech.com.au>

MessageNeeraj,

Where are you getting this source code for LinkedBlockingQueue from? The
code you gave is not what I have (either from the JSR-166 source site, or
the JDK 1.5.0_01 download for windows or linux.) Hmmm I just noticed the
code you gave has no generic type parameters - is this from the backport?

If it is the backport then in the absence of atomics support it probably
uses a different approach - but I know nothing of the details of the
backport.

The real take() looks like:

public E take() throws InterruptedException {
        E x;
        int c = -1;
        final AtomicInteger count = this.count;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lockInterruptibly();
        try {
            try {
                while (count.get() == 0)
                    notEmpty.await();
            } catch (InterruptedException ie) {
                notEmpty.signal(); // propagate to a non-interrupted thread
                throw ie;
            }

            x = extract();
            c = count.getAndDecrement();
            if (c > 1)
                notEmpty.signal();
        } finally {
            takeLock.unlock();
        }
        if (c == capacity)
            signalNotFull();
        return x;
    }

Cheers,
David Holmes
  -----Original Message-----
  From: Kumar, Neeraj [mailto:Neeraj.Kumar@FMR.com]
  Sent: Friday, 11 March 2005 12:03 PM
  To: David Holmes; Joshi, Rahul; concurrency-interest@altair.cs.oswego.edu
  Cc: Olin, Jordan; Kumar, Neeraj
  Subject: RE: [concurrency-interest] LinkedBlockingQueue
v/sPriorityBlockingQueue - implementation differences


  Hi David, Please take a look at these 2 take function . First 'take'
function of LinkedBlockingQueue uses a synchronized block ( on the
takeGuard_ object)  which makes sense but same function in the
PriorityBlockingQueue uses "final ReentrantLock lock = this.lock;" to
achieve the same purpose. Is there any special purpose of using
ReentrantLock in PriorityBlockingQueue class. Please help us in
understanding this.

  Thanks,

  Neeraj Kumar

  This 'take' is from LinkedBlockingQueue

  public Object take() throws InterruptedException {

  if (Thread.interrupted()) throw new InterruptedException();

  Object x = extract();

  if (x != null)

  return x;

  else {

  synchronized (takeGuard_) {

  try {

  for (; ; ) {

  x = extract();

  if (x != null) {

  return x;

  }

  else {

  takeGuard_.wait();

  }

  }

  }

  catch (InterruptedException ex) {

  takeGuard_.notify();

  throw ex;

  }

  }

  }

  }



  And take function for PriorityBlockingQueue is

  public Object take() throws InterruptedException {

  final ReentrantLock lock = this.lock;

  lock.lockInterruptibly();

  try {

  try {

  while (q.size() == 0)

  notEmpty.await();

  } catch (InterruptedException ie) {

  notEmpty.signal(); // propagate to non-interrupted thread

  throw ie;

  }

  Object x = q.poll();

  assert x != null;

  return x;

  } finally {

  lock.unlock();

  }

  }

    -----Original Message-----
    From: David Holmes [mailto:dholmes@dltech.com.au]
    Sent: Thursday, March 10, 2005 6:47 PM
    To: Joshi, Rahul; concurrency-interest@altair.cs.oswego.edu
    Cc: Olin, Jordan; Kumar,Neeraj
    Subject: RE: [concurrency-interest] LinkedBlockingQueue
v/sPriorityBlockingQueue - implementation differences


    Rahul,

    I don't know what implementation you are looking at but
LinkedBlockingQueue uses ReentrantLock and Condition as well.

    The key difference is that LinkedBlockingQueue can use the well known
two-lock algorithm for protecting the head and tail separately, for those
operations known to work on the head or the tail. Thus allowing greater
concurrency of put with take. Any operation not on the head or tail requires
both locks to be held.

    In contrast PriorityBlockingQueue is a simple and direct use of a Lock
and a Condition protecting access to an underlying PriorityQueue.

    David Holmes
      -----Original Message-----
      From: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of Joshi, Rahul
      Sent: Friday, 11 March 2005 9:22 AM
      To: concurrency-interest@altair.cs.oswego.edu
      Cc: Olin, Jordan; Kumar,Neeraj
      Subject: [concurrency-interest] LinkedBlockingQueue
v/sPriorityBlockingQueue - implementation differences


      Hi,
      I think we understand the functional differences of
LinkedBlockingQueue v/s PriorityBlockingQueue. When we walked through the
implementation code we found that both have a very different concurrency
implementation. Sometimes they confuse us a lot.

      I think we do not understand it clearly and need help from someone.
Lets take 'take' method implementation as an example. LinkedBlockingQueue
uses takeGuard_ for synchronization where as PriorityBlockingQueue has very
different implementation using 'ReentrantLock' and 'Condition'. Both has
very different style of implementation.

      Why there is a difference between implementation? Are we missing
something here?

      Thanks,
      Rahul Joshi


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050311/5989b1e8/attachment-0001.htm
From dawidk at mathcs.emory.edu  Fri Mar 11 01:42:06 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri Mar 11 01:42:21 2005
Subject: [concurrency-interest]
	LinkedBlockingQueue	v/sPriorityBlockingQueue
	- implementation differences
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEGBFHAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCAEGBFHAA.dholmes@dltech.com.au>
Message-ID: <42313DBE.7010006@mathcs.emory.edu>

David Holmes wrote:

> Neeraj,
>  
> Where are you getting this source code for LinkedBlockingQueue from? 
> The code you gave is not what I have (either from the JSR-166 source 
> site, or the JDK 1.5.0_01 download for windows or linux.) Hmmm I just 
> noticed the code you gave has no generic type parameters - is this 
> from the backport?
>  
> If it is the backport then in the absence of atomics support it 
> probably uses a different approach - but I know nothing of the details 
> of the backport.
>
I thought I answered this earlier but apparently it didn't worked:

This indeed seems to be from the backport. As David Holmes pointed out, 
Java 1.4 does not natively support atomics; thus, the backported 
LinkedBlockingQueue implementation is based on dl.util.concurrent 1.3.4 
API and not on JSR 166 sources. The backported PriorityBlockingQueue, on 
the other hand, is based on the JSR 166 code. These two APIs were 
written a few years apart, hence the difference in the implementation 
style. (Note though that the algorithms of both LinkedBlockingQueues - 
JSR 166 and backport - are actually similar).

Regards,
Dawid Kurzyniec


From Neeraj.Kumar at FMR.com  Thu Mar 10 21:03:28 2005
From: Neeraj.Kumar at FMR.com (Kumar, Neeraj)
Date: Fri Mar 11 06:05:55 2005
Subject: [concurrency-interest] LinkedBlockingQueue
	v/sPriorityBlockingQueue - implementation differences
Message-ID: <67DCA285A2D7754280D3B8E88EB548024C9504@MSGBOSCLB2WIN.DMN1.FMR.COM>

Hi David, Please take a look at these 2 take function . First 'take'
function of LinkedBlockingQueue uses a synchronized block ( on the
takeGuard_ object)  which makes sense but same function in the
PriorityBlockingQueue uses "final ReentrantLock lock = this.lock;" to
achieve the same purpose. Is there any special purpose of using
ReentrantLock in PriorityBlockingQueue class. Please help us in
understanding this.

Thanks,

Neeraj Kumar

This 'take' is from LinkedBlockingQueue

public Object take() throws InterruptedException {

if (Thread.interrupted()) throw new InterruptedException();

Object x = extract();

if (x != null)

return x;

else {

synchronized (takeGuard_) {

try {

for (; ; ) {

x = extract();

if (x != null) {

return x;

}

else {

takeGuard_.wait();

}

}

}

catch (InterruptedException ex) {

takeGuard_.notify();

throw ex;

}

}

}

}

 

And take function for PriorityBlockingQueue is

public Object take() throws InterruptedException {

final ReentrantLock lock = this.lock;

lock.lockInterruptibly();

try {

try {

while (q.size() == 0)

notEmpty.await();

} catch (InterruptedException ie) {

notEmpty.signal(); // propagate to non-interrupted thread

throw ie;

}

Object x = q.poll();

assert x != null;

return x;

} finally {

lock.unlock();

}

}

	-----Original Message-----
	From: David Holmes [mailto:dholmes@dltech.com.au] 
	Sent: Thursday, March 10, 2005 6:47 PM
	To: Joshi, Rahul; concurrency-interest@altair.cs.oswego.edu
	Cc: Olin, Jordan; Kumar,Neeraj
	Subject: RE: [concurrency-interest] LinkedBlockingQueue
v/sPriorityBlockingQueue - implementation differences
	
	
	Rahul,
	 
	I don't know what implementation you are looking at but
LinkedBlockingQueue uses ReentrantLock and Condition as well. 
	 
	The key difference is that LinkedBlockingQueue can use the well
known two-lock algorithm for protecting the head and tail separately,
for those operations known to work on the head or the tail. Thus
allowing greater concurrency of put with take. Any operation not on the
head or tail requires both locks to be held.
	 
	In contrast PriorityBlockingQueue is a simple and direct use of
a Lock and a Condition protecting access to an underlying PriorityQueue.
	 
	David Holmes

		-----Original Message-----
		From: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of Joshi,
Rahul
		Sent: Friday, 11 March 2005 9:22 AM
		To: concurrency-interest@altair.cs.oswego.edu
		Cc: Olin, Jordan; Kumar,Neeraj
		Subject: [concurrency-interest] LinkedBlockingQueue
v/sPriorityBlockingQueue - implementation differences
		
		

		Hi, 
		I think we understand the functional differences of
LinkedBlockingQueue v/s PriorityBlockingQueue. When we walked through
the implementation code we found that both have a very different
concurrency implementation. Sometimes they confuse us a lot.

		I think we do not understand it clearly and need help
from someone. Lets take 'take' method implementation as an example.
LinkedBlockingQueue uses takeGuard_ for synchronization where as
PriorityBlockingQueue has very different implementation using
'ReentrantLock' and 'Condition'. Both has very different style of
implementation.

		Why there is a difference between implementation? Are we
missing something here? 

		Thanks, 
		Rahul Joshi 


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050310/1eeaea40/attachment.htm
From Shailender.Bathula at airnz.co.nz  Sun Mar 13 16:25:37 2005
From: Shailender.Bathula at airnz.co.nz (Bathula, Shailender)
Date: Sun Mar 13 16:26:01 2005
Subject: [concurrency-interest] dl.util.concurrent v1.3.4, PooledExecu
	tor, LinkedQueue, shutdownN ow and hangup
Message-ID: <C455FDCD31B75E4F88A8B37435A01C8ED3C1F4@aklex017.corp.ad.airnz.co.nz>

Thanks for your response.

The problem described did not occur when we ran the test case using
backport-util-concurrent-1.1 and we ended up using that. Our code has been
through testing and is in production now. At the moment we are forced to use
LinuxThreads as v5.1  of WebSphere we are using does not support NPTL even
on a NPTL-enhanced kernel
(http://publib.boulder.ibm.com/infocenter/ws51help/index.jsp?topic=/com.ibm.
websphere.base.doc/info/aes/ae/cins_nptl.html) Apparently v6.0 of WebSphere
supports NPTL.

Regards,
Shailender

-----Original Message-----
From: Doug Lea [mailto:dl@cs.oswego.edu] 
Sent: Saturday, 22 January 2005 3:46 a.m.
To: Bathula, Shailender
Cc: concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest] dl.util.concurrent v1.3.4,
PooledExecutor, LinkedQueue, shutdownN ow and hangup


I ran your test program a few times to completion without errors or problems
on a more recent linux kernel and using hotspot. My best guess is that your
very old (2.4.9) linux kernel is to blame here. Everyone running Java on
linux should be using either NPTL-enhanced 2.4 kernels (e.g., from redhat
9+) or 2.6 kernels. There were many, many Java threading problems on
pre-NPTL kernels.

-Doug

____________________________________________________________________
CAUTION - This message may contain privileged and confidential 
information intended only for the use of the addressee named above.
If you are not the intended recipient of this message you are hereby 
notified that any use, dissemination, distribution or reproduction 
of this message is prohibited. If you have received this message in 
error please notify Air New Zealand immediately. Any views expressed 
in this message are those of the individual sender and may not 
necessarily reflect the views of Air New Zealand.
_____________________________________________________________________
For more information on the Air New Zealand Group, visit us online
at http://www.airnewzealand.com 
_____________________________________________________________________
From leou at us.ibm.com  Sun Mar 13 17:34:34 2005
From: leou at us.ibm.com (Leo Uzcategui)
Date: Sun Mar 13 17:34:53 2005
Subject: [concurrency-interest] Leo Uzcategui/Austin/IBM is out of the
	office.
Message-ID: <OF8CDC7261.C646F96F-ON87256FC3.007C0406-87256FC3.007C040A@us.ibm.com>





I will be out of the office starting  03/11/2005 and will not return until
03/14/2005.

For assistance, please contact Carlton Mason at (512) 838-4537
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050313/0c42de47/attachment.htm
From dl at cs.oswego.edu  Mon Mar 14 12:44:03 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon Mar 14 12:44:05 2005
Subject: [concurrency-interest] 1.5.0_2
In-Reply-To: <16848.13600.655293.130360@altair.cs.oswego.edu>
References: <16848.13600.655293.130360@altair.cs.oswego.edu>
Message-ID: <4235CD63.5000104@cs.oswego.edu>


We don't usually mention Sun updates here, but the 1.5.0_2 update
release contains the fix to the LinkedBlockingQueue.drainTo bug,
so everyone ought to install it.
see http://java.sun.com/j2se/1.5.0/download.jsp

-Doug

From jbaxter at panscient.com  Fri Mar 18 00:47:28 2005
From: jbaxter at panscient.com (Jonathan Baxter)
Date: Fri Mar 18 00:46:15 2005
Subject: [concurrency-interest] PooledExecutor vs java.util.concurrent
Message-ID: <200503181617.28496.jbaxter@panscient.com>

I just upgraded to jdk 1.5 and since I have been using the edu.oswego 
concurrent package for a while I thought I would upgrade to 
java.util.concurrent. 

Used to be really easy to create a bounded, blocking thread pool:

PooledExecutor pe = new PooledExecutor(10);
pe.waitWhenBlocked();

Was also easy to increase and decrease the maximum number of threads 
available, via setMaximumPoolSize and createThreads. 

How do you get the same behaviour under java.util.concurrent? I can't see how 
without having to explicitly code the blocking behaviour and manage queue 
sizes and so on, which seems far less clean. Am I missing something?

Thanks,

Jonathan 
From jbaxter at panscient.com  Fri Mar 18 00:49:58 2005
From: jbaxter at panscient.com (Jonathan Baxter)
Date: Fri Mar 18 00:48:27 2005
Subject: [concurrency-interest] PooledExecutor vs java.util.concurrent
Message-ID: <200503181619.58814.jbaxter@panscient.com>

I just upgraded to jdk 1.5 and since I have been using the edu.oswego
concurrent package for a while I thought I would upgrade to
java.util.concurrent.

Used to be really easy to create a bounded, blocking thread pool:

PooledExecutor pe = new PooledExecutor(10);
pe.waitWhenBlocked();

Was also easy to increase and decrease the maximum number of threads
available, via setMaximumPoolSize and createThreads.

How do you get the same behaviour under java.util.concurrent? I can't see how
without having to explicitly code the blocking behaviour externally and manage 
queue sizes and so on, which seems far less clean. Am I missing something?

Thanks,

Jonathan
From tim at peierls.net  Fri Mar 18 01:19:00 2005
From: tim at peierls.net (Tim Peierls)
Date: Fri Mar 18 01:19:16 2005
Subject: [concurrency-interest] PooledExecutor vs java.util.concurrent
In-Reply-To: <200503181619.58814.jbaxter@panscient.com>
References: <200503181619.58814.jbaxter@panscient.com>
Message-ID: <423A72D4.5040108@peierls.net>

Jonathan Baxter wrote:
> Used to be really easy to create a bounded, blocking thread pool:
> 
> PooledExecutor pe = new PooledExecutor(10);
> pe.waitWhenBlocked();
> 
> Was also easy to increase and decrease the maximum number of threads
> available, via setMaximumPoolSize and createThreads.
> 
> How do you get the same behaviour under java.util.concurrent? 

  ExecutorService exec = new ThreadPoolExecutor(1, 10, 1, TimeUnit.MINUTES,
                                          new SynchronousQueue<Runnable>());

Doesn't seem too hard. setMaximumPoolSize() is still there, and you can 
prestartAllCoreThreads() instead of createThreads().

--tim

From jbaxter at panscient.com  Fri Mar 18 06:52:40 2005
From: jbaxter at panscient.com (Jonathan Baxter)
Date: Fri Mar 18 06:51:24 2005
Subject: [concurrency-interest] PooledExecutor vs java.util.concurrent
In-Reply-To: <423A72D4.5040108@peierls.net>
References: <200503181619.58814.jbaxter@panscient.com>
	<423A72D4.5040108@peierls.net>
Message-ID: <200503182222.40601.jbaxter@panscient.com>

On Friday 18 March 2005 16:49, Tim Peierls wrote:
> Jonathan Baxter wrote:
> > Used to be really easy to create a bounded, blocking thread pool:
> >
> > PooledExecutor pe = new PooledExecutor(10);
> > pe.waitWhenBlocked();
> >
> > Was also easy to increase and decrease the maximum number of threads
> > available, via setMaximumPoolSize and createThreads.
> >
> > How do you get the same behaviour under java.util.concurrent?
>
>   ExecutorService exec = new ThreadPoolExecutor(1, 10, 1, TimeUnit.MINUTES,
>                                           new
> SynchronousQueue<Runnable>());
>
> Doesn't seem too hard. setMaximumPoolSize() is still there, and you can
> prestartAllCoreThreads() instead of createThreads().

Ah - hadn't spotted SynchronousQueue. Thanks for the pointer. There are a lot 
more moving parts to bolt together to get the same behaviour in 
java.util.concurrent. 

- jonathan 

>
> --tim
From forax at univ-mlv.fr  Fri Mar 25 09:15:07 2005
From: forax at univ-mlv.fr (Remi Forax)
Date: Fri Mar 25 09:12:54 2005
Subject: [concurrency-interest] ListIterator,
	ascending and descending iterator
Message-ID: <42441CEB.5080106@univ-mlv.fr>

Prior JSR166x, the only way to iterate in descending order on
a collection is to use a ListIterator on a List. All others data-structures
don't have this feature.

Now, JSR166x propose to introduce the interface NavigableSet
that provide "navigation" methods.

I think, to be coherent LinkedList/ArrayList could have a method 
descendingIterator(),
  this Iterator is more lightweight than the ListIterator.

I think LinkedHashSet could implements NavigableSet
(see bugs 4848853 and 6182958) to gain navigation ability.

what do you think about these ?

R?mi Forax

From lionel2 at enorth.com.cn  Fri Mar 25 16:33:40 2005
From: lionel2 at enorth.com.cn (=?UTF-8?B?5ZGo56uL?=)
Date: Fri Mar 25 16:34:34 2005
Subject: [concurrency-interest] On Demand Staffing for Information
	Technology Projects
Message-ID: <424483B4.4050903@enorth.com.cn>

Rent-A-Pro.com offers on demand staffing and service delivery for 
information technology projects. It is convenient for small businesses 
as well as individual developers to get temporary help, consulting 
service and outsourcing service from independent contractors around the 
world through our site.

We provide functions for posting project requirements, bidding for 
projects and rating between buyers and sellers. Buyers and sellers are 
protected from fraud by an escrow system and a dispute resolution system.

http://www.rent-a-pro.com/
-------------- next part --------------
A non-text attachment was scrubbed...
Name: lionel2.vcf
Type: text/x-vcard
Size: 253 bytes
Desc: not available
Url : /pipermail/attachments/20050326/28e129d7/lionel2.vcf
From dl at cs.oswego.edu  Wed Mar 30 19:11:19 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed Mar 30 19:11:22 2005
Subject: [concurrency-interest] ListIterator,	ascending and descending
	iterator
In-Reply-To: <42441CEB.5080106@univ-mlv.fr>
References: <42441CEB.5080106@univ-mlv.fr>
Message-ID: <424B4027.2060104@cs.oswego.edu>

Remi Forax wrote:
> Prior JSR166x, the only way to iterate in descending order on
> a collection is to use a ListIterator on a List. All others data-structures
> don't have this feature.
> 
> Now, JSR166x propose to introduce the interface NavigableSet
> that provide "navigation" methods.
> 
> I think, to be coherent LinkedList/ArrayList could have a method 
> descendingIterator(),
>   this Iterator is more lightweight than the ListIterator.
> 
> I think LinkedHashSet could implements NavigableSet
> (see bugs 4848853 and 6182958) to gain navigation ability.
> 
> what do you think about these ?

Thanks for the suggestion. We considered some options along
these lines, but logistically, they don't work out. Navigable{Map,Set}
extend Sorted{Map,Set}, which these other classes cannot support.
And there's no nice way we could find to do so. Also, having a
descendingIterator (and ascendingIterator) for List classes is not
appreciably faster than using a ListIterator, so there's not much 
motivation to try to fit these in.

While on the subject, note a small change in the Navigable{Map,Set}
interfaces that will soon be integrated into Mustang builds.
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/
These interfaces now define "navigableSubSet", "navigableSubMap" etc
rather than just "subSet" and "subMap". This is due to a backward
compatibility concern. Any existing subclass of, say, TreeSet
would no longer compile or run without change if we had simply
overridden "subSet" to now guarantee to return a NavigableSet.
But with the method name changes, old code will still run.
This change is slightly awkward but tolerable.

-Doug
From kevinb at google.com  Thu Mar 31 11:46:21 2005
From: kevinb at google.com (Kevin Bourrillion)
Date: Thu Mar 31 11:46:30 2005
Subject: [concurrency-interest] Tree{Map,Set}
Message-ID: <108fcdeb05033108464e54823e@mail.google.com>

Hi,

I heard a rumor that in Mustang, TreeMap and TreeSet will be
retrofitted to implement the fabulous new Navigable interfaces.

If so, is it possible to include jsr166x.TreeMap/Set in jsr166x.jar so
that we might start using them?

On the other hand: for a caller who needs just a general-purpose,
non-concurrent, sorted set or map, would it be a bad idea for them to
use ConcurrentSkipList*?  If it's not appreciably slower in this case,
perhaps for our purposes we can just forget about Tree*?

Thanks,
K

-- 
http://www/~kevinb/
From dl at cs.oswego.edu  Thu Mar 31 12:40:05 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu Mar 31 12:40:07 2005
Subject: [concurrency-interest] Tree{Map,Set}
In-Reply-To: <108fcdeb05033108464e54823e@mail.google.com>
References: <108fcdeb05033108464e54823e@mail.google.com>
Message-ID: <424C35F5.6060104@cs.oswego.edu>

Kevin Bourrillion wrote:
> Hi,
> 
> I heard a rumor that in Mustang, TreeMap and TreeSet will be
> retrofitted to implement the fabulous new Navigable interfaces.

Yes. These should appear in Mustang builds reasonably soon for
those of you getting the early access snapshots. 
(https://mustang.dev.java.net/)

> 
> If so, is it possible to include jsr166x.TreeMap/Set in jsr166x.jar so
> that we might start using them?


Probably. I'll check. (The integrated versions of our updated
java.util.Tree*, have Sun headers. It ought to be possible to get
Sun permission to distribute in jsr166x, although those of you
concerned about purity might not like the re-introduction of
mixed-license jars for jsr166x.)

> 
> On the other hand: for a caller who needs just a general-purpose,
> non-concurrent, sorted set or map, would it be a bad idea for them to
> use ConcurrentSkipList*?  If it's not appreciably slower in this case,
> perhaps for our purposes we can just forget about Tree*?
> 

It depends on what you mean by "appreciably".

If most of your uses are methods put() and get() and their variants,
and map sizes are not huge, you might not notice any difference.
In many these cases, ConcurrentSkipLists are often even slightly faster.

If you do a lot of deletions, Trees will be noticeably faster because
the deletion algorithm in concurrent skip lists has much more overhead
than redblack tree deletion.

If you mostly have very large maps (say, 100K+ elements), Trees will
be noticeably faster because of the algorithmic asymptotics -- as n
increases, redblack trees perform around log2(n) comparisons per get()
vs around 2*log2(n) for skip lists.



-Doug
From Sai.Kumar at ca.com  Thu Mar 31 13:57:51 2005
From: Sai.Kumar at ca.com (Pollachi, Saikumar)
Date: Thu Mar 31 13:59:41 2005
Subject: [concurrency-interest] Tree{Map,Set}
Message-ID: <B80488675062364A909EE60F4A6660380710FE94@usilms23.ca.com>


Hi!

I am a silent member of the group. I enjoy reading the mails from this
group. Can somebody tell me if there is any possibility of deadlocks in
this code. I extended LinkedQueue to create  a PersistentQueue. It works
fine most of the time. Some time I suspect there is a dead lock.


public class PersistentQueue
    extends LinkedQueue
{
    private void restoreQueue()
    {
	...
    }

    private void buildQueue() throws InterruptedException, IOException
    {
		...
    }

    public void put(Object item) throws InterruptedException
    {
        //Object[] items = getSnapshot(item);
        super.put(item);
        persist();
    }

    public Object take() throws InterruptedException
    {
        Object obj = super.take();
        persist();
        return obj;
    }

    private void persist(Object[] items)
    {
        if (items != null)
        {
            int size = items.length;
            ObjectOutputStream out = null;

            try
            {
                out = new ObjectOutputStream(new
FileOutputStream(queuePath, false));

                for (int i = 0; i < size; i++)
                {
                    out.writeObject(items[i]);
                }

                out.flush();
                out.close();
            }
            catch (IOException ioe)
            {
                logger.logp(Level.WARNING, "PersistentQueue",
"buildQueue()",
                            "Failed to persist the Queue..: " +
ioe.getMessage(), ioe);
            }
        }
    }

    private void persist()
    {
        if (queuePath == null)
        {
            return;
        }

        ObjectOutputStream out = null;

        boolean retry = false;
        do
        {
            retry = false;
            try
            {
                out = new ObjectOutputStream(new
FileOutputStream(queuePath, false));
                synchronized (head_)
                {
                    LinkedNode head = head_.next;
                    while (head != null)
                    {
                        if (head.value != null)
                        {
                            out.writeObject(head.value);
                        }
                        head = head.next;
                    }
                }
            }
            catch (IOException ioe)
            {
                //possible that the directory or file does not exist!
                //try to create it and if it fails then throw an
exception
                logger.logp(Level.WARNING, "PersistentQueue",
"persist()",
                            "Failed to persist the Queue..: " +
ioe.getMessage(), ioe);
                logger.logp(Level.FINE, "PersistentQueue", "persist()",
                            "Attempting to create the directory and then
persist.");
                createDir(queuePath);
                retry = true;
            }
            finally
            {
                try
                {
                    if(out != null)
                    {
                        out.flush();
                        out.close();
                    }
                }
                catch (IOException ioe)
                {
                    logger.logp(Level.FINE, "PersistentQueue",
"persist()",
                                "Failed to close the file stream : " +
ioe.getMessage());

                }
            }
        }while(retry);
    }

}

Thanks

Saikumar Pollachi

From dholmes at dltech.com.au  Thu Mar 31 18:47:37 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Thu Mar 31 18:47:45 2005
Subject: [concurrency-interest] Tree{Map,Set}
In-Reply-To: <B80488675062364A909EE60F4A6660380710FE94@usilms23.ca.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEJIFIAA.dholmes@dltech.com.au>

I'm not at all clear on what you have done. What is a LinkedQueue? How does
it perform synchronization?

David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces@cs.oswego.edu
> [mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of
> Pollachi, Saikumar
> Sent: Friday, 1 April 2005 4:58 AM
> To: concurrency-interest@altair.cs.oswego.edu
> Subject: RE: [concurrency-interest] Tree{Map,Set}
>
>
>
> Hi!
>
> I am a silent member of the group. I enjoy reading the mails from this
> group. Can somebody tell me if there is any possibility of deadlocks in
> this code. I extended LinkedQueue to create  a PersistentQueue. It works
> fine most of the time. Some time I suspect there is a dead lock.
>
>
> public class PersistentQueue
>     extends LinkedQueue
> {
>     private void restoreQueue()
>     {
> 	...
>     }
>
>     private void buildQueue() throws InterruptedException, IOException
>     {
> 		...
>     }
>
>     public void put(Object item) throws InterruptedException
>     {
>         //Object[] items = getSnapshot(item);
>         super.put(item);
>         persist();
>     }
>
>     public Object take() throws InterruptedException
>     {
>         Object obj = super.take();
>         persist();
>         return obj;
>     }
>
>     private void persist(Object[] items)
>     {
>         if (items != null)
>         {
>             int size = items.length;
>             ObjectOutputStream out = null;
>
>             try
>             {
>                 out = new ObjectOutputStream(new
> FileOutputStream(queuePath, false));
>
>                 for (int i = 0; i < size; i++)
>                 {
>                     out.writeObject(items[i]);
>                 }
>
>                 out.flush();
>                 out.close();
>             }
>             catch (IOException ioe)
>             {
>                 logger.logp(Level.WARNING, "PersistentQueue",
> "buildQueue()",
>                             "Failed to persist the Queue..: " +
> ioe.getMessage(), ioe);
>             }
>         }
>     }
>
>     private void persist()
>     {
>         if (queuePath == null)
>         {
>             return;
>         }
>
>         ObjectOutputStream out = null;
>
>         boolean retry = false;
>         do
>         {
>             retry = false;
>             try
>             {
>                 out = new ObjectOutputStream(new
> FileOutputStream(queuePath, false));
>                 synchronized (head_)
>                 {
>                     LinkedNode head = head_.next;
>                     while (head != null)
>                     {
>                         if (head.value != null)
>                         {
>                             out.writeObject(head.value);
>                         }
>                         head = head.next;
>                     }
>                 }
>             }
>             catch (IOException ioe)
>             {
>                 //possible that the directory or file does not exist!
>                 //try to create it and if it fails then throw an
> exception
>                 logger.logp(Level.WARNING, "PersistentQueue",
> "persist()",
>                             "Failed to persist the Queue..: " +
> ioe.getMessage(), ioe);
>                 logger.logp(Level.FINE, "PersistentQueue", "persist()",
>                             "Attempting to create the directory and then
> persist.");
>                 createDir(queuePath);
>                 retry = true;
>             }
>             finally
>             {
>                 try
>                 {
>                     if(out != null)
>                     {
>                         out.flush();
>                         out.close();
>                     }
>                 }
>                 catch (IOException ioe)
>                 {
>                     logger.logp(Level.FINE, "PersistentQueue",
> "persist()",
>                                 "Failed to close the file stream : " +
> ioe.getMessage());
>
>                 }
>             }
>         }while(retry);
>     }
>
> }
>
> Thanks
>
> Saikumar Pollachi
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

