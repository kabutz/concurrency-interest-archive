From dt at flyingtroika.com  Mon Sep  1 00:48:20 2014
From: dt at flyingtroika.com (DT)
Date: Sun, 31 Aug 2014 21:48:20 -0700
Subject: [concurrency-interest] AtomicReference and java.lang.ref package
	design thoughts
Message-ID: <5403FA94.3090703@flyingtroika.com>

Are any plans to move AtomicReference to the java.lang.ref package? Just 
interesting to understand what was the idea behind the AtomicReference 
implementation. AtomicReference is used for concurrency reason and its 
some sort of a strong reference. So it makes sense to put it under 
concurrency package but at the same time it represents a reference 
object and the construct for Atomicreference is the same as any other 
references - AtomicReference aRef_ = new AtomicReference() , or 
SoftReference sRef_ = new SoftReference();
The ref package has multiple reference implementations such as 
Reference, PhantomReference, SoftReference, WeakReference  - and all of 
them are managed by ReferenceQueue in the direct or abstract way, though 
AtomicReference does not belong to  ref package and is not extended from 
Reference class. My understanding is that its not meant to be used in 
any way with a ReferenceQueue for any type of weak cache implementations 
either. So should it be under the ref package or under concurrency 
package if we look at this from high level?
Seems to me there is some misconception about references which makes it 
hard to understand in terms of the memory and gc behaviors.

Thanks,
DT

From davidcholmes at aapt.net.au  Mon Sep  1 04:29:04 2014
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 1 Sep 2014 18:29:04 +1000
Subject: [concurrency-interest] AtomicReference and java.lang.ref
	packagedesign thoughts
In-Reply-To: <5403FA94.3090703@flyingtroika.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKELBKIAA.davidcholmes@aapt.net.au>

Hi DT,

AtomicReference is an atomic class that operates on object references as
opposed to one of the primitive types.

The java.lang.ref package concerns types that manage references to other
objects for the purpose of interacting with the garbage collector.

AtomicReference has nothing to do with interacting with the garbage
collector.

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of DT
> Sent: Monday, 1 September 2014 2:48 PM
> To: concurrency-interest
> Subject: [concurrency-interest] AtomicReference and java.lang.ref
> packagedesign thoughts
>
>
> Are any plans to move AtomicReference to the java.lang.ref package? Just
> interesting to understand what was the idea behind the AtomicReference
> implementation. AtomicReference is used for concurrency reason and its
> some sort of a strong reference. So it makes sense to put it under
> concurrency package but at the same time it represents a reference
> object and the construct for Atomicreference is the same as any other
> references - AtomicReference aRef_ = new AtomicReference() , or
> SoftReference sRef_ = new SoftReference();
> The ref package has multiple reference implementations such as
> Reference, PhantomReference, SoftReference, WeakReference  - and all of
> them are managed by ReferenceQueue in the direct or abstract way, though
> AtomicReference does not belong to  ref package and is not extended from
> Reference class. My understanding is that its not meant to be used in
> any way with a ReferenceQueue for any type of weak cache implementations
> either. So should it be under the ref package or under concurrency
> package if we look at this from high level?
> Seems to me there is some misconception about references which makes it
> hard to understand in terms of the memory and gc behaviors.
>
> Thanks,
> DT
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From oleksandr.otenko at oracle.com  Mon Sep  1 09:11:45 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Mon, 01 Sep 2014 14:11:45 +0100
Subject: [concurrency-interest] AtomicReference and java.lang.ref
 package design thoughts
In-Reply-To: <5403FA94.3090703@flyingtroika.com>
References: <5403FA94.3090703@flyingtroika.com>
Message-ID: <54047091.3000000@oracle.com>

They are in separate packages and don't have any inheritance 
relationship exactly because they are in no way similar.

Alex

On 01/09/2014 05:48, DT wrote:
> Are any plans to move AtomicReference to the java.lang.ref package? 
> Just interesting to understand what was the idea behind the 
> AtomicReference implementation. AtomicReference is used for 
> concurrency reason and its some sort of a strong reference. So it 
> makes sense to put it under concurrency package but at the same time 
> it represents a reference object and the construct for Atomicreference 
> is the same as any other references - AtomicReference aRef_ = new 
> AtomicReference() , or SoftReference sRef_ = new SoftReference();
> The ref package has multiple reference implementations such as 
> Reference, PhantomReference, SoftReference, WeakReference  - and all 
> of them are managed by ReferenceQueue in the direct or abstract way, 
> though AtomicReference does not belong to  ref package and is not 
> extended from Reference class. My understanding is that its not meant 
> to be used in any way with a ReferenceQueue for any type of weak cache 
> implementations either. So should it be under the ref package or under 
> concurrency package if we look at this from high level?
> Seems to me there is some misconception about references which makes 
> it hard to understand in terms of the memory and gc behaviors.
>
> Thanks,
> DT
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From dl at cs.oswego.edu  Mon Sep  1 12:23:58 2014
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 01 Sep 2014 12:23:58 -0400
Subject: [concurrency-interest] Draft guidelines on parallelism in
	java.util.streams
Message-ID: <54049D9E.9090106@cs.oswego.edu>


It's been a while now since release of JDK8, but there are still no
helpful guidelines posted about when to use their parallel features.
So some of us decided to put together some, with the aim of staying
high-level and accessible, but with enough depth and accuracy
to be concretely useful. A draft is at
   http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html

This or some adaptation might someday appear in JDK supporting
materials or elsewhere.

Comments and suggestions would be welcome, especially from those
of you who have been using data-parallelism for years (long prior
to JDK8 streams).

-Doug

From dt at flyingtroika.com  Mon Sep  1 16:30:30 2014
From: dt at flyingtroika.com (DT)
Date: Mon, 01 Sep 2014 13:30:30 -0700
Subject: [concurrency-interest] AtomicReference and java.lang.ref
 packagedesign thoughts
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKELBKIAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCKELBKIAA.davidcholmes@aapt.net.au>
Message-ID: <5404D766.6030902@flyingtroika.com>


thanks, so AtomicReference does not have anything common with a strong 
reference , is it correct? in the sense how strong reference is implemented.

DT
On 9/1/2014 1:29 AM, David Holmes wrote:
> Hi DT,
>
> AtomicReference is an atomic class that operates on object references as
> opposed to one of the primitive types.
>
> The java.lang.ref package concerns types that manage references to other
> objects for the purpose of interacting with the garbage collector.
>
> AtomicReference has nothing to do with interacting with the garbage
> collector.
>
> Cheers,
> David Holmes
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of DT
>> Sent: Monday, 1 September 2014 2:48 PM
>> To: concurrency-interest
>> Subject: [concurrency-interest] AtomicReference and java.lang.ref
>> packagedesign thoughts
>>
>>
>> Are any plans to move AtomicReference to the java.lang.ref package? Just
>> interesting to understand what was the idea behind the AtomicReference
>> implementation. AtomicReference is used for concurrency reason and its
>> some sort of a strong reference. So it makes sense to put it under
>> concurrency package but at the same time it represents a reference
>> object and the construct for Atomicreference is the same as any other
>> references - AtomicReference aRef_ = new AtomicReference() , or
>> SoftReference sRef_ = new SoftReference();
>> The ref package has multiple reference implementations such as
>> Reference, PhantomReference, SoftReference, WeakReference  - and all of
>> them are managed by ReferenceQueue in the direct or abstract way, though
>> AtomicReference does not belong to  ref package and is not extended from
>> Reference class. My understanding is that its not meant to be used in
>> any way with a ReferenceQueue for any type of weak cache implementations
>> either. So should it be under the ref package or under concurrency
>> package if we look at this from high level?
>> Seems to me there is some misconception about references which makes it
>> hard to understand in terms of the memory and gc behaviors.
>>
>> Thanks,
>> DT
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From davidcholmes at aapt.net.au  Mon Sep  1 17:11:31 2014
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 2 Sep 2014 07:11:31 +1000
Subject: [concurrency-interest] AtomicReference and java.lang.ref
	packagedesign thoughts
In-Reply-To: <5404D766.6030902@flyingtroika.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOELEKIAA.davidcholmes@aapt.net.au>

DT writes:
>
> thanks, so AtomicReference does not have anything common with a strong
> reference , is it correct? in the sense how strong reference is
> implemented.

What do you mean by "how strong reference is implemented"? There is no type
"strong reference" - any field of reference type that holds a reference to
an object is a strong reference. Even WeakReference/SoftReference hold
strong references to their referents - it is the GC that clears those strong
references when it needs to.

Atomic Reference has nothing to do with the functionality of the
java.lang.ref package.

Cheers,
David Holmes

>
> DT
> On 9/1/2014 1:29 AM, David Holmes wrote:
> > Hi DT,
> >
> > AtomicReference is an atomic class that operates on object references as
> > opposed to one of the primitive types.
> >
> > The java.lang.ref package concerns types that manage references to other
> > objects for the purpose of interacting with the garbage collector.
> >
> > AtomicReference has nothing to do with interacting with the garbage
> > collector.
> >
> > Cheers,
> > David Holmes
> >
> >> -----Original Message-----
> >> From: concurrency-interest-bounces at cs.oswego.edu
> >> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of DT
> >> Sent: Monday, 1 September 2014 2:48 PM
> >> To: concurrency-interest
> >> Subject: [concurrency-interest] AtomicReference and java.lang.ref
> >> packagedesign thoughts
> >>
> >>
> >> Are any plans to move AtomicReference to the java.lang.ref
> package? Just
> >> interesting to understand what was the idea behind the AtomicReference
> >> implementation. AtomicReference is used for concurrency reason and its
> >> some sort of a strong reference. So it makes sense to put it under
> >> concurrency package but at the same time it represents a reference
> >> object and the construct for Atomicreference is the same as any other
> >> references - AtomicReference aRef_ = new AtomicReference() , or
> >> SoftReference sRef_ = new SoftReference();
> >> The ref package has multiple reference implementations such as
> >> Reference, PhantomReference, SoftReference, WeakReference  - and all of
> >> them are managed by ReferenceQueue in the direct or abstract
> way, though
> >> AtomicReference does not belong to  ref package and is not
> extended from
> >> Reference class. My understanding is that its not meant to be used in
> >> any way with a ReferenceQueue for any type of weak cache
> implementations
> >> either. So should it be under the ref package or under concurrency
> >> package if we look at this from high level?
> >> Seems to me there is some misconception about references which makes it
> >> hard to understand in terms of the memory and gc behaviors.
> >>
> >> Thanks,
> >> DT
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From stanimir at riflexo.com  Mon Sep  1 17:23:54 2014
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Tue, 2 Sep 2014 00:23:54 +0300
Subject: [concurrency-interest] AtomicReference and java.lang.ref
 packagedesign thoughts
In-Reply-To: <5404D766.6030902@flyingtroika.com>
References: <NFBBKALFDCPFIDBNKAPCKELBKIAA.davidcholmes@aapt.net.au>
	<5404D766.6030902@flyingtroika.com>
Message-ID: <CAEJX8opwa8THwQboTEw4v3RhaCbK2nhvZX-oUMOij=gt0grJyw@mail.gmail.com>

Any reference in Java is strong but the garbage collector has special
treatment for Weak/Soft/Phantom ones and only for them.
AtomicReference allows Read-check-modify (or CAS [Compare-And-Set]) as an
atomic operation.

To put it simply AtomicReference doesn't enjoy any special treatment unlike
Weak/Soft ones.


On Mon, Sep 1, 2014 at 11:30 PM, DT <dt at flyingtroika.com> wrote:

>
> thanks, so AtomicReference does not have anything common with a strong
> reference , is it correct? in the sense how strong reference is implemented.
>
> DT
>
> On 9/1/2014 1:29 AM, David Holmes wrote:
>
>> Hi DT,
>>
>> AtomicReference is an atomic class that operates on object references as
>> opposed to one of the primitive types.
>>
>> The java.lang.ref package concerns types that manage references to other
>> objects for the purpose of interacting with the garbage collector.
>>
>> AtomicReference has nothing to do with interacting with the garbage
>> collector.
>>
>> Cheers,
>> David Holmes
>>
>>  -----Original Message-----
>>> From: concurrency-interest-bounces at cs.oswego.edu
>>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of DT
>>> Sent: Monday, 1 September 2014 2:48 PM
>>> To: concurrency-interest
>>> Subject: [concurrency-interest] AtomicReference and java.lang.ref
>>> packagedesign thoughts
>>>
>>>
>>> Are any plans to move AtomicReference to the java.lang.ref package? Just
>>> interesting to understand what was the idea behind the AtomicReference
>>> implementation. AtomicReference is used for concurrency reason and its
>>> some sort of a strong reference. So it makes sense to put it under
>>> concurrency package but at the same time it represents a reference
>>> object and the construct for Atomicreference is the same as any other
>>> references - AtomicReference aRef_ = new AtomicReference() , or
>>> SoftReference sRef_ = new SoftReference();
>>> The ref package has multiple reference implementations such as
>>> Reference, PhantomReference, SoftReference, WeakReference  - and all of
>>> them are managed by ReferenceQueue in the direct or abstract way, though
>>> AtomicReference does not belong to  ref package and is not extended from
>>> Reference class. My understanding is that its not meant to be used in
>>> any way with a ReferenceQueue for any type of weak cache implementations
>>> either. So should it be under the ref package or under concurrency
>>> package if we look at this from high level?
>>> Seems to me there is some misconception about references which makes it
>>> hard to understand in terms of the memory and gc behaviors.
>>>
>>> Thanks,
>>> DT
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140902/e5ea4714/attachment.html>

From dt at flyingtroika.com  Mon Sep  1 20:43:00 2014
From: dt at flyingtroika.com (DT)
Date: Mon, 01 Sep 2014 17:43:00 -0700
Subject: [concurrency-interest] AtomicReference and java.lang.ref
 packagedesign thoughts
In-Reply-To: <CAEJX8opwa8THwQboTEw4v3RhaCbK2nhvZX-oUMOij=gt0grJyw@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCKELBKIAA.davidcholmes@aapt.net.au>	<5404D766.6030902@flyingtroika.com>
	<CAEJX8opwa8THwQboTEw4v3RhaCbK2nhvZX-oUMOij=gt0grJyw@mail.gmail.com>
Message-ID: <54051294.3040708@flyingtroika.com>

thank you,  this is exactly what I was looking for.
DT
On 9/1/2014 2:23 PM, Stanimir Simeonoff wrote:
> Any reference in Java is strong but the garbage collector has special 
> treatment for Weak/Soft/Phantom ones and only for them.
> AtomicReference allows Read-check-modify (or CAS [Compare-And-Set]) as 
> an atomic operation.
>
> To put it simply AtomicReference doesn't enjoy any special treatment 
> unlike Weak/Soft ones.
>
>
> On Mon, Sep 1, 2014 at 11:30 PM, DT <dt at flyingtroika.com 
> <mailto:dt at flyingtroika.com>> wrote:
>
>
>     thanks, so AtomicReference does not have anything common with a
>     strong reference , is it correct? in the sense how strong
>     reference is implemented.
>
>     DT
>
>     On 9/1/2014 1:29 AM, David Holmes wrote:
>
>         Hi DT,
>
>         AtomicReference is an atomic class that operates on object
>         references as
>         opposed to one of the primitive types.
>
>         The java.lang.ref package concerns types that manage
>         references to other
>         objects for the purpose of interacting with the garbage collector.
>
>         AtomicReference has nothing to do with interacting with the
>         garbage
>         collector.
>
>         Cheers,
>         David Holmes
>
>             -----Original Message-----
>             From: concurrency-interest-bounces at cs.oswego.edu
>             <mailto:concurrency-interest-bounces at cs.oswego.edu>
>             [mailto:concurrency-interest-bounces at cs.oswego.edu
>             <mailto:concurrency-interest-bounces at cs.oswego.edu>]On
>             Behalf Of DT
>             Sent: Monday, 1 September 2014 2:48 PM
>             To: concurrency-interest
>             Subject: [concurrency-interest] AtomicReference and
>             java.lang.ref
>             packagedesign thoughts
>
>
>             Are any plans to move AtomicReference to the java.lang.ref
>             package? Just
>             interesting to understand what was the idea behind the
>             AtomicReference
>             implementation. AtomicReference is used for concurrency
>             reason and its
>             some sort of a strong reference. So it makes sense to put
>             it under
>             concurrency package but at the same time it represents a
>             reference
>             object and the construct for Atomicreference is the same
>             as any other
>             references - AtomicReference aRef_ = new AtomicReference()
>             , or
>             SoftReference sRef_ = new SoftReference();
>             The ref package has multiple reference implementations such as
>             Reference, PhantomReference, SoftReference, WeakReference 
>             - and all of
>             them are managed by ReferenceQueue in the direct or
>             abstract way, though
>             AtomicReference does not belong to  ref package and is not
>             extended from
>             Reference class. My understanding is that its not meant to
>             be used in
>             any way with a ReferenceQueue for any type of weak cache
>             implementations
>             either. So should it be under the ref package or under
>             concurrency
>             package if we look at this from high level?
>             Seems to me there is some misconception about references
>             which makes it
>             hard to understand in terms of the memory and gc behaviors.
>
>             Thanks,
>             DT
>             _______________________________________________
>             Concurrency-interest mailing list
>             Concurrency-interest at cs.oswego.edu
>             <mailto:Concurrency-interest at cs.oswego.edu>
>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140901/81bf6fc1/attachment-0001.html>

From martijnverburg at gmail.com  Tue Sep  2 06:39:39 2014
From: martijnverburg at gmail.com (Martijn Verburg)
Date: Tue, 2 Sep 2014 11:39:39 +0100
Subject: [concurrency-interest] Draft guidelines on parallelism in
	java.util.streams
In-Reply-To: <54049D9E.9090106@cs.oswego.edu>
References: <54049D9E.9090106@cs.oswego.edu>
Message-ID: <CAP7YuATF9z7yCXoU=9sCJnwpwNK_qPLjBMDGaayRC+ER=PDv0Q@mail.gmail.com>

Hi Doug,

Nice to see this guideline posted! It's a question we get asked a bit in
London, some quick feedback.

* Would be good to have concrete code examples of F (side effect free vs
side effect)
* N,Q,F example - would be good to have the formula (and a concrete
example) split out from the body of the text
* Splitability - could present this as a table?

There's a bunch of minor spelling, grammar and formatting things as well -
If there's a source file I can annotate with comments, happy to add
suggested fixes there?



Cheers,
Martijn


On 1 September 2014 17:23, Doug Lea <dl at cs.oswego.edu> wrote:

>
> It's been a while now since release of JDK8, but there are still no
> helpful guidelines posted about when to use their parallel features.
> So some of us decided to put together some, with the aim of staying
> high-level and accessible, but with enough depth and accuracy
> to be concretely useful. A draft is at
>   http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html
>
> This or some adaptation might someday appear in JDK supporting
> materials or elsewhere.
>
> Comments and suggestions would be welcome, especially from those
> of you who have been using data-parallelism for years (long prior
> to JDK8 streams).
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140902/2ef79a2b/attachment.html>

From dl at cs.oswego.edu  Tue Sep  2 15:06:13 2014
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 02 Sep 2014 15:06:13 -0400
Subject: [concurrency-interest] Draft guidelines on parallelism in
	java.util.streams
In-Reply-To: <CAP7YuATF9z7yCXoU=9sCJnwpwNK_qPLjBMDGaayRC+ER=PDv0Q@mail.gmail.com>
References: <54049D9E.9090106@cs.oswego.edu>
	<CAP7YuATF9z7yCXoU=9sCJnwpwNK_qPLjBMDGaayRC+ER=PDv0Q@mail.gmail.com>
Message-ID: <54061525.4070806@cs.oswego.edu>

On 09/02/2014 06:39 AM, Martijn Verburg wrote:

> Nice to see this guideline posted! It's a question we get asked a bit in London,
> some quick feedback.
>
> * Would be good to have concrete code examples of F (side effect free vs side
> effect)

Yes, although there are some in the linked java.util.stream package javadocs
(http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html).
Suggestions for more examples that immediately get the point across would be
welcome.

> * N,Q,F example - would be good to have the formula (and a concrete example)
> split out from the body of the text
> * Splitability - could present this as a table?

I worry a little about mentioning all JDK collections in a table,
since some Spliterators might change or improve over time. This might be
good fodder for a cheat-sheet somewhere though.

>
> There's a bunch of minor spelling, grammar and formatting things as well - If
> there's a source file I can annotate with comments, happy to add suggested fixes
> there?

Thanks to others I did an edit pass fixing some of these, but please
let me know of others in any way you like. (Including just via
edited saved html).

-Doug



From mr.chrisvest at gmail.com  Wed Sep  3 16:49:19 2014
From: mr.chrisvest at gmail.com (Chris Vest)
Date: Wed, 3 Sep 2014 22:49:19 +0200
Subject: [concurrency-interest] Ensuring the correctness of concurrent code
Message-ID: <3BEA2123-7489-45E6-AD0F-4F0CA50EF755@gmail.com>

Hi,

I occasionally have to write code that does shared mutable memory concurrency, have high performance requirements, and needs a high degree of confidence in the correctness of the implementation.

So far I have tackled this by thinking hard and working hard. I?ve written hundreds of tests for tiny APIs, targeted and randomised alike, I?ve drawn up diagrams summarising all the state transitions, I?ve gone through the code to check every against said diagram, I?ve written documentation to specify all observable behaviours, and then written more tests for things I discovered while writing said documentation, sleep on it, wake up and write even more tests for new scenarios I?ve literally dreamt up. And so on?

This has worked well so far, though it takes a lot of effort and discipline. However, as the problems I try to solve get harder, and the optimisations I want to pull off gets more cunning, I feel like I?m approaching the limits of this ?technique.?

So, how to other people approach this? How is the correctness of the j.u.c. implementations ensured, for instance?

I have begun studying TLA+ in the hope that the formal specifications might be helpful, but I?m not sure if that?s the right path. I haven?t studied proof techniques before. One worry I have with TLA+ is how to accurately represent the given memory model I?m working with, which has thus far been the JMM.

Cheers,
Chris

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140903/e5ea5ada/attachment.html>

From szabolcs.ferenczi at gmail.com  Wed Sep  3 19:16:41 2014
From: szabolcs.ferenczi at gmail.com (Szabolcs Ferenczi)
Date: Thu, 4 Sep 2014 01:16:41 +0200
Subject: [concurrency-interest] Ensuring the correctness of concurrent
	code
In-Reply-To: <3BEA2123-7489-45E6-AD0F-4F0CA50EF755@gmail.com>
References: <3BEA2123-7489-45E6-AD0F-4F0CA50EF755@gmail.com>
Message-ID: <CA+AsFvYNFjsMG5DCnGYpvD-Lhv+QM9v07q1ur9oiUypjkp0Jiw@mail.gmail.com>

Hi, I have used CSP before and I liked it. It is very powerful but it needs
a special thinking when you try to map the procedural language notation
such as Java into the CSP notation. It is better to generate the mapping if
possible. Even better to model first and generate the code from the model.
In the book Concurrency: State Models & Java Programs the authors show a
way how to do the mapping by hand. You need to deal with the memory model
at the lowest level though. The advantage of the CSP notation is that you
can model your program at different abstraction levels and check that the
refinement still holds between the levels.
--
Szabolcs


On 3 September 2014 22:49, Chris Vest <mr.chrisvest at gmail.com> wrote:

> Hi,
>
> I occasionally have to write code that does shared mutable memory
> concurrency, have high performance requirements, and needs a high degree of
> confidence in the correctness of the implementation.
>
> So far I have tackled this by thinking hard and working hard. I?ve written
> hundreds of tests for tiny APIs, targeted and randomised alike, I?ve drawn
> up diagrams summarising all the state transitions, I?ve gone through the
> code to check every against said diagram, I?ve written documentation to
> specify all observable behaviours, and then written more tests for things I
> discovered while writing said documentation, sleep on it, wake up and write
> even more tests for new scenarios I?ve literally dreamt up. And so on?
>
> This has worked well so far, though it takes a lot of effort and
> discipline. However, as the problems I try to solve get harder, and the
> optimisations I want to pull off gets more cunning, I feel like I?m
> approaching the limits of this ?technique.?
>
> So, how to other people approach this? How is the correctness of the
> j.u.c. implementations ensured, for instance?
>
> I have begun studying TLA+ in the hope that the formal specifications
> might be helpful, but I?m not sure if that?s the right path. I haven?t
> studied proof techniques before. One worry I have with TLA+ is how to
> accurately represent the given memory model I?m working with, which has
> thus far been the JMM.
>
> Cheers,
> Chris
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140904/26a50a65/attachment.html>

From nathan.reynolds at oracle.com  Wed Sep  3 20:34:13 2014
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Wed, 03 Sep 2014 17:34:13 -0700
Subject: [concurrency-interest] Ensuring the correctness of concurrent
 code
In-Reply-To: <CA+AsFvYNFjsMG5DCnGYpvD-Lhv+QM9v07q1ur9oiUypjkp0Jiw@mail.gmail.com>
References: <3BEA2123-7489-45E6-AD0F-4F0CA50EF755@gmail.com>
	<CA+AsFvYNFjsMG5DCnGYpvD-Lhv+QM9v07q1ur9oiUypjkp0Jiw@mail.gmail.com>
Message-ID: <5407B385.3010308@oracle.com>

I used a tool called Java Pathfinder (JPF), 
http://en.wikipedia.org/wiki/Java_Pathfinder.  It runs a Java program 
and will find all data races and deadlocks if given enough time.

It does this by simulating all thread interleavings.  By this I mean, 
when a bytecode executes, JPF saves the state and picks a thread to 
continue the execution.  Later JPF will backtrack to that state and pick 
a different thread.  It continues to execute and backtrack until all 
threads have executed from that given state.

This would be terribly slow except that a lot of bytecodes don't do 
anything that can be seen by multiple threads.  Hence, these bytecodes 
don't cause backtracking.

It is terribly slow if you run more than 2 threads or have a very 
complicated program.  The best thing to do is create a very small toy 
program which models what you want to test.  This cuts down on the 
shared state and hence the thread interleavings.

I haven't used it in a while.  When I last used it, it didn't support 
JMM.  So, you can't test volatile very well.  You also can't test 
whether instruction reordering is going to cause a problem.

-Nathan

On 9/3/2014 4:16 PM, Szabolcs Ferenczi wrote:
> Hi, I have used CSP before and I liked it. It is very powerful but it 
> needs a special thinking when you try to map the procedural language 
> notation such as Java into the CSP notation. It is better to generate 
> the mapping if possible. Even better to model first and generate the 
> code from the model. In the book Concurrency: State Models & Java 
> Programs the authors show a way how to do the mapping by hand. You 
> need to deal with the memory model at the lowest level though. The 
> advantage of the CSP notation is that you can model your program at 
> different abstraction levels and check that the refinement still holds 
> between the levels.
> --
> Szabolcs
>
>
> On 3 September 2014 22:49, Chris Vest <mr.chrisvest at gmail.com 
> <mailto:mr.chrisvest at gmail.com>> wrote:
>
>     Hi,
>
>     I occasionally have to write code that does shared mutable memory
>     concurrency, have high performance requirements, and needs a high
>     degree of confidence in the correctness of the implementation.
>
>     So far I have tackled this by thinking hard and working hard. I?ve
>     written hundreds of tests for tiny APIs, targeted and randomised
>     alike, I?ve drawn up diagrams summarising all the state
>     transitions, I?ve gone through the code to check every against
>     said diagram, I?ve written documentation to specify all observable
>     behaviours, and then written more tests for things I discovered
>     while writing said documentation, sleep on it, wake up and write
>     even more tests for new scenarios I?ve literally dreamt up. And so on?
>
>     This has worked well so far, though it takes a lot of effort and
>     discipline. However, as the problems I try to solve get harder,
>     and the optimisations I want to pull off gets more cunning, I feel
>     like I?m approaching the limits of this ?technique.?
>
>     So, how to other people approach this? How is the correctness of
>     the j.u.c. implementations ensured, for instance?
>
>     I have begun studying TLA+ in the hope that the formal
>     specifications might be helpful, but I?m not sure if that?s the
>     right path. I haven?t studied proof techniques before. One worry I
>     have with TLA+ is how to accurately represent the given memory
>     model I?m working with, which has thus far been the JMM.
>
>     Cheers,
>     Chris
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140903/784e6952/attachment.html>

From vikas.vksingh at gmail.com  Thu Sep  4 22:17:42 2014
From: vikas.vksingh at gmail.com (vikas)
Date: Thu, 4 Sep 2014 19:17:42 -0700 (MST)
Subject: [concurrency-interest] Happens Before guarantee in case of
 unsafe.putOrderedObject and corresponding nomal read of a variable
Message-ID: <1409883462168-11255.post@n7.nabble.com>

I just wanted  to know if there is any kind of synchronization/happens before
guarantees with 
unsafe.putOrderedObject(data) and normal read of that particular data.

I am aware of the guarantees of the putOrderedObject (lazySet) in
AtomicInteger. Here i wanted to  know if can we reason on any gaurantees
/happens before edge between lazySet of a variable by thread T1  and *normal
read of that variable by thread T2.*

As far as i know you need both write and read barrier  to establish some
type of ordering relationship between two threads.

For example see below: 

class DS {
   
         private Integer [] data;
        
         public Test(int m) {
           data = new Object[m];
          }

         public void set(int index, Integer obj) {
             unsafe*.putOrderedObject(data, rawIndex(index), obj*);  // kind
of lazy set
         }
      
         public Integer get(final int index) {
            return  data[index]; // *non volatile read i.e normal read*
         }
}

So Suppose : 
  
  T1 Thread : 

    Integer v1 = new Integer(); // init the integer to  0
    v1.setValue(5);
    ds.set(2, v1);
    
  T2 thread :
       Integer v1 = ds.get(2);
        if(v1 != null ) { // *normal read *
           sysout(v1.get()) ;  //* Is thread 2 always guaranteed to  see 5 *
       }
  
*It would be very helpful if somebody can tell me if thread  T2 is always
guaranteed to see  5 or not*



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Happens-Before-guarantee-in-case-of-unsafe-putOrderedObject-and-corresponding-nomal-read-of-a-variabe-tp11255.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From vikas.vksingh at gmail.com  Fri Sep  5 00:15:11 2014
From: vikas.vksingh at gmail.com (vikas)
Date: Thu, 4 Sep 2014 21:15:11 -0700 (MST)
Subject: [concurrency-interest] Happens Before guarantee in case of
 unsafe.putOrderedObject and corresponding nomal read of a variable
In-Reply-To: <1409883462168-11255.post@n7.nabble.com>
References: <1409883462168-11255.post@n7.nabble.com>
Message-ID: <1409890511664-11256.post@n7.nabble.com>

Just some minor modifications for in the above mail

So Suppose initially
 * ds.get(2) == null  and ds.get(3) refers to a integer Object 7 i.e new
Integer(7) : *
then if 
  
  T1 Thread : 
       Integer v1 = ds.get(3); // suppose v1 is not null it contains 7 as an
int value
       v1.setValue(5);
       ds.set(2, v1);
    
  T2 thread :
       Integer v1 = ds.get(2);
       if(v1 != null ) { // *normal read i.e is not a volatile read*
           sysout(v1.get()) ;  //* Is thread 2 always guaranteed to  see 5 *
       }
  
*It would be very helpful if somebody can tell me if thread  T2 is always
guaranteed to see 5 or not*





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Happens-Before-guarantee-in-case-of-unsafe-putOrderedObject-and-corresponding-nomal-read-of-a-variabe-tp11255p11256.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From dl at cs.oswego.edu  Fri Sep  5 07:07:39 2014
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 05 Sep 2014 07:07:39 -0400
Subject: [concurrency-interest] Happens Before guarantee in case of
 unsafe.putOrderedObject and corresponding nomal read of a variable
In-Reply-To: <1409883462168-11255.post@n7.nabble.com>
References: <1409883462168-11255.post@n7.nabble.com>
Message-ID: <5409997B.8080507@cs.oswego.edu>

On 09/04/2014 10:17 PM, vikas wrote:
> I just wanted  to know if there is any kind of synchronization/happens before
> guarantees with
> unsafe.putOrderedObject(data) and normal read of that particular data.

In general, not. In C++/C11 terms, putOrderedObject provides
a release-mode write, that must be paired with an acquire-mode
read, which you can do via getObjectVolatile if not already volatile.
There are a few special cases where you do not need this because
of some other dominating volatile reads/writes, but they are not common.

-Doug


From aph at redhat.com  Fri Sep  5 07:26:33 2014
From: aph at redhat.com (Andrew Haley)
Date: Fri, 05 Sep 2014 12:26:33 +0100
Subject: [concurrency-interest] Happens Before guarantee in case of
 unsafe.putOrderedObject and corresponding nomal read of a variable
In-Reply-To: <5409997B.8080507@cs.oswego.edu>
References: <1409883462168-11255.post@n7.nabble.com>
	<5409997B.8080507@cs.oswego.edu>
Message-ID: <54099DE9.3000909@redhat.com>

On 09/05/2014 12:07 PM, Doug Lea wrote:
> On 09/04/2014 10:17 PM, vikas wrote:
>> I just wanted  to know if there is any kind of synchronization/happens before
>> guarantees with
>> unsafe.putOrderedObject(data) and normal read of that particular data.
> 
> In general, not. In C++/C11 terms, putOrderedObject provides
> a release-mode write, that must be paired with an acquire-mode
> read, which you can do via getObjectVolatile if not already volatile.
> There are a few special cases where you do not need this because
> of some other dominating volatile reads/writes, but they are not common.

While we have this particular box open, do you know why
AtomicIntegerFieldUpdater.putOrderedInt() uses Unsafe.putOrderedInt() ?

That one always baffles me.  I would have thought it was just a store.

Andrew.


From dl at cs.oswego.edu  Fri Sep  5 07:29:21 2014
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 05 Sep 2014 07:29:21 -0400
Subject: [concurrency-interest] Happens Before guarantee in case of
 unsafe.putOrderedObject and corresponding nomal read of a variable
In-Reply-To: <54099DE9.3000909@redhat.com>
References: <1409883462168-11255.post@n7.nabble.com>
	<5409997B.8080507@cs.oswego.edu> <54099DE9.3000909@redhat.com>
Message-ID: <54099E91.30607@cs.oswego.edu>

On 09/05/2014 07:26 AM, Andrew Haley wrote:
> On 09/05/2014 12:07 PM, Doug Lea wrote:
>> On 09/04/2014 10:17 PM, vikas wrote:
>>> I just wanted  to know if there is any kind of synchronization/happens before
>>> guarantees with
>>> unsafe.putOrderedObject(data) and normal read of that particular data.
>>
>> In general, not. In C++/C11 terms, putOrderedObject provides
>> a release-mode write, that must be paired with an acquire-mode
>> read, which you can do via getObjectVolatile if not already volatile.
>> There are a few special cases where you do not need this because
>> of some other dominating volatile reads/writes, but they are not common.
>
> While we have this particular box open, do you know why
> AtomicIntegerFieldUpdater.putOrderedInt() uses Unsafe.putOrderedInt() ?
>
> That one always baffles me.  I would have thought it was just a store.
>

Because the underlying field must be volatile, at implementation level,
the VM would otherwise generate the heavier full volatile store.

-Doug



From aph at redhat.com  Fri Sep  5 07:31:26 2014
From: aph at redhat.com (Andrew Haley)
Date: Fri, 05 Sep 2014 12:31:26 +0100
Subject: [concurrency-interest] Happens Before guarantee in case of
 unsafe.putOrderedObject and corresponding nomal read of a variable
In-Reply-To: <54099E91.30607@cs.oswego.edu>
References: <1409883462168-11255.post@n7.nabble.com>
	<5409997B.8080507@cs.oswego.edu> <54099DE9.3000909@redhat.com>
	<54099E91.30607@cs.oswego.edu>
Message-ID: <54099F0E.8070303@redhat.com>

On 09/05/2014 12:29 PM, Doug Lea wrote:
> On 09/05/2014 07:26 AM, Andrew Haley wrote:
>> On 09/05/2014 12:07 PM, Doug Lea wrote:
>>> On 09/04/2014 10:17 PM, vikas wrote:
>>>> I just wanted  to know if there is any kind of synchronization/happens before
>>>> guarantees with
>>>> unsafe.putOrderedObject(data) and normal read of that particular data.
>>>
>>> In general, not. In C++/C11 terms, putOrderedObject provides
>>> a release-mode write, that must be paired with an acquire-mode
>>> read, which you can do via getObjectVolatile if not already volatile.
>>> There are a few special cases where you do not need this because
>>> of some other dominating volatile reads/writes, but they are not common.
>>
>> While we have this particular box open, do you know why
>> AtomicIntegerFieldUpdater.putOrderedInt() uses Unsafe.putOrderedInt() ?
>>
>> That one always baffles me.  I would have thought it was just a store.
> 
> Because the underlying field must be volatile, at implementation level,
> the VM would otherwise generate the heavier full volatile store.

Argh.  My question was meant to be about lazySet(), sorry.

And again: I thought the idea of lazySet was to *weaken* the guarantee.
Otherwise I don't know what it is for.

Andrew.


From dl at cs.oswego.edu  Fri Sep  5 07:42:21 2014
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 05 Sep 2014 07:42:21 -0400
Subject: [concurrency-interest] Happens Before guarantee in case of
 unsafe.putOrderedObject and corresponding nomal read of a variable
In-Reply-To: <54099F0E.8070303@redhat.com>
References: <1409883462168-11255.post@n7.nabble.com>
	<5409997B.8080507@cs.oswego.edu> <54099DE9.3000909@redhat.com>
	<54099E91.30607@cs.oswego.edu> <54099F0E.8070303@redhat.com>
Message-ID: <5409A19D.2060905@cs.oswego.edu>

On 09/05/2014 07:31 AM, Andrew Haley wrote:
>
>>> While we have this particular box open, do you know why
>>> AtomicIntegerFieldUpdater.putOrderedInt() uses Unsafe.putOrderedInt() ?
>>>
>>> That one always baffles me.  I would have thought it was just a store.
>>
>> Because the underlying field must be volatile, at implementation level,
>> the VM would otherwise generate the heavier full volatile store.
>
> Argh.  My question was meant to be about lazySet(), sorry.
>
> And again: I thought the idea of lazySet was to *weaken* the guarantee.
> Otherwise I don't know what it is for.
>

There are three basic strengths of write: Relaxed (normal),
releasing, and SC volatile. I got talked into naming the second
releasing version "lazySet" which is confusing enough, but
compounded by the almost equally odd internal unsafe name "ordered".

These should be less confusing in JDK9 when we provide more
uniform enhanced-volatile support.

-Doug


From jsampson at guidewire.com  Fri Sep  5 13:14:34 2014
From: jsampson at guidewire.com (Justin Sampson)
Date: Fri, 5 Sep 2014 17:14:34 +0000
Subject: [concurrency-interest] Happens Before guarantee in case of
 unsafe.putOrderedObject and corresponding nomal read of a variable
In-Reply-To: <54099F0E.8070303@redhat.com>
References: <1409883462168-11255.post@n7.nabble.com>
	<5409997B.8080507@cs.oswego.edu> <54099DE9.3000909@redhat.com>
	<54099E91.30607@cs.oswego.edu> <54099F0E.8070303@redhat.com>
Message-ID: <0FD072A166C6DC4C851F6115F37DDD2763EE5875@sm-ex-01-vm.guidewire.com>

Andrew Haley wrote:

> And again: I thought the idea of lazySet was to *weaken* the
> guarantee.  Otherwise I don't know what it is for.

My own _guess_ based on the docs is that a full-volatile write ensures a
happens-before relation with _all_ subsequent volatile reads of the same
field, whereas a lazy/ordered write ensures a happens-before relation
with any subsequent volatile read _that sees the value written_ by that
write.  Therefore lazy writes guarantee, for example, safe publication
of objects, without actually forcing everything immediately out to main
memory.  But all bets are off, of course, if the read itself is not a
volatile read.

Doug et al., how close am I?

Cheers,
Justin


From vitalyd at gmail.com  Fri Sep  5 13:49:31 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 5 Sep 2014 13:49:31 -0400
Subject: [concurrency-interest] Happens Before guarantee in case of
 unsafe.putOrderedObject and corresponding nomal read of a variable
In-Reply-To: <0FD072A166C6DC4C851F6115F37DDD2763EE5875@sm-ex-01-vm.guidewire.com>
References: <1409883462168-11255.post@n7.nabble.com>
	<5409997B.8080507@cs.oswego.edu> <54099DE9.3000909@redhat.com>
	<54099E91.30607@cs.oswego.edu> <54099F0E.8070303@redhat.com>
	<0FD072A166C6DC4C851F6115F37DDD2763EE5875@sm-ex-01-vm.guidewire.com>
Message-ID: <CAHjP37FJhUzq4NGkDhmpOmyko9nDMunQpF__HYCkX-YAsWtXDw@mail.gmail.com>

lazySet orders preceding writes with the write being done as part of
lazySet, but does not guarantee that this write is globally visible before
next instruction is executed by the writing CPU.  In practical terms, on
x86/64, this compiles into a plain mov instruction with a compiler barrier
prevent prior stores from moving past the lazy one.  If this store were
done via volatile write or AtomicXXX.set(), then a cpu serializing
instruction would be added after the store (e.g. lock add $0, %rsp).

I'm guessing on non-TSO platforms lazySet implies a weaker release fence
instruction is emitted, but I don't know the details.


On Fri, Sep 5, 2014 at 1:14 PM, Justin Sampson <jsampson at guidewire.com>
wrote:

> Andrew Haley wrote:
>
> > And again: I thought the idea of lazySet was to *weaken* the
> > guarantee.  Otherwise I don't know what it is for.
>
> My own _guess_ based on the docs is that a full-volatile write ensures a
> happens-before relation with _all_ subsequent volatile reads of the same
> field, whereas a lazy/ordered write ensures a happens-before relation
> with any subsequent volatile read _that sees the value written_ by that
> write.  Therefore lazy writes guarantee, for example, safe publication
> of objects, without actually forcing everything immediately out to main
> memory.  But all bets are off, of course, if the read itself is not a
> volatile read.
>
> Doug et al., how close am I?
>
> Cheers,
> Justin
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140905/9b6cca3c/attachment.html>

From aph at redhat.com  Fri Sep  5 14:02:12 2014
From: aph at redhat.com (Andrew Haley)
Date: Fri, 05 Sep 2014 19:02:12 +0100
Subject: [concurrency-interest] Happens Before guarantee in case of
 unsafe.putOrderedObject and corresponding nomal read of a variable
In-Reply-To: <CAHjP37FJhUzq4NGkDhmpOmyko9nDMunQpF__HYCkX-YAsWtXDw@mail.gmail.com>
References: <1409883462168-11255.post@n7.nabble.com>	<5409997B.8080507@cs.oswego.edu>	<54099DE9.3000909@redhat.com>	<54099E91.30607@cs.oswego.edu>	<54099F0E.8070303@redhat.com>	<0FD072A166C6DC4C851F6115F37DDD2763EE5875@sm-ex-01-vm.guidewire.com>
	<CAHjP37FJhUzq4NGkDhmpOmyko9nDMunQpF__HYCkX-YAsWtXDw@mail.gmail.com>
Message-ID: <5409FAA4.1000002@redhat.com>

On 09/05/2014 06:49 PM, Vitaly Davidovich wrote:
> lazySet orders preceding writes with the write being done as part of
> lazySet, but does not guarantee that this write is globally visible before
> next instruction is executed by the writing CPU.  In practical terms, on
> x86/64, this compiles into a plain mov instruction with a compiler barrier
> prevent prior stores from moving past the lazy one.  If this store were
> done via volatile write or AtomicXXX.set(), then a cpu serializing
> instruction would be added after the store (e.g. lock add $0, %rsp).
> 
> I'm guessing on non-TSO platforms lazySet implies a weaker release fence
> instruction is emitted, but I don't know the details.

Okay, so it's simply a store release without a following barrier.  I
guess all of this will be clarified as part of the JMM work.

Thanks all,
Andrew.


From paul.sandoz at oracle.com  Mon Sep  8 04:48:19 2014
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Mon, 8 Sep 2014 10:48:19 +0200
Subject: [concurrency-interest] Happens Before guarantee in case of
	unsafe.putOrderedObject and corresponding nomal read of a variable
In-Reply-To: <5409FAA4.1000002@redhat.com>
References: <1409883462168-11255.post@n7.nabble.com>	<5409997B.8080507@cs.oswego.edu>	<54099DE9.3000909@redhat.com>	<54099E91.30607@cs.oswego.edu>	<54099F0E.8070303@redhat.com>	<0FD072A166C6DC4C851F6115F37DDD2763EE5875@sm-ex-01-vm.guidewire.com>
	<CAHjP37FJhUzq4NGkDhmpOmyko9nDMunQpF__HYCkX-YAsWtXDw@mail.gmail.com>
	<5409FAA4.1000002@redhat.com>
Message-ID: <891C4320-A2CA-4086-B026-A7C267F75E74@oracle.com>


On Sep 5, 2014, at 8:02 PM, Andrew Haley <aph at redhat.com> wrote:

> On 09/05/2014 06:49 PM, Vitaly Davidovich wrote:
>> lazySet orders preceding writes with the write being done as part of
>> lazySet, but does not guarantee that this write is globally visible before
>> next instruction is executed by the writing CPU.  In practical terms, on
>> x86/64, this compiles into a plain mov instruction with a compiler barrier
>> prevent prior stores from moving past the lazy one.  If this store were
>> done via volatile write or AtomicXXX.set(), then a cpu serializing
>> instruction would be added after the store (e.g. lock add $0, %rsp).
>> 
>> I'm guessing on non-TSO platforms lazySet implies a weaker release fence
>> instruction is emitted, but I don't know the details.
> 
> Okay, so it's simply a store release without a following barrier.  I
> guess all of this will be clarified as part of the JMM work.
> 

Yes. The different names also threw me off the scent for a while (need to look at the code).

Also, it does not help that we got the docs wrong on Unsafe.storeFence :-)

  https://bugs.openjdk.java.net/browse/JDK-8038978

Paul.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140908/3ab8af57/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 841 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140908/3ab8af57/attachment.bin>

From vyazelenko at yahoo.com  Mon Sep  8 11:08:29 2014
From: vyazelenko at yahoo.com (Dmitry Vyazelenko)
Date: Mon, 8 Sep 2014 08:08:29 -0700
Subject: [concurrency-interest] Unsafe + DirectBuffer concurrency bug?
Message-ID: <1410188909.78423.YahooMailNeo@web162206.mail.bf1.yahoo.com>

Hi all,

Please find standalone test that points to potential Unsafe/DirectBuffer issue. The test uses memory mapped file (DirectBuffer) and Unsafe to communicate between reader and writer. 
The data layout within the buffer:
<64 bytes padding><reader counter><64 bytes padding><writer counter><64 bytes padding><end of data flag><64 bytes padding>
Total number of bytes is 256.

The Writer thread keeps incrementing writerCounter until it reaches value 42. At which point it also writes endOfDataFlag and closes the FileChannel.

The Reader threads reads both readerCounter and writerCounter. If both have the same value and endOfDataFlag is set then it exits. Otherwise it increments readerCounter.

Below is the complete test:

package ipc_bug;

import sun.misc.Unsafe;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.Field;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;

class IpcBase implements AutoCloseable {
    private static final long PADDING = 64;
    static final long READER_COUNTER_OFFSET = PADDING;
    static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET + PADDING;
    static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
    static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;

    private static final Unsafe UNSAFE;
    static {
        try {
            final Field field = Unsafe.class.getDeclaredField("theUnsafe");
            field.setAccessible(true);
            UNSAFE = (Unsafe) field.get(null);
        } catch (final Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    private final FileChannel channel;
    private final MappedByteBuffer buffer;
    private final long baseAddress;

    public IpcBase(File file) throws IOException {
        channel = new RandomAccessFile(file, "rw").getChannel();
        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, TOTAL_LENGTH);
        baseAddress = ((sun.nio.ch.DirectBuffer) buffer).address();
    }

    final void putLongVolatile(long offset, long value) {
        UNSAFE.putLongVolatile(null, baseAddress + offset, value);
    }

    final long getLongVolatile(long offset) {
        return UNSAFE.getLongVolatile(null, baseAddress + offset);
    }

    @Override
    public void close() throws Exception {
        channel.close();
    }
}

class Writer extends IpcBase {
    public Writer(File file) throws IOException {
        super(file);
    }

    @Override
    public void close() throws Exception {
        putLongVolatile(FLAG_OFFSET, 1L);
        super.close();
    }

    long writerCounter;

    public long write() {
        writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
        putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
        return writerCounter;
    }
}

class Reader extends IpcBase {
    public Reader(File file) throws IOException {
        super(file);
    }

    long readCounter;
    long writeCounter;

    public boolean read() {
        readCounter = getLongVolatile(READER_COUNTER_OFFSET);
        writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
        if (readCounter == writeCounter && isFlagSet()) {
            return false;
        } else if (readCounter < writeCounter) {
            putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
        }
        return true;
    }

    private boolean isFlagSet() {
        return 1L == getLongVolatile(FLAG_OFFSET);
    }
}

public class IpcBugTest {
    public static void main(String[] args) throws Exception {
        File file = createFile();
        for (int i = 0; i < 50_000; i++) {
            testIPC(file);
        }
        System.out.println("NO BUG EXISTS! :-)");
    }

    private static File createFile() throws IOException {
        File file = File.createTempFile("ipc-", ".dat");
        file.deleteOnExit();
        return file;
    }

    private static void testIPC(final File file) throws Exception {
        writeZeros(file);

        final Writer writer = new Writer(file);
        Thread writerThread = new Thread("WRITER") {
            @Override
            public void run() {
                try {
                    try {
                        while (writer.write() < 42) ;
                    } finally {
                        writer.close();
                    }
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        };
        writerThread.start();

        final Reader reader = new Reader(file);
        Thread readerThread = new Thread("READER") {
            @Override
            public void run() {
                try {
                    try {
                        while (reader.read()) ;
                    } finally {
                        reader.close();
                    }
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        };
        readerThread.start();

        writerThread.join();
        readerThread.join();

        if (reader.readCounter != writer.writerCounter) {
            throw new Error("Reader exited prematurely: Reader.readCounter=" + reader.readCounter
                    + ", Reader.writeCounter=" + reader.writeCounter
                    + ", Writer.writeCounter=" + writer.writerCounter);
        }
    }

    private static void writeZeros(File file) throws IOException {
        Files.write(file.toPath(), new byte[(int) IpcBase.TOTAL_LENGTH], StandardOpenOption.WRITE);
    }
}

This test fails on my Windows 7 machine using JDK 7u67 and JDK 8u20 (older Intel i5). It also fails on Intel i7 IvyBridge machine that is running Ubuntu 14.04 on same JDKs. The failure is random, i.e. I've observed it fail on first iteration, 600, after 10K iterations etc. but it fails eventually on each run I tried. 

The failure message shown is:
    java.lang.Error: Reader exited prematurely: Reader.readCounter=0, Reader.writeCounter=0, Writer.writeCounter=42

In this case the reader thread observed both counters to have the same value 0 and endOfDataFlag is set. However writer thread writes endOfDataFlag after final writerCounter (i.e. 42) is being written.

I hope the bug is in my code. So please tell me how wrong I am! ;)
 
Best regards,
Dmitry Vyazelenko
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140908/bb93daf8/attachment-0001.html>

From jsampson at guidewire.com  Mon Sep  8 15:55:34 2014
From: jsampson at guidewire.com (Justin Sampson)
Date: Mon, 8 Sep 2014 19:55:34 +0000
Subject: [concurrency-interest] Happens Before guarantee in case of
 unsafe.putOrderedObject and corresponding nomal read of a variable
In-Reply-To: <CAHjP37FJhUzq4NGkDhmpOmyko9nDMunQpF__HYCkX-YAsWtXDw@mail.gmail.com>
References: <1409883462168-11255.post@n7.nabble.com>
	<5409997B.8080507@cs.oswego.edu>	<54099DE9.3000909@redhat.com>
	<54099E91.30607@cs.oswego.edu>	<54099F0E.8070303@redhat.com>
	<0FD072A166C6DC4C851F6115F37DDD2763EE5875@sm-ex-01-vm.guidewire.com>
	<CAHjP37FJhUzq4NGkDhmpOmyko9nDMunQpF__HYCkX-YAsWtXDw@mail.gmail.com>
Message-ID: <0FD072A166C6DC4C851F6115F37DDD2763EE5D45@sm-ex-01-vm.guidewire.com>

Vitaly Davidovich wrote:

> lazySet orders preceding writes with the write being done as part of
> lazySet, but does not guarantee that this write is globally visible
> before next instruction is executed by the writing CPU. ?In practical
> terms, on x86/64, this compiles into a plain mov instruction with a
> compiler barrier prevent prior stores from moving past the lazy one.
> If this store were done via volatile write or AtomicXXX.set(), then a
> cpu serializing instruction would be added after the store (e.g. lock
> add $0, %rsp).
>
> I'm guessing on non-TSO platforms lazySet implies a weaker release
> fence instruction is emitted, but I don't know the details.

Is there a simple translation of those implementation details into
happens-before semantics (perhaps like I tried to describe), or is it
best to always think in terms of reordering?

Thanks,
Justin



From mjpt777 at gmail.com  Mon Sep  8 16:16:04 2014
From: mjpt777 at gmail.com (Martin Thompson)
Date: Mon, 8 Sep 2014 21:16:04 +0100
Subject: [concurrency-interest]  Unsafe + DirectBuffer concurrency bug?
Message-ID: <CAChYfd8bv7hkUcJEq6iY-uSNDdFFLHciHDgHTS0dv8sV1DZ5dw@mail.gmail.com>

The version below fails for me every time but at different iteration values.

Regards,
Martin...

import sun.misc.Unsafe;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.Field;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;

class IpcBase implements AutoCloseable
{
    private static final long PADDING = 64;
    static final long READER_COUNTER_OFFSET = PADDING;
    static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET +
PADDING;
    static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
    static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;

    private static final Unsafe UNSAFE;

    static
    {
        try
        {
            final Field field = Unsafe.class.getDeclaredField("theUnsafe");
            field.setAccessible(true);
            UNSAFE = (Unsafe)field.get(null);
        }
        catch (final Exception ex)
        {
            throw new RuntimeException(ex);
        }
    }

    private final FileChannel channel;
    private final MappedByteBuffer buffer; // hold reference to prevent GC
    private final long baseAddress;

    public IpcBase(final File file) throws IOException
    {
        channel = new RandomAccessFile(file, "rw").getChannel();
        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0,
TOTAL_LENGTH);
        baseAddress = ((sun.nio.ch.DirectBuffer)buffer).address();
    }

    final void putLongVolatile(final long offset, final long value)
    {
        UNSAFE.putLongVolatile(null, baseAddress + offset, value);
    }

    final long getLongVolatile(final long offset)
    {
        return UNSAFE.getLongVolatile(null, baseAddress + offset);
    }

    @Override
    public void close() throws Exception
    {
        channel.close();
    }
}

class Writer extends IpcBase
{
    long writerCounter;

    public Writer(final File file) throws IOException
    {
        super(file);
    }

    @Override
    public void close() throws Exception
    {
        putLongVolatile(FLAG_OFFSET, 1L);
        super.close();
    }

    public long write()
    {
        writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
        putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
        return writerCounter;
    }
}

class Reader extends IpcBase
{
    long readCounter;
    long writeCounter;

    public Reader(final File file) throws IOException
    {
        super(file);
    }

    public boolean read()
    {
        readCounter = getLongVolatile(READER_COUNTER_OFFSET);
        writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
        if (readCounter == writeCounter && isFlagSet())
        {
            return false;
        }
        else if (readCounter < writeCounter)
        {
            putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
        }

        return true;
    }

    private boolean isFlagSet()
    {
        return 1L == getLongVolatile(FLAG_OFFSET);
    }
}

public class IpcBugTest
{
    public static int iteration = 0;

    public static void main(String[] args) throws Exception
    {
        final File file = createFile();

        for (int i = 0; i < 1_000_000; i++)
        {
            iteration = i;
            testIpc(file);
        }

        System.out.println("NO BUG HERE! :-)");
    }

    private static File createFile() throws IOException
    {
        final File file = File.createTempFile("ipc-", ".dat");
        file.deleteOnExit();

        return file;
    }

    private static void testIpc(final File file) throws Exception
    {
        writeZeros(file);

        final Reader reader = new Reader(file);
        final Thread readerThread = new Thread("READER")
        {
            @Override
            public void run()
            {
                try
                {
                    try
                    {
                        while (reader.read())
                        {
                            // busy spin
                        }
                    }
                    finally
                    {
                        reader.close();
                    }
                }
                catch (Exception ex)
                {
                    ex.printStackTrace();
                }
            }
        };
        readerThread.start();

        final Writer writer = new Writer(file);
        final Thread writerThread = new Thread("WRITER")
        {
            @Override
            public void run()
            {
                try
                {
                    try
                    {
                        while (writer.write() < 42)
                        {
                            // busy spin
                        }
                    }
                    finally
                    {
                        writer.close();
                    }
                }
                catch (Exception ex)
                {
                    ex.printStackTrace();
                }
            }
        };
        writerThread.start();

        writerThread.join();
        readerThread.join();

        if (reader.readCounter != writer.writerCounter)
        {
            throw new Error(
                "Reader exited prematurely: Reader.readCounter=" +
reader.readCounter +
                ", Reader.writeCounter=" + reader.writeCounter +
                ", Writer.writeCounter=" + writer.writerCounter +
                ", iteration=" + iteration);
        }
    }

    private static void writeZeros(final File file) throws IOException
    {
        Files.write(file.toPath(), new byte[(int)IpcBase.TOTAL_LENGTH],
StandardOpenOption.WRITE);
    }
}

Date: Mon, 8 Sep 2014 08:08:29 -0700
> From: Dmitry Vyazelenko <vyazelenko at yahoo.com>
> To: "concurrency-interest at cs.oswego.edu"
>         <concurrency-interest at cs.oswego.edu>
> Subject: [concurrency-interest] Unsafe + DirectBuffer concurrency bug?
> Message-ID:
>         <1410188909.78423.YahooMailNeo at web162206.mail.bf1.yahoo.com>
> Content-Type: text/plain; charset="utf-8"
>
> Hi all,
>
> Please find standalone test that points to potential Unsafe/DirectBuffer
> issue. The test uses memory mapped file (DirectBuffer) and Unsafe to
> communicate between reader and writer.
> The data layout within the buffer:
> <64 bytes padding><reader counter><64 bytes padding><writer counter><64
> bytes padding><end of data flag><64 bytes padding>
> Total number of bytes is 256.
>
> The Writer thread keeps incrementing writerCounter until it reaches value
> 42. At which point it also writes endOfDataFlag and closes the FileChannel.
>
> The Reader threads reads both readerCounter and writerCounter. If both
> have the same value and endOfDataFlag is set then it exits. Otherwise it
> increments readerCounter.
>
> Below is the complete test:
>
> package ipc_bug;
>
> import sun.misc.Unsafe;
>
> import java.io.File;
> import java.io.IOException;
> import java.io.RandomAccessFile;
> import java.lang.reflect.Field;
> import java.nio.MappedByteBuffer;
> import java.nio.channels.FileChannel;
> import java.nio.file.Files;
> import java.nio.file.StandardOpenOption;
>
> class IpcBase implements AutoCloseable {
>     private static final long PADDING = 64;
>     static final long READER_COUNTER_OFFSET = PADDING;
>     static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET +
> PADDING;
>     static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
>     static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;
>
>     private static final Unsafe UNSAFE;
>     static {
>         try {
>             final Field field = Unsafe.class.getDeclaredField("theUnsafe");
>             field.setAccessible(true);
>             UNSAFE = (Unsafe) field.get(null);
>         } catch (final Exception ex) {
>             throw new RuntimeException(ex);
>         }
>     }
>
>     private final FileChannel channel;
>     private final MappedByteBuffer buffer;
>     private final long baseAddress;
>
>     public IpcBase(File file) throws IOException {
>         channel = new RandomAccessFile(file, "rw").getChannel();
>         buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0,
> TOTAL_LENGTH);
>         baseAddress = ((sun.nio.ch.DirectBuffer) buffer).address();
>     }
>
>     final void putLongVolatile(long offset, long value) {
>         UNSAFE.putLongVolatile(null, baseAddress + offset, value);
>     }
>
>     final long getLongVolatile(long offset) {
>         return UNSAFE.getLongVolatile(null, baseAddress + offset);
>     }
>
>     @Override
>     public void close() throws Exception {
>         channel.close();
>     }
> }
>
> class Writer extends IpcBase {
>     public Writer(File file) throws IOException {
>         super(file);
>     }
>
>     @Override
>     public void close() throws Exception {
>         putLongVolatile(FLAG_OFFSET, 1L);
>         super.close();
>     }
>
>     long writerCounter;
>
>     public long write() {
>         writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>         putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
>         return writerCounter;
>     }
> }
>
> class Reader extends IpcBase {
>     public Reader(File file) throws IOException {
>         super(file);
>     }
>
>     long readCounter;
>     long writeCounter;
>
>     public boolean read() {
>         readCounter = getLongVolatile(READER_COUNTER_OFFSET);
>         writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>         if (readCounter == writeCounter && isFlagSet()) {
>             return false;
>         } else if (readCounter < writeCounter) {
>             putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
>         }
>         return true;
>     }
>
>     private boolean isFlagSet() {
>         return 1L == getLongVolatile(FLAG_OFFSET);
>     }
> }
>
> public class IpcBugTest {
>     public static void main(String[] args) throws Exception {
>         File file = createFile();
>         for (int i = 0; i < 50_000; i++) {
>             testIPC(file);
>         }
>         System.out.println("NO BUG EXISTS! :-)");
>     }
>
>     private static File createFile() throws IOException {
>         File file = File.createTempFile("ipc-", ".dat");
>         file.deleteOnExit();
>         return file;
>     }
>
>     private static void testIPC(final File file) throws Exception {
>         writeZeros(file);
>
>         final Writer writer = new Writer(file);
>         Thread writerThread = new Thread("WRITER") {
>             @Override
>             public void run() {
>                 try {
>                     try {
>                         while (writer.write() < 42) ;
>                     } finally {
>                         writer.close();
>                     }
>                 } catch (Exception ex) {
>                     ex.printStackTrace();
>                 }
>             }
>         };
>         writerThread.start();
>
>         final Reader reader = new Reader(file);
>         Thread readerThread = new Thread("READER") {
>             @Override
>             public void run() {
>                 try {
>                     try {
>                         while (reader.read()) ;
>                     } finally {
>                         reader.close();
>                     }
>                 } catch (Exception ex) {
>                     ex.printStackTrace();
>                 }
>             }
>         };
>         readerThread.start();
>
>         writerThread.join();
>         readerThread.join();
>
>         if (reader.readCounter != writer.writerCounter) {
>             throw new Error("Reader exited prematurely:
> Reader.readCounter=" + reader.readCounter
>                     + ", Reader.writeCounter=" + reader.writeCounter
>                     + ", Writer.writeCounter=" + writer.writerCounter);
>         }
>     }
>
>     private static void writeZeros(File file) throws IOException {
>         Files.write(file.toPath(), new byte[(int) IpcBase.TOTAL_LENGTH],
> StandardOpenOption.WRITE);
>     }
> }
>
> This test fails on my Windows 7 machine using JDK 7u67 and JDK 8u20 (older
> Intel i5). It also fails on Intel i7 IvyBridge machine that is running
> Ubuntu 14.04 on same JDKs. The failure is random, i.e. I've observed it
> fail on first iteration, 600, after 10K iterations etc. but it fails
> eventually on each run I tried.
>
> The failure message shown is:
>     java.lang.Error: Reader exited prematurely: Reader.readCounter=0,
> Reader.writeCounter=0, Writer.writeCounter=42
>
> In this case the reader thread observed both counters to have the same
> value 0 and endOfDataFlag is set. However writer thread writes
> endOfDataFlag after final writerCounter (i.e. 42) is being written.
>
> I hope the bug is in my code. So please tell me how wrong I am! ;)
>
> Best regards,
> Dmitry Vyazelenko
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140908/e6a41d82/attachment-0001.html>

From vitalyd at gmail.com  Mon Sep  8 16:23:03 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 8 Sep 2014 16:23:03 -0400
Subject: [concurrency-interest] Happens Before guarantee in case of
 unsafe.putOrderedObject and corresponding nomal read of a variable
In-Reply-To: <0FD072A166C6DC4C851F6115F37DDD2763EE5D45@sm-ex-01-vm.guidewire.com>
References: <1409883462168-11255.post@n7.nabble.com>
	<5409997B.8080507@cs.oswego.edu> <54099DE9.3000909@redhat.com>
	<54099E91.30607@cs.oswego.edu> <54099F0E.8070303@redhat.com>
	<0FD072A166C6DC4C851F6115F37DDD2763EE5875@sm-ex-01-vm.guidewire.com>
	<CAHjP37FJhUzq4NGkDhmpOmyko9nDMunQpF__HYCkX-YAsWtXDw@mail.gmail.com>
	<0FD072A166C6DC4C851F6115F37DDD2763EE5D45@sm-ex-01-vm.guidewire.com>
Message-ID: <CAHjP37EfQQ5n-eTw=+_zgCvL2Q0QBewBHMwLpFwY7esLdUc2Dg@mail.gmail.com>

lazySet/ordered writes are outside JMM as of today (next revision is
addressing this I believe) so it's perhaps a bit disingenuous to use JMM
terms to translate.  However, with that caveat, your description seems fair
to me.

Sent from my phone
On Sep 8, 2014 3:55 PM, "Justin Sampson" <jsampson at guidewire.com> wrote:

> Vitaly Davidovich wrote:
>
> > lazySet orders preceding writes with the write being done as part of
> > lazySet, but does not guarantee that this write is globally visible
> > before next instruction is executed by the writing CPU.  In practical
> > terms, on x86/64, this compiles into a plain mov instruction with a
> > compiler barrier prevent prior stores from moving past the lazy one.
> > If this store were done via volatile write or AtomicXXX.set(), then a
> > cpu serializing instruction would be added after the store (e.g. lock
> > add $0, %rsp).
> >
> > I'm guessing on non-TSO platforms lazySet implies a weaker release
> > fence instruction is emitted, but I don't know the details.
>
> Is there a simple translation of those implementation details into
> happens-before semantics (perhaps like I tried to describe), or is it
> best to always think in terms of reordering?
>
> Thanks,
> Justin
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140908/eefe3fc4/attachment.html>

From nitsanw at yahoo.com  Mon Sep  8 16:53:04 2014
From: nitsanw at yahoo.com (Nitsan Wakart)
Date: Mon, 8 Sep 2014 13:53:04 -0700
Subject: [concurrency-interest] Unsafe + DirectBuffer concurrency bug?
In-Reply-To: <CAChYfd8bv7hkUcJEq6iY-uSNDdFFLHciHDgHTS0dv8sV1DZ5dw@mail.gmail.com>
References: <CAChYfd8bv7hkUcJEq6iY-uSNDdFFLHciHDgHTS0dv8sV1DZ5dw@mail.gmail.com>
Message-ID: <1410209584.32996.YahooMailNeo@web120701.mail.ne1.yahoo.com>

1    readCounter = getLongVolatile(READER_COUNTER_OFFSET);
2      writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
3      if (readCounter == writeCounter && isFlagSet()) {
4           return false;
5       } else if (readCounter < writeCounter) {
6           putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
7       }

It is possible for 1,2 to execute and see 0, then have the writer thread blaze through it's loop and set the flag to 1before you hit 3.
The HB relationship assumption is in the wrong order, you should read flag first and flag visibility necessitates the counter visibility.


On Monday, September 8, 2014 10:23 PM, Martin Thompson <mjpt777 at gmail.com> wrote:
 


The version below fails for me every time but at different iteration values.

Regards,
Martin...


import sun.misc.Unsafe;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.Field;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;

class IpcBase implements AutoCloseable
{
    private static final long PADDING = 64;
    static final long READER_COUNTER_OFFSET = PADDING;
    static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET + PADDING;
    static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
    static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;

    private static final Unsafe UNSAFE;

    static
    {
        try
        {
            final Field field = Unsafe.class.getDeclaredField("theUnsafe");
            field.setAccessible(true);
            UNSAFE = (Unsafe)field.get(null);
        }
        catch (final Exception ex)
        {
            throw new RuntimeException(ex);
        }
    }

    private final FileChannel channel;
    private final MappedByteBuffer buffer; // hold reference to prevent GC
    private final long baseAddress;

    public IpcBase(final File file) throws IOException
    {
        channel = new RandomAccessFile(file, "rw").getChannel();
        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, TOTAL_LENGTH);
        baseAddress = ((sun.nio.ch.DirectBuffer)buffer).address();
    }

    final void putLongVolatile(final long offset, final long value)
    {
        UNSAFE.putLongVolatile(null, baseAddress + offset, value);
    }

    final long getLongVolatile(final long offset)
    {
        return UNSAFE.getLongVolatile(null, baseAddress + offset);
    }

    @Override
    public void close() throws Exception
    {
        channel.close();
    }
}

class Writer extends IpcBase
{
    long writerCounter;

    public Writer(final File file) throws IOException
    {
        super(file);
    }

    @Override
    public void close() throws Exception
    {
        putLongVolatile(FLAG_OFFSET, 1L);
        super.close();
    }

    public long write()
    {
        writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
        putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
        return writerCounter;
    }
}

class Reader extends IpcBase
{
    long readCounter;
    long writeCounter;

    public Reader(final File file) throws IOException
    {
        super(file);
    }

    public boolean read()
    {
        readCounter = getLongVolatile(READER_COUNTER_OFFSET);
        writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
        if (readCounter == writeCounter && isFlagSet())
        {
            return false;
        }
        else if (readCounter < writeCounter)
        {
            putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
        }

        return true;
    }

    private boolean isFlagSet()
    {
        return 1L == getLongVolatile(FLAG_OFFSET);
    }
}

public class IpcBugTest
{
    public static int iteration = 0;

    public static void main(String[] args) throws Exception
    {
        final File file = createFile();

        for (int i = 0; i < 1_000_000; i++)
        {
            iteration = i;
            testIpc(file);
        }

        System.out.println("NO BUG HERE! :-)");
    }

    private static File createFile() throws IOException
    {
        final File file = File.createTempFile("ipc-", ".dat");
        file.deleteOnExit();

        return file;
    }

    private static void testIpc(final File file) throws Exception
    {
        writeZeros(file);

        final Reader reader = new Reader(file);
        final Thread readerThread = new Thread("READER")
        {
            @Override
            public void run()
            {
                try
                {
                    try
                    {
                        while (reader.read())
                        {
                            // busy spin
                        }
                    }
                    finally
                    {
                        reader.close();
                    }
                }
                catch (Exception ex)
                {
                    ex.printStackTrace();
                }
            }
        };
        readerThread.start();

        final Writer writer = new Writer(file);
        final Thread writerThread = new Thread("WRITER")
        {
            @Override
            public void run()
            {
                try
                {
                    try
                    {
                        while (writer.write() < 42)
                        {
                            // busy spin
                        }
                    }
                    finally
                    {
                        writer.close();
                    }
                }
                catch (Exception ex)
                {
                    ex.printStackTrace();
                }
            }
        };
        writerThread.start();

        writerThread.join();
        readerThread.join();

        if (reader.readCounter != writer.writerCounter)
        {
            throw new Error(
                "Reader exited prematurely: Reader.readCounter=" + reader.readCounter +
                ", Reader.writeCounter=" + reader.writeCounter +
                ", Writer.writeCounter=" + writer.writerCounter +
                ", iteration=" + iteration);
        }
    }

    private static void writeZeros(final File file) throws IOException
    {
        Files.write(file.toPath(), new byte[(int)IpcBase.TOTAL_LENGTH], StandardOpenOption.WRITE);
    }
}


Date: Mon, 8 Sep 2014 08:08:29 -0700
>From: Dmitry Vyazelenko <vyazelenko at yahoo.com>
>To: "concurrency-interest at cs.oswego.edu"
>        <concurrency-interest at cs.oswego.edu>
>Subject: [concurrency-interest] Unsafe + DirectBuffer concurrency bug?
>Message-ID:
>        <1410188909.78423.YahooMailNeo at web162206.mail.bf1.yahoo.com>
>Content-Type: text/plain; charset="utf-8"
>
>Hi all,
>
>Please find standalone test that points to potential Unsafe/DirectBuffer issue. The test uses memory mapped file (DirectBuffer) and Unsafe to communicate between reader and writer.
>The data layout within the buffer:
><64 bytes padding><reader counter><64 bytes padding><writer counter><64 bytes padding><end of data flag><64 bytes padding>
>Total number of bytes is 256.
>
>The Writer thread keeps incrementing writerCounter until it reaches value 42. At which point it also writes endOfDataFlag and closes the FileChannel.
>
>The Reader threads reads both readerCounter and writerCounter. If both have the same value and endOfDataFlag is set then it exits. Otherwise it increments readerCounter.
>
>Below is the complete test:
>
>package ipc_bug;
>
>import sun.misc.Unsafe;
>
>import java.io.File;
>import java.io.IOException;
>import java.io.RandomAccessFile;
>import java.lang.reflect.Field;
>import java.nio.MappedByteBuffer;
>import java.nio.channels.FileChannel;
>import java.nio.file.Files;
>import java.nio.file.StandardOpenOption;
>
>class IpcBase implements AutoCloseable {
>    private static final long PADDING = 64;
>    static final long READER_COUNTER_OFFSET = PADDING;
>    static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET + PADDING;
>    static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
>    static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;
>
>    private static final Unsafe UNSAFE;
>    static {
>        try {
>            final Field field = Unsafe.class.getDeclaredField("theUnsafe");
>            field.setAccessible(true);
>            UNSAFE = (Unsafe) field.get(null);
>        } catch (final Exception ex) {
>            throw new RuntimeException(ex);
>        }
>    }
>
>    private final FileChannel channel;
>    private final MappedByteBuffer buffer;
>    private final long baseAddress;
>
>    public IpcBase(File file) throws IOException {
>        channel = new RandomAccessFile(file, "rw").getChannel();
>        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, TOTAL_LENGTH);
>        baseAddress = ((sun.nio.ch.DirectBuffer) buffer).address();
>    }
>
>    final void putLongVolatile(long offset, long value) {
>        UNSAFE.putLongVolatile(null, baseAddress + offset, value);
>    }
>
>    final long getLongVolatile(long offset) {
>        return UNSAFE.getLongVolatile(null, baseAddress + offset);
>    }
>
>    @Override
>    public void close() throws Exception {
>        channel.close();
>    }
>}
>
>class Writer extends IpcBase {
>    public Writer(File file) throws IOException {
>        super(file);
>    }
>
>    @Override
>    public void close() throws Exception {
>        putLongVolatile(FLAG_OFFSET, 1L);
>        super.close();
>    }
>
>    long writerCounter;
>
>    public long write() {
>        writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>        putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
>        return writerCounter;
>    }
>}
>
>class Reader extends IpcBase {
>    public Reader(File file) throws IOException {
>        super(file);
>    }
>
>    long readCounter;
>    long writeCounter;
>
>    public boolean read() {
>        readCounter = getLongVolatile(READER_COUNTER_OFFSET);
>        writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>        if (readCounter == writeCounter && isFlagSet()) {
>            return false;
>        } else if (readCounter < writeCounter) {
>            putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
>        }
>        return true;
>    }
>
>    private boolean isFlagSet() {
>        return 1L == getLongVolatile(FLAG_OFFSET);
>    }
>}
>
>public class IpcBugTest {
>    public static void main(String[] args) throws Exception {
>        File file = createFile();
>        for (int i = 0; i < 50_000; i++) {
>            testIPC(file);
>        }
>        System.out.println("NO BUG EXISTS! :-)");
>    }
>
>    private static File createFile() throws IOException {
>        File file = File.createTempFile("ipc-", ".dat");
>        file.deleteOnExit();
>        return file;
>    }
>
>    private static void testIPC(final File file) throws Exception {
>        writeZeros(file);
>
>        final Writer writer = new Writer(file);
>        Thread writerThread = new Thread("WRITER") {
>            @Override
>            public void run() {
>                try {
>                    try {
>                        while (writer.write() < 42) ;
>                    } finally {
>                        writer.close();
>                    }
>                } catch (Exception ex) {
>                    ex.printStackTrace();
>                }
>            }
>        };
>        writerThread.start();
>
>        final Reader reader = new Reader(file);
>        Thread readerThread = new Thread("READER") {
>            @Override
>            public void run() {
>                try {
>                    try {
>                        while (reader.read()) ;
>                    } finally {
>                        reader.close();
>                    }
>                } catch (Exception ex) {
>                    ex.printStackTrace();
>                }
>            }
>        };
>        readerThread.start();
>
>        writerThread.join();
>        readerThread.join();
>
>        if (reader.readCounter != writer.writerCounter) {
>            throw new Error("Reader exited prematurely: Reader.readCounter=" + reader.readCounter
>                    + ", Reader.writeCounter=" + reader.writeCounter
>                    + ", Writer.writeCounter=" + writer.writerCounter);
>        }
>    }
>
>    private static void writeZeros(File file) throws IOException {
>        Files.write(file.toPath(), new byte[(int) IpcBase.TOTAL_LENGTH], StandardOpenOption.WRITE);
>    }
>}
>
>This test fails on my Windows 7 machine using JDK 7u67 and JDK 8u20 (older Intel i5). It also fails on Intel i7 IvyBridge machine that is running Ubuntu 14.04 on same JDKs. The failure is random, i.e. I've observed it fail on first iteration, 600, after 10K iterations etc. but it fails eventually on each run I tried.
>
>The failure message shown is:
>    java.lang.Error: Reader exited prematurely: Reader.readCounter=0, Reader.writeCounter=0, Writer.writeCounter=42
>
>In this case the reader thread observed both counters to have the same value 0 and endOfDataFlag is set. However writer thread writes endOfDataFlag after final writerCounter (i.e. 42) is being written.
>
>I hope the bug is in my code. So please tell me how wrong I am! ;)
>
>Best regards,
>Dmitry Vyazelenko
>
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140908/ff343fc5/attachment-0001.html>

From vitalyd at gmail.com  Mon Sep  8 17:10:53 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 8 Sep 2014 17:10:53 -0400
Subject: [concurrency-interest] Unsafe + DirectBuffer concurrency bug?
In-Reply-To: <CAChYfd8bv7hkUcJEq6iY-uSNDdFFLHciHDgHTS0dv8sV1DZ5dw@mail.gmail.com>
References: <CAChYfd8bv7hkUcJEq6iY-uSNDdFFLHciHDgHTS0dv8sV1DZ5dw@mail.gmail.com>
Message-ID: <CAHjP37GqbqXC=F-BMW19yHW60zC2bvKwfji2z1_W8ooA31buzQ@mail.gmail.com>

Just to rule some things out, what happens if you fsync the file as part of
writeZeros?

On Mon, Sep 8, 2014 at 4:16 PM, Martin Thompson <mjpt777 at gmail.com> wrote:

> The version below fails for me every time but at different iteration
> values.
>
> Regards,
> Martin...
>
> import sun.misc.Unsafe;
>
> import java.io.File;
> import java.io.IOException;
> import java.io.RandomAccessFile;
> import java.lang.reflect.Field;
> import java.nio.MappedByteBuffer;
> import java.nio.channels.FileChannel;
> import java.nio.file.Files;
> import java.nio.file.StandardOpenOption;
>
> class IpcBase implements AutoCloseable
> {
>     private static final long PADDING = 64;
>     static final long READER_COUNTER_OFFSET = PADDING;
>     static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET +
> PADDING;
>     static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
>     static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;
>
>     private static final Unsafe UNSAFE;
>
>     static
>     {
>         try
>         {
>             final Field field = Unsafe.class.getDeclaredField("theUnsafe");
>             field.setAccessible(true);
>             UNSAFE = (Unsafe)field.get(null);
>         }
>         catch (final Exception ex)
>         {
>             throw new RuntimeException(ex);
>         }
>     }
>
>     private final FileChannel channel;
>     private final MappedByteBuffer buffer; // hold reference to prevent GC
>     private final long baseAddress;
>
>     public IpcBase(final File file) throws IOException
>     {
>         channel = new RandomAccessFile(file, "rw").getChannel();
>         buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0,
> TOTAL_LENGTH);
>         baseAddress = ((sun.nio.ch.DirectBuffer)buffer).address();
>     }
>
>     final void putLongVolatile(final long offset, final long value)
>     {
>         UNSAFE.putLongVolatile(null, baseAddress + offset, value);
>     }
>
>     final long getLongVolatile(final long offset)
>     {
>         return UNSAFE.getLongVolatile(null, baseAddress + offset);
>     }
>
>     @Override
>     public void close() throws Exception
>     {
>         channel.close();
>     }
> }
>
> class Writer extends IpcBase
> {
>     long writerCounter;
>
>     public Writer(final File file) throws IOException
>     {
>         super(file);
>     }
>
>     @Override
>     public void close() throws Exception
>     {
>         putLongVolatile(FLAG_OFFSET, 1L);
>         super.close();
>     }
>
>     public long write()
>     {
>         writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>         putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
>         return writerCounter;
>     }
> }
>
> class Reader extends IpcBase
> {
>     long readCounter;
>     long writeCounter;
>
>     public Reader(final File file) throws IOException
>     {
>         super(file);
>     }
>
>     public boolean read()
>     {
>         readCounter = getLongVolatile(READER_COUNTER_OFFSET);
>         writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>         if (readCounter == writeCounter && isFlagSet())
>         {
>             return false;
>         }
>         else if (readCounter < writeCounter)
>         {
>             putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
>         }
>
>         return true;
>     }
>
>     private boolean isFlagSet()
>     {
>         return 1L == getLongVolatile(FLAG_OFFSET);
>     }
> }
>
> public class IpcBugTest
> {
>     public static int iteration = 0;
>
>     public static void main(String[] args) throws Exception
>     {
>         final File file = createFile();
>
>         for (int i = 0; i < 1_000_000; i++)
>         {
>             iteration = i;
>             testIpc(file);
>         }
>
>         System.out.println("NO BUG HERE! :-)");
>     }
>
>     private static File createFile() throws IOException
>     {
>         final File file = File.createTempFile("ipc-", ".dat");
>         file.deleteOnExit();
>
>         return file;
>     }
>
>     private static void testIpc(final File file) throws Exception
>     {
>         writeZeros(file);
>
>         final Reader reader = new Reader(file);
>         final Thread readerThread = new Thread("READER")
>         {
>             @Override
>             public void run()
>             {
>                 try
>                 {
>                     try
>                     {
>                         while (reader.read())
>                         {
>                             // busy spin
>                         }
>                     }
>                     finally
>                     {
>                         reader.close();
>                     }
>                 }
>                 catch (Exception ex)
>                 {
>                     ex.printStackTrace();
>                 }
>             }
>         };
>         readerThread.start();
>
>         final Writer writer = new Writer(file);
>         final Thread writerThread = new Thread("WRITER")
>         {
>             @Override
>             public void run()
>             {
>                 try
>                 {
>                     try
>                     {
>                         while (writer.write() < 42)
>                         {
>                             // busy spin
>                         }
>                     }
>                     finally
>                     {
>                         writer.close();
>                     }
>                 }
>                 catch (Exception ex)
>                 {
>                     ex.printStackTrace();
>                 }
>             }
>         };
>         writerThread.start();
>
>         writerThread.join();
>         readerThread.join();
>
>         if (reader.readCounter != writer.writerCounter)
>         {
>             throw new Error(
>                 "Reader exited prematurely: Reader.readCounter=" +
> reader.readCounter +
>                 ", Reader.writeCounter=" + reader.writeCounter +
>                 ", Writer.writeCounter=" + writer.writerCounter +
>                 ", iteration=" + iteration);
>         }
>     }
>
>     private static void writeZeros(final File file) throws IOException
>     {
>         Files.write(file.toPath(), new byte[(int)IpcBase.TOTAL_LENGTH],
> StandardOpenOption.WRITE);
>     }
> }
>
> Date: Mon, 8 Sep 2014 08:08:29 -0700
>> From: Dmitry Vyazelenko <vyazelenko at yahoo.com>
>> To: "concurrency-interest at cs.oswego.edu"
>>         <concurrency-interest at cs.oswego.edu>
>> Subject: [concurrency-interest] Unsafe + DirectBuffer concurrency bug?
>> Message-ID:
>>         <1410188909.78423.YahooMailNeo at web162206.mail.bf1.yahoo.com>
>> Content-Type: text/plain; charset="utf-8"
>>
>> Hi all,
>>
>> Please find standalone test that points to potential Unsafe/DirectBuffer
>> issue. The test uses memory mapped file (DirectBuffer) and Unsafe to
>> communicate between reader and writer.
>> The data layout within the buffer:
>> <64 bytes padding><reader counter><64 bytes padding><writer counter><64
>> bytes padding><end of data flag><64 bytes padding>
>> Total number of bytes is 256.
>>
>> The Writer thread keeps incrementing writerCounter until it reaches value
>> 42. At which point it also writes endOfDataFlag and closes the FileChannel.
>>
>> The Reader threads reads both readerCounter and writerCounter. If both
>> have the same value and endOfDataFlag is set then it exits. Otherwise it
>> increments readerCounter.
>>
>> Below is the complete test:
>>
>> package ipc_bug;
>>
>> import sun.misc.Unsafe;
>>
>> import java.io.File;
>> import java.io.IOException;
>> import java.io.RandomAccessFile;
>> import java.lang.reflect.Field;
>> import java.nio.MappedByteBuffer;
>> import java.nio.channels.FileChannel;
>> import java.nio.file.Files;
>> import java.nio.file.StandardOpenOption;
>>
>> class IpcBase implements AutoCloseable {
>>     private static final long PADDING = 64;
>>     static final long READER_COUNTER_OFFSET = PADDING;
>>     static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET +
>> PADDING;
>>     static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
>>     static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;
>>
>>     private static final Unsafe UNSAFE;
>>     static {
>>         try {
>>             final Field field =
>> Unsafe.class.getDeclaredField("theUnsafe");
>>             field.setAccessible(true);
>>             UNSAFE = (Unsafe) field.get(null);
>>         } catch (final Exception ex) {
>>             throw new RuntimeException(ex);
>>         }
>>     }
>>
>>     private final FileChannel channel;
>>     private final MappedByteBuffer buffer;
>>     private final long baseAddress;
>>
>>     public IpcBase(File file) throws IOException {
>>         channel = new RandomAccessFile(file, "rw").getChannel();
>>         buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0,
>> TOTAL_LENGTH);
>>         baseAddress = ((sun.nio.ch.DirectBuffer) buffer).address();
>>     }
>>
>>     final void putLongVolatile(long offset, long value) {
>>         UNSAFE.putLongVolatile(null, baseAddress + offset, value);
>>     }
>>
>>     final long getLongVolatile(long offset) {
>>         return UNSAFE.getLongVolatile(null, baseAddress + offset);
>>     }
>>
>>     @Override
>>     public void close() throws Exception {
>>         channel.close();
>>     }
>> }
>>
>> class Writer extends IpcBase {
>>     public Writer(File file) throws IOException {
>>         super(file);
>>     }
>>
>>     @Override
>>     public void close() throws Exception {
>>         putLongVolatile(FLAG_OFFSET, 1L);
>>         super.close();
>>     }
>>
>>     long writerCounter;
>>
>>     public long write() {
>>         writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>>         putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
>>         return writerCounter;
>>     }
>> }
>>
>> class Reader extends IpcBase {
>>     public Reader(File file) throws IOException {
>>         super(file);
>>     }
>>
>>     long readCounter;
>>     long writeCounter;
>>
>>     public boolean read() {
>>         readCounter = getLongVolatile(READER_COUNTER_OFFSET);
>>         writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>>         if (readCounter == writeCounter && isFlagSet()) {
>>             return false;
>>         } else if (readCounter < writeCounter) {
>>             putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
>>         }
>>         return true;
>>     }
>>
>>     private boolean isFlagSet() {
>>         return 1L == getLongVolatile(FLAG_OFFSET);
>>     }
>> }
>>
>> public class IpcBugTest {
>>     public static void main(String[] args) throws Exception {
>>         File file = createFile();
>>         for (int i = 0; i < 50_000; i++) {
>>             testIPC(file);
>>         }
>>         System.out.println("NO BUG EXISTS! :-)");
>>     }
>>
>>     private static File createFile() throws IOException {
>>         File file = File.createTempFile("ipc-", ".dat");
>>         file.deleteOnExit();
>>         return file;
>>     }
>>
>>     private static void testIPC(final File file) throws Exception {
>>         writeZeros(file);
>>
>>         final Writer writer = new Writer(file);
>>         Thread writerThread = new Thread("WRITER") {
>>             @Override
>>             public void run() {
>>                 try {
>>                     try {
>>                         while (writer.write() < 42) ;
>>                     } finally {
>>                         writer.close();
>>                     }
>>                 } catch (Exception ex) {
>>                     ex.printStackTrace();
>>                 }
>>             }
>>         };
>>         writerThread.start();
>>
>>         final Reader reader = new Reader(file);
>>         Thread readerThread = new Thread("READER") {
>>             @Override
>>             public void run() {
>>                 try {
>>                     try {
>>                         while (reader.read()) ;
>>                     } finally {
>>                         reader.close();
>>                     }
>>                 } catch (Exception ex) {
>>                     ex.printStackTrace();
>>                 }
>>             }
>>         };
>>         readerThread.start();
>>
>>         writerThread.join();
>>         readerThread.join();
>>
>>         if (reader.readCounter != writer.writerCounter) {
>>             throw new Error("Reader exited prematurely:
>> Reader.readCounter=" + reader.readCounter
>>                     + ", Reader.writeCounter=" + reader.writeCounter
>>                     + ", Writer.writeCounter=" + writer.writerCounter);
>>         }
>>     }
>>
>>     private static void writeZeros(File file) throws IOException {
>>         Files.write(file.toPath(), new byte[(int) IpcBase.TOTAL_LENGTH],
>> StandardOpenOption.WRITE);
>>     }
>> }
>>
>> This test fails on my Windows 7 machine using JDK 7u67 and JDK 8u20
>> (older Intel i5). It also fails on Intel i7 IvyBridge machine that is
>> running Ubuntu 14.04 on same JDKs. The failure is random, i.e. I've
>> observed it fail on first iteration, 600, after 10K iterations etc. but it
>> fails eventually on each run I tried.
>>
>> The failure message shown is:
>>     java.lang.Error: Reader exited prematurely: Reader.readCounter=0,
>> Reader.writeCounter=0, Writer.writeCounter=42
>>
>> In this case the reader thread observed both counters to have the same
>> value 0 and endOfDataFlag is set. However writer thread writes
>> endOfDataFlag after final writerCounter (i.e. 42) is being written.
>>
>> I hope the bug is in my code. So please tell me how wrong I am! ;)
>>
>> Best regards,
>> Dmitry Vyazelenko
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140908/98e77cba/attachment-0001.html>

From mjpt777 at gmail.com  Mon Sep  8 17:17:47 2014
From: mjpt777 at gmail.com (Martin Thompson)
Date: Mon, 8 Sep 2014 22:17:47 +0100
Subject: [concurrency-interest] Unsafe + DirectBuffer concurrency bug?
Message-ID: <CAChYfd-p5QcXiS+X3uiOcRLLRFPQhYNDGTVidVxwxBb94FnDuw@mail.gmail.com>

Thanks Nitsan I think you are correct here. I'll have another look tomorrow
morning after coffee :-)

On 8 September 2014 21:53, Nitsan Wakart <nitsanw at yahoo.com> wrote:

> 1    readCounter = getLongVolatile(READER_COUNTER_OFFSET);
> 2      writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
> 3      if (readCounter == writeCounter && isFlagSet()) {
> 4           return false;
> 5       } else if (readCounter < writeCounter) {
> 6           putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
> 7       }
>
> It is possible for 1,2 to execute and see 0, then have the writer thread
> blaze through it's loop and set the flag to 1before you hit 3.
> The HB relationship assumption is in the wrong order, you should read flag
> first and flag visibility necessitates the counter visibility.
>
>
>   On Monday, September 8, 2014 10:23 PM, Martin Thompson <
> mjpt777 at gmail.com> wrote:
>
>
> The version below fails for me every time but at different iteration
> values.
>
> Regards,
> Martin...
>
> import sun.misc.Unsafe;
>
> import java.io.File;
> import java.io.IOException;
> import java.io.RandomAccessFile;
> import java.lang.reflect.Field;
> import java.nio.MappedByteBuffer;
> import java.nio.channels.FileChannel;
> import java.nio.file.Files;
> import java.nio.file.StandardOpenOption;
>
> class IpcBase implements AutoCloseable
> {
>     private static final long PADDING = 64;
>     static final long READER_COUNTER_OFFSET = PADDING;
>     static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET +
> PADDING;
>     static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
>     static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;
>
>     private static final Unsafe UNSAFE;
>
>     static
>     {
>         try
>         {
>             final Field field = Unsafe.class.getDeclaredField("theUnsafe");
>             field.setAccessible(true);
>             UNSAFE = (Unsafe)field.get(null);
>         }
>         catch (final Exception ex)
>         {
>             throw new RuntimeException(ex);
>         }
>     }
>
>     private final FileChannel channel;
>     private final MappedByteBuffer buffer; // hold reference to prevent GC
>     private final long baseAddress;
>
>     public IpcBase(final File file) throws IOException
>     {
>         channel = new RandomAccessFile(file, "rw").getChannel();
>         buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0,
> TOTAL_LENGTH);
>         baseAddress = ((sun.nio.ch.DirectBuffer)buffer).address();
>     }
>
>     final void putLongVolatile(final long offset, final long value)
>     {
>         UNSAFE.putLongVolatile(null, baseAddress + offset, value);
>     }
>
>     final long getLongVolatile(final long offset)
>     {
>         return UNSAFE.getLongVolatile(null, baseAddress + offset);
>     }
>
>     @Override
>     public void close() throws Exception
>     {
>         channel.close();
>     }
> }
>
> class Writer extends IpcBase
> {
>     long writerCounter;
>
>     public Writer(final File file) throws IOException
>     {
>         super(file);
>     }
>
>     @Override
>     public void close() throws Exception
>     {
>         putLongVolatile(FLAG_OFFSET, 1L);
>         super.close();
>     }
>
>     public long write()
>     {
>         writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>         putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
>         return writerCounter;
>     }
> }
>
> class Reader extends IpcBase
> {
>     long readCounter;
>     long writeCounter;
>
>     public Reader(final File file) throws IOException
>     {
>         super(file);
>     }
>
>     public boolean read()
>     {
>         readCounter = getLongVolatile(READER_COUNTER_OFFSET);
>         writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>         if (readCounter == writeCounter && isFlagSet())
>         {
>             return false;
>         }
>         else if (readCounter < writeCounter)
>         {
>             putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
>         }
>
>         return true;
>     }
>
>     private boolean isFlagSet()
>     {
>         return 1L == getLongVolatile(FLAG_OFFSET);
>     }
> }
>
> public class IpcBugTest
> {
>     public static int iteration = 0;
>
>     public static void main(String[] args) throws Exception
>     {
>         final File file = createFile();
>
>         for (int i = 0; i < 1_000_000; i++)
>         {
>             iteration = i;
>             testIpc(file);
>         }
>
>         System.out.println("NO BUG HERE! :-)");
>     }
>
>     private static File createFile() throws IOException
>     {
>         final File file = File.createTempFile("ipc-", ".dat");
>         file.deleteOnExit();
>
>         return file;
>     }
>
>     private static void testIpc(final File file) throws Exception
>     {
>         writeZeros(file);
>
>         final Reader reader = new Reader(file);
>         final Thread readerThread = new Thread("READER")
>         {
>             @Override
>             public void run()
>             {
>                 try
>                 {
>                     try
>                     {
>                         while (reader.read())
>                         {
>                             // busy spin
>                         }
>                     }
>                     finally
>                     {
>                         reader.close();
>                     }
>                 }
>                 catch (Exception ex)
>                 {
>                     ex.printStackTrace();
>                 }
>             }
>         };
>         readerThread.start();
>
>         final Writer writer = new Writer(file);
>         final Thread writerThread = new Thread("WRITER")
>         {
>             @Override
>             public void run()
>             {
>                 try
>                 {
>                     try
>                     {
>                         while (writer.write() < 42)
>                         {
>                             // busy spin
>                         }
>                     }
>                     finally
>                     {
>                         writer.close();
>                     }
>                 }
>                 catch (Exception ex)
>                 {
>                     ex.printStackTrace();
>                 }
>             }
>         };
>         writerThread.start();
>
>         writerThread.join();
>         readerThread.join();
>
>         if (reader.readCounter != writer.writerCounter)
>         {
>             throw new Error(
>                 "Reader exited prematurely: Reader.readCounter=" +
> reader.readCounter +
>                 ", Reader.writeCounter=" + reader.writeCounter +
>                 ", Writer.writeCounter=" + writer.writerCounter +
>                 ", iteration=" + iteration);
>         }
>     }
>
>     private static void writeZeros(final File file) throws IOException
>     {
>         Files.write(file.toPath(), new byte[(int)IpcBase.TOTAL_LENGTH],
> StandardOpenOption.WRITE);
>     }
> }
>
> Date: Mon, 8 Sep 2014 08:08:29 -0700
> From: Dmitry Vyazelenko <vyazelenko at yahoo.com>
> To: "concurrency-interest at cs.oswego.edu"
>         <concurrency-interest at cs.oswego.edu>
> Subject: [concurrency-interest] Unsafe + DirectBuffer concurrency bug?
> Message-ID:
>         <1410188909.78423.YahooMailNeo at web162206.mail.bf1.yahoo.com>
> Content-Type: text/plain; charset="utf-8"
>
> Hi all,
>
> Please find standalone test that points to potential Unsafe/DirectBuffer
> issue. The test uses memory mapped file (DirectBuffer) and Unsafe to
> communicate between reader and writer.
> The data layout within the buffer:
> <64 bytes padding><reader counter><64 bytes padding><writer counter><64
> bytes padding><end of data flag><64 bytes padding>
> Total number of bytes is 256.
>
> The Writer thread keeps incrementing writerCounter until it reaches value
> 42. At which point it also writes endOfDataFlag and closes the FileChannel.
>
> The Reader threads reads both readerCounter and writerCounter. If both
> have the same value and endOfDataFlag is set then it exits. Otherwise it
> increments readerCounter.
>
> Below is the complete test:
>
> package ipc_bug;
>
> import sun.misc.Unsafe;
>
> import java.io.File;
> import java.io.IOException;
> import java.io.RandomAccessFile;
> import java.lang.reflect.Field;
> import java.nio.MappedByteBuffer;
> import java.nio.channels.FileChannel;
> import java.nio.file.Files;
> import java.nio.file.StandardOpenOption;
>
> class IpcBase implements AutoCloseable {
>     private static final long PADDING = 64;
>     static final long READER_COUNTER_OFFSET = PADDING;
>     static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET +
> PADDING;
>     static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
>     static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;
>
>     private static final Unsafe UNSAFE;
>     static {
>         try {
>             final Field field = Unsafe.class.getDeclaredField("theUnsafe");
>             field.setAccessible(true);
>             UNSAFE = (Unsafe) field.get(null);
>         } catch (final Exception ex) {
>             throw new RuntimeException(ex);
>         }
>     }
>
>     private final FileChannel channel;
>     private final MappedByteBuffer buffer;
>     private final long baseAddress;
>
>     public IpcBase(File file) throws IOException {
>         channel = new RandomAccessFile(file, "rw").getChannel();
>         buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0,
> TOTAL_LENGTH);
>         baseAddress = ((sun.nio.ch.DirectBuffer) buffer).address();
>     }
>
>     final void putLongVolatile(long offset, long value) {
>         UNSAFE.putLongVolatile(null, baseAddress + offset, value);
>     }
>
>     final long getLongVolatile(long offset) {
>         return UNSAFE.getLongVolatile(null, baseAddress + offset);
>     }
>
>     @Override
>     public void close() throws Exception {
>         channel.close();
>     }
> }
>
> class Writer extends IpcBase {
>     public Writer(File file) throws IOException {
>         super(file);
>     }
>
>     @Override
>     public void close() throws Exception {
>         putLongVolatile(FLAG_OFFSET, 1L);
>         super.close();
>     }
>
>     long writerCounter;
>
>     public long write() {
>         writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>         putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
>         return writerCounter;
>     }
> }
>
> class Reader extends IpcBase {
>     public Reader(File file) throws IOException {
>         super(file);
>     }
>
>     long readCounter;
>     long writeCounter;
>
>     public boolean read() {
>         readCounter = getLongVolatile(READER_COUNTER_OFFSET);
>         writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>         if (readCounter == writeCounter && isFlagSet()) {
>             return false;
>         } else if (readCounter < writeCounter) {
>             putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
>         }
>         return true;
>     }
>
>     private boolean isFlagSet() {
>         return 1L == getLongVolatile(FLAG_OFFSET);
>     }
> }
>
> public class IpcBugTest {
>     public static void main(String[] args) throws Exception {
>         File file = createFile();
>         for (int i = 0; i < 50_000; i++) {
>             testIPC(file);
>         }
>         System.out.println("NO BUG EXISTS! :-)");
>     }
>
>     private static File createFile() throws IOException {
>         File file = File.createTempFile("ipc-", ".dat");
>         file.deleteOnExit();
>         return file;
>     }
>
>     private static void testIPC(final File file) throws Exception {
>         writeZeros(file);
>
>         final Writer writer = new Writer(file);
>         Thread writerThread = new Thread("WRITER") {
>             @Override
>             public void run() {
>                 try {
>                     try {
>                         while (writer.write() < 42) ;
>                     } finally {
>                         writer.close();
>                     }
>                 } catch (Exception ex) {
>                     ex.printStackTrace();
>                 }
>             }
>         };
>         writerThread.start();
>
>         final Reader reader = new Reader(file);
>         Thread readerThread = new Thread("READER") {
>             @Override
>             public void run() {
>                 try {
>                     try {
>                         while (reader.read()) ;
>                     } finally {
>                         reader.close();
>                     }
>                 } catch (Exception ex) {
>                     ex.printStackTrace();
>                 }
>             }
>         };
>         readerThread.start();
>
>         writerThread.join();
>         readerThread.join();
>
>         if (reader.readCounter != writer.writerCounter) {
>             throw new Error("Reader exited prematurely:
> Reader.readCounter=" + reader.readCounter
>                     + ", Reader.writeCounter=" + reader.writeCounter
>                     + ", Writer.writeCounter=" + writer.writerCounter);
>         }
>     }
>
>     private static void writeZeros(File file) throws IOException {
>         Files.write(file.toPath(), new byte[(int) IpcBase.TOTAL_LENGTH],
> StandardOpenOption.WRITE);
>     }
> }
>
> This test fails on my Windows 7 machine using JDK 7u67 and JDK 8u20 (older
> Intel i5). It also fails on Intel i7 IvyBridge machine that is running
> Ubuntu 14.04 on same JDKs. The failure is random, i.e. I've observed it
> fail on first iteration, 600, after 10K iterations etc. but it fails
> eventually on each run I tried.
>
> The failure message shown is:
>     java.lang.Error: Reader exited prematurely: Reader.readCounter=0,
> Reader.writeCounter=0, Writer.writeCounter=42
>
> In this case the reader thread observed both counters to have the same
> value 0 and endOfDataFlag is set. However writer thread writes
> endOfDataFlag after final writerCounter (i.e. 42) is being written.
>
> I hope the bug is in my code. So please tell me how wrong I am! ;)
>
> Best regards,
> Dmitry Vyazelenko
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140908/b7e86f58/attachment-0001.html>

From vyazelenko at yahoo.com  Mon Sep  8 17:29:11 2014
From: vyazelenko at yahoo.com (Dmitry Vyazelenko)
Date: Mon, 8 Sep 2014 23:29:11 +0200
Subject: [concurrency-interest] Unsafe + DirectBuffer concurrency bug?
In-Reply-To: <CAChYfd8ZjAcrrdYeeQuOCARGQFocwaXTxC0O5KSXEhXSsNpfxA@mail.gmail.com>
References: <CAChYfd8bv7hkUcJEq6iY-uSNDdFFLHciHDgHTS0dv8sV1DZ5dw@mail.gmail.com>
	<1410209584.32996.YahooMailNeo@web120701.mail.ne1.yahoo.com>
	<1410209953.42329.YahooMailNeo@web120701.mail.ne1.yahoo.com>
	<CAChYfd8ZjAcrrdYeeQuOCARGQFocwaXTxC0O5KSXEhXSsNpfxA@mail.gmail.com>
Message-ID: <B4AB84AA-AE05-4E9B-BEB7-5E32DC2C1F79@yahoo.com>

Nitsan, nailed it. Moving isFlagSet() call before reading writerCounter fixes the program.


Best regards,
Dmitry Vyazelenko
On Sep 8, 2014, at 23:14 , Martin Thompson <mjpt777 at gmail.com> wrote:

> No worries. I'll have a look tomorrow and see if it makes sense to me. I was hoping for the bug not being in the JVM/JDK, if not then that is a great result :-)
> 
> On a quick review I think you are correct.
> 
> On 8 September 2014 21:59, Nitsan Wakart <nitsanw at yahoo.com> wrote:
> Sorry for the short hand reply, no brusqueness intended.
> Hope it hits the mark.
>  
> 
> 
> On Monday, September 8, 2014 10:53 PM, Nitsan Wakart <nitsanw at yahoo.com> wrote:
> 
> 
> 1    readCounter = getLongVolatile(READER_COUNTER_OFFSET);
> 2      writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
> 3      if (readCounter == writeCounter && isFlagSet()) {
> 4           return false;
> 5       } else if (readCounter < writeCounter) {
> 6           putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
> 7       }
> 
> It is possible for 1,2 to execute and see 0, then have the writer thread blaze through it's loop and set the flag to 1before you hit 3.
> The HB relationship assumption is in the wrong order, you should read flag first and flag visibility necessitates the counter visibility.
> 
> 
> On Monday, September 8, 2014 10:23 PM, Martin Thompson <mjpt777 at gmail.com> wrote:
> 
> 
> The version below fails for me every time but at different iteration values.
> 
> Regards,
> Martin...
> 
> import sun.misc.Unsafe;
> 
> import java.io.File;
> import java.io.IOException;
> import java.io.RandomAccessFile;
> import java.lang.reflect.Field;
> import java.nio.MappedByteBuffer;
> import java.nio.channels.FileChannel;
> import java.nio.file.Files;
> import java.nio.file.StandardOpenOption;
> 
> class IpcBase implements AutoCloseable
> {
>     private static final long PADDING = 64;
>     static final long READER_COUNTER_OFFSET = PADDING;
>     static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET + PADDING;
>     static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
>     static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;
> 
>     private static final Unsafe UNSAFE;
> 
>     static
>     {
>         try
>         {
>             final Field field = Unsafe.class.getDeclaredField("theUnsafe");
>             field.setAccessible(true);
>             UNSAFE = (Unsafe)field.get(null);
>         }
>         catch (final Exception ex)
>         {
>             throw new RuntimeException(ex);
>         }
>     }
> 
>     private final FileChannel channel;
>     private final MappedByteBuffer buffer; // hold reference to prevent GC
>     private final long baseAddress;
> 
>     public IpcBase(final File file) throws IOException
>     {
>         channel = new RandomAccessFile(file, "rw").getChannel();
>         buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, TOTAL_LENGTH);
>         baseAddress = ((sun.nio.ch.DirectBuffer)buffer).address();
>     }
> 
>     final void putLongVolatile(final long offset, final long value)
>     {
>         UNSAFE.putLongVolatile(null, baseAddress + offset, value);
>     }
> 
>     final long getLongVolatile(final long offset)
>     {
>         return UNSAFE.getLongVolatile(null, baseAddress + offset);
>     }
> 
>     @Override
>     public void close() throws Exception
>     {
>         channel.close();
>     }
> }
> 
> class Writer extends IpcBase
> {
>     long writerCounter;
> 
>     public Writer(final File file) throws IOException
>     {
>         super(file);
>     }
> 
>     @Override
>     public void close() throws Exception
>     {
>         putLongVolatile(FLAG_OFFSET, 1L);
>         super.close();
>     }
> 
>     public long write()
>     {
>         writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>         putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
>         return writerCounter;
>     }
> }
> 
> class Reader extends IpcBase
> {
>     long readCounter;
>     long writeCounter;
> 
>     public Reader(final File file) throws IOException
>     {
>         super(file);
>     }
> 
>     public boolean read()
>     {
>         readCounter = getLongVolatile(READER_COUNTER_OFFSET);
>         writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>         if (readCounter == writeCounter && isFlagSet())
>         {
>             return false;
>         }
>         else if (readCounter < writeCounter)
>         {
>             putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
>         }
> 
>         return true;
>     }
> 
>     private boolean isFlagSet()
>     {
>         return 1L == getLongVolatile(FLAG_OFFSET);
>     }
> }
> 
> public class IpcBugTest
> {
>     public static int iteration = 0;
> 
>     public static void main(String[] args) throws Exception
>     {
>         final File file = createFile();
> 
>         for (int i = 0; i < 1_000_000; i++)
>         {
>             iteration = i;
>             testIpc(file);
>         }
> 
>         System.out.println("NO BUG HERE! :-)");
>     }
> 
>     private static File createFile() throws IOException
>     {
>         final File file = File.createTempFile("ipc-", ".dat");
>         file.deleteOnExit();
> 
>         return file;
>     }
> 
>     private static void testIpc(final File file) throws Exception
>     {
>         writeZeros(file);
> 
>         final Reader reader = new Reader(file);
>         final Thread readerThread = new Thread("READER")
>         {
>             @Override
>             public void run()
>             {
>                 try
>                 {
>                     try
>                     {
>                         while (reader.read())
>                         {
>                             // busy spin
>                         }
>                     }
>                     finally
>                     {
>                         reader.close();
>                     }
>                 }
>                 catch (Exception ex)
>                 {
>                     ex.printStackTrace();
>                 }
>             }
>         };
>         readerThread.start();
> 
>         final Writer writer = new Writer(file);
>         final Thread writerThread = new Thread("WRITER")
>         {
>             @Override
>             public void run()
>             {
>                 try
>                 {
>                     try
>                     {
>                         while (writer.write() < 42)
>                         {
>                             // busy spin
>                         }
>                     }
>                     finally
>                     {
>                         writer.close();
>                     }
>                 }
>                 catch (Exception ex)
>                 {
>                     ex.printStackTrace();
>                 }
>             }
>         };
>         writerThread.start();
> 
>         writerThread.join();
>         readerThread.join();
> 
>         if (reader.readCounter != writer.writerCounter)
>         {
>             throw new Error(
>                 "Reader exited prematurely: Reader.readCounter=" + reader.readCounter +
>                 ", Reader.writeCounter=" + reader.writeCounter +
>                 ", Writer.writeCounter=" + writer.writerCounter +
>                 ", iteration=" + iteration);
>         }
>     }
> 
>     private static void writeZeros(final File file) throws IOException
>     {
>         Files.write(file.toPath(), new byte[(int)IpcBase.TOTAL_LENGTH], StandardOpenOption.WRITE);
>     }
> }
> 
> Date: Mon, 8 Sep 2014 08:08:29 -0700
> From: Dmitry Vyazelenko <vyazelenko at yahoo.com>
> To: "concurrency-interest at cs.oswego.edu"
>         <concurrency-interest at cs.oswego.edu>
> Subject: [concurrency-interest] Unsafe + DirectBuffer concurrency bug?
> Message-ID:
>         <1410188909.78423.YahooMailNeo at web162206.mail.bf1.yahoo.com>
> Content-Type: text/plain; charset="utf-8"
> 
> Hi all,
> 
> Please find standalone test that points to potential Unsafe/DirectBuffer issue. The test uses memory mapped file (DirectBuffer) and Unsafe to communicate between reader and writer.
> The data layout within the buffer:
> <64 bytes padding><reader counter><64 bytes padding><writer counter><64 bytes padding><end of data flag><64 bytes padding>
> Total number of bytes is 256.
> 
> The Writer thread keeps incrementing writerCounter until it reaches value 42. At which point it also writes endOfDataFlag and closes the FileChannel.
> 
> The Reader threads reads both readerCounter and writerCounter. If both have the same value and endOfDataFlag is set then it exits. Otherwise it increments readerCounter.
> 
> Below is the complete test:
> 
> package ipc_bug;
> 
> import sun.misc.Unsafe;
> 
> import java.io.File;
> import java.io.IOException;
> import java.io.RandomAccessFile;
> import java.lang.reflect.Field;
> import java.nio.MappedByteBuffer;
> import java.nio.channels.FileChannel;
> import java.nio.file.Files;
> import java.nio.file.StandardOpenOption;
> 
> class IpcBase implements AutoCloseable {
>     private static final long PADDING = 64;
>     static final long READER_COUNTER_OFFSET = PADDING;
>     static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET + PADDING;
>     static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
>     static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;
> 
>     private static final Unsafe UNSAFE;
>     static {
>         try {
>             final Field field = Unsafe.class.getDeclaredField("theUnsafe");
>             field.setAccessible(true);
>             UNSAFE = (Unsafe) field.get(null);
>         } catch (final Exception ex) {
>             throw new RuntimeException(ex);
>         }
>     }
> 
>     private final FileChannel channel;
>     private final MappedByteBuffer buffer;
>     private final long baseAddress;
> 
>     public IpcBase(File file) throws IOException {
>         channel = new RandomAccessFile(file, "rw").getChannel();
>         buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, TOTAL_LENGTH);
>         baseAddress = ((sun.nio.ch.DirectBuffer) buffer).address();
>     }
> 
>     final void putLongVolatile(long offset, long value) {
>         UNSAFE.putLongVolatile(null, baseAddress + offset, value);
>     }
> 
>     final long getLongVolatile(long offset) {
>         return UNSAFE.getLongVolatile(null, baseAddress + offset);
>     }
> 
>     @Override
>     public void close() throws Exception {
>         channel.close();
>     }
> }
> 
> class Writer extends IpcBase {
>     public Writer(File file) throws IOException {
>         super(file);
>     }
> 
>     @Override
>     public void close() throws Exception {
>         putLongVolatile(FLAG_OFFSET, 1L);
>         super.close();
>     }
> 
>     long writerCounter;
> 
>     public long write() {
>         writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>         putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
>         return writerCounter;
>     }
> }
> 
> class Reader extends IpcBase {
>     public Reader(File file) throws IOException {
>         super(file);
>     }
> 
>     long readCounter;
>     long writeCounter;
> 
>     public boolean read() {
>         readCounter = getLongVolatile(READER_COUNTER_OFFSET);
>         writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>         if (readCounter == writeCounter && isFlagSet()) {
>             return false;
>         } else if (readCounter < writeCounter) {
>             putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
>         }
>         return true;
>     }
> 
>     private boolean isFlagSet() {
>         return 1L == getLongVolatile(FLAG_OFFSET);
>     }
> }
> 
> public class IpcBugTest {
>     public static void main(String[] args) throws Exception {
>         File file = createFile();
>         for (int i = 0; i < 50_000; i++) {
>             testIPC(file);
>         }
>         System.out.println("NO BUG EXISTS! :-)");
>     }
> 
>     private static File createFile() throws IOException {
>         File file = File.createTempFile("ipc-", ".dat");
>         file.deleteOnExit();
>         return file;
>     }
> 
>     private static void testIPC(final File file) throws Exception {
>         writeZeros(file);
> 
>         final Writer writer = new Writer(file);
>         Thread writerThread = new Thread("WRITER") {
>             @Override
>             public void run() {
>                 try {
>                     try {
>                         while (writer.write() < 42) ;
>                     } finally {
>                         writer.close();
>                     }
>                 } catch (Exception ex) {
>                     ex.printStackTrace();
>                 }
>             }
>         };
>         writerThread.start();
> 
>         final Reader reader = new Reader(file);
>         Thread readerThread = new Thread("READER") {
>             @Override
>             public void run() {
>                 try {
>                     try {
>                         while (reader.read()) ;
>                     } finally {
>                         reader.close();
>                     }
>                 } catch (Exception ex) {
>                     ex.printStackTrace();
>                 }
>             }
>         };
>         readerThread.start();
> 
>         writerThread.join();
>         readerThread.join();
> 
>         if (reader.readCounter != writer.writerCounter) {
>             throw new Error("Reader exited prematurely: Reader.readCounter=" + reader.readCounter
>                     + ", Reader.writeCounter=" + reader.writeCounter
>                     + ", Writer.writeCounter=" + writer.writerCounter);
>         }
>     }
> 
>     private static void writeZeros(File file) throws IOException {
>         Files.write(file.toPath(), new byte[(int) IpcBase.TOTAL_LENGTH], StandardOpenOption.WRITE);
>     }
> }
> 
> This test fails on my Windows 7 machine using JDK 7u67 and JDK 8u20 (older Intel i5). It also fails on Intel i7 IvyBridge machine that is running Ubuntu 14.04 on same JDKs. The failure is random, i.e. I've observed it fail on first iteration, 600, after 10K iterations etc. but it fails eventually on each run I tried.
> 
> The failure message shown is:
>     java.lang.Error: Reader exited prematurely: Reader.readCounter=0, Reader.writeCounter=0, Writer.writeCounter=42
> 
> In this case the reader thread observed both counters to have the same value 0 and endOfDataFlag is set. However writer thread writes endOfDataFlag after final writerCounter (i.e. 42) is being written.
> 
> I hope the bug is in my code. So please tell me how wrong I am! ;)
> 
> Best regards,
> Dmitry Vyazelenko
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> 
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140908/42919b95/attachment-0001.html>

From vitalyd at gmail.com  Mon Sep  8 17:45:07 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 8 Sep 2014 17:45:07 -0400
Subject: [concurrency-interest] Unsafe + DirectBuffer concurrency bug?
In-Reply-To: <CAChYfd-p5QcXiS+X3uiOcRLLRFPQhYNDGTVidVxwxBb94FnDuw@mail.gmail.com>
References: <CAChYfd-p5QcXiS+X3uiOcRLLRFPQhYNDGTVidVxwxBb94FnDuw@mail.gmail.com>
Message-ID: <CAHjP37HQ28qn6+JkUnShkZt6ArYs1BGJTK7ZYsNrx22qUV_AQg@mail.gmail.com>

(getting emails out of order)

Forget my comment, I agree that Nitsan is on the money.  This could break
even if reader and writer ran on same core and got scheduled in the "right"
order.

On Mon, Sep 8, 2014 at 5:17 PM, Martin Thompson <mjpt777 at gmail.com> wrote:

> Thanks Nitsan I think you are correct here. I'll have another look
> tomorrow morning after coffee :-)
>
> On 8 September 2014 21:53, Nitsan Wakart <nitsanw at yahoo.com> wrote:
>
>> 1    readCounter = getLongVolatile(READER_COUNTER_OFFSET);
>> 2      writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>> 3      if (readCounter == writeCounter && isFlagSet()) {
>> 4           return false;
>> 5       } else if (readCounter < writeCounter) {
>> 6           putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
>> 7       }
>>
>> It is possible for 1,2 to execute and see 0, then have the writer thread
>> blaze through it's loop and set the flag to 1before you hit 3.
>> The HB relationship assumption is in the wrong order, you should read
>> flag first and flag visibility necessitates the counter visibility.
>>
>>
>>   On Monday, September 8, 2014 10:23 PM, Martin Thompson <
>> mjpt777 at gmail.com> wrote:
>>
>>
>> The version below fails for me every time but at different iteration
>> values.
>>
>> Regards,
>> Martin...
>>
>> import sun.misc.Unsafe;
>>
>> import java.io.File;
>> import java.io.IOException;
>> import java.io.RandomAccessFile;
>> import java.lang.reflect.Field;
>> import java.nio.MappedByteBuffer;
>> import java.nio.channels.FileChannel;
>> import java.nio.file.Files;
>> import java.nio.file.StandardOpenOption;
>>
>> class IpcBase implements AutoCloseable
>> {
>>     private static final long PADDING = 64;
>>     static final long READER_COUNTER_OFFSET = PADDING;
>>     static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET +
>> PADDING;
>>     static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
>>     static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;
>>
>>     private static final Unsafe UNSAFE;
>>
>>     static
>>     {
>>         try
>>         {
>>             final Field field =
>> Unsafe.class.getDeclaredField("theUnsafe");
>>             field.setAccessible(true);
>>             UNSAFE = (Unsafe)field.get(null);
>>         }
>>         catch (final Exception ex)
>>         {
>>             throw new RuntimeException(ex);
>>         }
>>     }
>>
>>     private final FileChannel channel;
>>     private final MappedByteBuffer buffer; // hold reference to prevent GC
>>     private final long baseAddress;
>>
>>     public IpcBase(final File file) throws IOException
>>     {
>>         channel = new RandomAccessFile(file, "rw").getChannel();
>>         buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0,
>> TOTAL_LENGTH);
>>         baseAddress = ((sun.nio.ch.DirectBuffer)buffer).address();
>>     }
>>
>>     final void putLongVolatile(final long offset, final long value)
>>     {
>>         UNSAFE.putLongVolatile(null, baseAddress + offset, value);
>>     }
>>
>>     final long getLongVolatile(final long offset)
>>     {
>>         return UNSAFE.getLongVolatile(null, baseAddress + offset);
>>     }
>>
>>     @Override
>>     public void close() throws Exception
>>     {
>>         channel.close();
>>     }
>> }
>>
>> class Writer extends IpcBase
>> {
>>     long writerCounter;
>>
>>     public Writer(final File file) throws IOException
>>     {
>>         super(file);
>>     }
>>
>>     @Override
>>     public void close() throws Exception
>>     {
>>         putLongVolatile(FLAG_OFFSET, 1L);
>>         super.close();
>>     }
>>
>>     public long write()
>>     {
>>         writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>>         putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
>>         return writerCounter;
>>     }
>> }
>>
>> class Reader extends IpcBase
>> {
>>     long readCounter;
>>     long writeCounter;
>>
>>     public Reader(final File file) throws IOException
>>     {
>>         super(file);
>>     }
>>
>>     public boolean read()
>>     {
>>         readCounter = getLongVolatile(READER_COUNTER_OFFSET);
>>         writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>>         if (readCounter == writeCounter && isFlagSet())
>>         {
>>             return false;
>>         }
>>         else if (readCounter < writeCounter)
>>         {
>>             putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
>>         }
>>
>>         return true;
>>     }
>>
>>     private boolean isFlagSet()
>>     {
>>         return 1L == getLongVolatile(FLAG_OFFSET);
>>     }
>> }
>>
>> public class IpcBugTest
>> {
>>     public static int iteration = 0;
>>
>>     public static void main(String[] args) throws Exception
>>     {
>>         final File file = createFile();
>>
>>         for (int i = 0; i < 1_000_000; i++)
>>         {
>>             iteration = i;
>>             testIpc(file);
>>         }
>>
>>         System.out.println("NO BUG HERE! :-)");
>>     }
>>
>>     private static File createFile() throws IOException
>>     {
>>         final File file = File.createTempFile("ipc-", ".dat");
>>         file.deleteOnExit();
>>
>>         return file;
>>     }
>>
>>     private static void testIpc(final File file) throws Exception
>>     {
>>         writeZeros(file);
>>
>>         final Reader reader = new Reader(file);
>>         final Thread readerThread = new Thread("READER")
>>         {
>>             @Override
>>             public void run()
>>             {
>>                 try
>>                 {
>>                     try
>>                     {
>>                         while (reader.read())
>>                         {
>>                             // busy spin
>>                         }
>>                     }
>>                     finally
>>                     {
>>                         reader.close();
>>                     }
>>                 }
>>                 catch (Exception ex)
>>                 {
>>                     ex.printStackTrace();
>>                 }
>>             }
>>         };
>>         readerThread.start();
>>
>>         final Writer writer = new Writer(file);
>>         final Thread writerThread = new Thread("WRITER")
>>         {
>>             @Override
>>             public void run()
>>             {
>>                 try
>>                 {
>>                     try
>>                     {
>>                         while (writer.write() < 42)
>>                         {
>>                             // busy spin
>>                         }
>>                     }
>>                     finally
>>                     {
>>                         writer.close();
>>                     }
>>                 }
>>                 catch (Exception ex)
>>                 {
>>                     ex.printStackTrace();
>>                 }
>>             }
>>         };
>>         writerThread.start();
>>
>>         writerThread.join();
>>         readerThread.join();
>>
>>         if (reader.readCounter != writer.writerCounter)
>>         {
>>             throw new Error(
>>                 "Reader exited prematurely: Reader.readCounter=" +
>> reader.readCounter +
>>                 ", Reader.writeCounter=" + reader.writeCounter +
>>                 ", Writer.writeCounter=" + writer.writerCounter +
>>                 ", iteration=" + iteration);
>>         }
>>     }
>>
>>     private static void writeZeros(final File file) throws IOException
>>     {
>>         Files.write(file.toPath(), new byte[(int)IpcBase.TOTAL_LENGTH],
>> StandardOpenOption.WRITE);
>>     }
>> }
>>
>> Date: Mon, 8 Sep 2014 08:08:29 -0700
>> From: Dmitry Vyazelenko <vyazelenko at yahoo.com>
>> To: "concurrency-interest at cs.oswego.edu"
>>         <concurrency-interest at cs.oswego.edu>
>> Subject: [concurrency-interest] Unsafe + DirectBuffer concurrency bug?
>> Message-ID:
>>         <1410188909.78423.YahooMailNeo at web162206.mail.bf1.yahoo.com>
>> Content-Type: text/plain; charset="utf-8"
>>
>> Hi all,
>>
>> Please find standalone test that points to potential Unsafe/DirectBuffer
>> issue. The test uses memory mapped file (DirectBuffer) and Unsafe to
>> communicate between reader and writer.
>> The data layout within the buffer:
>> <64 bytes padding><reader counter><64 bytes padding><writer counter><64
>> bytes padding><end of data flag><64 bytes padding>
>> Total number of bytes is 256.
>>
>> The Writer thread keeps incrementing writerCounter until it reaches value
>> 42. At which point it also writes endOfDataFlag and closes the FileChannel.
>>
>> The Reader threads reads both readerCounter and writerCounter. If both
>> have the same value and endOfDataFlag is set then it exits. Otherwise it
>> increments readerCounter.
>>
>> Below is the complete test:
>>
>> package ipc_bug;
>>
>> import sun.misc.Unsafe;
>>
>> import java.io.File;
>> import java.io.IOException;
>> import java.io.RandomAccessFile;
>> import java.lang.reflect.Field;
>> import java.nio.MappedByteBuffer;
>> import java.nio.channels.FileChannel;
>> import java.nio.file.Files;
>> import java.nio.file.StandardOpenOption;
>>
>> class IpcBase implements AutoCloseable {
>>     private static final long PADDING = 64;
>>     static final long READER_COUNTER_OFFSET = PADDING;
>>     static final long WRITER_COUNTER_OFFSET = READER_COUNTER_OFFSET +
>> PADDING;
>>     static final long FLAG_OFFSET = WRITER_COUNTER_OFFSET + PADDING;
>>     static final long TOTAL_LENGTH = FLAG_OFFSET + PADDING;
>>
>>     private static final Unsafe UNSAFE;
>>     static {
>>         try {
>>             final Field field =
>> Unsafe.class.getDeclaredField("theUnsafe");
>>             field.setAccessible(true);
>>             UNSAFE = (Unsafe) field.get(null);
>>         } catch (final Exception ex) {
>>             throw new RuntimeException(ex);
>>         }
>>     }
>>
>>     private final FileChannel channel;
>>     private final MappedByteBuffer buffer;
>>     private final long baseAddress;
>>
>>     public IpcBase(File file) throws IOException {
>>         channel = new RandomAccessFile(file, "rw").getChannel();
>>         buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0,
>> TOTAL_LENGTH);
>>         baseAddress = ((sun.nio.ch.DirectBuffer) buffer).address();
>>     }
>>
>>     final void putLongVolatile(long offset, long value) {
>>         UNSAFE.putLongVolatile(null, baseAddress + offset, value);
>>     }
>>
>>     final long getLongVolatile(long offset) {
>>         return UNSAFE.getLongVolatile(null, baseAddress + offset);
>>     }
>>
>>     @Override
>>     public void close() throws Exception {
>>         channel.close();
>>     }
>> }
>>
>> class Writer extends IpcBase {
>>     public Writer(File file) throws IOException {
>>         super(file);
>>     }
>>
>>     @Override
>>     public void close() throws Exception {
>>         putLongVolatile(FLAG_OFFSET, 1L);
>>         super.close();
>>     }
>>
>>     long writerCounter;
>>
>>     public long write() {
>>         writerCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>>         putLongVolatile(WRITER_COUNTER_OFFSET, ++writerCounter);
>>         return writerCounter;
>>     }
>> }
>>
>> class Reader extends IpcBase {
>>     public Reader(File file) throws IOException {
>>         super(file);
>>     }
>>
>>     long readCounter;
>>     long writeCounter;
>>
>>     public boolean read() {
>>         readCounter = getLongVolatile(READER_COUNTER_OFFSET);
>>         writeCounter = getLongVolatile(WRITER_COUNTER_OFFSET);
>>         if (readCounter == writeCounter && isFlagSet()) {
>>             return false;
>>         } else if (readCounter < writeCounter) {
>>             putLongVolatile(READER_COUNTER_OFFSET, ++readCounter);
>>         }
>>         return true;
>>     }
>>
>>     private boolean isFlagSet() {
>>         return 1L == getLongVolatile(FLAG_OFFSET);
>>     }
>> }
>>
>> public class IpcBugTest {
>>     public static void main(String[] args) throws Exception {
>>         File file = createFile();
>>         for (int i = 0; i < 50_000; i++) {
>>             testIPC(file);
>>         }
>>         System.out.println("NO BUG EXISTS! :-)");
>>     }
>>
>>     private static File createFile() throws IOException {
>>         File file = File.createTempFile("ipc-", ".dat");
>>         file.deleteOnExit();
>>         return file;
>>     }
>>
>>     private static void testIPC(final File file) throws Exception {
>>         writeZeros(file);
>>
>>         final Writer writer = new Writer(file);
>>         Thread writerThread = new Thread("WRITER") {
>>             @Override
>>             public void run() {
>>                 try {
>>                     try {
>>                         while (writer.write() < 42) ;
>>                     } finally {
>>                         writer.close();
>>                     }
>>                 } catch (Exception ex) {
>>                     ex.printStackTrace();
>>                 }
>>             }
>>         };
>>         writerThread.start();
>>
>>         final Reader reader = new Reader(file);
>>         Thread readerThread = new Thread("READER") {
>>             @Override
>>             public void run() {
>>                 try {
>>                     try {
>>                         while (reader.read()) ;
>>                     } finally {
>>                         reader.close();
>>                     }
>>                 } catch (Exception ex) {
>>                     ex.printStackTrace();
>>                 }
>>             }
>>         };
>>         readerThread.start();
>>
>>         writerThread.join();
>>         readerThread.join();
>>
>>         if (reader.readCounter != writer.writerCounter) {
>>             throw new Error("Reader exited prematurely:
>> Reader.readCounter=" + reader.readCounter
>>                     + ", Reader.writeCounter=" + reader.writeCounter
>>                     + ", Writer.writeCounter=" + writer.writerCounter);
>>         }
>>     }
>>
>>     private static void writeZeros(File file) throws IOException {
>>         Files.write(file.toPath(), new byte[(int) IpcBase.TOTAL_LENGTH],
>> StandardOpenOption.WRITE);
>>     }
>> }
>>
>> This test fails on my Windows 7 machine using JDK 7u67 and JDK 8u20
>> (older Intel i5). It also fails on Intel i7 IvyBridge machine that is
>> running Ubuntu 14.04 on same JDKs. The failure is random, i.e. I've
>> observed it fail on first iteration, 600, after 10K iterations etc. but it
>> fails eventually on each run I tried.
>>
>> The failure message shown is:
>>     java.lang.Error: Reader exited prematurely: Reader.readCounter=0,
>> Reader.writeCounter=0, Writer.writeCounter=42
>>
>> In this case the reader thread observed both counters to have the same
>> value 0 and endOfDataFlag is set. However writer thread writes
>> endOfDataFlag after final writerCounter (i.e. 42) is being written.
>>
>> I hope the bug is in my code. So please tell me how wrong I am! ;)
>>
>> Best regards,
>> Dmitry Vyazelenko
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140908/d1fa8cc8/attachment-0001.html>

From Sebastian.Millies at softwareag.com  Wed Sep 10 12:10:20 2014
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Wed, 10 Sep 2014 16:10:20 +0000
Subject: [concurrency-interest] Repeatedly completing futures?
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E490F105AA14@HQMBX5.eur.ad.sag>

Hello there,

is there something like a CompletableFuture that can  be completed multiple times?
I?d like to react to repeatedly occurring events, always with the same chain of asynchronous processing.
Here is a simulation of what I have in mind:

    Supplier<Double> randomNumberSupplier = ?;
    CompletableFuture<Double> future = succeedRepeatedlyWithFixedDelay(randomNumberSupplier, 100, MILLISECONDS);
    future = future
               .thenApplyAsync(this::doSth)
               .thenApplyAsync(this::doMore);
    while( true ) {
      double result = future.get(); // block until result of processing next event becomes available
      publish(result);
    }

    static <T> CompletableFuture<T> succeedRepeatedlyWithFixedDelay(Supplier<T> generator, int delay, TimeUnit unit) {
      CompletableFuture<T> future = new CompletableFuture<T>();
      try {
        scheduler.scheduleWithFixedDelay(() -> future.complete(generator.get()), delay, delay, unit); // <-- HERE
      } catch (RejectedExecutionException e) {
        future.completeExceptionally(new CompletionException("Could not schedule timer task", e));
      }
      return future;
    }

But of course CompletableFuture can be completed only once.
So my questions are: how to go about this? Why cannot CF be completed repeatedly?


n  Sebasian

Sebastian Millies
Expert Java Business Analytics
Phone: +49 681 210 3221 | Fax: +49 681 210 1801 | Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at ids-scheer.com>


Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140910/a958b105/attachment.html>

From benjamin.sieffert at metrigo.de  Thu Sep 11 04:28:51 2014
From: benjamin.sieffert at metrigo.de (Benjamin Sieffert)
Date: Thu, 11 Sep 2014 10:28:51 +0200
Subject: [concurrency-interest] Repeatedly completing futures?
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E490F105AA14@HQMBX5.eur.ad.sag>
References: <32F15738E8E5524DA4F01A0FA4A8E490F105AA14@HQMBX5.eur.ad.sag>
Message-ID: <CAJr8_qPQV8oRhObqvHSacanpis17dqdeyFK3ouLewsm2moT7Cg@mail.gmail.com>

Hello there,

I think the guarantees concerning the number of times a Future will be
completed/fail is very important, because it goes a long way to prevent
multithreading mistakes when using them. E.g. if Future didn't come with
this kind of guarantee and one wanted to trigger a callback logic only
once, a naive implementation would be "if(! future.isDone()) {
future.complete(..) }" which is obviously wrong.

The mechanism you are looking for, though, seems to be the kind of
continuous pushing/polling mechanism that is commonly implemented by using
queues. That is, your call to .complete() is rather like a .put() and your
call to .get() is rather like a .take().
In regards to the functions you'd like to apply to the future's result
along the way, then, I think there's a lot of frameworks out there that let
you build these kinds of pipelines. You might especially want to look into
actor oriented programming.

Regards
Benjamin

On 10 September 2014 18:10, Millies, Sebastian <
Sebastian.Millies at softwareag.com> wrote:

>  Hello there,
>
>
>
> is there something like a CompletableFuture that can  be completed
> multiple times?
>
> I?d like to react to repeatedly occurring events, always with the same
> chain of asynchronous processing.
>
> Here is a simulation of what I have in mind:
>
>
>
>     Supplier<Double> randomNumberSupplier = ?;
>
>     CompletableFuture<Double> future =
> succeedRepeatedlyWithFixedDelay(randomNumberSupplier, 100, MILLISECONDS);
>
>     future = future
>
>                .thenApplyAsync(this::doSth)
>
>                .thenApplyAsync(this::doMore);
>
>     while( true ) {
>
>       double result = future.get(); // block until result of processing
> next event becomes available
>
>       publish(result);
>
>     }
>
>
>
>     static <T> CompletableFuture<T>
> succeedRepeatedlyWithFixedDelay(Supplier<T> generator, int delay, TimeUnit
> unit) {
>
>       CompletableFuture<T> future = new CompletableFuture<T>();
>
>       try {
>
>         scheduler.scheduleWithFixedDelay(() ->
> future.complete(generator.get()), delay, delay, unit); // <-- HERE
>
>       } catch (RejectedExecutionException e) {
>
>         future.completeExceptionally(new CompletionException("Could not
> schedule timer task", e));
>
>       }
>
>       return future;
>
>     }
>
>
>
> But of course CompletableFuture can be completed only once.
>
> So my questions are: how to go about this? Why cannot CF be completed
> repeatedly?
>
>
>
> n  Sebasian
>
>
>
> *Sebastian Millies*
>
> *Expert Java Business Analytics*
>
> Phone: +49 681 210 3221 *|* Fax: +49 681 210 1801 *|*
> Sebastian.Millies at softwareag.com <Sebastian.Millies at ids-scheer.com>
>
>
>
>    Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297
> Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB
> 1562 - Vorstand/Management Board: Karl-Heinz Streibich
> (Vorsitzender/Chairman), Dr. Wolfram Jost, Arnd Zinnhardt; -
> Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas
> Bereczky - *http://www.softwareag.com* <http://www.softwareag.com>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Benjamin Sieffert
metrigo GmbH
Sternstr. 106
20357 Hamburg

Gesch?ftsf?hrer: Christian M?ller, Tobias Schlottke, Philipp Westermeyer,
Martin Rie?
Die Gesellschaft ist eingetragen beim Registergericht Hamburg
Nr. HRB 120447.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140911/c94d1bf1/attachment-0001.html>

From Sebastian.Millies at softwareag.com  Thu Sep 11 09:36:24 2014
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Thu, 11 Sep 2014 13:36:24 +0000
Subject: [concurrency-interest] Repeatedly completing futures?
In-Reply-To: <CAJr8_qPQV8oRhObqvHSacanpis17dqdeyFK3ouLewsm2moT7Cg@mail.gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E490F105AA14@HQMBX5.eur.ad.sag>
	<CAJr8_qPQV8oRhObqvHSacanpis17dqdeyFK3ouLewsm2moT7Cg@mail.gmail.com>
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E490F1A15799@HQMBX5.eur.ad.sag>

thanks for the pointer, I do think that someday I should look at Akka, for example. Meanwhile, though, I am specifically interested in exploring the out-of-the-box capabilities of Java 8. So here?s what I have come up with: I have a ProducerConsumerService, in which a producer puts values into a blocking queue, and the consumer(s) remove them. The consumers in addition get passed a supplier of futures. Each time a value is taken from the queue, a new future is supplied and completed with that value, which then triggers the asynchronous processing. Does that sound reasonable?

Sketch of an example:

// start producer and consumers, the producer gets passed a generator function, the consumers get passed the futureSupplier
ProducerConsumerService(UnaryOperator<T> generator, T startValue, Supplier<CompletableFuture<T>> futureSupplier);

// consume values and use them to complete a future
public class Consumer<T> implements Runnable {
  private final BlockingQueue<T> queue; // shared queue
  private final Supplier<CompletableFuture<T>> futureSupplier;

  @Override
  public void run() {
    try {
      while (true) {
        T value = queue.take();
        futureSupplier.get().complete(value);  // <-- HERE
      }
    } catch (InterruptedException e) {
      // terminate
      Thread.interrupted();
    }
  }
}

// USAGE example:

// return a new future that when completed will trigger some asynchronous processing steps
private CompletableFuture<Long> createProcessor() {
  CompletableFuture<Long> future = new CompletableFuture<>();
  future.thenApplyAsync(this::doSth)
        .thenApplyAsync(this::doMore);
  return future;
}


UnaryOperator<Long> generator = x -> x + 1;
Supplier<CompletableFuture<Long>> processor = this::createProcessor;
ProducerConsumerService<Long> pcs = new ProducerConsumerService<>(generator, 1L, processor);
pcs.start();

The point for me, I guess, is that I can define the asynchronous processing necessary for each incoming event outside the infrastructure that actually deals with producing and receiving these events.


n  Sebastian



From: Benjamin Sieffert [mailto:benjamin.sieffert at metrigo.de]
Sent: Thursday, September 11, 2014 10:29 AM
To: Millies, Sebastian
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Repeatedly completing futures?

Hello there,

I think the guarantees concerning the number of times a Future will be completed/fail is very important, because it goes a long way to prevent multithreading mistakes when using them. E.g. if Future didn't come with this kind of guarantee and one wanted to trigger a callback logic only once, a naive implementation would be "if(! future.isDone()) { future.complete(..) }" which is obviously wrong.
The mechanism you are looking for, though, seems to be the kind of continuous pushing/polling mechanism that is commonly implemented by using queues. That is, your call to .complete() is rather like a .put() and your call to .get() is rather like a .take().
In regards to the functions you'd like to apply to the future's result along the way, then, I think there's a lot of frameworks out there that let you build these kinds of pipelines. You might especially want to look into actor oriented programming.
Regards
Benjamin


Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140911/b6891bca/attachment.html>

From lukeisandberg at gmail.com  Mon Sep 15 19:11:58 2014
From: lukeisandberg at gmail.com (Luke Sandberg)
Date: Mon, 15 Sep 2014 16:11:58 -0700
Subject: [concurrency-interest] Proposal for a CallerRunsExecutor in
	j.u.c.Executors
In-Reply-To: <CA+kOe09UY1iT2JDyh0zvuUNSOJn2JswOXcTYEN5Jrj3N14E34g@mail.gmail.com>
References: <CAO9V1MKUEBD6Ea7yqHeqYW98JZX7cLv6zoyDgp7xu7051EHykg@mail.gmail.com>
	<5380DED8.9060103@cs.oswego.edu>
	<CAO9V1MKzSg7W978rqYtP+v-fR0M3+MpjgjUtOpoNgvUeMhXGoA@mail.gmail.com>
	<CAO9V1MJNxG3vFyqoP195pPCF4Ws8WkgQPrLOOZR2dfS0Uth=0Q@mail.gmail.com>
	<CA+kOe09pgFMDQB5gzbc_OTVsqSgrttbJFo+qAZxauxFwH398oA@mail.gmail.com>
	<CACuKZqFb5mkuujCOw8Brk7taJ_x-XsKhNdLkWwzQnsYe3tzEyQ@mail.gmail.com>
	<CA+kOe09UY1iT2JDyh0zvuUNSOJn2JswOXcTYEN5Jrj3N14E34g@mail.gmail.com>
Message-ID: <CAO9V1MLuwZuenK7KgiayXaOUHBGMJ4xKceCpsQ8UoC9iyFuLQQ@mail.gmail.com>

To close the loop here: Guava released MoreExecutors.directExecutor() as
part of Guava 18 <https://code.google.com/p/guava-libraries/wiki/Release18>

On Tue, Jun 24, 2014 at 9:52 AM, Martin Buchholz <martinrb at google.com>
wrote:

>
>
>
> On Mon, Jun 23, 2014 at 7:19 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>
>> On Mon, Jun 23, 2014 at 5:39 PM, Martin Buchholz <martinrb at google.com>
>> wrote:
>> > Since introducing a plain Executor is much better than doing nothing,
>> let's
>> > start with that.
>>
>> Is it necessary though? In java 8, programmers can simply use
>>
>>
> Of course it's not necessary, and that was a reason to not include it back
> in 2005.  But it's quite popular, and as Doug says, merely giving it a
> standard name has a lot of value.
>
> It would also have value to go further and define an ExecutorService, but
> the smart people here need to agree on the semantics.
>
>
>>     (Executor)Runnable::run
>>
>> Pre java8, an anonymous class isn't too verbose either
>>
>>     new Executor(){ public void execute(Runnable r) { r.run(); } }
>>
>> It doesn't seem to warrant a convenience method in java.*.
>>
>> Zhong Yu
>> bayou.io
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140915/89092ee0/attachment.html>

From ggu at quartetfs.com  Thu Sep 18 06:38:59 2014
From: ggu at quartetfs.com (=?UTF-8?Q?Ga=C3=ABlle_Guimezanes?=)
Date: Thu, 18 Sep 2014 12:38:59 +0200
Subject: [concurrency-interest] JVM crash when using Unsafe to read/write
 bytes in Java 8 (no crash with same code in Java 7)
Message-ID: <CAEK--A5oNK1ZRfrtzNJfT2A8GfbfLndw0G3Zq4rddHSazNNt4Q@mail.gmail.com>

Hello,

I am sorry this is not really a concurrency problem since it can be
reproduced using only one thread, but I didn't really know where to discuss
this. Since many of you use Unsafe I thought you might be able to help me
understand what's happening or direct me to the correct mailing list.

I have a strange behaviour using Unsafe in Java 1.8.0_20.
When I use getByte/putByte to manipulate bits, my JVM crashes (access
violation).
But when I use getLong/putLong for the same purpose it works correctly
(even though I have allocated exactly the same amount of memory).
Also, when using Java 1.7.0_67 to compile and run the same source code,
both the getByte/putByte and the getLong/putLong approaches work correctly.

I have attached a simple test class (DirectMemoryCrash.java) for
reproducing the problem: you can run it with no argument for
the getByte/putByte version, or with "useLongs" arguments for
the getLong/putLong version.

I also have attached crash reports :
hs_err_pid5480.log for the crash on windows
hs_err_pid7210.log for the crash on linux

Thank you for your attention,
Best regards,
Ga?lle Guimezanes.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/42abd171/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: hs_err_pid7210.log
Type: application/octet-stream
Size: 33906 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/42abd171/attachment-0003.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: hs_err_pid5480.log
Type: application/octet-stream
Size: 16917 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/42abd171/attachment-0004.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: DirectMemoryCrash.java
Type: application/octet-stream
Size: 4672 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/42abd171/attachment-0005.obj>

From stanimir at riflexo.com  Thu Sep 18 07:34:03 2014
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Thu, 18 Sep 2014 14:34:03 +0300
Subject: [concurrency-interest] JVM crash when using Unsafe to
 read/write bytes in Java 8 (no crash with same code in Java 7)
In-Reply-To: <CAEK--A5oNK1ZRfrtzNJfT2A8GfbfLndw0G3Zq4rddHSazNNt4Q@mail.gmail.com>
References: <CAEK--A5oNK1ZRfrtzNJfT2A8GfbfLndw0G3Zq4rddHSazNNt4Q@mail.gmail.com>
Message-ID: <CAEJX8ooLs9p+22LCLaG4dkG=3E2s05f-yZQfCmNZHMD_yrQyXg@mail.gmail.com>

Hi,

I suppose the problem occurs due to the last few (less than 8) bytes are
addressed. Probably getByte(address) won't read just a byte but a 32/64
word and mask+shift it.
Try to allocate extra 16 bytes instead of 8.

Stanimir

On Thu, Sep 18, 2014 at 1:38 PM, Ga?lle Guimezanes <ggu at quartetfs.com>
wrote:

> Hello,
>
> I am sorry this is not really a concurrency problem since it can be
> reproduced using only one thread, but I didn't really know where to discuss
> this. Since many of you use Unsafe I thought you might be able to help me
> understand what's happening or direct me to the correct mailing list.
>
> I have a strange behaviour using Unsafe in Java 1.8.0_20.
> When I use getByte/putByte to manipulate bits, my JVM crashes (access
> violation).
> But when I use getLong/putLong for the same purpose it works correctly
> (even though I have allocated exactly the same amount of memory).
> Also, when using Java 1.7.0_67 to compile and run the same source code,
> both the getByte/putByte and the getLong/putLong approaches work correctly.
>
> I have attached a simple test class (DirectMemoryCrash.java) for
> reproducing the problem: you can run it with no argument for
> the getByte/putByte version, or with "useLongs" arguments for
> the getLong/putLong version.
>
> I also have attached crash reports :
> hs_err_pid5480.log for the crash on windows
> hs_err_pid7210.log for the crash on linux
>
> Thank you for your attention,
> Best regards,
> Ga?lle Guimezanes.
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/7b9a3f03/attachment.html>

From ggu at quartetfs.com  Thu Sep 18 07:53:55 2014
From: ggu at quartetfs.com (=?UTF-8?Q?Ga=C3=ABlle_Guimezanes?=)
Date: Thu, 18 Sep 2014 13:53:55 +0200
Subject: [concurrency-interest] JVM crash when using Unsafe to
 read/write bytes in Java 8 (no crash with same code in Java 7)
In-Reply-To: <CAEJX8ooLs9p+22LCLaG4dkG=3E2s05f-yZQfCmNZHMD_yrQyXg@mail.gmail.com>
References: <CAEK--A5oNK1ZRfrtzNJfT2A8GfbfLndw0G3Zq4rddHSazNNt4Q@mail.gmail.com>
	<CAEJX8ooLs9p+22LCLaG4dkG=3E2s05f-yZQfCmNZHMD_yrQyXg@mail.gmail.com>
Message-ID: <CAEK--A5Y+RALj3+p8o8r0wdjPhzd77DM=9BRzBUwna4Z4b9LJw@mail.gmail.com>

Hi Stanimir,

Thanks for the suggestion, but I've tried allocating extra 16 bytes and
even extra 1024 bytes, and it still fails.

Gaelle

On Thu, Sep 18, 2014 at 1:34 PM, Stanimir Simeonoff <stanimir at riflexo.com>
wrote:

> Hi,
>
> I suppose the problem occurs due to the last few (less than 8) bytes are
> addressed. Probably getByte(address) won't read just a byte but a 32/64
> word and mask+shift it.
> Try to allocate extra 16 bytes instead of 8.
>
> Stanimir
>
> On Thu, Sep 18, 2014 at 1:38 PM, Ga?lle Guimezanes <ggu at quartetfs.com>
> wrote:
>
>> Hello,
>>
>> I am sorry this is not really a concurrency problem since it can be
>> reproduced using only one thread, but I didn't really know where to discuss
>> this. Since many of you use Unsafe I thought you might be able to help me
>> understand what's happening or direct me to the correct mailing list.
>>
>> I have a strange behaviour using Unsafe in Java 1.8.0_20.
>> When I use getByte/putByte to manipulate bits, my JVM crashes (access
>> violation).
>> But when I use getLong/putLong for the same purpose it works correctly
>> (even though I have allocated exactly the same amount of memory).
>> Also, when using Java 1.7.0_67 to compile and run the same source code,
>> both the getByte/putByte and the getLong/putLong approaches work correctly.
>>
>> I have attached a simple test class (DirectMemoryCrash.java) for
>> reproducing the problem: you can run it with no argument for
>> the getByte/putByte version, or with "useLongs" arguments for
>> the getLong/putLong version.
>>
>> I also have attached crash reports :
>> hs_err_pid5480.log for the crash on windows
>> hs_err_pid7210.log for the crash on linux
>>
>> Thank you for your attention,
>> Best regards,
>> Ga?lle Guimezanes.
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/1a6e9e7f/attachment.html>

From vitalyd at gmail.com  Thu Sep 18 08:53:22 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 18 Sep 2014 08:53:22 -0400
Subject: [concurrency-interest] JVM crash when using Unsafe to
 read/write bytes in Java 8 (no crash with same code in Java 7)
In-Reply-To: <CAEK--A5Y+RALj3+p8o8r0wdjPhzd77DM=9BRzBUwna4Z4b9LJw@mail.gmail.com>
References: <CAEK--A5oNK1ZRfrtzNJfT2A8GfbfLndw0G3Zq4rddHSazNNt4Q@mail.gmail.com>
	<CAEJX8ooLs9p+22LCLaG4dkG=3E2s05f-yZQfCmNZHMD_yrQyXg@mail.gmail.com>
	<CAEK--A5Y+RALj3+p8o8r0wdjPhzd77DM=9BRzBUwna4Z4b9LJw@mail.gmail.com>
Message-ID: <CAHjP37EeOB9N-9ykMWHjoNC_2TzP=XmXw-9W_dVR0T8KpP4u6Q@mail.gmail.com>

Looks like it's C1 OSR compiled code when it crashes.  Have you tried
running this only in interpreter and only using C2 compiler? Can also try
disabling OSR compiles.  Just to rule out any miscompilation ...

Sent from my phone
On Sep 18, 2014 8:09 AM, "Ga?lle Guimezanes" <ggu at quartetfs.com> wrote:

> Hi Stanimir,
>
> Thanks for the suggestion, but I've tried allocating extra 16 bytes and
> even extra 1024 bytes, and it still fails.
>
> Gaelle
>
> On Thu, Sep 18, 2014 at 1:34 PM, Stanimir Simeonoff <stanimir at riflexo.com>
> wrote:
>
>> Hi,
>>
>> I suppose the problem occurs due to the last few (less than 8) bytes are
>> addressed. Probably getByte(address) won't read just a byte but a 32/64
>> word and mask+shift it.
>> Try to allocate extra 16 bytes instead of 8.
>>
>> Stanimir
>>
>> On Thu, Sep 18, 2014 at 1:38 PM, Ga?lle Guimezanes <ggu at quartetfs.com>
>> wrote:
>>
>>> Hello,
>>>
>>> I am sorry this is not really a concurrency problem since it can be
>>> reproduced using only one thread, but I didn't really know where to discuss
>>> this. Since many of you use Unsafe I thought you might be able to help me
>>> understand what's happening or direct me to the correct mailing list.
>>>
>>> I have a strange behaviour using Unsafe in Java 1.8.0_20.
>>> When I use getByte/putByte to manipulate bits, my JVM crashes (access
>>> violation).
>>> But when I use getLong/putLong for the same purpose it works correctly
>>> (even though I have allocated exactly the same amount of memory).
>>> Also, when using Java 1.7.0_67 to compile and run the same source code,
>>> both the getByte/putByte and the getLong/putLong approaches work correctly.
>>>
>>> I have attached a simple test class (DirectMemoryCrash.java) for
>>> reproducing the problem: you can run it with no argument for
>>> the getByte/putByte version, or with "useLongs" arguments for
>>> the getLong/putLong version.
>>>
>>> I also have attached crash reports :
>>> hs_err_pid5480.log for the crash on windows
>>> hs_err_pid7210.log for the crash on linux
>>>
>>> Thank you for your attention,
>>> Best regards,
>>> Ga?lle Guimezanes.
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/497249db/attachment.html>

From oleksandr.otenko at oracle.com  Thu Sep 18 09:49:18 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Thu, 18 Sep 2014 14:49:18 +0100
Subject: [concurrency-interest] JVM crash when using Unsafe to
 read/write bytes in Java 8 (no crash with same code in Java 7)
In-Reply-To: <CAEK--A5Y+RALj3+p8o8r0wdjPhzd77DM=9BRzBUwna4Z4b9LJw@mail.gmail.com>
References: <CAEK--A5oNK1ZRfrtzNJfT2A8GfbfLndw0G3Zq4rddHSazNNt4Q@mail.gmail.com>	<CAEJX8ooLs9p+22LCLaG4dkG=3E2s05f-yZQfCmNZHMD_yrQyXg@mail.gmail.com>
	<CAEK--A5Y+RALj3+p8o8r0wdjPhzd77DM=9BRzBUwna4Z4b9LJw@mail.gmail.com>
Message-ID: <541AE2DE.1060002@oracle.com>

Small modification of the loop for bytewise method:

         for (int i = 0; i < numberBits; i++) {
             int oddOrEven = 1 + i & 1;
             long byteAddress = addressAndLength[0] + (i >>> 3);
             byte oldValue = unsafe.getByte(byteAddress);
             System.out.println("iteration " + i + " reading " + 
oldValue + " at address " + byteAddress + (((oldValue | 85) != 85 )? " - 
look, how could it get bad value?!": ""));
             byte newValue = (byte) (oldValue | (oddOrEven << (i & 7)));
             System.out.println("iteration " + i + " putting " + 
newValue + " at address " + byteAddress);
             unsafe.putByte(byteAddress, newValue);
         }


gives this on output (clearly way before the end of array, so nothing to 
do with misalignment):
(and many more lines like these, too)

iteration 61440 reading 0 at address 1482093984
iteration 61440 putting 1 at address 1482093984
iteration 61441 reading 96 at address 1482093984 - look, how could it 
get bad value?!
iteration 61441 putting 96 at address 1482093984
iteration 61442 reading 96 at address 1482093984 - look, how could it 
get bad value?!
iteration 61442 putting 100 at address 1482093984
iteration 61443 reading 0 at address 1482093984
iteration 61443 putting 0 at address 1482093984
iteration 61444 reading 1 at address 1482093984
iteration 61444 putting 17 at address 1482093984
iteration 61445 reading 24 at address 1482093984 - look, how could it 
get bad value?!
iteration 61445 putting 24 at address 1482093984
iteration 61446 reading 96 at address 1482093984 - look, how could it 
get bad value?!
iteration 61446 putting 96 at address 1482093984
iteration 61447 reading 17 at address 1482093984
iteration 61447 putting 17 at address 1482093984


Alex


On 18/09/2014 12:53, Ga?lle Guimezanes wrote:
> Hi Stanimir,
>
> Thanks for the suggestion, but I've tried allocating extra 16 bytes 
> and even extra 1024 bytes, and it still fails.
>
> Gaelle
>
> On Thu, Sep 18, 2014 at 1:34 PM, Stanimir Simeonoff 
> <stanimir at riflexo.com <mailto:stanimir at riflexo.com>> wrote:
>
>     Hi,
>
>     I suppose the problem occurs due to the last few (less than 8)
>     bytes are addressed. Probably getByte(address) won't read just a
>     byte but a 32/64 word and mask+shift it.
>     Try to allocate extra 16 bytes instead of 8.
>
>     Stanimir
>
>     On Thu, Sep 18, 2014 at 1:38 PM, Ga?lle Guimezanes
>     <ggu at quartetfs.com <mailto:ggu at quartetfs.com>> wrote:
>
>         Hello,
>
>         I am sorry this is not really a concurrency problem since it
>         can be reproduced using only one thread, but I didn't really
>         know where to discuss this. Since many of you use Unsafe I
>         thought you might be able to help me understand what's
>         happening or direct me to the correct mailing list.
>
>         I have a strange behaviour using Unsafe in Java 1.8.0_20.
>         When I use getByte/putByte to manipulate bits, my JVM crashes
>         (access violation).
>         But when I use getLong/putLong for the same purpose it works
>         correctly (even though I have allocated exactly the same
>         amount of memory).
>         Also, when using Java 1.7.0_67 to compile and run the same
>         source code, both the getByte/putByte and the getLong/putLong
>         approaches work correctly.
>
>         I have attached a simple test class (DirectMemoryCrash.java)
>         for reproducing the problem: you can run it with no argument
>         for the getByte/putByte version, or with "useLongs" arguments
>         for the getLong/putLong version.
>
>         I also have attached crash reports :
>         hs_err_pid5480.log for the crash on windows
>         hs_err_pid7210.log for the crash on linux
>
>         Thank you for your attention,
>         Best regards,
>         Ga?lle Guimezanes.
>
>
>         _______________________________________________
>         Concurrency-interest mailing list
>         Concurrency-interest at cs.oswego.edu
>         <mailto:Concurrency-interest at cs.oswego.edu>
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/c0b98157/attachment-0001.html>

From ggu at quartetfs.com  Thu Sep 18 09:54:51 2014
From: ggu at quartetfs.com (=?UTF-8?Q?Ga=C3=ABlle_Guimezanes?=)
Date: Thu, 18 Sep 2014 15:54:51 +0200
Subject: [concurrency-interest] JVM crash when using Unsafe to
 read/write bytes in Java 8 (no crash with same code in Java 7)
In-Reply-To: <CAHjP37EeOB9N-9ykMWHjoNC_2TzP=XmXw-9W_dVR0T8KpP4u6Q@mail.gmail.com>
References: <CAEK--A5oNK1ZRfrtzNJfT2A8GfbfLndw0G3Zq4rddHSazNNt4Q@mail.gmail.com>
	<CAEJX8ooLs9p+22LCLaG4dkG=3E2s05f-yZQfCmNZHMD_yrQyXg@mail.gmail.com>
	<CAEK--A5Y+RALj3+p8o8r0wdjPhzd77DM=9BRzBUwna4Z4b9LJw@mail.gmail.com>
	<CAHjP37EeOB9N-9ykMWHjoNC_2TzP=XmXw-9W_dVR0T8KpP4u6Q@mail.gmail.com>
Message-ID: <CAEK--A4yZtPTmC-1gjdw67mMqmgfDPSRNFEZU2bSkowntPPDyQ@mail.gmail.com>

Running the test class with -Xint or -Xcomp makes the test work with no
crash, so the problem apparently is with OSR compiles...

However I don't know how to use only the C2 compiler, can you explain how
to do it?

Thanks
Gaelle



On Thu, Sep 18, 2014 at 2:53 PM, Vitaly Davidovich <vitalyd at gmail.com>
wrote:

> Looks like it's C1 OSR compiled code when it crashes.  Have you tried
> running this only in interpreter and only using C2 compiler? Can also try
> disabling OSR compiles.  Just to rule out any miscompilation ...
>
> Sent from my phone
> On Sep 18, 2014 8:09 AM, "Ga?lle Guimezanes" <ggu at quartetfs.com> wrote:
>
>> Hi Stanimir,
>>
>> Thanks for the suggestion, but I've tried allocating extra 16 bytes and
>> even extra 1024 bytes, and it still fails.
>>
>> Gaelle
>>
>> On Thu, Sep 18, 2014 at 1:34 PM, Stanimir Simeonoff <stanimir at riflexo.com
>> > wrote:
>>
>>> Hi,
>>>
>>> I suppose the problem occurs due to the last few (less than 8) bytes are
>>> addressed. Probably getByte(address) won't read just a byte but a 32/64
>>> word and mask+shift it.
>>> Try to allocate extra 16 bytes instead of 8.
>>>
>>> Stanimir
>>>
>>> On Thu, Sep 18, 2014 at 1:38 PM, Ga?lle Guimezanes <ggu at quartetfs.com>
>>> wrote:
>>>
>>>> Hello,
>>>>
>>>> I am sorry this is not really a concurrency problem since it can be
>>>> reproduced using only one thread, but I didn't really know where to discuss
>>>> this. Since many of you use Unsafe I thought you might be able to help me
>>>> understand what's happening or direct me to the correct mailing list.
>>>>
>>>> I have a strange behaviour using Unsafe in Java 1.8.0_20.
>>>> When I use getByte/putByte to manipulate bits, my JVM crashes (access
>>>> violation).
>>>> But when I use getLong/putLong for the same purpose it works correctly
>>>> (even though I have allocated exactly the same amount of memory).
>>>> Also, when using Java 1.7.0_67 to compile and run the same source code,
>>>> both the getByte/putByte and the getLong/putLong approaches work correctly.
>>>>
>>>> I have attached a simple test class (DirectMemoryCrash.java) for
>>>> reproducing the problem: you can run it with no argument for
>>>> the getByte/putByte version, or with "useLongs" arguments for
>>>> the getLong/putLong version.
>>>>
>>>> I also have attached crash reports :
>>>> hs_err_pid5480.log for the crash on windows
>>>> hs_err_pid7210.log for the crash on linux
>>>>
>>>> Thank you for your attention,
>>>> Best regards,
>>>> Ga?lle Guimezanes.
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/79d5aec4/attachment.html>

From vitalyd at gmail.com  Thu Sep 18 10:17:42 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 18 Sep 2014 10:17:42 -0400
Subject: [concurrency-interest] JVM crash when using Unsafe to
 read/write bytes in Java 8 (no crash with same code in Java 7)
In-Reply-To: <CAEK--A4yZtPTmC-1gjdw67mMqmgfDPSRNFEZU2bSkowntPPDyQ@mail.gmail.com>
References: <CAEK--A5oNK1ZRfrtzNJfT2A8GfbfLndw0G3Zq4rddHSazNNt4Q@mail.gmail.com>
	<CAEJX8ooLs9p+22LCLaG4dkG=3E2s05f-yZQfCmNZHMD_yrQyXg@mail.gmail.com>
	<CAEK--A5Y+RALj3+p8o8r0wdjPhzd77DM=9BRzBUwna4Z4b9LJw@mail.gmail.com>
	<CAHjP37EeOB9N-9ykMWHjoNC_2TzP=XmXw-9W_dVR0T8KpP4u6Q@mail.gmail.com>
	<CAEK--A4yZtPTmC-1gjdw67mMqmgfDPSRNFEZU2bSkowntPPDyQ@mail.gmail.com>
Message-ID: <CAHjP37Hh9UoagxkZ81BdQ+frdRgbnszqEiRzq1mGEvbotaRcTw@mail.gmail.com>

Try turning off tiered compilation (-XX:-TieredCompilation) and pass
-server to the launcher.  I *think* that should do it.

However, I think you ran this with C1 just without OSR compilation (I
believe -Xcomp would do that), so this seems to point at an OSR compile.
 You can try disabling OSR compilation (irrespective of C1 or C2):
-XX:-UseOnStackReplacement

On Thu, Sep 18, 2014 at 9:54 AM, Ga?lle Guimezanes <ggu at quartetfs.com>
wrote:

> Running the test class with -Xint or -Xcomp makes the test work with no
> crash, so the problem apparently is with OSR compiles...
>
> However I don't know how to use only the C2 compiler, can you explain how
> to do it?
>
> Thanks
> Gaelle
>
>
>
> On Thu, Sep 18, 2014 at 2:53 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
>
>> Looks like it's C1 OSR compiled code when it crashes.  Have you tried
>> running this only in interpreter and only using C2 compiler? Can also try
>> disabling OSR compiles.  Just to rule out any miscompilation ...
>>
>> Sent from my phone
>> On Sep 18, 2014 8:09 AM, "Ga?lle Guimezanes" <ggu at quartetfs.com> wrote:
>>
>>> Hi Stanimir,
>>>
>>> Thanks for the suggestion, but I've tried allocating extra 16 bytes and
>>> even extra 1024 bytes, and it still fails.
>>>
>>> Gaelle
>>>
>>> On Thu, Sep 18, 2014 at 1:34 PM, Stanimir Simeonoff <
>>> stanimir at riflexo.com> wrote:
>>>
>>>> Hi,
>>>>
>>>> I suppose the problem occurs due to the last few (less than 8) bytes
>>>> are addressed. Probably getByte(address) won't read just a byte but a 32/64
>>>> word and mask+shift it.
>>>> Try to allocate extra 16 bytes instead of 8.
>>>>
>>>> Stanimir
>>>>
>>>> On Thu, Sep 18, 2014 at 1:38 PM, Ga?lle Guimezanes <ggu at quartetfs.com>
>>>> wrote:
>>>>
>>>>> Hello,
>>>>>
>>>>> I am sorry this is not really a concurrency problem since it can be
>>>>> reproduced using only one thread, but I didn't really know where to discuss
>>>>> this. Since many of you use Unsafe I thought you might be able to help me
>>>>> understand what's happening or direct me to the correct mailing list.
>>>>>
>>>>> I have a strange behaviour using Unsafe in Java 1.8.0_20.
>>>>> When I use getByte/putByte to manipulate bits, my JVM crashes (access
>>>>> violation).
>>>>> But when I use getLong/putLong for the same purpose it works correctly
>>>>> (even though I have allocated exactly the same amount of memory).
>>>>> Also, when using Java 1.7.0_67 to compile and run the same source
>>>>> code, both the getByte/putByte and the getLong/putLong approaches work
>>>>> correctly.
>>>>>
>>>>> I have attached a simple test class (DirectMemoryCrash.java) for
>>>>> reproducing the problem: you can run it with no argument for
>>>>> the getByte/putByte version, or with "useLongs" arguments for
>>>>> the getLong/putLong version.
>>>>>
>>>>> I also have attached crash reports :
>>>>> hs_err_pid5480.log for the crash on windows
>>>>> hs_err_pid7210.log for the crash on linux
>>>>>
>>>>> Thank you for your attention,
>>>>> Best regards,
>>>>> Ga?lle Guimezanes.
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/034d0a4e/attachment.html>

From ggu at quartetfs.com  Thu Sep 18 10:49:10 2014
From: ggu at quartetfs.com (=?UTF-8?Q?Ga=C3=ABlle_Guimezanes?=)
Date: Thu, 18 Sep 2014 16:49:10 +0200
Subject: [concurrency-interest] JVM crash when using Unsafe to
 read/write bytes in Java 8 (no crash with same code in Java 7)
In-Reply-To: <CAHjP37Hh9UoagxkZ81BdQ+frdRgbnszqEiRzq1mGEvbotaRcTw@mail.gmail.com>
References: <CAEK--A5oNK1ZRfrtzNJfT2A8GfbfLndw0G3Zq4rddHSazNNt4Q@mail.gmail.com>
	<CAEJX8ooLs9p+22LCLaG4dkG=3E2s05f-yZQfCmNZHMD_yrQyXg@mail.gmail.com>
	<CAEK--A5Y+RALj3+p8o8r0wdjPhzd77DM=9BRzBUwna4Z4b9LJw@mail.gmail.com>
	<CAHjP37EeOB9N-9ykMWHjoNC_2TzP=XmXw-9W_dVR0T8KpP4u6Q@mail.gmail.com>
	<CAEK--A4yZtPTmC-1gjdw67mMqmgfDPSRNFEZU2bSkowntPPDyQ@mail.gmail.com>
	<CAHjP37Hh9UoagxkZ81BdQ+frdRgbnszqEiRzq1mGEvbotaRcTw@mail.gmail.com>
Message-ID: <CAEK--A7kbpetVmmms9LQgPE6Z_NxP1GKPcy0aCsv-1_HtgQ_Aw@mail.gmail.com>

We're nearing it down... disabling OSR compilation or tiered compilation
makes the test run correctly.
So if the options work as I understood, this means the problem is in C1,
only when doing OSR.

On Thu, Sep 18, 2014 at 4:17 PM, Vitaly Davidovich <vitalyd at gmail.com>
wrote:

> Try turning off tiered compilation (-XX:-TieredCompilation) and pass
> -server to the launcher.  I *think* that should do it.
>
> However, I think you ran this with C1 just without OSR compilation (I
> believe -Xcomp would do that), so this seems to point at an OSR compile.
>  You can try disabling OSR compilation (irrespective of C1 or C2):
> -XX:-UseOnStackReplacement
>
> On Thu, Sep 18, 2014 at 9:54 AM, Ga?lle Guimezanes <ggu at quartetfs.com>
> wrote:
>
>> Running the test class with -Xint or -Xcomp makes the test work with no
>> crash, so the problem apparently is with OSR compiles...
>>
>> However I don't know how to use only the C2 compiler, can you explain how
>> to do it?
>>
>> Thanks
>> Gaelle
>>
>>
>>
>> On Thu, Sep 18, 2014 at 2:53 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>>
>>> Looks like it's C1 OSR compiled code when it crashes.  Have you tried
>>> running this only in interpreter and only using C2 compiler? Can also try
>>> disabling OSR compiles.  Just to rule out any miscompilation ...
>>>
>>> Sent from my phone
>>> On Sep 18, 2014 8:09 AM, "Ga?lle Guimezanes" <ggu at quartetfs.com> wrote:
>>>
>>>> Hi Stanimir,
>>>>
>>>> Thanks for the suggestion, but I've tried allocating extra 16 bytes and
>>>> even extra 1024 bytes, and it still fails.
>>>>
>>>> Gaelle
>>>>
>>>> On Thu, Sep 18, 2014 at 1:34 PM, Stanimir Simeonoff <
>>>> stanimir at riflexo.com> wrote:
>>>>
>>>>> Hi,
>>>>>
>>>>> I suppose the problem occurs due to the last few (less than 8) bytes
>>>>> are addressed. Probably getByte(address) won't read just a byte but a 32/64
>>>>> word and mask+shift it.
>>>>> Try to allocate extra 16 bytes instead of 8.
>>>>>
>>>>> Stanimir
>>>>>
>>>>> On Thu, Sep 18, 2014 at 1:38 PM, Ga?lle Guimezanes <ggu at quartetfs.com>
>>>>> wrote:
>>>>>
>>>>>> Hello,
>>>>>>
>>>>>> I am sorry this is not really a concurrency problem since it can be
>>>>>> reproduced using only one thread, but I didn't really know where to discuss
>>>>>> this. Since many of you use Unsafe I thought you might be able to help me
>>>>>> understand what's happening or direct me to the correct mailing list.
>>>>>>
>>>>>> I have a strange behaviour using Unsafe in Java 1.8.0_20.
>>>>>> When I use getByte/putByte to manipulate bits, my JVM crashes (access
>>>>>> violation).
>>>>>> But when I use getLong/putLong for the same purpose it works
>>>>>> correctly (even though I have allocated exactly the same amount of memory).
>>>>>> Also, when using Java 1.7.0_67 to compile and run the same source
>>>>>> code, both the getByte/putByte and the getLong/putLong approaches work
>>>>>> correctly.
>>>>>>
>>>>>> I have attached a simple test class (DirectMemoryCrash.java) for
>>>>>> reproducing the problem: you can run it with no argument for
>>>>>> the getByte/putByte version, or with "useLongs" arguments for
>>>>>> the getLong/putLong version.
>>>>>>
>>>>>> I also have attached crash reports :
>>>>>> hs_err_pid5480.log for the crash on windows
>>>>>> hs_err_pid7210.log for the crash on linux
>>>>>>
>>>>>> Thank you for your attention,
>>>>>> Best regards,
>>>>>> Ga?lle Guimezanes.
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/84114196/attachment-0001.html>

From vitalyd at gmail.com  Thu Sep 18 10:51:23 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 18 Sep 2014 10:51:23 -0400
Subject: [concurrency-interest] JVM crash when using Unsafe to
 read/write bytes in Java 8 (no crash with same code in Java 7)
In-Reply-To: <CAEK--A7kbpetVmmms9LQgPE6Z_NxP1GKPcy0aCsv-1_HtgQ_Aw@mail.gmail.com>
References: <CAEK--A5oNK1ZRfrtzNJfT2A8GfbfLndw0G3Zq4rddHSazNNt4Q@mail.gmail.com>
	<CAEJX8ooLs9p+22LCLaG4dkG=3E2s05f-yZQfCmNZHMD_yrQyXg@mail.gmail.com>
	<CAEK--A5Y+RALj3+p8o8r0wdjPhzd77DM=9BRzBUwna4Z4b9LJw@mail.gmail.com>
	<CAHjP37EeOB9N-9ykMWHjoNC_2TzP=XmXw-9W_dVR0T8KpP4u6Q@mail.gmail.com>
	<CAEK--A4yZtPTmC-1gjdw67mMqmgfDPSRNFEZU2bSkowntPPDyQ@mail.gmail.com>
	<CAHjP37Hh9UoagxkZ81BdQ+frdRgbnszqEiRzq1mGEvbotaRcTw@mail.gmail.com>
	<CAEK--A7kbpetVmmms9LQgPE6Z_NxP1GKPcy0aCsv-1_HtgQ_Aw@mail.gmail.com>
Message-ID: <CAHjP37H7ikW3xPJyxSghYLrQ6iPJKqav36eZJrZY1t7zoWRo3A@mail.gmail.com>

Sounds like it.  Given you have a self-contained repro, you can forward
this email thread (or CC them) to hotspot-compiler-dev at openjdk.java.net,
and see if anyone from the JIT team has any ideas.

On Thu, Sep 18, 2014 at 10:49 AM, Ga?lle Guimezanes <ggu at quartetfs.com>
wrote:

> We're nearing it down... disabling OSR compilation or tiered compilation
> makes the test run correctly.
> So if the options work as I understood, this means the problem is in C1,
> only when doing OSR.
>
> On Thu, Sep 18, 2014 at 4:17 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
>
>> Try turning off tiered compilation (-XX:-TieredCompilation) and pass
>> -server to the launcher.  I *think* that should do it.
>>
>> However, I think you ran this with C1 just without OSR compilation (I
>> believe -Xcomp would do that), so this seems to point at an OSR compile.
>>  You can try disabling OSR compilation (irrespective of C1 or C2):
>> -XX:-UseOnStackReplacement
>>
>> On Thu, Sep 18, 2014 at 9:54 AM, Ga?lle Guimezanes <ggu at quartetfs.com>
>> wrote:
>>
>>> Running the test class with -Xint or -Xcomp makes the test work with no
>>> crash, so the problem apparently is with OSR compiles...
>>>
>>> However I don't know how to use only the C2 compiler, can you explain
>>> how to do it?
>>>
>>> Thanks
>>> Gaelle
>>>
>>>
>>>
>>> On Thu, Sep 18, 2014 at 2:53 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>> wrote:
>>>
>>>> Looks like it's C1 OSR compiled code when it crashes.  Have you tried
>>>> running this only in interpreter and only using C2 compiler? Can also try
>>>> disabling OSR compiles.  Just to rule out any miscompilation ...
>>>>
>>>> Sent from my phone
>>>> On Sep 18, 2014 8:09 AM, "Ga?lle Guimezanes" <ggu at quartetfs.com> wrote:
>>>>
>>>>> Hi Stanimir,
>>>>>
>>>>> Thanks for the suggestion, but I've tried allocating extra 16 bytes
>>>>> and even extra 1024 bytes, and it still fails.
>>>>>
>>>>> Gaelle
>>>>>
>>>>> On Thu, Sep 18, 2014 at 1:34 PM, Stanimir Simeonoff <
>>>>> stanimir at riflexo.com> wrote:
>>>>>
>>>>>> Hi,
>>>>>>
>>>>>> I suppose the problem occurs due to the last few (less than 8) bytes
>>>>>> are addressed. Probably getByte(address) won't read just a byte but a 32/64
>>>>>> word and mask+shift it.
>>>>>> Try to allocate extra 16 bytes instead of 8.
>>>>>>
>>>>>> Stanimir
>>>>>>
>>>>>> On Thu, Sep 18, 2014 at 1:38 PM, Ga?lle Guimezanes <ggu at quartetfs.com
>>>>>> > wrote:
>>>>>>
>>>>>>> Hello,
>>>>>>>
>>>>>>> I am sorry this is not really a concurrency problem since it can be
>>>>>>> reproduced using only one thread, but I didn't really know where to discuss
>>>>>>> this. Since many of you use Unsafe I thought you might be able to help me
>>>>>>> understand what's happening or direct me to the correct mailing list.
>>>>>>>
>>>>>>> I have a strange behaviour using Unsafe in Java 1.8.0_20.
>>>>>>> When I use getByte/putByte to manipulate bits, my JVM crashes
>>>>>>> (access violation).
>>>>>>> But when I use getLong/putLong for the same purpose it works
>>>>>>> correctly (even though I have allocated exactly the same amount of memory).
>>>>>>> Also, when using Java 1.7.0_67 to compile and run the same source
>>>>>>> code, both the getByte/putByte and the getLong/putLong approaches work
>>>>>>> correctly.
>>>>>>>
>>>>>>> I have attached a simple test class (DirectMemoryCrash.java) for
>>>>>>> reproducing the problem: you can run it with no argument for
>>>>>>> the getByte/putByte version, or with "useLongs" arguments for
>>>>>>> the getLong/putLong version.
>>>>>>>
>>>>>>> I also have attached crash reports :
>>>>>>> hs_err_pid5480.log for the crash on windows
>>>>>>> hs_err_pid7210.log for the crash on linux
>>>>>>>
>>>>>>> Thank you for your attention,
>>>>>>> Best regards,
>>>>>>> Ga?lle Guimezanes.
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/d0f1c3a3/attachment.html>

From ggu at quartetfs.com  Thu Sep 18 11:05:25 2014
From: ggu at quartetfs.com (=?UTF-8?Q?Ga=C3=ABlle_Guimezanes?=)
Date: Thu, 18 Sep 2014 17:05:25 +0200
Subject: [concurrency-interest] JVM crash when using Unsafe to
 read/write bytes in Java 8 (no crash with same code in Java 7)
In-Reply-To: <CAHjP37H7ikW3xPJyxSghYLrQ6iPJKqav36eZJrZY1t7zoWRo3A@mail.gmail.com>
References: <CAEK--A5oNK1ZRfrtzNJfT2A8GfbfLndw0G3Zq4rddHSazNNt4Q@mail.gmail.com>
	<CAEJX8ooLs9p+22LCLaG4dkG=3E2s05f-yZQfCmNZHMD_yrQyXg@mail.gmail.com>
	<CAEK--A5Y+RALj3+p8o8r0wdjPhzd77DM=9BRzBUwna4Z4b9LJw@mail.gmail.com>
	<CAHjP37EeOB9N-9ykMWHjoNC_2TzP=XmXw-9W_dVR0T8KpP4u6Q@mail.gmail.com>
	<CAEK--A4yZtPTmC-1gjdw67mMqmgfDPSRNFEZU2bSkowntPPDyQ@mail.gmail.com>
	<CAHjP37Hh9UoagxkZ81BdQ+frdRgbnszqEiRzq1mGEvbotaRcTw@mail.gmail.com>
	<CAEK--A7kbpetVmmms9LQgPE6Z_NxP1GKPcy0aCsv-1_HtgQ_Aw@mail.gmail.com>
	<CAHjP37H7ikW3xPJyxSghYLrQ6iPJKqav36eZJrZY1t7zoWRo3A@mail.gmail.com>
Message-ID: <CAEK--A5MQj+U6Nnw9ADLqqbYgtZR1YOaGJfHD91-90-khaC+hg@mail.gmail.com>

Thanks!

I'll start a clean thread on that address and stop spamming you.
I'll just post the "conclusion" on this thread, if there is one.

Gaelle

On Thu, Sep 18, 2014 at 4:51 PM, Vitaly Davidovich <vitalyd at gmail.com>
wrote:

> Sounds like it.  Given you have a self-contained repro, you can forward
> this email thread (or CC them) to hotspot-compiler-dev at openjdk.java.net,
> and see if anyone from the JIT team has any ideas.
>
> On Thu, Sep 18, 2014 at 10:49 AM, Ga?lle Guimezanes <ggu at quartetfs.com>
> wrote:
>
>> We're nearing it down... disabling OSR compilation or tiered compilation
>> makes the test run correctly.
>> So if the options work as I understood, this means the problem is in C1,
>> only when doing OSR.
>>
>> On Thu, Sep 18, 2014 at 4:17 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>>
>>> Try turning off tiered compilation (-XX:-TieredCompilation) and pass
>>> -server to the launcher.  I *think* that should do it.
>>>
>>> However, I think you ran this with C1 just without OSR compilation (I
>>> believe -Xcomp would do that), so this seems to point at an OSR compile.
>>>  You can try disabling OSR compilation (irrespective of C1 or C2):
>>> -XX:-UseOnStackReplacement
>>>
>>> On Thu, Sep 18, 2014 at 9:54 AM, Ga?lle Guimezanes <ggu at quartetfs.com>
>>> wrote:
>>>
>>>> Running the test class with -Xint or -Xcomp makes the test work with no
>>>> crash, so the problem apparently is with OSR compiles...
>>>>
>>>> However I don't know how to use only the C2 compiler, can you explain
>>>> how to do it?
>>>>
>>>> Thanks
>>>> Gaelle
>>>>
>>>>
>>>>
>>>> On Thu, Sep 18, 2014 at 2:53 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>>> wrote:
>>>>
>>>>> Looks like it's C1 OSR compiled code when it crashes.  Have you tried
>>>>> running this only in interpreter and only using C2 compiler? Can also try
>>>>> disabling OSR compiles.  Just to rule out any miscompilation ...
>>>>>
>>>>> Sent from my phone
>>>>> On Sep 18, 2014 8:09 AM, "Ga?lle Guimezanes" <ggu at quartetfs.com>
>>>>> wrote:
>>>>>
>>>>>> Hi Stanimir,
>>>>>>
>>>>>> Thanks for the suggestion, but I've tried allocating extra 16 bytes
>>>>>> and even extra 1024 bytes, and it still fails.
>>>>>>
>>>>>> Gaelle
>>>>>>
>>>>>> On Thu, Sep 18, 2014 at 1:34 PM, Stanimir Simeonoff <
>>>>>> stanimir at riflexo.com> wrote:
>>>>>>
>>>>>>> Hi,
>>>>>>>
>>>>>>> I suppose the problem occurs due to the last few (less than 8) bytes
>>>>>>> are addressed. Probably getByte(address) won't read just a byte but a 32/64
>>>>>>> word and mask+shift it.
>>>>>>> Try to allocate extra 16 bytes instead of 8.
>>>>>>>
>>>>>>> Stanimir
>>>>>>>
>>>>>>> On Thu, Sep 18, 2014 at 1:38 PM, Ga?lle Guimezanes <
>>>>>>> ggu at quartetfs.com> wrote:
>>>>>>>
>>>>>>>> Hello,
>>>>>>>>
>>>>>>>> I am sorry this is not really a concurrency problem since it can be
>>>>>>>> reproduced using only one thread, but I didn't really know where to discuss
>>>>>>>> this. Since many of you use Unsafe I thought you might be able to help me
>>>>>>>> understand what's happening or direct me to the correct mailing list.
>>>>>>>>
>>>>>>>> I have a strange behaviour using Unsafe in Java 1.8.0_20.
>>>>>>>> When I use getByte/putByte to manipulate bits, my JVM crashes
>>>>>>>> (access violation).
>>>>>>>> But when I use getLong/putLong for the same purpose it works
>>>>>>>> correctly (even though I have allocated exactly the same amount of memory).
>>>>>>>> Also, when using Java 1.7.0_67 to compile and run the same source
>>>>>>>> code, both the getByte/putByte and the getLong/putLong approaches work
>>>>>>>> correctly.
>>>>>>>>
>>>>>>>> I have attached a simple test class (DirectMemoryCrash.java) for
>>>>>>>> reproducing the problem: you can run it with no argument for
>>>>>>>> the getByte/putByte version, or with "useLongs" arguments for
>>>>>>>> the getLong/putLong version.
>>>>>>>>
>>>>>>>> I also have attached crash reports :
>>>>>>>> hs_err_pid5480.log for the crash on windows
>>>>>>>> hs_err_pid7210.log for the crash on linux
>>>>>>>>
>>>>>>>> Thank you for your attention,
>>>>>>>> Best regards,
>>>>>>>> Ga?lle Guimezanes.
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140918/d35cb5ad/attachment.html>

From vladimir.x.ivanov at oracle.com  Thu Sep 18 11:21:00 2014
From: vladimir.x.ivanov at oracle.com (Vladimir Ivanov)
Date: Thu, 18 Sep 2014 19:21:00 +0400
Subject: [concurrency-interest] JVM crash when using Unsafe to
 read/write bytes in Java 8 (no crash with same code in Java 7)
In-Reply-To: <CAHjP37H7ikW3xPJyxSghYLrQ6iPJKqav36eZJrZY1t7zoWRo3A@mail.gmail.com>
References: <CAEK--A5oNK1ZRfrtzNJfT2A8GfbfLndw0G3Zq4rddHSazNNt4Q@mail.gmail.com>	<CAEJX8ooLs9p+22LCLaG4dkG=3E2s05f-yZQfCmNZHMD_yrQyXg@mail.gmail.com>	<CAEK--A5Y+RALj3+p8o8r0wdjPhzd77DM=9BRzBUwna4Z4b9LJw@mail.gmail.com>	<CAHjP37EeOB9N-9ykMWHjoNC_2TzP=XmXw-9W_dVR0T8KpP4u6Q@mail.gmail.com>	<CAEK--A4yZtPTmC-1gjdw67mMqmgfDPSRNFEZU2bSkowntPPDyQ@mail.gmail.com>	<CAHjP37Hh9UoagxkZ81BdQ+frdRgbnszqEiRzq1mGEvbotaRcTw@mail.gmail.com>	<CAEK--A7kbpetVmmms9LQgPE6Z_NxP1GKPcy0aCsv-1_HtgQ_Aw@mail.gmail.com>
	<CAHjP37H7ikW3xPJyxSghYLrQ6iPJKqav36eZJrZY1t7zoWRo3A@mail.gmail.com>
Message-ID: <541AF85C.3090101@oracle.com>

FYI, I filed JDK-8058744 [1] to track that.

Best regards,
Vladimir Ivanov

[1] https://bugs.openjdk.java.net/browse/JDK-8058744

On 9/18/14, 6:51 PM, Vitaly Davidovich wrote:
> Sounds like it.  Given you have a self-contained repro, you can forward
> this email thread (or CC them) to hotspot-compiler-dev at openjdk.java.net
> <mailto:hotspot-compiler-dev at openjdk.java.net>, and see if anyone from
> the JIT team has any ideas.
>
> On Thu, Sep 18, 2014 at 10:49 AM, Ga?lle Guimezanes <ggu at quartetfs.com
> <mailto:ggu at quartetfs.com>> wrote:
>
>     We're nearing it down... disabling OSR compilation or tiered
>     compilation makes the test run correctly.
>     So if the options work as I understood, this means the problem is in
>     C1, only when doing OSR.
>
>     On Thu, Sep 18, 2014 at 4:17 PM, Vitaly Davidovich
>     <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
>
>         Try turning off tiered compilation (-XX:-TieredCompilation) and
>         pass -server to the launcher.  I *think* that should do it.
>
>         However, I think you ran this with C1 just without OSR
>         compilation (I believe -Xcomp would do that), so this seems to
>         point at an OSR compile.  You can try disabling OSR compilation
>         (irrespective of C1 or C2): -XX:-UseOnStackReplacement
>
>         On Thu, Sep 18, 2014 at 9:54 AM, Ga?lle Guimezanes
>         <ggu at quartetfs.com <mailto:ggu at quartetfs.com>> wrote:
>
>             Running the test class with -Xint or -Xcomp makes the test
>             work with no crash, so the problem apparently is with OSR
>             compiles...
>
>             However I don't know how to use only the C2 compiler, can
>             you explain how to do it?
>
>             Thanks
>             Gaelle
>
>
>
>             On Thu, Sep 18, 2014 at 2:53 PM, Vitaly Davidovich
>             <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
>
>                 Looks like it's C1 OSR compiled code when it crashes.
>                 Have you tried running this only in interpreter and only
>                 using C2 compiler? Can also try disabling OSR compiles.
>                 Just to rule out any miscompilation ...
>
>                 Sent from my phone
>
>                 On Sep 18, 2014 8:09 AM, "Ga?lle Guimezanes"
>                 <ggu at quartetfs.com <mailto:ggu at quartetfs.com>> wrote:
>
>                     Hi Stanimir,
>
>                     Thanks for the suggestion, but I've tried allocating
>                     extra 16 bytes and even extra 1024 bytes, and it
>                     still fails.
>
>                     Gaelle
>
>                     On Thu, Sep 18, 2014 at 1:34 PM, Stanimir Simeonoff
>                     <stanimir at riflexo.com <mailto:stanimir at riflexo.com>>
>                     wrote:
>
>                         Hi,
>
>                         I suppose the problem occurs due to the last few
>                         (less than 8) bytes are addressed. Probably
>                         getByte(address) won't read just a byte but a
>                         32/64 word and mask+shift it.
>                         Try to allocate extra 16 bytes instead of 8.
>
>                         Stanimir
>
>                         On Thu, Sep 18, 2014 at 1:38 PM, Ga?lle
>                         Guimezanes <ggu at quartetfs.com
>                         <mailto:ggu at quartetfs.com>> wrote:
>
>                             Hello,
>
>                             I am sorry this is not really a concurrency
>                             problem since it can be reproduced using
>                             only one thread, but I didn't really know
>                             where to discuss this. Since many of you use
>                             Unsafe I thought you might be able to help
>                             me understand what's happening or direct me
>                             to the correct mailing list.
>
>                             I have a strange behaviour using Unsafe in
>                             Java 1.8.0_20.
>                             When I use getByte/putByte to manipulate
>                             bits, my JVM crashes (access violation).
>                             But when I use getLong/putLong for the same
>                             purpose it works correctly (even though I
>                             have allocated exactly the same amount of
>                             memory).
>                             Also, when using Java 1.7.0_67 to compile
>                             and run the same source code, both the
>                             getByte/putByte and the getLong/putLong
>                             approaches work correctly.
>
>                             I have attached a simple test class
>                             (DirectMemoryCrash.java) for reproducing the
>                             problem: you can run it with no argument for
>                             the getByte/putByte version, or with
>                             "useLongs" arguments for
>                             the getLong/putLong version.
>
>                             I also have attached crash reports :
>                             hs_err_pid5480.log for the crash on windows
>                             hs_err_pid7210.log for the crash on linux
>
>                             Thank you for your attention,
>                             Best regards,
>                             Ga?lle Guimezanes.
>
>
>                             _______________________________________________
>                             Concurrency-interest mailing list
>                             Concurrency-interest at cs.oswego.edu
>                             <mailto:Concurrency-interest at cs.oswego.edu>
>                             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>                     _______________________________________________
>                     Concurrency-interest mailing list
>                     Concurrency-interest at cs.oswego.edu
>                     <mailto:Concurrency-interest at cs.oswego.edu>
>                     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From davidcholmes at aapt.net.au  Fri Sep 19 00:52:40 2014
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 19 Sep 2014 14:52:40 +1000
Subject: [concurrency-interest] JVM crash when using Unsafe to
	read/write bytes in Java 8 (no crash with same code in Java 7)
In-Reply-To: <541AF85C.3090101@oracle.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEDGKJAA.davidcholmes@aapt.net.au>

Gaelle had already submitted a webbug that came through as 8058781, so I
closed that as a dup of Vladimir's bug.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Vladimir
> Ivanov
> Sent: Friday, 19 September 2014 1:21 AM
> To: Vitaly Davidovich; Ga?lle Guimezanes
> Cc: hotspot compiler; Concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JVM crash when using Unsafe to
> read/write bytes in Java 8 (no crash with same code in Java 7)
>
>
> FYI, I filed JDK-8058744 [1] to track that.
>
> Best regards,
> Vladimir Ivanov
>
> [1] https://bugs.openjdk.java.net/browse/JDK-8058744
>
> On 9/18/14, 6:51 PM, Vitaly Davidovich wrote:
> > Sounds like it.  Given you have a self-contained repro, you can forward
> > this email thread (or CC them) to hotspot-compiler-dev at openjdk.java.net
> > <mailto:hotspot-compiler-dev at openjdk.java.net>, and see if anyone from
> > the JIT team has any ideas.
> >
> > On Thu, Sep 18, 2014 at 10:49 AM, Ga?lle Guimezanes <ggu at quartetfs.com
> > <mailto:ggu at quartetfs.com>> wrote:
> >
> >     We're nearing it down... disabling OSR compilation or tiered
> >     compilation makes the test run correctly.
> >     So if the options work as I understood, this means the problem is in
> >     C1, only when doing OSR.
> >
> >     On Thu, Sep 18, 2014 at 4:17 PM, Vitaly Davidovich
> >     <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
> >
> >         Try turning off tiered compilation (-XX:-TieredCompilation) and
> >         pass -server to the launcher.  I *think* that should do it.
> >
> >         However, I think you ran this with C1 just without OSR
> >         compilation (I believe -Xcomp would do that), so this seems to
> >         point at an OSR compile.  You can try disabling OSR compilation
> >         (irrespective of C1 or C2): -XX:-UseOnStackReplacement
> >
> >         On Thu, Sep 18, 2014 at 9:54 AM, Ga?lle Guimezanes
> >         <ggu at quartetfs.com <mailto:ggu at quartetfs.com>> wrote:
> >
> >             Running the test class with -Xint or -Xcomp makes the test
> >             work with no crash, so the problem apparently is with OSR
> >             compiles...
> >
> >             However I don't know how to use only the C2 compiler, can
> >             you explain how to do it?
> >
> >             Thanks
> >             Gaelle
> >
> >
> >
> >             On Thu, Sep 18, 2014 at 2:53 PM, Vitaly Davidovich
> >             <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
> >
> >                 Looks like it's C1 OSR compiled code when it crashes.
> >                 Have you tried running this only in interpreter and only
> >                 using C2 compiler? Can also try disabling OSR compiles.
> >                 Just to rule out any miscompilation ...
> >
> >                 Sent from my phone
> >
> >                 On Sep 18, 2014 8:09 AM, "Ga?lle Guimezanes"
> >                 <ggu at quartetfs.com <mailto:ggu at quartetfs.com>> wrote:
> >
> >                     Hi Stanimir,
> >
> >                     Thanks for the suggestion, but I've tried allocating
> >                     extra 16 bytes and even extra 1024 bytes, and it
> >                     still fails.
> >
> >                     Gaelle
> >
> >                     On Thu, Sep 18, 2014 at 1:34 PM, Stanimir Simeonoff
> >                     <stanimir at riflexo.com <mailto:stanimir at riflexo.com>>
> >                     wrote:
> >
> >                         Hi,
> >
> >                         I suppose the problem occurs due to the last few
> >                         (less than 8) bytes are addressed. Probably
> >                         getByte(address) won't read just a byte but a
> >                         32/64 word and mask+shift it.
> >                         Try to allocate extra 16 bytes instead of 8.
> >
> >                         Stanimir
> >
> >                         On Thu, Sep 18, 2014 at 1:38 PM, Ga?lle
> >                         Guimezanes <ggu at quartetfs.com
> >                         <mailto:ggu at quartetfs.com>> wrote:
> >
> >                             Hello,
> >
> >                             I am sorry this is not really a concurrency
> >                             problem since it can be reproduced using
> >                             only one thread, but I didn't really know
> >                             where to discuss this. Since many of you use
> >                             Unsafe I thought you might be able to help
> >                             me understand what's happening or direct me
> >                             to the correct mailing list.
> >
> >                             I have a strange behaviour using Unsafe in
> >                             Java 1.8.0_20.
> >                             When I use getByte/putByte to manipulate
> >                             bits, my JVM crashes (access violation).
> >                             But when I use getLong/putLong for the same
> >                             purpose it works correctly (even though I
> >                             have allocated exactly the same amount of
> >                             memory).
> >                             Also, when using Java 1.7.0_67 to compile
> >                             and run the same source code, both the
> >                             getByte/putByte and the getLong/putLong
> >                             approaches work correctly.
> >
> >                             I have attached a simple test class
> >                             (DirectMemoryCrash.java) for reproducing the
> >                             problem: you can run it with no argument for
> >                             the getByte/putByte version, or with
> >                             "useLongs" arguments for
> >                             the getLong/putLong version.
> >
> >                             I also have attached crash reports :
> >                             hs_err_pid5480.log for the crash on windows
> >                             hs_err_pid7210.log for the crash on linux
> >
> >                             Thank you for your attention,
> >                             Best regards,
> >                             Ga?lle Guimezanes.
> >
> >
> >
> _______________________________________________
> >                             Concurrency-interest mailing list
> >                             Concurrency-interest at cs.oswego.edu
> >                             <mailto:Concurrency-interest at cs.oswego.edu>
> >
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> >
> >                     _______________________________________________
> >                     Concurrency-interest mailing list
> >                     Concurrency-interest at cs.oswego.edu
> >                     <mailto:Concurrency-interest at cs.oswego.edu>
> >
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> >
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From vikas.vksingh at gmail.com  Mon Sep 22 15:14:45 2014
From: vikas.vksingh at gmail.com (vikas)
Date: Mon, 22 Sep 2014 12:14:45 -0700 (MST)
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
Message-ID: <1411413285745-11291.post@n7.nabble.com>


I was reading a article from Hans and he argues that LoadStore is also
needed before lazySet or a final variable write (i assume then also before
volatile write).

He demonstrated a particular race condition which i couldn't understand 
(link below).

http://www.hboehm.info/c++mm/no_write_fences.html see *Recipient writes to
object*.

Its very counter intuitive how  * store of x.a = 43* can be done past the
StoreStore barrier in thread 1.
*
x.a = 0; x.a++;
x_init.store_write_release(true);

and the code that uses x in thread 2 updates it, with e.g.

if (x_init.load_acquire())
    x.a = 42;*


Similar argument here http://shipilev.net/blog/2014/all-fields-are-final/

Copying Shiplev here :

/JSR 133 Cookbook only requires StoreStore, but might also require LoadStore
barriers. This covers for a corner case when the final field is getting
initialized off some other field which experiences a racy update. *This
corner case can be enabled by runtime optimization which figures out the
final store is not needed, puts the value in the local variable, and hence
breaks out of ordering guarantees of StoreStore alone*/

How runtime can figure out that final Store is not needed, also if load is
getting passed/reorder the StoreStore Barrier then Store to local Variable
also is getting passed/reorder with the storeStore barrier, *This is the
part i don't quite understand , why store to local variable can reorder with
StoreStore Barrier. *

It would be very help full if anybody can explain in more details what is
the race condition they both are mentioning by some simple example.




--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/LoadStore-and-StoreStore-are-both-are-required-before-lazySet-and-volatile-write-tp11291.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From vitalyd at gmail.com  Mon Sep 22 16:31:58 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 22 Sep 2014 16:31:58 -0400
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
In-Reply-To: <1411413285745-11291.post@n7.nabble.com>
References: <1411413285745-11291.post@n7.nabble.com>
Message-ID: <CAHjP37EMKkZbV8aPDWKmyZWW1qeK=iNYShW4e90yTRtyhxZWCA@mail.gmail.com>

For Hans' example, he's basically saying this:
x.a = 0;
tmp = x.a; << read of x itself
tmp = tmp + 1;
x.a = tmp;
x.init_store_write_release(true);

The argument is that if only stores are ordered and loads can be reordered
with the stores, then the read of x.a could be reordered with the releasing
store, i.e.:
x.a = 0;
x.init_store_write_release(true);
tmp = x.a; << this load re-ordered with the store and may now see x.a = 42
if thread 2 ran
tmp = tmp + 1;
x.a = tmp; << results in x.a = 43

As Hans mentions, this is somewhat esoteric and strange.  It would require
something (e.g. cpu, compiler) determining/allowing reordering dependent
memory operations; in terms of cpu, only one I know that allows this is the
Alpha.  But he has a separate argument about not relying on memory
dependence to enforce any ordering ...






On Mon, Sep 22, 2014 at 3:14 PM, vikas <vikas.vksingh at gmail.com> wrote:

>
> I was reading a article from Hans and he argues that LoadStore is also
> needed before lazySet or a final variable write (i assume then also before
> volatile write).
>
> He demonstrated a particular race condition which i couldn't understand
> (link below).
>
> http://www.hboehm.info/c++mm/no_write_fences.html see *Recipient writes to
> object*.
>
> Its very counter intuitive how  * store of x.a = 43* can be done past the
> StoreStore barrier in thread 1.
> *
> x.a = 0; x.a++;
> x_init.store_write_release(true);
>
> and the code that uses x in thread 2 updates it, with e.g.
>
> if (x_init.load_acquire())
>     x.a = 42;*
>
>
> Similar argument here http://shipilev.net/blog/2014/all-fields-are-final/
>
> Copying Shiplev here :
>
> /JSR 133 Cookbook only requires StoreStore, but might also require
> LoadStore
> barriers. This covers for a corner case when the final field is getting
> initialized off some other field which experiences a racy update. *This
> corner case can be enabled by runtime optimization which figures out the
> final store is not needed, puts the value in the local variable, and hence
> breaks out of ordering guarantees of StoreStore alone*/
>
> How runtime can figure out that final Store is not needed, also if load is
> getting passed/reorder the StoreStore Barrier then Store to local Variable
> also is getting passed/reorder with the storeStore barrier, *This is the
> part i don't quite understand , why store to local variable can reorder
> with
> StoreStore Barrier. *
>
> It would be very help full if anybody can explain in more details what is
> the race condition they both are mentioning by some simple example.
>
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/LoadStore-and-StoreStore-are-both-are-required-before-lazySet-and-volatile-write-tp11291.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140922/747c7a67/attachment.html>

From vitalyd at gmail.com  Mon Sep 22 16:50:48 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 22 Sep 2014 16:50:48 -0400
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
In-Reply-To: <1411413285745-11291.post@n7.nabble.com>
References: <1411413285745-11291.post@n7.nabble.com>
Message-ID: <CAHjP37EDswdXOosspbi1RLDc0_6jM4xBst0=HnZ3C3eycOZ0VA@mail.gmail.com>

As for Aleksey's point, I don't quite follow why initializing a final field
off some racy field *requires* a LoadStore.  Eliminating StoreStore may
happen, I guess, if something like escape analysis removes the allocation
of an object with final field and scalar replaces it.  But again, unsure
why another racy memory location requires LoadStore (unless this is talking
about same thing as Hans in different terms).

Sent from my phone
On Sep 22, 2014 3:46 PM, "vikas" <vikas.vksingh at gmail.com> wrote:

>
> I was reading a article from Hans and he argues that LoadStore is also
> needed before lazySet or a final variable write (i assume then also before
> volatile write).
>
> He demonstrated a particular race condition which i couldn't understand
> (link below).
>
> http://www.hboehm.info/c++mm/no_write_fences.html see *Recipient writes to
> object*.
>
> Its very counter intuitive how  * store of x.a = 43* can be done past the
> StoreStore barrier in thread 1.
> *
> x.a = 0; x.a++;
> x_init.store_write_release(true);
>
> and the code that uses x in thread 2 updates it, with e.g.
>
> if (x_init.load_acquire())
>     x.a = 42;*
>
>
> Similar argument here http://shipilev.net/blog/2014/all-fields-are-final/
>
> Copying Shiplev here :
>
> /JSR 133 Cookbook only requires StoreStore, but might also require
> LoadStore
> barriers. This covers for a corner case when the final field is getting
> initialized off some other field which experiences a racy update. *This
> corner case can be enabled by runtime optimization which figures out the
> final store is not needed, puts the value in the local variable, and hence
> breaks out of ordering guarantees of StoreStore alone*/
>
> How runtime can figure out that final Store is not needed, also if load is
> getting passed/reorder the StoreStore Barrier then Store to local Variable
> also is getting passed/reorder with the storeStore barrier, *This is the
> part i don't quite understand , why store to local variable can reorder
> with
> StoreStore Barrier. *
>
> It would be very help full if anybody can explain in more details what is
> the race condition they both are mentioning by some simple example.
>
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/LoadStore-and-StoreStore-are-both-are-required-before-lazySet-and-volatile-write-tp11291.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140922/80a24b4e/attachment.html>

From oleksandr.otenko at oracle.com  Tue Sep 23 11:54:44 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 23 Sep 2014 16:54:44 +0100
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
In-Reply-To: <CAHjP37EMKkZbV8aPDWKmyZWW1qeK=iNYShW4e90yTRtyhxZWCA@mail.gmail.com>
References: <1411413285745-11291.post@n7.nabble.com>
	<CAHjP37EMKkZbV8aPDWKmyZWW1qeK=iNYShW4e90yTRtyhxZWCA@mail.gmail.com>
Message-ID: <542197C4.9020501@oracle.com>

Is this sufficient?

Without LoadStore in the second thread, Thread 2 is allowed to observe x 
after writing x.a=42. I am not sure what that means to Thread 1.

Alex

On 22/09/2014 21:31, Vitaly Davidovich wrote:
> For Hans' example, he's basically saying this:
> x.a = 0;
> tmp = x.a; << read of x itself
> tmp = tmp + 1;
> x.a = tmp;
> x.init_store_write_release(true);
>
> The argument is that if only stores are ordered and loads can be 
> reordered with the stores, then the read of x.a could be reordered 
> with the releasing store, i.e.:
> x.a = 0;
> x.init_store_write_release(true);
> tmp = x.a; << this load re-ordered with the store and may now see x.a 
> = 42 if thread 2 ran
> tmp = tmp + 1;
> x.a = tmp; << results in x.a = 43
>
> As Hans mentions, this is somewhat esoteric and strange. It would 
> require something (e.g. cpu, compiler) determining/allowing reordering 
> dependent memory operations; in terms of cpu, only one I know that 
> allows this is the Alpha.  But he has a separate argument about not 
> relying on memory dependence to enforce any ordering ...
>
>
>
>
>
>
> On Mon, Sep 22, 2014 at 3:14 PM, vikas <vikas.vksingh at gmail.com 
> <mailto:vikas.vksingh at gmail.com>> wrote:
>
>
>     I was reading a article from Hans and he argues that LoadStore is also
>     needed before lazySet or a final variable write (i assume then
>     also before
>     volatile write).
>
>     He demonstrated a particular race condition which i couldn't
>     understand
>     (link below).
>
>     http://www.hboehm.info/c++mm/no_write_fences.html see *Recipient
>     writes to
>     object*.
>
>     Its very counter intuitive how  * store of x.a = 43* can be done
>     past the
>     StoreStore barrier in thread 1.
>     *
>     x.a = 0; x.a++;
>     x_init.store_write_release(true);
>
>     and the code that uses x in thread 2 updates it, with e.g.
>
>     if (x_init.load_acquire())
>         x.a = 42;*
>
>
>     Similar argument here
>     http://shipilev.net/blog/2014/all-fields-are-final/
>
>     Copying Shiplev here :
>
>     /JSR 133 Cookbook only requires StoreStore, but might also require
>     LoadStore
>     barriers. This covers for a corner case when the final field is
>     getting
>     initialized off some other field which experiences a racy update.
>     *This
>     corner case can be enabled by runtime optimization which figures
>     out the
>     final store is not needed, puts the value in the local variable,
>     and hence
>     breaks out of ordering guarantees of StoreStore alone*/
>
>     How runtime can figure out that final Store is not needed, also if
>     load is
>     getting passed/reorder the StoreStore Barrier then Store to local
>     Variable
>     also is getting passed/reorder with the storeStore barrier, *This
>     is the
>     part i don't quite understand , why store to local variable can
>     reorder with
>     StoreStore Barrier. *
>
>     It would be very help full if anybody can explain in more details
>     what is
>     the race condition they both are mentioning by some simple example.
>
>
>
>
>     --
>     View this message in context:
>     http://jsr166-concurrency.10961.n7.nabble.com/LoadStore-and-StoreStore-are-both-are-required-before-lazySet-and-volatile-write-tp11291.html
>     Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140923/83a9e7bf/attachment-0001.html>

From vitalyd at gmail.com  Tue Sep 23 12:04:20 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 23 Sep 2014 12:04:20 -0400
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
In-Reply-To: <542197C4.9020501@oracle.com>
References: <1411413285745-11291.post@n7.nabble.com>
	<CAHjP37EMKkZbV8aPDWKmyZWW1qeK=iNYShW4e90yTRtyhxZWCA@mail.gmail.com>
	<542197C4.9020501@oracle.com>
Message-ID: <CAHjP37H6GuS904eKzqL64Ooo9xZ+-Aajcrh2C-YrGz5UtcKSGg@mail.gmail.com>

That would be somewhat hard to believe as this means something (compiler or
cpu) speculated about x_init.load_acquire() returning true but wrote to
memory beforehand? A cpu can speculate like this, I suppose, but it
wouldn't be able to actually retire the store of 42 until the speculation
is proven correct, at which point the store is committed (but then this
doesn't change observed behavior).  Or did you mean something else?

On Tue, Sep 23, 2014 at 11:54 AM, Oleksandr Otenko <
oleksandr.otenko at oracle.com> wrote:

>  Is this sufficient?
>
> Without LoadStore in the second thread, Thread 2 is allowed to observe x
> after writing x.a=42. I am not sure what that means to Thread 1.
>
> Alex
>
>
> On 22/09/2014 21:31, Vitaly Davidovich wrote:
>
> For Hans' example, he's basically saying this:
> x.a = 0;
> tmp = x.a; << read of x itself
> tmp = tmp + 1;
> x.a = tmp;
> x.init_store_write_release(true);
>
>  The argument is that if only stores are ordered and loads can be
> reordered with the stores, then the read of x.a could be reordered with the
> releasing store, i.e.:
>  x.a = 0;
> x.init_store_write_release(true);
>  tmp = x.a; << this load re-ordered with the store and may now see x.a =
> 42 if thread 2 ran
> tmp = tmp + 1;
> x.a = tmp; << results in x.a = 43
>
>  As Hans mentions, this is somewhat esoteric and strange.  It would
> require something (e.g. cpu, compiler) determining/allowing reordering
> dependent memory operations; in terms of cpu, only one I know that allows
> this is the Alpha.  But he has a separate argument about not relying on
> memory dependence to enforce any ordering ...
>
>
>
>
>
>
> On Mon, Sep 22, 2014 at 3:14 PM, vikas <vikas.vksingh at gmail.com> wrote:
>
>>
>> I was reading a article from Hans and he argues that LoadStore is also
>> needed before lazySet or a final variable write (i assume then also before
>> volatile write).
>>
>> He demonstrated a particular race condition which i couldn't understand
>> (link below).
>>
>> http://www.hboehm.info/c++mm/no_write_fences.html see *Recipient writes
>> to
>> object*.
>>
>> Its very counter intuitive how  * store of x.a = 43* can be done past the
>> StoreStore barrier in thread 1.
>> *
>> x.a = 0; x.a++;
>> x_init.store_write_release(true);
>>
>> and the code that uses x in thread 2 updates it, with e.g.
>>
>> if (x_init.load_acquire())
>>     x.a = 42;*
>>
>>
>> Similar argument here http://shipilev.net/blog/2014/all-fields-are-final/
>>
>> Copying Shiplev here :
>>
>> /JSR 133 Cookbook only requires StoreStore, but might also require
>> LoadStore
>> barriers. This covers for a corner case when the final field is getting
>> initialized off some other field which experiences a racy update. *This
>> corner case can be enabled by runtime optimization which figures out the
>> final store is not needed, puts the value in the local variable, and hence
>> breaks out of ordering guarantees of StoreStore alone*/
>>
>> How runtime can figure out that final Store is not needed, also if load is
>> getting passed/reorder the StoreStore Barrier then Store to local Variable
>> also is getting passed/reorder with the storeStore barrier, *This is the
>> part i don't quite understand , why store to local variable can reorder
>> with
>> StoreStore Barrier. *
>>
>> It would be very help full if anybody can explain in more details what is
>> the race condition they both are mentioning by some simple example.
>>
>>
>>
>>
>> --
>> View this message in context:
>> http://jsr166-concurrency.10961.n7.nabble.com/LoadStore-and-StoreStore-are-both-are-required-before-lazySet-and-volatile-write-tp11291.html
>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140923/c9b36fcf/attachment.html>

From oleksandr.otenko at oracle.com  Tue Sep 23 12:13:06 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 23 Sep 2014 17:13:06 +0100
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
In-Reply-To: <CAHjP37H6GuS904eKzqL64Ooo9xZ+-Aajcrh2C-YrGz5UtcKSGg@mail.gmail.com>
References: <1411413285745-11291.post@n7.nabble.com>	<CAHjP37EMKkZbV8aPDWKmyZWW1qeK=iNYShW4e90yTRtyhxZWCA@mail.gmail.com>	<542197C4.9020501@oracle.com>
	<CAHjP37H6GuS904eKzqL64Ooo9xZ+-Aajcrh2C-YrGz5UtcKSGg@mail.gmail.com>
Message-ID: <54219C12.8090902@oracle.com>

When discussing reordering of the dependencies, it was made clear that 
Thread 2 may observe x==null, and still the store of x.a=42 may succeed. 
Depending on the magic involved, Thread 1 may observe x.a==42. So my 
question is mostly about what magic is feasible in modern day technology.


Alex


On 23/09/2014 17:04, Vitaly Davidovich wrote:
> That would be somewhat hard to believe as this means something 
> (compiler or cpu) speculated about x_init.load_acquire() returning 
> true but wrote to memory beforehand? A cpu can speculate like this, I 
> suppose, but it wouldn't be able to actually retire the store of 42 
> until the speculation is proven correct, at which point the store is 
> committed (but then this doesn't change observed behavior).  Or did 
> you mean something else?
>
> On Tue, Sep 23, 2014 at 11:54 AM, Oleksandr Otenko 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     Is this sufficient?
>
>     Without LoadStore in the second thread, Thread 2 is allowed to
>     observe x after writing x.a=42. I am not sure what that means to
>     Thread 1.
>
>     Alex
>
>
>     On 22/09/2014 21:31, Vitaly Davidovich wrote:
>>     For Hans' example, he's basically saying this:
>>     x.a = 0;
>>     tmp = x.a; << read of x itself
>>     tmp = tmp + 1;
>>     x.a = tmp;
>>     x.init_store_write_release(true);
>>
>>     The argument is that if only stores are ordered and loads can be
>>     reordered with the stores, then the read of x.a could be
>>     reordered with the releasing store, i.e.:
>>     x.a = 0;
>>     x.init_store_write_release(true);
>>     tmp = x.a; << this load re-ordered with the store and may now see
>>     x.a = 42 if thread 2 ran
>>     tmp = tmp + 1;
>>     x.a = tmp; << results in x.a = 43
>>
>>     As Hans mentions, this is somewhat esoteric and strange.  It
>>     would require something (e.g. cpu, compiler) determining/allowing
>>     reordering dependent memory operations; in terms of cpu, only one
>>     I know that allows this is the Alpha. But he has a separate
>>     argument about not relying on memory dependence to enforce any
>>     ordering ...
>>
>>
>>
>>
>>
>>
>>     On Mon, Sep 22, 2014 at 3:14 PM, vikas <vikas.vksingh at gmail.com
>>     <mailto:vikas.vksingh at gmail.com>> wrote:
>>
>>
>>         I was reading a article from Hans and he argues that
>>         LoadStore is also
>>         needed before lazySet or a final variable write (i assume
>>         then also before
>>         volatile write).
>>
>>         He demonstrated a particular race condition which i couldn't
>>         understand
>>         (link below).
>>
>>         http://www.hboehm.info/c++mm/no_write_fences.html see
>>         *Recipient writes to
>>         object*.
>>
>>         Its very counter intuitive how  * store of x.a = 43* can be
>>         done past the
>>         StoreStore barrier in thread 1.
>>         *
>>         x.a = 0; x.a++;
>>         x_init.store_write_release(true);
>>
>>         and the code that uses x in thread 2 updates it, with e.g.
>>
>>         if (x_init.load_acquire())
>>             x.a = 42;*
>>
>>
>>         Similar argument here
>>         http://shipilev.net/blog/2014/all-fields-are-final/
>>
>>         Copying Shiplev here :
>>
>>         /JSR 133 Cookbook only requires StoreStore, but might also
>>         require LoadStore
>>         barriers. This covers for a corner case when the final field
>>         is getting
>>         initialized off some other field which experiences a racy
>>         update. *This
>>         corner case can be enabled by runtime optimization which
>>         figures out the
>>         final store is not needed, puts the value in the local
>>         variable, and hence
>>         breaks out of ordering guarantees of StoreStore alone*/
>>
>>         How runtime can figure out that final Store is not needed,
>>         also if load is
>>         getting passed/reorder the StoreStore Barrier then Store to
>>         local Variable
>>         also is getting passed/reorder with the storeStore barrier,
>>         *This is the
>>         part i don't quite understand , why store to local variable
>>         can reorder with
>>         StoreStore Barrier. *
>>
>>         It would be very help full if anybody can explain in more
>>         details what is
>>         the race condition they both are mentioning by some simple
>>         example.
>>
>>
>>
>>
>>         --
>>         View this message in context:
>>         http://jsr166-concurrency.10961.n7.nabble.com/LoadStore-and-StoreStore-are-both-are-required-before-lazySet-and-volatile-write-tp11291.html
>>         Sent from the JSR166 Concurrency mailing list archive at
>>         Nabble.com.
>>         _______________________________________________
>>         Concurrency-interest mailing list
>>         Concurrency-interest at cs.oswego.edu
>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140923/8aae5678/attachment-0001.html>

From vitalyd at gmail.com  Tue Sep 23 12:35:40 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 23 Sep 2014 12:35:40 -0400
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
In-Reply-To: <54219C12.8090902@oracle.com>
References: <1411413285745-11291.post@n7.nabble.com>
	<CAHjP37EMKkZbV8aPDWKmyZWW1qeK=iNYShW4e90yTRtyhxZWCA@mail.gmail.com>
	<542197C4.9020501@oracle.com>
	<CAHjP37H6GuS904eKzqL64Ooo9xZ+-Aajcrh2C-YrGz5UtcKSGg@mail.gmail.com>
	<54219C12.8090902@oracle.com>
Message-ID: <CAHjP37FgOVxZbGffFWNTWKSBD-B2qzucCv_F4J9RJjbVi_qRUQ@mail.gmail.com>

As I understood it, Thread 1 can see 42 before the increment only because
of reordering of its own operations, allowing x_init to be set earlier and
giving Thread 2 a chance to run before the increment in Thread 1.  I'm not
sure what x == null has to do with it.

Sent from my phone
On Sep 23, 2014 12:13 PM, "Oleksandr Otenko" <oleksandr.otenko at oracle.com>
wrote:

>  When discussing reordering of the dependencies, it was made clear that
> Thread 2 may observe x==null, and still the store of x.a=42 may succeed.
> Depending on the magic involved, Thread 1 may observe x.a==42. So my
> question is mostly about what magic is feasible in modern day technology.
>
>
> Alex
>
>
> On 23/09/2014 17:04, Vitaly Davidovich wrote:
>
> That would be somewhat hard to believe as this means something (compiler
> or cpu) speculated about x_init.load_acquire() returning true but wrote to
> memory beforehand? A cpu can speculate like this, I suppose, but it
> wouldn't be able to actually retire the store of 42 until the speculation
> is proven correct, at which point the store is committed (but then this
> doesn't change observed behavior).  Or did you mean something else?
>
> On Tue, Sep 23, 2014 at 11:54 AM, Oleksandr Otenko <
> oleksandr.otenko at oracle.com> wrote:
>
>>  Is this sufficient?
>>
>> Without LoadStore in the second thread, Thread 2 is allowed to observe x
>> after writing x.a=42. I am not sure what that means to Thread 1.
>>
>> Alex
>>
>>
>> On 22/09/2014 21:31, Vitaly Davidovich wrote:
>>
>> For Hans' example, he's basically saying this:
>> x.a = 0;
>> tmp = x.a; << read of x itself
>> tmp = tmp + 1;
>> x.a = tmp;
>> x.init_store_write_release(true);
>>
>>  The argument is that if only stores are ordered and loads can be
>> reordered with the stores, then the read of x.a could be reordered with the
>> releasing store, i.e.:
>>  x.a = 0;
>> x.init_store_write_release(true);
>>  tmp = x.a; << this load re-ordered with the store and may now see x.a =
>> 42 if thread 2 ran
>> tmp = tmp + 1;
>> x.a = tmp; << results in x.a = 43
>>
>>  As Hans mentions, this is somewhat esoteric and strange.  It would
>> require something (e.g. cpu, compiler) determining/allowing reordering
>> dependent memory operations; in terms of cpu, only one I know that allows
>> this is the Alpha.  But he has a separate argument about not relying on
>> memory dependence to enforce any ordering ...
>>
>>
>>
>>
>>
>>
>> On Mon, Sep 22, 2014 at 3:14 PM, vikas <vikas.vksingh at gmail.com> wrote:
>>
>>>
>>> I was reading a article from Hans and he argues that LoadStore is also
>>> needed before lazySet or a final variable write (i assume then also
>>> before
>>> volatile write).
>>>
>>> He demonstrated a particular race condition which i couldn't understand
>>> (link below).
>>>
>>> http://www.hboehm.info/c++mm/no_write_fences.html see *Recipient writes
>>> to
>>> object*.
>>>
>>> Its very counter intuitive how  * store of x.a = 43* can be done past the
>>> StoreStore barrier in thread 1.
>>> *
>>> x.a = 0; x.a++;
>>> x_init.store_write_release(true);
>>>
>>> and the code that uses x in thread 2 updates it, with e.g.
>>>
>>> if (x_init.load_acquire())
>>>     x.a = 42;*
>>>
>>>
>>> Similar argument here
>>> http://shipilev.net/blog/2014/all-fields-are-final/
>>>
>>> Copying Shiplev here :
>>>
>>> /JSR 133 Cookbook only requires StoreStore, but might also require
>>> LoadStore
>>> barriers. This covers for a corner case when the final field is getting
>>> initialized off some other field which experiences a racy update. *This
>>> corner case can be enabled by runtime optimization which figures out the
>>> final store is not needed, puts the value in the local variable, and
>>> hence
>>> breaks out of ordering guarantees of StoreStore alone*/
>>>
>>> How runtime can figure out that final Store is not needed, also if load
>>> is
>>> getting passed/reorder the StoreStore Barrier then Store to local
>>> Variable
>>> also is getting passed/reorder with the storeStore barrier, *This is the
>>> part i don't quite understand , why store to local variable can reorder
>>> with
>>> StoreStore Barrier. *
>>>
>>> It would be very help full if anybody can explain in more details what is
>>> the race condition they both are mentioning by some simple example.
>>>
>>>
>>>
>>>
>>> --
>>> View this message in context:
>>> http://jsr166-concurrency.10961.n7.nabble.com/LoadStore-and-StoreStore-are-both-are-required-before-lazySet-and-volatile-write-tp11291.html
>>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140923/1a60b7a0/attachment.html>

From aph at redhat.com  Tue Sep 23 13:21:24 2014
From: aph at redhat.com (Andrew Haley)
Date: Tue, 23 Sep 2014 18:21:24 +0100
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
In-Reply-To: <CAHjP37H6GuS904eKzqL64Ooo9xZ+-Aajcrh2C-YrGz5UtcKSGg@mail.gmail.com>
References: <1411413285745-11291.post@n7.nabble.com>	<CAHjP37EMKkZbV8aPDWKmyZWW1qeK=iNYShW4e90yTRtyhxZWCA@mail.gmail.com>	<542197C4.9020501@oracle.com>
	<CAHjP37H6GuS904eKzqL64Ooo9xZ+-Aajcrh2C-YrGz5UtcKSGg@mail.gmail.com>
Message-ID: <5421AC14.9050003@redhat.com>

The key phrase is "it doesn't make sense to enforce ordering based on
dependencies, since they cannot be reliably defined *at this level*."

In other words, once you start translating the example into machine
instructions you can nail it down in ways that aren't imposed by the
memory model.  As I understand it, there is nothing in a memory model
to prevent stores in Thread 2 after the load_acquire from floating up
past the x_init.store_write_release in Thread 1.

Andrew.


On 09/23/2014 05:04 PM, Vitaly Davidovich wrote:
> That would be somewhat hard to believe as this means something (compiler or
> cpu) speculated about x_init.load_acquire() returning true but wrote to
> memory beforehand? A cpu can speculate like this, I suppose, but it
> wouldn't be able to actually retire the store of 42 until the speculation
> is proven correct, at which point the store is committed (but then this
> doesn't change observed behavior).  Or did you mean something else?
> 
> On Tue, Sep 23, 2014 at 11:54 AM, Oleksandr Otenko <
> oleksandr.otenko at oracle.com> wrote:
> 
>>  Is this sufficient?
>>
>> Without LoadStore in the second thread, Thread 2 is allowed to observe x
>> after writing x.a=42. I am not sure what that means to Thread 1.
>>
>> Alex
>>
>>
>> On 22/09/2014 21:31, Vitaly Davidovich wrote:
>>
>> For Hans' example, he's basically saying this:
>> x.a = 0;
>> tmp = x.a; << read of x itself
>> tmp = tmp + 1;
>> x.a = tmp;
>> x.init_store_write_release(true);
>>
>>  The argument is that if only stores are ordered and loads can be
>> reordered with the stores, then the read of x.a could be reordered with the
>> releasing store, i.e.:
>>  x.a = 0;
>> x.init_store_write_release(true);
>>  tmp = x.a; << this load re-ordered with the store and may now see x.a =
>> 42 if thread 2 ran
>> tmp = tmp + 1;
>> x.a = tmp; << results in x.a = 43
>>
>>  As Hans mentions, this is somewhat esoteric and strange.  It would
>> require something (e.g. cpu, compiler) determining/allowing reordering
>> dependent memory operations; in terms of cpu, only one I know that allows
>> this is the Alpha.  But he has a separate argument about not relying on
>> memory dependence to enforce any ordering ...
>>
>>
>>
>>
>>
>>
>> On Mon, Sep 22, 2014 at 3:14 PM, vikas <vikas.vksingh at gmail.com> wrote:
>>
>>>
>>> I was reading a article from Hans and he argues that LoadStore is also
>>> needed before lazySet or a final variable write (i assume then also before
>>> volatile write).
>>>
>>> He demonstrated a particular race condition which i couldn't understand
>>> (link below).
>>>
>>> http://www.hboehm.info/c++mm/no_write_fences.html see *Recipient writes
>>> to
>>> object*.
>>>
>>> Its very counter intuitive how  * store of x.a = 43* can be done past the
>>> StoreStore barrier in thread 1.
>>> *
>>> x.a = 0; x.a++;
>>> x_init.store_write_release(true);
>>>
>>> and the code that uses x in thread 2 updates it, with e.g.
>>>
>>> if (x_init.load_acquire())
>>>     x.a = 42;*
>>>
>>>
>>> Similar argument here http://shipilev.net/blog/2014/all-fields-are-final/
>>>
>>> Copying Shiplev here :
>>>
>>> /JSR 133 Cookbook only requires StoreStore, but might also require
>>> LoadStore
>>> barriers. This covers for a corner case when the final field is getting
>>> initialized off some other field which experiences a racy update. *This
>>> corner case can be enabled by runtime optimization which figures out the
>>> final store is not needed, puts the value in the local variable, and hence
>>> breaks out of ordering guarantees of StoreStore alone*/
>>>
>>> How runtime can figure out that final Store is not needed, also if load is
>>> getting passed/reorder the StoreStore Barrier then Store to local Variable
>>> also is getting passed/reorder with the storeStore barrier, *This is the
>>> part i don't quite understand , why store to local variable can reorder
>>> with
>>> StoreStore Barrier. *
>>>
>>> It would be very help full if anybody can explain in more details what is
>>> the race condition they both are mentioning by some simple example.
>>>
>>>
>>>
>>>
>>> --
>>> View this message in context:
>>> http://jsr166-concurrency.10961.n7.nabble.com/LoadStore-and-StoreStore-are-both-are-required-before-lazySet-and-volatile-write-tp11291.html
>>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From oleksandr.otenko at oracle.com  Tue Sep 23 13:23:46 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 23 Sep 2014 18:23:46 +0100
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
In-Reply-To: <CAHjP37FgOVxZbGffFWNTWKSBD-B2qzucCv_F4J9RJjbVi_qRUQ@mail.gmail.com>
References: <1411413285745-11291.post@n7.nabble.com>	<CAHjP37EMKkZbV8aPDWKmyZWW1qeK=iNYShW4e90yTRtyhxZWCA@mail.gmail.com>	<542197C4.9020501@oracle.com>	<CAHjP37H6GuS904eKzqL64Ooo9xZ+-Aajcrh2C-YrGz5UtcKSGg@mail.gmail.com>	<54219C12.8090902@oracle.com>
	<CAHjP37FgOVxZbGffFWNTWKSBD-B2qzucCv_F4J9RJjbVi_qRUQ@mail.gmail.com>
Message-ID: <5421ACA2.1010700@oracle.com>

x==null is evidence that Thread 2 observed the operations in the 
opposite order (opposite to "program order"). Then the question is 
whether Thread 1 can see them in the opposite order too.

Alex

On 23/09/2014 17:35, Vitaly Davidovich wrote:
>
> As I understood it, Thread 1 can see 42 before the increment only 
> because of reordering of its own operations, allowing x_init to be set 
> earlier and giving Thread 2 a chance to run before the increment in 
> Thread 1.  I'm not sure what x == null has to do with it.
>
> Sent from my phone
>
> On Sep 23, 2014 12:13 PM, "Oleksandr Otenko" 
> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>
>     When discussing reordering of the dependencies, it was made clear
>     that Thread 2 may observe x==null, and still the store of x.a=42
>     may succeed. Depending on the magic involved, Thread 1 may observe
>     x.a==42. So my question is mostly about what magic is feasible in
>     modern day technology.
>
>
>     Alex
>
>
>     On 23/09/2014 17:04, Vitaly Davidovich wrote:
>>     That would be somewhat hard to believe as this means something
>>     (compiler or cpu) speculated about x_init.load_acquire()
>>     returning true but wrote to memory beforehand? A cpu can
>>     speculate like this, I suppose, but it wouldn't be able to
>>     actually retire the store of 42 until the speculation is proven
>>     correct, at which point the store is committed (but then this
>>     doesn't change observed behavior).  Or did you mean something else?
>>
>>     On Tue, Sep 23, 2014 at 11:54 AM, Oleksandr Otenko
>>     <oleksandr.otenko at oracle.com
>>     <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>>         Is this sufficient?
>>
>>         Without LoadStore in the second thread, Thread 2 is allowed
>>         to observe x after writing x.a=42. I am not sure what that
>>         means to Thread 1.
>>
>>         Alex
>>
>>
>>         On 22/09/2014 21:31, Vitaly Davidovich wrote:
>>>         For Hans' example, he's basically saying this:
>>>         x.a = 0;
>>>         tmp = x.a; << read of x itself
>>>         tmp = tmp + 1;
>>>         x.a = tmp;
>>>         x.init_store_write_release(true);
>>>
>>>         The argument is that if only stores are ordered and loads
>>>         can be reordered with the stores, then the read of x.a could
>>>         be reordered with the releasing store, i.e.:
>>>         x.a = 0;
>>>         x.init_store_write_release(true);
>>>         tmp = x.a; << this load re-ordered with the store and may
>>>         now see x.a = 42 if thread 2 ran
>>>         tmp = tmp + 1;
>>>         x.a = tmp; << results in x.a = 43
>>>
>>>         As Hans mentions, this is somewhat esoteric and strange.  It
>>>         would require something (e.g. cpu, compiler)
>>>         determining/allowing reordering dependent memory operations;
>>>         in terms of cpu, only one I know that allows this is the
>>>         Alpha.  But he has a separate argument about not relying on
>>>         memory dependence to enforce any ordering ...
>>>
>>>
>>>
>>>
>>>
>>>
>>>         On Mon, Sep 22, 2014 at 3:14 PM, vikas
>>>         <vikas.vksingh at gmail.com <mailto:vikas.vksingh at gmail.com>>
>>>         wrote:
>>>
>>>
>>>             I was reading a article from Hans and he argues that
>>>             LoadStore is also
>>>             needed before lazySet or a final variable write (i
>>>             assume then also before
>>>             volatile write).
>>>
>>>             He demonstrated a particular race condition which i
>>>             couldn't understand
>>>             (link below).
>>>
>>>             http://www.hboehm.info/c++mm/no_write_fences.html see
>>>             *Recipient writes to
>>>             object*.
>>>
>>>             Its very counter intuitive how  * store of x.a = 43* can
>>>             be done past the
>>>             StoreStore barrier in thread 1.
>>>             *
>>>             x.a = 0; x.a++;
>>>             x_init.store_write_release(true);
>>>
>>>             and the code that uses x in thread 2 updates it, with e.g.
>>>
>>>             if (x_init.load_acquire())
>>>                 x.a = 42;*
>>>
>>>
>>>             Similar argument here
>>>             http://shipilev.net/blog/2014/all-fields-are-final/
>>>
>>>             Copying Shiplev here :
>>>
>>>             /JSR 133 Cookbook only requires StoreStore, but might
>>>             also require LoadStore
>>>             barriers. This covers for a corner case when the final
>>>             field is getting
>>>             initialized off some other field which experiences a
>>>             racy update. *This
>>>             corner case can be enabled by runtime optimization which
>>>             figures out the
>>>             final store is not needed, puts the value in the local
>>>             variable, and hence
>>>             breaks out of ordering guarantees of StoreStore alone*/
>>>
>>>             How runtime can figure out that final Store is not
>>>             needed, also if load is
>>>             getting passed/reorder the StoreStore Barrier then Store
>>>             to local Variable
>>>             also is getting passed/reorder with the storeStore
>>>             barrier, *This is the
>>>             part i don't quite understand , why store to local
>>>             variable can reorder with
>>>             StoreStore Barrier. *
>>>
>>>             It would be very help full if anybody can explain in
>>>             more details what is
>>>             the race condition they both are mentioning by some
>>>             simple example.
>>>
>>>
>>>
>>>
>>>             --
>>>             View this message in context:
>>>             http://jsr166-concurrency.10961.n7.nabble.com/LoadStore-and-StoreStore-are-both-are-required-before-lazySet-and-volatile-write-tp11291.html
>>>             Sent from the JSR166 Concurrency mailing list archive at
>>>             Nabble.com.
>>>             _______________________________________________
>>>             Concurrency-interest mailing list
>>>             Concurrency-interest at cs.oswego.edu
>>>             <mailto:Concurrency-interest at cs.oswego.edu>
>>>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>>
>>>
>>>         _______________________________________________
>>>         Concurrency-interest mailing list
>>>         Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140923/15b769aa/attachment-0001.html>

From vitalyd at gmail.com  Tue Sep 23 13:38:35 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 23 Sep 2014 13:38:35 -0400
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
In-Reply-To: <5421AC14.9050003@redhat.com>
References: <1411413285745-11291.post@n7.nabble.com>
	<CAHjP37EMKkZbV8aPDWKmyZWW1qeK=iNYShW4e90yTRtyhxZWCA@mail.gmail.com>
	<542197C4.9020501@oracle.com>
	<CAHjP37H6GuS904eKzqL64Ooo9xZ+-Aajcrh2C-YrGz5UtcKSGg@mail.gmail.com>
	<5421AC14.9050003@redhat.com>
Message-ID: <CAHjP37E4QGV1JFFbpFv+dgR3Rp2-0MEaCWYP9nn2CYdoMQ_4KQ@mail.gmail.com>

>
> As I understand it, there is nothing in a memory model
> to prevent stores in Thread 2 after the load_acquire from floating up
> past the x_init.store_write_release in Thread 1.


Maybe nothing in memory model, but this would violate control flow
dependency though, wouldn't it? In order for thread 2 to execute the store,
it has to observe x_init being set to true -- there's explicit control
dependency there.  If thread 1 wrote that with a releasing store, then its
preceding stores are also visible at this point, so I don't see how thread
2's store can float above thread 1's releasing store; thread 1's releasing
store can get reordered within its own operations (like the x.a++ example),
causing thread 2 to perform the write at an "earlier" point in thread 1's
program order (is that what you meant?).

On Tue, Sep 23, 2014 at 1:21 PM, Andrew Haley <aph at redhat.com> wrote:

> The key phrase is "it doesn't make sense to enforce ordering based on
> dependencies, since they cannot be reliably defined *at this level*."
>
> In other words, once you start translating the example into machine
> instructions you can nail it down in ways that aren't imposed by the
> memory model.  As I understand it, there is nothing in a memory model
> to prevent stores in Thread 2 after the load_acquire from floating up
> past the x_init.store_write_release in Thread 1.
>
> Andrew.
>
>
> On 09/23/2014 05:04 PM, Vitaly Davidovich wrote:
> > That would be somewhat hard to believe as this means something (compiler
> or
> > cpu) speculated about x_init.load_acquire() returning true but wrote to
> > memory beforehand? A cpu can speculate like this, I suppose, but it
> > wouldn't be able to actually retire the store of 42 until the speculation
> > is proven correct, at which point the store is committed (but then this
> > doesn't change observed behavior).  Or did you mean something else?
> >
> > On Tue, Sep 23, 2014 at 11:54 AM, Oleksandr Otenko <
> > oleksandr.otenko at oracle.com> wrote:
> >
> >>  Is this sufficient?
> >>
> >> Without LoadStore in the second thread, Thread 2 is allowed to observe x
> >> after writing x.a=42. I am not sure what that means to Thread 1.
> >>
> >> Alex
> >>
> >>
> >> On 22/09/2014 21:31, Vitaly Davidovich wrote:
> >>
> >> For Hans' example, he's basically saying this:
> >> x.a = 0;
> >> tmp = x.a; << read of x itself
> >> tmp = tmp + 1;
> >> x.a = tmp;
> >> x.init_store_write_release(true);
> >>
> >>  The argument is that if only stores are ordered and loads can be
> >> reordered with the stores, then the read of x.a could be reordered with
> the
> >> releasing store, i.e.:
> >>  x.a = 0;
> >> x.init_store_write_release(true);
> >>  tmp = x.a; << this load re-ordered with the store and may now see x.a =
> >> 42 if thread 2 ran
> >> tmp = tmp + 1;
> >> x.a = tmp; << results in x.a = 43
> >>
> >>  As Hans mentions, this is somewhat esoteric and strange.  It would
> >> require something (e.g. cpu, compiler) determining/allowing reordering
> >> dependent memory operations; in terms of cpu, only one I know that
> allows
> >> this is the Alpha.  But he has a separate argument about not relying on
> >> memory dependence to enforce any ordering ...
> >>
> >>
> >>
> >>
> >>
> >>
> >> On Mon, Sep 22, 2014 at 3:14 PM, vikas <vikas.vksingh at gmail.com> wrote:
> >>
> >>>
> >>> I was reading a article from Hans and he argues that LoadStore is also
> >>> needed before lazySet or a final variable write (i assume then also
> before
> >>> volatile write).
> >>>
> >>> He demonstrated a particular race condition which i couldn't understand
> >>> (link below).
> >>>
> >>> http://www.hboehm.info/c++mm/no_write_fences.html see *Recipient
> writes
> >>> to
> >>> object*.
> >>>
> >>> Its very counter intuitive how  * store of x.a = 43* can be done past
> the
> >>> StoreStore barrier in thread 1.
> >>> *
> >>> x.a = 0; x.a++;
> >>> x_init.store_write_release(true);
> >>>
> >>> and the code that uses x in thread 2 updates it, with e.g.
> >>>
> >>> if (x_init.load_acquire())
> >>>     x.a = 42;*
> >>>
> >>>
> >>> Similar argument here
> http://shipilev.net/blog/2014/all-fields-are-final/
> >>>
> >>> Copying Shiplev here :
> >>>
> >>> /JSR 133 Cookbook only requires StoreStore, but might also require
> >>> LoadStore
> >>> barriers. This covers for a corner case when the final field is getting
> >>> initialized off some other field which experiences a racy update. *This
> >>> corner case can be enabled by runtime optimization which figures out
> the
> >>> final store is not needed, puts the value in the local variable, and
> hence
> >>> breaks out of ordering guarantees of StoreStore alone*/
> >>>
> >>> How runtime can figure out that final Store is not needed, also if
> load is
> >>> getting passed/reorder the StoreStore Barrier then Store to local
> Variable
> >>> also is getting passed/reorder with the storeStore barrier, *This is
> the
> >>> part i don't quite understand , why store to local variable can reorder
> >>> with
> >>> StoreStore Barrier. *
> >>>
> >>> It would be very help full if anybody can explain in more details what
> is
> >>> the race condition they both are mentioning by some simple example.
> >>>
> >>>
> >>>
> >>>
> >>> --
> >>> View this message in context:
> >>>
> http://jsr166-concurrency.10961.n7.nabble.com/LoadStore-and-StoreStore-are-both-are-required-before-lazySet-and-volatile-write-tp11291.html
> >>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>
> >>
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing listConcurrency-interest
> @cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >>
> >>
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140923/96927d19/attachment.html>

From aph at redhat.com  Tue Sep 23 13:53:08 2014
From: aph at redhat.com (Andrew Haley)
Date: Tue, 23 Sep 2014 18:53:08 +0100
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
In-Reply-To: <CAHjP37E4QGV1JFFbpFv+dgR3Rp2-0MEaCWYP9nn2CYdoMQ_4KQ@mail.gmail.com>
References: <1411413285745-11291.post@n7.nabble.com>	<CAHjP37EMKkZbV8aPDWKmyZWW1qeK=iNYShW4e90yTRtyhxZWCA@mail.gmail.com>	<542197C4.9020501@oracle.com>	<CAHjP37H6GuS904eKzqL64Ooo9xZ+-Aajcrh2C-YrGz5UtcKSGg@mail.gmail.com>	<5421AC14.9050003@redhat.com>
	<CAHjP37E4QGV1JFFbpFv+dgR3Rp2-0MEaCWYP9nn2CYdoMQ_4KQ@mail.gmail.com>
Message-ID: <5421B384.5070006@redhat.com>

On 09/23/2014 06:38 PM, Vitaly Davidovich wrote:
>>
>> As I understand it, there is nothing in a memory model
>> to prevent stores in Thread 2 after the load_acquire from floating up
>> past the x_init.store_write_release in Thread 1.
> 
> 
> Maybe nothing in memory model, but this would violate control flow
> dependency though, wouldn't it? In order for thread 2 to execute the store,
> it has to observe x_init being set to true -- there's explicit control
> dependency there.

That's right.  However, he goes on to say

"it doesn't make sense to enforce ordering based on dependencies"
http://www.hboehm.info/c++mm/dependencies.html

I think he's saying that the problem is that it while it is easy
enough to define what "dependence" means at the hardware level it's
much harder to define in the context of a memory model for a high-level
language.

But, to be honest, I am unaware of any compiler transformation which
would make the effect he's describing appear on any hardware of which
I'm aware.

> If thread 1 wrote that with a releasing store, then its
> preceding stores are also visible at this point, so I don't see how thread
> 2's store can float above thread 1's releasing store; thread 1's releasing
> store can get reordered within its own operations (like the x.a++ example),
> causing thread 2 to perform the write at an "earlier" point in thread 1's
> program order (is that what you meant?).

I am sorry, I was careless.  AIUI, it's the load in x.a++ which moves
after the the assignment x_init.

Thread 1:

x.a = 0; x.a++;
x_init.store_write_release(true);

Thread 2:

if (x_init.load_acquire())
    x.a = 42;

Andrew.

From vitalyd at gmail.com  Tue Sep 23 14:17:03 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 23 Sep 2014 14:17:03 -0400
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
In-Reply-To: <5421B384.5070006@redhat.com>
References: <1411413285745-11291.post@n7.nabble.com>
	<CAHjP37EMKkZbV8aPDWKmyZWW1qeK=iNYShW4e90yTRtyhxZWCA@mail.gmail.com>
	<542197C4.9020501@oracle.com>
	<CAHjP37H6GuS904eKzqL64Ooo9xZ+-Aajcrh2C-YrGz5UtcKSGg@mail.gmail.com>
	<5421AC14.9050003@redhat.com>
	<CAHjP37E4QGV1JFFbpFv+dgR3Rp2-0MEaCWYP9nn2CYdoMQ_4KQ@mail.gmail.com>
	<5421B384.5070006@redhat.com>
Message-ID: <CAHjP37HYm4EDfY=UDxksWQBa9ont8LcTQqeg4cRXrtvaDCTHkA@mail.gmail.com>

Ah yes, he does mention control dependency as well (I thought he was
talking about data only).  This whole thing is nasty ...

Yeah ok, load in x.a++ I got.

Sent from my phone
On Sep 23, 2014 1:53 PM, "Andrew Haley" <aph at redhat.com> wrote:

> On 09/23/2014 06:38 PM, Vitaly Davidovich wrote:
> >>
> >> As I understand it, there is nothing in a memory model
> >> to prevent stores in Thread 2 after the load_acquire from floating up
> >> past the x_init.store_write_release in Thread 1.
> >
> >
> > Maybe nothing in memory model, but this would violate control flow
> > dependency though, wouldn't it? In order for thread 2 to execute the
> store,
> > it has to observe x_init being set to true -- there's explicit control
> > dependency there.
>
> That's right.  However, he goes on to say
>
> "it doesn't make sense to enforce ordering based on dependencies"
> http://www.hboehm.info/c++mm/dependencies.html
>
> I think he's saying that the problem is that it while it is easy
> enough to define what "dependence" means at the hardware level it's
> much harder to define in the context of a memory model for a high-level
> language.
>
> But, to be honest, I am unaware of any compiler transformation which
> would make the effect he's describing appear on any hardware of which
> I'm aware.
>
> > If thread 1 wrote that with a releasing store, then its
> > preceding stores are also visible at this point, so I don't see how
> thread
> > 2's store can float above thread 1's releasing store; thread 1's
> releasing
> > store can get reordered within its own operations (like the x.a++
> example),
> > causing thread 2 to perform the write at an "earlier" point in thread 1's
> > program order (is that what you meant?).
>
> I am sorry, I was careless.  AIUI, it's the load in x.a++ which moves
> after the the assignment x_init.
>
> Thread 1:
>
> x.a = 0; x.a++;
> x_init.store_write_release(true);
>
> Thread 2:
>
> if (x_init.load_acquire())
>     x.a = 42;
>
> Andrew.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140923/b65c559d/attachment.html>

From aleksey.shipilev at oracle.com  Thu Sep 25 11:13:59 2014
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Thu, 25 Sep 2014 19:13:59 +0400
Subject: [concurrency-interest] LoadStore and StoreStore ,
 are both are required before lazySet and volatile write
In-Reply-To: <CAHjP37EDswdXOosspbi1RLDc0_6jM4xBst0=HnZ3C3eycOZ0VA@mail.gmail.com>
References: <1411413285745-11291.post@n7.nabble.com>
	<CAHjP37EDswdXOosspbi1RLDc0_6jM4xBst0=HnZ3C3eycOZ0VA@mail.gmail.com>
Message-ID: <54243137.6010404@oracle.com>

On 09/23/2014 12:50 AM, Vitaly Davidovich wrote:
> As for Aleksey's point, I don't quite follow why initializing a final
> field off some racy field *requires* a LoadStore.  Eliminating
> StoreStore may happen, I guess, if something like escape analysis
> removes the allocation of an object with final field and scalar replaces
> it.  But again, unsure why another racy memory location requires
> LoadStore (unless this is talking about same thing as Hans in different
> terms).

Ah yes, I do indeed reference Hans' example there: allowing loads to be
satisfied after the publication store may set us to "observe" the racy
update before the object is published. As Hans warns, trying to
interpret this on transformation level is confusing, and instead I
should have resorted to describe the high-level behavior. Fixed in my
text now.

Also, Hans moved from HP to Google, and that means all my HP links are
broken, argh. Fixed that as well.

-Aleksey.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140925/127e24b5/attachment.bin>

From discus at kotek.net  Thu Sep 25 15:00:07 2014
From: discus at kotek.net (Jan Kotek)
Date: Thu, 25 Sep 2014 22:00:07 +0300
Subject: [concurrency-interest] MapDB 2.0 as fast as ConcurrentSkiplListMap
Message-ID: <20140925220007.5ef5a69d@artemis>

Hi,

I would like to share some news about MapDB, it is library which
provides alternative java collections [1]

I started work on new version. It removes a few bottlenecks and in
result BTreeMap[2] now (almost) outperforms ConcurrentSkipListMap. 

Here is a benchmark [3] with 32 byte strings keys, 10 million records
and random get/set operations:

  ConcurrentSkipListMap
    get @ 254,107 per second
    set @ 236,540 per second 

  BTreeMap from MapDB 2.0
    get @ 335,648 per second
    set @ 198,475 per second

  HTreeMap from MapDB 2.0
    get @ 526,645 per second
    set @ 225,270 per second

I used smaller set to avoid GC overhead. With 100M+ entries result
would be very different since BTreeMap is not limited by GC. 

This is single thread test. BTreeMap with concurrent updates scales
linearly up-to 6 threads (cores), than it degrades. Improved memory
allocator should push it to around 16 cores. 

There are no dirty tricks here, current version does not even use
Unsafe. This project is 14 years old, and it has several improvements
to minimize overhead and save memory.

For example BTreeMap uses plug-able specialized keys. Keys in BTree
Node can be represented as long[], or strings can be
represented as class{ int stringOffsets; byte[] stringData }

I have lot of plans for MapDB 2.0. For example I would like to
implement parallel streams to execute operations concurrently.

I could use some help from skilled veterans on this mailing list. My
stress tests sometimes find rare race conditions. But formal
verification of most of concurrent code is beyond my skills. I am
slowly improving, but it takes a lot of time. 

All best,

Jan Kotek
MapDB author

[1]
http://www.mapdb.org/
https://github.com/jankotek/mapdb/

[2]
https://github.com/jankotek/MapDB/blob/master/src/main/java/org/mapdb/BTreeMap.java

[3] 
https://github.com/jankotek/mapdb-benchmarks

From stanimir at riflexo.com  Fri Sep 26 07:54:11 2014
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Fri, 26 Sep 2014 07:54:11 -0400
Subject: [concurrency-interest] MapDB 2.0 as fast as
	ConcurrentSkiplListMap
In-Reply-To: <20140925220007.5ef5a69d@artemis>
References: <20140925220007.5ef5a69d@artemis>
Message-ID: <CAEJX8op9Rb9rKfX55VcASu_anB+9mFAbPdfL-=yet3+T+rKNtQ@mail.gmail.com>

Hi Jan,

An issue with the tests, you are using a shared Random instance that would
be a major contention point.
Using random strings for both put and get doesn't make much sense to me,
the get operations are never likely to return anything (aside null) and the
put will always add a new entry in the map.

Someone may want to link the loop tests for the concurrent package to have
a peek at.

Cheers
Stanimir


On Thu, Sep 25, 2014 at 3:00 PM, Jan Kotek <discus at kotek.net> wrote:

> Hi,
>
> I would like to share some news about MapDB, it is library which
> provides alternative java collections [1]
>
> I started work on new version. It removes a few bottlenecks and in
> result BTreeMap[2] now (almost) outperforms ConcurrentSkipListMap.
>
> Here is a benchmark [3] with 32 byte strings keys, 10 million records
> and random get/set operations:
>
>   ConcurrentSkipListMap
>     get @ 254,107 per second
>     set @ 236,540 per second
>
>   BTreeMap from MapDB 2.0
>     get @ 335,648 per second
>     set @ 198,475 per second
>
>   HTreeMap from MapDB 2.0
>     get @ 526,645 per second
>     set @ 225,270 per second
>
> I used smaller set to avoid GC overhead. With 100M+ entries result
> would be very different since BTreeMap is not limited by GC.
>
> This is single thread test. BTreeMap with concurrent updates scales
> linearly up-to 6 threads (cores), than it degrades. Improved memory
> allocator should push it to around 16 cores.
>
> There are no dirty tricks here, current version does not even use
> Unsafe. This project is 14 years old, and it has several improvements
> to minimize overhead and save memory.
>
> For example BTreeMap uses plug-able specialized keys. Keys in BTree
> Node can be represented as long[], or strings can be
> represented as class{ int stringOffsets; byte[] stringData }
>
> I have lot of plans for MapDB 2.0. For example I would like to
> implement parallel streams to execute operations concurrently.
>
> I could use some help from skilled veterans on this mailing list. My
> stress tests sometimes find rare race conditions. But formal
> verification of most of concurrent code is beyond my skills. I am
> slowly improving, but it takes a lot of time.
>
> All best,
>
> Jan Kotek
> MapDB author
>
> [1]
> http://www.mapdb.org/
> https://github.com/jankotek/mapdb/
>
> [2]
>
> https://github.com/jankotek/MapDB/blob/master/src/main/java/org/mapdb/BTreeMap.java
>
> [3]
> https://github.com/jankotek/mapdb-benchmarks
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140926/8c64b6c5/attachment.html>

From thurston at nomagicsoftware.com  Sat Sep 27 07:35:23 2014
From: thurston at nomagicsoftware.com (thurstonn)
Date: Sat, 27 Sep 2014 04:35:23 -0700 (MST)
Subject: [concurrency-interest] final field/constructor visibility (cf.
	CyclicBarrier)
Message-ID: <1411817723290-11306.post@n7.nabble.com>

I have a question regarding the memory semantics of a constructor that sets
both a final and non-final field.

It was triggered by looking at j.u.c.CyclicBarrier which is defined:

<code>
final int parties
int count

CyclicBarrier(int parties)
   this.parties = parties;
   this.count = parties;
</code>

Now my understanding of the JMM is that any thread referencing the CB is
guaranteed to see  CB#parties as expected, but there is no guarantee that a
thread can't see CB#count = 0 //initialized state, i.e. the fact that the
constructor sets a final variable (#parties) has no bearing at all on any
guarantees of the visibility of #count (and as a side note, the code order
of the writes has no bearing at all either, i.e.

<code>
final int parties
int count

CyclicBarrier(int parties)
    this.count = parties;
    this.parties = parties;
   
</code>

has the same issue.

So the following is theoretically possible
T1                            T2
x = new CB(5)             assert x.getCount() == 5  //may fail

Now CB takes great care that all access of #count is under protection of a
lock (both reads and writes), but there is no happens-before edge between
the constructor writing to non-final #count and T2 (or T3, T4) acquiring the
lock and then reading #count.
In short (although there is a high presumption that the JDK is correct), CB
does not look multi thread-safe (to me).

I was expecting to see:

<code>
CyclicBarrier(int parties)
    this.lock.lock();
    this.count = parties;
    this.lock.unlock();
    this.parties = parties;
   
</code>
or something similar (of course the lock#lock() would be uncontended and so
shouldn't present any substantial performance cost); this would provide the
necessary happens-before edge (release of lock happens-before any subsequent
acquisition of said lock).


As a side note, this is not the situation that generally causes confusion
with respect to final field visibility guarantees, e.g. where a constructor
writes a final Map field and then populates the Map (I think that's been
settled?)

Someone want to set me straight?






--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/final-field-constructor-visibility-cf-CyclicBarrier-tp11306.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From valentin.male.kovalenko at gmail.com  Sat Sep 27 12:28:07 2014
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Sat, 27 Sep 2014 20:28:07 +0400
Subject: [concurrency-interest] final field/constructor visibility (cf.
	CyclicBarrier)
Message-ID: <CAO-wXw+KK4ACF428EaiMhv-v5HawD2-Hnc1O=2-=H3DQYULo1A@mail.gmail.com>

Yes, you a right, if CB published via data race then JMM doesn't guarantee
that write to the field CB.count made in constructor will be visible to a
thread that didn't created CB instance. But it doesn't mean that CB is
broken, because CB's specification doesn't tell you that you'r allowed to
publish instances of CB via data race. The same is true for many classes
(e.g. AtomicLong and Co).




*>>As a side note, this is not the situation that generally causes
confusionwith respect to final field visibility guarantees, e.g. where a
constructorwrites a final Map field and then populates the Map (I think
that's beensettled?)*
In this case final semantics works.

On Sat, Sep 27, 2014 at 8:00 PM, <concurrency-interest-request at cs.oswego.edu
> wrote:

> Send Concurrency-interest mailing list submissions to
>         concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
>         concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
>         concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>    1. final field/constructor visibility (cf.   CyclicBarrier) (thurstonn)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Sat, 27 Sep 2014 04:35:23 -0700 (MST)
> From: thurstonn <thurston at nomagicsoftware.com>
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] final field/constructor visibility
>         (cf.    CyclicBarrier)
> Message-ID: <1411817723290-11306.post at n7.nabble.com>
> Content-Type: text/plain; charset=us-ascii
>
> I have a question regarding the memory semantics of a constructor that sets
> both a final and non-final field.
>
> It was triggered by looking at j.u.c.CyclicBarrier which is defined:
>
> <code>
> final int parties
> int count
>
> CyclicBarrier(int parties)
>    this.parties = parties;
>    this.count = parties;
> </code>
>
> Now my understanding of the JMM is that any thread referencing the CB is
> guaranteed to see  CB#parties as expected, but there is no guarantee that a
> thread can't see CB#count = 0 //initialized state, i.e. the fact that the
> constructor sets a final variable (#parties) has no bearing at all on any
> guarantees of the visibility of #count (and as a side note, the code order
> of the writes has no bearing at all either, i.e.
>
> <code>
> final int parties
> int count
>
> CyclicBarrier(int parties)
>     this.count = parties;
>     this.parties = parties;
>
> </code>
>
> has the same issue.
>
> So the following is theoretically possible
> T1                            T2
> x = new CB(5)             assert x.getCount() == 5  //may fail
>
> Now CB takes great care that all access of #count is under protection of a
> lock (both reads and writes), but there is no happens-before edge between
> the constructor writing to non-final #count and T2 (or T3, T4) acquiring
> the
> lock and then reading #count.
> In short (although there is a high presumption that the JDK is correct), CB
> does not look multi thread-safe (to me).
>
> I was expecting to see:
>
> <code>
> CyclicBarrier(int parties)
>     this.lock.lock();
>     this.count = parties;
>     this.lock.unlock();
>     this.parties = parties;
>
> </code>
> or something similar (of course the lock#lock() would be uncontended and so
> shouldn't present any substantial performance cost); this would provide the
> necessary happens-before edge (release of lock happens-before any
> subsequent
> acquisition of said lock).
>
>
> As a side note, this is not the situation that generally causes confusion
> with respect to final field visibility guarantees, e.g. where a constructor
> writes a final Map field and then populates the Map (I think that's been
> settled?)
>
> Someone want to set me straight?
>
>
>
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/final-field-constructor-visibility-cf-CyclicBarrier-tp11306.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 116, Issue 29
> *****************************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140927/880764f3/attachment.html>

From vitalyd at gmail.com  Sat Sep 27 15:04:26 2014
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Sat, 27 Sep 2014 15:04:26 -0400
Subject: [concurrency-interest] final field/constructor visibility (cf.
	CyclicBarrier)
In-Reply-To: <1411817723290-11306.post@n7.nabble.com>
References: <1411817723290-11306.post@n7.nabble.com>
Message-ID: <CAHjP37FVd99RLZCwC4Nd-M+9hX3zevV9H-b9doUp7amRrWAb2Q@mail.gmail.com>

I think you're right from JMM standpoint, but in practice Hotspot doesn't
track final fields individually.  It records whether any final field is
written in a ctor, and if so, emits barriers.  So in reality, at least on
today's hotspot version, it will work as if both were final.

Sent from my phone
On Sep 27, 2014 8:19 AM, "thurstonn" <thurston at nomagicsoftware.com> wrote:

> I have a question regarding the memory semantics of a constructor that sets
> both a final and non-final field.
>
> It was triggered by looking at j.u.c.CyclicBarrier which is defined:
>
> <code>
> final int parties
> int count
>
> CyclicBarrier(int parties)
>    this.parties = parties;
>    this.count = parties;
> </code>
>
> Now my understanding of the JMM is that any thread referencing the CB is
> guaranteed to see  CB#parties as expected, but there is no guarantee that a
> thread can't see CB#count = 0 //initialized state, i.e. the fact that the
> constructor sets a final variable (#parties) has no bearing at all on any
> guarantees of the visibility of #count (and as a side note, the code order
> of the writes has no bearing at all either, i.e.
>
> <code>
> final int parties
> int count
>
> CyclicBarrier(int parties)
>     this.count = parties;
>     this.parties = parties;
>
> </code>
>
> has the same issue.
>
> So the following is theoretically possible
> T1                            T2
> x = new CB(5)             assert x.getCount() == 5  //may fail
>
> Now CB takes great care that all access of #count is under protection of a
> lock (both reads and writes), but there is no happens-before edge between
> the constructor writing to non-final #count and T2 (or T3, T4) acquiring
> the
> lock and then reading #count.
> In short (although there is a high presumption that the JDK is correct), CB
> does not look multi thread-safe (to me).
>
> I was expecting to see:
>
> <code>
> CyclicBarrier(int parties)
>     this.lock.lock();
>     this.count = parties;
>     this.lock.unlock();
>     this.parties = parties;
>
> </code>
> or something similar (of course the lock#lock() would be uncontended and so
> shouldn't present any substantial performance cost); this would provide the
> necessary happens-before edge (release of lock happens-before any
> subsequent
> acquisition of said lock).
>
>
> As a side note, this is not the situation that generally causes confusion
> with respect to final field visibility guarantees, e.g. where a constructor
> writes a final Map field and then populates the Map (I think that's been
> settled?)
>
> Someone want to set me straight?
>
>
>
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/final-field-constructor-visibility-cf-CyclicBarrier-tp11306.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140927/ad857059/attachment.html>

From thurston at nomagicsoftware.com  Sun Sep 28 03:18:44 2014
From: thurston at nomagicsoftware.com (thurstonn)
Date: Sun, 28 Sep 2014 00:18:44 -0700 (MST)
Subject: [concurrency-interest] final field/constructor visibility (cf.
	CyclicBarrier)
In-Reply-To: <1411817723290-11306.post@n7.nabble.com>
References: <1411817723290-11306.post@n7.nabble.com>
Message-ID: <1411888724012-11309.post@n7.nabble.com>

But why not as I referenced?

<code>
CyclicBarrier(int parties)
    this.lock.lock();
    this.count = parties;
    this.lock.unlock();
    this.parties = parties;

</code>


Is it just somehow unappealing/ungainly (not often you see self-lock
acquisition in a constructor - can't say I like it that much)?

Of course you're right about safe publication,and I should have referenced
the fact that it's only unsafe in the face of improper publication.

Still I think it's valuable to have j.u.c objects be "either null or
multi-thread safe" where possible (e.g. ReentrantLock)



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/final-field-constructor-visibility-cf-CyclicBarrier-tp11306p11309.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From yankee.sierra at gmail.com  Sun Sep 28 11:43:17 2014
From: yankee.sierra at gmail.com (Yuval Shavit)
Date: Sun, 28 Sep 2014 11:43:17 -0400
Subject: [concurrency-interest] final field/constructor visibility (cf.
	CyclicBarrier)
In-Reply-To: <1411888724012-11309.post@n7.nabble.com>
References: <1411817723290-11306.post@n7.nabble.com>
	<1411888724012-11309.post@n7.nabble.com>
Message-ID: <CAE+h5-C9R2wFA-6NAvKfx2-TnMAZ=mT2F50FSfV-SCSGM_9vig@mail.gmail.com>

This is somewhat related to a discussion I started here on synchronized
constructors (specifically, why they're not allowed). In particular:
http://cs.oswego.edu/pipermail/concurrency-interest/2011-December/008634.html

The short of it is that your code is _still_ not safe in the face of unsafe
publication. Yes, you establish HB relationships between the lock/unlock in
the constructor and other lock/unlocks -- but you still haven't guaranteed
that the constructor is seen first, as un-intuitive as that sounds. Some
thread could see (for instance) a getter invoked before the constructor. In
that case, the default value happens-before the getter, which
happens-before the constructor. Clearly, that's not helpful, but it's valid
according to a strict reading of the JMM.

To be safe even in the face of unsafe publication, you'd need to not just
establish just any old HB edge, but more precisely to ensure that the
constructor happens-before everything else. One way to do that could be:

    volatile boolean ctorFinished;

    CyclicBarrier(int parties) {
        // lock/unlock, set this.count and this.parties...
        ctorFinished = true;
    }

    int getCount() {
        while (!ctorFinished) {} // spin, wait for the ctor to finish on
the instantiating thread
        this.lock.lock();
        // etc
    }



On Sun, Sep 28, 2014 at 3:18 AM, thurstonn <thurston at nomagicsoftware.com>
wrote:

> But why not as I referenced?
>
> <code>
> CyclicBarrier(int parties)
>     this.lock.lock();
>     this.count = parties;
>     this.lock.unlock();
>     this.parties = parties;
>
> </code>
>
>
> Is it just somehow unappealing/ungainly (not often you see self-lock
> acquisition in a constructor - can't say I like it that much)?
>
> Of course you're right about safe publication,and I should have referenced
> the fact that it's only unsafe in the face of improper publication.
>
> Still I think it's valuable to have j.u.c objects be "either null or
> multi-thread safe" where possible (e.g. ReentrantLock)
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/final-field-constructor-visibility-cf-CyclicBarrier-tp11306p11309.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140928/fba65288/attachment-0001.html>

From zhong.j.yu at gmail.com  Sun Sep 28 18:30:20 2014
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Sun, 28 Sep 2014 17:30:20 -0500
Subject: [concurrency-interest] final field/constructor visibility (cf.
	CyclicBarrier)
In-Reply-To: <CAE+h5-C9R2wFA-6NAvKfx2-TnMAZ=mT2F50FSfV-SCSGM_9vig@mail.gmail.com>
References: <1411817723290-11306.post@n7.nabble.com>
	<1411888724012-11309.post@n7.nabble.com>
	<CAE+h5-C9R2wFA-6NAvKfx2-TnMAZ=mT2F50FSfV-SCSGM_9vig@mail.gmail.com>
Message-ID: <CACuKZqFgtscsN1eLn3CHuc=ys4DtJ3O-KgdBtmL4KqUpR1RkaQ@mail.gmail.com>

On Sun, Sep 28, 2014 at 10:43 AM, Yuval Shavit <yankee.sierra at gmail.com> wrote:
> This is somewhat related to a discussion I started here on synchronized
> constructors (specifically, why they're not allowed). In particular:
> http://cs.oswego.edu/pipermail/concurrency-interest/2011-December/008634.html

The conclusion of that thread is that synchronized constructor *works*
even with unsafe publication. See
http://cs.oswego.edu/pipermail/concurrency-interest/2011-December/008642.html

I made the opposite and wrong assertion in that thread, which
fortunately was corrected by others. Sorry about that.

thurstonn's code with locking inside constructor should work as he expected.

Zhong Yu
bayou.io


>
> The short of it is that your code is _still_ not safe in the face of unsafe
> publication. Yes, you establish HB relationships between the lock/unlock in
> the constructor and other lock/unlocks -- but you still haven't guaranteed
> that the constructor is seen first, as un-intuitive as that sounds. Some
> thread could see (for instance) a getter invoked before the constructor. In
> that case, the default value happens-before the getter, which happens-before
> the constructor. Clearly, that's not helpful, but it's valid according to a
> strict reading of the JMM.
>
> To be safe even in the face of unsafe publication, you'd need to not just
> establish just any old HB edge, but more precisely to ensure that the
> constructor happens-before everything else. One way to do that could be:
>
>     volatile boolean ctorFinished;
>
>     CyclicBarrier(int parties) {
>         // lock/unlock, set this.count and this.parties...
>         ctorFinished = true;
>     }
>
>     int getCount() {
>         while (!ctorFinished) {} // spin, wait for the ctor to finish on the
> instantiating thread
>         this.lock.lock();
>         // etc
>     }
>
>
>
> On Sun, Sep 28, 2014 at 3:18 AM, thurstonn <thurston at nomagicsoftware.com>
> wrote:
>>
>> But why not as I referenced?
>>
>> <code>
>> CyclicBarrier(int parties)
>>     this.lock.lock();
>>     this.count = parties;
>>     this.lock.unlock();
>>     this.parties = parties;
>>
>> </code>
>>
>>
>> Is it just somehow unappealing/ungainly (not often you see self-lock
>> acquisition in a constructor - can't say I like it that much)?
>>
>> Of course you're right about safe publication,and I should have referenced
>> the fact that it's only unsafe in the face of improper publication.
>>
>> Still I think it's valuable to have j.u.c objects be "either null or
>> multi-thread safe" where possible (e.g. ReentrantLock)
>>
>>
>>
>> --
>> View this message in context:
>> http://jsr166-concurrency.10961.n7.nabble.com/final-field-constructor-visibility-cf-CyclicBarrier-tp11306p11309.html
>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From yankee.sierra at gmail.com  Sun Sep 28 19:52:54 2014
From: yankee.sierra at gmail.com (Yuval Shavit)
Date: Sun, 28 Sep 2014 19:52:54 -0400
Subject: [concurrency-interest] final field/constructor visibility (cf.
	CyclicBarrier)
In-Reply-To: <CACuKZqFgtscsN1eLn3CHuc=ys4DtJ3O-KgdBtmL4KqUpR1RkaQ@mail.gmail.com>
References: <1411817723290-11306.post@n7.nabble.com>
	<1411888724012-11309.post@n7.nabble.com>
	<CAE+h5-C9R2wFA-6NAvKfx2-TnMAZ=mT2F50FSfV-SCSGM_9vig@mail.gmail.com>
	<CACuKZqFgtscsN1eLn3CHuc=ys4DtJ3O-KgdBtmL4KqUpR1RkaQ@mail.gmail.com>
Message-ID: <CAE+h5-AZE8pWJ5VB0k20jNHDZ9_1gWkcM=OHRs1KwhmKu3KpnQ@mail.gmail.com>

I had forgotten about that email, but now that I'm re-reading it, I don't
understand it. Or rather, I understand its conclusions but not its initial
assertion. Specifically, *why* is publication-via-superclass the only way
to "beat" a synchronized constructor?

If the code is:

    Foo(int i) {
        synchronized (this) {
            this.i = i;
        }
    }

    synchronized int get() {
        return i;
    }

    static Foo unsafeFoo;

    static void installFoo() {
        unsafeFoo = new Foo(1);
    }

... then the only HB edges we've established are that get() happens-before
<init> OR <init> happens-before get. There are no other HB edges I see, and
in particular there's no HB between <init> and the write to unsafeFoo in
installFoo, nor is there a HB between a write to unsafeFoo and a read from
it.

So, if another thread reads a non-null unsafeFoo and invokes get() on it, I
don't see what guarantees that the write to this.i in the constructor
happens-before the read to this.i in get(). One of them must formally
happen-before the other, but that's the only guarantee I see here.

Apologies if I've turned this thread into a zombie of a 2.5-year-old
thread, but I think the original question in this thread basically boils
down to the same issue.

On Sun, Sep 28, 2014 at 6:30 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> On Sun, Sep 28, 2014 at 10:43 AM, Yuval Shavit <yankee.sierra at gmail.com>
> wrote:
> > This is somewhat related to a discussion I started here on synchronized
> > constructors (specifically, why they're not allowed). In particular:
> >
> http://cs.oswego.edu/pipermail/concurrency-interest/2011-December/008634.html
>
> The conclusion of that thread is that synchronized constructor *works*
> even with unsafe publication. See
>
> http://cs.oswego.edu/pipermail/concurrency-interest/2011-December/008642.html
>
> I made the opposite and wrong assertion in that thread, which
> fortunately was corrected by others. Sorry about that.
>
> thurstonn's code with locking inside constructor should work as he
> expected.
>
> Zhong Yu
> bayou.io
>
>
> >
> > The short of it is that your code is _still_ not safe in the face of
> unsafe
> > publication. Yes, you establish HB relationships between the lock/unlock
> in
> > the constructor and other lock/unlocks -- but you still haven't
> guaranteed
> > that the constructor is seen first, as un-intuitive as that sounds. Some
> > thread could see (for instance) a getter invoked before the constructor.
> In
> > that case, the default value happens-before the getter, which
> happens-before
> > the constructor. Clearly, that's not helpful, but it's valid according
> to a
> > strict reading of the JMM.
> >
> > To be safe even in the face of unsafe publication, you'd need to not just
> > establish just any old HB edge, but more precisely to ensure that the
> > constructor happens-before everything else. One way to do that could be:
> >
> >     volatile boolean ctorFinished;
> >
> >     CyclicBarrier(int parties) {
> >         // lock/unlock, set this.count and this.parties...
> >         ctorFinished = true;
> >     }
> >
> >     int getCount() {
> >         while (!ctorFinished) {} // spin, wait for the ctor to finish on
> the
> > instantiating thread
> >         this.lock.lock();
> >         // etc
> >     }
> >
> >
> >
> > On Sun, Sep 28, 2014 at 3:18 AM, thurstonn <thurston at nomagicsoftware.com
> >
> > wrote:
> >>
> >> But why not as I referenced?
> >>
> >> <code>
> >> CyclicBarrier(int parties)
> >>     this.lock.lock();
> >>     this.count = parties;
> >>     this.lock.unlock();
> >>     this.parties = parties;
> >>
> >> </code>
> >>
> >>
> >> Is it just somehow unappealing/ungainly (not often you see self-lock
> >> acquisition in a constructor - can't say I like it that much)?
> >>
> >> Of course you're right about safe publication,and I should have
> referenced
> >> the fact that it's only unsafe in the face of improper publication.
> >>
> >> Still I think it's valuable to have j.u.c objects be "either null or
> >> multi-thread safe" where possible (e.g. ReentrantLock)
> >>
> >>
> >>
> >> --
> >> View this message in context:
> >>
> http://jsr166-concurrency.10961.n7.nabble.com/final-field-constructor-visibility-cf-CyclicBarrier-tp11306p11309.html
> >> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140928/5041493e/attachment.html>

From zhong.j.yu at gmail.com  Sun Sep 28 21:23:39 2014
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Sun, 28 Sep 2014 20:23:39 -0500
Subject: [concurrency-interest] final field/constructor visibility (cf.
	CyclicBarrier)
In-Reply-To: <CAE+h5-AZE8pWJ5VB0k20jNHDZ9_1gWkcM=OHRs1KwhmKu3KpnQ@mail.gmail.com>
References: <1411817723290-11306.post@n7.nabble.com>
	<1411888724012-11309.post@n7.nabble.com>
	<CAE+h5-C9R2wFA-6NAvKfx2-TnMAZ=mT2F50FSfV-SCSGM_9vig@mail.gmail.com>
	<CACuKZqFgtscsN1eLn3CHuc=ys4DtJ3O-KgdBtmL4KqUpR1RkaQ@mail.gmail.com>
	<CAE+h5-AZE8pWJ5VB0k20jNHDZ9_1gWkcM=OHRs1KwhmKu3KpnQ@mail.gmail.com>
Message-ID: <CACuKZqEQb=SZ6dP5SkjGN=BvHOUuePR1x59uWXyWMz15jrh0NA@mail.gmail.com>

Thread 1

synchronized(v1) { ... }  // [s1]
unsafeFoo = v1;  // [w]

Thread 2

v2 = unsafeFoo; // [r]
if(v2!=null)
    synchronized(v2) { ... }  // [s2]

If [s2] is ordered before [s1], then [r] happens-before [w]; at the
same time, [r] observes [w]. This is not allowed in JMM. See
http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5-500

Zhong Yu
bayou.io



On Sun, Sep 28, 2014 at 6:52 PM, Yuval Shavit <yankee.sierra at gmail.com> wrote:
> I had forgotten about that email, but now that I'm re-reading it, I don't
> understand it. Or rather, I understand its conclusions but not its initial
> assertion. Specifically, *why* is publication-via-superclass the only way to
> "beat" a synchronized constructor?
>
> If the code is:
>
>     Foo(int i) {
>         synchronized (this) {
>             this.i = i;
>         }
>     }
>
>     synchronized int get() {
>         return i;
>     }
>
>     static Foo unsafeFoo;
>
>     static void installFoo() {
>         unsafeFoo = new Foo(1);
>     }
>
> ... then the only HB edges we've established are that get() happens-before
> <init> OR <init> happens-before get. There are no other HB edges I see, and
> in particular there's no HB between <init> and the write to unsafeFoo in
> installFoo, nor is there a HB between a write to unsafeFoo and a read from
> it.
>
> So, if another thread reads a non-null unsafeFoo and invokes get() on it, I
> don't see what guarantees that the write to this.i in the constructor
> happens-before the read to this.i in get(). One of them must formally
> happen-before the other, but that's the only guarantee I see here.
>
> Apologies if I've turned this thread into a zombie of a 2.5-year-old thread,
> but I think the original question in this thread basically boils down to the
> same issue.
>
> On Sun, Sep 28, 2014 at 6:30 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>
>> On Sun, Sep 28, 2014 at 10:43 AM, Yuval Shavit <yankee.sierra at gmail.com>
>> wrote:
>> > This is somewhat related to a discussion I started here on synchronized
>> > constructors (specifically, why they're not allowed). In particular:
>> >
>> > http://cs.oswego.edu/pipermail/concurrency-interest/2011-December/008634.html
>>
>> The conclusion of that thread is that synchronized constructor *works*
>> even with unsafe publication. See
>>
>> http://cs.oswego.edu/pipermail/concurrency-interest/2011-December/008642.html
>>
>> I made the opposite and wrong assertion in that thread, which
>> fortunately was corrected by others. Sorry about that.
>>
>> thurstonn's code with locking inside constructor should work as he
>> expected.
>>
>> Zhong Yu
>> bayou.io
>>
>>
>> >
>> > The short of it is that your code is _still_ not safe in the face of
>> > unsafe
>> > publication. Yes, you establish HB relationships between the lock/unlock
>> > in
>> > the constructor and other lock/unlocks -- but you still haven't
>> > guaranteed
>> > that the constructor is seen first, as un-intuitive as that sounds. Some
>> > thread could see (for instance) a getter invoked before the constructor.
>> > In
>> > that case, the default value happens-before the getter, which
>> > happens-before
>> > the constructor. Clearly, that's not helpful, but it's valid according
>> > to a
>> > strict reading of the JMM.
>> >
>> > To be safe even in the face of unsafe publication, you'd need to not
>> > just
>> > establish just any old HB edge, but more precisely to ensure that the
>> > constructor happens-before everything else. One way to do that could be:
>> >
>> >     volatile boolean ctorFinished;
>> >
>> >     CyclicBarrier(int parties) {
>> >         // lock/unlock, set this.count and this.parties...
>> >         ctorFinished = true;
>> >     }
>> >
>> >     int getCount() {
>> >         while (!ctorFinished) {} // spin, wait for the ctor to finish on
>> > the
>> > instantiating thread
>> >         this.lock.lock();
>> >         // etc
>> >     }
>> >
>> >
>> >
>> > On Sun, Sep 28, 2014 at 3:18 AM, thurstonn
>> > <thurston at nomagicsoftware.com>
>> > wrote:
>> >>
>> >> But why not as I referenced?
>> >>
>> >> <code>
>> >> CyclicBarrier(int parties)
>> >>     this.lock.lock();
>> >>     this.count = parties;
>> >>     this.lock.unlock();
>> >>     this.parties = parties;
>> >>
>> >> </code>
>> >>
>> >>
>> >> Is it just somehow unappealing/ungainly (not often you see self-lock
>> >> acquisition in a constructor - can't say I like it that much)?
>> >>
>> >> Of course you're right about safe publication,and I should have
>> >> referenced
>> >> the fact that it's only unsafe in the face of improper publication.
>> >>
>> >> Still I think it's valuable to have j.u.c objects be "either null or
>> >> multi-thread safe" where possible (e.g. ReentrantLock)
>> >>
>> >>
>> >>
>> >> --
>> >> View this message in context:
>> >>
>> >> http://jsr166-concurrency.10961.n7.nabble.com/final-field-constructor-visibility-cf-CyclicBarrier-tp11306p11309.html
>> >> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>
>

From yankee.sierra at gmail.com  Sun Sep 28 22:58:00 2014
From: yankee.sierra at gmail.com (Yuval Shavit)
Date: Sun, 28 Sep 2014 22:58:00 -0400
Subject: [concurrency-interest] final field/constructor visibility (cf.
	CyclicBarrier)
In-Reply-To: <CACuKZqEQb=SZ6dP5SkjGN=BvHOUuePR1x59uWXyWMz15jrh0NA@mail.gmail.com>
References: <1411817723290-11306.post@n7.nabble.com>
	<1411888724012-11309.post@n7.nabble.com>
	<CAE+h5-C9R2wFA-6NAvKfx2-TnMAZ=mT2F50FSfV-SCSGM_9vig@mail.gmail.com>
	<CACuKZqFgtscsN1eLn3CHuc=ys4DtJ3O-KgdBtmL4KqUpR1RkaQ@mail.gmail.com>
	<CAE+h5-AZE8pWJ5VB0k20jNHDZ9_1gWkcM=OHRs1KwhmKu3KpnQ@mail.gmail.com>
	<CACuKZqEQb=SZ6dP5SkjGN=BvHOUuePR1x59uWXyWMz15jrh0NA@mail.gmail.com>
Message-ID: <CAE+h5-DKNx2EAwdtKARpbR=zJgiHRsYAMmwiYyvcPFK=a_mbcA@mail.gmail.com>

> If [s2] is ordered before [s1], then [r] happens-before [w]

I don't see why this is the case. It would certainly be true if [s1]
happened-before [w] and [r] happened-before [s2], but that's not the case.
Thread 1 will act as if hb(s1, w) because of same-thread semantics, and
similarly for thread 2 acting as if hb(r, s2), but neither edge is
established outside of its respective thread.

In other words, it seems that you are saying:

- given hb(r, s2) and hb(s1, w)
- let hb(s2, s1)
- therefore hb(r, w) by 17.4.5 ("If hb(x, y) and hb(y, z), then hb(x, z)")

But the two HB edges in that first bullet are not there. I fail to see how
hb(s2, s1) implies hb(r, w), and the introduction of the data race ([r] and
[w]) means that the program does not have to be sequentially consistent.

On Sun, Sep 28, 2014 at 9:23 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> Thread 1
>
> synchronized(v1) { ... }  // [s1]
> unsafeFoo = v1;  // [w]
>
> Thread 2
>
> v2 = unsafeFoo; // [r]
> if(v2!=null)
>     synchronized(v2) { ... }  // [s2]
>
> If [s2] is ordered before [s1], then [r] happens-before [w]; at the
> same time, [r] observes [w]. This is not allowed in JMM. See
> http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5-500
>
> Zhong Yu
> bayou.io
>
>
>
> On Sun, Sep 28, 2014 at 6:52 PM, Yuval Shavit <yankee.sierra at gmail.com>
> wrote:
> > I had forgotten about that email, but now that I'm re-reading it, I don't
> > understand it. Or rather, I understand its conclusions but not its
> initial
> > assertion. Specifically, *why* is publication-via-superclass the only
> way to
> > "beat" a synchronized constructor?
> >
> > If the code is:
> >
> >     Foo(int i) {
> >         synchronized (this) {
> >             this.i = i;
> >         }
> >     }
> >
> >     synchronized int get() {
> >         return i;
> >     }
> >
> >     static Foo unsafeFoo;
> >
> >     static void installFoo() {
> >         unsafeFoo = new Foo(1);
> >     }
> >
> > ... then the only HB edges we've established are that get()
> happens-before
> > <init> OR <init> happens-before get. There are no other HB edges I see,
> and
> > in particular there's no HB between <init> and the write to unsafeFoo in
> > installFoo, nor is there a HB between a write to unsafeFoo and a read
> from
> > it.
> >
> > So, if another thread reads a non-null unsafeFoo and invokes get() on
> it, I
> > don't see what guarantees that the write to this.i in the constructor
> > happens-before the read to this.i in get(). One of them must formally
> > happen-before the other, but that's the only guarantee I see here.
> >
> > Apologies if I've turned this thread into a zombie of a 2.5-year-old
> thread,
> > but I think the original question in this thread basically boils down to
> the
> > same issue.
> >
> > On Sun, Sep 28, 2014 at 6:30 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
> >>
> >> On Sun, Sep 28, 2014 at 10:43 AM, Yuval Shavit <yankee.sierra at gmail.com
> >
> >> wrote:
> >> > This is somewhat related to a discussion I started here on
> synchronized
> >> > constructors (specifically, why they're not allowed). In particular:
> >> >
> >> >
> http://cs.oswego.edu/pipermail/concurrency-interest/2011-December/008634.html
> >>
> >> The conclusion of that thread is that synchronized constructor *works*
> >> even with unsafe publication. See
> >>
> >>
> http://cs.oswego.edu/pipermail/concurrency-interest/2011-December/008642.html
> >>
> >> I made the opposite and wrong assertion in that thread, which
> >> fortunately was corrected by others. Sorry about that.
> >>
> >> thurstonn's code with locking inside constructor should work as he
> >> expected.
> >>
> >> Zhong Yu
> >> bayou.io
> >>
> >>
> >> >
> >> > The short of it is that your code is _still_ not safe in the face of
> >> > unsafe
> >> > publication. Yes, you establish HB relationships between the
> lock/unlock
> >> > in
> >> > the constructor and other lock/unlocks -- but you still haven't
> >> > guaranteed
> >> > that the constructor is seen first, as un-intuitive as that sounds.
> Some
> >> > thread could see (for instance) a getter invoked before the
> constructor.
> >> > In
> >> > that case, the default value happens-before the getter, which
> >> > happens-before
> >> > the constructor. Clearly, that's not helpful, but it's valid according
> >> > to a
> >> > strict reading of the JMM.
> >> >
> >> > To be safe even in the face of unsafe publication, you'd need to not
> >> > just
> >> > establish just any old HB edge, but more precisely to ensure that the
> >> > constructor happens-before everything else. One way to do that could
> be:
> >> >
> >> >     volatile boolean ctorFinished;
> >> >
> >> >     CyclicBarrier(int parties) {
> >> >         // lock/unlock, set this.count and this.parties...
> >> >         ctorFinished = true;
> >> >     }
> >> >
> >> >     int getCount() {
> >> >         while (!ctorFinished) {} // spin, wait for the ctor to finish
> on
> >> > the
> >> > instantiating thread
> >> >         this.lock.lock();
> >> >         // etc
> >> >     }
> >> >
> >> >
> >> >
> >> > On Sun, Sep 28, 2014 at 3:18 AM, thurstonn
> >> > <thurston at nomagicsoftware.com>
> >> > wrote:
> >> >>
> >> >> But why not as I referenced?
> >> >>
> >> >> <code>
> >> >> CyclicBarrier(int parties)
> >> >>     this.lock.lock();
> >> >>     this.count = parties;
> >> >>     this.lock.unlock();
> >> >>     this.parties = parties;
> >> >>
> >> >> </code>
> >> >>
> >> >>
> >> >> Is it just somehow unappealing/ungainly (not often you see self-lock
> >> >> acquisition in a constructor - can't say I like it that much)?
> >> >>
> >> >> Of course you're right about safe publication,and I should have
> >> >> referenced
> >> >> the fact that it's only unsafe in the face of improper publication.
> >> >>
> >> >> Still I think it's valuable to have j.u.c objects be "either null or
> >> >> multi-thread safe" where possible (e.g. ReentrantLock)
> >> >>
> >> >>
> >> >>
> >> >> --
> >> >> View this message in context:
> >> >>
> >> >>
> http://jsr166-concurrency.10961.n7.nabble.com/final-field-constructor-visibility-cf-CyclicBarrier-tp11306p11309.html
> >> >> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> >> >> _______________________________________________
> >> >> Concurrency-interest mailing list
> >> >> Concurrency-interest at cs.oswego.edu
> >> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> >
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140928/3d7acd4f/attachment-0001.html>

From jsampson at guidewire.com  Mon Sep 29 03:33:49 2014
From: jsampson at guidewire.com (Justin Sampson)
Date: Mon, 29 Sep 2014 07:33:49 +0000
Subject: [concurrency-interest] final field/constructor visibility
	(cf.	CyclicBarrier)
In-Reply-To: <CAE+h5-DKNx2EAwdtKARpbR=zJgiHRsYAMmwiYyvcPFK=a_mbcA@mail.gmail.com>
References: <1411817723290-11306.post@n7.nabble.com>
	<1411888724012-11309.post@n7.nabble.com>
	<CAE+h5-C9R2wFA-6NAvKfx2-TnMAZ=mT2F50FSfV-SCSGM_9vig@mail.gmail.com>
	<CACuKZqFgtscsN1eLn3CHuc=ys4DtJ3O-KgdBtmL4KqUpR1RkaQ@mail.gmail.com>
	<CAE+h5-AZE8pWJ5VB0k20jNHDZ9_1gWkcM=OHRs1KwhmKu3KpnQ@mail.gmail.com>
	<CACuKZqEQb=SZ6dP5SkjGN=BvHOUuePR1x59uWXyWMz15jrh0NA@mail.gmail.com>
	<CAE+h5-DKNx2EAwdtKARpbR=zJgiHRsYAMmwiYyvcPFK=a_mbcA@mail.gmail.com>
Message-ID: <0FD072A166C6DC4C851F6115F37DDD2763EF3367@sm-ex-01-vm.guidewire.com>

Yuval Shavit wrote:

> >?If [s2] is ordered before [s1], then [r] happens-before [w]
>
> I don't see why this is the case.  It would certainly be true if
> [s1] happened-before [w] and [r] happened-before [s2], but that's
> not the case.  Thread 1 will act as if hb(s1, w) because of same-
> thread semantics, and similarly for thread 2 acting as if hb(r,
> s2), but neither edge is established outside of its respective
> thread.

But isn't that exactly the point of happens-before, to establish
constraints between threads?  What happens _within_ a thread is
simply called "program order."  The very first rule in 17.4.5
establishes the relationship between program order and happens-
before order:  "If x and y are actions of the same thread and x
comes before y in program order, then hb(x, y)."  That is, program
order is subsumed within happens-before order.  But alone that's
not very interesting, because it still takes synchronization actions
and transitivity to actually introduce _constraints_ between
threads.  The existence of hb(x, y) for two actions of thread #1 is
irrelevant to thread #2, absent synchronization, simply because the
actions x and y are not actions of thread #2, not because the
relation hb(x, y) is established by another thread.

Cheers,
Justin



