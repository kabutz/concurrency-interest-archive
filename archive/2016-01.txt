From oleksandr.otenko at gmail.com  Mon Jan  4 05:34:38 2016
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 4 Jan 2016 10:34:38 +0000
Subject: [concurrency-interest] Explicitly initializing volatile fields
	with default values
In-Reply-To: <56732AF9.7030109@oracle.com>
References: <56732AF9.7030109@oracle.com>
Message-ID: <61E7C0E1-E94C-45B8-9093-7A3453B51406@gmail.com>

So, you are considering what the legitimate outcomes of a racy publication are, right? Since global in both cases is not volatile, I am not sure I understand the purpose of specifying a ?correct? initialization visibility order for values published in a way we discourage as error-prone. Do we have legitimate code that uses racy publication of this sort?

Alex

> On 17 Dec 2015, at 21:36, Aleksey Shipilev <aleksey.shipilev at oracle.com> wrote:
> 
> Hi there, concurrency dwellers,
> 
> I'm trying to find a counter-example/constraints against removing the
> field initializers for volatile fields, when those initializers are
> storing the default value. We know this improves performance, e.g.
>  https://bugs.openjdk.java.net/browse/JDK-8035284
> 
> There is a gut feeling that removing these initializations is safe. But,
> I have heard rumors of traces of counter-examples in OpenJDK bugtracker,
> but found nothing substantial, which gives me doubts. Maybe there are
> constraints I am overlooking?
> 
> First, let me show that you cannot (always) do this mechanically for all
> (even non-volatile!) usages. JLS 8.3.2.3 "Restrictions on the use of
> Fields during Initialization" allows this:
> 
> public class InitializerOverwrite {
>  {
>    x1 = 42;
>    x2 = 42;
>  }
> 
>  int x1;
>  int x2 = 0;
> 
>  public static void main(String... args) {
>    InitializerOverwrite io = new InitializerOverwrite();
>    System.out.println(io.x1); // 42
>    System.out.println(io.x2); // 0
>  }
> }
> 
> ...so you definitely need to inspect if there is some stray store that
> needs to be stamped out with the field initializer. What's worse,
> instance/field initializer can invoke an arbitrary method that might
> confuse any analysis, but still perform an instance field store. So, we
> can reliably do this optimization for simple cases only.
> 
> But let's consider a simpler case for concurrency implications:
> 
> class C {
>   volatile int v = 0; // can we drop " = 0"?
> 
>   public C() {
>     // nothing here
>   }
> }
> 
> Is there a plausible case that shows the semantical difference with
> field initializer storing a default value, and without one, that does
> *not* also affect single-threaded usages (i.e. it does not follow from
> the instance initialization sequence itself)?
> 
> Naive attempts to construct the examples seem to boil down to two cases.
> 
> *** Case A. Over-reaching "memory effects" for instance fields:
> 
> class A {
>   int f;
>   volatile int v = 0;
> 
>   public A() {
>     f = 42;
>   }
> }
> 
> A global;
> 
> ----
> 
> Thread 1:
>   global = new A();
> 
> Thread 2:
>   A a = global;
>   if (a != null && a.v == 0) {
>     print(a.f); // ?
>   }
> 
> There are no guarantees here whatsoever, because field initializations
> are performed *before* any constructor body starts, as per JLS 12.5.
> Therefore, the "releasing" volatile store to $v is executed before any
> store to $f, which deconstructs any happens-before.
> 
> This seems to expand to non-instance fields, and other variables written
> after firing the field initializer.
> 
> Note, that perhaps moving the initialization ($v = 0) into the
> constructor after ($f = 42), or, similarly, making ($f = 42) the field
> initializer, would lay out the code in the correct shape, and this gets
> us to case B.
> 
> 
> *** Case B. Transitive "memory effects" over explicit stores:
> 
> class B {
>   int f = 42;
>   volatile int v = 0;
> }
> 
> B global;
> 
> ----
> 
> Thread 1:
>   global = new B();
> 
> Thread 2:
>   B b = global;
>   if (b != null && b.v == 0) {
>     print(b.f); // ?
>   }
> 
> These three executions seem plausible:
> 
> 1) Happens-before read of write(f, 42):
> 
>  (default) write(v,0)
>  (default) write(f,0)
>         |
>         | hb/sw
>         v
>     write(f,42) --hb/po--> write(v,0)
>                                |
>                                | hb/sw
>                                v
>                             read(v):0 --hb/po--> read(f):42;
> 
> 2) Read of default write(f, 0) -- these synchronize-with the first
> action in the thread:
> 
>                       (default) write(v,0)
>                       (default) write(f,0)
>                                |
>                                | hb/sw
>                                v
>                             read(v):0 --hb/po--> read(f):0
> 
> (One might wonder if that means you can see the default value for an
> explicitly initialized volatile field, once you read the instance itself
> -- you can! -- we have seen this with AtomicIntegers before)
> 
> 3) Racy read of unordered write(f, 42):
> 
>     (default) write(v,0)
>     (default) write(f,0)          write(f, 42)
>                  |                     .
>                  | hb/sw               . (unordered)
>                  v                     .
>               read(v):0 --hb/po--> read(f):42
> 
> 
> In other words, if we drop execution (1) by omitting the explicit
> initializing store, we would still be able to observe both "0" and "42".
> 
> This seems to expand to non-instance fields, and other variables written
> before firing the field initializer.
> 
> *** Putting all together
> 
> Now, putting these things together:
> 
> * Case A tells that no variable written *after* the volatile instance
> field initializer is protected (duh).
> 
> * Case B tells that no variable written *before* the volatile instance
> field initializer writing the default value is protected by
> happens-before. This is because the explicit initializing store with the
> default value is indistinguishable from the default value store.
> 
> * Since Case A and Case B cover all possible variables (with the
> exception of the volatile field itself), this seems to imply that
> explicit field initializers that store default values have no effect on
> memory ordering.
> 
> Is it a correct way to think about it?
> 
> Thanks,
> -Aleksey
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From martinrb at google.com  Mon Jan  4 19:43:00 2016
From: martinrb at google.com (Martin Buchholz)
Date: Mon, 4 Jan 2016 16:43:00 -0800
Subject: [concurrency-interest] CompletableFuture.whenComplete survey,
 pass 2
In-Reply-To: <CA+F8eeS-p4yRgcxcskC2nsRqDykrBw-PHWGMP9tvQtW2uuinwg@mail.gmail.com>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
	<56756676.3040608@cs.oswego.edu>
	<CAJUoZVY3u=Jw=vRFdTkLckoc5jLh7KRZwyo7DKVhAigdagxjsQ@mail.gmail.com>
	<567599C7.9010906@cs.oswego.edu>
	<CAJUoZVamtYv65Vwha67BNQRKpbFfA6+HeJ-6dW5+8JzBRfns0w@mail.gmail.com>
	<5676BA4C.1060703@cs.oswego.edu> <567A90C0.2@cs.oswego.edu>
	<CA+F8eeS-p4yRgcxcskC2nsRqDykrBw-PHWGMP9tvQtW2uuinwg@mail.gmail.com>
Message-ID: <CA+kOe08Agu4U2dcb6UAuV3C0qSkdRgs+hq5g+a0dQCAWgRps4A@mail.gmail.com>

Software is hard.

I agree with Doug that we should change the spec to clarify that
whenComplete's action should not throw, and I'd also like to rewrite
the class doc so that handle, as the most general continuation method,
gets the top billing instead of what we have now, where handle seems
to be merely an alternative to whenComplete.

I worry that addSuppressed (magic time travel, modifying a "past
future") is not the clear winner we would like whenever changing
existing behavior.  As an example, it is possible for many futures to
use a failed future as a source.  If any of the dependent futures
fail, you have a very rare and surprising memory leak.  So I'm now
sadly inclined to leave the jdk9 behavior the same as jdk8 ("do no
harm"), but like many others I'll grumble and accept "B".  Doug should
decide.

Doug, go ahead and commit pending spec changes.

From markus at headcrashing.eu  Sat Jan  9 04:28:53 2016
From: markus at headcrashing.eu (Markus KARG)
Date: Sat, 9 Jan 2016 10:28:53 +0100
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request
	for Comments
Message-ID: <002501d14ac0$28189150$7849b3f0$@eu>

The following requests comments on a Feature Proposal for Absolute
Scheduling.

 

OpenJDK ticket JDK-8146527
(https://bugs.openjdk.java.net/browse/JDK-8146527) describes the following
case:

 

* ScheduledExecutorService.schedule() is invoked to schedule firing of an
event "in one minute".

* The laptop lid gets closed instantly after that, so hibernation will
occur, hence the JVM will suspend.

* After thirty seconds of hibernation, the laptop lid gets openen, so
hibernation will cancel and the JVM resumes.

* Despite the expected result (one minute after start of program the event
does occur), the event actually is delayed by the length of the hibernation
phase, and happens 90 seconds after the program was started. In the
expectation of the end user, the event fired 30 seconds "too late"!

 

This is annoying to users and rather unexpected and astonishing for
programmers literally following the words of the JavaDocs. Clearly the
provided deadline is a relative value in the physical sense ("one minute
from now, independent of what 'now' is currently like"), but certainly what
the user actually expects it to work like is an absolute value in the
physical sense ("one minute from now, where 'now' is the current point on
the time axis of the Universe, hence unaffected by hibernation). Whether or
not the laptop was closed temporarily in the meantime plays no role to the
expectation of neither the end user nor the application provider.

 

Unfortunately there is no other API that allows the application vendor to
define that the deadline it meant to be unaffected of hibernation. Clearly
this is a drawback to the Java platform, as many applications need such a
behaviour (like "check my mails once per hour" - if you open your laptop lid
ONLY for a few minutes to see whether meanwhile new emails arrived or not
[like, BTW, some laptops are able to perform these days, even with the lid
closed, thanks to a BIOS timer] you won't receive any new emails ever as
"JVM" time progresses only be few minutes per day then).

 

A solution could be the addition of a special variant of
ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of
any hibernation, and will fire either exactly at the absoluteInstant (in
case the laptop is not hibernating _currently_), or it will fire instantly
after the end of hibernation, in case the laptop was hibernating at
absoluteInstant.

 

There are two possible ways to reach this: Either there is an OS-specific
API that alrady provides exactly that behaviour, or the JVM needs to be
informed every 'x' fractions of "discontinuous jvm time" to find out how
much "continuous real world time" has advanced and whether a scheduled event
was missed meanwhile (which is the workaround such applications have to
perform on their own currently to workaround the problem). The first is
problematic due to changes in the implementations of the APIs (e. g. Windows
changed some APIs from "continuous time" to using "discontinuous time"), the
second is complex in finding the optimal value of 'x' (too low means high
power consumption, too high means firing too late after the deadline).

 

Side note: To be unambiguous, the new deadline should possibly be typed as
java.time.Instant, as that could never be misunderstood as "discontinous jvm
time" inherently.

 

What is your opinion on that?

 

-Markus

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160109/399d4de3/attachment.html>

From carsten.schipke at gmail.com  Sat Jan  9 05:02:29 2016
From: carsten.schipke at gmail.com (Carsten Schipke)
Date: Sat, 9 Jan 2016 18:02:29 +0800
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
	Request for Comments
In-Reply-To: <002501d14ac0$28189150$7849b3f0$@eu>
References: <002501d14ac0$28189150$7849b3f0$@eu>
Message-ID: <EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>

?...or it will fire instantly after the end of hibernation ?? considering your example of hourly/periodically checking mails, that would mean that the program checks your mailbox 10 times at once after 10h hibernation. 
So the API would also need to know whether unfired events should queue up over time. Sounds like a rattail pulling endlessly use cases & requirements behind it.

I for one never thought about using the JVM to schedule things that live through hibernation or similar (not knowing the original intention of the API). But I have also never built daemon-like desktop/client applications/services.

I guess in case of JVM, one could argue that specifications only apply at runtime, and hibernation is interrupting that. Maybe it would be better to provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-hibernation, standby, signals etc. Then one could de/attach events accordingly.


> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu> wrote:
> 
> The following requests comments on a Feature Proposal for Absolute Scheduling.
>  
> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the following case:
>  
> * ScheduledExecutorService.schedule() is invoked to schedule firing of an event "in one minute".
> * The laptop lid gets closed instantly after that, so hibernation will occur, hence the JVM will suspend.
> * After thirty seconds of hibernation, the laptop lid gets openen, so hibernation will cancel and the JVM resumes.
> * Despite the expected result (one minute after start of program the event does occur), the event actually is delayed by the length of the hibernation phase, and happens 90 seconds after the program was started. In the expectation of the end user, the event fired 30 seconds "too late"!
>  
> This is annoying to users and rather unexpected and astonishing for programmers literally following the words of the JavaDocs. Clearly the provided deadline is a relative value in the physical sense ("one minute from now, independent of what 'now' is currently like"), but certainly what the user actually expects it to work like is an absolute value in the physical sense ("one minute from now, where 'now' is the current point on the time axis of the Universe, hence unaffected by hibernation). Whether or not the laptop was closed temporarily in the meantime plays no role to the expectation of neither the end user nor the application provider.
>  
> Unfortunately there is no other API that allows the application vendor to define that the deadline it meant to be unaffected of hibernation. Clearly this is a drawback to the Java platform, as many applications need such a behaviour (like "check my mails once per hour" - if you open your laptop lid ONLY for a few minutes to see whether meanwhile new emails arrived or not [like, BTW, some laptops are able to perform these days, even with the lid closed, thanks to a BIOS timer] you won't receive any new emails ever as "JVM" time progresses only be few minutes per day then).
>  
> A solution could be the addition of a special variant of ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of any hibernation, and will fire either exactly at the absoluteInstant (in case the laptop is not hibernating _currently_), or it will fire instantly after the end of hibernation, in case the laptop was hibernating at absoluteInstant.
>  
> There are two possible ways to reach this: Either there is an OS-specific API that alrady provides exactly that behaviour, or the JVM needs to be informed every 'x' fractions of "discontinuous jvm time" to find out how much "continuous real world time" has advanced and whether a scheduled event was missed meanwhile (which is the workaround such applications have to perform on their own currently to workaround the problem). The first is problematic due to changes in the implementations of the APIs (e. g. Windows changed some APIs from "continuous time" to using "discontinuous time"), the second is complex in finding the optimal value of 'x' (too low means high power consumption, too high means firing too late after the deadline).
>  
> Side note: To be unambiguous, the new deadline should possibly be typed as java.time.Instant, as that could never be misunderstood as "discontinous jvm time" inherently.
>  
> What is your opinion on that?
>  
> -Markus
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From markus at headcrashing.eu  Sat Jan  9 08:04:23 2016
From: markus at headcrashing.eu (Markus KARG)
Date: Sat, 9 Jan 2016 14:04:23 +0100
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
	Request for Comments
In-Reply-To: <EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
Message-ID: <009001d14ade$43383fd0$c9a8bf70$@eu>

I think it should be up to the programmer (e. g. by passing a flag or using different methods) whether he wants 10 events after missing those while hibernation, or whether he wants the events to be collapsed into one single event alternatively. BTW, I never said that the API must support an absolute variant of repeated event schedulung. You could also simply provide an absolute variant of the "fire ONCE" method, and the mail application has to reschedule inside of the event handler.

Hooks are out of scope for my proposal, as they solve a different problem and are working on a deeper level (the scheduler API could certainly make use of such hooks). In case the Windows API for example would be able to solve the problem for us (it is, BTW), why shouldn't we provide a Java API wrapping that (without running into any rattail, as we simply offload)?

-Markus

-----Original Message-----
From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
Sent: Samstag, 9. Januar 2016 11:02
To: Markus KARG
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

?...or it will fire instantly after the end of hibernation ?? considering your example of hourly/periodically checking mails, that would mean that the program checks your mailbox 10 times at once after 10h hibernation. 
So the API would also need to know whether unfired events should queue up over time. Sounds like a rattail pulling endlessly use cases & requirements behind it.

I for one never thought about using the JVM to schedule things that live through hibernation or similar (not knowing the original intention of the API). But I have also never built daemon-like desktop/client applications/services.

I guess in case of JVM, one could argue that specifications only apply at runtime, and hibernation is interrupting that. Maybe it would be better to provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-hibernation, standby, signals etc. Then one could de/attach events accordingly.


> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu> wrote:
> 
> The following requests comments on a Feature Proposal for Absolute Scheduling.
>  
> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the following case:
>  
> * ScheduledExecutorService.schedule() is invoked to schedule firing of an event "in one minute".
> * The laptop lid gets closed instantly after that, so hibernation will occur, hence the JVM will suspend.
> * After thirty seconds of hibernation, the laptop lid gets openen, so hibernation will cancel and the JVM resumes.
> * Despite the expected result (one minute after start of program the event does occur), the event actually is delayed by the length of the hibernation phase, and happens 90 seconds after the program was started. In the expectation of the end user, the event fired 30 seconds "too late"!
>  
> This is annoying to users and rather unexpected and astonishing for programmers literally following the words of the JavaDocs. Clearly the provided deadline is a relative value in the physical sense ("one minute from now, independent of what 'now' is currently like"), but certainly what the user actually expects it to work like is an absolute value in the physical sense ("one minute from now, where 'now' is the current point on the time axis of the Universe, hence unaffected by hibernation). Whether or not the laptop was closed temporarily in the meantime plays no role to the expectation of neither the end user nor the application provider.
>  
> Unfortunately there is no other API that allows the application vendor to define that the deadline it meant to be unaffected of hibernation. Clearly this is a drawback to the Java platform, as many applications need such a behaviour (like "check my mails once per hour" - if you open your laptop lid ONLY for a few minutes to see whether meanwhile new emails arrived or not [like, BTW, some laptops are able to perform these days, even with the lid closed, thanks to a BIOS timer] you won't receive any new emails ever as "JVM" time progresses only be few minutes per day then).
>  
> A solution could be the addition of a special variant of ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of any hibernation, and will fire either exactly at the absoluteInstant (in case the laptop is not hibernating _currently_), or it will fire instantly after the end of hibernation, in case the laptop was hibernating at absoluteInstant.
>  
> There are two possible ways to reach this: Either there is an OS-specific API that alrady provides exactly that behaviour, or the JVM needs to be informed every 'x' fractions of "discontinuous jvm time" to find out how much "continuous real world time" has advanced and whether a scheduled event was missed meanwhile (which is the workaround such applications have to perform on their own currently to workaround the problem). The first is problematic due to changes in the implementations of the APIs (e. g. Windows changed some APIs from "continuous time" to using "discontinuous time"), the second is complex in finding the optimal value of 'x' (too low means high power consumption, too high means firing too late after the deadline).
>  
> Side note: To be unambiguous, the new deadline should possibly be typed as java.time.Instant, as that could never be misunderstood as "discontinous jvm time" inherently.
>  
> What is your opinion on that?
>  
> -Markus
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest




From carsten.schipke at gmail.com  Sat Jan  9 08:08:33 2016
From: carsten.schipke at gmail.com (Carsten Schipke)
Date: Sat, 9 Jan 2016 21:08:33 +0800
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
	Request for Comments
In-Reply-To: <009001d14ade$43383fd0$c9a8bf70$@eu>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
	<009001d14ade$43383fd0$c9a8bf70$@eu>
Message-ID: <8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>

sure, as I mentioned, I have never really had that requirement, it just sounded to me like many programmers could have many slightly different requirements on such an API. I also don?t know what the Windows API offers in those regards / how its solved there, but if there is such a widely accepted solution, then it surely would make sense as you say. 

 
> On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu> wrote:
> 
> I think it should be up to the programmer (e. g. by passing a flag or using different methods) whether he wants 10 events after missing those while hibernation, or whether he wants the events to be collapsed into one single event alternatively. BTW, I never said that the API must support an absolute variant of repeated event schedulung. You could also simply provide an absolute variant of the "fire ONCE" method, and the mail application has to reschedule inside of the event handler.
> 
> Hooks are out of scope for my proposal, as they solve a different problem and are working on a deeper level (the scheduler API could certainly make use of such hooks). In case the Windows API for example would be able to solve the problem for us (it is, BTW), why shouldn't we provide a Java API wrapping that (without running into any rattail, as we simply offload)?
> 
> -Markus
> 
> -----Original Message-----
> From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
> Sent: Samstag, 9. Januar 2016 11:02
> To: Markus KARG
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments
> 
> ?...or it will fire instantly after the end of hibernation ?? considering your example of hourly/periodically checking mails, that would mean that the program checks your mailbox 10 times at once after 10h hibernation. 
> So the API would also need to know whether unfired events should queue up over time. Sounds like a rattail pulling endlessly use cases & requirements behind it.
> 
> I for one never thought about using the JVM to schedule things that live through hibernation or similar (not knowing the original intention of the API). But I have also never built daemon-like desktop/client applications/services.
> 
> I guess in case of JVM, one could argue that specifications only apply at runtime, and hibernation is interrupting that. Maybe it would be better to provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-hibernation, standby, signals etc. Then one could de/attach events accordingly.
> 
> 
>> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu> wrote:
>> 
>> The following requests comments on a Feature Proposal for Absolute Scheduling.
>> 
>> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the following case:
>> 
>> * ScheduledExecutorService.schedule() is invoked to schedule firing of an event "in one minute".
>> * The laptop lid gets closed instantly after that, so hibernation will occur, hence the JVM will suspend.
>> * After thirty seconds of hibernation, the laptop lid gets openen, so hibernation will cancel and the JVM resumes.
>> * Despite the expected result (one minute after start of program the event does occur), the event actually is delayed by the length of the hibernation phase, and happens 90 seconds after the program was started. In the expectation of the end user, the event fired 30 seconds "too late"!
>> 
>> This is annoying to users and rather unexpected and astonishing for programmers literally following the words of the JavaDocs. Clearly the provided deadline is a relative value in the physical sense ("one minute from now, independent of what 'now' is currently like"), but certainly what the user actually expects it to work like is an absolute value in the physical sense ("one minute from now, where 'now' is the current point on the time axis of the Universe, hence unaffected by hibernation). Whether or not the laptop was closed temporarily in the meantime plays no role to the expectation of neither the end user nor the application provider.
>> 
>> Unfortunately there is no other API that allows the application vendor to define that the deadline it meant to be unaffected of hibernation. Clearly this is a drawback to the Java platform, as many applications need such a behaviour (like "check my mails once per hour" - if you open your laptop lid ONLY for a few minutes to see whether meanwhile new emails arrived or not [like, BTW, some laptops are able to perform these days, even with the lid closed, thanks to a BIOS timer] you won't receive any new emails ever as "JVM" time progresses only be few minutes per day then).
>> 
>> A solution could be the addition of a special variant of ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of any hibernation, and will fire either exactly at the absoluteInstant (in case the laptop is not hibernating _currently_), or it will fire instantly after the end of hibernation, in case the laptop was hibernating at absoluteInstant.
>> 
>> There are two possible ways to reach this: Either there is an OS-specific API that alrady provides exactly that behaviour, or the JVM needs to be informed every 'x' fractions of "discontinuous jvm time" to find out how much "continuous real world time" has advanced and whether a scheduled event was missed meanwhile (which is the workaround such applications have to perform on their own currently to workaround the problem). The first is problematic due to changes in the implementations of the APIs (e. g. Windows changed some APIs from "continuous time" to using "discontinuous time"), the second is complex in finding the optimal value of 'x' (too low means high power consumption, too high means firing too late after the deadline).
>> 
>> Side note: To be unambiguous, the new deadline should possibly be typed as java.time.Instant, as that could never be misunderstood as "discontinous jvm time" inherently.
>> 
>> What is your opinion on that?
>> 
>> -Markus
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 



From carsten.schipke at gmail.com  Sat Jan  9 08:09:49 2016
From: carsten.schipke at gmail.com (Carsten Schipke)
Date: Sat, 9 Jan 2016 21:09:49 +0800
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
	Request for Comments
In-Reply-To: <009001d14ade$43383fd0$c9a8bf70$@eu>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
	<009001d14ade$43383fd0$c9a8bf70$@eu>
Message-ID: <53BD1CB4-8E7D-4A3D-9D6E-1217B99852FE@gmail.com>

That is if it would be portable - utilising Windows API would require similar facilities on all supported OS?s.

> On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu> wrote:
> 
> I think it should be up to the programmer (e. g. by passing a flag or using different methods) whether he wants 10 events after missing those while hibernation, or whether he wants the events to be collapsed into one single event alternatively. BTW, I never said that the API must support an absolute variant of repeated event schedulung. You could also simply provide an absolute variant of the "fire ONCE" method, and the mail application has to reschedule inside of the event handler.
> 
> Hooks are out of scope for my proposal, as they solve a different problem and are working on a deeper level (the scheduler API could certainly make use of such hooks). In case the Windows API for example would be able to solve the problem for us (it is, BTW), why shouldn't we provide a Java API wrapping that (without running into any rattail, as we simply offload)?
> 
> -Markus
> 
> -----Original Message-----
> From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
> Sent: Samstag, 9. Januar 2016 11:02
> To: Markus KARG
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments
> 
> ?...or it will fire instantly after the end of hibernation ?? considering your example of hourly/periodically checking mails, that would mean that the program checks your mailbox 10 times at once after 10h hibernation. 
> So the API would also need to know whether unfired events should queue up over time. Sounds like a rattail pulling endlessly use cases & requirements behind it.
> 
> I for one never thought about using the JVM to schedule things that live through hibernation or similar (not knowing the original intention of the API). But I have also never built daemon-like desktop/client applications/services.
> 
> I guess in case of JVM, one could argue that specifications only apply at runtime, and hibernation is interrupting that. Maybe it would be better to provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-hibernation, standby, signals etc. Then one could de/attach events accordingly.
> 
> 
>> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu> wrote:
>> 
>> The following requests comments on a Feature Proposal for Absolute Scheduling.
>> 
>> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the following case:
>> 
>> * ScheduledExecutorService.schedule() is invoked to schedule firing of an event "in one minute".
>> * The laptop lid gets closed instantly after that, so hibernation will occur, hence the JVM will suspend.
>> * After thirty seconds of hibernation, the laptop lid gets openen, so hibernation will cancel and the JVM resumes.
>> * Despite the expected result (one minute after start of program the event does occur), the event actually is delayed by the length of the hibernation phase, and happens 90 seconds after the program was started. In the expectation of the end user, the event fired 30 seconds "too late"!
>> 
>> This is annoying to users and rather unexpected and astonishing for programmers literally following the words of the JavaDocs. Clearly the provided deadline is a relative value in the physical sense ("one minute from now, independent of what 'now' is currently like"), but certainly what the user actually expects it to work like is an absolute value in the physical sense ("one minute from now, where 'now' is the current point on the time axis of the Universe, hence unaffected by hibernation). Whether or not the laptop was closed temporarily in the meantime plays no role to the expectation of neither the end user nor the application provider.
>> 
>> Unfortunately there is no other API that allows the application vendor to define that the deadline it meant to be unaffected of hibernation. Clearly this is a drawback to the Java platform, as many applications need such a behaviour (like "check my mails once per hour" - if you open your laptop lid ONLY for a few minutes to see whether meanwhile new emails arrived or not [like, BTW, some laptops are able to perform these days, even with the lid closed, thanks to a BIOS timer] you won't receive any new emails ever as "JVM" time progresses only be few minutes per day then).
>> 
>> A solution could be the addition of a special variant of ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of any hibernation, and will fire either exactly at the absoluteInstant (in case the laptop is not hibernating _currently_), or it will fire instantly after the end of hibernation, in case the laptop was hibernating at absoluteInstant.
>> 
>> There are two possible ways to reach this: Either there is an OS-specific API that alrady provides exactly that behaviour, or the JVM needs to be informed every 'x' fractions of "discontinuous jvm time" to find out how much "continuous real world time" has advanced and whether a scheduled event was missed meanwhile (which is the workaround such applications have to perform on their own currently to workaround the problem). The first is problematic due to changes in the implementations of the APIs (e. g. Windows changed some APIs from "continuous time" to using "discontinuous time"), the second is complex in finding the optimal value of 'x' (too low means high power consumption, too high means firing too late after the deadline).
>> 
>> Side note: To be unambiguous, the new deadline should possibly be typed as java.time.Instant, as that could never be misunderstood as "discontinous jvm time" inherently.
>> 
>> What is your opinion on that?
>> 
>> -Markus
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 



From markus at headcrashing.eu  Sat Jan  9 08:57:33 2016
From: markus at headcrashing.eu (Markus KARG)
Date: Sat, 9 Jan 2016 14:57:33 +0100
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
	Request for Comments
In-Reply-To: <8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
	<009001d14ade$43383fd0$c9a8bf70$@eu>
	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
Message-ID: <00ac01d14ae5$b0628d70$1127a850$@eu>

Carsten,

the Windows API provides several different methods for timing. Some of them are definitively able to fire at a particular point in time, independent of any hibernation.

In case a different OS won't have such a factility, there is a simple fallback: Triggering events more often, checking the actual time (in pure Java), so we find out whether to wait further, or whether the event is to be fired. This, BTW, is the workaround applied by pure Java solutions currently, hence what I'd like to get rid off by this feature request. :-)

-Markus 


-----Original Message-----
From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
Sent: Samstag, 9. Januar 2016 14:09
To: Markus KARG
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

sure, as I mentioned, I have never really had that requirement, it just sounded to me like many programmers could have many slightly different requirements on such an API. I also don?t know what the Windows API offers in those regards / how its solved there, but if there is such a widely accepted solution, then it surely would make sense as you say. 

 
> On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu> wrote:
> 
> I think it should be up to the programmer (e. g. by passing a flag or using different methods) whether he wants 10 events after missing those while hibernation, or whether he wants the events to be collapsed into one single event alternatively. BTW, I never said that the API must support an absolute variant of repeated event schedulung. You could also simply provide an absolute variant of the "fire ONCE" method, and the mail application has to reschedule inside of the event handler.
> 
> Hooks are out of scope for my proposal, as they solve a different problem and are working on a deeper level (the scheduler API could certainly make use of such hooks). In case the Windows API for example would be able to solve the problem for us (it is, BTW), why shouldn't we provide a Java API wrapping that (without running into any rattail, as we simply offload)?
> 
> -Markus
> 
> -----Original Message-----
> From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
> Sent: Samstag, 9. Januar 2016 11:02
> To: Markus KARG
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments
> 
> ?...or it will fire instantly after the end of hibernation ?? considering your example of hourly/periodically checking mails, that would mean that the program checks your mailbox 10 times at once after 10h hibernation. 
> So the API would also need to know whether unfired events should queue up over time. Sounds like a rattail pulling endlessly use cases & requirements behind it.
> 
> I for one never thought about using the JVM to schedule things that live through hibernation or similar (not knowing the original intention of the API). But I have also never built daemon-like desktop/client applications/services.
> 
> I guess in case of JVM, one could argue that specifications only apply at runtime, and hibernation is interrupting that. Maybe it would be better to provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-hibernation, standby, signals etc. Then one could de/attach events accordingly.
> 
> 
>> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu> wrote:
>> 
>> The following requests comments on a Feature Proposal for Absolute Scheduling.
>> 
>> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the following case:
>> 
>> * ScheduledExecutorService.schedule() is invoked to schedule firing of an event "in one minute".
>> * The laptop lid gets closed instantly after that, so hibernation will occur, hence the JVM will suspend.
>> * After thirty seconds of hibernation, the laptop lid gets openen, so hibernation will cancel and the JVM resumes.
>> * Despite the expected result (one minute after start of program the event does occur), the event actually is delayed by the length of the hibernation phase, and happens 90 seconds after the program was started. In the expectation of the end user, the event fired 30 seconds "too late"!
>> 
>> This is annoying to users and rather unexpected and astonishing for programmers literally following the words of the JavaDocs. Clearly the provided deadline is a relative value in the physical sense ("one minute from now, independent of what 'now' is currently like"), but certainly what the user actually expects it to work like is an absolute value in the physical sense ("one minute from now, where 'now' is the current point on the time axis of the Universe, hence unaffected by hibernation). Whether or not the laptop was closed temporarily in the meantime plays no role to the expectation of neither the end user nor the application provider.
>> 
>> Unfortunately there is no other API that allows the application vendor to define that the deadline it meant to be unaffected of hibernation. Clearly this is a drawback to the Java platform, as many applications need such a behaviour (like "check my mails once per hour" - if you open your laptop lid ONLY for a few minutes to see whether meanwhile new emails arrived or not [like, BTW, some laptops are able to perform these days, even with the lid closed, thanks to a BIOS timer] you won't receive any new emails ever as "JVM" time progresses only be few minutes per day then).
>> 
>> A solution could be the addition of a special variant of ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of any hibernation, and will fire either exactly at the absoluteInstant (in case the laptop is not hibernating _currently_), or it will fire instantly after the end of hibernation, in case the laptop was hibernating at absoluteInstant.
>> 
>> There are two possible ways to reach this: Either there is an OS-specific API that alrady provides exactly that behaviour, or the JVM needs to be informed every 'x' fractions of "discontinuous jvm time" to find out how much "continuous real world time" has advanced and whether a scheduled event was missed meanwhile (which is the workaround such applications have to perform on their own currently to workaround the problem). The first is problematic due to changes in the implementations of the APIs (e. g. Windows changed some APIs from "continuous time" to using "discontinuous time"), the second is complex in finding the optimal value of 'x' (too low means high power consumption, too high means firing too late after the deadline).
>> 
>> Side note: To be unambiguous, the new deadline should possibly be typed as java.time.Instant, as that could never be misunderstood as "discontinous jvm time" inherently.
>> 
>> What is your opinion on that?
>> 
>> -Markus
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 




From nathanila at gmail.com  Sat Jan  9 12:18:37 2016
From: nathanila at gmail.com (Nathan & Ila Reynolds)
Date: Sat, 9 Jan 2016 10:18:37 -0700
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling
	/	Request for Comments
In-Reply-To: <00ac01d14ae5$b0628d70$1127a850$@eu>
References: <002501d14ac0$28189150$7849b3f0$@eu>	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>	<009001d14ade$43383fd0$c9a8bf70$@eu>	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
	<00ac01d14ae5$b0628d70$1127a850$@eu>
Message-ID: <006001d14b01$c85b6b60$59124220$@gmail.com>

Also, Windows fires an event to all applications when the system resumes after hibernation.  You could use that event instead of polling.

ScheduledExecutorService provides schedule(), scheduleAtFixedRate() and scheduleWithFixedDelay().  I expect schedule() to run the command at or very soon after the delay or as soon as the machine resumes if the delay has elapsed.  I expect scheduleAtFixedRate() to run the command N times rapidly if hibernation lasted N periods.  I expect scheduleWithFixedDelay() to run the command one time at or very soon after the delay or as soon as the machine resumes.  In this regard, the programmer has control whether they need N times or 1 time after hibernation.  I only use scheduleAtFixedRate() if I have something staying in sync with the passage of time.  I use scheduleWithFixedDelay() in all other cases because if the command takes a long time, I don't need it to run right away.

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html

-Nathan

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
Sent: Saturday, January 09, 2016 6:58 AM
To: 'Carsten Schipke' <carsten.schipke at gmail.com>
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

Carsten,

the Windows API provides several different methods for timing. Some of them are definitively able to fire at a particular point in time, independent of any hibernation.

In case a different OS won't have such a factility, there is a simple fallback: Triggering events more often, checking the actual time (in pure Java), so we find out whether to wait further, or whether the event is to be fired. This, BTW, is the workaround applied by pure Java solutions currently, hence what I'd like to get rid off by this feature request. :-)

-Markus 


-----Original Message-----
From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
Sent: Samstag, 9. Januar 2016 14:09
To: Markus KARG
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

sure, as I mentioned, I have never really had that requirement, it just sounded to me like many programmers could have many slightly different requirements on such an API. I also don?t know what the Windows API offers in those regards / how its solved there, but if there is such a widely accepted solution, then it surely would make sense as you say. 

 
> On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu> wrote:
> 
> I think it should be up to the programmer (e. g. by passing a flag or using different methods) whether he wants 10 events after missing those while hibernation, or whether he wants the events to be collapsed into one single event alternatively. BTW, I never said that the API must support an absolute variant of repeated event schedulung. You could also simply provide an absolute variant of the "fire ONCE" method, and the mail application has to reschedule inside of the event handler.
> 
> Hooks are out of scope for my proposal, as they solve a different problem and are working on a deeper level (the scheduler API could certainly make use of such hooks). In case the Windows API for example would be able to solve the problem for us (it is, BTW), why shouldn't we provide a Java API wrapping that (without running into any rattail, as we simply offload)?
> 
> -Markus
> 
> -----Original Message-----
> From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
> Sent: Samstag, 9. Januar 2016 11:02
> To: Markus KARG
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments
> 
> ?...or it will fire instantly after the end of hibernation ?? considering your example of hourly/periodically checking mails, that would mean that the program checks your mailbox 10 times at once after 10h hibernation. 
> So the API would also need to know whether unfired events should queue up over time. Sounds like a rattail pulling endlessly use cases & requirements behind it.
> 
> I for one never thought about using the JVM to schedule things that live through hibernation or similar (not knowing the original intention of the API). But I have also never built daemon-like desktop/client applications/services.
> 
> I guess in case of JVM, one could argue that specifications only apply at runtime, and hibernation is interrupting that. Maybe it would be better to provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-hibernation, standby, signals etc. Then one could de/attach events accordingly.
> 
> 
>> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu> wrote:
>> 
>> The following requests comments on a Feature Proposal for Absolute Scheduling.
>> 
>> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the following case:
>> 
>> * ScheduledExecutorService.schedule() is invoked to schedule firing of an event "in one minute".
>> * The laptop lid gets closed instantly after that, so hibernation will occur, hence the JVM will suspend.
>> * After thirty seconds of hibernation, the laptop lid gets openen, so hibernation will cancel and the JVM resumes.
>> * Despite the expected result (one minute after start of program the event does occur), the event actually is delayed by the length of the hibernation phase, and happens 90 seconds after the program was started. In the expectation of the end user, the event fired 30 seconds "too late"!
>> 
>> This is annoying to users and rather unexpected and astonishing for programmers literally following the words of the JavaDocs. Clearly the provided deadline is a relative value in the physical sense ("one minute from now, independent of what 'now' is currently like"), but certainly what the user actually expects it to work like is an absolute value in the physical sense ("one minute from now, where 'now' is the current point on the time axis of the Universe, hence unaffected by hibernation). Whether or not the laptop was closed temporarily in the meantime plays no role to the expectation of neither the end user nor the application provider.
>> 
>> Unfortunately there is no other API that allows the application vendor to define that the deadline it meant to be unaffected of hibernation. Clearly this is a drawback to the Java platform, as many applications need such a behaviour (like "check my mails once per hour" - if you open your laptop lid ONLY for a few minutes to see whether meanwhile new emails arrived or not [like, BTW, some laptops are able to perform these days, even with the lid closed, thanks to a BIOS timer] you won't receive any new emails ever as "JVM" time progresses only be few minutes per day then).
>> 
>> A solution could be the addition of a special variant of ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of any hibernation, and will fire either exactly at the absoluteInstant (in case the laptop is not hibernating _currently_), or it will fire instantly after the end of hibernation, in case the laptop was hibernating at absoluteInstant.
>> 
>> There are two possible ways to reach this: Either there is an OS-specific API that alrady provides exactly that behaviour, or the JVM needs to be informed every 'x' fractions of "discontinuous jvm time" to find out how much "continuous real world time" has advanced and whether a scheduled event was missed meanwhile (which is the workaround such applications have to perform on their own currently to workaround the problem). The first is problematic due to changes in the implementations of the APIs (e. g. Windows changed some APIs from "continuous time" to using "discontinuous time"), the second is complex in finding the optimal value of 'x' (too low means high power consumption, too high means firing too late after the deadline).
>> 
>> Side note: To be unambiguous, the new deadline should possibly be typed as java.time.Instant, as that could never be misunderstood as "discontinous jvm time" inherently.
>> 
>> What is your opinion on that?
>> 
>> -Markus
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From markus at headcrashing.eu  Sat Jan  9 12:51:19 2016
From: markus at headcrashing.eu (Markus KARG)
Date: Sat, 9 Jan 2016 18:51:19 +0100
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling
	/	Request for Comments
In-Reply-To: <006001d14b01$c85b6b60$59124220$@gmail.com>
References: <002501d14ac0$28189150$7849b3f0$@eu>	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>	<009001d14ade$43383fd0$c9a8bf70$@eu>	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
	<00ac01d14ae5$b0628d70$1127a850$@eu>
	<006001d14b01$c85b6b60$59124220$@gmail.com>
Message-ID: <006401d14b06$58dadb40$0a9091c0$@eu>

Nathan,

thanks for your comments.

Please note that the actual behaviour deviates from your expectation on varying with the OS type and version. For example, the one-time-trigger "schedule(delay)" variant of JDK 8u66 on Win 8.1 (64 Bit) does *not* fire the event "very soon after the delay" in some cases; in fact, it adds the complete duration of the hibernation to relative-ms. Hence, when you call "schedule(1min)", hibernate for 30s, wakeup the PC, then the event actually fires 90s after you invoked that command! In fact, that behaviour is *by design* as I learned (according to Oracle's David Holmes), and it is the reason for filing this RFC.

-Markus


-----Original Message-----
From: Nathan & Ila Reynolds [mailto:nathanila at gmail.com] 
Sent: Samstag, 9. Januar 2016 18:19
To: 'Markus KARG'; 'Carsten Schipke'
Cc: concurrency-interest at cs.oswego.edu
Subject: RE: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

Also, Windows fires an event to all applications when the system resumes after hibernation.  You could use that event instead of polling.

ScheduledExecutorService provides schedule(), scheduleAtFixedRate() and scheduleWithFixedDelay().  I expect schedule() to run the command at or very soon after the delay or as soon as the machine resumes if the delay has elapsed.  I expect scheduleAtFixedRate() to run the command N times rapidly if hibernation lasted N periods.  I expect scheduleWithFixedDelay() to run the command one time at or very soon after the delay or as soon as the machine resumes.  In this regard, the programmer has control whether they need N times or 1 time after hibernation.  I only use scheduleAtFixedRate() if I have something staying in sync with the passage of time.  I use scheduleWithFixedDelay() in all other cases because if the command takes a long time, I don't need it to run right away.

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html

-Nathan

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
Sent: Saturday, January 09, 2016 6:58 AM
To: 'Carsten Schipke' <carsten.schipke at gmail.com>
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

Carsten,

the Windows API provides several different methods for timing. Some of them are definitively able to fire at a particular point in time, independent of any hibernation.

In case a different OS won't have such a factility, there is a simple fallback: Triggering events more often, checking the actual time (in pure Java), so we find out whether to wait further, or whether the event is to be fired. This, BTW, is the workaround applied by pure Java solutions currently, hence what I'd like to get rid off by this feature request. :-)

-Markus 


-----Original Message-----
From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
Sent: Samstag, 9. Januar 2016 14:09
To: Markus KARG
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

sure, as I mentioned, I have never really had that requirement, it just sounded to me like many programmers could have many slightly different requirements on such an API. I also don?t know what the Windows API offers in those regards / how its solved there, but if there is such a widely accepted solution, then it surely would make sense as you say. 

 
> On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu> wrote:
> 
> I think it should be up to the programmer (e. g. by passing a flag or using different methods) whether he wants 10 events after missing those while hibernation, or whether he wants the events to be collapsed into one single event alternatively. BTW, I never said that the API must support an absolute variant of repeated event schedulung. You could also simply provide an absolute variant of the "fire ONCE" method, and the mail application has to reschedule inside of the event handler.
> 
> Hooks are out of scope for my proposal, as they solve a different problem and are working on a deeper level (the scheduler API could certainly make use of such hooks). In case the Windows API for example would be able to solve the problem for us (it is, BTW), why shouldn't we provide a Java API wrapping that (without running into any rattail, as we simply offload)?
> 
> -Markus
> 
> -----Original Message-----
> From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
> Sent: Samstag, 9. Januar 2016 11:02
> To: Markus KARG
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments
> 
> ?...or it will fire instantly after the end of hibernation ?? considering your example of hourly/periodically checking mails, that would mean that the program checks your mailbox 10 times at once after 10h hibernation. 
> So the API would also need to know whether unfired events should queue up over time. Sounds like a rattail pulling endlessly use cases & requirements behind it.
> 
> I for one never thought about using the JVM to schedule things that live through hibernation or similar (not knowing the original intention of the API). But I have also never built daemon-like desktop/client applications/services.
> 
> I guess in case of JVM, one could argue that specifications only apply at runtime, and hibernation is interrupting that. Maybe it would be better to provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-hibernation, standby, signals etc. Then one could de/attach events accordingly.
> 
> 
>> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu> wrote:
>> 
>> The following requests comments on a Feature Proposal for Absolute Scheduling.
>> 
>> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the following case:
>> 
>> * ScheduledExecutorService.schedule() is invoked to schedule firing of an event "in one minute".
>> * The laptop lid gets closed instantly after that, so hibernation will occur, hence the JVM will suspend.
>> * After thirty seconds of hibernation, the laptop lid gets openen, so hibernation will cancel and the JVM resumes.
>> * Despite the expected result (one minute after start of program the event does occur), the event actually is delayed by the length of the hibernation phase, and happens 90 seconds after the program was started. In the expectation of the end user, the event fired 30 seconds "too late"!
>> 
>> This is annoying to users and rather unexpected and astonishing for programmers literally following the words of the JavaDocs. Clearly the provided deadline is a relative value in the physical sense ("one minute from now, independent of what 'now' is currently like"), but certainly what the user actually expects it to work like is an absolute value in the physical sense ("one minute from now, where 'now' is the current point on the time axis of the Universe, hence unaffected by hibernation). Whether or not the laptop was closed temporarily in the meantime plays no role to the expectation of neither the end user nor the application provider.
>> 
>> Unfortunately there is no other API that allows the application vendor to define that the deadline it meant to be unaffected of hibernation. Clearly this is a drawback to the Java platform, as many applications need such a behaviour (like "check my mails once per hour" - if you open your laptop lid ONLY for a few minutes to see whether meanwhile new emails arrived or not [like, BTW, some laptops are able to perform these days, even with the lid closed, thanks to a BIOS timer] you won't receive any new emails ever as "JVM" time progresses only be few minutes per day then).
>> 
>> A solution could be the addition of a special variant of ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of any hibernation, and will fire either exactly at the absoluteInstant (in case the laptop is not hibernating _currently_), or it will fire instantly after the end of hibernation, in case the laptop was hibernating at absoluteInstant.
>> 
>> There are two possible ways to reach this: Either there is an OS-specific API that alrady provides exactly that behaviour, or the JVM needs to be informed every 'x' fractions of "discontinuous jvm time" to find out how much "continuous real world time" has advanced and whether a scheduled event was missed meanwhile (which is the workaround such applications have to perform on their own currently to workaround the problem). The first is problematic due to changes in the implementations of the APIs (e. g. Windows changed some APIs from "continuous time" to using "discontinuous time"), the second is complex in finding the optimal value of 'x' (too low means high power consumption, too high means firing too late after the deadline).
>> 
>> Side note: To be unambiguous, the new deadline should possibly be typed as java.time.Instant, as that could never be misunderstood as "discontinous jvm time" inherently.
>> 
>> What is your opinion on that?
>> 
>> -Markus
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest




From nathanila at gmail.com  Sat Jan  9 14:41:33 2016
From: nathanila at gmail.com (Nathan & Ila Reynolds)
Date: Sat, 9 Jan 2016 12:41:33 -0700
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling
	/	Request for Comments
In-Reply-To: <006401d14b06$58dadb40$0a9091c0$@eu>
References: <002501d14ac0$28189150$7849b3f0$@eu>	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>	<009001d14ade$43383fd0$c9a8bf70$@eu>	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
	<00ac01d14ae5$b0628d70$1127a850$@eu>
	<006001d14b01$c85b6b60$59124220$@gmail.com>
	<006401d14b06$58dadb40$0a9091c0$@eu>
Message-ID: <008001d14b15$bf711270$3e533750$@gmail.com>

Before this email chain, I hadn't thought about hibernation and its impact.  After I read through the email chain, I understood what you just summarized.  I then stated my expectations of the APIs.

Hence, I don't expect new APIs to come out of this.  I expect the existing APIs to be "corrected".

On the side, if you want to overload the methods which accept Duration and Instant parameters, I would be grateful.  I have already implemented such methods for my thread pools.  In fact, my implementation of the existing APIs forward the calls to my Duration and Instant methods.  I found this made the implementation of the overall thread pool much easier.

-Nathan

-----Original Message-----
From: Markus KARG [mailto:markus at headcrashing.eu] 
Sent: Saturday, January 09, 2016 10:51 AM
To: 'Nathan & Ila Reynolds' <nathanila at gmail.com>; 'Carsten Schipke' <carsten.schipke at gmail.com>
Cc: concurrency-interest at cs.oswego.edu
Subject: RE: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

Nathan,

thanks for your comments.

Please note that the actual behaviour deviates from your expectation on varying with the OS type and version. For example, the one-time-trigger "schedule(delay)" variant of JDK 8u66 on Win 8.1 (64 Bit) does *not* fire the event "very soon after the delay" in some cases; in fact, it adds the complete duration of the hibernation to relative-ms. Hence, when you call "schedule(1min)", hibernate for 30s, wakeup the PC, then the event actually fires 90s after you invoked that command! In fact, that behaviour is *by design* as I learned (according to Oracle's David Holmes), and it is the reason for filing this RFC.

-Markus


-----Original Message-----
From: Nathan & Ila Reynolds [mailto:nathanila at gmail.com] 
Sent: Samstag, 9. Januar 2016 18:19
To: 'Markus KARG'; 'Carsten Schipke'
Cc: concurrency-interest at cs.oswego.edu
Subject: RE: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

Also, Windows fires an event to all applications when the system resumes after hibernation.  You could use that event instead of polling.

ScheduledExecutorService provides schedule(), scheduleAtFixedRate() and scheduleWithFixedDelay().  I expect schedule() to run the command at or very soon after the delay or as soon as the machine resumes if the delay has elapsed.  I expect scheduleAtFixedRate() to run the command N times rapidly if hibernation lasted N periods.  I expect scheduleWithFixedDelay() to run the command one time at or very soon after the delay or as soon as the machine resumes.  In this regard, the programmer has control whether they need N times or 1 time after hibernation.  I only use scheduleAtFixedRate() if I have something staying in sync with the passage of time.  I use scheduleWithFixedDelay() in all other cases because if the command takes a long time, I don't need it to run right away.

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html

-Nathan

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
Sent: Saturday, January 09, 2016 6:58 AM
To: 'Carsten Schipke' <carsten.schipke at gmail.com>
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

Carsten,

the Windows API provides several different methods for timing. Some of them are definitively able to fire at a particular point in time, independent of any hibernation.

In case a different OS won't have such a factility, there is a simple fallback: Triggering events more often, checking the actual time (in pure Java), so we find out whether to wait further, or whether the event is to be fired. This, BTW, is the workaround applied by pure Java solutions currently, hence what I'd like to get rid off by this feature request. :-)

-Markus 


-----Original Message-----
From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
Sent: Samstag, 9. Januar 2016 14:09
To: Markus KARG
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

sure, as I mentioned, I have never really had that requirement, it just sounded to me like many programmers could have many slightly different requirements on such an API. I also don?t know what the Windows API offers in those regards / how its solved there, but if there is such a widely accepted solution, then it surely would make sense as you say. 

 
> On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu> wrote:
> 
> I think it should be up to the programmer (e. g. by passing a flag or using different methods) whether he wants 10 events after missing those while hibernation, or whether he wants the events to be collapsed into one single event alternatively. BTW, I never said that the API must support an absolute variant of repeated event schedulung. You could also simply provide an absolute variant of the "fire ONCE" method, and the mail application has to reschedule inside of the event handler.
> 
> Hooks are out of scope for my proposal, as they solve a different problem and are working on a deeper level (the scheduler API could certainly make use of such hooks). In case the Windows API for example would be able to solve the problem for us (it is, BTW), why shouldn't we provide a Java API wrapping that (without running into any rattail, as we simply offload)?
> 
> -Markus
> 
> -----Original Message-----
> From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
> Sent: Samstag, 9. Januar 2016 11:02
> To: Markus KARG
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments
> 
> ?...or it will fire instantly after the end of hibernation ?? considering your example of hourly/periodically checking mails, that would mean that the program checks your mailbox 10 times at once after 10h hibernation. 
> So the API would also need to know whether unfired events should queue up over time. Sounds like a rattail pulling endlessly use cases & requirements behind it.
> 
> I for one never thought about using the JVM to schedule things that live through hibernation or similar (not knowing the original intention of the API). But I have also never built daemon-like desktop/client applications/services.
> 
> I guess in case of JVM, one could argue that specifications only apply at runtime, and hibernation is interrupting that. Maybe it would be better to provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-hibernation, standby, signals etc. Then one could de/attach events accordingly.
> 
> 
>> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu> wrote:
>> 
>> The following requests comments on a Feature Proposal for Absolute Scheduling.
>> 
>> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the following case:
>> 
>> * ScheduledExecutorService.schedule() is invoked to schedule firing of an event "in one minute".
>> * The laptop lid gets closed instantly after that, so hibernation will occur, hence the JVM will suspend.
>> * After thirty seconds of hibernation, the laptop lid gets openen, so hibernation will cancel and the JVM resumes.
>> * Despite the expected result (one minute after start of program the event does occur), the event actually is delayed by the length of the hibernation phase, and happens 90 seconds after the program was started. In the expectation of the end user, the event fired 30 seconds "too late"!
>> 
>> This is annoying to users and rather unexpected and astonishing for programmers literally following the words of the JavaDocs. Clearly the provided deadline is a relative value in the physical sense ("one minute from now, independent of what 'now' is currently like"), but certainly what the user actually expects it to work like is an absolute value in the physical sense ("one minute from now, where 'now' is the current point on the time axis of the Universe, hence unaffected by hibernation). Whether or not the laptop was closed temporarily in the meantime plays no role to the expectation of neither the end user nor the application provider.
>> 
>> Unfortunately there is no other API that allows the application vendor to define that the deadline it meant to be unaffected of hibernation. Clearly this is a drawback to the Java platform, as many applications need such a behaviour (like "check my mails once per hour" - if you open your laptop lid ONLY for a few minutes to see whether meanwhile new emails arrived or not [like, BTW, some laptops are able to perform these days, even with the lid closed, thanks to a BIOS timer] you won't receive any new emails ever as "JVM" time progresses only be few minutes per day then).
>> 
>> A solution could be the addition of a special variant of ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of any hibernation, and will fire either exactly at the absoluteInstant (in case the laptop is not hibernating _currently_), or it will fire instantly after the end of hibernation, in case the laptop was hibernating at absoluteInstant.
>> 
>> There are two possible ways to reach this: Either there is an OS-specific API that alrady provides exactly that behaviour, or the JVM needs to be informed every 'x' fractions of "discontinuous jvm time" to find out how much "continuous real world time" has advanced and whether a scheduled event was missed meanwhile (which is the workaround such applications have to perform on their own currently to workaround the problem). The first is problematic due to changes in the implementations of the APIs (e. g. Windows changed some APIs from "continuous time" to using "discontinuous time"), the second is complex in finding the optimal value of 'x' (too low means high power consumption, too high means firing too late after the deadline).
>> 
>> Side note: To be unambiguous, the new deadline should possibly be typed as java.time.Instant, as that could never be misunderstood as "discontinous jvm time" inherently.
>> 
>> What is your opinion on that?
>> 
>> -Markus
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest





From davidcholmes at aapt.net.au  Sat Jan  9 17:07:42 2016
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sun, 10 Jan 2016 08:07:42 +1000
Subject: [concurrency-interest] JDK-8146527: Absolute
	Scheduling	/	Request for Comments
In-Reply-To: <006401d14b06$58dadb40$0a9091c0$@eu>
References: <002501d14ac0$28189150$7849b3f0$@eu>	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>	<009001d14ade$43383fd0$c9a8bf70$@eu>	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>	<00ac01d14ae5$b0628d70$1127a850$@eu>	<006001d14b01$c85b6b60$59124220$@gmail.com>
	<006401d14b06$58dadb40$0a9091c0$@eu>
Message-ID: <00c401d14b2a$297506e0$7c5f14a0$@aapt.net.au>

It is "by design" in the sense that:

a) nothing in the Java platform APIs, or the VM implementation, were designed to work across machine suspension
b) the underlying Window's API's do not behave in the way that is being described.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> Sent: Sunday, January 10, 2016 3:51 AM
> To: 'Nathan & Ila Reynolds' <nathanila at gmail.com>; 'Carsten Schipke'
> <carsten.schipke at gmail.com>
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> 
> Nathan,
> 
> thanks for your comments.
> 
> Please note that the actual behaviour deviates from your expectation on
> varying with the OS type and version. For example, the one-time-trigger
> "schedule(delay)" variant of JDK 8u66 on Win 8.1 (64 Bit) does *not* fire the
> event "very soon after the delay" in some cases; in fact, it adds the complete
> duration of the hibernation to relative-ms. Hence, when you call
> "schedule(1min)", hibernate for 30s, wakeup the PC, then the event actually
> fires 90s after you invoked that command! In fact, that behaviour is *by
> design* as I learned (according to Oracle's David Holmes), and it is the reason
> for filing this RFC.
> 
> -Markus
> 
> 
> -----Original Message-----
> From: Nathan & Ila Reynolds [mailto:nathanila at gmail.com]
> Sent: Samstag, 9. Januar 2016 18:19
> To: 'Markus KARG'; 'Carsten Schipke'
> Cc: concurrency-interest at cs.oswego.edu
> Subject: RE: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> 
> Also, Windows fires an event to all applications when the system resumes
> after hibernation.  You could use that event instead of polling.
> 
> ScheduledExecutorService provides schedule(), scheduleAtFixedRate() and
> scheduleWithFixedDelay().  I expect schedule() to run the command at or
> very soon after the delay or as soon as the machine resumes if the delay has
> elapsed.  I expect scheduleAtFixedRate() to run the command N times
> rapidly if hibernation lasted N periods.  I expect scheduleWithFixedDelay() to
> run the command one time at or very soon after the delay or as soon as the
> machine resumes.  In this regard, the programmer has control whether they
> need N times or 1 time after hibernation.  I only use scheduleAtFixedRate() if
> I have something staying in sync with the passage of time.  I use
> scheduleWithFixedDelay() in all other cases because if the command takes a
> long time, I don't need it to run right away.
> 
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
> xecutorService.html
> 
> -Nathan
> 
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> Sent: Saturday, January 09, 2016 6:58 AM
> To: 'Carsten Schipke' <carsten.schipke at gmail.com>
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> 
> Carsten,
> 
> the Windows API provides several different methods for timing. Some of
> them are definitively able to fire at a particular point in time, independent of
> any hibernation.
> 
> In case a different OS won't have such a factility, there is a simple fallback:
> Triggering events more often, checking the actual time (in pure Java), so we
> find out whether to wait further, or whether the event is to be fired. This,
> BTW, is the workaround applied by pure Java solutions currently, hence what
> I'd like to get rid off by this feature request. :-)
> 
> -Markus
> 
> 
> -----Original Message-----
> From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> Sent: Samstag, 9. Januar 2016 14:09
> To: Markus KARG
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> 
> sure, as I mentioned, I have never really had that requirement, it just
> sounded to me like many programmers could have many slightly different
> requirements on such an API. I also don?t know what the Windows API
> offers in those regards / how its solved there, but if there is such a widely
> accepted solution, then it surely would make sense as you say.
> 
> 
> > On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu> wrote:
> >
> > I think it should be up to the programmer (e. g. by passing a flag or using
> different methods) whether he wants 10 events after missing those while
> hibernation, or whether he wants the events to be collapsed into one single
> event alternatively. BTW, I never said that the API must support an absolute
> variant of repeated event schedulung. You could also simply provide an
> absolute variant of the "fire ONCE" method, and the mail application has to
> reschedule inside of the event handler.
> >
> > Hooks are out of scope for my proposal, as they solve a different problem
> and are working on a deeper level (the scheduler API could certainly make
> use of such hooks). In case the Windows API for example would be able to
> solve the problem for us (it is, BTW), why shouldn't we provide a Java API
> wrapping that (without running into any rattail, as we simply offload)?
> >
> > -Markus
> >
> > -----Original Message-----
> > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > Sent: Samstag, 9. Januar 2016 11:02
> > To: Markus KARG
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> >
> > ?...or it will fire instantly after the end of hibernation ?? considering your
> example of hourly/periodically checking mails, that would mean that the
> program checks your mailbox 10 times at once after 10h hibernation.
> > So the API would also need to know whether unfired events should queue
> up over time. Sounds like a rattail pulling endlessly use cases & requirements
> behind it.
> >
> > I for one never thought about using the JVM to schedule things that live
> through hibernation or similar (not knowing the original intention of the API).
> But I have also never built daemon-like desktop/client applications/services.
> >
> > I guess in case of JVM, one could argue that specifications only apply at
> runtime, and hibernation is interrupting that. Maybe it would be better to
> provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-
> hibernation, standby, signals etc. Then one could de/attach events
> accordingly.
> >
> >
> >> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu>
> wrote:
> >>
> >> The following requests comments on a Feature Proposal for Absolute
> Scheduling.
> >>
> >> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-
> 8146527) describes the following case:
> >>
> >> * ScheduledExecutorService.schedule() is invoked to schedule firing of an
> event "in one minute".
> >> * The laptop lid gets closed instantly after that, so hibernation will occur,
> hence the JVM will suspend.
> >> * After thirty seconds of hibernation, the laptop lid gets openen, so
> hibernation will cancel and the JVM resumes.
> >> * Despite the expected result (one minute after start of program the
> event does occur), the event actually is delayed by the length of the
> hibernation phase, and happens 90 seconds after the program was started.
> In the expectation of the end user, the event fired 30 seconds "too late"!
> >>
> >> This is annoying to users and rather unexpected and astonishing for
> programmers literally following the words of the JavaDocs. Clearly the
> provided deadline is a relative value in the physical sense ("one minute from
> now, independent of what 'now' is currently like"), but certainly what the
> user actually expects it to work like is an absolute value in the physical sense
> ("one minute from now, where 'now' is the current point on the time axis of
> the Universe, hence unaffected by hibernation). Whether or not the laptop
> was closed temporarily in the meantime plays no role to the expectation of
> neither the end user nor the application provider.
> >>
> >> Unfortunately there is no other API that allows the application vendor to
> define that the deadline it meant to be unaffected of hibernation. Clearly
> this is a drawback to the Java platform, as many applications need such a
> behaviour (like "check my mails once per hour" - if you open your laptop lid
> ONLY for a few minutes to see whether meanwhile new emails arrived or not
> [like, BTW, some laptops are able to perform these days, even with the lid
> closed, thanks to a BIOS timer] you won't receive any new emails ever as
> "JVM" time progresses only be few minutes per day then).
> >>
> >> A solution could be the addition of a special variant of
> ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of
> any hibernation, and will fire either exactly at the absoluteInstant (in case the
> laptop is not hibernating _currently_), or it will fire instantly after the end of
> hibernation, in case the laptop was hibernating at absoluteInstant.
> >>
> >> There are two possible ways to reach this: Either there is an OS-specific
> API that alrady provides exactly that behaviour, or the JVM needs to be
> informed every 'x' fractions of "discontinuous jvm time" to find out how
> much "continuous real world time" has advanced and whether a scheduled
> event was missed meanwhile (which is the workaround such applications
> have to perform on their own currently to workaround the problem). The
> first is problematic due to changes in the implementations of the APIs (e. g.
> Windows changed some APIs from "continuous time" to using
> "discontinuous time"), the second is complex in finding the optimal value of
> 'x' (too low means high power consumption, too high means firing too late
> after the deadline).
> >>
> >> Side note: To be unambiguous, the new deadline should possibly be
> typed as java.time.Instant, as that could never be misunderstood as
> "discontinous jvm time" inherently.
> >>
> >> What is your opinion on that?
> >>
> >> -Markus
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From joe.bowbeer at gmail.com  Sat Jan  9 17:57:40 2016
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sat, 9 Jan 2016 14:57:40 -0800
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
 Request for Comments
In-Reply-To: <00c401d14b2a$297506e0$7c5f14a0$@aapt.net.au>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
	<009001d14ade$43383fd0$c9a8bf70$@eu>
	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
	<00ac01d14ae5$b0628d70$1127a850$@eu>
	<006001d14b01$c85b6b60$59124220$@gmail.com>
	<006401d14b06$58dadb40$0a9091c0$@eu>
	<00c401d14b2a$297506e0$7c5f14a0$@aapt.net.au>
Message-ID: <CAHzJPEqyA1C7c8VjOhv_wym3AghQ4SHvuZoR0OM2H1VVwJdEgg@mail.gmail.com>

On mobile platforms, such as Android (or J2ME), suspension is commonplace,
and even force-termination for resource reclamation or battery preservation
is common.

For both these reasons, app developers need to deal with these
eventualities explicitly, saving and restoring persistent state, and cannot
rely only on a scheduled executor service.

On Sat, Jan 9, 2016 at 2:07 PM, David Holmes <davidcholmes at aapt.net.au>
wrote:

> It is "by design" in the sense that:
>
> a) nothing in the Java platform APIs, or the VM implementation, were
> designed to work across machine suspension
> b) the underlying Window's API's do not behave in the way that is being
> described.
>
> David
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> > Sent: Sunday, January 10, 2016 3:51 AM
> > To: 'Nathan & Ila Reynolds' <nathanila at gmail.com>; 'Carsten Schipke'
> > <carsten.schipke at gmail.com>
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> >
> > Nathan,
> >
> > thanks for your comments.
> >
> > Please note that the actual behaviour deviates from your expectation on
> > varying with the OS type and version. For example, the one-time-trigger
> > "schedule(delay)" variant of JDK 8u66 on Win 8.1 (64 Bit) does *not*
> fire the
> > event "very soon after the delay" in some cases; in fact, it adds the
> complete
> > duration of the hibernation to relative-ms. Hence, when you call
> > "schedule(1min)", hibernate for 30s, wakeup the PC, then the event
> actually
> > fires 90s after you invoked that command! In fact, that behaviour is *by
> > design* as I learned (according to Oracle's David Holmes), and it is the
> reason
> > for filing this RFC.
> >
> > -Markus
> >
> >
> > -----Original Message-----
> > From: Nathan & Ila Reynolds [mailto:nathanila at gmail.com]
> > Sent: Samstag, 9. Januar 2016 18:19
> > To: 'Markus KARG'; 'Carsten Schipke'
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: RE: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> >
> > Also, Windows fires an event to all applications when the system resumes
> > after hibernation.  You could use that event instead of polling.
> >
> > ScheduledExecutorService provides schedule(), scheduleAtFixedRate() and
> > scheduleWithFixedDelay().  I expect schedule() to run the command at or
> > very soon after the delay or as soon as the machine resumes if the delay
> has
> > elapsed.  I expect scheduleAtFixedRate() to run the command N times
> > rapidly if hibernation lasted N periods.  I expect
> scheduleWithFixedDelay() to
> > run the command one time at or very soon after the delay or as soon as
> the
> > machine resumes.  In this regard, the programmer has control whether they
> > need N times or 1 time after hibernation.  I only use
> scheduleAtFixedRate() if
> > I have something staying in sync with the passage of time.  I use
> > scheduleWithFixedDelay() in all other cases because if the command takes
> a
> > long time, I don't need it to run right away.
> >
> >
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
> > xecutorService.html
> >
> > -Nathan
> >
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> > Sent: Saturday, January 09, 2016 6:58 AM
> > To: 'Carsten Schipke' <carsten.schipke at gmail.com>
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> >
> > Carsten,
> >
> > the Windows API provides several different methods for timing. Some of
> > them are definitively able to fire at a particular point in time,
> independent of
> > any hibernation.
> >
> > In case a different OS won't have such a factility, there is a simple
> fallback:
> > Triggering events more often, checking the actual time (in pure Java),
> so we
> > find out whether to wait further, or whether the event is to be fired.
> This,
> > BTW, is the workaround applied by pure Java solutions currently, hence
> what
> > I'd like to get rid off by this feature request. :-)
> >
> > -Markus
> >
> >
> > -----Original Message-----
> > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > Sent: Samstag, 9. Januar 2016 14:09
> > To: Markus KARG
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> >
> > sure, as I mentioned, I have never really had that requirement, it just
> > sounded to me like many programmers could have many slightly different
> > requirements on such an API. I also don?t know what the Windows API
> > offers in those regards / how its solved there, but if there is such a
> widely
> > accepted solution, then it surely would make sense as you say.
> >
> >
> > > On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu> wrote:
> > >
> > > I think it should be up to the programmer (e. g. by passing a flag or
> using
> > different methods) whether he wants 10 events after missing those while
> > hibernation, or whether he wants the events to be collapsed into one
> single
> > event alternatively. BTW, I never said that the API must support an
> absolute
> > variant of repeated event schedulung. You could also simply provide an
> > absolute variant of the "fire ONCE" method, and the mail application has
> to
> > reschedule inside of the event handler.
> > >
> > > Hooks are out of scope for my proposal, as they solve a different
> problem
> > and are working on a deeper level (the scheduler API could certainly make
> > use of such hooks). In case the Windows API for example would be able to
> > solve the problem for us (it is, BTW), why shouldn't we provide a Java
> API
> > wrapping that (without running into any rattail, as we simply offload)?
> > >
> > > -Markus
> > >
> > > -----Original Message-----
> > > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > > Sent: Samstag, 9. Januar 2016 11:02
> > > To: Markus KARG
> > > Cc: concurrency-interest at cs.oswego.edu
> > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> > >
> > > ?...or it will fire instantly after the end of hibernation ??
> considering your
> > example of hourly/periodically checking mails, that would mean that the
> > program checks your mailbox 10 times at once after 10h hibernation.
> > > So the API would also need to know whether unfired events should queue
> > up over time. Sounds like a rattail pulling endlessly use cases &
> requirements
> > behind it.
> > >
> > > I for one never thought about using the JVM to schedule things that
> live
> > through hibernation or similar (not knowing the original intention of
> the API).
> > But I have also never built daemon-like desktop/client
> applications/services.
> > >
> > > I guess in case of JVM, one could argue that specifications only apply
> at
> > runtime, and hibernation is interrupting that. Maybe it would be better
> to
> > provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-
> > hibernation, standby, signals etc. Then one could de/attach events
> > accordingly.
> > >
> > >
> > >> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu>
> > wrote:
> > >>
> > >> The following requests comments on a Feature Proposal for Absolute
> > Scheduling.
> > >>
> > >> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-
> > 8146527) describes the following case:
> > >>
> > >> * ScheduledExecutorService.schedule() is invoked to schedule firing
> of an
> > event "in one minute".
> > >> * The laptop lid gets closed instantly after that, so hibernation
> will occur,
> > hence the JVM will suspend.
> > >> * After thirty seconds of hibernation, the laptop lid gets openen, so
> > hibernation will cancel and the JVM resumes.
> > >> * Despite the expected result (one minute after start of program the
> > event does occur), the event actually is delayed by the length of the
> > hibernation phase, and happens 90 seconds after the program was started.
> > In the expectation of the end user, the event fired 30 seconds "too
> late"!
> > >>
> > >> This is annoying to users and rather unexpected and astonishing for
> > programmers literally following the words of the JavaDocs. Clearly the
> > provided deadline is a relative value in the physical sense ("one minute
> from
> > now, independent of what 'now' is currently like"), but certainly what
> the
> > user actually expects it to work like is an absolute value in the
> physical sense
> > ("one minute from now, where 'now' is the current point on the time axis
> of
> > the Universe, hence unaffected by hibernation). Whether or not the laptop
> > was closed temporarily in the meantime plays no role to the expectation
> of
> > neither the end user nor the application provider.
> > >>
> > >> Unfortunately there is no other API that allows the application
> vendor to
> > define that the deadline it meant to be unaffected of hibernation.
> Clearly
> > this is a drawback to the Java platform, as many applications need such a
> > behaviour (like "check my mails once per hour" - if you open your laptop
> lid
> > ONLY for a few minutes to see whether meanwhile new emails arrived or not
> > [like, BTW, some laptops are able to perform these days, even with the
> lid
> > closed, thanks to a BIOS timer] you won't receive any new emails ever as
> > "JVM" time progresses only be few minutes per day then).
> > >>
> > >> A solution could be the addition of a special variant of
> > ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of
> > any hibernation, and will fire either exactly at the absoluteInstant (in
> case the
> > laptop is not hibernating _currently_), or it will fire instantly after
> the end of
> > hibernation, in case the laptop was hibernating at absoluteInstant.
> > >>
> > >> There are two possible ways to reach this: Either there is an
> OS-specific
> > API that alrady provides exactly that behaviour, or the JVM needs to be
> > informed every 'x' fractions of "discontinuous jvm time" to find out how
> > much "continuous real world time" has advanced and whether a scheduled
> > event was missed meanwhile (which is the workaround such applications
> > have to perform on their own currently to workaround the problem). The
> > first is problematic due to changes in the implementations of the APIs
> (e. g.
> > Windows changed some APIs from "continuous time" to using
> > "discontinuous time"), the second is complex in finding the optimal
> value of
> > 'x' (too low means high power consumption, too high means firing too late
> > after the deadline).
> > >>
> > >> Side note: To be unambiguous, the new deadline should possibly be
> > typed as java.time.Instant, as that could never be misunderstood as
> > "discontinous jvm time" inherently.
> > >>
> > >> What is your opinion on that?
> > >>
> > >> -Markus
> > >> _______________________________________________
> > >> Concurrency-interest mailing list
> > >> Concurrency-interest at cs.oswego.edu
> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160109/991f9b06/attachment-0001.html>

From oleksandr.otenko at gmail.com  Sat Jan  9 21:03:30 2016
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Sun, 10 Jan 2016 02:03:30 +0000
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling
	/	Request for Comments
In-Reply-To: <006001d14b01$c85b6b60$59124220$@gmail.com>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
	<009001d14ade$43383fd0$c9a8bf70$@eu>
	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
	<00ac01d14ae5$b0628d70$1127a850$@eu>
	<006001d14b01$c85b6b60$59124220$@gmail.com>
Message-ID: <EE8F7E94-8BEC-47CF-9D76-049944F08B6B@gmail.com>

I would expect these to be case-specific.

The flow of time is different in different frames of reference. Mailer wants it to be tied to the frame of reference coinciding with mail server (which is in the same frame as Greenwich), Sudoku game wants it tied to the frame of reference coinciding with Sudoku process space - it doesn?t want to count time towards the score whilst the game is not in the foreground.

It would be nice to have a replaceable clock, or the source of time for individual condvars.

Alex

> On 9 Jan 2016, at 17:18, Nathan & Ila Reynolds <nathanila at gmail.com> wrote:
> 
> Also, Windows fires an event to all applications when the system resumes after hibernation.  You could use that event instead of polling.
> 
> ScheduledExecutorService provides schedule(), scheduleAtFixedRate() and scheduleWithFixedDelay().  I expect schedule() to run the command at or very soon after the delay or as soon as the machine resumes if the delay has elapsed.  I expect scheduleAtFixedRate() to run the command N times rapidly if hibernation lasted N periods.  I expect scheduleWithFixedDelay() to run the command one time at or very soon after the delay or as soon as the machine resumes.  In this regard, the programmer has control whether they need N times or 1 time after hibernation.  I only use scheduleAtFixedRate() if I have something staying in sync with the passage of time.  I use scheduleWithFixedDelay() in all other cases because if the command takes a long time, I don't need it to run right away.
> 
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html
> 
> -Nathan
> 
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> Sent: Saturday, January 09, 2016 6:58 AM
> To: 'Carsten Schipke' <carsten.schipke at gmail.com>
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments
> 
> Carsten,
> 
> the Windows API provides several different methods for timing. Some of them are definitively able to fire at a particular point in time, independent of any hibernation.
> 
> In case a different OS won't have such a factility, there is a simple fallback: Triggering events more often, checking the actual time (in pure Java), so we find out whether to wait further, or whether the event is to be fired. This, BTW, is the workaround applied by pure Java solutions currently, hence what I'd like to get rid off by this feature request. :-)
> 
> -Markus 
> 
> 
> -----Original Message-----
> From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
> Sent: Samstag, 9. Januar 2016 14:09
> To: Markus KARG
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments
> 
> sure, as I mentioned, I have never really had that requirement, it just sounded to me like many programmers could have many slightly different requirements on such an API. I also don?t know what the Windows API offers in those regards / how its solved there, but if there is such a widely accepted solution, then it surely would make sense as you say. 
> 
> 
>> On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu> wrote:
>> 
>> I think it should be up to the programmer (e. g. by passing a flag or using different methods) whether he wants 10 events after missing those while hibernation, or whether he wants the events to be collapsed into one single event alternatively. BTW, I never said that the API must support an absolute variant of repeated event schedulung. You could also simply provide an absolute variant of the "fire ONCE" method, and the mail application has to reschedule inside of the event handler.
>> 
>> Hooks are out of scope for my proposal, as they solve a different problem and are working on a deeper level (the scheduler API could certainly make use of such hooks). In case the Windows API for example would be able to solve the problem for us (it is, BTW), why shouldn't we provide a Java API wrapping that (without running into any rattail, as we simply offload)?
>> 
>> -Markus
>> 
>> -----Original Message-----
>> From: Carsten Schipke [mailto:carsten.schipke at gmail.com] 
>> Sent: Samstag, 9. Januar 2016 11:02
>> To: Markus KARG
>> Cc: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments
>> 
>> ?...or it will fire instantly after the end of hibernation ?? considering your example of hourly/periodically checking mails, that would mean that the program checks your mailbox 10 times at once after 10h hibernation. 
>> So the API would also need to know whether unfired events should queue up over time. Sounds like a rattail pulling endlessly use cases & requirements behind it.
>> 
>> I for one never thought about using the JVM to schedule things that live through hibernation or similar (not knowing the original intention of the API). But I have also never built daemon-like desktop/client applications/services.
>> 
>> I guess in case of JVM, one could argue that specifications only apply at runtime, and hibernation is interrupting that. Maybe it would be better to provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-hibernation, standby, signals etc. Then one could de/attach events accordingly.
>> 
>> 
>>> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu> wrote:
>>> 
>>> The following requests comments on a Feature Proposal for Absolute Scheduling.
>>> 
>>> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the following case:
>>> 
>>> * ScheduledExecutorService.schedule() is invoked to schedule firing of an event "in one minute".
>>> * The laptop lid gets closed instantly after that, so hibernation will occur, hence the JVM will suspend.
>>> * After thirty seconds of hibernation, the laptop lid gets openen, so hibernation will cancel and the JVM resumes.
>>> * Despite the expected result (one minute after start of program the event does occur), the event actually is delayed by the length of the hibernation phase, and happens 90 seconds after the program was started. In the expectation of the end user, the event fired 30 seconds "too late"!
>>> 
>>> This is annoying to users and rather unexpected and astonishing for programmers literally following the words of the JavaDocs. Clearly the provided deadline is a relative value in the physical sense ("one minute from now, independent of what 'now' is currently like"), but certainly what the user actually expects it to work like is an absolute value in the physical sense ("one minute from now, where 'now' is the current point on the time axis of the Universe, hence unaffected by hibernation). Whether or not the laptop was closed temporarily in the meantime plays no role to the expectation of neither the end user nor the application provider.
>>> 
>>> Unfortunately there is no other API that allows the application vendor to define that the deadline it meant to be unaffected of hibernation. Clearly this is a drawback to the Java platform, as many applications need such a behaviour (like "check my mails once per hour" - if you open your laptop lid ONLY for a few minutes to see whether meanwhile new emails arrived or not [like, BTW, some laptops are able to perform these days, even with the lid closed, thanks to a BIOS timer] you won't receive any new emails ever as "JVM" time progresses only be few minutes per day then).
>>> 
>>> A solution could be the addition of a special variant of ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of any hibernation, and will fire either exactly at the absoluteInstant (in case the laptop is not hibernating _currently_), or it will fire instantly after the end of hibernation, in case the laptop was hibernating at absoluteInstant.
>>> 
>>> There are two possible ways to reach this: Either there is an OS-specific API that alrady provides exactly that behaviour, or the JVM needs to be informed every 'x' fractions of "discontinuous jvm time" to find out how much "continuous real world time" has advanced and whether a scheduled event was missed meanwhile (which is the workaround such applications have to perform on their own currently to workaround the problem). The first is problematic due to changes in the implementations of the APIs (e. g. Windows changed some APIs from "continuous time" to using "discontinuous time"), the second is complex in finding the optimal value of 'x' (too low means high power consumption, too high means firing too late after the deadline).
>>> 
>>> Side note: To be unambiguous, the new deadline should possibly be typed as java.time.Instant, as that could never be misunderstood as "discontinous jvm time" inherently.
>>> 
>>> What is your opinion on that?
>>> 
>>> -Markus
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From davidcholmes at aapt.net.au  Sat Jan  9 22:07:51 2016
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sun, 10 Jan 2016 13:07:51 +1000
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
	Request for Comments
In-Reply-To: <CAHzJPEqyA1C7c8VjOhv_wym3AghQ4SHvuZoR0OM2H1VVwJdEgg@mail.gmail.com>
References: <002501d14ac0$28189150$7849b3f0$@eu>	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>	<009001d14ade$43383fd0$c9a8bf70$@eu>	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>	<00ac01d14ae5$b0628d70$1127a850$@eu>	<006001d14b01$c85b6b60$59124220$@gmail.com>	<006401d14b06$58dadb40$0a9091c0$@eu>	<00c401d14b2a$297506e0$7c5f14a0$@aapt.net.au>
	<CAHzJPEqyA1C7c8VjOhv_wym3AghQ4SHvuZoR0OM2H1VVwJdEgg@mail.gmail.com>
Message-ID: <00cc01d14b54$180b39e0$4821ada0$@aapt.net.au>

Yes for mobile this is part of the programming model and it needs to be a primary consideration. Hence the various event hooks to allow for this.

 

David

 

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Joe Bowbeer
Sent: Sunday, January 10, 2016 8:58 AM
To: David Holmes <dholmes at ieee.org>
Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

 

On mobile platforms, such as Android (or J2ME), suspension is commonplace, and even force-termination for resource reclamation or battery preservation is common.

 

For both these reasons, app developers need to deal with these eventualities explicitly, saving and restoring persistent state, and cannot rely only on a scheduled executor service.

 

On Sat, Jan 9, 2016 at 2:07 PM, David Holmes <davidcholmes at aapt.net.au <mailto:davidcholmes at aapt.net.au> > wrote:

It is "by design" in the sense that:

a) nothing in the Java platform APIs, or the VM implementation, were designed to work across machine suspension
b) the underlying Window's API's do not behave in the way that is being described.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu <mailto:concurrency-interest-bounces at cs.oswego.edu>  [mailto:concurrency- <mailto:concurrency-> 
> interest-bounces at cs.oswego.edu <mailto:interest-bounces at cs.oswego.edu> ] On Behalf Of Markus KARG
> Sent: Sunday, January 10, 2016 3:51 AM
> To: 'Nathan & Ila Reynolds' <nathanila at gmail.com <mailto:nathanila at gmail.com> >; 'Carsten Schipke'
> <carsten.schipke at gmail.com <mailto:carsten.schipke at gmail.com> >
> Cc: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu> 
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
>

> Nathan,
>
> thanks for your comments.
>
> Please note that the actual behaviour deviates from your expectation on
> varying with the OS type and version. For example, the one-time-trigger
> "schedule(delay)" variant of JDK 8u66 on Win 8.1 (64 Bit) does *not* fire the
> event "very soon after the delay" in some cases; in fact, it adds the complete
> duration of the hibernation to relative-ms. Hence, when you call
> "schedule(1min)", hibernate for 30s, wakeup the PC, then the event actually
> fires 90s after you invoked that command! In fact, that behaviour is *by
> design* as I learned (according to Oracle's David Holmes), and it is the reason
> for filing this RFC.
>
> -Markus
>
>
> -----Original Message-----
> From: Nathan & Ila Reynolds [mailto:nathanila at gmail.com <mailto:nathanila at gmail.com> ]
> Sent: Samstag, 9. Januar 2016 18:19
> To: 'Markus KARG'; 'Carsten Schipke'
> Cc: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu> 
> Subject: RE: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
>
> Also, Windows fires an event to all applications when the system resumes
> after hibernation.  You could use that event instead of polling.
>
> ScheduledExecutorService provides schedule(), scheduleAtFixedRate() and
> scheduleWithFixedDelay().  I expect schedule() to run the command at or
> very soon after the delay or as soon as the machine resumes if the delay has
> elapsed.  I expect scheduleAtFixedRate() to run the command N times
> rapidly if hibernation lasted N periods.  I expect scheduleWithFixedDelay() to
> run the command one time at or very soon after the delay or as soon as the
> machine resumes.  In this regard, the programmer has control whether they
> need N times or 1 time after hibernation.  I only use scheduleAtFixedRate() if
> I have something staying in sync with the passage of time.  I use
> scheduleWithFixedDelay() in all other cases because if the command takes a
> long time, I don't need it to run right away.
>
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
> xecutorService.html
>
> -Nathan
>
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu <mailto:concurrency-interest-bounces at cs.oswego.edu>  [mailto:concurrency- <mailto:concurrency-> 
> interest-bounces at cs.oswego.edu <mailto:interest-bounces at cs.oswego.edu> ] On Behalf Of Markus KARG
> Sent: Saturday, January 09, 2016 6:58 AM
> To: 'Carsten Schipke' <carsten.schipke at gmail.com <mailto:carsten.schipke at gmail.com> >
> Cc: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu> 
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
>
> Carsten,
>
> the Windows API provides several different methods for timing. Some of
> them are definitively able to fire at a particular point in time, independent of
> any hibernation.
>
> In case a different OS won't have such a factility, there is a simple fallback:
> Triggering events more often, checking the actual time (in pure Java), so we
> find out whether to wait further, or whether the event is to be fired. This,
> BTW, is the workaround applied by pure Java solutions currently, hence what
> I'd like to get rid off by this feature request. :-)
>
> -Markus
>
>
> -----Original Message-----
> From: Carsten Schipke [mailto:carsten.schipke at gmail.com <mailto:carsten.schipke at gmail.com> ]
> Sent: Samstag, 9. Januar 2016 14:09
> To: Markus KARG
> Cc: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu> 
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
>
> sure, as I mentioned, I have never really had that requirement, it just
> sounded to me like many programmers could have many slightly different
> requirements on such an API. I also don?t know what the Windows API
> offers in those regards / how its solved there, but if there is such a widely
> accepted solution, then it surely would make sense as you say.
>
>
> > On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu <mailto:markus at headcrashing.eu> > wrote:
> >
> > I think it should be up to the programmer (e. g. by passing a flag or using
> different methods) whether he wants 10 events after missing those while
> hibernation, or whether he wants the events to be collapsed into one single
> event alternatively. BTW, I never said that the API must support an absolute
> variant of repeated event schedulung. You could also simply provide an
> absolute variant of the "fire ONCE" method, and the mail application has to
> reschedule inside of the event handler.
> >
> > Hooks are out of scope for my proposal, as they solve a different problem
> and are working on a deeper level (the scheduler API could certainly make
> use of such hooks). In case the Windows API for example would be able to
> solve the problem for us (it is, BTW), why shouldn't we provide a Java API
> wrapping that (without running into any rattail, as we simply offload)?
> >
> > -Markus
> >
> > -----Original Message-----
> > From: Carsten Schipke [mailto:carsten.schipke at gmail.com <mailto:carsten.schipke at gmail.com> ]
> > Sent: Samstag, 9. Januar 2016 11:02
> > To: Markus KARG
> > Cc: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu> 
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> >
> > ?...or it will fire instantly after the end of hibernation ?? considering your
> example of hourly/periodically checking mails, that would mean that the
> program checks your mailbox 10 times at once after 10h hibernation.
> > So the API would also need to know whether unfired events should queue
> up over time. Sounds like a rattail pulling endlessly use cases & requirements
> behind it.
> >
> > I for one never thought about using the JVM to schedule things that live
> through hibernation or similar (not knowing the original intention of the API).
> But I have also never built daemon-like desktop/client applications/services.
> >
> > I guess in case of JVM, one could argue that specifications only apply at
> runtime, and hibernation is interrupting that. Maybe it would be better to
> provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-
> hibernation, standby, signals etc. Then one could de/attach events
> accordingly.
> >
> >
> >> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu <mailto:markus at headcrashing.eu> >
> wrote:
> >>
> >> The following requests comments on a Feature Proposal for Absolute
> Scheduling.
> >>
> >> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-
> 8146527) describes the following case:
> >>
> >> * ScheduledExecutorService.schedule() is invoked to schedule firing of an
> event "in one minute".
> >> * The laptop lid gets closed instantly after that, so hibernation will occur,
> hence the JVM will suspend.
> >> * After thirty seconds of hibernation, the laptop lid gets openen, so
> hibernation will cancel and the JVM resumes.
> >> * Despite the expected result (one minute after start of program the
> event does occur), the event actually is delayed by the length of the
> hibernation phase, and happens 90 seconds after the program was started.
> In the expectation of the end user, the event fired 30 seconds "too late"!
> >>
> >> This is annoying to users and rather unexpected and astonishing for
> programmers literally following the words of the JavaDocs. Clearly the
> provided deadline is a relative value in the physical sense ("one minute from
> now, independent of what 'now' is currently like"), but certainly what the
> user actually expects it to work like is an absolute value in the physical sense
> ("one minute from now, where 'now' is the current point on the time axis of
> the Universe, hence unaffected by hibernation). Whether or not the laptop
> was closed temporarily in the meantime plays no role to the expectation of
> neither the end user nor the application provider.
> >>
> >> Unfortunately there is no other API that allows the application vendor to
> define that the deadline it meant to be unaffected of hibernation. Clearly
> this is a drawback to the Java platform, as many applications need such a
> behaviour (like "check my mails once per hour" - if you open your laptop lid
> ONLY for a few minutes to see whether meanwhile new emails arrived or not
> [like, BTW, some laptops are able to perform these days, even with the lid
> closed, thanks to a BIOS timer] you won't receive any new emails ever as
> "JVM" time progresses only be few minutes per day then).
> >>
> >> A solution could be the addition of a special variant of
> ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of
> any hibernation, and will fire either exactly at the absoluteInstant (in case the
> laptop is not hibernating _currently_), or it will fire instantly after the end of
> hibernation, in case the laptop was hibernating at absoluteInstant.
> >>
> >> There are two possible ways to reach this: Either there is an OS-specific
> API that alrady provides exactly that behaviour, or the JVM needs to be
> informed every 'x' fractions of "discontinuous jvm time" to find out how
> much "continuous real world time" has advanced and whether a scheduled
> event was missed meanwhile (which is the workaround such applications
> have to perform on their own currently to workaround the problem). The
> first is problematic due to changes in the implementations of the APIs (e. g.
> Windows changed some APIs from "continuous time" to using
> "discontinuous time"), the second is complex in finding the optimal value of
> 'x' (too low means high power consumption, too high means firing too late
> after the deadline).
> >>
> >> Side note: To be unambiguous, the new deadline should possibly be
> typed as java.time.Instant, as that could never be misunderstood as
> "discontinous jvm time" inherently.
> >>
> >> What is your opinion on that?
> >>
> >> -Markus
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> 
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> 
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> 
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> 
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160110/1c045399/attachment-0001.html>

From carsten.schipke at gmail.com  Sat Jan  9 22:36:13 2016
From: carsten.schipke at gmail.com (Carsten Schipke)
Date: Sun, 10 Jan 2016 11:36:13 +0800
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
	Request for Comments
In-Reply-To: <00cc01d14b54$180b39e0$4821ada0$@aapt.net.au>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
	<009001d14ade$43383fd0$c9a8bf70$@eu>
	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
	<00ac01d14ae5$b0628d70$1127a850$@eu>
	<006001d14b01$c85b6b60$59124220$@gmail.com>
	<006401d14b06$58dadb40$0a9091c0$@eu>
	<00c401d14b2a$297506e0$7c5f14a0$@aapt.net.au>
	<CAHzJPEqyA1C7c8VjOhv_wym3AghQ4SHvuZoR0OM2H1VVwJdEgg@mail.gmail.com>
	<00cc01d14b54$180b39e0$4821ada0$@aapt.net.au>
Message-ID: <DE72C72B-4C70-4286-ACC5-0BF79AA49A75@gmail.com>

Considering the continuous convergence of all platforms nowadays, that should not be a ?mobile programming model?.. Portability was once a major feature of Java. The JVM & Java have some technical debt to pay to make that true again for current times/platforms/technologies.


> On Jan 10, 2016, at 11:07, David Holmes <davidcholmes at aapt.net.au> wrote:
> 
> Yes for mobile this is part of the programming model and it needs to be a primary consideration. Hence the various event hooks to allow for this.
>  
> David
>  
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Joe Bowbeer
> Sent: Sunday, January 10, 2016 8:58 AM
> To: David Holmes <dholmes at ieee.org>
> Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments
>  
> On mobile platforms, such as Android (or J2ME), suspension is commonplace, and even force-termination for resource reclamation or battery preservation is common.
>  
> For both these reasons, app developers need to deal with these eventualities explicitly, saving and restoring persistent state, and cannot rely only on a scheduled executor service.
>  
> On Sat, Jan 9, 2016 at 2:07 PM, David Holmes <davidcholmes at aapt.net.au> wrote:
>> It is "by design" in the sense that:
>> 
>> a) nothing in the Java platform APIs, or the VM implementation, were designed to work across machine suspension
>> b) the underlying Window's API's do not behave in the way that is being described.
>> 
>> David
>> 
>> > -----Original Message-----
>> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
>> > Sent: Sunday, January 10, 2016 3:51 AM
>> > To: 'Nathan & Ila Reynolds' <nathanila at gmail.com>; 'Carsten Schipke'
>> > <carsten.schipke at gmail.com>
>> > Cc: concurrency-interest at cs.oswego.edu
>> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
>> > Request for Comments
>> >
>> > Nathan,
>> >
>> > thanks for your comments.
>> >
>> > Please note that the actual behaviour deviates from your expectation on
>> > varying with the OS type and version. For example, the one-time-trigger
>> > "schedule(delay)" variant of JDK 8u66 on Win 8.1 (64 Bit) does *not* fire the
>> > event "very soon after the delay" in some cases; in fact, it adds the complete
>> > duration of the hibernation to relative-ms. Hence, when you call
>> > "schedule(1min)", hibernate for 30s, wakeup the PC, then the event actually
>> > fires 90s after you invoked that command! In fact, that behaviour is *by
>> > design* as I learned (according to Oracle's David Holmes), and it is the reason
>> > for filing this RFC.
>> >
>> > -Markus
>> >
>> >
>> > -----Original Message-----
>> > From: Nathan & Ila Reynolds [mailto:nathanila at gmail.com]
>> > Sent: Samstag, 9. Januar 2016 18:19
>> > To: 'Markus KARG'; 'Carsten Schipke'
>> > Cc: concurrency-interest at cs.oswego.edu
>> > Subject: RE: [concurrency-interest] JDK-8146527: Absolute Scheduling /
>> > Request for Comments
>> >
>> > Also, Windows fires an event to all applications when the system resumes
>> > after hibernation.  You could use that event instead of polling.
>> >
>> > ScheduledExecutorService provides schedule(), scheduleAtFixedRate() and
>> > scheduleWithFixedDelay().  I expect schedule() to run the command at or
>> > very soon after the delay or as soon as the machine resumes if the delay has
>> > elapsed.  I expect scheduleAtFixedRate() to run the command N times
>> > rapidly if hibernation lasted N periods.  I expect scheduleWithFixedDelay() to
>> > run the command one time at or very soon after the delay or as soon as the
>> > machine resumes.  In this regard, the programmer has control whether they
>> > need N times or 1 time after hibernation.  I only use scheduleAtFixedRate() if
>> > I have something staying in sync with the passage of time.  I use
>> > scheduleWithFixedDelay() in all other cases because if the command takes a
>> > long time, I don't need it to run right away.
>> >
>> > https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
>> > xecutorService.html
>> >
>> > -Nathan
>> >
>> > -----Original Message-----
>> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
>> > Sent: Saturday, January 09, 2016 6:58 AM
>> > To: 'Carsten Schipke' <carsten.schipke at gmail.com>
>> > Cc: concurrency-interest at cs.oswego.edu
>> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
>> > Request for Comments
>> >
>> > Carsten,
>> >
>> > the Windows API provides several different methods for timing. Some of
>> > them are definitively able to fire at a particular point in time, independent of
>> > any hibernation.
>> >
>> > In case a different OS won't have such a factility, there is a simple fallback:
>> > Triggering events more often, checking the actual time (in pure Java), so we
>> > find out whether to wait further, or whether the event is to be fired. This,
>> > BTW, is the workaround applied by pure Java solutions currently, hence what
>> > I'd like to get rid off by this feature request. :-)
>> >
>> > -Markus
>> >
>> >
>> > -----Original Message-----
>> > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
>> > Sent: Samstag, 9. Januar 2016 14:09
>> > To: Markus KARG
>> > Cc: concurrency-interest at cs.oswego.edu
>> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
>> > Request for Comments
>> >
>> > sure, as I mentioned, I have never really had that requirement, it just
>> > sounded to me like many programmers could have many slightly different
>> > requirements on such an API. I also don?t know what the Windows API
>> > offers in those regards / how its solved there, but if there is such a widely
>> > accepted solution, then it surely would make sense as you say.
>> >
>> >
>> > > On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu> wrote:
>> > >
>> > > I think it should be up to the programmer (e. g. by passing a flag or using
>> > different methods) whether he wants 10 events after missing those while
>> > hibernation, or whether he wants the events to be collapsed into one single
>> > event alternatively. BTW, I never said that the API must support an absolute
>> > variant of repeated event schedulung. You could also simply provide an
>> > absolute variant of the "fire ONCE" method, and the mail application has to
>> > reschedule inside of the event handler.
>> > >
>> > > Hooks are out of scope for my proposal, as they solve a different problem
>> > and are working on a deeper level (the scheduler API could certainly make
>> > use of such hooks). In case the Windows API for example would be able to
>> > solve the problem for us (it is, BTW), why shouldn't we provide a Java API
>> > wrapping that (without running into any rattail, as we simply offload)?
>> > >
>> > > -Markus
>> > >
>> > > -----Original Message-----
>> > > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
>> > > Sent: Samstag, 9. Januar 2016 11:02
>> > > To: Markus KARG
>> > > Cc: concurrency-interest at cs.oswego.edu
>> > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
>> > Request for Comments
>> > >
>> > > ?...or it will fire instantly after the end of hibernation ?? considering your
>> > example of hourly/periodically checking mails, that would mean that the
>> > program checks your mailbox 10 times at once after 10h hibernation.
>> > > So the API would also need to know whether unfired events should queue
>> > up over time. Sounds like a rattail pulling endlessly use cases & requirements
>> > behind it.
>> > >
>> > > I for one never thought about using the JVM to schedule things that live
>> > through hibernation or similar (not knowing the original intention of the API).
>> > But I have also never built daemon-like desktop/client applications/services.
>> > >
>> > > I guess in case of JVM, one could argue that specifications only apply at
>> > runtime, and hibernation is interrupting that. Maybe it would be better to
>> > provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-
>> > hibernation, standby, signals etc. Then one could de/attach events
>> > accordingly.
>> > >
>> > >
>> > >> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu>
>> > wrote:
>> > >>
>> > >> The following requests comments on a Feature Proposal for Absolute
>> > Scheduling.
>> > >>
>> > >> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-
>> > 8146527) describes the following case:
>> > >>
>> > >> * ScheduledExecutorService.schedule() is invoked to schedule firing of an
>> > event "in one minute".
>> > >> * The laptop lid gets closed instantly after that, so hibernation will occur,
>> > hence the JVM will suspend.
>> > >> * After thirty seconds of hibernation, the laptop lid gets openen, so
>> > hibernation will cancel and the JVM resumes.
>> > >> * Despite the expected result (one minute after start of program the
>> > event does occur), the event actually is delayed by the length of the
>> > hibernation phase, and happens 90 seconds after the program was started.
>> > In the expectation of the end user, the event fired 30 seconds "too late"!
>> > >>
>> > >> This is annoying to users and rather unexpected and astonishing for
>> > programmers literally following the words of the JavaDocs. Clearly the
>> > provided deadline is a relative value in the physical sense ("one minute from
>> > now, independent of what 'now' is currently like"), but certainly what the
>> > user actually expects it to work like is an absolute value in the physical sense
>> > ("one minute from now, where 'now' is the current point on the time axis of
>> > the Universe, hence unaffected by hibernation). Whether or not the laptop
>> > was closed temporarily in the meantime plays no role to the expectation of
>> > neither the end user nor the application provider.
>> > >>
>> > >> Unfortunately there is no other API that allows the application vendor to
>> > define that the deadline it meant to be unaffected of hibernation. Clearly
>> > this is a drawback to the Java platform, as many applications need such a
>> > behaviour (like "check my mails once per hour" - if you open your laptop lid
>> > ONLY for a few minutes to see whether meanwhile new emails arrived or not
>> > [like, BTW, some laptops are able to perform these days, even with the lid
>> > closed, thanks to a BIOS timer] you won't receive any new emails ever as
>> > "JVM" time progresses only be few minutes per day then).
>> > >>
>> > >> A solution could be the addition of a special variant of
>> > ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of
>> > any hibernation, and will fire either exactly at the absoluteInstant (in case the
>> > laptop is not hibernating _currently_), or it will fire instantly after the end of
>> > hibernation, in case the laptop was hibernating at absoluteInstant.
>> > >>
>> > >> There are two possible ways to reach this: Either there is an OS-specific
>> > API that alrady provides exactly that behaviour, or the JVM needs to be
>> > informed every 'x' fractions of "discontinuous jvm time" to find out how
>> > much "continuous real world time" has advanced and whether a scheduled
>> > event was missed meanwhile (which is the workaround such applications
>> > have to perform on their own currently to workaround the problem). The
>> > first is problematic due to changes in the implementations of the APIs (e. g.
>> > Windows changed some APIs from "continuous time" to using
>> > "discontinuous time"), the second is complex in finding the optimal value of
>> > 'x' (too low means high power consumption, too high means firing too late
>> > after the deadline).
>> > >>
>> > >> Side note: To be unambiguous, the new deadline should possibly be
>> > typed as java.time.Instant, as that could never be misunderstood as
>> > "discontinous jvm time" inherently.
>> > >>
>> > >> What is your opinion on that?
>> > >>
>> > >> -Markus
>> > >> _______________________________________________
>> > >> Concurrency-interest mailing list
>> > >> Concurrency-interest at cs.oswego.edu
>> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > >
>> > >
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>  
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From davidcholmes at aapt.net.au  Sat Jan  9 23:34:24 2016
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sun, 10 Jan 2016 14:34:24 +1000
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling
	/	Request for Comments
In-Reply-To: <DE72C72B-4C70-4286-ACC5-0BF79AA49A75@gmail.com>
References: <002501d14ac0$28189150$7849b3f0$@eu>	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>	<009001d14ade$43383fd0$c9a8bf70$@eu>	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>	<00ac01d14ae5$b0628d70$1127a850$@eu>	<006001d14b01$c85b6b60$59124220$@gmail.com>	<006401d14b06$58dadb40$0a9091c0$@eu>	<00c401d14b2a$297506e0$7c5f14a0$@aapt.net.au>	<CAHzJPEqyA1C7c8VjOhv_wym3AghQ4SHvuZoR0OM2H1VVwJdEgg@mail.gmail.com>	<00cc01d14b54$180b39e0$4821ada0$@aapt.net.au>
	<DE72C72B-4C70-4286-ACC5-0BF79AA49A75@gmail.com>
Message-ID: <00d601d14b60$2f06bf50$8d143df0$@aapt.net.au>

Continuous convergence? How you write mobile apps is completely different to how you write regular applications. One programming does not fit all - by a long stretch.

Mobile app programming has more in common with old Applet programming than anything else in SE Java.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Carsten Schipke
> Sent: Sunday, January 10, 2016 1:36 PM
> To: dholmes at ieee.org
> Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> 
> Considering the continuous convergence of all platforms nowadays, that
> should not be a ?mobile programming model?.. Portability was once a major
> feature of Java. The JVM & Java have some technical debt to pay to make
> that true again for current times/platforms/technologies.
> 
> 
> > On Jan 10, 2016, at 11:07, David Holmes <davidcholmes at aapt.net.au>
> wrote:
> >
> > Yes for mobile this is part of the programming model and it needs to be a
> primary consideration. Hence the various event hooks to allow for this.
> >
> > David
> >
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Joe Bowbeer
> > Sent: Sunday, January 10, 2016 8:58 AM
> > To: David Holmes <dholmes at ieee.org>
> > Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> >
> > On mobile platforms, such as Android (or J2ME), suspension is
> commonplace, and even force-termination for resource reclamation or
> battery preservation is common.
> >
> > For both these reasons, app developers need to deal with these
> eventualities explicitly, saving and restoring persistent state, and cannot rely
> only on a scheduled executor service.
> >
> > On Sat, Jan 9, 2016 at 2:07 PM, David Holmes <davidcholmes at aapt.net.au>
> wrote:
> >> It is "by design" in the sense that:
> >>
> >> a) nothing in the Java platform APIs, or the VM implementation, were
> designed to work across machine suspension
> >> b) the underlying Window's API's do not behave in the way that is being
> described.
> >>
> >> David
> >>
> >> > -----Original Message-----
> >> > From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-
> >> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> >> > Sent: Sunday, January 10, 2016 3:51 AM
> >> > To: 'Nathan & Ila Reynolds' <nathanila at gmail.com>; 'Carsten Schipke'
> >> > <carsten.schipke at gmail.com>
> >> > Cc: concurrency-interest at cs.oswego.edu
> >> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> >> > Request for Comments
> >> >
> >> > Nathan,
> >> >
> >> > thanks for your comments.
> >> >
> >> > Please note that the actual behaviour deviates from your expectation
> on
> >> > varying with the OS type and version. For example, the one-time-trigger
> >> > "schedule(delay)" variant of JDK 8u66 on Win 8.1 (64 Bit) does *not* fire
> the
> >> > event "very soon after the delay" in some cases; in fact, it adds the
> complete
> >> > duration of the hibernation to relative-ms. Hence, when you call
> >> > "schedule(1min)", hibernate for 30s, wakeup the PC, then the event
> actually
> >> > fires 90s after you invoked that command! In fact, that behaviour is *by
> >> > design* as I learned (according to Oracle's David Holmes), and it is the
> reason
> >> > for filing this RFC.
> >> >
> >> > -Markus
> >> >
> >> >
> >> > -----Original Message-----
> >> > From: Nathan & Ila Reynolds [mailto:nathanila at gmail.com]
> >> > Sent: Samstag, 9. Januar 2016 18:19
> >> > To: 'Markus KARG'; 'Carsten Schipke'
> >> > Cc: concurrency-interest at cs.oswego.edu
> >> > Subject: RE: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> >> > Request for Comments
> >> >
> >> > Also, Windows fires an event to all applications when the system
> resumes
> >> > after hibernation.  You could use that event instead of polling.
> >> >
> >> > ScheduledExecutorService provides schedule(), scheduleAtFixedRate()
> and
> >> > scheduleWithFixedDelay().  I expect schedule() to run the command at
> or
> >> > very soon after the delay or as soon as the machine resumes if the delay
> has
> >> > elapsed.  I expect scheduleAtFixedRate() to run the command N times
> >> > rapidly if hibernation lasted N periods.  I expect
> scheduleWithFixedDelay() to
> >> > run the command one time at or very soon after the delay or as soon as
> the
> >> > machine resumes.  In this regard, the programmer has control whether
> they
> >> > need N times or 1 time after hibernation.  I only use
> scheduleAtFixedRate() if
> >> > I have something staying in sync with the passage of time.  I use
> >> > scheduleWithFixedDelay() in all other cases because if the command
> takes a
> >> > long time, I don't need it to run right away.
> >> >
> >> >
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
> >> > xecutorService.html
> >> >
> >> > -Nathan
> >> >
> >> > -----Original Message-----
> >> > From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-
> >> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> >> > Sent: Saturday, January 09, 2016 6:58 AM
> >> > To: 'Carsten Schipke' <carsten.schipke at gmail.com>
> >> > Cc: concurrency-interest at cs.oswego.edu
> >> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> >> > Request for Comments
> >> >
> >> > Carsten,
> >> >
> >> > the Windows API provides several different methods for timing. Some
> of
> >> > them are definitively able to fire at a particular point in time,
> independent of
> >> > any hibernation.
> >> >
> >> > In case a different OS won't have such a factility, there is a simple
> fallback:
> >> > Triggering events more often, checking the actual time (in pure Java), so
> we
> >> > find out whether to wait further, or whether the event is to be fired.
> This,
> >> > BTW, is the workaround applied by pure Java solutions currently, hence
> what
> >> > I'd like to get rid off by this feature request. :-)
> >> >
> >> > -Markus
> >> >
> >> >
> >> > -----Original Message-----
> >> > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> >> > Sent: Samstag, 9. Januar 2016 14:09
> >> > To: Markus KARG
> >> > Cc: concurrency-interest at cs.oswego.edu
> >> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> >> > Request for Comments
> >> >
> >> > sure, as I mentioned, I have never really had that requirement, it just
> >> > sounded to me like many programmers could have many slightly
> different
> >> > requirements on such an API. I also don?t know what the Windows API
> >> > offers in those regards / how its solved there, but if there is such a
> widely
> >> > accepted solution, then it surely would make sense as you say.
> >> >
> >> >
> >> > > On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu>
> wrote:
> >> > >
> >> > > I think it should be up to the programmer (e. g. by passing a flag or
> using
> >> > different methods) whether he wants 10 events after missing those
> while
> >> > hibernation, or whether he wants the events to be collapsed into one
> single
> >> > event alternatively. BTW, I never said that the API must support an
> absolute
> >> > variant of repeated event schedulung. You could also simply provide an
> >> > absolute variant of the "fire ONCE" method, and the mail application has
> to
> >> > reschedule inside of the event handler.
> >> > >
> >> > > Hooks are out of scope for my proposal, as they solve a different
> problem
> >> > and are working on a deeper level (the scheduler API could certainly
> make
> >> > use of such hooks). In case the Windows API for example would be able
> to
> >> > solve the problem for us (it is, BTW), why shouldn't we provide a Java
> API
> >> > wrapping that (without running into any rattail, as we simply offload)?
> >> > >
> >> > > -Markus
> >> > >
> >> > > -----Original Message-----
> >> > > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> >> > > Sent: Samstag, 9. Januar 2016 11:02
> >> > > To: Markus KARG
> >> > > Cc: concurrency-interest at cs.oswego.edu
> >> > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling
> /
> >> > Request for Comments
> >> > >
> >> > > ?...or it will fire instantly after the end of hibernation ?? considering
> your
> >> > example of hourly/periodically checking mails, that would mean that the
> >> > program checks your mailbox 10 times at once after 10h hibernation.
> >> > > So the API would also need to know whether unfired events should
> queue
> >> > up over time. Sounds like a rattail pulling endlessly use cases &
> requirements
> >> > behind it.
> >> > >
> >> > > I for one never thought about using the JVM to schedule things that
> live
> >> > through hibernation or similar (not knowing the original intention of the
> API).
> >> > But I have also never built daemon-like desktop/client
> applications/services.
> >> > >
> >> > > I guess in case of JVM, one could argue that specifications only apply
> at
> >> > runtime, and hibernation is interrupting that. Maybe it would be better
> to
> >> > provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-
> >> > hibernation, standby, signals etc. Then one could de/attach events
> >> > accordingly.
> >> > >
> >> > >
> >> > >> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu>
> >> > wrote:
> >> > >>
> >> > >> The following requests comments on a Feature Proposal for
> Absolute
> >> > Scheduling.
> >> > >>
> >> > >> OpenJDK ticket JDK-8146527
> (https://bugs.openjdk.java.net/browse/JDK-
> >> > 8146527) describes the following case:
> >> > >>
> >> > >> * ScheduledExecutorService.schedule() is invoked to schedule firing
> of an
> >> > event "in one minute".
> >> > >> * The laptop lid gets closed instantly after that, so hibernation will
> occur,
> >> > hence the JVM will suspend.
> >> > >> * After thirty seconds of hibernation, the laptop lid gets openen, so
> >> > hibernation will cancel and the JVM resumes.
> >> > >> * Despite the expected result (one minute after start of program the
> >> > event does occur), the event actually is delayed by the length of the
> >> > hibernation phase, and happens 90 seconds after the program was
> started.
> >> > In the expectation of the end user, the event fired 30 seconds "too
> late"!
> >> > >>
> >> > >> This is annoying to users and rather unexpected and astonishing for
> >> > programmers literally following the words of the JavaDocs. Clearly the
> >> > provided deadline is a relative value in the physical sense ("one minute
> from
> >> > now, independent of what 'now' is currently like"), but certainly what
> the
> >> > user actually expects it to work like is an absolute value in the physical
> sense
> >> > ("one minute from now, where 'now' is the current point on the time
> axis of
> >> > the Universe, hence unaffected by hibernation). Whether or not the
> laptop
> >> > was closed temporarily in the meantime plays no role to the expectation
> of
> >> > neither the end user nor the application provider.
> >> > >>
> >> > >> Unfortunately there is no other API that allows the application
> vendor to
> >> > define that the deadline it meant to be unaffected of hibernation.
> Clearly
> >> > this is a drawback to the Java platform, as many applications need such a
> >> > behaviour (like "check my mails once per hour" - if you open your laptop
> lid
> >> > ONLY for a few minutes to see whether meanwhile new emails arrived
> or not
> >> > [like, BTW, some laptops are able to perform these days, even with the
> lid
> >> > closed, thanks to a BIOS timer] you won't receive any new emails ever
> as
> >> > "JVM" time progresses only be few minutes per day then).
> >> > >>
> >> > >> A solution could be the addition of a special variant of
> >> > ScheduledExecutorService.schedule(absoluteInstant) which is
> unaffected of
> >> > any hibernation, and will fire either exactly at the absoluteInstant (in
> case the
> >> > laptop is not hibernating _currently_), or it will fire instantly after the
> end of
> >> > hibernation, in case the laptop was hibernating at absoluteInstant.
> >> > >>
> >> > >> There are two possible ways to reach this: Either there is an OS-
> specific
> >> > API that alrady provides exactly that behaviour, or the JVM needs to be
> >> > informed every 'x' fractions of "discontinuous jvm time" to find out how
> >> > much "continuous real world time" has advanced and whether a
> scheduled
> >> > event was missed meanwhile (which is the workaround such
> applications
> >> > have to perform on their own currently to workaround the problem).
> The
> >> > first is problematic due to changes in the implementations of the APIs
> (e. g.
> >> > Windows changed some APIs from "continuous time" to using
> >> > "discontinuous time"), the second is complex in finding the optimal
> value of
> >> > 'x' (too low means high power consumption, too high means firing too
> late
> >> > after the deadline).
> >> > >>
> >> > >> Side note: To be unambiguous, the new deadline should possibly be
> >> > typed as java.time.Instant, as that could never be misunderstood as
> >> > "discontinous jvm time" inherently.
> >> > >>
> >> > >> What is your opinion on that?
> >> > >>
> >> > >> -Markus
> >> > >> _______________________________________________
> >> > >> Concurrency-interest mailing list
> >> > >> Concurrency-interest at cs.oswego.edu
> >> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> > >
> >> > >
> >> >
> >> >
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> >
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From carsten.schipke at gmail.com  Sun Jan 10 02:33:27 2016
From: carsten.schipke at gmail.com (Carsten Schipke)
Date: Sun, 10 Jan 2016 15:33:27 +0800
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling
	/	Request for Comments
In-Reply-To: <00d601d14b60$2f06bf50$8d143df0$@aapt.net.au>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
	<009001d14ade$43383fd0$c9a8bf70$@eu>
	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
	<00ac01d14ae5$b0628d70$1127a850$@eu>
	<006001d14b01$c85b6b60$59124220$@gmail.com>
	<006401d14b06$58dadb40$0a9091c0$@eu>
	<00c401d14b2a$297506e0$7c5f14a0$@aapt.net.au>
	<CAHzJPEqyA1C7c8VjOhv_wym3AghQ4SHvuZoR0OM2H1VVwJdEgg@mail.gmail.com>
	<00cc01d14b54$180b39e0$4821ada0$@aapt.net.au>
	<DE72C72B-4C70-4286-ACC5-0BF79AA49A75@gmail.com>
	<00d601d14b60$2f06bf50$8d143df0$@aapt.net.au>
Message-ID: <E660AE9C-BB93-49EF-812B-07E29CFA43FA@gmail.com>

I am not talking about your specific programming style or whatever. I am talking about the JVM & Java language representing a portable runtime environment & framework that should provide consistent facilities to developers across all its supported underlying platforms.
And in many aspects, domains & ways, developers do very much try to exploit that portability the same methodologies across platforms - as far as they are allowed to.. I am talking about that ?allowed to?.

I am definitely not writing any code nowadays that looks like 20 year old java applets or anything 20 year old for that matter.

Why wouldn?t you want to allow Java developers to write one email client for desktop & mobile (see Windows 10 & .NET) - just for sake of prior given example?


> On Jan 10, 2016, at 12:34, David Holmes <davidcholmes at aapt.net.au> wrote:
> 
> Continuous convergence? How you write mobile apps is completely different to how you write regular applications. One programming does not fit all - by a long stretch.
> 
> Mobile app programming has more in common with old Applet programming than anything else in SE Java.
> 
> David
> 
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>> interest-bounces at cs.oswego.edu] On Behalf Of Carsten Schipke
>> Sent: Sunday, January 10, 2016 1:36 PM
>> To: dholmes at ieee.org
>> Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
>> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
>> Request for Comments
>> 
>> Considering the continuous convergence of all platforms nowadays, that
>> should not be a ?mobile programming model?.. Portability was once a major
>> feature of Java. The JVM & Java have some technical debt to pay to make
>> that true again for current times/platforms/technologies.
>> 
>> 
>>> On Jan 10, 2016, at 11:07, David Holmes <davidcholmes at aapt.net.au>
>> wrote:
>>> 
>>> Yes for mobile this is part of the programming model and it needs to be a
>> primary consideration. Hence the various event hooks to allow for this.
>>> 
>>> David
>>> 
>>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>> interest-bounces at cs.oswego.edu] On Behalf Of Joe Bowbeer
>>> Sent: Sunday, January 10, 2016 8:58 AM
>>> To: David Holmes <dholmes at ieee.org>
>>> Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
>>> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
>> Request for Comments
>>> 
>>> On mobile platforms, such as Android (or J2ME), suspension is
>> commonplace, and even force-termination for resource reclamation or
>> battery preservation is common.
>>> 
>>> For both these reasons, app developers need to deal with these
>> eventualities explicitly, saving and restoring persistent state, and cannot rely
>> only on a scheduled executor service.
>>> 
>>> On Sat, Jan 9, 2016 at 2:07 PM, David Holmes <davidcholmes at aapt.net.au>
>> wrote:
>>>> It is "by design" in the sense that:
>>>> 
>>>> a) nothing in the Java platform APIs, or the VM implementation, were
>> designed to work across machine suspension
>>>> b) the underlying Window's API's do not behave in the way that is being
>> described.
>>>> 
>>>> David
>>>> 
>>>>> -----Original Message-----
>>>>> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-
>>>>> interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
>>>>> Sent: Sunday, January 10, 2016 3:51 AM
>>>>> To: 'Nathan & Ila Reynolds' <nathanila at gmail.com>; 'Carsten Schipke'
>>>>> <carsten.schipke at gmail.com>
>>>>> Cc: concurrency-interest at cs.oswego.edu
>>>>> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
>>>>> Request for Comments
>>>>> 
>>>>> Nathan,
>>>>> 
>>>>> thanks for your comments.
>>>>> 
>>>>> Please note that the actual behaviour deviates from your expectation
>> on
>>>>> varying with the OS type and version. For example, the one-time-trigger
>>>>> "schedule(delay)" variant of JDK 8u66 on Win 8.1 (64 Bit) does *not* fire
>> the
>>>>> event "very soon after the delay" in some cases; in fact, it adds the
>> complete
>>>>> duration of the hibernation to relative-ms. Hence, when you call
>>>>> "schedule(1min)", hibernate for 30s, wakeup the PC, then the event
>> actually
>>>>> fires 90s after you invoked that command! In fact, that behaviour is *by
>>>>> design* as I learned (according to Oracle's David Holmes), and it is the
>> reason
>>>>> for filing this RFC.
>>>>> 
>>>>> -Markus
>>>>> 
>>>>> 
>>>>> -----Original Message-----
>>>>> From: Nathan & Ila Reynolds [mailto:nathanila at gmail.com]
>>>>> Sent: Samstag, 9. Januar 2016 18:19
>>>>> To: 'Markus KARG'; 'Carsten Schipke'
>>>>> Cc: concurrency-interest at cs.oswego.edu
>>>>> Subject: RE: [concurrency-interest] JDK-8146527: Absolute Scheduling /
>>>>> Request for Comments
>>>>> 
>>>>> Also, Windows fires an event to all applications when the system
>> resumes
>>>>> after hibernation.  You could use that event instead of polling.
>>>>> 
>>>>> ScheduledExecutorService provides schedule(), scheduleAtFixedRate()
>> and
>>>>> scheduleWithFixedDelay().  I expect schedule() to run the command at
>> or
>>>>> very soon after the delay or as soon as the machine resumes if the delay
>> has
>>>>> elapsed.  I expect scheduleAtFixedRate() to run the command N times
>>>>> rapidly if hibernation lasted N periods.  I expect
>> scheduleWithFixedDelay() to
>>>>> run the command one time at or very soon after the delay or as soon as
>> the
>>>>> machine resumes.  In this regard, the programmer has control whether
>> they
>>>>> need N times or 1 time after hibernation.  I only use
>> scheduleAtFixedRate() if
>>>>> I have something staying in sync with the passage of time.  I use
>>>>> scheduleWithFixedDelay() in all other cases because if the command
>> takes a
>>>>> long time, I don't need it to run right away.
>>>>> 
>>>>> 
>> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
>>>>> xecutorService.html
>>>>> 
>>>>> -Nathan
>>>>> 
>>>>> -----Original Message-----
>>>>> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-
>>>>> interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
>>>>> Sent: Saturday, January 09, 2016 6:58 AM
>>>>> To: 'Carsten Schipke' <carsten.schipke at gmail.com>
>>>>> Cc: concurrency-interest at cs.oswego.edu
>>>>> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
>>>>> Request for Comments
>>>>> 
>>>>> Carsten,
>>>>> 
>>>>> the Windows API provides several different methods for timing. Some
>> of
>>>>> them are definitively able to fire at a particular point in time,
>> independent of
>>>>> any hibernation.
>>>>> 
>>>>> In case a different OS won't have such a factility, there is a simple
>> fallback:
>>>>> Triggering events more often, checking the actual time (in pure Java), so
>> we
>>>>> find out whether to wait further, or whether the event is to be fired.
>> This,
>>>>> BTW, is the workaround applied by pure Java solutions currently, hence
>> what
>>>>> I'd like to get rid off by this feature request. :-)
>>>>> 
>>>>> -Markus
>>>>> 
>>>>> 
>>>>> -----Original Message-----
>>>>> From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
>>>>> Sent: Samstag, 9. Januar 2016 14:09
>>>>> To: Markus KARG
>>>>> Cc: concurrency-interest at cs.oswego.edu
>>>>> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
>>>>> Request for Comments
>>>>> 
>>>>> sure, as I mentioned, I have never really had that requirement, it just
>>>>> sounded to me like many programmers could have many slightly
>> different
>>>>> requirements on such an API. I also don?t know what the Windows API
>>>>> offers in those regards / how its solved there, but if there is such a
>> widely
>>>>> accepted solution, then it surely would make sense as you say.
>>>>> 
>>>>> 
>>>>>> On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu>
>> wrote:
>>>>>> 
>>>>>> I think it should be up to the programmer (e. g. by passing a flag or
>> using
>>>>> different methods) whether he wants 10 events after missing those
>> while
>>>>> hibernation, or whether he wants the events to be collapsed into one
>> single
>>>>> event alternatively. BTW, I never said that the API must support an
>> absolute
>>>>> variant of repeated event schedulung. You could also simply provide an
>>>>> absolute variant of the "fire ONCE" method, and the mail application has
>> to
>>>>> reschedule inside of the event handler.
>>>>>> 
>>>>>> Hooks are out of scope for my proposal, as they solve a different
>> problem
>>>>> and are working on a deeper level (the scheduler API could certainly
>> make
>>>>> use of such hooks). In case the Windows API for example would be able
>> to
>>>>> solve the problem for us (it is, BTW), why shouldn't we provide a Java
>> API
>>>>> wrapping that (without running into any rattail, as we simply offload)?
>>>>>> 
>>>>>> -Markus
>>>>>> 
>>>>>> -----Original Message-----
>>>>>> From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
>>>>>> Sent: Samstag, 9. Januar 2016 11:02
>>>>>> To: Markus KARG
>>>>>> Cc: concurrency-interest at cs.oswego.edu
>>>>>> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling
>> /
>>>>> Request for Comments
>>>>>> 
>>>>>> ?...or it will fire instantly after the end of hibernation ?? considering
>> your
>>>>> example of hourly/periodically checking mails, that would mean that the
>>>>> program checks your mailbox 10 times at once after 10h hibernation.
>>>>>> So the API would also need to know whether unfired events should
>> queue
>>>>> up over time. Sounds like a rattail pulling endlessly use cases &
>> requirements
>>>>> behind it.
>>>>>> 
>>>>>> I for one never thought about using the JVM to schedule things that
>> live
>>>>> through hibernation or similar (not knowing the original intention of the
>> API).
>>>>> But I have also never built daemon-like desktop/client
>> applications/services.
>>>>>> 
>>>>>> I guess in case of JVM, one could argue that specifications only apply
>> at
>>>>> runtime, and hibernation is interrupting that. Maybe it would be better
>> to
>>>>> provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-
>>>>> hibernation, standby, signals etc. Then one could de/attach events
>>>>> accordingly.
>>>>>> 
>>>>>> 
>>>>>>> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu>
>>>>> wrote:
>>>>>>> 
>>>>>>> The following requests comments on a Feature Proposal for
>> Absolute
>>>>> Scheduling.
>>>>>>> 
>>>>>>> OpenJDK ticket JDK-8146527
>> (https://bugs.openjdk.java.net/browse/JDK-
>>>>> 8146527) describes the following case:
>>>>>>> 
>>>>>>> * ScheduledExecutorService.schedule() is invoked to schedule firing
>> of an
>>>>> event "in one minute".
>>>>>>> * The laptop lid gets closed instantly after that, so hibernation will
>> occur,
>>>>> hence the JVM will suspend.
>>>>>>> * After thirty seconds of hibernation, the laptop lid gets openen, so
>>>>> hibernation will cancel and the JVM resumes.
>>>>>>> * Despite the expected result (one minute after start of program the
>>>>> event does occur), the event actually is delayed by the length of the
>>>>> hibernation phase, and happens 90 seconds after the program was
>> started.
>>>>> In the expectation of the end user, the event fired 30 seconds "too
>> late"!
>>>>>>> 
>>>>>>> This is annoying to users and rather unexpected and astonishing for
>>>>> programmers literally following the words of the JavaDocs. Clearly the
>>>>> provided deadline is a relative value in the physical sense ("one minute
>> from
>>>>> now, independent of what 'now' is currently like"), but certainly what
>> the
>>>>> user actually expects it to work like is an absolute value in the physical
>> sense
>>>>> ("one minute from now, where 'now' is the current point on the time
>> axis of
>>>>> the Universe, hence unaffected by hibernation). Whether or not the
>> laptop
>>>>> was closed temporarily in the meantime plays no role to the expectation
>> of
>>>>> neither the end user nor the application provider.
>>>>>>> 
>>>>>>> Unfortunately there is no other API that allows the application
>> vendor to
>>>>> define that the deadline it meant to be unaffected of hibernation.
>> Clearly
>>>>> this is a drawback to the Java platform, as many applications need such a
>>>>> behaviour (like "check my mails once per hour" - if you open your laptop
>> lid
>>>>> ONLY for a few minutes to see whether meanwhile new emails arrived
>> or not
>>>>> [like, BTW, some laptops are able to perform these days, even with the
>> lid
>>>>> closed, thanks to a BIOS timer] you won't receive any new emails ever
>> as
>>>>> "JVM" time progresses only be few minutes per day then).
>>>>>>> 
>>>>>>> A solution could be the addition of a special variant of
>>>>> ScheduledExecutorService.schedule(absoluteInstant) which is
>> unaffected of
>>>>> any hibernation, and will fire either exactly at the absoluteInstant (in
>> case the
>>>>> laptop is not hibernating _currently_), or it will fire instantly after the
>> end of
>>>>> hibernation, in case the laptop was hibernating at absoluteInstant.
>>>>>>> 
>>>>>>> There are two possible ways to reach this: Either there is an OS-
>> specific
>>>>> API that alrady provides exactly that behaviour, or the JVM needs to be
>>>>> informed every 'x' fractions of "discontinuous jvm time" to find out how
>>>>> much "continuous real world time" has advanced and whether a
>> scheduled
>>>>> event was missed meanwhile (which is the workaround such
>> applications
>>>>> have to perform on their own currently to workaround the problem).
>> The
>>>>> first is problematic due to changes in the implementations of the APIs
>> (e. g.
>>>>> Windows changed some APIs from "continuous time" to using
>>>>> "discontinuous time"), the second is complex in finding the optimal
>> value of
>>>>> 'x' (too low means high power consumption, too high means firing too
>> late
>>>>> after the deadline).
>>>>>>> 
>>>>>>> Side note: To be unambiguous, the new deadline should possibly be
>>>>> typed as java.time.Instant, as that could never be misunderstood as
>>>>> "discontinous jvm time" inherently.
>>>>>>> 
>>>>>>> What is your opinion on that?
>>>>>>> 
>>>>>>> -Markus
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>> 
>>>>>> 
>>>>> 
>>>>> 
>>>>> 
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> 
>>>>> 
>>>>> 
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> 
>>>> 
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From markus at headcrashing.eu  Sun Jan 10 03:06:20 2016
From: markus at headcrashing.eu (Markus KARG)
Date: Sun, 10 Jan 2016 09:06:20 +0100
Subject: [concurrency-interest] JDK-8146527: Absolute
	Scheduling	/	Request for Comments
In-Reply-To: <00d601d14b60$2f06bf50$8d143df0$@aapt.net.au>
References: <002501d14ac0$28189150$7849b3f0$@eu>	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>	<009001d14ade$43383fd0$c9a8bf70$@eu>	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>	<00ac01d14ae5$b0628d70$1127a850$@eu>	<006001d14b01$c85b6b60$59124220$@gmail.com>	<006401d14b06$58dadb40$0a9091c0$@eu>	<00c401d14b2a$297506e0$7c5f14a0$@aapt.net.au>	<CAHzJPEqyA1C7c8VjOhv_wym3AghQ4SHvuZoR0OM2H1VVwJdEgg@mail.gmail.com>	<00cc01d14b54$180b39e0$4821ada0$@aapt.net.au>	<DE72C72B-4C70-4286-ACC5-0BF79AA49A75@gmail.com>
	<00d601d14b60$2f06bf50$8d143df0$@aapt.net.au>
Message-ID: <007901d14b7d$ca63d330$5f2b7990$@eu>

As a contributor to JavaFX I need to chime in here. Actually JavaFX *does* provide a one-size-fits-all API independent of underlying platform (desktop, browser or mobile). Oracle's recent commitment to port Java SE to mobile platforms supports this. So maybe the core team should accept that the paradigm what Java SE covers shifted slightly here? As soon as Java SE will be available on Android (and prototypes exist already), Java SE programmers will expect the schedulers to work "correctly" in hibernated environments.

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David Holmes
Sent: Sonntag, 10. Januar 2016 05:34
To: 'concurrency-interest'
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

Continuous convergence? How you write mobile apps is completely different to how you write regular applications. One programming does not fit all - by a long stretch.

Mobile app programming has more in common with old Applet programming than anything else in SE Java.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Carsten Schipke
> Sent: Sunday, January 10, 2016 1:36 PM
> To: dholmes at ieee.org
> Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> 
> Considering the continuous convergence of all platforms nowadays, that
> should not be a ?mobile programming model?.. Portability was once a major
> feature of Java. The JVM & Java have some technical debt to pay to make
> that true again for current times/platforms/technologies.
> 
> 
> > On Jan 10, 2016, at 11:07, David Holmes <davidcholmes at aapt.net.au>
> wrote:
> >
> > Yes for mobile this is part of the programming model and it needs to be a
> primary consideration. Hence the various event hooks to allow for this.
> >
> > David
> >
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Joe Bowbeer
> > Sent: Sunday, January 10, 2016 8:58 AM
> > To: David Holmes <dholmes at ieee.org>
> > Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> >
> > On mobile platforms, such as Android (or J2ME), suspension is
> commonplace, and even force-termination for resource reclamation or
> battery preservation is common.
> >
> > For both these reasons, app developers need to deal with these
> eventualities explicitly, saving and restoring persistent state, and cannot rely
> only on a scheduled executor service.
> >
> > On Sat, Jan 9, 2016 at 2:07 PM, David Holmes <davidcholmes at aapt.net.au>
> wrote:
> >> It is "by design" in the sense that:
> >>
> >> a) nothing in the Java platform APIs, or the VM implementation, were
> designed to work across machine suspension
> >> b) the underlying Window's API's do not behave in the way that is being
> described.
> >>
> >> David
> >>
> >> > -----Original Message-----
> >> > From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-
> >> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> >> > Sent: Sunday, January 10, 2016 3:51 AM
> >> > To: 'Nathan & Ila Reynolds' <nathanila at gmail.com>; 'Carsten Schipke'
> >> > <carsten.schipke at gmail.com>
> >> > Cc: concurrency-interest at cs.oswego.edu
> >> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> >> > Request for Comments
> >> >
> >> > Nathan,
> >> >
> >> > thanks for your comments.
> >> >
> >> > Please note that the actual behaviour deviates from your expectation
> on
> >> > varying with the OS type and version. For example, the one-time-trigger
> >> > "schedule(delay)" variant of JDK 8u66 on Win 8.1 (64 Bit) does *not* fire
> the
> >> > event "very soon after the delay" in some cases; in fact, it adds the
> complete
> >> > duration of the hibernation to relative-ms. Hence, when you call
> >> > "schedule(1min)", hibernate for 30s, wakeup the PC, then the event
> actually
> >> > fires 90s after you invoked that command! In fact, that behaviour is *by
> >> > design* as I learned (according to Oracle's David Holmes), and it is the
> reason
> >> > for filing this RFC.
> >> >
> >> > -Markus
> >> >
> >> >
> >> > -----Original Message-----
> >> > From: Nathan & Ila Reynolds [mailto:nathanila at gmail.com]
> >> > Sent: Samstag, 9. Januar 2016 18:19
> >> > To: 'Markus KARG'; 'Carsten Schipke'
> >> > Cc: concurrency-interest at cs.oswego.edu
> >> > Subject: RE: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> >> > Request for Comments
> >> >
> >> > Also, Windows fires an event to all applications when the system
> resumes
> >> > after hibernation.  You could use that event instead of polling.
> >> >
> >> > ScheduledExecutorService provides schedule(), scheduleAtFixedRate()
> and
> >> > scheduleWithFixedDelay().  I expect schedule() to run the command at
> or
> >> > very soon after the delay or as soon as the machine resumes if the delay
> has
> >> > elapsed.  I expect scheduleAtFixedRate() to run the command N times
> >> > rapidly if hibernation lasted N periods.  I expect
> scheduleWithFixedDelay() to
> >> > run the command one time at or very soon after the delay or as soon as
> the
> >> > machine resumes.  In this regard, the programmer has control whether
> they
> >> > need N times or 1 time after hibernation.  I only use
> scheduleAtFixedRate() if
> >> > I have something staying in sync with the passage of time.  I use
> >> > scheduleWithFixedDelay() in all other cases because if the command
> takes a
> >> > long time, I don't need it to run right away.
> >> >
> >> >
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
> >> > xecutorService.html
> >> >
> >> > -Nathan
> >> >
> >> > -----Original Message-----
> >> > From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-
> >> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> >> > Sent: Saturday, January 09, 2016 6:58 AM
> >> > To: 'Carsten Schipke' <carsten.schipke at gmail.com>
> >> > Cc: concurrency-interest at cs.oswego.edu
> >> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> >> > Request for Comments
> >> >
> >> > Carsten,
> >> >
> >> > the Windows API provides several different methods for timing. Some
> of
> >> > them are definitively able to fire at a particular point in time,
> independent of
> >> > any hibernation.
> >> >
> >> > In case a different OS won't have such a factility, there is a simple
> fallback:
> >> > Triggering events more often, checking the actual time (in pure Java), so
> we
> >> > find out whether to wait further, or whether the event is to be fired.
> This,
> >> > BTW, is the workaround applied by pure Java solutions currently, hence
> what
> >> > I'd like to get rid off by this feature request. :-)
> >> >
> >> > -Markus
> >> >
> >> >
> >> > -----Original Message-----
> >> > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> >> > Sent: Samstag, 9. Januar 2016 14:09
> >> > To: Markus KARG
> >> > Cc: concurrency-interest at cs.oswego.edu
> >> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> >> > Request for Comments
> >> >
> >> > sure, as I mentioned, I have never really had that requirement, it just
> >> > sounded to me like many programmers could have many slightly
> different
> >> > requirements on such an API. I also don?t know what the Windows API
> >> > offers in those regards / how its solved there, but if there is such a
> widely
> >> > accepted solution, then it surely would make sense as you say.
> >> >
> >> >
> >> > > On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu>
> wrote:
> >> > >
> >> > > I think it should be up to the programmer (e. g. by passing a flag or
> using
> >> > different methods) whether he wants 10 events after missing those
> while
> >> > hibernation, or whether he wants the events to be collapsed into one
> single
> >> > event alternatively. BTW, I never said that the API must support an
> absolute
> >> > variant of repeated event schedulung. You could also simply provide an
> >> > absolute variant of the "fire ONCE" method, and the mail application has
> to
> >> > reschedule inside of the event handler.
> >> > >
> >> > > Hooks are out of scope for my proposal, as they solve a different
> problem
> >> > and are working on a deeper level (the scheduler API could certainly
> make
> >> > use of such hooks). In case the Windows API for example would be able
> to
> >> > solve the problem for us (it is, BTW), why shouldn't we provide a Java
> API
> >> > wrapping that (without running into any rattail, as we simply offload)?
> >> > >
> >> > > -Markus
> >> > >
> >> > > -----Original Message-----
> >> > > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> >> > > Sent: Samstag, 9. Januar 2016 11:02
> >> > > To: Markus KARG
> >> > > Cc: concurrency-interest at cs.oswego.edu
> >> > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling
> /
> >> > Request for Comments
> >> > >
> >> > > ?...or it will fire instantly after the end of hibernation ?? considering
> your
> >> > example of hourly/periodically checking mails, that would mean that the
> >> > program checks your mailbox 10 times at once after 10h hibernation.
> >> > > So the API would also need to know whether unfired events should
> queue
> >> > up over time. Sounds like a rattail pulling endlessly use cases &
> requirements
> >> > behind it.
> >> > >
> >> > > I for one never thought about using the JVM to schedule things that
> live
> >> > through hibernation or similar (not knowing the original intention of the
> API).
> >> > But I have also never built daemon-like desktop/client
> applications/services.
> >> > >
> >> > > I guess in case of JVM, one could argue that specifications only apply
> at
> >> > runtime, and hibernation is interrupting that. Maybe it would be better
> to
> >> > provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-
> >> > hibernation, standby, signals etc. Then one could de/attach events
> >> > accordingly.
> >> > >
> >> > >
> >> > >> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu>
> >> > wrote:
> >> > >>
> >> > >> The following requests comments on a Feature Proposal for
> Absolute
> >> > Scheduling.
> >> > >>
> >> > >> OpenJDK ticket JDK-8146527
> (https://bugs.openjdk.java.net/browse/JDK-
> >> > 8146527) describes the following case:
> >> > >>
> >> > >> * ScheduledExecutorService.schedule() is invoked to schedule firing
> of an
> >> > event "in one minute".
> >> > >> * The laptop lid gets closed instantly after that, so hibernation will
> occur,
> >> > hence the JVM will suspend.
> >> > >> * After thirty seconds of hibernation, the laptop lid gets openen, so
> >> > hibernation will cancel and the JVM resumes.
> >> > >> * Despite the expected result (one minute after start of program the
> >> > event does occur), the event actually is delayed by the length of the
> >> > hibernation phase, and happens 90 seconds after the program was
> started.
> >> > In the expectation of the end user, the event fired 30 seconds "too
> late"!
> >> > >>
> >> > >> This is annoying to users and rather unexpected and astonishing for
> >> > programmers literally following the words of the JavaDocs. Clearly the
> >> > provided deadline is a relative value in the physical sense ("one minute
> from
> >> > now, independent of what 'now' is currently like"), but certainly what
> the
> >> > user actually expects it to work like is an absolute value in the physical
> sense
> >> > ("one minute from now, where 'now' is the current point on the time
> axis of
> >> > the Universe, hence unaffected by hibernation). Whether or not the
> laptop
> >> > was closed temporarily in the meantime plays no role to the expectation
> of
> >> > neither the end user nor the application provider.
> >> > >>
> >> > >> Unfortunately there is no other API that allows the application
> vendor to
> >> > define that the deadline it meant to be unaffected of hibernation.
> Clearly
> >> > this is a drawback to the Java platform, as many applications need such a
> >> > behaviour (like "check my mails once per hour" - if you open your laptop
> lid
> >> > ONLY for a few minutes to see whether meanwhile new emails arrived
> or not
> >> > [like, BTW, some laptops are able to perform these days, even with the
> lid
> >> > closed, thanks to a BIOS timer] you won't receive any new emails ever
> as
> >> > "JVM" time progresses only be few minutes per day then).
> >> > >>
> >> > >> A solution could be the addition of a special variant of
> >> > ScheduledExecutorService.schedule(absoluteInstant) which is
> unaffected of
> >> > any hibernation, and will fire either exactly at the absoluteInstant (in
> case the
> >> > laptop is not hibernating _currently_), or it will fire instantly after the
> end of
> >> > hibernation, in case the laptop was hibernating at absoluteInstant.
> >> > >>
> >> > >> There are two possible ways to reach this: Either there is an OS-
> specific
> >> > API that alrady provides exactly that behaviour, or the JVM needs to be
> >> > informed every 'x' fractions of "discontinuous jvm time" to find out how
> >> > much "continuous real world time" has advanced and whether a
> scheduled
> >> > event was missed meanwhile (which is the workaround such
> applications
> >> > have to perform on their own currently to workaround the problem).
> The
> >> > first is problematic due to changes in the implementations of the APIs
> (e. g.
> >> > Windows changed some APIs from "continuous time" to using
> >> > "discontinuous time"), the second is complex in finding the optimal
> value of
> >> > 'x' (too low means high power consumption, too high means firing too
> late
> >> > after the deadline).
> >> > >>
> >> > >> Side note: To be unambiguous, the new deadline should possibly be
> >> > typed as java.time.Instant, as that could never be misunderstood as
> >> > "discontinous jvm time" inherently.
> >> > >>
> >> > >> What is your opinion on that?
> >> > >>
> >> > >> -Markus
> >> > >> _______________________________________________
> >> > >> Concurrency-interest mailing list
> >> > >> Concurrency-interest at cs.oswego.edu
> >> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> > >
> >> > >
> >> >
> >> >
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >> >
> >> >
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From aph at redhat.com  Sun Jan 10 14:11:22 2016
From: aph at redhat.com (Andrew Haley)
Date: Sun, 10 Jan 2016 19:11:22 +0000
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
 Request for Comments
In-Reply-To: <00cc01d14b54$180b39e0$4821ada0$@aapt.net.au>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
	<009001d14ade$43383fd0$c9a8bf70$@eu>
	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
	<00ac01d14ae5$b0628d70$1127a850$@eu>
	<006001d14b01$c85b6b60$59124220$@gmail.com>
	<006401d14b06$58dadb40$0a9091c0$@eu>
	<00c401d14b2a$297506e0$7c5f14a0$@aapt.net.au>
	<CAHzJPEqyA1C7c8VjOhv_wym3AghQ4SHvuZoR0OM2H1VVwJdEgg@mail.gmail.com>
	<00cc01d14b54$180b39e0$4821ada0$@aapt.net.au>
Message-ID: <5692ACDA.70108@redhat.com>

On 10/01/16 03:07, David Holmes wrote:

> Yes for mobile this is part of the programming model and it needs to
> be a primary consideration. Hence the various event hooks to allow
> for this.

For servers it is ever more important because of virtualization, where
entire VMs will be suspended, migrated across the cloud, etc.  I think
that you probably do not want a lot of tasks all firing up when a VM
is restarted.

Andrew.


From davidcholmes at aapt.net.au  Sun Jan 10 17:43:22 2016
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 11 Jan 2016 08:43:22 +1000
Subject: [concurrency-interest] JDK-8146527: Absolute
	Scheduling	/	Request for Comments
In-Reply-To: <EE8F7E94-8BEC-47CF-9D76-049944F08B6B@gmail.com>
References: <002501d14ac0$28189150$7849b3f0$@eu>	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>	<009001d14ade$43383fd0$c9a8bf70$@eu>	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>	<00ac01d14ae5$b0628d70$1127a850$@eu>	<006001d14b01$c85b6b60$59124220$@gmail.com>
	<EE8F7E94-8BEC-47CF-9D76-049944F08B6B@gmail.com>
Message-ID: <00da01d14bf8$4f9c9710$eed5c530$@aapt.net.au>

I think Alex hits the nail on the head here. For these API's to work "correctly" in these difference contexts we have to make "time" an explicit part of the API and in particular we do need a notion of different Clocks that represent different kinds of "time". The Real-time Specification for Java did try to go down this path but ran into serious practical limitations - if the operating system doesn't support different kinds of clocks and the API's they expose don't allow control of the clocks involved, then implementing such abstractions in an efficient and practical way is exceedingly difficult, to say the least.

David
-------

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Alex Otenko
> Sent: Sunday, January 10, 2016 12:04 PM
> To: Nathan & Ila Reynolds <nathanila at gmail.com>
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> 
> I would expect these to be case-specific.
> 
> The flow of time is different in different frames of reference. Mailer wants it
> to be tied to the frame of reference coinciding with mail server (which is in
> the same frame as Greenwich), Sudoku game wants it tied to the frame of
> reference coinciding with Sudoku process space - it doesn?t want to count
> time towards the score whilst the game is not in the foreground.
> 
> It would be nice to have a replaceable clock, or the source of time for
> individual condvars.
> 
> Alex
> 
> > On 9 Jan 2016, at 17:18, Nathan & Ila Reynolds <nathanila at gmail.com>
> wrote:
> >
> > Also, Windows fires an event to all applications when the system resumes
> after hibernation.  You could use that event instead of polling.
> >
> > ScheduledExecutorService provides schedule(), scheduleAtFixedRate() and
> scheduleWithFixedDelay().  I expect schedule() to run the command at or
> very soon after the delay or as soon as the machine resumes if the delay has
> elapsed.  I expect scheduleAtFixedRate() to run the command N times
> rapidly if hibernation lasted N periods.  I expect scheduleWithFixedDelay() to
> run the command one time at or very soon after the delay or as soon as the
> machine resumes.  In this regard, the programmer has control whether they
> need N times or 1 time after hibernation.  I only use scheduleAtFixedRate() if
> I have something staying in sync with the passage of time.  I use
> scheduleWithFixedDelay() in all other cases because if the command takes a
> long time, I don't need it to run right away.
> >
> >
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
> xecutorService.html
> >
> > -Nathan
> >
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> > Sent: Saturday, January 09, 2016 6:58 AM
> > To: 'Carsten Schipke' <carsten.schipke at gmail.com>
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> >
> > Carsten,
> >
> > the Windows API provides several different methods for timing. Some of
> them are definitively able to fire at a particular point in time, independent of
> any hibernation.
> >
> > In case a different OS won't have such a factility, there is a simple fallback:
> Triggering events more often, checking the actual time (in pure Java), so we
> find out whether to wait further, or whether the event is to be fired. This,
> BTW, is the workaround applied by pure Java solutions currently, hence what
> I'd like to get rid off by this feature request. :-)
> >
> > -Markus
> >
> >
> > -----Original Message-----
> > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > Sent: Samstag, 9. Januar 2016 14:09
> > To: Markus KARG
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> >
> > sure, as I mentioned, I have never really had that requirement, it just
> sounded to me like many programmers could have many slightly different
> requirements on such an API. I also don?t know what the Windows API
> offers in those regards / how its solved there, but if there is such a widely
> accepted solution, then it surely would make sense as you say.
> >
> >
> >> On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu>
> wrote:
> >>
> >> I think it should be up to the programmer (e. g. by passing a flag or using
> different methods) whether he wants 10 events after missing those while
> hibernation, or whether he wants the events to be collapsed into one single
> event alternatively. BTW, I never said that the API must support an absolute
> variant of repeated event schedulung. You could also simply provide an
> absolute variant of the "fire ONCE" method, and the mail application has to
> reschedule inside of the event handler.
> >>
> >> Hooks are out of scope for my proposal, as they solve a different problem
> and are working on a deeper level (the scheduler API could certainly make
> use of such hooks). In case the Windows API for example would be able to
> solve the problem for us (it is, BTW), why shouldn't we provide a Java API
> wrapping that (without running into any rattail, as we simply offload)?
> >>
> >> -Markus
> >>
> >> -----Original Message-----
> >> From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> >> Sent: Samstag, 9. Januar 2016 11:02
> >> To: Markus KARG
> >> Cc: concurrency-interest at cs.oswego.edu
> >> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> >>
> >> ?...or it will fire instantly after the end of hibernation ?? considering your
> example of hourly/periodically checking mails, that would mean that the
> program checks your mailbox 10 times at once after 10h hibernation.
> >> So the API would also need to know whether unfired events should
> queue up over time. Sounds like a rattail pulling endlessly use cases &
> requirements behind it.
> >>
> >> I for one never thought about using the JVM to schedule things that live
> through hibernation or similar (not knowing the original intention of the API).
> But I have also never built daemon-like desktop/client applications/services.
> >>
> >> I guess in case of JVM, one could argue that specifications only apply at
> runtime, and hibernation is interrupting that. Maybe it would be better to
> provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-
> hibernation, standby, signals etc. Then one could de/attach events
> accordingly.
> >>
> >>
> >>> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu>
> wrote:
> >>>
> >>> The following requests comments on a Feature Proposal for Absolute
> Scheduling.
> >>>
> >>> OpenJDK ticket JDK-8146527
> (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the
> following case:
> >>>
> >>> * ScheduledExecutorService.schedule() is invoked to schedule firing of
> an event "in one minute".
> >>> * The laptop lid gets closed instantly after that, so hibernation will occur,
> hence the JVM will suspend.
> >>> * After thirty seconds of hibernation, the laptop lid gets openen, so
> hibernation will cancel and the JVM resumes.
> >>> * Despite the expected result (one minute after start of program the
> event does occur), the event actually is delayed by the length of the
> hibernation phase, and happens 90 seconds after the program was started.
> In the expectation of the end user, the event fired 30 seconds "too late"!
> >>>
> >>> This is annoying to users and rather unexpected and astonishing for
> programmers literally following the words of the JavaDocs. Clearly the
> provided deadline is a relative value in the physical sense ("one minute from
> now, independent of what 'now' is currently like"), but certainly what the
> user actually expects it to work like is an absolute value in the physical sense
> ("one minute from now, where 'now' is the current point on the time axis of
> the Universe, hence unaffected by hibernation). Whether or not the laptop
> was closed temporarily in the meantime plays no role to the expectation of
> neither the end user nor the application provider.
> >>>
> >>> Unfortunately there is no other API that allows the application vendor to
> define that the deadline it meant to be unaffected of hibernation. Clearly
> this is a drawback to the Java platform, as many applications need such a
> behaviour (like "check my mails once per hour" - if you open your laptop lid
> ONLY for a few minutes to see whether meanwhile new emails arrived or not
> [like, BTW, some laptops are able to perform these days, even with the lid
> closed, thanks to a BIOS timer] you won't receive any new emails ever as
> "JVM" time progresses only be few minutes per day then).
> >>>
> >>> A solution could be the addition of a special variant of
> ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of
> any hibernation, and will fire either exactly at the absoluteInstant (in case the
> laptop is not hibernating _currently_), or it will fire instantly after the end of
> hibernation, in case the laptop was hibernating at absoluteInstant.
> >>>
> >>> There are two possible ways to reach this: Either there is an OS-specific
> API that alrady provides exactly that behaviour, or the JVM needs to be
> informed every 'x' fractions of "discontinuous jvm time" to find out how
> much "continuous real world time" has advanced and whether a scheduled
> event was missed meanwhile (which is the workaround such applications
> have to perform on their own currently to workaround the problem). The
> first is problematic due to changes in the implementations of the APIs (e. g.
> Windows changed some APIs from "continuous time" to using
> "discontinuous time"), the second is complex in finding the optimal value of
> 'x' (too low means high power consumption, too high means firing too late
> after the deadline).
> >>>
> >>> Side note: To be unambiguous, the new deadline should possibly be
> typed as java.time.Instant, as that could never be misunderstood as
> "discontinous jvm time" inherently.
> >>>
> >>> What is your opinion on that?
> >>>
> >>> -Markus
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >>
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From davidcholmes at aapt.net.au  Sun Jan 10 17:54:03 2016
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 11 Jan 2016 08:54:03 +1000
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling/Request
	for Comments
Message-ID: <00db01d14bf9$cdb22880$69167980$@aapt.net.au>

I suggest you start a discussion on mobile-dev at openjdk.java.net if you expect to see certain behavior here. What you will get will depend on how the OS API's behave - and whether the JVM suspends or continues to run as a background app. As already noted the Windows API does not work as described. I don't know how iOS or Android behave here.

There is a big difference between trying to define a "one size fits all" API, versus defining a common programming model. The programming model for mobile apps is very different to regular server based applications. As I said the way a mobile app has to handle backgrounding and sudden termination is more akin to the old applet lifecycle: init, start, stop, destroy - where you could loop from stop back to start indefinitely as you navigated away from then back to the page hosting the applet. The need to handle this was an explicit part of the applet programming model, and is also an explicit part of the native programming model for mobile apps.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> Sent: Sunday, January 10, 2016 6:06 PM
> To: dholmes at ieee.org; 'concurrency-interest' <concurrency-
> interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> 
> As a contributor to JavaFX I need to chime in here. Actually JavaFX *does*
> provide a one-size-fits-all API independent of underlying platform (desktop,
> browser or mobile). Oracle's recent commitment to port Java SE to mobile
> platforms supports this. So maybe the core team should accept that the
> paradigm what Java SE covers shifted slightly here? As soon as Java SE will be
> available on Android (and prototypes exist already), Java SE programmers will
> expect the schedulers to work "correctly" in hibernated environments.
> 
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of David Holmes
> Sent: Sonntag, 10. Januar 2016 05:34
> To: 'concurrency-interest'
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> 
> Continuous convergence? How you write mobile apps is completely different
> to how you write regular applications. One programming does not fit all - by a
> long stretch.
> 
> Mobile app programming has more in common with old Applet programming
> than anything else in SE Java.
> 
> David
> 
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of Carsten Schipke
> > Sent: Sunday, January 10, 2016 1:36 PM
> > To: dholmes at ieee.org
> > Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> >
> > Considering the continuous convergence of all platforms nowadays, that
> > should not be a ?mobile programming model?.. Portability was once a
> major
> > feature of Java. The JVM & Java have some technical debt to pay to make
> > that true again for current times/platforms/technologies.
> >
> >
> > > On Jan 10, 2016, at 11:07, David Holmes <davidcholmes at aapt.net.au>
> > wrote:
> > >
> > > Yes for mobile this is part of the programming model and it needs to be a
> > primary consideration. Hence the various event hooks to allow for this.
> > >
> > > David
> > >
> > > From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of Joe Bowbeer
> > > Sent: Sunday, January 10, 2016 8:58 AM
> > > To: David Holmes <dholmes at ieee.org>
> > > Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
> > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> > >
> > > On mobile platforms, such as Android (or J2ME), suspension is
> > commonplace, and even force-termination for resource reclamation or
> > battery preservation is common.
> > >
> > > For both these reasons, app developers need to deal with these
> > eventualities explicitly, saving and restoring persistent state, and cannot
> rely
> > only on a scheduled executor service.
> > >
> > > On Sat, Jan 9, 2016 at 2:07 PM, David Holmes
> <davidcholmes at aapt.net.au>
> > wrote:
> > >> It is "by design" in the sense that:
> > >>
> > >> a) nothing in the Java platform APIs, or the VM implementation, were
> > designed to work across machine suspension
> > >> b) the underlying Window's API's do not behave in the way that is being
> > described.
> > >>
> > >> David
> > >>
> > >> > -----Original Message-----
> > >> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-
> > >> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> > >> > Sent: Sunday, January 10, 2016 3:51 AM
> > >> > To: 'Nathan & Ila Reynolds' <nathanila at gmail.com>; 'Carsten Schipke'
> > >> > <carsten.schipke at gmail.com>
> > >> > Cc: concurrency-interest at cs.oswego.edu
> > >> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling
> /
> > >> > Request for Comments
> > >> >
> > >> > Nathan,
> > >> >
> > >> > thanks for your comments.
> > >> >
> > >> > Please note that the actual behaviour deviates from your expectation
> > on
> > >> > varying with the OS type and version. For example, the one-time-
> trigger
> > >> > "schedule(delay)" variant of JDK 8u66 on Win 8.1 (64 Bit) does *not*
> fire
> > the
> > >> > event "very soon after the delay" in some cases; in fact, it adds the
> > complete
> > >> > duration of the hibernation to relative-ms. Hence, when you call
> > >> > "schedule(1min)", hibernate for 30s, wakeup the PC, then the event
> > actually
> > >> > fires 90s after you invoked that command! In fact, that behaviour is
> *by
> > >> > design* as I learned (according to Oracle's David Holmes), and it is the
> > reason
> > >> > for filing this RFC.
> > >> >
> > >> > -Markus
> > >> >
> > >> >
> > >> > -----Original Message-----
> > >> > From: Nathan & Ila Reynolds [mailto:nathanila at gmail.com]
> > >> > Sent: Samstag, 9. Januar 2016 18:19
> > >> > To: 'Markus KARG'; 'Carsten Schipke'
> > >> > Cc: concurrency-interest at cs.oswego.edu
> > >> > Subject: RE: [concurrency-interest] JDK-8146527: Absolute Scheduling
> /
> > >> > Request for Comments
> > >> >
> > >> > Also, Windows fires an event to all applications when the system
> > resumes
> > >> > after hibernation.  You could use that event instead of polling.
> > >> >
> > >> > ScheduledExecutorService provides schedule(),
> scheduleAtFixedRate()
> > and
> > >> > scheduleWithFixedDelay().  I expect schedule() to run the command
> at
> > or
> > >> > very soon after the delay or as soon as the machine resumes if the
> delay
> > has
> > >> > elapsed.  I expect scheduleAtFixedRate() to run the command N times
> > >> > rapidly if hibernation lasted N periods.  I expect
> > scheduleWithFixedDelay() to
> > >> > run the command one time at or very soon after the delay or as soon
> as
> > the
> > >> > machine resumes.  In this regard, the programmer has control
> whether
> > they
> > >> > need N times or 1 time after hibernation.  I only use
> > scheduleAtFixedRate() if
> > >> > I have something staying in sync with the passage of time.  I use
> > >> > scheduleWithFixedDelay() in all other cases because if the command
> > takes a
> > >> > long time, I don't need it to run right away.
> > >> >
> > >> >
> >
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
> > >> > xecutorService.html
> > >> >
> > >> > -Nathan
> > >> >
> > >> > -----Original Message-----
> > >> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-
> > >> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> > >> > Sent: Saturday, January 09, 2016 6:58 AM
> > >> > To: 'Carsten Schipke' <carsten.schipke at gmail.com>
> > >> > Cc: concurrency-interest at cs.oswego.edu
> > >> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling
> /
> > >> > Request for Comments
> > >> >
> > >> > Carsten,
> > >> >
> > >> > the Windows API provides several different methods for timing. Some
> > of
> > >> > them are definitively able to fire at a particular point in time,
> > independent of
> > >> > any hibernation.
> > >> >
> > >> > In case a different OS won't have such a factility, there is a simple
> > fallback:
> > >> > Triggering events more often, checking the actual time (in pure Java),
> so
> > we
> > >> > find out whether to wait further, or whether the event is to be fired.
> > This,
> > >> > BTW, is the workaround applied by pure Java solutions currently,
> hence
> > what
> > >> > I'd like to get rid off by this feature request. :-)
> > >> >
> > >> > -Markus
> > >> >
> > >> >
> > >> > -----Original Message-----
> > >> > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > >> > Sent: Samstag, 9. Januar 2016 14:09
> > >> > To: Markus KARG
> > >> > Cc: concurrency-interest at cs.oswego.edu
> > >> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling
> /
> > >> > Request for Comments
> > >> >
> > >> > sure, as I mentioned, I have never really had that requirement, it just
> > >> > sounded to me like many programmers could have many slightly
> > different
> > >> > requirements on such an API. I also don?t know what the Windows
> API
> > >> > offers in those regards / how its solved there, but if there is such a
> > widely
> > >> > accepted solution, then it surely would make sense as you say.
> > >> >
> > >> >
> > >> > > On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu>
> > wrote:
> > >> > >
> > >> > > I think it should be up to the programmer (e. g. by passing a flag or
> > using
> > >> > different methods) whether he wants 10 events after missing those
> > while
> > >> > hibernation, or whether he wants the events to be collapsed into one
> > single
> > >> > event alternatively. BTW, I never said that the API must support an
> > absolute
> > >> > variant of repeated event schedulung. You could also simply provide
> an
> > >> > absolute variant of the "fire ONCE" method, and the mail application
> has
> > to
> > >> > reschedule inside of the event handler.
> > >> > >
> > >> > > Hooks are out of scope for my proposal, as they solve a different
> > problem
> > >> > and are working on a deeper level (the scheduler API could certainly
> > make
> > >> > use of such hooks). In case the Windows API for example would be
> able
> > to
> > >> > solve the problem for us (it is, BTW), why shouldn't we provide a Java
> > API
> > >> > wrapping that (without running into any rattail, as we simply offload)?
> > >> > >
> > >> > > -Markus
> > >> > >
> > >> > > -----Original Message-----
> > >> > > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > >> > > Sent: Samstag, 9. Januar 2016 11:02
> > >> > > To: Markus KARG
> > >> > > Cc: concurrency-interest at cs.oswego.edu
> > >> > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute
> Scheduling
> > /
> > >> > Request for Comments
> > >> > >
> > >> > > ?...or it will fire instantly after the end of hibernation ?? considering
> > your
> > >> > example of hourly/periodically checking mails, that would mean that
> the
> > >> > program checks your mailbox 10 times at once after 10h hibernation.
> > >> > > So the API would also need to know whether unfired events should
> > queue
> > >> > up over time. Sounds like a rattail pulling endlessly use cases &
> > requirements
> > >> > behind it.
> > >> > >
> > >> > > I for one never thought about using the JVM to schedule things that
> > live
> > >> > through hibernation or similar (not knowing the original intention of
> the
> > API).
> > >> > But I have also never built daemon-like desktop/client
> > applications/services.
> > >> > >
> > >> > > I guess in case of JVM, one could argue that specifications only apply
> > at
> > >> > runtime, and hibernation is interrupting that. Maybe it would be
> better
> > to
> > >> > provide hooks e.g. in the Runtime class to allow callbacks on pre-
> /post-
> > >> > hibernation, standby, signals etc. Then one could de/attach events
> > >> > accordingly.
> > >> > >
> > >> > >
> > >> > >> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu>
> > >> > wrote:
> > >> > >>
> > >> > >> The following requests comments on a Feature Proposal for
> > Absolute
> > >> > Scheduling.
> > >> > >>
> > >> > >> OpenJDK ticket JDK-8146527
> > (https://bugs.openjdk.java.net/browse/JDK-
> > >> > 8146527) describes the following case:
> > >> > >>
> > >> > >> * ScheduledExecutorService.schedule() is invoked to schedule
> firing
> > of an
> > >> > event "in one minute".
> > >> > >> * The laptop lid gets closed instantly after that, so hibernation will
> > occur,
> > >> > hence the JVM will suspend.
> > >> > >> * After thirty seconds of hibernation, the laptop lid gets openen, so
> > >> > hibernation will cancel and the JVM resumes.
> > >> > >> * Despite the expected result (one minute after start of program
> the
> > >> > event does occur), the event actually is delayed by the length of the
> > >> > hibernation phase, and happens 90 seconds after the program was
> > started.
> > >> > In the expectation of the end user, the event fired 30 seconds "too
> > late"!
> > >> > >>
> > >> > >> This is annoying to users and rather unexpected and astonishing for
> > >> > programmers literally following the words of the JavaDocs. Clearly the
> > >> > provided deadline is a relative value in the physical sense ("one
> minute
> > from
> > >> > now, independent of what 'now' is currently like"), but certainly what
> > the
> > >> > user actually expects it to work like is an absolute value in the physical
> > sense
> > >> > ("one minute from now, where 'now' is the current point on the time
> > axis of
> > >> > the Universe, hence unaffected by hibernation). Whether or not the
> > laptop
> > >> > was closed temporarily in the meantime plays no role to the
> expectation
> > of
> > >> > neither the end user nor the application provider.
> > >> > >>
> > >> > >> Unfortunately there is no other API that allows the application
> > vendor to
> > >> > define that the deadline it meant to be unaffected of hibernation.
> > Clearly
> > >> > this is a drawback to the Java platform, as many applications need such
> a
> > >> > behaviour (like "check my mails once per hour" - if you open your
> laptop
> > lid
> > >> > ONLY for a few minutes to see whether meanwhile new emails
> arrived
> > or not
> > >> > [like, BTW, some laptops are able to perform these days, even with
> the
> > lid
> > >> > closed, thanks to a BIOS timer] you won't receive any new emails ever
> > as
> > >> > "JVM" time progresses only be few minutes per day then).
> > >> > >>
> > >> > >> A solution could be the addition of a special variant of
> > >> > ScheduledExecutorService.schedule(absoluteInstant) which is
> > unaffected of
> > >> > any hibernation, and will fire either exactly at the absoluteInstant (in
> > case the
> > >> > laptop is not hibernating _currently_), or it will fire instantly after the
> > end of
> > >> > hibernation, in case the laptop was hibernating at absoluteInstant.
> > >> > >>
> > >> > >> There are two possible ways to reach this: Either there is an OS-
> > specific
> > >> > API that alrady provides exactly that behaviour, or the JVM needs to
> be
> > >> > informed every 'x' fractions of "discontinuous jvm time" to find out
> how
> > >> > much "continuous real world time" has advanced and whether a
> > scheduled
> > >> > event was missed meanwhile (which is the workaround such
> > applications
> > >> > have to perform on their own currently to workaround the problem).
> > The
> > >> > first is problematic due to changes in the implementations of the APIs
> > (e. g.
> > >> > Windows changed some APIs from "continuous time" to using
> > >> > "discontinuous time"), the second is complex in finding the optimal
> > value of
> > >> > 'x' (too low means high power consumption, too high means firing too
> > late
> > >> > after the deadline).
> > >> > >>
> > >> > >> Side note: To be unambiguous, the new deadline should possibly
> be
> > >> > typed as java.time.Instant, as that could never be misunderstood as
> > >> > "discontinous jvm time" inherently.
> > >> > >>
> > >> > >> What is your opinion on that?
> > >> > >>
> > >> > >> -Markus
> > >> > >> _______________________________________________
> > >> > >> Concurrency-interest mailing list
> > >> > >> Concurrency-interest at cs.oswego.edu
> > >> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> > >
> > >> > >
> > >> >
> > >> >
> > >> >
> > >> > _______________________________________________
> > >> > Concurrency-interest mailing list
> > >> > Concurrency-interest at cs.oswego.edu
> > >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >> >
> > >> >
> > >> >
> > >> > _______________________________________________
> > >> > Concurrency-interest mailing list
> > >> > Concurrency-interest at cs.oswego.edu
> > >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >>
> > >>
> > >> _______________________________________________
> > >> Concurrency-interest mailing list
> > >> Concurrency-interest at cs.oswego.edu
> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From joe.bowbeer at gmail.com  Sun Jan 10 19:09:14 2016
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sun, 10 Jan 2016 16:09:14 -0800
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling/Request
 for Comments
In-Reply-To: <00db01d14bf9$cdb22880$69167980$@aapt.net.au>
References: <00db01d14bf9$cdb22880$69167980$@aapt.net.au>
Message-ID: <CAHzJPEqpRfVE7m3xiGrvJCsHfPVdf5EbmpMV92Ay7Z7nxzUoOA@mail.gmail.com>

A possible intermediate solution to consider is more support for pause-able
executor services.

I've written several of these over the years for different situations and
different platforms, but I think a common API is possible. Generally, on
pause I want to be able to pause execution of queued tasks and do something
with tasks that are already running (let them run? each task can pause
itself?), Then, on resume I want to adjust the scheduled execution times of
queued tasks before resuming execution. I want to be able to perform the
rescheduling programmatically rather than automatically, though some
reasonable default behavior might be possible.

Would support for pause/resume help in this hibernate use case described?

On Sun, Jan 10, 2016 at 2:54 PM, David Holmes <davidcholmes at aapt.net.au>
wrote:

> I suggest you start a discussion on mobile-dev at openjdk.java.net if you
> expect to see certain behavior here. What you will get will depend on how
> the OS API's behave - and whether the JVM suspends or continues to run as a
> background app. As already noted the Windows API does not work as
> described. I don't know how iOS or Android behave here.
>
> There is a big difference between trying to define a "one size fits all"
> API, versus defining a common programming model. The programming model for
> mobile apps is very different to regular server based applications. As I
> said the way a mobile app has to handle backgrounding and sudden
> termination is more akin to the old applet lifecycle: init, start, stop,
> destroy - where you could loop from stop back to start indefinitely as you
> navigated away from then back to the page hosting the applet. The need to
> handle this was an explicit part of the applet programming model, and is
> also an explicit part of the native programming model for mobile apps.
>
> David
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> > Sent: Sunday, January 10, 2016 6:06 PM
> > To: dholmes at ieee.org; 'concurrency-interest' <concurrency-
> > interest at cs.oswego.edu>
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> >
> > As a contributor to JavaFX I need to chime in here. Actually JavaFX
> *does*
> > provide a one-size-fits-all API independent of underlying platform
> (desktop,
> > browser or mobile). Oracle's recent commitment to port Java SE to mobile
> > platforms supports this. So maybe the core team should accept that the
> > paradigm what Java SE covers shifted slightly here? As soon as Java SE
> will be
> > available on Android (and prototypes exist already), Java SE programmers
> will
> > expect the schedulers to work "correctly" in hibernated environments.
> >
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of David Holmes
> > Sent: Sonntag, 10. Januar 2016 05:34
> > To: 'concurrency-interest'
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> >
> > Continuous convergence? How you write mobile apps is completely different
> > to how you write regular applications. One programming does not fit all
> - by a
> > long stretch.
> >
> > Mobile app programming has more in common with old Applet programming
> > than anything else in SE Java.
> >
> > David
> >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> > > interest-bounces at cs.oswego.edu] On Behalf Of Carsten Schipke
> > > Sent: Sunday, January 10, 2016 1:36 PM
> > > To: dholmes at ieee.org
> > > Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
> > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > > Request for Comments
> > >
> > > Considering the continuous convergence of all platforms nowadays, that
> > > should not be a ?mobile programming model?.. Portability was once a
> > major
> > > feature of Java. The JVM & Java have some technical debt to pay to make
> > > that true again for current times/platforms/technologies.
> > >
> > >
> > > > On Jan 10, 2016, at 11:07, David Holmes <davidcholmes at aapt.net.au>
> > > wrote:
> > > >
> > > > Yes for mobile this is part of the programming model and it needs to
> be a
> > > primary consideration. Hence the various event hooks to allow for this.
> > > >
> > > > David
> > > >
> > > > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-
> > > interest-bounces at cs.oswego.edu] On Behalf Of Joe Bowbeer
> > > > Sent: Sunday, January 10, 2016 8:58 AM
> > > > To: David Holmes <dholmes at ieee.org>
> > > > Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
> > > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling
> /
> > > Request for Comments
> > > >
> > > > On mobile platforms, such as Android (or J2ME), suspension is
> > > commonplace, and even force-termination for resource reclamation or
> > > battery preservation is common.
> > > >
> > > > For both these reasons, app developers need to deal with these
> > > eventualities explicitly, saving and restoring persistent state, and
> cannot
> > rely
> > > only on a scheduled executor service.
> > > >
> > > > On Sat, Jan 9, 2016 at 2:07 PM, David Holmes
> > <davidcholmes at aapt.net.au>
> > > wrote:
> > > >> It is "by design" in the sense that:
> > > >>
> > > >> a) nothing in the Java platform APIs, or the VM implementation, were
> > > designed to work across machine suspension
> > > >> b) the underlying Window's API's do not behave in the way that is
> being
> > > described.
> > > >>
> > > >> David
> > > >>
> > > >> > -----Original Message-----
> > > >> > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-
> > > >> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> > > >> > Sent: Sunday, January 10, 2016 3:51 AM
> > > >> > To: 'Nathan & Ila Reynolds' <nathanila at gmail.com>; 'Carsten
> Schipke'
> > > >> > <carsten.schipke at gmail.com>
> > > >> > Cc: concurrency-interest at cs.oswego.edu
> > > >> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute
> Scheduling
> > /
> > > >> > Request for Comments
> > > >> >
> > > >> > Nathan,
> > > >> >
> > > >> > thanks for your comments.
> > > >> >
> > > >> > Please note that the actual behaviour deviates from your
> expectation
> > > on
> > > >> > varying with the OS type and version. For example, the one-time-
> > trigger
> > > >> > "schedule(delay)" variant of JDK 8u66 on Win 8.1 (64 Bit) does
> *not*
> > fire
> > > the
> > > >> > event "very soon after the delay" in some cases; in fact, it adds
> the
> > > complete
> > > >> > duration of the hibernation to relative-ms. Hence, when you call
> > > >> > "schedule(1min)", hibernate for 30s, wakeup the PC, then the event
> > > actually
> > > >> > fires 90s after you invoked that command! In fact, that behaviour
> is
> > *by
> > > >> > design* as I learned (according to Oracle's David Holmes), and it
> is the
> > > reason
> > > >> > for filing this RFC.
> > > >> >
> > > >> > -Markus
> > > >> >
> > > >> >
> > > >> > -----Original Message-----
> > > >> > From: Nathan & Ila Reynolds [mailto:nathanila at gmail.com]
> > > >> > Sent: Samstag, 9. Januar 2016 18:19
> > > >> > To: 'Markus KARG'; 'Carsten Schipke'
> > > >> > Cc: concurrency-interest at cs.oswego.edu
> > > >> > Subject: RE: [concurrency-interest] JDK-8146527: Absolute
> Scheduling
> > /
> > > >> > Request for Comments
> > > >> >
> > > >> > Also, Windows fires an event to all applications when the system
> > > resumes
> > > >> > after hibernation.  You could use that event instead of polling.
> > > >> >
> > > >> > ScheduledExecutorService provides schedule(),
> > scheduleAtFixedRate()
> > > and
> > > >> > scheduleWithFixedDelay().  I expect schedule() to run the command
> > at
> > > or
> > > >> > very soon after the delay or as soon as the machine resumes if the
> > delay
> > > has
> > > >> > elapsed.  I expect scheduleAtFixedRate() to run the command N
> times
> > > >> > rapidly if hibernation lasted N periods.  I expect
> > > scheduleWithFixedDelay() to
> > > >> > run the command one time at or very soon after the delay or as
> soon
> > as
> > > the
> > > >> > machine resumes.  In this regard, the programmer has control
> > whether
> > > they
> > > >> > need N times or 1 time after hibernation.  I only use
> > > scheduleAtFixedRate() if
> > > >> > I have something staying in sync with the passage of time.  I use
> > > >> > scheduleWithFixedDelay() in all other cases because if the command
> > > takes a
> > > >> > long time, I don't need it to run right away.
> > > >> >
> > > >> >
> > >
> >
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
> > > >> > xecutorService.html
> > > >> >
> > > >> > -Nathan
> > > >> >
> > > >> > -----Original Message-----
> > > >> > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-
> > > >> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> > > >> > Sent: Saturday, January 09, 2016 6:58 AM
> > > >> > To: 'Carsten Schipke' <carsten.schipke at gmail.com>
> > > >> > Cc: concurrency-interest at cs.oswego.edu
> > > >> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute
> Scheduling
> > /
> > > >> > Request for Comments
> > > >> >
> > > >> > Carsten,
> > > >> >
> > > >> > the Windows API provides several different methods for timing.
> Some
> > > of
> > > >> > them are definitively able to fire at a particular point in time,
> > > independent of
> > > >> > any hibernation.
> > > >> >
> > > >> > In case a different OS won't have such a factility, there is a
> simple
> > > fallback:
> > > >> > Triggering events more often, checking the actual time (in pure
> Java),
> > so
> > > we
> > > >> > find out whether to wait further, or whether the event is to be
> fired.
> > > This,
> > > >> > BTW, is the workaround applied by pure Java solutions currently,
> > hence
> > > what
> > > >> > I'd like to get rid off by this feature request. :-)
> > > >> >
> > > >> > -Markus
> > > >> >
> > > >> >
> > > >> > -----Original Message-----
> > > >> > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > > >> > Sent: Samstag, 9. Januar 2016 14:09
> > > >> > To: Markus KARG
> > > >> > Cc: concurrency-interest at cs.oswego.edu
> > > >> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute
> Scheduling
> > /
> > > >> > Request for Comments
> > > >> >
> > > >> > sure, as I mentioned, I have never really had that requirement,
> it just
> > > >> > sounded to me like many programmers could have many slightly
> > > different
> > > >> > requirements on such an API. I also don?t know what the Windows
> > API
> > > >> > offers in those regards / how its solved there, but if there is
> such a
> > > widely
> > > >> > accepted solution, then it surely would make sense as you say.
> > > >> >
> > > >> >
> > > >> > > On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu>
> > > wrote:
> > > >> > >
> > > >> > > I think it should be up to the programmer (e. g. by passing a
> flag or
> > > using
> > > >> > different methods) whether he wants 10 events after missing those
> > > while
> > > >> > hibernation, or whether he wants the events to be collapsed into
> one
> > > single
> > > >> > event alternatively. BTW, I never said that the API must support
> an
> > > absolute
> > > >> > variant of repeated event schedulung. You could also simply
> provide
> > an
> > > >> > absolute variant of the "fire ONCE" method, and the mail
> application
> > has
> > > to
> > > >> > reschedule inside of the event handler.
> > > >> > >
> > > >> > > Hooks are out of scope for my proposal, as they solve a
> different
> > > problem
> > > >> > and are working on a deeper level (the scheduler API could
> certainly
> > > make
> > > >> > use of such hooks). In case the Windows API for example would be
> > able
> > > to
> > > >> > solve the problem for us (it is, BTW), why shouldn't we provide a
> Java
> > > API
> > > >> > wrapping that (without running into any rattail, as we simply
> offload)?
> > > >> > >
> > > >> > > -Markus
> > > >> > >
> > > >> > > -----Original Message-----
> > > >> > > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > > >> > > Sent: Samstag, 9. Januar 2016 11:02
> > > >> > > To: Markus KARG
> > > >> > > Cc: concurrency-interest at cs.oswego.edu
> > > >> > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute
> > Scheduling
> > > /
> > > >> > Request for Comments
> > > >> > >
> > > >> > > ?...or it will fire instantly after the end of hibernation ??
> considering
> > > your
> > > >> > example of hourly/periodically checking mails, that would mean
> that
> > the
> > > >> > program checks your mailbox 10 times at once after 10h
> hibernation.
> > > >> > > So the API would also need to know whether unfired events should
> > > queue
> > > >> > up over time. Sounds like a rattail pulling endlessly use cases &
> > > requirements
> > > >> > behind it.
> > > >> > >
> > > >> > > I for one never thought about using the JVM to schedule things
> that
> > > live
> > > >> > through hibernation or similar (not knowing the original
> intention of
> > the
> > > API).
> > > >> > But I have also never built daemon-like desktop/client
> > > applications/services.
> > > >> > >
> > > >> > > I guess in case of JVM, one could argue that specifications
> only apply
> > > at
> > > >> > runtime, and hibernation is interrupting that. Maybe it would be
> > better
> > > to
> > > >> > provide hooks e.g. in the Runtime class to allow callbacks on pre-
> > /post-
> > > >> > hibernation, standby, signals etc. Then one could de/attach events
> > > >> > accordingly.
> > > >> > >
> > > >> > >
> > > >> > >> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu>
> > > >> > wrote:
> > > >> > >>
> > > >> > >> The following requests comments on a Feature Proposal for
> > > Absolute
> > > >> > Scheduling.
> > > >> > >>
> > > >> > >> OpenJDK ticket JDK-8146527
> > > (https://bugs.openjdk.java.net/browse/JDK-
> > > >> > 8146527) describes the following case:
> > > >> > >>
> > > >> > >> * ScheduledExecutorService.schedule() is invoked to schedule
> > firing
> > > of an
> > > >> > event "in one minute".
> > > >> > >> * The laptop lid gets closed instantly after that, so
> hibernation will
> > > occur,
> > > >> > hence the JVM will suspend.
> > > >> > >> * After thirty seconds of hibernation, the laptop lid gets
> openen, so
> > > >> > hibernation will cancel and the JVM resumes.
> > > >> > >> * Despite the expected result (one minute after start of
> program
> > the
> > > >> > event does occur), the event actually is delayed by the length of
> the
> > > >> > hibernation phase, and happens 90 seconds after the program was
> > > started.
> > > >> > In the expectation of the end user, the event fired 30 seconds
> "too
> > > late"!
> > > >> > >>
> > > >> > >> This is annoying to users and rather unexpected and
> astonishing for
> > > >> > programmers literally following the words of the JavaDocs.
> Clearly the
> > > >> > provided deadline is a relative value in the physical sense ("one
> > minute
> > > from
> > > >> > now, independent of what 'now' is currently like"), but certainly
> what
> > > the
> > > >> > user actually expects it to work like is an absolute value in the
> physical
> > > sense
> > > >> > ("one minute from now, where 'now' is the current point on the
> time
> > > axis of
> > > >> > the Universe, hence unaffected by hibernation). Whether or not the
> > > laptop
> > > >> > was closed temporarily in the meantime plays no role to the
> > expectation
> > > of
> > > >> > neither the end user nor the application provider.
> > > >> > >>
> > > >> > >> Unfortunately there is no other API that allows the application
> > > vendor to
> > > >> > define that the deadline it meant to be unaffected of hibernation.
> > > Clearly
> > > >> > this is a drawback to the Java platform, as many applications
> need such
> > a
> > > >> > behaviour (like "check my mails once per hour" - if you open your
> > laptop
> > > lid
> > > >> > ONLY for a few minutes to see whether meanwhile new emails
> > arrived
> > > or not
> > > >> > [like, BTW, some laptops are able to perform these days, even with
> > the
> > > lid
> > > >> > closed, thanks to a BIOS timer] you won't receive any new emails
> ever
> > > as
> > > >> > "JVM" time progresses only be few minutes per day then).
> > > >> > >>
> > > >> > >> A solution could be the addition of a special variant of
> > > >> > ScheduledExecutorService.schedule(absoluteInstant) which is
> > > unaffected of
> > > >> > any hibernation, and will fire either exactly at the
> absoluteInstant (in
> > > case the
> > > >> > laptop is not hibernating _currently_), or it will fire instantly
> after the
> > > end of
> > > >> > hibernation, in case the laptop was hibernating at
> absoluteInstant.
> > > >> > >>
> > > >> > >> There are two possible ways to reach this: Either there is an
> OS-
> > > specific
> > > >> > API that alrady provides exactly that behaviour, or the JVM needs
> to
> > be
> > > >> > informed every 'x' fractions of "discontinuous jvm time" to find
> out
> > how
> > > >> > much "continuous real world time" has advanced and whether a
> > > scheduled
> > > >> > event was missed meanwhile (which is the workaround such
> > > applications
> > > >> > have to perform on their own currently to workaround the problem).
> > > The
> > > >> > first is problematic due to changes in the implementations of the
> APIs
> > > (e. g.
> > > >> > Windows changed some APIs from "continuous time" to using
> > > >> > "discontinuous time"), the second is complex in finding the
> optimal
> > > value of
> > > >> > 'x' (too low means high power consumption, too high means firing
> too
> > > late
> > > >> > after the deadline).
> > > >> > >>
> > > >> > >> Side note: To be unambiguous, the new deadline should possibly
> > be
> > > >> > typed as java.time.Instant, as that could never be misunderstood
> as
> > > >> > "discontinous jvm time" inherently.
> > > >> > >>
> > > >> > >> What is your opinion on that?
> > > >> > >>
> > > >> > >> -Markus
> > > >> > >> _______________________________________________
> > > >> > >> Concurrency-interest mailing list
> > > >> > >> Concurrency-interest at cs.oswego.edu
> > > >> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >> > >
> > > >> > >
> > > >> >
> > > >> >
> > > >> >
> > > >> > _______________________________________________
> > > >> > Concurrency-interest mailing list
> > > >> > Concurrency-interest at cs.oswego.edu
> > > >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >> >
> > > >> >
> > > >> >
> > > >> > _______________________________________________
> > > >> > Concurrency-interest mailing list
> > > >> > Concurrency-interest at cs.oswego.edu
> > > >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >>
> > > >>
> > > >> _______________________________________________
> > > >> Concurrency-interest mailing list
> > > >> Concurrency-interest at cs.oswego.edu
> > > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at cs.oswego.edu
> > > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160110/717de3f6/attachment-0001.html>

From aleksey.shipilev at oracle.com  Mon Jan 11 06:05:52 2016
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Mon, 11 Jan 2016 14:05:52 +0300
Subject: [concurrency-interest] Explicitly initializing volatile fields
 with default values
In-Reply-To: <61E7C0E1-E94C-45B8-9093-7A3453B51406@gmail.com>
References: <56732AF9.7030109@oracle.com>
	<61E7C0E1-E94C-45B8-9093-7A3453B51406@gmail.com>
Message-ID: <56938C90.6020009@oracle.com>

On 01/04/2016 01:34 PM, Alex Otenko wrote:
> So, you are considering what the legitimate outcomes of a racy
> publication are, right? Since global in both cases is not volatile, I
> am not sure I understand the purpose of specifying a ?correct?
> initialization visibility order for values published in a way we
> discourage as error-prone. Do we have legitimate code that uses racy
> publication of this sort?

When considering a bulk update in a class library, it is pragmatic to
understand if any new behaviors are possible, even if they are within
the realm of current spec. Because the alternative would be reviewing
each and any usage for "surprising" but legitimate code examples.

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160111/d83d871b/attachment.bin>

From oleksandr.otenko at gmail.com  Mon Jan 11 09:26:32 2016
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 11 Jan 2016 14:26:32 +0000
Subject: [concurrency-interest] Explicitly initializing volatile fields
	with default values
In-Reply-To: <56938C90.6020009@oracle.com>
References: <56732AF9.7030109@oracle.com>
	<61E7C0E1-E94C-45B8-9093-7A3453B51406@gmail.com>
	<56938C90.6020009@oracle.com>
Message-ID: <81070DA1-5660-4926-8917-748EFD0A7E1E@gmail.com>

ok, I see your point.

Even though I think in the end the surprising behaviours will be down to underspecified outcomes and specific JVM implementations.

Alex

> On 11 Jan 2016, at 11:05, Aleksey Shipilev <aleksey.shipilev at oracle.com> wrote:
> 
> On 01/04/2016 01:34 PM, Alex Otenko wrote:
>> So, you are considering what the legitimate outcomes of a racy
>> publication are, right? Since global in both cases is not volatile, I
>> am not sure I understand the purpose of specifying a ?correct?
>> initialization visibility order for values published in a way we
>> discourage as error-prone. Do we have legitimate code that uses racy
>> publication of this sort?
> 
> When considering a bulk update in a class library, it is pragmatic to
> understand if any new behaviors are possible, even if they are within
> the realm of current spec. Because the alternative would be reviewing
> each and any usage for "surprising" but legitimate code examples.
> 
> Thanks,
> -Aleksey
> 



From markus at headcrashing.eu  Mon Jan 11 11:37:52 2016
From: markus at headcrashing.eu (Markus KARG)
Date: Mon, 11 Jan 2016 17:37:52 +0100
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
	Request for Comments
In-Reply-To: <5692ACDA.70108@redhat.com>
References: <002501d14ac0$28189150$7849b3f0$@eu>	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>	<009001d14ade$43383fd0$c9a8bf70$@eu>	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>	<00ac01d14ae5$b0628d70$1127a850$@eu>	<006001d14b01$c85b6b60$59124220$@gmail.com>	<006401d14b06$58dadb40$0a9091c0$@eu>	<00c401d14b2a$297506e0$7c5f14a0$@aapt.net.au>	<CAHzJPEqyA1C7c8VjOhv_wym3AghQ4SHvuZoR0OM2H1VVwJdEgg@mail.gmail.com>	<00cc01d14b54$180b39e0$4821ada0$@aapt.net.au>
	<5692ACDA.70108@redhat.com>
Message-ID: <014401d14c8e$6a7da060$3f78e120$@eu>

It depends on the use case, so the application programmer should decide
whether he wants coalesced events, an event storm, or the current behaviour
(delayed).

-Markus

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Andrew
Haley
Sent: Sonntag, 10. Januar 2016 20:11
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
Request for Comments

On 10/01/16 03:07, David Holmes wrote:

> Yes for mobile this is part of the programming model and it needs to
> be a primary consideration. Hence the various event hooks to allow
> for this.

For servers it is ever more important because of virtualization, where
entire VMs will be suspended, migrated across the cloud, etc.  I think
that you probably do not want a lot of tasks all firing up when a VM
is restarted.

Andrew.

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From markus at headcrashing.eu  Mon Jan 11 11:43:05 2016
From: markus at headcrashing.eu (Markus KARG)
Date: Mon, 11 Jan 2016 17:43:05 +0100
Subject: [concurrency-interest] JDK-8146527:
	Absolute	Scheduling	/	Request for Comments
In-Reply-To: <00da01d14bf8$4f9c9710$eed5c530$@aapt.net.au>
References: <002501d14ac0$28189150$7849b3f0$@eu>	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>	<009001d14ade$43383fd0$c9a8bf70$@eu>	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>	<00ac01d14ae5$b0628d70$1127a850$@eu>	<006001d14b01$c85b6b60$59124220$@gmail.com>	<EE8F7E94-8BEC-47CF-9D76-049944F08B6B@gmail.com>
	<00da01d14bf8$4f9c9710$eed5c530$@aapt.net.au>
Message-ID: <014a01d14c8f$2533ef90$6f9bceb0$@eu>

The Windows OS _does_ provide different types of clocks.

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David Holmes
Sent: Sonntag, 10. Januar 2016 23:43
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Request for Comments

I think Alex hits the nail on the head here. For these API's to work "correctly" in these difference contexts we have to make "time" an explicit part of the API and in particular we do need a notion of different Clocks that represent different kinds of "time". The Real-time Specification for Java did try to go down this path but ran into serious practical limitations - if the operating system doesn't support different kinds of clocks and the API's they expose don't allow control of the clocks involved, then implementing such abstractions in an efficient and practical way is exceedingly difficult, to say the least.

David
-------

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Alex Otenko
> Sent: Sunday, January 10, 2016 12:04 PM
> To: Nathan & Ila Reynolds <nathanila at gmail.com>
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> 
> I would expect these to be case-specific.
> 
> The flow of time is different in different frames of reference. Mailer wants it
> to be tied to the frame of reference coinciding with mail server (which is in
> the same frame as Greenwich), Sudoku game wants it tied to the frame of
> reference coinciding with Sudoku process space - it doesn?t want to count
> time towards the score whilst the game is not in the foreground.
> 
> It would be nice to have a replaceable clock, or the source of time for
> individual condvars.
> 
> Alex
> 
> > On 9 Jan 2016, at 17:18, Nathan & Ila Reynolds <nathanila at gmail.com>
> wrote:
> >
> > Also, Windows fires an event to all applications when the system resumes
> after hibernation.  You could use that event instead of polling.
> >
> > ScheduledExecutorService provides schedule(), scheduleAtFixedRate() and
> scheduleWithFixedDelay().  I expect schedule() to run the command at or
> very soon after the delay or as soon as the machine resumes if the delay has
> elapsed.  I expect scheduleAtFixedRate() to run the command N times
> rapidly if hibernation lasted N periods.  I expect scheduleWithFixedDelay() to
> run the command one time at or very soon after the delay or as soon as the
> machine resumes.  In this regard, the programmer has control whether they
> need N times or 1 time after hibernation.  I only use scheduleAtFixedRate() if
> I have something staying in sync with the passage of time.  I use
> scheduleWithFixedDelay() in all other cases because if the command takes a
> long time, I don't need it to run right away.
> >
> >
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
> xecutorService.html
> >
> > -Nathan
> >
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> > Sent: Saturday, January 09, 2016 6:58 AM
> > To: 'Carsten Schipke' <carsten.schipke at gmail.com>
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> >
> > Carsten,
> >
> > the Windows API provides several different methods for timing. Some of
> them are definitively able to fire at a particular point in time, independent of
> any hibernation.
> >
> > In case a different OS won't have such a factility, there is a simple fallback:
> Triggering events more often, checking the actual time (in pure Java), so we
> find out whether to wait further, or whether the event is to be fired. This,
> BTW, is the workaround applied by pure Java solutions currently, hence what
> I'd like to get rid off by this feature request. :-)
> >
> > -Markus
> >
> >
> > -----Original Message-----
> > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > Sent: Samstag, 9. Januar 2016 14:09
> > To: Markus KARG
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> >
> > sure, as I mentioned, I have never really had that requirement, it just
> sounded to me like many programmers could have many slightly different
> requirements on such an API. I also don?t know what the Windows API
> offers in those regards / how its solved there, but if there is such a widely
> accepted solution, then it surely would make sense as you say.
> >
> >
> >> On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu>
> wrote:
> >>
> >> I think it should be up to the programmer (e. g. by passing a flag or using
> different methods) whether he wants 10 events after missing those while
> hibernation, or whether he wants the events to be collapsed into one single
> event alternatively. BTW, I never said that the API must support an absolute
> variant of repeated event schedulung. You could also simply provide an
> absolute variant of the "fire ONCE" method, and the mail application has to
> reschedule inside of the event handler.
> >>
> >> Hooks are out of scope for my proposal, as they solve a different problem
> and are working on a deeper level (the scheduler API could certainly make
> use of such hooks). In case the Windows API for example would be able to
> solve the problem for us (it is, BTW), why shouldn't we provide a Java API
> wrapping that (without running into any rattail, as we simply offload)?
> >>
> >> -Markus
> >>
> >> -----Original Message-----
> >> From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> >> Sent: Samstag, 9. Januar 2016 11:02
> >> To: Markus KARG
> >> Cc: concurrency-interest at cs.oswego.edu
> >> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> >>
> >> ?...or it will fire instantly after the end of hibernation ?? considering your
> example of hourly/periodically checking mails, that would mean that the
> program checks your mailbox 10 times at once after 10h hibernation.
> >> So the API would also need to know whether unfired events should
> queue up over time. Sounds like a rattail pulling endlessly use cases &
> requirements behind it.
> >>
> >> I for one never thought about using the JVM to schedule things that live
> through hibernation or similar (not knowing the original intention of the API).
> But I have also never built daemon-like desktop/client applications/services.
> >>
> >> I guess in case of JVM, one could argue that specifications only apply at
> runtime, and hibernation is interrupting that. Maybe it would be better to
> provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-
> hibernation, standby, signals etc. Then one could de/attach events
> accordingly.
> >>
> >>
> >>> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu>
> wrote:
> >>>
> >>> The following requests comments on a Feature Proposal for Absolute
> Scheduling.
> >>>
> >>> OpenJDK ticket JDK-8146527
> (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the
> following case:
> >>>
> >>> * ScheduledExecutorService.schedule() is invoked to schedule firing of
> an event "in one minute".
> >>> * The laptop lid gets closed instantly after that, so hibernation will occur,
> hence the JVM will suspend.
> >>> * After thirty seconds of hibernation, the laptop lid gets openen, so
> hibernation will cancel and the JVM resumes.
> >>> * Despite the expected result (one minute after start of program the
> event does occur), the event actually is delayed by the length of the
> hibernation phase, and happens 90 seconds after the program was started.
> In the expectation of the end user, the event fired 30 seconds "too late"!
> >>>
> >>> This is annoying to users and rather unexpected and astonishing for
> programmers literally following the words of the JavaDocs. Clearly the
> provided deadline is a relative value in the physical sense ("one minute from
> now, independent of what 'now' is currently like"), but certainly what the
> user actually expects it to work like is an absolute value in the physical sense
> ("one minute from now, where 'now' is the current point on the time axis of
> the Universe, hence unaffected by hibernation). Whether or not the laptop
> was closed temporarily in the meantime plays no role to the expectation of
> neither the end user nor the application provider.
> >>>
> >>> Unfortunately there is no other API that allows the application vendor to
> define that the deadline it meant to be unaffected of hibernation. Clearly
> this is a drawback to the Java platform, as many applications need such a
> behaviour (like "check my mails once per hour" - if you open your laptop lid
> ONLY for a few minutes to see whether meanwhile new emails arrived or not
> [like, BTW, some laptops are able to perform these days, even with the lid
> closed, thanks to a BIOS timer] you won't receive any new emails ever as
> "JVM" time progresses only be few minutes per day then).
> >>>
> >>> A solution could be the addition of a special variant of
> ScheduledExecutorService.schedule(absoluteInstant) which is unaffected of
> any hibernation, and will fire either exactly at the absoluteInstant (in case the
> laptop is not hibernating _currently_), or it will fire instantly after the end of
> hibernation, in case the laptop was hibernating at absoluteInstant.
> >>>
> >>> There are two possible ways to reach this: Either there is an OS-specific
> API that alrady provides exactly that behaviour, or the JVM needs to be
> informed every 'x' fractions of "discontinuous jvm time" to find out how
> much "continuous real world time" has advanced and whether a scheduled
> event was missed meanwhile (which is the workaround such applications
> have to perform on their own currently to workaround the problem). The
> first is problematic due to changes in the implementations of the APIs (e. g.
> Windows changed some APIs from "continuous time" to using
> "discontinuous time"), the second is complex in finding the optimal value of
> 'x' (too low means high power consumption, too high means firing too late
> after the deadline).
> >>>
> >>> Side note: To be unambiguous, the new deadline should possibly be
> typed as java.time.Instant, as that could never be misunderstood as
> "discontinous jvm time" inherently.
> >>>
> >>> What is your opinion on that?
> >>>
> >>> -Markus
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >>
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From aph at redhat.com  Mon Jan 11 11:46:13 2016
From: aph at redhat.com (Andrew Haley)
Date: Mon, 11 Jan 2016 16:46:13 +0000
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
 Request for Comments
In-Reply-To: <014401d14c8e$6a7da060$3f78e120$@eu>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
	<009001d14ade$43383fd0$c9a8bf70$@eu>
	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
	<00ac01d14ae5$b0628d70$1127a850$@eu>
	<006001d14b01$c85b6b60$59124220$@gmail.com>
	<006401d14b06$58dadb40$0a9091c0$@eu>
	<00c401d14b2a$297506e0$7c5f14a0$@aapt.net.au>
	<CAHzJPEqyA1C7c8VjOhv_wym3AghQ4SHvuZoR0OM2H1VVwJdEgg@mail.gmail.com>
	<00cc01d14b54$180b39e0$4821ada0$@aapt.net.au>
	<5692ACDA.70108@redhat.com> <014401d14c8e$6a7da060$3f78e120$@eu>
Message-ID: <5693DC55.8010300@redhat.com>

On 01/11/2016 04:37 PM, Markus KARG wrote:
> It depends on the use case, so the application programmer should decide
> whether he wants coalesced events, an event storm, or the current behaviour
> (delayed).

But the application programmer may not even know that their
application is being used in such an environment.  It's a deployment
issue.

Andrew.


From markus at headcrashing.eu  Mon Jan 11 12:18:12 2016
From: markus at headcrashing.eu (Markus KARG)
Date: Mon, 11 Jan 2016 18:18:12 +0100
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
	Request for Comments
In-Reply-To: <5693DC55.8010300@redhat.com>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
	<009001d14ade$43383fd0$c9a8bf70$@eu>
	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
	<00ac01d14ae5$b0628d70$1127a850$@eu>
	<006001d14b01$c85b6b60$59124220$@gmail.com>
	<006401d14b06$58dadb40$0a9091c0$@eu>
	<00c401d14b2a$297506e0$7c5f14a0$@aapt.net.au>
	<CAHzJPEqyA1C7c8VjOhv_wym3AghQ4SHvuZoR0OM2H1VVwJdEgg@mail.gmail.com>
	<00cc01d14b54$180b39e0$4821ada0$@aapt.net.au>
	<5692ACDA.70108@redhat.com> <014401d14c8e$6a7da060$3f78e120$@eu>
	<5693DC55.8010300@redhat.com>
Message-ID: <01af01d14c94$0d05f4e0$2711dea0$@eu>

The application programmer knows very well whether he wants to have absolute
time (non-affected of hibernation), or whether he don't cares if time is
delayed (affected of hibernation). Whether or not hibernation actually
occurs is of no interest when using the "right" API then. The deployer on
the other hand know whether hibernation will occur, but cannot know whether
delayed time will harm the use case of the application. So *only* the
application programmer can decide safely for the correct API.

-----Original Message-----
From: Andrew Haley [mailto:aph at redhat.com] 
Sent: Montag, 11. Januar 2016 17:46
To: Markus KARG; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
Request for Comments

On 01/11/2016 04:37 PM, Markus KARG wrote:
> It depends on the use case, so the application programmer should decide
> whether he wants coalesced events, an event storm, or the current
behaviour
> (delayed).

But the application programmer may not even know that their
application is being used in such an environment.  It's a deployment
issue.

Andrew.



From davidcholmes at aapt.net.au  Mon Jan 11 15:52:43 2016
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 12 Jan 2016 06:52:43 +1000
Subject: [concurrency-interest]
	JDK-8146527:	Absolute	Scheduling	/	Request for Comments
In-Reply-To: <014a01d14c8f$2533ef90$6f9bceb0$@eu>
References: <002501d14ac0$28189150$7849b3f0$@eu>	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>	<009001d14ade$43383fd0$c9a8bf70$@eu>	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>	<00ac01d14ae5$b0628d70$1127a850$@eu>	<006001d14b01$c85b6b60$59124220$@gmail.com>	<EE8F7E94-8BEC-47CF-9D76-049944F08B6B@gmail.com>	<00da01d14bf8$4f9c9710$eed5c530$@aapt.net.au>
	<014a01d14c8f$2533ef90$6f9bceb0$@eu>
Message-ID: <010e01d14cb2$04e39b50$0eaad1f0$@aapt.net.au>

Markus KARG writes:
> 
> The Windows OS _does_ provide different types of clocks.

Not to the extent described by Alex ie relative clocks that track across suspension, relative clocks that don't. There is only a single relative time clock and a single absolute time clock - and the Windows synchronization API's don't let you specify which clock you want to use for timeouts - they are simply relative with whatever suspension semantics windows has chosen.

David
-------
 
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of David Holmes
> Sent: Sonntag, 10. Januar 2016 23:43
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> 
> I think Alex hits the nail on the head here. For these API's to work "correctly"
> in these difference contexts we have to make "time" an explicit part of the
> API and in particular we do need a notion of different Clocks that represent
> different kinds of "time". The Real-time Specification for Java did try to go
> down this path but ran into serious practical limitations - if the operating
> system doesn't support different kinds of clocks and the API's they expose
> don't allow control of the clocks involved, then implementing such
> abstractions in an efficient and practical way is exceedingly difficult, to say
> the least.
> 
> David
> -------
> 
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of Alex Otenko
> > Sent: Sunday, January 10, 2016 12:04 PM
> > To: Nathan & Ila Reynolds <nathanila at gmail.com>
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> >
> > I would expect these to be case-specific.
> >
> > The flow of time is different in different frames of reference. Mailer wants
> it
> > to be tied to the frame of reference coinciding with mail server (which is in
> > the same frame as Greenwich), Sudoku game wants it tied to the frame of
> > reference coinciding with Sudoku process space - it doesn?t want to count
> > time towards the score whilst the game is not in the foreground.
> >
> > It would be nice to have a replaceable clock, or the source of time for
> > individual condvars.
> >
> > Alex
> >
> > > On 9 Jan 2016, at 17:18, Nathan & Ila Reynolds <nathanila at gmail.com>
> > wrote:
> > >
> > > Also, Windows fires an event to all applications when the system
> resumes
> > after hibernation.  You could use that event instead of polling.
> > >
> > > ScheduledExecutorService provides schedule(), scheduleAtFixedRate()
> and
> > scheduleWithFixedDelay().  I expect schedule() to run the command at or
> > very soon after the delay or as soon as the machine resumes if the delay
> has
> > elapsed.  I expect scheduleAtFixedRate() to run the command N times
> > rapidly if hibernation lasted N periods.  I expect scheduleWithFixedDelay()
> to
> > run the command one time at or very soon after the delay or as soon as the
> > machine resumes.  In this regard, the programmer has control whether
> they
> > need N times or 1 time after hibernation.  I only use scheduleAtFixedRate()
> if
> > I have something staying in sync with the passage of time.  I use
> > scheduleWithFixedDelay() in all other cases because if the command takes
> a
> > long time, I don't need it to run right away.
> > >
> > >
> >
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
> > xecutorService.html
> > >
> > > -Nathan
> > >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> > > Sent: Saturday, January 09, 2016 6:58 AM
> > > To: 'Carsten Schipke' <carsten.schipke at gmail.com>
> > > Cc: concurrency-interest at cs.oswego.edu
> > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> > >
> > > Carsten,
> > >
> > > the Windows API provides several different methods for timing. Some of
> > them are definitively able to fire at a particular point in time, independent
> of
> > any hibernation.
> > >
> > > In case a different OS won't have such a factility, there is a simple fallback:
> > Triggering events more often, checking the actual time (in pure Java), so
> we
> > find out whether to wait further, or whether the event is to be fired. This,
> > BTW, is the workaround applied by pure Java solutions currently, hence
> what
> > I'd like to get rid off by this feature request. :-)
> > >
> > > -Markus
> > >
> > >
> > > -----Original Message-----
> > > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > > Sent: Samstag, 9. Januar 2016 14:09
> > > To: Markus KARG
> > > Cc: concurrency-interest at cs.oswego.edu
> > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> > >
> > > sure, as I mentioned, I have never really had that requirement, it just
> > sounded to me like many programmers could have many slightly different
> > requirements on such an API. I also don?t know what the Windows API
> > offers in those regards / how its solved there, but if there is such a widely
> > accepted solution, then it surely would make sense as you say.
> > >
> > >
> > >> On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu>
> > wrote:
> > >>
> > >> I think it should be up to the programmer (e. g. by passing a flag or using
> > different methods) whether he wants 10 events after missing those while
> > hibernation, or whether he wants the events to be collapsed into one
> single
> > event alternatively. BTW, I never said that the API must support an
> absolute
> > variant of repeated event schedulung. You could also simply provide an
> > absolute variant of the "fire ONCE" method, and the mail application has to
> > reschedule inside of the event handler.
> > >>
> > >> Hooks are out of scope for my proposal, as they solve a different
> problem
> > and are working on a deeper level (the scheduler API could certainly make
> > use of such hooks). In case the Windows API for example would be able to
> > solve the problem for us (it is, BTW), why shouldn't we provide a Java API
> > wrapping that (without running into any rattail, as we simply offload)?
> > >>
> > >> -Markus
> > >>
> > >> -----Original Message-----
> > >> From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > >> Sent: Samstag, 9. Januar 2016 11:02
> > >> To: Markus KARG
> > >> Cc: concurrency-interest at cs.oswego.edu
> > >> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> > >>
> > >> ?...or it will fire instantly after the end of hibernation ?? considering your
> > example of hourly/periodically checking mails, that would mean that the
> > program checks your mailbox 10 times at once after 10h hibernation.
> > >> So the API would also need to know whether unfired events should
> > queue up over time. Sounds like a rattail pulling endlessly use cases &
> > requirements behind it.
> > >>
> > >> I for one never thought about using the JVM to schedule things that live
> > through hibernation or similar (not knowing the original intention of the
> API).
> > But I have also never built daemon-like desktop/client
> applications/services.
> > >>
> > >> I guess in case of JVM, one could argue that specifications only apply at
> > runtime, and hibernation is interrupting that. Maybe it would be better to
> > provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-
> > hibernation, standby, signals etc. Then one could de/attach events
> > accordingly.
> > >>
> > >>
> > >>> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu>
> > wrote:
> > >>>
> > >>> The following requests comments on a Feature Proposal for Absolute
> > Scheduling.
> > >>>
> > >>> OpenJDK ticket JDK-8146527
> > (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the
> > following case:
> > >>>
> > >>> * ScheduledExecutorService.schedule() is invoked to schedule firing of
> > an event "in one minute".
> > >>> * The laptop lid gets closed instantly after that, so hibernation will
> occur,
> > hence the JVM will suspend.
> > >>> * After thirty seconds of hibernation, the laptop lid gets openen, so
> > hibernation will cancel and the JVM resumes.
> > >>> * Despite the expected result (one minute after start of program the
> > event does occur), the event actually is delayed by the length of the
> > hibernation phase, and happens 90 seconds after the program was started.
> > In the expectation of the end user, the event fired 30 seconds "too late"!
> > >>>
> > >>> This is annoying to users and rather unexpected and astonishing for
> > programmers literally following the words of the JavaDocs. Clearly the
> > provided deadline is a relative value in the physical sense ("one minute
> from
> > now, independent of what 'now' is currently like"), but certainly what the
> > user actually expects it to work like is an absolute value in the physical
> sense
> > ("one minute from now, where 'now' is the current point on the time axis
> of
> > the Universe, hence unaffected by hibernation). Whether or not the
> laptop
> > was closed temporarily in the meantime plays no role to the expectation of
> > neither the end user nor the application provider.
> > >>>
> > >>> Unfortunately there is no other API that allows the application vendor
> to
> > define that the deadline it meant to be unaffected of hibernation. Clearly
> > this is a drawback to the Java platform, as many applications need such a
> > behaviour (like "check my mails once per hour" - if you open your laptop lid
> > ONLY for a few minutes to see whether meanwhile new emails arrived or
> not
> > [like, BTW, some laptops are able to perform these days, even with the lid
> > closed, thanks to a BIOS timer] you won't receive any new emails ever as
> > "JVM" time progresses only be few minutes per day then).
> > >>>
> > >>> A solution could be the addition of a special variant of
> > ScheduledExecutorService.schedule(absoluteInstant) which is unaffected
> of
> > any hibernation, and will fire either exactly at the absoluteInstant (in case
> the
> > laptop is not hibernating _currently_), or it will fire instantly after the end
> of
> > hibernation, in case the laptop was hibernating at absoluteInstant.
> > >>>
> > >>> There are two possible ways to reach this: Either there is an OS-specific
> > API that alrady provides exactly that behaviour, or the JVM needs to be
> > informed every 'x' fractions of "discontinuous jvm time" to find out how
> > much "continuous real world time" has advanced and whether a scheduled
> > event was missed meanwhile (which is the workaround such applications
> > have to perform on their own currently to workaround the problem). The
> > first is problematic due to changes in the implementations of the APIs (e. g.
> > Windows changed some APIs from "continuous time" to using
> > "discontinuous time"), the second is complex in finding the optimal value of
> > 'x' (too low means high power consumption, too high means firing too late
> > after the deadline).
> > >>>
> > >>> Side note: To be unambiguous, the new deadline should possibly be
> > typed as java.time.Instant, as that could never be misunderstood as
> > "discontinous jvm time" inherently.
> > >>>
> > >>> What is your opinion on that?
> > >>>
> > >>> -Markus
> > >>> _______________________________________________
> > >>> Concurrency-interest mailing list
> > >>> Concurrency-interest at cs.oswego.edu
> > >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >>
> > >>
> > >
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From dl at cs.oswego.edu  Tue Jan 12 07:10:44 2016
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 12 Jan 2016 07:10:44 -0500
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
 Request for Comments
In-Reply-To: <002501d14ac0$28189150$7849b3f0$@eu>
References: <002501d14ac0$28189150$7849b3f0$@eu>
Message-ID: <5694ED44.6000202@cs.oswego.edu>

On 01/09/2016 04:28 AM, Markus KARG wrote:
> The following requests comments on a Feature Proposal for Absolute Scheduling.
>
> OpenJDK ticket JDK-8146527 (https://bugs.openjdk.java.net/browse/JDK-8146527)
> describes the following case:

Everyone wants time-related functions to do The Right Thing,
for evolving notions of The Right Thing.

The Right Thing should also be compatible with how Android
deals with deep-sleep etc. See
http://developer.android.com/reference/android/os/SystemClock.html

The main obstacle is finding people to invest substantial time
to work on the intricate and messy JVM support. If anyone is looking
for a challenging OpenJDK problem to work on long-term, this might
be a good choice.

-Doug


From markus at headcrashing.eu  Tue Jan 12 12:51:55 2016
From: markus at headcrashing.eu (Markus KARG)
Date: Tue, 12 Jan 2016 18:51:55 +0100
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
	Request for Comments
In-Reply-To: <5694ED44.6000202@cs.oswego.edu>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<5694ED44.6000202@cs.oswego.edu>
Message-ID: <023d01d14d61$ed2a8bd0$c77fa370$@eu>

Does that mean that the decision, how the future API shall look like IN THE
FUTURE is dependent of whether we can find a volunterr NOW?
-Markus

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Doug Lea
Sent: Dienstag, 12. Januar 2016 13:11
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
Request for Comments

On 01/09/2016 04:28 AM, Markus KARG wrote:
> The following requests comments on a Feature Proposal for Absolute
Scheduling.
>
> OpenJDK ticket JDK-8146527 
> (https://bugs.openjdk.java.net/browse/JDK-8146527)
> describes the following case:

Everyone wants time-related functions to do The Right Thing, for evolving
notions of The Right Thing.

The Right Thing should also be compatible with how Android deals with
deep-sleep etc. See
http://developer.android.com/reference/android/os/SystemClock.html

The main obstacle is finding people to invest substantial time to work on
the intricate and messy JVM support. If anyone is looking for a challenging
OpenJDK problem to work on long-term, this might be a good choice.

-Doug

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From martinrb at google.com  Tue Jan 12 13:59:34 2016
From: martinrb at google.com (Martin Buchholz)
Date: Tue, 12 Jan 2016 10:59:34 -0800
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
 Request for Comments
In-Reply-To: <5694ED44.6000202@cs.oswego.edu>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<5694ED44.6000202@cs.oswego.edu>
Message-ID: <CA+kOe09uixLrGk_Kavj8Vaq99PEvwBYQN2O_UZ+GwfytH3bQhw@mail.gmail.com>

On Tue, Jan 12, 2016 at 4:10 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> The Right Thing should also be compatible with how Android
> deals with deep-sleep etc. See
> http://developer.android.com/reference/android/os/SystemClock.html

TIL about CLOCK_BOOTTIME
http://stackoverflow.com/questions/6360210/androidlinux-uptime-using-clock-monotonic/6360726#6360726
So this is much messier and harder to fix - it's not just a windows bug!
Windows and Linux actually agree!  Both stop the clock while the
system is suspended.

From pavel.rappo at gmail.com  Wed Jan 13 06:38:06 2016
From: pavel.rappo at gmail.com (Pavel Rappo)
Date: Wed, 13 Jan 2016 11:38:06 +0000
Subject: [concurrency-interest] A case of silent cancellation of
	SubmissionPublisher's tasks
Message-ID: <CAChcVun1Gtrx=0ULPZ5sBAztmMYPYtUF-gE0neFuYD0b3v6+fA@mail.gmail.com>

Hi,

I have a question regarding a behaviour of a SubmissionPublisher. The robustness
of its asynchronous machinery relies on the fact that a task being submitted to
an executor will either run or fail eventually. In both cases an appropriate
feedback will be provided.

The cases of RejectedExecutionException upon submitting, errors during delivery
and thread interruptions are taken care of.
But what about a subtle case when the task has been submitted and later removed
from the executor's internal queue? For example, a cancellation of the submitted
task or shutting down the executor. In this case the SubmissionPublisher won't
have any feedback might end silently waiting for nothing for an
arbitrary amount of time.

Consider the following code snippet.

    public static void main(String[] args) throws InterruptedException {

        ExecutorService testSupport = Executors.newCachedThreadPool();
        ExecutorService sharedExecutor = Executors.newFixedThreadPool(1);

        CountDownLatch latch = new CountDownLatch(1);

        SubmissionPublisher<Integer> p1 = new
SubmissionPublisher<>(sharedExecutor, 1024);
        SubmissionPublisher<Integer> p2 = new
SubmissionPublisher<>(sharedExecutor, 1024);

        testSupport.execute(() -> {
            p1.subscribe(createSubscriber(latch));
            p2.subscribe(createSubscriber(latch));

            for (int i = 0; i < 100; i++)
                p1.submit(i);

            for (int i = 0; i < 100; i++)
                p2.submit(i);
        });

        testSupport.execute(() -> {
            try {
                latch.await();
            } catch (InterruptedException ignored) { }
            sharedExecutor.shutdownNow();
        });

        testSupport.shutdown();
    }

    private static Flow.Subscriber<Integer>
createSubscriber(CountDownLatch latch) {
        return new Flow.Subscriber<Integer>() {
            @Override
            public void onSubscribe(Flow.Subscription subscription) {
                subscription.request(100);
                latch.countDown();
            }

            @Override
            public void onNext(Integer integer) {
                System.out.println(this + ":" + integer);
            }

            @Override
            public void onError(Throwable throwable) { }

            @Override
            public void onComplete() { }
        };
    }

It's very probable that during a run, the subscriber attached to 'p2' won't
receive anything. Moreover, 'p2' itself won't get any errors.

Is this expected? Thanks.

-Pavel

From akarnokd at gmail.com  Wed Jan 13 08:19:41 2016
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Wed, 13 Jan 2016 14:19:41 +0100
Subject: [concurrency-interest] A case of silent cancellation of
 SubmissionPublisher's tasks
In-Reply-To: <CAChcVun1Gtrx=0ULPZ5sBAztmMYPYtUF-gE0neFuYD0b3v6+fA@mail.gmail.com>
References: <CAChcVun1Gtrx=0ULPZ5sBAztmMYPYtUF-gE0neFuYD0b3v6+fA@mail.gmail.com>
Message-ID: <CAAWwtm8e=z5gnMovp1cNeEt-8LHybiMukVO57R7Xxk2tNALEaw@mail.gmail.com>

In RxJava (1.x, 2.x and its j.u.c.Flow port), it is expected that active
flows are cancelled before the standard threadpools are shut down because
tasks have no knowledge about what they drive. Besides, if they knew,
firing onError could trigger more tasks to be scheduled and at that point,
who knows what would get through and what would fail again and again.
2016. jan. 13. 12:54 ezt ?rta ("Pavel Rappo" <pavel.rappo at gmail.com>):

> Hi,
>
> I have a question regarding a behaviour of a SubmissionPublisher. The
> robustness
> of its asynchronous machinery relies on the fact that a task being
> submitted to
> an executor will either run or fail eventually. In both cases an
> appropriate
> feedback will be provided.
>
> The cases of RejectedExecutionException upon submitting, errors during
> delivery
> and thread interruptions are taken care of.
> But what about a subtle case when the task has been submitted and later
> removed
> from the executor's internal queue? For example, a cancellation of the
> submitted
> task or shutting down the executor. In this case the SubmissionPublisher
> won't
> have any feedback might end silently waiting for nothing for an
> arbitrary amount of time.
>
> Consider the following code snippet.
>
>     public static void main(String[] args) throws InterruptedException {
>
>         ExecutorService testSupport = Executors.newCachedThreadPool();
>         ExecutorService sharedExecutor = Executors.newFixedThreadPool(1);
>
>         CountDownLatch latch = new CountDownLatch(1);
>
>         SubmissionPublisher<Integer> p1 = new
> SubmissionPublisher<>(sharedExecutor, 1024);
>         SubmissionPublisher<Integer> p2 = new
> SubmissionPublisher<>(sharedExecutor, 1024);
>
>         testSupport.execute(() -> {
>             p1.subscribe(createSubscriber(latch));
>             p2.subscribe(createSubscriber(latch));
>
>             for (int i = 0; i < 100; i++)
>                 p1.submit(i);
>
>             for (int i = 0; i < 100; i++)
>                 p2.submit(i);
>         });
>
>         testSupport.execute(() -> {
>             try {
>                 latch.await();
>             } catch (InterruptedException ignored) { }
>             sharedExecutor.shutdownNow();
>         });
>
>         testSupport.shutdown();
>     }
>
>     private static Flow.Subscriber<Integer>
> createSubscriber(CountDownLatch latch) {
>         return new Flow.Subscriber<Integer>() {
>             @Override
>             public void onSubscribe(Flow.Subscription subscription) {
>                 subscription.request(100);
>                 latch.countDown();
>             }
>
>             @Override
>             public void onNext(Integer integer) {
>                 System.out.println(this + ":" + integer);
>             }
>
>             @Override
>             public void onError(Throwable throwable) { }
>
>             @Override
>             public void onComplete() { }
>         };
>     }
>
> It's very probable that during a run, the subscriber attached to 'p2' won't
> receive anything. Moreover, 'p2' itself won't get any errors.
>
> Is this expected? Thanks.
>
> -Pavel
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160113/5b4bb12f/attachment.html>

From jason_mehrens at hotmail.com  Wed Jan 13 10:53:30 2016
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Wed, 13 Jan 2016 15:53:30 +0000
Subject: [concurrency-interest] No vacancy at the Roach Motel for
	Thread.holdsLock?
Message-ID: <BN4PR13MB0594994891B79142C1C0B05C83CB0@BN4PR13MB0594.namprd13.prod.outlook.com>

Hello c-i list,

Per http://jeremymanson.blogspot.com/2007/05/roach-motels-and-java-memory-model.html, the compiler is allowed to move code into synchronized blocks.
So given the following code:

===============
    private final Object toStringLock = new Object();

    @Override
    public String toString() {
        if (!Thread.holdsLock(toStringLock)) {
            synchronized (toStringLock) {
                return deepToString();
            }
        } else {
            return "self";
        }
    }
==============

What prevents the compiler from moving Thread.holdsLock into the synchronized block and changing the intent?  
My assumption is that there must be a happens-before  edge in holdsLock that I'm failing to identify when browsing the openjdk source.

Thanks,

Jason

From vitalyd at gmail.com  Wed Jan 13 11:23:50 2016
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 13 Jan 2016 11:23:50 -0500
Subject: [concurrency-interest] No vacancy at the Roach Motel for
	Thread.holdsLock?
In-Reply-To: <BN4PR13MB0594994891B79142C1C0B05C83CB0@BN4PR13MB0594.namprd13.prod.outlook.com>
References: <BN4PR13MB0594994891B79142C1C0B05C83CB0@BN4PR13MB0594.namprd13.prod.outlook.com>
Message-ID: <CAHjP37HcCfRX=a8b72MAz3zEppkJeo9Ufzk7zMY4g93U0cwuHw@mail.gmail.com>

holdsLock() is a native call, which lands at
http://hg.openjdk.java.net/jdk9/hs-comp/hotspot/file/7c1c2a79f981/src/share/vm/prims/jvm.cpp#l3155.
That in turn proceeds to
http://hg.openjdk.java.net/jdk9/hs-comp/hotspot/file/7c1c2a79f981/src/share/vm/runtime/synchronizer.cpp#l782,
where the core logic is implemented.

holdsLock() being a native call which does not appear to be a compiler
intrinsic means the compiler will not be able to reason about moving this
call with respect to other operations.  Probably not an overly satisfactory
answer for some folks though ...

On Wed, Jan 13, 2016 at 10:53 AM, Jason Mehrens <jason_mehrens at hotmail.com>
wrote:

> Hello c-i list,
>
> Per
> http://jeremymanson.blogspot.com/2007/05/roach-motels-and-java-memory-model.html,
> the compiler is allowed to move code into synchronized blocks.
> So given the following code:
>
> ===============
>     private final Object toStringLock = new Object();
>
>     @Override
>     public String toString() {
>         if (!Thread.holdsLock(toStringLock)) {
>             synchronized (toStringLock) {
>                 return deepToString();
>             }
>         } else {
>             return "self";
>         }
>     }
> ==============
>
> What prevents the compiler from moving Thread.holdsLock into the
> synchronized block and changing the intent?
> My assumption is that there must be a happens-before  edge in holdsLock
> that I'm failing to identify when browsing the openjdk source.
>
> Thanks,
>
> Jason
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160113/a5c8e3bd/attachment-0001.html>

From aleksey.shipilev at oracle.com  Wed Jan 13 11:48:10 2016
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 13 Jan 2016 19:48:10 +0300
Subject: [concurrency-interest] No vacancy at the Roach Motel for
 Thread.holdsLock?
In-Reply-To: <BN4PR13MB0594994891B79142C1C0B05C83CB0@BN4PR13MB0594.namprd13.prod.outlook.com>
References: <BN4PR13MB0594994891B79142C1C0B05C83CB0@BN4PR13MB0594.namprd13.prod.outlook.com>
Message-ID: <56967FCA.4030206@oracle.com>

On 01/13/2016 06:53 PM, Jason Mehrens wrote:
> Per
> http://jeremymanson.blogspot.com/2007/05/roach-motels-and-java-memory-model.html,
> the compiler is allowed to move code into synchronized blocks.

"Roach Motel" is not a generic rule that allows pulling arbitrary code
into the synchronized blocks. Its scope is mandated by what JMM and
general semantic rules allow.

The essence of "Roach Motel" interpretation is that the program behavior
after *some* transformations that effectively "pull in" the code into
sync block is still a subset of the behaviors of original program, and
thus a modification is sound.

> So given the following code:
> 
> ===============
>     private final Object toStringLock = new Object();
> 
>     @Override
>     public String toString() {
>         if (!Thread.holdsLock(toStringLock)) {
>             synchronized (toStringLock) {
>                 return deepToString();
>             }
>         } else {
>             return "self";
>         }
>     }
> ==============
> 
> What prevents the compiler from moving Thread.holdsLock into the
> synchronized block and changing the intent?

Pragmatically, two things:

 a) Thread.hasLock is native, and so the side-effects are opaque in it.
It takes an insane compiler to move the code around without
understanding what that code does.

Let's take another example though:

===============
     private final Object toStringLock = new Object();
     private boolean isAFullMoonToday;

     @Override
     public String toString() {
         if (isAFullMoonToday) { // some arbitrary predicate
             synchronized (toStringLock) {
                 return deepToString();
             }
         } else {
             return "self";
         }
     }
 ==============

 b) Moving isAFullMoonToday into the synchronized section would mean the
code *always* locks. In other words, the compiler would introduce
locking on the path that did not have any locks before -- a recipe for
deadlock. In yet another words, messing with control flow that changes
the locking order is a no-no for a compiler.

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160113/1bb79369/attachment.bin>

From openjdk at duigou.org  Wed Jan 13 17:31:27 2016
From: openjdk at duigou.org (Mike Duigou)
Date: Wed, 13 Jan 2016 14:31:27 -0800
Subject: [concurrency-interest] Github project for standalone
	CopyOnWriteArrayNavigableSet
Message-ID: <d6c90c2dcdeb1db0b8e172ff8d1e9fbc@sonic.net>

As promised in my earlier messages I have created a GitHub project for 
the standalone Java 8 compatible version of 
CopyOnWriteArrayNavigableSet. Currently the source is identical to the 
Java 9 version proposed to this list.  If there is interest (or a 
volunteer) I will probably also provide a Java 7 compatible version. I 
hope to have the module published on Maven Central soonish.

https://github.com/bondolo/cowans8

Cheers,

Mike

From aaron.grunthal at infinite-source.de  Wed Jan 13 18:01:15 2016
From: aaron.grunthal at infinite-source.de (Aaron Grunthal)
Date: Thu, 14 Jan 2016 00:01:15 +0100
Subject: [concurrency-interest] Github project for standalone
 CopyOnWriteArrayNavigableSet
In-Reply-To: <d6c90c2dcdeb1db0b8e172ff8d1e9fbc@sonic.net>
References: <d6c90c2dcdeb1db0b8e172ff8d1e9fbc@sonic.net>
Message-ID: <5696D73B.1010001@infinite-source.de>

Looking through the code I notice that the constructor can be used to
make a snapshot without copying. I think that might be worth documenting
as that's less expensive than toArray or similar operations.

And it may also be useful to also modify the CoWAL constructor to do the
same so the set can be converted to a list which can then be used for
indexed access to a snapshot.

- Aaron



On 13.01.2016 23:31, Mike Duigou wrote:
> As promised in my earlier messages I have created a GitHub project for
> the standalone Java 8 compatible version of
> CopyOnWriteArrayNavigableSet. Currently the source is identical to the
> Java 9 version proposed to this list.  If there is interest (or a
> volunteer) I will probably also provide a Java 7 compatible version. I
> hope to have the module published on Maven Central soonish.
> 
> https://github.com/bondolo/cowans8
> 
> Cheers,
> 
> Mike
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From thurston at nomagicsoftware.com  Thu Jan 14 14:07:38 2016
From: thurston at nomagicsoftware.com (thurstonn)
Date: Thu, 14 Jan 2016 12:07:38 -0700 (MST)
Subject: [concurrency-interest] No vacancy at the Roach Motel for
	Thread.holdsLock?
In-Reply-To: <56967FCA.4030206@oracle.com>
References: <BN4PR13MB0594994891B79142C1C0B05C83CB0@BN4PR13MB0594.namprd13.prod.outlook.com>
	<56967FCA.4030206@oracle.com>
Message-ID: <1452798458906-13181.post@n7.nabble.com>

I'm not sure the "blueMoon" code is analogous (since it's a POSV and may be
cached in a register, even ellided)

Although not directly related to roach motel, the OP example seems similar
to the discussion related to the memory semantics of *unpark/park*  (another
native method) which we had here about a year ago, and ultimately was left
unresolved (and is fundamental to a lot of code in j.u.c).

I suspect there are many more such examples, where there are native methods
with unspecified memory semantics that are being used (can only usefully be
used?) as if they have acquire or release semantics.

It's a problem, I think




--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/No-vacancy-at-the-Roach-Motel-for-Thread-holdsLock-tp13176p13181.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From viktor.klang at gmail.com  Fri Jan 15 07:12:17 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Fri, 15 Jan 2016 13:12:17 +0100
Subject: [concurrency-interest] A case of silent cancellation of
 SubmissionPublisher's tasks
In-Reply-To: <CAAWwtm8e=z5gnMovp1cNeEt-8LHybiMukVO57R7Xxk2tNALEaw@mail.gmail.com>
References: <CAChcVun1Gtrx=0ULPZ5sBAztmMYPYtUF-gE0neFuYD0b3v6+fA@mail.gmail.com>
	<CAAWwtm8e=z5gnMovp1cNeEt-8LHybiMukVO57R7Xxk2tNALEaw@mail.gmail.com>
Message-ID: <CANPzfU_z_SZ+vH84qWMMfPOT6EuJ9YvCd=pfeN3aAqLvv1cxBg@mail.gmail.com>

Apologies in advance for "butting in",

To generalise even further around *"The robustness*
*of its asynchronous machinery relies on the fact that a task being
submitted to*
*an executor will either run or fail eventually."*
and
*"But what about a subtle case when the task has been submitted and later
removed*
*from the executor's internal queue?"*

The only way to *try* to get around from that is to require an interface
other than *Executor*, since the guarantees of *Executor* is too weak. An
implementation of that other interface which violates its contract is
indistinguishable from a bug.



On Wed, Jan 13, 2016 at 2:19 PM, D?vid Karnok <akarnokd at gmail.com> wrote:

> In RxJava (1.x, 2.x and its j.u.c.Flow port), it is expected that active
> flows are cancelled before the standard threadpools are shut down because
> tasks have no knowledge about what they drive. Besides, if they knew,
> firing onError could trigger more tasks to be scheduled and at that point,
> who knows what would get through and what would fail again and again.
> 2016. jan. 13. 12:54 ezt ?rta ("Pavel Rappo" <pavel.rappo at gmail.com>):
>
>> Hi,
>>
>> I have a question regarding a behaviour of a SubmissionPublisher. The
>> robustness
>> of its asynchronous machinery relies on the fact that a task being
>> submitted to
>> an executor will either run or fail eventually. In both cases an
>> appropriate
>> feedback will be provided.
>>
>> The cases of RejectedExecutionException upon submitting, errors during
>> delivery
>> and thread interruptions are taken care of.
>> But what about a subtle case when the task has been submitted and later
>> removed
>> from the executor's internal queue? For example, a cancellation of the
>> submitted
>> task or shutting down the executor. In this case the SubmissionPublisher
>> won't
>> have any feedback might end silently waiting for nothing for an
>> arbitrary amount of time.
>>
>> Consider the following code snippet.
>>
>>     public static void main(String[] args) throws InterruptedException {
>>
>>         ExecutorService testSupport = Executors.newCachedThreadPool();
>>         ExecutorService sharedExecutor = Executors.newFixedThreadPool(1);
>>
>>         CountDownLatch latch = new CountDownLatch(1);
>>
>>         SubmissionPublisher<Integer> p1 = new
>> SubmissionPublisher<>(sharedExecutor, 1024);
>>         SubmissionPublisher<Integer> p2 = new
>> SubmissionPublisher<>(sharedExecutor, 1024);
>>
>>         testSupport.execute(() -> {
>>             p1.subscribe(createSubscriber(latch));
>>             p2.subscribe(createSubscriber(latch));
>>
>>             for (int i = 0; i < 100; i++)
>>                 p1.submit(i);
>>
>>             for (int i = 0; i < 100; i++)
>>                 p2.submit(i);
>>         });
>>
>>         testSupport.execute(() -> {
>>             try {
>>                 latch.await();
>>             } catch (InterruptedException ignored) { }
>>             sharedExecutor.shutdownNow();
>>         });
>>
>>         testSupport.shutdown();
>>     }
>>
>>     private static Flow.Subscriber<Integer>
>> createSubscriber(CountDownLatch latch) {
>>         return new Flow.Subscriber<Integer>() {
>>             @Override
>>             public void onSubscribe(Flow.Subscription subscription) {
>>                 subscription.request(100);
>>                 latch.countDown();
>>             }
>>
>>             @Override
>>             public void onNext(Integer integer) {
>>                 System.out.println(this + ":" + integer);
>>             }
>>
>>             @Override
>>             public void onError(Throwable throwable) { }
>>
>>             @Override
>>             public void onComplete() { }
>>         };
>>     }
>>
>> It's very probable that during a run, the subscriber attached to 'p2'
>> won't
>> receive anything. Moreover, 'p2' itself won't get any errors.
>>
>> Is this expected? Thanks.
>>
>> -Pavel
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160115/4787a1c5/attachment.html>

From jneidi.sleiman at gmail.com  Fri Jan 15 10:21:47 2016
From: jneidi.sleiman at gmail.com (Sleiman Jneidi)
Date: Fri, 15 Jan 2016 15:21:47 +0000
Subject: [concurrency-interest] Locking on local variables
Message-ID: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>

Hi everyone,

>From what I know, locking on local variables is useless, Brian Goetz in his
book gave the following as an example of a bad lock

 synchronized(new Object()){
  ..
 }

So I assume, the code above is equivalent to the following

  Object o = new Object();

 synchronized(o){
  ..
 }

However looking at ConcurrentHashMap#computeIfAbsent I see the following

Node<K,V> r = new ReservationNode<K,V>();
    synchronized (r) {
    ...
    }

Just curious, why is that?


Thanks
Sleiman
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160115/f9f1c165/attachment.html>

From dmitry.zaslavsky at gmail.com  Fri Jan 15 10:54:11 2016
From: dmitry.zaslavsky at gmail.com (Dmitry Zaslavsky)
Date: Fri, 15 Jan 2016 10:54:11 -0500
Subject: [concurrency-interest] Locking on local variables
In-Reply-To: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
References: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
Message-ID: <CAAQJ6COM2Xcb+JPKAzom1HKLUnA4aXq_jvmOxeZZqAyFZVjvKg@mail.gmail.com>

Object o = new Object();
synchronized(o){

}

The reason this code looks incorrect is that 'o' is not shared and not
known to any other thread.
Therefore you can't possibly be achieving any synchronization with any
other thread.

Consider slightly modified example

// Not local (outside of your function)
volatile Object lock = null;

// Local code
Object o = new Object();
synchronized(o){
  lock = o;
}

While this code has some other issues. At least it's potentially
meaningful. It will acquire the lock on 'o' and will publish it to the
outside world
Now some other thread can find and synchronize on it

Look at the next line in computeIfAbsent
It publishes that lock 'r' in casTabAt()


On Fri, Jan 15, 2016 at 10:21 AM, Sleiman Jneidi <jneidi.sleiman at gmail.com>
wrote:

> Hi everyone,
>
> From what I know, locking on local variables is useless, Brian Goetz in
> his book gave the following as an example of a bad lock
>
>  synchronized(new Object()){
>   ..
>  }
>
> So I assume, the code above is equivalent to the following
>
>   Object o = new Object();
>
>  synchronized(o){
>   ..
>  }
>
> However looking at ConcurrentHashMap#computeIfAbsent I see the following
>
> Node<K,V> r = new ReservationNode<K,V>();
>     synchronized (r) {
>     ...
>     }
>
> Just curious, why is that?
>
>
> Thanks
> Sleiman
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160115/c44404c1/attachment-0001.html>

From vitalyd at gmail.com  Fri Jan 15 10:58:10 2016
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 15 Jan 2016 10:58:10 -0500
Subject: [concurrency-interest] Locking on local variables
In-Reply-To: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
References: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
Message-ID: <CAHjP37HaULupQpdgV39bo3a5mdCNPoTBBq4qxfgfgfAogaKwFg@mail.gmail.com>

Looks like `r` is entered into the table within that synchronized block,
meaning it's potentially visible to other threads.  Holding its monitor
precludes other threads from observing state (as other threads will attempt
to acquire the monitor on it) until the initial insertion is complete (I'm
sure Doug can give a more thorough explanation).

On Fri, Jan 15, 2016 at 10:21 AM, Sleiman Jneidi <jneidi.sleiman at gmail.com>
wrote:

> Hi everyone,
>
> From what I know, locking on local variables is useless, Brian Goetz in
> his book gave the following as an example of a bad lock
>
>  synchronized(new Object()){
>   ..
>  }
>
> So I assume, the code above is equivalent to the following
>
>   Object o = new Object();
>
>  synchronized(o){
>   ..
>  }
>
> However looking at ConcurrentHashMap#computeIfAbsent I see the following
>
> Node<K,V> r = new ReservationNode<K,V>();
>     synchronized (r) {
>     ...
>     }
>
> Just curious, why is that?
>
>
> Thanks
> Sleiman
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160115/1876cc42/attachment.html>

From vitalyd at gmail.com  Fri Jan 15 11:07:00 2016
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 15 Jan 2016 11:07:00 -0500
Subject: [concurrency-interest] Locking on local variables
In-Reply-To: <CAHjP37HaULupQpdgV39bo3a5mdCNPoTBBq4qxfgfgfAogaKwFg@mail.gmail.com>
References: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
	<CAHjP37HaULupQpdgV39bo3a5mdCNPoTBBq4qxfgfgfAogaKwFg@mail.gmail.com>
Message-ID: <CAHjP37E3seFzc=gTrdtfGtu2ZjSYGvAsmdyUDwSCKjy2oO+Meg@mail.gmail.com>

All that to say `r` is not a local in the sense Brian's book intended; the
book ought to have called this a temporary, not a local.  But perhaps a
better description still is "thread local" (or "non-escaping" with escape
referring to sharing between threads, etc).

On Fri, Jan 15, 2016 at 10:58 AM, Vitaly Davidovich <vitalyd at gmail.com>
wrote:

> Looks like `r` is entered into the table within that synchronized block,
> meaning it's potentially visible to other threads.  Holding its monitor
> precludes other threads from observing state (as other threads will attempt
> to acquire the monitor on it) until the initial insertion is complete (I'm
> sure Doug can give a more thorough explanation).
>
> On Fri, Jan 15, 2016 at 10:21 AM, Sleiman Jneidi <jneidi.sleiman at gmail.com
> > wrote:
>
>> Hi everyone,
>>
>> From what I know, locking on local variables is useless, Brian Goetz in
>> his book gave the following as an example of a bad lock
>>
>>  synchronized(new Object()){
>>   ..
>>  }
>>
>> So I assume, the code above is equivalent to the following
>>
>>   Object o = new Object();
>>
>>  synchronized(o){
>>   ..
>>  }
>>
>> However looking at ConcurrentHashMap#computeIfAbsent I see the following
>>
>> Node<K,V> r = new ReservationNode<K,V>();
>>     synchronized (r) {
>>     ...
>>     }
>>
>> Just curious, why is that?
>>
>>
>> Thanks
>> Sleiman
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160115/c3dc90fe/attachment.html>

From godmar at gmail.com  Fri Jan 15 11:09:30 2016
From: godmar at gmail.com (Godmar Back)
Date: Fri, 15 Jan 2016 11:09:30 -0500
Subject: [concurrency-interest] Locking on local variables
In-Reply-To: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
References: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
Message-ID: <CAB4+JYJiRuV=CC8VmtYLSFzMFq6xNEtieZFs1b5Bj6z76LaY-A@mail.gmail.com>

r is not a local variable (in the sense that it doesn't escape), you missed:

               Node<K,V> r = new ReservationNode<K,V>();
                synchronized (r) {
                    if (casTabAt(tab, i, null, *r*)) {



On Fri, Jan 15, 2016 at 10:21 AM, Sleiman Jneidi <jneidi.sleiman at gmail.com>
wrote:

> Hi everyone,
>
> From what I know, locking on local variables is useless, Brian Goetz in
> his book gave the following as an example of a bad lock
>
>  synchronized(new Object()){
>   ..
>  }
>
> So I assume, the code above is equivalent to the following
>
>   Object o = new Object();
>
>  synchronized(o){
>   ..
>  }
>
> However looking at ConcurrentHashMap#computeIfAbsent I see the following
>
> Node<K,V> r = new ReservationNode<K,V>();
>     synchronized (r) {
>     ...
>     }
>
> Just curious, why is that?
>
>
> Thanks
> Sleiman
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160115/c89256e6/attachment.html>

From thurston at nomagicsoftware.com  Fri Jan 15 14:20:56 2016
From: thurston at nomagicsoftware.com (thurstonn)
Date: Fri, 15 Jan 2016 12:20:56 -0700 (MST)
Subject: [concurrency-interest] Locking on local variables
In-Reply-To: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
References: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
Message-ID: <1452885656616-13188.post@n7.nabble.com>

Just curious, is this something the JIT optimizes?
It is provable that the lock will be uncontended at the point of
monitorenter; on the other hand, it's an unusual pattern so probably low
priority among all things that could be optimized



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Locking-on-local-variables-tp13183p13188.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From aaron.grunthal at infinite-source.de  Fri Jan 15 16:32:14 2016
From: aaron.grunthal at infinite-source.de (Aaron Grunthal)
Date: Fri, 15 Jan 2016 22:32:14 +0100
Subject: [concurrency-interest] Locking on local variables
In-Reply-To: <1452885656616-13188.post@n7.nabble.com>
References: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
	<1452885656616-13188.post@n7.nabble.com>
Message-ID: <5699655E.4070804@infinite-source.de>

That's part of escape analysis.

http://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis

On 15.01.2016 20:20, thurstonn wrote:
> Just curious, is this something the JIT optimizes?
> It is provable that the lock will be uncontended at the point of
> monitorenter; on the other hand, it's an unusual pattern so probably low
> priority among all things that could be optimized
> 
> 
> 
> --
> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Locking-on-local-variables-tp13183p13188.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From martinrb at google.com  Fri Jan 15 16:51:33 2016
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 15 Jan 2016 13:51:33 -0800
Subject: [concurrency-interest] Locking on local variables
In-Reply-To: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
References: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
Message-ID: <CA+kOe08Ynm0KfQy4zDsRiR7Lo3SXU4MBnhi+-MEMByAgTAxitA@mail.gmail.com>

On Fri, Jan 15, 2016 at 7:21 AM, Sleiman Jneidi
<jneidi.sleiman at gmail.com> wrote:

> From what I know, locking on local variables is useless

The key observation is that you can't synchronize on variables, only on objects.

From vitalyd at gmail.com  Fri Jan 15 17:17:03 2016
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 15 Jan 2016 17:17:03 -0500
Subject: [concurrency-interest] Locking on local variables
In-Reply-To: <1452885656616-13188.post@n7.nabble.com>
References: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
	<1452885656616-13188.post@n7.nabble.com>
Message-ID: <CAHjP37Fjx8BqzPna2yTX0nLAozvgpUjj8u1nFz6EhYBS=FsVog@mail.gmail.com>

What type of optimization are you thinking of? The lock needs to be
acquired and held for the duration since the object escapes almost
immediately there.

On Friday, January 15, 2016, thurstonn <thurston at nomagicsoftware.com> wrote:

> Just curious, is this something the JIT optimizes?
> It is provable that the lock will be uncontended at the point of
> monitorenter; on the other hand, it's an unusual pattern so probably low
> priority among all things that could be optimized
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/Locking-on-local-variables-tp13183p13188.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <javascript:;>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160115/e1e7a24f/attachment.html>

From martinrb at google.com  Fri Jan 15 17:26:27 2016
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 15 Jan 2016 14:26:27 -0800
Subject: [concurrency-interest] Locking on local variables
In-Reply-To: <5699655E.4070804@infinite-source.de>
References: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
	<1452885656616-13188.post@n7.nabble.com>
	<5699655E.4070804@infinite-source.de>
Message-ID: <CA+kOe0-fCoKe-7b0mGJB-3NTLKD-+KM67u5dfentYWh3uro77w@mail.gmail.com>

On Fri, Jan 15, 2016 at 1:32 PM, Aaron Grunthal
<aaron.grunthal at infinite-source.de> wrote:
> That's part of escape analysis.
>
> http://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis

In this case the object does escape, but we can optimize operations
that occur while the object is provably thread-confined.  When we
implement synchronizers in Java, we often hand-optimize by using e.g.
Unsafe.putInt on volatile fields before publication.

From vitalyd at gmail.com  Fri Jan 15 17:57:50 2016
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 15 Jan 2016 17:57:50 -0500
Subject: [concurrency-interest] Locking on local variables
In-Reply-To: <CA+kOe0-fCoKe-7b0mGJB-3NTLKD-+KM67u5dfentYWh3uro77w@mail.gmail.com>
References: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
	<1452885656616-13188.post@n7.nabble.com>
	<5699655E.4070804@infinite-source.de>
	<CA+kOe0-fCoKe-7b0mGJB-3NTLKD-+KM67u5dfentYWh3uro77w@mail.gmail.com>
Message-ID: <CAHjP37GUPbnJF3V_GNx5XJh_YeNKdQi+3s7ZO7L4jKGcJUB7gw@mail.gmail.com>

You need a control flow sensitive EA pass, which Hotspot doesn't have
(graal does though), to even enable such optimization from compiler.  Not
sure cost/benefit is in favor of this since hand rolling such things is
pretty easy.

On Friday, January 15, 2016, Martin Buchholz <martinrb at google.com> wrote:

> On Fri, Jan 15, 2016 at 1:32 PM, Aaron Grunthal
> <aaron.grunthal at infinite-source.de <javascript:;>> wrote:
> > That's part of escape analysis.
> >
> >
> http://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis
>
> In this case the object does escape, but we can optimize operations
> that occur while the object is provably thread-confined.  When we
> implement synchronizers in Java, we often hand-optimize by using e.g.
> Unsafe.putInt on volatile fields before publication.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <javascript:;>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160115/563c484d/attachment.html>

From thurston at nomagicsoftware.com  Sun Jan 17 09:56:43 2016
From: thurston at nomagicsoftware.com (thurstonn)
Date: Sun, 17 Jan 2016 07:56:43 -0700 (MST)
Subject: [concurrency-interest] Locking on local variables
In-Reply-To: <CAHjP37Fjx8BqzPna2yTX0nLAozvgpUjj8u1nFz6EhYBS=FsVog@mail.gmail.com>
References: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
	<1452885656616-13188.post@n7.nabble.com>
	<CAHjP37Fjx8BqzPna2yTX0nLAozvgpUjj8u1nFz6EhYBS=FsVog@mail.gmail.com>
Message-ID: <1453042603501-13194.post@n7.nabble.com>

Vitaly Davidovich wrote
> What type of optimization are you thinking of? The lock needs to be
> acquired and held for the duration since the object escapes almost
> immediately there.

As I wrote, the  optimization would follow from the observation that the
monitor is provably uncontended.
Presumably, optimization would be something along the lines of a volatile
write vis a vis a CAS.

Now, there's already been a great deal of effort put into JVMs to make
uncontended monitor acquisition cheap (biased, lightweight monitors), so
it's already fairly cheap



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Locking-on-local-variables-tp13183p13194.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From radhakrishnan.mohan at gmail.com  Mon Jan 18 07:14:43 2016
From: radhakrishnan.mohan at gmail.com (Mohan Radhakrishnan)
Date: Mon, 18 Jan 2016 17:44:43 +0530
Subject: [concurrency-interest] Locking on local variables
In-Reply-To: <1453042603501-13194.post@n7.nabble.com>
References: <CA+9AD=BAJEqSUjFWwbLzjCk+UKqDWNMFWPZ+fqKcEb49BE7Dzw@mail.gmail.com>
	<1452885656616-13188.post@n7.nabble.com>
	<CAHjP37Fjx8BqzPna2yTX0nLAozvgpUjj8u1nFz6EhYBS=FsVog@mail.gmail.com>
	<1453042603501-13194.post@n7.nabble.com>
Message-ID: <CAOoXFP9cB+NWojiUc0zRt45StAKh8g1kqG5cMCDcm6OmJFhnXQ@mail.gmail.com>

I understand that there is a switch to enable biased locking. What are
lightweight
monitors ? Thin locks/fat locks ?

Thanks,
Mohan

On 17 January 2016 at 20:26, thurstonn <thurston at nomagicsoftware.com> wrote:

> Vitaly Davidovich wrote
> > What type of optimization are you thinking of? The lock needs to be
> > acquired and held for the duration since the object escapes almost
> > immediately there.
>
> As I wrote, the  optimization would follow from the observation that the
> monitor is provably uncontended.
> Presumably, optimization would be something along the lines of a volatile
> write vis a vis a CAS.
>
> Now, there's already been a great deal of effort put into JVMs to make
> uncontended monitor acquisition cheap (biased, lightweight monitors), so
> it's already fairly cheap
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/Locking-on-local-variables-tp13183p13194.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160118/3c0b06c5/attachment.html>

From timo.kinnunen at gmail.com  Tue Jan 19 12:34:07 2016
From: timo.kinnunen at gmail.com (Timo Kinnunen)
Date: Tue, 19 Jan 2016 18:34:07 +0100
Subject: [concurrency-interest]
	JDK-8146527:	Absolute	Scheduling	/	Requestfor Comments
In-Reply-To: <010e01d14cb2$04e39b50$0eaad1f0$@aapt.net.au>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<EA0C7F1B-3917-4E17-A27D-37DCE4F17DF5@gmail.com>
	<009001d14ade$43383fd0$c9a8bf70$@eu>
	<8BBE3708-DC1B-44E4-AD01-49342C3E86B8@gmail.com>
	<00ac01d14ae5$b0628d70$1127a850$@eu>
	<006001d14b01$c85b6b60$59124220$@gmail.com>
	<EE8F7E94-8BEC-47CF-9D76-049944F08B6B@gmail.com>
	<00da01d14bf8$4f9c9710$eed5c530$@aapt.net.au>
	<014a01d14c8f$2533ef90$6f9bceb0$@eu>
	<010e01d14cb2$04e39b50$0eaad1f0$@aapt.net.au>
Message-ID: <569e739d.a85fc20a.6917f.ffff817d@mx.google.com>

Hi, 

I find this hard to believe. According to MSDN, these functions are available:


Includes sleeping time
Adjusted to external time reference 
Highest resolution
QueryPerformanceCounter, QueryUnbiasedInterruptTimePrecise
No
No
Yes
GetSystemTimePreciseAsFileTime
Yes
Yes
Yes
QueryInterruptTimePrecise
Yes
No
Yes
GetSystemTimeAsFileTime
Yes
Yes
No
GetTickCount64, QueryInterruptTime
Yes
No
No
QueryUnbiasedInterruptTime
No
No
No
Since synchronizing time to an external UTC time source implies tracking time that elapses during system sleep, that table covers all possible combinations.

Let it not be said that Windows doesn?t have enough clocks ?? 






-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10

From: David Holmes
Sent: Monday, January 11, 2016 22:16
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Requestfor Comments

Markus KARG writes:
> 
> The Windows OS _does_ provide different types of clocks.

Not to the extent described by Alex ie relative clocks that track across suspension, relative clocks that don't. There is only a single relative time clock and a single absolute time clock - and the Windows synchronization API's don't let you specify which clock you want to use for timeouts - they are simply relative with whatever suspension semantics windows has chosen.

David
-------
 
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of David Holmes
> Sent: Sonntag, 10. Januar 2016 23:43
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> Request for Comments
> 
> I think Alex hits the nail on the head here. For these API's to work "correctly"
> in these difference contexts we have to make "time" an explicit part of the
> API and in particular we do need a notion of different Clocks that represent
> different kinds of "time". The Real-time Specification for Java did try to go
> down this path but ran into serious practical limitations - if the operating
> system doesn't support different kinds of clocks and the API's they expose
> don't allow control of the clocks involved, then implementing such
> abstractions in an efficient and practical way is exceedingly difficult, to say
> the least.
> 
> David
> -------
> 
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of Alex Otenko
> > Sent: Sunday, January 10, 2016 12:04 PM
> > To: Nathan & Ila Reynolds <nathanila at gmail.com>
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> >
> > I would expect these to be case-specific.
> >
> > The flow of time is different in different frames of reference. Mailer wants
> it
> > to be tied to the frame of reference coinciding with mail server (which is in
> > the same frame as Greenwich), Sudoku game wants it tied to the frame of
> > reference coinciding with Sudoku process space - it doesn?t want to count
> > time towards the score whilst the game is not in the foreground.
> >
> > It would be nice to have a replaceable clock, or the source of time for
> > individual condvars.
> >
> > Alex
> >
> > > On 9 Jan 2016, at 17:18, Nathan & Ila Reynolds <nathanila at gmail.com>
> > wrote:
> > >
> > > Also, Windows fires an event to all applications when the system
> resumes
> > after hibernation.  You could use that event instead of polling.
> > >
> > > ScheduledExecutorService provides schedule(), scheduleAtFixedRate()
> and
> > scheduleWithFixedDelay().  I expect schedule() to run the command at or
> > very soon after the delay or as soon as the machine resumes if the delay
> has
> > elapsed.  I expect scheduleAtFixedRate() to run the command N times
> > rapidly if hibernation lasted N periods.  I expect scheduleWithFixedDelay()
> to
> > run the command one time at or very soon after the delay or as soon as the
> > machine resumes.  In this regard, the programmer has control whether
> they
> > need N times or 1 time after hibernation.  I only use scheduleAtFixedRate()
> if
> > I have something staying in sync with the passage of time.  I use
> > scheduleWithFixedDelay() in all other cases because if the command takes
> a
> > long time, I don't need it to run right away.
> > >
> > >
> >
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledE
> > xecutorService.html
> > >
> > > -Nathan
> > >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of Markus KARG
> > > Sent: Saturday, January 09, 2016 6:58 AM
> > > To: 'Carsten Schipke' <carsten.schipke at gmail.com>
> > > Cc: concurrency-interest at cs.oswego.edu
> > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> > >
> > > Carsten,
> > >
> > > the Windows API provides several different methods for timing. Some of
> > them are definitively able to fire at a particular point in time, independent
> of
> > any hibernation.
> > >
> > > In case a different OS won't have such a factility, there is a simple fallback:
> > Triggering events more often, checking the actual time (in pure Java), so
> we
> > find out whether to wait further, or whether the event is to be fired. This,
> > BTW, is the workaround applied by pure Java solutions currently, hence
> what
> > I'd like to get rid off by this feature request. :-)
> > >
> > > -Markus
> > >
> > >
> > > -----Original Message-----
> > > From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > > Sent: Samstag, 9. Januar 2016 14:09
> > > To: Markus KARG
> > > Cc: concurrency-interest at cs.oswego.edu
> > > Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> > >
> > > sure, as I mentioned, I have never really had that requirement, it just
> > sounded to me like many programmers could have many slightly different
> > requirements on such an API. I also don?t know what the Windows API
> > offers in those regards / how its solved there, but if there is such a widely
> > accepted solution, then it surely would make sense as you say.
> > >
> > >
> > >> On Jan 9, 2016, at 21:04, Markus KARG <markus at headcrashing.eu>
> > wrote:
> > >>
> > >> I think it should be up to the programmer (e. g. by passing a flag or using
> > different methods) whether he wants 10 events after missing those while
> > hibernation, or whether he wants the events to be collapsed into one
> single
> > event alternatively. BTW, I never said that the API must support an
> absolute
> > variant of repeated event schedulung. You could also simply provide an
> > absolute variant of the "fire ONCE" method, and the mail application has to
> > reschedule inside of the event handler.
> > >>
> > >> Hooks are out of scope for my proposal, as they solve a different
> problem
> > and are working on a deeper level (the scheduler API could certainly make
> > use of such hooks). In case the Windows API for example would be able to
> > solve the problem for us (it is, BTW), why shouldn't we provide a Java API
> > wrapping that (without running into any rattail, as we simply offload)?
> > >>
> > >> -Markus
> > >>
> > >> -----Original Message-----
> > >> From: Carsten Schipke [mailto:carsten.schipke at gmail.com]
> > >> Sent: Samstag, 9. Januar 2016 11:02
> > >> To: Markus KARG
> > >> Cc: concurrency-interest at cs.oswego.edu
> > >> Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling /
> > Request for Comments
> > >>
> > >> ?...or it will fire instantly after the end of hibernation ?? considering your
> > example of hourly/periodically checking mails, that would mean that the
> > program checks your mailbox 10 times at once after 10h hibernation.
> > >> So the API would also need to know whether unfired events should
> > queue up over time. Sounds like a rattail pulling endlessly use cases &
> > requirements behind it.
> > >>
> > >> I for one never thought about using the JVM to schedule things that live
> > through hibernation or similar (not knowing the original intention of the
> API).
> > But I have also never built daemon-like desktop/client
> applications/services.
> > >>
> > >> I guess in case of JVM, one could argue that specifications only apply at
> > runtime, and hibernation is interrupting that. Maybe it would be better to
> > provide hooks e.g. in the Runtime class to allow callbacks on pre-/post-
> > hibernation, standby, signals etc. Then one could de/attach events
> > accordingly.
> > >>
> > >>
> > >>> On Jan 9, 2016, at 17:28, Markus KARG <markus at headcrashing.eu>
> > wrote:
> > >>>
> > >>> The following requests comments on a Feature Proposal for Absolute
> > Scheduling.
> > >>>
> > >>> OpenJDK ticket JDK-8146527
> > (https://bugs.openjdk.java.net/browse/JDK-8146527) describes the
> > following case:
> > >>>
> > >>> * ScheduledExecutorService.schedule() is invoked to schedule firing of
> > an event "in one minute".
> > >>> * The laptop lid gets closed instantly after that, so hibernation will
> occur,
> > hence the JVM will suspend.
> > >>> * After thirty seconds of hibernation, the laptop lid gets openen, so
> > hibernation will cancel and the JVM resumes.
> > >>> * Despite the expected result (one minute after start of program the
> > event does occur), the event actually is delayed by the length of the
> > hibernation phase, and happens 90 seconds after the program was started.
> > In the expectation of the end user, the event fired 30 seconds "too late"!
> > >>>
> > >>> This is annoying to users and rather unexpected and astonishing for
> > programmers literally following the words of the JavaDocs. Clearly the
> > provided deadline is a relative value in the physical sense ("one minute
> from
> > now, independent of what 'now' is currently like"), but certainly what the
> > user actually expects it to work like is an absolute value in the physical
> sense
> > ("one minute from now, where 'now' is the current point on the time axis
> of
> > the Universe, hence unaffected by hibernation). Whether or not the
> laptop
> > was closed temporarily in the meantime plays no role to the expectation of
> > neither the end user nor the application provider.
> > >>>
> > >>> Unfortunately there is no other API that allows the application vendor
> to
> > define that the deadline it meant to be unaffected of hibernation. Clearly
> > this is a drawback to the Java platform, as many applications need such a
> > behaviour (like "check my mails once per hour" - if you open your laptop lid
> > ONLY for a few minutes to see whether meanwhile new emails arrived or
> not
> > [like, BTW, some laptops are able to perform these days, even with the lid
> > closed, thanks to a BIOS timer] you won't receive any new emails ever as
> > "JVM" time progresses only be few minutes per day then).
> > >>>
> > >>> A solution could be the addition of a special variant of
> > ScheduledExecutorService.schedule(absoluteInstant) which is unaffected
> of
> > any hibernation, and will fire either exactly at the absoluteInstant (in case
> the
> > laptop is not hibernating _currently_), or it will fire instantly after the end
> of
> > hibernation, in case the laptop was hibernating at absoluteInstant.
> > >>>
> > >>> There are two possible ways to reach this: Either there is an OS-specific
> > API that alrady provides exactly that behaviour, or the JVM needs to be
> > informed every 'x' fractions of "discontinuous jvm time" to find out how
> > much "continuous real world time" has advanced and whether a scheduled
> > event was missed meanwhile (which is the workaround such applications
> > have to perform on their own currently to workaround the problem). The
> > first is problematic due to changes in the implementations of the APIs (e. g.
> > Windows changed some APIs from "continuous time" to using
> > "discontinuous time"), the second is complex in finding the optimal value of
> > 'x' (too low means high power consumption, too high means firing too late
> > after the deadline).
> > >>>
> > >>> Side note: To be unambiguous, the new deadline should possibly be
> > typed as java.time.Instant, as that could never be misunderstood as
> > "discontinous jvm time" inherently.
> > >>>
> > >>> What is your opinion on that?
> > >>>
> > >>> -Markus
> > >>> _______________________________________________
> > >>> Concurrency-interest mailing list
> > >>> Concurrency-interest at cs.oswego.edu
> > >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >>
> > >>
> > >
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160119/54fc20f1/attachment-0001.html>

From timo.kinnunen at gmail.com  Tue Jan 19 12:51:08 2016
From: timo.kinnunen at gmail.com (Timo Kinnunen)
Date: Tue, 19 Jan 2016 18:51:08 +0100
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
 Requestfor Comments
In-Reply-To: <CA+kOe09uixLrGk_Kavj8Vaq99PEvwBYQN2O_UZ+GwfytH3bQhw@mail.gmail.com>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<5694ED44.6000202@cs.oswego.edu>
	<CA+kOe09uixLrGk_Kavj8Vaq99PEvwBYQN2O_UZ+GwfytH3bQhw@mail.gmail.com>
Message-ID: <569e7797.01adc20a.fd20d.fffff785@mx.google.com>

Hi, 

Well it also depends on which function we are talking about. If it is the WaitForSingleObject function then this has apparently changed from Windows 8 onwards, according to MSDN: 

?Windows?XP, Windows Server?2003, Windows?Vista, Windows?7, Windows Server?2008, and Windows Server?2008?R2:??The dwMilliseconds value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.

Windows?8, Windows Server?2012, Windows?8.1, Windows Server?2012?R2, Windows?10, and Windows Server?2016 Technical Preview:??The dwMilliseconds value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.?
 
I haven?t looked at how Object.wait(long) is implemented but if it is using WaitForSingleObject (or the same clock it uses) then it too may be affected. The API documentation promises that one condition for resuming is that ?The specified amount of real time has elapsed, more or less?, referring to the specified timeout parameter. So while sleeping a total 90 seconds when only 60 seconds was specified might still be technically within the specification, it?s really pushing it.






-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10

From: Martin Buchholz
Sent: Tuesday, January 12, 2016 20:09
To: Doug Lea
Cc: concurrency-interest
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Requestfor Comments

On Tue, Jan 12, 2016 at 4:10 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> The Right Thing should also be compatible with how Android
> deals with deep-sleep etc. See
> http://developer.android.com/reference/android/os/SystemClock.html

TIL about CLOCK_BOOTTIME
http://stackoverflow.com/questions/6360210/androidlinux-uptime-using-clock-monotonic/6360726#6360726
So this is much messier and harder to fix - it's not just a windows bug!
Windows and Linux actually agree!  Both stop the clock while the
system is suspended.
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160119/81d519db/attachment.html>

From davidcholmes at aapt.net.au  Tue Jan 19 15:27:06 2016
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 20 Jan 2016 06:27:06 +1000
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling /
	Requestfor Comments
In-Reply-To: <569e7797.01adc20a.fd20d.fffff785@mx.google.com>
References: <002501d14ac0$28189150$7849b3f0$@eu>	<5694ED44.6000202@cs.oswego.edu>	<CA+kOe09uixLrGk_Kavj8Vaq99PEvwBYQN2O_UZ+GwfytH3bQhw@mail.gmail.com>
	<569e7797.01adc20a.fd20d.fffff785@mx.google.com>
Message-ID: <000901d152f7$c4245450$4c6cfcf0$@aapt.net.au>

Thanks for that info Timo, I hadn?t  seen that - we use WaitForMultipleObjects in the VM for everything (there is an event for interruption and an event for actually ?parking? the thread),and its MSDN page says nothing about this ? which is very odd because the two functions should behave the same. It is interesting to see that MS is moving away from having these core API functions continue to track time across ?sleep? states.

 

David

 

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Timo Kinnunen
Sent: Wednesday, January 20, 2016 3:51 AM
To: Martin Buchholz <martinrb at google.com>; Doug Lea <dl at cs.oswego.edu>
Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Requestfor Comments

 

Hi, 

 

Well it also depends on which function we are talking about. If it is the WaitForSingleObject <https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx>  function then this has apparently changed from Windows 8 onwards, according to MSDN: 

 

?Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008, and Windows Server 2008 R2:  The dwMilliseconds value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.

 

Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10, and Windows Server 2016 Technical Preview:  The dwMilliseconds value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.?

 

I haven?t looked at how Object.wait(long) is implemented but if it is using WaitForSingleObject (or the same clock it uses) then it too may be affected. The API documentation promises that one condition for resuming is that ?The specified amount of real time has elapsed, more or less?, referring to the specified timeout parameter. So while sleeping a total 90 seconds when only 60 seconds was specified might still be technically within the specification, it?s really pushing it.

 






-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10

 

From: Martin Buchholz <mailto:martinrb at google.com> 
Sent: Tuesday, January 12, 2016 20:09
To: Doug Lea <mailto:dl at cs.oswego.edu> 
Cc: concurrency-interest <mailto:concurrency-interest at cs.oswego.edu> 
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Requestfor Comments

 

On Tue, Jan 12, 2016 at 4:10 AM, Doug Lea <dl at cs.oswego.edu <mailto:dl at cs.oswego.edu> > wrote:

 

> The Right Thing should also be compatible with how Android

> deals with deep-sleep etc. See

> http://developer.android.com/reference/android/os/SystemClock.html

 

TIL about CLOCK_BOOTTIME

http://stackoverflow.com/questions/6360210/androidlinux-uptime-using-clock-monotonic/6360726#6360726

So this is much messier and harder to fix - it's not just a windows bug!

Windows and Linux actually agree!  Both stop the clock while the

system is suspended.

_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> 

http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160120/9a114f20/attachment.html>

From timo.kinnunen at gmail.com  Tue Jan 19 16:17:16 2016
From: timo.kinnunen at gmail.com (Timo Kinnunen)
Date: Tue, 19 Jan 2016 22:17:16 +0100
Subject: [concurrency-interest] JDK-8146527: Absolute Scheduling
 /Requestfor Comments
In-Reply-To: <000901d152f7$c4245450$4c6cfcf0$@aapt.net.au>
References: <002501d14ac0$28189150$7849b3f0$@eu>
	<5694ED44.6000202@cs.oswego.edu>
	<CA+kOe09uixLrGk_Kavj8Vaq99PEvwBYQN2O_UZ+GwfytH3bQhw@mail.gmail.com>
	<569e7797.01adc20a.fd20d.fffff785@mx.google.com>
	<000901d152f7$c4245450$4c6cfcf0$@aapt.net.au>
Message-ID: <569ea7e7.a867c20a.88a60.ffffa83c@mx.google.com>

It is a bit odd but I think it?s because it?s a corner case and also because it isn?t technically a change in the wait functions. If you read them carefully, the timeout interval is given in milliseconds but the actual wait time is defined in terms of ?ticks?; and the change is in how many ticks occur while the system is sleeping. The millisecond parameter is only for convenience and intuitiveness when deciding how many ticks to wait until the timeout will have elapsed.


I think for the scheduling issue, the function you?d want would be SetWaitableTimer with relative times converted to absolute UTC time. That way changes to the system clock should get reflected in the timer waiting times automatically. In addition, setting the resume parameter should bring up the system back from power conservation states ? provided the system has support for this -- if the timer expiration time ends up occurring during sleep.






-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10

From: David Holmes
Sent: Tuesday, January 19, 2016 21:27
To: 'Timo Kinnunen'; 'Martin Buchholz'; 'Doug Lea'
Cc: 'concurrency-interest'
Subject: RE: [concurrency-interest] JDK-8146527: Absolute Scheduling /Requestfor Comments

Thanks for that info Timo, I hadn?t ?seen that - we use WaitForMultipleObjects in the VM for everything (there is an event for interruption and an event for actually ?parking? the thread),and its MSDN page says nothing about this ? which is very odd because the two functions should behave the same. It is interesting to see that MS is moving away from having these core API functions continue to track time across ?sleep? states.

David

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Timo Kinnunen
Sent: Wednesday, January 20, 2016 3:51 AM
To: Martin Buchholz <martinrb at google.com>; Doug Lea <dl at cs.oswego.edu>
Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Requestfor Comments

Hi, 

Well it also depends on which function we are talking about. If it is the WaitForSingleObject function then this has apparently changed from Windows 8 onwards, according to MSDN: 

?Windows?XP, Windows Server?2003, Windows?Vista, Windows?7, Windows Server?2008, and Windows Server?2008?R2:??The dwMilliseconds value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.

Windows?8, Windows Server?2012, Windows?8.1, Windows Server?2012?R2, Windows?10, and Windows Server?2016 Technical Preview:??The dwMilliseconds value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.?

I haven?t looked at how Object.wait(long) is implemented but if it is using WaitForSingleObject (or the same clock it uses) then it too may be affected. The API documentation promises that one condition for resuming is that ?The specified amount of real time has elapsed, more or less?, referring to the specified timeout parameter. So while sleeping a total 90 seconds when only 60 seconds was specified might still be technically within the specification, it?s really pushing it.






-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10

From: Martin Buchholz
Sent: Tuesday, January 12, 2016 20:09
To: Doug Lea
Cc: concurrency-interest
Subject: Re: [concurrency-interest] JDK-8146527: Absolute Scheduling / Requestfor Comments

On Tue, Jan 12, 2016 at 4:10 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> The Right Thing should also be compatible with how Android
> deals with deep-sleep etc. See
> http://developer.android.com/reference/android/os/SystemClock.html

TIL about CLOCK_BOOTTIME
http://stackoverflow.com/questions/6360210/androidlinux-uptime-using-clock-monotonic/6360726#6360726
So this is much messier and harder to fix - it's not just a windows bug!
Windows and Linux actually agree!? Both stop the clock while the
system is suspended.
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160119/9988bdf7/attachment-0001.html>

From oleksandr.otenko at gmail.com  Mon Jan 25 09:26:23 2016
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 25 Jan 2016 14:26:23 +0000
Subject: [concurrency-interest] No vacancy at the Roach Motel for
	Thread.holdsLock?
In-Reply-To: <56967FCA.4030206@oracle.com>
References: <BN4PR13MB0594994891B79142C1C0B05C83CB0@BN4PR13MB0594.namprd13.prod.outlook.com>
	<56967FCA.4030206@oracle.com>
Message-ID: <3E39CB4A-4323-47CB-9B42-8FC4B2A21487@gmail.com>

The problem with this example is not the compiler making good or bad decisions, but someone making decisions whether to lock based on values that aren?t part of synchronization order.

Alex


> On 13 Jan 2016, at 16:48, Aleksey Shipilev <aleksey.shipilev at oracle.com> wrote:
> 
> On 01/13/2016 06:53 PM, Jason Mehrens wrote:
>> Per
>> http://jeremymanson.blogspot.com/2007/05/roach-motels-and-java-memory-model.html,
>> the compiler is allowed to move code into synchronized blocks.
> 
> "Roach Motel" is not a generic rule that allows pulling arbitrary code
> into the synchronized blocks. Its scope is mandated by what JMM and
> general semantic rules allow.
> 
> The essence of "Roach Motel" interpretation is that the program behavior
> after *some* transformations that effectively "pull in" the code into
> sync block is still a subset of the behaviors of original program, and
> thus a modification is sound.
> 
>> So given the following code:
>> 
>> ===============
>>    private final Object toStringLock = new Object();
>> 
>>    @Override
>>    public String toString() {
>>        if (!Thread.holdsLock(toStringLock)) {
>>            synchronized (toStringLock) {
>>                return deepToString();
>>            }
>>        } else {
>>            return "self";
>>        }
>>    }
>> ==============
>> 
>> What prevents the compiler from moving Thread.holdsLock into the
>> synchronized block and changing the intent?
> 
> Pragmatically, two things:
> 
> a) Thread.hasLock is native, and so the side-effects are opaque in it.
> It takes an insane compiler to move the code around without
> understanding what that code does.
> 
> Let's take another example though:
> 
> ===============
>     private final Object toStringLock = new Object();
>     private boolean isAFullMoonToday;
> 
>     @Override
>     public String toString() {
>         if (isAFullMoonToday) { // some arbitrary predicate
>             synchronized (toStringLock) {
>                 return deepToString();
>             }
>         } else {
>             return "self";
>         }
>     }
> ==============
> 
> b) Moving isAFullMoonToday into the synchronized section would mean the
> code *always* locks. In other words, the compiler would introduce
> locking on the path that did not have any locks before -- a recipe for
> deadlock. In yet another words, messing with control flow that changes
> the locking order is a no-no for a compiler.
> 
> Thanks,
> -Aleksey
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From christian.schudt at gmx.de  Tue Jan 26 15:42:51 2016
From: christian.schudt at gmx.de (Christian Schudt)
Date: Tue, 26 Jan 2016 21:42:51 +0100
Subject: [concurrency-interest] CompletionStage / read-only
	CompletableFuture / design-by-UOE ?
Message-ID: <4AA2B89B-C357-44D9-9A06-68B1D4816AE3@gmx.de>

Hi,

I want to design an API which returns ?read-only? CompletableFutures, because I don?t want the API user to be able to complete the future. Instead only internal triggers of my library should complete it.
(Same requirement as in [1]).

After some research, the preferred way to achieve this, seems to be to simply return CompletionStage, which is kind of the read-only interface.
However, a user could still complete it by calling: toCompletableFuture().complete(...);

To prevent this, I throw an UnsupportedOperationException in toCompletableFuture(), in accordance with the JavaDoc.

However, composing/chaining multiple CompletionStages then no longer works, because they internally call toCompletableFuture().
JavaDoc says it does not "interoperate with others? then, but is that really necessary?


The JDK 9 JavaDocs [2] have an example which subclasses CompletableFuture, which ?disables? some the ?complete? methods by throwing UOE.
This post [3] also suggests a "design-by-UOE?, but still I am feeling uncomfortable with it, I?d rather return the minimal CompletionStage.

What would be the preferred way to do this?

class MyReadOnlyCompletableFuture extends CompletableFuture {
	// override all complete methods and throw UOE
}

class MyCompletionStage implements CompletionStage {
	// delegate all methods to instance of MyReadOnlyCompletableFuture
}

Then return instances of MyCompletionStage in API methods.


But then the next problem: JDK 9 added new methods to complete a CompletableFuture. Those won?t be overridden, when compiled for JDK 8.
(completeOnTimeout(), completeAsync(), ..)
API users could then still complete a read-only CompletionStage:

myCompletionStage.toCompletableFuture(). completeAsync(?) when using JDK 8 libraries under JDK 9.


Btw: I also feel CompletableFuture.allOf(?); should accept CompletionStages as parameter. Thoughts?

Thanks for some feedback for a good design.

Best regards,
Christian


[1]: http://cs.oswego.edu/pipermail/concurrency-interest/2014-February/012354.html
[2]: http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CompletableFuture.html
[3]: http://cs.oswego.edu/pipermail/concurrency-interest/2013-July/011496.html

From jh at squareup.com  Tue Jan 26 16:38:10 2016
From: jh at squareup.com (Josh Humphries)
Date: Tue, 26 Jan 2016 16:38:10 -0500
Subject: [concurrency-interest] CompletionStage / read-only
 CompletableFuture / design-by-UOE ?
In-Reply-To: <4AA2B89B-C357-44D9-9A06-68B1D4816AE3@gmx.de>
References: <4AA2B89B-C357-44D9-9A06-68B1D4816AE3@gmx.de>
Message-ID: <CAHJZN-u_XjWyXOriK6sTLrkekGL6M4f2qhDJwhUfcw6mf8FcsA@mail.gmail.com>

Instead of throwing UnsupportedOperationException in toCompletableFuture(),
you could just return a new future (that completes with the same result or
failure when the receiver completes).

That way the original CompletionStage is still read-only since
toCompletableFuture().complete() would end up modifying a different object.

This is actually necessary for implementations of CompletionStage that do
not actually extend CompletableFuture but implement the API from scratch
(which I've done to inter-op between frameworks that use Guava
ListenableFutures and Java 8 CompletionStage APIs).




----
*Josh Humphries*
Manager, Shared Systems  |  Platform Engineering
Atlanta, GA  |  678-400-4867
*Square* (www.squareup.com)

On Tue, Jan 26, 2016 at 3:42 PM, Christian Schudt <christian.schudt at gmx.de>
wrote:

> Hi,
>
> I want to design an API which returns ?read-only? CompletableFutures,
> because I don?t want the API user to be able to complete the future.
> Instead only internal triggers of my library should complete it.
> (Same requirement as in [1]).
>
> After some research, the preferred way to achieve this, seems to be to
> simply return CompletionStage, which is kind of the read-only interface.
> However, a user could still complete it by calling:
> toCompletableFuture().complete(...);
>
> To prevent this, I throw an UnsupportedOperationException in
> toCompletableFuture(), in accordance with the JavaDoc.
>
> However, composing/chaining multiple CompletionStages then no longer
> works, because they internally call toCompletableFuture().
> JavaDoc says it does not "interoperate with others? then, but is that
> really necessary?
>
>
> The JDK 9 JavaDocs [2] have an example which subclasses CompletableFuture,
> which ?disables? some the ?complete? methods by throwing UOE.
> This post [3] also suggests a "design-by-UOE?, but still I am feeling
> uncomfortable with it, I?d rather return the minimal CompletionStage.
>
> What would be the preferred way to do this?
>
> class MyReadOnlyCompletableFuture extends CompletableFuture {
>         // override all complete methods and throw UOE
> }
>
> class MyCompletionStage implements CompletionStage {
>         // delegate all methods to instance of MyReadOnlyCompletableFuture
> }
>
> Then return instances of MyCompletionStage in API methods.
>
>
> But then the next problem: JDK 9 added new methods to complete a
> CompletableFuture. Those won?t be overridden, when compiled for JDK 8.
> (completeOnTimeout(), completeAsync(), ..)
> API users could then still complete a read-only CompletionStage:
>
> myCompletionStage.toCompletableFuture(). completeAsync(?) when using JDK 8
> libraries under JDK 9.
>
>
> Btw: I also feel CompletableFuture.allOf(?); should accept
> CompletionStages as parameter. Thoughts?
>
> Thanks for some feedback for a good design.
>
> Best regards,
> Christian
>
>
> [1]:
> http://cs.oswego.edu/pipermail/concurrency-interest/2014-February/012354.html
> [2]:
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CompletableFuture.html
> [3]:
> http://cs.oswego.edu/pipermail/concurrency-interest/2013-July/011496.html
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160126/27f6656e/attachment.html>

From viktor.klang at gmail.com  Tue Jan 26 17:11:07 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 26 Jan 2016 23:11:07 +0100
Subject: [concurrency-interest] CompletionStage / read-only
 CompletableFuture / design-by-UOE ?
In-Reply-To: <CAHJZN-u_XjWyXOriK6sTLrkekGL6M4f2qhDJwhUfcw6mf8FcsA@mail.gmail.com>
References: <4AA2B89B-C357-44D9-9A06-68B1D4816AE3@gmx.de>
	<CAHJZN-u_XjWyXOriK6sTLrkekGL6M4f2qhDJwhUfcw6mf8FcsA@mail.gmail.com>
Message-ID: <CANPzfU9=RqciiiHHdU0ZK1cCuhZSB2td-hkzcw9O4tSqCmeT1w@mail.gmail.com>

+1 for Josh's proposal

On Tue, Jan 26, 2016 at 10:38 PM, Josh Humphries <jh at squareup.com> wrote:

> Instead of throwing UnsupportedOperationException in
> toCompletableFuture(), you could just return a new future (that completes
> with the same result or failure when the receiver completes).
>
> That way the original CompletionStage is still read-only since
> toCompletableFuture().complete() would end up modifying a different object.
>
> This is actually necessary for implementations of CompletionStage that do
> not actually extend CompletableFuture but implement the API from scratch
> (which I've done to inter-op between frameworks that use Guava
> ListenableFutures and Java 8 CompletionStage APIs).
>
>
>
>
> ----
> *Josh Humphries*
> Manager, Shared Systems  |  Platform Engineering
> Atlanta, GA  |  678-400-4867
> *Square* (www.squareup.com)
>
> On Tue, Jan 26, 2016 at 3:42 PM, Christian Schudt <christian.schudt at gmx.de
> > wrote:
>
>> Hi,
>>
>> I want to design an API which returns ?read-only? CompletableFutures,
>> because I don?t want the API user to be able to complete the future.
>> Instead only internal triggers of my library should complete it.
>> (Same requirement as in [1]).
>>
>> After some research, the preferred way to achieve this, seems to be to
>> simply return CompletionStage, which is kind of the read-only interface.
>> However, a user could still complete it by calling:
>> toCompletableFuture().complete(...);
>>
>> To prevent this, I throw an UnsupportedOperationException in
>> toCompletableFuture(), in accordance with the JavaDoc.
>>
>> However, composing/chaining multiple CompletionStages then no longer
>> works, because they internally call toCompletableFuture().
>> JavaDoc says it does not "interoperate with others? then, but is that
>> really necessary?
>>
>>
>> The JDK 9 JavaDocs [2] have an example which subclasses
>> CompletableFuture, which ?disables? some the ?complete? methods by throwing
>> UOE.
>> This post [3] also suggests a "design-by-UOE?, but still I am feeling
>> uncomfortable with it, I?d rather return the minimal CompletionStage.
>>
>> What would be the preferred way to do this?
>>
>> class MyReadOnlyCompletableFuture extends CompletableFuture {
>>         // override all complete methods and throw UOE
>> }
>>
>> class MyCompletionStage implements CompletionStage {
>>         // delegate all methods to instance of MyReadOnlyCompletableFuture
>> }
>>
>> Then return instances of MyCompletionStage in API methods.
>>
>>
>> But then the next problem: JDK 9 added new methods to complete a
>> CompletableFuture. Those won?t be overridden, when compiled for JDK 8.
>> (completeOnTimeout(), completeAsync(), ..)
>> API users could then still complete a read-only CompletionStage:
>>
>> myCompletionStage.toCompletableFuture(). completeAsync(?) when using JDK
>> 8 libraries under JDK 9.
>>
>>
>> Btw: I also feel CompletableFuture.allOf(?); should accept
>> CompletionStages as parameter. Thoughts?
>>
>> Thanks for some feedback for a good design.
>>
>> Best regards,
>> Christian
>>
>>
>> [1]:
>> http://cs.oswego.edu/pipermail/concurrency-interest/2014-February/012354.html
>> [2]:
>> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CompletableFuture.html
>> [3]:
>> http://cs.oswego.edu/pipermail/concurrency-interest/2013-July/011496.html
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160126/ebcd63c7/attachment-0001.html>

From christian.schudt at gmx.de  Tue Jan 26 17:27:49 2016
From: christian.schudt at gmx.de (Christian Schudt)
Date: Tue, 26 Jan 2016 23:27:49 +0100
Subject: [concurrency-interest] CompletionStage / read-only
	CompletableFuture / design-by-UOE ?
In-Reply-To: <CAHJZN-u_XjWyXOriK6sTLrkekGL6M4f2qhDJwhUfcw6mf8FcsA@mail.gmail.com>
References: <4AA2B89B-C357-44D9-9A06-68B1D4816AE3@gmx.de>
	<CAHJZN-u_XjWyXOriK6sTLrkekGL6M4f2qhDJwhUfcw6mf8FcsA@mail.gmail.com>
Message-ID: <1703C978-69CE-4F5A-BC25-9E8F6BDA5907@gmx.de>

Nice, that sounds like a good and working solution :-), thanks.

I?ve did it like that (in a CompletionStage implementation which hides a private CompletableFuture):

@Override
public CompletableFuture<T> toCompletableFuture() {
    return completableFuture.whenComplete((result, throwable) -> {
    });
}

If there?s a better way, let me know.

Best,
Christian



> Am 26.01.2016 um 22:38 schrieb Josh Humphries <jh at squareup.com>:
> 
> Instead of throwing UnsupportedOperationException in toCompletableFuture(), you could just return a new future (that completes with the same result or failure when the receiver completes).
> 
> That way the original CompletionStage is still read-only since toCompletableFuture().complete() would end up modifying a different object.
> 
> This is actually necessary for implementations of CompletionStage that do not actually extend CompletableFuture but implement the API from scratch (which I've done to inter-op between frameworks that use Guava ListenableFutures and Java 8 CompletionStage APIs).
> 
> 
> 
> 
> ----
> Josh Humphries
> Manager, Shared Systems  |  Platform Engineering
> Atlanta, GA  |  678-400-4867
> Square (www.squareup.com)
> 
> On Tue, Jan 26, 2016 at 3:42 PM, Christian Schudt <christian.schudt at gmx.de> wrote:
> Hi,
> 
> I want to design an API which returns ?read-only? CompletableFutures, because I don?t want the API user to be able to complete the future. Instead only internal triggers of my library should complete it.
> (Same requirement as in [1]).
> 
> After some research, the preferred way to achieve this, seems to be to simply return CompletionStage, which is kind of the read-only interface.
> However, a user could still complete it by calling: toCompletableFuture().complete(...);
> 
> To prevent this, I throw an UnsupportedOperationException in toCompletableFuture(), in accordance with the JavaDoc.
> 
> However, composing/chaining multiple CompletionStages then no longer works, because they internally call toCompletableFuture().
> JavaDoc says it does not "interoperate with others? then, but is that really necessary?
> 
> 
> The JDK 9 JavaDocs [2] have an example which subclasses CompletableFuture, which ?disables? some the ?complete? methods by throwing UOE.
> This post [3] also suggests a "design-by-UOE?, but still I am feeling uncomfortable with it, I?d rather return the minimal CompletionStage.
> 
> What would be the preferred way to do this?
> 
> class MyReadOnlyCompletableFuture extends CompletableFuture {
>         // override all complete methods and throw UOE
> }
> 
> class MyCompletionStage implements CompletionStage {
>         // delegate all methods to instance of MyReadOnlyCompletableFuture
> }
> 
> Then return instances of MyCompletionStage in API methods.
> 
> 
> But then the next problem: JDK 9 added new methods to complete a CompletableFuture. Those won?t be overridden, when compiled for JDK 8.
> (completeOnTimeout(), completeAsync(), ..)
> API users could then still complete a read-only CompletionStage:
> 
> myCompletionStage.toCompletableFuture(). completeAsync(?) when using JDK 8 libraries under JDK 9.
> 
> 
> Btw: I also feel CompletableFuture.allOf(?); should accept CompletionStages as parameter. Thoughts?
> 
> Thanks for some feedback for a good design.
> 
> Best regards,
> Christian
> 
> 
> [1]: http://cs.oswego.edu/pipermail/concurrency-interest/2014-February/012354.html
> [2]: http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CompletableFuture.html
> [3]: http://cs.oswego.edu/pipermail/concurrency-interest/2013-July/011496.html
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 



From thurston at nomagicsoftware.com  Tue Jan 26 22:05:32 2016
From: thurston at nomagicsoftware.com (thurstonn)
Date: Tue, 26 Jan 2016 20:05:32 -0700 (MST)
Subject: [concurrency-interest] CompletionStage / read-only
	CompletableFuture / design-by-UOE ?
In-Reply-To: <4AA2B89B-C357-44D9-9A06-68B1D4816AE3@gmx.de>
References: <4AA2B89B-C357-44D9-9A06-68B1D4816AE3@gmx.de>
Message-ID: <1453863932890-13205.post@n7.nabble.com>

"...I?d rather return the minimal CompletionStage"

Well, there's the 1.9 API method CompletableFuture#minimalCompletionStage()
(perhaps that's exactly what you meant); you could just delegate to that in
your overridden #toCompletableFuture() (casting it to a CompletableFuture of
course).
That returned CF instance seems to give you exactly the behavior you want



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/CompletionStage-read-only-CompletableFuture-design-by-UOE-tp13201p13205.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.


From openjdk at duigou.org  Tue Jan 26 23:43:07 2016
From: openjdk at duigou.org (Mike Duigou)
Date: Tue, 26 Jan 2016 20:43:07 -0800
Subject: [concurrency-interest] CopyOnWriteArrayNavigableSet Now on Maven
	Central
Message-ID: <99624d76f7a1512165d38ffcf2510baa@sonic.net>

Hello All;

There are now pre-built Java 8 compatible binaries on Maven Central of 
the CopyOnWriteArrayNavigableSet implementation I have been working on. 
For most people this means they only have to add it as a dependency to 
their project pom file:

   <dependency>
       <groupId>org.bondolo</groupId>
       <artifactId>cowans8</artifactId>
       <version>5</version>
   </dependency>

For other non-maven usages the jars can be directly downloaded from 
<http://central.maven.org/maven2/org/bondolo/cowans8/5/> or you can find 
the source GitHub project for the binaries at 
<https://github.com/bondolo/cowans8>

Cheers,

Mike


From aph at redhat.com  Wed Jan 27 04:10:54 2016
From: aph at redhat.com (Andrew Haley)
Date: Wed, 27 Jan 2016 09:10:54 +0000
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <55D774D8.5030200@cs.oswego.edu>
References: <55D72B2F.70901@cs.oswego.edu> <55D7544F.9030001@oracle.com>
	<55D774D8.5030200@cs.oswego.edu>
Message-ID: <56A8899E.9000604@redhat.com>

On 21/08/15 19:58, Doug Lea wrote:

> getOpaque is the same, but with the further constraint that the read
> must actually occur even if other JMM rules would allow it to be
> optimized away (for example due to common subexpression evaluation).
> Usage is rare. Think IO.

I still don't understand.  Under what circumstances could it possibly
matter whether the read actually occurs?  Maybe it'd cause a memory-
mapped file to be read in or something.

We really need some sort of example of what this is for.  (Well, I do
anyway, and I'm sure it's not just me.)  We surely can't be adding
stuff to the library which appears to have no use.

Andrew.

From vitalyd at gmail.com  Wed Jan 27 07:08:32 2016
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 27 Jan 2016 07:08:32 -0500
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <56A8899E.9000604@redhat.com>
References: <55D72B2F.70901@cs.oswego.edu> <55D7544F.9030001@oracle.com>
	<55D774D8.5030200@cs.oswego.edu> <56A8899E.9000604@redhat.com>
Message-ID: <CAHjP37GNNM-SwTJrpmBKzwMtDHiTqFcYdLAKoRYkwg5tsdyThg@mail.gmail.com>

I could use a motivating example too.

I suppose it could be used by a thread to loop on a termination condition
that's set by another thread.  Today volatile loads are used for that, but
lots of times there's no happens-before requirement after the loop exits.
However, I don't know if this requires ordering constraints too (I.e.
memory_order_relaxed ought to work too).

I like the atomicity guarantee and the operation having to occur (no
elimination by compiler), but the full compiler fence I don't quite
understand without an example.  I can see how having this load be dependent
on control is useful but otherwise don't quite get further ordering
requirements.

On Wednesday, January 27, 2016, Andrew Haley <aph at redhat.com> wrote:

> On 21/08/15 19:58, Doug Lea wrote:
>
> > getOpaque is the same, but with the further constraint that the read
> > must actually occur even if other JMM rules would allow it to be
> > optimized away (for example due to common subexpression evaluation).
> > Usage is rare. Think IO.
>
> I still don't understand.  Under what circumstances could it possibly
> matter whether the read actually occurs?  Maybe it'd cause a memory-
> mapped file to be read in or something.
>
> We really need some sort of example of what this is for.  (Well, I do
> anyway, and I'm sure it's not just me.)  We surely can't be adding
> stuff to the library which appears to have no use.
>
> Andrew.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <javascript:;>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160127/e7ce3b0a/attachment.html>

From aph at redhat.com  Wed Jan 27 08:34:23 2016
From: aph at redhat.com (Andrew Haley)
Date: Wed, 27 Jan 2016 13:34:23 +0000
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <CAHjP37GNNM-SwTJrpmBKzwMtDHiTqFcYdLAKoRYkwg5tsdyThg@mail.gmail.com>
References: <55D72B2F.70901@cs.oswego.edu> <55D7544F.9030001@oracle.com>
	<55D774D8.5030200@cs.oswego.edu> <56A8899E.9000604@redhat.com>
	<CAHjP37GNNM-SwTJrpmBKzwMtDHiTqFcYdLAKoRYkwg5tsdyThg@mail.gmail.com>
Message-ID: <56A8C75F.2030909@redhat.com>

On 01/27/2016 12:08 PM, Vitaly Davidovich wrote:
> I suppose it could be used by a thread to loop on a termination condition
> that's set by another thread.  Today volatile loads are used for that, but
> lots of times there's no happens-before requirement after the loop exits.

If you do that on an AArch64, you're going to be waiting for
a very long time indeed.  :-)

Andrew.


From dl at cs.oswego.edu  Wed Jan 27 08:36:01 2016
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 27 Jan 2016 08:36:01 -0500
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <56A8899E.9000604@redhat.com>
References: <55D72B2F.70901@cs.oswego.edu> <55D7544F.9030001@oracle.com>
	<55D774D8.5030200@cs.oswego.edu> <56A8899E.9000604@redhat.com>
Message-ID: <56A8C7C1.1@cs.oswego.edu>

(Sorry for slow replies; swamped..)

On 01/27/2016 04:10 AM, Andrew Haley wrote:
> On 21/08/15 19:58, Doug Lea wrote:
>
>> getOpaque is the same, but with the further constraint that the read
>> must actually occur even if other JMM rules would allow it to be
>> optimized away (for example due to common subexpression evaluation).
>> Usage is rare. Think IO.
>
> I still don't understand.  Under what circumstances could it possibly
> matter whether the read actually occurs?  Maybe it'd cause a memory-
> mapped file to be read in or something.

The canonical example of opaque read is linux RCU.

For opaque writes, the main (nichy) case is publication loops
that do not need fences but still prevent compilers from delaying
the writes until end of loop.

Both of these cases are arranged in C/C++ using volatile-casts.
(As a separate issue, C/C++ specs may someday either integrate
volatile-casts with their memory model, or create explicit
opaque mode.)

For discussion, see jmm-dev archives mainly from last August:
http://mail.openjdk.java.net/pipermail/jmm-dev/2015-August/thread.html

>
> We really need some sort of example of what this is for.  (Well, I do
> anyway, and I'm sure it's not just me.)  We surely can't be adding
> stuff to the library which appears to have no use.

The goal was parity of expressiveness with C/C++11.

-Doug



From vitalyd at gmail.com  Wed Jan 27 08:59:19 2016
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 27 Jan 2016 08:59:19 -0500
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <56A8C75F.2030909@redhat.com>
References: <55D72B2F.70901@cs.oswego.edu> <55D7544F.9030001@oracle.com>
	<55D774D8.5030200@cs.oswego.edu> <56A8899E.9000604@redhat.com>
	<CAHjP37GNNM-SwTJrpmBKzwMtDHiTqFcYdLAKoRYkwg5tsdyThg@mail.gmail.com>
	<56A8C75F.2030909@redhat.com>
Message-ID: <CAHjP37HvpFG19TfcnP2f8xsRDvmWDhFN0j_PMMULw90T+EFjtA@mail.gmail.com>

why's that? how's it different from x86/64? On the surface, it seems like a
decent fit -- don't care about ordering with respect to other operations in
the loop, just want to read from (cache coherent) memory each time.  If
that's indeed the case, then clearly this API needs a lot more explanation
(I think that's already been clear given this thread).

On Wed, Jan 27, 2016 at 8:34 AM, Andrew Haley <aph at redhat.com> wrote:

> On 01/27/2016 12:08 PM, Vitaly Davidovich wrote:
> > I suppose it could be used by a thread to loop on a termination condition
> > that's set by another thread.  Today volatile loads are used for that,
> but
> > lots of times there's no happens-before requirement after the loop exits.
>
> If you do that on an AArch64, you're going to be waiting for
> a very long time indeed.  :-)
>
> Andrew.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160127/55a9d11a/attachment-0001.html>

From vitalyd at gmail.com  Wed Jan 27 09:26:02 2016
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 27 Jan 2016 09:26:02 -0500
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <56A8C7C1.1@cs.oswego.edu>
References: <55D72B2F.70901@cs.oswego.edu> <55D7544F.9030001@oracle.com>
	<55D774D8.5030200@cs.oswego.edu> <56A8899E.9000604@redhat.com>
	<56A8C7C1.1@cs.oswego.edu>
Message-ID: <CAHjP37FrurwKHph+SkHXiRdB0R2Rc2x2YFe-b=kzJ7WZ=Fxrjg@mail.gmail.com>

>
> For opaque writes, the main (nichy) case is publication loops
> that do not need fences but still prevent compilers from delaying
> the writes until end of loop.


Preventing moving/scheduling subsequent unrelated loads, for example, seems
like overkill here, no? For this particular example (publication *loop*), a
control effect on the opaque set would be enough to prevent it from being
delayed until end of loop, but may allow movement within a loop iteration.

Also, given Andrew's comment above regarding AArch64 opaque load delays
(which I don't quite understand, but hopefully he'll explain), how would an
opaque write work there?


> The goal was parity of expressiveness with C/C++11.


Is there a reason for not having memory_order_relaxed then?

On Wed, Jan 27, 2016 at 8:36 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> (Sorry for slow replies; swamped..)
>
> On 01/27/2016 04:10 AM, Andrew Haley wrote:
>
>> On 21/08/15 19:58, Doug Lea wrote:
>>
>> getOpaque is the same, but with the further constraint that the read
>>> must actually occur even if other JMM rules would allow it to be
>>> optimized away (for example due to common subexpression evaluation).
>>> Usage is rare. Think IO.
>>>
>>
>> I still don't understand.  Under what circumstances could it possibly
>> matter whether the read actually occurs?  Maybe it'd cause a memory-
>> mapped file to be read in or something.
>>
>
> The canonical example of opaque read is linux RCU.
>
> For opaque writes, the main (nichy) case is publication loops
> that do not need fences but still prevent compilers from delaying
> the writes until end of loop.
>
> Both of these cases are arranged in C/C++ using volatile-casts.
> (As a separate issue, C/C++ specs may someday either integrate
> volatile-casts with their memory model, or create explicit
> opaque mode.)
>
> For discussion, see jmm-dev archives mainly from last August:
> http://mail.openjdk.java.net/pipermail/jmm-dev/2015-August/thread.html
>
>
>> We really need some sort of example of what this is for.  (Well, I do
>> anyway, and I'm sure it's not just me.)  We surely can't be adding
>> stuff to the library which appears to have no use.
>>
>
> The goal was parity of expressiveness with C/C++11.
>
> -Doug
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160127/a742a956/attachment.html>

From aph at redhat.com  Wed Jan 27 09:50:28 2016
From: aph at redhat.com (Andrew Haley)
Date: Wed, 27 Jan 2016 14:50:28 +0000
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <CAHjP37HvpFG19TfcnP2f8xsRDvmWDhFN0j_PMMULw90T+EFjtA@mail.gmail.com>
References: <55D72B2F.70901@cs.oswego.edu> <55D7544F.9030001@oracle.com>
	<55D774D8.5030200@cs.oswego.edu> <56A8899E.9000604@redhat.com>
	<CAHjP37GNNM-SwTJrpmBKzwMtDHiTqFcYdLAKoRYkwg5tsdyThg@mail.gmail.com>
	<56A8C75F.2030909@redhat.com>
	<CAHjP37HvpFG19TfcnP2f8xsRDvmWDhFN0j_PMMULw90T+EFjtA@mail.gmail.com>
Message-ID: <56A8D934.7020401@redhat.com>

On 01/27/2016 01:59 PM, Vitaly Davidovich wrote:
> why's that? how's it different from x86/64? On the surface, it seems like a
> decent fit -- don't care about ordering with respect to other operations in
> the loop, just want to read from (cache coherent) memory each time.

An obvious translation of

  while (atomic_load_explicit(&barf, memory_order_relaxed));

is

.L2:
	ldr	w0, [x1]
	cbnz	w0, .L2
	ret

which is unbounded.

With no memory fence before a read you're not going to see writes
by other cores until the core you're running on is pre-empted for
some reason.

Andrew.


From aph at redhat.com  Wed Jan 27 09:57:32 2016
From: aph at redhat.com (Andrew Haley)
Date: Wed, 27 Jan 2016 14:57:32 +0000
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <56A8C7C1.1@cs.oswego.edu>
References: <55D72B2F.70901@cs.oswego.edu> <55D7544F.9030001@oracle.com>
	<55D774D8.5030200@cs.oswego.edu> <56A8899E.9000604@redhat.com>
	<56A8C7C1.1@cs.oswego.edu>
Message-ID: <56A8DADC.2060503@redhat.com>

On 01/27/2016 01:36 PM, Doug Lea wrote:
> For discussion, see jmm-dev archives mainly from last August:
> http://mail.openjdk.java.net/pipermail/jmm-dev/2015-August/thread.html

I'm looking at jdk9 APIs [Fences specifically],
Doug Lea dl at cs.oswego.edu Thu Aug 13 12:19:17 UTC 2015

which deals with using a storeStoreFence:

    void p() {      // called in producer thread
       for (int i = 0; i < 1000000; ++i)
         writes(heavyPureComputation(i));
    }

...

    void writes(int k) {
       x = k;
       y = k + 17;
       storeStoreFence(); // please actually store x and y if in a loop
    }

That makes sense.  I get it.  But with no fence at all?

Andrew.

From vitalyd at gmail.com  Wed Jan 27 10:15:43 2016
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 27 Jan 2016 10:15:43 -0500
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <56A8D934.7020401@redhat.com>
References: <55D72B2F.70901@cs.oswego.edu> <55D7544F.9030001@oracle.com>
	<55D774D8.5030200@cs.oswego.edu> <56A8899E.9000604@redhat.com>
	<CAHjP37GNNM-SwTJrpmBKzwMtDHiTqFcYdLAKoRYkwg5tsdyThg@mail.gmail.com>
	<56A8C75F.2030909@redhat.com>
	<CAHjP37HvpFG19TfcnP2f8xsRDvmWDhFN0j_PMMULw90T+EFjtA@mail.gmail.com>
	<56A8D934.7020401@redhat.com>
Message-ID: <CAHjP37FY=xg_CRy0fCOgCxMW3rn_-6VUFnpPUzpCiekKW74D0A@mail.gmail.com>

That's ... bizarre :)

So m_o_relaxed is useless there? Or is it lowered with some lightweight
fence to force a load of that address? What do C++ compilers emit?

Is it the same way for stores? If so, Doug's example of a publication loop
that wants no delay from compiler seems moot if the core delays it without
explicit fence (unless opaque will lower with these fences).

On Wednesday, January 27, 2016, Andrew Haley <aph at redhat.com> wrote:

> On 01/27/2016 01:59 PM, Vitaly Davidovich wrote:
> > why's that? how's it different from x86/64? On the surface, it seems
> like a
> > decent fit -- don't care about ordering with respect to other operations
> in
> > the loop, just want to read from (cache coherent) memory each time.
>
> An obvious translation of
>
>   while (atomic_load_explicit(&barf, memory_order_relaxed));
>
> is
>
> .L2:
>         ldr     w0, [x1]
>         cbnz    w0, .L2
>         ret
>
> which is unbounded.
>
> With no memory fence before a read you're not going to see writes
> by other cores until the core you're running on is pre-empted for
> some reason.
>
> Andrew.
>
>

-- 
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160127/c8d4dbab/attachment.html>

From aph at redhat.com  Wed Jan 27 10:27:17 2016
From: aph at redhat.com (Andrew Haley)
Date: Wed, 27 Jan 2016 15:27:17 +0000
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <CAHjP37FY=xg_CRy0fCOgCxMW3rn_-6VUFnpPUzpCiekKW74D0A@mail.gmail.com>
References: <55D72B2F.70901@cs.oswego.edu> <55D7544F.9030001@oracle.com>
	<55D774D8.5030200@cs.oswego.edu> <56A8899E.9000604@redhat.com>
	<CAHjP37GNNM-SwTJrpmBKzwMtDHiTqFcYdLAKoRYkwg5tsdyThg@mail.gmail.com>
	<56A8C75F.2030909@redhat.com>
	<CAHjP37HvpFG19TfcnP2f8xsRDvmWDhFN0j_PMMULw90T+EFjtA@mail.gmail.com>
	<56A8D934.7020401@redhat.com>
	<CAHjP37FY=xg_CRy0fCOgCxMW3rn_-6VUFnpPUzpCiekKW74D0A@mail.gmail.com>
Message-ID: <56A8E1D5.8080608@redhat.com>

On 01/27/2016 03:15 PM, Vitaly Davidovich wrote:
> That's ... bizarre :)
> 
> So m_o_relaxed is useless there? Or is it lowered with some lightweight
> fence to force a load of that address? What do C++ compilers emit?

For this:

  while (atomic_load_explicit(&barf, memory_order_relaxed))
    atomic_store_explicit(&barse, 0, memory_order_relaxed);

a C++ compiler emits this:

	b	.L2
.L3:
	str	wzr, [x2]
.L2:
	ldr	w0, [x1]
	cbnz	w0, .L3

> Is it the same way for stores? If so, Doug's example of a publication loop
> that wants no delay from compiler seems moot if the core delays it without
> explicit fence (unless opaque will lower with these fences).

I would have thought so. but I can see no reason for opaque to emit
a fence.  Its spec does not seem to require it.

Andrew.



From dl at cs.oswego.edu  Wed Jan 27 11:20:40 2016
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 27 Jan 2016 11:20:40 -0500
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <56A8E1D5.8080608@redhat.com>
References: <55D72B2F.70901@cs.oswego.edu> <55D7544F.9030001@oracle.com>
	<55D774D8.5030200@cs.oswego.edu> <56A8899E.9000604@redhat.com>
	<CAHjP37GNNM-SwTJrpmBKzwMtDHiTqFcYdLAKoRYkwg5tsdyThg@mail.gmail.com>
	<56A8C75F.2030909@redhat.com>
	<CAHjP37HvpFG19TfcnP2f8xsRDvmWDhFN0j_PMMULw90T+EFjtA@mail.gmail.com>
	<56A8D934.7020401@redhat.com>
	<CAHjP37FY=xg_CRy0fCOgCxMW3rn_-6VUFnpPUzpCiekKW74D0A@mail.gmail.com>
	<56A8E1D5.8080608@redhat.com>
Message-ID: <56A8EE58.1070008@cs.oswego.edu>

On 01/27/2016 10:27 AM, Andrew Haley wrote:

> I would have thought so. but I can see no reason for opaque to emit
> a fence.  Its spec does not seem to require it.
>

It does not. Among the usage examples cited are cases where people
are content to observe (very) stale values, but are not content for
them to never be written in long-running loops. For example,
a progress monitor:

static int progress;    // occasionally read by monitor thread

for (int i = 0; i < 10000000; ++i) {
   progress = i;
   work();
}

-Doug


From vitalyd at gmail.com  Wed Jan 27 12:38:54 2016
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 27 Jan 2016 12:38:54 -0500
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <56A8EE58.1070008@cs.oswego.edu>
References: <55D72B2F.70901@cs.oswego.edu> <55D7544F.9030001@oracle.com>
	<55D774D8.5030200@cs.oswego.edu> <56A8899E.9000604@redhat.com>
	<CAHjP37GNNM-SwTJrpmBKzwMtDHiTqFcYdLAKoRYkwg5tsdyThg@mail.gmail.com>
	<56A8C75F.2030909@redhat.com>
	<CAHjP37HvpFG19TfcnP2f8xsRDvmWDhFN0j_PMMULw90T+EFjtA@mail.gmail.com>
	<56A8D934.7020401@redhat.com>
	<CAHjP37FY=xg_CRy0fCOgCxMW3rn_-6VUFnpPUzpCiekKW74D0A@mail.gmail.com>
	<56A8E1D5.8080608@redhat.com> <56A8EE58.1070008@cs.oswego.edu>
Message-ID: <CAHjP37H9944O6H0AsiGV1YEe4a0HjAN0g_gyG+5HOLaHtdWH6w@mail.gmail.com>

What if the writing core is isolated and only this thread is runnable on
it? There would be no context switch.  When would that be written and
visible? What other actions on AArch64 would make it visible?

I think for archs like AArch64 a minimal fence to ensure the operation
happens globally would be needed; otherwise, this API is a trap there.  IMO.

On Wednesday, January 27, 2016, Doug Lea <dl at cs.oswego.edu> wrote:

> On 01/27/2016 10:27 AM, Andrew Haley wrote:
>
> I would have thought so. but I can see no reason for opaque to emit
>> a fence.  Its spec does not seem to require it.
>>
>>
> It does not. Among the usage examples cited are cases where people
> are content to observe (very) stale values, but are not content for
> them to never be written in long-running loops. For example,
> a progress monitor:
>
> static int progress;    // occasionally read by monitor thread
>
> for (int i = 0; i < 10000000; ++i) {
>   progress = i;
>   work();
> }
>
> -Doug
>
>

-- 
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160127/bb10c648/attachment.html>

From pavel.rappo at gmail.com  Fri Jan 29 11:26:06 2016
From: pavel.rappo at gmail.com (Pavel Rappo)
Date: Fri, 29 Jan 2016 16:26:06 +0000
Subject: [concurrency-interest] Flow.Subscription's javadoc
Message-ID: <CAChcVuk3+L66Y_NuRqZH5p28YwMM8azEEAp9AQVtGJoc1t+FzA@mail.gmail.com>

Hi,

    /**
     * Message control linking a {@link Publisher} and {@link
     * Subscriber}.  Subscribers receive items only when requested,
     * and may cancel at any time. The methods in this interface are
     * intended to be invoked only by their Subscribers; usages in
     * other contexts have undefined effects.
     */
    public static interface Subscription

Could anyone please explain what the "The methods in this interface are intended
to be invoked only by their Subscribers; usages in other contexts have undefined
effects." part is all about? (or 3.1 [1])

I'm sure I understand the relationship between a subscriber and its subscription
to a certain publisher. What I'm not sure about is that I understand what
constitutes the "context" mentioned in the javadoc above.

For example, can a subscriber invoke Subscription.request NOT in a response to
Subscriber.onNext or Subscriber.onSubscribe? Or in the general case, delegate
the responsibility to replenish requests to someone else (e.g. to let
Subscription.request be triggered by outer events)?

Thanks.

--------------------------------------------------------------------------------
[1] https://github.com/reactive-streams/reactive-streams-jvm/#3-subscription-code

From akarnokd at gmail.com  Fri Jan 29 12:11:17 2016
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Fri, 29 Jan 2016 18:11:17 +0100
Subject: [concurrency-interest] Flow.Subscription's javadoc
In-Reply-To: <CAChcVuk3+L66Y_NuRqZH5p28YwMM8azEEAp9AQVtGJoc1t+FzA@mail.gmail.com>
References: <CAChcVuk3+L66Y_NuRqZH5p28YwMM8azEEAp9AQVtGJoc1t+FzA@mail.gmail.com>
Message-ID: <CAAWwtm8DfoqvosXp=tvFd0iAkh29MK+V0=CSi-08qTujZp4cpA@mail.gmail.com>

I must admit that sounds a bit of a weak guarantee. In RxJava 2 and
reactive-streams-commons, Subscription implementations are thread safe and
reentrant-safe, thus request and cancel can be called at any time from any
thread, even immediately from onSubscribe. What I can deduce,
Flow.SubmissionPublisher has also this property.

However, the spec indicates that the link itself is a private matter
between Publisher and Subscriber and if you want to expose, for example,
cancel() to the outside world in your MySubscriber(), extra care has to be
taken inside MySubscriber. Same goes for request(). Here [1][2] is an
example of a Subscriber that allows external cancellation and requests.

Bottom line is, that if you can get hold of a Subscription, you won't break
the upstream but you may break a downstream if it didn't expect more values
you just requested.

-------------
[1]
https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/subscribers/TestSubscriber.java#L203
[2]
https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/subscribers/TestSubscriber.java#L223

2016-01-29 17:26 GMT+01:00 Pavel Rappo <pavel.rappo at gmail.com>:

> Hi,
>
>     /**
>      * Message control linking a {@link Publisher} and {@link
>      * Subscriber}.  Subscribers receive items only when requested,
>      * and may cancel at any time. The methods in this interface are
>      * intended to be invoked only by their Subscribers; usages in
>      * other contexts have undefined effects.
>      */
>     public static interface Subscription
>
> Could anyone please explain what the "The methods in this interface are
> intended
> to be invoked only by their Subscribers; usages in other contexts have
> undefined
> effects." part is all about? (or 3.1 [1])
>
> I'm sure I understand the relationship between a subscriber and its
> subscription
> to a certain publisher. What I'm not sure about is that I understand what
> constitutes the "context" mentioned in the javadoc above.
>
> For example, can a subscriber invoke Subscription.request NOT in a
> response to
> Subscriber.onNext or Subscriber.onSubscribe? Or in the general case,
> delegate
> the responsibility to replenish requests to someone else (e.g. to let
> Subscription.request be triggered by outer events)?
>
> Thanks.
>
>
> --------------------------------------------------------------------------------
> [1]
> https://github.com/reactive-streams/reactive-streams-jvm/#3-subscription-code
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160129/4e3e0e3d/attachment.html>

From james at typesafe.com  Sat Jan 30 00:09:39 2016
From: james at typesafe.com (James Roper)
Date: Sat, 30 Jan 2016 16:09:39 +1100
Subject: [concurrency-interest] Flow.Subscription's javadoc
In-Reply-To: <CAAWwtm8DfoqvosXp=tvFd0iAkh29MK+V0=CSi-08qTujZp4cpA@mail.gmail.com>
References: <CAChcVuk3+L66Y_NuRqZH5p28YwMM8azEEAp9AQVtGJoc1t+FzA@mail.gmail.com>
	<CAAWwtm8DfoqvosXp=tvFd0iAkh29MK+V0=CSi-08qTujZp4cpA@mail.gmail.com>
Message-ID: <CABY0rKMQ2ZFCTxZV05kCFGk8shVz9E7J3D7T7oFEgZMf4cBzfQ@mail.gmail.com>

It is a weak assertion, the word context in this case simply is not a
thread or invocation context, but more of an abstract context, the context
of a relationship between a particular subscriber that has subscribed to a
particular publisher.  As David said, the point is that it's a private
matter between a Publisher and Subscriber.  The point of that statement is
that if a library were to create a public API like this:

interface SubscriptionFactory {
  Subscription createSubscription();
}

The effect of the returned subscription in that case is undefined according
to the reactive streams spec - that is to say it does not make sense to
have or use a subscription outside of a Publisher/Subscriber relationship
context.

As far as when request() and cancel() can be invoked, the reactive streams
spec makes clear that these can be invoked at will by a subscriber, they
definitely don't need to be in response to any calls on the subscriber.



On 30 January 2016 at 04:11, D?vid Karnok <akarnokd at gmail.com> wrote:

> I must admit that sounds a bit of a weak guarantee. In RxJava 2 and
> reactive-streams-commons, Subscription implementations are thread safe and
> reentrant-safe, thus request and cancel can be called at any time from any
> thread, even immediately from onSubscribe. What I can deduce,
> Flow.SubmissionPublisher has also this property.
>
> However, the spec indicates that the link itself is a private matter
> between Publisher and Subscriber and if you want to expose, for example,
> cancel() to the outside world in your MySubscriber(), extra care has to be
> taken inside MySubscriber. Same goes for request(). Here [1][2] is an
> example of a Subscriber that allows external cancellation and requests.
>
> Bottom line is, that if you can get hold of a Subscription, you won't
> break the upstream but you may break a downstream if it didn't expect more
> values you just requested.
>
> -------------
> [1]
> https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/subscribers/TestSubscriber.java#L203
> [2]
> https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/subscribers/TestSubscriber.java#L223
>
> 2016-01-29 17:26 GMT+01:00 Pavel Rappo <pavel.rappo at gmail.com>:
>
>> Hi,
>>
>>     /**
>>      * Message control linking a {@link Publisher} and {@link
>>      * Subscriber}.  Subscribers receive items only when requested,
>>      * and may cancel at any time. The methods in this interface are
>>      * intended to be invoked only by their Subscribers; usages in
>>      * other contexts have undefined effects.
>>      */
>>     public static interface Subscription
>>
>> Could anyone please explain what the "The methods in this interface are
>> intended
>> to be invoked only by their Subscribers; usages in other contexts have
>> undefined
>> effects." part is all about? (or 3.1 [1])
>>
>> I'm sure I understand the relationship between a subscriber and its
>> subscription
>> to a certain publisher. What I'm not sure about is that I understand what
>> constitutes the "context" mentioned in the javadoc above.
>>
>> For example, can a subscriber invoke Subscription.request NOT in a
>> response to
>> Subscriber.onNext or Subscriber.onSubscribe? Or in the general case,
>> delegate
>> the responsibility to replenish requests to someone else (e.g. to let
>> Subscription.request be triggered by outer events)?
>>
>> Thanks.
>>
>>
>> --------------------------------------------------------------------------------
>> [1]
>> https://github.com/reactive-streams/reactive-streams-jvm/#3-subscription-code
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> --
> Best regards,
> David Karnok
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
*James Roper*
*Software Engineer*

Typesafe <http://typesafe.com/> ? Build reactive apps!
Twitter: @jroper <https://twitter.com/jroper>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160130/0c562240/attachment.html>

From viktor.klang at gmail.com  Sun Jan 31 13:49:16 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Sun, 31 Jan 2016 19:49:16 +0100
Subject: [concurrency-interest] Flow.Subscription's javadoc
In-Reply-To: <CABY0rKMQ2ZFCTxZV05kCFGk8shVz9E7J3D7T7oFEgZMf4cBzfQ@mail.gmail.com>
References: <CAChcVuk3+L66Y_NuRqZH5p28YwMM8azEEAp9AQVtGJoc1t+FzA@mail.gmail.com>
	<CAAWwtm8DfoqvosXp=tvFd0iAkh29MK+V0=CSi-08qTujZp4cpA@mail.gmail.com>
	<CABY0rKMQ2ZFCTxZV05kCFGk8shVz9E7J3D7T7oFEgZMf4cBzfQ@mail.gmail.com>
Message-ID: <CANPzfU8Wk1LgPQePVaQXBKBzvxTALtAtzeW3WxhZsN4My=6wLw@mail.gmail.com>

On Sat, Jan 30, 2016 at 6:09 AM, James Roper <james at typesafe.com> wrote:

> It is a weak assertion, the word context in this case simply is not a
> thread or invocation context, but more of an abstract context, the context
> of a relationship between a particular subscriber that has subscribed to a
> particular publisher.  As David said, the point is that it's a private
> matter between a Publisher and Subscriber.  The point of that statement is
> that if a library were to create a public API like this:
>
> interface SubscriptionFactory {
>   Subscription createSubscription();
> }
>
> The effect of the returned subscription in that case is undefined
> according to the reactive streams spec - that is to say it does not make
> sense to have or use a subscription outside of a Publisher/Subscriber
> relationship context.
>
> As far as when request() and cancel() can be invoked, the reactive streams
> spec makes clear that these can be invoked at will by a subscriber, they
> definitely don't need to be in response to any calls on the subscriber.
>

James' correct. I'd also like to add that the reason for the "weak"
guarantee is to allow for performant implementations?if a Subscriber
chooses to expose its Subscription to some other context/thread/etc, then
the Subscriber needs to make sure that the Subscription cannot be used in a
way which violates the spec, which means that it may have to wrap the
Subscription in a Subscription which provides the stronger guarantees, for
instance prevents concurrent signalling etc.

Does that make sense?


>
>
>
> On 30 January 2016 at 04:11, D?vid Karnok <akarnokd at gmail.com> wrote:
>
>> I must admit that sounds a bit of a weak guarantee. In RxJava 2 and
>> reactive-streams-commons, Subscription implementations are thread safe and
>> reentrant-safe, thus request and cancel can be called at any time from any
>> thread, even immediately from onSubscribe. What I can deduce,
>> Flow.SubmissionPublisher has also this property.
>>
>> However, the spec indicates that the link itself is a private matter
>> between Publisher and Subscriber and if you want to expose, for example,
>> cancel() to the outside world in your MySubscriber(), extra care has to be
>> taken inside MySubscriber. Same goes for request(). Here [1][2] is an
>> example of a Subscriber that allows external cancellation and requests.
>>
>> Bottom line is, that if you can get hold of a Subscription, you won't
>> break the upstream but you may break a downstream if it didn't expect more
>> values you just requested.
>>
>> -------------
>> [1]
>> https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/subscribers/TestSubscriber.java#L203
>> [2]
>> https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/subscribers/TestSubscriber.java#L223
>>
>> 2016-01-29 17:26 GMT+01:00 Pavel Rappo <pavel.rappo at gmail.com>:
>>
>>> Hi,
>>>
>>>     /**
>>>      * Message control linking a {@link Publisher} and {@link
>>>      * Subscriber}.  Subscribers receive items only when requested,
>>>      * and may cancel at any time. The methods in this interface are
>>>      * intended to be invoked only by their Subscribers; usages in
>>>      * other contexts have undefined effects.
>>>      */
>>>     public static interface Subscription
>>>
>>> Could anyone please explain what the "The methods in this interface are
>>> intended
>>> to be invoked only by their Subscribers; usages in other contexts have
>>> undefined
>>> effects." part is all about? (or 3.1 [1])
>>>
>>> I'm sure I understand the relationship between a subscriber and its
>>> subscription
>>> to a certain publisher. What I'm not sure about is that I understand what
>>> constitutes the "context" mentioned in the javadoc above.
>>>
>>> For example, can a subscriber invoke Subscription.request NOT in a
>>> response to
>>> Subscriber.onNext or Subscriber.onSubscribe? Or in the general case,
>>> delegate
>>> the responsibility to replenish requests to someone else (e.g. to let
>>> Subscription.request be triggered by outer events)?
>>>
>>> Thanks.
>>>
>>>
>>> --------------------------------------------------------------------------------
>>> [1]
>>> https://github.com/reactive-streams/reactive-streams-jvm/#3-subscription-code
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>>
>> --
>> Best regards,
>> David Karnok
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> --
> *James Roper*
> *Software Engineer*
>
> Typesafe <http://typesafe.com/> ? Build reactive apps!
> Twitter: @jroper <https://twitter.com/jroper>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160131/e7e893ca/attachment.html>

