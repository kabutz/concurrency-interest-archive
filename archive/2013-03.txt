From aleksey.shipilev at oracle.com  Fri Mar  1 04:44:59 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Fri, 01 Mar 2013 13:44:59 +0400
Subject: [concurrency-interest] AtomicInteger implementation
In-Reply-To: <512FD8D4.6060306@oracle.com>
References: <CAOPu7Ej=SoN1FcPrDQcHkjWRnR0y_C1aU9YzorpmibgQHXJNBQ@mail.gmail.com>
	<512FD1CE.5090005@oracle.com>
	<CAOPu7EiyoFzwNSsHCTvpbEWbcQLNDcarL5sQShk-iX=qe1CmOQ@mail.gmail.com>
	<512FD8D4.6060306@oracle.com>
Message-ID: <5130789B.5030901@oracle.com>

On 03/01/2013 02:23 AM, Nathan Reynolds wrote:
> Given that the backport was resolved on 11/7/2012, I kind of doubt it
> was done in time for HotSpot 7u10.  7u11, 13 and 15 are security
> releases and hence won't have this fix.  7u12 and 14 were skipped.  I
> hope this means that the next non-security HotSpot release (7u16?) will
> have the backport.

As the person intimately involved in this particular bit, here's the
outline:
 - the VM intrinsic support was done back in November; however, those
intrinsics use the magic Unsafe.getAndAdd*/blah family of methods as the
intrinsic points, and...
 - the JDK side of things was done back in December, and committed
2012-12-20: http://hg.openjdk.java.net/hsx/hotspot-main/jdk/rev/8cf5b18488d1
 - Doug had adjusted AtomicX to use these intrinsics on 2013-01-16:
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/atomic/AtomicInteger.java?revision=1.35&view=markup

You are caught in the middle of the tide here ;) The debate around
incrementAndGet is soon to blow over, because it is the plain
intrinsified Unsafe call now.

I'm not sure when it will end up in 7u release (I'd say next even
release), but preview builds for JDK8 are already having new AtomicX, at
least b77 does. As usual, the feedbacks are welcome, but use the latest
bits to research on the topic.

Hope that helps.

-Aleksey.

From chris.hegarty at oracle.com  Fri Mar  1 05:23:49 2013
From: chris.hegarty at oracle.com (Chris Hegarty)
Date: Fri, 01 Mar 2013 10:23:49 +0000
Subject: [concurrency-interest] AtomicInteger implementation
In-Reply-To: <5130789B.5030901@oracle.com>
References: <CAOPu7Ej=SoN1FcPrDQcHkjWRnR0y_C1aU9YzorpmibgQHXJNBQ@mail.gmail.com>
	<512FD1CE.5090005@oracle.com>
	<CAOPu7EiyoFzwNSsHCTvpbEWbcQLNDcarL5sQShk-iX=qe1CmOQ@mail.gmail.com>
	<512FD8D4.6060306@oracle.com> <5130789B.5030901@oracle.com>
Message-ID: <513081B5.8090703@oracle.com>

Just to add...

On 03/01/2013 09:44 AM, Aleksey Shipilev wrote:
> On 03/01/2013 02:23 AM, Nathan Reynolds wrote:
>> Given that the backport was resolved on 11/7/2012, I kind of doubt it
>> was done in time for HotSpot 7u10.  7u11, 13 and 15 are security
>> releases and hence won't have this fix.  7u12 and 14 were skipped.  I
>> hope this means that the next non-security HotSpot release (7u16?) will
>> have the backport.
>
> As the person intimately involved in this particular bit, here's the
> outline:
>   - the VM intrinsic support was done back in November; however, those

As Nathan correctly said, the VM support was added through 7023898 [1], 
which is in the latest 7u-dev repository. (There is currently no public 
release based on this, but it will be in the next non-security public 7 
update). However, 7u-dev seems to be missing the VM side of 8004330 [2], 
to fix java names for getAndSet intrinsics. This will need to be ported.

Now to the JDK side. Currently there are no changes in the 7u-dev jdk 
repository to either expose these new intrinsics, or to use them. We 
would need to backport the Unsafe changes from 8004330 [3], and the 
actual changes to the atomic classes themselves 8006007 [4].

So, is there an appetite to have these changes in a 7 Update? Or 
minimally port [2] to have a version of jsr166.jar to use them.

-Chris.

[1] http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7023898
[2] http://hg.openjdk.java.net/jdk8/jdk8/hotspot/rev/a46457045d66
[3] http://hg.openjdk.java.net/hsx/hotspot-main/jdk/rev/8cf5b18488d1
[4] http://hg.openjdk.java.net/jdk8/tl/jdk/rev/3e906ccad412

> intrinsics use the magic Unsafe.getAndAdd*/blah family of methods as the
> intrinsic points, and...
>   - the JDK side of things was done back in December, and committed
> 2012-12-20: http://hg.openjdk.java.net/hsx/hotspot-main/jdk/rev/8cf5b18488d1
>   - Doug had adjusted AtomicX to use these intrinsics on 2013-01-16:
> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/atomic/AtomicInteger.java?revision=1.35&view=markup
>
> You are caught in the middle of the tide here ;) The debate around
> incrementAndGet is soon to blow over, because it is the plain
> intrinsified Unsafe call now.
>
> I'm not sure when it will end up in 7u release (I'd say next even
> release), but preview builds for JDK8 are already having new AtomicX, at
> least b77 does. As usual, the feedbacks are welcome, but use the latest
> bits to research on the topic.
>
> Hope that helps.
>
> -Aleksey.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From peter.levart at gmail.com  Tue Mar  5 04:35:53 2013
From: peter.levart at gmail.com (Peter Levart)
Date: Tue, 05 Mar 2013 10:35:53 +0100
Subject: [concurrency-interest] Unsafe.putXXX vs. normal field write
Message-ID: <5135BC79.7040804@gmail.com>

Hi,

At the risk of asking stupid questions that have already been answered, 
I'll ask them anyway...

Is Unsafe.putInt() for example (and other normal putXXX methods - not 
volatile nor ordered) exactly the same as normal field access (when the 
field is not declared as volatile or final)? Does JIT compiler establish 
dependencies between writes and reads of the same field if they are 
performed using normal JVM bytecodes intermingled with Usafe.getXXX|putXXX ?

The sub-question: what about if the field is declared as final? What are 
legal modifications of a final field (not a compile-time constant) and 
why might they be better (or not) than using simple non-final field?

Thank you,

Peter

From aleksey.shipilev at oracle.com  Tue Mar  5 04:53:45 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Tue, 05 Mar 2013 13:53:45 +0400
Subject: [concurrency-interest] Unsafe.putXXX vs. normal field write
In-Reply-To: <5135BC79.7040804@gmail.com>
References: <5135BC79.7040804@gmail.com>
Message-ID: <5135C0A9.6090504@oracle.com>

On 03/05/2013 01:35 PM, Peter Levart wrote:
> Is Unsafe.putInt() for example (and other normal putXXX methods - not
> volatile nor ordered) exactly the same as normal field access (when the
> field is not declared as volatile or final)? Does JIT compiler establish
> dependencies between writes and reads of the same field if they are
> performed using normal JVM bytecodes intermingled with
> Usafe.getXXX|putXXX ?

Yes. If I remember the relevant code right, in the worst case for
HotSpot, if aliasing analysis can't figure out what is being referred to
with Unsafe setters/getters, it bails out to reorder just about anything
about this call, thus conservatively maintaining the program order. I
don't think it is sensible to do otherwise, because you can not mix
U.get/put* with normal fields accesses at all otherwise.

> The sub-question: what about if the field is declared as final? What are
> legal modifications of a final field (not a compile-time constant) and
> why might they be better (or not) than using simple non-final field?

The implications are drastic. If the final field was expanded during
javac compilation, there are no guarantees the new value will be visible
at all. This is somewhat a gray zone, and the most useful trick in
serialization is setting the final field during deserialization when
nothing else had seen the object yet. That way we can rely on the data
dependency to see the established value for final field.

Otherwise, IMO, there are no guarantees the set value will be visible.
You can think about this as the non-paired operation: no matter how hard
you enforce the "release" part of with U.putVolatile, with missing
"acquire" part, you can not rely on any particular ordering.

If you are modifying the field is some globally-escaped object, the
safest way is to declare that field "volatile", to gain the acquire
semantics. The other idea would be using U.getVolatile at the parts
requiring the visibility, although the reasoning about the correctness
would still be hard in all other places.

HTHS,
-Aleksey.

From peter.levart at gmail.com  Tue Mar  5 06:42:34 2013
From: peter.levart at gmail.com (Peter Levart)
Date: Tue, 05 Mar 2013 12:42:34 +0100
Subject: [concurrency-interest] Unsafe.putXXX vs. normal field write
In-Reply-To: <5135C0A9.6090504@oracle.com>
References: <5135BC79.7040804@gmail.com> <5135C0A9.6090504@oracle.com>
Message-ID: <5135DA2A.10600@gmail.com>

On 03/05/2013 10:53 AM, Aleksey Shipilev wrote:
> On 03/05/2013 01:35 PM, Peter Levart wrote:
>> Is Unsafe.putInt() for example (and other normal putXXX methods - not
>> volatile nor ordered) exactly the same as normal field access (when the
>> field is not declared as volatile or final)? Does JIT compiler establish
>> dependencies between writes and reads of the same field if they are
>> performed using normal JVM bytecodes intermingled with
>> Usafe.getXXX|putXXX ?
> Yes. If I remember the relevant code right, in the worst case for
> HotSpot, if aliasing analysis can't figure out what is being referred to
> with Unsafe setters/getters, it bails out to reorder just about anything
> about this call, thus conservatively maintaining the program order. I
> don't think it is sensible to do otherwise, because you can not mix
> U.get/put* with normal fields accesses at all otherwise.
>
>> The sub-question: what about if the field is declared as final? What are
>> legal modifications of a final field (not a compile-time constant) and
>> why might they be better (or not) than using simple non-final field?
> The implications are drastic. If the final field was expanded during
> javac compilation, there are no guarantees the new value will be visible
> at all. This is somewhat a gray zone, and the most useful trick in
> serialization is setting the final field during deserialization when
> nothing else had seen the object yet. That way we can rely on the data
> dependency to see the established value for final field.
>
> Otherwise, IMO, there are no guarantees the set value will be visible.
> You can think about this as the non-paired operation: no matter how hard
> you enforce the "release" part of with U.putVolatile, with missing
> "acquire" part, you can not rely on any particular ordering.
>
> If you are modifying the field is some globally-escaped object, the
> safest way is to declare that field "volatile", to gain the acquire
> semantics. The other idea would be using U.getVolatile at the parts
> requiring the visibility, although the reasoning about the correctness
> would still be hard in all other places.

Hi Aleksey,

I was not really thinking about implications of visibility of final 
field value in other threads, but only in the single thread that also 
does the Unsafe.putXXX to write to the final field. Does JIT also try to 
invalidate or update the aliases of the final field when Unsafe.putXXX 
(not putXXXVolatile or putOrderedXXX) is used to write to the final 
field, like you said it does for normal fields?

I'm aware of the compile-time constant expansion implications and only 
asking for the case when the compiler can not expand the compile-time 
constant.

So if JIT tracks aliases also for final fields in Unsafe.putXXX 
operations, does using final fields and normal java bytecode accesses to 
read the final fields combined with Unsafe.putXXX to update final fields 
(assuming it actually works) present any performance difference to using 
normal non-final fields and reading/writing them in plain java 
bytecodes. Not regarding any multithreaded visibility implications - 
only single threaded code. Asking differently: Would there be a reason 
to use final field and update it via Usafe.putXXX instead of using plain 
non-final field?

Thanks,

Peter

>
> HTHS,
> -Aleksey.


From vitalyd at gmail.com  Tue Mar  5 07:36:58 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 5 Mar 2013 07:36:58 -0500
Subject: [concurrency-interest] Unsafe.putXXX vs. normal field write
In-Reply-To: <5135DA2A.10600@gmail.com>
References: <5135BC79.7040804@gmail.com> <5135C0A9.6090504@oracle.com>
	<5135DA2A.10600@gmail.com>
Message-ID: <CAHjP37GSE+EkSBjBcu-5ZSi6KOv3ttk79NyLPUJZL03vh0eNvw@mail.gmail.com>

I don't see much use in having a final field that's written by Unsafe.
Memory model aside, final is supposed to encourage the JIT to enregister
their loads; in practice, there are practical issues with being overly
aggressive with them (there was a recent discussion around this on this
list).  Also, using Unsafe to do the write may lead to worse code
generation than using non-final field with byte code access; if compiler
cannot de-alias the memory due to Unsafe.put it may give up on certain code
motion/optimizations.

Sent from my phone
On Mar 5, 2013 6:46 AM, "Peter Levart" <peter.levart at gmail.com> wrote:

> On 03/05/2013 10:53 AM, Aleksey Shipilev wrote:
>
>> On 03/05/2013 01:35 PM, Peter Levart wrote:
>>
>>> Is Unsafe.putInt() for example (and other normal putXXX methods - not
>>> volatile nor ordered) exactly the same as normal field access (when the
>>> field is not declared as volatile or final)? Does JIT compiler establish
>>> dependencies between writes and reads of the same field if they are
>>> performed using normal JVM bytecodes intermingled with
>>> Usafe.getXXX|putXXX ?
>>>
>> Yes. If I remember the relevant code right, in the worst case for
>> HotSpot, if aliasing analysis can't figure out what is being referred to
>> with Unsafe setters/getters, it bails out to reorder just about anything
>> about this call, thus conservatively maintaining the program order. I
>> don't think it is sensible to do otherwise, because you can not mix
>> U.get/put* with normal fields accesses at all otherwise.
>>
>>  The sub-question: what about if the field is declared as final? What are
>>> legal modifications of a final field (not a compile-time constant) and
>>> why might they be better (or not) than using simple non-final field?
>>>
>> The implications are drastic. If the final field was expanded during
>> javac compilation, there are no guarantees the new value will be visible
>> at all. This is somewhat a gray zone, and the most useful trick in
>> serialization is setting the final field during deserialization when
>> nothing else had seen the object yet. That way we can rely on the data
>> dependency to see the established value for final field.
>>
>> Otherwise, IMO, there are no guarantees the set value will be visible.
>> You can think about this as the non-paired operation: no matter how hard
>> you enforce the "release" part of with U.putVolatile, with missing
>> "acquire" part, you can not rely on any particular ordering.
>>
>> If you are modifying the field is some globally-escaped object, the
>> safest way is to declare that field "volatile", to gain the acquire
>> semantics. The other idea would be using U.getVolatile at the parts
>> requiring the visibility, although the reasoning about the correctness
>> would still be hard in all other places.
>>
>
> Hi Aleksey,
>
> I was not really thinking about implications of visibility of final field
> value in other threads, but only in the single thread that also does the
> Unsafe.putXXX to write to the final field. Does JIT also try to invalidate
> or update the aliases of the final field when Unsafe.putXXX (not
> putXXXVolatile or putOrderedXXX) is used to write to the final field, like
> you said it does for normal fields?
>
> I'm aware of the compile-time constant expansion implications and only
> asking for the case when the compiler can not expand the compile-time
> constant.
>
> So if JIT tracks aliases also for final fields in Unsafe.putXXX
> operations, does using final fields and normal java bytecode accesses to
> read the final fields combined with Unsafe.putXXX to update final fields
> (assuming it actually works) present any performance difference to using
> normal non-final fields and reading/writing them in plain java bytecodes.
> Not regarding any multithreaded visibility implications - only single
> threaded code. Asking differently: Would there be a reason to use final
> field and update it via Usafe.putXXX instead of using plain non-final field?
>
> Thanks,
>
> Peter
>
>
>> HTHS,
>> -Aleksey.
>>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130305/20758c0b/attachment.html>

From aleksey.shipilev at oracle.com  Tue Mar  5 07:49:36 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Tue, 05 Mar 2013 16:49:36 +0400
Subject: [concurrency-interest] Unsafe.putXXX vs. normal field write
In-Reply-To: <5135DA2A.10600@gmail.com>
References: <5135BC79.7040804@gmail.com> <5135C0A9.6090504@oracle.com>
	<5135DA2A.10600@gmail.com>
Message-ID: <5135E9E0.1090100@oracle.com>

On 03/05/2013 03:42 PM, Peter Levart wrote:
> I was not really thinking about implications of visibility of final 
> field value in other threads, but only in the single thread that
> also does the Unsafe.putXXX to write to the final field. Does JIT
> also try to invalidate or update the aliases of the final field when
> Unsafe.putXXX (not putXXXVolatile or putOrderedXXX) is used to write
> to the final field, like you said it does for normal fields?

Ok, I think I'm puzzled at this question now. In HotSpot, there is no
notion of "aliasing" the fields. It's not the case we magically
constant-fold the field values in the relevant parts of the compiled
code, and deoptimize when the field is changing. It is possible with
some JSR292 magic though (see "almost final" example), but it is not
happening for usual final fields. (In practical sense, that will require
extensive meta-information associated with potentially every object with
final field).

> Asking differently: Would there be a reason to use final field and
> update it via Usafe.putXXX instead of using plain non-final field?

You can't untangle the visibility implications from the semantics here.
JIT is free to constant-fold the final value everywhere it fits, and any
external change would not be visible at those uses. If you are OK with
the possibility of this is happening, then there *is* the performance
merit in doing this, because, well... constant-folding gives you the
performance advantage.

-Aleksey.

From peter.levart at gmail.com  Tue Mar  5 08:57:25 2013
From: peter.levart at gmail.com (Peter Levart)
Date: Tue, 05 Mar 2013 14:57:25 +0100
Subject: [concurrency-interest] Unsafe.putXXX vs. normal field write
In-Reply-To: <5135E9E0.1090100@oracle.com>
References: <5135BC79.7040804@gmail.com> <5135C0A9.6090504@oracle.com>
	<5135DA2A.10600@gmail.com> <5135E9E0.1090100@oracle.com>
Message-ID: <5135F9C5.6040903@gmail.com>

Thank you Aleksey and Vitaly,

I think I get the picture approximately although your answers are quite 
the opposite: Aleksey says that JIT wins, defeating Unsafe.put and 
Vitaly says that Unsafe.put wins, defeating JIT optimizations. In either 
case my proposed usage is - unusable.

I guess that for single-threaded mutable state, the best way to model it 
is using plain fields and let the JIT do it's part optimizing it. That 
is also the answer I anticipated for my stupid question.

Thanks again,

Peter

On 03/05/2013 01:36 PM, Vitaly Davidovich wrote:
>
> I don't see much use in having a final field that's written by 
> Unsafe.  Memory model aside, final is supposed to encourage the JIT to 
> enregister their loads; in practice, there are practical issues with 
> being overly aggressive with them (there was a recent discussion 
> around this on this list).  Also, using Unsafe to do the write may 
> lead to worse code generation than using non-final field with byte 
> code access; if compiler cannot de-alias the memory due to Unsafe.put 
> it may give up on certain code motion/optimizations.
>

On 03/05/2013 01:49 PM, Aleksey Shipilev wrote:
> On 03/05/2013 03:42 PM, Peter Levart wrote:
>> I was not really thinking about implications of visibility of final
>> field value in other threads, but only in the single thread that
>> also does the Unsafe.putXXX to write to the final field. Does JIT
>> also try to invalidate or update the aliases of the final field when
>> Unsafe.putXXX (not putXXXVolatile or putOrderedXXX) is used to write
>> to the final field, like you said it does for normal fields?
> Ok, I think I'm puzzled at this question now. In HotSpot, there is no
> notion of "aliasing" the fields. It's not the case we magically
> constant-fold the field values in the relevant parts of the compiled
> code, and deoptimize when the field is changing. It is possible with
> some JSR292 magic though (see "almost final" example), but it is not
> happening for usual final fields. (In practical sense, that will require
> extensive meta-information associated with potentially every object with
> final field).
>
>> Asking differently: Would there be a reason to use final field and
>> update it via Usafe.putXXX instead of using plain non-final field?
> You can't untangle the visibility implications from the semantics here.
> JIT is free to constant-fold the final value everywhere it fits, and any
> external change would not be visible at those uses. If you are OK with
> the possibility of this is happening, then there *is* the performance
> merit in doing this, because, well... constant-folding gives you the
> performance advantage.
>
> -Aleksey.


From vitalyd at gmail.com  Tue Mar  5 09:07:37 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 5 Mar 2013 09:07:37 -0500
Subject: [concurrency-interest] Unsafe.putXXX vs. normal field write
In-Reply-To: <5135F9C5.6040903@gmail.com>
References: <5135BC79.7040804@gmail.com> <5135C0A9.6090504@oracle.com>
	<5135DA2A.10600@gmail.com> <5135E9E0.1090100@oracle.com>
	<5135F9C5.6040903@gmail.com>
Message-ID: <CAHjP37HjKhqGutLzoS9d+eQwdJBJ3Ncr5xJ+k3GXuymjVv8WGg@mail.gmail.com>

I'm not saying Unsafe wins.  All I meant was that if JIT cannot determine
target of the write it may bail on doing some optimizations - not saying
this happens frequently (or at all for some usage) but it's a possibility.
With plain java read/write it's as transparent as it gets for the compiler.

Cheers

Sent from my phone
On Mar 5, 2013 8:57 AM, "Peter Levart" <peter.levart at gmail.com> wrote:

> Thank you Aleksey and Vitaly,
>
> I think I get the picture approximately although your answers are quite
> the opposite: Aleksey says that JIT wins, defeating Unsafe.put and Vitaly
> says that Unsafe.put wins, defeating JIT optimizations. In either case my
> proposed usage is - unusable.
>
> I guess that for single-threaded mutable state, the best way to model it
> is using plain fields and let the JIT do it's part optimizing it. That is
> also the answer I anticipated for my stupid question.
>
> Thanks again,
>
> Peter
>
> On 03/05/2013 01:36 PM, Vitaly Davidovich wrote:
>
>>
>> I don't see much use in having a final field that's written by Unsafe.
>>  Memory model aside, final is supposed to encourage the JIT to enregister
>> their loads; in practice, there are practical issues with being overly
>> aggressive with them (there was a recent discussion around this on this
>> list).  Also, using Unsafe to do the write may lead to worse code
>> generation than using non-final field with byte code access; if compiler
>> cannot de-alias the memory due to Unsafe.put it may give up on certain code
>> motion/optimizations.
>>
>>
> On 03/05/2013 01:49 PM, Aleksey Shipilev wrote:
>
>> On 03/05/2013 03:42 PM, Peter Levart wrote:
>>
>>> I was not really thinking about implications of visibility of final
>>> field value in other threads, but only in the single thread that
>>> also does the Unsafe.putXXX to write to the final field. Does JIT
>>> also try to invalidate or update the aliases of the final field when
>>> Unsafe.putXXX (not putXXXVolatile or putOrderedXXX) is used to write
>>> to the final field, like you said it does for normal fields?
>>>
>> Ok, I think I'm puzzled at this question now. In HotSpot, there is no
>> notion of "aliasing" the fields. It's not the case we magically
>> constant-fold the field values in the relevant parts of the compiled
>> code, and deoptimize when the field is changing. It is possible with
>> some JSR292 magic though (see "almost final" example), but it is not
>> happening for usual final fields. (In practical sense, that will require
>> extensive meta-information associated with potentially every object with
>> final field).
>>
>>  Asking differently: Would there be a reason to use final field and
>>> update it via Usafe.putXXX instead of using plain non-final field?
>>>
>> You can't untangle the visibility implications from the semantics here.
>> JIT is free to constant-fold the final value everywhere it fits, and any
>> external change would not be visible at those uses. If you are OK with
>> the possibility of this is happening, then there *is* the performance
>> merit in doing this, because, well... constant-folding gives you the
>> performance advantage.
>>
>> -Aleksey.
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130305/f5577064/attachment.html>

From aleksey.shipilev at oracle.com  Tue Mar  5 09:37:17 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Tue, 05 Mar 2013 18:37:17 +0400
Subject: [concurrency-interest] Unsafe.putXXX vs. normal field write
In-Reply-To: <5135F9C5.6040903@gmail.com>
References: <5135BC79.7040804@gmail.com> <5135C0A9.6090504@oracle.com>
	<5135DA2A.10600@gmail.com> <5135E9E0.1090100@oracle.com>
	<5135F9C5.6040903@gmail.com>
Message-ID: <5136031D.8030401@oracle.com>

On 03/05/2013 05:57 PM, Peter Levart wrote:
> I think I get the picture approximately although your answers are quite
> the opposite: Aleksey says that JIT wins, defeating Unsafe.put and
> Vitaly says that Unsafe.put wins, defeating JIT optimizations. 

Our viewpoints are not opposite at all, we just having two different
cases in mind.

Case 1: "JIT wins", no acquire semantics for $x in the loop, thread 1 is
stuck in the infinite loop:

  final int x = 0;

  Thread 1:
     while (x == 0)
       burn();

  Thread 2:
     U.putIntVolatile(offset(#x), 100);

Case 2: "Unsafe wins": alias analysis break, what is loaded is unknown,
simple optimization to "r1 = 1;" breaks:

  final int x = 0;
  final int SOME_CRYPTIC_OFFSET_OF_X = AES_Dec(AES_Enc(offset(#x)));

  m() {
     x = 1;
     int r1 = U.getInt(SOME_CRYPTIC_OFFSET_OF_X);
  }

Thanks,
Aleksey.

From henri.tremblay at gmail.com  Wed Mar  6 14:56:17 2013
From: henri.tremblay at gmail.com (Henri Tremblay)
Date: Wed, 6 Mar 2013 20:56:17 +0100
Subject: [concurrency-interest] About Unsafe
Message-ID: <CADZL2=sgQOdWs+pmF1zS1dptE7QNTtzJLstEgaFYAvLG9ORTJA@mail.gmail.com>

Hi,

I'm really sorry if this is not the right place to ask such a question. It
occurs that it is the biggest group of Unsafe users I know.

I'm the lead developer of Objenesis which is used to create Objects (mainly
mocks) on any JVM (or at least the ones we currently support).

A long time ago, someone has requested to have us expose the Unsafe
methods across all JVMs. But my understanding is that it is now commonly
implemented on many JVMs.

The questions are:

   - Do you think it could be useful?
   - How is Unsafe supported on other JVMs apart from Hotspot?
   - Which methods would be the most useful?

No need for comments like "Unsafe is too Unsafe to be exposed!". I know
that but any who's using Objenesis is already doing strange things.

-
Henri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130306/fa106c98/attachment.html>

From stanimir at riflexo.com  Wed Mar  6 15:18:39 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Wed, 6 Mar 2013 22:18:39 +0200
Subject: [concurrency-interest] About Unsafe
In-Reply-To: <CADZL2=sgQOdWs+pmF1zS1dptE7QNTtzJLstEgaFYAvLG9ORTJA@mail.gmail.com>
References: <CADZL2=sgQOdWs+pmF1zS1dptE7QNTtzJLstEgaFYAvLG9ORTJA@mail.gmail.com>
Message-ID: <CAEJX8oqFdXQqTpnriV3WqxPjAEGOWUawQCq0YTqbb-4s0k1MnA@mail.gmail.com>

Hello,

While many of the methods of unsafe are useful to improve performance by
cutting corners, most of the its functionality is already available through
various package -
* java.lang.ref (and setAccessible) - put/get methods ,
* java.util.concurrent.atomic.AtomicFieldUpdater - mostly CAS to regular
fields - this is the usual use to bypass the checks of the updaters
* java.nio.DirectBuffers - allocateMemory/copyMemory; Technically you can
use copyMemory for fast and dirty&serialization (and unsafe)
* LockSupport - park/unpark  - those are quite safe to call but never
needed directly.
* Probably defineClass can be of use to bypass any standard verifier while
creating mock and you can extends classes you normally have no access to.
* tryMonitorEnter is an interesting one but aside deadlock avoidance
java.util.concurrent.Lock offers similar/better stuff

Basically unless you need some special memory fencing and care (a lot)
about concurrency/performance you should not need to access Unsafe directly.

Stanimir

On Wed, Mar 6, 2013 at 9:56 PM, Henri Tremblay <henri.tremblay at gmail.com>wrote:

> Hi,
>
> I'm really sorry if this is not the right place to ask such a question. It
> occurs that it is the biggest group of Unsafe users I know.
>
> I'm the lead developer of Objenesis which is used to create Objects
> (mainly mocks) on any JVM (or at least the ones we currently support).
>
> A long time ago, someone has requested to have us expose the Unsafe
> methods across all JVMs. But my understanding is that it is now commonly
> implemented on many JVMs.
>
> The questions are:
>
>    - Do you think it could be useful?
>    - How is Unsafe supported on other JVMs apart from Hotspot?
>    - Which methods would be the most useful?
>
> No need for comments like "Unsafe is too Unsafe to be exposed!". I know
> that but any who's using Objenesis is already doing strange things.
>
> -
>  Henri
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130306/725188e2/attachment.html>

From aleksey.shipilev at oracle.com  Wed Mar  6 15:28:39 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Thu, 07 Mar 2013 00:28:39 +0400
Subject: [concurrency-interest] About Unsafe
In-Reply-To: <CADZL2=sgQOdWs+pmF1zS1dptE7QNTtzJLstEgaFYAvLG9ORTJA@mail.gmail.com>
References: <CADZL2=sgQOdWs+pmF1zS1dptE7QNTtzJLstEgaFYAvLG9ORTJA@mail.gmail.com>
Message-ID: <5137A6F7.3050300@oracle.com>

Ugh.

On 03/06/2013 11:56 PM, Henri Tremblay wrote:
>   * Do you think it could be useful?

Nope. IMHO, the consensus for far is that Unsafe is not the library
class; it is the doorway into JVM hell. The libraries should securely
bridge the gap between JVM hell, developers, and users. And most of the
methods in Unsafe are really the trampolines used by other public
classes in the (non-)standard API.

>   * How is Unsafe supported on other JVMs apart from Hotspot?

By magic?

This seems to be completely library-driven. For JSR166, which is used in
many projects, including those which you can't legally (and technically)
call Java, reliance on stable Unsafe interface is the utmost need, so
Doug et al. are trying to arrange the coordinated update behind the
scenes every once in a while.

>   * Which methods would be the most useful?

All of them?

In all seriousness, you can see how much push-back we had recently with
trying to get something as constrained as Fences into the public API.
For every potentially unsecure method in Unsafe, multiply that by a few
orders of magnitude.

-Aleksey

------------ ANOTHER FLAME WAR THREAD BEGINS HERE ------------

From corporate.piyush at gmail.com  Fri Mar  8 09:01:07 2013
From: corporate.piyush at gmail.com (corporate.piyush at gmail.com)
Date: Fri, 8 Mar 2013 19:31:07 +0530
Subject: [concurrency-interest] Multithreaded Higher Order function library
	for Java 5+
In-Reply-To: <5d0b12ea6d042f28ae168110f26a58e3@nomagicsoftware.com>
References: <5d0b12ea6d042f28ae168110f26a58e3@nomagicsoftware.com>
Message-ID: <E71B1FA6B2564C2BA911FBA9CF495709@PiyushPC>


I have done a lot of work in use cases which needs to be executed 
concurrently while was with Vodafone India(telecom) to support enormous use 
request load,
I order to make it more simpler I ended up making small higher order 
function library "jHighFun" !

here is the link for the same

https://github.com/corporatepiyush/jHighFun


Regards,
Piyush katariya 


From viktor.klang at gmail.com  Fri Mar  8 09:19:06 2013
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Fri, 8 Mar 2013 15:19:06 +0100
Subject: [concurrency-interest] Multithreaded Higher Order function
 library for Java 5+
In-Reply-To: <E71B1FA6B2564C2BA911FBA9CF495709@PiyushPC>
References: <5d0b12ea6d042f28ae168110f26a58e3@nomagicsoftware.com>
	<E71B1FA6B2564C2BA911FBA9CF495709@PiyushPC>
Message-ID: <CANPzfU_tk9ojGdCUG+86vbGUNQ6OUBb_4PQnOnE+F_XRiHBTzQ@mail.gmail.com>

Hi Piyush!

Perhaps I missed something, but I couldn't find what was Multithreaded
about it?

Cheers,
?


On Fri, Mar 8, 2013 at 3:01 PM, <corporate.piyush at gmail.com> wrote:

>
> I have done a lot of work in use cases which needs to be executed
> concurrently while was with Vodafone India(telecom) to support enormous use
> request load,
> I order to make it more simpler I ended up making small higher order
> function library "jHighFun" !
>
> here is the link for the same
>
> https://github.com/**corporatepiyush/jHighFun<https://github.com/corporatepiyush/jHighFun>
>
>
> Regards,
> Piyush katariya
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
*Viktor Klang*
*Director of Engineering*
*
*
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale
Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130308/139d94ec/attachment.html>

From richard at burnison.ca  Fri Mar  8 09:34:46 2013
From: richard at burnison.ca (Richard Burnison)
Date: Fri, 8 Mar 2013 09:34:46 -0500
Subject: [concurrency-interest] Use Of putOrderedObject In ConcurrentHashMap
	Constructor
Message-ID: <20130308093446.67761783@rhea.burnison.local>

As of hg-005c0c85b0de, the main constructor in ConcurrentHashMap writes its
initial Segment, s0, into a Segment array, ss, using
Unsafe.putOrderedObject(ss, SBASE, s0). Subsequently, the final instance
field, segments, is set to ss.

My understanding is that marking 'segments' as final is already sufficient
to guarantee, at least, the transient, up-to-date visibility of 'segments[0]'
through 'segments' prior to the constructor returning (i.e. after the freeze).

Have I overlooked a subtlety of the JMM, or this implementation, that
predicates such explicit ordering?


Regards,


Richard

From stanimir at riflexo.com  Fri Mar  8 09:59:08 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Fri, 8 Mar 2013 16:59:08 +0200
Subject: [concurrency-interest] Multithreaded Higher Order function
 library for Java 5+
In-Reply-To: <CANPzfU_tk9ojGdCUG+86vbGUNQ6OUBb_4PQnOnE+F_XRiHBTzQ@mail.gmail.com>
References: <5d0b12ea6d042f28ae168110f26a58e3@nomagicsoftware.com>
	<E71B1FA6B2564C2BA911FBA9CF495709@PiyushPC>
	<CANPzfU_tk9ojGdCUG+86vbGUNQ6OUBb_4PQnOnE+F_XRiHBTzQ@mail.gmail.com>
Message-ID: <CAEJX8oqU_c-9q6q5js88FSjmWKtkznpZ4qTB+mN2eMDP-=0yzw@mail.gmail.com>

On Fri, Mar 8, 2013 at 4:19 PM, ?iktor ?lang <viktor.klang at gmail.com> wrote:

> Hi Piyush!
>
> Perhaps I missed something, but I couldn't find what was Multithreaded
> about it?
>
> org.highfun.util.FunctionUtil uses practically unbound ThreadPoolExecutor
to carry the functions.


My main critics on such such approaches (static thread pools) is that they
are unmanageable aside JVM shutdown and the only sane solution is putting
them in the main classpath as they can't be easily undeployed.
If you provide similar functionality do not resort to static pools, I'd
advise having a normal lifecycle - create/start/stop.

One of the main issues w/ them is thread creation on demand - they require
truly dedicated ThreadFactory to ensure proper ThreadGroup, change the
ContextClassLoader, and AccessControlContext, guard against Inherited
ThreadLocals, adjust Thread stack size, etc. In my experience, such threads
on demand are one of the worst leak offenders.

Regards
Stanimir


>
> On Fri, Mar 8, 2013 at 3:01 PM, <corporate.piyush at gmail.com> wrote:
>
>>
>> I have done a lot of work in use cases which needs to be executed
>> concurrently while was with Vodafone India(telecom) to support enormous use
>> request load,
>> I order to make it more simpler I ended up making small higher order
>> function library "jHighFun" !
>>
>> here is the link for the same
>>
>> https://github.com/**corporatepiyush/jHighFun<https://github.com/corporatepiyush/jHighFun>
>>
>>
>> Regards,
>> Piyush katariya
>> ______________________________**_________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>
>
>
> --
> *Viktor Klang*
> *Director of Engineering*
> *
> *
> Typesafe <http://www.typesafe.com/> - The software stack for applications
> that scale
> Twitter: @viktorklang
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130308/ab1de15e/attachment.html>

From aleksey.shipilev at oracle.com  Fri Mar  8 10:16:15 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Fri, 08 Mar 2013 19:16:15 +0400
Subject: [concurrency-interest] Use Of putOrderedObject In
 ConcurrentHashMap Constructor
In-Reply-To: <20130308093446.67761783@rhea.burnison.local>
References: <20130308093446.67761783@rhea.burnison.local>
Message-ID: <513A00BF.3060308@oracle.com>

On 03/08/2013 06:34 PM, Richard Burnison wrote:
> Have I overlooked a subtlety of the JMM, or this implementation, that
> predicates such explicit ordering?

That putOrderedObject() is the lazySet() in disguise. Segments are
apparently read/written as volatile elements, and in some corner cases
we can spare the volatile write and make the lazy write. This is
coherent with what captured in Javadoc there:

/*
     * [snip] To maintain visibility
     * in the presence of lazy construction, accesses to segments as
     * well as elements of segment's table must use volatile access,
     * which is done via Unsafe within methods segmentAt etc
     * below. These provide the functionality of AtomicReferenceArrays
     * but reduce the levels of indirection. Additionally,
     * volatile-writes of table elements and entry "next" fields
     * within locked operations use the cheaper "lazySet" forms of
     * writes (via putOrderedObject) because these writes are always
     * followed by lock releases that maintain sequential consistency
     * of table updates.
*/

I suspect you can't replace that with the plain write because that will
introduce the "formal" data race, throwing much of the standard
reasoning away. We can explore where it gets you :)

-Aleksey.

From vitalyd at gmail.com  Fri Mar  8 10:28:46 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 8 Mar 2013 10:28:46 -0500
Subject: [concurrency-interest] Use Of putOrderedObject In
 ConcurrentHashMap Constructor
In-Reply-To: <513A00BF.3060308@oracle.com>
References: <20130308093446.67761783@rhea.burnison.local>
	<513A00BF.3060308@oracle.com>
Message-ID: <CAHjP37GM10UBF73zo5Vo9ZmD=aQk98aT2xwXRW9QSvq91deF+g@mail.gmail.com>

But if this is inside ctor and assigned to final field, what's the issue?
The lazySet is StoreStore and so is the final field assignment essentially.

Sent from my phone
On Mar 8, 2013 10:19 AM, "Aleksey Shipilev" <aleksey.shipilev at oracle.com>
wrote:

> On 03/08/2013 06:34 PM, Richard Burnison wrote:
> > Have I overlooked a subtlety of the JMM, or this implementation, that
> > predicates such explicit ordering?
>
> That putOrderedObject() is the lazySet() in disguise. Segments are
> apparently read/written as volatile elements, and in some corner cases
> we can spare the volatile write and make the lazy write. This is
> coherent with what captured in Javadoc there:
>
> /*
>      * [snip] To maintain visibility
>      * in the presence of lazy construction, accesses to segments as
>      * well as elements of segment's table must use volatile access,
>      * which is done via Unsafe within methods segmentAt etc
>      * below. These provide the functionality of AtomicReferenceArrays
>      * but reduce the levels of indirection. Additionally,
>      * volatile-writes of table elements and entry "next" fields
>      * within locked operations use the cheaper "lazySet" forms of
>      * writes (via putOrderedObject) because these writes are always
>      * followed by lock releases that maintain sequential consistency
>      * of table updates.
> */
>
> I suspect you can't replace that with the plain write because that will
> introduce the "formal" data race, throwing much of the standard
> reasoning away. We can explore where it gets you :)
>
> -Aleksey.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130308/50746bf4/attachment-0001.html>

From viktor.klang at gmail.com  Fri Mar  8 11:35:32 2013
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Fri, 8 Mar 2013 17:35:32 +0100
Subject: [concurrency-interest] Multithreaded Higher Order function
 library for Java 5+
In-Reply-To: <CAEJX8oqU_c-9q6q5js88FSjmWKtkznpZ4qTB+mN2eMDP-=0yzw@mail.gmail.com>
References: <5d0b12ea6d042f28ae168110f26a58e3@nomagicsoftware.com>
	<E71B1FA6B2564C2BA911FBA9CF495709@PiyushPC>
	<CANPzfU_tk9ojGdCUG+86vbGUNQ6OUBb_4PQnOnE+F_XRiHBTzQ@mail.gmail.com>
	<CAEJX8oqU_c-9q6q5js88FSjmWKtkznpZ4qTB+mN2eMDP-=0yzw@mail.gmail.com>
Message-ID: <CANPzfU-STur3ZSyP2fPrgVkfksc+gDGJ0XMLB46afvnAxYV4Lg@mail.gmail.com>

On Fri, Mar 8, 2013 at 3:59 PM, Stanimir Simeonoff <stanimir at riflexo.com>wrote:

>
> On Fri, Mar 8, 2013 at 4:19 PM, ?iktor ?lang <viktor.klang at gmail.com>wrote:
>
>> Hi Piyush!
>>
>> Perhaps I missed something, but I couldn't find what was Multithreaded
>> about it?
>>
>> org.highfun.util.FunctionUtil uses practically unbound ThreadPoolExecutor
> to carry the functions.
>

Ah! Nice catch, I definitely made the mistake of not thinking that
FunctionUtil would contain a thread pool.


>
>
> My main critics on such such approaches (static thread pools) is that they
> are unmanageable aside JVM shutdown and the only sane solution is putting
> them in the main classpath as they can't be easily undeployed.
> If you provide similar functionality do not resort to static pools, I'd
> advise having a normal lifecycle - create/start/stop.
>
> One of the main issues w/ them is thread creation on demand - they require
> truly dedicated ThreadFactory to ensure proper ThreadGroup, change the
> ContextClassLoader, and AccessControlContext, guard against Inherited
> ThreadLocals, adjust Thread stack size, etc. In my experience, such threads
> on demand are one of the worst leak offenders.
>

Also, things like UnhandledExceptionHandler, RejectedExecutionHandler etc,
but yes, you are right. Global pools are very difficult to get right. and
they need to be configurable. As a sidenote, TPE has a really poor
scalability profile.

Cheers,
?


>
> Regards
> Stanimir
>
>
>>
>> On Fri, Mar 8, 2013 at 3:01 PM, <corporate.piyush at gmail.com> wrote:
>>
>>>
>>> I have done a lot of work in use cases which needs to be executed
>>> concurrently while was with Vodafone India(telecom) to support enormous use
>>> request load,
>>> I order to make it more simpler I ended up making small higher order
>>> function library "jHighFun" !
>>>
>>> here is the link for the same
>>>
>>> https://github.com/**corporatepiyush/jHighFun<https://github.com/corporatepiyush/jHighFun>
>>>
>>>
>>> Regards,
>>> Piyush katariya
>>> ______________________________**_________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>
>>
>>
>>
>> --
>> *Viktor Klang*
>> *Director of Engineering*
>> *
>> *
>> Typesafe <http://www.typesafe.com/> - The software stack for
>> applications that scale
>> Twitter: @viktorklang
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>


-- 
*Viktor Klang*
*Director of Engineering*
*
*
Typesafe <http://www.typesafe.com/> - The software stack for applications
that scale
Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130308/3dd9700c/attachment.html>

From raould at gmail.com  Fri Mar  8 12:46:39 2013
From: raould at gmail.com (Raoul Duke)
Date: Fri, 8 Mar 2013 09:46:39 -0800
Subject: [concurrency-interest] Multithreaded Higher Order function
 library for Java 5+
In-Reply-To: <CAEJX8oqU_c-9q6q5js88FSjmWKtkznpZ4qTB+mN2eMDP-=0yzw@mail.gmail.com>
References: <5d0b12ea6d042f28ae168110f26a58e3@nomagicsoftware.com>
	<E71B1FA6B2564C2BA911FBA9CF495709@PiyushPC>
	<CANPzfU_tk9ojGdCUG+86vbGUNQ6OUBb_4PQnOnE+F_XRiHBTzQ@mail.gmail.com>
	<CAEJX8oqU_c-9q6q5js88FSjmWKtkznpZ4qTB+mN2eMDP-=0yzw@mail.gmail.com>
Message-ID: <CAJ7XQb5HhRo2Wgrohyy26gn8bQwFZJ=ps-Hyg0TvgPkyeHjc3A@mail.gmail.com>

> org.highfun.util.FunctionUtil uses practically unbound ThreadPoolExecutor to
> carry the functions.

sheesh, aren't there other languages in which this kind of thing comes
almost for free? some might even run on the jvm.

From stanimir at riflexo.com  Fri Mar  8 13:35:08 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Fri, 8 Mar 2013 20:35:08 +0200
Subject: [concurrency-interest] Multithreaded Higher Order function
 library for Java 5+
In-Reply-To: <CAJ7XQb5HhRo2Wgrohyy26gn8bQwFZJ=ps-Hyg0TvgPkyeHjc3A@mail.gmail.com>
References: <5d0b12ea6d042f28ae168110f26a58e3@nomagicsoftware.com>
	<E71B1FA6B2564C2BA911FBA9CF495709@PiyushPC>
	<CANPzfU_tk9ojGdCUG+86vbGUNQ6OUBb_4PQnOnE+F_XRiHBTzQ@mail.gmail.com>
	<CAEJX8oqU_c-9q6q5js88FSjmWKtkznpZ4qTB+mN2eMDP-=0yzw@mail.gmail.com>
	<CAJ7XQb5HhRo2Wgrohyy26gn8bQwFZJ=ps-Hyg0TvgPkyeHjc3A@mail.gmail.com>
Message-ID: <CAEJX8opLxzO7Pb9bzMpFqSSW7OfcQREv+KKPmdQdoskQLNGZBQ@mail.gmail.com>

On Fri, Mar 8, 2013 at 7:46 PM, Raoul Duke <raould at gmail.com> wrote:

> > org.highfun.util.FunctionUtil uses practically unbound
> ThreadPoolExecutor to
> > carry the functions.
>
> sheesh, aren't there other languages in which this kind of thing comes
> almost for free? some might even run on the jvm.
>

I am sure how that's an argument. Although ThreadPoolExecutor is not so
good for map/reduces schemes, at some point someone has to manage the
threads/associated resources.
Even if you prefer fancier languages, Java itself and most of its libraries
are quite matured, so if you feel comfortable you may use it as well.

Stanimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130308/c1147f06/attachment.html>

From martinrb at google.com  Fri Mar  8 16:58:21 2013
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 8 Mar 2013 13:58:21 -0800
Subject: [concurrency-interest] Use Of putOrderedObject In
 ConcurrentHashMap Constructor
In-Reply-To: <20130308093446.67761783@rhea.burnison.local>
References: <20130308093446.67761783@rhea.burnison.local>
Message-ID: <CA+kOe0-mQBqxrGd01bTr97dNi+pLg92NT8ninkba+=QiUG2Mjg@mail.gmail.com>

On Fri, Mar 8, 2013 at 6:34 AM, Richard Burnison <richard at burnison.ca>wrote:

> As of hg-005c0c85b0de, the main constructor in ConcurrentHashMap writes its
> initial Segment, s0, into a Segment array, ss, using
> Unsafe.putOrderedObject(ss, SBASE, s0). Subsequently, the final instance
> field, segments, is set to ss.
>

The latest version of  ConcurrentHashMap no longer uses segments.
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.java?view=markup

That said, it looks to me like you are right, and the call
to putOrderedObject is not strictly necessary.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130308/fe5ab221/attachment.html>

From amath0312 at 163.com  Mon Mar 11 22:07:21 2013
From: amath0312 at 163.com (amath0312)
Date: Tue, 12 Mar 2013 10:07:21 +0800
Subject: [concurrency-interest] (no subject)
Message-ID: <201303121007203368329@163.com>



2013-03-12 



amath0312 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130312/aff4c9eb/attachment.html>

From nitsanw at yahoo.com  Thu Mar 14 08:12:46 2013
From: nitsanw at yahoo.com (Nitsan Wakart)
Date: Thu, 14 Mar 2013 05:12:46 -0700 (PDT)
Subject: [concurrency-interest] TLR false sharing avoidance using padding
Message-ID: <1363263166.68687.YahooMailNeo@web120703.mail.ne1.yahoo.com>

Hi,
Reading through?http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadLocalRandom.html code I find the following:
? ? // Padding to help avoid memory contention among seed updates in
? ? // different TLRs in the common case that they are located near
? ? // each other.
? ? private long pad0, pad1, pad2, pad3, pad4, pad5, pad6, pad7;
The fields are never used. Running through the?https://github.com/shipilev/java-object-layout I get:
Running 64-bit HotSpot VM.
Using compressed references with 3-bit shift.
Objects are 8 bytes aligned.

java.util.concurrent.ThreadLocalRandom
?offset ?size ? ? ? type description
? ? ? 0 ? ?12 ? ? ? ? ? ?(assumed to be the object header + first field alignment)
? ? ?12 ? ? 1 ? ?boolean Random.haveNextNextGaussian
? ? ?13 ? ? 3 ? ? ? ? ? ?(alignment/padding gap)
? ? ?16 ? ? 8 ? ? double Random.nextNextGaussian
? ? ?24 ? ? 4 AtomicLong Random.seed
? ? ?28 ? ? 1 ? ?boolean ThreadLocalRandom.initialized
? ? ?29 ? ? 3 ? ? ? ? ? ?(alignment/padding gap)
? ? ?32 ? ? 8 ? ? ? long ThreadLocalRandom.rnd
? ? ?40 ? ? 8 ? ? ? long ThreadLocalRandom.pad0
? ? ?48 ? ? 8 ? ? ? long ThreadLocalRandom.pad1
? ? ?56 ? ? 8 ? ? ? long ThreadLocalRandom.pad2
? ? ?64 ? ? 8 ? ? ? long ThreadLocalRandom.pad3
? ? ?72 ? ? 8 ? ? ? long ThreadLocalRandom.pad4
? ? ?80 ? ? 8 ? ? ? long ThreadLocalRandom.pad5
? ? ?88 ? ? 8 ? ? ? long ThreadLocalRandom.pad6
? ? ?96 ? ? 8 ? ? ? long ThreadLocalRandom.pad7
? ? 104 ? ? ? ? ? ? ? ? ?(object boundary, size estimate)
Which suggests the layout is as intended, but that is in contradiction to what Martin Thompson describes in his blog post here?http://mechanical-sympathy.blogspot.co.uk/2011/07/false-sharing.html and here:?http://mechanical-sympathy.blogspot.co.uk/2011/08/false-sharing-java-7.html where the JIT optimizes away the unsused fields and re-introduces false sharing.
Is this code somehow not subject to the optimization? Is the object layout tool giving me an initial view on the layout which may get changed later in life by the JIT compiler?
Thanks,
Nitsan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130314/8dd1403e/attachment.html>

From aleksey.shipilev at oracle.com  Thu Mar 14 08:47:37 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Thu, 14 Mar 2013 16:47:37 +0400
Subject: [concurrency-interest] TLR false sharing avoidance using padding
In-Reply-To: <1363263166.68687.YahooMailNeo@web120703.mail.ne1.yahoo.com>
References: <1363263166.68687.YahooMailNeo@web120703.mail.ne1.yahoo.com>
Message-ID: <5141C6E9.3010809@oracle.com>

Ok, I'll try to answer all the questions at once:

On 03/14/2013 04:12 PM, Nitsan Wakart wrote:
> Using compressed references with 3-bit shift.
> Objects are 8 bytes aligned.
> 
> java.util.concurrent.ThreadLocalRandom
>  offset  size       type description
>       0    12            (assumed to be the object header + first field
> alignment)
>      12     1    boolean Random.haveNextNextGaussian
>      13     3            (alignment/padding gap)
>      16     8     double Random.nextNextGaussian
>      24     4 AtomicLong Random.seed
>      28     1    boolean ThreadLocalRandom.initialized
>      29     3            (alignment/padding gap)
>      32     8       long ThreadLocalRandom.rnd
>      40     8       long ThreadLocalRandom.pad0
>      48     8       long ThreadLocalRandom.pad1
>      56     8       long ThreadLocalRandom.pad2
>      64     8       long ThreadLocalRandom.pad3
>      72     8       long ThreadLocalRandom.pad4
>      80     8       long ThreadLocalRandom.pad5
>      88     8       long ThreadLocalRandom.pad6
>      96     8       long ThreadLocalRandom.pad7
>     104                  (object boundary, size estimate)

It's worth noting that this padding only protects the false sharing from
the behind. You still can experience the false sharing with the adjacent
object just above the TLR instance. The absence of fine control over
this pushed us over implementing @Contended.

BTW, for JDK8-ish TLR it is already different, because the state is
moved to j.l.Thread, pretty much invalidating the issue :) (There is a
lingering debate between me and Doug if j.l.Thread itself should be
padded/@Contended)

> Which suggests the layout is as intended, but that is in contradiction
> to what Martin Thompson describes in his blog post
> here http://mechanical-sympathy.blogspot.co.uk/2011/07/false-sharing.html and
> here: http://mechanical-sympathy.blogspot.co.uk/2011/08/false-sharing-java-7.html
> where the JIT optimizes away the unsused fields and re-introduces false
> sharing.

Martin is accurate enough to claim "it seems Java 7 got clever and
eliminated OR RE-ORDERED the unused fields". Eliminating the fields
without future-predicting capabilities would require the facility to
redefine the class, reviving back the eliminated fields once anyone in
the unpredictable feature (e.g. class is coming over the network) is
about the read/write that field.

> Is this code somehow not subject to the optimization? Is the object
> layout tool giving me an initial view on the layout which may get
> changed later in life by the JIT compiler?

Can't tell for other VMs. HotSpot does not change the layout of the
class after the classloading. The current capabilities for class
redefinition are quite limited (see "HotSwap"), but that could change
with http://openjdk.java.net/jeps/159.

Hence, at this point, java-object-layout view is consistent with the
object layout throughout the JVM lifetime.

-Aleksey.

From nitsanw at yahoo.com  Thu Mar 14 09:08:06 2013
From: nitsanw at yahoo.com (Nitsan Wakart)
Date: Thu, 14 Mar 2013 06:08:06 -0700 (PDT)
Subject: [concurrency-interest] TLR false sharing avoidance using padding
In-Reply-To: <5141C6E9.3010809@oracle.com>
References: <1363263166.68687.YahooMailNeo@web120703.mail.ne1.yahoo.com>
	<5141C6E9.3010809@oracle.com>
Message-ID: <1363266486.44515.YahooMailNeo@web120704.mail.ne1.yahoo.com>

Thanks for your quick reply.
"It's worth noting that this padding only protects the false sharing from
>the behind. You still can experience the false sharing with the adjacent
>object just above the TLR instance. The absence of fine control over
>this pushed us over implementing @Contended."
I would also add that it is only going to work where cache line size is 64b, failing on processors with 128b wide cache lines.

"Martin is accurate enough to claim "it seems Java 7 got clever and
>eliminated OR RE-ORDERED the unused fields". "
I accept your criticism :), as I have no way to reproduce his environment or end result memory layout I assumed the worse of the 2.

"Hence, at this point, java-object-layout view is consistent with the
>object layout throughout the JVM lifetime."
Great, that means I can rely on the object-layout tool output to verify false sharing protection rather than guess at it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130314/be3c34a6/attachment.html>

From aleksey.shipilev at oracle.com  Thu Mar 14 09:12:18 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Thu, 14 Mar 2013 17:12:18 +0400
Subject: [concurrency-interest] TLR false sharing avoidance using padding
In-Reply-To: <1363266486.44515.YahooMailNeo@web120704.mail.ne1.yahoo.com>
References: <1363263166.68687.YahooMailNeo@web120703.mail.ne1.yahoo.com>
	<5141C6E9.3010809@oracle.com>
	<1363266486.44515.YahooMailNeo@web120704.mail.ne1.yahoo.com>
Message-ID: <5141CCB2.6000406@oracle.com>

On 03/14/2013 05:08 PM, Nitsan Wakart wrote:
> I would also add that it is only going to work where cache line size is
> 64b, failing on processors with 128b wide cache lines.

Well, it can also fail badly with 64b cache lines, but adjacent cache
line prefetchers enabled (it is actually reproducible on some of the my
x86 servers). This is why the default value for @Contended padding we
pushed to JDK8 was 128b.

> Great, that means I can rely on the object-layout tool output to verify
> false sharing protection rather than guess at it.

Yes, it was built on the premise to track what @Contended is actually
doing under the cover.

-Aleksey.


From stanimir at riflexo.com  Thu Mar 14 09:19:33 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Thu, 14 Mar 2013 15:19:33 +0200
Subject: [concurrency-interest] TLR false sharing avoidance using padding
In-Reply-To: <5141CCB2.6000406@oracle.com>
References: <1363263166.68687.YahooMailNeo@web120703.mail.ne1.yahoo.com>
	<5141C6E9.3010809@oracle.com>
	<1363266486.44515.YahooMailNeo@web120704.mail.ne1.yahoo.com>
	<5141CCB2.6000406@oracle.com>
Message-ID: <CAEJX8ooWuByZWvdV5mWWwtOgyqQA2Yco+RFj15Q_ncQJdv_shg@mail.gmail.com>

Would @Contended be ignored if running on a (physical) single core only?

Stanimir

On Thu, Mar 14, 2013 at 3:12 PM, Aleksey Shipilev <
aleksey.shipilev at oracle.com> wrote:

> On 03/14/2013 05:08 PM, Nitsan Wakart wrote:
> > I would also add that it is only going to work where cache line size is
> > 64b, failing on processors with 128b wide cache lines.
>
> Well, it can also fail badly with 64b cache lines, but adjacent cache
> line prefetchers enabled (it is actually reproducible on some of the my
> x86 servers). This is why the default value for @Contended padding we
> pushed to JDK8 was 128b.
>
> > Great, that means I can rely on the object-layout tool output to verify
> > false sharing protection rather than guess at it.
>
> Yes, it was built on the premise to track what @Contended is actually
> doing under the cover.
>
> -Aleksey.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130314/66ba9a39/attachment-0001.html>

From aleksey.shipilev at oracle.com  Thu Mar 14 10:28:27 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Thu, 14 Mar 2013 18:28:27 +0400
Subject: [concurrency-interest] TLR false sharing avoidance using padding
In-Reply-To: <CAEJX8ooWuByZWvdV5mWWwtOgyqQA2Yco+RFj15Q_ncQJdv_shg@mail.gmail.com>
References: <1363263166.68687.YahooMailNeo@web120703.mail.ne1.yahoo.com>
	<5141C6E9.3010809@oracle.com>
	<1363266486.44515.YahooMailNeo@web120704.mail.ne1.yahoo.com>
	<5141CCB2.6000406@oracle.com>
	<CAEJX8ooWuByZWvdV5mWWwtOgyqQA2Yco+RFj15Q_ncQJdv_shg@mail.gmail.com>
Message-ID: <5141DE8B.4010605@oracle.com>

On 03/14/2013 05:19 PM, Stanimir Simeonoff wrote:
> Would @Contended be ignored if running on a (physical) single core
> only?

With current implementation, it will still be in effect. We can nil the
effects when we detect 1 available CPU, like we do with eliding memory
barriers.

Is there a desire to have this corner case optimization?

-Aleksey.

From stanimir at riflexo.com  Thu Mar 14 10:45:31 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Thu, 14 Mar 2013 16:45:31 +0200
Subject: [concurrency-interest] TLR false sharing avoidance using padding
In-Reply-To: <5141DE8B.4010605@oracle.com>
References: <1363263166.68687.YahooMailNeo@web120703.mail.ne1.yahoo.com>
	<5141C6E9.3010809@oracle.com>
	<1363266486.44515.YahooMailNeo@web120704.mail.ne1.yahoo.com>
	<5141CCB2.6000406@oracle.com>
	<CAEJX8ooWuByZWvdV5mWWwtOgyqQA2Yco+RFj15Q_ncQJdv_shg@mail.gmail.com>
	<5141DE8B.4010605@oracle.com>
Message-ID: <CAEJX8or1NGGvREN3-AejQBarOywQuG-epb6+YK1YevL5rM+s9Q@mail.gmail.com>

I was just curious, however it can potentially affect people running under
virtualization, esp if the annotation becomes common.

Stanimir

On Thu, Mar 14, 2013 at 4:28 PM, Aleksey Shipilev <
aleksey.shipilev at oracle.com> wrote:

> On 03/14/2013 05:19 PM, Stanimir Simeonoff wrote:
> > Would @Contended be ignored if running on a (physical) single core
> > only?
>
> With current implementation, it will still be in effect. We can nil the
> effects when we detect 1 available CPU, like we do with eliding memory
> barriers.
>
> Is there a desire to have this corner case optimization?
>
> -Aleksey.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130314/12e79b1d/attachment.html>

From logogin at hotbox.ru  Thu Mar 14 11:09:45 2013
From: logogin at hotbox.ru (logogin at hotbox.ru)
Date: Thu, 14 Mar 2013 19:09:45 +0400
Subject: [concurrency-interest] ExecutorService.newFixedThreadPool,
	submit operation and new threads
Message-ID: <d7deb98b5247dbf776d4135197720bcc68079787@mail.qip.ru>

Hello,
I can see in javadoc for java.util.concurrent.Executors.newFixedThreadPool(int):
... If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. ...

But what I am experiencing is a different worker thread life-cycle for java.util.concurrent.ExecutorService.submit(Runnable) and java.util.concurrent.Executor.execute(Runnable) in case of fixed thread pool. Seems like for "execute" method it performs as stated in javadoc, but for "submit" - the worker thread is never replaced by new one in case of task failure.
Here is code snippet to show the behavior:

This is execute case:
public void execute_spawn_new() throws Exception {
        System.out.println("execute");
        ExecutorService exec = Executors.newFixedThreadPool(1);
        final CountDownLatch latch = new CountDownLatch(1);
        exec.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(String.format("Thread[%s, id=%d]", Thread.currentThread().getName(), Thread.currentThread().getId()));
                latch.countDown();
            }
        });
        latch.await();

        exec.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(String.format("Thread[%s, id=%d]", Thread.currentThread().getName(), Thread.currentThread().getId()));
                latch.countDown();
                throw new RuntimeException("failed to complete");
            }
        });
        latch.await();

        exec.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(String.format("Thread[%s, id=%d]", Thread.currentThread().getName(), Thread.currentThread().getId()));
                latch.countDown();
            }
        });
        latch.await();
}

the output is:
Thread[pool-1-thread-1, id=9]
Thread[pool-1-thread-1, id=9]
Exception in thread "pool-1-thread-1" java.lang.RuntimeException:
failed to complete
...stack trace here...
Thread[pool-1-thread-2, id=10]

It is clearly visible that Thread id=10 replaced failed one in the pool.

This is submit case:
public void submit_spawn_new() throws Exception {
        System.out.println("submit");
        ExecutorService exec = Executors.newFixedThreadPool(1);
        final CountDownLatch latch = new CountDownLatch(1);
        exec.submit(new Runnable() {
            @Override
            public void run() {
                System.out.println(String.format("Thread[%s, id=%d]", Thread.currentThread().getName(), Thread.currentThread().getId()));
                latch.countDown();
            }
        }).get();
        latch.await();

        try {
            exec.submit(new Runnable() {
                @Override
                public void run() {
                    System.out.println(String.format("Thread[%s, id=%d]", Thread.currentThread().getName(), Thread.currentThread().getId()));
                    latch.countDown();
                    throw new RuntimeException("failed to complete");
                }
            }).get();
        } catch (Throwable ex) {
            ex.printStackTrace();
        }
        latch.await();

        exec.submit(new Runnable() {
            @Override
            public void run() {
                System.out.println(String.format("Thread[%s, id=%d]", Thread.currentThread().getName(), Thread.currentThread().getId()));
                latch.countDown();
            }
        }).get();
        latch.await();
}

Thread[pool-2-thread-1, id=11]
Thread[pool-2-thread-1, id=11]
java.util.concurrent.ExecutionException: java.lang.RuntimeException:
failed to complete
...stack trace here...
Thread[pool-2-thread-1, id=11]

Now the Thread id=11 still remains in the pool and capable to take tasks.

Could someone please clarify above differences.
Thanks


From martinrb at google.com  Thu Mar 14 11:33:17 2013
From: martinrb at google.com (Martin Buchholz)
Date: Thu, 14 Mar 2013 08:33:17 -0700
Subject: [concurrency-interest] ExecutorService.newFixedThreadPool,
 submit operation and new threads
In-Reply-To: <d7deb98b5247dbf776d4135197720bcc68079787@mail.qip.ru>
References: <d7deb98b5247dbf776d4135197720bcc68079787@mail.qip.ru>
Message-ID: <CA+kOe0-TprkB4mwBY8BMtsEwrLwiwCzcpRgA=6rR-6czj5E+vg@mail.gmail.com>

The difference is that with submit, the Runnable is wrapped, the exception
is caught and stored in the Future and not propagated to the pool thread.
 This distinction is not explained adequately in the docs, I think.


On Thu, Mar 14, 2013 at 8:09 AM, <logogin at hotbox.ru> wrote:

> Hello,
> I can see in javadoc for
> java.util.concurrent.Executors.newFixedThreadPool(int):
> ... If any thread terminates due to a failure during execution prior to
> shutdown, a new one will take its place if needed to execute subsequent
> tasks. ...
>
> But what I am experiencing is a different worker thread life-cycle for
> java.util.concurrent.ExecutorService.submit(Runnable) and
> java.util.concurrent.Executor.execute(Runnable) in case of fixed thread
> pool. Seems like for "execute" method it performs as stated in javadoc, but
> for "submit" - the worker thread is never replaced by new one in case of
> task failure.
> Here is code snippet to show the behavior:
>
> This is execute case:
> public void execute_spawn_new() throws Exception {
>         System.out.println("execute");
>         ExecutorService exec = Executors.newFixedThreadPool(1);
>         final CountDownLatch latch = new CountDownLatch(1);
>         exec.execute(new Runnable() {
>             @Override
>             public void run() {
>                 System.out.println(String.format("Thread[%s, id=%d]",
> Thread.currentThread().getName(), Thread.currentThread().getId()));
>                 latch.countDown();
>             }
>         });
>         latch.await();
>
>         exec.execute(new Runnable() {
>             @Override
>             public void run() {
>                 System.out.println(String.format("Thread[%s, id=%d]",
> Thread.currentThread().getName(), Thread.currentThread().getId()));
>                 latch.countDown();
>                 throw new RuntimeException("failed to complete");
>             }
>         });
>         latch.await();
>
>         exec.execute(new Runnable() {
>             @Override
>             public void run() {
>                 System.out.println(String.format("Thread[%s, id=%d]",
> Thread.currentThread().getName(), Thread.currentThread().getId()));
>                 latch.countDown();
>             }
>         });
>         latch.await();
> }
>
> the output is:
> Thread[pool-1-thread-1, id=9]
> Thread[pool-1-thread-1, id=9]
> Exception in thread "pool-1-thread-1" java.lang.RuntimeException:
> failed to complete
> ...stack trace here...
> Thread[pool-1-thread-2, id=10]
>
> It is clearly visible that Thread id=10 replaced failed one in the pool.
>
> This is submit case:
> public void submit_spawn_new() throws Exception {
>         System.out.println("submit");
>         ExecutorService exec = Executors.newFixedThreadPool(1);
>         final CountDownLatch latch = new CountDownLatch(1);
>         exec.submit(new Runnable() {
>             @Override
>             public void run() {
>                 System.out.println(String.format("Thread[%s, id=%d]",
> Thread.currentThread().getName(), Thread.currentThread().getId()));
>                 latch.countDown();
>             }
>         }).get();
>         latch.await();
>
>         try {
>             exec.submit(new Runnable() {
>                 @Override
>                 public void run() {
>                     System.out.println(String.format("Thread[%s, id=%d]",
> Thread.currentThread().getName(), Thread.currentThread().getId()));
>                     latch.countDown();
>                     throw new RuntimeException("failed to complete");
>                 }
>             }).get();
>         } catch (Throwable ex) {
>             ex.printStackTrace();
>         }
>         latch.await();
>
>         exec.submit(new Runnable() {
>             @Override
>             public void run() {
>                 System.out.println(String.format("Thread[%s, id=%d]",
> Thread.currentThread().getName(), Thread.currentThread().getId()));
>                 latch.countDown();
>             }
>         }).get();
>         latch.await();
> }
>
> Thread[pool-2-thread-1, id=11]
> Thread[pool-2-thread-1, id=11]
> java.util.concurrent.ExecutionException: java.lang.RuntimeException:
> failed to complete
> ...stack trace here...
> Thread[pool-2-thread-1, id=11]
>
> Now the Thread id=11 still remains in the pool and capable to take tasks.
>
> Could someone please clarify above differences.
> Thanks
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130314/6ee9cc5f/attachment.html>

From ariel at weisberg.ws  Thu Mar 14 12:45:16 2013
From: ariel at weisberg.ws (Ariel Weisberg)
Date: Thu, 14 Mar 2013 12:45:16 -0400
Subject: [concurrency-interest] ExecutorService.newFixedThreadPool,
 submit operation and new threads
In-Reply-To: <CA+kOe0-TprkB4mwBY8BMtsEwrLwiwCzcpRgA=6rR-6czj5E+vg@mail.gmail.com>
References: <d7deb98b5247dbf776d4135197720bcc68079787@mail.qip.ru>
	<CA+kOe0-TprkB4mwBY8BMtsEwrLwiwCzcpRgA=6rR-6czj5E+vg@mail.gmail.com>
Message-ID: <1363279516.21581.140661204375217.1462D13C@webmail.messagingengine.com>

Hi,



And to make it more interesting, while TPE will not wrap tasks
submitted by execute in a FutureTask, STPE will. That means that
uncaught exceptions will disappear into the FutureTask in an STPE and
not propagate to the pool thread's uncaught exception handler.



Regards,

Ariel





On Thu, Mar 14, 2013, at 11:33 AM, Martin Buchholz wrote:

The difference is that with submit, the Runnable is wrapped, the
exception is caught and stored in the Future and not propagated to the
pool thread.  This distinction is not explained adequately in the docs,
I think.



On Thu, Mar 14, 2013 at 8:09 AM, <[1]logogin at hotbox.ru> wrote:

Hello,

I can see in javadoc for
java.util.concurrent.Executors.newFixedThreadPool(int):

... If any thread terminates due to a failure during execution prior to
shutdown, a new one will take its place if needed to execute subsequent
tasks. ...



But what I am experiencing is a different worker thread life-cycle for
java.util.concurrent.ExecutorService.submit(Runnable) and
java.util.concurrent.Executor.execute(Runnable) in case of fixed thread
pool. Seems like for "execute" method it performs as stated in javadoc,
but for "submit" - the worker thread is never replaced by new one in
case of task failure.

Here is code snippet to show the behavior:



This is execute case:

public void execute_spawn_new() throws Exception {

        System.out.println("execute");

        ExecutorService exec = Executors.newFixedThreadPool(1);

        final CountDownLatch latch = new CountDownLatch(1);

        exec.execute(new Runnable() {

            @Override

            public void run() {

                System.out.println(String.format("Thread[%s, id=%d]",
Thread.currentThread().getName(), Thread.currentThread().getId()));

                latch.countDown();

            }

        });

        latch.await();



        exec.execute(new Runnable() {

            @Override

            public void run() {

                System.out.println(String.format("Thread[%s, id=%d]",
Thread.currentThread().getName(), Thread.currentThread().getId()));

                latch.countDown();

                throw new RuntimeException("failed to complete");

            }

        });

        latch.await();



        exec.execute(new Runnable() {

            @Override

            public void run() {

                System.out.println(String.format("Thread[%s, id=%d]",
Thread.currentThread().getName(), Thread.currentThread().getId()));

                latch.countDown();

            }

        });

        latch.await();

}



the output is:

Thread[pool-1-thread-1, id=9]

Thread[pool-1-thread-1, id=9]

Exception in thread "pool-1-thread-1" java.lang.RuntimeException:

failed to complete

...stack trace here...

Thread[pool-1-thread-2, id=10]



It is clearly visible that Thread id=10 replaced failed one in the
pool.



This is submit case:

public void submit_spawn_new() throws Exception {

        System.out.println("submit");

        ExecutorService exec = Executors.newFixedThreadPool(1);

        final CountDownLatch latch = new CountDownLatch(1);

        exec.submit(new Runnable() {

            @Override

            public void run() {

                System.out.println(String.format("Thread[%s, id=%d]",
Thread.currentThread().getName(), Thread.currentThread().getId()));

                latch.countDown();

            }

        }).get();

        latch.await();



        try {

            exec.submit(new Runnable() {

                @Override

                public void run() {

                    System.out.println(String.format("Thread[%s,
id=%d]", Thread.currentThread().getName(),
Thread.currentThread().getId()));

                    latch.countDown();

                    throw new RuntimeException("failed to complete");

                }

            }).get();

        } catch (Throwable ex) {

            ex.printStackTrace();

        }

        latch.await();



        exec.submit(new Runnable() {

            @Override

            public void run() {

                System.out.println(String.format("Thread[%s, id=%d]",
Thread.currentThread().getName(), Thread.currentThread().getId()));

                latch.countDown();

            }

        }).get();

        latch.await();

}



Thread[pool-2-thread-1, id=11]

Thread[pool-2-thread-1, id=11]

java.util.concurrent.ExecutionException: java.lang.RuntimeException:

failed to complete

...stack trace here...

Thread[pool-2-thread-1, id=11]



Now the Thread id=11 still remains in the pool and capable to take
tasks.



Could someone please clarify above differences.

Thanks



_______________________________________________

Concurrency-interest mailing list

[2]Concurrency-interest at cs.oswego.edu

[3]http://cs.oswego.edu/mailman/listinfo/concurrency-interest




_______________________________________________

Concurrency-interest mailing list

[4]Concurrency-interest at cs.oswego.edu

[5]http://cs.oswego.edu/mailman/listinfo/concurrency-interest

References

1. mailto:logogin at hotbox.ru
2. mailto:Concurrency-interest at cs.oswego.edu
3. http://cs.oswego.edu/mailman/listinfo/concurrency-interest
4. mailto:Concurrency-interest at cs.oswego.edu
5. http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130314/c4c23ff7/attachment.html>

From zhong.j.yu at gmail.com  Thu Mar 14 17:21:53 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Thu, 14 Mar 2013 16:21:53 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
Message-ID: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>

java.lang.Thread

    private char name[];

    public final void setName(String name) {
        checkAccess();
        this.name = name.toCharArray();
    }

    public final String getName() {
        return String.valueOf(name);
    }

On the surface, set/getName() are not correctly synchronized,
getName() could observe a partially filled char array. What's the
story here?

Zhong Yu

From gregg at cytetech.com  Thu Mar 14 17:30:03 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Thu, 14 Mar 2013 16:30:03 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
Message-ID: <5142415B.1080109@cytetech.com>

It looks to me that getName() can only see a 'this.name' which 
"name.toCharArray()" in setName() has completely filled in.

Gregg Wonderly

On 3/14/2013 4:21 PM, Zhong Yu wrote:
> java.lang.Thread
>
>      private char name[];
>
>      public final void setName(String name) {
>          checkAccess();
>          this.name = name.toCharArray();
>      }
>
>      public final String getName() {
>          return String.valueOf(name);
>      }
>
> On the surface, set/getName() are not correctly synchronized,
> getName() could observe a partially filled char array. What's the
> story here?
>
> Zhong Yu
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From aleksey.shipilev at oracle.com  Thu Mar 14 17:49:36 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Fri, 15 Mar 2013 01:49:36 +0400
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
Message-ID: <514245F0.9080406@oracle.com>

On 03/15/2013 01:21 AM, Zhong Yu wrote:
> java.lang.Thread
> 
>     private char name[];
> 
>     public final void setName(String name) {
>         checkAccess();
>         this.name = name.toCharArray();
>     }
> 
>     public final String getName() {
>         return String.valueOf(name);
>     }
> 
> On the surface, set/getName() are not correctly synchronized,
> getName() could observe a partially filled char array. What's the
> story here?

I think calling getName() is safe within the thread itself, because
Thread.start() happens-before any other action in that thread, and you
normally set the name before starting the thread. Otherwise, this is
subject to the same consistency considerations as any other code.

-Aleksey.


From stanimir at riflexo.com  Thu Mar 14 17:51:12 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Thu, 14 Mar 2013 23:51:12 +0200
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
Message-ID: <CAEJX8op946+W1BXdkk20cNdvpWrcQPuZqZWETOzbrkRM3Ufcbw@mail.gmail.com>

char[] name is usually initialized in the c-tor, in that case it'd be fine.
Since the access to 'name' is racy to begin, the changes may not be
necessarily 'visible'.

Stanimir

On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> java.lang.Thread
>
>     private char name[];
>
>     public final void setName(String name) {
>         checkAccess();
>         this.name = name.toCharArray();
>     }
>
>     public final String getName() {
>         return String.valueOf(name);
>     }
>
> On the surface, set/getName() are not correctly synchronized,
> getName() could observe a partially filled char array. What's the
> story here?
>
> Zhong Yu
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130314/68c6235a/attachment-0001.html>

From zhong.j.yu at gmail.com  Thu Mar 14 17:55:36 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Thu, 14 Mar 2013 16:55:36 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CAEJX8op946+W1BXdkk20cNdvpWrcQPuZqZWETOzbrkRM3Ufcbw@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<CAEJX8op946+W1BXdkk20cNdvpWrcQPuZqZWETOzbrkRM3Ufcbw@mail.gmail.com>
Message-ID: <CACuKZqGQSaAgOaEF_hvsgaF7BfZ6t3FYrsG-5DfyERhRYGfFjw@mail.gmail.com>

It's a common practice to modify thread names on the fly, for
diagnosis purposes.

On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
<stanimir at riflexo.com> wrote:
> char[] name is usually initialized in the c-tor, in that case it'd be fine.
> Since the access to 'name' is racy to begin, the changes may not be
> necessarily 'visible'.
>
> Stanimir
>
> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>
>> java.lang.Thread
>>
>>     private char name[];
>>
>>     public final void setName(String name) {
>>         checkAccess();
>>         this.name = name.toCharArray();
>>     }
>>
>>     public final String getName() {
>>         return String.valueOf(name);
>>     }
>>
>> On the surface, set/getName() are not correctly synchronized,
>> getName() could observe a partially filled char array. What's the
>> story here?
>>
>> Zhong Yu
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From aleksey.shipilev at oracle.com  Thu Mar 14 18:09:20 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Fri, 15 Mar 2013 02:09:20 +0400
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqGQSaAgOaEF_hvsgaF7BfZ6t3FYrsG-5DfyERhRYGfFjw@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<CAEJX8op946+W1BXdkk20cNdvpWrcQPuZqZWETOzbrkRM3Ufcbw@mail.gmail.com>
	<CACuKZqGQSaAgOaEF_hvsgaF7BfZ6t3FYrsG-5DfyERhRYGfFjw@mail.gmail.com>
Message-ID: <51424A90.2000601@oracle.com>

I'm not sure where this "common practice" is practiced, but it seems to
be inherently racy. Nothing special prevents you from reading the
incomplete name[]. It should be at least volatile to provide the
necessary semantics under the racy updates.

-Aleksey.

On 03/15/2013 01:55 AM, Zhong Yu wrote:
> It's a common practice to modify thread names on the fly, for
> diagnosis purposes.
> 
> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
> <stanimir at riflexo.com> wrote:
>> char[] name is usually initialized in the c-tor, in that case it'd be fine.
>> Since the access to 'name' is racy to begin, the changes may not be
>> necessarily 'visible'.
>>
>> Stanimir
>>
>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>
>>> java.lang.Thread
>>>
>>>     private char name[];
>>>
>>>     public final void setName(String name) {
>>>         checkAccess();
>>>         this.name = name.toCharArray();
>>>     }
>>>
>>>     public final String getName() {
>>>         return String.valueOf(name);
>>>     }
>>>
>>> On the surface, set/getName() are not correctly synchronized,
>>> getName() could observe a partially filled char array. What's the
>>> story here?
>>>
>>> Zhong Yu
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From raimund.klein at uni-bremen.de  Thu Mar 14 18:16:13 2013
From: raimund.klein at uni-bremen.de (Raimund Klein)
Date: Thu, 14 Mar 2013 23:16:13 +0100
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqGQSaAgOaEF_hvsgaF7BfZ6t3FYrsG-5DfyERhRYGfFjw@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<CAEJX8op946+W1BXdkk20cNdvpWrcQPuZqZWETOzbrkRM3Ufcbw@mail.gmail.com>
	<CACuKZqGQSaAgOaEF_hvsgaF7BfZ6t3FYrsG-5DfyERhRYGfFjw@mail.gmail.com>
Message-ID: <51424C2D.5040809@uni-bremen.de>

Since when is that "common practice"? I don't think I ever did that - I 
usually rely on using the Executors class combined with a ThreadFactory 
that will give me an appropriate name from the very beginning.

Cheers
Ray

On 14.03.2013 22:55, Zhong Yu wrote:
> It's a common practice to modify thread names on the fly, for
> diagnosis purposes.
>
> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
> <stanimir at riflexo.com> wrote:
>> char[] name is usually initialized in the c-tor, in that case it'd be fine.
>> Since the access to 'name' is racy to begin, the changes may not be
>> necessarily 'visible'.
>>
>> Stanimir
>>
>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>
>>> java.lang.Thread
>>>
>>>      private char name[];
>>>
>>>      public final void setName(String name) {
>>>          checkAccess();
>>>          this.name = name.toCharArray();
>>>      }
>>>
>>>      public final String getName() {
>>>          return String.valueOf(name);
>>>      }
>>>
>>> On the surface, set/getName() are not correctly synchronized,
>>> getName() could observe a partially filled char array. What's the
>>> story here?
>>>
>>> Zhong Yu
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



From zhong.j.yu at gmail.com  Thu Mar 14 18:22:15 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Thu, 14 Mar 2013 17:22:15 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51424C2D.5040809@uni-bremen.de>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<CAEJX8op946+W1BXdkk20cNdvpWrcQPuZqZWETOzbrkRM3Ufcbw@mail.gmail.com>
	<CACuKZqGQSaAgOaEF_hvsgaF7BfZ6t3FYrsG-5DfyERhRYGfFjw@mail.gmail.com>
	<51424C2D.5040809@uni-bremen.de>
Message-ID: <CACuKZqF1maR+0vEHWUwPb0WBFicA-3Wom0XAuaMw=3vaAO=S1w@mail.gmail.com>

Well, the method is public, isn't it:) People are gonna use it.

What is the point to name a thread anyway? Nothing really, other than
for diagnosis. One could, for example, append IP address to the name
of a thread which is handling an http request from that IP. He can
then cross reference http access logs and application logs for some
detective work.

Zhong Yu

On Thu, Mar 14, 2013 at 5:16 PM, Raimund Klein
<raimund.klein at uni-bremen.de> wrote:
> Since when is that "common practice"? I don't think I ever did that - I
> usually rely on using the Executors class combined with a ThreadFactory that
> will give me an appropriate name from the very beginning.
>
> Cheers
> Ray
>
> On 14.03.2013 22:55, Zhong Yu wrote:
>>
>> It's a common practice to modify thread names on the fly, for
>> diagnosis purposes.
>>
>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>> <stanimir at riflexo.com> wrote:
>>>
>>> char[] name is usually initialized in the c-tor, in that case it'd be
>>> fine.
>>> Since the access to 'name' is racy to begin, the changes may not be
>>> necessarily 'visible'.
>>>
>>> Stanimir
>>>
>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>>
>>>>
>>>> java.lang.Thread
>>>>
>>>>      private char name[];
>>>>
>>>>      public final void setName(String name) {
>>>>          checkAccess();
>>>>          this.name = name.toCharArray();
>>>>      }
>>>>
>>>>      public final String getName() {
>>>>          return String.valueOf(name);
>>>>      }
>>>>
>>>> On the surface, set/getName() are not correctly synchronized,
>>>> getName() could observe a partially filled char array. What's the
>>>> story here?
>>>>
>>>> Zhong Yu
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From javamann at cox.net  Thu Mar 14 18:23:18 2013
From: javamann at cox.net (javamann at cox.net)
Date: Thu, 14 Mar 2013 18:23:18 -0400
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51424C2D.5040809@uni-bremen.de>
Message-ID: <20130314222318.21107.21616.imail@fed1rmwml214>

Way back in the 90's, before I knew better, I used to set the name of a Thread during execution as a way of passing a message to the Thread.

-Pete

---- Raimund Klein <raimund.klein at uni-bremen.de> wrote: 

=============
Since when is that "common practice"? I don't think I ever did that - I 
usually rely on using the Executors class combined with a ThreadFactory 
that will give me an appropriate name from the very beginning.

Cheers
Ray

On 14.03.2013 22:55, Zhong Yu wrote:
> It's a common practice to modify thread names on the fly, for
> diagnosis purposes.
>
> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
> <stanimir at riflexo.com> wrote:
>> char[] name is usually initialized in the c-tor, in that case it'd be fine.
>> Since the access to 'name' is racy to begin, the changes may not be
>> necessarily 'visible'.
>>
>> Stanimir
>>
>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>
>>> java.lang.Thread
>>>
>>>      private char name[];
>>>
>>>      public final void setName(String name) {
>>>          checkAccess();
>>>          this.name = name.toCharArray();
>>>      }
>>>
>>>      public final String getName() {
>>>          return String.valueOf(name);
>>>      }
>>>
>>> On the surface, set/getName() are not correctly synchronized,
>>> getName() could observe a partially filled char array. What's the
>>> story here?
>>>
>>> Zhong Yu
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

--

1. If a man is standing in the middle of the forest talking, and there is no woman around to hear him, is he still wrong?

2. Behind every great woman... Is a man checking out her ass

3. I am not a member of any organized political party. I am a Democrat.*

4. Diplomacy is the art of saying "Nice doggie" until you can find a rock.*

5. A process is what you need when all your good people have left.


*Will Rogers



From stanimir at riflexo.com  Thu Mar 14 18:26:59 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Fri, 15 Mar 2013 00:26:59 +0200
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqGQSaAgOaEF_hvsgaF7BfZ6t3FYrsG-5DfyERhRYGfFjw@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<CAEJX8op946+W1BXdkk20cNdvpWrcQPuZqZWETOzbrkRM3Ufcbw@mail.gmail.com>
	<CACuKZqGQSaAgOaEF_hvsgaF7BfZ6t3FYrsG-5DfyERhRYGfFjw@mail.gmail.com>
Message-ID: <CAEJX8oo1Q-CN4Vv8UanRJfYFdtHBL15yB+7wcxrEQ-uFg8hOsw@mail.gmail.com>

We already agree about being racy. Unline the clone() method 'name' has no
critical applications (or at least shall not), so I presume it was never
considered a problem to warrant a volatile field.

On Thu, Mar 14, 2013 at 11:55 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> It's a common practice to modify thread names on the fly, for
> diagnosis purposes.
>
> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
> <stanimir at riflexo.com> wrote:
> > char[] name is usually initialized in the c-tor, in that case it'd be
> fine.
> > Since the access to 'name' is racy to begin, the changes may not be
> > necessarily 'visible'.
> >
> > Stanimir
> >
> > On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
> >>
> >> java.lang.Thread
> >>
> >>     private char name[];
> >>
> >>     public final void setName(String name) {
> >>         checkAccess();
> >>         this.name = name.toCharArray();
> >>     }
> >>
> >>     public final String getName() {
> >>         return String.valueOf(name);
> >>     }
> >>
> >> On the surface, set/getName() are not correctly synchronized,
> >> getName() could observe a partially filled char array. What's the
> >> story here?
> >>
> >> Zhong Yu
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/37363439/attachment.html>

From aleksey.shipilev at oracle.com  Thu Mar 14 18:28:02 2013
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Fri, 15 Mar 2013 02:28:02 +0400
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqF1maR+0vEHWUwPb0WBFicA-3Wom0XAuaMw=3vaAO=S1w@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<CAEJX8op946+W1BXdkk20cNdvpWrcQPuZqZWETOzbrkRM3Ufcbw@mail.gmail.com>
	<CACuKZqGQSaAgOaEF_hvsgaF7BfZ6t3FYrsG-5DfyERhRYGfFjw@mail.gmail.com>
	<51424C2D.5040809@uni-bremen.de>
	<CACuKZqF1maR+0vEHWUwPb0WBFicA-3Wom0XAuaMw=3vaAO=S1w@mail.gmail.com>
Message-ID: <51424EF2.2040103@oracle.com>

Ahem. I always thought the usual practice is setting the thread name in
the ThreadFactory, before starting the thread. Which allows us to have
the valid name over the Thread.start() happens-before edge.

-Aleksey.

On 03/15/2013 02:22 AM, Zhong Yu wrote:
> Well, the method is public, isn't it:) People are gonna use it.
> 
> What is the point to name a thread anyway? Nothing really, other than
> for diagnosis. One could, for example, append IP address to the name
> of a thread which is handling an http request from that IP. He can
> then cross reference http access logs and application logs for some
> detective work.
> 
> Zhong Yu
> 
> On Thu, Mar 14, 2013 at 5:16 PM, Raimund Klein
> <raimund.klein at uni-bremen.de> wrote:
>> Since when is that "common practice"? I don't think I ever did that - I
>> usually rely on using the Executors class combined with a ThreadFactory that
>> will give me an appropriate name from the very beginning.
>>
>> Cheers
>> Ray
>>
>> On 14.03.2013 22:55, Zhong Yu wrote:
>>>
>>> It's a common practice to modify thread names on the fly, for
>>> diagnosis purposes.
>>>
>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>>> <stanimir at riflexo.com> wrote:
>>>>
>>>> char[] name is usually initialized in the c-tor, in that case it'd be
>>>> fine.
>>>> Since the access to 'name' is racy to begin, the changes may not be
>>>> necessarily 'visible'.
>>>>
>>>> Stanimir
>>>>
>>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>>>
>>>>>
>>>>> java.lang.Thread
>>>>>
>>>>>      private char name[];
>>>>>
>>>>>      public final void setName(String name) {
>>>>>          checkAccess();
>>>>>          this.name = name.toCharArray();
>>>>>      }
>>>>>
>>>>>      public final String getName() {
>>>>>          return String.valueOf(name);
>>>>>      }
>>>>>
>>>>> On the surface, set/getName() are not correctly synchronized,
>>>>> getName() could observe a partially filled char array. What's the
>>>>> story here?
>>>>>
>>>>> Zhong Yu
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From stanimir at riflexo.com  Thu Mar 14 18:29:53 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Fri, 15 Mar 2013 00:29:53 +0200
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51424C2D.5040809@uni-bremen.de>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<CAEJX8op946+W1BXdkk20cNdvpWrcQPuZqZWETOzbrkRM3Ufcbw@mail.gmail.com>
	<CACuKZqGQSaAgOaEF_hvsgaF7BfZ6t3FYrsG-5DfyERhRYGfFjw@mail.gmail.com>
	<51424C2D.5040809@uni-bremen.de>
Message-ID: <CAEJX8oq3XSezXceugrRCy5DP0fBBh_kJLoXd66OKMA2W3HrFSw@mail.gmail.com>

On Fri, Mar 15, 2013 at 12:16 AM, Raimund Klein <raimund.klein at uni-bremen.de
> wrote:

> Since when is that "common practice"? I don't think I ever did that - I
> usually rely on using the Executors class combined with a ThreadFactory
> that will give me an appropriate name from the very beginning.
>
>
Some frameworks do change thread name to indicate some phase (mina comes to
mind and NamePreservingRunnable), I disagree w/ dynamic name changes as
they are too racy.

Stanimir

Cheers
> Ray
>
>
> On 14.03.2013 22:55, Zhong Yu wrote:
>
>> It's a common practice to modify thread names on the fly, for
>> diagnosis purposes.
>>
>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>> <stanimir at riflexo.com> wrote:
>>
>>> char[] name is usually initialized in the c-tor, in that case it'd be
>>> fine.
>>> Since the access to 'name' is racy to begin, the changes may not be
>>> necessarily 'visible'.
>>>
>>> Stanimir
>>>
>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>
>>>>
>>>> java.lang.Thread
>>>>
>>>>      private char name[];
>>>>
>>>>      public final void setName(String name) {
>>>>          checkAccess();
>>>>          this.name = name.toCharArray();
>>>>      }
>>>>
>>>>      public final String getName() {
>>>>          return String.valueOf(name);
>>>>      }
>>>>
>>>> On the surface, set/getName() are not correctly synchronized,
>>>> getName() could observe a partially filled char array. What's the
>>>> story here?
>>>>
>>>> Zhong Yu
>>>>
>>>> ______________________________**_________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>
>>>
>>>
>>>  ______________________________**_________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/62ed23b5/attachment.html>

From davidcholmes at aapt.net.au  Thu Mar 14 18:33:43 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 15 Mar 2013 08:33:43 +1000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqF1maR+0vEHWUwPb0WBFicA-3Wom0XAuaMw=3vaAO=S1w@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKECNJLAA.davidcholmes@aapt.net.au>

Zhong Yu writes:
> Well, the method is public, isn't it:) People are gonna use it.

Yes but mostly at construction time or at least prior to starting.

> What is the point to name a thread anyway? Nothing really, other than
> for diagnosis. One could, for example, append IP address to the name
> of a thread which is handling an http request from that IP. He can
> then cross reference http access logs and application logs for some
> detective work.

Sure but even there the most common pattern only involves intra-thread
usage, so no race involved.

It's only when you have some external monitoring agent that might examine
the thread as the name is changing that a problem might arise.

BTW the current implementation will also call into the VM to set the native
thread name. That means the chance of getting a race on the read of
thread.name is pretty much non-existent due to the thread state transitions
(in hotspot anyway).

But bottom line is that setName is racy - so use with care.

Cheers,
David


> Zhong Yu
>
> On Thu, Mar 14, 2013 at 5:16 PM, Raimund Klein
> <raimund.klein at uni-bremen.de> wrote:
> > Since when is that "common practice"? I don't think I ever did that - I
> > usually rely on using the Executors class combined with a
> ThreadFactory that
> > will give me an appropriate name from the very beginning.
> >
> > Cheers
> > Ray
> >
> > On 14.03.2013 22:55, Zhong Yu wrote:
> >>
> >> It's a common practice to modify thread names on the fly, for
> >> diagnosis purposes.
> >>
> >> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
> >> <stanimir at riflexo.com> wrote:
> >>>
> >>> char[] name is usually initialized in the c-tor, in that case it'd be
> >>> fine.
> >>> Since the access to 'name' is racy to begin, the changes may not be
> >>> necessarily 'visible'.
> >>>
> >>> Stanimir
> >>>
> >>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu
> <zhong.j.yu at gmail.com> wrote:
> >>>>
> >>>>
> >>>> java.lang.Thread
> >>>>
> >>>>      private char name[];
> >>>>
> >>>>      public final void setName(String name) {
> >>>>          checkAccess();
> >>>>          this.name = name.toCharArray();
> >>>>      }
> >>>>
> >>>>      public final String getName() {
> >>>>          return String.valueOf(name);
> >>>>      }
> >>>>
> >>>> On the surface, set/getName() are not correctly synchronized,
> >>>> getName() could observe a partially filled char array. What's the
> >>>> story here?
> >>>>
> >>>> Zhong Yu
> >>>>
> >>>> _______________________________________________
> >>>> Concurrency-interest mailing list
> >>>> Concurrency-interest at cs.oswego.edu
> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>
> >>>
> >>>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> -----
> No virus found in this message.
> Checked by AVG - www.avg.com
> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
>


From stanimir at riflexo.com  Thu Mar 14 18:43:41 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Fri, 15 Mar 2013 00:43:41 +0200
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <20130314222318.21107.21616.imail@fed1rmwml214>
References: <51424C2D.5040809@uni-bremen.de>
	<20130314222318.21107.21616.imail@fed1rmwml214>
Message-ID: <CAEJX8ooyrRrFhZ+03HWD-o1qpKXQZWC1BF0y0P7Q9FWgchBnAg@mail.gmail.com>

On Fri, Mar 15, 2013 at 12:23 AM, <javamann at cox.net> wrote:

> Way back in the 90's, before I knew better, I used to set the name of a
> Thread during execution as a way of passing a message to the Thread.
>
I recall using Hashtable w/ thread as the key and value some socket to be
processed. That actually worked quite stable.

Stanimir


> -Pete
>
> ---- Raimund Klein <raimund.klein at uni-bremen.de> wrote:
>
> =============
> Since when is that "common practice"? I don't think I ever did that - I
> usually rely on using the Executors class combined with a ThreadFactory
> that will give me an appropriate name from the very beginning.
>
> Cheers
> Ray
>
> On 14.03.2013 22:55, Zhong Yu wrote:
> > It's a common practice to modify thread names on the fly, for
> > diagnosis purposes.
> >
> > On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
> > <stanimir at riflexo.com> wrote:
> >> char[] name is usually initialized in the c-tor, in that case it'd be
> fine.
> >> Since the access to 'name' is racy to begin, the changes may not be
> >> necessarily 'visible'.
> >>
> >> Stanimir
> >>
> >> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com>
> wrote:
> >>>
> >>> java.lang.Thread
> >>>
> >>>      private char name[];
> >>>
> >>>      public final void setName(String name) {
> >>>          checkAccess();
> >>>          this.name = name.toCharArray();
> >>>      }
> >>>
> >>>      public final String getName() {
> >>>          return String.valueOf(name);
> >>>      }
> >>>
> >>> On the surface, set/getName() are not correctly synchronized,
> >>> getName() could observe a partially filled char array. What's the
> >>> story here?
> >>>
> >>> Zhong Yu
> >>>
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >>
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> --
>
> 1. If a man is standing in the middle of the forest talking, and there is
> no woman around to hear him, is he still wrong?
>
> 2. Behind every great woman... Is a man checking out her ass
>
> 3. I am not a member of any organized political party. I am a Democrat.*
>
> 4. Diplomacy is the art of saying "Nice doggie" until you can find a rock.*
>
> 5. A process is what you need when all your good people have left.
>
>
> *Will Rogers
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/04e660fa/attachment.html>

From zhong.j.yu at gmail.com  Thu Mar 14 18:47:37 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Thu, 14 Mar 2013 17:47:37 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CAEJX8oo1Q-CN4Vv8UanRJfYFdtHBL15yB+7wcxrEQ-uFg8hOsw@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<CAEJX8op946+W1BXdkk20cNdvpWrcQPuZqZWETOzbrkRM3Ufcbw@mail.gmail.com>
	<CACuKZqGQSaAgOaEF_hvsgaF7BfZ6t3FYrsG-5DfyERhRYGfFjw@mail.gmail.com>
	<CAEJX8oo1Q-CN4Vv8UanRJfYFdtHBL15yB+7wcxrEQ-uFg8hOsw@mail.gmail.com>
Message-ID: <CACuKZqFPPWfYw0GX5PXhi+bOr2FTsTP+27GrKb2u=wwHkFm16Q@mail.gmail.com>

On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
<stanimir at riflexo.com> wrote:
> We already agree about being racy. Unline the clone() method 'name' has no
> critical applications (or at least shall not), so I presume it was never
> considered a problem to warrant a volatile field.

A non-volatile String field would be ok.

Since getName() can be invoked by anyone at anytime, it's troubling
that it could observe a scrambled name.

Zhong Yu

>
> On Thu, Mar 14, 2013 at 11:55 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>
>> It's a common practice to modify thread names on the fly, for
>> diagnosis purposes.
>>
>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>> <stanimir at riflexo.com> wrote:
>> > char[] name is usually initialized in the c-tor, in that case it'd be
>> > fine.
>> > Since the access to 'name' is racy to begin, the changes may not be
>> > necessarily 'visible'.
>> >
>> > Stanimir
>> >
>> > On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>> >>
>> >> java.lang.Thread
>> >>
>> >>     private char name[];
>> >>
>> >>     public final void setName(String name) {
>> >>         checkAccess();
>> >>         this.name = name.toCharArray();
>> >>     }
>> >>
>> >>     public final String getName() {
>> >>         return String.valueOf(name);
>> >>     }
>> >>
>> >> On the surface, set/getName() are not correctly synchronized,
>> >> getName() could observe a partially filled char array. What's the
>> >> story here?
>> >>
>> >> Zhong Yu
>> >>
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> >
>
>

From pete at guyatt.ca  Thu Mar 14 19:03:10 2013
From: pete at guyatt.ca (Pete Guyatt)
Date: Thu, 14 Mar 2013 17:03:10 -0600
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqFPPWfYw0GX5PXhi+bOr2FTsTP+27GrKb2u=wwHkFm16Q@mail.gmail.com>
Message-ID: <CD67AFF1.22532%pete@guyatt.ca>

I'm sure I'm missing something here but I don't quite see how the
character array can be scrambled.

I can see how it "racy" and how an inconsistent write/read happens where a
thread calls setName -- could be the thread itself or another thread --
and another calls getName but from what I can see the assignment of the
new value to the name[] array is only going to happen after the call to
toCharArray completes. I thought this would be the case even with the JVM
performing some reordering of instructions.

Would someone mind clarifying?

Kind Regards, 

Pete

On 2013-03-14 4:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:

>On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
><stanimir at riflexo.com> wrote:
>> We already agree about being racy. Unline the clone() method 'name' has
>>no
>> critical applications (or at least shall not), so I presume it was never
>> considered a problem to warrant a volatile field.
>
>A non-volatile String field would be ok.
>
>Since getName() can be invoked by anyone at anytime, it's troubling
>that it could observe a scrambled name.
>
>Zhong Yu
>
>>
>> On Thu, Mar 14, 2013 at 11:55 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>
>>> It's a common practice to modify thread names on the fly, for
>>> diagnosis purposes.
>>>
>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>>> <stanimir at riflexo.com> wrote:
>>> > char[] name is usually initialized in the c-tor, in that case it'd be
>>> > fine.
>>> > Since the access to 'name' is racy to begin, the changes may not be
>>> > necessarily 'visible'.
>>> >
>>> > Stanimir
>>> >
>>> > On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com>
>>>wrote:
>>> >>
>>> >> java.lang.Thread
>>> >>
>>> >>     private char name[];
>>> >>
>>> >>     public final void setName(String name) {
>>> >>         checkAccess();
>>> >>         this.name = name.toCharArray();
>>> >>     }
>>> >>
>>> >>     public final String getName() {
>>> >>         return String.valueOf(name);
>>> >>     }
>>> >>
>>> >> On the surface, set/getName() are not correctly synchronized,
>>> >> getName() could observe a partially filled char array. What's the
>>> >> story here?
>>> >>
>>> >> Zhong Yu
>>> >>
>>> >> _______________________________________________
>>> >> Concurrency-interest mailing list
>>> >> Concurrency-interest at cs.oswego.edu
>>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >
>>> >
>>
>>
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest at cs.oswego.edu
>http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From nathan.reynolds at oracle.com  Thu Mar 14 19:14:57 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Thu, 14 Mar 2013 16:14:57 -0700
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CD67AFF1.22532%pete@guyatt.ca>
References: <CD67AFF1.22532%pete@guyatt.ca>
Message-ID: <514259F1.2080604@oracle.com>

I've inlined the name.toCharArray() and rearranged a few operations that 
JIT could do.  If another thread reads this.name between its creation 
and the end of arraycopy() then the thread will see a partially filled 
char[].

     public final void setName(String name) {
         this.name = new char[name.length()];
         System.arraycopy(..., 0, result, 0, name.length());
     }

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 3/14/2013 4:03 PM, Pete Guyatt wrote:
> I'm sure I'm missing something here but I don't quite see how the
> character array can be scrambled.
>
> I can see how it "racy" and how an inconsistent write/read happens where a
> thread calls setName -- could be the thread itself or another thread --
> and another calls getName but from what I can see the assignment of the
> new value to the name[] array is only going to happen after the call to
> toCharArray completes. I thought this would be the case even with the JVM
> performing some reordering of instructions.
>
> Would someone mind clarifying?
>
> Kind Regards,
>
> Pete
>
> On 2013-03-14 4:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com> wrote:
>
>> On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
>> <stanimir at riflexo.com> wrote:
>>> We already agree about being racy. Unline the clone() method 'name' has
>>> no
>>> critical applications (or at least shall not), so I presume it was never
>>> considered a problem to warrant a volatile field.
>> A non-volatile String field would be ok.
>>
>> Since getName() can be invoked by anyone at anytime, it's troubling
>> that it could observe a scrambled name.
>>
>> Zhong Yu
>>
>>> On Thu, Mar 14, 2013 at 11:55 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>> It's a common practice to modify thread names on the fly, for
>>>> diagnosis purposes.
>>>>
>>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>>>> <stanimir at riflexo.com> wrote:
>>>>> char[] name is usually initialized in the c-tor, in that case it'd be
>>>>> fine.
>>>>> Since the access to 'name' is racy to begin, the changes may not be
>>>>> necessarily 'visible'.
>>>>>
>>>>> Stanimir
>>>>>
>>>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com>
>>>> wrote:
>>>>>> java.lang.Thread
>>>>>>
>>>>>>      private char name[];
>>>>>>
>>>>>>      public final void setName(String name) {
>>>>>>          checkAccess();
>>>>>>          this.name = name.toCharArray();
>>>>>>      }
>>>>>>
>>>>>>      public final String getName() {
>>>>>>          return String.valueOf(name);
>>>>>>      }
>>>>>>
>>>>>> On the surface, set/getName() are not correctly synchronized,
>>>>>> getName() could observe a partially filled char array. What's the
>>>>>> story here?
>>>>>>
>>>>>> Zhong Yu
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130314/f8732099/attachment.html>

From pete at guyatt.ca  Thu Mar 14 19:19:27 2013
From: pete at guyatt.ca (Pete Guyatt)
Date: Thu, 14 Mar 2013 17:19:27 -0600
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <514259F1.2080604@oracle.com>
Message-ID: <CD67B6B1.22558%pete@guyatt.ca>

Hi Nathan, 

Thanks for the reply and the clarification. I was wondering if inlining
could be the cause ? I thought about that after I sent the email.

Pete

From:  Nathan Reynolds <nathan.reynolds at oracle.com>
Organization:  Oracle Corporation
Date:  Thursday, 14 March, 2013 5:14 PM
To:  <concurrency-interest at cs.oswego.edu>
Subject:  Re: [concurrency-interest] Thread safety of Thread.getName()

    
 
I've inlined the name.toCharArray() and rearranged a few operations that JIT
could do.  If another thread reads this.name between its creation and the
end of arraycopy() then the thread will see a partially filled char[].
 
     public final void setName(String name) {
         this.name = new char[name.length()];
         System.arraycopy(..., 0, result, 0, name.length());
     }
 
 
Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>  | Architect
| 602.333.9091
 Oracle PSR Engineering <http://psr.us.oracle.com/>  | Server Technology
 
 On 3/14/2013 4:03 PM, Pete Guyatt wrote:
 
 
>  
> I'm sure I'm missing something here but I don't quite see how the
> character array can be scrambled.
> 
> I can see how it "racy" and how an inconsistent write/read happens where a
> thread calls setName -- could be the thread itself or another thread --
> and another calls getName but from what I can see the assignment of the
> new value to the name[] array is only going to happen after the call to
> toCharArray completes. I thought this would be the case even with the JVM
> performing some reordering of instructions.
> 
> Would someone mind clarifying?
> 
> Kind Regards, 
> 
> Pete
> 
> On 2013-03-14 4:47 PM, "Zhong Yu" <zhong.j.yu at gmail.com>
> <mailto:zhong.j.yu at gmail.com>  wrote:
> 
>  
>>  
>> On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
>> <stanimir at riflexo.com> <mailto:stanimir at riflexo.com>  wrote:
>>  
>>>  
>>> We already agree about being racy. Unline the clone() method 'name' has
>>> no
>>> critical applications (or at least shall not), so I presume it was never
>>> considered a problem to warrant a volatile field.
>>>  
>>  
>> A non-volatile String field would be ok.
>> 
>> Since getName() can be invoked by anyone at anytime, it's troubling
>> that it could observe a scrambled name.
>> 
>> Zhong Yu
>> 
>>  
>>>  
>>> On Thu, Mar 14, 2013 at 11:55 PM, Zhong Yu <zhong.j.yu at gmail.com>
>>> <mailto:zhong.j.yu at gmail.com>  wrote:
>>>  
>>>>  
>>>> It's a common practice to modify thread names on the fly, for
>>>> diagnosis purposes.
>>>> 
>>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>>>> <stanimir at riflexo.com> <mailto:stanimir at riflexo.com>  wrote:
>>>>  
>>>>>  
>>>>> char[] name is usually initialized in the c-tor, in that case it'd be
>>>>> fine.
>>>>> Since the access to 'name' is racy to begin, the changes may not be
>>>>> necessarily 'visible'.
>>>>> 
>>>>> Stanimir
>>>>> 
>>>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com>
>>>>> <mailto:zhong.j.yu at gmail.com>
>>>>>  
>>>>  
>>>> wrote:
>>>>  
>>>>>  
>>>>>>  
>>>>>> java.lang.Thread
>>>>>> 
>>>>>>     private char name[];
>>>>>> 
>>>>>>     public final void setName(String name) {
>>>>>>         checkAccess();
>>>>>>         this.name = name.toCharArray();
>>>>>>     }
>>>>>> 
>>>>>>     public final String getName() {
>>>>>>         return String.valueOf(name);
>>>>>>     }
>>>>>> 
>>>>>> On the surface, set/getName() are not correctly synchronized,
>>>>>> getName() could observe a partially filled char array. What's the
>>>>>> story here?
>>>>>> 
>>>>>> Zhong Yu
>>>>>> 
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/c
>>>>>> oncurrency-interest
>>>>>>  
>>>>>  
>>>>>  
>>>>  
>>>  
>>>  
>>  
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concu
>> rrency-interest
>>  
>  
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concur
> rency-interest
>  
 
 
_______________________________________________ Concurrency-interest mailing
list Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130314/375e2090/attachment.html>

From davidcholmes at aapt.net.au  Thu Mar 14 19:35:24 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 15 Mar 2013 09:35:24 +1000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKECNJLAA.davidcholmes@aapt.net.au>
Message-ID: <NFBBKALFDCPFIDBNKAPCCECPJLAA.davidcholmes@aapt.net.au>

I wrote:
> Zhong Yu writes:
> > Well, the method is public, isn't it:) People are gonna use it.
>
> Yes but mostly at construction time or at least prior to starting.
>
> > What is the point to name a thread anyway? Nothing really, other than
> > for diagnosis. One could, for example, append IP address to the name
> > of a thread which is handling an http request from that IP. He can
> > then cross reference http access logs and application logs for some
> > detective work.
>
> Sure but even there the most common pattern only involves intra-thread
> usage, so no race involved.
>
> It's only when you have some external monitoring agent that might examine
> the thread as the name is changing that a problem might arise.
>
> BTW the current implementation will also call into the VM to set
> the native
> thread name. That means the chance of getting a race on the read of
> thread.name is pretty much non-existent due to the thread state
> transitions (in hotspot anyway).

That's incorrect. The name array is set first so the same races exist.

BTW I'm a little surprised someone hasn't asked why the name is a char[]
instead of a String - as that would fix it ;-)

Ans: the VM also needs to set the name in some cases and it is easier to
deal with a char[] than a String, particularly during VM startup.

David

>
> But bottom line is that setName is racy - so use with care.
>
> Cheers,
> David
>
>
> > Zhong Yu
> >
> > On Thu, Mar 14, 2013 at 5:16 PM, Raimund Klein
> > <raimund.klein at uni-bremen.de> wrote:
> > > Since when is that "common practice"? I don't think I ever
> did that - I
> > > usually rely on using the Executors class combined with a
> > ThreadFactory that
> > > will give me an appropriate name from the very beginning.
> > >
> > > Cheers
> > > Ray
> > >
> > > On 14.03.2013 22:55, Zhong Yu wrote:
> > >>
> > >> It's a common practice to modify thread names on the fly, for
> > >> diagnosis purposes.
> > >>
> > >> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
> > >> <stanimir at riflexo.com> wrote:
> > >>>
> > >>> char[] name is usually initialized in the c-tor, in that
> case it'd be
> > >>> fine.
> > >>> Since the access to 'name' is racy to begin, the changes may not be
> > >>> necessarily 'visible'.
> > >>>
> > >>> Stanimir
> > >>>
> > >>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu
> > <zhong.j.yu at gmail.com> wrote:
> > >>>>
> > >>>>
> > >>>> java.lang.Thread
> > >>>>
> > >>>>      private char name[];
> > >>>>
> > >>>>      public final void setName(String name) {
> > >>>>          checkAccess();
> > >>>>          this.name = name.toCharArray();
> > >>>>      }
> > >>>>
> > >>>>      public final String getName() {
> > >>>>          return String.valueOf(name);
> > >>>>      }
> > >>>>
> > >>>> On the surface, set/getName() are not correctly synchronized,
> > >>>> getName() could observe a partially filled char array. What's the
> > >>>> story here?
> > >>>>
> > >>>> Zhong Yu
> > >>>>
> > >>>> _______________________________________________
> > >>>> Concurrency-interest mailing list
> > >>>> Concurrency-interest at cs.oswego.edu
> > >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >>>
> > >>>
> > >>>
> > >> _______________________________________________
> > >> Concurrency-interest mailing list
> > >> Concurrency-interest at cs.oswego.edu
> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >>
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > -----
> > No virus found in this message.
> > Checked by AVG - www.avg.com
> > Version: 2013.0.2904 / Virus Database: 2641/6158 - Release
> Date: 03/08/13
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> -----
> No virus found in this message.
> Checked by AVG - www.avg.com
> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
>


From mike.duigou at oracle.com  Thu Mar 14 20:28:48 2013
From: mike.duigou at oracle.com (Mike Duigou)
Date: Thu, 14 Mar 2013 17:28:48 -0700
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
Message-ID: <F8DF0611-61DA-4628-9E7C-6067026106D0@oracle.com>


On Mar 14 2013, at 14:21 , Zhong Yu wrote:

> java.lang.Thread
> 
>    private char name[];
> 
>    public final void setName(String name) {
>        checkAccess();
>        this.name = name.toCharArray();

The following suggestion is not for the weak of heart:

Since String.value is now always the same content as this character array we could simply extract the character array from the String instance. This would also seem to correct the problem because for a String to be visible it's value character array and contents would be visible. 

Some people would probably consider this suggestion to be morally dubious foolishness. They may be right.

>    }
> 
>    public final String getName() {
>        return String.valueOf(name);

Since we "know" that the character array is not modified after assignment this could be replaced with the String(char[], boolean) constructor. ibid "morally dubious foolishness."

>    }
> 
> On the surface, set/getName() are not correctly synchronized,
> getName() could observe a partially filled char array. What's the
> story here?
> 
> Zhong Yu



From mike.duigou at oracle.com  Thu Mar 14 20:29:21 2013
From: mike.duigou at oracle.com (Mike Duigou)
Date: Thu, 14 Mar 2013 17:29:21 -0700
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCECPJLAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCCECPJLAA.davidcholmes@aapt.net.au>
Message-ID: <43809F08-1441-4621-BED9-FAFBEE90B489@oracle.com>


On Mar 14 2013, at 16:35 , David Holmes wrote:
> 
> BTW I'm a little surprised someone hasn't asked why the name is a char[]
> instead of a String - as that would fix it ;-)
> 
> Ans: the VM also needs to set the name in some cases and it is easier to
> deal with a char[] than a String, particularly during VM startup.

I've always assumed it was a char[] for easier capture in debugging, dtrace, introspection by native code, etc. This would have been especially true when String had offset/count in addition to the value.

> David



From davidcholmes at aapt.net.au  Thu Mar 14 20:52:47 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 15 Mar 2013 10:52:47 +1000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <43809F08-1441-4621-BED9-FAFBEE90B489@oracle.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEDAJLAA.davidcholmes@aapt.net.au>

Mike Dugious writes:
>
> On Mar 14 2013, at 16:35 , David Holmes wrote:
> >
> > BTW I'm a little surprised someone hasn't asked why the name is a char[]
> > instead of a String - as that would fix it ;-)
> >
> > Ans: the VM also needs to set the name in some cases and it is easier to
> > deal with a char[] than a String, particularly during VM startup.
>
> I've always assumed it was a char[] for easier capture in
> debugging, dtrace, introspection by native code, etc. This would
> have been especially true when String had offset/count in
> addition to the value.

Yes I should have said "access the name". Still doable if it is a string but
simpler as a char array.

Cheers,
David

> > David
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> -----
> No virus found in this message.
> Checked by AVG - www.avg.com
> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
>


From zhong.j.yu at gmail.com  Thu Mar 14 21:14:03 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Thu, 14 Mar 2013 20:14:03 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCECPJLAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCKECNJLAA.davidcholmes@aapt.net.au>
	<NFBBKALFDCPFIDBNKAPCCECPJLAA.davidcholmes@aapt.net.au>
Message-ID: <CACuKZqFquTZ7d+g6zJSpNeyigSC8-53Uv-NRyN-r2CMn6qEfQQ@mail.gmail.com>

On Thu, Mar 14, 2013 at 6:35 PM, David Holmes <davidcholmes at aapt.net.au> wrote:
> I wrote:
>> Zhong Yu writes:
>> > Well, the method is public, isn't it:) People are gonna use it.
>>
>> Yes but mostly at construction time or at least prior to starting.
>>
>> > What is the point to name a thread anyway? Nothing really, other than
>> > for diagnosis. One could, for example, append IP address to the name
>> > of a thread which is handling an http request from that IP. He can
>> > then cross reference http access logs and application logs for some
>> > detective work.
>>
>> Sure but even there the most common pattern only involves intra-thread
>> usage, so no race involved.
>>
>> It's only when you have some external monitoring agent that might examine
>> the thread as the name is changing that a problem might arise.
>>
>> BTW the current implementation will also call into the VM to set
>> the native
>> thread name. That means the chance of getting a race on the read of
>> thread.name is pretty much non-existent due to the thread state
>> transitions (in hotspot anyway).
>
> That's incorrect. The name array is set first so the same races exist.
>
> BTW I'm a little surprised someone hasn't asked why the name is a char[]
> instead of a String - as that would fix it ;-)

Yes it was very puzzling to me, and probably to a lot of people. It
would be nice to have some documentation there.

Zhong Yu

>
> Ans: the VM also needs to set the name in some cases and it is easier to
> deal with a char[] than a String, particularly during VM startup.
>
> David
>
>>
>> But bottom line is that setName is racy - so use with care.
>>
>> Cheers,
>> David
>>
>>
>> > Zhong Yu
>> >
>> > On Thu, Mar 14, 2013 at 5:16 PM, Raimund Klein
>> > <raimund.klein at uni-bremen.de> wrote:
>> > > Since when is that "common practice"? I don't think I ever
>> did that - I
>> > > usually rely on using the Executors class combined with a
>> > ThreadFactory that
>> > > will give me an appropriate name from the very beginning.
>> > >
>> > > Cheers
>> > > Ray
>> > >
>> > > On 14.03.2013 22:55, Zhong Yu wrote:
>> > >>
>> > >> It's a common practice to modify thread names on the fly, for
>> > >> diagnosis purposes.
>> > >>
>> > >> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>> > >> <stanimir at riflexo.com> wrote:
>> > >>>
>> > >>> char[] name is usually initialized in the c-tor, in that
>> case it'd be
>> > >>> fine.
>> > >>> Since the access to 'name' is racy to begin, the changes may not be
>> > >>> necessarily 'visible'.
>> > >>>
>> > >>> Stanimir
>> > >>>
>> > >>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu
>> > <zhong.j.yu at gmail.com> wrote:
>> > >>>>
>> > >>>>
>> > >>>> java.lang.Thread
>> > >>>>
>> > >>>>      private char name[];
>> > >>>>
>> > >>>>      public final void setName(String name) {
>> > >>>>          checkAccess();
>> > >>>>          this.name = name.toCharArray();
>> > >>>>      }
>> > >>>>
>> > >>>>      public final String getName() {
>> > >>>>          return String.valueOf(name);
>> > >>>>      }
>> > >>>>
>> > >>>> On the surface, set/getName() are not correctly synchronized,
>> > >>>> getName() could observe a partially filled char array. What's the
>> > >>>> story here?
>> > >>>>
>> > >>>> Zhong Yu
>> > >>>>
>> > >>>> _______________________________________________
>> > >>>> Concurrency-interest mailing list
>> > >>>> Concurrency-interest at cs.oswego.edu
>> > >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > >>>
>> > >>>
>> > >>>
>> > >> _______________________________________________
>> > >> Concurrency-interest mailing list
>> > >> Concurrency-interest at cs.oswego.edu
>> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > >>
>> > >
>> > >
>> > > _______________________________________________
>> > > Concurrency-interest mailing list
>> > > Concurrency-interest at cs.oswego.edu
>> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> >
>> > -----
>> > No virus found in this message.
>> > Checked by AVG - www.avg.com
>> > Version: 2013.0.2904 / Virus Database: 2641/6158 - Release
>> Date: 03/08/13
>> >
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> -----
>> No virus found in this message.
>> Checked by AVG - www.avg.com
>> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
>>
>

From gregg at cytetech.com  Fri Mar 15 00:59:34 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Thu, 14 Mar 2013 23:59:34 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51424C2D.5040809@uni-bremen.de>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<CAEJX8op946+W1BXdkk20cNdvpWrcQPuZqZWETOzbrkRM3Ufcbw@mail.gmail.com>
	<CACuKZqGQSaAgOaEF_hvsgaF7BfZ6t3FYrsG-5DfyERhRYGfFjw@mail.gmail.com>
	<51424C2D.5040809@uni-bremen.de>
Message-ID: <5142AAB6.2020006@cytetech.com>

In JavaSE network applications, I do this all the time to set the name of the 
thread to a string describing the socket address/work-item so that I can create 
a thread dump with SIGQUIT and identify what state that "connection" is in for 
debugging purposes when someone might report that they are "stuck" or "not 
working" in some way.  I don't worry about the raciness of the "setName()" vs 
"getName()" value.  It seems to always get "flushed" so that whatever thread is 
handling the stack dump sees that new name.

Gregg Wonderly

On 3/14/2013 5:16 PM, Raimund Klein wrote:
> Since when is that "common practice"? I don't think I ever did that - I usually
> rely on using the Executors class combined with a ThreadFactory that will give
> me an appropriate name from the very beginning.
>
> Cheers
> Ray
>
> On 14.03.2013 22:55, Zhong Yu wrote:
>> It's a common practice to modify thread names on the fly, for
>> diagnosis purposes.
>>
>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>> <stanimir at riflexo.com> wrote:
>>> char[] name is usually initialized in the c-tor, in that case it'd be fine.
>>> Since the access to 'name' is racy to begin, the changes may not be
>>> necessarily 'visible'.
>>>
>>> Stanimir
>>>
>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>>
>>>> java.lang.Thread
>>>>
>>>>      private char name[];
>>>>
>>>>      public final void setName(String name) {
>>>>          checkAccess();
>>>>          this.name = name.toCharArray();
>>>>      }
>>>>
>>>>      public final String getName() {
>>>>          return String.valueOf(name);
>>>>      }
>>>>
>>>> On the surface, set/getName() are not correctly synchronized,
>>>> getName() could observe a partially filled char array. What's the
>>>> story here?
>>>>
>>>> Zhong Yu
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From gregg at cytetech.com  Fri Mar 15 01:14:19 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Fri, 15 Mar 2013 00:14:19 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <514259F1.2080604@oracle.com>
References: <CD67AFF1.22532%pete@guyatt.ca> <514259F1.2080604@oracle.com>
Message-ID: <5142AE2B.3030203@cytetech.com>

On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
> I've inlined the name.toCharArray() and rearranged a few operations that JIT
> could do.  If another thread reads this.name between its creation and the end of
> arraycopy() then the thread will see a partially filled char[].
>
>      public final void setName(String name) {
>          this.name = new char[name.length()];
>          System.arraycopy(..., 0, result, 0, name.length());
>      }

This rewrite/optimization doesn't seem to meet sequential consistency ordering 
requirements.  I don't see how this could be considered SC since it creates a 
different result (uninitialized value) then the way that the original source was 
coded did not.

If the JIT is actually doing this when concurrency is not detected (non-volatile 
and no other happensBefore/fence), its no wonder we have so many developers 
plagued with unexplainable racy program bugs.

I thought the rewrite of while( nonvolatileBoolean ){} to if 
(nonvolatileBoolean) { while (true ) {} } was bad enough of a mistake.  This 
just wreaks of frustration for developers.

How is this optimization more efficient, really?  Are we really so interested in 
absolutely most efficient that we've given up on letting developers decide when 
performance matters and then optimize to "incorrect" on their own terms?

This kind optimization, if it is actually occurring is another example of 
insidious change in program behavior...

Gregg Wonderly

>
> Nathan Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> Architect | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
> On 3/14/2013 4:03 PM, Pete Guyatt wrote:
>> I'm sure I'm missing something here but I don't quite see how the
>> character array can be scrambled.
>>
>> I can see how it "racy" and how an inconsistent write/read happens where a
>> thread calls setName -- could be the thread itself or another thread --
>> and another calls getName but from what I can see the assignment of the
>> new value to the name[] array is only going to happen after the call to
>> toCharArray completes. I thought this would be the case even with the JVM
>> performing some reordering of instructions.
>>
>> Would someone mind clarifying?
>>
>> Kind Regards,
>>
>> Pete
>>
>> On 2013-03-14 4:47 PM, "Zhong Yu"<zhong.j.yu at gmail.com>  wrote:
>>
>>> On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
>>> <stanimir at riflexo.com>  wrote:
>>>> We already agree about being racy. Unline the clone() method 'name' has
>>>> no
>>>> critical applications (or at least shall not), so I presume it was never
>>>> considered a problem to warrant a volatile field.
>>> A non-volatile String field would be ok.
>>>
>>> Since getName() can be invoked by anyone at anytime, it's troubling
>>> that it could observe a scrambled name.
>>>
>>> Zhong Yu
>>>
>>>> On Thu, Mar 14, 2013 at 11:55 PM, Zhong Yu<zhong.j.yu at gmail.com>  wrote:
>>>>> It's a common practice to modify thread names on the fly, for
>>>>> diagnosis purposes.
>>>>>
>>>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>>>>> <stanimir at riflexo.com>  wrote:
>>>>>> char[] name is usually initialized in the c-tor, in that case it'd be
>>>>>> fine.
>>>>>> Since the access to 'name' is racy to begin, the changes may not be
>>>>>> necessarily 'visible'.
>>>>>>
>>>>>> Stanimir
>>>>>>
>>>>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu<zhong.j.yu at gmail.com>
>>>>> wrote:
>>>>>>> java.lang.Thread
>>>>>>>
>>>>>>>      private char name[];
>>>>>>>
>>>>>>>      public final void setName(String name) {
>>>>>>>          checkAccess();
>>>>>>>          this.name = name.toCharArray();
>>>>>>>      }
>>>>>>>
>>>>>>>      public final String getName() {
>>>>>>>          return String.valueOf(name);
>>>>>>>      }
>>>>>>>
>>>>>>> On the surface, set/getName() are not correctly synchronized,
>>>>>>> getName() could observe a partially filled char array. What's the
>>>>>>> story here?
>>>>>>>
>>>>>>> Zhong Yu
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From davidcholmes at aapt.net.au  Fri Mar 15 01:29:09 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 15 Mar 2013 15:29:09 +1000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <5142AE2B.3030203@cytetech.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>

Gregg,

Gregg Wonderly writes:
>
> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
> > I've inlined the name.toCharArray() and rearranged a few
> operations that JIT
> > could do.  If another thread reads this.name between its
> creation and the end of
> > arraycopy() then the thread will see a partially filled char[].
> >
> >      public final void setName(String name) {
> >          this.name = new char[name.length()];
> >          System.arraycopy(..., 0, result, 0, name.length());
> >      }
>
> This rewrite/optimization doesn't seem to meet sequential
> consistency ordering requirements.  I don't see how this could be
considered SC since
> it creates a different result (uninitialized value) then the way that the
> original source was coded did not.

The JIT quite rightly can assume that it only needs to obey intra-thread
semantics not inter-thread semantics. If you want SC across threads then you
need synchronization and/or volatiles - not race conditions.

Java programs are only SC in the absence of race conditions.

David
-----


>
> If the JIT is actually doing this when concurrency is not
> detected (non-volatile
> and no other happensBefore/fence), its no wonder we have so many
> developers
> plagued with unexplainable racy program bugs.
>
> I thought the rewrite of while( nonvolatileBoolean ){} to if
> (nonvolatileBoolean) { while (true ) {} } was bad enough of a
> mistake.  This
> just wreaks of frustration for developers.
>
> How is this optimization more efficient, really?  Are we really
> so interested in
> absolutely most efficient that we've given up on letting
> developers decide when
> performance matters and then optimize to "incorrect" on their own terms?
>
> This kind optimization, if it is actually occurring is another example of
> insidious change in program behavior...
>
> Gregg Wonderly
>
> >
> > Nathan Reynolds
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> > Architect | 602.333.9091
> > Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
> > On 3/14/2013 4:03 PM, Pete Guyatt wrote:
> >> I'm sure I'm missing something here but I don't quite see how the
> >> character array can be scrambled.
> >>
> >> I can see how it "racy" and how an inconsistent write/read
> happens where a
> >> thread calls setName -- could be the thread itself or another thread --
> >> and another calls getName but from what I can see the assignment of the
> >> new value to the name[] array is only going to happen after the call to
> >> toCharArray completes. I thought this would be the case even
> with the JVM
> >> performing some reordering of instructions.
> >>
> >> Would someone mind clarifying?
> >>
> >> Kind Regards,
> >>
> >> Pete
> >>
> >> On 2013-03-14 4:47 PM, "Zhong Yu"<zhong.j.yu at gmail.com>  wrote:
> >>
> >>> On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
> >>> <stanimir at riflexo.com>  wrote:
> >>>> We already agree about being racy. Unline the clone() method
> 'name' has
> >>>> no
> >>>> critical applications (or at least shall not), so I presume
> it was never
> >>>> considered a problem to warrant a volatile field.
> >>> A non-volatile String field would be ok.
> >>>
> >>> Since getName() can be invoked by anyone at anytime, it's troubling
> >>> that it could observe a scrambled name.
> >>>
> >>> Zhong Yu
> >>>
> >>>> On Thu, Mar 14, 2013 at 11:55 PM, Zhong
> Yu<zhong.j.yu at gmail.com>  wrote:
> >>>>> It's a common practice to modify thread names on the fly, for
> >>>>> diagnosis purposes.
> >>>>>
> >>>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
> >>>>> <stanimir at riflexo.com>  wrote:
> >>>>>> char[] name is usually initialized in the c-tor, in that
> case it'd be
> >>>>>> fine.
> >>>>>> Since the access to 'name' is racy to begin, the changes may not be
> >>>>>> necessarily 'visible'.
> >>>>>>
> >>>>>> Stanimir
> >>>>>>
> >>>>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu<zhong.j.yu at gmail.com>
> >>>>> wrote:
> >>>>>>> java.lang.Thread
> >>>>>>>
> >>>>>>>      private char name[];
> >>>>>>>
> >>>>>>>      public final void setName(String name) {
> >>>>>>>          checkAccess();
> >>>>>>>          this.name = name.toCharArray();
> >>>>>>>      }
> >>>>>>>
> >>>>>>>      public final String getName() {
> >>>>>>>          return String.valueOf(name);
> >>>>>>>      }
> >>>>>>>
> >>>>>>> On the surface, set/getName() are not correctly synchronized,
> >>>>>>> getName() could observe a partially filled char array. What's the
> >>>>>>> story here?
> >>>>>>>
> >>>>>>> Zhong Yu
> >>>>>>>
> >>>>>>> _______________________________________________
> >>>>>>> Concurrency-interest mailing list
> >>>>>>> Concurrency-interest at cs.oswego.edu
> >>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>>>
> >>>>
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >>
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> -----
> No virus found in this message.
> Checked by AVG - www.avg.com
> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
>


From zhong.j.yu at gmail.com  Fri Mar 15 02:53:12 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Fri, 15 Mar 2013 01:53:12 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <F8DF0611-61DA-4628-9E7C-6067026106D0@oracle.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<F8DF0611-61DA-4628-9E7C-6067026106D0@oracle.com>
Message-ID: <CACuKZqEUAfo2jFugQkvSj_wQbSX4=dnBwaUhXubKr-PTuGQe7A@mail.gmail.com>

Mike, your suggestion does not seem to be able to walk around the problem.

// shared
    char name[];

Thread 1
    char[] chars = {'a','b','c'};
    String string1 = new String(chars);
    name=string1.value;

Thread 2
    String string2 = new String(name, true);

The final-ness of String.value does no good here, Thread 1 can still
inline and reorder, to the effect that the array reference is
published before the array is filled. Thread 2 can still observe a
partially filled array. Even better, string2's content can be observed
to mutate while the array is being filled!

Zhong Yu

On Thu, Mar 14, 2013 at 7:28 PM, Mike Duigou <mike.duigou at oracle.com> wrote:
>
> On Mar 14 2013, at 14:21 , Zhong Yu wrote:
>
>> java.lang.Thread
>>
>>    private char name[];
>>
>>    public final void setName(String name) {
>>        checkAccess();
>>        this.name = name.toCharArray();
>
> The following suggestion is not for the weak of heart:
>
> Since String.value is now always the same content as this character array we could simply extract the character array from the String instance. This would also seem to correct the problem because for a String to be visible it's value character array and contents would be visible.
>
> Some people would probably consider this suggestion to be morally dubious foolishness. They may be right.
>
>>    }
>>
>>    public final String getName() {
>>        return String.valueOf(name);
>
> Since we "know" that the character array is not modified after assignment this could be replaced with the String(char[], boolean) constructor. ibid "morally dubious foolishness."
>
>>    }
>>
>> On the surface, set/getName() are not correctly synchronized,
>> getName() could observe a partially filled char array. What's the
>> story here?
>>
>> Zhong Yu
>


From gregg at cytetech.com  Fri Mar 15 09:10:09 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Fri, 15 Mar 2013 08:10:09 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
Message-ID: <51431DB1.6010707@cytetech.com>

On 3/15/2013 12:29 AM, David Holmes wrote:
> Gregg,
>
> Gregg Wonderly writes:
>>
>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>> I've inlined the name.toCharArray() and rearranged a few
>> operations that JIT
>>> could do.  If another thread reads this.name between its
>> creation and the end of
>>> arraycopy() then the thread will see a partially filled char[].
>>>
>>>       public final void setName(String name) {
>>>           this.name = new char[name.length()];
>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>       }
>>
>> This rewrite/optimization doesn't seem to meet sequential
>> consistency ordering requirements.  I don't see how this could be
> considered SC since
>> it creates a different result (uninitialized value) then the way that the
>> original source was coded did not.
>
> The JIT quite rightly can assume that it only needs to obey intra-thread
> semantics not inter-thread semantics. If you want SC across threads then you
> need synchronization and/or volatiles - not race conditions.
>
> Java programs are only SC in the absence of race conditions.

I do, completely understand this as being the case based on what the JMM 
specifies as non-racy programming.  The issue is, that this is unlike any other 
optimizations that have happened in computer science, in other languages, 
throughout a long history.  The old "register" keyword issues in C allowed the 
developer to decide when to "optimize".  When we had Sys-V IPC, you couldn't 
"share" without "controls".   When memmap hit the scene, then, it was possible 
to "share" unexpectedly, and it was expected that you knew to use semaphores to 
make sharing explicit/work.

Now, without any actions (I know that creating a thread is a sharing action) on 
the part of the developer, we have "incorrect" program operation.  Without 
source code or "javadoc comments" that detail how a method works, a developer 
has no idea how to use that software "correctly".  That is the insidious issue.

Litterally, all over the planet, there are people working feverishly to find and 
remove racy code because they are seeing unexpected and unpredictable behaviors, 
which are like "magic", happening in their applications.

For me, that is not an advancement in the science of software.  This kind of 
"tooling" works against the developer, not for/with them.

Gregg Wonderly

From vitalyd at gmail.com  Fri Mar 15 09:25:07 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 15 Mar 2013 09:25:07 -0400
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51431DB1.6010707@cytetech.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51431DB1.6010707@cytetech.com>
Message-ID: <CAHjP37H-AMTz=pU+hk0PbBme+=A7ZSx-nLxwjcVH95jnO364_Q@mail.gmail.com>

Every mainstream language with an optimizing compiler will always assume,
unless told otherwise, that the only thing it has to respect is
intra-thread visible behavior - this is nothing specific to java and is a
perfectly good assumption IMHO.  Given prevalence of multicore it's
imperative that concurrent programming is made easier (and there are
advancements both in software and hardware), but that's somewhat orthogonal
to compiler optimizations.

The issue here is whether get/setName were specifically written to not
account for multithreaded access or whether this is an oversight.

Sent from my phone
On Mar 15, 2013 9:16 AM, "Gregg Wonderly" <gregg at cytetech.com> wrote:

> On 3/15/2013 12:29 AM, David Holmes wrote:
>
>> Gregg,
>>
>> Gregg Wonderly writes:
>>
>>>
>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>
>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>
>>> operations that JIT
>>>
>>>> could do.  If another thread reads this.name between its
>>>>
>>> creation and the end of
>>>
>>>> arraycopy() then the thread will see a partially filled char[].
>>>>
>>>>       public final void setName(String name) {
>>>>           this.name = new char[name.length()];
>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>       }
>>>>
>>>
>>> This rewrite/optimization doesn't seem to meet sequential
>>> consistency ordering requirements.  I don't see how this could be
>>>
>> considered SC since
>>
>>> it creates a different result (uninitialized value) then the way that the
>>> original source was coded did not.
>>>
>>
>> The JIT quite rightly can assume that it only needs to obey intra-thread
>> semantics not inter-thread semantics. If you want SC across threads then
>> you
>> need synchronization and/or volatiles - not race conditions.
>>
>> Java programs are only SC in the absence of race conditions.
>>
>
> I do, completely understand this as being the case based on what the JMM
> specifies as non-racy programming.  The issue is, that this is unlike any
> other optimizations that have happened in computer science, in other
> languages, throughout a long history.  The old "register" keyword issues in
> C allowed the developer to decide when to "optimize".  When we had Sys-V
> IPC, you couldn't "share" without "controls".   When memmap hit the scene,
> then, it was possible to "share" unexpectedly, and it was expected that you
> knew to use semaphores to make sharing explicit/work.
>
> Now, without any actions (I know that creating a thread is a sharing
> action) on the part of the developer, we have "incorrect" program
> operation.  Without source code or "javadoc comments" that detail how a
> method works, a developer has no idea how to use that software "correctly".
>  That is the insidious issue.
>
> Litterally, all over the planet, there are people working feverishly to
> find and remove racy code because they are seeing unexpected and
> unpredictable behaviors, which are like "magic", happening in their
> applications.
>
> For me, that is not an advancement in the science of software.  This kind
> of "tooling" works against the developer, not for/with them.
>
> Gregg Wonderly
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/33079c37/attachment.html>

From viktor.klang at gmail.com  Fri Mar 15 09:34:03 2013
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Fri, 15 Mar 2013 14:34:03 +0100
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CAHjP37H-AMTz=pU+hk0PbBme+=A7ZSx-nLxwjcVH95jnO364_Q@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51431DB1.6010707@cytetech.com>
	<CAHjP37H-AMTz=pU+hk0PbBme+=A7ZSx-nLxwjcVH95jnO364_Q@mail.gmail.com>
Message-ID: <CANPzfU92Cx3ofCYKU4-MY72fS3_PZnFeDZGFEqxdd3zetrU_NQ@mail.gmail.com>

On Fri, Mar 15, 2013 at 2:25 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:

> Every mainstream language with an optimizing compiler will always assume,
> unless told otherwise, that the only thing it has to respect is
> intra-thread visible behavior - this is nothing specific to java and is a
> perfectly good assumption IMHO.  Given prevalence of multicore it's
> imperative that concurrent programming is made easier (and there are
> advancements both in software and hardware), but that's somewhat orthogonal
> to compiler optimizations.
>
> The issue here is whether get/setName were specifically written to not
> account for multithreaded access or whether this is an oversight.
>
Well, in this case the user needs to know how setName is implemented (on
all platforms he/she intends to run on). That's the real issue, IMO.

Cheers,
?

> Sent from my phone
> On Mar 15, 2013 9:16 AM, "Gregg Wonderly" <gregg at cytetech.com> wrote:
>
>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>
>>> Gregg,
>>>
>>> Gregg Wonderly writes:
>>>
>>>>
>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>
>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>
>>>> operations that JIT
>>>>
>>>>> could do.  If another thread reads this.name between its
>>>>>
>>>> creation and the end of
>>>>
>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>
>>>>>       public final void setName(String name) {
>>>>>           this.name = new char[name.length()];
>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>       }
>>>>>
>>>>
>>>> This rewrite/optimization doesn't seem to meet sequential
>>>> consistency ordering requirements.  I don't see how this could be
>>>>
>>> considered SC since
>>>
>>>> it creates a different result (uninitialized value) then the way that
>>>> the
>>>> original source was coded did not.
>>>>
>>>
>>> The JIT quite rightly can assume that it only needs to obey intra-thread
>>> semantics not inter-thread semantics. If you want SC across threads then
>>> you
>>> need synchronization and/or volatiles - not race conditions.
>>>
>>> Java programs are only SC in the absence of race conditions.
>>>
>>
>> I do, completely understand this as being the case based on what the JMM
>> specifies as non-racy programming.  The issue is, that this is unlike any
>> other optimizations that have happened in computer science, in other
>> languages, throughout a long history.  The old "register" keyword issues in
>> C allowed the developer to decide when to "optimize".  When we had Sys-V
>> IPC, you couldn't "share" without "controls".   When memmap hit the scene,
>> then, it was possible to "share" unexpectedly, and it was expected that you
>> knew to use semaphores to make sharing explicit/work.
>>
>> Now, without any actions (I know that creating a thread is a sharing
>> action) on the part of the developer, we have "incorrect" program
>> operation.  Without source code or "javadoc comments" that detail how a
>> method works, a developer has no idea how to use that software "correctly".
>>  That is the insidious issue.
>>
>> Litterally, all over the planet, there are people working feverishly to
>> find and remove racy code because they are seeing unexpected and
>> unpredictable behaviors, which are like "magic", happening in their
>> applications.
>>
>> For me, that is not an advancement in the science of software.  This kind
>> of "tooling" works against the developer, not for/with them.
>>
>> Gregg Wonderly
>> ______________________________**_________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
*Viktor Klang*
*Director of Engineering*
Typesafe <http://www.typesafe.com/>

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/11283345/attachment-0001.html>

From vitalyd at gmail.com  Fri Mar 15 09:38:03 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 15 Mar 2013 09:38:03 -0400
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CANPzfU92Cx3ofCYKU4-MY72fS3_PZnFeDZGFEqxdd3zetrU_NQ@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51431DB1.6010707@cytetech.com>
	<CAHjP37H-AMTz=pU+hk0PbBme+=A7ZSx-nLxwjcVH95jnO364_Q@mail.gmail.com>
	<CANPzfU92Cx3ofCYKU4-MY72fS3_PZnFeDZGFEqxdd3zetrU_NQ@mail.gmail.com>
Message-ID: <CAHjP37GxAuWAKKV+du1PfkpCmUaS5nRPLLMSObhGfeJ-j6WT6Q@mail.gmail.com>

They only need to know that if they're sharing the name across threads;
what's unclear though is whether this is a supported scenario.  If it's not
supported then you can't race on this even if it happened to work today
because it may break in a future version.

Sent from my phone
On Mar 15, 2013 9:34 AM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:

>
>
>
> On Fri, Mar 15, 2013 at 2:25 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>
>> Every mainstream language with an optimizing compiler will always assume,
>> unless told otherwise, that the only thing it has to respect is
>> intra-thread visible behavior - this is nothing specific to java and is a
>> perfectly good assumption IMHO.  Given prevalence of multicore it's
>> imperative that concurrent programming is made easier (and there are
>> advancements both in software and hardware), but that's somewhat orthogonal
>> to compiler optimizations.
>>
>> The issue here is whether get/setName were specifically written to not
>> account for multithreaded access or whether this is an oversight.
>>
> Well, in this case the user needs to know how setName is implemented (on
> all platforms he/she intends to run on). That's the real issue, IMO.
>
> Cheers,
> ?
>
>> Sent from my phone
>> On Mar 15, 2013 9:16 AM, "Gregg Wonderly" <gregg at cytetech.com> wrote:
>>
>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>
>>>> Gregg,
>>>>
>>>> Gregg Wonderly writes:
>>>>
>>>>>
>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>
>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>
>>>>> operations that JIT
>>>>>
>>>>>> could do.  If another thread reads this.name between its
>>>>>>
>>>>> creation and the end of
>>>>>
>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>
>>>>>>       public final void setName(String name) {
>>>>>>           this.name = new char[name.length()];
>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>>       }
>>>>>>
>>>>>
>>>>> This rewrite/optimization doesn't seem to meet sequential
>>>>> consistency ordering requirements.  I don't see how this could be
>>>>>
>>>> considered SC since
>>>>
>>>>> it creates a different result (uninitialized value) then the way that
>>>>> the
>>>>> original source was coded did not.
>>>>>
>>>>
>>>> The JIT quite rightly can assume that it only needs to obey intra-thread
>>>> semantics not inter-thread semantics. If you want SC across threads
>>>> then you
>>>> need synchronization and/or volatiles - not race conditions.
>>>>
>>>> Java programs are only SC in the absence of race conditions.
>>>>
>>>
>>> I do, completely understand this as being the case based on what the JMM
>>> specifies as non-racy programming.  The issue is, that this is unlike any
>>> other optimizations that have happened in computer science, in other
>>> languages, throughout a long history.  The old "register" keyword issues in
>>> C allowed the developer to decide when to "optimize".  When we had Sys-V
>>> IPC, you couldn't "share" without "controls".   When memmap hit the scene,
>>> then, it was possible to "share" unexpectedly, and it was expected that you
>>> knew to use semaphores to make sharing explicit/work.
>>>
>>> Now, without any actions (I know that creating a thread is a sharing
>>> action) on the part of the developer, we have "incorrect" program
>>> operation.  Without source code or "javadoc comments" that detail how a
>>> method works, a developer has no idea how to use that software "correctly".
>>>  That is the insidious issue.
>>>
>>> Litterally, all over the planet, there are people working feverishly to
>>> find and remove racy code because they are seeing unexpected and
>>> unpredictable behaviors, which are like "magic", happening in their
>>> applications.
>>>
>>> For me, that is not an advancement in the science of software.  This
>>> kind of "tooling" works against the developer, not for/with them.
>>>
>>> Gregg Wonderly
>>> ______________________________**_________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> --
> *Viktor Klang*
> *Director of Engineering*
> Typesafe <http://www.typesafe.com/>
>
> Twitter: @viktorklang
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/90e60dda/attachment.html>

From viktor.klang at gmail.com  Fri Mar 15 09:50:41 2013
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Fri, 15 Mar 2013 14:50:41 +0100
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CAHjP37GxAuWAKKV+du1PfkpCmUaS5nRPLLMSObhGfeJ-j6WT6Q@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51431DB1.6010707@cytetech.com>
	<CAHjP37H-AMTz=pU+hk0PbBme+=A7ZSx-nLxwjcVH95jnO364_Q@mail.gmail.com>
	<CANPzfU92Cx3ofCYKU4-MY72fS3_PZnFeDZGFEqxdd3zetrU_NQ@mail.gmail.com>
	<CAHjP37GxAuWAKKV+du1PfkpCmUaS5nRPLLMSObhGfeJ-j6WT6Q@mail.gmail.com>
Message-ID: <CANPzfU8WtUEQd53HZNZ59k6i+F8iYi=D3WaX01+1KnnFfLJ0kQ@mail.gmail.com>

On Fri, Mar 15, 2013 at 2:38 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:

> They only need to know that if they're sharing the name across threads;
> what's unclear though is whether this is a supported scenario.  If it's not
> supported then you can't race on this even if it happened to work today
> because it may break in a future version.
>
Doesn't VisualVM/JConsole extract the name of the Thread from another
Thread?
Which means that even though you set the name from within the thread,
getName may be invoked by any other thread.

Or am I missing something?

Cheers,
?


> Sent from my phone
> On Mar 15, 2013 9:34 AM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:
>
>>
>>
>>
>> On Fri, Mar 15, 2013 at 2:25 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>>
>>> Every mainstream language with an optimizing compiler will always
>>> assume, unless told otherwise, that the only thing it has to respect is
>>> intra-thread visible behavior - this is nothing specific to java and is a
>>> perfectly good assumption IMHO.  Given prevalence of multicore it's
>>> imperative that concurrent programming is made easier (and there are
>>> advancements both in software and hardware), but that's somewhat orthogonal
>>> to compiler optimizations.
>>>
>>> The issue here is whether get/setName were specifically written to not
>>> account for multithreaded access or whether this is an oversight.
>>>
>> Well, in this case the user needs to know how setName is implemented (on
>> all platforms he/she intends to run on). That's the real issue, IMO.
>>
>> Cheers,
>> ?
>>
>>> Sent from my phone
>>> On Mar 15, 2013 9:16 AM, "Gregg Wonderly" <gregg at cytetech.com> wrote:
>>>
>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>
>>>>> Gregg,
>>>>>
>>>>> Gregg Wonderly writes:
>>>>>
>>>>>>
>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>
>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>>
>>>>>> operations that JIT
>>>>>>
>>>>>>> could do.  If another thread reads this.name between its
>>>>>>>
>>>>>> creation and the end of
>>>>>>
>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>
>>>>>>>       public final void setName(String name) {
>>>>>>>           this.name = new char[name.length()];
>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>>>       }
>>>>>>>
>>>>>>
>>>>>> This rewrite/optimization doesn't seem to meet sequential
>>>>>> consistency ordering requirements.  I don't see how this could be
>>>>>>
>>>>> considered SC since
>>>>>
>>>>>> it creates a different result (uninitialized value) then the way that
>>>>>> the
>>>>>> original source was coded did not.
>>>>>>
>>>>>
>>>>> The JIT quite rightly can assume that it only needs to obey
>>>>> intra-thread
>>>>> semantics not inter-thread semantics. If you want SC across threads
>>>>> then you
>>>>> need synchronization and/or volatiles - not race conditions.
>>>>>
>>>>> Java programs are only SC in the absence of race conditions.
>>>>>
>>>>
>>>> I do, completely understand this as being the case based on what the
>>>> JMM specifies as non-racy programming.  The issue is, that this is unlike
>>>> any other optimizations that have happened in computer science, in other
>>>> languages, throughout a long history.  The old "register" keyword issues in
>>>> C allowed the developer to decide when to "optimize".  When we had Sys-V
>>>> IPC, you couldn't "share" without "controls".   When memmap hit the scene,
>>>> then, it was possible to "share" unexpectedly, and it was expected that you
>>>> knew to use semaphores to make sharing explicit/work.
>>>>
>>>> Now, without any actions (I know that creating a thread is a sharing
>>>> action) on the part of the developer, we have "incorrect" program
>>>> operation.  Without source code or "javadoc comments" that detail how a
>>>> method works, a developer has no idea how to use that software "correctly".
>>>>  That is the insidious issue.
>>>>
>>>> Litterally, all over the planet, there are people working feverishly to
>>>> find and remove racy code because they are seeing unexpected and
>>>> unpredictable behaviors, which are like "magic", happening in their
>>>> applications.
>>>>
>>>> For me, that is not an advancement in the science of software.  This
>>>> kind of "tooling" works against the developer, not for/with them.
>>>>
>>>> Gregg Wonderly
>>>> ______________________________**_________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>>
>> --
>> *Viktor Klang*
>> *Director of Engineering*
>> Typesafe <http://www.typesafe.com/>
>>
>> Twitter: @viktorklang
>>
>


-- 
*Viktor Klang*
*Director of Engineering*
Typesafe <http://www.typesafe.com/>

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/0f9350dd/attachment-0001.html>

From vitalyd at gmail.com  Fri Mar 15 09:59:49 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 15 Mar 2013 09:59:49 -0400
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CANPzfU8WtUEQd53HZNZ59k6i+F8iYi=D3WaX01+1KnnFfLJ0kQ@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51431DB1.6010707@cytetech.com>
	<CAHjP37H-AMTz=pU+hk0PbBme+=A7ZSx-nLxwjcVH95jnO364_Q@mail.gmail.com>
	<CANPzfU92Cx3ofCYKU4-MY72fS3_PZnFeDZGFEqxdd3zetrU_NQ@mail.gmail.com>
	<CAHjP37GxAuWAKKV+du1PfkpCmUaS5nRPLLMSObhGfeJ-j6WT6Q@mail.gmail.com>
	<CANPzfU8WtUEQd53HZNZ59k6i+F8iYi=D3WaX01+1KnnFfLJ0kQ@mail.gmail.com>
Message-ID: <CAHjP37HEvJ+Q4nNHu_2bGe7EC07hktXgncVV_nvMAm1ZH5PjEw@mail.gmail.com>

They're definitely places where the name is read (some examples brought up
in this thread as well).  So for the common case of creating a thread,
setting its name, and starting it - the start is an HB action in the JMM;
tooling reading that is fine.  The question is whether setting the name
after thread has started is considered "OK".  Given that this is a managed
runtime, nothing horrendous is going to happen (e.g. sigsegv) if you
observe a partial char[] (unless there's important logic depending on it,
but then design is broken already).

As an aside, in .NET for example, you can only set the thread name once -
it throws on subsequent attempts.

Sent from my phone
On Mar 15, 2013 9:50 AM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:

>
>
>
> On Fri, Mar 15, 2013 at 2:38 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>
>> They only need to know that if they're sharing the name across threads;
>> what's unclear though is whether this is a supported scenario.  If it's not
>> supported then you can't race on this even if it happened to work today
>> because it may break in a future version.
>>
> Doesn't VisualVM/JConsole extract the name of the Thread from another
> Thread?
> Which means that even though you set the name from within the thread,
> getName may be invoked by any other thread.
>
> Or am I missing something?
>
> Cheers,
> ?
>
>
>> Sent from my phone
>> On Mar 15, 2013 9:34 AM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:
>>
>>>
>>>
>>>
>>> On Fri, Mar 15, 2013 at 2:25 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>>>
>>>> Every mainstream language with an optimizing compiler will always
>>>> assume, unless told otherwise, that the only thing it has to respect is
>>>> intra-thread visible behavior - this is nothing specific to java and is a
>>>> perfectly good assumption IMHO.  Given prevalence of multicore it's
>>>> imperative that concurrent programming is made easier (and there are
>>>> advancements both in software and hardware), but that's somewhat orthogonal
>>>> to compiler optimizations.
>>>>
>>>> The issue here is whether get/setName were specifically written to not
>>>> account for multithreaded access or whether this is an oversight.
>>>>
>>> Well, in this case the user needs to know how setName is implemented (on
>>> all platforms he/she intends to run on). That's the real issue, IMO.
>>>
>>> Cheers,
>>> ?
>>>
>>>> Sent from my phone
>>>> On Mar 15, 2013 9:16 AM, "Gregg Wonderly" <gregg at cytetech.com> wrote:
>>>>
>>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>>
>>>>>> Gregg,
>>>>>>
>>>>>> Gregg Wonderly writes:
>>>>>>
>>>>>>>
>>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>>
>>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>>>
>>>>>>> operations that JIT
>>>>>>>
>>>>>>>> could do.  If another thread reads this.name between its
>>>>>>>>
>>>>>>> creation and the end of
>>>>>>>
>>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>>
>>>>>>>>       public final void setName(String name) {
>>>>>>>>           this.name = new char[name.length()];
>>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>>>>       }
>>>>>>>>
>>>>>>>
>>>>>>> This rewrite/optimization doesn't seem to meet sequential
>>>>>>> consistency ordering requirements.  I don't see how this could be
>>>>>>>
>>>>>> considered SC since
>>>>>>
>>>>>>> it creates a different result (uninitialized value) then the way
>>>>>>> that the
>>>>>>> original source was coded did not.
>>>>>>>
>>>>>>
>>>>>> The JIT quite rightly can assume that it only needs to obey
>>>>>> intra-thread
>>>>>> semantics not inter-thread semantics. If you want SC across threads
>>>>>> then you
>>>>>> need synchronization and/or volatiles - not race conditions.
>>>>>>
>>>>>> Java programs are only SC in the absence of race conditions.
>>>>>>
>>>>>
>>>>> I do, completely understand this as being the case based on what the
>>>>> JMM specifies as non-racy programming.  The issue is, that this is unlike
>>>>> any other optimizations that have happened in computer science, in other
>>>>> languages, throughout a long history.  The old "register" keyword issues in
>>>>> C allowed the developer to decide when to "optimize".  When we had Sys-V
>>>>> IPC, you couldn't "share" without "controls".   When memmap hit the scene,
>>>>> then, it was possible to "share" unexpectedly, and it was expected that you
>>>>> knew to use semaphores to make sharing explicit/work.
>>>>>
>>>>> Now, without any actions (I know that creating a thread is a sharing
>>>>> action) on the part of the developer, we have "incorrect" program
>>>>> operation.  Without source code or "javadoc comments" that detail how a
>>>>> method works, a developer has no idea how to use that software "correctly".
>>>>>  That is the insidious issue.
>>>>>
>>>>> Litterally, all over the planet, there are people working feverishly
>>>>> to find and remove racy code because they are seeing unexpected and
>>>>> unpredictable behaviors, which are like "magic", happening in their
>>>>> applications.
>>>>>
>>>>> For me, that is not an advancement in the science of software.  This
>>>>> kind of "tooling" works against the developer, not for/with them.
>>>>>
>>>>> Gregg Wonderly
>>>>> ______________________________**_________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>>
>>> --
>>> *Viktor Klang*
>>> *Director of Engineering*
>>> Typesafe <http://www.typesafe.com/>
>>>
>>> Twitter: @viktorklang
>>>
>>
>
>
> --
> *Viktor Klang*
> *Director of Engineering*
> Typesafe <http://www.typesafe.com/>
>
> Twitter: @viktorklang
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/5a6090b7/attachment.html>

From gergg at cox.net  Fri Mar 15 10:30:29 2013
From: gergg at cox.net (Gregg Wonderly)
Date: Fri, 15 Mar 2013 09:30:29 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CAHjP37HEvJ+Q4nNHu_2bGe7EC07hktXgncVV_nvMAm1ZH5PjEw@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51431DB1.6010707@cytetech.com>
	<CAHjP37H-AMTz=pU+hk0PbBme+=A7ZSx-nLxwjcVH95jnO364_Q@mail.gmail.com>
	<CANPzfU92Cx3ofCYKU4-MY72fS3_PZnFeDZGFEqxdd3zetrU_NQ@mail.gmail.com>
	<CAHjP37GxAuWAKKV+du1PfkpCmUaS5nRPLLMSObhGfeJ-j6WT6Q@mail.gmail.com>
	<CANPzfU8WtUEQd53HZNZ59k6i+F8iYi=D3WaX01+1KnnFfLJ0kQ@mail.gmail.com>
	<CAHjP37HEvJ+Q4nNHu_2bGe7EC07hktXgncVV_nvMAm1ZH5PjEw@mail.gmail.com>
Message-ID: <BC314B2E-69DE-486E-ACD8-DCEAA2DCA68C@cox.net>

If the optimization pointed out here is actually happening, then it would be possible for two threads to race on setting this.name to an array that is too short for the string that the other thread would subsequently copy into the allocated array.  So, under some specific circumstances, it seems to me that setName() could throw "ArrayIndexOutOfBounds" or worse, sigsegv if the array copy is not checking each byte written against the "current" length of the array in an atomic "check-length-store-byte" operation. 

This is a nasty race optimization and clearly the JVM can fault or cause an unexpected RuntimeException out of this code?

Gregg Wonderly

On Mar 15, 2013, at 8:59 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:

> They're definitely places where the name is read (some examples brought up in this thread as well).  So for the common case of creating a thread, setting its name, and starting it - the start is an HB action in the JMM; tooling reading that is fine.  The question is whether setting the name after thread has started is considered "OK".  Given that this is a managed runtime, nothing horrendous is going to happen (e.g. sigsegv) if you observe a partial char[] (unless there's important logic depending on it, but then design is broken already).
> 
> As an aside, in .NET for example, you can only set the thread name once - it throws on subsequent attempts.
> 
> Sent from my phone
> 
> On Mar 15, 2013 9:50 AM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:
> 
> 
> 
> On Fri, Mar 15, 2013 at 2:38 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> They only need to know that if they're sharing the name across threads; what's unclear though is whether this is a supported scenario.  If it's not supported then you can't race on this even if it happened to work today because it may break in a future version.
> 
> Doesn't VisualVM/JConsole extract the name of the Thread from another Thread?
> Which means that even though you set the name from within the thread, getName may be invoked by any other thread.
> 
> Or am I missing something?
> 
> Cheers,
> ?
>  
> Sent from my phone
> 
> On Mar 15, 2013 9:34 AM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:
> 
> 
> 
> On Fri, Mar 15, 2013 at 2:25 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> Every mainstream language with an optimizing compiler will always assume, unless told otherwise, that the only thing it has to respect is intra-thread visible behavior - this is nothing specific to java and is a perfectly good assumption IMHO.  Given prevalence of multicore it's imperative that concurrent programming is made easier (and there are advancements both in software and hardware), but that's somewhat orthogonal to compiler optimizations.
> 
> The issue here is whether get/setName were specifically written to not account for multithreaded access or whether this is an oversight.
> 
> Well, in this case the user needs to know how setName is implemented (on all platforms he/she intends to run on). That's the real issue, IMO.
> 
> Cheers,
> ?
> Sent from my phone
> 
> On Mar 15, 2013 9:16 AM, "Gregg Wonderly" <gregg at cytetech.com> wrote:
> On 3/15/2013 12:29 AM, David Holmes wrote:
> Gregg,
> 
> Gregg Wonderly writes:
> 
> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
> I've inlined the name.toCharArray() and rearranged a few
> operations that JIT
> could do.  If another thread reads this.name between its
> creation and the end of
> arraycopy() then the thread will see a partially filled char[].
> 
>       public final void setName(String name) {
>           this.name = new char[name.length()];
>           System.arraycopy(..., 0, result, 0, name.length());
>       }
> 
> This rewrite/optimization doesn't seem to meet sequential
> consistency ordering requirements.  I don't see how this could be
> considered SC since
> it creates a different result (uninitialized value) then the way that the
> original source was coded did not.
> 
> The JIT quite rightly can assume that it only needs to obey intra-thread
> semantics not inter-thread semantics. If you want SC across threads then you
> need synchronization and/or volatiles - not race conditions.
> 
> Java programs are only SC in the absence of race conditions.
> 
> I do, completely understand this as being the case based on what the JMM specifies as non-racy programming.  The issue is, that this is unlike any other optimizations that have happened in computer science, in other languages, throughout a long history.  The old "register" keyword issues in C allowed the developer to decide when to "optimize".  When we had Sys-V IPC, you couldn't "share" without "controls".   When memmap hit the scene, then, it was possible to "share" unexpectedly, and it was expected that you knew to use semaphores to make sharing explicit/work.
> 
> Now, without any actions (I know that creating a thread is a sharing action) on the part of the developer, we have "incorrect" program operation.  Without source code or "javadoc comments" that detail how a method works, a developer has no idea how to use that software "correctly".  That is the insidious issue.
> 
> Litterally, all over the planet, there are people working feverishly to find and remove racy code because they are seeing unexpected and unpredictable behaviors, which are like "magic", happening in their applications.
> 
> For me, that is not an advancement in the science of software.  This kind of "tooling" works against the developer, not for/with them.
> 
> Gregg Wonderly
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> 
> 
> -- 
> Viktor Klang
> Director of Engineering
> Typesafe
> 
> Twitter: @viktorklang
> 
> 
> 
> -- 
> Viktor Klang
> Director of Engineering
> Typesafe
> 
> Twitter: @viktorklang
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/04339f29/attachment-0001.html>

From stanimir at riflexo.com  Fri Mar 15 10:31:49 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Fri, 15 Mar 2013 16:31:49 +0200
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CANPzfU8WtUEQd53HZNZ59k6i+F8iYi=D3WaX01+1KnnFfLJ0kQ@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51431DB1.6010707@cytetech.com>
	<CAHjP37H-AMTz=pU+hk0PbBme+=A7ZSx-nLxwjcVH95jnO364_Q@mail.gmail.com>
	<CANPzfU92Cx3ofCYKU4-MY72fS3_PZnFeDZGFEqxdd3zetrU_NQ@mail.gmail.com>
	<CAHjP37GxAuWAKKV+du1PfkpCmUaS5nRPLLMSObhGfeJ-j6WT6Q@mail.gmail.com>
	<CANPzfU8WtUEQd53HZNZ59k6i+F8iYi=D3WaX01+1KnnFfLJ0kQ@mail.gmail.com>
Message-ID: <CAEJX8orNkXv4x2OGhLUnrsFj+aAC0zwYG4S_-NB2LgNO1PsUsg@mail.gmail.com>

On Fri, Mar 15, 2013 at 2:38 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>
>> They only need to know that if they're sharing the name across threads;
>> what's unclear though is whether this is a supported scenario.  If it's not
>> supported then you can't race on this even if it happened to work today
>> because it may break in a future version.
>>
> Doesn't VisualVM/JConsole extract the name of the Thread from another
> Thread?
> Which means that even though you set the name from within the thread,
> getName may be invoked by any other thread.
>
> The entire JMX threading framework uses different thread(s) to obtain the
names, virtually all interesting calls to getName() would be out of the
current thread. Even Thread.getAllStackTraces() would be called from a
different thread.
However any thread that has its name set prior to start() would never be
affected by the race provided it doesn't get changed dynamically.
IMO, not being volatile is an omission: parkBlocker is volatile and it's
useful for the same diagnostic purposes, of course it set significantly
more often. There are no warnings about modifying setName past start(), so
it shall follow suit.
Generally, I see it as very minor issue, though.

Stanimir


>

>
>> Sent from my phone
>> On Mar 15, 2013 9:34 AM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:
>>
>>>
>>>
>>>
>>> On Fri, Mar 15, 2013 at 2:25 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>>>
>>>> Every mainstream language with an optimizing compiler will always
>>>> assume, unless told otherwise, that the only thing it has to respect is
>>>> intra-thread visible behavior - this is nothing specific to java and is a
>>>> perfectly good assumption IMHO.  Given prevalence of multicore it's
>>>> imperative that concurrent programming is made easier (and there are
>>>> advancements both in software and hardware), but that's somewhat orthogonal
>>>> to compiler optimizations.
>>>>
>>>> The issue here is whether get/setName were specifically written to not
>>>> account for multithreaded access or whether this is an oversight.
>>>>
>>> Well, in this case the user needs to know how setName is implemented (on
>>> all platforms he/she intends to run on). That's the real issue, IMO.
>>>
>>> Cheers,
>>> ?
>>>
>>>> Sent from my phone
>>>> On Mar 15, 2013 9:16 AM, "Gregg Wonderly" <gregg at cytetech.com> wrote:
>>>>
>>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>>
>>>>>> Gregg,
>>>>>>
>>>>>> Gregg Wonderly writes:
>>>>>>
>>>>>>>
>>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>>
>>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>>>
>>>>>>> operations that JIT
>>>>>>>
>>>>>>>> could do.  If another thread reads this.name between its
>>>>>>>>
>>>>>>> creation and the end of
>>>>>>>
>>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>>
>>>>>>>>       public final void setName(String name) {
>>>>>>>>           this.name = new char[name.length()];
>>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>>>>       }
>>>>>>>>
>>>>>>>
>>>>>>> This rewrite/optimization doesn't seem to meet sequential
>>>>>>> consistency ordering requirements.  I don't see how this could be
>>>>>>>
>>>>>> considered SC since
>>>>>>
>>>>>>> it creates a different result (uninitialized value) then the way
>>>>>>> that the
>>>>>>> original source was coded did not.
>>>>>>>
>>>>>>
>>>>>> The JIT quite rightly can assume that it only needs to obey
>>>>>> intra-thread
>>>>>> semantics not inter-thread semantics. If you want SC across threads
>>>>>> then you
>>>>>> need synchronization and/or volatiles - not race conditions.
>>>>>>
>>>>>> Java programs are only SC in the absence of race conditions.
>>>>>>
>>>>>
>>>>> I do, completely understand this as being the case based on what the
>>>>> JMM specifies as non-racy programming.  The issue is, that this is unlike
>>>>> any other optimizations that have happened in computer science, in other
>>>>> languages, throughout a long history.  The old "register" keyword issues in
>>>>> C allowed the developer to decide when to "optimize".  When we had Sys-V
>>>>> IPC, you couldn't "share" without "controls".   When memmap hit the scene,
>>>>> then, it was possible to "share" unexpectedly, and it was expected that you
>>>>> knew to use semaphores to make sharing explicit/work.
>>>>>
>>>>> Now, without any actions (I know that creating a thread is a sharing
>>>>> action) on the part of the developer, we have "incorrect" program
>>>>> operation.  Without source code or "javadoc comments" that detail how a
>>>>> method works, a developer has no idea how to use that software "correctly".
>>>>>  That is the insidious issue.
>>>>>
>>>>> Litterally, all over the planet, there are people working feverishly
>>>>> to find and remove racy code because they are seeing unexpected and
>>>>> unpredictable behaviors, which are like "magic", happening in their
>>>>> applications.
>>>>>
>>>>> For me, that is not an advancement in the science of software.  This
>>>>> kind of "tooling" works against the developer, not for/with them.
>>>>>
>>>>> Gregg Wonderly
>>>>> ______________________________**_________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>>
>>> --
>>> *Viktor Klang*
>>> *Director of Engineering*
>>> Typesafe <http://www.typesafe.com/>
>>>
>>> Twitter: @viktorklang
>>>
>>
>
>
> --
> *Viktor Klang*
> *Director of Engineering*
> Typesafe <http://www.typesafe.com/>
>
> Twitter: @viktorklang
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/d3bb9884/attachment.html>

From stanimir at riflexo.com  Fri Mar 15 10:42:58 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Fri, 15 Mar 2013 16:42:58 +0200
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <BC314B2E-69DE-486E-ACD8-DCEAA2DCA68C@cox.net>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51431DB1.6010707@cytetech.com>
	<CAHjP37H-AMTz=pU+hk0PbBme+=A7ZSx-nLxwjcVH95jnO364_Q@mail.gmail.com>
	<CANPzfU92Cx3ofCYKU4-MY72fS3_PZnFeDZGFEqxdd3zetrU_NQ@mail.gmail.com>
	<CAHjP37GxAuWAKKV+du1PfkpCmUaS5nRPLLMSObhGfeJ-j6WT6Q@mail.gmail.com>
	<CANPzfU8WtUEQd53HZNZ59k6i+F8iYi=D3WaX01+1KnnFfLJ0kQ@mail.gmail.com>
	<CAHjP37HEvJ+Q4nNHu_2bGe7EC07hktXgncVV_nvMAm1ZH5PjEw@mail.gmail.com>
	<BC314B2E-69DE-486E-ACD8-DCEAA2DCA68C@cox.net>
Message-ID: <CAEJX8opu_M=r7PsdSv=3C==j_GTw5fw=VWqd2XbV2HsE66swMA@mail.gmail.com>

On Fri, Mar 15, 2013 at 4:30 PM, Gregg Wonderly <gergg at cox.net> wrote:

> If the optimization pointed out here is actually happening, then it would
> be possible for two threads to race on setting this.name to an array that
> is too short for the string that the other thread would subsequently copy
> into the allocated array.  So, under some specific circumstances, it seems
> to me that setName() could throw "ArrayIndexOutOfBounds" or worse, sigsegv
> if the array copy is not checking each byte written against the "current"
> length of the array in an atomic "check-length-store-byte" operation.
>
> This is a nasty race optimization and clearly the JVM can fault or cause
> an unexpected RuntimeException out of this code?
>
>
It'd be incorrect code if the JVM uses more than a single load to generate
the String.
It's possible to see 'zeros' but nothing else, zero as character is totally
ok.

Stanimir


> Gregg Wonderly
>
> On Mar 15, 2013, at 8:59 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> They're definitely places where the name is read (some examples brought up
> in this thread as well).  So for the common case of creating a thread,
> setting its name, and starting it - the start is an HB action in the JMM;
> tooling reading that is fine.  The question is whether setting the name
> after thread has started is considered "OK".  Given that this is a managed
> runtime, nothing horrendous is going to happen (e.g. sigsegv) if you
> observe a partial char[] (unless there's important logic depending on it,
> but then design is broken already).
>
> As an aside, in .NET for example, you can only set the thread name once -
> it throws on subsequent attempts.
>
> Sent from my phone
> On Mar 15, 2013 9:50 AM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:
>
>>
>>
>>
>> On Fri, Mar 15, 2013 at 2:38 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>>
>>> They only need to know that if they're sharing the name across threads;
>>> what's unclear though is whether this is a supported scenario.  If it's not
>>> supported then you can't race on this even if it happened to work today
>>> because it may break in a future version.
>>>
>> Doesn't VisualVM/JConsole extract the name of the Thread from another
>> Thread?
>> Which means that even though you set the name from within the thread,
>> getName may be invoked by any other thread.
>>
>> Or am I missing something?
>>
>> Cheers,
>> ?
>>
>>
>>> Sent from my phone
>>> On Mar 15, 2013 9:34 AM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:
>>>
>>>>
>>>>
>>>>
>>>> On Fri, Mar 15, 2013 at 2:25 PM, Vitaly Davidovich <vitalyd at gmail.com>wrote:
>>>>
>>>>> Every mainstream language with an optimizing compiler will always
>>>>> assume, unless told otherwise, that the only thing it has to respect is
>>>>> intra-thread visible behavior - this is nothing specific to java and is a
>>>>> perfectly good assumption IMHO.  Given prevalence of multicore it's
>>>>> imperative that concurrent programming is made easier (and there are
>>>>> advancements both in software and hardware), but that's somewhat orthogonal
>>>>> to compiler optimizations.
>>>>>
>>>>> The issue here is whether get/setName were specifically written to not
>>>>> account for multithreaded access or whether this is an oversight.
>>>>>
>>>> Well, in this case the user needs to know how setName is implemented
>>>> (on all platforms he/she intends to run on). That's the real issue, IMO.
>>>>
>>>> Cheers,
>>>> ?
>>>>
>>>>> Sent from my phone
>>>>> On Mar 15, 2013 9:16 AM, "Gregg Wonderly" <gregg at cytetech.com> wrote:
>>>>>
>>>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>>>
>>>>>>> Gregg,
>>>>>>>
>>>>>>> Gregg Wonderly writes:
>>>>>>>
>>>>>>>>
>>>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>>>
>>>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>>>>
>>>>>>>> operations that JIT
>>>>>>>>
>>>>>>>>> could do.  If another thread reads this.name between its
>>>>>>>>>
>>>>>>>> creation and the end of
>>>>>>>>
>>>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>>>
>>>>>>>>>       public final void setName(String name) {
>>>>>>>>>           this.name = new char[name.length()];
>>>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>>>>>       }
>>>>>>>>>
>>>>>>>>
>>>>>>>> This rewrite/optimization doesn't seem to meet sequential
>>>>>>>> consistency ordering requirements.  I don't see how this could be
>>>>>>>>
>>>>>>> considered SC since
>>>>>>>
>>>>>>>> it creates a different result (uninitialized value) then the way
>>>>>>>> that the
>>>>>>>> original source was coded did not.
>>>>>>>>
>>>>>>>
>>>>>>> The JIT quite rightly can assume that it only needs to obey
>>>>>>> intra-thread
>>>>>>> semantics not inter-thread semantics. If you want SC across threads
>>>>>>> then you
>>>>>>> need synchronization and/or volatiles - not race conditions.
>>>>>>>
>>>>>>> Java programs are only SC in the absence of race conditions.
>>>>>>>
>>>>>>
>>>>>> I do, completely understand this as being the case based on what the
>>>>>> JMM specifies as non-racy programming.  The issue is, that this is unlike
>>>>>> any other optimizations that have happened in computer science, in other
>>>>>> languages, throughout a long history.  The old "register" keyword issues in
>>>>>> C allowed the developer to decide when to "optimize".  When we had Sys-V
>>>>>> IPC, you couldn't "share" without "controls".   When memmap hit the scene,
>>>>>> then, it was possible to "share" unexpectedly, and it was expected that you
>>>>>> knew to use semaphores to make sharing explicit/work.
>>>>>>
>>>>>> Now, without any actions (I know that creating a thread is a sharing
>>>>>> action) on the part of the developer, we have "incorrect" program
>>>>>> operation.  Without source code or "javadoc comments" that detail how a
>>>>>> method works, a developer has no idea how to use that software "correctly".
>>>>>>  That is the insidious issue.
>>>>>>
>>>>>> Litterally, all over the planet, there are people working feverishly
>>>>>> to find and remove racy code because they are seeing unexpected and
>>>>>> unpredictable behaviors, which are like "magic", happening in their
>>>>>> applications.
>>>>>>
>>>>>> For me, that is not an advancement in the science of software.  This
>>>>>> kind of "tooling" works against the developer, not for/with them.
>>>>>>
>>>>>> Gregg Wonderly
>>>>>> ______________________________**_________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>>
>>>> --
>>>> *Viktor Klang*
>>>> *Director of Engineering*
>>>> Typesafe <http://www.typesafe.com/>
>>>>
>>>> Twitter: @viktorklang
>>>>
>>>
>>
>>
>> --
>> *Viktor Klang*
>> *Director of Engineering*
>> Typesafe <http://www.typesafe.com/>
>>
>> Twitter: @viktorklang
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/2c4c448b/attachment-0001.html>

From zhong.j.yu at gmail.com  Fri Mar 15 11:25:49 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Fri, 15 Mar 2013 10:25:49 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <BC314B2E-69DE-486E-ACD8-DCEAA2DCA68C@cox.net>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51431DB1.6010707@cytetech.com>
	<CAHjP37H-AMTz=pU+hk0PbBme+=A7ZSx-nLxwjcVH95jnO364_Q@mail.gmail.com>
	<CANPzfU92Cx3ofCYKU4-MY72fS3_PZnFeDZGFEqxdd3zetrU_NQ@mail.gmail.com>
	<CAHjP37GxAuWAKKV+du1PfkpCmUaS5nRPLLMSObhGfeJ-j6WT6Q@mail.gmail.com>
	<CANPzfU8WtUEQd53HZNZ59k6i+F8iYi=D3WaX01+1KnnFfLJ0kQ@mail.gmail.com>
	<CAHjP37HEvJ+Q4nNHu_2bGe7EC07hktXgncVV_nvMAm1ZH5PjEw@mail.gmail.com>
	<BC314B2E-69DE-486E-ACD8-DCEAA2DCA68C@cox.net>
Message-ID: <CACuKZqGBG946po2eu37nY0S=3kpo=edyNXAEHzE2t3RkJWnSFg@mail.gmail.com>

On Fri, Mar 15, 2013 at 9:30 AM, Gregg Wonderly <gergg at cox.net> wrote:
> If the optimization pointed out here is actually happening, then it would be
> possible for two threads to race on setting this.name to an array that is
> too short for the string that the other thread would subsequently copy into
> the allocated array.  So, under some specific circumstances, it seems to me
> that setName() could throw "ArrayIndexOutOfBounds" or worse, sigsegv if the
> array copy is not checking each byte written against the "current" length of
> the array in an atomic "check-length-store-byte" operation.

Fortunately that won't happen. Consider this code

    char[] x = name;
    assert x.length==x.length;

The assertion must succeed. (Note the length field is final). The
compiler must not transform the code to

    char[] x = name;
    char[] y = name; // another read!
    assert x.length==y.length;

Zhong Yu

> This is a nasty race optimization and clearly the JVM can fault or cause an
> unexpected RuntimeException out of this code?
>
> Gregg Wonderly
>
> On Mar 15, 2013, at 8:59 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> They're definitely places where the name is read (some examples brought up
> in this thread as well).  So for the common case of creating a thread,
> setting its name, and starting it - the start is an HB action in the JMM;
> tooling reading that is fine.  The question is whether setting the name
> after thread has started is considered "OK".  Given that this is a managed
> runtime, nothing horrendous is going to happen (e.g. sigsegv) if you observe
> a partial char[] (unless there's important logic depending on it, but then
> design is broken already).
>
> As an aside, in .NET for example, you can only set the thread name once - it
> throws on subsequent attempts.
>
> Sent from my phone
>
> On Mar 15, 2013 9:50 AM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:
>>
>>
>>
>>
>> On Fri, Mar 15, 2013 at 2:38 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>>>
>>> They only need to know that if they're sharing the name across threads;
>>> what's unclear though is whether this is a supported scenario.  If it's not
>>> supported then you can't race on this even if it happened to work today
>>> because it may break in a future version.
>>
>> Doesn't VisualVM/JConsole extract the name of the Thread from another
>> Thread?
>> Which means that even though you set the name from within the thread,
>> getName may be invoked by any other thread.
>>
>> Or am I missing something?
>>
>> Cheers,
>> ?
>>
>>>
>>> Sent from my phone
>>>
>>> On Mar 15, 2013 9:34 AM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:
>>>>
>>>>
>>>>
>>>>
>>>> On Fri, Mar 15, 2013 at 2:25 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>>> wrote:
>>>>>
>>>>> Every mainstream language with an optimizing compiler will always
>>>>> assume, unless told otherwise, that the only thing it has to respect is
>>>>> intra-thread visible behavior - this is nothing specific to java and is a
>>>>> perfectly good assumption IMHO.  Given prevalence of multicore it's
>>>>> imperative that concurrent programming is made easier (and there are
>>>>> advancements both in software and hardware), but that's somewhat orthogonal
>>>>> to compiler optimizations.
>>>>>
>>>>> The issue here is whether get/setName were specifically written to not
>>>>> account for multithreaded access or whether this is an oversight.
>>>>
>>>> Well, in this case the user needs to know how setName is implemented (on
>>>> all platforms he/she intends to run on). That's the real issue, IMO.
>>>>
>>>> Cheers,
>>>> ?
>>>>>
>>>>> Sent from my phone
>>>>>
>>>>> On Mar 15, 2013 9:16 AM, "Gregg Wonderly" <gregg at cytetech.com> wrote:
>>>>>>
>>>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>>>>
>>>>>>> Gregg,
>>>>>>>
>>>>>>> Gregg Wonderly writes:
>>>>>>>>
>>>>>>>>
>>>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>>>>
>>>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>>>
>>>>>>>> operations that JIT
>>>>>>>>>
>>>>>>>>> could do.  If another thread reads this.name between its
>>>>>>>>
>>>>>>>> creation and the end of
>>>>>>>>>
>>>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>>>
>>>>>>>>>       public final void setName(String name) {
>>>>>>>>>           this.name = new char[name.length()];
>>>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>>>>>       }
>>>>>>>>
>>>>>>>>
>>>>>>>> This rewrite/optimization doesn't seem to meet sequential
>>>>>>>> consistency ordering requirements.  I don't see how this could be
>>>>>>>
>>>>>>> considered SC since
>>>>>>>>
>>>>>>>> it creates a different result (uninitialized value) then the way
>>>>>>>> that the
>>>>>>>> original source was coded did not.
>>>>>>>
>>>>>>>
>>>>>>> The JIT quite rightly can assume that it only needs to obey
>>>>>>> intra-thread
>>>>>>> semantics not inter-thread semantics. If you want SC across threads
>>>>>>> then you
>>>>>>> need synchronization and/or volatiles - not race conditions.
>>>>>>>
>>>>>>> Java programs are only SC in the absence of race conditions.
>>>>>>
>>>>>>
>>>>>> I do, completely understand this as being the case based on what the
>>>>>> JMM specifies as non-racy programming.  The issue is, that this is unlike
>>>>>> any other optimizations that have happened in computer science, in other
>>>>>> languages, throughout a long history.  The old "register" keyword issues in
>>>>>> C allowed the developer to decide when to "optimize".  When we had Sys-V
>>>>>> IPC, you couldn't "share" without "controls".   When memmap hit the scene,
>>>>>> then, it was possible to "share" unexpectedly, and it was expected that you
>>>>>> knew to use semaphores to make sharing explicit/work.
>>>>>>
>>>>>> Now, without any actions (I know that creating a thread is a sharing
>>>>>> action) on the part of the developer, we have "incorrect" program operation.
>>>>>> Without source code or "javadoc comments" that detail how a method works, a
>>>>>> developer has no idea how to use that software "correctly".  That is the
>>>>>> insidious issue.
>>>>>>
>>>>>> Litterally, all over the planet, there are people working feverishly
>>>>>> to find and remove racy code because they are seeing unexpected and
>>>>>> unpredictable behaviors, which are like "magic", happening in their
>>>>>> applications.
>>>>>>
>>>>>> For me, that is not an advancement in the science of software.  This
>>>>>> kind of "tooling" works against the developer, not for/with them.
>>>>>>
>>>>>> Gregg Wonderly
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>>
>>>>
>>>> --
>>>> Viktor Klang
>>>> Director of Engineering
>>>> Typesafe
>>>>
>>>> Twitter: @viktorklang
>>
>>
>>
>>
>> --
>> Viktor Klang
>> Director of Engineering
>> Typesafe
>>
>> Twitter: @viktorklang
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From logogin at hotbox.ru  Fri Mar 15 11:29:49 2013
From: logogin at hotbox.ru (logogin at hotbox.ru)
Date: Fri, 15 Mar 2013 19:29:49 +0400
Subject: [concurrency-interest]
 =?utf-8?q?=5Bconcurrency-interest=C2=AD=5D?=
 =?utf-8?q?_ExecutorService=2EnewFixe=C2=ADdThreadPool=2C_submit_oper?=
In-Reply-To: <CA+kOe0-TprkB4mwBY8BMtsEwrLwiwCzcpRgA=6rR-6czj5E+vg@mail.gmail.com>
References: <CA+kOe0-TprkB4mwBY8BMtsEwrLwiwCzcpRgA=6rR-6czj5E+vg@mail.gmail.com>
Message-ID: <97c0aea1370a6ce0c9ca7c5a340d71a44c1ee78a@mail.qip.ru>

Thanks for the reply.
I personally unsure which pattern is better dying thread or "immortal" one. But definitely it would be good for developer to expect common pattern for worker threads no matter of way of providing tasks for it.

> The difference is that with submit, the Runnable is wrapped, the exception is caught and stored in the Future and not propagated to the pool thread.  This distinction is not explained adequately in the docs, I think.
> 
> On Thu, Mar 14, 2013 at 8:09 AM,  <logogin at hotbox.ru> wrote:
> Hello,
> I can see in javadoc for java.util.concurrent.Executors.newFixedThreadPool(int):
> .. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. ...
> 
> But what I am experiencing is a different worker thread life-cycle for java.util.concurrent.ExecutorService.submit(Runnable) and java.util.concurrent.Executor.execute(Runnable) in case of fixed thread pool. Seems like for "execute" method it performs as stated in javadoc, but for "submit" - the worker thread is never replaced by new one in case of task failure.
> Here is code snippet to show the behavior:
> 
> This is execute case:
> public void execute_spawn_new() throws Exception {
>         System.out.println("execute");
>         ExecutorService exec = Executors.newFixedThreadPool(1);
>         final CountDownLatch latch = new CountDownLatch(1);
>         exec.execute(new Runnable() {
>             @Override
>             public void run() {
>                 System.out.println(String.format("Thread[%s, XSSCleaned=%d]", Thread.currentThread().getName(), Thread.currentThread().getId()));
>                 latch.countDown();
>             }
>         });
>         latch.await();
> 
>         exec.execute(new Runnable() {
>             @Override
>             public void run() {
>                 System.out.println(String.format("Thread[%s, XSSCleaned=%d]", Thread.currentThread().getName(), Thread.currentThread().getId()));
>                 latch.countDown();
>                 throw new RuntimeException("failed to complete");
>             }
>         });
>         latch.await();
> 
>         exec.execute(new Runnable() {
>             @Override
>             public void run() {
>                 System.out.println(String.format("Thread[%s, XSSCleaned=%d]", Thread.currentThread().getName(), Thread.currentThread().getId()));
>                 latch.countDown();
>             }
>         });
>         latch.await();
> }
> 
> the output is:
> Thread[pool-1-thread-1, XSSCleaned=9]
> Thread[pool-1-thread-1, XSSCleaned=9]
> Exception in thread "pool-1-thread-1" java.lang.RuntimeException:
> failed to complete
> ..stack trace here...
> Thread[pool-1-thread-2, XSSCleaned=10]
> 
> It is clearly visible that Thread XSSCleaned=10 replaced failed one in the pool.
> 
> This is submit case:
> public void submit_spawn_new() throws Exception {
>         System.out.println("submit");
>         ExecutorService exec = Executors.newFixedThreadPool(1);
>         final CountDownLatch latch = new CountDownLatch(1);
>         exec.submit(new Runnable() {
>             @Override
>             public void run() {
>                 System.out.println(String.format("Thread[%s, XSSCleaned=%d]", Thread.currentThread().getName(), Thread.currentThread().getId()));
>                 latch.countDown();
>             }
>         }).get();
>         latch.await();
> 
>         try {
>             exec.submit(new Runnable() {
>                 @Override
>                 public void run() {
>                     System.out.println(String.format("Thread[%s, XSSCleaned=%d]", Thread.currentThread().getName(), Thread.currentThread().getId()));
>                     latch.countDown();
>                     throw new RuntimeException("failed to complete");
>                 }
>             }).get();
>         } catch (Throwable ex) {
>             ex.printStackTrace();
>         }
>         latch.await();
> 
>         exec.submit(new Runnable() {
>             @Override
>             public void run() {
>                 System.out.println(String.format("Thread[%s, XSSCleaned=%d]", Thread.currentThread().getName(), Thread.currentThread().getId()));
>                 latch.countDown();
>             }
>         }).get();
>         latch.await();
> }
> 
> Thread[pool-2-thread-1, XSSCleaned=11]
> Thread[pool-2-thread-1, XSSCleaned=11]
> java.util.concurrent.ExecutionException: java.lang.RuntimeException:
> failed to complete
> ..stack trace here...
> Thread[pool-2-thread-1, XSSCleaned=11]
> 
> Now the Thread XSSCleaned=11 still remains in the pool and capable to take tasks.
> 
> Could someone please clarify above differences.
> Thanks
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From peter.levart at gmail.com  Fri Mar 15 12:20:28 2013
From: peter.levart at gmail.com (Peter Levart)
Date: Fri, 15 Mar 2013 17:20:28 +0100
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqEUAfo2jFugQkvSj_wQbSX4=dnBwaUhXubKr-PTuGQe7A@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<F8DF0611-61DA-4628-9E7C-6067026106D0@oracle.com>
	<CACuKZqEUAfo2jFugQkvSj_wQbSX4=dnBwaUhXubKr-PTuGQe7A@mail.gmail.com>
Message-ID: <51434A4C.4000106@gmail.com>

Would this be a correct work-around without changing VM code and adding 
'volatile' to 'char name[]' field?


public class Thread implements Runnable {

     private char name[];
     private String nameString;

     private void init(ThreadGroup g, Runnable target, String name,
                       long stackSize) {
         ...

         this.name = name.toCharArray();
         this.nameString = name;
         ...

     }

     public final void setName(String name) {
         checkAccess();
         this.name = name.toCharArray();
         this.nameString = name;
         if (threadStatus != 0) {
             setNativeName(name);
         }
     }

     public final String getName() {
         String nameString = this.nameString;
         if (nameString == null) {
             nameString = new String(this.name);
             this.nameString = nameString;
         }
         return nameString;
     }



... assuming that 'nameString' field is only ever possible to be null 
when VM allocates Thread object and only sets the 'char[] name' and that 
this always HB any other thread dereferencing the Thread object...

Regards, Peter

On 03/15/2013 07:53 AM, Zhong Yu wrote:
> Mike, your suggestion does not seem to be able to walk around the problem.
>
> // shared
>      char name[];
>
> Thread 1
>      char[] chars = {'a','b','c'};
>      String string1 = new String(chars);
>      name=string1.value;
>
> Thread 2
>      String string2 = new String(name, true);
>
> The final-ness of String.value does no good here, Thread 1 can still
> inline and reorder, to the effect that the array reference is
> published before the array is filled. Thread 2 can still observe a
> partially filled array. Even better, string2's content can be observed
> to mutate while the array is being filled!
>
> Zhong Yu
>
> On Thu, Mar 14, 2013 at 7:28 PM, Mike Duigou <mike.duigou at oracle.com> wrote:
>> On Mar 14 2013, at 14:21 , Zhong Yu wrote:
>>
>>> java.lang.Thread
>>>
>>>     private char name[];
>>>
>>>     public final void setName(String name) {
>>>         checkAccess();
>>>         this.name = name.toCharArray();
>> The following suggestion is not for the weak of heart:
>>
>> Since String.value is now always the same content as this character array we could simply extract the character array from the String instance. This would also seem to correct the problem because for a String to be visible it's value character array and contents would be visible.
>>
>> Some people would probably consider this suggestion to be morally dubious foolishness. They may be right.
>>
>>>     }
>>>
>>>     public final String getName() {
>>>         return String.valueOf(name);
>> Since we "know" that the character array is not modified after assignment this could be replaced with the String(char[], boolean) constructor. ibid "morally dubious foolishness."
>>
>>>     }
>>>
>>> On the surface, set/getName() are not correctly synchronized,
>>> getName() could observe a partially filled char array. What's the
>>> story here?
>>>
>>> Zhong Yu
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From mike.duigou at oracle.com  Fri Mar 15 12:32:48 2013
From: mike.duigou at oracle.com (Mike Duigou)
Date: Fri, 15 Mar 2013 09:32:48 -0700
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqEUAfo2jFugQkvSj_wQbSX4=dnBwaUhXubKr-PTuGQe7A@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<F8DF0611-61DA-4628-9E7C-6067026106D0@oracle.com>
	<CACuKZqEUAfo2jFugQkvSj_wQbSX4=dnBwaUhXubKr-PTuGQe7A@mail.gmail.com>
Message-ID: <CC745A8D-E3A5-47B0-AF79-BF367FC8B81E@oracle.com>

String.value is final. This is significant for making the contents of the array visible.

per http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html :

> but if the field itself is a reference, then you also want your code to see the up to date values for the object (or array) to which it points. If your field is a final field, this is also guaranteed. So, you can have a final pointer to an array and not have to worry about other threads seeing the correct values for the array reference, but incorrect values for the contents of the array. Again, by "correct" here, we mean "up to date as of the end of the object's constructor", not "the latest value available".

So the contents of the String.value char array are assured to be visible in either the get or set case.

Mike

On Mar 14 2013, at 23:53 , Zhong Yu wrote:

> Mike, your suggestion does not seem to be able to walk around the problem.
> 
> // shared
>    char name[];
> 
> Thread 1
>    char[] chars = {'a','b','c'};
>    String string1 = new String(chars);
>    name=string1.value;
> 
> Thread 2
>    String string2 = new String(name, true);
> 
> The final-ness of String.value does no good here, Thread 1 can still
> inline and reorder, to the effect that the array reference is
> published before the array is filled. Thread 2 can still observe a
> partially filled array. Even better, string2's content can be observed
> to mutate while the array is being filled!
> 
> Zhong Yu
> 
> On Thu, Mar 14, 2013 at 7:28 PM, Mike Duigou <mike.duigou at oracle.com> wrote:
>> 
>> On Mar 14 2013, at 14:21 , Zhong Yu wrote:
>> 
>>> java.lang.Thread
>>> 
>>>   private char name[];
>>> 
>>>   public final void setName(String name) {
>>>       checkAccess();
>>>       this.name = name.toCharArray();
>> 
>> The following suggestion is not for the weak of heart:
>> 
>> Since String.value is now always the same content as this character array we could simply extract the character array from the String instance. This would also seem to correct the problem because for a String to be visible it's value character array and contents would be visible.
>> 
>> Some people would probably consider this suggestion to be morally dubious foolishness. They may be right.
>> 
>>>   }
>>> 
>>>   public final String getName() {
>>>       return String.valueOf(name);
>> 
>> Since we "know" that the character array is not modified after assignment this could be replaced with the String(char[], boolean) constructor. ibid "morally dubious foolishness."
>> 
>>>   }
>>> 
>>> On the surface, set/getName() are not correctly synchronized,
>>> getName() could observe a partially filled char array. What's the
>>> story here?
>>> 
>>> Zhong Yu
>> 



From stanimir at riflexo.com  Fri Mar 15 13:08:09 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Fri, 15 Mar 2013 19:08:09 +0200
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51434A4C.4000106@gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<F8DF0611-61DA-4628-9E7C-6067026106D0@oracle.com>
	<CACuKZqEUAfo2jFugQkvSj_wQbSX4=dnBwaUhXubKr-PTuGQe7A@mail.gmail.com>
	<51434A4C.4000106@gmail.com>
Message-ID: <CAEJX8orMUUnogQmy2n99GX=nXFn1TpypOGqg0m9RdsOzTfsxwQ@mail.gmail.com>

Peter, the code races if there is concurrent invocation of getName() and
setName(), getName can overwrite  nameString w/ an oldValue. With CAS it
won't work and in such case making the char[] name volatile is better.

Stanimir


On Fri, Mar 15, 2013 at 6:20 PM, Peter Levart <peter.levart at gmail.com>wrote:

> Would this be a correct work-around without changing VM code and adding
> 'volatile' to 'char name[]' field?
>
>
> public class Thread implements Runnable {
>
>     private char name[];
>     private String nameString;
>
>     private void init(ThreadGroup g, Runnable target, String name,
>                       long stackSize) {
>         ...
>
>         this.name = name.toCharArray();
>         this.nameString = name;
>         ...
>
>
>     }
>
>     public final void setName(String name) {
>         checkAccess();
>         this.name = name.toCharArray();
>         this.nameString = name;
>         if (threadStatus != 0) {
>             setNativeName(name);
>         }
>     }
>
>     public final String getName() {
>         String nameString = this.nameString;
>         if (nameString == null) {
>             nameString = new String(this.name);
>             this.nameString = nameString;
>         }
>         return nameString;
>     }
>
>
>
> ... assuming that 'nameString' field is only ever possible to be null when
> VM allocates Thread object and only sets the 'char[] name' and that this
> always HB any other thread dereferencing the Thread object...
>
> Regards, Peter
>
>
> On 03/15/2013 07:53 AM, Zhong Yu wrote:
>
>> Mike, your suggestion does not seem to be able to walk around the problem.
>>
>> // shared
>>      char name[];
>>
>> Thread 1
>>      char[] chars = {'a','b','c'};
>>      String string1 = new String(chars);
>>      name=string1.value;
>>
>> Thread 2
>>      String string2 = new String(name, true);
>>
>> The final-ness of String.value does no good here, Thread 1 can still
>> inline and reorder, to the effect that the array reference is
>> published before the array is filled. Thread 2 can still observe a
>> partially filled array. Even better, string2's content can be observed
>> to mutate while the array is being filled!
>>
>> Zhong Yu
>>
>> On Thu, Mar 14, 2013 at 7:28 PM, Mike Duigou <mike.duigou at oracle.com>
>> wrote:
>>
>>> On Mar 14 2013, at 14:21 , Zhong Yu wrote:
>>>
>>>  java.lang.Thread
>>>>
>>>>     private char name[];
>>>>
>>>>     public final void setName(String name) {
>>>>         checkAccess();
>>>>         this.name = name.toCharArray();
>>>>
>>> The following suggestion is not for the weak of heart:
>>>
>>> Since String.value is now always the same content as this character
>>> array we could simply extract the character array from the String instance.
>>> This would also seem to correct the problem because for a String to be
>>> visible it's value character array and contents would be visible.
>>>
>>> Some people would probably consider this suggestion to be morally
>>> dubious foolishness. They may be right.
>>>
>>>      }
>>>>
>>>>     public final String getName() {
>>>>         return String.valueOf(name);
>>>>
>>> Since we "know" that the character array is not modified after
>>> assignment this could be replaced with the String(char[], boolean)
>>> constructor. ibid "morally dubious foolishness."
>>>
>>>      }
>>>>
>>>> On the surface, set/getName() are not correctly synchronized,
>>>> getName() could observe a partially filled char array. What's the
>>>> story here?
>>>>
>>>> Zhong Yu
>>>>
>>> ______________________________**_________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/f94896bc/attachment.html>

From gregg at cytetech.com  Fri Mar 15 16:22:24 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Fri, 15 Mar 2013 15:22:24 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
Message-ID: <51438300.1080204@cytetech.com>

Nathan's example below is my issue...

On 3/15/2013 12:29 AM, David Holmes wrote:
> Gregg,
>
> Gregg Wonderly writes:
>>
>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>> I've inlined the name.toCharArray() and rearranged a few
>> operations that JIT
>>> could do.  If another thread reads this.name between its
>> creation and the end of
>>> arraycopy() then the thread will see a partially filled char[].
>>>
>>>       public final void setName(String name) {
>>>           this.name = new char[name.length()];
>>>           System.arraycopy(..., 0, result, 0, name.length());

If two different threads call setName concurrently, then if the code was 
transformed as shown above, then it is possible to see

T1:           this.name = new char["some longer string".length()];
T2:           this.name = new char["a short string".length()];
T1:           System.arraycopy( "some longer string", 0,
			this.name, 0, "some longer string".length());

Which will result in an exception at best and memory corruption at worse 
depending on how this.name is referenced.

Gregg Wonderly

From zhong.j.yu at gmail.com  Fri Mar 15 16:34:46 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Fri, 15 Mar 2013 15:34:46 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CC745A8D-E3A5-47B0-AF79-BF367FC8B81E@oracle.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<F8DF0611-61DA-4628-9E7C-6067026106D0@oracle.com>
	<CACuKZqEUAfo2jFugQkvSj_wQbSX4=dnBwaUhXubKr-PTuGQe7A@mail.gmail.com>
	<CC745A8D-E3A5-47B0-AF79-BF367FC8B81E@oracle.com>
Message-ID: <CACuKZqHLFJks=jcKZcDBzNfDiTMch6K_4XPvzrrBTsJvNhXF3g@mail.gmail.com>

It looks to me that according to the jsr133 cookbook, reordering can
occur such that str2 is instantiated while the char array is still
being filled.

On Fri, Mar 15, 2013 at 11:32 AM, Mike Duigou <mike.duigou at oracle.com> wrote:
> String.value is final. This is significant for making the contents of the array visible.
>
> per http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html :
>
>> but if the field itself is a reference, then you also want your code to see the up to date values for the object (or array) to which it points. If your field is a final field, this is also guaranteed. So, you can have a final pointer to an array and not have to worry about other threads seeing the correct values for the array reference, but incorrect values for the contents of the array. Again, by "correct" here, we mean "up to date as of the end of the object's constructor", not "the latest value available".
>
> So the contents of the String.value char array are assured to be visible in either the get or set case.
>
> Mike
>
> On Mar 14 2013, at 23:53 , Zhong Yu wrote:
>
>> Mike, your suggestion does not seem to be able to walk around the problem.
>>
>> // shared
>>    char name[];
>>
>> Thread 1
>>    char[] chars = {'a','b','c'};
>>    String string1 = new String(chars);
>>    name=string1.value;
>>
>> Thread 2
>>    String string2 = new String(name, true);
>>
>> The final-ness of String.value does no good here, Thread 1 can still
>> inline and reorder, to the effect that the array reference is
>> published before the array is filled. Thread 2 can still observe a
>> partially filled array. Even better, string2's content can be observed
>> to mutate while the array is being filled!
>>
>> Zhong Yu
>>
>> On Thu, Mar 14, 2013 at 7:28 PM, Mike Duigou <mike.duigou at oracle.com> wrote:
>>>
>>> On Mar 14 2013, at 14:21 , Zhong Yu wrote:
>>>
>>>> java.lang.Thread
>>>>
>>>>   private char name[];
>>>>
>>>>   public final void setName(String name) {
>>>>       checkAccess();
>>>>       this.name = name.toCharArray();
>>>
>>> The following suggestion is not for the weak of heart:
>>>
>>> Since String.value is now always the same content as this character array we could simply extract the character array from the String instance. This would also seem to correct the problem because for a String to be visible it's value character array and contents would be visible.
>>>
>>> Some people would probably consider this suggestion to be morally dubious foolishness. They may be right.
>>>
>>>>   }
>>>>
>>>>   public final String getName() {
>>>>       return String.valueOf(name);
>>>
>>> Since we "know" that the character array is not modified after assignment this could be replaced with the String(char[], boolean) constructor. ibid "morally dubious foolishness."
>>>
>>>>   }
>>>>
>>>> On the surface, set/getName() are not correctly synchronized,
>>>> getName() could observe a partially filled char array. What's the
>>>> story here?
>>>>
>>>> Zhong Yu
>>>
>


From zhong.j.yu at gmail.com  Fri Mar 15 16:44:38 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Fri, 15 Mar 2013 15:44:38 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51438300.1080204@cytetech.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
Message-ID: <CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>

On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
> Nathan's example below is my issue...
>
>
> On 3/15/2013 12:29 AM, David Holmes wrote:
>>
>> Gregg,
>>
>> Gregg Wonderly writes:
>>>
>>>
>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>
>>>> I've inlined the name.toCharArray() and rearranged a few
>>>
>>> operations that JIT
>>>>
>>>> could do.  If another thread reads this.name between its
>>>
>>> creation and the end of
>>>>
>>>> arraycopy() then the thread will see a partially filled char[].
>>>>
>>>>       public final void setName(String name) {
>>>>           this.name = new char[name.length()];
>>>>           System.arraycopy(..., 0, result, 0, name.length());
>
>
> If two different threads call setName concurrently, then if the code was
> transformed as shown above, then it is possible to see
>
> T1:           this.name = new char["some longer string".length()];
> T2:           this.name = new char["a short string".length()];
> T1:           System.arraycopy( "some longer string", 0,
>                         this.name, 0, "some longer string".length());
>
> Which will result in an exception at best and memory corruption at worse
> depending on how this.name is referenced.

I think you are right, the compiler must not issue a load that did not
exist in the source code (the compiler *is* aware that some other
thread may be changing the variable).

The following transformation should be legal

       public final void setName(String name) {
            char[]  tmp = new char[name.length()]
            this.name = tmp;
            System.arraycopy(name.value, 0, tmp, 0, name.length());

Zhong Yu

> Gregg Wonderly
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From nathan.reynolds at oracle.com  Fri Mar 15 17:40:02 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Fri, 15 Mar 2013 14:40:02 -0700
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
Message-ID: <51439532.8060105@oracle.com>

System.arraycopy has its own internal checks to make sure the copy 
doesn't go beyond the ends of the array.  I highly doubt JIT will be 
able to move instructions around in such a way as to cause 
System.arraycopy instructions to reload the "this.name" reference after 
checking the array bounds.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 3/15/2013 1:44 PM, Zhong Yu wrote:
> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
>> Nathan's example below is my issue...
>>
>>
>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>> Gregg,
>>>
>>> Gregg Wonderly writes:
>>>>
>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>> operations that JIT
>>>>> could do.  If another thread reads this.name between its
>>>> creation and the end of
>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>
>>>>>        public final void setName(String name) {
>>>>>            this.name = new char[name.length()];
>>>>>            System.arraycopy(..., 0, result, 0, name.length());
>>
>> If two different threads call setName concurrently, then if the code was
>> transformed as shown above, then it is possible to see
>>
>> T1:           this.name = new char["some longer string".length()];
>> T2:           this.name = new char["a short string".length()];
>> T1:           System.arraycopy( "some longer string", 0,
>>                          this.name, 0, "some longer string".length());
>>
>> Which will result in an exception at best and memory corruption at worse
>> depending on how this.name is referenced.
> I think you are right, the compiler must not issue a load that did not
> exist in the source code (the compiler *is* aware that some other
> thread may be changing the variable).
>
> The following transformation should be legal
>
>         public final void setName(String name) {
>              char[]  tmp = new char[name.length()]
>              this.name = tmp;
>              System.arraycopy(name.value, 0, tmp, 0, name.length());
>
> Zhong Yu
>
>> Gregg Wonderly
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/ebef2c15/attachment.html>

From gergg at cox.net  Fri Mar 15 17:46:10 2013
From: gergg at cox.net (Gregg Wonderly)
Date: Fri, 15 Mar 2013 16:46:10 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
Message-ID: <FD424034-EF10-455E-8939-18D856236D45@cox.net>

Yes, that transformation is legal, but it is also broken in the current design of that class.  Because Thread.setName() is callable, and because there is no other visible happensBefore with Thread.getName, the compiler can make the decision to designate these methods as intra-thread use only.

That is the problem.  Even if I subsequently introduce a "happens before" by synchronizing or locking or something else, I have to know what the implementation is, know how it is broken and only then can I actually expect to achieve safe use of the provided API.

I assert that this is completely and totally non-productive for software developers.  The JDK and many other large Java applications/libraries are broken in subtle ways, such as the missing "volatile" here.   The compilers rewrite of such code into non-thread safe segments when the developer(s) might look at their code and say "that's racy, but safe, because I'll just use "synchronized" around my calls, is changing the outcome that breaks SC.  Yes SC is not supposed to be guaranteed in this case, but do JVM and hotspot developers really feel like they are doing great and wonderful things, when this kind of stuff is haunting everybody everywhere, because even the JDK has not been "fixed"?

Gregg Wonderly

On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
>> Nathan's example below is my issue...
>> 
>> 
>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>> 
>>> Gregg,
>>> 
>>> Gregg Wonderly writes:
>>>> 
>>>> 
>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>> 
>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>> 
>>>> operations that JIT
>>>>> 
>>>>> could do.  If another thread reads this.name between its
>>>> 
>>>> creation and the end of
>>>>> 
>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>> 
>>>>>      public final void setName(String name) {
>>>>>          this.name = new char[name.length()];
>>>>>          System.arraycopy(..., 0, result, 0, name.length());
>> 
>> 
>> If two different threads call setName concurrently, then if the code was
>> transformed as shown above, then it is possible to see
>> 
>> T1:           this.name = new char["some longer string".length()];
>> T2:           this.name = new char["a short string".length()];
>> T1:           System.arraycopy( "some longer string", 0,
>>                        this.name, 0, "some longer string".length());
>> 
>> Which will result in an exception at best and memory corruption at worse
>> depending on how this.name is referenced.
> 
> I think you are right, the compiler must not issue a load that did not
> exist in the source code (the compiler *is* aware that some other
> thread may be changing the variable).
> 
> The following transformation should be legal
> 
>       public final void setName(String name) {
>            char[]  tmp = new char[name.length()]
>            this.name = tmp;
>            System.arraycopy(name.value, 0, tmp, 0, name.length());
> 
> Zhong Yu
> 
>> Gregg Wonderly
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From gergg at cox.net  Fri Mar 15 17:53:27 2013
From: gergg at cox.net (Gregg Wonderly)
Date: Fri, 15 Mar 2013 16:53:27 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51439532.8060105@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<51439532.8060105@oracle.com>
Message-ID: <E5DFC89E-D5E7-44C1-BFB7-9441AF434F39@cox.net>


On Mar 15, 2013, at 4:40 PM, Nathan Reynolds <nathan.reynolds at oracle.com> wrote:

> System.arraycopy has its own internal checks to make sure the copy doesn't go beyond the ends of the array.  I highly doubt JIT will be able to move instructions around in such a way as to cause System.arraycopy instructions to reload the "this.name" reference after checking the array bounds.

Okay, but is there actually any guarantee?  Since that still leaves the "ArrayIndexOutOfBoundsException" as a possibility, I'd suggest that there needs to be something done to "fix" this API.  It still seems like we need an annotation that actually turns on "intra-thread" optimizations.  In the end, inter-thread optimizations should be all that is done by default, because we do not have any "guarantees" in the language constructs or the compilers operation, that would allow it to guarantee that a method is not used inter-thread.

@MultiThreaded or some kind of annotation needs to come into play at some point.  I just can't imagine that we will be able to continue to "guess" about this and "hope" and "laugh when it fails" or "fix it later" for too much longer.  The hardware is in our faces now, and the tools and Java in particular just doesn't provide a developer with any indication that there code is not thread-safe.  I think it would be much, much more productive to let developers make that designation, literally, so that Javadoc and introspection and all kinds of "real" observations regarding safe concurrency can actually happen.

Gregg

> 
> Nathan Reynolds | Architect | 602.333.9091
> Oracle PSR Engineering | Server Technology
> On 3/15/2013 1:44 PM, Zhong Yu wrote:
>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
>>> Nathan's example below is my issue...
>>> 
>>> 
>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>> Gregg,
>>>> 
>>>> Gregg Wonderly writes:
>>>>> 
>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>> operations that JIT
>>>>>> could do.  If another thread reads this.name between its
>>>>> creation and the end of
>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>> 
>>>>>>       public final void setName(String name) {
>>>>>>           this.name = new char[name.length()];
>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>> 
>>> If two different threads call setName concurrently, then if the code was
>>> transformed as shown above, then it is possible to see
>>> 
>>> T1:           this.name = new char["some longer string".length()];
>>> T2:           this.name = new char["a short string".length()];
>>> T1:           System.arraycopy( "some longer string", 0,
>>>                         this.name, 0, "some longer string".length());
>>> 
>>> Which will result in an exception at best and memory corruption at worse
>>> depending on how this.name is referenced.
>> I think you are right, the compiler must not issue a load that did not
>> exist in the source code (the compiler *is* aware that some other
>> thread may be changing the variable).
>> 
>> The following transformation should be legal
>> 
>>        public final void setName(String name) {
>>             char[]  tmp = new char[name.length()]
>>             this.name = tmp;
>>             System.arraycopy(name.value, 0, tmp, 0, name.length());
>> 
>> Zhong Yu
>> 
>>> Gregg Wonderly
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/d3b2f6d1/attachment-0001.html>

From davidcholmes at aapt.net.au  Fri Mar 15 19:12:33 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 16 Mar 2013 09:12:33 +1000
Subject: [concurrency-interest] [concurrency-interest-]
	ExecutorService.newFixe-dThreadPool, submit oper
In-Reply-To: <97c0aea1370a6ce0c9ca7c5a340d71a44c1ee78a@mail.qip.ru>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEDJJLAA.davidcholmes@aapt.net.au>

logogin at hotbox.ru writes:
>
> Thanks for the reply.
> I personally unsure which pattern is better dying thread or
> "immortal" one. But definitely it would be good for developer to
> expect common pattern for worker threads no matter of way of
> providing tasks for it.

I think you are missing the point. This has nothing to do with how worker
threads handle uncaught exceptions. This is about whether a task allows
uncaught exceptions. If there is no such thing as an uncaught exception - as
there isn't when Future is involved - then the worker thread never sees it.

submit returns a Future, and Future's trap all exceptions throw during
processing.

The docs can certainly make this clearer though.

Cheers,
David
-----


> > The difference is that with submit, the Runnable is wrapped,
> the exception is caught and stored in the Future and not
> propagated to the pool thread.  This distinction is not explained
> adequately in the docs, I think.
> >
> > On Thu, Mar 14, 2013 at 8:09 AM,  <logogin at hotbox.ru> wrote:
> > Hello,
> > I can see in javadoc for
> java.util.concurrent.Executors.newFixedThreadPool(int):
> > .. If any thread terminates due to a failure during execution
> prior to shutdown, a new one will take its place if needed to
> execute subsequent tasks. ...
> >
> > But what I am experiencing is a different worker thread
> life-cycle for
> java.util.concurrent.ExecutorService.submit(Runnable) and
> java.util.concurrent.Executor.execute(Runnable) in case of fixed
> thread pool. Seems like for "execute" method it performs as
> stated in javadoc, but for "submit" - the worker thread is never
> replaced by new one in case of task failure.
> > Here is code snippet to show the behavior:
> >
> > This is execute case:
> > public void execute_spawn_new() throws Exception {
> >         System.out.println("execute");
> >         ExecutorService exec = Executors.newFixedThreadPool(1);
> >         final CountDownLatch latch = new CountDownLatch(1);
> >         exec.execute(new Runnable() {
> >             @Override
> >             public void run() {
> >                 System.out.println(String.format("Thread[%s,
> XSSCleaned=%d]", Thread.currentThread().getName(),
> Thread.currentThread().getId()));
> >                 latch.countDown();
> >             }
> >         });
> >         latch.await();
> >
> >         exec.execute(new Runnable() {
> >             @Override
> >             public void run() {
> >                 System.out.println(String.format("Thread[%s,
> XSSCleaned=%d]", Thread.currentThread().getName(),
> Thread.currentThread().getId()));
> >                 latch.countDown();
> >                 throw new RuntimeException("failed to complete");
> >             }
> >         });
> >         latch.await();
> >
> >         exec.execute(new Runnable() {
> >             @Override
> >             public void run() {
> >                 System.out.println(String.format("Thread[%s,
> XSSCleaned=%d]", Thread.currentThread().getName(),
> Thread.currentThread().getId()));
> >                 latch.countDown();
> >             }
> >         });
> >         latch.await();
> > }
> >
> > the output is:
> > Thread[pool-1-thread-1, XSSCleaned=9]
> > Thread[pool-1-thread-1, XSSCleaned=9]
> > Exception in thread "pool-1-thread-1" java.lang.RuntimeException:
> > failed to complete
> > ..stack trace here...
> > Thread[pool-1-thread-2, XSSCleaned=10]
> >
> > It is clearly visible that Thread XSSCleaned=10 replaced failed
> one in the pool.
> >
> > This is submit case:
> > public void submit_spawn_new() throws Exception {
> >         System.out.println("submit");
> >         ExecutorService exec = Executors.newFixedThreadPool(1);
> >         final CountDownLatch latch = new CountDownLatch(1);
> >         exec.submit(new Runnable() {
> >             @Override
> >             public void run() {
> >                 System.out.println(String.format("Thread[%s,
> XSSCleaned=%d]", Thread.currentThread().getName(),
> Thread.currentThread().getId()));
> >                 latch.countDown();
> >             }
> >         }).get();
> >         latch.await();
> >
> >         try {
> >             exec.submit(new Runnable() {
> >                 @Override
> >                 public void run() {
> >
> System.out.println(String.format("Thread[%s, XSSCleaned=%d]",
> Thread.currentThread().getName(), Thread.currentThread().getId()));
> >                     latch.countDown();
> >                     throw new RuntimeException("failed to complete");
> >                 }
> >             }).get();
> >         } catch (Throwable ex) {
> >             ex.printStackTrace();
> >         }
> >         latch.await();
> >
> >         exec.submit(new Runnable() {
> >             @Override
> >             public void run() {
> >                 System.out.println(String.format("Thread[%s,
> XSSCleaned=%d]", Thread.currentThread().getName(),
> Thread.currentThread().getId()));
> >                 latch.countDown();
> >             }
> >         }).get();
> >         latch.await();
> > }
> >
> > Thread[pool-2-thread-1, XSSCleaned=11]
> > Thread[pool-2-thread-1, XSSCleaned=11]
> > java.util.concurrent.ExecutionException: java.lang.RuntimeException:
> > failed to complete
> > ..stack trace here...
> > Thread[pool-2-thread-1, XSSCleaned=11]
> >
> > Now the Thread XSSCleaned=11 still remains in the pool and
> capable to take tasks.
> >
> > Could someone please clarify above differences.
> > Thanks
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> -----
> No virus found in this message.
> Checked by AVG - www.avg.com
> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
> Internal Virus Database is out of date.
>


From davidcholmes at aapt.net.au  Fri Mar 15 19:27:14 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 16 Mar 2013 09:27:14 +1000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <FD424034-EF10-455E-8939-18D856236D45@cox.net>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEDKJLAA.davidcholmes@aapt.net.au>

Gregg,

The sky is not falling, the end of the world is not nigh. There are
thousands of non-thread-safe methods in the JDK libraries, this is just an
example. This might be a surprising example, but I expect there was little
consideration given to dynamic thread re-naming. You may ineed get an
exception because of the possible races - so be it.

We can file a bug and make them synchronized or whaetver.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Gregg
> Wonderly
> Sent: Saturday, 16 March 2013 7:46 AM
> To: Zhong Yu
> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org;
> gregg.wonderly at pobox.com
> Subject: Re: [concurrency-interest] Thread safety of Thread.getName()
>
>
> Yes, that transformation is legal, but it is also broken in the
> current design of that class.  Because Thread.setName() is
> callable, and because there is no other visible happensBefore
> with Thread.getName, the compiler can make the decision to
> designate these methods as intra-thread use only.
>
> That is the problem.  Even if I subsequently introduce a "happens
> before" by synchronizing or locking or something else, I have to
> know what the implementation is, know how it is broken and only
> then can I actually expect to achieve safe use of the provided API.
>
> I assert that this is completely and totally non-productive for
> software developers.  The JDK and many other large Java
> applications/libraries are broken in subtle ways, such as the
> missing "volatile" here.   The compilers rewrite of such code
> into non-thread safe segments when the developer(s) might look at
> their code and say "that's racy, but safe, because I'll just use
> "synchronized" around my calls, is changing the outcome that
> breaks SC.  Yes SC is not supposed to be guaranteed in this case,
> but do JVM and hotspot developers really feel like they are doing
> great and wonderful things, when this kind of stuff is haunting
> everybody everywhere, because even the JDK has not been "fixed"?
>
> Gregg Wonderly
>
> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>
> > On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly
> <gregg at cytetech.com> wrote:
> >> Nathan's example below is my issue...
> >>
> >>
> >> On 3/15/2013 12:29 AM, David Holmes wrote:
> >>>
> >>> Gregg,
> >>>
> >>> Gregg Wonderly writes:
> >>>>
> >>>>
> >>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
> >>>>>
> >>>>> I've inlined the name.toCharArray() and rearranged a few
> >>>>
> >>>> operations that JIT
> >>>>>
> >>>>> could do.  If another thread reads this.name between its
> >>>>
> >>>> creation and the end of
> >>>>>
> >>>>> arraycopy() then the thread will see a partially filled char[].
> >>>>>
> >>>>>      public final void setName(String name) {
> >>>>>          this.name = new char[name.length()];
> >>>>>          System.arraycopy(..., 0, result, 0, name.length());
> >>
> >>
> >> If two different threads call setName concurrently, then if
> the code was
> >> transformed as shown above, then it is possible to see
> >>
> >> T1:           this.name = new char["some longer string".length()];
> >> T2:           this.name = new char["a short string".length()];
> >> T1:           System.arraycopy( "some longer string", 0,
> >>                        this.name, 0, "some longer string".length());
> >>
> >> Which will result in an exception at best and memory
> corruption at worse
> >> depending on how this.name is referenced.
> >
> > I think you are right, the compiler must not issue a load that did not
> > exist in the source code (the compiler *is* aware that some other
> > thread may be changing the variable).
> >
> > The following transformation should be legal
> >
> >       public final void setName(String name) {
> >            char[]  tmp = new char[name.length()]
> >            this.name = tmp;
> >            System.arraycopy(name.value, 0, tmp, 0, name.length());
> >
> > Zhong Yu
> >
> >> Gregg Wonderly
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> -----
> No virus found in this message.
> Checked by AVG - www.avg.com
> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
> Internal Virus Database is out of date.
>


From hans.boehm at hp.com  Fri Mar 15 19:49:20 2013
From: hans.boehm at hp.com (Boehm, Hans)
Date: Fri, 15 Mar 2013 23:49:20 +0000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <E5DFC89E-D5E7-44C1-BFB7-9441AF434F39@cox.net>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<51439532.8060105@oracle.com>
	<E5DFC89E-D5E7-44C1-BFB7-9441AF434F39@cox.net>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD2369B2C94@G9W0725.americas.hpqcorp.net>

It seems to me that the right general solution consists of:


-          Annotations for intentional, and extremely carefully considered, data races.

-          A data race detector that can be used on a regular basis, and ignores the above data races.

-          A general understanding that unannotated data races are bugs.

AFAIK, all of this is fundamentally possible.

Hans

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Gregg Wonderly
Sent: Friday, March 15, 2013 2:53 PM
To: Nathan Reynolds
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Thread safety of Thread.getName()


On Mar 15, 2013, at 4:40 PM, Nathan Reynolds <nathan.reynolds at oracle.com<mailto:nathan.reynolds at oracle.com>> wrote:


System.arraycopy has its own internal checks to make sure the copy doesn't go beyond the ends of the array.  I highly doubt JIT will be able to move instructions around in such a way as to cause System.arraycopy instructions to reload the "this.name" reference after checking the array bounds.

Okay, but is there actually any guarantee?  Since that still leaves the "ArrayIndexOutOfBoundsException" as a possibility, I'd suggest that there needs to be something done to "fix" this API.  It still seems like we need an annotation that actually turns on "intra-thread" optimizations.  In the end, inter-thread optimizations should be all that is done by default, because we do not have any "guarantees" in the language constructs or the compilers operation, that would allow it to guarantee that a method is not used inter-thread.

@MultiThreaded or some kind of annotation needs to come into play at some point.  I just can't imagine that we will be able to continue to "guess" about this and "hope" and "laugh when it fails" or "fix it later" for too much longer.  The hardware is in our faces now, and the tools and Java in particular just doesn't provide a developer with any indication that there code is not thread-safe.  I think it would be much, much more productive to let developers make that designation, literally, so that Javadoc and introspection and all kinds of "real" observations regarding safe concurrency can actually happen.

Gregg



Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | Architect | 602.333.9091
Oracle PSR Engineering<http://psr.us.oracle.com/> | Server Technology
On 3/15/2013 1:44 PM, Zhong Yu wrote:

On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly <gregg at cytetech.com><mailto:gregg at cytetech.com> wrote:

Nathan's example below is my issue...





On 3/15/2013 12:29 AM, David Holmes wrote:

Gregg,



Gregg Wonderly writes:



On 3/14/2013 6:14 PM, Nathan Reynolds wrote:

I've inlined the name.toCharArray() and rearranged a few

operations that JIT

could do.  If another thread reads this.name between its

creation and the end of

arraycopy() then the thread will see a partially filled char[].



      public final void setName(String name) {

          this.name = new char[name.length()];

          System.arraycopy(..., 0, result, 0, name.length());



If two different threads call setName concurrently, then if the code was

transformed as shown above, then it is possible to see



T1:           this.name = new char["some longer string".length()];

T2:           this.name = new char["a short string".length()];

T1:           System.arraycopy( "some longer string", 0,

                        this.name, 0, "some longer string".length());



Which will result in an exception at best and memory corruption at worse

depending on how this.name is referenced.

I think you are right, the compiler must not issue a load that did not

exist in the source code (the compiler *is* aware that some other

thread may be changing the variable).



The following transformation should be legal



       public final void setName(String name) {

            char[]  tmp = new char[name.length()]

            this.name = tmp;

            System.arraycopy(name.value, 0, tmp, 0, name.length());



Zhong Yu



Gregg Wonderly



_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest





_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/305cdc6f/attachment-0001.html>

From nathan.reynolds at oracle.com  Fri Mar 15 22:22:11 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Fri, 15 Mar 2013 19:22:11 -0700
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD2369B2C94@G9W0725.americas.hpqcorp.net>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<51439532.8060105@oracle.com>
	<E5DFC89E-D5E7-44C1-BFB7-9441AF434F39@cox.net>
	<A3E67C2071F49C4CBC4F17E6D77CDDD2369B2C94@G9W0725.americas.hpqcorp.net>
Message-ID: <5143D753.9080509@oracle.com>

Its called Java Path Finder. http://babelfish.arc.nasa.gov/trac/jpf/

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 3/15/2013 4:49 PM, Boehm, Hans wrote:
>
> It seems to me that the right general solution consists of:
>
> -Annotations for intentional, and extremely carefully considered, data 
> races.
>
> -A data race detector that can be used on a regular basis, and ignores 
> the above data races.
>
> -A general understanding that unannotated data races are bugs.
>
> AFAIK, all of this is fundamentally possible.
>
> Hans
>
> *From:*concurrency-interest-bounces at cs.oswego.edu 
> [mailto:concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of 
> *Gregg Wonderly
> *Sent:* Friday, March 15, 2013 2:53 PM
> *To:* Nathan Reynolds
> *Cc:* concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Thread safety of Thread.getName()
>
> On Mar 15, 2013, at 4:40 PM, Nathan Reynolds 
> <nathan.reynolds at oracle.com <mailto:nathan.reynolds at oracle.com>> wrote:
>
>
>
> System.arraycopy has its own internal checks to make sure the copy 
> doesn't go beyond the ends of the array.  I highly doubt JIT will be 
> able to move instructions around in such a way as to cause 
> System.arraycopy instructions to reload the "this.name" reference 
> after checking the array bounds.
>
> Okay, but is there actually any guarantee?  Since that still leaves 
> the "ArrayIndexOutOfBoundsException" as a possibility, I'd suggest 
> that there needs to be something done to "fix" this API.  It still 
> seems like we need an annotation that actually turns on "intra-thread" 
> optimizations.  In the end, inter-thread optimizations should be all 
> that is done by default, because we do not have any "guarantees" in 
> the language constructs or the compilers operation, that would allow 
> it to guarantee that a method is not used inter-thread.
>
> @MultiThreaded or some kind of annotation needs to come into play at 
> some point.  I just can't imagine that we will be able to continue to 
> "guess" about this and "hope" and "laugh when it fails" or "fix it 
> later" for too much longer.  The hardware is in our faces now, and the 
> tools and Java in particular just doesn't provide a developer with any 
> indication that there code is not thread-safe.  I think it would be 
> much, much more productive to let developers make that designation, 
> literally, so that Javadoc and introspection and all kinds of "real" 
> observations regarding safe concurrency can actually happen.
>
> Gregg
>
>
>
> Nathan Reynolds 
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
> Architect | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>
> On 3/15/2013 1:44 PM, Zhong Yu wrote:
>
>     On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly<gregg at cytetech.com>  <mailto:gregg at cytetech.com>  wrote:
>
>         Nathan's example below is my issue...
>
>           
>
>           
>
>         On 3/15/2013 12:29 AM, David Holmes wrote:
>
>             Gregg,
>
>               
>
>             Gregg Wonderly writes:
>
>                   
>
>                 On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>
>                     I've inlined the name.toCharArray() and rearranged a few
>
>                 operations that JIT
>
>                     could do.  If another thread reads this.name between its
>
>                 creation and the end of
>
>                     arraycopy() then the thread will see a partially filled char[].
>
>                       
>
>                            public final void setName(String name) {
>
>                                this.name = new char[name.length()];
>
>                                System.arraycopy(..., 0, result, 0, name.length());
>
>           
>
>         If two different threads call setName concurrently, then if the code was
>
>         transformed as shown above, then it is possible to see
>
>           
>
>         T1:           this.name = new char["some longer string".length()];
>
>         T2:           this.name = new char["a short string".length()];
>
>         T1:           System.arraycopy( "some longer string", 0,
>
>                                  this.name, 0, "some longer string".length());
>
>           
>
>         Which will result in an exception at best and memory corruption at worse
>
>         depending on how this.name is referenced.
>
>     I think you are right, the compiler must not issue a load that did not
>
>     exist in the source code (the compiler *is* aware that some other
>
>     thread may be changing the variable).
>
>       
>
>     The following transformation should be legal
>
>       
>
>             public final void setName(String name) {
>
>                  char[]  tmp = new char[name.length()]
>
>                  this.name = tmp;
>
>                  System.arraycopy(name.value, 0, tmp, 0, name.length());
>
>       
>
>     Zhong Yu
>
>       
>
>         Gregg Wonderly
>
>           
>
>         _______________________________________________
>
>         Concurrency-interest mailing list
>
>         Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>     _______________________________________________
>
>     Concurrency-interest mailing list
>
>     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>       
>
>       
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu 
> <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130315/4b795c5c/attachment.html>

From gregg at cytetech.com  Fri Mar 15 22:39:07 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Fri, 15 Mar 2013 21:39:07 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEDKJLAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCGEDKJLAA.davidcholmes@aapt.net.au>
Message-ID: <5143DB4B.5070505@cytetech.com>

On 3/15/2013 6:27 PM, David Holmes wrote:
> Gregg,
>
> The sky is not falling, the end of the world is not nigh. There are
> thousands of non-thread-safe methods in the JDK libraries, this is just an
> example. This might be a surprising example, but I expect there was little
> consideration given to dynamic thread re-naming. You may ineed get an
> exception because of the possible races - so be it.

I am not sure of how many lines of code you have written in applications running 
in the wild David, and I don't want to diminish anything about what you know 
and/or have experienced.  I can tell you for sure, that I am constantly 
frustrated by these kinds of APIs with neither specified nor correct (in some 
potential cases) concurrency and having people involved in the development of 
Java tell me, the user and customer, that everything is just fine.

I really want my software to function correctly and run unfettered, forever, 
without any "odd" behavior.  My software is involved in applications which need 
correct results each and every time.  I can not live with any chance that 
something will sometimes be wrong or may not complete for unexplainable or 
correctable reasons.

I just can not understand how the possibility of "wrong", or "incomplete" or 
"unpredictable" results can feel acceptable.

To mediate this issue in my software, for some time now, I've lived by the rule, 
all variables must be declared either volatile or final.  I've mentioned that 
here before, and I recall that I was sort of pushed back on, saying that was not 
really necessary.  It's cases like this where an API permits something to happen 
that is incorrect for its implementation of concurrent access that really 
highlight the reasons for me.

Yes, volatile doesn't result in 'non-race' execution.  But, it does keep the 
compiler for doing things that this reordering might do which would cause 
software to produce unexpected results in the form of a RuntimeException.  I'm 
not up for surrounding every statement with a try{}catch.

Only when performance becomes a consideration, do I start to revisit the 
volatile declarations.  I've not really had to do very much removing of 
volatile.  For simple values, I'd either have synchronized setter/getter or 
volatile already anyway.

> We can file a bug and make them synchronized or whaetver.

I know this seems like an over-the-top reaction, but it's just so frustrating to 
keep having to deal with things like this in my software, and everytime I turn 
around, there's another something like this that highlights something that I've 
overlooked or had not expected to possibly be an issue.  My trust in the JDK 
libraries (except for java.util.concurrent, which Doug has been flawlessly open 
and considerate of developers needs in my opinion) is waning...

Maybe it's time to open src.zip and start writing bug reports.  I just really 
don't think I'll enjoy doing that, but I suppose no one would...

Gregg Wonderly

> David
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Gregg
>> Wonderly
>> Sent: Saturday, 16 March 2013 7:46 AM
>> To: Zhong Yu
>> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org;
>> gregg.wonderly at pobox.com
>> Subject: Re: [concurrency-interest] Thread safety of Thread.getName()
>>
>>
>> Yes, that transformation is legal, but it is also broken in the
>> current design of that class.  Because Thread.setName() is
>> callable, and because there is no other visible happensBefore
>> with Thread.getName, the compiler can make the decision to
>> designate these methods as intra-thread use only.
>>
>> That is the problem.  Even if I subsequently introduce a "happens
>> before" by synchronizing or locking or something else, I have to
>> know what the implementation is, know how it is broken and only
>> then can I actually expect to achieve safe use of the provided API.
>>
>> I assert that this is completely and totally non-productive for
>> software developers.  The JDK and many other large Java
>> applications/libraries are broken in subtle ways, such as the
>> missing "volatile" here.   The compilers rewrite of such code
>> into non-thread safe segments when the developer(s) might look at
>> their code and say "that's racy, but safe, because I'll just use
>> "synchronized" around my calls, is changing the outcome that
>> breaks SC.  Yes SC is not supposed to be guaranteed in this case,
>> but do JVM and hotspot developers really feel like they are doing
>> great and wonderful things, when this kind of stuff is haunting
>> everybody everywhere, because even the JDK has not been "fixed"?
>>
>> Gregg Wonderly
>>
>> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>
>>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly
>> <gregg at cytetech.com> wrote:
>>>> Nathan's example below is my issue...
>>>>
>>>>
>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>>
>>>>> Gregg,
>>>>>
>>>>> Gregg Wonderly writes:
>>>>>>
>>>>>>
>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>>
>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>
>>>>>> operations that JIT
>>>>>>>
>>>>>>> could do.  If another thread reads this.name between its
>>>>>>
>>>>>> creation and the end of
>>>>>>>
>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>
>>>>>>>       public final void setName(String name) {
>>>>>>>           this.name = new char[name.length()];
>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>
>>>>
>>>> If two different threads call setName concurrently, then if
>> the code was
>>>> transformed as shown above, then it is possible to see
>>>>
>>>> T1:           this.name = new char["some longer string".length()];
>>>> T2:           this.name = new char["a short string".length()];
>>>> T1:           System.arraycopy( "some longer string", 0,
>>>>                         this.name, 0, "some longer string".length());
>>>>
>>>> Which will result in an exception at best and memory
>> corruption at worse
>>>> depending on how this.name is referenced.
>>>
>>> I think you are right, the compiler must not issue a load that did not
>>> exist in the source code (the compiler *is* aware that some other
>>> thread may be changing the variable).
>>>
>>> The following transformation should be legal
>>>
>>>        public final void setName(String name) {
>>>             char[]  tmp = new char[name.length()]
>>>             this.name = tmp;
>>>             System.arraycopy(name.value, 0, tmp, 0, name.length());
>>>
>>> Zhong Yu
>>>
>>>> Gregg Wonderly
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> -----
>> No virus found in this message.
>> Checked by AVG - www.avg.com
>> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
>> Internal Virus Database is out of date.
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From gregg at cytetech.com  Fri Mar 15 22:45:59 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Fri, 15 Mar 2013 21:45:59 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <5143D753.9080509@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<51439532.8060105@oracle.com>
	<E5DFC89E-D5E7-44C1-BFB7-9441AF434F39@cox.net>
	<A3E67C2071F49C4CBC4F17E6D77CDDD2369B2C94@G9W0725.americas.hpqcorp.net>
	<5143D753.9080509@oracle.com>
Message-ID: <5143DCE7.5080401@cytetech.com>

I guess that this use of it would be the place to go for race detections.

http://www.cise.ufl.edu/research/JavaRacefinder/Java_RaceFinder/Download.html

Gregg Wonderly

On 3/15/2013 9:22 PM, Nathan Reynolds wrote:
> Its called Java Path Finder. http://babelfish.arc.nasa.gov/trac/jpf/
>
> Nathan Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> Architect | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
> On 3/15/2013 4:49 PM, Boehm, Hans wrote:
>>
>> It seems to me that the right general solution consists of:
>>
>> -Annotations for intentional, and extremely carefully considered, data races.
>>
>> -A data race detector that can be used on a regular basis, and ignores the
>> above data races.
>>
>> -A general understanding that unannotated data races are bugs.
>>
>> AFAIK, all of this is fundamentally possible.
>>
>> Hans
>>
>> *From:*concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Gregg Wonderly
>> *Sent:* Friday, March 15, 2013 2:53 PM
>> *To:* Nathan Reynolds
>> *Cc:* concurrency-interest at cs.oswego.edu
>> *Subject:* Re: [concurrency-interest] Thread safety of Thread.getName()
>>
>> On Mar 15, 2013, at 4:40 PM, Nathan Reynolds <nathan.reynolds at oracle.com
>> <mailto:nathan.reynolds at oracle.com>> wrote:
>>
>>
>>
>> System.arraycopy has its own internal checks to make sure the copy doesn't go
>> beyond the ends of the array.  I highly doubt JIT will be able to move
>> instructions around in such a way as to cause System.arraycopy instructions to
>> reload the "this.name" reference after checking the array bounds.
>>
>> Okay, but is there actually any guarantee?  Since that still leaves the
>> "ArrayIndexOutOfBoundsException" as a possibility, I'd suggest that there
>> needs to be something done to "fix" this API.  It still seems like we need an
>> annotation that actually turns on "intra-thread" optimizations.  In the end,
>> inter-thread optimizations should be all that is done by default, because we
>> do not have any "guarantees" in the language constructs or the compilers
>> operation, that would allow it to guarantee that a method is not used
>> inter-thread.
>>
>> @MultiThreaded or some kind of annotation needs to come into play at some
>> point.  I just can't imagine that we will be able to continue to "guess" about
>> this and "hope" and "laugh when it fails" or "fix it later" for too much
>> longer.  The hardware is in our faces now, and the tools and Java in
>> particular just doesn't provide a developer with any indication that there
>> code is not thread-safe.  I think it would be much, much more productive to
>> let developers make that designation, literally, so that Javadoc and
>> introspection and all kinds of "real" observations regarding safe concurrency
>> can actually happen.
>>
>> Gregg
>>
>>
>>
>> Nathan Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>> | Architect | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>
>> On 3/15/2013 1:44 PM, Zhong Yu wrote:
>>
>>     On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly<gregg at cytetech.com>  <mailto:gregg at cytetech.com>  wrote:
>>
>>         Nathan's example below is my issue...
>>
>>
>>
>>
>>
>>         On 3/15/2013 12:29 AM, David Holmes wrote:
>>
>>             Gregg,
>>
>>
>>
>>             Gregg Wonderly writes:
>>
>>
>>
>>                 On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>
>>                     I've inlined the name.toCharArray() and rearranged a few
>>
>>                 operations that JIT
>>
>>                     could do.  If another thread reads this.name between its
>>
>>                 creation and the end of
>>
>>                     arraycopy() then the thread will see a partially filled char[].
>>
>>
>>
>>                            public final void setName(String name) {
>>
>>                                this.name = new char[name.length()];
>>
>>                                System.arraycopy(..., 0, result, 0, name.length());
>>
>>
>>
>>         If two different threads call setName concurrently, then if the code was
>>
>>         transformed as shown above, then it is possible to see
>>
>>
>>
>>         T1:           this.name = new char["some longer string".length()];
>>
>>         T2:           this.name = new char["a short string".length()];
>>
>>         T1:           System.arraycopy( "some longer string", 0,
>>
>>                                  this.name, 0, "some longer string".length());
>>
>>
>>
>>         Which will result in an exception at best and memory corruption at worse
>>
>>         depending on how this.name is referenced.
>>
>>     I think you are right, the compiler must not issue a load that did not
>>
>>     exist in the source code (the compiler *is* aware that some other
>>
>>     thread may be changing the variable).
>>
>>
>>
>>     The following transformation should be legal
>>
>>
>>
>>             public final void setName(String name) {
>>
>>                  char[]  tmp = new char[name.length()]
>>
>>                  this.name = tmp;
>>
>>                  System.arraycopy(name.value, 0, tmp, 0, name.length());
>>
>>
>>
>>     Zhong Yu
>>
>>
>>
>>         Gregg Wonderly
>>
>>
>>
>>         _______________________________________________
>>
>>         Concurrency-interest mailing list
>>
>>         Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>     _______________________________________________
>>
>>     Concurrency-interest mailing list
>>
>>     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From hans.boehm at hp.com  Sat Mar 16 01:09:34 2013
From: hans.boehm at hp.com (Boehm, Hans)
Date: Sat, 16 Mar 2013 05:09:34 +0000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <5143DCE7.5080401@cytetech.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<51439532.8060105@oracle.com>
	<E5DFC89E-D5E7-44C1-BFB7-9441AF434F39@cox.net>
	<A3E67C2071F49C4CBC4F17E6D77CDDD2369B2C94@G9W0725.americas.hpqcorp.net>
	<5143D753.9080509@oracle.com> <5143DCE7.5080401@cytetech.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD2369B2DA5@G9W0725.americas.hpqcorp.net>

My impression is that currently you have a choice between tools like this that try to explore all paths (notably Java Path Finder), presumably with a huge slowdown, or dynamic race detectors (e.g. http://dl.acm.org/citation.cfm?id=1542490 ) that check a single execution for the absence of a happens-before relation between accesses, at perhaps an order of magnitude slowdown.  Since I haven't in fact been following my own advice, I don't know whether there are good production quality tools in the latter category that work for Java.  I would expect that if they exist, they are more practical for medium or large applications than the former kind of tool.  The down side is clearly that a dynamic race detector has all the problems with coverage that any other form of testing has.

Hans

> -----Original Message-----
> From: Gregg Wonderly [mailto:gregg at cytetech.com]
> Sent: Friday, March 15, 2013 7:46 PM
> To: Nathan Reynolds
> Cc: Boehm, Hans; Gregg Wonderly; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Thread safety of Thread.getName()
> 
> I guess that this use of it would be the place to go for race detections.
> 
> http://www.cise.ufl.edu/research/JavaRacefinder/Java_RaceFinder/Downlo
> ad.html
> 
> Gregg Wonderly
> 
> On 3/15/2013 9:22 PM, Nathan Reynolds wrote:
> > Its called Java Path Finder. http://babelfish.arc.nasa.gov/trac/jpf/
> >
> > Nathan Reynolds
> > <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> > Architect | 602.333.9091 Oracle PSR Engineering
> > <http://psr.us.oracle.com/> | Server Technology On 3/15/2013 4:49 PM,
> Boehm, Hans wrote:
> >>
> >> It seems to me that the right general solution consists of:
> >>
> >> -Annotations for intentional, and extremely carefully considered, data
> races.
> >>
> >> -A data race detector that can be used on a regular basis, and
> >> ignores the above data races.
> >>
> >> -A general understanding that unannotated data races are bugs.
> >>
> >> AFAIK, all of this is fundamentally possible.
> >>
> >> Hans
> >>
> >> *From:*concurrency-interest-bounces at cs.oswego.edu
> >> [mailto:concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of
> >> *Gregg Wonderly
> >> *Sent:* Friday, March 15, 2013 2:53 PM
> >> *To:* Nathan Reynolds
> >> *Cc:* concurrency-interest at cs.oswego.edu
> >> *Subject:* Re: [concurrency-interest] Thread safety of
> >> Thread.getName()
> >>
> >> On Mar 15, 2013, at 4:40 PM, Nathan Reynolds
> >> <nathan.reynolds at oracle.com <mailto:nathan.reynolds at oracle.com>>
> wrote:
> >>
> >>
> >>
> >> System.arraycopy has its own internal checks to make sure the copy
> >> doesn't go beyond the ends of the array.  I highly doubt JIT will be
> >> able to move instructions around in such a way as to cause
> >> System.arraycopy instructions to reload the "this.name" reference after
> checking the array bounds.
> >>
> >> Okay, but is there actually any guarantee?  Since that still leaves
> >> the "ArrayIndexOutOfBoundsException" as a possibility, I'd suggest
> >> that there needs to be something done to "fix" this API.  It still
> >> seems like we need an annotation that actually turns on
> >> "intra-thread" optimizations.  In the end, inter-thread optimizations
> >> should be all that is done by default, because we do not have any
> >> "guarantees" in the language constructs or the compilers operation,
> >> that would allow it to guarantee that a method is not used inter-thread.
> >>
> >> @MultiThreaded or some kind of annotation needs to come into play at
> >> some point.  I just can't imagine that we will be able to continue to
> >> "guess" about this and "hope" and "laugh when it fails" or "fix it
> >> later" for too much longer.  The hardware is in our faces now, and
> >> the tools and Java in particular just doesn't provide a developer
> >> with any indication that there code is not thread-safe.  I think it
> >> would be much, much more productive to let developers make that
> >> designation, literally, so that Javadoc and introspection and all
> >> kinds of "real" observations regarding safe concurrency can actually
> happen.
> >>
> >> Gregg
> >>
> >>
> >>
> >> Nathan Reynolds
> >> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
> >> | Architect | 602.333.9091
> >> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
> >> Technology
> >>
> >> On 3/15/2013 1:44 PM, Zhong Yu wrote:
> >>
> >>     On Fri, Mar 15, 2013 at 3:22 PM, Gregg
> Wonderly<gregg at cytetech.com>  <mailto:gregg at cytetech.com>  wrote:
> >>
> >>         Nathan's example below is my issue...
> >>
> >>
> >>
> >>
> >>
> >>         On 3/15/2013 12:29 AM, David Holmes wrote:
> >>
> >>             Gregg,
> >>
> >>
> >>
> >>             Gregg Wonderly writes:
> >>
> >>
> >>
> >>                 On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
> >>
> >>                     I've inlined the name.toCharArray() and
> >> rearranged a few
> >>
> >>                 operations that JIT
> >>
> >>                     could do.  If another thread reads this.name
> >> between its
> >>
> >>                 creation and the end of
> >>
> >>                     arraycopy() then the thread will see a partially filled char[].
> >>
> >>
> >>
> >>                            public final void setName(String name) {
> >>
> >>                                this.name = new char[name.length()];
> >>
> >>                                System.arraycopy(..., 0, result, 0,
> >> name.length());
> >>
> >>
> >>
> >>         If two different threads call setName concurrently, then if
> >> the code was
> >>
> >>         transformed as shown above, then it is possible to see
> >>
> >>
> >>
> >>         T1:           this.name = new char["some longer string".length()];
> >>
> >>         T2:           this.name = new char["a short string".length()];
> >>
> >>         T1:           System.arraycopy( "some longer string", 0,
> >>
> >>                                  this.name, 0, "some longer
> >> string".length());
> >>
> >>
> >>
> >>         Which will result in an exception at best and memory
> >> corruption at worse
> >>
> >>         depending on how this.name is referenced.
> >>
> >>     I think you are right, the compiler must not issue a load that
> >> did not
> >>
> >>     exist in the source code (the compiler *is* aware that some other
> >>
> >>     thread may be changing the variable).
> >>
> >>
> >>
> >>     The following transformation should be legal
> >>
> >>
> >>
> >>             public final void setName(String name) {
> >>
> >>                  char[]  tmp = new char[name.length()]
> >>
> >>                  this.name = tmp;
> >>
> >>                  System.arraycopy(name.value, 0, tmp, 0,
> >> name.length());
> >>
> >>
> >>
> >>     Zhong Yu
> >>
> >>
> >>
> >>         Gregg Wonderly
> >>
> >>
> >>
> >>         _______________________________________________
> >>
> >>         Concurrency-interest mailing list
> >>
> >>         Concurrency-interest at cs.oswego.edu
> >> <mailto:Concurrency-interest at cs.oswego.edu>
> >>
> >>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >>     _______________________________________________
> >>
> >>     Concurrency-interest mailing list
> >>
> >>     Concurrency-interest at cs.oswego.edu
> >> <mailto:Concurrency-interest at cs.oswego.edu>
> >>
> >>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >>
> >>
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> <mailto:Concurrency-interest at cs.oswego.edu>
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >



From chris.hegarty at oracle.com  Sun Mar 17 04:52:12 2013
From: chris.hegarty at oracle.com (Chris Hegarty)
Date: Sun, 17 Mar 2013 08:52:12 +0000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <A3E67C2071F49C4CBC4F17E6D77CDDD2369B2DA5@G9W0725.americas.hpqcorp.net>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<51439532.8060105@oracle.com>
	<E5DFC89E-D5E7-44C1-BFB7-9441AF434F39@cox.net>
	<A3E67C2071F49C4CBC4F17E6D77CDDD2369B2C94@G9W0725.americas.hpqcorp.net>
	<5143D753.9080509@oracle.com> <5143DCE7.5080401@cytetech.com>
	<A3E67C2071F49C4CBC4F17E6D77CDDD2369B2DA5@G9W0725.americas.hpqcorp.net>
Message-ID: <5145843C.3080201@oracle.com>

I filed 8010182: "Thread safety of Thread get/setName()" to track this 
issue in the JDK. I know Gregg has other issues around this type of 
"optimization", but I think at the very least we need to make char[] 
name volatile.

-Chris.

On 03/16/2013 05:09 AM, Boehm, Hans wrote:
> My impression is that currently you have a choice between tools like this that try to explore all paths (notably Java Path Finder), presumably with a huge slowdown, or dynamic race detectors (e.g. http://dl.acm.org/citation.cfm?id=1542490 ) that check a single execution for the absence of a happens-before relation between accesses, at perhaps an order of magnitude slowdown.  Since I haven't in fact been following my own advice, I don't know whether there are good production quality tools in the latter category that work for Java.  I would expect that if they exist, they are more practical for medium or large applications than the former kind of tool.  The down side is clearly that a dynamic race detector has all the problems with coverage that any other form of testing has.
>
> Hans
>
>> -----Original Message-----
>> From: Gregg Wonderly [mailto:gregg at cytetech.com]
>> Sent: Friday, March 15, 2013 7:46 PM
>> To: Nathan Reynolds
>> Cc: Boehm, Hans; Gregg Wonderly; concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Thread safety of Thread.getName()
>>
>> I guess that this use of it would be the place to go for race detections.
>>
>> http://www.cise.ufl.edu/research/JavaRacefinder/Java_RaceFinder/Downlo
>> ad.html
>>
>> Gregg Wonderly
>>
>> On 3/15/2013 9:22 PM, Nathan Reynolds wrote:
>>> Its called Java Path Finder. http://babelfish.arc.nasa.gov/trac/jpf/
>>>
>>> Nathan Reynolds
>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>> Architect | 602.333.9091 Oracle PSR Engineering
>>> <http://psr.us.oracle.com/> | Server Technology On 3/15/2013 4:49 PM,
>> Boehm, Hans wrote:
>>>>
>>>> It seems to me that the right general solution consists of:
>>>>
>>>> -Annotations for intentional, and extremely carefully considered, data
>> races.
>>>>
>>>> -A data race detector that can be used on a regular basis, and
>>>> ignores the above data races.
>>>>
>>>> -A general understanding that unannotated data races are bugs.
>>>>
>>>> AFAIK, all of this is fundamentally possible.
>>>>
>>>> Hans
>>>>
>>>> *From:*concurrency-interest-bounces at cs.oswego.edu
>>>> [mailto:concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of
>>>> *Gregg Wonderly
>>>> *Sent:* Friday, March 15, 2013 2:53 PM
>>>> *To:* Nathan Reynolds
>>>> *Cc:* concurrency-interest at cs.oswego.edu
>>>> *Subject:* Re: [concurrency-interest] Thread safety of
>>>> Thread.getName()
>>>>
>>>> On Mar 15, 2013, at 4:40 PM, Nathan Reynolds
>>>> <nathan.reynolds at oracle.com <mailto:nathan.reynolds at oracle.com>>
>> wrote:
>>>>
>>>>
>>>>
>>>> System.arraycopy has its own internal checks to make sure the copy
>>>> doesn't go beyond the ends of the array.  I highly doubt JIT will be
>>>> able to move instructions around in such a way as to cause
>>>> System.arraycopy instructions to reload the "this.name" reference after
>> checking the array bounds.
>>>>
>>>> Okay, but is there actually any guarantee?  Since that still leaves
>>>> the "ArrayIndexOutOfBoundsException" as a possibility, I'd suggest
>>>> that there needs to be something done to "fix" this API.  It still
>>>> seems like we need an annotation that actually turns on
>>>> "intra-thread" optimizations.  In the end, inter-thread optimizations
>>>> should be all that is done by default, because we do not have any
>>>> "guarantees" in the language constructs or the compilers operation,
>>>> that would allow it to guarantee that a method is not used inter-thread.
>>>>
>>>> @MultiThreaded or some kind of annotation needs to come into play at
>>>> some point.  I just can't imagine that we will be able to continue to
>>>> "guess" about this and "hope" and "laugh when it fails" or "fix it
>>>> later" for too much longer.  The hardware is in our faces now, and
>>>> the tools and Java in particular just doesn't provide a developer
>>>> with any indication that there code is not thread-safe.  I think it
>>>> would be much, much more productive to let developers make that
>>>> designation, literally, so that Javadoc and introspection and all
>>>> kinds of "real" observations regarding safe concurrency can actually
>> happen.
>>>>
>>>> Gregg
>>>>
>>>>
>>>>
>>>> Nathan Reynolds
>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>>>> | Architect | 602.333.9091
>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>>>> Technology
>>>>
>>>> On 3/15/2013 1:44 PM, Zhong Yu wrote:
>>>>
>>>>      On Fri, Mar 15, 2013 at 3:22 PM, Gregg
>> Wonderly<gregg at cytetech.com>  <mailto:gregg at cytetech.com>  wrote:
>>>>
>>>>          Nathan's example below is my issue...
>>>>
>>>>
>>>>
>>>>
>>>>
>>>>          On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>
>>>>              Gregg,
>>>>
>>>>
>>>>
>>>>              Gregg Wonderly writes:
>>>>
>>>>
>>>>
>>>>                  On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>
>>>>                      I've inlined the name.toCharArray() and
>>>> rearranged a few
>>>>
>>>>                  operations that JIT
>>>>
>>>>                      could do.  If another thread reads this.name
>>>> between its
>>>>
>>>>                  creation and the end of
>>>>
>>>>                      arraycopy() then the thread will see a partially filled char[].
>>>>
>>>>
>>>>
>>>>                             public final void setName(String name) {
>>>>
>>>>                                 this.name = new char[name.length()];
>>>>
>>>>                                 System.arraycopy(..., 0, result, 0,
>>>> name.length());
>>>>
>>>>
>>>>
>>>>          If two different threads call setName concurrently, then if
>>>> the code was
>>>>
>>>>          transformed as shown above, then it is possible to see
>>>>
>>>>
>>>>
>>>>          T1:           this.name = new char["some longer string".length()];
>>>>
>>>>          T2:           this.name = new char["a short string".length()];
>>>>
>>>>          T1:           System.arraycopy( "some longer string", 0,
>>>>
>>>>                                   this.name, 0, "some longer
>>>> string".length());
>>>>
>>>>
>>>>
>>>>          Which will result in an exception at best and memory
>>>> corruption at worse
>>>>
>>>>          depending on how this.name is referenced.
>>>>
>>>>      I think you are right, the compiler must not issue a load that
>>>> did not
>>>>
>>>>      exist in the source code (the compiler *is* aware that some other
>>>>
>>>>      thread may be changing the variable).
>>>>
>>>>
>>>>
>>>>      The following transformation should be legal
>>>>
>>>>
>>>>
>>>>              public final void setName(String name) {
>>>>
>>>>                   char[]  tmp = new char[name.length()]
>>>>
>>>>                   this.name = tmp;
>>>>
>>>>                   System.arraycopy(name.value, 0, tmp, 0,
>>>> name.length());
>>>>
>>>>
>>>>
>>>>      Zhong Yu
>>>>
>>>>
>>>>
>>>>          Gregg Wonderly
>>>>
>>>>
>>>>
>>>>          _______________________________________________
>>>>
>>>>          Concurrency-interest mailing list
>>>>
>>>>          Concurrency-interest at cs.oswego.edu
>>>> <mailto:Concurrency-interest at cs.oswego.edu>
>>>>
>>>>          http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>      _______________________________________________
>>>>
>>>>      Concurrency-interest mailing list
>>>>
>>>>      Concurrency-interest at cs.oswego.edu
>>>> <mailto:Concurrency-interest at cs.oswego.edu>
>>>>
>>>>      http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> <mailto:Concurrency-interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From discus at kotek.net  Sun Mar 17 06:58:41 2013
From: discus at kotek.net (Jan Kotek)
Date: Sun, 17 Mar 2013 10:58:41 +0000
Subject: [concurrency-interest] MapDB intro
Message-ID: <1672847.2aYbfy5OL9@artemis>

Hi,
I would like to introduce my hobby project I have been working on for last 4 
years. You may know it under name JDBM

MapDB provides Maps, Sets and Queues backed by disk storage or off-heap memory. 
It is usually described as embedded database engine (such as BerkeleyDB JE).  
But better description would be an alternative memory management model for 
Java. One of goals is to solve limited scalability of Java Heap.

Using MapDB API is very similar to usual concurrent programming in Java. There 
is CAS, Atomic Variables, Concurrent collections... In fact large part of 
MapDB code and unit tests was 'stolen' from JSR-166, Google Collections, 
Apache Harmony etc...

Why I am writing here? MapDB reimplements stuff from JSR-166: 
ConcurrentNavigableMap, HashMapV8... Soon I will ask many questions , and I 
would like  people to know its code. 

MapDB is a few weeks away from first stable release. 99% code is working, I am 
fixing last bugs and improving concurrency. There is not much documentation yet 
(and existing doc may be outdated and misleading).

Best place to start are examples:
	https://github.com/jankotek/MapDB/tree/master/src/test/java/examples
There is also overview podcast:
	https://www.youtube.com/watch?v=FdZmyEHcWLI
Javadoc:
	http://www.mapdb.org/apidocs/index.html
Github page
	https://github.com/jankotek/MapDB
Homepage
	http://www.mapdb.org

Regards,
Jan Kotek

From nathan.reynolds at oracle.com  Mon Mar 18 12:26:56 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 18 Mar 2013 09:26:56 -0700
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <5143DB4B.5070505@cytetech.com>
References: <NFBBKALFDCPFIDBNKAPCGEDKJLAA.davidcholmes@aapt.net.au>
	<5143DB4B.5070505@cytetech.com>
Message-ID: <51474050.8000305@oracle.com>

 > Maybe it's time to open src.zip and start writing bug reports.  I 
just really don't think I'll enjoy doing that, but I suppose no one 
would...

That would be awesome!  You will learn a lot about the JDK and become an 
expert on it.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 3/15/2013 7:39 PM, Gregg Wonderly wrote:
> On 3/15/2013 6:27 PM, David Holmes wrote:
>> Gregg,
>>
>> The sky is not falling, the end of the world is not nigh. There are
>> thousands of non-thread-safe methods in the JDK libraries, this is 
>> just an
>> example. This might be a surprising example, but I expect there was 
>> little
>> consideration given to dynamic thread re-naming. You may ineed get an
>> exception because of the possible races - so be it.
>
> I am not sure of how many lines of code you have written in 
> applications running in the wild David, and I don't want to diminish 
> anything about what you know and/or have experienced.  I can tell you 
> for sure, that I am constantly frustrated by these kinds of APIs with 
> neither specified nor correct (in some potential cases) concurrency 
> and having people involved in the development of Java tell me, the 
> user and customer, that everything is just fine.
>
> I really want my software to function correctly and run unfettered, 
> forever, without any "odd" behavior.  My software is involved in 
> applications which need correct results each and every time.  I can 
> not live with any chance that something will sometimes be wrong or may 
> not complete for unexplainable or correctable reasons.
>
> I just can not understand how the possibility of "wrong", or 
> "incomplete" or "unpredictable" results can feel acceptable.
>
> To mediate this issue in my software, for some time now, I've lived by 
> the rule, all variables must be declared either volatile or final.  
> I've mentioned that here before, and I recall that I was sort of 
> pushed back on, saying that was not really necessary. It's cases like 
> this where an API permits something to happen that is incorrect for 
> its implementation of concurrent access that really highlight the 
> reasons for me.
>
> Yes, volatile doesn't result in 'non-race' execution.  But, it does 
> keep the compiler for doing things that this reordering might do which 
> would cause software to produce unexpected results in the form of a 
> RuntimeException.  I'm not up for surrounding every statement with a 
> try{}catch.
>
> Only when performance becomes a consideration, do I start to revisit 
> the volatile declarations.  I've not really had to do very much 
> removing of volatile.  For simple values, I'd either have synchronized 
> setter/getter or volatile already anyway.
>
>> We can file a bug and make them synchronized or whaetver.
>
> I know this seems like an over-the-top reaction, but it's just so 
> frustrating to keep having to deal with things like this in my 
> software, and everytime I turn around, there's another something like 
> this that highlights something that I've overlooked or had not 
> expected to possibly be an issue.  My trust in the JDK libraries 
> (except for java.util.concurrent, which Doug has been flawlessly open 
> and considerate of developers needs in my opinion) is waning...
>
> Maybe it's time to open src.zip and start writing bug reports.  I just 
> really don't think I'll enjoy doing that, but I suppose no one would...
>
> Gregg Wonderly
>
>> David
>>
>>> -----Original Message-----
>>> From: concurrency-interest-bounces at cs.oswego.edu
>>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Gregg
>>> Wonderly
>>> Sent: Saturday, 16 March 2013 7:46 AM
>>> To: Zhong Yu
>>> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org;
>>> gregg.wonderly at pobox.com
>>> Subject: Re: [concurrency-interest] Thread safety of Thread.getName()
>>>
>>>
>>> Yes, that transformation is legal, but it is also broken in the
>>> current design of that class.  Because Thread.setName() is
>>> callable, and because there is no other visible happensBefore
>>> with Thread.getName, the compiler can make the decision to
>>> designate these methods as intra-thread use only.
>>>
>>> That is the problem.  Even if I subsequently introduce a "happens
>>> before" by synchronizing or locking or something else, I have to
>>> know what the implementation is, know how it is broken and only
>>> then can I actually expect to achieve safe use of the provided API.
>>>
>>> I assert that this is completely and totally non-productive for
>>> software developers.  The JDK and many other large Java
>>> applications/libraries are broken in subtle ways, such as the
>>> missing "volatile" here.   The compilers rewrite of such code
>>> into non-thread safe segments when the developer(s) might look at
>>> their code and say "that's racy, but safe, because I'll just use
>>> "synchronized" around my calls, is changing the outcome that
>>> breaks SC.  Yes SC is not supposed to be guaranteed in this case,
>>> but do JVM and hotspot developers really feel like they are doing
>>> great and wonderful things, when this kind of stuff is haunting
>>> everybody everywhere, because even the JDK has not been "fixed"?
>>>
>>> Gregg Wonderly
>>>
>>> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>
>>>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly
>>> <gregg at cytetech.com> wrote:
>>>>> Nathan's example below is my issue...
>>>>>
>>>>>
>>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>>>
>>>>>> Gregg,
>>>>>>
>>>>>> Gregg Wonderly writes:
>>>>>>>
>>>>>>>
>>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>>>
>>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>>
>>>>>>> operations that JIT
>>>>>>>>
>>>>>>>> could do.  If another thread reads this.name between its
>>>>>>>
>>>>>>> creation and the end of
>>>>>>>>
>>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>>
>>>>>>>>       public final void setName(String name) {
>>>>>>>>           this.name = new char[name.length()];
>>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>
>>>>>
>>>>> If two different threads call setName concurrently, then if
>>> the code was
>>>>> transformed as shown above, then it is possible to see
>>>>>
>>>>> T1:           this.name = new char["some longer string".length()];
>>>>> T2:           this.name = new char["a short string".length()];
>>>>> T1:           System.arraycopy( "some longer string", 0,
>>>>>                         this.name, 0, "some longer string".length());
>>>>>
>>>>> Which will result in an exception at best and memory
>>> corruption at worse
>>>>> depending on how this.name is referenced.
>>>>
>>>> I think you are right, the compiler must not issue a load that did not
>>>> exist in the source code (the compiler *is* aware that some other
>>>> thread may be changing the variable).
>>>>
>>>> The following transformation should be legal
>>>>
>>>>        public final void setName(String name) {
>>>>             char[]  tmp = new char[name.length()]
>>>>             this.name = tmp;
>>>>             System.arraycopy(name.value, 0, tmp, 0, name.length());
>>>>
>>>> Zhong Yu
>>>>
>>>>> Gregg Wonderly
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>> -----
>>> No virus found in this message.
>>> Checked by AVG - www.avg.com
>>> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 
>>> 03/08/13
>>> Internal Virus Database is out of date.
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130318/4494e533/attachment.html>

From oleksandr.otenko at oracle.com  Mon Mar 18 13:42:43 2013
From: oleksandr.otenko at oracle.com (oleksandr otenko)
Date: Mon, 18 Mar 2013 17:42:43 +0000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <FD424034-EF10-455E-8939-18D856236D45@cox.net>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<FD424034-EF10-455E-8939-18D856236D45@cox.net>
Message-ID: <51475213.3030509@oracle.com>

It is hardly surprising that in order to combine effects you need to 
know what the effects are.

So nothing special about having to know what setName does to properly 
synchronize.

Alex

On 15/03/2013 21:46, Gregg Wonderly wrote:
> Yes, that transformation is legal, but it is also broken in the current design of that class.  Because Thread.setName() is callable, and because there is no other visible happensBefore with Thread.getName, the compiler can make the decision to designate these methods as intra-thread use only.
>
> That is the problem.  Even if I subsequently introduce a "happens before" by synchronizing or locking or something else, I have to know what the implementation is, know how it is broken and only then can I actually expect to achieve safe use of the provided API.
>
> I assert that this is completely and totally non-productive for software developers.  The JDK and many other large Java applications/libraries are broken in subtle ways, such as the missing "volatile" here.   The compilers rewrite of such code into non-thread safe segments when the developer(s) might look at their code and say "that's racy, but safe, because I'll just use "synchronized" around my calls, is changing the outcome that breaks SC.  Yes SC is not supposed to be guaranteed in this case, but do JVM and hotspot developers really feel like they are doing great and wonderful things, when this kind of stuff is haunting everybody everywhere, because even the JDK has not been "fixed"?
>
> Gregg Wonderly
>
> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>
>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
>>> Nathan's example below is my issue...
>>>
>>>
>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>> Gregg,
>>>>
>>>> Gregg Wonderly writes:
>>>>>
>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>> operations that JIT
>>>>>> could do.  If another thread reads this.name between its
>>>>> creation and the end of
>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>
>>>>>>       public final void setName(String name) {
>>>>>>           this.name = new char[name.length()];
>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>
>>> If two different threads call setName concurrently, then if the code was
>>> transformed as shown above, then it is possible to see
>>>
>>> T1:           this.name = new char["some longer string".length()];
>>> T2:           this.name = new char["a short string".length()];
>>> T1:           System.arraycopy( "some longer string", 0,
>>>                         this.name, 0, "some longer string".length());
>>>
>>> Which will result in an exception at best and memory corruption at worse
>>> depending on how this.name is referenced.
>> I think you are right, the compiler must not issue a load that did not
>> exist in the source code (the compiler *is* aware that some other
>> thread may be changing the variable).
>>
>> The following transformation should be legal
>>
>>        public final void setName(String name) {
>>             char[]  tmp = new char[name.length()]
>>             this.name = tmp;
>>             System.arraycopy(name.value, 0, tmp, 0, name.length());
>>
>> Zhong Yu
>>
>>> Gregg Wonderly
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From oleksandr.otenko at oracle.com  Mon Mar 18 15:05:39 2013
From: oleksandr.otenko at oracle.com (oleksandr otenko)
Date: Mon, 18 Mar 2013 19:05:39 +0000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <5142AE2B.3030203@cytetech.com>
References: <CD67AFF1.22532%pete@guyatt.ca> <514259F1.2080604@oracle.com>
	<5142AE2B.3030203@cytetech.com>
Message-ID: <51476583.2070102@oracle.com>

Why Sequential Consistency, of all consistency requirements? As an 
example, Vector and Hashtable will return "consistent" results, but that 
doesn't eliminate races between get and put - what sort of consistency 
guarantee do you get?

Also, bear in mind that 2 billion calls to Vector and Hashtable methods 
will create about 8 minutes of runtime overhead even on a 
single-threaded flow - no contention, just the cost of those 
instructions (compared to exactly the same test, but on a uniprocessor = 
JVM optimizes away the atomics on the locks). (this is not the latest 
HotSpot, but I think a useful rule of thumb) Maybe if you count all 
field mutations in your workflow you can see why non-volatile accesses 
is the default.


Alex


On 15/03/2013 05:14, Gregg Wonderly wrote:
> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>> I've inlined the name.toCharArray() and rearranged a few operations 
>> that JIT
>> could do.  If another thread reads this.name between its creation and 
>> the end of
>> arraycopy() then the thread will see a partially filled char[].
>>
>>      public final void setName(String name) {
>>          this.name = new char[name.length()];
>>          System.arraycopy(..., 0, result, 0, name.length());
>>      }
>
> This rewrite/optimization doesn't seem to meet sequential consistency 
> ordering requirements.  I don't see how this could be considered SC 
> since it creates a different result (uninitialized value) then the way 
> that the original source was coded did not.
>
> If the JIT is actually doing this when concurrency is not detected 
> (non-volatile and no other happensBefore/fence), its no wonder we have 
> so many developers plagued with unexplainable racy program bugs.
>
> I thought the rewrite of while( nonvolatileBoolean ){} to if 
> (nonvolatileBoolean) { while (true ) {} } was bad enough of a 
> mistake.  This just wreaks of frustration for developers.
>
> How is this optimization more efficient, really?  Are we really so 
> interested in absolutely most efficient that we've given up on letting 
> developers decide when performance matters and then optimize to 
> "incorrect" on their own terms?
>
> This kind optimization, if it is actually occurring is another example 
> of insidious change in program behavior...
>
> Gregg Wonderly
>
>>
>> Nathan Reynolds 
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>> Architect | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>> On 3/14/2013 4:03 PM, Pete Guyatt wrote:
>>> I'm sure I'm missing something here but I don't quite see how the
>>> character array can be scrambled.
>>>
>>> I can see how it "racy" and how an inconsistent write/read happens 
>>> where a
>>> thread calls setName -- could be the thread itself or another thread --
>>> and another calls getName but from what I can see the assignment of the
>>> new value to the name[] array is only going to happen after the call to
>>> toCharArray completes. I thought this would be the case even with 
>>> the JVM
>>> performing some reordering of instructions.
>>>
>>> Would someone mind clarifying?
>>>
>>> Kind Regards,
>>>
>>> Pete
>>>
>>> On 2013-03-14 4:47 PM, "Zhong Yu"<zhong.j.yu at gmail.com> wrote:
>>>
>>>> On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
>>>> <stanimir at riflexo.com>  wrote:
>>>>> We already agree about being racy. Unline the clone() method 
>>>>> 'name' has
>>>>> no
>>>>> critical applications (or at least shall not), so I presume it was 
>>>>> never
>>>>> considered a problem to warrant a volatile field.
>>>> A non-volatile String field would be ok.
>>>>
>>>> Since getName() can be invoked by anyone at anytime, it's troubling
>>>> that it could observe a scrambled name.
>>>>
>>>> Zhong Yu
>>>>
>>>>> On Thu, Mar 14, 2013 at 11:55 PM, Zhong Yu<zhong.j.yu at gmail.com>  
>>>>> wrote:
>>>>>> It's a common practice to modify thread names on the fly, for
>>>>>> diagnosis purposes.
>>>>>>
>>>>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>>>>>> <stanimir at riflexo.com>  wrote:
>>>>>>> char[] name is usually initialized in the c-tor, in that case 
>>>>>>> it'd be
>>>>>>> fine.
>>>>>>> Since the access to 'name' is racy to begin, the changes may not be
>>>>>>> necessarily 'visible'.
>>>>>>>
>>>>>>> Stanimir
>>>>>>>
>>>>>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu<zhong.j.yu at gmail.com>
>>>>>> wrote:
>>>>>>>> java.lang.Thread
>>>>>>>>
>>>>>>>>      private char name[];
>>>>>>>>
>>>>>>>>      public final void setName(String name) {
>>>>>>>>          checkAccess();
>>>>>>>>          this.name = name.toCharArray();
>>>>>>>>      }
>>>>>>>>
>>>>>>>>      public final String getName() {
>>>>>>>>          return String.valueOf(name);
>>>>>>>>      }
>>>>>>>>
>>>>>>>> On the surface, set/getName() are not correctly synchronized,
>>>>>>>> getName() could observe a partially filled char array. What's the
>>>>>>>> story here?
>>>>>>>>
>>>>>>>> Zhong Yu
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From oleksandr.otenko at oracle.com  Mon Mar 18 15:22:13 2013
From: oleksandr.otenko at oracle.com (oleksandr otenko)
Date: Mon, 18 Mar 2013 19:22:13 +0000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51434A4C.4000106@gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<F8DF0611-61DA-4628-9E7C-6067026106D0@oracle.com>
	<CACuKZqEUAfo2jFugQkvSj_wQbSX4=dnBwaUhXubKr-PTuGQe7A@mail.gmail.com>
	<51434A4C.4000106@gmail.com>
Message-ID: <51476965.8060107@oracle.com>


On 15/03/2013 16:20, Peter Levart wrote:
> Would this be a correct work-around without changing VM code and 
> adding 'volatile' to 'char name[]' field?
>
>
> public class Thread implements Runnable {
>
>     private char name[];
>     private String nameString;
>
>     private void init(ThreadGroup g, Runnable target, String name,
>                       long stackSize) {
>         ...
>
>         this.name = name.toCharArray();
>         this.nameString = name;
>         ...
>
>     }
>
>     public final void setName(String name) {
>         checkAccess();
>         this.name = name.toCharArray();
>         this.nameString = name;

These 2 lines are allowed to reorder.


> if (threadStatus != 0) {
>             setNativeName(name);
>         }
>     }
>
>     public final String getName() {
>         String nameString = this.nameString;
>         if (nameString == null) {
>             nameString = new String(this.name);

Loading this.name is permitted to go ahead of loading this.nameString.

Alex

> this.nameString = nameString;
>         }
>         return nameString;
>     }
>
>
>
> ... assuming that 'nameString' field is only ever possible to be null 
> when VM allocates Thread object and only sets the 'char[] name' and 
> that this always HB any other thread dereferencing the Thread object...
>
> Regards, Peter
>
> On 03/15/2013 07:53 AM, Zhong Yu wrote:
>> Mike, your suggestion does not seem to be able to walk around the 
>> problem.
>>
>> // shared
>>      char name[];
>>
>> Thread 1
>>      char[] chars = {'a','b','c'};
>>      String string1 = new String(chars);
>>      name=string1.value;
>>
>> Thread 2
>>      String string2 = new String(name, true);
>>
>> The final-ness of String.value does no good here, Thread 1 can still
>> inline and reorder, to the effect that the array reference is
>> published before the array is filled. Thread 2 can still observe a
>> partially filled array. Even better, string2's content can be observed
>> to mutate while the array is being filled!
>>
>> Zhong Yu
>>
>> On Thu, Mar 14, 2013 at 7:28 PM, Mike Duigou <mike.duigou at oracle.com> 
>> wrote:
>>> On Mar 14 2013, at 14:21 , Zhong Yu wrote:
>>>
>>>> java.lang.Thread
>>>>
>>>>     private char name[];
>>>>
>>>>     public final void setName(String name) {
>>>>         checkAccess();
>>>>         this.name = name.toCharArray();
>>> The following suggestion is not for the weak of heart:
>>>
>>> Since String.value is now always the same content as this character 
>>> array we could simply extract the character array from the String 
>>> instance. This would also seem to correct the problem because for a 
>>> String to be visible it's value character array and contents would 
>>> be visible.
>>>
>>> Some people would probably consider this suggestion to be morally 
>>> dubious foolishness. They may be right.
>>>
>>>>     }
>>>>
>>>>     public final String getName() {
>>>>         return String.valueOf(name);
>>> Since we "know" that the character array is not modified after 
>>> assignment this could be replaced with the String(char[], boolean) 
>>> constructor. ibid "morally dubious foolishness."
>>>
>>>>     }
>>>>
>>>> On the surface, set/getName() are not correctly synchronized,
>>>> getName() could observe a partially filled char array. What's the
>>>> story here?
>>>>
>>>> Zhong Yu
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From gregg at cytetech.com  Mon Mar 18 15:37:52 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Mon, 18 Mar 2013 14:37:52 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51475213.3030509@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<FD424034-EF10-455E-8939-18D856236D45@cox.net>
	<51475213.3030509@oracle.com>
Message-ID: <51476D10.5090001@cytetech.com>

So how does the developer know?  setName()/getName() have no visible contract do 
they?

Gregg

On 3/18/2013 12:42 PM, oleksandr otenko wrote:
> It is hardly surprising that in order to combine effects you need to know what
> the effects are.
>
> So nothing special about having to know what setName does to properly synchronize.
>
> Alex
>
> On 15/03/2013 21:46, Gregg Wonderly wrote:
>> Yes, that transformation is legal, but it is also broken in the current design
>> of that class.  Because Thread.setName() is callable, and because there is no
>> other visible happensBefore with Thread.getName, the compiler can make the
>> decision to designate these methods as intra-thread use only.
>>
>> That is the problem.  Even if I subsequently introduce a "happens before" by
>> synchronizing or locking or something else, I have to know what the
>> implementation is, know how it is broken and only then can I actually expect
>> to achieve safe use of the provided API.
>>
>> I assert that this is completely and totally non-productive for software
>> developers.  The JDK and many other large Java applications/libraries are
>> broken in subtle ways, such as the missing "volatile" here.   The compilers
>> rewrite of such code into non-thread safe segments when the developer(s) might
>> look at their code and say "that's racy, but safe, because I'll just use
>> "synchronized" around my calls, is changing the outcome that breaks SC.  Yes
>> SC is not supposed to be guaranteed in this case, but do JVM and hotspot
>> developers really feel like they are doing great and wonderful things, when
>> this kind of stuff is haunting everybody everywhere, because even the JDK has
>> not been "fixed"?
>>
>> Gregg Wonderly
>>
>> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>
>>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
>>>> Nathan's example below is my issue...
>>>>
>>>>
>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>> Gregg,
>>>>>
>>>>> Gregg Wonderly writes:
>>>>>>
>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>> operations that JIT
>>>>>>> could do.  If another thread reads this.name between its
>>>>>> creation and the end of
>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>
>>>>>>>       public final void setName(String name) {
>>>>>>>           this.name = new char[name.length()];
>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>
>>>> If two different threads call setName concurrently, then if the code was
>>>> transformed as shown above, then it is possible to see
>>>>
>>>> T1:           this.name = new char["some longer string".length()];
>>>> T2:           this.name = new char["a short string".length()];
>>>> T1:           System.arraycopy( "some longer string", 0,
>>>>                         this.name, 0, "some longer string".length());
>>>>
>>>> Which will result in an exception at best and memory corruption at worse
>>>> depending on how this.name is referenced.
>>> I think you are right, the compiler must not issue a load that did not
>>> exist in the source code (the compiler *is* aware that some other
>>> thread may be changing the variable).
>>>
>>> The following transformation should be legal
>>>
>>>        public final void setName(String name) {
>>>             char[]  tmp = new char[name.length()]
>>>             this.name = tmp;
>>>             System.arraycopy(name.value, 0, tmp, 0, name.length());
>>>
>>> Zhong Yu
>>>
>>>> Gregg Wonderly
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From oleksandr.otenko at oracle.com  Mon Mar 18 15:53:38 2013
From: oleksandr.otenko at oracle.com (oleksandr otenko)
Date: Mon, 18 Mar 2013 19:53:38 +0000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51476D10.5090001@cytetech.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<FD424034-EF10-455E-8939-18D856236D45@cox.net>
	<51475213.3030509@oracle.com> <51476D10.5090001@cytetech.com>
Message-ID: <514770C2.3000700@oracle.com>

I am pointing out this is a problem of concurrent programming and no one 
said it is a */simple/* extension of a single-threaded world. You need 
to know all effects to know how to combine them.

Do you expect the thread name to show IP address (someone mentioned 
that?) and the stack trace to show the thread processing that same 
request? How do you combine these? So you'd need to come up with what a 
consistent state is first.

This is easily illustrated by a example of a thread dump where no thread 
holds the lock, yet has a few threads blocked on it. All because by the 
time the thread dump for the lock owner was taken, it released the lock.

Alex

On 18/03/2013 19:37, Gregg Wonderly wrote:
> So how does the developer know?  setName()/getName() have no visible 
> contract do they?
>
> Gregg
>
> On 3/18/2013 12:42 PM, oleksandr otenko wrote:
>> It is hardly surprising that in order to combine effects you need to 
>> know what
>> the effects are.
>>
>> So nothing special about having to know what setName does to properly 
>> synchronize.
>>
>> Alex
>>
>> On 15/03/2013 21:46, Gregg Wonderly wrote:
>>> Yes, that transformation is legal, but it is also broken in the 
>>> current design
>>> of that class.  Because Thread.setName() is callable, and because 
>>> there is no
>>> other visible happensBefore with Thread.getName, the compiler can 
>>> make the
>>> decision to designate these methods as intra-thread use only.
>>>
>>> That is the problem.  Even if I subsequently introduce a "happens 
>>> before" by
>>> synchronizing or locking or something else, I have to know what the
>>> implementation is, know how it is broken and only then can I 
>>> actually expect
>>> to achieve safe use of the provided API.
>>>
>>> I assert that this is completely and totally non-productive for 
>>> software
>>> developers.  The JDK and many other large Java 
>>> applications/libraries are
>>> broken in subtle ways, such as the missing "volatile" here. The 
>>> compilers
>>> rewrite of such code into non-thread safe segments when the 
>>> developer(s) might
>>> look at their code and say "that's racy, but safe, because I'll just 
>>> use
>>> "synchronized" around my calls, is changing the outcome that breaks 
>>> SC.  Yes
>>> SC is not supposed to be guaranteed in this case, but do JVM and 
>>> hotspot
>>> developers really feel like they are doing great and wonderful 
>>> things, when
>>> this kind of stuff is haunting everybody everywhere, because even 
>>> the JDK has
>>> not been "fixed"?
>>>
>>> Gregg Wonderly
>>>
>>> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>
>>>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly 
>>>> <gregg at cytetech.com> wrote:
>>>>> Nathan's example below is my issue...
>>>>>
>>>>>
>>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>>> Gregg,
>>>>>>
>>>>>> Gregg Wonderly writes:
>>>>>>>
>>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>> operations that JIT
>>>>>>>> could do.  If another thread reads this.name between its
>>>>>>> creation and the end of
>>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>>
>>>>>>>>       public final void setName(String name) {
>>>>>>>>           this.name = new char[name.length()];
>>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>
>>>>> If two different threads call setName concurrently, then if the 
>>>>> code was
>>>>> transformed as shown above, then it is possible to see
>>>>>
>>>>> T1:           this.name = new char["some longer string".length()];
>>>>> T2:           this.name = new char["a short string".length()];
>>>>> T1:           System.arraycopy( "some longer string", 0,
>>>>>                         this.name, 0, "some longer string".length());
>>>>>
>>>>> Which will result in an exception at best and memory corruption at 
>>>>> worse
>>>>> depending on how this.name is referenced.
>>>> I think you are right, the compiler must not issue a load that did not
>>>> exist in the source code (the compiler *is* aware that some other
>>>> thread may be changing the variable).
>>>>
>>>> The following transformation should be legal
>>>>
>>>>        public final void setName(String name) {
>>>>             char[]  tmp = new char[name.length()]
>>>>             this.name = tmp;
>>>>             System.arraycopy(name.value, 0, tmp, 0, name.length());
>>>>
>>>> Zhong Yu
>>>>
>>>>> Gregg Wonderly
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130318/f3565298/attachment-0001.html>

From gregg at cytetech.com  Mon Mar 18 16:00:41 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Mon, 18 Mar 2013 15:00:41 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51476583.2070102@oracle.com>
References: <CD67AFF1.22532%pete@guyatt.ca> <514259F1.2080604@oracle.com>
	<5142AE2B.3030203@cytetech.com> <51476583.2070102@oracle.com>
Message-ID: <51477269.5060502@cytetech.com>

On 3/18/2013 2:05 PM, oleksandr otenko wrote:
> Why Sequential Consistency, of all consistency requirements?

The rewrite provides a set of instructions, that when weaved by two or more 
threads, might (see below) cause "failure" of the VM.  That is the problem for 
me.  The single statement,

	 this.name = name.toCharArray();

being transformed as Nathan illustrated violates the "developers" belief in what 
he coded.  This statement, by observation, is threadsafe with respect to the 
assignment of a value to this.name, and would appear to have no chance of 
causing an exception.   When one looks at the code in String.toCharArray(), 
inlining those two lines of code in String.toCharArray(), would seem probable to 
me as well, as Nathan's illustration seemed to point out.

But I would never, ever guess that rather than use a temporary holder 
variable/register for the array allocated, that the value would instead be 
stored to this.name, before the arraycopy() call.

Now, I will concede that the arraycopy() might in fact use the exact value 
returned from the array allocation, instead of referencing this.name, but I 
don't know that.  Nathan's example was devoid of the exact semantics of how the 
arguments to arraycopy() were sourced.

If the code that actually would exist would look like

         char result[] = this.name = new char[value.length];
         System.arraycopy(value, 0, result, 0, value.length);

Then of course, all is well regarding an ArrayIndexOutOfBoundsException, because 
that wouldn't happen.

However, it would still be possible for getName() to be called with an array 
that was not completely populated with the actual 'value' string.

I just don't see how it's exciting or even comfortable to feel like a public API 
should require 'work' of this nature to use effectively.

I just don't understand how there is any advantage at all to assigning this.name 
before the array is filled.  If there is a temporary variable/register used so 
that arraycopy() can be called with that as the third argument, then the 
assignment can be called after that.  If, instead there is no temp 
variable/register used, then we may be back to the AIOOBE being the issue if 
this.name is the third argument to arraycopy().

Gregg Wonderly

 > As an example,
> Vector and Hashtable will return "consistent" results, but that doesn't
> eliminate races between get and put - what sort of consistency guarantee do you
> get?
>
> Also, bear in mind that 2 billion calls to Vector and Hashtable methods will
> create about 8 minutes of runtime overhead even on a single-threaded flow - no
> contention, just the cost of those instructions (compared to exactly the same
> test, but on a uniprocessor = JVM optimizes away the atomics on the locks).
> (this is not the latest HotSpot, but I think a useful rule of thumb) Maybe if
> you count all field mutations in your workflow you can see why non-volatile
> accesses is the default.
>
>
> Alex
>
>
> On 15/03/2013 05:14, Gregg Wonderly wrote:
>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>> I've inlined the name.toCharArray() and rearranged a few operations that JIT
>>> could do.  If another thread reads this.name between its creation and the end of
>>> arraycopy() then the thread will see a partially filled char[].
>>>
>>>      public final void setName(String name) {
>>>          this.name = new char[name.length()];
>>>          System.arraycopy(..., 0, result, 0, name.length());
>>>      }
>>
>> This rewrite/optimization doesn't seem to meet sequential consistency ordering
>> requirements.  I don't see how this could be considered SC since it creates a
>> different result (uninitialized value) then the way that the original source
>> was coded did not.
>>
>> If the JIT is actually doing this when concurrency is not detected
>> (non-volatile and no other happensBefore/fence), its no wonder we have so many
>> developers plagued with unexplainable racy program bugs.
>>
>> I thought the rewrite of while( nonvolatileBoolean ){} to if
>> (nonvolatileBoolean) { while (true ) {} } was bad enough of a mistake.  This
>> just wreaks of frustration for developers.
>>
>> How is this optimization more efficient, really?  Are we really so interested
>> in absolutely most efficient that we've given up on letting developers decide
>> when performance matters and then optimize to "incorrect" on their own terms?
>>
>> This kind optimization, if it is actually occurring is another example of
>> insidious change in program behavior...
>>
>> Gregg Wonderly
>>
>>>
>>> Nathan Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>> Architect | 602.333.9091
>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>> On 3/14/2013 4:03 PM, Pete Guyatt wrote:
>>>> I'm sure I'm missing something here but I don't quite see how the
>>>> character array can be scrambled.
>>>>
>>>> I can see how it "racy" and how an inconsistent write/read happens where a
>>>> thread calls setName -- could be the thread itself or another thread --
>>>> and another calls getName but from what I can see the assignment of the
>>>> new value to the name[] array is only going to happen after the call to
>>>> toCharArray completes. I thought this would be the case even with the JVM
>>>> performing some reordering of instructions.
>>>>
>>>> Would someone mind clarifying?
>>>>
>>>> Kind Regards,
>>>>
>>>> Pete
>>>>
>>>> On 2013-03-14 4:47 PM, "Zhong Yu"<zhong.j.yu at gmail.com> wrote:
>>>>
>>>>> On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
>>>>> <stanimir at riflexo.com>  wrote:
>>>>>> We already agree about being racy. Unline the clone() method 'name' has
>>>>>> no
>>>>>> critical applications (or at least shall not), so I presume it was never
>>>>>> considered a problem to warrant a volatile field.
>>>>> A non-volatile String field would be ok.
>>>>>
>>>>> Since getName() can be invoked by anyone at anytime, it's troubling
>>>>> that it could observe a scrambled name.
>>>>>
>>>>> Zhong Yu
>>>>>
>>>>>> On Thu, Mar 14, 2013 at 11:55 PM, Zhong Yu<zhong.j.yu at gmail.com> wrote:
>>>>>>> It's a common practice to modify thread names on the fly, for
>>>>>>> diagnosis purposes.
>>>>>>>
>>>>>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>>>>>>> <stanimir at riflexo.com>  wrote:
>>>>>>>> char[] name is usually initialized in the c-tor, in that case it'd be
>>>>>>>> fine.
>>>>>>>> Since the access to 'name' is racy to begin, the changes may not be
>>>>>>>> necessarily 'visible'.
>>>>>>>>
>>>>>>>> Stanimir
>>>>>>>>
>>>>>>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu<zhong.j.yu at gmail.com>
>>>>>>> wrote:
>>>>>>>>> java.lang.Thread
>>>>>>>>>
>>>>>>>>>      private char name[];
>>>>>>>>>
>>>>>>>>>      public final void setName(String name) {
>>>>>>>>>          checkAccess();
>>>>>>>>>          this.name = name.toCharArray();
>>>>>>>>>      }
>>>>>>>>>
>>>>>>>>>      public final String getName() {
>>>>>>>>>          return String.valueOf(name);
>>>>>>>>>      }
>>>>>>>>>
>>>>>>>>> On the surface, set/getName() are not correctly synchronized,
>>>>>>>>> getName() could observe a partially filled char array. What's the
>>>>>>>>> story here?
>>>>>>>>>
>>>>>>>>> Zhong Yu
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From gregg at cytetech.com  Mon Mar 18 16:32:35 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Mon, 18 Mar 2013 15:32:35 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <514770C2.3000700@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<FD424034-EF10-455E-8939-18D856236D45@cox.net>
	<51475213.3030509@oracle.com> <51476D10.5090001@cytetech.com>
	<514770C2.3000700@oracle.com>
Message-ID: <514779E3.70206@cytetech.com>

Right, and what I am saying, is that things that the developer has not "coded" 
should not happen.  Ordering of what they've coded should be all that is 
something for them to consider when looking for concurrency or race conditions.

Even if we had all ended up with massive EMSP (I did some research on this in 
college with some of the people who had worked on it, before this contract 
happened: 
http://www.thefreelibrary.com/AT%26T+WINS+$26.6+MILLION+NAVY+SOFTWARE+CONVERSION+CONTRACT-a012623510) 
processors with complete data flow analysis, there would still be SC with 
respect to each data item.  It can't be used before it exists.  Assigning 
this.name a value, before the value "exists" (not until arraycopy() returns does 
the value exist), is the problem.  There is no merit to any argument that says 
that the "software" should see such a state.  The developer did not code

this.name = new char[len];
System.arrayCopy( str.getBytes(), 0, this.name, 0, len );

Maybe you can help me understand how you see this optimization as a benefit? 
Having the developer need to check every single function in any API to make sure 
it's been fixed to keep this optimization from biting them is where I'm 
struggling.  Software that used to work, before this kind of optimization was 
made, could now, just break or behave oddly and just by looking at it, how would 
any average developer know?

Gregg Wonderly

On 3/18/2013 2:53 PM, oleksandr otenko wrote:
> I am pointing out this is a problem of concurrent programming and no one said it
> is a */simple/* extension of a single-threaded world. You need to know all
> effects to know how to combine them.
>
> Do you expect the thread name to show IP address (someone mentioned that?) and
> the stack trace to show the thread processing that same request? How do you
> combine these? So you'd need to come up with what a consistent state is first.
>
> This is easily illustrated by a example of a thread dump where no thread holds
> the lock, yet has a few threads blocked on it. All because by the time the
> thread dump for the lock owner was taken, it released the lock.
>
> Alex
>
> On 18/03/2013 19:37, Gregg Wonderly wrote:
>> So how does the developer know?  setName()/getName() have no visible contract
>> do they?
>>
>> Gregg
>>
>> On 3/18/2013 12:42 PM, oleksandr otenko wrote:
>>> It is hardly surprising that in order to combine effects you need to know what
>>> the effects are.
>>>
>>> So nothing special about having to know what setName does to properly
>>> synchronize.
>>>
>>> Alex
>>>
>>> On 15/03/2013 21:46, Gregg Wonderly wrote:
>>>> Yes, that transformation is legal, but it is also broken in the current design
>>>> of that class.  Because Thread.setName() is callable, and because there is no
>>>> other visible happensBefore with Thread.getName, the compiler can make the
>>>> decision to designate these methods as intra-thread use only.
>>>>
>>>> That is the problem.  Even if I subsequently introduce a "happens before" by
>>>> synchronizing or locking or something else, I have to know what the
>>>> implementation is, know how it is broken and only then can I actually expect
>>>> to achieve safe use of the provided API.
>>>>
>>>> I assert that this is completely and totally non-productive for software
>>>> developers.  The JDK and many other large Java applications/libraries are
>>>> broken in subtle ways, such as the missing "volatile" here. The compilers
>>>> rewrite of such code into non-thread safe segments when the developer(s) might
>>>> look at their code and say "that's racy, but safe, because I'll just use
>>>> "synchronized" around my calls, is changing the outcome that breaks SC.  Yes
>>>> SC is not supposed to be guaranteed in this case, but do JVM and hotspot
>>>> developers really feel like they are doing great and wonderful things, when
>>>> this kind of stuff is haunting everybody everywhere, because even the JDK has
>>>> not been "fixed"?
>>>>
>>>> Gregg Wonderly
>>>>
>>>> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>>
>>>>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
>>>>>> Nathan's example below is my issue...
>>>>>>
>>>>>>
>>>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>>>> Gregg,
>>>>>>>
>>>>>>> Gregg Wonderly writes:
>>>>>>>>
>>>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>>> operations that JIT
>>>>>>>>> could do.  If another thread reads this.name between its
>>>>>>>> creation and the end of
>>>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>>>
>>>>>>>>>       public final void setName(String name) {
>>>>>>>>>           this.name = new char[name.length()];
>>>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>>
>>>>>> If two different threads call setName concurrently, then if the code was
>>>>>> transformed as shown above, then it is possible to see
>>>>>>
>>>>>> T1:           this.name = new char["some longer string".length()];
>>>>>> T2:           this.name = new char["a short string".length()];
>>>>>> T1:           System.arraycopy( "some longer string", 0,
>>>>>>                         this.name, 0, "some longer string".length());
>>>>>>
>>>>>> Which will result in an exception at best and memory corruption at worse
>>>>>> depending on how this.name is referenced.
>>>>> I think you are right, the compiler must not issue a load that did not
>>>>> exist in the source code (the compiler *is* aware that some other
>>>>> thread may be changing the variable).
>>>>>
>>>>> The following transformation should be legal
>>>>>
>>>>>        public final void setName(String name) {
>>>>>             char[]  tmp = new char[name.length()]
>>>>>             this.name = tmp;
>>>>>             System.arraycopy(name.value, 0, tmp, 0, name.length());
>>>>>
>>>>> Zhong Yu
>>>>>
>>>>>> Gregg Wonderly
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From oleksandr.otenko at oracle.com  Mon Mar 18 16:50:09 2013
From: oleksandr.otenko at oracle.com (oleksandr otenko)
Date: Mon, 18 Mar 2013 20:50:09 +0000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51477269.5060502@cytetech.com>
References: <CD67AFF1.22532%pete@guyatt.ca> <514259F1.2080604@oracle.com>
	<5142AE2B.3030203@cytetech.com> <51476583.2070102@oracle.com>
	<51477269.5060502@cytetech.com>
Message-ID: <51477E01.70201@oracle.com>

On 18/03/2013 20:00, Gregg Wonderly wrote:
> On 3/18/2013 2:05 PM, oleksandr otenko wrote:
>> Why Sequential Consistency, of all consistency requirements?
>
> The rewrite provides a set of instructions, that when weaved by two or 
> more threads, might (see below) cause "failure" of the VM. That is the 
> problem for me.  The single statement,
>
>      this.name = name.toCharArray();

I must point out that there is nothing saying name.toCharArray() doesn't 
write anything to this.name during its operation before returning the 
result (which you happen to assign to this.name). For all it matters, if 
the modification is not visible by the caller, it may be happening in a 
single-threaded world.


>
> being transformed as Nathan illustrated violates the "developers" 
> belief in what he coded.  This statement, by observation, is 
> threadsafe with respect to the assignment of a value to this.name, and 

I don't see what makes it thread-safe, except when you look at the lines 
of code as atomic units of execution.


> would appear to have no chance of causing an exception.   When one 
> looks at the code in String.toCharArray(), inlining those two lines of 
> code in String.toCharArray(), would seem probable to me as well, as 
> Nathan's illustration seemed to point out.
>
> But I would never, ever guess that rather than use a temporary holder 
> variable/register for the array allocated, that the value would 
> instead be stored to this.name, before the arraycopy() call.
A temporary holder variable is in memory? Then you have one more write 
and read.

A plausible sequence of instructions: allocate, store address in EDI, 
use REP MOVSB to copy - EDI is ruined after copy. Why not store address 
to this.name before starting to copy?


>
> Now, I will concede that the arraycopy() might in fact use the exact 
> value returned from the array allocation, instead of referencing 
> this.name, but I don't know that. 

It doesn't matter. Getting used to the idea that correct single-threaded 
code is not always correct in a concurrent setting, helps.


> Nathan's example was devoid of the exact semantics of how the 
> arguments to arraycopy() were sourced.
>
> If the code that actually would exist would look like
>
>         char result[] = this.name = new char[value.length];
>         System.arraycopy(value, 0, result, 0, value.length);
>
> Then of course, all is well regarding an 
> ArrayIndexOutOfBoundsException, because that wouldn't happen.
It won't surprise me even if it throws ArrayIndexOutOfBoundsException. 
If you stop considering that all calls to setName are serialized, then 
you synchronize all calls to setName yourself.


>
> However, it would still be possible for getName() to be called with an 
> array that was not completely populated with the actual 'value' string.
If setName or toCharArray is a black box, then you don't know whether it 
sets this.name to any other values between the start and end of the 
setName call. If you deny all knowledge of how it is done, then you need 
to accept this is a valid way to do it.


Alex

PS I am only trying to demonstrate from a wider angle that certain types 
of guarantees are not possible, if you consider a function as a black 
box. For the system as a whole to be sequentially consistent, you need 
to consider the system as a whole. Use of Sequentially Consistent black 
boxes doesn't mean the result is sequentially consistent.

Whereas knowing what setName does is a pain, I don't think it is avoidable.


>
> I just don't see how it's exciting or even comfortable to feel like a 
> public API should require 'work' of this nature to use effectively.
>
> I just don't understand how there is any advantage at all to assigning 
> this.name before the array is filled.  If there is a temporary 
> variable/register used so that arraycopy() can be called with that as 
> the third argument, then the assignment can be called after that.  If, 
> instead there is no temp variable/register used, then we may be back 
> to the AIOOBE being the issue if this.name is the third argument to 
> arraycopy().
>
> Gregg Wonderly
>
> > As an example,
>> Vector and Hashtable will return "consistent" results, but that doesn't
>> eliminate races between get and put - what sort of consistency 
>> guarantee do you
>> get?
>>
>> Also, bear in mind that 2 billion calls to Vector and Hashtable 
>> methods will
>> create about 8 minutes of runtime overhead even on a single-threaded 
>> flow - no
>> contention, just the cost of those instructions (compared to exactly 
>> the same
>> test, but on a uniprocessor = JVM optimizes away the atomics on the 
>> locks).
>> (this is not the latest HotSpot, but I think a useful rule of thumb) 
>> Maybe if
>> you count all field mutations in your workflow you can see why 
>> non-volatile
>> accesses is the default.
>>
>>
>> Alex
>>
>>
>> On 15/03/2013 05:14, Gregg Wonderly wrote:
>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>> I've inlined the name.toCharArray() and rearranged a few operations 
>>>> that JIT
>>>> could do.  If another thread reads this.name between its creation 
>>>> and the end of
>>>> arraycopy() then the thread will see a partially filled char[].
>>>>
>>>>      public final void setName(String name) {
>>>>          this.name = new char[name.length()];
>>>>          System.arraycopy(..., 0, result, 0, name.length());
>>>>      }
>>>
>>> This rewrite/optimization doesn't seem to meet sequential 
>>> consistency ordering
>>> requirements.  I don't see how this could be considered SC since it 
>>> creates a
>>> different result (uninitialized value) then the way that the 
>>> original source
>>> was coded did not.
>>>
>>> If the JIT is actually doing this when concurrency is not detected
>>> (non-volatile and no other happensBefore/fence), its no wonder we 
>>> have so many
>>> developers plagued with unexplainable racy program bugs.
>>>
>>> I thought the rewrite of while( nonvolatileBoolean ){} to if
>>> (nonvolatileBoolean) { while (true ) {} } was bad enough of a 
>>> mistake.  This
>>> just wreaks of frustration for developers.
>>>
>>> How is this optimization more efficient, really?  Are we really so 
>>> interested
>>> in absolutely most efficient that we've given up on letting 
>>> developers decide
>>> when performance matters and then optimize to "incorrect" on their 
>>> own terms?
>>>
>>> This kind optimization, if it is actually occurring is another 
>>> example of
>>> insidious change in program behavior...
>>>
>>> Gregg Wonderly
>>>
>>>>
>>>> Nathan Reynolds 
>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>> Architect | 602.333.9091
>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>> On 3/14/2013 4:03 PM, Pete Guyatt wrote:
>>>>> I'm sure I'm missing something here but I don't quite see how the
>>>>> character array can be scrambled.
>>>>>
>>>>> I can see how it "racy" and how an inconsistent write/read happens 
>>>>> where a
>>>>> thread calls setName -- could be the thread itself or another 
>>>>> thread --
>>>>> and another calls getName but from what I can see the assignment 
>>>>> of the
>>>>> new value to the name[] array is only going to happen after the 
>>>>> call to
>>>>> toCharArray completes. I thought this would be the case even with 
>>>>> the JVM
>>>>> performing some reordering of instructions.
>>>>>
>>>>> Would someone mind clarifying?
>>>>>
>>>>> Kind Regards,
>>>>>
>>>>> Pete
>>>>>
>>>>> On 2013-03-14 4:47 PM, "Zhong Yu"<zhong.j.yu at gmail.com> wrote:
>>>>>
>>>>>> On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
>>>>>> <stanimir at riflexo.com>  wrote:
>>>>>>> We already agree about being racy. Unline the clone() method 
>>>>>>> 'name' has
>>>>>>> no
>>>>>>> critical applications (or at least shall not), so I presume it 
>>>>>>> was never
>>>>>>> considered a problem to warrant a volatile field.
>>>>>> A non-volatile String field would be ok.
>>>>>>
>>>>>> Since getName() can be invoked by anyone at anytime, it's troubling
>>>>>> that it could observe a scrambled name.
>>>>>>
>>>>>> Zhong Yu
>>>>>>
>>>>>>> On Thu, Mar 14, 2013 at 11:55 PM, Zhong Yu<zhong.j.yu at gmail.com> 
>>>>>>> wrote:
>>>>>>>> It's a common practice to modify thread names on the fly, for
>>>>>>>> diagnosis purposes.
>>>>>>>>
>>>>>>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>>>>>>>> <stanimir at riflexo.com>  wrote:
>>>>>>>>> char[] name is usually initialized in the c-tor, in that case 
>>>>>>>>> it'd be
>>>>>>>>> fine.
>>>>>>>>> Since the access to 'name' is racy to begin, the changes may 
>>>>>>>>> not be
>>>>>>>>> necessarily 'visible'.
>>>>>>>>>
>>>>>>>>> Stanimir
>>>>>>>>>
>>>>>>>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu<zhong.j.yu at gmail.com>
>>>>>>>> wrote:
>>>>>>>>>> java.lang.Thread
>>>>>>>>>>
>>>>>>>>>>      private char name[];
>>>>>>>>>>
>>>>>>>>>>      public final void setName(String name) {
>>>>>>>>>>          checkAccess();
>>>>>>>>>>          this.name = name.toCharArray();
>>>>>>>>>>      }
>>>>>>>>>>
>>>>>>>>>>      public final String getName() {
>>>>>>>>>>          return String.valueOf(name);
>>>>>>>>>>      }
>>>>>>>>>>
>>>>>>>>>> On the surface, set/getName() are not correctly synchronized,
>>>>>>>>>> getName() could observe a partially filled char array. What's 
>>>>>>>>>> the
>>>>>>>>>> story here?
>>>>>>>>>>
>>>>>>>>>> Zhong Yu
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>
>>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>


From stanimir at riflexo.com  Mon Mar 18 17:39:59 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Mon, 18 Mar 2013 23:39:59 +0200
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51474050.8000305@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCGEDKJLAA.davidcholmes@aapt.net.au>
	<5143DB4B.5070505@cytetech.com> <51474050.8000305@oracle.com>
Message-ID: <CAEJX8ooBZAj9e2adoOiAt8jL-nOkQZWF4Y_OG+834eX4HEx6TA@mail.gmail.com>

On Mon, Mar 18, 2013 at 6:26 PM, Nathan Reynolds <nathan.reynolds at oracle.com
> wrote:

>  > Maybe it's time to open src.zip and start writing bug reports.  I just
> really don't think I'll enjoy doing that, but I suppose no one would...
>
> That would be awesome!  You will learn a lot about the JDK and become an
> expert on it.
>
...speaking of which. Becoming an expert is the easy part, filing bug
reports and seeing them lingering for years or decades aint fun even if
they are simple to fix.
Here is a nasty bug in sun.net.www.protocol.jar.JarFileFactory ::
close(JarFile jarFile). The bug is far more severe than Thread.getName().

The method should be synchronized(this) (or just have the sync bit)
Otherwise it accesses the HashMaps in absolute thread-unsafe manner + there
is a race between both operation as bonus.
Now closing JarFile I had to manually synchronize to the instance.
Closing is very important for deploy/undeploying jar files and accessing
them through URL. Accessing the a modified jar/zip results may result into
the notorious (Won't Fix) JVM crash
http://bugs.sun.com/view_bug.do?bug_id=4425695
Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)
J  java.util.zip.ZipFile.getEntry(JLjava/lang/String;Z)J
J
sun.misc.URLClassPath$JarLoader.getResource(Ljava/lang/String;Z)Lsun/misc/Resource;
J  java.net.URLClassLoader$1.run()Ljava/lang/Object;


Stanimir



>
> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>| Architect |
> 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>  On 3/15/2013 7:39 PM, Gregg Wonderly wrote:
>
> On 3/15/2013 6:27 PM, David Holmes wrote:
>
> Gregg,
>
> The sky is not falling, the end of the world is not nigh. There are
> thousands of non-thread-safe methods in the JDK libraries, this is just an
> example. This might be a surprising example, but I expect there was little
> consideration given to dynamic thread re-naming. You may ineed get an
> exception because of the possible races - so be it.
>
>
> I am not sure of how many lines of code you have written in applications
> running in the wild David, and I don't want to diminish anything about what
> you know and/or have experienced.  I can tell you for sure, that I am
> constantly frustrated by these kinds of APIs with neither specified nor
> correct (in some potential cases) concurrency and having people involved in
> the development of Java tell me, the user and customer, that everything is
> just fine.
>
> I really want my software to function correctly and run unfettered,
> forever, without any "odd" behavior.  My software is involved in
> applications which need correct results each and every time.  I can not
> live with any chance that something will sometimes be wrong or may not
> complete for unexplainable or correctable reasons.
>
> I just can not understand how the possibility of "wrong", or "incomplete"
> or "unpredictable" results can feel acceptable.
>
> To mediate this issue in my software, for some time now, I've lived by the
> rule, all variables must be declared either volatile or final.  I've
> mentioned that here before, and I recall that I was sort of pushed back on,
> saying that was not really necessary.  It's cases like this where an API
> permits something to happen that is incorrect for its implementation of
> concurrent access that really highlight the reasons for me.
>
> Yes, volatile doesn't result in 'non-race' execution.  But, it does keep
> the compiler for doing things that this reordering might do which would
> cause software to produce unexpected results in the form of a
> RuntimeException.  I'm not up for surrounding every statement with a
> try{}catch.
>
> Only when performance becomes a consideration, do I start to revisit the
> volatile declarations.  I've not really had to do very much removing of
> volatile.  For simple values, I'd either have synchronized setter/getter or
> volatile already anyway.
>
> We can file a bug and make them synchronized or whaetver.
>
>
> I know this seems like an over-the-top reaction, but it's just so
> frustrating to keep having to deal with things like this in my software,
> and everytime I turn around, there's another something like this that
> highlights something that I've overlooked or had not expected to possibly
> be an issue.  My trust in the JDK libraries (except for
> java.util.concurrent, which Doug has been flawlessly open and considerate
> of developers needs in my opinion) is waning...
>
> Maybe it's time to open src.zip and start writing bug reports.  I just
> really don't think I'll enjoy doing that, but I suppose no one would...
>
> Gregg Wonderly
>
> David
>
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu<concurrency-interest-bounces at cs.oswego.edu>]On
> Behalf Of Gregg
> Wonderly
> Sent: Saturday, 16 March 2013 7:46 AM
> To: Zhong Yu
> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org;
> gregg.wonderly at pobox.com
> Subject: Re: [concurrency-interest] Thread safety of Thread.getName()
>
>
> Yes, that transformation is legal, but it is also broken in the
> current design of that class.  Because Thread.setName() is
> callable, and because there is no other visible happensBefore
> with Thread.getName, the compiler can make the decision to
> designate these methods as intra-thread use only.
>
> That is the problem.  Even if I subsequently introduce a "happens
> before" by synchronizing or locking or something else, I have to
> know what the implementation is, know how it is broken and only
> then can I actually expect to achieve safe use of the provided API.
>
> I assert that this is completely and totally non-productive for
> software developers.  The JDK and many other large Java
> applications/libraries are broken in subtle ways, such as the
> missing "volatile" here.   The compilers rewrite of such code
> into non-thread safe segments when the developer(s) might look at
> their code and say "that's racy, but safe, because I'll just use
> "synchronized" around my calls, is changing the outcome that
> breaks SC.  Yes SC is not supposed to be guaranteed in this case,
> but do JVM and hotspot developers really feel like they are doing
> great and wonderful things, when this kind of stuff is haunting
> everybody everywhere, because even the JDK has not been "fixed"?
>
> Gregg Wonderly
>
> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com><zhong.j.yu at gmail.com>wrote:
>
> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly
>
> <gregg at cytetech.com> <gregg at cytetech.com> wrote:
>
> Nathan's example below is my issue...
>
>
> On 3/15/2013 12:29 AM, David Holmes wrote:
>
>
> Gregg,
>
> Gregg Wonderly writes:
>
>
>
> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>
>
> I've inlined the name.toCharArray() and rearranged a few
>
>
> operations that JIT
>
>
> could do.  If another thread reads this.name between its
>
>
> creation and the end of
>
>
> arraycopy() then the thread will see a partially filled char[].
>
>       public final void setName(String name) {
>           this.name = new char[name.length()];
>           System.arraycopy(..., 0, result, 0, name.length());
>
>
>
> If two different threads call setName concurrently, then if
>
>  the code was
>
> transformed as shown above, then it is possible to see
>
> T1:           this.name = new char["some longer string".length()];
> T2:           this.name = new char["a short string".length()];
> T1:           System.arraycopy( "some longer string", 0,
>                         this.name, 0, "some longer string".length());
>
> Which will result in an exception at best and memory
>
>  corruption at worse
>
> depending on how this.name is referenced.
>
>
> I think you are right, the compiler must not issue a load that did not
> exist in the source code (the compiler *is* aware that some other
> thread may be changing the variable).
>
> The following transformation should be legal
>
>        public final void setName(String name) {
>             char[]  tmp = new char[name.length()]
>             this.name = tmp;
>             System.arraycopy(name.value, 0, tmp, 0, name.length());
>
> Zhong Yu
>
> Gregg Wonderly
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> -----
> No virus found in this message.
> Checked by AVG - www.avg.com
> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
> Internal Virus Database is out of date.
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130318/9670b1a1/attachment-0001.html>

From nathan.reynolds at oracle.com  Mon Mar 18 17:40:29 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 18 Mar 2013 14:40:29 -0700
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <514779E3.70206@cytetech.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<FD424034-EF10-455E-8939-18D856236D45@cox.net>
	<51475213.3030509@oracle.com> <51476D10.5090001@cytetech.com>
	<514770C2.3000700@oracle.com> <514779E3.70206@cytetech.com>
Message-ID: <514789CD.508@oracle.com>

I agree with you as well as many others.  This is why the final keyword 
was enhanced with Java Memory Model.

I also agree that Thread.setName() shouldn't because of JIT cause an 
exception and shouldn't show a corrupted name.  It won't as long as 
getName and setName are called by the same thread.

The problem comes into play with concurrency.  The getName and setName 
APIs were not designed to be concurrently accessed.  Many parts of the 
JDK were not designed to be concurrently accessed. In fact, many parts 
of the JDK were written before we even had the Java Memory Model.

I think the safest assumption is to assume that unless documented, the 
API can not be accessed concurrently.  If an average programer wants to 
access it concurrently, then they better wrap it in a lock.  If a 
pressing need arises to make the API concurrent, then an enhancement 
request should be filed.  An expert will analyze the code and either 
update the documentation saying it can be accessed concurrently or fix 
the code and then document.

As for being able to reorder operations, this has significant 
performance benefit.  Much of the performance progress in the past 10 
years both in software and hardware has come from being more aggressive 
at reordering.  For example, loop hoisting is extremely important for 
optimizing loops and can get huge benefits.  This one optimization has 
bitten many on this list.  They didn't realize that they needed to 
declare the field as volatile.  As the stuff underneath us gets more 
aggressive, we are going to have to communicate better in our code as to 
what kinds of things are allowed to be done by underlying machinery 
(e.g. volatile).

Here's another reordering example.  A memory fence on a core causes a 
huge stall.  It basically clears the execution pipeline since the 
subsequent data loads have to wait.  Cores need to be able to reorder 
instructions (loads) across memory fences.  A core could speculatively 
do the load and monitor the cache line.  If no one else in the system 
touches the cache line before the memory fence is finished, then the 
speculative load just prevented a stall.  If another core touches the 
cache line, then the speculation is thrown out and the instructions are 
restarted.  The core's performance is either on par or still ahead of 
stalling. The great benefit of this is that the memory fence still 
appears to software to be enforced yet the core is able to perform well 
in spite of its existence.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 3/18/2013 1:32 PM, Gregg Wonderly wrote:
> Right, and what I am saying, is that things that the developer has not 
> "coded" should not happen.  Ordering of what they've coded should be 
> all that is something for them to consider when looking for 
> concurrency or race conditions.
>
> Even if we had all ended up with massive EMSP (I did some research on 
> this in college with some of the people who had worked on it, before 
> this contract happened: 
> http://www.thefreelibrary.com/AT%26T+WINS+$26.6+MILLION+NAVY+SOFTWARE+CONVERSION+CONTRACT-a012623510) 
> processors with complete data flow analysis, there would still be SC 
> with respect to each data item.  It can't be used before it exists.  
> Assigning this.name a value, before the value "exists" (not until 
> arraycopy() returns does the value exist), is the problem.  There is 
> no merit to any argument that says that the "software" should see such 
> a state.  The developer did not code
>
> this.name = new char[len];
> System.arrayCopy( str.getBytes(), 0, this.name, 0, len );
>
> Maybe you can help me understand how you see this optimization as a 
> benefit? Having the developer need to check every single function in 
> any API to make sure it's been fixed to keep this optimization from 
> biting them is where I'm struggling.  Software that used to work, 
> before this kind of optimization was made, could now, just break or 
> behave oddly and just by looking at it, how would any average 
> developer know?
>
> Gregg Wonderly
>
> On 3/18/2013 2:53 PM, oleksandr otenko wrote:
>> I am pointing out this is a problem of concurrent programming and no 
>> one said it
>> is a */simple/* extension of a single-threaded world. You need to 
>> know all
>> effects to know how to combine them.
>>
>> Do you expect the thread name to show IP address (someone mentioned 
>> that?) and
>> the stack trace to show the thread processing that same request? How 
>> do you
>> combine these? So you'd need to come up with what a consistent state 
>> is first.
>>
>> This is easily illustrated by a example of a thread dump where no 
>> thread holds
>> the lock, yet has a few threads blocked on it. All because by the 
>> time the
>> thread dump for the lock owner was taken, it released the lock.
>>
>> Alex
>>
>> On 18/03/2013 19:37, Gregg Wonderly wrote:
>>> So how does the developer know? setName()/getName() have no visible 
>>> contract
>>> do they?
>>>
>>> Gregg
>>>
>>> On 3/18/2013 12:42 PM, oleksandr otenko wrote:
>>>> It is hardly surprising that in order to combine effects you need 
>>>> to know what
>>>> the effects are.
>>>>
>>>> So nothing special about having to know what setName does to properly
>>>> synchronize.
>>>>
>>>> Alex
>>>>
>>>> On 15/03/2013 21:46, Gregg Wonderly wrote:
>>>>> Yes, that transformation is legal, but it is also broken in the 
>>>>> current design
>>>>> of that class.  Because Thread.setName() is callable, and because 
>>>>> there is no
>>>>> other visible happensBefore with Thread.getName, the compiler can 
>>>>> make the
>>>>> decision to designate these methods as intra-thread use only.
>>>>>
>>>>> That is the problem.  Even if I subsequently introduce a "happens 
>>>>> before" by
>>>>> synchronizing or locking or something else, I have to know what the
>>>>> implementation is, know how it is broken and only then can I 
>>>>> actually expect
>>>>> to achieve safe use of the provided API.
>>>>>
>>>>> I assert that this is completely and totally non-productive for 
>>>>> software
>>>>> developers.  The JDK and many other large Java 
>>>>> applications/libraries are
>>>>> broken in subtle ways, such as the missing "volatile" here. The 
>>>>> compilers
>>>>> rewrite of such code into non-thread safe segments when the 
>>>>> developer(s) might
>>>>> look at their code and say "that's racy, but safe, because I'll 
>>>>> just use
>>>>> "synchronized" around my calls, is changing the outcome that 
>>>>> breaks SC.  Yes
>>>>> SC is not supposed to be guaranteed in this case, but do JVM and 
>>>>> hotspot
>>>>> developers really feel like they are doing great and wonderful 
>>>>> things, when
>>>>> this kind of stuff is haunting everybody everywhere, because even 
>>>>> the JDK has
>>>>> not been "fixed"?
>>>>>
>>>>> Gregg Wonderly
>>>>>
>>>>> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>>>
>>>>>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly 
>>>>>> <gregg at cytetech.com> wrote:
>>>>>>> Nathan's example below is my issue...
>>>>>>>
>>>>>>>
>>>>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>>>>> Gregg,
>>>>>>>>
>>>>>>>> Gregg Wonderly writes:
>>>>>>>>>
>>>>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>>>> operations that JIT
>>>>>>>>>> could do.  If another thread reads this.name between its
>>>>>>>>> creation and the end of
>>>>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>>>>
>>>>>>>>>>       public final void setName(String name) {
>>>>>>>>>>           this.name = new char[name.length()];
>>>>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>>>
>>>>>>> If two different threads call setName concurrently, then if the 
>>>>>>> code was
>>>>>>> transformed as shown above, then it is possible to see
>>>>>>>
>>>>>>> T1:           this.name = new char["some longer string".length()];
>>>>>>> T2:           this.name = new char["a short string".length()];
>>>>>>> T1:           System.arraycopy( "some longer string", 0,
>>>>>>>                         this.name, 0, "some longer 
>>>>>>> string".length());
>>>>>>>
>>>>>>> Which will result in an exception at best and memory corruption 
>>>>>>> at worse
>>>>>>> depending on how this.name is referenced.
>>>>>> I think you are right, the compiler must not issue a load that 
>>>>>> did not
>>>>>> exist in the source code (the compiler *is* aware that some other
>>>>>> thread may be changing the variable).
>>>>>>
>>>>>> The following transformation should be legal
>>>>>>
>>>>>>        public final void setName(String name) {
>>>>>>             char[]  tmp = new char[name.length()]
>>>>>>             this.name = tmp;
>>>>>>             System.arraycopy(name.value, 0, tmp, 0, name.length());
>>>>>>
>>>>>> Zhong Yu
>>>>>>
>>>>>>> Gregg Wonderly
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130318/82c4740a/attachment-0001.html>

From nathan.reynolds at oracle.com  Mon Mar 18 17:56:11 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 18 Mar 2013 14:56:11 -0700
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CAEJX8ooBZAj9e2adoOiAt8jL-nOkQZWF4Y_OG+834eX4HEx6TA@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEDKJLAA.davidcholmes@aapt.net.au>
	<5143DB4B.5070505@cytetech.com> <51474050.8000305@oracle.com>
	<CAEJX8ooBZAj9e2adoOiAt8jL-nOkQZWF4Y_OG+834eX4HEx6TA@mail.gmail.com>
Message-ID: <51478D7B.5070201@oracle.com>

 > filing bug reports and seeing them lingering for years or decades 
aint fun

Yeah, I am in that same boat on several bugs.  In fact, someone on my 
team did an optimization to reduce heap usage.  It saved about 10% for a 
few workloads.  It turns out that someone else had the same idea 5 years 
ago and even blogged about it!

I guess it is a bandwidth problem.  There are only so many engineers in 
Oracle.  They do really good work and solve some really troublesome 
problems.  However, we have 9-10 million Java programmers in the world!  
There is no way any 1 company could service all of the bugs from 9 
million programmers.  It really is up to the Java programmers to fix the 
bugs.  So, I guess I should submit fixes for my own bugs.  That's the 
only way I can ensure they get fixed.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 3/18/2013 2:39 PM, Stanimir Simeonoff wrote:
>
> On Mon, Mar 18, 2013 at 6:26 PM, Nathan Reynolds 
> <nathan.reynolds at oracle.com <mailto:nathan.reynolds at oracle.com>> wrote:
>
>     > Maybe it's time to open src.zip and start writing bug reports. 
>     I just really don't think I'll enjoy doing that, but I suppose no
>     one would...
>
>     That would be awesome!  You will learn a lot about the JDK and
>     become an expert on it.
>
> ...speaking of which. Becoming an expert is the easy part, filing bug 
> reports and seeing them lingering for years or decades aint fun even 
> if they are simple to fix.
> Here is a nasty bug in sun.net.www.protocol.jar.JarFileFactory :: 
> close(JarFile jarFile). The bug is far more severe than Thread.getName().
>
> The method should be synchronized(this) (or just have the sync bit) 
> Otherwise it accesses the HashMaps in absolute thread-unsafe manner + 
> there is a race between both operation as bonus.
> Now closing JarFile I had to manually synchronize to the instance.
> Closing is very important for deploy/undeploying jar files and 
> accessing them through URL. Accessing the a modified jar/zip results 
> may result into the notorious (Won't Fix) JVM crash 
> http://bugs.sun.com/view_bug.do?bug_id=4425695
> Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)
> J java.util.zip.ZipFile.getEntry(JLjava/lang/String;Z)J
> J 
> sun.misc.URLClassPath$JarLoader.getResource(Ljava/lang/String;Z)Lsun/misc/Resource;
> J java.net.URLClassLoader$1.run()Ljava/lang/Object;
>
>
> Stanimir
>
>
>
>
>     Nathan Reynolds
>     <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>     Architect | 602.333.9091 <tel:602.333.9091>
>     Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>     On 3/15/2013 7:39 PM, Gregg Wonderly wrote:
>>     On 3/15/2013 6:27 PM, David Holmes wrote:
>>>     Gregg,
>>>
>>>     The sky is not falling, the end of the world is not nigh. There are
>>>     thousands of non-thread-safe methods in the JDK libraries, this
>>>     is just an
>>>     example. This might be a surprising example, but I expect there
>>>     was little
>>>     consideration given to dynamic thread re-naming. You may ineed
>>>     get an
>>>     exception because of the possible races - so be it.
>>
>>     I am not sure of how many lines of code you have written in
>>     applications running in the wild David, and I don't want to
>>     diminish anything about what you know and/or have experienced.  I
>>     can tell you for sure, that I am constantly frustrated by these
>>     kinds of APIs with neither specified nor correct (in some
>>     potential cases) concurrency and having people involved in the
>>     development of Java tell me, the user and customer, that
>>     everything is just fine.
>>
>>     I really want my software to function correctly and run
>>     unfettered, forever, without any "odd" behavior. My software is
>>     involved in applications which need correct results each and
>>     every time.  I can not live with any chance that something will
>>     sometimes be wrong or may not complete for unexplainable or
>>     correctable reasons.
>>
>>     I just can not understand how the possibility of "wrong", or
>>     "incomplete" or "unpredictable" results can feel acceptable.
>>
>>     To mediate this issue in my software, for some time now, I've
>>     lived by the rule, all variables must be declared either volatile
>>     or final.  I've mentioned that here before, and I recall that I
>>     was sort of pushed back on, saying that was not really necessary.
>>     It's cases like this where an API permits something to happen
>>     that is incorrect for its implementation of concurrent access
>>     that really highlight the reasons for me.
>>
>>     Yes, volatile doesn't result in 'non-race' execution. But, it
>>     does keep the compiler for doing things that this reordering
>>     might do which would cause software to produce unexpected results
>>     in the form of a RuntimeException.  I'm not up for surrounding
>>     every statement with a try{}catch.
>>
>>     Only when performance becomes a consideration, do I start to
>>     revisit the volatile declarations.  I've not really had to do
>>     very much removing of volatile.  For simple values, I'd either
>>     have synchronized setter/getter or volatile already anyway.
>>
>>>     We can file a bug and make them synchronized or whaetver.
>>
>>     I know this seems like an over-the-top reaction, but it's just so
>>     frustrating to keep having to deal with things like this in my
>>     software, and everytime I turn around, there's another something
>>     like this that highlights something that I've overlooked or had
>>     not expected to possibly be an issue.  My trust in the JDK
>>     libraries (except for java.util.concurrent, which Doug has been
>>     flawlessly open and considerate of developers needs in my
>>     opinion) is waning...
>>
>>     Maybe it's time to open src.zip and start writing bug reports.  I
>>     just really don't think I'll enjoy doing that, but I suppose no
>>     one would...
>>
>>     Gregg Wonderly
>>
>>>     David
>>>
>>>>     -----Original Message-----
>>>>     From: concurrency-interest-bounces at cs.oswego.edu
>>>>     <mailto:concurrency-interest-bounces at cs.oswego.edu>
>>>>     [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
>>>>     Gregg
>>>>     Wonderly
>>>>     Sent: Saturday, 16 March 2013 7:46 AM
>>>>     To: Zhong Yu
>>>>     Cc: concurrency-interest at cs.oswego.edu
>>>>     <mailto:concurrency-interest at cs.oswego.edu>; dholmes at ieee.org
>>>>     <mailto:dholmes at ieee.org>;
>>>>     gregg.wonderly at pobox.com <mailto:gregg.wonderly at pobox.com>
>>>>     Subject: Re: [concurrency-interest] Thread safety of
>>>>     Thread.getName()
>>>>
>>>>
>>>>     Yes, that transformation is legal, but it is also broken in the
>>>>     current design of that class.  Because Thread.setName() is
>>>>     callable, and because there is no other visible happensBefore
>>>>     with Thread.getName, the compiler can make the decision to
>>>>     designate these methods as intra-thread use only.
>>>>
>>>>     That is the problem.  Even if I subsequently introduce a "happens
>>>>     before" by synchronizing or locking or something else, I have to
>>>>     know what the implementation is, know how it is broken and only
>>>>     then can I actually expect to achieve safe use of the provided
>>>>     API.
>>>>
>>>>     I assert that this is completely and totally non-productive for
>>>>     software developers.  The JDK and many other large Java
>>>>     applications/libraries are broken in subtle ways, such as the
>>>>     missing "volatile" here.   The compilers rewrite of such code
>>>>     into non-thread safe segments when the developer(s) might look at
>>>>     their code and say "that's racy, but safe, because I'll just use
>>>>     "synchronized" around my calls, is changing the outcome that
>>>>     breaks SC.  Yes SC is not supposed to be guaranteed in this case,
>>>>     but do JVM and hotspot developers really feel like they are doing
>>>>     great and wonderful things, when this kind of stuff is haunting
>>>>     everybody everywhere, because even the JDK has not been "fixed"?
>>>>
>>>>     Gregg Wonderly
>>>>
>>>>     On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com>
>>>>     <mailto:zhong.j.yu at gmail.com> wrote:
>>>>
>>>>>     On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly
>>>>     <gregg at cytetech.com> <mailto:gregg at cytetech.com> wrote:
>>>>>>     Nathan's example below is my issue...
>>>>>>
>>>>>>
>>>>>>     On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>>>>
>>>>>>>     Gregg,
>>>>>>>
>>>>>>>     Gregg Wonderly writes:
>>>>>>>>
>>>>>>>>
>>>>>>>>     On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>>>>
>>>>>>>>>     I've inlined the name.toCharArray() and rearranged a few
>>>>>>>>
>>>>>>>>     operations that JIT
>>>>>>>>>
>>>>>>>>>     could do.  If another thread reads this.name
>>>>>>>>>     <http://this.name> between its
>>>>>>>>
>>>>>>>>     creation and the end of
>>>>>>>>>
>>>>>>>>>     arraycopy() then the thread will see a partially filled
>>>>>>>>>     char[].
>>>>>>>>>
>>>>>>>>>           public final void setName(String name) {
>>>>>>>>>     this.name <http://this.name> = new char[name.length()];
>>>>>>>>>               System.arraycopy(..., 0, result, 0, name.length());
>>>>>>
>>>>>>
>>>>>>     If two different threads call setName concurrently, then if
>>>>     the code was
>>>>>>     transformed as shown above, then it is possible to see
>>>>>>
>>>>>>     T1: this.name <http://this.name> = new char["some longer
>>>>>>     string".length()];
>>>>>>     T2: this.name <http://this.name> = new char["a short
>>>>>>     string".length()];
>>>>>>     T1:           System.arraycopy( "some longer string", 0,
>>>>>>     this.name <http://this.name>, 0, "some longer string".length());
>>>>>>
>>>>>>     Which will result in an exception at best and memory
>>>>     corruption at worse
>>>>>>     depending on how this.name <http://this.name> is referenced.
>>>>>
>>>>>     I think you are right, the compiler must not issue a load that
>>>>>     did not
>>>>>     exist in the source code (the compiler *is* aware that some other
>>>>>     thread may be changing the variable).
>>>>>
>>>>>     The following transformation should be legal
>>>>>
>>>>>            public final void setName(String name) {
>>>>>                 char[]  tmp = new char[name.length()]
>>>>>     this.name <http://this.name> = tmp;
>>>>>                 System.arraycopy(name.value, 0, tmp, 0,
>>>>>     name.length());
>>>>>
>>>>>     Zhong Yu
>>>>>
>>>>>>     Gregg Wonderly
>>>>>>
>>>>>>     _______________________________________________
>>>>>>     Concurrency-interest mailing list
>>>>>>     Concurrency-interest at cs.oswego.edu
>>>>>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>     _______________________________________________
>>>>>     Concurrency-interest mailing list
>>>>>     Concurrency-interest at cs.oswego.edu
>>>>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>     _______________________________________________
>>>>     Concurrency-interest mailing list
>>>>     Concurrency-interest at cs.oswego.edu
>>>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>     -----
>>>>     No virus found in this message.
>>>>     Checked by AVG - www.avg.com <http://www.avg.com>
>>>>     Version: 2013.0.2904 / Virus Database: 2641/6158 - Release
>>>>     Date: 03/08/13
>>>>     Internal Virus Database is out of date.
>>>>
>>>
>>>     _______________________________________________
>>>     Concurrency-interest mailing list
>>>     Concurrency-interest at cs.oswego.edu
>>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu
>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130318/1f9a0360/attachment-0001.html>

From cheremin at gmail.com  Mon Mar 18 17:56:37 2013
From: cheremin at gmail.com (Ruslan Cheremin)
Date: Tue, 19 Mar 2013 01:56:37 +0400
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <514789CD.508@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<FD424034-EF10-455E-8939-18D856236D45@cox.net>
	<51475213.3030509@oracle.com> <51476D10.5090001@cytetech.com>
	<514770C2.3000700@oracle.com> <514779E3.70206@cytetech.com>
	<514789CD.508@oracle.com>
Message-ID: <CAOwENiJvDNf_-rOuUanRfGfO4_E81FcMuJBi-mN_8vsh8pobcA@mail.gmail.com>

>A core could speculatively do the load and monitor
> the cache line.  If no one else in the system touches the cache line before
> the memory fence is finished, then the speculative load just prevented a
> stall.  If another core touches the cache line, then the speculation is
> thrown out and the instructions are restarted.  The core's performance is
> either on par or still ahead of stalling.  The great benefit of this is that
> the memory fence still appears to software to be enforced yet the core is
> able to perform well in spite of its existence.

It is very interesting -- has it actually implemented in hardware?
I've heard many times about "fence is not required to be implemented
as store/load buffers flush, but it is actually implemented this way
in commodity CPUs". Who is the hero I should glorify for such great
job?



> Nathan Reynolds | Architect | 602.333.9091
> Oracle PSR Engineering | Server Technology
> On 3/18/2013 1:32 PM, Gregg Wonderly wrote:
>
> Right, and what I am saying, is that things that the developer has not
> "coded" should not happen.  Ordering of what they've coded should be all
> that is something for them to consider when looking for concurrency or race
> conditions.
>
> Even if we had all ended up with massive EMSP (I did some research on this
> in college with some of the people who had worked on it, before this
> contract happened:
> http://www.thefreelibrary.com/AT%26T+WINS+$26.6+MILLION+NAVY+SOFTWARE+CONVERSION+CONTRACT-a012623510)
> processors with complete data flow analysis, there would still be SC with
> respect to each data item.  It can't be used before it exists.  Assigning
> this.name a value, before the value "exists" (not until arraycopy() returns
> does the value exist), is the problem.  There is no merit to any argument
> that says that the "software" should see such a state.  The developer did
> not code
>
> this.name = new char[len];
> System.arrayCopy( str.getBytes(), 0, this.name, 0, len );
>
> Maybe you can help me understand how you see this optimization as a benefit?
> Having the developer need to check every single function in any API to make
> sure it's been fixed to keep this optimization from biting them is where I'm
> struggling.  Software that used to work, before this kind of optimization
> was made, could now, just break or behave oddly and just by looking at it,
> how would any average developer know?
>
> Gregg Wonderly
>
> On 3/18/2013 2:53 PM, oleksandr otenko wrote:
>
> I am pointing out this is a problem of concurrent programming and no one
> said it
> is a */simple/* extension of a single-threaded world. You need to know all
> effects to know how to combine them.
>
> Do you expect the thread name to show IP address (someone mentioned that?)
> and
> the stack trace to show the thread processing that same request? How do you
> combine these? So you'd need to come up with what a consistent state is
> first.
>
> This is easily illustrated by a example of a thread dump where no thread
> holds
> the lock, yet has a few threads blocked on it. All because by the time the
> thread dump for the lock owner was taken, it released the lock.
>
> Alex
>
> On 18/03/2013 19:37, Gregg Wonderly wrote:
>
> So how does the developer know?  setName()/getName() have no visible
> contract
> do they?
>
> Gregg
>
> On 3/18/2013 12:42 PM, oleksandr otenko wrote:
>
> It is hardly surprising that in order to combine effects you need to know
> what
> the effects are.
>
> So nothing special about having to know what setName does to properly
> synchronize.
>
> Alex
>
> On 15/03/2013 21:46, Gregg Wonderly wrote:
>
> Yes, that transformation is legal, but it is also broken in the current
> design
> of that class.  Because Thread.setName() is callable, and because there is
> no
> other visible happensBefore with Thread.getName, the compiler can make the
> decision to designate these methods as intra-thread use only.
>
> That is the problem.  Even if I subsequently introduce a "happens before" by
> synchronizing or locking or something else, I have to know what the
> implementation is, know how it is broken and only then can I actually expect
> to achieve safe use of the provided API.
>
> I assert that this is completely and totally non-productive for software
> developers.  The JDK and many other large Java applications/libraries are
> broken in subtle ways, such as the missing "volatile" here. The compilers
> rewrite of such code into non-thread safe segments when the developer(s)
> might
> look at their code and say "that's racy, but safe, because I'll just use
> "synchronized" around my calls, is changing the outcome that breaks SC.  Yes
> SC is not supposed to be guaranteed in this case, but do JVM and hotspot
> developers really feel like they are doing great and wonderful things, when
> this kind of stuff is haunting everybody everywhere, because even the JDK
> has
> not been "fixed"?
>
> Gregg Wonderly
>
> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>
> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
>
> Nathan's example below is my issue...
>
>
> On 3/15/2013 12:29 AM, David Holmes wrote:
>
> Gregg,
>
> Gregg Wonderly writes:
>
>
> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>
> I've inlined the name.toCharArray() and rearranged a few
>
> operations that JIT
>
> could do.  If another thread reads this.name between its
>
> creation and the end of
>
> arraycopy() then the thread will see a partially filled char[].
>
>       public final void setName(String name) {
>           this.name = new char[name.length()];
>           System.arraycopy(..., 0, result, 0, name.length());
>
>
> If two different threads call setName concurrently, then if the code was
> transformed as shown above, then it is possible to see
>
> T1:           this.name = new char["some longer string".length()];
> T2:           this.name = new char["a short string".length()];
> T1:           System.arraycopy( "some longer string", 0,
>                         this.name, 0, "some longer string".length());
>
> Which will result in an exception at best and memory corruption at worse
> depending on how this.name is referenced.
>
> I think you are right, the compiler must not issue a load that did not
> exist in the source code (the compiler *is* aware that some other
> thread may be changing the variable).
>
> The following transformation should be legal
>
>        public final void setName(String name) {
>             char[]  tmp = new char[name.length()]
>             this.name = tmp;
>             System.arraycopy(name.value, 0, tmp, 0, name.length());
>
> Zhong Yu
>
> Gregg Wonderly
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From gregg at cytetech.com  Mon Mar 18 18:00:46 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Mon, 18 Mar 2013 17:00:46 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51477E01.70201@oracle.com>
References: <CD67AFF1.22532%pete@guyatt.ca> <514259F1.2080604@oracle.com>
	<5142AE2B.3030203@cytetech.com> <51476583.2070102@oracle.com>
	<51477269.5060502@cytetech.com> <51477E01.70201@oracle.com>
Message-ID: <51478E8E.2030805@cytetech.com>

On 3/18/2013 3:50 PM, oleksandr otenko wrote:
> On 18/03/2013 20:00, Gregg Wonderly wrote:
>> On 3/18/2013 2:05 PM, oleksandr otenko wrote:
>>> Why Sequential Consistency, of all consistency requirements?
>>
>> The rewrite provides a set of instructions, that when weaved by two or more
>> threads, might (see below) cause "failure" of the VM. That is the problem for
>> me.  The single statement,
>>
>>      this.name = name.toCharArray();
>
> I must point out that there is nothing saying name.toCharArray() doesn't write
> anything to this.name during its operation before returning the result (which
> you happen to assign to this.name). For all it matters, if the modification is
> not visible by the caller, it may be happening in a single-threaded world.

There has never been anything in the JLS that has allowed this.name to be 
assigned an incomplete value.

15.26 is the Assignment Operators, 15.26.1, Simple assignment, states many 
things about the evaluation of the left side of the operator denoted as e.f.  It 
concludes with the text:

"Otherwise, the variable denoted by e.f is assigned the value of the right hand
operand as computed above"

There is no visible text that says, 'if the right hand expression is an array, 
the array may be assigned before it is filled with any value generated by the 
evaluation of that expression' or anything similar.  It says the left hand is 
assigned the value computed from the expression on the right.

Gregg Wonderly

>> being transformed as Nathan illustrated violates the "developers" belief in
>> what he coded.  This statement, by observation, is threadsafe with respect to
>> the assignment of a value to this.name, and
>
> I don't see what makes it thread-safe, except when you look at the lines of code
> as atomic units of execution.

Precisely.  Lines of code exist because there is no other way to express 
"order".  They are in fact what developers expect to "complete", entirely. 
Unrelated lines of code may be reordered, but a line is a line!  It has to do 
what it says it does, and the right side of assignment has to complete before 
the left side can be assigned.  I know that because long can have this problem, 
that it might seem perfectly good that the behavior here is consistent with that.

However, I know how long is stored/used and I know that it isn't a "single" 
value on some processors.  Whereas object references "are" consistent, or else 
we would have real problems with every line needing to be synchronized.  Thus, 
my reasoning would cause me to say that this object reference would not be 
updated until the object was initialized (or that race could be exploited as a 
security risk in any many different APIs), and what you are suggesting, is that 
this will not be guaranteed.

>> would appear to have no chance of causing an exception.   When one looks at
>> the code in String.toCharArray(), inlining those two lines of code in
>> String.toCharArray(), would seem probable to me as well, as Nathan's
>> illustration seemed to point out.
>>
>> But I would never, ever guess that rather than use a temporary holder
>> variable/register for the array allocated, that the value would instead be
>> stored to this.name, before the arraycopy() call.
> A temporary holder variable is in memory? Then you have one more write and read.
>
> A plausible sequence of instructions: allocate, store address in EDI, use REP
> MOVSB to copy - EDI is ruined after copy. Why not store address to this.name
> before starting to copy?

I understand how all of these optimizations are focused on staying away from 
memory, even the stack I suppose.  I used to do this kind of jockeying with hand 
coded assembler on the Z-80 and TI-9900, decades ago. The results still have to 
be correct, and a partially initialized array is not specified as valid in the 
JLS as far as I read.

>>
>> Now, I will concede that the arraycopy() might in fact use the exact value
>> returned from the array allocation, instead of referencing this.name, but I
>> don't know that.
>
> It doesn't matter. Getting used to the idea that correct single-threaded code is
> not always correct in a concurrent setting, helps.

I guess it's hard for you to understand that I already know this, since we don't 
really know each others history.  The first time that I ran Java 1.5 code on a 
dual core machine, I was bit by the loop exit hoist that happens to code like 
the following.

class foo {
	boolean bar;
	public void work() {
		while(!bar ) {
			..do the work..
		}
	}
	public void setBar( boolean how ) {
		bar = how;
	}
}

I would expect that visibility would be a problem that might cause bar to not be 
set immediately, but the JLS doesn't say that this will be rewritten as

		if( !bar ) {
			while( true ) {
			}
		}

That was the first disaster that optimization of non-volatile values created.  I 
think I lost about a day at least, of work trying to understand why the loop 
would not exit.  I think I had to post on this list to get a hint that this was 
happening.  No documentation on the planet says that this will happen and then 
tells me to code accordingly.  Prior to 1.5, volatile was meaningless, and for 
1.5 to change code that was working to non-working code just seemed completely 
pointless and downright ridiculous.  To this day, I still find this rewrite 
killing working code, and thus I just paste "volatile" on every single 
declaration, because there is no telling what silly, pointless optimization 
(pointless from the perspective that it doesn't 'fix' anything if it breaks 
code) will be injected into the JDK next.

In the JLS, 8.3.1.4 has information about ordering of non-volatile value 
references/updates.  This is the expected, old details about unrelated values 
being updated out of program order.  If neither i nor j were volatile, then the 
expression i = ++j, used in "one()" in that example could produce the values 
where i is one less than j.  But you should never see i greater than j.  That 
just doesn't make programmatic sense based on the expression.  But, I would 
honestly expect that kind of silly optimization to be made.  So that it was 
rewritten as effectively

	j = i = j + 1;

Why in the world would we want to force the use of volatile unless it's actually 
useful to the developer to guarantee something important to them?  These kinds 
of optimizations just make debugging hard.  People will go in and declare i and 
j volatile so that their debugging message works, and it's not really necessary 
to do that.

Gregg

>
>> Nathan's example was devoid of the exact semantics of how the arguments to
>> arraycopy() were sourced.
>>
>> If the code that actually would exist would look like
>>
>>         char result[] = this.name = new char[value.length];
>>         System.arraycopy(value, 0, result, 0, value.length);
>>
>> Then of course, all is well regarding an ArrayIndexOutOfBoundsException,
>> because that wouldn't happen.
> It won't surprise me even if it throws ArrayIndexOutOfBoundsException. If you
> stop considering that all calls to setName are serialized, then you synchronize
> all calls to setName yourself.
>
>
>>
>> However, it would still be possible for getName() to be called with an array
>> that was not completely populated with the actual 'value' string.
> If setName or toCharArray is a black box, then you don't know whether it sets
> this.name to any other values between the start and end of the setName call. If
> you deny all knowledge of how it is done, then you need to accept this is a
> valid way to do it.
>
>
> Alex
>
> PS I am only trying to demonstrate from a wider angle that certain types of
> guarantees are not possible, if you consider a function as a black box. For the
> system as a whole to be sequentially consistent, you need to consider the system
> as a whole. Use of Sequentially Consistent black boxes doesn't mean the result
> is sequentially consistent.
>
> Whereas knowing what setName does is a pain, I don't think it is avoidable.
>
>
>>
>> I just don't see how it's exciting or even comfortable to feel like a public
>> API should require 'work' of this nature to use effectively.
>>
>> I just don't understand how there is any advantage at all to assigning
>> this.name before the array is filled.  If there is a temporary
>> variable/register used so that arraycopy() can be called with that as the
>> third argument, then the assignment can be called after that.  If, instead
>> there is no temp variable/register used, then we may be back to the AIOOBE
>> being the issue if this.name is the third argument to arraycopy().
>>
>> Gregg Wonderly
>>
>> > As an example,
>>> Vector and Hashtable will return "consistent" results, but that doesn't
>>> eliminate races between get and put - what sort of consistency guarantee do you
>>> get?
>>>
>>> Also, bear in mind that 2 billion calls to Vector and Hashtable methods will
>>> create about 8 minutes of runtime overhead even on a single-threaded flow - no
>>> contention, just the cost of those instructions (compared to exactly the same
>>> test, but on a uniprocessor = JVM optimizes away the atomics on the locks).
>>> (this is not the latest HotSpot, but I think a useful rule of thumb) Maybe if
>>> you count all field mutations in your workflow you can see why non-volatile
>>> accesses is the default.
>>>
>>>
>>> Alex
>>>
>>>
>>> On 15/03/2013 05:14, Gregg Wonderly wrote:
>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>> I've inlined the name.toCharArray() and rearranged a few operations that JIT
>>>>> could do.  If another thread reads this.name between its creation and the
>>>>> end of
>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>
>>>>>      public final void setName(String name) {
>>>>>          this.name = new char[name.length()];
>>>>>          System.arraycopy(..., 0, result, 0, name.length());
>>>>>      }
>>>>
>>>> This rewrite/optimization doesn't seem to meet sequential consistency ordering
>>>> requirements.  I don't see how this could be considered SC since it creates a
>>>> different result (uninitialized value) then the way that the original source
>>>> was coded did not.
>>>>
>>>> If the JIT is actually doing this when concurrency is not detected
>>>> (non-volatile and no other happensBefore/fence), its no wonder we have so many
>>>> developers plagued with unexplainable racy program bugs.
>>>>
>>>> I thought the rewrite of while( nonvolatileBoolean ){} to if
>>>> (nonvolatileBoolean) { while (true ) {} } was bad enough of a mistake.  This
>>>> just wreaks of frustration for developers.
>>>>
>>>> How is this optimization more efficient, really?  Are we really so interested
>>>> in absolutely most efficient that we've given up on letting developers decide
>>>> when performance matters and then optimize to "incorrect" on their own terms?
>>>>
>>>> This kind optimization, if it is actually occurring is another example of
>>>> insidious change in program behavior...
>>>>
>>>> Gregg Wonderly
>>>>
>>>>>
>>>>> Nathan Reynolds
>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>> Architect | 602.333.9091
>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>>> On 3/14/2013 4:03 PM, Pete Guyatt wrote:
>>>>>> I'm sure I'm missing something here but I don't quite see how the
>>>>>> character array can be scrambled.
>>>>>>
>>>>>> I can see how it "racy" and how an inconsistent write/read happens where a
>>>>>> thread calls setName -- could be the thread itself or another thread --
>>>>>> and another calls getName but from what I can see the assignment of the
>>>>>> new value to the name[] array is only going to happen after the call to
>>>>>> toCharArray completes. I thought this would be the case even with the JVM
>>>>>> performing some reordering of instructions.
>>>>>>
>>>>>> Would someone mind clarifying?
>>>>>>
>>>>>> Kind Regards,
>>>>>>
>>>>>> Pete
>>>>>>
>>>>>> On 2013-03-14 4:47 PM, "Zhong Yu"<zhong.j.yu at gmail.com> wrote:
>>>>>>
>>>>>>> On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
>>>>>>> <stanimir at riflexo.com>  wrote:
>>>>>>>> We already agree about being racy. Unline the clone() method 'name' has
>>>>>>>> no
>>>>>>>> critical applications (or at least shall not), so I presume it was never
>>>>>>>> considered a problem to warrant a volatile field.
>>>>>>> A non-volatile String field would be ok.
>>>>>>>
>>>>>>> Since getName() can be invoked by anyone at anytime, it's troubling
>>>>>>> that it could observe a scrambled name.
>>>>>>>
>>>>>>> Zhong Yu
>>>>>>>
>>>>>>>> On Thu, Mar 14, 2013 at 11:55 PM, Zhong Yu<zhong.j.yu at gmail.com> wrote:
>>>>>>>>> It's a common practice to modify thread names on the fly, for
>>>>>>>>> diagnosis purposes.
>>>>>>>>>
>>>>>>>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>>>>>>>>> <stanimir at riflexo.com>  wrote:
>>>>>>>>>> char[] name is usually initialized in the c-tor, in that case it'd be
>>>>>>>>>> fine.
>>>>>>>>>> Since the access to 'name' is racy to begin, the changes may not be
>>>>>>>>>> necessarily 'visible'.
>>>>>>>>>>
>>>>>>>>>> Stanimir
>>>>>>>>>>
>>>>>>>>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong Yu<zhong.j.yu at gmail.com>
>>>>>>>>> wrote:
>>>>>>>>>>> java.lang.Thread
>>>>>>>>>>>
>>>>>>>>>>>      private char name[];
>>>>>>>>>>>
>>>>>>>>>>>      public final void setName(String name) {
>>>>>>>>>>>          checkAccess();
>>>>>>>>>>>          this.name = name.toCharArray();
>>>>>>>>>>>      }
>>>>>>>>>>>
>>>>>>>>>>>      public final String getName() {
>>>>>>>>>>>          return String.valueOf(name);
>>>>>>>>>>>      }
>>>>>>>>>>>
>>>>>>>>>>> On the surface, set/getName() are not correctly synchronized,
>>>>>>>>>>> getName() could observe a partially filled char array. What's the
>>>>>>>>>>> story here?
>>>>>>>>>>>
>>>>>>>>>>> Zhong Yu
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>
>>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From nathan.reynolds at oracle.com  Mon Mar 18 18:05:02 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 18 Mar 2013 15:05:02 -0700
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CAOwENiJvDNf_-rOuUanRfGfO4_E81FcMuJBi-mN_8vsh8pobcA@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<FD424034-EF10-455E-8939-18D856236D45@cox.net>
	<51475213.3030509@oracle.com> <51476D10.5090001@cytetech.com>
	<514770C2.3000700@oracle.com> <514779E3.70206@cytetech.com>
	<514789CD.508@oracle.com>
	<CAOwENiJvDNf_-rOuUanRfGfO4_E81FcMuJBi-mN_8vsh8pobcA@mail.gmail.com>
Message-ID: <51478F8E.9060707@oracle.com>

I don't know if it has been implemented yet.  However, it should be 
easier to implement if the processor supports hardware transactional 
memory.  This is because many of the same mechanisms used to implement 
hardware transactional memory can be reused to implement speculative loads.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 3/18/2013 2:56 PM, Ruslan Cheremin wrote:
>> A core could speculatively do the load and monitor
>> the cache line.  If no one else in the system touches the cache line before
>> the memory fence is finished, then the speculative load just prevented a
>> stall.  If another core touches the cache line, then the speculation is
>> thrown out and the instructions are restarted.  The core's performance is
>> either on par or still ahead of stalling.  The great benefit of this is that
>> the memory fence still appears to software to be enforced yet the core is
>> able to perform well in spite of its existence.
> It is very interesting -- has it actually implemented in hardware?
> I've heard many times about "fence is not required to be implemented
> as store/load buffers flush, but it is actually implemented this way
> in commodity CPUs". Who is the hero I should glorify for such great
> job?
>
>
>
>> Nathan Reynolds | Architect | 602.333.9091
>> Oracle PSR Engineering | Server Technology
>> On 3/18/2013 1:32 PM, Gregg Wonderly wrote:
>>
>> Right, and what I am saying, is that things that the developer has not
>> "coded" should not happen.  Ordering of what they've coded should be all
>> that is something for them to consider when looking for concurrency or race
>> conditions.
>>
>> Even if we had all ended up with massive EMSP (I did some research on this
>> in college with some of the people who had worked on it, before this
>> contract happened:
>> http://www.thefreelibrary.com/AT%26T+WINS+$26.6+MILLION+NAVY+SOFTWARE+CONVERSION+CONTRACT-a012623510)
>> processors with complete data flow analysis, there would still be SC with
>> respect to each data item.  It can't be used before it exists.  Assigning
>> this.name a value, before the value "exists" (not until arraycopy() returns
>> does the value exist), is the problem.  There is no merit to any argument
>> that says that the "software" should see such a state.  The developer did
>> not code
>>
>> this.name = new char[len];
>> System.arrayCopy( str.getBytes(), 0, this.name, 0, len );
>>
>> Maybe you can help me understand how you see this optimization as a benefit?
>> Having the developer need to check every single function in any API to make
>> sure it's been fixed to keep this optimization from biting them is where I'm
>> struggling.  Software that used to work, before this kind of optimization
>> was made, could now, just break or behave oddly and just by looking at it,
>> how would any average developer know?
>>
>> Gregg Wonderly
>>
>> On 3/18/2013 2:53 PM, oleksandr otenko wrote:
>>
>> I am pointing out this is a problem of concurrent programming and no one
>> said it
>> is a */simple/* extension of a single-threaded world. You need to know all
>> effects to know how to combine them.
>>
>> Do you expect the thread name to show IP address (someone mentioned that?)
>> and
>> the stack trace to show the thread processing that same request? How do you
>> combine these? So you'd need to come up with what a consistent state is
>> first.
>>
>> This is easily illustrated by a example of a thread dump where no thread
>> holds
>> the lock, yet has a few threads blocked on it. All because by the time the
>> thread dump for the lock owner was taken, it released the lock.
>>
>> Alex
>>
>> On 18/03/2013 19:37, Gregg Wonderly wrote:
>>
>> So how does the developer know?  setName()/getName() have no visible
>> contract
>> do they?
>>
>> Gregg
>>
>> On 3/18/2013 12:42 PM, oleksandr otenko wrote:
>>
>> It is hardly surprising that in order to combine effects you need to know
>> what
>> the effects are.
>>
>> So nothing special about having to know what setName does to properly
>> synchronize.
>>
>> Alex
>>
>> On 15/03/2013 21:46, Gregg Wonderly wrote:
>>
>> Yes, that transformation is legal, but it is also broken in the current
>> design
>> of that class.  Because Thread.setName() is callable, and because there is
>> no
>> other visible happensBefore with Thread.getName, the compiler can make the
>> decision to designate these methods as intra-thread use only.
>>
>> That is the problem.  Even if I subsequently introduce a "happens before" by
>> synchronizing or locking or something else, I have to know what the
>> implementation is, know how it is broken and only then can I actually expect
>> to achieve safe use of the provided API.
>>
>> I assert that this is completely and totally non-productive for software
>> developers.  The JDK and many other large Java applications/libraries are
>> broken in subtle ways, such as the missing "volatile" here. The compilers
>> rewrite of such code into non-thread safe segments when the developer(s)
>> might
>> look at their code and say "that's racy, but safe, because I'll just use
>> "synchronized" around my calls, is changing the outcome that breaks SC.  Yes
>> SC is not supposed to be guaranteed in this case, but do JVM and hotspot
>> developers really feel like they are doing great and wonderful things, when
>> this kind of stuff is haunting everybody everywhere, because even the JDK
>> has
>> not been "fixed"?
>>
>> Gregg Wonderly
>>
>> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>
>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
>>
>> Nathan's example below is my issue...
>>
>>
>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>
>> Gregg,
>>
>> Gregg Wonderly writes:
>>
>>
>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>
>> I've inlined the name.toCharArray() and rearranged a few
>>
>> operations that JIT
>>
>> could do.  If another thread reads this.name between its
>>
>> creation and the end of
>>
>> arraycopy() then the thread will see a partially filled char[].
>>
>>        public final void setName(String name) {
>>            this.name = new char[name.length()];
>>            System.arraycopy(..., 0, result, 0, name.length());
>>
>>
>> If two different threads call setName concurrently, then if the code was
>> transformed as shown above, then it is possible to see
>>
>> T1:           this.name = new char["some longer string".length()];
>> T2:           this.name = new char["a short string".length()];
>> T1:           System.arraycopy( "some longer string", 0,
>>                          this.name, 0, "some longer string".length());
>>
>> Which will result in an exception at best and memory corruption at worse
>> depending on how this.name is referenced.
>>
>> I think you are right, the compiler must not issue a load that did not
>> exist in the source code (the compiler *is* aware that some other
>> thread may be changing the variable).
>>
>> The following transformation should be legal
>>
>>         public final void setName(String name) {
>>              char[]  tmp = new char[name.length()]
>>              this.name = tmp;
>>              System.arraycopy(name.value, 0, tmp, 0, name.length());
>>
>> Zhong Yu
>>
>> Gregg Wonderly
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130318/9c25f100/attachment-0001.html>

From oleksandr.otenko at oracle.com  Mon Mar 18 18:07:51 2013
From: oleksandr.otenko at oracle.com (oleksandr otenko)
Date: Mon, 18 Mar 2013 22:07:51 +0000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <514779E3.70206@cytetech.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<FD424034-EF10-455E-8939-18D856236D45@cox.net>
	<51475213.3030509@oracle.com> <51476D10.5090001@cytetech.com>
	<514770C2.3000700@oracle.com> <514779E3.70206@cytetech.com>
Message-ID: <51479037.40107@oracle.com>

On 18/03/2013 20:32, Gregg Wonderly wrote:
> Right, and what I am saying, is that things that the developer has not 
> "coded" should not happen.  Ordering of what they've coded should be 
> all that is something for them to consider when looking for 
> concurrency or race conditions.
So.... why is volatile not good enough a marker? "these are the things 
whose access order is important".


>
> Even if we had all ended up with massive EMSP (I did some research on 
> this in college with some of the people who had worked on it, before 
> this contract happened: 
> http://www.thefreelibrary.com/AT%26T+WINS+$26.6+MILLION+NAVY+SOFTWARE+CONVERSION+CONTRACT-a012623510) 
> processors with complete data flow analysis, there would still be SC 
> with respect to each data item.  It can't be used before it exists.  
> Assigning this.name a value, before the value "exists" (not until 
> arraycopy() returns does the value exist), is the problem.  There is 
> no merit to any argument that says that the "software" should see such 
> a state.  The developer did not code
>
> this.name = new char[len];
> System.arrayCopy( str.getBytes(), 0, this.name, 0, len );
>
> Maybe you can help me understand how you see this optimization as a 
> benefit? 
For example, arrayCopy ruins the pointer to source and destination. It's 
cheaper to save the pointer before starting the copying, and it doesn't 
matter in 99.9999999% of cases.


> Having the developer need to check every single function in any API to 
> make sure it's been fixed to keep this optimization from biting them 
> is where I'm struggling.  Software that used to work, before this kind 
> of optimization was made, could now, just break or behave oddly and 
> just by looking at it, how would any average developer know?
It doesn't look like odd behaviour to those familiar with JMM. The 
average developer either evolves to understand it, or will die out - in 
both cases the average will move up.

Like the others here observed, this code is evidence of a very weak 
guarantee of ordering (avoiding the word "wrong"), and only need to 
figure out whether a stronger guarantee is needed. I'd say we are 
talking about corner cases with multiple threads setting name 
concurrently, if you are considering a AIOOBE - and I'd say "tough" to 
concurrent getters; just live with slightly inconsistent view of the 
ever changing world, no one said that view can be transactional for the 
money paid for that processor. :-)

Looks too verbose a explanation why no one is running for the emergency 
exit.


As a side, you mention "complete data flow analysis". Here are two 
important things: "complete" (possible for some Navy software, but what 
about Web Server deploying new applications), and the presence of 
assertions about valid state transitions (try to express that 
Thread.getName() == something we consider valid).


Alex


>
> Gregg Wonderly
>
> On 3/18/2013 2:53 PM, oleksandr otenko wrote:
>> I am pointing out this is a problem of concurrent programming and no 
>> one said it
>> is a */simple/* extension of a single-threaded world. You need to 
>> know all
>> effects to know how to combine them.
>>
>> Do you expect the thread name to show IP address (someone mentioned 
>> that?) and
>> the stack trace to show the thread processing that same request? How 
>> do you
>> combine these? So you'd need to come up with what a consistent state 
>> is first.
>>
>> This is easily illustrated by a example of a thread dump where no 
>> thread holds
>> the lock, yet has a few threads blocked on it. All because by the 
>> time the
>> thread dump for the lock owner was taken, it released the lock.
>>
>> Alex
>>
>> On 18/03/2013 19:37, Gregg Wonderly wrote:
>>> So how does the developer know? setName()/getName() have no visible 
>>> contract
>>> do they?
>>>
>>> Gregg
>>>
>>> On 3/18/2013 12:42 PM, oleksandr otenko wrote:
>>>> It is hardly surprising that in order to combine effects you need 
>>>> to know what
>>>> the effects are.
>>>>
>>>> So nothing special about having to know what setName does to properly
>>>> synchronize.
>>>>
>>>> Alex
>>>>
>>>> On 15/03/2013 21:46, Gregg Wonderly wrote:
>>>>> Yes, that transformation is legal, but it is also broken in the 
>>>>> current design
>>>>> of that class.  Because Thread.setName() is callable, and because 
>>>>> there is no
>>>>> other visible happensBefore with Thread.getName, the compiler can 
>>>>> make the
>>>>> decision to designate these methods as intra-thread use only.
>>>>>
>>>>> That is the problem.  Even if I subsequently introduce a "happens 
>>>>> before" by
>>>>> synchronizing or locking or something else, I have to know what the
>>>>> implementation is, know how it is broken and only then can I 
>>>>> actually expect
>>>>> to achieve safe use of the provided API.
>>>>>
>>>>> I assert that this is completely and totally non-productive for 
>>>>> software
>>>>> developers.  The JDK and many other large Java 
>>>>> applications/libraries are
>>>>> broken in subtle ways, such as the missing "volatile" here. The 
>>>>> compilers
>>>>> rewrite of such code into non-thread safe segments when the 
>>>>> developer(s) might
>>>>> look at their code and say "that's racy, but safe, because I'll 
>>>>> just use
>>>>> "synchronized" around my calls, is changing the outcome that 
>>>>> breaks SC.  Yes
>>>>> SC is not supposed to be guaranteed in this case, but do JVM and 
>>>>> hotspot
>>>>> developers really feel like they are doing great and wonderful 
>>>>> things, when
>>>>> this kind of stuff is haunting everybody everywhere, because even 
>>>>> the JDK has
>>>>> not been "fixed"?
>>>>>
>>>>> Gregg Wonderly
>>>>>
>>>>> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>>>
>>>>>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly 
>>>>>> <gregg at cytetech.com> wrote:
>>>>>>> Nathan's example below is my issue...
>>>>>>>
>>>>>>>
>>>>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>>>>> Gregg,
>>>>>>>>
>>>>>>>> Gregg Wonderly writes:
>>>>>>>>>
>>>>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>>>> operations that JIT
>>>>>>>>>> could do.  If another thread reads this.name between its
>>>>>>>>> creation and the end of
>>>>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>>>>
>>>>>>>>>>       public final void setName(String name) {
>>>>>>>>>>           this.name = new char[name.length()];
>>>>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>>>
>>>>>>> If two different threads call setName concurrently, then if the 
>>>>>>> code was
>>>>>>> transformed as shown above, then it is possible to see
>>>>>>>
>>>>>>> T1:           this.name = new char["some longer string".length()];
>>>>>>> T2:           this.name = new char["a short string".length()];
>>>>>>> T1:           System.arraycopy( "some longer string", 0,
>>>>>>>                         this.name, 0, "some longer 
>>>>>>> string".length());
>>>>>>>
>>>>>>> Which will result in an exception at best and memory corruption 
>>>>>>> at worse
>>>>>>> depending on how this.name is referenced.
>>>>>> I think you are right, the compiler must not issue a load that 
>>>>>> did not
>>>>>> exist in the source code (the compiler *is* aware that some other
>>>>>> thread may be changing the variable).
>>>>>>
>>>>>> The following transformation should be legal
>>>>>>
>>>>>>        public final void setName(String name) {
>>>>>>             char[]  tmp = new char[name.length()]
>>>>>>             this.name = tmp;
>>>>>>             System.arraycopy(name.value, 0, tmp, 0, name.length());
>>>>>>
>>>>>> Zhong Yu
>>>>>>
>>>>>>> Gregg Wonderly
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>


From davidcholmes at aapt.net.au  Mon Mar 18 18:31:56 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 19 Mar 2013 08:31:56 +1000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51476D10.5090001@cytetech.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEFKJLAA.davidcholmes@aapt.net.au>

Gregg Wonderly writes:
>
> So how does the developer know?  setName()/getName() have no
> visible contract do they?

Basic rule: if it doesn't say it is thread-safe then assume it is not.

If people did this and then complained when things should be thread-safe
then hopefully we wouldn't get this kind of discussion 15 years later!

David
-----

>
> Gregg
>
> On 3/18/2013 12:42 PM, oleksandr otenko wrote:
> > It is hardly surprising that in order to combine effects you
> need to know what
> > the effects are.
> >
> > So nothing special about having to know what setName does to
> properly synchronize.
> >
> > Alex
> >
> > On 15/03/2013 21:46, Gregg Wonderly wrote:
> >> Yes, that transformation is legal, but it is also broken in
> the current design
> >> of that class.  Because Thread.setName() is callable, and
> because there is no
> >> other visible happensBefore with Thread.getName, the compiler
> can make the
> >> decision to designate these methods as intra-thread use only.
> >>
> >> That is the problem.  Even if I subsequently introduce a
> "happens before" by
> >> synchronizing or locking or something else, I have to know what the
> >> implementation is, know how it is broken and only then can I
> actually expect
> >> to achieve safe use of the provided API.
> >>
> >> I assert that this is completely and totally non-productive
> for software
> >> developers.  The JDK and many other large Java
> applications/libraries are
> >> broken in subtle ways, such as the missing "volatile" here.
> The compilers
> >> rewrite of such code into non-thread safe segments when the
> developer(s) might
> >> look at their code and say "that's racy, but safe, because
> I'll just use
> >> "synchronized" around my calls, is changing the outcome that
> breaks SC.  Yes
> >> SC is not supposed to be guaranteed in this case, but do JVM
> and hotspot
> >> developers really feel like they are doing great and wonderful
> things, when
> >> this kind of stuff is haunting everybody everywhere, because
> even the JDK has
> >> not been "fixed"?
> >>
> >> Gregg Wonderly
> >>
> >> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
> >>
> >>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly
> <gregg at cytetech.com> wrote:
> >>>> Nathan's example below is my issue...
> >>>>
> >>>>
> >>>> On 3/15/2013 12:29 AM, David Holmes wrote:
> >>>>> Gregg,
> >>>>>
> >>>>> Gregg Wonderly writes:
> >>>>>>
> >>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
> >>>>>>> I've inlined the name.toCharArray() and rearranged a few
> >>>>>> operations that JIT
> >>>>>>> could do.  If another thread reads this.name between its
> >>>>>> creation and the end of
> >>>>>>> arraycopy() then the thread will see a partially filled char[].
> >>>>>>>
> >>>>>>>       public final void setName(String name) {
> >>>>>>>           this.name = new char[name.length()];
> >>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
> >>>>
> >>>> If two different threads call setName concurrently, then if
> the code was
> >>>> transformed as shown above, then it is possible to see
> >>>>
> >>>> T1:           this.name = new char["some longer string".length()];
> >>>> T2:           this.name = new char["a short string".length()];
> >>>> T1:           System.arraycopy( "some longer string", 0,
> >>>>                         this.name, 0, "some longer string".length());
> >>>>
> >>>> Which will result in an exception at best and memory
> corruption at worse
> >>>> depending on how this.name is referenced.
> >>> I think you are right, the compiler must not issue a load that did not
> >>> exist in the source code (the compiler *is* aware that some other
> >>> thread may be changing the variable).
> >>>
> >>> The following transformation should be legal
> >>>
> >>>        public final void setName(String name) {
> >>>             char[]  tmp = new char[name.length()]
> >>>             this.name = tmp;
> >>>             System.arraycopy(name.value, 0, tmp, 0, name.length());
> >>>
> >>> Zhong Yu
> >>>
> >>>> Gregg Wonderly
> >>>>
> >>>> _______________________________________________
> >>>> Concurrency-interest mailing list
> >>>> Concurrency-interest at cs.oswego.edu
> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> -----
> No virus found in this message.
> Checked by AVG - www.avg.com
> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
> Internal Virus Database is out of date.
>


From oleksandr.otenko at oracle.com  Mon Mar 18 18:34:10 2013
From: oleksandr.otenko at oracle.com (oleksandr otenko)
Date: Mon, 18 Mar 2013 22:34:10 +0000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51478E8E.2030805@cytetech.com>
References: <CD67AFF1.22532%pete@guyatt.ca> <514259F1.2080604@oracle.com>
	<5142AE2B.3030203@cytetech.com> <51476583.2070102@oracle.com>
	<51477269.5060502@cytetech.com> <51477E01.70201@oracle.com>
	<51478E8E.2030805@cytetech.com>
Message-ID: <51479662.7020302@oracle.com>


On 18/03/2013 22:00, Gregg Wonderly wrote:
> On 3/18/2013 3:50 PM, oleksandr otenko wrote:
>> On 18/03/2013 20:00, Gregg Wonderly wrote:
>>> On 3/18/2013 2:05 PM, oleksandr otenko wrote:
>>>> Why Sequential Consistency, of all consistency requirements?
>>>
>>> The rewrite provides a set of instructions, that when weaved by two 
>>> or more
>>> threads, might (see below) cause "failure" of the VM. That is the 
>>> problem for
>>> me.  The single statement,
>>>
>>>      this.name = name.toCharArray();
>>
>> I must point out that there is nothing saying name.toCharArray() 
>> doesn't write
>> anything to this.name during its operation before returning the 
>> result (which
>> you happen to assign to this.name). For all it matters, if the 
>> modification is
>> not visible by the caller, it may be happening in a single-threaded 
>> world.
>
> There has never been anything in the JLS that has allowed this.name to 
> be assigned an incomplete value.
>
> 15.26 is the Assignment Operators, 15.26.1, Simple assignment, states 
> many things about the evaluation of the left side of the operator 
> denoted as e.f.  It concludes with the text:
>
> "Otherwise, the variable denoted by e.f is assigned the value of the 
> right hand
> operand as computed above"
>
> There is no visible text that says, 'if the right hand expression is 
> an array, the array may be assigned before it is filled with any value 
> generated by the evaluation of that expression' or anything similar.  
> It says the left hand is assigned the value computed from the 
> expression on the right.

Just a moment. Let's consider what "is assigned" means.

"is assigned" means the value will be written to e.f BEFORE it is 
subsequently read - ie whenever you read the value back, you always see 
the last write. But when is that "BEFORE"?


>
> Gregg Wonderly
>
>>> being transformed as Nathan illustrated violates the "developers" 
>>> belief in
>>> what he coded.  This statement, by observation, is threadsafe with 
>>> respect to
>>> the assignment of a value to this.name, and
>>
>> I don't see what makes it thread-safe, except when you look at the 
>> lines of code
>> as atomic units of execution.
>
> Precisely.  Lines of code exist because there is no other way to 
> express "order".  They are in fact what developers expect to 
> "complete", entirely. Unrelated lines of code may be reordered, but a 
> line is a line!  It has to do what it says it does, and the right side 
> of assignment has to complete before the left side can be assigned.  I 
> know that because long can have this problem, that it might seem 
> perfectly good that the behavior here is consistent with that.

I guess the difference is in what we think the line says it does.


>
> However, I know how long is stored/used and I know that it isn't a 
> "single" value on some processors.  Whereas object references "are" 
> consistent, or else we would have real problems with every line 
> needing to be synchronized.  Thus, my reasoning would cause me to say 
> that this object reference would not be updated until the object was 
> initialized (or that race could be exploited as a security risk in any 
> many different APIs), and what you are suggesting, is that this will 
> not be guaranteed.

We can apply the same reasoning to "long" values. But you just happen to 
know they aren't atomic.


>
>>> would appear to have no chance of causing an exception.   When one 
>>> looks at
>>> the code in String.toCharArray(), inlining those two lines of code in
>>> String.toCharArray(), would seem probable to me as well, as Nathan's
>>> illustration seemed to point out.
>>>
>>> But I would never, ever guess that rather than use a temporary holder
>>> variable/register for the array allocated, that the value would 
>>> instead be
>>> stored to this.name, before the arraycopy() call.
>> A temporary holder variable is in memory? Then you have one more 
>> write and read.
>>
>> A plausible sequence of instructions: allocate, store address in EDI, 
>> use REP
>> MOVSB to copy - EDI is ruined after copy. Why not store address to 
>> this.name
>> before starting to copy?
>
> I understand how all of these optimizations are focused on staying 
> away from memory, even the stack I suppose.  I used to do this kind of 
> jockeying with hand coded assembler on the Z-80 and TI-9900, decades 
> ago. The results still have to be correct, and a partially initialized 
> array is not specified as valid in the JLS as far as I read.
It is not partially initialized - it is completely initialized to 0. It 
is partially copied - yes.


>
>>>
>>> Now, I will concede that the arraycopy() might in fact use the exact 
>>> value
>>> returned from the array allocation, instead of referencing 
>>> this.name, but I
>>> don't know that.
>>
>> It doesn't matter. Getting used to the idea that correct 
>> single-threaded code is
>> not always correct in a concurrent setting, helps.
>
> I guess it's hard for you to understand that I already know this, 
> since we don't really know each others history.  The first time that I 
> ran Java 1.5 code on a dual core machine, I was bit by the loop exit 
> hoist that happens to code like the following.
>
> class foo {
>     boolean bar;
>     public void work() {
>         while(!bar ) {
>             ..do the work..
>         }
>     }
>     public void setBar( boolean how ) {
>         bar = how;
>     }
> }
>
> I would expect that visibility would be a problem that might cause bar 
> to not be set immediately, but the JLS doesn't say that this will be 
> rewritten as
>
>         if( !bar ) {
>             while( true ) {
>             }
>         }
>
> That was the first disaster that optimization of non-volatile values 
> created.  I think I lost about a day at least, of work trying to 
> understand why the loop would not exit.  I think I had to post on this 
> list to get a hint that this was happening.  No documentation on the 
> planet says that this will happen and then tells me to code 
> accordingly.  Prior to 1.5, volatile was meaningless, and for 1.5 to 
> change code that was working to non-working code just seemed 
> completely pointless and downright ridiculous.  To this day, I still 
> find this rewrite killing working code, and thus I just paste 
> "volatile" on every single declaration, because there is no telling 
> what silly, pointless optimization (pointless from the perspective 
> that it doesn't 'fix' anything if it breaks code) will be injected 
> into the JDK next.
>
> In the JLS, 8.3.1.4 has information about ordering of non-volatile 
> value references/updates.  This is the expected, old details about 
> unrelated values being updated out of program order.  If neither i nor 
> j were volatile, then the expression i = ++j, used in "one()" in that 
> example could produce the values where i is one less than j.  But you 
> should never see i greater than j.  That just doesn't make 
> programmatic sense based on the expression. 

Which i and which j? There are many of them on the timeline. It is not 
clear from that line of code what it says. If you mean it guarantees i 
never greater than j, is it meant to guarantee j increases by 2, if two 
threads execute it?


> But, I would honestly expect that kind of silly optimization to be 
> made.  So that it was rewritten as effectively
>
>     j = i = j + 1;

This semantic wasn't obvious from a line saying "i=++j". I thought that 
line said "i = j = j+1".


Alex

>
> Why in the world would we want to force the use of volatile unless 
> it's actually useful to the developer to guarantee something important 
> to them?  These kinds of optimizations just make debugging hard.  
> People will go in and declare i and j volatile so that their debugging 
> message works, and it's not really necessary to do that.
>
> Gregg
>
>>
>>> Nathan's example was devoid of the exact semantics of how the 
>>> arguments to
>>> arraycopy() were sourced.
>>>
>>> If the code that actually would exist would look like
>>>
>>>         char result[] = this.name = new char[value.length];
>>>         System.arraycopy(value, 0, result, 0, value.length);
>>>
>>> Then of course, all is well regarding an 
>>> ArrayIndexOutOfBoundsException,
>>> because that wouldn't happen.
>> It won't surprise me even if it throws 
>> ArrayIndexOutOfBoundsException. If you
>> stop considering that all calls to setName are serialized, then you 
>> synchronize
>> all calls to setName yourself.
>>
>>
>>>
>>> However, it would still be possible for getName() to be called with 
>>> an array
>>> that was not completely populated with the actual 'value' string.
>> If setName or toCharArray is a black box, then you don't know whether 
>> it sets
>> this.name to any other values between the start and end of the 
>> setName call. If
>> you deny all knowledge of how it is done, then you need to accept 
>> this is a
>> valid way to do it.
>>
>>
>> Alex
>>
>> PS I am only trying to demonstrate from a wider angle that certain 
>> types of
>> guarantees are not possible, if you consider a function as a black 
>> box. For the
>> system as a whole to be sequentially consistent, you need to consider 
>> the system
>> as a whole. Use of Sequentially Consistent black boxes doesn't mean 
>> the result
>> is sequentially consistent.
>>
>> Whereas knowing what setName does is a pain, I don't think it is 
>> avoidable.
>>
>>
>>>
>>> I just don't see how it's exciting or even comfortable to feel like 
>>> a public
>>> API should require 'work' of this nature to use effectively.
>>>
>>> I just don't understand how there is any advantage at all to assigning
>>> this.name before the array is filled.  If there is a temporary
>>> variable/register used so that arraycopy() can be called with that 
>>> as the
>>> third argument, then the assignment can be called after that. If, 
>>> instead
>>> there is no temp variable/register used, then we may be back to the 
>>> AIOOBE
>>> being the issue if this.name is the third argument to arraycopy().
>>>
>>> Gregg Wonderly
>>>
>>> > As an example,
>>>> Vector and Hashtable will return "consistent" results, but that 
>>>> doesn't
>>>> eliminate races between get and put - what sort of consistency 
>>>> guarantee do you
>>>> get?
>>>>
>>>> Also, bear in mind that 2 billion calls to Vector and Hashtable 
>>>> methods will
>>>> create about 8 minutes of runtime overhead even on a 
>>>> single-threaded flow - no
>>>> contention, just the cost of those instructions (compared to 
>>>> exactly the same
>>>> test, but on a uniprocessor = JVM optimizes away the atomics on the 
>>>> locks).
>>>> (this is not the latest HotSpot, but I think a useful rule of 
>>>> thumb) Maybe if
>>>> you count all field mutations in your workflow you can see why 
>>>> non-volatile
>>>> accesses is the default.
>>>>
>>>>
>>>> Alex
>>>>
>>>>
>>>> On 15/03/2013 05:14, Gregg Wonderly wrote:
>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>> I've inlined the name.toCharArray() and rearranged a few 
>>>>>> operations that JIT
>>>>>> could do.  If another thread reads this.name between its creation 
>>>>>> and the
>>>>>> end of
>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>
>>>>>>      public final void setName(String name) {
>>>>>>          this.name = new char[name.length()];
>>>>>>          System.arraycopy(..., 0, result, 0, name.length());
>>>>>>      }
>>>>>
>>>>> This rewrite/optimization doesn't seem to meet sequential 
>>>>> consistency ordering
>>>>> requirements.  I don't see how this could be considered SC since 
>>>>> it creates a
>>>>> different result (uninitialized value) then the way that the 
>>>>> original source
>>>>> was coded did not.
>>>>>
>>>>> If the JIT is actually doing this when concurrency is not detected
>>>>> (non-volatile and no other happensBefore/fence), its no wonder we 
>>>>> have so many
>>>>> developers plagued with unexplainable racy program bugs.
>>>>>
>>>>> I thought the rewrite of while( nonvolatileBoolean ){} to if
>>>>> (nonvolatileBoolean) { while (true ) {} } was bad enough of a 
>>>>> mistake.  This
>>>>> just wreaks of frustration for developers.
>>>>>
>>>>> How is this optimization more efficient, really?  Are we really so 
>>>>> interested
>>>>> in absolutely most efficient that we've given up on letting 
>>>>> developers decide
>>>>> when performance matters and then optimize to "incorrect" on their 
>>>>> own terms?
>>>>>
>>>>> This kind optimization, if it is actually occurring is another 
>>>>> example of
>>>>> insidious change in program behavior...
>>>>>
>>>>> Gregg Wonderly
>>>>>
>>>>>>
>>>>>> Nathan Reynolds
>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>> Architect | 602.333.9091
>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server 
>>>>>> Technology
>>>>>> On 3/14/2013 4:03 PM, Pete Guyatt wrote:
>>>>>>> I'm sure I'm missing something here but I don't quite see how the
>>>>>>> character array can be scrambled.
>>>>>>>
>>>>>>> I can see how it "racy" and how an inconsistent write/read 
>>>>>>> happens where a
>>>>>>> thread calls setName -- could be the thread itself or another 
>>>>>>> thread --
>>>>>>> and another calls getName but from what I can see the assignment 
>>>>>>> of the
>>>>>>> new value to the name[] array is only going to happen after the 
>>>>>>> call to
>>>>>>> toCharArray completes. I thought this would be the case even 
>>>>>>> with the JVM
>>>>>>> performing some reordering of instructions.
>>>>>>>
>>>>>>> Would someone mind clarifying?
>>>>>>>
>>>>>>> Kind Regards,
>>>>>>>
>>>>>>> Pete
>>>>>>>
>>>>>>> On 2013-03-14 4:47 PM, "Zhong Yu"<zhong.j.yu at gmail.com> wrote:
>>>>>>>
>>>>>>>> On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
>>>>>>>> <stanimir at riflexo.com>  wrote:
>>>>>>>>> We already agree about being racy. Unline the clone() method 
>>>>>>>>> 'name' has
>>>>>>>>> no
>>>>>>>>> critical applications (or at least shall not), so I presume it 
>>>>>>>>> was never
>>>>>>>>> considered a problem to warrant a volatile field.
>>>>>>>> A non-volatile String field would be ok.
>>>>>>>>
>>>>>>>> Since getName() can be invoked by anyone at anytime, it's 
>>>>>>>> troubling
>>>>>>>> that it could observe a scrambled name.
>>>>>>>>
>>>>>>>> Zhong Yu
>>>>>>>>
>>>>>>>>> On Thu, Mar 14, 2013 at 11:55 PM, Zhong 
>>>>>>>>> Yu<zhong.j.yu at gmail.com> wrote:
>>>>>>>>>> It's a common practice to modify thread names on the fly, for
>>>>>>>>>> diagnosis purposes.
>>>>>>>>>>
>>>>>>>>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>>>>>>>>>> <stanimir at riflexo.com>  wrote:
>>>>>>>>>>> char[] name is usually initialized in the c-tor, in that 
>>>>>>>>>>> case it'd be
>>>>>>>>>>> fine.
>>>>>>>>>>> Since the access to 'name' is racy to begin, the changes may 
>>>>>>>>>>> not be
>>>>>>>>>>> necessarily 'visible'.
>>>>>>>>>>>
>>>>>>>>>>> Stanimir
>>>>>>>>>>>
>>>>>>>>>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong 
>>>>>>>>>>> Yu<zhong.j.yu at gmail.com>
>>>>>>>>>> wrote:
>>>>>>>>>>>> java.lang.Thread
>>>>>>>>>>>>
>>>>>>>>>>>>      private char name[];
>>>>>>>>>>>>
>>>>>>>>>>>>      public final void setName(String name) {
>>>>>>>>>>>>          checkAccess();
>>>>>>>>>>>>          this.name = name.toCharArray();
>>>>>>>>>>>>      }
>>>>>>>>>>>>
>>>>>>>>>>>>      public final String getName() {
>>>>>>>>>>>>          return String.valueOf(name);
>>>>>>>>>>>>      }
>>>>>>>>>>>>
>>>>>>>>>>>> On the surface, set/getName() are not correctly synchronized,
>>>>>>>>>>>> getName() could observe a partially filled char array. 
>>>>>>>>>>>> What's the
>>>>>>>>>>>> story here?
>>>>>>>>>>>>
>>>>>>>>>>>> Zhong Yu
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>
>>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>


From zhong.j.yu at gmail.com  Mon Mar 18 18:48:26 2013
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Mon, 18 Mar 2013 17:48:26 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <514789CD.508@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<FD424034-EF10-455E-8939-18D856236D45@cox.net>
	<51475213.3030509@oracle.com> <51476D10.5090001@cytetech.com>
	<514770C2.3000700@oracle.com> <514779E3.70206@cytetech.com>
	<514789CD.508@oracle.com>
Message-ID: <CACuKZqGRWavEDGvMTF+FD+Q+bOEUE315hOpnbkT2P83o06ThiQ@mail.gmail.com>

On Mon, Mar 18, 2013 at 4:40 PM, Nathan Reynolds
<nathan.reynolds at oracle.com> wrote:
> I agree with you as well as many others.  This is why the final keyword was
> enhanced with Java Memory Model.
>
> I also agree that Thread.setName() shouldn't because of JIT cause an
> exception and shouldn't show a corrupted name.  It won't as long as getName
> and setName are called by the same thread.
>
> The problem comes into play with concurrency.  The getName and setName APIs
> were not designed to be concurrently accessed.  Many parts of the JDK were
> not designed to be concurrently accessed.

Typically, if an object is not for concurrent access, it has an owner,
and the owner controls all accesses to it.

But who is the owner of a thread? Nobody. Threads are openly exposed
for anybody to access. So it's not enough to simply label some of its
methods as not thread safe. If the methods are not thread safe, then
who can access it and when? What synchronization protocols we need to
follow to safely invoke them? There are not obvious answers to these
questions, therefore the methods would be unusable.

Users would intuitively assume that all methods in Thread are thread
safe, otherwise they have no idea how to invoke them in a thread safe
manner.

More generally, any object that is exposed to the public to access,
must either be thread safe, or declare a synchronization protocol so
that callers can follow cooperatively.

Zhong Yu

> In fact, many parts of the JDK
> were written before we even had the Java Memory Model.
>
> I think the safest assumption is to assume that unless documented, the API
> can not be accessed concurrently.  If an average programer wants to access
> it concurrently, then they better wrap it in a lock.  If a pressing need
> arises to make the API concurrent, then an enhancement request should be
> filed.  An expert will analyze the code and either update the documentation
> saying it can be accessed concurrently or fix the code and then document.
>
> As for being able to reorder operations, this has significant performance
> benefit.  Much of the performance progress in the past 10 years both in
> software and hardware has come from being more aggressive at reordering.
> For example, loop hoisting is extremely important for optimizing loops and
> can get huge benefits.  This one optimization has bitten many on this list.
> They didn't realize that they needed to declare the field as volatile.  As
> the stuff underneath us gets more aggressive, we are going to have to
> communicate better in our code as to what kinds of things are allowed to be
> done by underlying machinery (e.g. volatile).
>
> Here's another reordering example.  A memory fence on a core causes a huge
> stall.  It basically clears the execution pipeline since the subsequent data
> loads have to wait.  Cores need to be able to reorder instructions (loads)
> across memory fences.  A core could speculatively do the load and monitor
> the cache line.  If no one else in the system touches the cache line before
> the memory fence is finished, then the speculative load just prevented a
> stall.  If another core touches the cache line, then the speculation is
> thrown out and the instructions are restarted.  The core's performance is
> either on par or still ahead of stalling.  The great benefit of this is that
> the memory fence still appears to software to be enforced yet the core is
> able to perform well in spite of its existence.
>
> Nathan Reynolds | Architect | 602.333.9091
> Oracle PSR Engineering | Server Technology
> On 3/18/2013 1:32 PM, Gregg Wonderly wrote:
>
> Right, and what I am saying, is that things that the developer has not
> "coded" should not happen.  Ordering of what they've coded should be all
> that is something for them to consider when looking for concurrency or race
> conditions.
>
> Even if we had all ended up with massive EMSP (I did some research on this
> in college with some of the people who had worked on it, before this
> contract happened:
> http://www.thefreelibrary.com/AT%26T+WINS+$26.6+MILLION+NAVY+SOFTWARE+CONVERSION+CONTRACT-a012623510)
> processors with complete data flow analysis, there would still be SC with
> respect to each data item.  It can't be used before it exists.  Assigning
> this.name a value, before the value "exists" (not until arraycopy() returns
> does the value exist), is the problem.  There is no merit to any argument
> that says that the "software" should see such a state.  The developer did
> not code
>
> this.name = new char[len];
> System.arrayCopy( str.getBytes(), 0, this.name, 0, len );
>
> Maybe you can help me understand how you see this optimization as a benefit?
> Having the developer need to check every single function in any API to make
> sure it's been fixed to keep this optimization from biting them is where I'm
> struggling.  Software that used to work, before this kind of optimization
> was made, could now, just break or behave oddly and just by looking at it,
> how would any average developer know?
>
> Gregg Wonderly
>
> On 3/18/2013 2:53 PM, oleksandr otenko wrote:
>
> I am pointing out this is a problem of concurrent programming and no one
> said it
> is a */simple/* extension of a single-threaded world. You need to know all
> effects to know how to combine them.
>
> Do you expect the thread name to show IP address (someone mentioned that?)
> and
> the stack trace to show the thread processing that same request? How do you
> combine these? So you'd need to come up with what a consistent state is
> first.
>
> This is easily illustrated by a example of a thread dump where no thread
> holds
> the lock, yet has a few threads blocked on it. All because by the time the
> thread dump for the lock owner was taken, it released the lock.
>
> Alex
>
> On 18/03/2013 19:37, Gregg Wonderly wrote:
>
> So how does the developer know?  setName()/getName() have no visible
> contract
> do they?
>
> Gregg
>
> On 3/18/2013 12:42 PM, oleksandr otenko wrote:
>
> It is hardly surprising that in order to combine effects you need to know
> what
> the effects are.
>
> So nothing special about having to know what setName does to properly
> synchronize.
>
> Alex
>
> On 15/03/2013 21:46, Gregg Wonderly wrote:
>
> Yes, that transformation is legal, but it is also broken in the current
> design
> of that class.  Because Thread.setName() is callable, and because there is
> no
> other visible happensBefore with Thread.getName, the compiler can make the
> decision to designate these methods as intra-thread use only.
>
> That is the problem.  Even if I subsequently introduce a "happens before" by
> synchronizing or locking or something else, I have to know what the
> implementation is, know how it is broken and only then can I actually expect
> to achieve safe use of the provided API.
>
> I assert that this is completely and totally non-productive for software
> developers.  The JDK and many other large Java applications/libraries are
> broken in subtle ways, such as the missing "volatile" here. The compilers
> rewrite of such code into non-thread safe segments when the developer(s)
> might
> look at their code and say "that's racy, but safe, because I'll just use
> "synchronized" around my calls, is changing the outcome that breaks SC.  Yes
> SC is not supposed to be guaranteed in this case, but do JVM and hotspot
> developers really feel like they are doing great and wonderful things, when
> this kind of stuff is haunting everybody everywhere, because even the JDK
> has
> not been "fixed"?
>
> Gregg Wonderly
>
> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>
> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
>
> Nathan's example below is my issue...
>
>
> On 3/15/2013 12:29 AM, David Holmes wrote:
>
> Gregg,
>
> Gregg Wonderly writes:
>
>
> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>
> I've inlined the name.toCharArray() and rearranged a few
>
> operations that JIT
>
> could do.  If another thread reads this.name between its
>
> creation and the end of
>
> arraycopy() then the thread will see a partially filled char[].
>
>       public final void setName(String name) {
>           this.name = new char[name.length()];
>           System.arraycopy(..., 0, result, 0, name.length());
>
>
> If two different threads call setName concurrently, then if the code was
> transformed as shown above, then it is possible to see
>
> T1:           this.name = new char["some longer string".length()];
> T2:           this.name = new char["a short string".length()];
> T1:           System.arraycopy( "some longer string", 0,
>                         this.name, 0, "some longer string".length());
>
> Which will result in an exception at best and memory corruption at worse
> depending on how this.name is referenced.
>
> I think you are right, the compiler must not issue a load that did not
> exist in the source code (the compiler *is* aware that some other
> thread may be changing the variable).
>
> The following transformation should be legal
>
>        public final void setName(String name) {
>             char[]  tmp = new char[name.length()]
>             this.name = tmp;
>             System.arraycopy(name.value, 0, tmp, 0, name.length());
>
> Zhong Yu
>
> Gregg Wonderly
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From peter.levart at gmail.com  Mon Mar 18 18:49:24 2013
From: peter.levart at gmail.com (Peter Levart)
Date: Mon, 18 Mar 2013 23:49:24 +0100
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CAEJX8orMUUnogQmy2n99GX=nXFn1TpypOGqg0m9RdsOzTfsxwQ@mail.gmail.com>
References: <CACuKZqEQKULE0j=FNncG9W4iuzaQkaXd35FTSpWimemE8HJ-Kw@mail.gmail.com>
	<F8DF0611-61DA-4628-9E7C-6067026106D0@oracle.com>
	<CACuKZqEUAfo2jFugQkvSj_wQbSX4=dnBwaUhXubKr-PTuGQe7A@mail.gmail.com>
	<51434A4C.4000106@gmail.com>
	<CAEJX8orMUUnogQmy2n99GX=nXFn1TpypOGqg0m9RdsOzTfsxwQ@mail.gmail.com>
Message-ID: <514799F4.40400@gmail.com>


On 03/15/2013 06:08 PM, Stanimir Simeonoff wrote:
> Peter, the code races if there is concurrent invocation of getName() 
> and setName(), getName can overwrite  nameString w/ an oldValue. With 
> CAS it won't work and in such case making the char[] name volatile is 
> better.

Ah, yes ;-(...

I know making the field 'volatile' is the best solution, since that is 
not a hot spot anyway. But if the 'char[] name' array is used to 
communicate with the VM only in the direction VM -> Java in situation 
when Thread object is allocated by VM (for example when a foreign thread 
is "atatched" to VM) and the other way Java -> VM is always via 
setNativeName(), then the following modification of previous idea could 
also be possible, right?


public class Thread implements Runnable {

     private char name[];
     private String nameString;

     private void init(ThreadGroup g, Runnable target, String name,
                       long stackSize) {
         ...

         this.nameString = Objects.requireNonNull(name);
         ...

     }

     public final void setName(String name) {
         checkAccess();
         this.nameString = Objects.requireNonNull(name);
         if (threadStatus != 0) {
             setNativeName(name);
         }
     }

     public final String getName() {
         String nameString = this.nameString;
         return nameString == null ? new String(this.name) : nameString;
     }


Regards, Peter

>
> Stanimir
>
>
> On Fri, Mar 15, 2013 at 6:20 PM, Peter Levart <peter.levart at gmail.com 
> <mailto:peter.levart at gmail.com>> wrote:
>
>     Would this be a correct work-around without changing VM code and
>     adding 'volatile' to 'char name[]' field?
>
>
>     public class Thread implements Runnable {
>
>         private char name[];
>         private String nameString;
>
>         private void init(ThreadGroup g, Runnable target, String name,
>                           long stackSize) {
>             ...
>
>     this.name <http://this.name> = name.toCharArray();
>             this.nameString = name;
>             ...
>
>
>         }
>
>         public final void setName(String name) {
>             checkAccess();
>     this.name <http://this.name> = name.toCharArray();
>             this.nameString = name;
>             if (threadStatus != 0) {
>                 setNativeName(name);
>             }
>         }
>
>         public final String getName() {
>             String nameString = this.nameString;
>             if (nameString == null) {
>                 nameString = new String(this.name <http://this.name>);
>                 this.nameString = nameString;
>             }
>             return nameString;
>         }
>
>
>
>     ... assuming that 'nameString' field is only ever possible to be
>     null when VM allocates Thread object and only sets the 'char[]
>     name' and that this always HB any other thread dereferencing the
>     Thread object...
>
>     Regards, Peter
>
>
>     On 03/15/2013 07:53 AM, Zhong Yu wrote:
>
>         Mike, your suggestion does not seem to be able to walk around
>         the problem.
>
>         // shared
>              char name[];
>
>         Thread 1
>              char[] chars = {'a','b','c'};
>              String string1 = new String(chars);
>              name=string1.value;
>
>         Thread 2
>              String string2 = new String(name, true);
>
>         The final-ness of String.value does no good here, Thread 1 can
>         still
>         inline and reorder, to the effect that the array reference is
>         published before the array is filled. Thread 2 can still observe a
>         partially filled array. Even better, string2's content can be
>         observed
>         to mutate while the array is being filled!
>
>         Zhong Yu
>
>         On Thu, Mar 14, 2013 at 7:28 PM, Mike Duigou
>         <mike.duigou at oracle.com <mailto:mike.duigou at oracle.com>> wrote:
>
>             On Mar 14 2013, at 14:21 , Zhong Yu wrote:
>
>                 java.lang.Thread
>
>                     private char name[];
>
>                     public final void setName(String name) {
>                         checkAccess();
>                 this.name <http://this.name> = name.toCharArray();
>
>             The following suggestion is not for the weak of heart:
>
>             Since String.value is now always the same content as this
>             character array we could simply extract the character
>             array from the String instance. This would also seem to
>             correct the problem because for a String to be visible
>             it's value character array and contents would be visible.
>
>             Some people would probably consider this suggestion to be
>             morally dubious foolishness. They may be right.
>
>                     }
>
>                     public final String getName() {
>                         return String.valueOf(name);
>
>             Since we "know" that the character array is not modified
>             after assignment this could be replaced with the
>             String(char[], boolean) constructor. ibid "morally dubious
>             foolishness."
>
>                     }
>
>                 On the surface, set/getName() are not correctly
>                 synchronized,
>                 getName() could observe a partially filled char array.
>                 What's the
>                 story here?
>
>                 Zhong Yu
>
>         _______________________________________________
>         Concurrency-interest mailing list
>         Concurrency-interest at cs.oswego.edu
>         <mailto:Concurrency-interest at cs.oswego.edu>
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130318/280d925a/attachment-0001.html>

From davidcholmes at aapt.net.au  Mon Mar 18 18:53:19 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 19 Mar 2013 08:53:19 +1000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51478E8E.2030805@cytetech.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEFLJLAA.davidcholmes@aapt.net.au>

Gregg Wonderly writes:
>
> On 3/18/2013 3:50 PM, oleksandr otenko wrote:
> > On 18/03/2013 20:00, Gregg Wonderly wrote:
> >> On 3/18/2013 2:05 PM, oleksandr otenko wrote:
> >>> Why Sequential Consistency, of all consistency requirements?
> >>
> >> The rewrite provides a set of instructions, that when weaved
> by two or more
> >> threads, might (see below) cause "failure" of the VM. That is
> the problem for
> >> me.  The single statement,
> >>
> >>      this.name = name.toCharArray();
> >
> > I must point out that there is nothing saying
> name.toCharArray() doesn't write
> > anything to this.name during its operation before returning the
> result (which
> > you happen to assign to this.name). For all it matters, if the
> modification is
> > not visible by the caller, it may be happening in a
> single-threaded world.
>
> There has never been anything in the JLS that has allowed this.name to be
> assigned an incomplete value.

The JLS defines the basic intra-thread semantics of the language. An
implementation of the Java Platform must provide those semantics. But that
permits any reordering that is not observable by a single thread. For
multi-thread semantics the rules of Chapter 17 have to be obeyed - what we
generally refer to as the Java Memory Model (which for the record has always
existed but the early form of which was significantly flawed.) As long as
intra-thread semantics obey the JLS general definitions for how things work;
and inter-thread semantics obey the JMM, then a runtime system can
reorder/optimize however it likes. There is no requirement that an external
observer must always see actions consistent with the JLS definitions.

David
-----


> 15.26 is the Assignment Operators, 15.26.1, Simple assignment,
> states many
> things about the evaluation of the left side of the operator
> denoted as e.f.  It
> concludes with the text:
>
> "Otherwise, the variable denoted by e.f is assigned the value of
> the right hand
> operand as computed above"
>
> There is no visible text that says, 'if the right hand expression
> is an array,
> the array may be assigned before it is filled with any value
> generated by the
> evaluation of that expression' or anything similar.  It says the
> left hand is
> assigned the value computed from the expression on the right.
>
> Gregg Wonderly
>
> >> being transformed as Nathan illustrated violates the
> "developers" belief in
> >> what he coded.  This statement, by observation, is threadsafe
> with respect to
> >> the assignment of a value to this.name, and
> >
> > I don't see what makes it thread-safe, except when you look at
> the lines of code
> > as atomic units of execution.
>
> Precisely.  Lines of code exist because there is no other way to express
> "order".  They are in fact what developers expect to "complete",
> entirely.
> Unrelated lines of code may be reordered, but a line is a line!
> It has to do
> what it says it does, and the right side of assignment has to
> complete before
> the left side can be assigned.  I know that because long can have
> this problem,
> that it might seem perfectly good that the behavior here is
> consistent with that.
>
> However, I know how long is stored/used and I know that it isn't
> a "single"
> value on some processors.  Whereas object references "are"
> consistent, or else
> we would have real problems with every line needing to be
> synchronized.  Thus,
> my reasoning would cause me to say that this object reference
> would not be
> updated until the object was initialized (or that race could be
> exploited as a
> security risk in any many different APIs), and what you are
> suggesting, is that
> this will not be guaranteed.
>
> >> would appear to have no chance of causing an exception.   When
> one looks at
> >> the code in String.toCharArray(), inlining those two lines of code in
> >> String.toCharArray(), would seem probable to me as well, as Nathan's
> >> illustration seemed to point out.
> >>
> >> But I would never, ever guess that rather than use a temporary holder
> >> variable/register for the array allocated, that the value
> would instead be
> >> stored to this.name, before the arraycopy() call.
> > A temporary holder variable is in memory? Then you have one
> more write and read.
> >
> > A plausible sequence of instructions: allocate, store address
> in EDI, use REP
> > MOVSB to copy - EDI is ruined after copy. Why not store address
> to this.name
> > before starting to copy?
>
> I understand how all of these optimizations are focused on
> staying away from
> memory, even the stack I suppose.  I used to do this kind of
> jockeying with hand
> coded assembler on the Z-80 and TI-9900, decades ago. The results
> still have to
> be correct, and a partially initialized array is not specified as
> valid in the
> JLS as far as I read.
>
> >>
> >> Now, I will concede that the arraycopy() might in fact use the
> exact value
> >> returned from the array allocation, instead of referencing
> this.name, but I
> >> don't know that.
> >
> > It doesn't matter. Getting used to the idea that correct
> single-threaded code is
> > not always correct in a concurrent setting, helps.
>
> I guess it's hard for you to understand that I already know this,
> since we don't
> really know each others history.  The first time that I ran Java
> 1.5 code on a
> dual core machine, I was bit by the loop exit hoist that happens
> to code like
> the following.
>
> class foo {
> 	boolean bar;
> 	public void work() {
> 		while(!bar ) {
> 			..do the work..
> 		}
> 	}
> 	public void setBar( boolean how ) {
> 		bar = how;
> 	}
> }
>
> I would expect that visibility would be a problem that might
> cause bar to not be
> set immediately, but the JLS doesn't say that this will be rewritten as
>
> 		if( !bar ) {
> 			while( true ) {
> 			}
> 		}
>
> That was the first disaster that optimization of non-volatile
> values created.  I
> think I lost about a day at least, of work trying to understand
> why the loop
> would not exit.  I think I had to post on this list to get a hint
> that this was
> happening.  No documentation on the planet says that this will
> happen and then
> tells me to code accordingly.  Prior to 1.5, volatile was
> meaningless, and for
> 1.5 to change code that was working to non-working code just
> seemed completely
> pointless and downright ridiculous.  To this day, I still find
> this rewrite
> killing working code, and thus I just paste "volatile" on every single
> declaration, because there is no telling what silly, pointless
> optimization
> (pointless from the perspective that it doesn't 'fix' anything if
> it breaks
> code) will be injected into the JDK next.
>
> In the JLS, 8.3.1.4 has information about ordering of non-volatile value
> references/updates.  This is the expected, old details about
> unrelated values
> being updated out of program order.  If neither i nor j were
> volatile, then the
> expression i = ++j, used in "one()" in that example could produce
> the values
> where i is one less than j.  But you should never see i greater
> than j.  That
> just doesn't make programmatic sense based on the expression.
> But, I would
> honestly expect that kind of silly optimization to be made.  So
> that it was
> rewritten as effectively
>
> 	j = i = j + 1;
>
> Why in the world would we want to force the use of volatile
> unless it's actually
> useful to the developer to guarantee something important to them?
>  These kinds
> of optimizations just make debugging hard.  People will go in and
> declare i and
> j volatile so that their debugging message works, and it's not
> really necessary
> to do that.
>
> Gregg
>
> >
> >> Nathan's example was devoid of the exact semantics of how the
> arguments to
> >> arraycopy() were sourced.
> >>
> >> If the code that actually would exist would look like
> >>
> >>         char result[] = this.name = new char[value.length];
> >>         System.arraycopy(value, 0, result, 0, value.length);
> >>
> >> Then of course, all is well regarding an
> ArrayIndexOutOfBoundsException,
> >> because that wouldn't happen.
> > It won't surprise me even if it throws
> ArrayIndexOutOfBoundsException. If you
> > stop considering that all calls to setName are serialized, then
> you synchronize
> > all calls to setName yourself.
> >
> >
> >>
> >> However, it would still be possible for getName() to be called
> with an array
> >> that was not completely populated with the actual 'value' string.
> > If setName or toCharArray is a black box, then you don't know
> whether it sets
> > this.name to any other values between the start and end of the
> setName call. If
> > you deny all knowledge of how it is done, then you need to
> accept this is a
> > valid way to do it.
> >
> >
> > Alex
> >
> > PS I am only trying to demonstrate from a wider angle that
> certain types of
> > guarantees are not possible, if you consider a function as a
> black box. For the
> > system as a whole to be sequentially consistent, you need to
> consider the system
> > as a whole. Use of Sequentially Consistent black boxes doesn't
> mean the result
> > is sequentially consistent.
> >
> > Whereas knowing what setName does is a pain, I don't think it
> is avoidable.
> >
> >
> >>
> >> I just don't see how it's exciting or even comfortable to feel
> like a public
> >> API should require 'work' of this nature to use effectively.
> >>
> >> I just don't understand how there is any advantage at all to assigning
> >> this.name before the array is filled.  If there is a temporary
> >> variable/register used so that arraycopy() can be called with
> that as the
> >> third argument, then the assignment can be called after that.
> If, instead
> >> there is no temp variable/register used, then we may be back
> to the AIOOBE
> >> being the issue if this.name is the third argument to arraycopy().
> >>
> >> Gregg Wonderly
> >>
> >> > As an example,
> >>> Vector and Hashtable will return "consistent" results, but
> that doesn't
> >>> eliminate races between get and put - what sort of
> consistency guarantee do you
> >>> get?
> >>>
> >>> Also, bear in mind that 2 billion calls to Vector and
> Hashtable methods will
> >>> create about 8 minutes of runtime overhead even on a
> single-threaded flow - no
> >>> contention, just the cost of those instructions (compared to
> exactly the same
> >>> test, but on a uniprocessor = JVM optimizes away the atomics
> on the locks).
> >>> (this is not the latest HotSpot, but I think a useful rule of
> thumb) Maybe if
> >>> you count all field mutations in your workflow you can see
> why non-volatile
> >>> accesses is the default.
> >>>
> >>>
> >>> Alex
> >>>
> >>>
> >>> On 15/03/2013 05:14, Gregg Wonderly wrote:
> >>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
> >>>>> I've inlined the name.toCharArray() and rearranged a few
> operations that JIT
> >>>>> could do.  If another thread reads this.name between its
> creation and the
> >>>>> end of
> >>>>> arraycopy() then the thread will see a partially filled char[].
> >>>>>
> >>>>>      public final void setName(String name) {
> >>>>>          this.name = new char[name.length()];
> >>>>>          System.arraycopy(..., 0, result, 0, name.length());
> >>>>>      }
> >>>>
> >>>> This rewrite/optimization doesn't seem to meet sequential
> consistency ordering
> >>>> requirements.  I don't see how this could be considered SC
> since it creates a
> >>>> different result (uninitialized value) then the way that the
> original source
> >>>> was coded did not.
> >>>>
> >>>> If the JIT is actually doing this when concurrency is not detected
> >>>> (non-volatile and no other happensBefore/fence), its no
> wonder we have so many
> >>>> developers plagued with unexplainable racy program bugs.
> >>>>
> >>>> I thought the rewrite of while( nonvolatileBoolean ){} to if
> >>>> (nonvolatileBoolean) { while (true ) {} } was bad enough of
> a mistake.  This
> >>>> just wreaks of frustration for developers.
> >>>>
> >>>> How is this optimization more efficient, really?  Are we
> really so interested
> >>>> in absolutely most efficient that we've given up on letting
> developers decide
> >>>> when performance matters and then optimize to "incorrect" on
> their own terms?
> >>>>
> >>>> This kind optimization, if it is actually occurring is
> another example of
> >>>> insidious change in program behavior...
> >>>>
> >>>> Gregg Wonderly
> >>>>
> >>>>>
> >>>>> Nathan Reynolds
> >>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> >>>>> Architect | 602.333.9091
> >>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
> Technology
> >>>>> On 3/14/2013 4:03 PM, Pete Guyatt wrote:
> >>>>>> I'm sure I'm missing something here but I don't quite see how the
> >>>>>> character array can be scrambled.
> >>>>>>
> >>>>>> I can see how it "racy" and how an inconsistent write/read
> happens where a
> >>>>>> thread calls setName -- could be the thread itself or
> another thread --
> >>>>>> and another calls getName but from what I can see the
> assignment of the
> >>>>>> new value to the name[] array is only going to happen
> after the call to
> >>>>>> toCharArray completes. I thought this would be the case
> even with the JVM
> >>>>>> performing some reordering of instructions.
> >>>>>>
> >>>>>> Would someone mind clarifying?
> >>>>>>
> >>>>>> Kind Regards,
> >>>>>>
> >>>>>> Pete
> >>>>>>
> >>>>>> On 2013-03-14 4:47 PM, "Zhong Yu"<zhong.j.yu at gmail.com> wrote:
> >>>>>>
> >>>>>>> On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
> >>>>>>> <stanimir at riflexo.com>  wrote:
> >>>>>>>> We already agree about being racy. Unline the clone()
> method 'name' has
> >>>>>>>> no
> >>>>>>>> critical applications (or at least shall not), so I
> presume it was never
> >>>>>>>> considered a problem to warrant a volatile field.
> >>>>>>> A non-volatile String field would be ok.
> >>>>>>>
> >>>>>>> Since getName() can be invoked by anyone at anytime, it's
> troubling
> >>>>>>> that it could observe a scrambled name.
> >>>>>>>
> >>>>>>> Zhong Yu
> >>>>>>>
> >>>>>>>> On Thu, Mar 14, 2013 at 11:55 PM, Zhong
> Yu<zhong.j.yu at gmail.com> wrote:
> >>>>>>>>> It's a common practice to modify thread names on the fly, for
> >>>>>>>>> diagnosis purposes.
> >>>>>>>>>
> >>>>>>>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
> >>>>>>>>> <stanimir at riflexo.com>  wrote:
> >>>>>>>>>> char[] name is usually initialized in the c-tor, in
> that case it'd be
> >>>>>>>>>> fine.
> >>>>>>>>>> Since the access to 'name' is racy to begin, the
> changes may not be
> >>>>>>>>>> necessarily 'visible'.
> >>>>>>>>>>
> >>>>>>>>>> Stanimir
> >>>>>>>>>>
> >>>>>>>>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong
> Yu<zhong.j.yu at gmail.com>
> >>>>>>>>> wrote:
> >>>>>>>>>>> java.lang.Thread
> >>>>>>>>>>>
> >>>>>>>>>>>      private char name[];
> >>>>>>>>>>>
> >>>>>>>>>>>      public final void setName(String name) {
> >>>>>>>>>>>          checkAccess();
> >>>>>>>>>>>          this.name = name.toCharArray();
> >>>>>>>>>>>      }
> >>>>>>>>>>>
> >>>>>>>>>>>      public final String getName() {
> >>>>>>>>>>>          return String.valueOf(name);
> >>>>>>>>>>>      }
> >>>>>>>>>>>
> >>>>>>>>>>> On the surface, set/getName() are not correctly synchronized,
> >>>>>>>>>>> getName() could observe a partially filled char
> array. What's the
> >>>>>>>>>>> story here?
> >>>>>>>>>>>
> >>>>>>>>>>> Zhong Yu
> >>>>>>>>>>>
> >>>>>>>>>>> _______________________________________________
> >>>>>>>>>>> Concurrency-interest mailing list
> >>>>>>>>>>> Concurrency-interest at cs.oswego.edu
> >>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>>>>>>>
> >>>>>>>>
> >>>>>>> _______________________________________________
> >>>>>>> Concurrency-interest mailing list
> >>>>>>> Concurrency-interest at cs.oswego.edu
> >>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>>>
> >>>>>> _______________________________________________
> >>>>>> Concurrency-interest mailing list
> >>>>>> Concurrency-interest at cs.oswego.edu
> >>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>>>
> >>>>>>
> >>>>>
> >>>>>
> >>>>>
> >>>>> _______________________________________________
> >>>>> Concurrency-interest mailing list
> >>>>> Concurrency-interest at cs.oswego.edu
> >>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>>
> >>>>
> >>>> _______________________________________________
> >>>> Concurrency-interest mailing list
> >>>> Concurrency-interest at cs.oswego.edu
> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>
> >>>
> >>
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> -----
> No virus found in this message.
> Checked by AVG - www.avg.com
> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
> Internal Virus Database is out of date.
>


From davidcholmes at aapt.net.au  Mon Mar 18 19:00:56 2013
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 19 Mar 2013 09:00:56 +1000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <514799F4.40400@gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEFMJLAA.davidcholmes@aapt.net.au>

Peter,

Simplest fix is to make setName synchronized, and name volatile. That way we
fix the current get/set race without too much overhead on get, and this has
the added advantage that we can then relax setNativeThreadName to work on
any thread - as it will no longer be able to terminate while being operated
upon due to the use of synchronized (and the way synchronized is used with
thread termination).

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter Levart
  Sent: Tuesday, 19 March 2013 8:49 AM
  To: Stanimir Simeonoff
  Cc: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Thread safety of Thread.getName()




  On 03/15/2013 06:08 PM, Stanimir Simeonoff wrote:

    Peter, the code races if there is concurrent invocation of getName() and
setName(), getName can overwrite  nameString w/ an oldValue. With CAS it
won't work and in such case making the char[] name volatile is better.


  Ah, yes ;-(...

  I know making the field 'volatile' is the best solution, since that is not
a hot spot anyway. But if the 'char[] name' array is used to communicate
with the VM only in the direction VM -> Java in situation when Thread object
is allocated by VM (for example when a foreign thread is "atatched" to VM)
and the other way Java -> VM is always via setNativeName(), then the
following modification of previous idea could also be possible, right?


  public class Thread implements Runnable {

      private char name[];
      private String nameString;

      private void init(ThreadGroup g, Runnable target, String name,
                        long stackSize) {
          ...

          this.nameString = Objects.requireNonNull(name);
          ...

      }

      public final void setName(String name) {
          checkAccess();
          this.nameString = Objects.requireNonNull(name);
          if (threadStatus != 0) {
              setNativeName(name);
          }
      }

      public final String getName() {
          String nameString = this.nameString;
          return nameString == null ? new String(this.name) : nameString;
      }


  Regards, Peter



    Stanimir



    On Fri, Mar 15, 2013 at 6:20 PM, Peter Levart <peter.levart at gmail.com>
wrote:

      Would this be a correct work-around without changing VM code and
adding 'volatile' to 'char name[]' field?


      public class Thread implements Runnable {

          private char name[];
          private String nameString;

          private void init(ThreadGroup g, Runnable target, String name,
                            long stackSize) {
              ...

              this.name = name.toCharArray();
              this.nameString = name;
              ...


          }

          public final void setName(String name) {
              checkAccess();
              this.name = name.toCharArray();

              this.nameString = name;
              if (threadStatus != 0) {
                  setNativeName(name);
              }
          }

          public final String getName() {
              String nameString = this.nameString;
              if (nameString == null) {
                  nameString = new String(this.name);
                  this.nameString = nameString;
              }
              return nameString;
          }



      ... assuming that 'nameString' field is only ever possible to be null
when VM allocates Thread object and only sets the 'char[] name' and that
this always HB any other thread dereferencing the Thread object...

      Regards, Peter


      On 03/15/2013 07:53 AM, Zhong Yu wrote:

        Mike, your suggestion does not seem to be able to walk around the
problem.

        // shared
             char name[];

        Thread 1
             char[] chars = {'a','b','c'};
             String string1 = new String(chars);
             name=string1.value;

        Thread 2
             String string2 = new String(name, true);

        The final-ness of String.value does no good here, Thread 1 can still
        inline and reorder, to the effect that the array reference is
        published before the array is filled. Thread 2 can still observe a
        partially filled array. Even better, string2's content can be
observed
        to mutate while the array is being filled!

        Zhong Yu

        On Thu, Mar 14, 2013 at 7:28 PM, Mike Duigou
<mike.duigou at oracle.com> wrote:

          On Mar 14 2013, at 14:21 , Zhong Yu wrote:


            java.lang.Thread

                private char name[];

                public final void setName(String name) {
                    checkAccess();
                    this.name = name.toCharArray();

          The following suggestion is not for the weak of heart:

          Since String.value is now always the same content as this
character array we could simply extract the character array from the String
instance. This would also seem to correct the problem because for a String
to be visible it's value character array and contents would be visible.

          Some people would probably consider this suggestion to be morally
dubious foolishness. They may be right.


                }

                public final String getName() {
                    return String.valueOf(name);

          Since we "know" that the character array is not modified after
assignment this could be replaced with the String(char[], boolean)
constructor. ibid "morally dubious foolishness."


                }

            On the surface, set/getName() are not correctly synchronized,
            getName() could observe a partially filled char array. What's
the
            story here?

            Zhong Yu

        _______________________________________________
        Concurrency-interest mailing list
        Concurrency-interest at cs.oswego.edu
        http://cs.oswego.edu/mailman/listinfo/concurrency-interest


      _______________________________________________
      Concurrency-interest mailing list
      Concurrency-interest at cs.oswego.edu
      http://cs.oswego.edu/mailman/listinfo/concurrency-interest




-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130319/0c235c19/attachment-0001.html>

From vitalyd at gmail.com  Mon Mar 18 19:06:37 2013
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 18 Mar 2013 19:06:37 -0400
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEFKJLAA.davidcholmes@aapt.net.au>
References: <51476D10.5090001@cytetech.com>
	<NFBBKALFDCPFIDBNKAPCEEFKJLAA.davidcholmes@aapt.net.au>
Message-ID: <CAHjP37GFoNT7yODAq88Q5QK1c0SSWB33+VXWHXB5bkYRHGX=gg@mail.gmail.com>

This.  I'm very surprised where this thread has ended up.  I don't
understand why there's an assumption that accessing non-threadsafe APIs
from multiple threads will somehow always work.  I do understand the
argument for fixing get/setName to be correct under concurrency, but the
general discussion around compiler optimizations breaking non-threadsafe
code when accessed concurrently is a bit puzzling, IMHO.

Sent from my phone
On Mar 18, 2013 6:35 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:

> Gregg Wonderly writes:
> >
> > So how does the developer know?  setName()/getName() have no
> > visible contract do they?
>
> Basic rule: if it doesn't say it is thread-safe then assume it is not.
>
> If people did this and then complained when things should be thread-safe
> then hopefully we wouldn't get this kind of discussion 15 years later!
>
> David
> -----
>
> >
> > Gregg
> >
> > On 3/18/2013 12:42 PM, oleksandr otenko wrote:
> > > It is hardly surprising that in order to combine effects you
> > need to know what
> > > the effects are.
> > >
> > > So nothing special about having to know what setName does to
> > properly synchronize.
> > >
> > > Alex
> > >
> > > On 15/03/2013 21:46, Gregg Wonderly wrote:
> > >> Yes, that transformation is legal, but it is also broken in
> > the current design
> > >> of that class.  Because Thread.setName() is callable, and
> > because there is no
> > >> other visible happensBefore with Thread.getName, the compiler
> > can make the
> > >> decision to designate these methods as intra-thread use only.
> > >>
> > >> That is the problem.  Even if I subsequently introduce a
> > "happens before" by
> > >> synchronizing or locking or something else, I have to know what the
> > >> implementation is, know how it is broken and only then can I
> > actually expect
> > >> to achieve safe use of the provided API.
> > >>
> > >> I assert that this is completely and totally non-productive
> > for software
> > >> developers.  The JDK and many other large Java
> > applications/libraries are
> > >> broken in subtle ways, such as the missing "volatile" here.
> > The compilers
> > >> rewrite of such code into non-thread safe segments when the
> > developer(s) might
> > >> look at their code and say "that's racy, but safe, because
> > I'll just use
> > >> "synchronized" around my calls, is changing the outcome that
> > breaks SC.  Yes
> > >> SC is not supposed to be guaranteed in this case, but do JVM
> > and hotspot
> > >> developers really feel like they are doing great and wonderful
> > things, when
> > >> this kind of stuff is haunting everybody everywhere, because
> > even the JDK has
> > >> not been "fixed"?
> > >>
> > >> Gregg Wonderly
> > >>
> > >> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
> > >>
> > >>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly
> > <gregg at cytetech.com> wrote:
> > >>>> Nathan's example below is my issue...
> > >>>>
> > >>>>
> > >>>> On 3/15/2013 12:29 AM, David Holmes wrote:
> > >>>>> Gregg,
> > >>>>>
> > >>>>> Gregg Wonderly writes:
> > >>>>>>
> > >>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
> > >>>>>>> I've inlined the name.toCharArray() and rearranged a few
> > >>>>>> operations that JIT
> > >>>>>>> could do.  If another thread reads this.name between its
> > >>>>>> creation and the end of
> > >>>>>>> arraycopy() then the thread will see a partially filled char[].
> > >>>>>>>
> > >>>>>>>       public final void setName(String name) {
> > >>>>>>>           this.name = new char[name.length()];
> > >>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
> > >>>>
> > >>>> If two different threads call setName concurrently, then if
> > the code was
> > >>>> transformed as shown above, then it is possible to see
> > >>>>
> > >>>> T1:           this.name = new char["some longer string".length()];
> > >>>> T2:           this.name = new char["a short string".length()];
> > >>>> T1:           System.arraycopy( "some longer string", 0,
> > >>>>                         this.name, 0, "some longer
> string".length());
> > >>>>
> > >>>> Which will result in an exception at best and memory
> > corruption at worse
> > >>>> depending on how this.name is referenced.
> > >>> I think you are right, the compiler must not issue a load that did
> not
> > >>> exist in the source code (the compiler *is* aware that some other
> > >>> thread may be changing the variable).
> > >>>
> > >>> The following transformation should be legal
> > >>>
> > >>>        public final void setName(String name) {
> > >>>             char[]  tmp = new char[name.length()]
> > >>>             this.name = tmp;
> > >>>             System.arraycopy(name.value, 0, tmp, 0, name.length());
> > >>>
> > >>> Zhong Yu
> > >>>
> > >>>> Gregg Wonderly
> > >>>>
> > >>>> _______________________________________________
> > >>>> Concurrency-interest mailing list
> > >>>> Concurrency-interest at cs.oswego.edu
> > >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >>> _______________________________________________
> > >>> Concurrency-interest mailing list
> > >>> Concurrency-interest at cs.oswego.edu
> > >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >>
> > >> _______________________________________________
> > >> Concurrency-interest mailing list
> > >> Concurrency-interest at cs.oswego.edu
> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > -----
> > No virus found in this message.
> > Checked by AVG - www.avg.com
> > Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
> > Internal Virus Database is out of date.
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130318/ec99666b/attachment.html>

From peter.levart at gmail.com  Tue Mar 19 02:55:41 2013
From: peter.levart at gmail.com (Peter Levart)
Date: Tue, 19 Mar 2013 07:55:41 +0100
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEFMJLAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCAEFMJLAA.davidcholmes@aapt.net.au>
Message-ID: <51480BED.1020900@gmail.com>

You're right,

I also forgot about the setName()/setNativeName(), where Java-view and 
native-view could get out of sync in face of race...

Regards, Peter

On 03/19/2013 12:00 AM, David Holmes wrote:
> Peter,
> Simplest fix is to make setName synchronized, and name volatile. That 
> way we fix the current get/set race without too much overhead on get, 
> and this has the added advantage that we can then relax 
> setNativeThreadName to work on any thread - as it will no longer be 
> able to terminate while being operated upon due to the use of 
> synchronized (and the way synchronized is used with thread termination).
> David
>
>     -----Original Message-----
>     *From:* concurrency-interest-bounces at cs.oswego.edu
>     [mailto:concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of
>     *Peter Levart
>     *Sent:* Tuesday, 19 March 2013 8:49 AM
>     *To:* Stanimir Simeonoff
>     *Cc:* concurrency-interest at cs.oswego.edu
>     *Subject:* Re: [concurrency-interest] Thread safety of
>     Thread.getName()
>
>
>     On 03/15/2013 06:08 PM, Stanimir Simeonoff wrote:
>>     Peter, the code races if there is concurrent invocation of
>>     getName() and setName(), getName can overwrite  nameString w/ an
>>     oldValue. With CAS it won't work and in such case making the
>>     char[] name volatile is better.
>
>     Ah, yes ;-(...
>
>     I know making the field 'volatile' is the best solution, since
>     that is not a hot spot anyway. But if the 'char[] name' array is
>     used to communicate with the VM only in the direction VM -> Java
>     in situation when Thread object is allocated by VM (for example
>     when a foreign thread is "atatched" to VM) and the other way Java
>     -> VM is always via setNativeName(), then the following
>     modification of previous idea could also be possible, right?
>
>
>     public class Thread implements Runnable {
>
>         private char name[];
>         private String nameString;
>
>         private void init(ThreadGroup g, Runnable target, String name,
>                           long stackSize) {
>             ...
>
>             this.nameString = Objects.requireNonNull(name);
>             ...
>
>         }
>
>         public final void setName(String name) {
>             checkAccess();
>             this.nameString = Objects.requireNonNull(name);
>             if (threadStatus != 0) {
>                 setNativeName(name);
>             }
>         }
>
>         public final String getName() {
>             String nameString = this.nameString;
>             return nameString == null ? new String(this.name) :
>     nameString;
>         }
>
>
>     Regards, Peter
>
>>
>>     Stanimir
>>
>>
>>     On Fri, Mar 15, 2013 at 6:20 PM, Peter Levart
>>     <peter.levart at gmail.com <mailto:peter.levart at gmail.com>> wrote:
>>
>>         Would this be a correct work-around without changing VM code
>>         and adding 'volatile' to 'char name[]' field?
>>
>>
>>         public class Thread implements Runnable {
>>
>>             private char name[];
>>             private String nameString;
>>
>>             private void init(ThreadGroup g, Runnable target, String
>>         name,
>>                               long stackSize) {
>>                 ...
>>
>>         this.name <http://this.name> = name.toCharArray();
>>                 this.nameString = name;
>>                 ...
>>
>>
>>             }
>>
>>             public final void setName(String name) {
>>                 checkAccess();
>>         this.name <http://this.name> = name.toCharArray();
>>                 this.nameString = name;
>>                 if (threadStatus != 0) {
>>                     setNativeName(name);
>>                 }
>>             }
>>
>>             public final String getName() {
>>                 String nameString = this.nameString;
>>                 if (nameString == null) {
>>                     nameString = new String(this.name
>>         <http://this.name>);
>>                     this.nameString = nameString;
>>                 }
>>                 return nameString;
>>             }
>>
>>
>>
>>         ... assuming that 'nameString' field is only ever possible to
>>         be null when VM allocates Thread object and only sets the
>>         'char[] name' and that this always HB any other thread
>>         dereferencing the Thread object...
>>
>>         Regards, Peter
>>
>>
>>         On 03/15/2013 07:53 AM, Zhong Yu wrote:
>>
>>             Mike, your suggestion does not seem to be able to walk
>>             around the problem.
>>
>>             // shared
>>                  char name[];
>>
>>             Thread 1
>>                  char[] chars = {'a','b','c'};
>>                  String string1 = new String(chars);
>>                  name=string1.value;
>>
>>             Thread 2
>>                  String string2 = new String(name, true);
>>
>>             The final-ness of String.value does no good here, Thread
>>             1 can still
>>             inline and reorder, to the effect that the array reference is
>>             published before the array is filled. Thread 2 can still
>>             observe a
>>             partially filled array. Even better, string2's content
>>             can be observed
>>             to mutate while the array is being filled!
>>
>>             Zhong Yu
>>
>>             On Thu, Mar 14, 2013 at 7:28 PM, Mike Duigou
>>             <mike.duigou at oracle.com <mailto:mike.duigou at oracle.com>>
>>             wrote:
>>
>>                 On Mar 14 2013, at 14:21 , Zhong Yu wrote:
>>
>>                     java.lang.Thread
>>
>>                         private char name[];
>>
>>                         public final void setName(String name) {
>>                             checkAccess();
>>                     this.name <http://this.name> = name.toCharArray();
>>
>>                 The following suggestion is not for the weak of heart:
>>
>>                 Since String.value is now always the same content as
>>                 this character array we could simply extract the
>>                 character array from the String instance. This would
>>                 also seem to correct the problem because for a String
>>                 to be visible it's value character array and contents
>>                 would be visible.
>>
>>                 Some people would probably consider this suggestion
>>                 to be morally dubious foolishness. They may be right.
>>
>>                         }
>>
>>                         public final String getName() {
>>                             return String.valueOf(name);
>>
>>                 Since we "know" that the character array is not
>>                 modified after assignment this could be replaced with
>>                 the String(char[], boolean) constructor. ibid
>>                 "morally dubious foolishness."
>>
>>                         }
>>
>>                     On the surface, set/getName() are not correctly
>>                     synchronized,
>>                     getName() could observe a partially filled char
>>                     array. What's the
>>                     story here?
>>
>>                     Zhong Yu
>>
>>             _______________________________________________
>>             Concurrency-interest mailing list
>>             Concurrency-interest at cs.oswego.edu
>>             <mailto:Concurrency-interest at cs.oswego.edu>
>>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>         _______________________________________________
>>         Concurrency-interest mailing list
>>         Concurrency-interest at cs.oswego.edu
>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130319/cd123eb0/attachment-0001.html>

From chris.hegarty at oracle.com  Tue Mar 19 06:56:21 2013
From: chris.hegarty at oracle.com (Chris Hegarty)
Date: Tue, 19 Mar 2013 10:56:21 +0000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CAEJX8ooBZAj9e2adoOiAt8jL-nOkQZWF4Y_OG+834eX4HEx6TA@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEDKJLAA.davidcholmes@aapt.net.au>
	<5143DB4B.5070505@cytetech.com> <51474050.8000305@oracle.com>
	<CAEJX8ooBZAj9e2adoOiAt8jL-nOkQZWF4Y_OG+834eX4HEx6TA@mail.gmail.com>
Message-ID: <51484455.5030405@oracle.com>

On 03/18/2013 09:39 PM, Stanimir Simeonoff wrote:
> ....
> Here is a nasty bug in sun.net.www.protocol.jar.JarFileFactory ::
> close(JarFile jarFile). The bug is far more severe than Thread.getName().
>
> The method should be synchronized(this) (or just have the sync bit)
> Otherwise it accesses the HashMaps in absolute thread-unsafe manner +
> there is a race between both operation as bonus.
> Now closing JarFile I had to manually synchronize to the instance.

Ouch! Thanks for reporting this issue Stanimir.

I filed 8010282: "sun.net.www.protocol.jar.JarFileFactory.close(JarFile) 
should be thread-safe", should be visible soon [1].

I will post a patch on net-dev [2] to resolve it. And then seek to 
backport to 7uXX.

-Chris.

[1] http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=8010282
[2] http://mail.openjdk.java.net/mailman/listinfo/net-dev

From gregg at cytetech.com  Tue Mar 19 09:24:04 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 19 Mar 2013 08:24:04 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEFKJLAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCEEFKJLAA.davidcholmes@aapt.net.au>
Message-ID: <514866F4.7030201@cytetech.com>

On 3/18/2013 5:31 PM, David Holmes wrote:
> Gregg Wonderly writes:
>>
>> So how does the developer know?  setName()/getName() have no
>> visible contract do they?
>
> Basic rule: if it doesn't say it is thread-safe then assume it is not.
>
> If people did this and then complained when things should be thread-safe
> then hopefully we wouldn't get this kind of discussion 15 years later!

This is my issue.  The evolution of support for concurrency has not made Java 
more stable.  It's made it possible to create much more stable applications, but 
code that used to "work" doesn't, as more and more of the JMM specified 
behaviors are used to justify optimizations that make the JLS less meaningful as 
a resource for what any particular JVM will do with a line of code.

We can have the "it's a racy design" discussion all day long, but in the end, 
I'm extremely concerned that developers, overall, have limited abilities to 
actually get this right.  There's still old broken code out there that is 
working just fine.  But, as these optimizations are injected, that code breaks, 
and people throw it away and switch platforms, or make other rash decisions 
because they can't understand the behaviors when intra-statement ordering 
changes and creates completely unexplainable behaviors (to them anyway).

Gregg

> David
> -----
>
>>
>> Gregg
>>
>> On 3/18/2013 12:42 PM, oleksandr otenko wrote:
>>> It is hardly surprising that in order to combine effects you
>> need to know what
>>> the effects are.
>>>
>>> So nothing special about having to know what setName does to
>> properly synchronize.
>>>
>>> Alex
>>>
>>> On 15/03/2013 21:46, Gregg Wonderly wrote:
>>>> Yes, that transformation is legal, but it is also broken in
>> the current design
>>>> of that class.  Because Thread.setName() is callable, and
>> because there is no
>>>> other visible happensBefore with Thread.getName, the compiler
>> can make the
>>>> decision to designate these methods as intra-thread use only.
>>>>
>>>> That is the problem.  Even if I subsequently introduce a
>> "happens before" by
>>>> synchronizing or locking or something else, I have to know what the
>>>> implementation is, know how it is broken and only then can I
>> actually expect
>>>> to achieve safe use of the provided API.
>>>>
>>>> I assert that this is completely and totally non-productive
>> for software
>>>> developers.  The JDK and many other large Java
>> applications/libraries are
>>>> broken in subtle ways, such as the missing "volatile" here.
>> The compilers
>>>> rewrite of such code into non-thread safe segments when the
>> developer(s) might
>>>> look at their code and say "that's racy, but safe, because
>> I'll just use
>>>> "synchronized" around my calls, is changing the outcome that
>> breaks SC.  Yes
>>>> SC is not supposed to be guaranteed in this case, but do JVM
>> and hotspot
>>>> developers really feel like they are doing great and wonderful
>> things, when
>>>> this kind of stuff is haunting everybody everywhere, because
>> even the JDK has
>>>> not been "fixed"?
>>>>
>>>> Gregg Wonderly
>>>>
>>>> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>>>
>>>>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly
>> <gregg at cytetech.com> wrote:
>>>>>> Nathan's example below is my issue...
>>>>>>
>>>>>>
>>>>>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>>>>>> Gregg,
>>>>>>>
>>>>>>> Gregg Wonderly writes:
>>>>>>>>
>>>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>>>>>>>> operations that JIT
>>>>>>>>> could do.  If another thread reads this.name between its
>>>>>>>> creation and the end of
>>>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>>>
>>>>>>>>>        public final void setName(String name) {
>>>>>>>>>            this.name = new char[name.length()];
>>>>>>>>>            System.arraycopy(..., 0, result, 0, name.length());
>>>>>>
>>>>>> If two different threads call setName concurrently, then if
>> the code was
>>>>>> transformed as shown above, then it is possible to see
>>>>>>
>>>>>> T1:           this.name = new char["some longer string".length()];
>>>>>> T2:           this.name = new char["a short string".length()];
>>>>>> T1:           System.arraycopy( "some longer string", 0,
>>>>>>                          this.name, 0, "some longer string".length());
>>>>>>
>>>>>> Which will result in an exception at best and memory
>> corruption at worse
>>>>>> depending on how this.name is referenced.
>>>>> I think you are right, the compiler must not issue a load that did not
>>>>> exist in the source code (the compiler *is* aware that some other
>>>>> thread may be changing the variable).
>>>>>
>>>>> The following transformation should be legal
>>>>>
>>>>>         public final void setName(String name) {
>>>>>              char[]  tmp = new char[name.length()]
>>>>>              this.name = tmp;
>>>>>              System.arraycopy(name.value, 0, tmp, 0, name.length());
>>>>>
>>>>> Zhong Yu
>>>>>
>>>>>> Gregg Wonderly
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> -----
>> No virus found in this message.
>> Checked by AVG - www.avg.com
>> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
>> Internal Virus Database is out of date.
>>
>
>
>


From gregg at cytetech.com  Tue Mar 19 09:32:37 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 19 Mar 2013 08:32:37 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <CACuKZqGRWavEDGvMTF+FD+Q+bOEUE315hOpnbkT2P83o06ThiQ@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEDEJLAA.davidcholmes@aapt.net.au>
	<51438300.1080204@cytetech.com>
	<CACuKZqG7-RVYJvS_Hkwa=jATnNNAmQ2j4-CJZ8JA3h1QW8=inA@mail.gmail.com>
	<FD424034-EF10-455E-8939-18D856236D45@cox.net>
	<51475213.3030509@oracle.com> <51476D10.5090001@cytetech.com>
	<514770C2.3000700@oracle.com> <514779E3.70206@cytetech.com>
	<514789CD.508@oracle.com>
	<CACuKZqGRWavEDGvMTF+FD+Q+bOEUE315hOpnbkT2P83o06ThiQ@mail.gmail.com>
Message-ID: <514868F5.7000901@cytetech.com>

On 3/18/2013 5:48 PM, Zhong Yu wrote:
> On Mon, Mar 18, 2013 at 4:40 PM, Nathan Reynolds
> <nathan.reynolds at oracle.com> wrote:
>> I agree with you as well as many others.  This is why the final keyword was
>> enhanced with Java Memory Model.
>>
>> I also agree that Thread.setName() shouldn't because of JIT cause an
>> exception and shouldn't show a corrupted name.  It won't as long as getName
>> and setName are called by the same thread.
>>
>> The problem comes into play with concurrency.  The getName and setName APIs
>> were not designed to be concurrently accessed.  Many parts of the JDK were
>> not designed to be concurrently accessed.
>
> Typically, if an object is not for concurrent access, it has an owner,
> and the owner controls all accesses to it.
>
> But who is the owner of a thread? Nobody. Threads are openly exposed
> for anybody to access.

And this is the larger issue for the JDK overall.  Every bit of it is a public 
API.  A major reason to use Java is for concurrency support.  The rest of the 
problems that can be or will be found in the JDK, come down to similar issues as 
this.  In JDK1.0 through JDK1.4, all of this stuff worked because the JIT and 
the JVM wasn't in your face about exploiting hardware.

Overall, I think that people believe this stuff is old enough, to just work. 
Surely in Sun and now Oracle, there is a group of engineers responsible for each 
package, if not an engineer assigned as responsible for each class at some level?

If the JDK is concurrency "broken" in these simple ways, then it seems to me 
that the programming model in concert with these optimizations and the JVM 
overall, is so complex that even all the experts who have and continue to work 
on Java and the JDK are being challenged in ways that keep them from being 
successful.  Being content that all of these things are okay issues seems 
counterproductive to the community that is Java, overall.

Gregg

> So it's not enough to simply label some of its
> methods as not thread safe. If the methods are not thread safe, then
> who can access it and when? What synchronization protocols we need to
> follow to safely invoke them? There are not obvious answers to these
> questions, therefore the methods would be unusable.
>
> Users would intuitively assume that all methods in Thread are thread
> safe, otherwise they have no idea how to invoke them in a thread safe
> manner.
>
> More generally, any object that is exposed to the public to access,
> must either be thread safe, or declare a synchronization protocol so
> that callers can follow cooperatively.
>
> Zhong Yu
>
>> In fact, many parts of the JDK
>> were written before we even had the Java Memory Model.
>>
>> I think the safest assumption is to assume that unless documented, the API
>> can not be accessed concurrently.  If an average programer wants to access
>> it concurrently, then they better wrap it in a lock.  If a pressing need
>> arises to make the API concurrent, then an enhancement request should be
>> filed.  An expert will analyze the code and either update the documentation
>> saying it can be accessed concurrently or fix the code and then document.
>>
>> As for being able to reorder operations, this has significant performance
>> benefit.  Much of the performance progress in the past 10 years both in
>> software and hardware has come from being more aggressive at reordering.
>> For example, loop hoisting is extremely important for optimizing loops and
>> can get huge benefits.  This one optimization has bitten many on this list.
>> They didn't realize that they needed to declare the field as volatile.  As
>> the stuff underneath us gets more aggressive, we are going to have to
>> communicate better in our code as to what kinds of things are allowed to be
>> done by underlying machinery (e.g. volatile).
>>
>> Here's another reordering example.  A memory fence on a core causes a huge
>> stall.  It basically clears the execution pipeline since the subsequent data
>> loads have to wait.  Cores need to be able to reorder instructions (loads)
>> across memory fences.  A core could speculatively do the load and monitor
>> the cache line.  If no one else in the system touches the cache line before
>> the memory fence is finished, then the speculative load just prevented a
>> stall.  If another core touches the cache line, then the speculation is
>> thrown out and the instructions are restarted.  The core's performance is
>> either on par or still ahead of stalling.  The great benefit of this is that
>> the memory fence still appears to software to be enforced yet the core is
>> able to perform well in spite of its existence.
>>
>> Nathan Reynolds | Architect | 602.333.9091
>> Oracle PSR Engineering | Server Technology
>> On 3/18/2013 1:32 PM, Gregg Wonderly wrote:
>>
>> Right, and what I am saying, is that things that the developer has not
>> "coded" should not happen.  Ordering of what they've coded should be all
>> that is something for them to consider when looking for concurrency or race
>> conditions.
>>
>> Even if we had all ended up with massive EMSP (I did some research on this
>> in college with some of the people who had worked on it, before this
>> contract happened:
>> http://www.thefreelibrary.com/AT%26T+WINS+$26.6+MILLION+NAVY+SOFTWARE+CONVERSION+CONTRACT-a012623510)
>> processors with complete data flow analysis, there would still be SC with
>> respect to each data item.  It can't be used before it exists.  Assigning
>> this.name a value, before the value "exists" (not until arraycopy() returns
>> does the value exist), is the problem.  There is no merit to any argument
>> that says that the "software" should see such a state.  The developer did
>> not code
>>
>> this.name = new char[len];
>> System.arrayCopy( str.getBytes(), 0, this.name, 0, len );
>>
>> Maybe you can help me understand how you see this optimization as a benefit?
>> Having the developer need to check every single function in any API to make
>> sure it's been fixed to keep this optimization from biting them is where I'm
>> struggling.  Software that used to work, before this kind of optimization
>> was made, could now, just break or behave oddly and just by looking at it,
>> how would any average developer know?
>>
>> Gregg Wonderly
>>
>> On 3/18/2013 2:53 PM, oleksandr otenko wrote:
>>
>> I am pointing out this is a problem of concurrent programming and no one
>> said it
>> is a */simple/* extension of a single-threaded world. You need to know all
>> effects to know how to combine them.
>>
>> Do you expect the thread name to show IP address (someone mentioned that?)
>> and
>> the stack trace to show the thread processing that same request? How do you
>> combine these? So you'd need to come up with what a consistent state is
>> first.
>>
>> This is easily illustrated by a example of a thread dump where no thread
>> holds
>> the lock, yet has a few threads blocked on it. All because by the time the
>> thread dump for the lock owner was taken, it released the lock.
>>
>> Alex
>>
>> On 18/03/2013 19:37, Gregg Wonderly wrote:
>>
>> So how does the developer know?  setName()/getName() have no visible
>> contract
>> do they?
>>
>> Gregg
>>
>> On 3/18/2013 12:42 PM, oleksandr otenko wrote:
>>
>> It is hardly surprising that in order to combine effects you need to know
>> what
>> the effects are.
>>
>> So nothing special about having to know what setName does to properly
>> synchronize.
>>
>> Alex
>>
>> On 15/03/2013 21:46, Gregg Wonderly wrote:
>>
>> Yes, that transformation is legal, but it is also broken in the current
>> design
>> of that class.  Because Thread.setName() is callable, and because there is
>> no
>> other visible happensBefore with Thread.getName, the compiler can make the
>> decision to designate these methods as intra-thread use only.
>>
>> That is the problem.  Even if I subsequently introduce a "happens before" by
>> synchronizing or locking or something else, I have to know what the
>> implementation is, know how it is broken and only then can I actually expect
>> to achieve safe use of the provided API.
>>
>> I assert that this is completely and totally non-productive for software
>> developers.  The JDK and many other large Java applications/libraries are
>> broken in subtle ways, such as the missing "volatile" here. The compilers
>> rewrite of such code into non-thread safe segments when the developer(s)
>> might
>> look at their code and say "that's racy, but safe, because I'll just use
>> "synchronized" around my calls, is changing the outcome that breaks SC.  Yes
>> SC is not supposed to be guaranteed in this case, but do JVM and hotspot
>> developers really feel like they are doing great and wonderful things, when
>> this kind of stuff is haunting everybody everywhere, because even the JDK
>> has
>> not been "fixed"?
>>
>> Gregg Wonderly
>>
>> On Mar 15, 2013, at 3:44 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:
>>
>> On Fri, Mar 15, 2013 at 3:22 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
>>
>> Nathan's example below is my issue...
>>
>>
>> On 3/15/2013 12:29 AM, David Holmes wrote:
>>
>> Gregg,
>>
>> Gregg Wonderly writes:
>>
>>
>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>
>> I've inlined the name.toCharArray() and rearranged a few
>>
>> operations that JIT
>>
>> could do.  If another thread reads this.name between its
>>
>> creation and the end of
>>
>> arraycopy() then the thread will see a partially filled char[].
>>
>>        public final void setName(String name) {
>>            this.name = new char[name.length()];
>>            System.arraycopy(..., 0, result, 0, name.length());
>>
>>
>> If two different threads call setName concurrently, then if the code was
>> transformed as shown above, then it is possible to see
>>
>> T1:           this.name = new char["some longer string".length()];
>> T2:           this.name = new char["a short string".length()];
>> T1:           System.arraycopy( "some longer string", 0,
>>                          this.name, 0, "some longer string".length());
>>
>> Which will result in an exception at best and memory corruption at worse
>> depending on how this.name is referenced.
>>
>> I think you are right, the compiler must not issue a load that did not
>> exist in the source code (the compiler *is* aware that some other
>> thread may be changing the variable).
>>
>> The following transformation should be legal
>>
>>         public final void setName(String name) {
>>              char[]  tmp = new char[name.length()]
>>              this.name = tmp;
>>              System.arraycopy(name.value, 0, tmp, 0, name.length());
>>
>> Zhong Yu
>>
>> Gregg Wonderly
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From gregg at cytetech.com  Tue Mar 19 09:53:33 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 19 Mar 2013 08:53:33 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEFLJLAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCIEFLJLAA.davidcholmes@aapt.net.au>
Message-ID: <51486DDD.6030404@cytetech.com>

On 3/18/2013 5:53 PM, David Holmes wrote:
> Gregg Wonderly writes:
>>
>> On 3/18/2013 3:50 PM, oleksandr otenko wrote:
>>> On 18/03/2013 20:00, Gregg Wonderly wrote:
>>>> On 3/18/2013 2:05 PM, oleksandr otenko wrote:
>>>>> Why Sequential Consistency, of all consistency requirements?
>>>>
>>>> The rewrite provides a set of instructions, that when weaved
>> by two or more
>>>> threads, might (see below) cause "failure" of the VM. That is
>> the problem for
>>>> me.  The single statement,
>>>>
>>>>       this.name = name.toCharArray();
>>>
>>> I must point out that there is nothing saying
>> name.toCharArray() doesn't write
>>> anything to this.name during its operation before returning the
>> result (which
>>> you happen to assign to this.name). For all it matters, if the
>> modification is
>>> not visible by the caller, it may be happening in a
>> single-threaded world.
>>
>> There has never been anything in the JLS that has allowed this.name to be
>> assigned an incomplete value.
>
> The JLS defines the basic intra-thread semantics of the language. An
> implementation of the Java Platform must provide those semantics. But that
> permits any reordering that is not observable by a single thread. For
> multi-thread semantics the rules of Chapter 17 have to be obeyed - what we
> generally refer to as the Java Memory Model (which for the record has always
> existed but the early form of which was significantly flawed.) As long as
> intra-thread semantics obey the JLS general definitions for how things work;
> and inter-thread semantics obey the JMM, then a runtime system can
> reorder/optimize however it likes. There is no requirement that an external
> observer must always see actions consistent with the JLS definitions.

The last sentence, for me, is the hanging point.  When we all have to manage 
this issue at strange moments (another thread reading a racey assignment is very 
common in debugging/logging/JMX it seems to me), then all of these optimizations 
start to be a hassle rather than a performance enhancement.  They create huge 
amounts of effort to try and understand what the simplest, least hardware 
impacting solution is.  Some annotations that both assert the developers 
expectations on use, and which tell the runtime environment when optimization is 
expected, put the developer in charge of getting the performance they need, 
while keeping their code executing in SC ways that make it possible to 
understand when a race is occurring.

The JVM faulting or returning "garbage" on a racey assignment is not something 
that I'd expect to ever happen (except for longs, because that's always been a 
non-atomic operation).  The JLS doesn't say assignment may be optimized into a 
non-atomi/non-SC operation if inter-thread use is not specified by a volatile 
declaration.  For me, that's the kind of thing that is essential to allow 
developers to be informed of why the use of volatile is often an important 
consideration.

I think we are going around in circles about this, and a fix for Thread's 
setName()/getName() is well known.  As more optimizations occur, and more 
developers write larger and larger standalone applications (Android testing in 
Java environments), that don't use libraries where HB is injected by so many 
thing that they get "automatic" HB for their broken code, this will come around 
again.

Gregg

> David
> -----
>
>
>> 15.26 is the Assignment Operators, 15.26.1, Simple assignment,
>> states many
>> things about the evaluation of the left side of the operator
>> denoted as e.f.  It
>> concludes with the text:
>>
>> "Otherwise, the variable denoted by e.f is assigned the value of
>> the right hand
>> operand as computed above"
>>
>> There is no visible text that says, 'if the right hand expression
>> is an array,
>> the array may be assigned before it is filled with any value
>> generated by the
>> evaluation of that expression' or anything similar.  It says the
>> left hand is
>> assigned the value computed from the expression on the right.
>>
>> Gregg Wonderly
>>
>>>> being transformed as Nathan illustrated violates the
>> "developers" belief in
>>>> what he coded.  This statement, by observation, is threadsafe
>> with respect to
>>>> the assignment of a value to this.name, and
>>>
>>> I don't see what makes it thread-safe, except when you look at
>> the lines of code
>>> as atomic units of execution.
>>
>> Precisely.  Lines of code exist because there is no other way to express
>> "order".  They are in fact what developers expect to "complete",
>> entirely.
>> Unrelated lines of code may be reordered, but a line is a line!
>> It has to do
>> what it says it does, and the right side of assignment has to
>> complete before
>> the left side can be assigned.  I know that because long can have
>> this problem,
>> that it might seem perfectly good that the behavior here is
>> consistent with that.
>>
>> However, I know how long is stored/used and I know that it isn't
>> a "single"
>> value on some processors.  Whereas object references "are"
>> consistent, or else
>> we would have real problems with every line needing to be
>> synchronized.  Thus,
>> my reasoning would cause me to say that this object reference
>> would not be
>> updated until the object was initialized (or that race could be
>> exploited as a
>> security risk in any many different APIs), and what you are
>> suggesting, is that
>> this will not be guaranteed.
>>
>>>> would appear to have no chance of causing an exception.   When
>> one looks at
>>>> the code in String.toCharArray(), inlining those two lines of code in
>>>> String.toCharArray(), would seem probable to me as well, as Nathan's
>>>> illustration seemed to point out.
>>>>
>>>> But I would never, ever guess that rather than use a temporary holder
>>>> variable/register for the array allocated, that the value
>> would instead be
>>>> stored to this.name, before the arraycopy() call.
>>> A temporary holder variable is in memory? Then you have one
>> more write and read.
>>>
>>> A plausible sequence of instructions: allocate, store address
>> in EDI, use REP
>>> MOVSB to copy - EDI is ruined after copy. Why not store address
>> to this.name
>>> before starting to copy?
>>
>> I understand how all of these optimizations are focused on
>> staying away from
>> memory, even the stack I suppose.  I used to do this kind of
>> jockeying with hand
>> coded assembler on the Z-80 and TI-9900, decades ago. The results
>> still have to
>> be correct, and a partially initialized array is not specified as
>> valid in the
>> JLS as far as I read.
>>
>>>>
>>>> Now, I will concede that the arraycopy() might in fact use the
>> exact value
>>>> returned from the array allocation, instead of referencing
>> this.name, but I
>>>> don't know that.
>>>
>>> It doesn't matter. Getting used to the idea that correct
>> single-threaded code is
>>> not always correct in a concurrent setting, helps.
>>
>> I guess it's hard for you to understand that I already know this,
>> since we don't
>> really know each others history.  The first time that I ran Java
>> 1.5 code on a
>> dual core machine, I was bit by the loop exit hoist that happens
>> to code like
>> the following.
>>
>> class foo {
>> 	boolean bar;
>> 	public void work() {
>> 		while(!bar ) {
>> 			..do the work..
>> 		}
>> 	}
>> 	public void setBar( boolean how ) {
>> 		bar = how;
>> 	}
>> }
>>
>> I would expect that visibility would be a problem that might
>> cause bar to not be
>> set immediately, but the JLS doesn't say that this will be rewritten as
>>
>> 		if( !bar ) {
>> 			while( true ) {
>> 			}
>> 		}
>>
>> That was the first disaster that optimization of non-volatile
>> values created.  I
>> think I lost about a day at least, of work trying to understand
>> why the loop
>> would not exit.  I think I had to post on this list to get a hint
>> that this was
>> happening.  No documentation on the planet says that this will
>> happen and then
>> tells me to code accordingly.  Prior to 1.5, volatile was
>> meaningless, and for
>> 1.5 to change code that was working to non-working code just
>> seemed completely
>> pointless and downright ridiculous.  To this day, I still find
>> this rewrite
>> killing working code, and thus I just paste "volatile" on every single
>> declaration, because there is no telling what silly, pointless
>> optimization
>> (pointless from the perspective that it doesn't 'fix' anything if
>> it breaks
>> code) will be injected into the JDK next.
>>
>> In the JLS, 8.3.1.4 has information about ordering of non-volatile value
>> references/updates.  This is the expected, old details about
>> unrelated values
>> being updated out of program order.  If neither i nor j were
>> volatile, then the
>> expression i = ++j, used in "one()" in that example could produce
>> the values
>> where i is one less than j.  But you should never see i greater
>> than j.  That
>> just doesn't make programmatic sense based on the expression.
>> But, I would
>> honestly expect that kind of silly optimization to be made.  So
>> that it was
>> rewritten as effectively
>>
>> 	j = i = j + 1;
>>
>> Why in the world would we want to force the use of volatile
>> unless it's actually
>> useful to the developer to guarantee something important to them?
>>   These kinds
>> of optimizations just make debugging hard.  People will go in and
>> declare i and
>> j volatile so that their debugging message works, and it's not
>> really necessary
>> to do that.
>>
>> Gregg
>>
>>>
>>>> Nathan's example was devoid of the exact semantics of how the
>> arguments to
>>>> arraycopy() were sourced.
>>>>
>>>> If the code that actually would exist would look like
>>>>
>>>>          char result[] = this.name = new char[value.length];
>>>>          System.arraycopy(value, 0, result, 0, value.length);
>>>>
>>>> Then of course, all is well regarding an
>> ArrayIndexOutOfBoundsException,
>>>> because that wouldn't happen.
>>> It won't surprise me even if it throws
>> ArrayIndexOutOfBoundsException. If you
>>> stop considering that all calls to setName are serialized, then
>> you synchronize
>>> all calls to setName yourself.
>>>
>>>
>>>>
>>>> However, it would still be possible for getName() to be called
>> with an array
>>>> that was not completely populated with the actual 'value' string.
>>> If setName or toCharArray is a black box, then you don't know
>> whether it sets
>>> this.name to any other values between the start and end of the
>> setName call. If
>>> you deny all knowledge of how it is done, then you need to
>> accept this is a
>>> valid way to do it.
>>>
>>>
>>> Alex
>>>
>>> PS I am only trying to demonstrate from a wider angle that
>> certain types of
>>> guarantees are not possible, if you consider a function as a
>> black box. For the
>>> system as a whole to be sequentially consistent, you need to
>> consider the system
>>> as a whole. Use of Sequentially Consistent black boxes doesn't
>> mean the result
>>> is sequentially consistent.
>>>
>>> Whereas knowing what setName does is a pain, I don't think it
>> is avoidable.
>>>
>>>
>>>>
>>>> I just don't see how it's exciting or even comfortable to feel
>> like a public
>>>> API should require 'work' of this nature to use effectively.
>>>>
>>>> I just don't understand how there is any advantage at all to assigning
>>>> this.name before the array is filled.  If there is a temporary
>>>> variable/register used so that arraycopy() can be called with
>> that as the
>>>> third argument, then the assignment can be called after that.
>> If, instead
>>>> there is no temp variable/register used, then we may be back
>> to the AIOOBE
>>>> being the issue if this.name is the third argument to arraycopy().
>>>>
>>>> Gregg Wonderly
>>>>
>>>>> As an example,
>>>>> Vector and Hashtable will return "consistent" results, but
>> that doesn't
>>>>> eliminate races between get and put - what sort of
>> consistency guarantee do you
>>>>> get?
>>>>>
>>>>> Also, bear in mind that 2 billion calls to Vector and
>> Hashtable methods will
>>>>> create about 8 minutes of runtime overhead even on a
>> single-threaded flow - no
>>>>> contention, just the cost of those instructions (compared to
>> exactly the same
>>>>> test, but on a uniprocessor = JVM optimizes away the atomics
>> on the locks).
>>>>> (this is not the latest HotSpot, but I think a useful rule of
>> thumb) Maybe if
>>>>> you count all field mutations in your workflow you can see
>> why non-volatile
>>>>> accesses is the default.
>>>>>
>>>>>
>>>>> Alex
>>>>>
>>>>>
>>>>> On 15/03/2013 05:14, Gregg Wonderly wrote:
>>>>>> On 3/14/2013 6:14 PM, Nathan Reynolds wrote:
>>>>>>> I've inlined the name.toCharArray() and rearranged a few
>> operations that JIT
>>>>>>> could do.  If another thread reads this.name between its
>> creation and the
>>>>>>> end of
>>>>>>> arraycopy() then the thread will see a partially filled char[].
>>>>>>>
>>>>>>>       public final void setName(String name) {
>>>>>>>           this.name = new char[name.length()];
>>>>>>>           System.arraycopy(..., 0, result, 0, name.length());
>>>>>>>       }
>>>>>>
>>>>>> This rewrite/optimization doesn't seem to meet sequential
>> consistency ordering
>>>>>> requirements.  I don't see how this could be considered SC
>> since it creates a
>>>>>> different result (uninitialized value) then the way that the
>> original source
>>>>>> was coded did not.
>>>>>>
>>>>>> If the JIT is actually doing this when concurrency is not detected
>>>>>> (non-volatile and no other happensBefore/fence), its no
>> wonder we have so many
>>>>>> developers plagued with unexplainable racy program bugs.
>>>>>>
>>>>>> I thought the rewrite of while( nonvolatileBoolean ){} to if
>>>>>> (nonvolatileBoolean) { while (true ) {} } was bad enough of
>> a mistake.  This
>>>>>> just wreaks of frustration for developers.
>>>>>>
>>>>>> How is this optimization more efficient, really?  Are we
>> really so interested
>>>>>> in absolutely most efficient that we've given up on letting
>> developers decide
>>>>>> when performance matters and then optimize to "incorrect" on
>> their own terms?
>>>>>>
>>>>>> This kind optimization, if it is actually occurring is
>> another example of
>>>>>> insidious change in program behavior...
>>>>>>
>>>>>> Gregg Wonderly
>>>>>>
>>>>>>>
>>>>>>> Nathan Reynolds
>>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>>>> Architect | 602.333.9091
>>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server
>> Technology
>>>>>>> On 3/14/2013 4:03 PM, Pete Guyatt wrote:
>>>>>>>> I'm sure I'm missing something here but I don't quite see how the
>>>>>>>> character array can be scrambled.
>>>>>>>>
>>>>>>>> I can see how it "racy" and how an inconsistent write/read
>> happens where a
>>>>>>>> thread calls setName -- could be the thread itself or
>> another thread --
>>>>>>>> and another calls getName but from what I can see the
>> assignment of the
>>>>>>>> new value to the name[] array is only going to happen
>> after the call to
>>>>>>>> toCharArray completes. I thought this would be the case
>> even with the JVM
>>>>>>>> performing some reordering of instructions.
>>>>>>>>
>>>>>>>> Would someone mind clarifying?
>>>>>>>>
>>>>>>>> Kind Regards,
>>>>>>>>
>>>>>>>> Pete
>>>>>>>>
>>>>>>>> On 2013-03-14 4:47 PM, "Zhong Yu"<zhong.j.yu at gmail.com> wrote:
>>>>>>>>
>>>>>>>>> On Thu, Mar 14, 2013 at 5:26 PM, Stanimir Simeonoff
>>>>>>>>> <stanimir at riflexo.com>  wrote:
>>>>>>>>>> We already agree about being racy. Unline the clone()
>> method 'name' has
>>>>>>>>>> no
>>>>>>>>>> critical applications (or at least shall not), so I
>> presume it was never
>>>>>>>>>> considered a problem to warrant a volatile field.
>>>>>>>>> A non-volatile String field would be ok.
>>>>>>>>>
>>>>>>>>> Since getName() can be invoked by anyone at anytime, it's
>> troubling
>>>>>>>>> that it could observe a scrambled name.
>>>>>>>>>
>>>>>>>>> Zhong Yu
>>>>>>>>>
>>>>>>>>>> On Thu, Mar 14, 2013 at 11:55 PM, Zhong
>> Yu<zhong.j.yu at gmail.com> wrote:
>>>>>>>>>>> It's a common practice to modify thread names on the fly, for
>>>>>>>>>>> diagnosis purposes.
>>>>>>>>>>>
>>>>>>>>>>> On Thu, Mar 14, 2013 at 4:51 PM, Stanimir Simeonoff
>>>>>>>>>>> <stanimir at riflexo.com>  wrote:
>>>>>>>>>>>> char[] name is usually initialized in the c-tor, in
>> that case it'd be
>>>>>>>>>>>> fine.
>>>>>>>>>>>> Since the access to 'name' is racy to begin, the
>> changes may not be
>>>>>>>>>>>> necessarily 'visible'.
>>>>>>>>>>>>
>>>>>>>>>>>> Stanimir
>>>>>>>>>>>>
>>>>>>>>>>>> On Thu, Mar 14, 2013 at 11:21 PM, Zhong
>> Yu<zhong.j.yu at gmail.com>
>>>>>>>>>>> wrote:
>>>>>>>>>>>>> java.lang.Thread
>>>>>>>>>>>>>
>>>>>>>>>>>>>       private char name[];
>>>>>>>>>>>>>
>>>>>>>>>>>>>       public final void setName(String name) {
>>>>>>>>>>>>>           checkAccess();
>>>>>>>>>>>>>           this.name = name.toCharArray();
>>>>>>>>>>>>>       }
>>>>>>>>>>>>>
>>>>>>>>>>>>>       public final String getName() {
>>>>>>>>>>>>>           return String.valueOf(name);
>>>>>>>>>>>>>       }
>>>>>>>>>>>>>
>>>>>>>>>>>>> On the surface, set/getName() are not correctly synchronized,
>>>>>>>>>>>>> getName() could observe a partially filled char
>> array. What's the
>>>>>>>>>>>>> story here?
>>>>>>>>>>>>>
>>>>>>>>>>>>> Zhong Yu
>>>>>>>>>>>>>
>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> -----
>> No virus found in this message.
>> Checked by AVG - www.avg.com
>> Version: 2013.0.2904 / Virus Database: 2641/6158 - Release Date: 03/08/13
>> Internal Virus Database is out of date.
>>
>
>
>


From chris.hegarty at oracle.com  Tue Mar 19 13:44:42 2013
From: chris.hegarty at oracle.com (Chris Hegarty)
Date: Tue, 19 Mar 2013 17:44:42 +0000
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <51484455.5030405@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCGEDKJLAA.davidcholmes@aapt.net.au>
	<5143DB4B.5070505@cytetech.com> <51474050.8000305@oracle.com>
	<CAEJX8ooBZAj9e2adoOiAt8jL-nOkQZWF4Y_OG+834eX4HEx6TA@mail.gmail.com>
	<51484455.5030405@oracle.com>
Message-ID: <5148A40A.6070903@oracle.com>

On 03/19/2013 10:56 AM, Chris Hegarty wrote:
> On 03/18/2013 09:39 PM, Stanimir Simeonoff wrote:
>> ....
>> Here is a nasty bug in sun.net.www.protocol.jar.JarFileFactory ::
>> close(JarFile jarFile). The bug is far more severe than Thread.getName().
>>
>> The method should be synchronized(this) (or just have the sync bit)
>> Otherwise it accesses the HashMaps in absolute thread-unsafe manner +
>> there is a race between both operation as bonus.
>> Now closing JarFile I had to manually synchronize to the instance.
>
> Ouch! Thanks for reporting this issue Stanimir.
>
> I filed 8010282: "sun.net.www.protocol.jar.JarFileFactory.close(JarFile)
> should be thread-safe", should be visible soon [1].

I started the following thread to resolve this issue:
   http://mail.openjdk.java.net/pipermail/net-dev/2013-March/005889.html

-Chris.

> I will post a patch on net-dev [2] to resolve it. And then seek to
> backport to 7uXX.
>
> -Chris.
>
> [1] http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=8010282
> [2] http://mail.openjdk.java.net/mailman/listinfo/net-dev
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From gergg at cox.net  Wed Mar 20 14:34:30 2013
From: gergg at cox.net (Gregg Wonderly)
Date: Wed, 20 Mar 2013 13:34:30 -0500
Subject: [concurrency-interest] Thread safety of Thread.getName()
In-Reply-To: <5148A40A.6070903@oracle.com>
References: <NFBBKALFDCPFIDBNKAPCGEDKJLAA.davidcholmes@aapt.net.au>
	<5143DB4B.5070505@cytetech.com> <51474050.8000305@oracle.com>
	<CAEJX8ooBZAj9e2adoOiAt8jL-nOkQZWF4Y_OG+834eX4HEx6TA@mail.gmail.com>
	<51484455.5030405@oracle.com> <5148A40A.6070903@oracle.com>
Message-ID: <CBE53465-2BA0-45A8-9107-3880445EAA94@cox.net>

One of the other points of discussion, is related to situation like that visible in Chris's changes

+     // must be called while holding the 'instance' lock
      private JarFile getCachedJarFile(URL url) {
          JarFile result = fileCache.get(URLUtil.urlNoFragString(url));
Wouldn't it be nice if we had an annotation that allowed this dependency to be validated by tooling?  I know that in Jini and some other places I have seen asserts used with Thread.holdsLock(?).  What should really be going on in these kinds of situations?  This is a private method, but it is accessed through a public API.  As a private method, tooling should be able to say that intra-method use is meeting the criteria specified here.

Gregg  

On Mar 19, 2013, at 12:44 PM, Chris Hegarty <chris.hegarty at oracle.com> wrote:

> On 03/19/2013 10:56 AM, Chris Hegarty wrote:
>> On 03/18/2013 09:39 PM, Stanimir Simeonoff wrote:
>>> ....
>>> Here is a nasty bug in sun.net.www.protocol.jar.JarFileFactory ::
>>> close(JarFile jarFile). The bug is far more severe than Thread.getName().
>>> 
>>> The method should be synchronized(this) (or just have the sync bit)
>>> Otherwise it accesses the HashMaps in absolute thread-unsafe manner +
>>> there is a race between both operation as bonus.
>>> Now closing JarFile I had to manually synchronize to the instance.
>> 
>> Ouch! Thanks for reporting this issue Stanimir.
>> 
>> I filed 8010282: "sun.net.www.protocol.jar.JarFileFactory.close(JarFile)
>> should be thread-safe", should be visible soon [1].
> 
> I started the following thread to resolve this issue:
>  http://mail.openjdk.java.net/pipermail/net-dev/2013-March/005889.html
> 
> -Chris.
> 
>> I will post a patch on net-dev [2] to resolve it. And then seek to
>> backport to 7uXX.
>> 
>> -Chris.
>> 
>> [1] http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=8010282
>> [2] http://mail.openjdk.java.net/mailman/listinfo/net-dev
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130320/929406de/attachment.html>

From thurston at nomagicsoftware.com  Sat Mar 23 13:52:37 2013
From: thurston at nomagicsoftware.com (thurstonn)
Date: Sat, 23 Mar 2013 10:52:37 -0700 (PDT)
Subject: [concurrency-interest] ByteBuffer vs byte[] and reading from a
	socket
Message-ID: <1364061157384-9337.post@n7.nabble.com>

I apologize if this is off-list, but I know that there are people on this
list who have a deep understanding of CPUs, caches, etc. (which may or may
not be relevant)

I'm curious as to the performance differential between doing the following:
     Socket.read(byte[])
     SocketChannel.read(ByteBuffer)

Here, I'm not talking about blocking vs non-blocking, i.e.
presume there are bytes in the socket's receive buffer ready to be read.

To me, it seems like it's just an issue of copying some bytes from
kernel-space to user-space.
Is SocketChannel.read() really faster?  Why?

And this is really naive I know, but assuming SocketChannel.read *is*
faster, is it by orders of magnitude, marginal, ... ? 




--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/ByteBuffer-vs-byte-and-reading-from-a-socket-tp9337.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From stanimir at riflexo.com  Sat Mar 23 15:02:24 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Sat, 23 Mar 2013 21:02:24 +0200
Subject: [concurrency-interest] ByteBuffer vs byte[] and reading from a
	socket
In-Reply-To: <1364061157384-9337.post@n7.nabble.com>
References: <1364061157384-9337.post@n7.nabble.com>
Message-ID: <CAEJX8oqg-3SOv2PJi+1kOQXa+tvcVkuOjXOPSnEQ6mQ0CQd4hg@mail.gmail.com>

This is really not the place but to put it simply: ByteBuffers are quite
different if they are direct or heap based. Heap-based are not that
different than read(byte[]) but the direct ones need not to reside in
java's heap and are unmanaged. byte[] is read via either dynamic
malloc-copy-free for larger byte[] or stack_alloc-copy for smaller. The
copy phase is always present. Copying may need to lock the java byte[] on
the heap, etc.Of course, it you run of of L2 cache the difference would be
noticeable.

The main difference is blocking/non-blocking though as blocking IO needs
separate thread(s) and you are at the mercy of the OS scheduler if you have
a lot of threads. The latter may hurt the latency for some clients although
the overall throughput may not differ greatly.

Stanimir

On Sat, Mar 23, 2013 at 7:52 PM, thurstonn <thurston at nomagicsoftware.com>wrote:

> I apologize if this is off-list, but I know that there are people on this
> list who have a deep understanding of CPUs, caches, etc. (which may or may
> not be relevant)
>
> I'm curious as to the performance differential between doing the following:
>      Socket.read(byte[])
>      SocketChannel.read(ByteBuffer)
>
> Here, I'm not talking about blocking vs non-blocking, i.e.
> presume there are bytes in the socket's receive buffer ready to be read.
>
> To me, it seems like it's just an issue of copying some bytes from
> kernel-space to user-space.
> Is SocketChannel.read() really faster?  Why?
>
> And this is really naive I know, but assuming SocketChannel.read *is*
> faster, is it by orders of magnitude, marginal, ... ?
>
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/ByteBuffer-vs-byte-and-reading-from-a-socket-tp9337.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130323/68d46e20/attachment.html>

From pramalhe at gmail.com  Sun Mar 24 13:54:29 2013
From: pramalhe at gmail.com (Pedro Ramalhete)
Date: Sun, 24 Mar 2013 18:54:29 +0100
Subject: [concurrency-interest] A Scalable and Fast Read-Write Lock
Message-ID: <CAAApjO1iPUtt1r2frfCwiUeMYGH59_Xh7P56v+pyB4s5RY-fFQ@mail.gmail.com>

Hello,

We have implemented a read-write lock that under a low number of Writes is
able to scale with the number of Reader threads almost linearly even under
high contention (source code at the end of this e-mail). The technique is
similar to the C-RW-WP algorithm described on the recently published paper
"NUMA-Aware Reader-Writer locks" from the Oracle Research team, that can be
found at this link:
http://labs.oracle.com/projects/scalable/pubs/PPoPP2013-numa-rwlock.pdf
This is an excellent and very detailed paper worth the reading if you're
interested in concurrent algorithms or read-write locks, but here is a very
short summary of our own implementation:

- There is a list readersStateList (a ConcurrentLinkedQueue in this
particular implementation) that contains the state of each reader, 0 means
"not reading", 1 means "reading" or "wishing to read".
- A reference to the state of each Reader thread is placed in the
readersStateList, which will be used from then on whenever it wants to
obtain a read-lock. This can be achieved with careful usage of a
ThreadLocal.
- There is a variable named writerOwner that holds the state of the
write-lock.

Read-lock procedure:
1. Get the reference to the Reader's state for the current thread (from a
ThreadLocal for example).
2. Do an AtomicInteger.set() of the current Reader's state to 1.
3. Do an AtomicInteger.get() of writerOwner and, if it is 1, set the
current Reader's state back to 0, do yield() and try again later (lock is
being held by a Writer), otherwise the lock has been acquired in read-only
mode by the current thread and return.

Write-lock procedure:
1. Do an AtomicInteger.compareAndSet() loop on writerOwner to change it's
state from 0 to 1. yield() when not successful.
2. Scan all the states in the readersStateList one at a time and yield() on
each that is at 1. Once a certain state has been seen to be at 0, we can
advance to the next one, and even if that state goes back to 1, it will be
temporarily because the writerOwner was already set at 1, thus preventing
Readers from acquiring the read-lock (i.e. this algorithm has
Writer-Preference).
3. At the end of the scan of readersStateList the write-mode lock will be
acquired by the current thread.

This class implements java.util.concurrent.locks.ReadWriteLock, and no
extra initialization is required.

A more detailed description of the two-state algorithm can be found here:
http://www.concurrencyfreaks.com/2013/02/flowcharts-for-2-states-scalable-rw-lock.html

You can find some performance plots here comparing it with StampedLock and
ReentrantReadWriteLock from java.util.concurrent:
http://www.concurrencyfreaks.com/2013/03/scalablereentrantrwlock-performance.html
and a "pseudo-analysis" of the performance:
http://www.concurrencyfreaks.com/2013/02/why-is-scalablerwlock-fast.html

A counter based version (and others) of this algorithm can be obtained from
sourceforge:
https://sourceforge.net/projects/ccfreaks


Please give it a try and let us know what you think of it.

Thanks,
Pedro & Andreia

ScalableReentrantRWLock.java
-------------------------------------------------------------------------------------------------

/******************************************************************************
 * Copyright (c) 2012 - 2013, Pedro Ramalhete, Andreia Correia
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the
distribution.
 *     * Neither the name of Concurrency Freaks nor the
 *       names of its contributors may be used to endorse or promote
products
 *       derived from this software without specific prior written
permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************
 */

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;



/** <h1> Scalable Reentrant Read - Write Lock </h1>
 * A Read -Write Lock that is scalable with the number of threads doing
Read.
 * <p>
 * Uses a two -state - machine for the Readers, and averages two
synchronized
 * operations. <br>
 * Although this mechanism was independently designed and implemented by the
 * authors, the idea is very similar to the algorithm C - RW- WP described
in this
 * paper: <a href="
http://blogs.oracle.com/dave/resource/ppopp13-dice-NUMAAwareRWLocks.pdf">NUMA
- Aware Reader- Writer locks </a>
 * <br>
 * Relative to the paper, there are two differences: The threads have no
 * particular order, which means this implementation is <b> not</b> NUMA
-aware;
 * Threads attempting a read - lock for the first time are added to a list
and
 * removed when the thread terminates, following the mechanism described
below.
 * <p>
 * To manage the adding and removal of new Reader threads, we use a
 * ConcurrentLinkedQueue instance named {@code readersStateList} containing
all
 * the references to ReadersEntry (Reader's states), which the Writer scans
to
 * determine if the Readers have completed or not.
 * After a thread terminates, the {@code finalize()} of the associated
 * {@code ReaderEntry} instance will be called, which will remove the
 * Reader's state reference from the {@code readersStateList}, to avoid
memory leaking.
 * <p>
 * Advantages: <ul>
 * <li> Implements {@code java.util.concurrent.locks.ReadWriteLock}
 * <li> When there are very few Writes, the performance scales with the
 *      number of Reader threads
 * <li> Reentrant, with support for lock downgrading (but <b>not </b>
upgrading)
 * <li> No need to call initialization/cleanup functions per thread
 * <li> No limitation on the number of concurrent threads
 * </ul>
 * <p>
 * Disadvantages: <ul>
 * <li> Has Writer - Preference
 * <li> writeLock().tryLock() is not guaranteed to return immediately
 * <li> Memory footprint increases with number of threads by
sizeof(ReadersEntry) x O(N_threads)
 * <li> Does not (yet) support {@code lockInterruptibly()}
 * <li> Does not (yet) support {@code newCondition()}
 * <li> Does not (yet) implement {@code java.io.Serializable}
 * </ul>
 * <p>
 * This lock allows downgrading from the write lock to a read lock, by
 * acquiring the write lock, then the read lock and then releasing the write
 * lock. However, upgrading from a read lock to the write lock is <b>
not<br>
 * possible.
 * <p>
 * For scenarios with few writes, the average case for {@code sharedLock()}
is
 * two synchronized calls: an {@code AtomicInteger.set()} on a cache line
that
 * is held in exclusive mode by the core where the current thread is
running,
 * and an {@code AtomicLong.get()} on a shared cache line. <br>
 * This means that when doing several sequential calls of
sharedLock()/unlock()
 * on the same instance, the performance penalty will be small because the
 * accessed variables will most likely be in L1/L2 cache.
 * <p>
 * We use several {@code pxxxxxx} variables to create cache -line padding
 * between the different member variables and avoid <tt> false- sharing
</tt>.
 * They have to be of the same type of the adjacent member to guarantee that
 * they won't be re - ordered, and they have to be {@code public} and
 * {@code volatile} so that they're not <tt> optimized away</tt> for not
 * being used.
 * We should be able to get rid of all these padding variables once the
 * annotation {@code @Contention } gets implemented in JEP 142
 * <a href="http://openjdk.java.net/jeps/142">
http://openjdk.java.net/jeps/142 </a>
 *
 * @author Pedro Ramalhete
 * @author Andreia Correia
 */
public class ScalableReentrantRWLock implements ReadWriteLock {

    // Definition of an invalid thread-id (must be negative)
    private final static int SRWL_INVALID_TID       = -1;
    private final static int SRWL_STATE_NOT_READING = 0;
    private final static int SRWL_STATE_READING     = 1;

    /**
     * List of Reader's states that the Writer will scan when attempting to
     * acquire the lock in write - mode
     */
    private final ConcurrentLinkedQueue<AtomicInteger> readersStateList;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p1readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p2readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p3readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p4readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p5readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p6readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p7readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p8readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p9readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p10readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p11readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p12readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p13readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p14readersState;
    public volatile ConcurrentLinkedQueue<AtomicInteger> p15readersState;

    /**
     * The thread - id of the Writer currently holding the lock in write
-mode, or
     * SRWL_INVALID_TID if there is no Writer holding or attempting to
acquire
     * the lock in write mode.
     */
    private final AtomicLong writerOwner ;
    public volatile AtomicLong p1writerOwner ;
    public volatile AtomicLong p2writerOwner ;
    public volatile AtomicLong p3writerOwner ;
    public volatile AtomicLong p4writerOwner ;
    public volatile AtomicLong p5writerOwner ;
    public volatile AtomicLong p6writerOwner ;
    public volatile AtomicLong p7writerOwner ;
    public volatile AtomicLong p8writerOwner ;
    public volatile AtomicLong p9writerOwner ;
    public volatile AtomicLong p10writerOwner ;
    public volatile AtomicLong p11writerOwner ;
    public volatile AtomicLong p12writerOwner ;
    public volatile AtomicLong p13writerOwner ;
    public volatile AtomicLong p14writerOwner ;
    public volatile AtomicLong p15writerOwner ;

    /**
     * The number of reentrant write locks held by the current thread.
     * <p>
     * This doesn't need to be volatile because we always modify it within
     * acquire - release- barriers, or within the same thread.
     * <p>
     * Initialized to zero in the constructor.
     */
    private int reentrantWriterCount ;
    public volatile int p1reentrantWriterCount ;
    public volatile int p2reentrantWriterCount ;
    public volatile int p3reentrantWriterCount ;
    public volatile int p4reentrantWriterCount ;
    public volatile int p5reentrantWriterCount ;
    public volatile int p6reentrantWriterCount ;
    public volatile int p7reentrantWriterCount ;
    public volatile int p8reentrantWriterCount ;
    public volatile int p9reentrantWriterCount ;
    public volatile int p10reentrantWriterCount ;
    public volatile int p11reentrantWriterCount ;
    public volatile int p12reentrantWriterCount ;
    public volatile int p13reentrantWriterCount ;
    public volatile int p14reentrantWriterCount ;
    public volatile int p15reentrantWriterCount ;

    /**
     * Thread - local reference to the current thread's ReadersEntry
instance.
     * It's from this instance that the current Reader thread is able
     * to determine where to store its own state, and the number of
reentrant
     * read lock loops for that particular thread.
     */
    private final ThreadLocal<ReadersEntry> entry ;
    public volatile ThreadLocal<ReadersEntry> p1entry ;
    public volatile ThreadLocal<ReadersEntry> p2entry ;
    public volatile ThreadLocal<ReadersEntry> p3entry ;
    public volatile ThreadLocal<ReadersEntry> p4entry ;
    public volatile ThreadLocal<ReadersEntry> p5entry ;
    public volatile ThreadLocal<ReadersEntry> p6entry ;
    public volatile ThreadLocal<ReadersEntry> p7entry ;
    public volatile ThreadLocal<ReadersEntry> p8entry ;
    public volatile ThreadLocal<ReadersEntry> p9entry ;
    public volatile ThreadLocal<ReadersEntry> p10entry ;
    public volatile ThreadLocal<ReadersEntry> p11entry ;
    public volatile ThreadLocal<ReadersEntry> p12entry ;
    public volatile ThreadLocal<ReadersEntry> p13entry ;
    public volatile ThreadLocal<ReadersEntry> p14entry ;
    public volatile ThreadLocal<ReadersEntry> p15entry ;

    /**
     * The lock returned by method {@link ScalableReentrantRWLock#readLock}
.
     */
    private final ScalableReentrantRWLock.InnerReadLock readerLock ;

    /**
     * The lock returned by method {@link
ScalableReentrantRWLock#writeLock} .
     */
    private final ScalableReentrantRWLock.InnerWriteLock writerLock;


    /**
     * Inner class that makes use of finalize() to remove the Reader's state
     * from the ConcurrentLinkedQueue {@code readersStateList}
     */
    public class ReadersEntry {
        public final AtomicInteger state;
        public int reentrantReaderCount = 0;

        public ReadersEntry(AtomicInteger state) {
            this .state = state;
        }

        protected void finalize() throws Throwable {
            removeState( state);
            super .finalize();
        }
    }


        /**
        * Read - only lock
        */
        public class InnerReadLock implements Lock {
           final ScalableReentrantRWLock rwlock ;

           public InnerReadLock(ScalableReentrantRWLock rwlock) { this.
rwlock = rwlock; }
            public void lock() { rwlock.sharedLock(); }
            public void unlock() { rwlock.sharedUnlock(); }
            public boolean tryLock() { return rwlock.sharedTryLock(); }
            public boolean tryLock( long timeout, TimeUnit unit)
                    throws InterruptedException {
                if (Thread.interrupted()) throw new
InterruptedException();
                return sharedTryLockNanos(unit.toNanos(timeout));
            }
            public void lockInterruptibly() throws InterruptedException {
                // Not supported
                throw new
UnsupportedOperationException();
            }
            public Condition newCondition() {
                // Not supported
                throw new UnsupportedOperationException();
            }
       }


    /**
     * Write - only lock
     */
    public class InnerWriteLock implements Lock {
        final ScalableReentrantRWLock rwlock ;

        public InnerWriteLock(ScalableReentrantRWLock rwlock) { this.
rwlock = rwlock; }
        public void lock() { rwlock.exclusiveLock(); }
        public void unlock() { rwlock.exclusiveUnlock(); }
        public boolean tryLock() { return rwlock.exclusiveTryLock(); }
        public boolean tryLock( long timeout, TimeUnit unit)
                throws InterruptedException {
            if (Thread.interrupted()) throw new InterruptedException();
            return exclusiveTryLockNanos(unit.toNanos(timeout));
        }
        public void lockInterruptibly() throws InterruptedException {
            // Not supported
            throw new UnsupportedOperationException();
        }
        public Condition newCondition() {
            // Not supported
            throw new UnsupportedOperationException();
        }
    }


    /**
     * Default constructor
     */
    public ScalableReentrantRWLock() {
        // States of the Readers, one entry in the list per thread
        readersStateList = new ConcurrentLinkedQueue<AtomicInteger>();
        p1readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p2readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p3readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p4readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p5readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p6readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p7readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p8readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p9readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p10readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p11readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p12readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p13readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p14readersState = new ConcurrentLinkedQueue<AtomicInteger>();
        p15readersState = new ConcurrentLinkedQueue<AtomicInteger>();

        writerOwner = new AtomicLong( SRWL_INVALID_TID);
        p1writerOwner = new AtomicLong();
        p2writerOwner = new AtomicLong();
        p3writerOwner = new AtomicLong();
        p4writerOwner = new AtomicLong();
        p5writerOwner = new AtomicLong();
        p6writerOwner = new AtomicLong();
        p7writerOwner = new AtomicLong();
        p8writerOwner = new AtomicLong();
        p9writerOwner = new AtomicLong();
        p10writerOwner = new AtomicLong();
        p11writerOwner = new AtomicLong();
        p12writerOwner = new AtomicLong();
        p13writerOwner = new AtomicLong();
        p14writerOwner = new AtomicLong();
        p15writerOwner = new AtomicLong();

        reentrantWriterCount = 0;
        p1reentrantWriterCount = 0;
        p2reentrantWriterCount = 0;
        p3reentrantWriterCount = 0;
        p4reentrantWriterCount = 0;
        p5reentrantWriterCount = 0;
        p6reentrantWriterCount = 0;
        p7reentrantWriterCount = 0;
        p8reentrantWriterCount = 0;
        p9reentrantWriterCount = 0;
        p10reentrantWriterCount = 0;
        p11reentrantWriterCount = 0;
        p12reentrantWriterCount = 0;
        p13reentrantWriterCount = 0;
        p14reentrantWriterCount = 0;
        p15reentrantWriterCount = 0;

        /* Default value for "entry" is null which is ok because, the thread
         * calling the constructor may never attempt to read-lock this
         * instance and, therefore, there is not point in allocating an
         * instance of ReadersEntry for it.
         */
        entry = new ThreadLocal<ReadersEntry>();
        p1entry = new ThreadLocal<ReadersEntry>();
        p2entry = new ThreadLocal<ReadersEntry>();
        p3entry = new ThreadLocal<ReadersEntry>();
        p4entry = new ThreadLocal<ReadersEntry>();
        p5entry = new ThreadLocal<ReadersEntry>();
        p6entry = new ThreadLocal<ReadersEntry>();
        p7entry = new ThreadLocal<ReadersEntry>();
        p8entry = new ThreadLocal<ReadersEntry>();
        p9entry = new ThreadLocal<ReadersEntry>();
        p10entry = new ThreadLocal<ReadersEntry>();
        p11entry = new ThreadLocal<ReadersEntry>();
        p12entry = new ThreadLocal<ReadersEntry>();
        p13entry = new ThreadLocal<ReadersEntry>();
        p14entry = new ThreadLocal<ReadersEntry>();
        p15entry = new ThreadLocal<ReadersEntry>();

        readerLock = new ScalableReentrantRWLock.InnerReadLock( this);
        writerLock = new ScalableReentrantRWLock.InnerWriteLock( this);

        // Force a release-memory barrier to make sure that initialization
        // is done by the time a lock operation is attempted
        writerOwner .set(SRWL_INVALID_TID );
    }

    public Lock readLock() { return readerLock ; }
    public Lock writeLock() { return writerLock ; }


    /**
     * This function should be called only from ReadersEntry.finalize()
     *
     * @param state The reader's state that we wish to remove from the
ConcurrentLinkedQueue
     */
    protected void removeState(AtomicInteger state) {
        /* We don't need to lock in exclusive mode in Java thanks to the
         * Garbage Collector, but in other languages (C/C++) we will need
         * to wrap this in an exclusiveLock()/exclusiveUnlock() to prevent
ABA
         * problem if another thread is calling the exclusiveLock() at the
         * same time, and is holding a pointer to this "state" while
scanning
         * the Readers.
         */
        readersStateList .remove(state);
        /* Paranoia: just in case someone forgot to call sharedUnlock()
         * and there is a Writer waiting on that state
         */
        state.set( SRWL_STATE_NOT_READING );
    }


    /**
     * Creates a new ReadersEntry instance for the current thread and
     * its associated AtomicInteger to store the state of the Reader
     *
     * @return Returns a reference to the newly created instance of
     * {@code ReadersEntry}
     */
    private ReadersEntry addState() {
        final AtomicInteger state = new AtomicInteger(
SRWL_STATE_NOT_READING);
        final ReadersEntry newEntry = new ReadersEntry(state);
        entry.set(newEntry);
        readersStateList .add(state);
        return newEntry;
    }


    /**
     * Acquires the read lock.
     *
     * <p> Acquires the read lock if the write lock is not held by
     * another thread and returns immediately.
     *
     * <p> If the write lock is held by another thread then
     * the current thread yields until the write lock is released.
     */
    public void sharedLock() {
        ReadersEntry localEntry = entry.get();
        // Initialize a new Reader-state for this thread if needed
        if (localEntry == null) {
            localEntry = addState();
        }

        // Already locked in read-mode, this is a reentrant lock so just
        // increase the count and return.
        if (localEntry.reentrantReaderCount > 0) {
            localEntry. reentrantReaderCount ++;
            return ;
        }

        final AtomicInteger currentReadersState = localEntry. state;
        /* The "optimistic" code path takes only two synchronized calls:
         * a set() on a cache line that should be held in exclusive mode
         * by the current thread, and a get() on a cache line that is
shared.
         */
        while (true ) {
            currentReadersState.set( SRWL_STATE_READING );
            if (writerOwner .get() == SRWL_INVALID_TID) {
                // Acquired lock in read-only mode
                localEntry. reentrantReaderCount = 1;
                return ;
            } else {
                // Go back to SRWL_STATE_NOT_READING to avoid blocking a
Writer
                // and then check if this is a downgrade.
                currentReadersState.set( SRWL_STATE_NOT_READING );
                if (writerOwner .get() == Thread.currentThread ().getId()) {
                    // Looks like it's the current thread that is holding
the
                    // write-lock. It's safe to go ahead and acquire the
read-lock
                    currentReadersState.set( SRWL_STATE_READING );
                    localEntry. reentrantReaderCount = 1;
                    return ;
                }
                // Some (other) thread is holding the write-lock, we must
wait
                while (writerOwner .get() != SRWL_INVALID_TID) {
                   Thread. yield();
                }
            }
        }
    }


    /**
     * Attempts to release the read lock.
     *
     * <p> If the current thread is the holder of this lock then
     * the {@code reentrantReaderCount} is decremented. If the
     * {@code reentrantReaderCount} is now zero then the lock is released.
     * If the current thread is not the holder of this lock then {@link
     * IllegalMonitorStateException} is thrown.
     *
     * @throws IllegalMonitorStateException if the current thread does not
     * hold this lock.
     */
    public void sharedUnlock() {
        final ReadersEntry localEntry = entry .get();

        if (localEntry== null || localEntry. reentrantReaderCount == 0) {
            // ERROR: Tried to unlock a non read-locked lock
            throw new IllegalMonitorStateException();
        } else {
            final AtomicInteger readersState = localEntry. state;
            localEntry. reentrantReaderCount --;
            if (localEntry.reentrantReaderCount == 0) {
                readersState.set( SRWL_STATE_NOT_READING );
            }
            return ;
        }
    }


    /**
     * Acquires the write lock.
     *
     * <p> Acquires the write lock if neither the read nor write lock
     * are held by another thread and returns immediately, setting
     * the write lock {@code reentrantWriterCount} to one.
     *
     * <p> If the current thread already holds the write lock then the
     * {@code reentrantWriterCount} is incremented by one and the method
     * returns immediately.
     *
     * <p> If the lock is held by another thread, then the current
     * thread yields and lies dormant until the write lock has been
acquired,
     * at which time the {@code reentrantWriterCount} is set to one.
     */
    public void exclusiveLock() {
        final long tid_self = Thread.currentThread ().getId();

        if (writerOwner .get() == tid_self) {
            // Already locked in write-mode, just increase the count and
return
            reentrantWriterCount ++;
            return ;
        }

        // Try to acquire the lock in write-mode
        while (!writerOwner .compareAndSet( SRWL_INVALID_TID, tid_self))
            Thread. yield();

        // Write-Lock was acquired, now wait for any running Readers to
finish
        Iterator<AtomicInteger> iter = readersStateList .iterator();
        AtomicInteger mynext = null ;
        while (iter.hasNext()) {
            try {
                /* iter.next() can throw a NoSuchElementException because
                 * after the iter.hasNext() has been evaluated, another
thread
                 * may call removeState() and the last element of the
                 * readersStateList is removed.
                 */
                mynext = iter.next();
            } catch (NoSuchElementException e) {
                break ;
            }
            while (mynext.get() == SRWL_STATE_READING) Thread. yield();
        }

        reentrantWriterCount = 1;
    }


    /**
     * Attempts to release the write lock.
     *
     * <p> If the current thread is the holder of this lock then
     * the {@code reentrantWriterCount} is decremented. If {@code
     * reentrantWriterCount} is now zero then the lock is released.
     * If the current thread is not the holder of this lock then {@link
     * IllegalMonitorStateException} is thrown.
     *
     * @throws IllegalMonitorStateException if the current thread does not
     * hold this lock.
     */
    public void exclusiveUnlock() {
        final long tid_self = Thread.currentThread ().getId();

        if (writerOwner .get() != tid_self) {
            // ERROR: tried to unlock a non write-locked instance
            throw new IllegalMonitorStateException();
        }

        if (reentrantWriterCount > 0) {
            // Reentrant lock in write-mode, just decrease the count
            reentrantWriterCount --;
        }

        if (reentrantWriterCount == 0) {
            // If this is the last reentrant lock, then clear the
writerOwner
            // to release the write-mode lock.
            writerOwner .set(SRWL_INVALID_TID );
        }
    }


   /**
    * Acquires the read lock only if the write lock is not held by
    * another thread at the time of invocation.
    *
    * <p>Acquires the read lock if the write lock is not held by
    * another thread and returns immediately with the value
    * {@code true}.
    *
    * <p>If the write lock is held by another thread then
    * this method will return immediately with the value
    * {@code false}.
    *
    * @return {@code true} if the read lock was acquired
    */
    public boolean sharedTryLock() {
        ReadersEntry localEntry = entry.get();
        // Initialize a new Reader-state for this thread if needed
        if (localEntry == null) {
            localEntry = addState();
        }

        // Already locked in read-mode, this is a reentrant lock so just
        // increase the count and return.
        if (localEntry.reentrantReaderCount > 0) {
            localEntry. reentrantReaderCount ++;
            return true ;
        }

        final AtomicInteger currentReadersState = localEntry. state;
        currentReadersState.set( SRWL_STATE_READING );
        if (writerOwner .get() == SRWL_INVALID_TID) {
            // Acquired lock in read-only mode
            localEntry. reentrantReaderCount = 1;
            return true ;
        } else {
            // Go back to SRWL_STATE_NOT_READING to avoid blocking a Writer
            // and then check if this is a downgrade.
            currentReadersState.set( SRWL_STATE_NOT_READING );
            if (writerOwner .get() == Thread.currentThread ().getId()) {
                // Looks like it's the current thread that is holding the
                // write-lock. It's safe to go ahead and acquire the
read-lock
                currentReadersState.set( SRWL_STATE_READING );
                localEntry. reentrantReaderCount = 1;
                return true ;
            }
            return false ;
        }
    }


    /**
     * Acquires the read lock if the write lock is not held by
     * another thread within the given waiting time.
     *
     * <p> Acquires the read lock if the write lock is not held by
     * another thread and returns immediately with the value
     * {@code true}.
     *
     * <p> If the write lock is held by another thread then the
     * current thread yields execution until one of two things happens:
     * <ul>
     * <li> The read lock is acquired by the current thread; or
     * <li> The specified waiting time elapses.
     * </ul>
     *
     * <p> If the read lock is acquired then the value {@code true} is
     * returned.
     *
     * @param nanosTimeout the time to wait for the read lock in nanoseconds
     * @return {@code true} if the read lock was acquired
     */
    public boolean sharedTryLockNanos( long nanosTimeout) {
        final long lastTime = System.nanoTime ();
        ReadersEntry localEntry = entry.get();
        // Initialize a new Reader-state for this thread if needed
        if (localEntry == null) {
            localEntry = addState();
        }

        // Already locked in read-mode, this is a reentrant lock so just
        // increase the count and return.
        if (localEntry.reentrantReaderCount > 0) {
            localEntry. reentrantReaderCount ++;
            return true ;
        }

        final AtomicInteger currentReadersState = localEntry. state;

        while (true ) {
            currentReadersState.set( SRWL_STATE_READING );
            if (writerOwner .get() == SRWL_INVALID_TID) {
                // Acquired lock in read-only mode
                localEntry. reentrantReaderCount = 1;
                return true ;
            } else {
                // Go back to SRWL_STATE_NOT_READING to avoid blocking a
Writer
                // and then check if this is a downgrade.
                currentReadersState.set( SRWL_STATE_NOT_READING );
                if (writerOwner .get() == Thread.currentThread ().getId()) {
                    // Looks like it's the current thread that is holding
the
                    // write-lock. It's safe to go ahead and acquire the
read-lock
                    currentReadersState.set( SRWL_STATE_READING );
                    localEntry. reentrantReaderCount = 1;
                    return true ;
                }
                if (nanosTimeout <= 0) return false;
            }

            if (System.nanoTime()-lastTime < nanosTimeout) {
                Thread. yield();
            } else {
                return false ;
            }
        }
    }


    /**
     * Acquires the write lock only if it is not held by another thread
     * at the time of invocation.
     *
     * <p> Acquires the write lock if the write lock is not
     * held by another thread and returns immediately with
     * the value {@code true} if and only if no other thread is attempting a
     * read lock, setting the write lock {@code writerLoop}
     * count to one. If another thread is attempting a read lock, this
     * function <b> may yield until the read lock is released </b>.
     *
     * <p> If the current thread already holds this lock then the
     * {@code reentrantWriterCount} count is incremented by one and the
method returns
     * {@code true}.
     *
     * <p> If the write lock is held by another thread then this method
     * will return immediately with the value {@code false}.
     *
     * @return {@code true} if the write lock was free and was acquired
     * by the current thread, or the write lock was already held
     * by the current thread; and {@code false} otherwise.
     */
    public boolean exclusiveTryLock() {
        final long tid_self = Thread.currentThread ().getId();

        if (writerOwner .get() == tid_self) {
           // Already locked in write-mode, just increase the count and
return
            reentrantWriterCount ++;
           return true ;
        }

        // Try to acquire the lock in write-mode
        if (!writerOwner .compareAndSet( SRWL_INVALID_TID, tid_self))
            return false ;

        // Write-Lock was acquired, now wait for any running Readers to
finish
        Iterator<AtomicInteger> iter = readersStateList .iterator();
        AtomicInteger mynext = null ;
        while (iter.hasNext()) {
            try {
                mynext = iter.next();
            } catch (NoSuchElementException e) {
                break ;
            }
            while (mynext.get() == SRWL_STATE_READING) Thread. yield();
        }

        reentrantWriterCount = 1;
        return true ;
    }


    /**
     * Acquires the write lock if it is not held by another thread
     * within the given waiting time.
     *
     * <p> Acquires the write lock if the write lock is not
     * held by another thread and returns immediately with
     * the value {@code true} if and only if no other thread is attempting a
     * read lock, setting the write lock {@code reentrantWriterCount}
     * to one. If another thread is attempting a read lock, this
     * function <b> may yield until the read lock is released </b>.
     *
     * <p> If the current thread already holds this lock then the
     * {@code reentrantWriterCount} is incremented by one and the method
returns
     * {@code true}.
     *
     * <p> If the write lock is held by another thread then the current
     * thread yields and lies dormant until one of two things happens:
     * <ul>
     * <li> The write lock is acquired by the current thread; or
     * <li> The specified waiting time elapses
     * </ul>
     *
     * <p> If the read lock is held by another thread then the current
     * thread yields and lies dormant until the read lock is released.
     *
     * <p> If the write lock is acquired then the value {@code true} is
     * returned and the write lock {@code reentrantWriterCount} is set to
one.
     *
     * <p> There is no guarantee that there is a maximum waiting time for
     * this method.
     *
     * @param nanosTimeout the time to wait for the write lock in
nanoseconds
     *
     * @return {@code true} if the lock was free and was acquired
     * by the current thread, or the write lock was already held by the
     * current thread; and {@code false} if the waiting time
     * elapsed before the lock could be acquired.
     */
    public boolean exclusiveTryLockNanos( long nanosTimeout) {
        final long lastTime = System.nanoTime ();
        final long tid_self = Thread.currentThread ().getId();

        if (writerOwner .get() == tid_self) {
           // Already locked in write-mode, just increase the count and
return
            reentrantWriterCount ++;
           return true ;
        }

        // Try to acquire the lock in write-mode
        while (!writerOwner .compareAndSet( SRWL_INVALID_TID, tid_self)) {
            if (System.nanoTime()-lastTime < nanosTimeout) {
                Thread. yield();
            } else {
                return false ;
            }
        }

        // Write-Lock was acquired, now wait for any running Readers to
finish
        Iterator<AtomicInteger> iter = readersStateList .iterator();
        AtomicInteger mynext = null ;
        while (iter.hasNext()) {
            try {
                mynext = iter.next();
            } catch (NoSuchElementException e) {
                break ;
            }
            while (mynext.get() == SRWL_STATE_READING) Thread. yield();
        }

        reentrantWriterCount = 1;
        return true ;
    }

}
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130324/30ecec53/attachment-0001.html>

From heinz at javaspecialists.eu  Sun Mar 24 14:11:34 2013
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Sun, 24 Mar 2013 20:11:34 +0200
Subject: [concurrency-interest] A Scalable and Fast Read-Write Lock
In-Reply-To: <CAAApjO1iPUtt1r2frfCwiUeMYGH59_Xh7P56v+pyB4s5RY-fFQ@mail.gmail.com>
References: <CAAApjO1iPUtt1r2frfCwiUeMYGH59_Xh7P56v+pyB4s5RY-fFQ@mail.gmail.com>
Message-ID: <514F41D6.4080504@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130324/08501aac/attachment-0001.html>

From stanimir at riflexo.com  Sun Mar 24 16:50:19 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Sun, 24 Mar 2013 22:50:19 +0200
Subject: [concurrency-interest] A Scalable and Fast Read-Write Lock
In-Reply-To: <CAAApjO1iPUtt1r2frfCwiUeMYGH59_Xh7P56v+pyB4s5RY-fFQ@mail.gmail.com>
References: <CAAApjO1iPUtt1r2frfCwiUeMYGH59_Xh7P56v+pyB4s5RY-fFQ@mail.gmail.com>
Message-ID: <CAEJX8ooT1iVe24JNJ5YEG-5r+eRBqfybOUOG5h8MoTEZwN6Mbg@mail.gmail.com>

I've had some quick code review, here my findings:

You can optimize the write by converting/polling the CLQ into
AtomicInterer[] during the exclusive lock. CLQ could be used for add/remove
events using the spare bits in the AtomicInteger.
CLQ doesn't throw NoSuchElementException if hasNext has returned true.
Probably you don't need to use CLQ/AtomicInteger to force padding, and esp,
you don't need to initialized them. Using 15 of them also will not ensure
proper padding on systems w/ 32bit pointers (basically anything running
below 32GB RAM).
Most definitely you don't need padding for the ThreadLocal.

Other than that the implementation looks good to me, except you might need
back-off strategy when the lock is exclusively taken.

Cheers!
Stanimir

On Sun, Mar 24, 2013 at 7:54 PM, Pedro Ramalhete <pramalhe at gmail.com> wrote:

> Hello,
>
> We have implemented a read-write lock that under a low number of Writes is
> able to scale with the number of Reader threads almost linearly even under
> high contention (source code at the end of this e-mail). The technique is
> similar to the C-RW-WP algorithm described on the recently published paper
> "NUMA-Aware Reader-Writer locks" from the Oracle Research team, that can be
> found at this link:
> http://labs.oracle.com/projects/scalable/pubs/PPoPP2013-numa-rwlock.pdf
> This is an excellent and very detailed paper worth the reading if you're
> interested in concurrent algorithms or read-write locks, but here is a very
> short summary of our own implementation:
>
> - There is a list readersStateList (a ConcurrentLinkedQueue in this
> particular implementation) that contains the state of each reader, 0 means
> "not reading", 1 means "reading" or "wishing to read".
> - A reference to the state of each Reader thread is placed in the
> readersStateList, which will be used from then on whenever it wants to
> obtain a read-lock. This can be achieved with careful usage of a
> ThreadLocal.
> - There is a variable named writerOwner that holds the state of the
> write-lock.
>
> Read-lock procedure:
> 1. Get the reference to the Reader's state for the current thread (from a
> ThreadLocal for example).
> 2. Do an AtomicInteger.set() of the current Reader's state to 1.
> 3. Do an AtomicInteger.get() of writerOwner and, if it is 1, set the
> current Reader's state back to 0, do yield() and try again later (lock is
> being held by a Writer), otherwise the lock has been acquired in read-only
> mode by the current thread and return.
>
> Write-lock procedure:
> 1. Do an AtomicInteger.compareAndSet() loop on writerOwner to change it's
> state from 0 to 1. yield() when not successful.
> 2. Scan all the states in the readersStateList one at a time and yield()
> on each that is at 1. Once a certain state has been seen to be at 0, we can
> advance to the next one, and even if that state goes back to 1, it will be
> temporarily because the writerOwner was already set at 1, thus preventing
> Readers from acquiring the read-lock (i.e. this algorithm has
> Writer-Preference).
> 3. At the end of the scan of readersStateList the write-mode lock will be
> acquired by the current thread.
>
> This class implements java.util.concurrent.locks.ReadWriteLock, and no
> extra initialization is required.
>
> A more detailed description of the two-state algorithm can be found here:
>
> http://www.concurrencyfreaks.com/2013/02/flowcharts-for-2-states-scalable-rw-lock.html
>
> You can find some performance plots here comparing it with StampedLock and
> ReentrantReadWriteLock from java.util.concurrent:
>
> http://www.concurrencyfreaks.com/2013/03/scalablereentrantrwlock-performance.html
> and a "pseudo-analysis" of the performance:
> http://www.concurrencyfreaks.com/2013/02/why-is-scalablerwlock-fast.html
>
> A counter based version (and others) of this algorithm can be obtained
> from sourceforge:
> https://sourceforge.net/projects/ccfreaks
>
>
> Please give it a try and let us know what you think of it.
>
> Thanks,
> Pedro & Andreia
>
> ScalableReentrantRWLock.java
>
> -------------------------------------------------------------------------------------------------
>
>
> /******************************************************************************
>  * Copyright (c) 2012 - 2013, Pedro Ramalhete, Andreia Correia
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms, with or without
>  * modification, are permitted provided that the following conditions are
> met:
>  *     * Redistributions of source code must retain the above copyright
>  *       notice, this list of conditions and the following disclaimer.
>  *     * Redistributions in binary form must reproduce the above copyright
>  *       notice, this list of conditions and the following disclaimer in
> the
>  *       documentation and/or other materials provided with the
> distribution.
>  *     * Neither the name of Concurrency Freaks nor the
>  *       names of its contributors may be used to endorse or promote
> products
>  *       derived from this software without specific prior written
> permission.
>  *
>  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
> IS" AND
>  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
> IMPLIED
>  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
>  * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
>  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
> DAMAGES
>  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
> SERVICES;
>  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
> AND
>  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
> TORT
>  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
> OF THIS
>  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
>
>  ******************************************************************************
>  */
>
> import java.util.Iterator;
> import java.util.NoSuchElementException;
> import java.util.concurrent.ConcurrentLinkedQueue;
> import java.util.concurrent.TimeUnit;
> import java.util.concurrent.atomic.AtomicInteger;
> import java.util.concurrent.atomic.AtomicLong;
> import java.util.concurrent.locks.Condition;
> import java.util.concurrent.locks.Lock;
> import java.util.concurrent.locks.ReadWriteLock;
>
>
>
> /** <h1> Scalable Reentrant Read - Write Lock </h1>
>  * A Read -Write Lock that is scalable with the number of threads doing
> Read.
>  * <p>
>  * Uses a two -state - machine for the Readers, and averages two
> synchronized
>  * operations. <br>
>  * Although this mechanism was independently designed and implemented by
> the
>  * authors, the idea is very similar to the algorithm C - RW- WP described
> in this
>  * paper: <a href="
> http://blogs.oracle.com/dave/resource/ppopp13-dice-NUMAAwareRWLocks.pdf">NUMA
> - Aware Reader- Writer locks </a>
>  * <br>
>  * Relative to the paper, there are two differences: The threads have no
>  * particular order, which means this implementation is <b> not</b> NUMA
> -aware;
>  * Threads attempting a read - lock for the first time are added to a list
> and
>  * removed when the thread terminates, following the mechanism described
> below.
>  * <p>
>  * To manage the adding and removal of new Reader threads, we use a
>  * ConcurrentLinkedQueue instance named {@code readersStateList}
> containing all
>  * the references to ReadersEntry (Reader's states), which the Writer
> scans to
>  * determine if the Readers have completed or not.
>  * After a thread terminates, the {@code finalize()} of the associated
>  * {@code ReaderEntry} instance will be called, which will remove the
>  * Reader's state reference from the {@code readersStateList}, to avoid
> memory leaking.
>  * <p>
>  * Advantages: <ul>
>  * <li> Implements {@code java.util.concurrent.locks.ReadWriteLock}
>  * <li> When there are very few Writes, the performance scales with the
>  *      number of Reader threads
>  * <li> Reentrant, with support for lock downgrading (but <b>not </b>
> upgrading)
>  * <li> No need to call initialization/cleanup functions per thread
>  * <li> No limitation on the number of concurrent threads
>  * </ul>
>  * <p>
>  * Disadvantages: <ul>
>  * <li> Has Writer - Preference
>  * <li> writeLock().tryLock() is not guaranteed to return immediately
>  * <li> Memory footprint increases with number of threads by
> sizeof(ReadersEntry) x O(N_threads)
>  * <li> Does not (yet) support {@code lockInterruptibly()}
>  * <li> Does not (yet) support {@code newCondition()}
>  * <li> Does not (yet) implement {@code java.io.Serializable}
>  * </ul>
>  * <p>
>  * This lock allows downgrading from the write lock to a read lock, by
>  * acquiring the write lock, then the read lock and then releasing the
> write
>  * lock. However, upgrading from a read lock to the write lock is <b>
> not<br>
>  * possible.
>  * <p>
>  * For scenarios with few writes, the average case for {@code
> sharedLock()} is
>  * two synchronized calls: an {@code AtomicInteger.set()} on a cache line
> that
>  * is held in exclusive mode by the core where the current thread is
> running,
>  * and an {@code AtomicLong.get()} on a shared cache line. <br>
>  * This means that when doing several sequential calls of
> sharedLock()/unlock()
>  * on the same instance, the performance penalty will be small because the
>  * accessed variables will most likely be in L1/L2 cache.
>  * <p>
>  * We use several {@code pxxxxxx} variables to create cache -line padding
>  * between the different member variables and avoid <tt> false- sharing
> </tt>.
>  * They have to be of the same type of the adjacent member to guarantee
> that
>  * they won't be re - ordered, and they have to be {@code public} and
>  * {@code volatile} so that they're not <tt> optimized away</tt> for not
>  * being used.
>  * We should be able to get rid of all these padding variables once the
>  * annotation {@code @Contention } gets implemented in JEP 142
>  * <a href="http://openjdk.java.net/jeps/142">
> http://openjdk.java.net/jeps/142 </a>
>  *
>  * @author Pedro Ramalhete
>  * @author Andreia Correia
>  */
> public class ScalableReentrantRWLock implements ReadWriteLock {
>
>     // Definition of an invalid thread-id (must be negative)
>     private final static int SRWL_INVALID_TID       = -1;
>     private final static int SRWL_STATE_NOT_READING = 0;
>     private final static int SRWL_STATE_READING     = 1;
>
>     /**
>      * List of Reader's states that the Writer will scan when attempting to
>      * acquire the lock in write - mode
>      */
>     private final ConcurrentLinkedQueue<AtomicInteger> readersStateList;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p1readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p2readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p3readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p4readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p5readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p6readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p7readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p8readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p9readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p10readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p11readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p12readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p13readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p14readersState;
>     public volatile ConcurrentLinkedQueue<AtomicInteger> p15readersState;
>
>     /**
>      * The thread - id of the Writer currently holding the lock in write
> -mode, or
>      * SRWL_INVALID_TID if there is no Writer holding or attempting to
> acquire
>      * the lock in write mode.
>      */
>     private final AtomicLong writerOwner ;
>     public volatile AtomicLong p1writerOwner ;
>     public volatile AtomicLong p2writerOwner ;
>     public volatile AtomicLong p3writerOwner ;
>     public volatile AtomicLong p4writerOwner ;
>     public volatile AtomicLong p5writerOwner ;
>     public volatile AtomicLong p6writerOwner ;
>     public volatile AtomicLong p7writerOwner ;
>     public volatile AtomicLong p8writerOwner ;
>     public volatile AtomicLong p9writerOwner ;
>     public volatile AtomicLong p10writerOwner ;
>     public volatile AtomicLong p11writerOwner ;
>     public volatile AtomicLong p12writerOwner ;
>     public volatile AtomicLong p13writerOwner ;
>     public volatile AtomicLong p14writerOwner ;
>     public volatile AtomicLong p15writerOwner ;
>
>     /**
>      * The number of reentrant write locks held by the current thread.
>      * <p>
>      * This doesn't need to be volatile because we always modify it within
>      * acquire - release- barriers, or within the same thread.
>      * <p>
>      * Initialized to zero in the constructor.
>      */
>     private int reentrantWriterCount ;
>     public volatile int p1reentrantWriterCount ;
>     public volatile int p2reentrantWriterCount ;
>     public volatile int p3reentrantWriterCount ;
>     public volatile int p4reentrantWriterCount ;
>     public volatile int p5reentrantWriterCount ;
>     public volatile int p6reentrantWriterCount ;
>     public volatile int p7reentrantWriterCount ;
>     public volatile int p8reentrantWriterCount ;
>     public volatile int p9reentrantWriterCount ;
>     public volatile int p10reentrantWriterCount ;
>     public volatile int p11reentrantWriterCount ;
>     public volatile int p12reentrantWriterCount ;
>     public volatile int p13reentrantWriterCount ;
>     public volatile int p14reentrantWriterCount ;
>     public volatile int p15reentrantWriterCount ;
>
>     /**
>      * Thread - local reference to the current thread's ReadersEntry
> instance.
>      * It's from this instance that the current Reader thread is able
>      * to determine where to store its own state, and the number of
> reentrant
>      * read lock loops for that particular thread.
>      */
>     private final ThreadLocal<ReadersEntry> entry ;
>     public volatile ThreadLocal<ReadersEntry> p1entry ;
>     public volatile ThreadLocal<ReadersEntry> p2entry ;
>     public volatile ThreadLocal<ReadersEntry> p3entry ;
>     public volatile ThreadLocal<ReadersEntry> p4entry ;
>     public volatile ThreadLocal<ReadersEntry> p5entry ;
>     public volatile ThreadLocal<ReadersEntry> p6entry ;
>     public volatile ThreadLocal<ReadersEntry> p7entry ;
>     public volatile ThreadLocal<ReadersEntry> p8entry ;
>     public volatile ThreadLocal<ReadersEntry> p9entry ;
>     public volatile ThreadLocal<ReadersEntry> p10entry ;
>     public volatile ThreadLocal<ReadersEntry> p11entry ;
>     public volatile ThreadLocal<ReadersEntry> p12entry ;
>     public volatile ThreadLocal<ReadersEntry> p13entry ;
>     public volatile ThreadLocal<ReadersEntry> p14entry ;
>     public volatile ThreadLocal<ReadersEntry> p15entry ;
>
>     /**
>      * The lock returned by method {@link
> ScalableReentrantRWLock#readLock} .
>      */
>     private final ScalableReentrantRWLock.InnerReadLock readerLock ;
>
>     /**
>      * The lock returned by method {@link
> ScalableReentrantRWLock#writeLock} .
>      */
>     private final ScalableReentrantRWLock.InnerWriteLock writerLock;
>
>
>     /**
>      * Inner class that makes use of finalize() to remove the Reader's
> state
>      * from the ConcurrentLinkedQueue {@code readersStateList}
>      */
>     public class ReadersEntry {
>         public final AtomicInteger state;
>         public int reentrantReaderCount = 0;
>
>         public ReadersEntry(AtomicInteger state) {
>             this .state = state;
>         }
>
>         protected void finalize() throws Throwable {
>             removeState( state);
>             super .finalize();
>         }
>     }
>
>
>         /**
>         * Read - only lock
>         */
>         public class InnerReadLock implements Lock {
>            final ScalableReentrantRWLock rwlock ;
>
>            public InnerReadLock(ScalableReentrantRWLock rwlock) { this.
> rwlock = rwlock; }
>             public void lock() { rwlock.sharedLock(); }
>             public void unlock() { rwlock.sharedUnlock(); }
>             public boolean tryLock() { return rwlock.sharedTryLock(); }
>             public boolean tryLock( long timeout, TimeUnit unit)
>                     throws InterruptedException {
>                 if (Thread.interrupted()) throw new
> InterruptedException();
>                 return sharedTryLockNanos(unit.toNanos(timeout));
>             }
>             public void lockInterruptibly() throws InterruptedException {
>                 // Not supported
>                 throw new
> UnsupportedOperationException();
>             }
>             public Condition newCondition() {
>                 // Not supported
>                 throw new UnsupportedOperationException();
>             }
>        }
>
>
>     /**
>      * Write - only lock
>      */
>     public class InnerWriteLock implements Lock {
>         final ScalableReentrantRWLock rwlock ;
>
>         public InnerWriteLock(ScalableReentrantRWLock rwlock) { this.
> rwlock = rwlock; }
>         public void lock() { rwlock.exclusiveLock(); }
>         public void unlock() { rwlock.exclusiveUnlock(); }
>         public boolean tryLock() { return rwlock.exclusiveTryLock(); }
>         public boolean tryLock( long timeout, TimeUnit unit)
>                 throws InterruptedException {
>             if (Thread.interrupted()) throw new InterruptedException();
>             return exclusiveTryLockNanos(unit.toNanos(timeout));
>         }
>         public void lockInterruptibly() throws InterruptedException {
>             // Not supported
>             throw new UnsupportedOperationException();
>         }
>         public Condition newCondition() {
>             // Not supported
>             throw new UnsupportedOperationException();
>         }
>     }
>
>
>     /**
>      * Default constructor
>      */
>     public ScalableReentrantRWLock() {
>         // States of the Readers, one entry in the list per thread
>         readersStateList = new ConcurrentLinkedQueue<AtomicInteger>();
>         p1readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p2readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p3readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p4readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p5readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p6readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p7readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p8readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p9readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p10readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p11readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p12readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p13readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p14readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>         p15readersState = new ConcurrentLinkedQueue<AtomicInteger>();
>
>         writerOwner = new AtomicLong( SRWL_INVALID_TID);
>         p1writerOwner = new AtomicLong();
>         p2writerOwner = new AtomicLong();
>         p3writerOwner = new AtomicLong();
>         p4writerOwner = new AtomicLong();
>         p5writerOwner = new AtomicLong();
>         p6writerOwner = new AtomicLong();
>         p7writerOwner = new AtomicLong();
>         p8writerOwner = new AtomicLong();
>         p9writerOwner = new AtomicLong();
>         p10writerOwner = new AtomicLong();
>         p11writerOwner = new AtomicLong();
>         p12writerOwner = new AtomicLong();
>         p13writerOwner = new AtomicLong();
>         p14writerOwner = new AtomicLong();
>         p15writerOwner = new AtomicLong();
>
>         reentrantWriterCount = 0;
>         p1reentrantWriterCount = 0;
>         p2reentrantWriterCount = 0;
>         p3reentrantWriterCount = 0;
>         p4reentrantWriterCount = 0;
>         p5reentrantWriterCount = 0;
>         p6reentrantWriterCount = 0;
>         p7reentrantWriterCount = 0;
>         p8reentrantWriterCount = 0;
>         p9reentrantWriterCount = 0;
>         p10reentrantWriterCount = 0;
>         p11reentrantWriterCount = 0;
>         p12reentrantWriterCount = 0;
>         p13reentrantWriterCount = 0;
>         p14reentrantWriterCount = 0;
>         p15reentrantWriterCount = 0;
>
>         /* Default value for "entry" is null which is ok because, the
> thread
>          * calling the constructor may never attempt to read-lock this
>          * instance and, therefore, there is not point in allocating an
>          * instance of ReadersEntry for it.
>          */
>         entry = new ThreadLocal<ReadersEntry>();
>         p1entry = new ThreadLocal<ReadersEntry>();
>         p2entry = new ThreadLocal<ReadersEntry>();
>         p3entry = new ThreadLocal<ReadersEntry>();
>         p4entry = new ThreadLocal<ReadersEntry>();
>         p5entry = new ThreadLocal<ReadersEntry>();
>         p6entry = new ThreadLocal<ReadersEntry>();
>         p7entry = new ThreadLocal<ReadersEntry>();
>         p8entry = new ThreadLocal<ReadersEntry>();
>         p9entry = new ThreadLocal<ReadersEntry>();
>         p10entry = new ThreadLocal<ReadersEntry>();
>         p11entry = new ThreadLocal<ReadersEntry>();
>         p12entry = new ThreadLocal<ReadersEntry>();
>         p13entry = new ThreadLocal<ReadersEntry>();
>         p14entry = new ThreadLocal<ReadersEntry>();
>         p15entry = new ThreadLocal<ReadersEntry>();
>
>         readerLock = new ScalableReentrantRWLock.InnerReadLock( this);
>         writerLock = new ScalableReentrantRWLock.InnerWriteLock( this);
>
>         // Force a release-memory barrier to make sure that initialization
>         // is done by the time a lock operation is attempted
>         writerOwner .set(SRWL_INVALID_TID );
>     }
>
>     public Lock readLock() { return readerLock ; }
>     public Lock writeLock() { return writerLock ; }
>
>
>     /**
>      * This function should be called only from ReadersEntry.finalize()
>      *
>      * @param state The reader's state that we wish to remove from the
> ConcurrentLinkedQueue
>      */
>     protected void removeState(AtomicInteger state) {
>         /* We don't need to lock in exclusive mode in Java thanks to the
>          * Garbage Collector, but in other languages (C/C++) we will need
>          * to wrap this in an exclusiveLock()/exclusiveUnlock() to prevent
> ABA
>          * problem if another thread is calling the exclusiveLock() at the
>          * same time, and is holding a pointer to this "state" while
> scanning
>          * the Readers.
>          */
>         readersStateList .remove(state);
>         /* Paranoia: just in case someone forgot to call sharedUnlock()
>          * and there is a Writer waiting on that state
>          */
>         state.set( SRWL_STATE_NOT_READING );
>     }
>
>
>     /**
>      * Creates a new ReadersEntry instance for the current thread and
>      * its associated AtomicInteger to store the state of the Reader
>      *
>      * @return Returns a reference to the newly created instance of
>      * {@code ReadersEntry}
>      */
>     private ReadersEntry addState() {
>         final AtomicInteger state = new AtomicInteger(
> SRWL_STATE_NOT_READING);
>         final ReadersEntry newEntry = new ReadersEntry(state);
>         entry.set(newEntry);
>         readersStateList .add(state);
>         return newEntry;
>     }
>
>
>     /**
>      * Acquires the read lock.
>      *
>      * <p> Acquires the read lock if the write lock is not held by
>      * another thread and returns immediately.
>      *
>      * <p> If the write lock is held by another thread then
>      * the current thread yields until the write lock is released.
>      */
>     public void sharedLock() {
>         ReadersEntry localEntry = entry.get();
>         // Initialize a new Reader-state for this thread if needed
>         if (localEntry == null) {
>             localEntry = addState();
>         }
>
>         // Already locked in read-mode, this is a reentrant lock so just
>         // increase the count and return.
>         if (localEntry.reentrantReaderCount > 0) {
>             localEntry. reentrantReaderCount ++;
>             return ;
>         }
>
>         final AtomicInteger currentReadersState = localEntry. state;
>         /* The "optimistic" code path takes only two synchronized calls:
>          * a set() on a cache line that should be held in exclusive mode
>          * by the current thread, and a get() on a cache line that is
> shared.
>          */
>         while (true ) {
>             currentReadersState.set( SRWL_STATE_READING );
>             if (writerOwner .get() == SRWL_INVALID_TID) {
>                 // Acquired lock in read-only mode
>                 localEntry. reentrantReaderCount = 1;
>                 return ;
>             } else {
>                 // Go back to SRWL_STATE_NOT_READING to avoid blocking a
> Writer
>                 // and then check if this is a downgrade.
>                 currentReadersState.set( SRWL_STATE_NOT_READING );
>                 if (writerOwner .get() == Thread.currentThread ().getId())
> {
>                     // Looks like it's the current thread that is holding
> the
>                     // write-lock. It's safe to go ahead and acquire the
> read-lock
>                     currentReadersState.set( SRWL_STATE_READING );
>                     localEntry. reentrantReaderCount = 1;
>                     return ;
>                 }
>                 // Some (other) thread is holding the write-lock, we must
> wait
>                 while (writerOwner .get() != SRWL_INVALID_TID) {
>                    Thread. yield();
>                 }
>             }
>         }
>     }
>
>
>     /**
>      * Attempts to release the read lock.
>      *
>      * <p> If the current thread is the holder of this lock then
>      * the {@code reentrantReaderCount} is decremented. If the
>      * {@code reentrantReaderCount} is now zero then the lock is released.
>      * If the current thread is not the holder of this lock then {@link
>      * IllegalMonitorStateException} is thrown.
>      *
>      * @throws IllegalMonitorStateException if the current thread does not
>      * hold this lock.
>      */
>     public void sharedUnlock() {
>         final ReadersEntry localEntry = entry .get();
>
>         if (localEntry== null || localEntry. reentrantReaderCount == 0) {
>             // ERROR: Tried to unlock a non read-locked lock
>             throw new IllegalMonitorStateException();
>         } else {
>             final AtomicInteger readersState = localEntry. state;
>             localEntry. reentrantReaderCount --;
>             if (localEntry.reentrantReaderCount == 0) {
>                 readersState.set( SRWL_STATE_NOT_READING );
>             }
>             return ;
>         }
>     }
>
>
>     /**
>      * Acquires the write lock.
>      *
>      * <p> Acquires the write lock if neither the read nor write lock
>      * are held by another thread and returns immediately, setting
>      * the write lock {@code reentrantWriterCount} to one.
>      *
>      * <p> If the current thread already holds the write lock then the
>      * {@code reentrantWriterCount} is incremented by one and the method
>      * returns immediately.
>      *
>      * <p> If the lock is held by another thread, then the current
>      * thread yields and lies dormant until the write lock has been
> acquired,
>      * at which time the {@code reentrantWriterCount} is set to one.
>      */
>     public void exclusiveLock() {
>         final long tid_self = Thread.currentThread ().getId();
>
>         if (writerOwner .get() == tid_self) {
>             // Already locked in write-mode, just increase the count and
> return
>             reentrantWriterCount ++;
>             return ;
>         }
>
>         // Try to acquire the lock in write-mode
>         while (!writerOwner .compareAndSet( SRWL_INVALID_TID, tid_self))
>             Thread. yield();
>
>         // Write-Lock was acquired, now wait for any running Readers to
> finish
>         Iterator<AtomicInteger> iter = readersStateList .iterator();
>         AtomicInteger mynext = null ;
>         while (iter.hasNext()) {
>             try {
>                 /* iter.next() can throw a NoSuchElementException because
>                  * after the iter.hasNext() has been evaluated, another
> thread
>                  * may call removeState() and the last element of the
>                  * readersStateList is removed.
>                  */
>                 mynext = iter.next();
>             } catch (NoSuchElementException e) {
>                 break ;
>             }
>             while (mynext.get() == SRWL_STATE_READING) Thread. yield();
>         }
>
>         reentrantWriterCount = 1;
>     }
>
>
>     /**
>      * Attempts to release the write lock.
>      *
>      * <p> If the current thread is the holder of this lock then
>      * the {@code reentrantWriterCount} is decremented. If {@code
>      * reentrantWriterCount} is now zero then the lock is released.
>      * If the current thread is not the holder of this lock then {@link
>      * IllegalMonitorStateException} is thrown.
>      *
>      * @throws IllegalMonitorStateException if the current thread does not
>      * hold this lock.
>      */
>     public void exclusiveUnlock() {
>         final long tid_self = Thread.currentThread ().getId();
>
>         if (writerOwner .get() != tid_self) {
>             // ERROR: tried to unlock a non write-locked instance
>             throw new IllegalMonitorStateException();
>         }
>
>         if (reentrantWriterCount > 0) {
>             // Reentrant lock in write-mode, just decrease the count
>             reentrantWriterCount --;
>         }
>
>         if (reentrantWriterCount == 0) {
>             // If this is the last reentrant lock, then clear the
> writerOwner
>             // to release the write-mode lock.
>             writerOwner .set(SRWL_INVALID_TID );
>         }
>     }
>
>
>    /**
>     * Acquires the read lock only if the write lock is not held by
>     * another thread at the time of invocation.
>     *
>     * <p>Acquires the read lock if the write lock is not held by
>     * another thread and returns immediately with the value
>     * {@code true}.
>     *
>     * <p>If the write lock is held by another thread then
>     * this method will return immediately with the value
>     * {@code false}.
>     *
>     * @return {@code true} if the read lock was acquired
>     */
>     public boolean sharedTryLock() {
>         ReadersEntry localEntry = entry.get();
>         // Initialize a new Reader-state for this thread if needed
>         if (localEntry == null) {
>             localEntry = addState();
>         }
>
>         // Already locked in read-mode, this is a reentrant lock so just
>         // increase the count and return.
>         if (localEntry.reentrantReaderCount > 0) {
>             localEntry. reentrantReaderCount ++;
>             return true ;
>         }
>
>         final AtomicInteger currentReadersState = localEntry. state;
>         currentReadersState.set( SRWL_STATE_READING );
>         if (writerOwner .get() == SRWL_INVALID_TID) {
>             // Acquired lock in read-only mode
>             localEntry. reentrantReaderCount = 1;
>             return true ;
>         } else {
>             // Go back to SRWL_STATE_NOT_READING to avoid blocking a Writer
>             // and then check if this is a downgrade.
>             currentReadersState.set( SRWL_STATE_NOT_READING );
>             if (writerOwner .get() == Thread.currentThread ().getId()) {
>                 // Looks like it's the current thread that is holding the
>                 // write-lock. It's safe to go ahead and acquire the
> read-lock
>                 currentReadersState.set( SRWL_STATE_READING );
>                 localEntry. reentrantReaderCount = 1;
>                 return true ;
>             }
>             return false ;
>         }
>     }
>
>
>     /**
>      * Acquires the read lock if the write lock is not held by
>      * another thread within the given waiting time.
>      *
>      * <p> Acquires the read lock if the write lock is not held by
>      * another thread and returns immediately with the value
>      * {@code true}.
>      *
>      * <p> If the write lock is held by another thread then the
>      * current thread yields execution until one of two things happens:
>      * <ul>
>      * <li> The read lock is acquired by the current thread; or
>      * <li> The specified waiting time elapses.
>      * </ul>
>      *
>      * <p> If the read lock is acquired then the value {@code true} is
>      * returned.
>      *
>      * @param nanosTimeout the time to wait for the read lock in
> nanoseconds
>      * @return {@code true} if the read lock was acquired
>      */
>     public boolean sharedTryLockNanos( long nanosTimeout) {
>         final long lastTime = System.nanoTime ();
>         ReadersEntry localEntry = entry.get();
>         // Initialize a new Reader-state for this thread if needed
>         if (localEntry == null) {
>             localEntry = addState();
>         }
>
>         // Already locked in read-mode, this is a reentrant lock so just
>         // increase the count and return.
>         if (localEntry.reentrantReaderCount > 0) {
>             localEntry. reentrantReaderCount ++;
>             return true ;
>         }
>
>         final AtomicInteger currentReadersState = localEntry. state;
>
>         while (true ) {
>             currentReadersState.set( SRWL_STATE_READING );
>             if (writerOwner .get() == SRWL_INVALID_TID) {
>                 // Acquired lock in read-only mode
>                 localEntry. reentrantReaderCount = 1;
>                 return true ;
>             } else {
>                 // Go back to SRWL_STATE_NOT_READING to avoid blocking a
> Writer
>                 // and then check if this is a downgrade.
>                 currentReadersState.set( SRWL_STATE_NOT_READING );
>                 if (writerOwner .get() == Thread.currentThread ().getId())
> {
>                     // Looks like it's the current thread that is holding
> the
>                     // write-lock. It's safe to go ahead and acquire the
> read-lock
>                     currentReadersState.set( SRWL_STATE_READING );
>                     localEntry. reentrantReaderCount = 1;
>                     return true ;
>                 }
>                 if (nanosTimeout <= 0) return false;
>             }
>
>             if (System.nanoTime()-lastTime < nanosTimeout) {
>                 Thread. yield();
>             } else {
>                 return false ;
>             }
>         }
>     }
>
>
>     /**
>      * Acquires the write lock only if it is not held by another thread
>      * at the time of invocation.
>      *
>      * <p> Acquires the write lock if the write lock is not
>      * held by another thread and returns immediately with
>      * the value {@code true} if and only if no other thread is attempting
> a
>      * read lock, setting the write lock {@code writerLoop}
>      * count to one. If another thread is attempting a read lock, this
>      * function <b> may yield until the read lock is released </b>.
>      *
>      * <p> If the current thread already holds this lock then the
>      * {@code reentrantWriterCount} count is incremented by one and the
> method returns
>      * {@code true}.
>      *
>      * <p> If the write lock is held by another thread then this method
>      * will return immediately with the value {@code false}.
>      *
>      * @return {@code true} if the write lock was free and was acquired
>      * by the current thread, or the write lock was already held
>      * by the current thread; and {@code false} otherwise.
>      */
>     public boolean exclusiveTryLock() {
>         final long tid_self = Thread.currentThread ().getId();
>
>         if (writerOwner .get() == tid_self) {
>            // Already locked in write-mode, just increase the count and
> return
>             reentrantWriterCount ++;
>            return true ;
>         }
>
>         // Try to acquire the lock in write-mode
>         if (!writerOwner .compareAndSet( SRWL_INVALID_TID, tid_self))
>             return false ;
>
>         // Write-Lock was acquired, now wait for any running Readers to
> finish
>         Iterator<AtomicInteger> iter = readersStateList .iterator();
>         AtomicInteger mynext = null ;
>         while (iter.hasNext()) {
>             try {
>                 mynext = iter.next();
>             } catch (NoSuchElementException e) {
>                 break ;
>             }
>             while (mynext.get() == SRWL_STATE_READING) Thread. yield();
>         }
>
>         reentrantWriterCount = 1;
>         return true ;
>     }
>
>
>     /**
>      * Acquires the write lock if it is not held by another thread
>      * within the given waiting time.
>      *
>      * <p> Acquires the write lock if the write lock is not
>      * held by another thread and returns immediately with
>      * the value {@code true} if and only if no other thread is attempting
> a
>      * read lock, setting the write lock {@code reentrantWriterCount}
>      * to one. If another thread is attempting a read lock, this
>      * function <b> may yield until the read lock is released </b>.
>      *
>      * <p> If the current thread already holds this lock then the
>      * {@code reentrantWriterCount} is incremented by one and the method
> returns
>      * {@code true}.
>      *
>      * <p> If the write lock is held by another thread then the current
>      * thread yields and lies dormant until one of two things happens:
>      * <ul>
>      * <li> The write lock is acquired by the current thread; or
>      * <li> The specified waiting time elapses
>      * </ul>
>      *
>      * <p> If the read lock is held by another thread then the current
>      * thread yields and lies dormant until the read lock is released.
>      *
>      * <p> If the write lock is acquired then the value {@code true} is
>      * returned and the write lock {@code reentrantWriterCount} is set to
> one.
>      *
>      * <p> There is no guarantee that there is a maximum waiting time for
>      * this method.
>      *
>      * @param nanosTimeout the time to wait for the write lock in
> nanoseconds
>      *
>      * @return {@code true} if the lock was free and was acquired
>      * by the current thread, or the write lock was already held by the
>      * current thread; and {@code false} if the waiting time
>      * elapsed before the lock could be acquired.
>      */
>     public boolean exclusiveTryLockNanos( long nanosTimeout) {
>         final long lastTime = System.nanoTime ();
>         final long tid_self = Thread.currentThread ().getId();
>
>         if (writerOwner .get() == tid_self) {
>            // Already locked in write-mode, just increase the count and
> return
>             reentrantWriterCount ++;
>            return true ;
>         }
>
>         // Try to acquire the lock in write-mode
>         while (!writerOwner .compareAndSet( SRWL_INVALID_TID, tid_self)) {
>             if (System.nanoTime()-lastTime < nanosTimeout) {
>                 Thread. yield();
>             } else {
>                 return false ;
>             }
>         }
>
>         // Write-Lock was acquired, now wait for any running Readers to
> finish
>         Iterator<AtomicInteger> iter = readersStateList .iterator();
>         AtomicInteger mynext = null ;
>         while (iter.hasNext()) {
>             try {
>                 mynext = iter.next();
>             } catch (NoSuchElementException e) {
>                 break ;
>             }
>             while (mynext.get() == SRWL_STATE_READING) Thread. yield();
>         }
>
>         reentrantWriterCount = 1;
>         return true ;
>     }
>
> }
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130324/d5027a0f/attachment-0001.html>

From henri.tremblay at gmail.com  Sun Mar 24 17:18:50 2013
From: henri.tremblay at gmail.com (Henri Tremblay)
Date: Sun, 24 Mar 2013 22:18:50 +0100
Subject: [concurrency-interest] About Unsafe
In-Reply-To: <5137A6F7.3050300@oracle.com>
References: <CADZL2=sgQOdWs+pmF1zS1dptE7QNTtzJLstEgaFYAvLG9ORTJA@mail.gmail.com>
	<5137A6F7.3050300@oracle.com>
Message-ID: <CADZL2=tKOBX9zU42=FuT5HxHp+H0DPzXXLHScv22n0n5xbPVoA@mail.gmail.com>

Hi,

I was waiting for the frame war to begin but it never happened.

So here's what I deduce from your two answers:

   - A lot of methods from Unsafe are already available somewhere in the
   standard API even though they might have some overhead added
   - Work on JSR166 makes sure most methods are implemented in every JVMs

So, based on your feedback, there's no much needs to have an abstraction
layer to provided a cross JVM implementation since it's pretty much the
case already.

To make myself clear, what I'm trying to know if in every high performance
framework Iook into there will be code looking like this:
if(javaVersion.equals("Hotspot 1.2.3.4")return
HotSpot1234WrapperOverUnsafeThatWorksForThatVersion();
if(javaVersion.equals("IBM 5.6.7")return
IBM5.6.7WrapperOverUnsafeThatWorksForThatVersion();
etc...

Why is the case for Objenesis instantiator. It makes sure it works on every
VMs so that every framework using Objenesis doesn't have to do it itself.

Regards,
Henri


On 6 March 2013 21:28, Aleksey Shipilev <aleksey.shipilev at oracle.com> wrote:

> Ugh.
>
> On 03/06/2013 11:56 PM, Henri Tremblay wrote:
> >   * Do you think it could be useful?
>
> Nope. IMHO, the consensus for far is that Unsafe is not the library
> class; it is the doorway into JVM hell. The libraries should securely
> bridge the gap between JVM hell, developers, and users. And most of the
> methods in Unsafe are really the trampolines used by other public
> classes in the (non-)standard API.
>
> >   * How is Unsafe supported on other JVMs apart from Hotspot?
>
> By magic?
>
> This seems to be completely library-driven. For JSR166, which is used in
> many projects, including those which you can't legally (and technically)
> call Java, reliance on stable Unsafe interface is the utmost need, so
> Doug et al. are trying to arrange the coordinated update behind the
> scenes every once in a while.
>
> >   * Which methods would be the most useful?
>
> All of them?
>
> In all seriousness, you can see how much push-back we had recently with
> trying to get something as constrained as Fences into the public API.
> For every potentially unsecure method in Unsafe, multiply that by a few
> orders of magnitude.
>
> -Aleksey
>
> ------------ ANOTHER FLAME WAR THREAD BEGINS HERE ------------
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130324/c77749a0/attachment.html>

From dl at cs.oswego.edu  Sun Mar 24 17:42:43 2013
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 24 Mar 2013 17:42:43 -0400
Subject: [concurrency-interest] A Scalable and Fast Read-Write Lock
In-Reply-To: <514F41D6.4080504@javaspecialists.eu>
References: <CAAApjO1iPUtt1r2frfCwiUeMYGH59_Xh7P56v+pyB4s5RY-fFQ@mail.gmail.com>
	<514F41D6.4080504@javaspecialists.eu>
Message-ID: <514F7353.8060204@cs.oswego.edu>

On 03/24/13 14:11, Dr Heinz M. Kabutz wrote:

> did you do some comparisons against the excellent new StampedLock?
>

I had urged Pedro to post this because it hits a different
set of usages. The short version is: StampedLock scales mainly
by supporting optimistic reads, their ScalableReentrantRWLock
by isolating per-thread-bookkeeping. If you cannot rework
code to use optimistic reads, and don't mind a possibly
large per-lock footprint (presumably because you have few
of them), then it is likely to be a good choice. Some of
us have discussed on and off whether to introduce an RWLock
of this form, but hadn't done it out as a releasable component,
so it is good to see it available for people to try.

I haven't looked at its fairness/starvation properties,
but you might try doing so with some of your test programs.

-Doug


From martinrb at google.com  Sun Mar 24 20:37:48 2013
From: martinrb at google.com (Martin Buchholz)
Date: Sun, 24 Mar 2013 17:37:48 -0700
Subject: [concurrency-interest] About Unsafe
In-Reply-To: <CADZL2=tKOBX9zU42=FuT5HxHp+H0DPzXXLHScv22n0n5xbPVoA@mail.gmail.com>
References: <CADZL2=sgQOdWs+pmF1zS1dptE7QNTtzJLstEgaFYAvLG9ORTJA@mail.gmail.com>
	<5137A6F7.3050300@oracle.com>
	<CADZL2=tKOBX9zU42=FuT5HxHp+H0DPzXXLHScv22n0n5xbPVoA@mail.gmail.com>
Message-ID: <CA+kOe0-_kmBTd4yWt4+3ZD_hxZWZEGR1xht=3AZnbsKwxc9PvA@mail.gmail.com>

On Sun, Mar 24, 2013 at 2:18 PM, Henri Tremblay <henri.tremblay at gmail.com>wrote:

>
> To make myself clear, what I'm trying to know if in every high performance
> framework Iook into there will be code looking like this:
> if(javaVersion.equals("Hotspot 1.2.3.4")return
> HotSpot1234WrapperOverUnsafeThatWorksForThatVersion();
> if(javaVersion.equals("IBM 5.6.7")return
> IBM5.6.7WrapperOverUnsafeThatWorksForThatVersion();
> etc...
>
>
It's more like everyone has funky static constructor code that obtains an
Unsafe (and if extra careful perhaps checks it reflectively for existence
of needed methods), and falls back to a slower implementation if Unsafe is
not supported or the security manager understandably objects.  E.g.

https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/primitives/UnsignedBytes.java
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130324/664556c3/attachment.html>

From nathan.reynolds at oracle.com  Mon Mar 25 15:41:12 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 25 Mar 2013 12:41:12 -0700
Subject: [concurrency-interest] ByteBuffer vs byte[] and reading from a
 socket
In-Reply-To: <CAEJX8oqg-3SOv2PJi+1kOQXa+tvcVkuOjXOPSnEQ6mQ0CQd4hg@mail.gmail.com>
References: <1364061157384-9337.post@n7.nabble.com>
	<CAEJX8oqg-3SOv2PJi+1kOQXa+tvcVkuOjXOPSnEQ6mQ0CQd4hg@mail.gmail.com>
Message-ID: <5150A858.4060802@oracle.com>

JRockit is capable of pinning the HeapByteBuffer (i.e. byte[]) on the 
heap and using it for I/O. HotSpot can't and has to copy the byte[] into 
a DirectByteBuffer before doing the I/O.  This copy time adds latency as 
well as degrading cache performance (i.e. 2 copies of the data in the 
cache).  Zero-copy I/O is ideal.  This is where the data is written to a 
buffer 1 time and never copied again as the buffer makes its way down 
the stack, into the kernel and on to the network.

The context switching also lowers cache performance because each I/O 
requires a context switch.  Non-blocking I/O allows for a small number 
of threads to saturate the network with very little context switching.  
If the CPU is maxed out, then the context switches are going to hurt 
performance.

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 3/23/2013 12:02 PM, Stanimir Simeonoff wrote:
> This is really not the place but to put it simply: ByteBuffers are 
> quite different if they are direct or heap based. Heap-based are not 
> that different than read(byte[]) but the direct ones need not to 
> reside in java's heap and are unmanaged. byte[] is read via either 
> dynamic malloc-copy-free for larger byte[] or stack_alloc-copy for 
> smaller. The copy phase is always present. Copying may need to lock 
> the java byte[] on the heap, etc.Of course, it you run of of L2 cache 
> the difference would be noticeable.
>
> The main difference is blocking/non-blocking though as blocking IO 
> needs separate thread(s) and you are at the mercy of the OS scheduler 
> if you have a lot of threads. The latter may hurt the latency for some 
> clients although the overall throughput may not differ greatly.
>
> Stanimir
>
> On Sat, Mar 23, 2013 at 7:52 PM, thurstonn 
> <thurston at nomagicsoftware.com <mailto:thurston at nomagicsoftware.com>> 
> wrote:
>
>     I apologize if this is off-list, but I know that there are people
>     on this
>     list who have a deep understanding of CPUs, caches, etc. (which
>     may or may
>     not be relevant)
>
>     I'm curious as to the performance differential between doing the
>     following:
>          Socket.read(byte[])
>          SocketChannel.read(ByteBuffer)
>
>     Here, I'm not talking about blocking vs non-blocking, i.e.
>     presume there are bytes in the socket's receive buffer ready to be
>     read.
>
>     To me, it seems like it's just an issue of copying some bytes from
>     kernel-space to user-space.
>     Is SocketChannel.read() really faster?  Why?
>
>     And this is really naive I know, but assuming SocketChannel.read *is*
>     faster, is it by orders of magnitude, marginal, ... ?
>
>
>
>
>     --
>     View this message in context:
>     http://jsr166-concurrency.10961.n7.nabble.com/ByteBuffer-vs-byte-and-reading-from-a-socket-tp9337.html
>     Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130325/b1dd1df4/attachment.html>

From hallorant at gmail.com  Wed Mar 27 16:48:50 2013
From: hallorant at gmail.com (Tim Halloran)
Date: Wed, 27 Mar 2013 16:48:50 -0400
Subject: [concurrency-interest] "One shot" delayed call using
 ScheduledExecutorService -- is there a better way?
Message-ID: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>

I need to run a call after a delay. I'm currently using

  void startIn(long delay, TimeUnit unit) {
    final ScheduledExecutorService ex = Executors.newScheduledThreadPool(1);
    ex.schedule(new WrappedRunnable(new Runnable() {
      public void run() {
        start();
        ex.shutdown();
      }
    }), delay, unit);
  }

This is part of the TimingFramework project, and the class start() is
being invoked upon is thread-safe, i.e., I don't care what the thread
context is. WrappedRunnable just helps log exceptions if something
goes wrong with my start() call.

Can this be done better? I'm limited to Java 6 and it has to work on
Android as well.

The use of startIn() is very rare in practice so keeping the executor
around seems like a bad approach to me.  The delays are most likely,
for this call in TimingFramework, significant - half a second or more.

I'm also interested if calling shutdown() in the Runnable can cause me
any grief, I'm guessing this is okay.

As always, thanks!

Tim

From nathan.reynolds at oracle.com  Wed Mar 27 17:08:47 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Wed, 27 Mar 2013 14:08:47 -0700
Subject: [concurrency-interest] "One shot" delayed call using
 ScheduledExecutorService -- is there a better way?
In-Reply-To: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>
References: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>
Message-ID: <51535FDF.70908@oracle.com>

Why not keep a "new ScheduledThreadPoolExecutor(0)" in a static final 
field?  If the threads idle long enough (i.e. setKeepAliveTime), then 
they will exit and free their resources.  If startIn() is called 
frequently enough, then the thread sticks around and saves CPU time.  If 
you don't want the thread to stick around, you could call 
setKeepAliveTime(0) or perhaps setKeepAliveTime(1, TimeUnit.NANOSECONDS).

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 3/27/2013 1:48 PM, Tim Halloran wrote:
> I need to run a call after a delay. I'm currently using
>
>    void startIn(long delay, TimeUnit unit) {
>      final ScheduledExecutorService ex = Executors.newScheduledThreadPool(1);
>      ex.schedule(new WrappedRunnable(new Runnable() {
>        public void run() {
>          start();
>          ex.shutdown();
>        }
>      }), delay, unit);
>    }
>
> This is part of the TimingFramework project, and the class start() is
> being invoked upon is thread-safe, i.e., I don't care what the thread
> context is. WrappedRunnable just helps log exceptions if something
> goes wrong with my start() call.
>
> Can this be done better? I'm limited to Java 6 and it has to work on
> Android as well.
>
> The use of startIn() is very rare in practice so keeping the executor
> around seems like a bad approach to me.  The delays are most likely,
> for this call in TimingFramework, significant - half a second or more.
>
> I'm also interested if calling shutdown() in the Runnable can cause me
> any grief, I'm guessing this is okay.
>
> As always, thanks!
>
> Tim
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130327/a5fc7c29/attachment.html>

From nathan.reynolds at oracle.com  Wed Mar 27 21:49:16 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Wed, 27 Mar 2013 18:49:16 -0700
Subject: [concurrency-interest] "One shot" delayed call using
 ScheduledExecutorService -- is there a better way?
In-Reply-To: <51535FDF.70908@oracle.com>
References: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>
	<51535FDF.70908@oracle.com>
Message-ID: <5153A19C.90906@oracle.com>

Another problem is that the original code could create a lot of 
short-lived threads.  After a thread terminates, HotSpot won't clean up 
the call stack until a full GC.  On a 32-bit process, if enough threads 
start and terminate, then the virtual address space will be completely 
consumed.  Other native allocations will fail.  New threads can't be 
created.  If the system doesn't have 4 GB of RAM, it will thrash.  I 
have run into this problem several times including on 2 different Java 
IDEs (e.g. Eclipse).

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 3/27/2013 2:08 PM, Nathan Reynolds wrote:
> Why not keep a "new ScheduledThreadPoolExecutor(0)" in a static final 
> field?  If the threads idle long enough (i.e. setKeepAliveTime), then 
> they will exit and free their resources.  If startIn() is called 
> frequently enough, then the thread sticks around and saves CPU time.  
> If you don't want the thread to stick around, you could call 
> setKeepAliveTime(0) or perhaps setKeepAliveTime(1, TimeUnit.NANOSECONDS).
>
> Nathan Reynolds 
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
> Architect | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
> On 3/27/2013 1:48 PM, Tim Halloran wrote:
>> I need to run a call after a delay. I'm currently using
>>
>>    void startIn(long delay, TimeUnit unit) {
>>      final ScheduledExecutorService ex = Executors.newScheduledThreadPool(1);
>>      ex.schedule(new WrappedRunnable(new Runnable() {
>>        public void run() {
>>          start();
>>          ex.shutdown();
>>        }
>>      }), delay, unit);
>>    }
>>
>> This is part of the TimingFramework project, and the class start() is
>> being invoked upon is thread-safe, i.e., I don't care what the thread
>> context is. WrappedRunnable just helps log exceptions if something
>> goes wrong with my start() call.
>>
>> Can this be done better? I'm limited to Java 6 and it has to work on
>> Android as well.
>>
>> The use of startIn() is very rare in practice so keeping the executor
>> around seems like a bad approach to me.  The delays are most likely,
>> for this call in TimingFramework, significant - half a second or more.
>>
>> I'm also interested if calling shutdown() in the Runnable can cause me
>> any grief, I'm guessing this is okay.
>>
>> As always, thanks!
>>
>> Tim
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130327/e48e5829/attachment.html>

From gregg at cytetech.com  Thu Mar 28 09:48:14 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Thu, 28 Mar 2013 08:48:14 -0500
Subject: [concurrency-interest] "One shot" delayed call using
 ScheduledExecutorService -- is there a better way?
In-Reply-To: <5153A19C.90906@oracle.com>
References: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>
	<51535FDF.70908@oracle.com> <5153A19C.90906@oracle.com>
Message-ID: <51544A1E.800@cytetech.com>

If hotspot finds itself in this position, why would it not go clean up the 
threads as a relief mechanism?  With multi-core systems, I am still not sure I 
understand why we don't have a JVM that monitors the processor and I/O use, 
through the OS, and try to be much more eager about cleaning up.  Practically, 
is there really, ever any resource "saved" by deferring this cleanup?  Wouldn't 
it be much more realistic to operate with a dependable overhead reflected by the 
JVM, instead of trying to not reveal the overhead of the JVM until it becomes so 
huge as to make the application misbehave compared to the observable normal 
behavior?

Gregg Wonderly

On 3/27/2013 8:49 PM, Nathan Reynolds wrote:
> Another problem is that the original code could create a lot of short-lived
> threads.  After a thread terminates, HotSpot won't clean up the call stack until
> a full GC.  On a 32-bit process, if enough threads start and terminate, then the
> virtual address space will be completely consumed.  Other native allocations
> will fail.  New threads can't be created.  If the system doesn't have 4 GB of
> RAM, it will thrash.  I have run into this problem several times including on 2
> different Java IDEs (e.g. Eclipse).
>
> Nathan Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
> Architect | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
> On 3/27/2013 2:08 PM, Nathan Reynolds wrote:
>> Why not keep a "new ScheduledThreadPoolExecutor(0)" in a static final field?
>> If the threads idle long enough (i.e. setKeepAliveTime), then they will exit
>> and free their resources.  If startIn() is called frequently enough, then the
>> thread sticks around and saves CPU time.  If you don't want the thread to
>> stick around, you could call setKeepAliveTime(0) or perhaps
>> setKeepAliveTime(1, TimeUnit.NANOSECONDS).
>>
>> Nathan Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>> | Architect | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>> On 3/27/2013 1:48 PM, Tim Halloran wrote:
>>> I need to run a call after a delay. I'm currently using
>>>
>>>    void startIn(long delay, TimeUnit unit) {
>>>      final ScheduledExecutorService ex = Executors.newScheduledThreadPool(1);
>>>      ex.schedule(new WrappedRunnable(new Runnable() {
>>>        public void run() {
>>>          start();
>>>          ex.shutdown();
>>>        }
>>>      }), delay, unit);
>>>    }
>>>
>>> This is part of the TimingFramework project, and the class start() is
>>> being invoked upon is thread-safe, i.e., I don't care what the thread
>>> context is. WrappedRunnable just helps log exceptions if something
>>> goes wrong with my start() call.
>>>
>>> Can this be done better? I'm limited to Java 6 and it has to work on
>>> Android as well.
>>>
>>> The use of startIn() is very rare in practice so keeping the executor
>>> around seems like a bad approach to me.  The delays are most likely,
>>> for this call in TimingFramework, significant - half a second or more.
>>>
>>> I'm also interested if calling shutdown() in the Runnable can cause me
>>> any grief, I'm guessing this is okay.
>>>
>>> As always, thanks!
>>>
>>> Tim
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From kirk at kodewerk.com  Thu Mar 28 09:58:39 2013
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Thu, 28 Mar 2013 14:58:39 +0100
Subject: [concurrency-interest] "One shot" delayed call using
	ScheduledExecutorService -- is there a better way?
In-Reply-To: <51544A1E.800@cytetech.com>
References: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>
	<51535FDF.70908@oracle.com> <5153A19C.90906@oracle.com>
	<51544A1E.800@cytetech.com>
Message-ID: <54EC8175-30E3-49EC-92F8-955D6F035557@kodewerk.com>

Hi Nathan,

Do you mean a Full GC or is a collection of tenured (CMS) good enough?

Regards,
Kirk

> On 3/27/2013 8:49 PM, Nathan Reynolds wrote:
>> Another problem is that the original code could create a lot of short-lived
>> threads.  After a thread terminates, HotSpot won't clean up the call stack until
>> a full GC.  On a 32-bit process, if enough threads start and terminate, then the
>> virtual address space will be completely consumed.  Other native allocations
>> will fail.  New threads can't be created.  If the system doesn't have 4 GB of
>> RAM, it will thrash.  I have run into this problem several times including on 2
>> different Java IDEs (e.g. Eclipse).
>> 
>> Nathan Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>> Architect | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>> On 3/27/2013 2:08 PM, Nathan Reynolds wrote:
>>> Why not keep a "new ScheduledThreadPoolExecutor(0)" in a static final field?
>>> If the threads idle long enough (i.e. setKeepAliveTime), then they will exit
>>> and free their resources.  If startIn() is called frequently enough, then the
>>> thread sticks around and saves CPU time.  If you don't want the thread to
>>> stick around, you could call setKeepAliveTime(0) or perhaps
>>> setKeepAliveTime(1, TimeUnit.NANOSECONDS).
>>> 
>>> Nathan Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>>> | Architect | 602.333.9091
>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>> On 3/27/2013 1:48 PM, Tim Halloran wrote:
>>>> I need to run a call after a delay. I'm currently using
>>>> 
>>>>   void startIn(long delay, TimeUnit unit) {
>>>>     final ScheduledExecutorService ex = Executors.newScheduledThreadPool(1);
>>>>     ex.schedule(new WrappedRunnable(new Runnable() {
>>>>       public void run() {
>>>>         start();
>>>>         ex.shutdown();
>>>>       }
>>>>     }), delay, unit);
>>>>   }
>>>> 
>>>> This is part of the TimingFramework project, and the class start() is
>>>> being invoked upon is thread-safe, i.e., I don't care what the thread
>>>> context is. WrappedRunnable just helps log exceptions if something
>>>> goes wrong with my start() call.
>>>> 
>>>> Can this be done better? I'm limited to Java 6 and it has to work on
>>>> Android as well.
>>>> 
>>>> The use of startIn() is very rare in practice so keeping the executor
>>>> around seems like a bad approach to me.  The delays are most likely,
>>>> for this call in TimingFramework, significant - half a second or more.
>>>> 
>>>> I'm also interested if calling shutdown() in the Runnable can cause me
>>>> any grief, I'm guessing this is okay.
>>>> 
>>>> As always, thanks!
>>>> 
>>>> Tim
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> 
>>>> 
>>> 
>> 
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From robert.j.saulnier at gmail.com  Thu Mar 28 10:10:32 2013
From: robert.j.saulnier at gmail.com (Robert J. Saulnier)
Date: Thu, 28 Mar 2013 11:10:32 -0300
Subject: [concurrency-interest] "One shot" delayed call using
 ScheduledExecutorService -- is there a better way?
In-Reply-To: <51544A1E.800@cytetech.com>
References: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>
	<51535FDF.70908@oracle.com> <5153A19C.90906@oracle.com>
	<51544A1E.800@cytetech.com>
Message-ID: <CAJ8S3ux+2WGyN29SXHqmv2Ayz1M5Nx3xLm1ChP5rYQS9sptOcQ@mail.gmail.com>

You can just shutdown the executor after scheduling the runnable:

ScheduledExecutorService ex = Executors.newScheduledThreadPool(1);
ex.schedule(...);
ex.shutdown();

>From the ExecutorService Javadocs:


void shutdown()

Initiates an orderly shutdown in which previously submitted tasks are
executed, but no new tasks will be accepted.



On Thu, Mar 28, 2013 at 10:48 AM, Gregg Wonderly <gregg at cytetech.com> wrote:

> If hotspot finds itself in this position, why would it not go clean up the
> threads as a relief mechanism?  With multi-core systems, I am still not
> sure I understand why we don't have a JVM that monitors the processor and
> I/O use, through the OS, and try to be much more eager about cleaning up.
>  Practically, is there really, ever any resource "saved" by deferring this
> cleanup?  Wouldn't it be much more realistic to operate with a dependable
> overhead reflected by the JVM, instead of trying to not reveal the overhead
> of the JVM until it becomes so huge as to make the application misbehave
> compared to the observable normal behavior?
>
> Gregg Wonderly
>
>
> On 3/27/2013 8:49 PM, Nathan Reynolds wrote:
>
>> Another problem is that the original code could create a lot of
>> short-lived
>> threads.  After a thread terminates, HotSpot won't clean up the call
>> stack until
>> a full GC.  On a 32-bit process, if enough threads start and terminate,
>> then the
>> virtual address space will be completely consumed.  Other native
>> allocations
>> will fail.  New threads can't be created.  If the system doesn't have 4
>> GB of
>> RAM, it will thrash.  I have run into this problem several times
>> including on 2
>> different Java IDEs (e.g. Eclipse).
>>
>> Nathan Reynolds <http://psr.us.oracle.com/**wiki/index.php/User:Nathan_**
>> Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>>
>> |
>> Architect | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>
>> On 3/27/2013 2:08 PM, Nathan Reynolds wrote:
>>
>>> Why not keep a "new ScheduledThreadPoolExecutor(0)**" in a static final
>>> field?
>>> If the threads idle long enough (i.e. setKeepAliveTime), then they will
>>> exit
>>> and free their resources.  If startIn() is called frequently enough,
>>> then the
>>> thread sticks around and saves CPU time.  If you don't want the thread to
>>> stick around, you could call setKeepAliveTime(0) or perhaps
>>> setKeepAliveTime(1, TimeUnit.NANOSECONDS).
>>>
>>> Nathan Reynolds <http://psr.us.oracle.com/**wiki/index.php/User:Nathan_*
>>> *Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>>> >
>>> | Architect | 602.333.9091
>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>
>>> On 3/27/2013 1:48 PM, Tim Halloran wrote:
>>>
>>>> I need to run a call after a delay. I'm currently using
>>>>
>>>>    void startIn(long delay, TimeUnit unit) {
>>>>      final ScheduledExecutorService ex = Executors.**
>>>> newScheduledThreadPool(1);
>>>>      ex.schedule(new WrappedRunnable(new Runnable() {
>>>>        public void run() {
>>>>          start();
>>>>          ex.shutdown();
>>>>        }
>>>>      }), delay, unit);
>>>>    }
>>>>
>>>> This is part of the TimingFramework project, and the class start() is
>>>> being invoked upon is thread-safe, i.e., I don't care what the thread
>>>> context is. WrappedRunnable just helps log exceptions if something
>>>> goes wrong with my start() call.
>>>>
>>>> Can this be done better? I'm limited to Java 6 and it has to work on
>>>> Android as well.
>>>>
>>>> The use of startIn() is very rare in practice so keeping the executor
>>>> around seems like a bad approach to me.  The delays are most likely,
>>>> for this call in TimingFramework, significant - half a second or more.
>>>>
>>>> I'm also interested if calling shutdown() in the Runnable can cause me
>>>> any grief, I'm guessing this is okay.
>>>>
>>>> As always, thanks!
>>>>
>>>> Tim
>>>> ______________________________**_________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>
>>>>
>>>>
>>>
>>
>>
>> ______________________________**_________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130328/19156498/attachment.html>

From oleksandr.otenko at oracle.com  Thu Mar 28 10:59:21 2013
From: oleksandr.otenko at oracle.com (oleksandr otenko)
Date: Thu, 28 Mar 2013 14:59:21 +0000
Subject: [concurrency-interest] "One shot" delayed call using
 ScheduledExecutorService -- is there a better way?
In-Reply-To: <51544A1E.800@cytetech.com>
References: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>
	<51535FDF.70908@oracle.com> <5153A19C.90906@oracle.com>
	<51544A1E.800@cytetech.com>
Message-ID: <51545AC9.5060900@oracle.com>

Throughput of clean up doesn't depend on timing. Distribution of 
response times does depend on timing.

Eg 99% of request execute in 2ms, 1% of requests execute in 100ms; vs 
100% of requests executing in 3ms.

Alex

On 28/03/2013 13:48, Gregg Wonderly wrote:
> If hotspot finds itself in this position, why would it not go clean up 
> the threads as a relief mechanism?  With multi-core systems, I am 
> still not sure I understand why we don't have a JVM that monitors the 
> processor and I/O use, through the OS, and try to be much more eager 
> about cleaning up.  Practically, is there really, ever any resource 
> "saved" by deferring this cleanup?  Wouldn't it be much more realistic 
> to operate with a dependable overhead reflected by the JVM, instead of 
> trying to not reveal the overhead of the JVM until it becomes so huge 
> as to make the application misbehave compared to the observable normal 
> behavior?
>
> Gregg Wonderly
>
> On 3/27/2013 8:49 PM, Nathan Reynolds wrote:
>> Another problem is that the original code could create a lot of 
>> short-lived
>> threads.  After a thread terminates, HotSpot won't clean up the call 
>> stack until
>> a full GC.  On a 32-bit process, if enough threads start and 
>> terminate, then the
>> virtual address space will be completely consumed.  Other native 
>> allocations
>> will fail.  New threads can't be created.  If the system doesn't have 
>> 4 GB of
>> RAM, it will thrash.  I have run into this problem several times 
>> including on 2
>> different Java IDEs (e.g. Eclipse).
>>
>> Nathan Reynolds 
>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>> Architect | 602.333.9091
>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>> On 3/27/2013 2:08 PM, Nathan Reynolds wrote:
>>> Why not keep a "new ScheduledThreadPoolExecutor(0)" in a static 
>>> final field?
>>> If the threads idle long enough (i.e. setKeepAliveTime), then they 
>>> will exit
>>> and free their resources.  If startIn() is called frequently enough, 
>>> then the
>>> thread sticks around and saves CPU time.  If you don't want the 
>>> thread to
>>> stick around, you could call setKeepAliveTime(0) or perhaps
>>> setKeepAliveTime(1, TimeUnit.NANOSECONDS).
>>>
>>> Nathan Reynolds 
>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>>> | Architect | 602.333.9091
>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>> On 3/27/2013 1:48 PM, Tim Halloran wrote:
>>>> I need to run a call after a delay. I'm currently using
>>>>
>>>>    void startIn(long delay, TimeUnit unit) {
>>>>      final ScheduledExecutorService ex = 
>>>> Executors.newScheduledThreadPool(1);
>>>>      ex.schedule(new WrappedRunnable(new Runnable() {
>>>>        public void run() {
>>>>          start();
>>>>          ex.shutdown();
>>>>        }
>>>>      }), delay, unit);
>>>>    }
>>>>
>>>> This is part of the TimingFramework project, and the class start() is
>>>> being invoked upon is thread-safe, i.e., I don't care what the thread
>>>> context is. WrappedRunnable just helps log exceptions if something
>>>> goes wrong with my start() call.
>>>>
>>>> Can this be done better? I'm limited to Java 6 and it has to work on
>>>> Android as well.
>>>>
>>>> The use of startIn() is very rare in practice so keeping the executor
>>>> around seems like a bad approach to me.  The delays are most likely,
>>>> for this call in TimingFramework, significant - half a second or more.
>>>>
>>>> I'm also interested if calling shutdown() in the Runnable can cause me
>>>> any grief, I'm guessing this is okay.
>>>>
>>>> As always, thanks!
>>>>
>>>> Tim
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From nathan.reynolds at oracle.com  Thu Mar 28 14:18:58 2013
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Thu, 28 Mar 2013 11:18:58 -0700
Subject: [concurrency-interest] "One shot" delayed call using
 ScheduledExecutorService -- is there a better way?
In-Reply-To: <54EC8175-30E3-49EC-92F8-955D6F035557@kodewerk.com>
References: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>
	<51535FDF.70908@oracle.com> <5153A19C.90906@oracle.com>
	<51544A1E.800@cytetech.com>
	<54EC8175-30E3-49EC-92F8-955D6F035557@kodewerk.com>
Message-ID: <51548992.9050709@oracle.com>

I never took time to figure this out until now.  Apparently, I made some 
bad conclusions from some observations.  Sorry about the confusion.

Thread stacks most likely don't need to be cleaned up by full GC in 
HotSpot.  The OS most likely cleans them up when the thread dies.  I 
haven't proven those previous statements, but that is what I am choosing 
to believe now.  The problem is that Eclipse IDE is launching a thread 
every time a thread is created or terminates in the debuggee.  The 
Eclipse thread blocks and doesn't exit.  The thread's call stack is 
going to consume virtual address space, of course.

The program below reproduces the problem when debugged with 32-bit 
Eclipse IDE on 64-bit Windows 7.  The program never outputs anything.  
Both Eclipse IDE and the program stop using the CPU.

Eclipse IDE has 1901 threads running.  It's virtual address space is 
completely used up (i.e all 4 GB used).  The debugged program is no 
where near maxed out on its address space.

I used SysInternal's VM Map to inspect the address space.  It calls out 
1901 call stacks with an associated thread ID which consume 1 MB of 
virtual address space.  It calls out another 1901 call stacks which say 
"64-bit thread stack" which consume 256 KB of virtual address space.  
Before I really dug into the problem, I assumed this meant the thread 
had exited and HotSpot didn't clean up the call stack yet.  Now that I 
see there is a 1:1 ratio between call stacks with thread ID and call 
stacks without an ID, I am wondering if the two are tied to each other.  
If so, why consume so much space for both?  Why not put them together?

I took a thread dump of Eclipse.  1870 threads have the following call 
stack.  Some thing is definitely wrong with Eclipse JDT debugger.  These 
threads don't exit after several minutes.  These threads might exist 
because the debuggee's thread terminated instead of created.  I say that 
because the 3^(r)^(d) frame says "ThreadDeathHandler".  I will need an 
Eclipse expert to look at it. I will file a bug against Eclipse.

     at java.lang.Thread.sleep(Native Method)
     at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:925)
     at 
org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget$ThreadDeathHandler.handleEvent(JDIDebugTarget.java:2051)
     at 
org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:152)
     at 
org.eclipse.jdt.internal.debug.core.EventDispatcher.access$0(EventDispatcher.java:100)
     at 
org.eclipse.jdt.internal.debug.core.EventDispatcher$1.run(EventDispatcher.java:249)
     at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

I used a BTrace script to dump the call stack when Thread.start() is 
called.  1896 threads were created with the following call stack. 
Unfortunately, that isn't very helpful... to me.

org.eclipse.core.internal.jobs.WorkerPool.jobQueued(WorkerPool.java:148)
org.eclipse.core.internal.jobs.WorkerPool.startJob(WorkerPool.java:244)
    org.eclipse.core.internal.jobs.Worker.run(Worker.java:50)

*Program*

public class ThreadLauncher
{
    public static void main(String[] args)
    {
       Thread thread;
       int i;

       i = 0;

       try
       {
          for ( ; true; i++)
          {
             thread = new Thread();

             thread.setDaemon(false);
             thread.setName("Thread " + i);
             thread.setPriority(Thread.MIN_PRIORITY);
             thread.start();
          }
       }
       catch (Throwable t)
       {
          System.out.println("Failed to create thread #" + i);
          System.out.flush();
          t.printStackTrace();
          System.err.flush();
       }
    }
}


Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Architect | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
On 3/28/2013 6:58 AM, Kirk Pepperdine wrote:
> Hi Nathan,
>
> Do you mean a Full GC or is a collection of tenured (CMS) good enough?
>
> Regards,
> Kirk
>
>> On 3/27/2013 8:49 PM, Nathan Reynolds wrote:
>>> Another problem is that the original code could create a lot of short-lived
>>> threads.  After a thread terminates, HotSpot won't clean up the call stack until
>>> a full GC.  On a 32-bit process, if enough threads start and terminate, then the
>>> virtual address space will be completely consumed.  Other native allocations
>>> will fail.  New threads can't be created.  If the system doesn't have 4 GB of
>>> RAM, it will thrash.  I have run into this problem several times including on 2
>>> different Java IDEs (e.g. Eclipse).
>>>
>>> Nathan Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>> Architect | 602.333.9091
>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>> On 3/27/2013 2:08 PM, Nathan Reynolds wrote:
>>>> Why not keep a "new ScheduledThreadPoolExecutor(0)" in a static final field?
>>>> If the threads idle long enough (i.e. setKeepAliveTime), then they will exit
>>>> and free their resources.  If startIn() is called frequently enough, then the
>>>> thread sticks around and saves CPU time.  If you don't want the thread to
>>>> stick around, you could call setKeepAliveTime(0) or perhaps
>>>> setKeepAliveTime(1, TimeUnit.NANOSECONDS).
>>>>
>>>> Nathan Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>>>> | Architect | 602.333.9091
>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>> On 3/27/2013 1:48 PM, Tim Halloran wrote:
>>>>> I need to run a call after a delay. I'm currently using
>>>>>
>>>>>    void startIn(long delay, TimeUnit unit) {
>>>>>      final ScheduledExecutorService ex = Executors.newScheduledThreadPool(1);
>>>>>      ex.schedule(new WrappedRunnable(new Runnable() {
>>>>>        public void run() {
>>>>>          start();
>>>>>          ex.shutdown();
>>>>>        }
>>>>>      }), delay, unit);
>>>>>    }
>>>>>
>>>>> This is part of the TimingFramework project, and the class start() is
>>>>> being invoked upon is thread-safe, i.e., I don't care what the thread
>>>>> context is. WrappedRunnable just helps log exceptions if something
>>>>> goes wrong with my start() call.
>>>>>
>>>>> Can this be done better? I'm limited to Java 6 and it has to work on
>>>>> Android as well.
>>>>>
>>>>> The use of startIn() is very rare in practice so keeping the executor
>>>>> around seems like a bad approach to me.  The delays are most likely,
>>>>> for this call in TimingFramework, significant - half a second or more.
>>>>>
>>>>> I'm also interested if calling shutdown() in the Runnable can cause me
>>>>> any grief, I'm guessing this is okay.
>>>>>
>>>>> As always, thanks!
>>>>>
>>>>> Tim
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130328/9c5c51c2/attachment.html>

From gregg at cytetech.com  Thu Mar 28 14:48:05 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Thu, 28 Mar 2013 13:48:05 -0500
Subject: [concurrency-interest] "One shot" delayed call using
 ScheduledExecutorService -- is there a better way?
In-Reply-To: <51545AC9.5060900@oracle.com>
References: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>
	<51535FDF.70908@oracle.com> <5153A19C.90906@oracle.com>
	<51544A1E.800@cytetech.com> <51545AC9.5060900@oracle.com>
Message-ID: <51549065.6090008@cytetech.com>

So you are saying that if the computer system is idle 99% of the time, then we 
can expect great performance, but if we load the computer to the point of taking 
advantage of the CPU resources that we have at hand, that we can then expect the 
application to fail completely with an OOME?

Gregg Wonderly

On 3/28/2013 9:59 AM, oleksandr otenko wrote:
> Throughput of clean up doesn't depend on timing. Distribution of response times
> does depend on timing.
>
> Eg 99% of request execute in 2ms, 1% of requests execute in 100ms; vs 100% of
> requests executing in 3ms.
>
> Alex
>
> On 28/03/2013 13:48, Gregg Wonderly wrote:
>> If hotspot finds itself in this position, why would it not go clean up the
>> threads as a relief mechanism?  With multi-core systems, I am still not sure I
>> understand why we don't have a JVM that monitors the processor and I/O use,
>> through the OS, and try to be much more eager about cleaning up.  Practically,
>> is there really, ever any resource "saved" by deferring this cleanup?
>> Wouldn't it be much more realistic to operate with a dependable overhead
>> reflected by the JVM, instead of trying to not reveal the overhead of the JVM
>> until it becomes so huge as to make the application misbehave compared to the
>> observable normal behavior?
>>
>> Gregg Wonderly
>>
>> On 3/27/2013 8:49 PM, Nathan Reynolds wrote:
>>> Another problem is that the original code could create a lot of short-lived
>>> threads.  After a thread terminates, HotSpot won't clean up the call stack until
>>> a full GC.  On a 32-bit process, if enough threads start and terminate, then the
>>> virtual address space will be completely consumed.  Other native allocations
>>> will fail.  New threads can't be created.  If the system doesn't have 4 GB of
>>> RAM, it will thrash.  I have run into this problem several times including on 2
>>> different Java IDEs (e.g. Eclipse).
>>>
>>> Nathan Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>> Architect | 602.333.9091
>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>> On 3/27/2013 2:08 PM, Nathan Reynolds wrote:
>>>> Why not keep a "new ScheduledThreadPoolExecutor(0)" in a static final field?
>>>> If the threads idle long enough (i.e. setKeepAliveTime), then they will exit
>>>> and free their resources.  If startIn() is called frequently enough, then the
>>>> thread sticks around and saves CPU time.  If you don't want the thread to
>>>> stick around, you could call setKeepAliveTime(0) or perhaps
>>>> setKeepAliveTime(1, TimeUnit.NANOSECONDS).
>>>>
>>>> Nathan Reynolds <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>>>> | Architect | 602.333.9091
>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>> On 3/27/2013 1:48 PM, Tim Halloran wrote:
>>>>> I need to run a call after a delay. I'm currently using
>>>>>
>>>>>    void startIn(long delay, TimeUnit unit) {
>>>>>      final ScheduledExecutorService ex = Executors.newScheduledThreadPool(1);
>>>>>      ex.schedule(new WrappedRunnable(new Runnable() {
>>>>>        public void run() {
>>>>>          start();
>>>>>          ex.shutdown();
>>>>>        }
>>>>>      }), delay, unit);
>>>>>    }
>>>>>
>>>>> This is part of the TimingFramework project, and the class start() is
>>>>> being invoked upon is thread-safe, i.e., I don't care what the thread
>>>>> context is. WrappedRunnable just helps log exceptions if something
>>>>> goes wrong with my start() call.
>>>>>
>>>>> Can this be done better? I'm limited to Java 6 and it has to work on
>>>>> Android as well.
>>>>>
>>>>> The use of startIn() is very rare in practice so keeping the executor
>>>>> around seems like a bad approach to me.  The delays are most likely,
>>>>> for this call in TimingFramework, significant - half a second or more.
>>>>>
>>>>> I'm also interested if calling shutdown() in the Runnable can cause me
>>>>> any grief, I'm guessing this is okay.
>>>>>
>>>>> As always, thanks!
>>>>>
>>>>> Tim
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From oleksandr.otenko at oracle.com  Thu Mar 28 14:56:20 2013
From: oleksandr.otenko at oracle.com (oleksandr otenko)
Date: Thu, 28 Mar 2013 18:56:20 +0000
Subject: [concurrency-interest] "One shot" delayed call using
 ScheduledExecutorService -- is there a better way?
In-Reply-To: <51548992.9050709@oracle.com>
References: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>
	<51535FDF.70908@oracle.com> <5153A19C.90906@oracle.com>
	<51544A1E.800@cytetech.com>
	<54EC8175-30E3-49EC-92F8-955D6F035557@kodewerk.com>
	<51548992.9050709@oracle.com>
Message-ID: <51549254.1010509@oracle.com>

The problem of cleaning up the threads is JVM-specific.

Short-lived threads do cause full GCs in other JVMs, because reusing the 
"OS" threads is tricky and not every JVM does it.

Alex

On 28/03/2013 18:18, Nathan Reynolds wrote:
> I never took time to figure this out until now.  Apparently, I made 
> some bad conclusions from some observations.  Sorry about the confusion.
>
> Thread stacks most likely don't need to be cleaned up by full GC in 
> HotSpot.  The OS most likely cleans them up when the thread dies.  I 
> haven't proven those previous statements, but that is what I am 
> choosing to believe now.  The problem is that Eclipse IDE is launching 
> a thread every time a thread is created or terminates in the 
> debuggee.  The Eclipse thread blocks and doesn't exit.  The thread's 
> call stack is going to consume virtual address space, of course.
>
> The program below reproduces the problem when debugged with 32-bit 
> Eclipse IDE on 64-bit Windows 7.  The program never outputs anything.  
> Both Eclipse IDE and the program stop using the CPU.
>
> Eclipse IDE has 1901 threads running.  It's virtual address space is 
> completely used up (i.e all 4 GB used).  The debugged program is no 
> where near maxed out on its address space.
>
> I used SysInternal's VM Map to inspect the address space.  It calls 
> out 1901 call stacks with an associated thread ID which consume 1 MB 
> of virtual address space.  It calls out another 1901 call stacks which 
> say "64-bit thread stack" which consume 256 KB of virtual address 
> space.  Before I really dug into the problem, I assumed this meant the 
> thread had exited and HotSpot didn't clean up the call stack yet.  Now 
> that I see there is a 1:1 ratio between call stacks with thread ID and 
> call stacks without an ID, I am wondering if the two are tied to each 
> other.  If so, why consume so much space for both?  Why not put them 
> together?
>
> I took a thread dump of Eclipse.  1870 threads have the following call 
> stack.  Some thing is definitely wrong with Eclipse JDT debugger.  
> These threads don't exit after several minutes.  These threads might 
> exist because the debuggee's thread terminated instead of created.  I 
> say that because the 3^(r)^(d) frame says "ThreadDeathHandler".  I 
> will need an Eclipse expert to look at it.  I will file a bug against 
> Eclipse.
>
>     at java.lang.Thread.sleep(Native Method)
>     at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:925)
>     at 
> org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget$ThreadDeathHandler.handleEvent(JDIDebugTarget.java:2051)
>     at 
> org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:152)
>     at 
> org.eclipse.jdt.internal.debug.core.EventDispatcher.access$0(EventDispatcher.java:100)
>     at 
> org.eclipse.jdt.internal.debug.core.EventDispatcher$1.run(EventDispatcher.java:249)
>     at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
>
> I used a BTrace script to dump the call stack when Thread.start() is 
> called.  1896 threads were created with the following call stack.  
> Unfortunately, that isn't very helpful... to me.
>
> org.eclipse.core.internal.jobs.WorkerPool.jobQueued(WorkerPool.java:148)
> org.eclipse.core.internal.jobs.WorkerPool.startJob(WorkerPool.java:244)
>    org.eclipse.core.internal.jobs.Worker.run(Worker.java:50)
>
> *Program*
>
> public class ThreadLauncher
> {
>    public static void main(String[] args)
>    {
>       Thread thread;
>       int i;
>
>       i = 0;
>
>       try
>       {
>          for ( ; true; i++)
>          {
>             thread = new Thread();
>
>             thread.setDaemon(false);
>             thread.setName("Thread " + i);
>             thread.setPriority(Thread.MIN_PRIORITY);
>             thread.start();
>          }
>       }
>       catch (Throwable t)
>       {
>          System.out.println("Failed to create thread #" + i);
>          System.out.flush();
>          t.printStackTrace();
>          System.err.flush();
>       }
>    }
> }
>
>
> Nathan Reynolds 
> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
> Architect | 602.333.9091
> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
> On 3/28/2013 6:58 AM, Kirk Pepperdine wrote:
>> Hi Nathan,
>>
>> Do you mean a Full GC or is a collection of tenured (CMS) good enough?
>>
>> Regards,
>> Kirk
>>
>>> On 3/27/2013 8:49 PM, Nathan Reynolds wrote:
>>>> Another problem is that the original code could create a lot of short-lived
>>>> threads.  After a thread terminates, HotSpot won't clean up the call stack until
>>>> a full GC.  On a 32-bit process, if enough threads start and terminate, then the
>>>> virtual address space will be completely consumed.  Other native allocations
>>>> will fail.  New threads can't be created.  If the system doesn't have 4 GB of
>>>> RAM, it will thrash.  I have run into this problem several times including on 2
>>>> different Java IDEs (e.g. Eclipse).
>>>>
>>>> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>  |
>>>> Architect | 602.333.9091
>>>> Oracle PSR Engineering<http://psr.us.oracle.com/>  | Server Technology
>>>> On 3/27/2013 2:08 PM, Nathan Reynolds wrote:
>>>>> Why not keep a "new ScheduledThreadPoolExecutor(0)" in a static final field?
>>>>> If the threads idle long enough (i.e. setKeepAliveTime), then they will exit
>>>>> and free their resources.  If startIn() is called frequently enough, then the
>>>>> thread sticks around and saves CPU time.  If you don't want the thread to
>>>>> stick around, you could call setKeepAliveTime(0) or perhaps
>>>>> setKeepAliveTime(1, TimeUnit.NANOSECONDS).
>>>>>
>>>>> Nathan Reynolds<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>>>>> | Architect | 602.333.9091
>>>>> Oracle PSR Engineering<http://psr.us.oracle.com/>  | Server Technology
>>>>> On 3/27/2013 1:48 PM, Tim Halloran wrote:
>>>>>> I need to run a call after a delay. I'm currently using
>>>>>>
>>>>>>    void startIn(long delay, TimeUnit unit) {
>>>>>>      final ScheduledExecutorService ex = Executors.newScheduledThreadPool(1);
>>>>>>      ex.schedule(new WrappedRunnable(new Runnable() {
>>>>>>        public void run() {
>>>>>>          start();
>>>>>>          ex.shutdown();
>>>>>>        }
>>>>>>      }), delay, unit);
>>>>>>    }
>>>>>>
>>>>>> This is part of the TimingFramework project, and the class start() is
>>>>>> being invoked upon is thread-safe, i.e., I don't care what the thread
>>>>>> context is. WrappedRunnable just helps log exceptions if something
>>>>>> goes wrong with my start() call.
>>>>>>
>>>>>> Can this be done better? I'm limited to Java 6 and it has to work on
>>>>>> Android as well.
>>>>>>
>>>>>> The use of startIn() is very rare in practice so keeping the executor
>>>>>> around seems like a bad approach to me.  The delays are most likely,
>>>>>> for this call in TimingFramework, significant - half a second or more.
>>>>>>
>>>>>> I'm also interested if calling shutdown() in the Runnable can cause me
>>>>>> any grief, I'm guessing this is okay.
>>>>>>
>>>>>> As always, thanks!
>>>>>>
>>>>>> Tim
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130328/b40f3352/attachment-0001.html>

From oleksandr.otenko at oracle.com  Thu Mar 28 15:03:23 2013
From: oleksandr.otenko at oracle.com (oleksandr otenko)
Date: Thu, 28 Mar 2013 19:03:23 +0000
Subject: [concurrency-interest] "One shot" delayed call using
 ScheduledExecutorService -- is there a better way?
In-Reply-To: <51549065.6090008@cytetech.com>
References: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>
	<51535FDF.70908@oracle.com> <5153A19C.90906@oracle.com>
	<51544A1E.800@cytetech.com> <51545AC9.5060900@oracle.com>
	<51549065.6090008@cytetech.com>
Message-ID: <515493FB.8040400@oracle.com>

I didn't say that.

This is basic queuing theory stuff. It is always better to execute 
short-running tasks first, then long-running tasks. The amount of time 
spent is the same, but the average wait time is lower than with uniform 
distribution of time between all tasks / fair time sharing / GC ASAP.

Alex

On 28/03/2013 18:48, Gregg Wonderly wrote:
> So you are saying that if the computer system is idle 99% of the time, 
> then we can expect great performance, but if we load the computer to 
> the point of taking advantage of the CPU resources that we have at 
> hand, that we can then expect the application to fail completely with 
> an OOME?
>
> Gregg Wonderly
>
> On 3/28/2013 9:59 AM, oleksandr otenko wrote:
>> Throughput of clean up doesn't depend on timing. Distribution of 
>> response times
>> does depend on timing.
>>
>> Eg 99% of request execute in 2ms, 1% of requests execute in 100ms; vs 
>> 100% of
>> requests executing in 3ms.
>>
>> Alex
>>
>> On 28/03/2013 13:48, Gregg Wonderly wrote:
>>> If hotspot finds itself in this position, why would it not go clean 
>>> up the
>>> threads as a relief mechanism?  With multi-core systems, I am still 
>>> not sure I
>>> understand why we don't have a JVM that monitors the processor and 
>>> I/O use,
>>> through the OS, and try to be much more eager about cleaning up.  
>>> Practically,
>>> is there really, ever any resource "saved" by deferring this cleanup?
>>> Wouldn't it be much more realistic to operate with a dependable 
>>> overhead
>>> reflected by the JVM, instead of trying to not reveal the overhead 
>>> of the JVM
>>> until it becomes so huge as to make the application misbehave 
>>> compared to the
>>> observable normal behavior?
>>>
>>> Gregg Wonderly
>>>
>>> On 3/27/2013 8:49 PM, Nathan Reynolds wrote:
>>>> Another problem is that the original code could create a lot of 
>>>> short-lived
>>>> threads.  After a thread terminates, HotSpot won't clean up the 
>>>> call stack until
>>>> a full GC.  On a 32-bit process, if enough threads start and 
>>>> terminate, then the
>>>> virtual address space will be completely consumed.  Other native 
>>>> allocations
>>>> will fail.  New threads can't be created.  If the system doesn't 
>>>> have 4 GB of
>>>> RAM, it will thrash.  I have run into this problem several times 
>>>> including on 2
>>>> different Java IDEs (e.g. Eclipse).
>>>>
>>>> Nathan Reynolds 
>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>> Architect | 602.333.9091
>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>> On 3/27/2013 2:08 PM, Nathan Reynolds wrote:
>>>>> Why not keep a "new ScheduledThreadPoolExecutor(0)" in a static 
>>>>> final field?
>>>>> If the threads idle long enough (i.e. setKeepAliveTime), then they 
>>>>> will exit
>>>>> and free their resources.  If startIn() is called frequently 
>>>>> enough, then the
>>>>> thread sticks around and saves CPU time.  If you don't want the 
>>>>> thread to
>>>>> stick around, you could call setKeepAliveTime(0) or perhaps
>>>>> setKeepAliveTime(1, TimeUnit.NANOSECONDS).
>>>>>
>>>>> Nathan Reynolds 
>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>>>>> | Architect | 602.333.9091
>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server 
>>>>> Technology
>>>>> On 3/27/2013 1:48 PM, Tim Halloran wrote:
>>>>>> I need to run a call after a delay. I'm currently using
>>>>>>
>>>>>>    void startIn(long delay, TimeUnit unit) {
>>>>>>      final ScheduledExecutorService ex = 
>>>>>> Executors.newScheduledThreadPool(1);
>>>>>>      ex.schedule(new WrappedRunnable(new Runnable() {
>>>>>>        public void run() {
>>>>>>          start();
>>>>>>          ex.shutdown();
>>>>>>        }
>>>>>>      }), delay, unit);
>>>>>>    }
>>>>>>
>>>>>> This is part of the TimingFramework project, and the class 
>>>>>> start() is
>>>>>> being invoked upon is thread-safe, i.e., I don't care what the 
>>>>>> thread
>>>>>> context is. WrappedRunnable just helps log exceptions if something
>>>>>> goes wrong with my start() call.
>>>>>>
>>>>>> Can this be done better? I'm limited to Java 6 and it has to work on
>>>>>> Android as well.
>>>>>>
>>>>>> The use of startIn() is very rare in practice so keeping the 
>>>>>> executor
>>>>>> around seems like a bad approach to me.  The delays are most likely,
>>>>>> for this call in TimingFramework, significant - half a second or 
>>>>>> more.
>>>>>>
>>>>>> I'm also interested if calling shutdown() in the Runnable can 
>>>>>> cause me
>>>>>> any grief, I'm guessing this is okay.
>>>>>>
>>>>>> As always, thanks!
>>>>>>
>>>>>> Tim
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>


From gregg at cytetech.com  Thu Mar 28 16:31:36 2013
From: gregg at cytetech.com (Gregg Wonderly)
Date: Thu, 28 Mar 2013 15:31:36 -0500
Subject: [concurrency-interest] "One shot" delayed call using
 ScheduledExecutorService -- is there a better way?
In-Reply-To: <515493FB.8040400@oracle.com>
References: <CAMyLHFyJFU6qboSi8MDhJ=kxETumfCtmRf9tCS=F0b9CS=3w+A@mail.gmail.com>
	<51535FDF.70908@oracle.com> <5153A19C.90906@oracle.com>
	<51544A1E.800@cytetech.com> <51545AC9.5060900@oracle.com>
	<51549065.6090008@cytetech.com> <515493FB.8040400@oracle.com>
Message-ID: <5154A8A8.1050705@cytetech.com>

Queuing theory is a great way to work through many problems.  But, it's not 
always best to defer longer running work, because it frees short running work to 
create more work.  I think in this case, because these are non-virtual 
resources, that cleaning them up immediately makes more sense, then deferring 
them, hoping you can do it later with less impact on the work load that exists 
at that time.

Average wait time is important for interactive systems, but not for server systems.

Back in the mid 1980's, while at college, I designed and wrote (in fortran), a 
detached VMS process which managed scheduling above the OS, because VMS was so 
brain dead.  I raised the system base priority for new interactive processes 
from 4 to 5, and then used a long term observation base algorithm, to let 
interactive processes have at most, 10 seconds of runtime at priority 5.  I then 
set them down to 4, and if they ran up more than 30 seconds there, they went 
down to 3.  After more than a minute, they went to 2.

The batch queues ran at priority 2. The issue was, that people would sit down at 
a terminal, and start an interactive session to run a program that would need 
hours of CPU time.  One person would do this at 4 different terminals, expecting 
that he'd get 4 times the performance.

So, in this case, I made the system (VAX-750) have amazing interactive 
performance which let people read email, compose documents and do all kinds of 
things quick and easy.  If you wanted to do something that ran longer, you had 
to wait.  You can look for "SCHED" in old usenet archives and maybe decus tapes. 
I haven't been able to find it in quite some time though.

So, I understand your point about queuing theory and displacing longer running 
tasks into the future.

When we had single CPU machines that costs 10's of thousands of dollars, and 
could not be easily expanded had had limited resources (6MB of RAM on the 750), 
all kinds of things were interesting to use queuing theory on.

Now days, I need to know when to upgrade, and what kind of scaling I can expect 
out of software.  I really don't care to find out "later" what I could of know 
now about the scalability of an application.

I write a lot of different kinds of applications.  But the ones I care the most 
about are highly threaded CPU processes where I need more real-time scheduling 
behavior than convenient queuing and delay, which just makes the load "suddenly" 
appear when the magic line is crossed.

Gregg Wonderly

On 3/28/2013 2:03 PM, oleksandr otenko wrote:
> I didn't say that.
>
> This is basic queuing theory stuff. It is always better to execute short-running
> tasks first, then long-running tasks. The amount of time spent is the same, but
> the average wait time is lower than with uniform distribution of time between
> all tasks / fair time sharing / GC ASAP.
>
> Alex
>
> On 28/03/2013 18:48, Gregg Wonderly wrote:
>> So you are saying that if the computer system is idle 99% of the time, then we
>> can expect great performance, but if we load the computer to the point of
>> taking advantage of the CPU resources that we have at hand, that we can then
>> expect the application to fail completely with an OOME?
>>
>> Gregg Wonderly
>>
>> On 3/28/2013 9:59 AM, oleksandr otenko wrote:
>>> Throughput of clean up doesn't depend on timing. Distribution of response times
>>> does depend on timing.
>>>
>>> Eg 99% of request execute in 2ms, 1% of requests execute in 100ms; vs 100% of
>>> requests executing in 3ms.
>>>
>>> Alex
>>>
>>> On 28/03/2013 13:48, Gregg Wonderly wrote:
>>>> If hotspot finds itself in this position, why would it not go clean up the
>>>> threads as a relief mechanism?  With multi-core systems, I am still not sure I
>>>> understand why we don't have a JVM that monitors the processor and I/O use,
>>>> through the OS, and try to be much more eager about cleaning up. Practically,
>>>> is there really, ever any resource "saved" by deferring this cleanup?
>>>> Wouldn't it be much more realistic to operate with a dependable overhead
>>>> reflected by the JVM, instead of trying to not reveal the overhead of the JVM
>>>> until it becomes so huge as to make the application misbehave compared to the
>>>> observable normal behavior?
>>>>
>>>> Gregg Wonderly
>>>>
>>>> On 3/27/2013 8:49 PM, Nathan Reynolds wrote:
>>>>> Another problem is that the original code could create a lot of short-lived
>>>>> threads.  After a thread terminates, HotSpot won't clean up the call stack
>>>>> until
>>>>> a full GC.  On a 32-bit process, if enough threads start and terminate,
>>>>> then the
>>>>> virtual address space will be completely consumed.  Other native allocations
>>>>> will fail.  New threads can't be created.  If the system doesn't have 4 GB of
>>>>> RAM, it will thrash.  I have run into this problem several times including
>>>>> on 2
>>>>> different Java IDEs (e.g. Eclipse).
>>>>>
>>>>> Nathan Reynolds
>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> |
>>>>> Architect | 602.333.9091
>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>>> On 3/27/2013 2:08 PM, Nathan Reynolds wrote:
>>>>>> Why not keep a "new ScheduledThreadPoolExecutor(0)" in a static final field?
>>>>>> If the threads idle long enough (i.e. setKeepAliveTime), then they will exit
>>>>>> and free their resources.  If startIn() is called frequently enough, then the
>>>>>> thread sticks around and saves CPU time.  If you don't want the thread to
>>>>>> stick around, you could call setKeepAliveTime(0) or perhaps
>>>>>> setKeepAliveTime(1, TimeUnit.NANOSECONDS).
>>>>>>
>>>>>> Nathan Reynolds
>>>>>> <http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds>
>>>>>> | Architect | 602.333.9091
>>>>>> Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology
>>>>>> On 3/27/2013 1:48 PM, Tim Halloran wrote:
>>>>>>> I need to run a call after a delay. I'm currently using
>>>>>>>
>>>>>>>    void startIn(long delay, TimeUnit unit) {
>>>>>>>      final ScheduledExecutorService ex =
>>>>>>> Executors.newScheduledThreadPool(1);
>>>>>>>      ex.schedule(new WrappedRunnable(new Runnable() {
>>>>>>>        public void run() {
>>>>>>>          start();
>>>>>>>          ex.shutdown();
>>>>>>>        }
>>>>>>>      }), delay, unit);
>>>>>>>    }
>>>>>>>
>>>>>>> This is part of the TimingFramework project, and the class start() is
>>>>>>> being invoked upon is thread-safe, i.e., I don't care what the thread
>>>>>>> context is. WrappedRunnable just helps log exceptions if something
>>>>>>> goes wrong with my start() call.
>>>>>>>
>>>>>>> Can this be done better? I'm limited to Java 6 and it has to work on
>>>>>>> Android as well.
>>>>>>>
>>>>>>> The use of startIn() is very rare in practice so keeping the executor
>>>>>>> around seems like a bad approach to me.  The delays are most likely,
>>>>>>> for this call in TimingFramework, significant - half a second or more.
>>>>>>>
>>>>>>> I'm also interested if calling shutdown() in the Runnable can cause me
>>>>>>> any grief, I'm guessing this is okay.
>>>>>>>
>>>>>>> As always, thanks!
>>>>>>>
>>>>>>> Tim
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From vipinarav at gmail.com  Sat Mar 30 11:59:52 2013
From: vipinarav at gmail.com (Vipin Aravind)
Date: Sat, 30 Mar 2013 21:29:52 +0530
Subject: [concurrency-interest] CancellableTask and CancellingExecutor
Message-ID: <CAJnwaPFZCsxvuZcdqEkcNSbspEURGhZcHTBvkXo_6UVXbO6Exw@mail.gmail.com>

We use the SocketUsingTask in java concurrency in practice(Listing 7.12)[
http://jcip.net.s3-website-us-east-1.amazonaws.com/listings/SocketUsingTask.java
] in our production code. I had enhanced the code for our purposes. We have
to run many tasks which make use of blocking socket calls. I enhanced the
CancellingExecutor so that we can track the tasks that are currently run by
cancellingexecutor and when bringing down the system, we could call the
CancellingExecutor?s shutdown which will then loop over  the task list and
call ?cancel? on them. This code has been in production for an year, but I
had like to get the opinion of experts and if there is a
better/nice/cleaner way of doing this.

Here is the modified CancellingExecutor:-

*class* CancellingExecutor *extends* ThreadPoolExecutor {

      *private* *final* List<Object> list;

    *public* CancellingExecutor(*int* corePoolSize, *int* maximumPoolSize, *
long* keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {


        *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
workQueue);

        list = Collections.*synchronizedList*(*new*
ArrayList<Object>(maximumPoolSize));

    }



    *public* CancellingExecutor(*int* corePoolSize, *int* maximumPoolSize, *
long* keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue,
ThreadFactory threadFactory) {

        *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
workQueue, threadFactory);

        list = Collections.*synchronizedList*(*new*
ArrayList<Object>(maximumPoolSize));

    }



    *public* CancellingExecutor(*int* corePoolSize, *int* maximumPoolSize, *
long* keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue,
RejectedExecutionHandler handler) {

        *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
workQueue, handler);

        list = Collections.*synchronizedList*(*new*
ArrayList<Object>(maximumPoolSize));

    }



    *public* CancellingExecutor(*int* corePoolSize, *int* maximumPoolSize, *
long* keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue,
ThreadFactory threadFactory, RejectedExecutionHandler handler) {

        *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
workQueue, threadFactory, handler);

       list = Collections.*synchronizedList*(*new*
ArrayList<Object>(maximumPoolSize));

    }



    *public* *static* ExecutorService newFixedThreadPool(*int* nThreads) {

        *return* *new* CancellingExecutor(nThreads, nThreads,

                                      0L, TimeUnit.*MILLISECONDS*,

                                      *new*
LinkedBlockingQueue<Runnable>());

    }

    *protected* *void* beforeExecute(Thread t, Runnable  r)

    {

      *super*.beforeExecute(t, r);

    }

    /*

     * Remove the  task  from  the  list if  it  was  added in  newTaskFor

     */

    *protected* *void* afterExecute(Runnable r, Throwable t)

    {

      *super*.afterExecute(r, t);

      *synchronized*(list){

            *if*(list.remove(r))

                  Log.*d*("SocketTask", "Connection Count:" + Integer.*
toString*(list.size()));

            }

    }

    /*

     * newTask  hook.

     * 1) If  it  is a  *cancellable*  task  add  to  the list.

     */

    *protected* <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {

            *if* (callable *instanceof* CancellableTask) {

                  RunnableFuture<T> future = ((CancellableTask<T>) callable)

                              .newTask();

                  *synchronized* (list) {

                        list.add(future);

                        Log.*d*("SocketTask", "Connection Count:" + Integer.
*toString*(list.size()));

                  }

                  *return* future;

            } *else*

                  *return* *super*.newTaskFor(callable);

      }

    /*

     * cancels all  the future tasks. We  need  to  come  out of  blocking
socket I/O calls

     * Interrupt  based  blocking  calls  will  also  come out.

     * Also shutdown any threads which  we  didn't  account  for  in  the
list(this  should  never  happen)

     * I have noticed  this  function  being  called  by a
FinalizerDameon(garbage collection??)

It  appears  harmless  for  now. one  could override  the

     * finalize  to  get  around  this, but  I  leave  it as  is  as  it
appears  harmless.

     */

    *public* *void* shutdown()

    {

      Log.*d*("SocketTask", "Start shutting down all connections");// +
Thread.currentThread().getName() + " "+ this.hashCode());

      *synchronized*(list){

      *for*(*int*  i = 0; i < list.size(); i++)

            *((RunnableFuture<Object>)**list**.get(i))*.cancel(*true*);

      }



      shutdownNow();

      /*

       * Wait  for  no  more  than  5 seconds  for  all  the worker
threads  to  be  done.

       * the  cancel  in  transport driver will  trigger a  disconnect in
peer  connection inn AppDriver

       */

      *try* {

                  awaitTermination(5, TimeUnit.*SECONDS*);

            } *catch* (InterruptedException e) {

            }

      Log.*d*("SocketTask", "Done shutting down all connections");

    }

}
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130330/83c5ba42/attachment-0001.html>

From stanimir at riflexo.com  Sat Mar 30 16:25:27 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Sat, 30 Mar 2013 22:25:27 +0200
Subject: [concurrency-interest] CancellableTask and CancellingExecutor
In-Reply-To: <CAJnwaPFZCsxvuZcdqEkcNSbspEURGhZcHTBvkXo_6UVXbO6Exw@mail.gmail.com>
References: <CAJnwaPFZCsxvuZcdqEkcNSbspEURGhZcHTBvkXo_6UVXbO6Exw@mail.gmail.com>
Message-ID: <CAEJX8oprk8t=hoLFUqzyKny=BQMAgo1-a-fa-2qxkn6xKfRBzA@mail.gmail.com>

I am not sure why you need the list. TPE.getQueue() does almost exactly the
same for the tasks that have not been scheduled already. The ones being
executed would be notified w/ shutdownNow the just same as cancel(true),
i.e. invoking thread.interrupt().
More also accessing logging via global lock usually is a big no. You can
always log after the synchronized{} block.

I merely do not see any benefits of CancellingExecutor compared to the
vanilla TPE.

Stanimir


On Sat, Mar 30, 2013 at 5:59 PM, Vipin Aravind <vipinarav at gmail.com> wrote:

> We use the SocketUsingTask in java concurrency in practice(Listing 7.12)[
> http://jcip.net.s3-website-us-east-1.amazonaws.com/listings/SocketUsingTask.java
> ] in our production code. I had enhanced the code for our purposes. We
> have to run many tasks which make use of blocking socket calls. I enhanced
> the CancellingExecutor so that we can track the tasks that are currently
> run by cancellingexecutor and when bringing down the system, we could call
> the CancellingExecutor?s shutdown which will then loop over  the task list
> and call ?cancel? on them. This code has been in production for an year,
> but I had like to get the opinion of experts and if there is a
> better/nice/cleaner way of doing this.
>
> Here is the modified CancellingExecutor:-
>
> *class* CancellingExecutor *extends* ThreadPoolExecutor {
>
>       *private* *final* List<Object> list;
>
>     *public* CancellingExecutor(*int* corePoolSize, *int* maximumPoolSize,
>  *long* keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)
> {
>
>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
> workQueue);
>
>         list = Collections.*synchronizedList*(*new*
> ArrayList<Object>(maximumPoolSize));
>
>     }
>
>
>
>     *public* CancellingExecutor(*int* corePoolSize, *int* maximumPoolSize,
>  *long* keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue,
> ThreadFactory threadFactory) {
>
>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
> workQueue, threadFactory);
>
>         list = Collections.*synchronizedList*(*new*
> ArrayList<Object>(maximumPoolSize));
>
>     }
>
>
>
>     *public* CancellingExecutor(*int* corePoolSize, *int* maximumPoolSize,
>  *long* keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue,
> RejectedExecutionHandler handler) {
>
>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
> workQueue, handler);
>
>         list = Collections.*synchronizedList*(*new*
> ArrayList<Object>(maximumPoolSize));
>
>     }
>
>
>
>     *public* CancellingExecutor(*int* corePoolSize, *int* maximumPoolSize,
>  *long* keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue,
> ThreadFactory threadFactory, RejectedExecutionHandler handler) {
>
>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
> workQueue, threadFactory, handler);
>
>        list = Collections.*synchronizedList*(*new*
> ArrayList<Object>(maximumPoolSize));
>
>     }
>
>
>
>     *public* *static* ExecutorService newFixedThreadPool(*int* nThreads) {
>
>         *return* *new* CancellingExecutor(nThreads, nThreads,
>
>                                       0L, TimeUnit.*MILLISECONDS*,
>
>                                       *new*
> LinkedBlockingQueue<Runnable>());
>
>     }
>
>     *protected* *void* beforeExecute(Thread t, Runnable  r)
>
>     {
>
>       *super*.beforeExecute(t, r);
>
>     }
>
>     /*
>
>      * Remove the  task  from  the  list if  it  was  added in  newTaskFor
>
>      */
>
>     *protected* *void* afterExecute(Runnable r, Throwable t)
>
>     {
>
>       *super*.afterExecute(r, t);
>
>       *synchronized*(list){
>
>             *if*(list.remove(r))
>
>                   Log.*d*("SocketTask", "Connection Count:" + Integer.*
> toString*(list.size()));
>
>             }
>
>     }
>
>     /*
>
>      * newTask  hook.
>
>      * 1) If  it  is a  *cancellable*  task  add  to  the list.
>
>      */
>
>     *protected* <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
>
>             *if* (callable *instanceof* CancellableTask) {
>
>                   RunnableFuture<T> future = ((CancellableTask<T>)
> callable)
>
>                               .newTask();
>
>                   *synchronized* (list) {
>
>                         list.add(future);
>
>                         Log.*d*("SocketTask", "Connection Count:" +
> Integer.*toString*(list.size()));
>
>                   }
>
>                   *return* future;
>
>             } *else*
>
>                   *return* *super*.newTaskFor(callable);
>
>       }
>
>     /*
>
>      * cancels all  the future tasks. We  need  to  come  out of  blocking
> socket I/O calls
>
>      * Interrupt  based  blocking  calls  will  also  come out.
>
>      * Also shutdown any threads which  we  didn't  account  for  in  the
> list(this  should  never  happen)
>
>      * I have noticed  this  function  being  called  by a
> FinalizerDameon(garbage collection??)
>
> It  appears  harmless  for  now. one  could override  the
>
>      * finalize  to  get  around  this, but  I  leave  it as  is  as  it
> appears  harmless.
>
>      */
>
>     *public* *void* shutdown()
>
>     {
>
>       Log.*d*("SocketTask", "Start shutting down all connections");// +
> Thread.currentThread().getName() + " "+ this.hashCode());
>
>       *synchronized*(list){
>
>       *for*(*int*  i = 0; i < list.size(); i++)
>
>             *((RunnableFuture<Object>)**list**.get(i))*.cancel(*true*);
>
>       }
>
>
>
>       shutdownNow();
>
>       /*
>
>        * Wait  for  no  more  than  5 seconds  for  all  the worker
> threads  to  be  done.
>
>        * the  cancel  in  transport driver will  trigger a  disconnect in
> peer  connection inn AppDriver
>
>        */
>
>       *try* {
>
>                   awaitTermination(5, TimeUnit.*SECONDS*);
>
>             } *catch* (InterruptedException e) {
>
>             }
>
>       Log.*d*("SocketTask", "Done shutting down all connections");
>
>     }
>
> }
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130330/d1f61d8a/attachment-0001.html>

From vipinarav at gmail.com  Sat Mar 30 23:28:35 2013
From: vipinarav at gmail.com (Vipin Aravind)
Date: Sun, 31 Mar 2013 08:58:35 +0530
Subject: [concurrency-interest] CancellableTask and CancellingExecutor
In-Reply-To: <CAEJX8oprk8t=hoLFUqzyKny=BQMAgo1-a-fa-2qxkn6xKfRBzA@mail.gmail.com>
References: <CAJnwaPFZCsxvuZcdqEkcNSbspEURGhZcHTBvkXo_6UVXbO6Exw@mail.gmail.com>
	<CAEJX8oprk8t=hoLFUqzyKny=BQMAgo1-a-fa-2qxkn6xKfRBzA@mail.gmail.com>
Message-ID: <CAJnwaPGHJcyXM7RD8eiR1HKacai8K3BdMGXjNrqP5_QkwVGTrQ@mail.gmail.com>

What we have in out tasks are blocking sockets so standard java mechamisms
shutdown/shutdownNow does not work as they merely set an
internal interrupted variable and nothing more.Refer 7.1.6(dealing with
non-interruptible blocking) and 7.1.7(Encapsulating nonstandard
cancellation with newTaskFor) of JCIP. To be truly interrupting, we have to
cancel the future which triggers the cancel in the SocketUsingTask which
closes the underlying socket causing the blocking operation to give up.
Instead of maintaining the futures outside, I track it within the
CancellingExecutor using a internal list when a new task is submitted. So
when the module is brought down I could call Cancelling exeuctor's shutdown
and my overriden shutdown method will internally trigger cancel on the
futures.


On Sun, Mar 31, 2013 at 1:55 AM, Stanimir Simeonoff <stanimir at riflexo.com>wrote:

> I am not sure why you need the list. TPE.getQueue() does almost exactly
> the same for the tasks that have not been scheduled already. The ones being
> executed would be notified w/ shutdownNow the just same as cancel(true),
> i.e. invoking thread.interrupt().
> More also accessing logging via global lock usually is a big no. You can
> always log after the synchronized{} block.
>
> I merely do not see any benefits of CancellingExecutor compared to the
> vanilla TPE.
>
> Stanimir
>
>
> On Sat, Mar 30, 2013 at 5:59 PM, Vipin Aravind <vipinarav at gmail.com>wrote:
>
>> We use the SocketUsingTask in java concurrency in practice(Listing 7.12)[
>> http://jcip.net.s3-website-us-east-1.amazonaws.com/listings/SocketUsingTask.java
>> ] in our production code. I had enhanced the code for our purposes. We
>> have to run many tasks which make use of blocking socket calls. I enhanced
>> the CancellingExecutor so that we can track the tasks that are currently
>> run by cancellingexecutor and when bringing down the system, we could call
>> the CancellingExecutor?s shutdown which will then loop over  the task list
>> and call ?cancel? on them. This code has been in production for an year,
>> but I had like to get the opinion of experts and if there is a
>> better/nice/cleaner way of doing this.
>>
>> Here is the modified CancellingExecutor:-
>>
>> *class* CancellingExecutor *extends* ThreadPoolExecutor {
>>
>>       *private* *final* List<Object> list;
>>
>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>> BlockingQueue<Runnable> workQueue) {
>>
>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>> workQueue);
>>
>>         list = Collections.*synchronizedList*(*new*
>> ArrayList<Object>(maximumPoolSize));
>>
>>     }
>>
>>
>>
>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>> BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
>>
>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>> workQueue, threadFactory);
>>
>>         list = Collections.*synchronizedList*(*new*
>> ArrayList<Object>(maximumPoolSize));
>>
>>     }
>>
>>
>>
>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>> BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
>>
>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>> workQueue, handler);
>>
>>         list = Collections.*synchronizedList*(*new*
>> ArrayList<Object>(maximumPoolSize));
>>
>>     }
>>
>>
>>
>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>> BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,
>> RejectedExecutionHandler handler) {
>>
>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>> workQueue, threadFactory, handler);
>>
>>        list = Collections.*synchronizedList*(*new*
>> ArrayList<Object>(maximumPoolSize));
>>
>>     }
>>
>>
>>
>>     *public* *static* ExecutorService newFixedThreadPool(*int* nThreads)
>> {
>>
>>         *return* *new* CancellingExecutor(nThreads, nThreads,
>>
>>                                       0L, TimeUnit.*MILLISECONDS*,
>>
>>                                       *new*
>> LinkedBlockingQueue<Runnable>());
>>
>>     }
>>
>>     *protected* *void* beforeExecute(Thread t, Runnable  r)
>>
>>     {
>>
>>       *super*.beforeExecute(t, r);
>>
>>     }
>>
>>     /*
>>
>>      * Remove the  task  from  the  list if  it  was  added in  newTaskFor
>>
>>      */
>>
>>     *protected* *void* afterExecute(Runnable r, Throwable t)
>>
>>     {
>>
>>       *super*.afterExecute(r, t);
>>
>>       *synchronized*(list){
>>
>>             *if*(list.remove(r))
>>
>>                   Log.*d*("SocketTask", "Connection Count:" + Integer.*
>> toString*(list.size()));
>>
>>             }
>>
>>     }
>>
>>     /*
>>
>>      * newTask  hook.
>>
>>      * 1) If  it  is a  *cancellable*  task  add  to  the list.
>>
>>      */
>>
>>     *protected* <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
>>
>>             *if* (callable *instanceof* CancellableTask) {
>>
>>                   RunnableFuture<T> future = ((CancellableTask<T>)
>> callable)
>>
>>                               .newTask();
>>
>>                   *synchronized* (list) {
>>
>>                         list.add(future);
>>
>>                         Log.*d*("SocketTask", "Connection Count:" +
>> Integer.*toString*(list.size()));
>>
>>                   }
>>
>>                   *return* future;
>>
>>             } *else*
>>
>>                   *return* *super*.newTaskFor(callable);
>>
>>       }
>>
>>     /*
>>
>>      * cancels all  the future tasks. We  need  to  come  out of
>> blocking socket I/O calls
>>
>>      * Interrupt  based  blocking  calls  will  also  come out.
>>
>>      * Also shutdown any threads which  we  didn't  account  for  in
>> the  list(this  should  never  happen)
>>
>>      * I have noticed  this  function  being  called  by a
>> FinalizerDameon(garbage collection??)
>>
>> It  appears  harmless  for  now. one  could override  the
>>
>>      * finalize  to  get  around  this, but  I  leave  it as  is  as  it
>> appears  harmless.
>>
>>      */
>>
>>     *public* *void* shutdown()
>>
>>     {
>>
>>       Log.*d*("SocketTask", "Start shutting down all connections");// +
>> Thread.currentThread().getName() + " "+ this.hashCode());
>>
>>       *synchronized*(list){
>>
>>       *for*(*int*  i = 0; i < list.size(); i++)
>>
>>             *((RunnableFuture<Object>)**list**.get(i))*.cancel(*true*);
>>
>>       }
>>
>>
>>
>>       shutdownNow();
>>
>>       /*
>>
>>        * Wait  for  no  more  than  5 seconds  for  all  the worker
>> threads  to  be  done.
>>
>>        * the  cancel  in  transport driver will  trigger a  disconnect
>> in  peer  connection inn AppDriver
>>
>>        */
>>
>>       *try* {
>>
>>                   awaitTermination(5, TimeUnit.*SECONDS*);
>>
>>             } *catch* (InterruptedException e) {
>>
>>             }
>>
>>       Log.*d*("SocketTask", "Done shutting down all connections");
>>
>>     }
>>
>> }
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130331/606bfa99/attachment-0001.html>

From stanimir at riflexo.com  Sun Mar 31 07:19:27 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Sun, 31 Mar 2013 14:19:27 +0300
Subject: [concurrency-interest] CancellableTask and CancellingExecutor
In-Reply-To: <CAJnwaPGHJcyXM7RD8eiR1HKacai8K3BdMGXjNrqP5_QkwVGTrQ@mail.gmail.com>
References: <CAJnwaPFZCsxvuZcdqEkcNSbspEURGhZcHTBvkXo_6UVXbO6Exw@mail.gmail.com>
	<CAEJX8oprk8t=hoLFUqzyKny=BQMAgo1-a-fa-2qxkn6xKfRBzA@mail.gmail.com>
	<CAJnwaPGHJcyXM7RD8eiR1HKacai8K3BdMGXjNrqP5_QkwVGTrQ@mail.gmail.com>
Message-ID: <CAEJX8opP_+qeUGUKOWba1akCbtPQ0tfT6MxmoKR+9p-UZ_-z5w@mail.gmail.com>

On Sun, Mar 31, 2013 at 6:28 AM, Vipin Aravind <vipinarav at gmail.com> wrote:

> What we have in out tasks are blocking sockets so standard java mechamisms
> shutdown/shutdownNow does not work as they *merely set an
> internal interrupted variable and nothing more*
>
That's not exactly true. I mean that interrupt only sets the flag. It does
call a registered handler that NIO is using it to interrupt selectors.
I've not been using blocking IO for almost 10 years, however it's possible
to handle Thread.interrupt from user space code and this is usually what
I'd do. It's a little known feature of NIO channels.
java.nio.channels.spi.AbstractInterruptibleChannel allows to install a
handler into implCloseChannel(). Basically you implement the method and
wrap it the calls between begin/end. before/afterExecute would be perfect.

Handling interrupt() allows to remotely close sockets, if need be - that's
the standard interrupt is a lot more powerful, how much you can decide.

The posted code has a race between  newTaskFor/execute and shutdown.
super.shutdown/shutdownNow has to be called prior canceling the tasks,
otherwise tasks/sockets on the fly will remain unclosed.

Stanimir




> .Refer 7.1.6(dealing with non-interruptible blocking) and
> 7.1.7(Encapsulating nonstandard cancellation with newTaskFor) of JCIP. To
> be truly interrupting, we have to cancel the future which triggers the
> cancel in the SocketUsingTask which closes the underlying socket causing
> the blocking operation to give up. Instead of maintaining the futures
> outside, I track it within the CancellingExecutor using a internal list
> when a new task is submitted. So when the module is brought down I could
> call Cancelling exeuctor's shutdown and my overriden shutdown method will
> internally trigger cancel on the futures.
>
>
> On Sun, Mar 31, 2013 at 1:55 AM, Stanimir Simeonoff <stanimir at riflexo.com>wrote:
>
>> I am not sure why you need the list. TPE.getQueue() does almost exactly
>> the same for the tasks that have not been scheduled already. The ones being
>> executed would be notified w/ shutdownNow the just same as cancel(true),
>> i.e. invoking thread.interrupt().
>> More also accessing logging via global lock usually is a big no. You can
>> always log after the synchronized{} block.
>>
>> I merely do not see any benefits of CancellingExecutor compared to the
>> vanilla TPE.
>>
>> Stanimir
>>
>>
>> On Sat, Mar 30, 2013 at 5:59 PM, Vipin Aravind <vipinarav at gmail.com>wrote:
>>
>>> We use the SocketUsingTask in java concurrency in practice(Listing 7.12)[
>>> http://jcip.net.s3-website-us-east-1.amazonaws.com/listings/SocketUsingTask.java
>>> ] in our production code. I had enhanced the code for our purposes. We
>>> have to run many tasks which make use of blocking socket calls. I enhanced
>>> the CancellingExecutor so that we can track the tasks that are currently
>>> run by cancellingexecutor and when bringing down the system, we could call
>>> the CancellingExecutor?s shutdown which will then loop over  the task list
>>> and call ?cancel? on them. This code has been in production for an year,
>>> but I had like to get the opinion of experts and if there is a
>>> better/nice/cleaner way of doing this.
>>>
>>> Here is the modified CancellingExecutor:-
>>>
>>> *class* CancellingExecutor *extends* ThreadPoolExecutor {
>>>
>>>       *private* *final* List<Object> list;
>>>
>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>> BlockingQueue<Runnable> workQueue) {
>>>
>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>> workQueue);
>>>
>>>         list = Collections.*synchronizedList*(*new*
>>> ArrayList<Object>(maximumPoolSize));
>>>
>>>     }
>>>
>>>
>>>
>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>> BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
>>>
>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>> workQueue, threadFactory);
>>>
>>>         list = Collections.*synchronizedList*(*new*
>>> ArrayList<Object>(maximumPoolSize));
>>>
>>>     }
>>>
>>>
>>>
>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>> BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
>>>
>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>> workQueue, handler);
>>>
>>>         list = Collections.*synchronizedList*(*new*
>>> ArrayList<Object>(maximumPoolSize));
>>>
>>>     }
>>>
>>>
>>>
>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>> BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,
>>> RejectedExecutionHandler handler) {
>>>
>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>> workQueue, threadFactory, handler);
>>>
>>>        list = Collections.*synchronizedList*(*new*
>>> ArrayList<Object>(maximumPoolSize));
>>>
>>>     }
>>>
>>>
>>>
>>>     *public* *static* ExecutorService newFixedThreadPool(*int* nThreads)
>>> {
>>>
>>>         *return* *new* CancellingExecutor(nThreads, nThreads,
>>>
>>>                                       0L, TimeUnit.*MILLISECONDS*,
>>>
>>>                                       *new*
>>> LinkedBlockingQueue<Runnable>());
>>>
>>>     }
>>>
>>>     *protected* *void* beforeExecute(Thread t, Runnable  r)
>>>
>>>     {
>>>
>>>       *super*.beforeExecute(t, r);
>>>
>>>     }
>>>
>>>     /*
>>>
>>>      * Remove the  task  from  the  list if  it  was  added in
>>> newTaskFor
>>>
>>>      */
>>>
>>>     *protected* *void* afterExecute(Runnable r, Throwable t)
>>>
>>>     {
>>>
>>>       *super*.afterExecute(r, t);
>>>
>>>       *synchronized*(list){
>>>
>>>             *if*(list.remove(r))
>>>
>>>                   Log.*d*("SocketTask", "Connection Count:" + Integer.*
>>> toString*(list.size()));
>>>
>>>             }
>>>
>>>     }
>>>
>>>     /*
>>>
>>>      * newTask  hook.
>>>
>>>      * 1) If  it  is a  *cancellable*  task  add  to  the list.
>>>
>>>      */
>>>
>>>     *protected* <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
>>>
>>>             *if* (callable *instanceof* CancellableTask) {
>>>
>>>                   RunnableFuture<T> future = ((CancellableTask<T>)
>>> callable)
>>>
>>>                               .newTask();
>>>
>>>                   *synchronized* (list) {
>>>
>>>                         list.add(future);
>>>
>>>                         Log.*d*("SocketTask", "Connection Count:" +
>>> Integer.*toString*(list.size()));
>>>
>>>                   }
>>>
>>>                   *return* future;
>>>
>>>             } *else*
>>>
>>>                   *return* *super*.newTaskFor(callable);
>>>
>>>       }
>>>
>>>     /*
>>>
>>>      * cancels all  the future tasks. We  need  to  come  out of
>>> blocking socket I/O calls
>>>
>>>      * Interrupt  based  blocking  calls  will  also  come out.
>>>
>>>      * Also shutdown any threads which  we  didn't  account  for  in
>>> the  list(this  should  never  happen)
>>>
>>>      * I have noticed  this  function  being  called  by a
>>> FinalizerDameon(garbage collection??)
>>>
>>> It  appears  harmless  for  now. one  could override  the
>>>
>>>      * finalize  to  get  around  this, but  I  leave  it as  is  as
>>> it  appears  harmless.
>>>
>>>      */
>>>
>>>     *public* *void* shutdown()
>>>
>>>     {
>>>
>>>       Log.*d*("SocketTask", "Start shutting down all connections");// +
>>> Thread.currentThread().getName() + " "+ this.hashCode());
>>>
>>>       *synchronized*(list){
>>>
>>>       *for*(*int*  i = 0; i < list.size(); i++)
>>>
>>>             *((RunnableFuture<Object>)**list**.get(i))*.cancel(*true*);
>>>
>>>       }
>>>
>>>
>>>
>>>       shutdownNow();
>>>
>>>       /*
>>>
>>>        * Wait  for  no  more  than  5 seconds  for  all  the worker
>>> threads  to  be  done.
>>>
>>>        * the  cancel  in  transport driver will  trigger a  disconnect
>>> in  peer  connection inn AppDriver
>>>
>>>        */
>>>
>>>       *try* {
>>>
>>>                   awaitTermination(5, TimeUnit.*SECONDS*);
>>>
>>>             } *catch* (InterruptedException e) {
>>>
>>>             }
>>>
>>>       Log.*d*("SocketTask", "Done shutting down all connections");
>>>
>>>     }
>>>
>>> }
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130331/d40b7098/attachment-0001.html>

From vipinarav at gmail.com  Sun Mar 31 08:59:35 2013
From: vipinarav at gmail.com (Vipin Aravind)
Date: Sun, 31 Mar 2013 18:29:35 +0530
Subject: [concurrency-interest] CancellableTask and CancellingExecutor
In-Reply-To: <CAEJX8opP_+qeUGUKOWba1akCbtPQ0tfT6MxmoKR+9p-UZ_-z5w@mail.gmail.com>
References: <CAJnwaPFZCsxvuZcdqEkcNSbspEURGhZcHTBvkXo_6UVXbO6Exw@mail.gmail.com>
	<CAEJX8oprk8t=hoLFUqzyKny=BQMAgo1-a-fa-2qxkn6xKfRBzA@mail.gmail.com>
	<CAJnwaPGHJcyXM7RD8eiR1HKacai8K3BdMGXjNrqP5_QkwVGTrQ@mail.gmail.com>
	<CAEJX8opP_+qeUGUKOWba1akCbtPQ0tfT6MxmoKR+9p-UZ_-z5w@mail.gmail.com>
Message-ID: <CAJnwaPEwOaQqCscrfamAbwH4qyxu3N0hg7_F=QEn+ivF7wgFZw@mail.gmail.com>

I prefer nio but sslsocket is blocking and there is no non blocking
equivalent for ssl sockets. My reference is to the point that the read and
write to input and ouput streams are not responsive to interruption. For
this I use the socketusing task and the cancel helps in closing the socket
and read and write to respond with socketexception
On 31 Mar 2013 16:49, "Stanimir Simeonoff" <stanimir at riflexo.com> wrote:

>
>
> On Sun, Mar 31, 2013 at 6:28 AM, Vipin Aravind <vipinarav at gmail.com>wrote:
>
>> What we have in out tasks are blocking sockets so standard java
>> mechamisms shutdown/shutdownNow does not work as they *merely set an
>> internal interrupted variable and nothing more*
>>
> That's not exactly true. I mean that interrupt only sets the flag. It does
> call a registered handler that NIO is using it to interrupt selectors.
> I've not been using blocking IO for almost 10 years, however it's possible
> to handle Thread.interrupt from user space code and this is usually what
> I'd do. It's a little known feature of NIO channels.
> java.nio.channels.spi.AbstractInterruptibleChannel allows to install a
> handler into implCloseChannel(). Basically you implement the method and
> wrap it the calls between begin/end. before/afterExecute would be perfect.
>
> Handling interrupt() allows to remotely close sockets, if need be - that's
> the standard interrupt is a lot more powerful, how much you can decide.
>
> The posted code has a race between  newTaskFor/execute and shutdown.
> super.shutdown/shutdownNow has to be called prior canceling the tasks,
> otherwise tasks/sockets on the fly will remain unclosed.
>
> Stanimir
>
>
>
>
>> .Refer 7.1.6(dealing with non-interruptible blocking) and
>> 7.1.7(Encapsulating nonstandard cancellation with newTaskFor) of JCIP. To
>> be truly interrupting, we have to cancel the future which triggers the
>> cancel in the SocketUsingTask which closes the underlying socket causing
>> the blocking operation to give up. Instead of maintaining the futures
>> outside, I track it within the CancellingExecutor using a internal list
>> when a new task is submitted. So when the module is brought down I could
>> call Cancelling exeuctor's shutdown and my overriden shutdown method will
>> internally trigger cancel on the futures.
>>
>>
>> On Sun, Mar 31, 2013 at 1:55 AM, Stanimir Simeonoff <stanimir at riflexo.com
>> > wrote:
>>
>>> I am not sure why you need the list. TPE.getQueue() does almost exactly
>>> the same for the tasks that have not been scheduled already. The ones being
>>> executed would be notified w/ shutdownNow the just same as cancel(true),
>>> i.e. invoking thread.interrupt().
>>> More also accessing logging via global lock usually is a big no. You can
>>> always log after the synchronized{} block.
>>>
>>> I merely do not see any benefits of CancellingExecutor compared to the
>>> vanilla TPE.
>>>
>>> Stanimir
>>>
>>>
>>> On Sat, Mar 30, 2013 at 5:59 PM, Vipin Aravind <vipinarav at gmail.com>wrote:
>>>
>>>> We use the SocketUsingTask in java concurrency in practice(Listing
>>>> 7.12)[
>>>> http://jcip.net.s3-website-us-east-1.amazonaws.com/listings/SocketUsingTask.java
>>>> ] in our production code. I had enhanced the code for our purposes. We
>>>> have to run many tasks which make use of blocking socket calls. I enhanced
>>>> the CancellingExecutor so that we can track the tasks that are currently
>>>> run by cancellingexecutor and when bringing down the system, we could call
>>>> the CancellingExecutor?s shutdown which will then loop over  the task list
>>>> and call ?cancel? on them. This code has been in production for an year,
>>>> but I had like to get the opinion of experts and if there is a
>>>> better/nice/cleaner way of doing this.
>>>>
>>>> Here is the modified CancellingExecutor:-
>>>>
>>>> *class* CancellingExecutor *extends* ThreadPoolExecutor {
>>>>
>>>>       *private* *final* List<Object> list;
>>>>
>>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>>> BlockingQueue<Runnable> workQueue) {
>>>>
>>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>>> workQueue);
>>>>
>>>>         list = Collections.*synchronizedList*(*new*
>>>> ArrayList<Object>(maximumPoolSize));
>>>>
>>>>     }
>>>>
>>>>
>>>>
>>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>>> BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
>>>>
>>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>>> workQueue, threadFactory);
>>>>
>>>>         list = Collections.*synchronizedList*(*new*
>>>> ArrayList<Object>(maximumPoolSize));
>>>>
>>>>     }
>>>>
>>>>
>>>>
>>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>>> BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
>>>>
>>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>>> workQueue, handler);
>>>>
>>>>         list = Collections.*synchronizedList*(*new*
>>>> ArrayList<Object>(maximumPoolSize));
>>>>
>>>>     }
>>>>
>>>>
>>>>
>>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>>> BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,
>>>> RejectedExecutionHandler handler) {
>>>>
>>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>>> workQueue, threadFactory, handler);
>>>>
>>>>        list = Collections.*synchronizedList*(*new*
>>>> ArrayList<Object>(maximumPoolSize));
>>>>
>>>>     }
>>>>
>>>>
>>>>
>>>>     *public* *static* ExecutorService newFixedThreadPool(*int* nThreads)
>>>> {
>>>>
>>>>         *return* *new* CancellingExecutor(nThreads, nThreads,
>>>>
>>>>                                       0L, TimeUnit.*MILLISECONDS*,
>>>>
>>>>                                       *new*
>>>> LinkedBlockingQueue<Runnable>());
>>>>
>>>>     }
>>>>
>>>>     *protected* *void* beforeExecute(Thread t, Runnable  r)
>>>>
>>>>     {
>>>>
>>>>       *super*.beforeExecute(t, r);
>>>>
>>>>     }
>>>>
>>>>     /*
>>>>
>>>>      * Remove the  task  from  the  list if  it  was  added in
>>>> newTaskFor
>>>>
>>>>      */
>>>>
>>>>     *protected* *void* afterExecute(Runnable r, Throwable t)
>>>>
>>>>     {
>>>>
>>>>       *super*.afterExecute(r, t);
>>>>
>>>>       *synchronized*(list){
>>>>
>>>>             *if*(list.remove(r))
>>>>
>>>>                   Log.*d*("SocketTask", "Connection Count:" + Integer.*
>>>> toString*(list.size()));
>>>>
>>>>             }
>>>>
>>>>     }
>>>>
>>>>     /*
>>>>
>>>>      * newTask  hook.
>>>>
>>>>      * 1) If  it  is a  *cancellable*  task  add  to  the list.
>>>>
>>>>      */
>>>>
>>>>     *protected* <T> RunnableFuture<T> newTaskFor(Callable<T> callable)
>>>> {
>>>>
>>>>             *if* (callable *instanceof* CancellableTask) {
>>>>
>>>>                   RunnableFuture<T> future = ((CancellableTask<T>)
>>>> callable)
>>>>
>>>>                               .newTask();
>>>>
>>>>                   *synchronized* (list) {
>>>>
>>>>                         list.add(future);
>>>>
>>>>                         Log.*d*("SocketTask", "Connection Count:" +
>>>> Integer.*toString*(list.size()));
>>>>
>>>>                   }
>>>>
>>>>                   *return* future;
>>>>
>>>>             } *else*
>>>>
>>>>                   *return* *super*.newTaskFor(callable);
>>>>
>>>>       }
>>>>
>>>>     /*
>>>>
>>>>      * cancels all  the future tasks. We  need  to  come  out of
>>>> blocking socket I/O calls
>>>>
>>>>      * Interrupt  based  blocking  calls  will  also  come out.
>>>>
>>>>      * Also shutdown any threads which  we  didn't  account  for  in
>>>> the  list(this  should  never  happen)
>>>>
>>>>      * I have noticed  this  function  being  called  by a
>>>> FinalizerDameon(garbage collection??)
>>>>
>>>> It  appears  harmless  for  now. one  could override  the
>>>>
>>>>      * finalize  to  get  around  this, but  I  leave  it as  is  as
>>>> it  appears  harmless.
>>>>
>>>>      */
>>>>
>>>>     *public* *void* shutdown()
>>>>
>>>>     {
>>>>
>>>>       Log.*d*("SocketTask", "Start shutting down all connections");//
>>>> + Thread.currentThread().getName() + " "+ this.hashCode());
>>>>
>>>>       *synchronized*(list){
>>>>
>>>>       *for*(*int*  i = 0; i < list.size(); i++)
>>>>
>>>>             *((RunnableFuture<Object>)**list**.get(i))*.cancel(*true*);
>>>>
>>>>       }
>>>>
>>>>
>>>>
>>>>       shutdownNow();
>>>>
>>>>       /*
>>>>
>>>>        * Wait  for  no  more  than  5 seconds  for  all  the worker
>>>> threads  to  be  done.
>>>>
>>>>        * the  cancel  in  transport driver will  trigger a  disconnect
>>>> in  peer  connection inn AppDriver
>>>>
>>>>        */
>>>>
>>>>       *try* {
>>>>
>>>>                   awaitTermination(5, TimeUnit.*SECONDS*);
>>>>
>>>>             } *catch* (InterruptedException e) {
>>>>
>>>>             }
>>>>
>>>>       Log.*d*("SocketTask", "Done shutting down all connections");
>>>>
>>>>     }
>>>>
>>>> }
>>>>
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130331/ae192c85/attachment-0001.html>

From stanimir at riflexo.com  Sun Mar 31 09:22:58 2013
From: stanimir at riflexo.com (Stanimir Simeonoff)
Date: Sun, 31 Mar 2013 16:22:58 +0300
Subject: [concurrency-interest] CancellableTask and CancellingExecutor
In-Reply-To: <CAJnwaPEwOaQqCscrfamAbwH4qyxu3N0hg7_F=QEn+ivF7wgFZw@mail.gmail.com>
References: <CAJnwaPFZCsxvuZcdqEkcNSbspEURGhZcHTBvkXo_6UVXbO6Exw@mail.gmail.com>
	<CAEJX8oprk8t=hoLFUqzyKny=BQMAgo1-a-fa-2qxkn6xKfRBzA@mail.gmail.com>
	<CAJnwaPGHJcyXM7RD8eiR1HKacai8K3BdMGXjNrqP5_QkwVGTrQ@mail.gmail.com>
	<CAEJX8opP_+qeUGUKOWba1akCbtPQ0tfT6MxmoKR+9p-UZ_-z5w@mail.gmail.com>
	<CAJnwaPEwOaQqCscrfamAbwH4qyxu3N0hg7_F=QEn+ivF7wgFZw@mail.gmail.com>
Message-ID: <CAEJX8or3k23APwz9tjmhifr5c6LLTGyAs-jxsEmLRo2pQDUOtA@mail.gmail.com>

Since 1.5 there is SSLEngine that allows any byte stream to be SSL/TLS
enabled.
Admittedly its usage is harder than SSLSockets, though. Yet, allows full
control of the process.

Stanimir


On Sun, Mar 31, 2013 at 3:59 PM, Vipin Aravind <vipinarav at gmail.com> wrote:

> I prefer nio but sslsocket is blocking and there is no non blocking
> equivalent for ssl sockets. My reference is to the point that the read and
> write to input and ouput streams are not responsive to interruption. For
> this I use the socketusing task and the cancel helps in closing the socket
> and read and write to respond with socketexception
> On 31 Mar 2013 16:49, "Stanimir Simeonoff" <stanimir at riflexo.com> wrote:
>
>>
>>
>> On Sun, Mar 31, 2013 at 6:28 AM, Vipin Aravind <vipinarav at gmail.com>wrote:
>>
>>> What we have in out tasks are blocking sockets so standard java
>>> mechamisms shutdown/shutdownNow does not work as they *merely set an
>>> internal interrupted variable and nothing more*
>>>
>> That's not exactly true. I mean that interrupt only sets the flag. It
>> does call a registered handler that NIO is using it to interrupt selectors.
>> I've not been using blocking IO for almost 10 years, however it's
>> possible to handle Thread.interrupt from user space code and this is
>> usually what I'd do. It's a little known feature of NIO channels.
>> java.nio.channels.spi.AbstractInterruptibleChannel allows to install a
>> handler into implCloseChannel(). Basically you implement the method and
>> wrap it the calls between begin/end. before/afterExecute would be perfect.
>>
>> Handling interrupt() allows to remotely close sockets, if need be -
>> that's the standard interrupt is a lot more powerful, how much you can
>> decide.
>>
>> The posted code has a race between  newTaskFor/execute and shutdown.
>> super.shutdown/shutdownNow has to be called prior canceling the tasks,
>> otherwise tasks/sockets on the fly will remain unclosed.
>>
>> Stanimir
>>
>>
>>
>>
>>> .Refer 7.1.6(dealing with non-interruptible blocking) and
>>> 7.1.7(Encapsulating nonstandard cancellation with newTaskFor) of JCIP. To
>>> be truly interrupting, we have to cancel the future which triggers the
>>> cancel in the SocketUsingTask which closes the underlying socket causing
>>> the blocking operation to give up. Instead of maintaining the futures
>>> outside, I track it within the CancellingExecutor using a internal list
>>> when a new task is submitted. So when the module is brought down I could
>>> call Cancelling exeuctor's shutdown and my overriden shutdown method will
>>> internally trigger cancel on the futures.
>>>
>>>
>>> On Sun, Mar 31, 2013 at 1:55 AM, Stanimir Simeonoff <
>>> stanimir at riflexo.com> wrote:
>>>
>>>> I am not sure why you need the list. TPE.getQueue() does almost exactly
>>>> the same for the tasks that have not been scheduled already. The ones being
>>>> executed would be notified w/ shutdownNow the just same as cancel(true),
>>>> i.e. invoking thread.interrupt().
>>>> More also accessing logging via global lock usually is a big no. You
>>>> can always log after the synchronized{} block.
>>>>
>>>> I merely do not see any benefits of CancellingExecutor compared to the
>>>> vanilla TPE.
>>>>
>>>> Stanimir
>>>>
>>>>
>>>> On Sat, Mar 30, 2013 at 5:59 PM, Vipin Aravind <vipinarav at gmail.com>wrote:
>>>>
>>>>> We use the SocketUsingTask in java concurrency in practice(Listing
>>>>> 7.12)[
>>>>> http://jcip.net.s3-website-us-east-1.amazonaws.com/listings/SocketUsingTask.java
>>>>> ] in our production code. I had enhanced the code for our purposes.
>>>>> We have to run many tasks which make use of blocking socket calls. I
>>>>> enhanced the CancellingExecutor so that we can track the tasks that are
>>>>> currently run by cancellingexecutor and when bringing down the system, we
>>>>> could call the CancellingExecutor?s shutdown which will then loop over  the
>>>>> task list and call ?cancel? on them. This code has been in production for
>>>>> an year, but I had like to get the opinion of experts and if there is a
>>>>> better/nice/cleaner way of doing this.
>>>>>
>>>>> Here is the modified CancellingExecutor:-
>>>>>
>>>>> *class* CancellingExecutor *extends* ThreadPoolExecutor {
>>>>>
>>>>>       *private* *final* List<Object> list;
>>>>>
>>>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>>>> BlockingQueue<Runnable> workQueue) {
>>>>>
>>>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>>>> workQueue);
>>>>>
>>>>>         list = Collections.*synchronizedList*(*new*
>>>>> ArrayList<Object>(maximumPoolSize));
>>>>>
>>>>>     }
>>>>>
>>>>>
>>>>>
>>>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>>>> BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
>>>>>
>>>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>>>> workQueue, threadFactory);
>>>>>
>>>>>         list = Collections.*synchronizedList*(*new*
>>>>> ArrayList<Object>(maximumPoolSize));
>>>>>
>>>>>     }
>>>>>
>>>>>
>>>>>
>>>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>>>> BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
>>>>>
>>>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>>>> workQueue, handler);
>>>>>
>>>>>         list = Collections.*synchronizedList*(*new*
>>>>> ArrayList<Object>(maximumPoolSize));
>>>>>
>>>>>     }
>>>>>
>>>>>
>>>>>
>>>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>>>> BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,
>>>>> RejectedExecutionHandler handler) {
>>>>>
>>>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>>>> workQueue, threadFactory, handler);
>>>>>
>>>>>        list = Collections.*synchronizedList*(*new*
>>>>> ArrayList<Object>(maximumPoolSize));
>>>>>
>>>>>     }
>>>>>
>>>>>
>>>>>
>>>>>     *public* *static* ExecutorService newFixedThreadPool(*int* nThreads)
>>>>> {
>>>>>
>>>>>         *return* *new* CancellingExecutor(nThreads, nThreads,
>>>>>
>>>>>                                       0L, TimeUnit.*MILLISECONDS*,
>>>>>
>>>>>                                       *new*
>>>>> LinkedBlockingQueue<Runnable>());
>>>>>
>>>>>     }
>>>>>
>>>>>     *protected* *void* beforeExecute(Thread t, Runnable  r)
>>>>>
>>>>>     {
>>>>>
>>>>>       *super*.beforeExecute(t, r);
>>>>>
>>>>>     }
>>>>>
>>>>>     /*
>>>>>
>>>>>      * Remove the  task  from  the  list if  it  was  added in
>>>>> newTaskFor
>>>>>
>>>>>      */
>>>>>
>>>>>     *protected* *void* afterExecute(Runnable r, Throwable t)
>>>>>
>>>>>     {
>>>>>
>>>>>       *super*.afterExecute(r, t);
>>>>>
>>>>>       *synchronized*(list){
>>>>>
>>>>>             *if*(list.remove(r))
>>>>>
>>>>>                   Log.*d*("SocketTask", "Connection Count:" + Integer.
>>>>> *toString*(list.size()));
>>>>>
>>>>>             }
>>>>>
>>>>>     }
>>>>>
>>>>>     /*
>>>>>
>>>>>      * newTask  hook.
>>>>>
>>>>>      * 1) If  it  is a  *cancellable*  task  add  to  the list.
>>>>>
>>>>>      */
>>>>>
>>>>>     *protected* <T> RunnableFuture<T> newTaskFor(Callable<T>
>>>>> callable) {
>>>>>
>>>>>             *if* (callable *instanceof* CancellableTask) {
>>>>>
>>>>>                   RunnableFuture<T> future = ((CancellableTask<T>)
>>>>> callable)
>>>>>
>>>>>                               .newTask();
>>>>>
>>>>>                   *synchronized* (list) {
>>>>>
>>>>>                         list.add(future);
>>>>>
>>>>>                         Log.*d*("SocketTask", "Connection Count:" +
>>>>> Integer.*toString*(list.size()));
>>>>>
>>>>>                   }
>>>>>
>>>>>                   *return* future;
>>>>>
>>>>>             } *else*
>>>>>
>>>>>                   *return* *super*.newTaskFor(callable);
>>>>>
>>>>>       }
>>>>>
>>>>>     /*
>>>>>
>>>>>      * cancels all  the future tasks. We  need  to  come  out of
>>>>> blocking socket I/O calls
>>>>>
>>>>>      * Interrupt  based  blocking  calls  will  also  come out.
>>>>>
>>>>>      * Also shutdown any threads which  we  didn't  account  for  in
>>>>> the  list(this  should  never  happen)
>>>>>
>>>>>      * I have noticed  this  function  being  called  by a
>>>>> FinalizerDameon(garbage collection??)
>>>>>
>>>>> It  appears  harmless  for  now. one  could override  the
>>>>>
>>>>>      * finalize  to  get  around  this, but  I  leave  it as  is  as
>>>>> it  appears  harmless.
>>>>>
>>>>>      */
>>>>>
>>>>>     *public* *void* shutdown()
>>>>>
>>>>>     {
>>>>>
>>>>>       Log.*d*("SocketTask", "Start shutting down all connections");//
>>>>> + Thread.currentThread().getName() + " "+ this.hashCode());
>>>>>
>>>>>       *synchronized*(list){
>>>>>
>>>>>       *for*(*int*  i = 0; i < list.size(); i++)
>>>>>
>>>>>             *((RunnableFuture<Object>)**list**.get(i))*.cancel(*true*
>>>>> );
>>>>>
>>>>>       }
>>>>>
>>>>>
>>>>>
>>>>>       shutdownNow();
>>>>>
>>>>>       /*
>>>>>
>>>>>        * Wait  for  no  more  than  5 seconds  for  all  the worker
>>>>> threads  to  be  done.
>>>>>
>>>>>        * the  cancel  in  transport driver will  trigger a  disconnect
>>>>> in  peer  connection inn AppDriver
>>>>>
>>>>>        */
>>>>>
>>>>>       *try* {
>>>>>
>>>>>                   awaitTermination(5, TimeUnit.*SECONDS*);
>>>>>
>>>>>             } *catch* (InterruptedException e) {
>>>>>
>>>>>             }
>>>>>
>>>>>       Log.*d*("SocketTask", "Done shutting down all connections");
>>>>>
>>>>>     }
>>>>>
>>>>> }
>>>>>
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130331/a5ebe2b5/attachment-0001.html>

From vipinarav at gmail.com  Sun Mar 31 10:03:46 2013
From: vipinarav at gmail.com (Vipin Aravind)
Date: Sun, 31 Mar 2013 19:33:46 +0530
Subject: [concurrency-interest] CancellableTask and CancellingExecutor
In-Reply-To: <CAEJX8or3k23APwz9tjmhifr5c6LLTGyAs-jxsEmLRo2pQDUOtA@mail.gmail.com>
References: <CAJnwaPFZCsxvuZcdqEkcNSbspEURGhZcHTBvkXo_6UVXbO6Exw@mail.gmail.com>
	<CAEJX8oprk8t=hoLFUqzyKny=BQMAgo1-a-fa-2qxkn6xKfRBzA@mail.gmail.com>
	<CAJnwaPGHJcyXM7RD8eiR1HKacai8K3BdMGXjNrqP5_QkwVGTrQ@mail.gmail.com>
	<CAEJX8opP_+qeUGUKOWba1akCbtPQ0tfT6MxmoKR+9p-UZ_-z5w@mail.gmail.com>
	<CAJnwaPEwOaQqCscrfamAbwH4qyxu3N0hg7_F=QEn+ivF7wgFZw@mail.gmail.com>
	<CAEJX8or3k23APwz9tjmhifr5c6LLTGyAs-jxsEmLRo2pQDUOtA@mail.gmail.com>
Message-ID: <CAJnwaPEnorhr5GtJNiMo25y2p4sAbx0qD04O8jzW5+gWQAbiUQ@mail.gmail.com>

Thanks for the comments. Yes I did investigate SSLEngine and the usage was
harder to get things done quickly and not reliable on android. Other then
the ordering problem do you see any other problem with the
cancellingexecutor?


On Sun, Mar 31, 2013 at 6:52 PM, Stanimir Simeonoff <stanimir at riflexo.com>wrote:

> Since 1.5 there is SSLEngine that allows any byte stream to be SSL/TLS
> enabled.
> Admittedly its usage is harder than SSLSockets, though. Yet, allows full
> control of the process.
>
> Stanimir
>
>
>
> On Sun, Mar 31, 2013 at 3:59 PM, Vipin Aravind <vipinarav at gmail.com>wrote:
>
>> I prefer nio but sslsocket is blocking and there is no non blocking
>> equivalent for ssl sockets. My reference is to the point that the read and
>> write to input and ouput streams are not responsive to interruption. For
>> this I use the socketusing task and the cancel helps in closing the socket
>> and read and write to respond with socketexception
>>  On 31 Mar 2013 16:49, "Stanimir Simeonoff" <stanimir at riflexo.com> wrote:
>>
>>>
>>>
>>> On Sun, Mar 31, 2013 at 6:28 AM, Vipin Aravind <vipinarav at gmail.com>wrote:
>>>
>>>> What we have in out tasks are blocking sockets so standard java
>>>> mechamisms shutdown/shutdownNow does not work as they *merely set an
>>>> internal interrupted variable and nothing more*
>>>>
>>> That's not exactly true. I mean that interrupt only sets the flag. It
>>> does call a registered handler that NIO is using it to interrupt selectors.
>>> I've not been using blocking IO for almost 10 years, however it's
>>> possible to handle Thread.interrupt from user space code and this is
>>> usually what I'd do. It's a little known feature of NIO channels.
>>> java.nio.channels.spi.AbstractInterruptibleChannel allows to install a
>>> handler into implCloseChannel(). Basically you implement the method and
>>> wrap it the calls between begin/end. before/afterExecute would be perfect.
>>>
>>> Handling interrupt() allows to remotely close sockets, if need be -
>>> that's the standard interrupt is a lot more powerful, how much you can
>>> decide.
>>>
>>> The posted code has a race between  newTaskFor/execute and shutdown.
>>> super.shutdown/shutdownNow has to be called prior canceling the tasks,
>>> otherwise tasks/sockets on the fly will remain unclosed.
>>>
>>> Stanimir
>>>
>>>
>>>
>>>
>>>> .Refer 7.1.6(dealing with non-interruptible blocking) and
>>>> 7.1.7(Encapsulating nonstandard cancellation with newTaskFor) of JCIP. To
>>>> be truly interrupting, we have to cancel the future which triggers the
>>>> cancel in the SocketUsingTask which closes the underlying socket causing
>>>> the blocking operation to give up. Instead of maintaining the futures
>>>> outside, I track it within the CancellingExecutor using a internal list
>>>> when a new task is submitted. So when the module is brought down I could
>>>> call Cancelling exeuctor's shutdown and my overriden shutdown method will
>>>> internally trigger cancel on the futures.
>>>>
>>>>
>>>> On Sun, Mar 31, 2013 at 1:55 AM, Stanimir Simeonoff <
>>>> stanimir at riflexo.com> wrote:
>>>>
>>>>> I am not sure why you need the list. TPE.getQueue() does almost
>>>>> exactly the same for the tasks that have not been scheduled already. The
>>>>> ones being executed would be notified w/ shutdownNow the just same as
>>>>> cancel(true), i.e. invoking thread.interrupt().
>>>>> More also accessing logging via global lock usually is a big no. You
>>>>> can always log after the synchronized{} block.
>>>>>
>>>>> I merely do not see any benefits of CancellingExecutor compared to the
>>>>> vanilla TPE.
>>>>>
>>>>> Stanimir
>>>>>
>>>>>
>>>>> On Sat, Mar 30, 2013 at 5:59 PM, Vipin Aravind <vipinarav at gmail.com>wrote:
>>>>>
>>>>>> We use the SocketUsingTask in java concurrency in practice(Listing
>>>>>> 7.12)[
>>>>>> http://jcip.net.s3-website-us-east-1.amazonaws.com/listings/SocketUsingTask.java
>>>>>> ] in our production code. I had enhanced the code for our purposes.
>>>>>> We have to run many tasks which make use of blocking socket calls. I
>>>>>> enhanced the CancellingExecutor so that we can track the tasks that are
>>>>>> currently run by cancellingexecutor and when bringing down the system, we
>>>>>> could call the CancellingExecutor?s shutdown which will then loop over  the
>>>>>> task list and call ?cancel? on them. This code has been in production for
>>>>>> an year, but I had like to get the opinion of experts and if there is a
>>>>>> better/nice/cleaner way of doing this.
>>>>>>
>>>>>> Here is the modified CancellingExecutor:-
>>>>>>
>>>>>> *class* CancellingExecutor *extends* ThreadPoolExecutor {
>>>>>>
>>>>>>       *private* *final* List<Object> list;
>>>>>>
>>>>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>>>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>>>>> BlockingQueue<Runnable> workQueue) {
>>>>>>
>>>>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>>>>> workQueue);
>>>>>>
>>>>>>         list = Collections.*synchronizedList*(*new*
>>>>>> ArrayList<Object>(maximumPoolSize));
>>>>>>
>>>>>>     }
>>>>>>
>>>>>>
>>>>>>
>>>>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>>>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>>>>> BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
>>>>>>
>>>>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>>>>> workQueue, threadFactory);
>>>>>>
>>>>>>         list = Collections.*synchronizedList*(*new*
>>>>>> ArrayList<Object>(maximumPoolSize));
>>>>>>
>>>>>>     }
>>>>>>
>>>>>>
>>>>>>
>>>>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>>>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>>>>> BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
>>>>>>
>>>>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>>>>> workQueue, handler);
>>>>>>
>>>>>>         list = Collections.*synchronizedList*(*new*
>>>>>> ArrayList<Object>(maximumPoolSize));
>>>>>>
>>>>>>     }
>>>>>>
>>>>>>
>>>>>>
>>>>>>     *public* CancellingExecutor(*int* corePoolSize, *int*
>>>>>> maximumPoolSize, *long* keepAliveTime, TimeUnit unit,
>>>>>> BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,
>>>>>> RejectedExecutionHandler handler) {
>>>>>>
>>>>>>         *super*(corePoolSize, maximumPoolSize, keepAliveTime, unit,
>>>>>> workQueue, threadFactory, handler);
>>>>>>
>>>>>>        list = Collections.*synchronizedList*(*new*
>>>>>> ArrayList<Object>(maximumPoolSize));
>>>>>>
>>>>>>     }
>>>>>>
>>>>>>
>>>>>>
>>>>>>     *public* *static* ExecutorService newFixedThreadPool(*int* nThreads)
>>>>>> {
>>>>>>
>>>>>>         *return* *new* CancellingExecutor(nThreads, nThreads,
>>>>>>
>>>>>>                                       0L, TimeUnit.*MILLISECONDS*,
>>>>>>
>>>>>>                                       *new*
>>>>>> LinkedBlockingQueue<Runnable>());
>>>>>>
>>>>>>     }
>>>>>>
>>>>>>     *protected* *void* beforeExecute(Thread t, Runnable  r)
>>>>>>
>>>>>>     {
>>>>>>
>>>>>>       *super*.beforeExecute(t, r);
>>>>>>
>>>>>>     }
>>>>>>
>>>>>>     /*
>>>>>>
>>>>>>      * Remove the  task  from  the  list if  it  was  added in
>>>>>> newTaskFor
>>>>>>
>>>>>>      */
>>>>>>
>>>>>>     *protected* *void* afterExecute(Runnable r, Throwable t)
>>>>>>
>>>>>>     {
>>>>>>
>>>>>>       *super*.afterExecute(r, t);
>>>>>>
>>>>>>       *synchronized*(list){
>>>>>>
>>>>>>             *if*(list.remove(r))
>>>>>>
>>>>>>                   Log.*d*("SocketTask", "Connection Count:" +
>>>>>> Integer.*toString*(list.size()));
>>>>>>
>>>>>>             }
>>>>>>
>>>>>>     }
>>>>>>
>>>>>>     /*
>>>>>>
>>>>>>      * newTask  hook.
>>>>>>
>>>>>>      * 1) If  it  is a  *cancellable*  task  add  to  the list.
>>>>>>
>>>>>>      */
>>>>>>
>>>>>>     *protected* <T> RunnableFuture<T> newTaskFor(Callable<T>
>>>>>> callable) {
>>>>>>
>>>>>>             *if* (callable *instanceof* CancellableTask) {
>>>>>>
>>>>>>                   RunnableFuture<T> future = ((CancellableTask<T>)
>>>>>> callable)
>>>>>>
>>>>>>                               .newTask();
>>>>>>
>>>>>>                   *synchronized* (list) {
>>>>>>
>>>>>>                         list.add(future);
>>>>>>
>>>>>>                         Log.*d*("SocketTask", "Connection Count:" +
>>>>>> Integer.*toString*(list.size()));
>>>>>>
>>>>>>                   }
>>>>>>
>>>>>>                   *return* future;
>>>>>>
>>>>>>             } *else*
>>>>>>
>>>>>>                   *return* *super*.newTaskFor(callable);
>>>>>>
>>>>>>       }
>>>>>>
>>>>>>     /*
>>>>>>
>>>>>>      * cancels all  the future tasks. We  need  to  come  out of
>>>>>> blocking socket I/O calls
>>>>>>
>>>>>>      * Interrupt  based  blocking  calls  will  also  come out.
>>>>>>
>>>>>>      * Also shutdown any threads which  we  didn't  account  for  in
>>>>>> the  list(this  should  never  happen)
>>>>>>
>>>>>>      * I have noticed  this  function  being  called  by a
>>>>>> FinalizerDameon(garbage collection??)
>>>>>>
>>>>>> It  appears  harmless  for  now. one  could override  the
>>>>>>
>>>>>>      * finalize  to  get  around  this, but  I  leave  it as  is  as
>>>>>> it  appears  harmless.
>>>>>>
>>>>>>      */
>>>>>>
>>>>>>     *public* *void* shutdown()
>>>>>>
>>>>>>     {
>>>>>>
>>>>>>       Log.*d*("SocketTask", "Start shutting down all connections");//
>>>>>> + Thread.currentThread().getName() + " "+ this.hashCode());
>>>>>>
>>>>>>       *synchronized*(list){
>>>>>>
>>>>>>       *for*(*int*  i = 0; i < list.size(); i++)
>>>>>>
>>>>>>             *((RunnableFuture<Object>)**list**.get(i))*.cancel(*true*
>>>>>> );
>>>>>>
>>>>>>       }
>>>>>>
>>>>>>
>>>>>>
>>>>>>       shutdownNow();
>>>>>>
>>>>>>       /*
>>>>>>
>>>>>>        * Wait  for  no  more  than  5 seconds  for  all  the worker
>>>>>> threads  to  be  done.
>>>>>>
>>>>>>        * the  cancel  in  transport driver will  trigger a
>>>>>> disconnect in  peer  connection inn AppDriver
>>>>>>
>>>>>>        */
>>>>>>
>>>>>>       *try* {
>>>>>>
>>>>>>                   awaitTermination(5, TimeUnit.*SECONDS*);
>>>>>>
>>>>>>             } *catch* (InterruptedException e) {
>>>>>>
>>>>>>             }
>>>>>>
>>>>>>       Log.*d*("SocketTask", "Done shutting down all connections");
>>>>>>
>>>>>>     }
>>>>>>
>>>>>> }
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>
>>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20130331/83358a4b/attachment-0001.html>

