From robertkuhar at yahoo.com  Thu Feb  2 00:54:46 2006
From: robertkuhar at yahoo.com (Robert Kuhar)
Date: Thu Feb  2 00:54:55 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "May fail
	spuriously"?
Message-ID: <20060202055446.27226.qmail@web30612.mail.mud.yahoo.com>

I was strolling through the Docs one day, and came upon the JDK 1.5 Javadocs
for Class java.util.concurrent.atomic.AtomicReference.  The description for the
weakCompareAndSet method confuses me:

  public final boolean weakCompareAndSet(V expect, V update)

  Atomically set the value to the given updated value if the current 
  value == the expected value. May fail spuriously.

  Parameters:
    expect - the expected value
    update - the new value 
  Returns:
    true if successful.

What does "May fail spuriously" mean?  Why would it fail spuriously?  When the
spurious failures occur, is the return value always false?  Why would anyone
call this method having been warned that "spurious failure" is possible?  I
think I'm missing something here.

Bob

__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From dawidk at mathcs.emory.edu  Thu Feb  2 02:53:55 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Thu Feb  2 02:54:08 2006
Subject: [concurrency-interest] backport-util-concurrent v2.0 available
Message-ID: <43E1BA93.7070509@mathcs.emory.edu>

Hello all,

The backport-util-concurrent, version 2.1, is now available:

http://dcl.mathcs.emory.edu/util/backport-util-concurrent/

New version is fully public-domain. It contains new functionality 
recently added to j.u.c., and several important bug fixes.

Enjoy,
Dawid Kurzyniec

From dl at cs.oswego.edu  Thu Feb  2 06:59:05 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu Feb  2 06:59:08 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "May
	fail	spuriously"?
In-Reply-To: <20060202055446.27226.qmail@web30612.mail.mud.yahoo.com>
References: <20060202055446.27226.qmail@web30612.mail.mud.yahoo.com>
Message-ID: <43E1F409.3050407@cs.oswego.edu>

Robert Kuhar wrote:
> I was strolling through the Docs one day, and came upon the JDK 1.5 Javadocs
> for Class java.util.concurrent.atomic.AtomicReference.  The description for the
> weakCompareAndSet method confuses me:
> 
>   public final boolean weakCompareAndSet(V expect, V update)
> 
>   Atomically set the value to the given updated value if the current 
>   value == the expected value. May fail spuriously.
> 
>   Parameters:
>     expect - the expected value
>     update - the new value 
>   Returns:
>     true if successful.
> 
> What does "May fail spuriously" mean?  Why would it fail spuriously?  When the
> spurious failures occur, is the return value always false?  Why would anyone
> call this method having been warned that "spurious failure" is possible?  I
> think I'm missing something here.
> 

See
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/package-summary.html

The javadocs in the atomic package also mention that this form may be more
efficient. (At least on some processors; on most (in fact all supported by
hotspot) it actually compiles to the same code.) The reason that it may be more
efficient is that some processors perform CAS via a pair of Load-linked /
Store-conditional instructions, which may fail if some other processor
happened to write to the same cache line, among other reasons that have
nothing to do with the CAS. In some cases, this is acceptable. On
such processors, a full strong CAS must actually be coded internally
as a loop. There are a handfull of non-blocking algorithms out there
where you don't actually want that loop, so we include this method
so you can avoid it. We expect use of this method to be uncommon.

-Doug
From studdugie at gmail.com  Sat Feb  4 15:06:37 2006
From: studdugie at gmail.com (studdugie)
Date: Sat Feb  4 15:06:46 2006
Subject: [concurrency-interest] RentrantLock performance vs. AtomicInt
Message-ID: <5a59ce530602041206w4b982f2cq1d6c834a6ce8da59@mail.gmail.com>

I recently re-read an IBM publication on the (then) new concurrency
utilities in Java 1.5
[http://www-128.ibm.com/developerworks/edu/j-dw-java-concur-i.html].
In it there was a graph comparing the throughput of AtomicLong vs
synchronized vs RentrantLock. I was surprised to see how quickly the
throughput of AtomicLong dropped as contention increased.

Given that the article is more than a year old I decided to run my own
benchmarks on the latest and greatest JVM to see if the conclusions
suggested by the graph still hold true. Unfortunately, they still do.
My micro benchmark isn't as sophisticated as the IBM's, it simply
computes the sum of 10,000,000 by incrementing an integer from
0-10000000. I've wrote 3 variations. One is protected by a
synchronized block, the other an AtomicInteger and AtomicLong, and
finally a ReentrantLock. I'm having trouble groking why ReentrantLock
is so much faster than the Atomic objects as the number of threads
increase. I looked through the ReentrackLock source and it's built
around similiar CAS calls as the Atomic classes, so why is it so much
faster?

Examples
======
4 Threads:
Atomic: 1sec 279millis 974micro
sync: 1sec 646millis 609micro
Lock: 479millis 566micro

8 Threads:
Atomic: 1sec 202millis 359micro
sync: 2sec 154millis 382micro
Lock: 418millis 975micro

16 Threads:
Atomic:1sec 113millis 365micro
sync: 2sec 19millis 532micro
Lock: 385millis 13micro

All the tests were run on the following platform:
CPU: AMD64 Operteron 270 dual processor/dual core (4CPUS)
RAM: 12GB
OS: GNU/Linux kernel 2.6.14.2
JVM: Java HotSpot 64-Bit Server VM (build 1.5.0_06-b05)

From dl at cs.oswego.edu  Sat Feb  4 16:36:27 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat Feb  4 16:36:33 2006
Subject: [concurrency-interest] RentrantLock performance vs. AtomicInt
In-Reply-To: <5a59ce530602041206w4b982f2cq1d6c834a6ce8da59@mail.gmail.com>
References: <5a59ce530602041206w4b982f2cq1d6c834a6ce8da59@mail.gmail.com>
Message-ID: <43E51E5B.5070400@cs.oswego.edu>

studdugie wrote:
> 
> My micro benchmark isn't as sophisticated as the IBM's, it simply
> computes the sum of 10,000,000 by incrementing an integer from
> 0-10000000. I've wrote 3 variations. One is protected by a
> synchronized block, the other an AtomicInteger and AtomicLong, and
> finally a ReentrantLock. I'm having trouble groking why ReentrantLock
> is so much faster than the Atomic objects as the number of threads
> increase. I looked through the ReentrackLock source and it's built
> around similiar CAS calls as the Atomic classes, so why is it so much
> faster?
> 

It is because all but a tiny fraction of those CAS'es are failing,
and causing the memory system to slosh cache lines around. For locks,
it is better to block some of those threads, so the others can make
progress, and then allow the blocked ones to eventually make progress too.
For things other than locks, other strategies may apply. Stay tuned for
some improvements in java.util.concurrent queues etc along those lines.

BTW, In mustang, you'll find that builtin sync has performance closer
to that of ReentrantLock in programs like this due, to friendly competition
between the hotspot folks and us j.u.c folks.

-Doug
From brian at quiotix.com  Sat Feb  4 16:56:01 2006
From: brian at quiotix.com (Brian Goetz)
Date: Sat Feb  4 16:56:18 2006
Subject: [concurrency-interest] RentrantLock performance vs. AtomicInt
In-Reply-To: <5a59ce530602041206w4b982f2cq1d6c834a6ce8da59@mail.gmail.com>
References: <5a59ce530602041206w4b982f2cq1d6c834a6ce8da59@mail.gmail.com>
Message-ID: <43E522F1.3010602@quiotix.com>

A good way to think of it:
  - Atomics do better at low contention;
  - Locks do better at high contention, because blocking takes the 
current thread out of contention.

With atomics, if you have 16 thread pounding on a memory location, 15 
will lose and one will make progress, but you get a _lot_ of 
synchronization traffic on the memory bus.  With locks, 15 of those 
threads will block, which means they are no longer pounding on the lock, 
and then when the lock is released _one_ will be awakened and allowed to 
proceed.  Its less of a free-for-all, which generates less bus traffic.

But be aware that this sort of pound-on-a-memory-location test is not a 
realistic test for locks vs atomics -- no one uses them in this way. 
Add in some real, thread-local work to your tasks, and you'll see 
Atomics pull ahead.

studdugie wrote:
> I recently re-read an IBM publication on the (then) new concurrency
> utilities in Java 1.5
> [http://www-128.ibm.com/developerworks/edu/j-dw-java-concur-i.html].
> In it there was a graph comparing the throughput of AtomicLong vs
> synchronized vs RentrantLock. I was surprised to see how quickly the
> throughput of AtomicLong dropped as contention increased.
> 
> Given that the article is more than a year old I decided to run my own
> benchmarks on the latest and greatest JVM to see if the conclusions
> suggested by the graph still hold true. Unfortunately, they still do.
> My micro benchmark isn't as sophisticated as the IBM's, it simply
> computes the sum of 10,000,000 by incrementing an integer from
> 0-10000000. I've wrote 3 variations. One is protected by a
> synchronized block, the other an AtomicInteger and AtomicLong, and
> finally a ReentrantLock. I'm having trouble groking why ReentrantLock
> is so much faster than the Atomic objects as the number of threads
> increase. I looked through the ReentrackLock source and it's built
> around similiar CAS calls as the Atomic classes, so why is it so much
> faster?
> 
> Examples
> ======
> 4 Threads:
> Atomic: 1sec 279millis 974micro
> sync: 1sec 646millis 609micro
> Lock: 479millis 566micro
> 
> 8 Threads:
> Atomic: 1sec 202millis 359micro
> sync: 2sec 154millis 382micro
> Lock: 418millis 975micro
> 
> 16 Threads:
> Atomic:1sec 113millis 365micro
> sync: 2sec 19millis 532micro
> Lock: 385millis 13micro
> 
> All the tests were run on the following platform:
> CPU: AMD64 Operteron 270 dual processor/dual core (4CPUS)
> RAM: 12GB
> OS: GNU/Linux kernel 2.6.14.2
> JVM: Java HotSpot 64-Bit Server VM (build 1.5.0_06-b05)
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

From chris.purcell.39 at gmail.com  Sat Feb  4 17:11:11 2006
From: chris.purcell.39 at gmail.com (Chris Purcell)
Date: Sat Feb  4 17:11:19 2006
Subject: [concurrency-interest] RentrantLock performance vs. AtomicInt
In-Reply-To: <5a59ce530602041206w4b982f2cq1d6c834a6ce8da59@mail.gmail.com>
References: <5a59ce530602041206w4b982f2cq1d6c834a6ce8da59@mail.gmail.com>
Message-ID: <54a81d9e50dc1c6fab8b9ed2700942e3@gmail.com>

> I'm having trouble groking why ReentrantLock is so much faster than 
> the Atomic objects as the number of threads increase.

Maybe try adding exponential backoff to those threads that fail their 
CASes, and see if performance improves? You'll probably need to tune it 
a bit.

Chris

From mwh at cs.umd.edu  Mon Feb  6 22:29:38 2006
From: mwh at cs.umd.edu (Michael Hicks)
Date: Mon Feb  6 22:29:10 2006
Subject: [concurrency-interest] Summer School on Language-Based Techniques
	for Concurrent and Distributed Computing
Message-ID: <845B2EEC-4077-480B-B75B-6FEF9617151B@cs.umd.edu>

For any students on this list in particular, I encourage you to consider
attending this summer school on concurrency.  We have a lot of great
speakers, the venue is nice and within the US, and the price is very
reasonable.

Cheers,
-Mike

-------------------------------------------------------------------

                        Call for Participation

                Summer School on Language-Based Techniques
                 for Concurrent and Distributed Software

			   July 12-21, 2006
			 University of Oregon
			  Eugene, Oregon USA

                  Registration Deadline:  March 15, 2006.


        http://www.cs.uoregon.edu/activities/summerschool/summer06/
	    e-mail: summerschool@cs.uoregon.edu

Program
-------
				
This Summer School will cover current research in language-based
techniques for concurrent and distributed software, ranging from
foundational materials on sprinciples, logic and type systems to
advanced techniques for analysis of concurrent software to the
application of these ideas to practical systems.

Material will be presented at a tutorial level that will help graduate
students and researchers from academia or industry understand the
critical issues and open problems confronting the field. The course is
open to anyone interested. Prerequisites are an elementary knowledge
of logic and mathematics that is usually covered in undergraduate
classes on discrete mathematics. Some knowledge of programming
languages at the level provided by an undergraduate survey course will
also be expected. Our primary target group is PhD students. We also
expect attendance by faculty members who would like to conduct
research on this topic or introduce new courses at their universities.

The program consists of more than thirty 80-minute lectures presented
by internationally recognized leaders in programming languages and
security research.  Topics include:

Static Analysis for Concurrency
- Cormac Flanagan, University of California, Santa Cruz

Design and Implementation of Concurrent Systems
- Matthew Flatt, University of Utah

Concurrency in Practice for C
- Jeff Foster, University of Maryland, College Park

Atomicity:  Synchronization via Explicit Software Transactions
- Dan Grossman, University of Washington

Language-Based Techniques for Distributed Systems
- Robert Harper, Carnegie Mellon University

Making Concurrent Software Safer
- Michael Hicks, University of Maryland, College Park

Language Design for Concurrency
- Charles Leiserson, Massachusetts Institute of Technology

Software Model Checking
- Shaz Qadeer, Microsoft Research

Type-Safe and Version-Safe Distributed Programming
- Peter Sewell, University of Cambridge

Architectures for Concurrent Systems
- Sandhya Dwarkadas, University of Rochester

Venue
-----

The summer school will be held at the University of Oregon, located in
the southern Willamette Valley city of Eugene, close to some of the
world's most spectacular beaches, mountains, lakes and forests.  On
Sunday, July 16, students will have the option of participating in a
group activity in Oregon's countryside.


Housing
-------

The school will provide on-campus housing and meals. To share a room
with another student attending the school, the cost is $460.00 (USD)
per person. Housing rates are based on check-in Wednesday, July 12 and
check-out before noon on Saturday, July 22. Some single rooms may be
available for an additional fee of $130.00 (USD). If you'd like a
single room, please indicate your choice and we will try to
accommodate you on a first-come/first-served basis.


Registration
------------

The cost for registration is $200.00 (USD) for graduate students, and
$300.00 (USD) for other participants. Reigstration must be paid upon
acceptance to the summer school, and is non-refundable. There are a
limited number of grants available to fund part of the cost of student
participation.  If you are a graduate student and want to apply for
grant money to cover your expenses, please also include a statement of
your needs with your registration.

Additional information about the program, registration, venue, and
housing options is available on the web site.  Or, you may request
more information by email.

To register for the Summer School, send a CV that includes a short
description of your educational background and one letter of
reference, unless you have already been granted a Ph.D. Please include
your name, address and current academic status.

Send all registration materials to summerschool@cs.uoregon.edu

All registration materials should be delivered to the program by March
15, 2006. Materials received after the closing date will be evaluated
on a space available basis. Non U.S. citizens should begin immediately
to obtain travel documents.


Organizers
----------

Organizing committee: Jeff Foster, Dan Grossman, and Zena Ariola

Sponsors
--------

ACM SIGPLAN

From studdugie at gmail.com  Wed Feb  8 17:51:16 2006
From: studdugie at gmail.com (studdugie)
Date: Wed Feb  8 17:51:27 2006
Subject: [concurrency-interest] synchronized block expansion
Message-ID: <5a59ce530602081451y2e1d0fc4n72d25f541413f436@mail.gmail.com>

I'm not sure I will be breaking a concurrency-interest nettiquette by
posting my question here but I could think of a better place to ask
it, so if I am, scold me gently :)

Here is the code fragment in question:

long wait;
synchronized( timeouts )
{
    if( timeouts.isEmpty() )
        wait = 0;
    else
        timeouts.remove( wait = timeouts.firstLong() );
}

if( 0 == wait )
    semaphore.await();
else
    semaphore.await( wait, EnclosingClass.this.units );

WHERE:
timeouts = long primitive java.util.SortedSet
semaphore = java.util.concurrent.CountDownLatch w/ a count of 1
EnclosingClass.this.units = java.util.concurrent.TimeUnit

I know that code w/i a synchronized block code is not allowed to be
reordered but that doesn't mean that the scope of the synchronized
block can't be expanded.  So my question is, what is the probablity
that Sun's hotspot compiler would expand the synchronized block to
include the semaphore.await() ? Or am I just being paranoid?

Dane

From jmanson at cs.purdue.edu  Wed Feb  8 18:49:12 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Wed Feb  8 18:49:29 2006
Subject: [concurrency-interest] synchronized block expansion
In-Reply-To: <5a59ce530602081451y2e1d0fc4n72d25f541413f436@mail.gmail.com>
References: <5a59ce530602081451y2e1d0fc4n72d25f541413f436@mail.gmail.com>
Message-ID: <43EA8378.1050800@cs.purdue.edu>

Hi,

Although it is legal to expand a synchronized section, it is not legal 
to expand it over another lock acquisition.  That would be bad, for very 
obvious reasons.  You wouldn't, for example, want to introduce of 
deadlock where none previously existed.

Since CountDownLatch.await() is implemented as a lock acquisition, you 
have nothing to worry about.

Having said that, stay paranoid.  Paranoid is good.

					Jeremy

studdugie wrote:
> I'm not sure I will be breaking a concurrency-interest nettiquette by
> posting my question here but I could think of a better place to ask
> it, so if I am, scold me gently :)
> 
> Here is the code fragment in question:
> 
> long wait;
> synchronized( timeouts )
> {
>     if( timeouts.isEmpty() )
>         wait = 0;
>     else
>         timeouts.remove( wait = timeouts.firstLong() );
> }
> 
> if( 0 == wait )
>     semaphore.await();
> else
>     semaphore.await( wait, EnclosingClass.this.units );
> 
> WHERE:
> timeouts = long primitive java.util.SortedSet
> semaphore = java.util.concurrent.CountDownLatch w/ a count of 1
> EnclosingClass.this.units = java.util.concurrent.TimeUnit
> 
> I know that code w/i a synchronized block code is not allowed to be
> reordered but that doesn't mean that the scope of the synchronized
> block can't be expanded.  So my question is, what is the probablity
> that Sun's hotspot compiler would expand the synchronized block to
> include the semaphore.await() ? Or am I just being paranoid?
> 
> Dane
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

From studdugie at gmail.com  Wed Feb  8 19:02:29 2006
From: studdugie at gmail.com (studdugie)
Date: Wed Feb  8 19:02:36 2006
Subject: [concurrency-interest] synchronized block expansion
In-Reply-To: <43EA8378.1050800@cs.purdue.edu>
References: <5a59ce530602081451y2e1d0fc4n72d25f541413f436@mail.gmail.com>
	<43EA8378.1050800@cs.purdue.edu>
Message-ID: <5a59ce530602081602h693f6c79md49cb3d5d87d13ea@mail.gmail.com>

Jeremy said:
   Although it is legal to expand a synchronized section, it is not legal
   to expand it over another lock acquisition.

That was the root of my confusion because I didn't know the JVM knew
that there are other types of locking beside its native monitor
aquisitions. I was concerned that it would see CountDownLatch as just
another class, completely oblivious to what CountDownLatch.await would
do.


On 2/8/06, Jeremy Manson <jmanson@cs.purdue.edu> wrote:
> Hi,
>
> Although it is legal to expand a synchronized section, it is not legal
> to expand it over another lock acquisition.  That would be bad, for very
> obvious reasons.  You wouldn't, for example, want to introduce of
> deadlock where none previously existed.
>
> Since CountDownLatch.await() is implemented as a lock acquisition, you
> have nothing to worry about.
>
> Having said that, stay paranoid.  Paranoid is good.
>
>                                         Jeremy
>
> studdugie wrote:
> > I'm not sure I will be breaking a concurrency-interest nettiquette by
> > posting my question here but I could think of a better place to ask
> > it, so if I am, scold me gently :)
> >
> > Here is the code fragment in question:
> >
> > long wait;
> > synchronized( timeouts )
> > {
> >     if( timeouts.isEmpty() )
> >         wait = 0;
> >     else
> >         timeouts.remove( wait = timeouts.firstLong() );
> > }
> >
> > if( 0 == wait )
> >     semaphore.await();
> > else
> >     semaphore.await( wait, EnclosingClass.this.units );
> >
> > WHERE:
> > timeouts = long primitive java.util.SortedSet
> > semaphore = java.util.concurrent.CountDownLatch w/ a count of 1
> > EnclosingClass.this.units = java.util.concurrent.TimeUnit
> >
> > I know that code w/i a synchronized block code is not allowed to be
> > reordered but that doesn't mean that the scope of the synchronized
> > block can't be expanded.  So my question is, what is the probablity
> > that Sun's hotspot compiler would expand the synchronized block to
> > include the semaphore.await() ? Or am I just being paranoid?
> >
> > Dane
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest@altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From dl at cs.oswego.edu  Thu Feb  9 07:56:24 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu Feb  9 07:56:29 2006
Subject: [concurrency-interest] synchronized block expansion
In-Reply-To: <5a59ce530602081602h693f6c79md49cb3d5d87d13ea@mail.gmail.com>
References: <5a59ce530602081451y2e1d0fc4n72d25f541413f436@mail.gmail.com>	<43EA8378.1050800@cs.purdue.edu>
	<5a59ce530602081602h693f6c79md49cb3d5d87d13ea@mail.gmail.com>
Message-ID: <43EB3BF8.9060403@cs.oswego.edu>

studdugie wrote:
> Jeremy said:
>    Although it is legal to expand a synchronized section, it is not legal
>    to expand it over another lock acquisition.
> 
> That was the root of my confusion because I didn't know the JVM knew
> that there are other types of locking beside its native monitor
> aquisitions. I was concerned that it would see CountDownLatch as just
> another class, completely oblivious to what CountDownLatch.await would
> do.
> 

For the most part, the low-level instruction generation in a JVM
doesn't know much about locks per se, but it must know the memory
model, and the fact volatile/atomic reads and writes (and compareAndSets)
have ordering constraints. So a java.util.concurrent synchronizer
based on atomics etc and a builtin lock (also based on atomics etc, but
using internally generated instructions) are handled in about the
same way, and must work correctly wrt each other.

-Doug

From studdugie at gmail.com  Fri Feb 10 12:35:36 2006
From: studdugie at gmail.com (studdugie)
Date: Fri Feb 10 12:35:42 2006
Subject: [concurrency-interest] A plea to applaud
Message-ID: <5a59ce530602100935n51845d4ei7d645eee41ebd82a@mail.gmail.com>

I just wanted to applaud the jsr166x team for enabling a problem
which, just this instant, materialized for me a better design solution
for some code that I'm writing.

Originally, this email started out as a plea to optimize
ConcurrentSkipListSet's toArray methods, which it doesn't have. It
acquiesces to AbstractCollection. As I drafted the email in my mind I
begun crafting the arguments for why it should be optimized, not by
using theoretical logic (BigO notation), but instead my specific
UseCase. I wanted to drive the point home that toArray means something
to _me_ in the program I'm writing _now_. As I reconstructed in my
mind how the class works and why toArray was a problem for it, it
suddenly dawned on me that there was a better way to do what I was
doing w/o resorting to toArray. With the right dataset the new design
can be +100% faster than the old. So I wanted to thank you, because if
toArray performed half as well as it can I probably never would have
arrived at my new design.

Dane

From philip.lee at logicacmg.com  Fri Feb 17 09:38:54 2006
From: philip.lee at logicacmg.com (Lee, Phil)
Date: Fri Feb 17 09:40:23 2006
Subject: [concurrency-interest] ClockDaemon deadlock in util.concurrent
	1.3.4 ?
Message-ID: <AE96F03DF899344B99F2ADD200A7C6CC46F359@uk-ex007.groupinfra.com>

Hi,

We appear to be getting deadlock within the ClockDaemon class. This only
happen after our application has been running for a number of hours
(typically between 3 and 18).

I'm not sure if I'm reading the stack traces correctly - Thread-17
appears to have aquired the monitor for the ClockDaemon object:

"Thread-17" prio=5 tid=017c3ae8 nid=41 lwp_id=4253774 in Object.wait()
[0x60666000..0x606664f0]
	at java.lang.Object.wait(Native Method)
	at EDU.oswego.cs.dl.util.concurrent.ClockDaemon.nextTask(Unknown
Source)
	- locked <68817bf8> (a
EDU.oswego.cs.dl.util.concurrent.ClockDaemon)
	at
EDU.oswego.cs.dl.util.concurrent.ClockDaemon$RunLoop.run(Unknown Source)
	at java.lang.Thread.run(Thread.java:534)

but it is in the wait() method which means it should have released the
monitor !?! However, there are a number of other threads that are
blocked on aquiring the monitor e.g. : 

"PooledWorkShedulerThread:9" prio=5 tid=0094b750 nid=47 lwp_id=4253780
waiting for monitor entry [0x60360000..0x603604f0]
	at EDU.oswego.cs.dl.util.concurrent.ClockDaemon.restart(Unknown
Source)
	- waiting to lock <68817bf8> (a
EDU.oswego.cs.dl.util.concurrent.ClockDaemon)
	at
EDU.oswego.cs.dl.util.concurrent.ClockDaemon.executeAfterDelay(Unknown
Source)
	at
com.logicacmg.wn.ic.starburst.StarburstTimerSystem.addTimer(StarburstTim
erSystem.java:82)
	...

This seeams just about plausible for an snapshot but I obtained multiple
thread dumps over the following hour and they all show exactly the same
threads waiting on the same ClockDaemon object.

Any thoughts would be much appreciated.

Thanks,

	Phil Lee.

HPUX 11.11  JVM 1.4.2_10 (corresponds to Sun JVM 1.4.2_09)

Full thread dump  [Fri Feb 17 14:10:44 GMT 2006] (Java HotSpot(TM)
Server VM 1.4.2 1.4.2.10-060112-16:07-PA_RISC2.0 PA2.0 (aCC_AP) mixed
mode):

"PooledWorkShedulerThread:10" prio=5 tid=0094b8c0 nid=48 lwp_id=4253781
waiting for monitor entry [0x602df000..0x602df4f0]
	at
com.logicacmg.wn.ic.starburst.event.AccountActivity.work(AccountActivity
.java:39)
	- waiting to lock <6c4c4b20> (a
com.logicacmg.wn.ic.starburst.event.AccountActivity)
	at
com.logicacmg.wn.module.eventprocessing.PooledWorkScheduler$WorkItem.run
(PooledWorkScheduler.java:46)
	at
EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"PooledWorkShedulerThread:9" prio=5 tid=0094b750 nid=47 lwp_id=4253780
waiting for monitor entry [0x60360000..0x603604f0]
	at EDU.oswego.cs.dl.util.concurrent.ClockDaemon.restart(Unknown
Source)
	- waiting to lock <68817bf8> (a
EDU.oswego.cs.dl.util.concurrent.ClockDaemon)
	at
EDU.oswego.cs.dl.util.concurrent.ClockDaemon.executeAfterDelay(Unknown
Source)
	at
com.logicacmg.wn.ic.starburst.StarburstTimerSystem.addTimer(StarburstTim
erSystem.java:82)
	at
com.logicacmg.wn.ic.starburst.StarburstSession.startTimer(StarburstSessi
on.java:310)
	at
com.logicacmg.wn.ic.starburst.StarburstSession.capture(StarburstSession.
java:260)
	at
com.logicacmg.wn.ic.starburst.event.CaptureEvent.run(CaptureEvent.java:6
6)
	at
com.logicacmg.wn.ic.starburst.event.StarburstEvent.execute(StarburstEven
t.java:76)
	at
com.logicacmg.wn.ic.starburst.event.AccountActivity.work(AccountActivity
.java:65)
	- locked <6b0e22c0> (a
com.logicacmg.wn.ic.starburst.event.AccountActivity)
	at
com.logicacmg.wn.module.eventprocessing.PooledWorkScheduler$WorkItem.run
(PooledWorkScheduler.java:46)
	at
EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"PooledWorkShedulerThread:8" prio=5 tid=0094b5e0 nid=46 lwp_id=4253779
waiting for monitor entry [0x603e1000..0x603e14f0]
	at
com.logicacmg.wn.ic.starburst.event.AccountActivity.work(AccountActivity
.java:39)
	- waiting to lock <6b0e22c0> (a
com.logicacmg.wn.ic.starburst.event.AccountActivity)
	at
com.logicacmg.wn.module.eventprocessing.PooledWorkScheduler$WorkItem.run
(PooledWorkScheduler.java:46)
	at
EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"PooledWorkShedulerThread:7" prio=5 tid=0094b470 nid=45 lwp_id=4253778
waiting for monitor entry [0x60462000..0x604624f0]
	at
com.logicacmg.wn.ic.starburst.event.AccountActivity.work(AccountActivity
.java:39)
	- waiting to lock <6b0e22c0> (a
com.logicacmg.wn.ic.starburst.event.AccountActivity)
	at
com.logicacmg.wn.module.eventprocessing.PooledWorkScheduler$WorkItem.run
(PooledWorkScheduler.java:46)
	at
EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"PooledWorkShedulerThread:6" prio=5 tid=0094b300 nid=44 lwp_id=4253777
waiting for monitor entry [0x604e3000..0x604e34f0]
	at EDU.oswego.cs.dl.util.concurrent.ClockDaemon.restart(Unknown
Source)
	- waiting to lock <68817bf8> (a
EDU.oswego.cs.dl.util.concurrent.ClockDaemon)
	at
EDU.oswego.cs.dl.util.concurrent.ClockDaemon.executeAfterDelay(Unknown
Source)
	at
com.logicacmg.wn.ic.starburst.StarburstTimerSystem.addTimer(StarburstTim
erSystem.java:82)
	at
com.logicacmg.wn.ic.starburst.StarburstSession.startTimer(StarburstSessi
on.java:310)
	at
com.logicacmg.wn.ic.starburst.StarburstSession.<init>(StarburstSession.j
ava:141)
	at
com.logicacmg.wn.ic.starburst.event.BeginSessionEvent.run(BeginSessionEv
ent.java:44)
	at
com.logicacmg.wn.ic.starburst.event.StarburstEvent.execute(StarburstEven
t.java:76)
	at
com.logicacmg.wn.ic.starburst.event.AccountActivity.work(AccountActivity
.java:65)
	- locked <6fb4f8b0> (a
com.logicacmg.wn.ic.starburst.event.AccountActivity)
	at
com.logicacmg.wn.module.eventprocessing.PooledWorkScheduler$WorkItem.run
(PooledWorkScheduler.java:46)
	at
EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"PooledWorkShedulerThread:5" prio=5 tid=0094b190 nid=43 lwp_id=4253776
waiting for monitor entry [0x60564000..0x605644f0]
	at
com.logicacmg.wn.ic.starburst.event.AccountActivity.work(AccountActivity
.java:39)
	- waiting to lock <6c4c4b20> (a
com.logicacmg.wn.ic.starburst.event.AccountActivity)
	at
com.logicacmg.wn.module.eventprocessing.PooledWorkScheduler$WorkItem.run
(PooledWorkScheduler.java:46)
	at
EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"Thread-18" prio=5 tid=017c3c58 nid=42 lwp_id=4253775 in Object.wait()
[0x605e5000..0x605e54f0]
	at java.lang.Object.wait(Native Method)
	at java.lang.Object.wait(Object.java:429)
	at
EDU.oswego.cs.dl.util.concurrent.BoundedLinkedQueue.take(Unknown Source)
	- locked <6881a400> (a java.lang.Object)
	at
EDU.oswego.cs.dl.util.concurrent.QueuedExecutor$RunLoop.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"Thread-17" prio=5 tid=017c3ae8 nid=41 lwp_id=4253774 in Object.wait()
[0x60666000..0x606664f0]
	at java.lang.Object.wait(Native Method)
	at EDU.oswego.cs.dl.util.concurrent.ClockDaemon.nextTask(Unknown
Source)
	- locked <68817bf8> (a
EDU.oswego.cs.dl.util.concurrent.ClockDaemon)
	at
EDU.oswego.cs.dl.util.concurrent.ClockDaemon$RunLoop.run(Unknown Source)
	at java.lang.Thread.run(Thread.java:534)

"PooledWorkShedulerThread:4" prio=5 tid=0094b020 nid=40 lwp_id=4253773
waiting for monitor entry [0x606e7000..0x606e74f0]
	at EDU.oswego.cs.dl.util.concurrent.ClockDaemon.restart(Unknown
Source)
	- waiting to lock <68817bf8> (a
EDU.oswego.cs.dl.util.concurrent.ClockDaemon)
	at
EDU.oswego.cs.dl.util.concurrent.ClockDaemon.executeAfterDelay(Unknown
Source)
	at
com.logicacmg.wn.ic.starburst.StarburstTimerSystem.addTimer(StarburstTim
erSystem.java:82)
	at
com.logicacmg.wn.ic.starburst.StarburstSession.startTimer(StarburstSessi
on.java:310)
	at
com.logicacmg.wn.ic.starburst.StarburstSession.reserve(StarburstSession.
java:211)
	at
com.logicacmg.wn.ic.starburst.event.ReserveEvent.run(ReserveEvent.java:6
7)
	at
com.logicacmg.wn.ic.starburst.event.StarburstEvent.execute(StarburstEven
t.java:76)
	at
com.logicacmg.wn.ic.starburst.event.AccountActivity.work(AccountActivity
.java:65)
	- locked <6d6bad90> (a
com.logicacmg.wn.ic.starburst.event.AccountActivity)
	at
com.logicacmg.wn.module.eventprocessing.PooledWorkScheduler$WorkItem.run
(PooledWorkScheduler.java:46)
	at
EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"PooledWorkShedulerThread:3" prio=5 tid=0094aeb0 nid=39 lwp_id=4253772
waiting for monitor entry [0x60768000..0x607684f0]
	at EDU.oswego.cs.dl.util.concurrent.ClockDaemon.restart(Unknown
Source)
	- waiting to lock <68817bf8> (a
EDU.oswego.cs.dl.util.concurrent.ClockDaemon)
	at
EDU.oswego.cs.dl.util.concurrent.ClockDaemon.executeAfterDelay(Unknown
Source)
	at
com.logicacmg.wn.ic.starburst.StarburstTimerSystem.addTimer(StarburstTim
erSystem.java:82)
	at
com.logicacmg.wn.ic.starburst.StarburstSession.startTimer(StarburstSessi
on.java:310)
	at
com.logicacmg.wn.ic.starburst.StarburstSession.reserve(StarburstSession.
java:211)
	at
com.logicacmg.wn.ic.starburst.event.ReserveEvent.run(ReserveEvent.java:6
7)
	at
com.logicacmg.wn.ic.starburst.event.StarburstEvent.execute(StarburstEven
t.java:76)
	at
com.logicacmg.wn.ic.starburst.event.AccountActivity.work(AccountActivity
.java:65)
	- locked <6c4c4b20> (a
com.logicacmg.wn.ic.starburst.event.AccountActivity)
	at
com.logicacmg.wn.module.eventprocessing.PooledWorkScheduler$WorkItem.run
(PooledWorkScheduler.java:46)
	at
EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"Thread-14" prio=5 tid=000a6f58 nid=38 lwp_id=4253771 in Object.wait()
[0x607e9000..0x607e94f0]
	at java.lang.Object.wait(Native Method)
	- waiting on <6881ec08> (a
com.logicacmg.wn.utils.statistics.AbacusStats)
	at com.logicacmg.wn.utils.statistics.Stats.run(Stats.java:221)
	- locked <6881ec08> (a
com.logicacmg.wn.utils.statistics.AbacusStats)
	at java.lang.Thread.run(Thread.java:534)

"Thread-13" prio=5 tid=000a6de8 nid=37 lwp_id=4253770 in Object.wait()
[0x6086a000..0x6086a4f0]
	at java.lang.Object.wait(Native Method)
	- waiting on <6881ec30> (a
com.logicacmg.wn.utils.statistics.StarburstStats)
	at com.logicacmg.wn.utils.statistics.Stats.run(Stats.java:221)
	- locked <6881ec30> (a
com.logicacmg.wn.utils.statistics.StarburstStats)
	at java.lang.Thread.run(Thread.java:534)

"PooledWorkShedulerThread:2" prio=5 tid=0094ad40 nid=36 lwp_id=4253769
waiting for monitor entry [0x608eb000..0x608eb4f0]
	at
com.logicacmg.wn.ic.starburst.event.AccountActivity.work(AccountActivity
.java:39)
	- waiting to lock <6c4c4b20> (a
com.logicacmg.wn.ic.starburst.event.AccountActivity)
	at
com.logicacmg.wn.module.eventprocessing.PooledWorkScheduler$WorkItem.run
(PooledWorkScheduler.java:46)
	at
EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"PooledWorkShedulerThread:1" prio=5 tid=0094abd0 nid=35 lwp_id=4253768
waiting for monitor entry [0x6096c000..0x6096c4f0]
	at
com.logicacmg.wn.ic.starburst.event.AccountActivity.work(AccountActivity
.java:39)
	- waiting to lock <6d6bad90> (a
com.logicacmg.wn.ic.starburst.event.AccountActivity)
	at
com.logicacmg.wn.module.eventprocessing.PooledWorkScheduler$WorkItem.run
(PooledWorkScheduler.java:46)
	at
EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"RequestRouterThread:1" prio=5 tid=01600188 nid=34 lwp_id=4253767 in
Object.wait() [0x609ed000..0x609ed4f0]
	at java.lang.Object.wait(Native Method)
	at java.lang.Object.wait(Object.java:429)
	at EDU.oswego.cs.dl.util.concurrent.LinkedQueue.take(Unknown
Source)
	- locked <68810438> (a java.lang.Object)
	at
EDU.oswego.cs.dl.util.concurrent.QueuedExecutor$RunLoop.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"Thread-8" prio=5 tid=01600018 nid=33 lwp_id=4253766 in Object.wait()
[0x60a6e000..0x60a6e4f0]
	at java.lang.Object.wait(Native Method)
	- waiting on <6881ec58> (a
com.logicacmg.wn.utils.statistics.InpAdaptorTcpStats)
	at com.logicacmg.wn.utils.statistics.Stats.run(Stats.java:221)
	- locked <6881ec58> (a
com.logicacmg.wn.utils.statistics.InpAdaptorTcpStats)
	at java.lang.Thread.run(Thread.java:534)

"Thread-7" prio=5 tid=000a6c78 nid=32 lwp_id=4253765 in Object.wait()
[0x60aef000..0x60aef4f0]
	at java.lang.Object.wait(Native Method)
	- waiting on <6881a430> (a java.lang.Object)
	at java.lang.Object.wait(Object.java:429)
	at EDU.oswego.cs.dl.util.concurrent.LinkedQueue.take(Unknown
Source)
	- locked <6881a430> (a java.lang.Object)
	at
com.logicacmg.wn.ic.statemanagement.IcOperationalStateMachine.run(IcOper
ationalStateMachine.java:68)
	at java.lang.Thread.run(Thread.java:534)

"TariffBrokerClientThread" daemon prio=5 tid=000a6b08 nid=31
lwp_id=4253764 in Object.wait() [0x60b70000..0x60b704f0]
	at java.lang.Object.wait(Native Method)
	at EDU.oswego.cs.dl.util.concurrent.LinkedQueue.poll(Unknown
Source)
	- locked <68818158> (a java.lang.Object)
	at
com.logicacmg.wn.tpbclient.TariffPlanBrokerClient$ClientThread.delayAndP
ollForStop(TariffPlanBrokerClient.java:330)
	at
com.logicacmg.wn.tpbclient.TariffPlanBrokerClient$ClientThread.run(Tarif
fPlanBrokerClient.java:315)

"IC1-vostok-15437" prio=5 tid=000a6998 nid=30 lwp_id=4253763 runnable
[0x60bf1000..0x60bf14f0]
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.read(SocketInputStream.java:134)
	at java.net.SocketInputStream.read(SocketInputStream.java:187)
	at java.io.DataInputStream.readByte(DataInputStream.java:331)
	at
com.logicacmg.wn.inpadaptor.tcp.gateway.InpGatewayConnection.readMessage
(InpGatewayConnection.java:259)
	at
com.logicacmg.wn.inpadaptor.tcp.gateway.InpGatewayConnection.handleReque
stsUntilShutDown(InpGatewayConnection.java:167)
	at
com.logicacmg.wn.inpadaptor.tcp.gateway.InpGatewayConnection.run(InpGate
wayConnection.java:94)

"IC1-vostok-15436" prio=5 tid=000a6828 nid=29 lwp_id=4253762 runnable
[0x60c72000..0x60c724f0]
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.read(SocketInputStream.java:134)
	at java.net.SocketInputStream.read(SocketInputStream.java:187)
	at java.io.DataInputStream.readByte(DataInputStream.java:331)
	at
com.logicacmg.wn.inpadaptor.tcp.gateway.InpGatewayConnection.readMessage
(InpGatewayConnection.java:259)
	at
com.logicacmg.wn.inpadaptor.tcp.gateway.InpGatewayConnection.handleReque
stsUntilShutDown(InpGatewayConnection.java:167)
	at
com.logicacmg.wn.inpadaptor.tcp.gateway.InpGatewayConnection.run(InpGate
wayConnection.java:94)

"Thread-5" daemon prio=5 tid=000a66b8 nid=28 lwp_id=4253756 runnable
[0x60cf3000..0x60cf34f0]
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.read(SocketInputStream.java:134)
	at org.jacorb.orb.etf.StreamConnectionBase.read(Unknown Source)
	at org.jacorb.orb.giop.GIOPConnection.getMessage(Unknown Source)
	at org.jacorb.orb.giop.GIOPConnection.receiveMessages(Unknown
Source)
	at org.jacorb.orb.giop.MessageReceptor.doWork(Unknown Source)
	at org.jacorb.util.threadpool.ConsumerTie.run(Unknown Source)
	at java.lang.Thread.run(Thread.java:534)

"Thread-4" daemon prio=5 tid=000a6548 nid=27 lwp_id=4253755 runnable
[0x60d74000..0x60d744f0]
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.read(SocketInputStream.java:134)
	at org.jacorb.orb.etf.StreamConnectionBase.read(Unknown Source)
	at org.jacorb.orb.giop.GIOPConnection.getMessage(Unknown Source)
	at org.jacorb.orb.giop.GIOPConnection.receiveMessages(Unknown
Source)
	at org.jacorb.orb.giop.MessageReceptor.doWork(Unknown Source)
	at org.jacorb.util.threadpool.ConsumerTie.run(Unknown Source)
	at java.lang.Thread.run(Thread.java:534)

"Thread-3" prio=5 tid=000a63d8 nid=26 lwp_id=4253749 in Object.wait()
[0x60df5000..0x60df54f0]
	at java.lang.Object.wait(Native Method)
	- waiting on <6882fa30> (a
com.logicacmg.wn.utils.statistics.EdrClientStats)
	at com.logicacmg.wn.utils.statistics.Stats.run(Stats.java:221)
	- locked <6882fa30> (a
com.logicacmg.wn.utils.statistics.EdrClientStats)
	at java.lang.Thread.run(Thread.java:534)

"RequestController-1" daemon prio=10 tid=000a6268 nid=24 lwp_id=4253746
in Object.wait() [0x60ef7000..0x60ef74f0]
	at java.lang.Object.wait(Native Method)
	- waiting on <68829e20> (a java.lang.Object)
	at java.lang.Object.wait(Object.java:429)
	at org.jacorb.poa.RequestController.waitForQueue(Unknown Source)
	- locked <68829e20> (a java.lang.Object)
	at org.jacorb.poa.RequestController.run(Unknown Source)

"Thread-1" daemon prio=5 tid=000a60f8 nid=23 lwp_id=4253744 runnable
[0x60f78000..0x60f784f0]
	at java.net.PlainSocketImpl.socketAccept(Native Method)
	at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:353)
	- locked <68834530> (a java.net.PlainSocketImpl)
	at java.net.ServerSocket.implAccept(ServerSocket.java:454)
	at java.net.ServerSocket.accept(ServerSocket.java:425)
	at org.jacorb.orb.iiop.IIOPListener$Acceptor.run(Unknown Source)

"Thread-0" prio=5 tid=000a5f88 nid=22 lwp_id=4253739 in Object.wait()
[0x60ff9000..0x60ff94f0]
	at java.lang.Object.wait(Native Method)
	- waiting on <68829e40> (a java.lang.Object)
	at java.lang.Object.wait(Object.java:429)
	at org.jacorb.orb.ORB.run(Unknown Source)
	- locked <68829e40> (a java.lang.Object)
	at
com.logicacmg.wn.ic.corba.context.RunningState$1.run(RunningState.java:4
8)
	at
EDU.oswego.cs.dl.util.concurrent.QueuedExecutor$RunLoop.run(Unknown
Source)
	at java.lang.Thread.run(Thread.java:534)

"Signal Dispatcher" daemon prio=10 tid=000a5b38 nid=17 lwp_id=4253716
waiting on condition [0x00000000..0xffffffff]

"Surrogate Locker Thread (CMS)" daemon prio=5 tid=000a59c8 nid=15
lwp_id=4253714 waiting on condition [0x00000000..0x6450e284]

"Finalizer" daemon prio=8 tid=000a5858 nid=14 lwp_id=4253708 in
Object.wait() [0x6458f000..0x6458f4f0]
	at java.lang.Object.wait(Native Method)
	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:127)
	- locked <6881a440> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)
	at
java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:188)

"Reference Handler" daemon prio=10 tid=000a56e8 nid=13 lwp_id=4253706 in
Object.wait() [0x64610000..0x646104f0]
	at java.lang.Object.wait(Native Method)
	- waiting on <688180a8> (a java.lang.ref.Reference$Lock)
	at java.lang.Object.wait(Object.java:429)
	at
java.lang.ref.Reference$ReferenceHandler.run(Reference.java:120)
	- locked <688180a8> (a java.lang.ref.Reference$Lock)

"main" prio=5 tid=000a5578 nid=1 lwp_id=4253671 waiting on condition
[0x7f7fb000..0x7f7fb7e0]
	at java.lang.Thread.sleep(Native Method)
	at com.logicacmg.wn.ic.IcMain.waitForExit(IcMain.java:81)
	at com.logicacmg.wn.ic.IcMain.main(IcMain.java:328)

"VM Thread" prio=5 tid=000167d0 nid=12 lwp_id=4253705 runnable 

"VM Periodic Task Thread" prio=10 tid=00016aa0 nid=21 lwp_id=4253720
waiting on condition 
"Suspend Checker Thread" prio=10 tid=00016a10 nid=16 lwp_id=4253715
runnable 


This e-mail and any attachment is for authorised use by the intended recipient(s) only. It may contain proprietary material, confidential information and/or be subject to legal privilege. It should not be copied, disclosed to, retained or used by, any other party. If you are not an intended recipient then please promptly delete this e-mail and any attachment and all copies and inform the sender. Thank you.

From yechielf at gigaspaces.com  Mon Feb 20 08:15:50 2006
From: yechielf at gigaspaces.com (Yechiel Feffer)
Date: Mon Feb 20 07:04:06 2006
Subject: [concurrency-interest] a  question regarding nested synchronized()
Message-ID: <D166C96F43D1D611B8E3000255A0C48C6BE885@OFFICESRV>

Hi

Say a Thread  does:===========

synchronized(objectA)
{
....Something

  synchronized(objectB)
  {
....Something

   objectB.wait()

  }
}

  my questions:

1. is the command  objectB.wait();, which is called by the thread  ,
releasing the lock on object A too, or does objectA remains locked
   since it is not the monitor used for the wait() ?  (My guess is that
objectA remains locked)
2. If the answer to 1. is yes,  in which order are the locks released ?

Regrds,
Yechiel Fefer  


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060220/3b626d89/attachment.html
From Paula.Mangas at fct.unl.pt  Mon Feb 20 08:47:38 2006
From: Paula.Mangas at fct.unl.pt (Paula Mangas)
Date: Mon Feb 20 08:47:57 2006
Subject: [concurrency-interest] a question regarding nested synchronized()
In-Reply-To: <D166C96F43D1D611B8E3000255A0C48C6BE885@OFFICESRV>
Message-ID: <200602201347.k1KDlpq0014546@cs.oswego.edu>

 

Yechiel Fefer,

 

( 1 ) objectA remains locked.

( 2 ) the locks are released in the opposite order that the they were made;
that means, using this kind of synchronization, you will always have
something like this:

 

Lock A

   Lock B

      Lock C

      Unlock C

   Unlock B

Unlock A

 

Best regards,

Paula Mangas

 

  _____  

From: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu] On Behalf Of Yechiel
Feffer
Sent: segunda-feira, 20 de Fevereiro de 2006 13:16
To: concurrency-interest@cs.oswego.edu
Subject: [concurrency-interest] a question regarding nested synchronized()

 

Hi 

Say a Thread  does:=========== 

synchronized(objectA) 
{ 
....Something 

  synchronized(objectB) 
  { 
....Something 

   objectB.wait() 

  } 
} 

  my questions: 

1. is the command  objectB.wait();, which is called by the thread  ,
releasing the lock on object A too, or does objectA remains locked

   since it is not the monitor used for the wait() ?  (My guess is that
objectA remains locked) 
2. If the answer to 1. is yes,  in which order are the locks released ? 

Regrds, 
Yechiel Fefer  

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060220/fa41e4e6/attachment.html
From cau at aspecthuntley.com.au  Tue Feb 28 19:00:45 2006
From: cau at aspecthuntley.com.au (Christopher Kin Chung Au)
Date: Tue Feb 28 19:17:27 2006
Subject: [concurrency-interest] cancelling future
Message-ID: <62E9031181B7CF41A5C90F9CAB1225D102715EFE@ahmail.aspecthuntley.local>

Hi,

 

Currently I have an application which sends out bulk email we use the
ExecutorService submit to get a future object back which we store. This
future object holds many other future objects which are the actual
workers that send out the email. The intention is that we will
potentially have many bulk email future objects which in turn hold many
email future objects sending out the emails. We want to be able to
choose and cancel a designated bulk email future object which in turn
stops all the email future objects associated with that bulk email
future object while the other bulk email future objects remain intact. I
have used the cancel command but whilst the bulk email future object
reports that it has been cancelled the email future objects seem to
continue to run. I hope this makes sense and any help would be
appreciated. 

 

Thanks

 

Chris

 

PS the email future objects are created using executorservice.submit.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060228/676c9649/attachment.html
From joe.bowbeer at gmail.com  Tue Feb 28 20:01:24 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue Feb 28 20:01:29 2006
Subject: [concurrency-interest] cancelling future
In-Reply-To: <62E9031181B7CF41A5C90F9CAB1225D102715EFE@ahmail.aspecthuntley.local>
References: <62E9031181B7CF41A5C90F9CAB1225D102715EFE@ahmail.aspecthuntley.local>
Message-ID: <31f2a7bd0602281701v67db221s6fd8fa1537cb3160@mail.gmail.com>

If you Future impl. can query isCancelled if that would help it be
more responsive to cancellation.  But that probably isn't your
question.

The most common method for cleaning up inside a Future after
cancellation is to override the done method (of FutureTask).  If
isCancelled is true here, then cancel the Futures that are dependent
on yours.

On 2/28/06, Christopher Kin Chung Au <cau@aspecthuntley.com.au> wrote:
>
> Currently I have an application which sends out bulk email we use the
> ExecutorService submit to get a future object back which we store. This
> future object holds many other future objects which are the actual workers
> that send out the email. The intention is that we will potentially have many
> bulk email future objects which in turn hold many email future objects
> sending out the emails. We want to be able to choose and cancel a designated
> bulk email future object which in turn stops all the email future objects
> associated with that bulk email future object while the other bulk email
> future objects remain intact. I have used the cancel command but whilst the
> bulk email future object reports that it has been cancelled the email future
> objects seem to continue to run. I hope this makes sense and any help would
> be appreciated.
>

From joe.bowbeer at gmail.com  Tue Feb 28 20:02:43 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue Feb 28 20:02:46 2006
Subject: [concurrency-interest] cancelling future
In-Reply-To: <31f2a7bd0602281701v67db221s6fd8fa1537cb3160@mail.gmail.com>
References: <62E9031181B7CF41A5C90F9CAB1225D102715EFE@ahmail.aspecthuntley.local>
	<31f2a7bd0602281701v67db221s6fd8fa1537cb3160@mail.gmail.com>
Message-ID: <31f2a7bd0602281702s72619e55uc2c4af084aca58e8@mail.gmail.com>

I meant to write:

Your Future impl. can query isCancelled if that would help it be more
responsive to cancellation.

On 2/28/06, Joe Bowbeer <joe.bowbeer@gmail.com> wrote:
> If you Future impl. can query isCancelled if that would help it be
> more responsive to cancellation.  But that probably isn't your
> question.
>
> The most common method for cleaning up inside a Future after
> cancellation is to override the done method (of FutureTask).  If
> isCancelled is true here, then cancel the Futures that are dependent
> on yours.
>
> On 2/28/06, Christopher Kin Chung Au <cau@aspecthuntley.com.au> wrote:
> >
> > Currently I have an application which sends out bulk email we use the
> > ExecutorService submit to get a future object back which we store. This
> > future object holds many other future objects which are the actual workers
> > that send out the email. The intention is that we will potentially have many
> > bulk email future objects which in turn hold many email future objects
> > sending out the emails. We want to be able to choose and cancel a designated
> > bulk email future object which in turn stops all the email future objects
> > associated with that bulk email future object while the other bulk email
> > future objects remain intact. I have used the cancel command but whilst the
> > bulk email future object reports that it has been cancelled the email future
> > objects seem to continue to run. I hope this makes sense and any help would
> > be appreciated.
> >
>

