From forax at univ-mlv.fr  Wed Aug  2 09:33:26 2006
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Wed, 02 Aug 2006 15:33:26 +0200
Subject: [concurrency-interest] concurrency errors in java.lang.Throwable
Message-ID: <44D0A9A6.2040105@univ-mlv.fr>

I think i've found a concurrency bug in the Sun implementation
of java.lang.Throwable.

Since 1.4, Throwable accepts a cause at construction time
using a ad hoc constructors or after if initilialisation using
the method initCause().

First, the field can't be final and is not volatile, the method 
getCause() is not
synchronized and  doesn't use a lock, so a thread can create an exception
with a cause and another thread can see the same exception without
a cause.

Second, initCause is synchronized but getCause() is not, so a thread
can call initCause() and another thread never see the change.

Am i right ?

Should the field that store the cause be volatile and use
a CAS in initCause() to initialize the cause (the cause can't be
initialized twice) ?

R?mi Forax




From mike.quilleash at subexazure.com  Wed Aug  2 10:59:57 2006
From: mike.quilleash at subexazure.com (Mike Quilleash )
Date: Wed, 2 Aug 2006 10:59:57 -0400
Subject: [concurrency-interest] Setting the name of a Thread
Message-ID: <DAE04D9F6FD21448A220918A522FB60E0275594D@MI8NYCMAIL15.Mi8.com>

I have a ThreadPoolExecutor that runs an arbitrary number of
housekeeping tasks in a system.  Each of these tasks implements an
interface extends Runnable and has getName().  I want to submit each of
these to the executor and have the name of the thread set to the
getName().
 
I thought I could just use a custom ThreadFactory and cast the Runnable
but it seems the ThreadPool implementation wraps each Runnable up in a
Worker inner class that I can't get my Runnable out of.
 
So I extended ThreadPoolExecutor and used the beforeExecute() hook which
has my Runnable in it so I can cast out and change the thread name.
This worked fine.
 
Later on I decided to wrap up the Executor with a
ExecutorCompletionService so I could trap any of these housekeeper tasks
terminating early and report that in an error log.  But adding the
CompletionService has now add another wrapper around my Runnable (the
QueuedFuture that ECS uses) so my code in beforeExecute() broke with a
ClassCastException.  I thought about storing the future result of
ECS.submit -> my Runnable but it's then possible for the beforeExecute()
to run before I've added the result to the map.
 
I ended up implementing ECS myself and storing a map of custom
QueuedFuture -> Runnable and then doing the lookup in beforeExecute() to
get my Runnable and therefore the thread name.
 
Is there any way or working around this as I've basically copied ECS out
into my own code so I can create the FutureTask and add it to a map
before it can be executed by the ThreadPool?
 
Any suggestions appreciated.
 

 This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060802/10e7e441/attachment.html 

From matthias.ernst at coremedia.com  Wed Aug  2 11:24:40 2006
From: matthias.ernst at coremedia.com (Ernst, Matthias)
Date: Wed, 2 Aug 2006 17:24:40 +0200
Subject: [concurrency-interest] Setting the name of a Thread
Message-ID: <9DC7096A2275564C9E2CF5042569976D1ACC2B@hermes.coremedia.com>

> I have a ThreadPoolExecutor that runs an arbitrary number of 
> housekeeping tasks in a system.  Each of these tasks 
> implements an interface extends Runnable and has getName().  
> I want to submit each of these to the executor and have the 
> name of the thread set to the getName().

Why don't you submit wrappers that implement the name-setting?

execute(final NamedRunnable namedRunnable) {
  tpe.execute(new Runnable() {
    public void run() {
      Thread t = Thread.currentThread();
      String oldName = t.getName();
      t.setName(namedRunnable.getName());
      try {
        namedRunnable.run();
      } finally {
        t.setName(oldName);
      }
    }
  });
}

Matthias


From mike.quilleash at subexazure.com  Wed Aug  2 12:57:12 2006
From: mike.quilleash at subexazure.com (Mike Quilleash )
Date: Wed, 2 Aug 2006 12:57:12 -0400
Subject: [concurrency-interest] Setting the name of a Thread
Message-ID: <DAE04D9F6FD21448A220918A522FB60E02755ACA@MI8NYCMAIL15.Mi8.com>

Thanks.

That's a lot better and neater than what I had.  I've put the proper ECS
back in and it all works perfectly.

Cheers.

-----Original Message-----
From: Ernst, Matthias [mailto:matthias.ernst at coremedia.com] 
Sent: 02 August 2006 16:25
To: Mike Quilleash ; concurrency-interest at cs.oswego.edu
Subject: AW: [concurrency-interest] Setting the name of a Thread

> I have a ThreadPoolExecutor that runs an arbitrary number of 
> housekeeping tasks in a system.  Each of these tasks implements an 
> interface extends Runnable and has getName().
> I want to submit each of these to the executor and have the name of 
> the thread set to the getName().

Why don't you submit wrappers that implement the name-setting?

execute(final NamedRunnable namedRunnable) {
  tpe.execute(new Runnable() {
    public void run() {
      Thread t = Thread.currentThread();
      String oldName = t.getName();
      t.setName(namedRunnable.getName());
      try {
        namedRunnable.run();
      } finally {
        t.setName(oldName);
      }
    }
  });
}

Matthias


 This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html



From joe.bowbeer at gmail.com  Wed Aug  2 12:59:42 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 2 Aug 2006 09:59:42 -0700
Subject: [concurrency-interest] concurrency errors in java.lang.Throwable
In-Reply-To: <44D0A9A6.2040105@univ-mlv.fr>
References: <44D0A9A6.2040105@univ-mlv.fr>
Message-ID: <31f2a7bd0608020959v2630fc3dnc8344a643e152a78@mail.gmail.com>

On 8/2/06, R?mi Forax <forax at univ-mlv.fr> wrote:
> I think i've found a concurrency bug in the Sun implementation
> of java.lang.Throwable.
>
> Since 1.4, Throwable accepts a cause at construction time
> using a ad hoc constructors or after if initilialisation using
> the method initCause().
>
> First, the field can't be final and is not volatile, the method
> getCause() is not
> synchronized and  doesn't use a lock, so a thread can create an
> exception with a cause and another thread can see the same
> exception without a cause.
>
> Second, initCause is synchronized but getCause() is not, so a thread
> can call initCause() and another thread never see the change.
>
> Am i right ?
>
> Should the field that store the cause be volatile and use
> a CAS in initCause() to initialize the cause (the cause can't be
> initialized twice) ?
>
> R?mi Forax
>

I noticed the same thing a short while ago and discussed it with the
experts.  A summary of that discussion follows.

David Holmes writes:

  "Being safely publishable even when published without
synchronization goes a step beyond basic thread-safety. That is not
the general expectation from a thread-safe class. Yes the publishing
aspect is subtle and most people don't get it until they read
something like JCiP, but it is a classic concurrency problem: the
variable to which the object is published is a shared, mutable
variable - hence access to it requires synchronization.

I don't think we should be expending effort trying to make thread-safe
classes publishable without synchronization.(*) Rather we need to
educate because no matter what we do with JDK classes the programmer
will still screw up their own if they don't understand the issues."

(*) An exception is made for classes like String that are involved in
security.  These must be publishable without synchronization.  Or,
rather, unsafe publication of these classes must not represent a
security vulnerability.

David Holmes again:

  "As far as I can see with unsafe publication (and synchronized
getCause) the worst that can happen is you will see no-cause when
there should be one. Even if you see the default initialized cause
value that will be null and getCause will return null. We don't try to
make this work for other mutable classes so I don't see why Throwable
needs to be special. In the few scenarios where I can imagine passing
Throwables across threads, the Throwable isn't mutated after being
thrown, and the exchange between threads will involve
synchronization."


We decided that it would be an improvement (for clarity as much as
anything) if detailMessage were declared final.

One could also argue for synchronizing getCause, since all the other
setter/getter methods are, though, as far as we know, the
synchronization of initCause is only supposed to be preventing
multiple threads from calling that method simultaneously.  It's
supposed to be "call-once".

Are we overlooking a security vulnerability?


As an exercise, we sketched a Throwable implementation that would be
"safe" for un-safe publication:

public class Throwable {

  private final AtomicReference<Throwable> causeRef =
     new AtomicReference<Throwable>(this);

  public Throwable getCause() {
     Throwable t = causeRef.get();
     return (t == this ? null : t);
 }

  public Throwable initCause(Throwable cause) {
     if (cause == this)
         throw new IllegalArgumentException("Self-causation not permitted");
    if (!causeRef.compareAndSet(this, cause))
      throw new IllegalArgumentException("Can't overwrite cause");
  }
}

We thought it was a good, concise example of a thread-safe one-shot --
but that it was overkill in this situation...

--Joe


From gergg at cox.net  Wed Aug  2 13:57:46 2006
From: gergg at cox.net (Gregg Wonderly)
Date: Wed, 02 Aug 2006 12:57:46 -0500
Subject: [concurrency-interest] concurrency errors in java.lang.Throwable
In-Reply-To: <31f2a7bd0608020959v2630fc3dnc8344a643e152a78@mail.gmail.com>
References: <44D0A9A6.2040105@univ-mlv.fr>
	<31f2a7bd0608020959v2630fc3dnc8344a643e152a78@mail.gmail.com>
Message-ID: <44D0E79A.4090406@cox.net>

Joe Bowbeer wrote:
> I noticed the same thing a short while ago and discussed it with the
> experts.  A summary of that discussion follows.

> We thought it was a good, concise example of a thread-safe one-shot --
> but that it was overkill in this situation...

Typically causes are used in environments that are 'complicated'.  Either the 
method can't return an exception and it is wrapped and thrown, or a thread 
encounters a problem and publishes information about that problem while 
continuing to make whatever progress it can.

In either case, I think there is considerable information to be gained from 
making sure that the cause is available.  I think that there is some merit to 
Dougs thoughts that there will eventually be a synchronized piece of code that 
runs and forces the visibility.

This is one of the primary issues that developers in MP systems will fight with. 
  So, education is an important thing.  But, I also think that it will be 
important for core classes to provide a highlevel of correctness garantees which 
will make sure that developers get the right information for diagnosing the 
problems that they are having.

Gregg Wonderly

From brian at quiotix.com  Wed Aug  2 15:18:17 2006
From: brian at quiotix.com (Brian Goetz)
Date: Wed, 02 Aug 2006 15:18:17 -0400
Subject: [concurrency-interest] concurrency errors in java.lang.Throwable
In-Reply-To: <44D0E79A.4090406@cox.net>
References: <44D0A9A6.2040105@univ-mlv.fr>	<31f2a7bd0608020959v2630fc3dnc8344a643e152a78@mail.gmail.com>
	<44D0E79A.4090406@cox.net>
Message-ID: <44D0FA79.9070502@quiotix.com>

> In either case, I think there is considerable information to be gained from 
> making sure that the cause is available.  I think that there is some merit to 
> Dougs thoughts that there will eventually be a synchronized piece of code that 
> runs and forces the visibility.

JCiP coins the term "effectively immutable" for describing objects like 
this -- they don't meet the definition of immutability, but they are 
treated as if they were immutable forward from some point in time, and 
this point is prior to publication.  For effectively immutable objects, 
it is safe to use them without synchronization as long as they are 
published (once) with synchronization.

From gregg at cytetech.com  Wed Aug  2 16:49:46 2006
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 02 Aug 2006 15:49:46 -0500
Subject: [concurrency-interest] concurrency errors in java.lang.Throwable
In-Reply-To: <44D0FA79.9070502@quiotix.com>
References: <44D0A9A6.2040105@univ-mlv.fr>	<31f2a7bd0608020959v2630fc3dnc8344a643e152a78@mail.gmail.com>	<44D0E79A.4090406@cox.net>
	<44D0FA79.9070502@quiotix.com>
Message-ID: <44D10FEA.8090403@cytetech.com>



Brian Goetz wrote:
>>In either case, I think there is considerable information to be gained from 
>>making sure that the cause is available.  I think that there is some merit to 
>>Dougs thoughts that there will eventually be a synchronized piece of code that 
>>runs and forces the visibility.
> 
> 
> JCiP coins the term "effectively immutable" for describing objects like 
> this -- they don't meet the definition of immutability, but they are 
> treated as if they were immutable forward from some point in time, and 
> this point is prior to publication.  For effectively immutable objects, 
> it is safe to use them without synchronization as long as they are 
> published (once) with synchronization.

Yes, and that's my point.  It's important for some of these core things to 
happen 'safely' so that developers are not sidetracked by the same, constantly 
recurring behavior which is difficult to track down.

Maybe I missed something.  Is it felt that there's no real value in 
synchronizing getCause() because subclasses might override it and not 
synchronize?  Is there a feeling that synchronizing getCause() would place some 
undue burden on JVM performance?

Gregg Wonderly

From joe.bowbeer at gmail.com  Wed Aug  2 17:00:14 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 2 Aug 2006 14:00:14 -0700
Subject: [concurrency-interest] concurrency errors in java.lang.Throwable
In-Reply-To: <44D10FEA.8090403@cytetech.com>
References: <44D0A9A6.2040105@univ-mlv.fr>
	<31f2a7bd0608020959v2630fc3dnc8344a643e152a78@mail.gmail.com>
	<44D0E79A.4090406@cox.net> <44D0FA79.9070502@quiotix.com>
	<44D10FEA.8090403@cytetech.com>
Message-ID: <31f2a7bd0608021400v3234cbe1n548dd91b4681ef87@mail.gmail.com>

On 8/2/06, Gregg Wonderly <gregg at cytetech.com> wrote:
>
> Maybe I missed something.  Is it felt that there's no real value in
> synchronizing getCause() because subclasses might override it and not
> synchronize?  Is there a feeling that synchronizing getCause() would
> place some undue burden on JVM performance?
>

It would be desirable to:

1. Declare detailMessage final
2. Make getCause synchronized
3. Most of all: document intent so we don't need to have these discussions

From gergg at cox.net  Wed Aug  2 17:09:24 2006
From: gergg at cox.net (Gregg Wonderly)
Date: Wed, 02 Aug 2006 16:09:24 -0500
Subject: [concurrency-interest] concurrency errors in java.lang.Throwable
In-Reply-To: <31f2a7bd0608021400v3234cbe1n548dd91b4681ef87@mail.gmail.com>
References: <44D0A9A6.2040105@univ-mlv.fr>	<31f2a7bd0608020959v2630fc3dnc8344a643e152a78@mail.gmail.com>	<44D0E79A.4090406@cox.net>
	<44D0FA79.9070502@quiotix.com>	<44D10FEA.8090403@cytetech.com>
	<31f2a7bd0608021400v3234cbe1n548dd91b4681ef87@mail.gmail.com>
Message-ID: <44D11484.5010708@cox.net>

Joe Bowbeer wrote:
> On 8/2/06, Gregg Wonderly <gregg at cytetech.com> wrote:
> 
>>Maybe I missed something.  Is it felt that there's no real value in
>>synchronizing getCause() because subclasses might override it and not
>>synchronize?  Is there a feeling that synchronizing getCause() would
>>place some undue burden on JVM performance?
>
> It would be desirable to:
> 
> 1. Declare detailMessage final
> 2. Make getCause synchronized
> 3. Most of all: document intent so we don't need to have these discussions

Okay, that sounds like a good plan to me :-)

Gregg Wonderly

From dhanji at gmail.com  Wed Aug  2 20:25:11 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 3 Aug 2006 10:25:11 +1000
Subject: [concurrency-interest] concurrency errors in java.lang.Throwable
In-Reply-To: <44D11484.5010708@cox.net>
References: <44D0A9A6.2040105@univ-mlv.fr>
	<31f2a7bd0608020959v2630fc3dnc8344a643e152a78@mail.gmail.com>
	<44D0E79A.4090406@cox.net> <44D0FA79.9070502@quiotix.com>
	<44D10FEA.8090403@cytetech.com>
	<31f2a7bd0608021400v3234cbe1n548dd91b4681ef87@mail.gmail.com>
	<44D11484.5010708@cox.net>
Message-ID: <aa067ea10608021725j723093bdn47e1b819aa31ffe6@mail.gmail.com>

This is purely hypothetical (and probably not feasible), but if the
cause is effectively immutable (after being set) and getCause()'s
contract is to only ever return the cause, is there a problem with
making it synchronized and final?

Obviously it would break backwards compat but maybe something like a
SafeThrowable?

On 8/3/06, Gregg Wonderly <gergg at cox.net> wrote:
> Joe Bowbeer wrote:
> > On 8/2/06, Gregg Wonderly <gregg at cytetech.com> wrote:
> >
> >>Maybe I missed something.  Is it felt that there's no real value in
> >>synchronizing getCause() because subclasses might override it and not
> >>synchronize?  Is there a feeling that synchronizing getCause() would
> >>place some undue burden on JVM performance?
> >
> > It would be desirable to:
> >
> > 1. Declare detailMessage final
> > 2. Make getCause synchronized
> > 3. Most of all: document intent so we don't need to have these discussions
>
> Okay, that sounds like a good plan to me :-)
>
> Gregg Wonderly
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dcholmes at optusnet.com.au  Wed Aug  2 22:04:50 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Thu, 3 Aug 2006 12:04:50 +1000
Subject: [concurrency-interest] concurrency errors in java.lang.Throwable
In-Reply-To: <31f2a7bd0608021400v3234cbe1n548dd91b4681ef87@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEOKHAAA.dcholmes@optusnet.com.au>

Joe,

> It would be desirable to:
>
> 1. Declare detailMessage final
> 2. Make getCause synchronized
> 3. Most of all: document intent so we don't need to have these discussions

getCause being synchronized would only be sufficient if the constructor used
the synchronized initCause() - otherwise we'd need a volatile, or atomics or
...

But to repeat what I've said elsewhere I don't expect Throwables to be
passed across threads very often. And if they are passed across threads then
that mechanism will need to involve synchronization. Hence access to the
cause would be safe.

I think this is a non-issue, but might support "fixing" it purely for reason
3. Only trouble is today it is Throwable tomorrow  its ...

Cheers,
David Holmes


From forax at univ-mlv.fr  Thu Aug  3 08:10:50 2006
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Thu, 03 Aug 2006 14:10:50 +0200
Subject: [concurrency-interest] concurrency errors in java.lang.Throwable
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEOKHAAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCAEOKHAAA.dcholmes@optusnet.com.au>
Message-ID: <44D1E7CA.2030408@univ-mlv.fr>

David Holmes a ?crit :
> Joe,
> 
>> It would be desirable to:
>>
>> 1. Declare detailMessage final
>> 2. Make getCause synchronized
>> 3. Most of all: document intent so we don't need to have these discussions
> 
> getCause being synchronized would only be sufficient if the constructor used
> the synchronized initCause() - otherwise we'd need a volatile, or atomics or
> ...
> 
> But to repeat what I've said elsewhere I don't expect Throwables to be
> passed across threads very often. And if they are passed across threads then
> that mechanism will need to involve synchronization. Hence access to the
> cause would be safe.
> 
> I think this is a non-issue, but might support "fixing" it purely for reason
> 3. Only trouble is today it is Throwable tomorrow  its ...
> 
> Cheers,
> David Holmes

I've a test case that shows the bug :

public class ThrowableConcurrencyBug {
   public static void initCause(Throwable t) {
     t.initCause(new Throwable());
   }

   public static void main(String[] args) {
     final Throwable t=new Throwable();
     new Thread() {
       @Override
       public void run() {
         for(;;) {
           if (t.getCause()!=null)
             System.out.println("bang !");
         }
       }
     }.start();

     for(int i=0;;i++) {
       initCause((i==100000)?t:new Throwable());
     }
   }
}

"bang !" is never (at least 15min :) printed with the server VM.

best regards

R?mi Forax


From gergg at cox.net  Thu Aug  3 13:36:53 2006
From: gergg at cox.net (Gregg Wonderly)
Date: Thu, 03 Aug 2006 12:36:53 -0500
Subject: [concurrency-interest] concurrency errors in java.lang.Throwable
In-Reply-To: <44D1E7CA.2030408@univ-mlv.fr>
References: <NFBBKALFDCPFIDBNKAPCAEOKHAAA.dcholmes@optusnet.com.au>
	<44D1E7CA.2030408@univ-mlv.fr>
Message-ID: <44D23435.1070802@cox.net>

R?mi Forax wrote:
> I've a test case that shows the bug :

...

> "bang !" is never (at least 15min :) printed with the server VM.

Right...  Because you are publishing without synchronization, the initCause() 
call's action of setting the field in one thread is not guarenteed to be visible 
in another threads read of that field.

On my laptop (dual core Xeon), it does become visible.  Perhaps because of the 
rate of garbage generation (new Throwable()), the GC activities are driving the 
visibility...

As David said, "Only trouble is today it is Throwable tomorrow, its ...".  There 
are all kinds of opportunities for threads to forget to synchronize 
communications/publishing of values between threads.  That's the education issue.

Gregg Wonderly

From joe.bowbeer at gmail.com  Thu Aug  3 14:03:28 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 3 Aug 2006 11:03:28 -0700
Subject: [concurrency-interest] concurrency errors in java.lang.Throwable
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEOKHAAA.dcholmes@optusnet.com.au>
References: <31f2a7bd0608021400v3234cbe1n548dd91b4681ef87@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEOKHAAA.dcholmes@optusnet.com.au>
Message-ID: <31f2a7bd0608031103i45a21171v42ba21a4521edf1d@mail.gmail.com>

On 8/2/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> Joe,
>
> getCause being synchronized would only be sufficient if the constructor
> used the synchronized initCause() - otherwise we'd need a volatile, or
> atomics or
>

Agreed.  In my original response to c-i, I said "one could argue" for
synchronizing getCause, but it wouldn't solve the problem.

Even without solving the problem, though, I thought it was desirable
to synchronize getCause -- for consistency.  But now I think
documentation is even more important.  Adding a "synchronized" that
won't fix anything may be just as confusing as leaving it out.

I still think using atomics is overkill unless there's a security vulnerability.

So I revise the work list to:

1. Declare detailMessage final.
2. Document why getCause isn't synchronized


I think it's also worth mentioning here that declaring cause as
volatile won't necessarily work.

Example from Jeremy Manson:

Thread 1:

// begin constructor
myThrowable.cause = this;
// end constructor
global = myThrowable;

Thread 2:

yourThrowable = global;
if (yourThrowable.cause == null)
  System.err.println("Null cause");

As Jeremy explains, the problem is that the assignment to global can
be hoisted above the write to cause (it isn't final).  In which case
the second thread won't see the appropriately initialized value of
cause.

--Joe

From kpauls at acm.org  Mon Aug  7 20:53:58 2006
From: kpauls at acm.org (Outside - Karl's ACM)
Date: Mon, 7 Aug 2006 17:53:58 -0700
Subject: [concurrency-interest] High performance Future aggregation -
	polling vs latching
Message-ID: <4BCD64ABC2F0674081427118425616E4778CF3@post.corp.trigeo.com>

I think I have an issue with Java 5 & 6's Future interface and the FutureTask
implementation, but I'm starting to think that it could be inappropriate to
use Future for the problem at hand. I could be stumbling over some of the
finer points of the concurrency library.

 

 

Let's say that you wanted to aggregate a number of possible available results
from a set of heterogeneous Futures with an aggregate time limit. After
marking the start time my implementation would first iterate through the
futures aggregating all complete futures. Then I would calculate the time
remaining and "spend" some fraction of that remaining time to wait for one of
the futures and repeat gathering up the completed futures.

 

The only way to poll a Future for its result indicates a timeout by throwing
an exception. Specifically:  Future.get(long timeout, TimeUnit unit)... So
every time I wait for a future without a result I experience a performance
hit from generating the exception. If implemented an additional "await"
method with a timeout parameter would not incur that expense. This method
would return a boolean indicating the Future.isDone result. The method
signature would look something like this: boolean await(long timeout,
TimeUnit unit).

 

 

It occurred to me that another method to wait on a set of futures would be to
create a CountDownLatch and wrap the Callable(s) in a Callable implementation
which counts down the latch. However, using the count down method I don't see
how to hook a new set of futures to a latch when they are already submitted
to the executor.

 

Even if an "await" method were provided on the Future interface it would not
be the most effective way to return a set of results as soon as some number
of them were ready: for instance attempting to return 5 of 10 completed
futures without a latch would likely result in some time wasted blocked on an
await call for a Future which would not complete before the others.

 

 

Is there a better way to aggregate futures or should I investigate a
different library for this kind of problem?

 

 

-karl

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060807/02c6227b/attachment.html 

From joe.bowbeer at gmail.com  Mon Aug  7 21:36:01 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 7 Aug 2006 18:36:01 -0700
Subject: [concurrency-interest] High performance Future aggregation -
	polling vs latching
In-Reply-To: <4BCD64ABC2F0674081427118425616E4778CF3@post.corp.trigeo.com>
References: <4BCD64ABC2F0674081427118425616E4778CF3@post.corp.trigeo.com>
Message-ID: <31f2a7bd0608071836p6212b3eck65cd5d9559f7dce5@mail.gmail.com>

On 8/7/06, Outside - Karl's ACM <kpauls at acm.org> wrote:
>
> I think I have an issue with Java 5 & 6's Future interface and the
> FutureTask implementation, but I'm starting to think that it could be
> inappropriate to use Future for the problem at hand. I could be stumbling
> over some of the finer points of the concurrency library.
>

Have you ruled out ExecutorCompletionService?

Another technique would be to implement custom futures that notify you
upon completion.  Override the done method to implement this feature.

From brian at quiotix.com  Mon Aug  7 22:15:53 2006
From: brian at quiotix.com (Brian Goetz)
Date: Mon, 07 Aug 2006 22:15:53 -0400
Subject: [concurrency-interest] High performance Future aggregation -
 polling vs latching
In-Reply-To: <4BCD64ABC2F0674081427118425616E4778CF3@post.corp.trigeo.com>
References: <4BCD64ABC2F0674081427118425616E4778CF3@post.corp.trigeo.com>
Message-ID: <44D7F3D9.2090909@quiotix.com>

> Is there a better way to aggregate futures or should I investigate a 
> different library for this kind of problem?

Take a look at ExecutorCompletionService.  Also see the explanation of
how it works and how you can build the same thing yourself in JCiP 6.3.5.


From kpauls at acm.org  Mon Aug  7 22:35:23 2006
From: kpauls at acm.org (Outside - Karl's ACM)
Date: Mon, 7 Aug 2006 19:35:23 -0700
Subject: [concurrency-interest] High performance Future aggregation
	-polling vs latching
Message-ID: <4BCD64ABC2F0674081427118425616E4659038@post.corp.trigeo.com>

Thanks Brian & Joe,

ExecutorCompletionService is a great starting point to explore this problem
further. I'll probably end up overriding FutureTask.done() so that I can
distinguish between different aggregators which use the same Executor.

-karl


From gregg at cytetech.com  Mon Aug  7 23:33:15 2006
From: gregg at cytetech.com (Gregg Wonderly)
Date: Mon, 07 Aug 2006 22:33:15 -0500
Subject: [concurrency-interest] High performance Future aggregation -
 polling vs latching
In-Reply-To: <4BCD64ABC2F0674081427118425616E4778CF3@post.corp.trigeo.com>
References: <4BCD64ABC2F0674081427118425616E4778CF3@post.corp.trigeo.com>
Message-ID: <44D805FB.1070801@cytetech.com>



Outside - Karl's ACM wrote:
> The only way to poll a Future for its result indicates a timeout by 
> throwing an exception. Specifically:  Future.get(long timeout, TimeUnit 
> unit)... So every time I wait for a future without a result I experience 
> a performance hit from generating the exception.

How busy will the JVM actually be, how long are these 'waits' and how many will 
be running at the same time?  I'm not so sure that the exception generation 
overhead (microseconds of CPU perhaps) is going to unduely impact your JVM 
performance.

Also, have you looked at JavaSpaces?  It is really good at distributing work 
loads and allowing you to scale up such applications by just adding more 
computers as you need.

Gregg Wonderly

From kpauls at acm.org  Tue Aug  8 15:33:09 2006
From: kpauls at acm.org (Outside - Karl's ACM)
Date: Tue, 8 Aug 2006 12:33:09 -0700
Subject: [concurrency-interest] High performance Future aggregation -
	polling vs latching
Message-ID: <4BCD64ABC2F0674081427118425616E4659039@post.corp.trigeo.com>

> -----Original Message-----
> From: Gregg Wonderly [mailto:gregg at cytetech.com]
> Sent: Monday, August 07, 2006 8:33 PM
> 
> How busy will the JVM actually be, how long are these 'waits' and how many
> will
> be running at the same time?  I'm not so sure that the exception
> generation
> overhead (microseconds of CPU perhaps) is going to unduely impact your JVM
> performance.

I'm more concerned about the memory cost.

I did put together a little impl of each method and using the
ExecutorCompletionService is much cleaner than polling and does not lend
itself to implementation errors (such as a poor wait strategy).

I'm considering JavaSpaces for future projects.


From yangjs at alibaba-inc.com  Fri Aug 11 01:38:12 2006
From: yangjs at alibaba-inc.com (yangjs)
Date: Fri, 11 Aug 2006 13:38:12 +0800
Subject: [concurrency-interest] ExecutorCompletionService is dangerous for
	critical app!!
References: <1466c1d60607250252w684a3238k67819e627b3d2472@mail.gmail.com><NFBBKALFDCPFIDBNKAPCIEJIHAAA.dcholmes@optusnet.com.au><1466c1d60607250427u41aa4522o26c1da96cd0b89c0@mail.gmail.com><aa067ea10607251726h6b8b840dwa7dfabe1805c23f2@mail.gmail.com><1466c1d60607252154w398cc012oaa80fc086b2042b8@mail.gmail.com><aa067ea10607252211p773537e2x7795a6acab218bc1@mail.gmail.com>
	<1466c1d60607252222p3acc1b3djd55e49b55b035ca4@mail.gmail.com>
Message-ID: <007101c6bd08$56544870$6244000a@alibabahz.com>


hi,all

   I  use ExecutorCompletionService in my app ,that is a producer-consumer pattern. code like follow:

    blic ExecutorCompletionService jobQueue = new ExecutorCompletionService<Document>(
     getThreadExecutor(), getBlockingQueue(100));

  I found when ExecutorCompletionService found queue full,then the finished job was discarded.
  after read the implement code ,the ExecutorCompletionService implments the QueueingFuture as follow:

      private class QueueingFuture extends FutureTask<V> {
          QueueingFuture(Callable<V> c) { super(c); }
          QueueingFuture(Runnable t, V r) { super(t, r); }
          protected void done() { completionQueue.add(this); }
      }

     when queue  full, completionQueue.add(this) will throw exception but swallowed by Future self.so the task will disappear,this is very dangerous for my critical app.

   why use completionQueue.add(this) ,why not use completionQueue.put(this),this is a block method , we want use throttling strategy when queue is full,I will implement self ,like this :


      private class QueueingFuture extends FutureTask<V> {
          QueueingFuture(Callable<V> c) { super(c); }
          QueueingFuture(Runnable t, V r) { super(t, r); }
          protected void done() { completionQueue.put(this); }
      }


  is right?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060811/a47c83ab/attachment.html 

From yangjs at alibaba-inc.com  Fri Aug 11 02:57:58 2006
From: yangjs at alibaba-inc.com (yangjs)
Date: Fri, 11 Aug 2006 14:57:58 +0800
Subject: [concurrency-interest]
	=?gb2312?B?RXhlY3V0b3JDb21wbGV0aW9uU2VydmljZSBpcyBkYW5nZXJvdXMgZg==?=	=?gb2312?B?b3IgY3JpdGljYWwgYXBwo6Gjvw==?=
Message-ID: <00a501c6bd13$7a9a5200$6244000a@alibabahz.com>



hi,all

   I  use ExecutorCompletionService in my app ,that is a producer-consumer pattern. code like follow:

    blic ExecutorCompletionService jobQueue = new ExecutorCompletionService<Document>(
     getThreadExecutor(), getBlockingQueue(100));

  I found when ExecutorCompletionService found queue full,then the finished job was discarded.
  after read the implement code ,the ExecutorCompletionService implments the QueueingFuture as follow:

      private class QueueingFuture extends FutureTask<V> {
          QueueingFuture(Callable<V> c) { super(c); }
          QueueingFuture(Runnable t, V r) { super(t, r); }
          protected void done() { completionQueue.add(this); }
      }

     when queue  full, completionQueue.add(this) will throw exception but swallowed by Future self.so the task will disappear,this is very dangerous for my critical app.

   why use completionQueue.add(this) ,why not use completionQueue.put(this),this is a block method , we want use throttling strategy when queue is full,I will implement self ,like this :


      private class QueueingFuture extends FutureTask<V> {
          QueueingFuture(Callable<V> c) { super(c); }
          QueueingFuture(Runnable t, V r) { super(t, r); }
          protected void done() { completionQueue.put(this); }
      }


  is right?



Best regards,
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060811/8198d988/attachment.html 

From dl at cs.oswego.edu  Fri Aug 11 14:16:37 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 11 Aug 2006 14:16:37 -0400
Subject: [concurrency-interest]
 =?utf-8?q?ExecutorCompletionService_is_dan?=
 =?utf-8?b?Z2Vyb3VzIGZvciBjcml0aWNhbCBhcHDvvIHvvJ8=?=
In-Reply-To: <00a501c6bd13$7a9a5200$6244000a@alibabahz.com>
References: <00a501c6bd13$7a9a5200$6244000a@alibabahz.com>
Message-ID: <44DCC985.9060303@cs.oswego.edu>

yangjs wrote:
> 
>    I  use ExecutorCompletionService in my app ,that is a 
> producer-consumer pattern. code like follow:
>  
> 
>     ExecutorCompletionService jobQueue = new
>     ExecutorCompletionService<Document>(
>        getThreadExecutor(), getBlockingQueue(100));/
>      
>     
>        when queue  full, completionQueue.add(this) will throw exception
>     but swallowed by Future self.

Sorry that the javadoc did not make clear that the supplied queue
should be unbounded. This should/will be clarified. The rationale
for not using BlockingQueue.put here is that there is no
policy control in this simple class for dealing with either
InterruptedExceptions that might occur with put, or the potential
for saturation and lockup.

Unless/until we get good suggestions for dealing with
such things in a generic way, I'm afraid that in those cases
where you have to deal with them, you'll need a custom
implementation of the CompletionService interface.

-Doug


From yangjs at alibaba-inc.com  Fri Aug 11 15:05:12 2006
From: yangjs at alibaba-inc.com (yangjs)
Date: Sat, 12 Aug 2006 03:05:12 +0800
Subject: [concurrency-interest]
	=?utf-8?q?ExecutorCompletionService_is_dan?=
	=?utf-8?b?Z2Vyb3VzIGZvciBjcml0aWNhbCBhcHDvvIHvvJ8=?=
References: <00a501c6bd13$7a9a5200$6244000a@alibabahz.com>
	<44DCC985.9060303@cs.oswego.edu>
Message-ID: <000801c6bd79$126b4430$a255fea9@alibabahz.com>

    This is my custom implementation of the CompletionService interface.
Can I use this impl for my work?

public class BlockingCompletionService<V> implements CompletionService<V> {
 private final Executor executor;

 private final BlockingQueue<Future<V>> completionQueue;

 private boolean isBlocking;

 /**
  * FutureTask extension to enqueue upon completion
  */
 private class QueueingFuture extends FutureTask<V> {
  QueueingFuture(Callable<V> c) {
   super(c);
  }

  QueueingFuture(Runnable t, V r) {
   super(t, r);
  }

  protected void done() {
   if (isBlocking) {
    try {
     completionQueue.put(this);
    } catch (InterruptedException e) {
     Thread.currentThread().interrupt();
     cancel(true);
    }
   } else {
    completionQueue.add(this);
   }
  }
 }

 public BlockingCompletionService(Executor executor) {
  if (executor == null)
   throw new NullPointerException();
  this.executor = executor;
  this.completionQueue = new LinkedBlockingQueue<Future<V>>();
 }

 public BlockingCompletionService(Executor executor,
   BlockingQueue<Future<V>> completionQueue, boolean isBlocking) {
  if (executor == null || completionQueue == null)
   throw new NullPointerException();
  this.executor = executor;
  this.completionQueue = completionQueue;
  this.isBlocking = isBlocking;
 }

 public Future<V> submit(Callable<V> task) {
  if (task == null)
   throw new NullPointerException();
  QueueingFuture f = new QueueingFuture(task);
  executor.execute(f);
  return f;
 }

 public Future<V> submit(Runnable task, V result) {
  if (task == null)
   throw new NullPointerException();
  QueueingFuture f = new QueueingFuture(task, result);
  executor.execute(f);
  return f;
 }

 public Future<V> take() throws InterruptedException {
  return completionQueue.take();
 }

 public Future<V> poll() {
  return completionQueue.poll();
 }

 public Future<V> poll(long timeout, TimeUnit unit)
   throws InterruptedException {
  return completionQueue.poll(timeout, unit);
 }

}


----- Original Message ----- 
From: "Doug Lea" <dl at cs.oswego.edu>
To: "yangjs" <yangjs at alibaba-inc.com>
Cc: <concurrency-interest at cs.oswego.edu>
Sent: Saturday, August 12, 2006 2:16 AM
Subject: Re: [concurrency-interest] ExecutorCompletionService is dangerous 
for critical app??


> yangjs wrote:
>>
>>    I  use ExecutorCompletionService in my app ,that is a 
>> producer-consumer pattern. code like follow:
>>  ExecutorCompletionService jobQueue = new
>>     ExecutorCompletionService<Document>(
>>        getThreadExecutor(), getBlockingQueue(100));/
>>      when queue  full, completionQueue.add(this) will throw exception
>>     but swallowed by Future self.
>
> Sorry that the javadoc did not make clear that the supplied queue
> should be unbounded. This should/will be clarified. The rationale
> for not using BlockingQueue.put here is that there is no
> policy control in this simple class for dealing with either
> InterruptedExceptions that might occur with put, or the potential
> for saturation and lockup.
>
> Unless/until we get good suggestions for dealing with
> such things in a generic way, I'm afraid that in those cases
> where you have to deal with them, you'll need a custom
> implementation of the CompletionService interface.
>
> -Doug
> 

From dl at cs.oswego.edu  Fri Aug 11 19:49:32 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 11 Aug 2006 19:49:32 -0400
Subject: [concurrency-interest]
 =?utf-8?q?ExecutorCompletionService_is_dan?=
 =?utf-8?b?Z2Vyb3VzIGZvciBjcml0aWNhbCBhcHDvvIHvvJ8=?=
In-Reply-To: <000801c6bd79$126b4430$a255fea9@alibabahz.com>
References: <00a501c6bd13$7a9a5200$6244000a@alibabahz.com>	<44DCC985.9060303@cs.oswego.edu>
	<000801c6bd79$126b4430$a255fea9@alibabahz.com>
Message-ID: <44DD178C.1020603@cs.oswego.edu>

yangjs wrote:
>     This is my custom implementation of the CompletionService interface.
> Can I use this impl for my work?
> 

Yes, this seems reasonable. You will still sometimes lose
tasks (on interrupt), but presumably your application can cope
with this.

-Doug


> 
>   protected void done() {
>    if (isBlocking) {
>     try {
>      completionQueue.put(this);
>     } catch (InterruptedException e) {
>      Thread.currentThread().interrupt();
>      cancel(true);
>     }
>    } else {
>     completionQueue.add(this);
>    }
>   }
>  }

From hanson.char at gmail.com  Sun Aug 13 02:56:47 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Sat, 12 Aug 2006 23:56:47 -0700
Subject: [concurrency-interest] ExecutorCompletionService for scheduled task
Message-ID: <ca53c8f80608122356h4b6598d9vb94e309e74b29e8a@mail.gmail.com>

Hi,

I am not sure if the existing ExecutorCompletionService can be nicely
fitted here.  What we want is a scheduled close operation to be
initiated on each open session after m seconds delay, and abort
regardless after a total of n seconds, even if some of these close
operations haven't started or finished, where n > m.

ExecutorCompletionService.submit() allows some tasks to be submitted
for execution, but there doesn't exist something like
ExecutorCompletionService.schedule() that would take a delay
parameter.

Thoughts ?

Hanson Char

From dhanji at gmail.com  Sun Aug 13 05:09:39 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Sun, 13 Aug 2006 19:09:39 +1000
Subject: [concurrency-interest] ExecutorCompletionService for scheduled
	task
In-Reply-To: <ca53c8f80608122356h4b6598d9vb94e309e74b29e8a@mail.gmail.com>
References: <ca53c8f80608122356h4b6598d9vb94e309e74b29e8a@mail.gmail.com>
Message-ID: <aa067ea10608130209g17e1a9calff68550aa8ea25a@mail.gmail.com>

Have you looked into using ScheduledThreadPoolExecutor with CompletionService?
The schedule() method takes a delay which can be used to trigger the
close operation.

Not sure if this is exactly what you want to do?

On 8/13/06, Hanson Char <hanson.char at gmail.com> wrote:
> Hi,
>
> I am not sure if the existing ExecutorCompletionService can be nicely
> fitted here.  What we want is a scheduled close operation to be
> initiated on each open session after m seconds delay, and abort
> regardless after a total of n seconds, even if some of these close
> operations haven't started or finished, where n > m.
>
> ExecutorCompletionService.submit() allows some tasks to be submitted
> for execution, but there doesn't exist something like
> ExecutorCompletionService.schedule() that would take a delay
> parameter.
>
> Thoughts ?
>
> Hanson Char
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From amar_nan at yahoo.com  Sun Aug 13 09:12:22 2006
From: amar_nan at yahoo.com (Amarnath Nanduri)
Date: Sun, 13 Aug 2006 06:12:22 -0700 (PDT)
Subject: [concurrency-interest] Question on GUI Applications
Message-ID: <20060813131222.24004.qmail@web30213.mail.mud.yahoo.com>

Hi,

   Was anybody successful in using the ListenerExamples.java from the book "Java Concurrency in Practise" in chapter 9? I am trying to use it to display information from a Database, while giving the end user the option to cancel if it takes too much time. I would appreciate a full blown example in using the classes from this chapter.

Thanks,
Amar..

 				
---------------------------------
Do you Yahoo!?
 Everyone is raving about the  all-new Yahoo! Mail Beta.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060813/93033e49/attachment.html 

From hanson.char at gmail.com  Sun Aug 13 12:47:41 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Sun, 13 Aug 2006 09:47:41 -0700
Subject: [concurrency-interest] ExecutorCompletionService for scheduled
	task
In-Reply-To: <aa067ea10608130209g17e1a9calff68550aa8ea25a@mail.gmail.com>
References: <ca53c8f80608122356h4b6598d9vb94e309e74b29e8a@mail.gmail.com>
	<aa067ea10608130209g17e1a9calff68550aa8ea25a@mail.gmail.com>
Message-ID: <ca53c8f80608130947l36c2c2a8y2db7a14a2f414d92@mail.gmail.com>

That's what I am using.  Specifically:

 Executors.newScheduledThreadPool(...);

plus other code to schedule via the ScheduledExecutorService, and then
to wait for timeout via the ScheduledFuture.get(...)

Just wonder if there is a better (lazier) way.

Hanson

On 8/13/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> Have you looked into using ScheduledThreadPoolExecutor with CompletionService?
> The schedule() method takes a delay which can be used to trigger the
> close operation.
>
> Not sure if this is exactly what you want to do?
>
> On 8/13/06, Hanson Char <hanson.char at gmail.com> wrote:
> > Hi,
> >
> > I am not sure if the existing ExecutorCompletionService can be nicely
> > fitted here.  What we want is a scheduled close operation to be
> > initiated on each open session after m seconds delay, and abort
> > regardless after a total of n seconds, even if some of these close
> > operations haven't started or finished, where n > m.
> >
> > ExecutorCompletionService.submit() allows some tasks to be submitted
> > for execution, but there doesn't exist something like
> > ExecutorCompletionService.schedule() that would take a delay
> > parameter.
> >
> > Thoughts ?
> >
> > Hanson Char
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>

From joe.bowbeer at gmail.com  Sun Aug 13 14:52:33 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sun, 13 Aug 2006 11:52:33 -0700
Subject: [concurrency-interest] ExecutorCompletionService for scheduled
	task
In-Reply-To: <ca53c8f80608130947l36c2c2a8y2db7a14a2f414d92@mail.gmail.com>
References: <ca53c8f80608122356h4b6598d9vb94e309e74b29e8a@mail.gmail.com>
	<aa067ea10608130209g17e1a9calff68550aa8ea25a@mail.gmail.com>
	<ca53c8f80608130947l36c2c2a8y2db7a14a2f414d92@mail.gmail.com>
Message-ID: <31f2a7bd0608131152j25e941c0k3c3b2bb2ecd665a@mail.gmail.com>

Have you thought about scheduling additional tasks whose job it is to
cancel the previously submitted tasks (and eventually close their
resources)?

For each task you schedule on the completion service, I'm imagining
you would schedule another task (or two) on a "cancellation service".
If a task completes in time, you would cancel its associated
cancellation task(s).  Otherwise, the cancellation task will cancel
its associated task and you'll dequeue that failed task from the
completion service.

If timing is a bit more complicated, each task may need to schedule
its own cancellation when it runs.  This is harder to do, I think,
because some of the wrapping added by the scheduled executor and/or
the completion service.


On 8/13/06, Hanson Char <hanson.char at gmail.com> wrote:
> That's what I am using.  Specifically:
>
>  Executors.newScheduledThreadPool(...);
>
> plus other code to schedule via the ScheduledExecutorService, and then
> to wait for timeout via the ScheduledFuture.get(...)
>
> Just wonder if there is a better (lazier) way.
>
> Hanson
>
> On 8/13/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> > Have you looked into using ScheduledThreadPoolExecutor with CompletionService?
> > The schedule() method takes a delay which can be used to trigger the
> > close operation.
> >
> > Not sure if this is exactly what you want to do?
> >
> > On 8/13/06, Hanson Char <hanson.char at gmail.com> wrote:
> > > Hi,
> > >
> > > I am not sure if the existing ExecutorCompletionService can be nicely
> > > fitted here.  What we want is a scheduled close operation to be
> > > initiated on each open session after m seconds delay, and abort
> > > regardless after a total of n seconds, even if some of these close
> > > operations haven't started or finished, where n > m.
> > >
> > > ExecutorCompletionService.submit() allows some tasks to be submitted
> > > for execution, but there doesn't exist something like
> > > ExecutorCompletionService.schedule() that would take a delay
> > > parameter.
> > >
> > > Thoughts ?
> > >
> > > Hanson Char

From dhanji at gmail.com  Sun Aug 13 19:11:50 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Mon, 14 Aug 2006 09:11:50 +1000
Subject: [concurrency-interest] ExecutorCompletionService for scheduled
	task
In-Reply-To: <ca53c8f80608130947l36c2c2a8y2db7a14a2f414d92@mail.gmail.com>
References: <ca53c8f80608122356h4b6598d9vb94e309e74b29e8a@mail.gmail.com>
	<aa067ea10608130209g17e1a9calff68550aa8ea25a@mail.gmail.com>
	<ca53c8f80608130947l36c2c2a8y2db7a14a2f414d92@mail.gmail.com>
Message-ID: <aa067ea10608131611x7529ad50w4a0582ca070d24e5@mail.gmail.com>

On 8/14/06, Hanson Char <hanson.char at gmail.com> wrote:
> plus other code to schedule via the ScheduledExecutorService, and then
> to wait for timeout via the ScheduledFuture.get(...)
>

I think that's about the simplest/most practical solution so long as
you are happy that the thread calling SF.get() is reliably early and
isolated (i.e. is able to call SF.get() on all scheduled threads
independently). If not, I think Joe's idea of using a parallel watcher
is the better solution.

> Just wonder if there is a better (lazier) way.
>
> Hanson
>
> On 8/13/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> > Have you looked into using ScheduledThreadPoolExecutor with CompletionService?
> > The schedule() method takes a delay which can be used to trigger the
> > close operation.
> >
> > Not sure if this is exactly what you want to do?
> >
> > On 8/13/06, Hanson Char <hanson.char at gmail.com> wrote:
> > > Hi,
> > >
> > > I am not sure if the existing ExecutorCompletionService can be nicely
> > > fitted here.  What we want is a scheduled close operation to be
> > > initiated on each open session after m seconds delay, and abort
> > > regardless after a total of n seconds, even if some of these close
> > > operations haven't started or finished, where n > m.
> > >
> > > ExecutorCompletionService.submit() allows some tasks to be submitted
> > > for execution, but there doesn't exist something like
> > > ExecutorCompletionService.schedule() that would take a delay
> > > parameter.
> > >
> > > Thoughts ?
> > >
> > > Hanson Char
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> >
>

From hanson.char at gmail.com  Sun Aug 13 22:21:00 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Sun, 13 Aug 2006 19:21:00 -0700
Subject: [concurrency-interest] ExecutorCompletionService for scheduled
	task
In-Reply-To: <aa067ea10608131611x7529ad50w4a0582ca070d24e5@mail.gmail.com>
References: <ca53c8f80608122356h4b6598d9vb94e309e74b29e8a@mail.gmail.com>
	<aa067ea10608130209g17e1a9calff68550aa8ea25a@mail.gmail.com>
	<ca53c8f80608130947l36c2c2a8y2db7a14a2f414d92@mail.gmail.com>
	<aa067ea10608131611x7529ad50w4a0582ca070d24e5@mail.gmail.com>
Message-ID: <ca53c8f80608131921h564e8266ub687ff4346fe4da1@mail.gmail.com>

Below is the "simplest" or most "lightweight" code fragment I can
think of to cancel all tasks (that have been scheduled to run after M
seconds delay) if not all completed within a total of N seconds (where
N > M).  Please shout if you spot any weakness/drawback.

Hanson

...
        List<ScheduledFuture> scheduledFutureList = ...// scheduled to
run after M seconds delay

        // Let's wait for a maximum of N seconds.
        // We will exit regardless even if not all open sessions have
been closed.
        final long dueTimeMillis = System.currentTimeMillis() + N * 1000;
        boolean interrupted = false;

        for (ScheduledFuture scheduledFuture : scheduledFutureList)
        {
            long timeoutMillis = dueTimeMillis - System.currentTimeMillis();

            if (timeoutMillis <= 0)
            {
                scheduledFuture.cancel(true);
                continue;
            }
            try {
                scheduledFuture.get(timeoutMillis, TimeUnit.MILLISECONDS);
            } catch (ExecutionException e) {
               // log it or whatever
            } catch (TimeoutException e) {
               // log it or whatever
            } catch (InterruptedException e) {
               // log it or whatever
                interrupted = true;
            } finally {
                scheduledFuture.cancel(true);
            }
        }

        if (interrupted)
            Thread.currentThread().interrupt();

...


On 8/13/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> On 8/14/06, Hanson Char <hanson.char at gmail.com> wrote:
> > plus other code to schedule via the ScheduledExecutorService, and then
> > to wait for timeout via the ScheduledFuture.get(...)
> >
>
> I think that's about the simplest/most practical solution so long as
> you are happy that the thread calling SF.get() is reliably early and
> isolated (i.e. is able to call SF.get() on all scheduled threads
> independently). If not, I think Joe's idea of using a parallel watcher
> is the better solution.
>
> > Just wonder if there is a better (lazier) way.
> >
> > Hanson
> >
> > On 8/13/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> > > Have you looked into using ScheduledThreadPoolExecutor with CompletionService?
> > > The schedule() method takes a delay which can be used to trigger the
> > > close operation.
> > >
> > > Not sure if this is exactly what you want to do?
> > >
> > > On 8/13/06, Hanson Char <hanson.char at gmail.com> wrote:
> > > > Hi,
> > > >
> > > > I am not sure if the existing ExecutorCompletionService can be nicely
> > > > fitted here.  What we want is a scheduled close operation to be
> > > > initiated on each open session after m seconds delay, and abort
> > > > regardless after a total of n seconds, even if some of these close
> > > > operations haven't started or finished, where n > m.
> > > >
> > > > ExecutorCompletionService.submit() allows some tasks to be submitted
> > > > for execution, but there doesn't exist something like
> > > > ExecutorCompletionService.schedule() that would take a delay
> > > > parameter.
> > > >
> > > > Thoughts ?
> > > >
> > > > Hanson Char
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >
> > >
> >
>

From yangjs at alibaba-inc.com  Tue Aug 15 02:04:43 2006
From: yangjs at alibaba-inc.com (yangjs)
Date: Tue, 15 Aug 2006 14:04:43 +0800
Subject: [concurrency-interest] why thread implement transform thread name
	to char[]?
References: <1466c1d60607250252w684a3238k67819e627b3d2472@mail.gmail.com><NFBBKALFDCPFIDBNKAPCIEJIHAAA.dcholmes@optusnet.com.au><1466c1d60607250427u41aa4522o26c1da96cd0b89c0@mail.gmail.com><aa067ea10607251726h6b8b840dwa7dfabe1805c23f2@mail.gmail.com><1466c1d60607252154w398cc012oaa80fc086b2042b8@mail.gmail.com><aa067ea10607252211p773537e2x7795a6acab218bc1@mail.gmail.com><1466c1d60607252222p3acc1b3djd55e49b55b035ca4@mail.gmail.com>
	<007101c6bd08$56544870$6244000a@alibabahz.com>
Message-ID: <003301c6c030$b44e9590$6244000a@alibabahz.com>


  When I read Thread implement code, I found when set thread name , name is String type ,the thread implement code will transform String to char[],when getName(), then transform to String! 
  who can explain ?why? 

thx

Best regards,
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060815/ef71a9ef/attachment.html 

From dcholmes at optusnet.com.au  Tue Aug 15 03:26:58 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 15 Aug 2006 17:26:58 +1000
Subject: [concurrency-interest] why thread implement transform thread
	nameto char[]?
In-Reply-To: <003301c6c030$b44e9590$6244000a@alibabahz.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEFDHBAA.dcholmes@optusnet.com.au>

That would be to make it easier to access the thread name from within C code
in the VM. Just a guess. :) I don't think this is really an issue today but
this code has been around a long time.

Cheers,
David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of yangjs
  Sent: Tuesday, 15 August 2006 4:05 PM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] why thread implement transform thread
nameto char[]?



    When I read Thread implement code, I found when set thread name , name
is String type ,the thread implement code will transform String to
char[],when getName(), then transform to String!
    who can explain ?why?

  thx

  Best regards,
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060815/b7e5e57a/attachment.html 

From tim at peierls.net  Tue Aug 15 12:26:38 2006
From: tim at peierls.net (Tim Peierls)
Date: Tue, 15 Aug 2006 12:26:38 -0400
Subject: [concurrency-interest] Question on GUI Applications
In-Reply-To: <20060813131222.24004.qmail@web30213.mail.mud.yahoo.com>
References: <20060813131222.24004.qmail@web30213.mail.mud.yahoo.com>
Message-ID: <63b4e4050608150926l2ac8a5b4r631dbbfb291bd3f9@mail.gmail.com>

Those examples are mainly to illustrate various techniques; they aren't
meant to be used directly (they are all private methods). For production
systems, you probably want to use the SwingWorker utility. It's standard
with Java 6, but if you can't wait that long, the BackgroundTask class from
JCiP chapter 9 is a reasonable stop-gap measure -- it has a cancel method
and a get with timeout method. It hasn't been tested seriously, however, so
proceed with caution and please let us know of any problems you find with
it.

--tim

On 8/13/06, Amarnath Nanduri <amar_nan at yahoo.com> wrote:
>
> Hi,
>
>    Was anybody successful in using the ListenerExamples.java from the book
> "Java Concurrency in Practise" in chapter 9? I am trying to use it to
> display information from a Database, while giving the end user the option to
> cancel if it takes too much time. I would appreciate a full blown example in
> using the classes from this chapter.
>
> Thanks,
> Amar..
>
> ------------------------------
> Do you Yahoo!?
> Everyone is raving about the all-new Yahoo! Mail Beta.<http://us.rd.yahoo.com/evt=42297/*http://advision.webevents.yahoo.com/handraisers>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060815/bc8aa96d/attachment.html 

From kpauls at acm.org  Tue Aug 15 16:28:37 2006
From: kpauls at acm.org (Outside - Karl's ACM)
Date: Tue, 15 Aug 2006 13:28:37 -0700
Subject: [concurrency-interest] ExecutorCompletionService for
	scheduledtask
Message-ID: <4BCD64ABC2F0674081427118425616E465903D@post.corp.trigeo.com>

Hanson,

Since you're not concerned about the Future's results; that looks great. It
also helps that there will only ever be one TimeoutException thrown within
your loop.

-karl


> Below is the "simplest" or most "lightweight" code fragment I can
> think of to cancel all tasks (that have been scheduled to run after M
> seconds delay) if not all completed within a total of N seconds (where
> N > M).  Please shout if you spot any weakness/drawback.
> 
> Hanson
> 
> ...
>         List<ScheduledFuture> scheduledFutureList = ...// scheduled to
> run after M seconds delay
> 
>         // Let's wait for a maximum of N seconds.
>         // We will exit regardless even if not all open sessions have
> been closed.
>         final long dueTimeMillis = System.currentTimeMillis() + N * 1000;
>         boolean interrupted = false;
> 
>         for (ScheduledFuture scheduledFuture : scheduledFutureList)
>         {
>             long timeoutMillis = dueTimeMillis -
> System.currentTimeMillis();
> 
>             if (timeoutMillis <= 0)
>             {
>                 scheduledFuture.cancel(true);
>                 continue;
>             }
>             try {
>                 scheduledFuture.get(timeoutMillis, TimeUnit.MILLISECONDS);
>             } catch (ExecutionException e) {
>                // log it or whatever
>             } catch (TimeoutException e) {
>                // log it or whatever
>             } catch (InterruptedException e) {
>                // log it or whatever
>                 interrupted = true;
>             } finally {
>                 scheduledFuture.cancel(true);
>             }
>         }
> 
>         if (interrupted)
>             Thread.currentThread().interrupt();
> 
> ...


From robertlazarski at gmail.com  Wed Aug 16 17:34:05 2006
From: robertlazarski at gmail.com (robert lazarski)
Date: Wed, 16 Aug 2006 18:34:05 -0300
Subject: [concurrency-interest] Simple ScheduledFuture problem
Message-ID: <f87675ee0608161434k760d6ce4rbfcd7591370bdf4d@mail.gmail.com>

Hi all,

I've seen similair questions on the list but I'm still stuck. I just
want to timeout a future that is scheduled at a fixed rate. The code
below works, but does not run at a scheduled rate for about two
minutes until it recovers after timeout! Maybe I should pass a
ThreadFactory to the Executor?  I'm unclear how to apply
future.get(timeout) when using a fixed rate. Please help, code below
(just a quick hack, nothing serious) . What times out is
URLConnectiion.openConnection();

package org;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.InetAddress;
import java.net.Socket;
import java.net.URL;
import java.net.URLConnection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.Timer;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class Ping {
	
	  private int flag = 0;
	  private static int STOPPED = new Integer(0);
	  private static int BEGIN_INIT = new Integer(1);
	  private static int RUNNING = new Integer(2);
          private static Map <Integer, String> map;
	
	  /** commons logging declaration. */
	  private static Log logger = LogFactory.getLog(
	    		Ping.class);

	  /** Timer expressed in milliseconds as six seconds */
	  private final static long ONCE_PER_SIX_SECONDS = 1000*6;

	  public static void main(String[] args) throws Exception {

              new Ping();
	  }

          Ping () {
              boolean interrupted = false;
              ScheduledExecutorService ses =
Executors.newSingleThreadScheduledExecutor();
              // Do pings, starting now, with a 6 second delay
              ScheduledFuture <?> ping = ses.scheduleAtFixedRate(new
PingTask(),
                  0L, 6000L, TimeUnit.MILLISECONDS);
	  }

          static {
              map = new HashMap<Integer, String>();
              map.put(STOPPED, "STOPPED");
              map.put(BEGIN_INIT, "BEGIN_INIT");
              map.put(RUNNING, "RUNNING");
          }

          class PingTask implements Runnable {

            private void doConnect(String host, int port, boolean
on_connect, int state) {
                try {
                    InetAddress addr = InetAddress.getByName(host);
                    // will throw an exception if could not connect
                    Socket s = new Socket(addr, port);
                    s.close();
                    if (on_connect) {
                        logger.debug("Found port: " + port);
                        setFlag(state);
                    }

                } catch (Exception ex) {
                    logger.error("Can't find port: " + port);
                    logger.error(ex.getMessage(), ex);
                    if (!on_connect) {
                        setFlag(state);
                    }
                }

            }

            private void doConnect(URL host, boolean on_connect, int state) {
                try {
                    logger.debug("connecting to url: " + host.toString());
                    URLConnection uc = host.openConnection();
                    if (uc == null) {
                        logger.error("Got a null URLConnection object!");
                        return;
                    }
                    InputStream is = uc.getInputStream();
                    if (is == null) {
                        logger.error("Got a null content object!");
                        return;
                    }
                    BufferedReader in = new BufferedReader(
                        new InputStreamReader(
                        is));
                    String inputLine;
                    // just test that its readable for now
                    while ((inputLine = in.readLine()) != null)  {
                        ;
                    }
                    in.close();
                    if (on_connect) {
                        logger.debug("Found url: " + host.toString());
                        setFlag(state);
                    }

                } catch (Exception ex) {
                    logger.error("Can't find url: " + host.toString());
                    logger.error(ex.getMessage(), ex);
                    if (!on_connect) {
                        setFlag(state);
                    }
                }

          }


          public void run() {

	      Timer timer = new Timer(true);
              try {
	          // Schedule a 5 second interupt for the timeout - ping
should complete
	          // in less than 5 seconds
	          timer.schedule(new TimeOutTask(Thread.currentThread()), 5000);
                  if (flag == STOPPED) {
                      doConnect("localhost", 1099, true, BEGIN_INIT);
                  }
                  if (flag == BEGIN_INIT) {
                      // test state of stopped to prevent endless loop
                      doConnect("localhost", 1099, false, STOPPED);
                      doConnect(new
URL("http://localhost:8080/maragato/"), true, RUNNING);
                  }
                  if (flag == RUNNING) {
                      doConnect("localhost", 1099, false, STOPPED);
                  }
                } catch (Exception ex) {
                    logger.error(ex.getMessage(), ex);
                }
                finally {
                    logger.debug("CURRENT STATE: " + getMessage(flag));
                    // task must be cancelled so Thread.interrupt() is
_not_ called
	            timer.cancel();
                }
            }
        }

        private synchronized void setFlag(int var) {
            flag = var;
        }

        /** Get message via an int.
         * @param code Integer mapped to message
         * @return String mapped message
         */
        public final String getMessage(int code) {
            return map.get(code);
        }
}

package org;

import java.util.TimerTask;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class TimeOutTask extends TimerTask {
	
	 /** commons logging declaration. */
    private static Log logger = LogFactory.getLog(
    		TimeOutTask.class);
	
	Thread t;

	TimeOutTask(Thread t) {
	    this.t = t;
	}

	/**
	An implementation of the Abstract Class TimerTask method run()
	*/
	public void run() {
	    if(t!= null && t.isAlive()) {
	        t.interrupt();
	        logger.error("thread: " + t.getName() + ", task timed out!");
	    }
	    else {
	    	logger.error("task timed out, but could not interrupt!");
	    }
	}
}

From dcholmes at optusnet.com.au  Wed Aug 16 18:51:38 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Thu, 17 Aug 2006 08:51:38 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <f87675ee0608161434k760d6ce4rbfcd7591370bdf4d@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEGIHBAA.dcholmes@optusnet.com.au>

Robert,

I'm not sure what the delay is in restarting the scheduled task, but
regarding your query on using future.get(timeout) with a fixed-rate task, my
understanding is that get() will return the last computed result (if there
is one) until the next computation cycle begins. In other words if the task
is between executions then get() returns the result from the last execution,
otherwise it blocks until the current execution completes.

But I'm not sure what thread would be calling it in your example. It seems
you want the task to be unblocked not some thread waiting on the output of
the task.

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of robert
> lazarski
> Sent: Thursday, 17 August 2006 7:34 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Simple ScheduledFuture problem
>
>
> Hi all,
>
> I've seen similair questions on the list but I'm still stuck. I just
> want to timeout a future that is scheduled at a fixed rate. The code
> below works, but does not run at a scheduled rate for about two
> minutes until it recovers after timeout! Maybe I should pass a
> ThreadFactory to the Executor?  I'm unclear how to apply
> future.get(timeout) when using a fixed rate. Please help, code below
> (just a quick hack, nothing serious) . What times out is
> URLConnectiion.openConnection();
>
> package org;
>
> import java.io.BufferedReader;
> import java.io.InputStream;
> import java.io.InputStreamReader;
> import java.net.InetAddress;
> import java.net.Socket;
> import java.net.URL;
> import java.net.URLConnection;
> import java.util.HashMap;
> import java.util.Map;
> import java.util.concurrent.Executors;
> import java.util.concurrent.ScheduledExecutorService;
> import java.util.concurrent.ScheduledFuture;
> import java.util.concurrent.TimeUnit;
> import java.util.Timer;
>
> import org.apache.commons.logging.Log;
> import org.apache.commons.logging.LogFactory;
>
> public class Ping {
>
> 	  private int flag = 0;
> 	  private static int STOPPED = new Integer(0);
> 	  private static int BEGIN_INIT = new Integer(1);
> 	  private static int RUNNING = new Integer(2);
>           private static Map <Integer, String> map;
>
> 	  /** commons logging declaration. */
> 	  private static Log logger = LogFactory.getLog(
> 	    		Ping.class);
>
> 	  /** Timer expressed in milliseconds as six seconds */
> 	  private final static long ONCE_PER_SIX_SECONDS = 1000*6;
>
> 	  public static void main(String[] args) throws Exception {
>
>               new Ping();
> 	  }
>
>           Ping () {
>               boolean interrupted = false;
>               ScheduledExecutorService ses =
> Executors.newSingleThreadScheduledExecutor();
>               // Do pings, starting now, with a 6 second delay
>               ScheduledFuture <?> ping = ses.scheduleAtFixedRate(new
> PingTask(),
>                   0L, 6000L, TimeUnit.MILLISECONDS);
> 	  }
>
>           static {
>               map = new HashMap<Integer, String>();
>               map.put(STOPPED, "STOPPED");
>               map.put(BEGIN_INIT, "BEGIN_INIT");
>               map.put(RUNNING, "RUNNING");
>           }
>
>           class PingTask implements Runnable {
>
>             private void doConnect(String host, int port, boolean
> on_connect, int state) {
>                 try {
>                     InetAddress addr = InetAddress.getByName(host);
>                     // will throw an exception if could not connect
>                     Socket s = new Socket(addr, port);
>                     s.close();
>                     if (on_connect) {
>                         logger.debug("Found port: " + port);
>                         setFlag(state);
>                     }
>
>                 } catch (Exception ex) {
>                     logger.error("Can't find port: " + port);
>                     logger.error(ex.getMessage(), ex);
>                     if (!on_connect) {
>                         setFlag(state);
>                     }
>                 }
>
>             }
>
>             private void doConnect(URL host, boolean on_connect,
> int state) {
>                 try {
>                     logger.debug("connecting to url: " + host.toString());
>                     URLConnection uc = host.openConnection();
>                     if (uc == null) {
>                         logger.error("Got a null URLConnection object!");
>                         return;
>                     }
>                     InputStream is = uc.getInputStream();
>                     if (is == null) {
>                         logger.error("Got a null content object!");
>                         return;
>                     }
>                     BufferedReader in = new BufferedReader(
>                         new InputStreamReader(
>                         is));
>                     String inputLine;
>                     // just test that its readable for now
>                     while ((inputLine = in.readLine()) != null)  {
>                         ;
>                     }
>                     in.close();
>                     if (on_connect) {
>                         logger.debug("Found url: " + host.toString());
>                         setFlag(state);
>                     }
>
>                 } catch (Exception ex) {
>                     logger.error("Can't find url: " + host.toString());
>                     logger.error(ex.getMessage(), ex);
>                     if (!on_connect) {
>                         setFlag(state);
>                     }
>                 }
>
>           }
>
>
>           public void run() {
>
> 	      Timer timer = new Timer(true);
>               try {
> 	          // Schedule a 5 second interupt for the timeout - ping
> should complete
> 	          // in less than 5 seconds
> 	          timer.schedule(new
> TimeOutTask(Thread.currentThread()), 5000);
>                   if (flag == STOPPED) {
>                       doConnect("localhost", 1099, true, BEGIN_INIT);
>                   }
>                   if (flag == BEGIN_INIT) {
>                       // test state of stopped to prevent endless loop
>                       doConnect("localhost", 1099, false, STOPPED);
>                       doConnect(new
> URL("http://localhost:8080/maragato/"), true, RUNNING);
>                   }
>                   if (flag == RUNNING) {
>                       doConnect("localhost", 1099, false, STOPPED);
>                   }
>                 } catch (Exception ex) {
>                     logger.error(ex.getMessage(), ex);
>                 }
>                 finally {
>                     logger.debug("CURRENT STATE: " + getMessage(flag));
>                     // task must be cancelled so Thread.interrupt() is
> _not_ called
> 	            timer.cancel();
>                 }
>             }
>         }
>
>         private synchronized void setFlag(int var) {
>             flag = var;
>         }
>
>         /** Get message via an int.
>          * @param code Integer mapped to message
>          * @return String mapped message
>          */
>         public final String getMessage(int code) {
>             return map.get(code);
>         }
> }
>
> package org;
>
> import java.util.TimerTask;
>
> import org.apache.commons.logging.Log;
> import org.apache.commons.logging.LogFactory;
>
> public class TimeOutTask extends TimerTask {
>
> 	 /** commons logging declaration. */
>     private static Log logger = LogFactory.getLog(
>     		TimeOutTask.class);
>
> 	Thread t;
>
> 	TimeOutTask(Thread t) {
> 	    this.t = t;
> 	}
>
> 	/**
> 	An implementation of the Abstract Class TimerTask method run()
> 	*/
> 	public void run() {
> 	    if(t!= null && t.isAlive()) {
> 	        t.interrupt();
> 	        logger.error("thread: " + t.getName() + ", task
> timed out!");
> 	    }
> 	    else {
> 	    	logger.error("task timed out, but could not interrupt!");
> 	    }
> 	}
> }
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From joe.bowbeer at gmail.com  Wed Aug 16 20:41:55 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 16 Aug 2006 17:41:55 -0700
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <f87675ee0608161434k760d6ce4rbfcd7591370bdf4d@mail.gmail.com>
References: <f87675ee0608161434k760d6ce4rbfcd7591370bdf4d@mail.gmail.com>
Message-ID: <31f2a7bd0608161741x333c5ca0p78d5d7cfe906aea0@mail.gmail.com>

At a glance, I notice a few things that could be cleaned up, though
they may have no impact on the problem.

1. setFlag is synchronized but there is no synchronized getFlag method.

Either added synchronized getFlag, or declare flag to be "volatile".

2. doConnect(url) code may fail without closing input stream.

Add try-catch after opening input stream.

3. Also, I would consider switching to fixed delay to avoid the
possibility of multiple outstanding pings.

From robertlazarski at gmail.com  Thu Aug 17 10:56:19 2006
From: robertlazarski at gmail.com (robert lazarski)
Date: Thu, 17 Aug 2006 11:56:19 -0300
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <31f2a7bd0608161741x333c5ca0p78d5d7cfe906aea0@mail.gmail.com>
References: <f87675ee0608161434k760d6ce4rbfcd7591370bdf4d@mail.gmail.com>
	<31f2a7bd0608161741x333c5ca0p78d5d7cfe906aea0@mail.gmail.com>
Message-ID: <f87675ee0608170756o3df9b556k2dabcfdbfcae3cae@mail.gmail.com>

Thanks Dave and Joe. I implemented the changes you two mentioned (I
hope) and now invoke a FutureTask inside the Runnable of the
ScheduledFuture . Here's what I came up with. The purpose here is just
to simply record the states of an app server.

Thanks!
Robert

package org;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.InetAddress;
import java.net.Socket;
import java.net.URL;
import java.net.URLConnection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class Ping {

      private volatile int  flag = 0;
      private static int STOPPED = new Integer(0);
      private static int BEGIN_INIT = new Integer(1);
      private static int RUNNING = new Integer(2);
          private static Map <Integer, String> map;

      /** commons logging declaration. */
      private static Log logger = LogFactory.getLog(
                Ping.class);

      public static void main(String[] args) throws Exception {

              new Ping();
      }

      Ping () {
          ScheduledExecutorService ses =
Executors.newSingleThreadScheduledExecutor();
          // Do pings, starting now, with a 2 second delay in between
          ScheduledFuture <?> ping = ses.scheduleWithFixedDelay(new PingTask(),
              0L, 2000L, TimeUnit.MILLISECONDS);
      }

      static {
          map = new HashMap<Integer, String>();
          map.put(STOPPED, "STOPPED");
          map.put(BEGIN_INIT, "BEGIN_INIT");
          map.put(RUNNING, "RUNNING");
      }

      private synchronized void setFlag(int var) {
          flag = var;
      }

      /** Get message via an int.
       * @param code Integer mapped to message
       * @return String mapped message
       */
      public final String getMessage(int code) {
          return map.get(code);
      }

      class PingFuture implements Runnable {
          private void doConnect(String host, int port, boolean
on_connect, int state) {
              try {
                  logger.debug("connecting to host: " +host+ ", port: " + port);
                  InetAddress addr = InetAddress.getByName(host);
                  // will throw an exception if could not connect
                  Socket s = new Socket(addr, port);
                  s.close();
                  if (on_connect) {
                      logger.debug("Found port: " + port);
                      setFlag(state);
                  }

              } catch (Exception ex) {
                  logger.error("Can't find port: " + port);
                  logger.error(ex.getMessage(), ex);
                  if (!on_connect) {
                      setFlag(state);
                  }
              }

          }

          private void doConnect(URL host, boolean on_connect, int
state) throws IOException {
              InputStream is = null;
              BufferedReader in = null;
              try {
                  logger.debug("connecting to url: " + host.toString());
                  URLConnection uc = host.openConnection();
                  if (uc == null) {
                      logger.error("Got a null URLConnection object!");
                      return;
                  }
                  is = uc.getInputStream();
                  if (is == null) {
                      logger.error("Got a null content object!");
                      return;
                  }
                  in = new BufferedReader(new InputStreamReader(
                        is));
                  String inputLine;
                  // just test that its readable for now
                  while ((inputLine = in.readLine()) != null)  {
                        ;
                  }
                  if (on_connect) {
                      logger.debug("Found url: " + host.toString());
                      setFlag(state);
                  }

              } catch (Exception ex) {
                  logger.error("Can't find url: " + host.toString());
                  logger.error(ex.getMessage(), ex);
                  if (!on_connect) {
                      setFlag(state);
                  }
              } finally {
                  if (is != null) {
                      is.close();
                  }
                  if (in != null) {
                      in.close();
                  }
              }

          }

          public void run() {

              try {
                  if (flag == STOPPED) {
                      doConnect("localhost", 1099, true, BEGIN_INIT);
                  }
                  if (flag == BEGIN_INIT) {
                      // test state of stopped to prevent endless loop
                      doConnect("localhost", 1099, false, STOPPED);
                      doConnect(new
URL("http://localhost:8080/maragato/"), true, RUNNING);

                  }
                  if (flag == RUNNING) {
                      doConnect(new
URL("http://localhost:8080/maragato/"), false, STOPPED);
                  }

              } catch (Exception ex) {
                    logger.error(ex.getMessage(), ex);
              }
          }
      } // end inner class PingFuture

      class PingTask implements Runnable {

          public void run() {

              try {
                  FutureTask<?> f = new FutureTask<Object>(new
PingFuture(), null);
                  Thread thread = new Thread(f);
                  thread.start();
                  // 5 seconds to finish connect or will timeout
                  f.get(5000, TimeUnit.MILLISECONDS);
              } catch (Exception ex) {
                    logger.error(ex.getMessage(), ex);
              }
              finally {
                  logger.debug("CURRENT STATE: " + getMessage(flag));

              }
          }
      } // end inner class PingTask

}


On 8/16/06, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> At a glance, I notice a few things that could be cleaned up, though
> they may have no impact on the problem.
>
> 1. setFlag is synchronized but there is no synchronized getFlag method.
>
> Either added synchronized getFlag, or declare flag to be "volatile".
>
> 2. doConnect(url) code may fail without closing input stream.
>
> Add try-catch after opening input stream.
>
> 3. Also, I would consider switching to fixed delay to avoid the
> possibility of multiple outstanding pings.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From tim at peierls.net  Thu Aug 17 14:55:22 2006
From: tim at peierls.net (Tim Peierls)
Date: Thu, 17 Aug 2006 14:55:22 -0400
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <f87675ee0608170756o3df9b556k2dabcfdbfcae3cae@mail.gmail.com>
References: <f87675ee0608161434k760d6ce4rbfcd7591370bdf4d@mail.gmail.com>
	<31f2a7bd0608161741x333c5ca0p78d5d7cfe906aea0@mail.gmail.com>
	<f87675ee0608170756o3df9b556k2dabcfdbfcae3cae@mail.gmail.com>
Message-ID: <63b4e4050608171155k7fd28158ob9197aed659f2553@mail.gmail.com>

On 8/17/06, robert lazarski <robertlazarski at gmail.com> wrote:
>
> Thanks Dave and Joe. I implemented the changes you two mentioned (I
> hope) and now invoke a FutureTask inside the Runnable of the
> ScheduledFuture .


Maybe instead of creating a new thread for each PingFuture, you could
decouple the execution policy of PingFuture from the scheduling of PingTask
using an ExecutorService. Specifically, instead of the following code in
PingTask.run:

FutureTask<?> f = new FutureTask<Object>(new PingFuture(), null);
> Thread thread = new Thread(f);
> thread.start();
> // 5 seconds to finish connect or will timeout
> f.get(5000, TimeUnit.MILLISECONDS);
>

You could write:

    exec.submit(new PingFuture()).get(5000, TimeUnit.MILLISECONDS);

where exec is initialized with Executors.newCachedThreadPool().

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060817/8b080dee/attachment.html 

From dcholmes at optusnet.com.au  Thu Aug 17 16:40:53 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 18 Aug 2006 06:40:53 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <f87675ee0608170756o3df9b556k2dabcfdbfcae3cae@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEHDHBAA.dcholmes@optusnet.com.au>

Robert,

A concern with this is what happens to the thread when the connection does
not respond? You have the get() timeout but the thread you used (whether
created directly or via an Executor) may still get hung on the actual
operation. You might want to cancel/interrupt the thread after you timeout.

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of robert
> lazarski
> Sent: Friday, 18 August 2006 12:56 AM
> To: Joe Bowbeer
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Simple ScheduledFuture problem
>
>
> Thanks Dave and Joe. I implemented the changes you two mentioned (I
> hope) and now invoke a FutureTask inside the Runnable of the
> ScheduledFuture . Here's what I came up with. The purpose here is just
> to simply record the states of an app server.
>
> Thanks!
> Robert
>
> package org;
>
> import java.io.BufferedReader;
> import java.io.IOException;
> import java.io.InputStream;
> import java.io.InputStreamReader;
> import java.net.InetAddress;
> import java.net.Socket;
> import java.net.URL;
> import java.net.URLConnection;
> import java.util.HashMap;
> import java.util.Map;
> import java.util.concurrent.Executors;
> import java.util.concurrent.FutureTask;
> import java.util.concurrent.ScheduledExecutorService;
> import java.util.concurrent.ScheduledFuture;
> import java.util.concurrent.TimeUnit;
>
> import org.apache.commons.logging.Log;
> import org.apache.commons.logging.LogFactory;
>
> public class Ping {
>
>       private volatile int  flag = 0;
>       private static int STOPPED = new Integer(0);
>       private static int BEGIN_INIT = new Integer(1);
>       private static int RUNNING = new Integer(2);
>           private static Map <Integer, String> map;
>
>       /** commons logging declaration. */
>       private static Log logger = LogFactory.getLog(
>                 Ping.class);
>
>       public static void main(String[] args) throws Exception {
>
>               new Ping();
>       }
>
>       Ping () {
>           ScheduledExecutorService ses =
> Executors.newSingleThreadScheduledExecutor();
>           // Do pings, starting now, with a 2 second delay in between
>           ScheduledFuture <?> ping =
> ses.scheduleWithFixedDelay(new PingTask(),
>               0L, 2000L, TimeUnit.MILLISECONDS);
>       }
>
>       static {
>           map = new HashMap<Integer, String>();
>           map.put(STOPPED, "STOPPED");
>           map.put(BEGIN_INIT, "BEGIN_INIT");
>           map.put(RUNNING, "RUNNING");
>       }
>
>       private synchronized void setFlag(int var) {
>           flag = var;
>       }
>
>       /** Get message via an int.
>        * @param code Integer mapped to message
>        * @return String mapped message
>        */
>       public final String getMessage(int code) {
>           return map.get(code);
>       }
>
>       class PingFuture implements Runnable {
>           private void doConnect(String host, int port, boolean
> on_connect, int state) {
>               try {
>                   logger.debug("connecting to host: " +host+ ",
> port: " + port);
>                   InetAddress addr = InetAddress.getByName(host);
>                   // will throw an exception if could not connect
>                   Socket s = new Socket(addr, port);
>                   s.close();
>                   if (on_connect) {
>                       logger.debug("Found port: " + port);
>                       setFlag(state);
>                   }
>
>               } catch (Exception ex) {
>                   logger.error("Can't find port: " + port);
>                   logger.error(ex.getMessage(), ex);
>                   if (!on_connect) {
>                       setFlag(state);
>                   }
>               }
>
>           }
>
>           private void doConnect(URL host, boolean on_connect, int
> state) throws IOException {
>               InputStream is = null;
>               BufferedReader in = null;
>               try {
>                   logger.debug("connecting to url: " + host.toString());
>                   URLConnection uc = host.openConnection();
>                   if (uc == null) {
>                       logger.error("Got a null URLConnection object!");
>                       return;
>                   }
>                   is = uc.getInputStream();
>                   if (is == null) {
>                       logger.error("Got a null content object!");
>                       return;
>                   }
>                   in = new BufferedReader(new InputStreamReader(
>                         is));
>                   String inputLine;
>                   // just test that its readable for now
>                   while ((inputLine = in.readLine()) != null)  {
>                         ;
>                   }
>                   if (on_connect) {
>                       logger.debug("Found url: " + host.toString());
>                       setFlag(state);
>                   }
>
>               } catch (Exception ex) {
>                   logger.error("Can't find url: " + host.toString());
>                   logger.error(ex.getMessage(), ex);
>                   if (!on_connect) {
>                       setFlag(state);
>                   }
>               } finally {
>                   if (is != null) {
>                       is.close();
>                   }
>                   if (in != null) {
>                       in.close();
>                   }
>               }
>
>           }
>
>           public void run() {
>
>               try {
>                   if (flag == STOPPED) {
>                       doConnect("localhost", 1099, true, BEGIN_INIT);
>                   }
>                   if (flag == BEGIN_INIT) {
>                       // test state of stopped to prevent endless loop
>                       doConnect("localhost", 1099, false, STOPPED);
>                       doConnect(new
> URL("http://localhost:8080/maragato/"), true, RUNNING);
>
>                   }
>                   if (flag == RUNNING) {
>                       doConnect(new
> URL("http://localhost:8080/maragato/"), false, STOPPED);
>                   }
>
>               } catch (Exception ex) {
>                     logger.error(ex.getMessage(), ex);
>               }
>           }
>       } // end inner class PingFuture
>
>       class PingTask implements Runnable {
>
>           public void run() {
>
>               try {
>                   FutureTask<?> f = new FutureTask<Object>(new
> PingFuture(), null);
>                   Thread thread = new Thread(f);
>                   thread.start();
>                   // 5 seconds to finish connect or will timeout
>                   f.get(5000, TimeUnit.MILLISECONDS);
>               } catch (Exception ex) {
>                     logger.error(ex.getMessage(), ex);
>               }
>               finally {
>                   logger.debug("CURRENT STATE: " + getMessage(flag));
>
>               }
>           }
>       } // end inner class PingTask
>
> }
>
>
> On 8/16/06, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> > At a glance, I notice a few things that could be cleaned up, though
> > they may have no impact on the problem.
> >
> > 1. setFlag is synchronized but there is no synchronized getFlag method.
> >
> > Either added synchronized getFlag, or declare flag to be "volatile".
> >
> > 2. doConnect(url) code may fail without closing input stream.
> >
> > Add try-catch after opening input stream.
> >
> > 3. Also, I would consider switching to fixed delay to avoid the
> > possibility of multiple outstanding pings.
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From robertlazarski at gmail.com  Tue Aug 22 09:28:45 2006
From: robertlazarski at gmail.com (robert lazarski)
Date: Tue, 22 Aug 2006 10:28:45 -0300
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEHDHBAA.dcholmes@optusnet.com.au>
References: <f87675ee0608170756o3df9b556k2dabcfdbfcae3cae@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEHDHBAA.dcholmes@optusnet.com.au>
Message-ID: <f87675ee0608220628l2a1cd2b2h19ce39af3105ad99@mail.gmail.com>

I finally got some time to implement the latest suggestions of David
and Tim. This is what I came up with:

class PingTask implements Runnable {

         public void run() {

             Future f = null;
             boolean interrupted = false;
             try {
                 ExecutorService exec = Executors.newCachedThreadPool();
                 f = exec.submit(new PingFuture());
                 f.get(5000, TimeUnit.MILLISECONDS);

             } catch (TimeoutException ex) {
                   interrupted = true;
                   logger.error("Future timed out: \n" + ex.getMessage(), ex);
             } catch (InterruptedException ex) {
                   interrupted = true;
                   logger.error("Future interrupted: \n" + ex.getMessage(), ex);
             } catch (Exception ex) {
                   logger.error(ex.getMessage(), ex);
             }
             finally {
                 f.cancel(true);
                 logger.debug("CURRENT STATE: " + getMessage(flag));

             }
             if (interrupted) {
                 Thread.currentThread().interrupt();
             }
         }
     } // end inner class PingTask

Thanks for the feedback!
Robert

On 8/17/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> Robert,
>
> A concern with this is what happens to the thread when the connection does
> not respond? You have the get() timeout but the thread you used (whether
> created directly or via an Executor) may still get hung on the actual
> operation. You might want to cancel/interrupt the thread after you timeout.
>
> Cheers,
> David Holmes
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of robert
> > lazarski
> > Sent: Friday, 18 August 2006 12:56 AM
> > To: Joe Bowbeer
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Simple ScheduledFuture problem
> >
> >
> > Thanks Dave and Joe. I implemented the changes you two mentioned (I
> > hope) and now invoke a FutureTask inside the Runnable of the
> > ScheduledFuture . Here's what I came up with. The purpose here is just
> > to simply record the states of an app server.
> >
> > Thanks!
> > Robert
> >
> > package org;
> >
> > import java.io.BufferedReader;
> > import java.io.IOException;
> > import java.io.InputStream;
> > import java.io.InputStreamReader;
> > import java.net.InetAddress;
> > import java.net.Socket;
> > import java.net.URL;
> > import java.net.URLConnection;
> > import java.util.HashMap;
> > import java.util.Map;
> > import java.util.concurrent.Executors;
> > import java.util.concurrent.FutureTask;
> > import java.util.concurrent.ScheduledExecutorService;
> > import java.util.concurrent.ScheduledFuture;
> > import java.util.concurrent.TimeUnit;
> >
> > import org.apache.commons.logging.Log;
> > import org.apache.commons.logging.LogFactory;
> >
> > public class Ping {
> >
> >       private volatile int  flag = 0;
> >       private static int STOPPED = new Integer(0);
> >       private static int BEGIN_INIT = new Integer(1);
> >       private static int RUNNING = new Integer(2);
> >           private static Map <Integer, String> map;
> >
> >       /** commons logging declaration. */
> >       private static Log logger = LogFactory.getLog(
> >                 Ping.class);
> >
> >       public static void main(String[] args) throws Exception {
> >
> >               new Ping();
> >       }
> >
> >       Ping () {
> >           ScheduledExecutorService ses =
> > Executors.newSingleThreadScheduledExecutor();
> >           // Do pings, starting now, with a 2 second delay in between
> >           ScheduledFuture <?> ping =
> > ses.scheduleWithFixedDelay(new PingTask(),
> >               0L, 2000L, TimeUnit.MILLISECONDS);
> >       }
> >
> >       static {
> >           map = new HashMap<Integer, String>();
> >           map.put(STOPPED, "STOPPED");
> >           map.put(BEGIN_INIT, "BEGIN_INIT");
> >           map.put(RUNNING, "RUNNING");
> >       }
> >
> >       private synchronized void setFlag(int var) {
> >           flag = var;
> >       }
> >
> >       /** Get message via an int.
> >        * @param code Integer mapped to message
> >        * @return String mapped message
> >        */
> >       public final String getMessage(int code) {
> >           return map.get(code);
> >       }
> >
> >       class PingFuture implements Runnable {
> >           private void doConnect(String host, int port, boolean
> > on_connect, int state) {
> >               try {
> >                   logger.debug("connecting to host: " +host+ ",
> > port: " + port);
> >                   InetAddress addr = InetAddress.getByName(host);
> >                   // will throw an exception if could not connect
> >                   Socket s = new Socket(addr, port);
> >                   s.close();
> >                   if (on_connect) {
> >                       logger.debug("Found port: " + port);
> >                       setFlag(state);
> >                   }
> >
> >               } catch (Exception ex) {
> >                   logger.error("Can't find port: " + port);
> >                   logger.error(ex.getMessage(), ex);
> >                   if (!on_connect) {
> >                       setFlag(state);
> >                   }
> >               }
> >
> >           }
> >
> >           private void doConnect(URL host, boolean on_connect, int
> > state) throws IOException {
> >               InputStream is = null;
> >               BufferedReader in = null;
> >               try {
> >                   logger.debug("connecting to url: " + host.toString());
> >                   URLConnection uc = host.openConnection();
> >                   if (uc == null) {
> >                       logger.error("Got a null URLConnection object!");
> >                       return;
> >                   }
> >                   is = uc.getInputStream();
> >                   if (is == null) {
> >                       logger.error("Got a null content object!");
> >                       return;
> >                   }
> >                   in = new BufferedReader(new InputStreamReader(
> >                         is));
> >                   String inputLine;
> >                   // just test that its readable for now
> >                   while ((inputLine = in.readLine()) != null)  {
> >                         ;
> >                   }
> >                   if (on_connect) {
> >                       logger.debug("Found url: " + host.toString());
> >                       setFlag(state);
> >                   }
> >
> >               } catch (Exception ex) {
> >                   logger.error("Can't find url: " + host.toString());
> >                   logger.error(ex.getMessage(), ex);
> >                   if (!on_connect) {
> >                       setFlag(state);
> >                   }
> >               } finally {
> >                   if (is != null) {
> >                       is.close();
> >                   }
> >                   if (in != null) {
> >                       in.close();
> >                   }
> >               }
> >
> >           }
> >
> >           public void run() {
> >
> >               try {
> >                   if (flag == STOPPED) {
> >                       doConnect("localhost", 1099, true, BEGIN_INIT);
> >                   }
> >                   if (flag == BEGIN_INIT) {
> >                       // test state of stopped to prevent endless loop
> >                       doConnect("localhost", 1099, false, STOPPED);
> >                       doConnect(new
> > URL("http://localhost:8080/maragato/"), true, RUNNING);
> >
> >                   }
> >                   if (flag == RUNNING) {
> >                       doConnect(new
> > URL("http://localhost:8080/maragato/"), false, STOPPED);
> >                   }
> >
> >               } catch (Exception ex) {
> >                     logger.error(ex.getMessage(), ex);
> >               }
> >           }
> >       } // end inner class PingFuture
> >
> >       class PingTask implements Runnable {
> >
> >           public void run() {
> >
> >               try {
> >                   FutureTask<?> f = new FutureTask<Object>(new
> > PingFuture(), null);
> >                   Thread thread = new Thread(f);
> >                   thread.start();
> >                   // 5 seconds to finish connect or will timeout
> >                   f.get(5000, TimeUnit.MILLISECONDS);
> >               } catch (Exception ex) {
> >                     logger.error(ex.getMessage(), ex);
> >               }
> >               finally {
> >                   logger.debug("CURRENT STATE: " + getMessage(flag));
> >
> >               }
> >           }
> >       } // end inner class PingTask
> >
> > }
> >
> >
> > On 8/16/06, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> > > At a glance, I notice a few things that could be cleaned up, though
> > > they may have no impact on the problem.
> > >
> > > 1. setFlag is synchronized but there is no synchronized getFlag method.
> > >
> > > Either added synchronized getFlag, or declare flag to be "volatile".
> > >
> > > 2. doConnect(url) code may fail without closing input stream.
> > >
> > > Add try-catch after opening input stream.
> > >
> > > 3. Also, I would consider switching to fixed delay to avoid the
> > > possibility of multiple outstanding pings.
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From tim at peierls.net  Tue Aug 22 09:42:07 2006
From: tim at peierls.net (Tim Peierls)
Date: Tue, 22 Aug 2006 09:42:07 -0400
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <f87675ee0608220628l2a1cd2b2h19ce39af3105ad99@mail.gmail.com>
References: <f87675ee0608170756o3df9b556k2dabcfdbfcae3cae@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEHDHBAA.dcholmes@optusnet.com.au>
	<f87675ee0608220628l2a1cd2b2h19ce39af3105ad99@mail.gmail.com>
Message-ID: <63b4e4050608220642r2bf9b44ek562f485519c73a15@mail.gmail.com>

You are creating a new thread pool each time the PingTask runs. I was
suggesting that the thread pool be a field, maybe even a static field, of
PingTask.

--tim

On 8/22/06, robert lazarski <robertlazarski at gmail.com> wrote:
>
> I finally got some time to implement the latest suggestions of David
> and Tim. This is what I came up with:
>
> class PingTask implements Runnable {
>
>          public void run() {
>
>              Future f = null;
>              boolean interrupted = false;
>              try {
>                  ExecutorService exec = Executors.newCachedThreadPool();
>                  f = exec.submit(new PingFuture());
>                  f.get(5000, TimeUnit.MILLISECONDS);
>
>              } catch (TimeoutException ex) {
>                    interrupted = true;
>                    logger.error("Future timed out: \n" + ex.getMessage(),
> ex);
>              } catch (InterruptedException ex) {
>                    interrupted = true;
>                    logger.error ("Future interrupted: \n" + ex.getMessage(),
> ex);
>              } catch (Exception ex) {
>                    logger.error(ex.getMessage(), ex);
>              }
>              finally {
>                  f.cancel(true);
>                  logger.debug("CURRENT STATE: " + getMessage(flag));
>
>              }
>              if (interrupted) {
>                  Thread.currentThread().interrupt();
>              }
>          }
>      } // end inner class PingTask
>
> Thanks for the feedback!
> Robert
>
> On 8/17/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > Robert,
> >
> > A concern with this is what happens to the thread when the connection
> does
> > not respond? You have the get() timeout but the thread you used (whether
> > created directly or via an Executor) may still get hung on the actual
> > operation. You might want to cancel/interrupt the thread after you
> timeout.
> >
> > Cheers,
> > David Holmes
> >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of robert
> > > lazarski
> > > Sent: Friday, 18 August 2006 12:56 AM
> > > To: Joe Bowbeer
> > > Cc: concurrency-interest at cs.oswego.edu
> > > Subject: Re: [concurrency-interest] Simple ScheduledFuture problem
> > >
> > >
> > > Thanks Dave and Joe. I implemented the changes you two mentioned (I
> > > hope) and now invoke a FutureTask inside the Runnable of the
> > > ScheduledFuture . Here's what I came up with. The purpose here is just
>
> > > to simply record the states of an app server.
> > >
> > > Thanks!
> > > Robert
> > >
> > > package org;
> > >
> > > import java.io.BufferedReader;
> > > import java.io.IOException;
> > > import java.io.InputStream;
> > > import java.io.InputStreamReader;
> > > import java.net.InetAddress;
> > > import java.net.Socket;
> > > import java.net.URL;
> > > import java.net.URLConnection;
> > > import java.util.HashMap;
> > > import java.util.Map;
> > > import java.util.concurrent.Executors;
> > > import java.util.concurrent.FutureTask ;
> > > import java.util.concurrent.ScheduledExecutorService;
> > > import java.util.concurrent.ScheduledFuture;
> > > import java.util.concurrent.TimeUnit;
> > >
> > > import org.apache.commons.logging.Log ;
> > > import org.apache.commons.logging.LogFactory;
> > >
> > > public class Ping {
> > >
> > >       private volatile int  flag = 0;
> > >       private static int STOPPED = new Integer(0);
> > >       private static int BEGIN_INIT = new Integer(1);
> > >       private static int RUNNING = new Integer(2);
> > >           private static Map <Integer, String> map;
> > >
> > >       /** commons logging declaration. */
> > >       private static Log logger = LogFactory.getLog(
> > >                 Ping.class);
> > >
> > >       public static void main(String[] args) throws Exception {
> > >
> > >               new Ping();
> > >       }
> > >
> > >       Ping () {
> > >           ScheduledExecutorService ses =
> > > Executors.newSingleThreadScheduledExecutor();
> > >           // Do pings, starting now, with a 2 second delay in between
> > >           ScheduledFuture <?> ping =
> > > ses.scheduleWithFixedDelay(new PingTask(),
> > >               0L, 2000L, TimeUnit.MILLISECONDS);
> > >       }
> > >
> > >       static {
> > >           map = new HashMap<Integer, String>();
> > >           map.put(STOPPED, "STOPPED");
> > >           map.put(BEGIN_INIT, "BEGIN_INIT");
> > >           map.put(RUNNING, "RUNNING");
> > >       }
> > >
> > >       private synchronized void setFlag(int var) {
> > >           flag = var;
> > >       }
> > >
> > >       /** Get message via an int.
> > >        * @param code Integer mapped to message
> > >        * @return String mapped message
> > >        */
> > >       public final String getMessage(int code) {
> > >           return map.get(code);
> > >       }
> > >
> > >       class PingFuture implements Runnable {
> > >           private void doConnect(String host, int port, boolean
> > > on_connect, int state) {
> > >               try {
> > >                   logger.debug("connecting to host: " +host+ ",
> > > port: " + port);
> > >                   InetAddress addr = InetAddress.getByName (host);
> > >                   // will throw an exception if could not connect
> > >                   Socket s = new Socket(addr, port);
> > >                   s.close();
> > >                   if (on_connect) {
> > >                       logger.debug("Found port: " + port);
> > >                       setFlag(state);
> > >                   }
> > >
> > >               } catch (Exception ex) {
> > >                   logger.error("Can't find port: " + port);
> > >                   logger.error(ex.getMessage(), ex);
> > >                   if (!on_connect) {
> > >                       setFlag(state);
> > >                   }
> > >               }
> > >
> > >           }
> > >
> > >           private void doConnect(URL host, boolean on_connect, int
> > > state) throws IOException {
> > >               InputStream is = null;
> > >               BufferedReader in = null;
> > >               try {
> > >                   logger.debug("connecting to url: " + host.toString());
> > >                   URLConnection uc = host.openConnection();
> > >                   if (uc == null) {
> > >                       logger.error("Got a null URLConnection
> object!");
> > >                       return;
> > >                   }
> > >                   is = uc.getInputStream();
> > >                   if (is == null) {
> > >                       logger.error ("Got a null content object!");
> > >                       return;
> > >                   }
> > >                   in = new BufferedReader(new InputStreamReader(
> > >                         is));
> > >                   String inputLine;
> > >                   // just test that its readable for now
> > >                   while ((inputLine = in.readLine()) != null)  {
> > >                         ;
> > >                   }
> > >                   if (on_connect) {
> > >                       logger.debug("Found url: " + host.toString());
> > >                       setFlag(state);
> > >                   }
> > >
> > >               } catch (Exception ex) {
> > >                   logger.error("Can't find url: " + host.toString());
> > >                   logger.error(ex.getMessage(), ex);
> > >                   if (!on_connect) {
> > >                       setFlag(state);
> > >                   }
> > >               } finally {
> > >                   if (is != null) {
> > >                       is.close();
> > >                   }
> > >                   if (in != null) {
> > >                       in.close();
> > >                   }
> > >               }
> > >
> > >           }
> > >
> > >           public void run() {
> > >
> > >               try {
> > >                   if (flag == STOPPED) {
> > >                       doConnect("localhost", 1099, true, BEGIN_INIT);
> > >                   }
> > >                   if (flag == BEGIN_INIT) {
> > >                       // test state of stopped to prevent endless loop
> > >                       doConnect("localhost", 1099, false, STOPPED);
> > >                       doConnect(new
> > > URL("http://localhost:8080/maragato/"), true, RUNNING);
> > >
> > >                   }
> > >                   if (flag == RUNNING) {
> > >                       doConnect(new
> > > URL("http://localhost:8080/maragato/"), false, STOPPED);
> > >                   }
> > >
> > >               } catch (Exception ex) {
> > >                     logger.error(ex.getMessage(), ex);
> > >               }
> > >           }
> > >       } // end inner class PingFuture
> > >
> > >       class PingTask implements Runnable {
> > >
> > >           public void run() {
> > >
> > >               try {
> > >                   FutureTask<?> f = new FutureTask<Object>(new
> > > PingFuture(), null);
> > >                   Thread thread = new Thread(f);
> > >                   thread.start ();
> > >                   // 5 seconds to finish connect or will timeout
> > >                   f.get(5000, TimeUnit.MILLISECONDS);
> > >               } catch (Exception ex) {
> > >                     logger.error(ex.getMessage(), ex);
> > >               }
> > >               finally {
> > >                   logger.debug("CURRENT STATE: " + getMessage(flag));
> > >
> > >               }
> > >           }
> > >       } // end inner class PingTask
> > >
> > > }
> > >
> > >
> > > On 8/16/06, Joe Bowbeer <joe.bowbeer at gmail.com > wrote:
> > > > At a glance, I notice a few things that could be cleaned up, though
> > > > they may have no impact on the problem.
> > > >
> > > > 1. setFlag is synchronized but there is no synchronized getFlag
> method.
> > > >
> > > > Either added synchronized getFlag, or declare flag to be "volatile".
> > > >
> > > > 2. doConnect(url) code may fail without closing input stream.
> > > >
> > > > Add try-catch after opening input stream.
> > > >
> > > > 3. Also, I would consider switching to fixed delay to avoid the
> > > > possibility of multiple outstanding pings.
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060822/1e0da407/attachment-0001.html 

From tim at peierls.net  Tue Aug 22 09:47:17 2006
From: tim at peierls.net (Tim Peierls)
Date: Tue, 22 Aug 2006 09:47:17 -0400
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <63b4e4050608220642r2bf9b44ek562f485519c73a15@mail.gmail.com>
References: <f87675ee0608170756o3df9b556k2dabcfdbfcae3cae@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEHDHBAA.dcholmes@optusnet.com.au>
	<f87675ee0608220628l2a1cd2b2h19ce39af3105ad99@mail.gmail.com>
	<63b4e4050608220642r2bf9b44ek562f485519c73a15@mail.gmail.com>
Message-ID: <63b4e4050608220647t57901da2i564fcf1bc4c681c7@mail.gmail.com>

Also, instead of catching Exception, you can catch the more specific
ExecutionException -- thrown by Future.get() -- and examine the underlying
Throwable with getCause().

--tim

On 8/22/06, robert lazarski <robertlazarski at gmail.com> wrote:
> >
> > I finally got some time to implement the latest suggestions of David
> > and Tim. This is what I came up with:
> >
> > class PingTask implements Runnable {
> >
> >          public void run() {
> >
> >              Future f = null;
> >              boolean interrupted = false;
> >              try {
> >                  ExecutorService exec = Executors.newCachedThreadPool();
> >                  f = exec.submit(new PingFuture());
> >                  f.get(5000, TimeUnit.MILLISECONDS);
> >
> >              } catch (TimeoutException ex) {
> >                    interrupted = true;
> >                    logger.error("Future timed out: \n" + ex.getMessage(),
> > ex);
> >              } catch (InterruptedException ex) {
> >                    interrupted = true;
> >                    logger.error ("Future interrupted: \n" +
> > ex.getMessage(), ex);
> >              } catch (Exception ex) {
> >                    logger.error(ex.getMessage(), ex);
> >              }
> >              finally {
> >                  f.cancel(true);
> >                  logger.debug("CURRENT STATE: " + getMessage(flag));
> >
> >              }
> >              if (interrupted) {
> >                  Thread.currentThread().interrupt();
> >              }
> >          }
> >      } // end inner class PingTask
> >
> > Thanks for the feedback!
> > Robert
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060822/f6c70faa/attachment.html 

From robertlazarski at gmail.com  Tue Aug 22 10:03:35 2006
From: robertlazarski at gmail.com (robert lazarski)
Date: Tue, 22 Aug 2006 11:03:35 -0300
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <63b4e4050608220647t57901da2i564fcf1bc4c681c7@mail.gmail.com>
References: <f87675ee0608170756o3df9b556k2dabcfdbfcae3cae@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEHDHBAA.dcholmes@optusnet.com.au>
	<f87675ee0608220628l2a1cd2b2h19ce39af3105ad99@mail.gmail.com>
	<63b4e4050608220642r2bf9b44ek562f485519c73a15@mail.gmail.com>
	<63b4e4050608220647t57901da2i564fcf1bc4c681c7@mail.gmail.com>
Message-ID: <f87675ee0608220703v670e467ak33db20283dee8933@mail.gmail.com>

Thanks Tim. If its any consolation, I did buy the concurrency in
practice book and I'm reading it every day, though I just started ;-)
. PingTask is an inner class and can't have static vars , so this is
the entire new version. Thanks!

package org;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.InetAddress;
import java.net.Socket;
import java.net.URL;
import java.net.URLConnection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.CancellationException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class Ping {

     // for the inner class PingTask
     static ExecutorService exec = Executors.newCachedThreadPool();
     private volatile int  flag = 0;
     private static int STOPPED = new Integer(0);
     private static int BEGIN_INIT = new Integer(1);
     private static int RUNNING = new Integer(2);
         private static Map <Integer, String> map;

     /** commons logging declaration. */
     private static Log logger = LogFactory.getLog(
               Ping.class);

     public static void main(String[] args) throws Exception {

             new Ping();
     }

     Ping () {
         ScheduledExecutorService ses =
Executors.newSingleThreadScheduledExecutor();
         // Do pings, starting now, with a 2 second delay in between
         ScheduledFuture <?> ping = ses.scheduleWithFixedDelay(new PingTask(),
             0L, 2000L, TimeUnit.MILLISECONDS);
     }

     static {
         map = new HashMap<Integer, String>();
         map.put(STOPPED, "STOPPED");
         map.put(BEGIN_INIT, "BEGIN_INIT");
         map.put(RUNNING, "RUNNING");
     }

     private synchronized void setFlag(int var) {
         flag = var;
     }

     /** Get message via an int.
      * @param code Integer mapped to message
      * @return String mapped message
      */
     public final String getMessage(int code) {
         return map.get(code);
     }

     class PingFuture implements Runnable {
         private void doConnect(String host, int port, boolean
on_connect, int state) {
             try {
                 logger.debug("connecting to host: " +host+ ", port: " + port);
                 InetAddress addr = InetAddress.getByName(host);
                 // will throw an exception if could not connect
                 Socket s = new Socket(addr, port);
                 s.close();
                 if (on_connect) {
                     logger.debug("Found port: " + port);
                     setFlag(state);
                 }

             } catch (Exception ex) {
                 logger.error("Can't find port: " + port);
                 logger.error(ex.getMessage(), ex);
                 if (!on_connect) {
                     setFlag(state);
                 }
             }

         }

         private void doConnect(URL host, boolean on_connect, int
state) throws IOException {
             InputStream is = null;
             BufferedReader in = null;
             try {
                 logger.debug("connecting to url: " + host.toString());
                 URLConnection uc = host.openConnection();
                 if (uc == null) {
                     logger.error("Got a null URLConnection object!");
                     return;
                 }
                 is = uc.getInputStream();
                 if (is == null) {
                     logger.error("Got a null content object!");
                     return;
                 }
                 in = new BufferedReader(new InputStreamReader(
                       is));
                 String inputLine;
                 // just test that its readable for now
                 while ((inputLine = in.readLine()) != null)  {
                       ;
                 }
                 if (on_connect) {
                     logger.debug("Found url: " + host.toString());
                     setFlag(state);
                 }

             } catch (Exception ex) {
                 logger.error("Can't find url: " + host.toString());
                 logger.error(ex.getMessage(), ex);
                 if (!on_connect) {
                     setFlag(state);
                 }
             } finally {
                 if (is != null) {
                     is.close();
                 }
                 if (in != null) {
                     in.close();
                 }
             }

         }

         public void run() {

             try {
                 if (flag == STOPPED) {
                     doConnect("localhost", 1099, true, BEGIN_INIT);
                 }
                 if (flag == BEGIN_INIT) {
                     // test state of stopped to prevent endless loop
                     doConnect("localhost", 1099, false, STOPPED);
                     doConnect(new
URL("http://localhost:8080/maragato/"), true, RUNNING);

                 }
                 if (flag == RUNNING) {
                     doConnect(new
URL("http://localhost:8080/maragato/"), false, STOPPED);
                 }

             } catch (Exception ex) {
                   logger.error(ex.getMessage(), ex);
             }
         }
     } // end inner class PingFuture

     class PingTask implements Runnable {


         public void run() {

             Future f = null;
             boolean interrupted = false;
             try {
                 f = exec.submit(new PingFuture());
                 f.get(5000, TimeUnit.MILLISECONDS);

             } catch (ExecutionException ex) {
                   interrupted = true;
                   logger.error("Future threw an error: \n" +
ex.getCause(), ex);
             } catch (CancellationException ex) {
                   interrupted = true;
                   logger.error("Future cancelled: \n" + ex.getCause(), ex);
             } catch (TimeoutException ex) {
                   interrupted = true;
                   logger.error("Future timed out: \n" + ex.getCause(), ex);
             } catch (InterruptedException ex) {
                   interrupted = true;
                   logger.error("Future interrupted: \n" + ex.getCause(), ex);
             } catch (Exception ex) {
                   logger.error("Unexpected error: \n" + ex.getMessage(), ex);
             }
             finally {
                 f.cancel(true);
                 logger.debug("CURRENT STATE: " + getMessage(flag));

             }
             if (interrupted) {
                 Thread.currentThread().interrupt();
             }
         }
     } // end inner class PingTask
}


On 8/22/06, Tim Peierls <tim at peierls.net> wrote:


On 8/22/06, Tim Peierls <tim at peierls.net> wrote:
> Also, instead of catching Exception, you can catch the more specific
> ExecutionException -- thrown by Future.get() -- and examine the underlying
> Throwable with getCause().
>
>
> --tim
>
>
> >
> >
> > On 8/22/06, robert lazarski <robertlazarski at gmail.com> wrote:
> > > I finally got some time to implement the latest suggestions of David
> > > and Tim. This is what I came up with:
> > >
> > > class PingTask implements Runnable {
> > >
> > >          public void run() {
> > >
> > >              Future f = null;
> > >              boolean interrupted = false;
> > >              try {
> > >                  ExecutorService exec = Executors.newCachedThreadPool();
> > >                  f = exec.submit(new PingFuture());
> > >                  f.get(5000, TimeUnit.MILLISECONDS);
> > >
> > >              } catch (TimeoutException ex) {
> > >                    interrupted = true;
> > >                    logger.error("Future timed out: \n" +
> ex.getMessage(), ex);
> > >              } catch (InterruptedException ex) {
> > >                    interrupted = true;
> > >                    logger.error ("Future interrupted: \n" +
> ex.getMessage(), ex);
> > >              } catch (Exception ex) {
> > >                    logger.error(ex.getMessage(), ex);
> > >              }
> > >              finally {
> > >                  f.cancel(true);
> > >                  logger.debug("CURRENT STATE: " + getMessage(flag));
> > >
> > >              }
> > >              if (interrupted) {
> > >                  Thread.currentThread().interrupt();
> > >              }
> > >          }
> > >      } // end inner class PingTask
> > >
> > > Thanks for the feedback!
> > > Robert
> > >
> >
>

From alarmnummer at gmail.com  Tue Aug 22 16:45:31 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Tue, 22 Aug 2006 22:45:31 +0200
Subject: [concurrency-interest] Problem #2: Reordering volatile and
	nonvolatile stores
Message-ID: <1466c1d60608221345u7206f8d9v8a078a0d9a9929a8@mail.gmail.com>

I have a question about the "Problem #2: Reordering volatile and
nonvolatile stores" mentioned in the article by Brian Goetz

http://www-128.ibm.com/developerworks/library/j-jtp02244.html

In the old vm it was allowed to reorden volatile and non volatile
stores and this could lead to non volatile fields that are not set.
But why is this bad? It is the consequence of being a non volatile
field.

The consequence is that a volatile field now has two responsibilities:
1) make sure that a value is read-from/written-to main memory instead of cache
2) prevent reordening with non volatile fields en synchronize them
with main memory before a volatile field is called.

I don't understand why the old behaviour is bad. The mistake of using
a non volatile field was made while information needs to be exchanged
in multiple threads. This sounds acceptable to me, so why is the
second responsibility added? Is this done to make jmm easier to use?
Or are their other reasons I'm missing?

From jmanson at cs.umd.edu  Tue Aug 22 17:00:46 2006
From: jmanson at cs.umd.edu (Jeremy Manson)
Date: Tue, 22 Aug 2006 14:00:46 -0700
Subject: [concurrency-interest] Problem #2: Reordering volatile
 and	nonvolatile stores
In-Reply-To: <1466c1d60608221345u7206f8d9v8a078a0d9a9929a8@mail.gmail.com>
References: <1466c1d60608221345u7206f8d9v8a078a0d9a9929a8@mail.gmail.com>
Message-ID: <44EB707E.4040109@cs.umd.edu>

Peter Veentjer wrote:
> I have a question about the "Problem #2: Reordering volatile and
> nonvolatile stores" mentioned in the article by Brian Goetz
> 
> http://www-128.ibm.com/developerworks/library/j-jtp02244.html
> 
> In the old vm it was allowed to reorden volatile and non volatile
> stores and this could lead to non volatile fields that are not set.
> But why is this bad? It is the consequence of being a non volatile
> field.

It is bad because the old behavior was basically useless, on account of 
the fact that it didn't support any of the use cases people actually 
have for volatiles.  Certainly, the overwhelming majority of the use 
cases I've heard of require this behavior.

To pick one use case at random, if you have:

int a = 0;
volatile boolean done = false;

Thread 1:
a = 1;
done = true;

Thread 2:
while (!done)
r1 = a;

Pretty much everyone wants the assignment to a to be seen by the second 
thread if the loop finishes.

Now, I suspect you will say that a should also be volatile.  But imagine 
what happens if a is a pointer to some enormous data structure, only 
some of which you can actually edit.  Should all of the reachable fields 
be made volatile, as well?  Ultimately, every field would need to be 
tagged volatile, just in case anyone ever wanted to use it in any sort 
of multithreaded context.


					Jeremy

From joe.bowbeer at gmail.com  Tue Aug 22 17:23:46 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 22 Aug 2006 14:23:46 -0700
Subject: [concurrency-interest] Problem #2: Reordering volatile and
	nonvolatile stores
In-Reply-To: <1466c1d60608221345u7206f8d9v8a078a0d9a9929a8@mail.gmail.com>
References: <1466c1d60608221345u7206f8d9v8a078a0d9a9929a8@mail.gmail.com>
Message-ID: <31f2a7bd0608221423p3febff31k56f2dc08c50e31f8@mail.gmail.com>

On 8/22/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> I have a question about the "Problem #2: Reordering volatile and
> nonvolatile stores" mentioned in the article by Brian Goetz
>
> http://www-128.ibm.com/developerworks/library/j-jtp02244.html
>
> In the old vm it was allowed to reorden volatile and non volatile
> stores and this could lead to non volatile fields that are not set.
> But why is this bad? It is the consequence of being a non volatile
> field.
>
> The consequence is that a volatile field now has two responsibilities:
> 1) make sure that a value is read-from/written-to main memory instead of cache
> 2) prevent reordening with non volatile fields en synchronize them
> with main memory before a volatile field is called.
>
> I don't understand why the old behaviour is bad. The mistake of using
> a non volatile field was made while information needs to be exchanged
> in multiple threads. This sounds acceptable to me, so why is the
> second responsibility added? Is this done to make jmm easier to use?
> Or are their other reasons I'm missing?
>

First of all, the old behavior was never completely specified, or
implemented, so it's hard to compare new with old.

As I understand the current spec, volatile reads and writes are
synchronization actions, similar in some ways to tiny one-statement
synchronized blocks.

To be effective as synchronization actions, it's important that the
rest of the code not move around too much.  Would you think it OK if
code outside of a synchronized block were allowed to jump over the
block?  (That would render ReentrantLock useless.)

Also see http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile

From alarmnummer at gmail.com  Tue Aug 22 17:29:28 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Tue, 22 Aug 2006 23:29:28 +0200
Subject: [concurrency-interest] Problem #2: Reordering volatile and
	nonvolatile stores
In-Reply-To: <44EB707E.4040109@cs.umd.edu>
References: <1466c1d60608221345u7206f8d9v8a078a0d9a9929a8@mail.gmail.com>
	<44EB707E.4040109@cs.umd.edu>
Message-ID: <1466c1d60608221429y7b9331b1v6b0d8bb9cc9223eb@mail.gmail.com>

Hmmm.. that sounds reasonable. Thank you.

On 8/22/06, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> Peter Veentjer wrote:
> > I have a question about the "Problem #2: Reordering volatile and
> > nonvolatile stores" mentioned in the article by Brian Goetz
> >
> > http://www-128.ibm.com/developerworks/library/j-jtp02244.html
> >
> > In the old vm it was allowed to reorden volatile and non volatile
> > stores and this could lead to non volatile fields that are not set.
> > But why is this bad? It is the consequence of being a non volatile
> > field.
>
> It is bad because the old behavior was basically useless, on account of
> the fact that it didn't support any of the use cases people actually
> have for volatiles.  Certainly, the overwhelming majority of the use
> cases I've heard of require this behavior.
>
> To pick one use case at random, if you have:
>
> int a = 0;
> volatile boolean done = false;
>
> Thread 1:
> a = 1;
> done = true;
>
> Thread 2:
> while (!done)
> r1 = a;
>
> Pretty much everyone wants the assignment to a to be seen by the second
> thread if the loop finishes.
>
> Now, I suspect you will say that a should also be volatile.  But imagine
> what happens if a is a pointer to some enormous data structure, only
> some of which you can actually edit.  Should all of the reachable fields
> be made volatile, as well?  Ultimately, every field would need to be
> tagged volatile, just in case anyone ever wanted to use it in any sort
> of multithreaded context.
>
>
>                                         Jeremy
>

From dhanji at gmail.com  Tue Aug 22 19:45:10 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Wed, 23 Aug 2006 09:45:10 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <f87675ee0608220703v670e467ak33db20283dee8933@mail.gmail.com>
References: <f87675ee0608170756o3df9b556k2dabcfdbfcae3cae@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEHDHBAA.dcholmes@optusnet.com.au>
	<f87675ee0608220628l2a1cd2b2h19ce39af3105ad99@mail.gmail.com>
	<63b4e4050608220642r2bf9b44ek562f485519c73a15@mail.gmail.com>
	<63b4e4050608220647t57901da2i564fcf1bc4c681c7@mail.gmail.com>
	<f87675ee0608220703v670e467ak33db20283dee8933@mail.gmail.com>
Message-ID: <aa067ea10608221645o4fac00e5p3d2395a9691ba2c4@mail.gmail.com>

Im curious, what is the purpose of declaring flag volatile AND
synchronizing setter access to it?

If it is volatile it will (could) be overwritten concurrently in a
visible manner anyway. Afaik the purpose of synchronizing access to a
field is to prevent diverging concurrent states (i.e. multiple states
of the same variable cached in separate threads and merged back
non-deterministically), afaik this is a moot point since the field is
volatile--a read should yield the same value of "flag" for all threads
should it not?

Since there is no happens-before edge established in setFlag(), I fail
to see how synchronizing it does anything useful?

I may very well be missing something here...

On 8/23/06, robert lazarski <robertlazarski at gmail.com> wrote:
> Thanks Tim. If its any consolation, I did buy the concurrency in
> practice book and I'm reading it every day, though I just started ;-)
> . PingTask is an inner class and can't have static vars , so this is
> the entire new version. Thanks!
>
> package org;
>
> import java.io.BufferedReader;
> import java.io.IOException;
> import java.io.InputStream;
> import java.io.InputStreamReader;
> import java.net.InetAddress;
> import java.net.Socket;
> import java.net.URL;
> import java.net.URLConnection;
> import java.util.HashMap;
> import java.util.Map;
> import java.util.concurrent.Executors;
> import java.util.concurrent.FutureTask;
> import java.util.concurrent.ScheduledExecutorService;
> import java.util.concurrent.ScheduledFuture;
> import java.util.concurrent.TimeUnit;
> import java.util.concurrent.ExecutorService;
> import java.util.concurrent.Executors;
> import java.util.concurrent.Future;
> import java.util.concurrent.TimeoutException;
> import java.util.concurrent.ExecutionException;
> import java.util.concurrent.CancellationException;
>
> import org.apache.commons.logging.Log;
> import org.apache.commons.logging.LogFactory;
>
> public class Ping {
>
>      // for the inner class PingTask
>      static ExecutorService exec = Executors.newCachedThreadPool();
>      private volatile int  flag = 0;
>      private static int STOPPED = new Integer(0);
>      private static int BEGIN_INIT = new Integer(1);
>      private static int RUNNING = new Integer(2);
>          private static Map <Integer, String> map;
>
>      /** commons logging declaration. */
>      private static Log logger = LogFactory.getLog(
>                Ping.class);
>
>      public static void main(String[] args) throws Exception {
>
>              new Ping();
>      }
>
>      Ping () {
>          ScheduledExecutorService ses =
> Executors.newSingleThreadScheduledExecutor();
>          // Do pings, starting now, with a 2 second delay in between
>          ScheduledFuture <?> ping = ses.scheduleWithFixedDelay(new PingTask(),
>              0L, 2000L, TimeUnit.MILLISECONDS);
>      }
>
>      static {
>          map = new HashMap<Integer, String>();
>          map.put(STOPPED, "STOPPED");
>          map.put(BEGIN_INIT, "BEGIN_INIT");
>          map.put(RUNNING, "RUNNING");
>      }
>
>      private synchronized void setFlag(int var) {
>          flag = var;
>      }
>
>      /** Get message via an int.
>       * @param code Integer mapped to message
>       * @return String mapped message
>       */
>      public final String getMessage(int code) {
>          return map.get(code);
>      }
>
>      class PingFuture implements Runnable {
>          private void doConnect(String host, int port, boolean
> on_connect, int state) {
>              try {
>                  logger.debug("connecting to host: " +host+ ", port: " + port);
>                  InetAddress addr = InetAddress.getByName(host);
>                  // will throw an exception if could not connect
>                  Socket s = new Socket(addr, port);
>                  s.close();
>                  if (on_connect) {
>                      logger.debug("Found port: " + port);
>                      setFlag(state);
>                  }
>
>              } catch (Exception ex) {
>                  logger.error("Can't find port: " + port);
>                  logger.error(ex.getMessage(), ex);
>                  if (!on_connect) {
>                      setFlag(state);
>                  }
>              }
>
>          }
>
>          private void doConnect(URL host, boolean on_connect, int
> state) throws IOException {
>              InputStream is = null;
>              BufferedReader in = null;
>              try {
>                  logger.debug("connecting to url: " + host.toString());
>                  URLConnection uc = host.openConnection();
>                  if (uc == null) {
>                      logger.error("Got a null URLConnection object!");
>                      return;
>                  }
>                  is = uc.getInputStream();
>                  if (is == null) {
>                      logger.error("Got a null content object!");
>                      return;
>                  }
>                  in = new BufferedReader(new InputStreamReader(
>                        is));
>                  String inputLine;
>                  // just test that its readable for now
>                  while ((inputLine = in.readLine()) != null)  {
>                        ;
>                  }
>                  if (on_connect) {
>                      logger.debug("Found url: " + host.toString());
>                      setFlag(state);
>                  }
>
>              } catch (Exception ex) {
>                  logger.error("Can't find url: " + host.toString());
>                  logger.error(ex.getMessage(), ex);
>                  if (!on_connect) {
>                      setFlag(state);
>                  }
>              } finally {
>                  if (is != null) {
>                      is.close();
>                  }
>                  if (in != null) {
>                      in.close();
>                  }
>              }
>
>          }
>
>          public void run() {
>
>              try {
>                  if (flag == STOPPED) {
>                      doConnect("localhost", 1099, true, BEGIN_INIT);
>                  }
>                  if (flag == BEGIN_INIT) {
>                      // test state of stopped to prevent endless loop
>                      doConnect("localhost", 1099, false, STOPPED);
>                      doConnect(new
> URL("http://localhost:8080/maragato/"), true, RUNNING);
>
>                  }
>                  if (flag == RUNNING) {
>                      doConnect(new
> URL("http://localhost:8080/maragato/"), false, STOPPED);
>                  }
>
>              } catch (Exception ex) {
>                    logger.error(ex.getMessage(), ex);
>              }
>          }
>      } // end inner class PingFuture
>
>      class PingTask implements Runnable {
>
>
>          public void run() {
>
>              Future f = null;
>              boolean interrupted = false;
>              try {
>                  f = exec.submit(new PingFuture());
>                  f.get(5000, TimeUnit.MILLISECONDS);
>
>              } catch (ExecutionException ex) {
>                    interrupted = true;
>                    logger.error("Future threw an error: \n" +
> ex.getCause(), ex);
>              } catch (CancellationException ex) {
>                    interrupted = true;
>                    logger.error("Future cancelled: \n" + ex.getCause(), ex);
>              } catch (TimeoutException ex) {
>                    interrupted = true;
>                    logger.error("Future timed out: \n" + ex.getCause(), ex);
>              } catch (InterruptedException ex) {
>                    interrupted = true;
>                    logger.error("Future interrupted: \n" + ex.getCause(), ex);
>              } catch (Exception ex) {
>                    logger.error("Unexpected error: \n" + ex.getMessage(), ex);
>              }
>              finally {
>                  f.cancel(true);
>                  logger.debug("CURRENT STATE: " + getMessage(flag));
>
>              }
>              if (interrupted) {
>                  Thread.currentThread().interrupt();
>              }
>          }
>      } // end inner class PingTask
> }
>
>
> On 8/22/06, Tim Peierls <tim at peierls.net> wrote:
>
>
> On 8/22/06, Tim Peierls <tim at peierls.net> wrote:
> > Also, instead of catching Exception, you can catch the more specific
> > ExecutionException -- thrown by Future.get() -- and examine the underlying
> > Throwable with getCause().
> >
> >
> > --tim
> >
> >
> > >
> > >
> > > On 8/22/06, robert lazarski <robertlazarski at gmail.com> wrote:
> > > > I finally got some time to implement the latest suggestions of David
> > > > and Tim. This is what I came up with:
> > > >
> > > > class PingTask implements Runnable {
> > > >
> > > >          public void run() {
> > > >
> > > >              Future f = null;
> > > >              boolean interrupted = false;
> > > >              try {
> > > >                  ExecutorService exec = Executors.newCachedThreadPool();
> > > >                  f = exec.submit(new PingFuture());
> > > >                  f.get(5000, TimeUnit.MILLISECONDS);
> > > >
> > > >              } catch (TimeoutException ex) {
> > > >                    interrupted = true;
> > > >                    logger.error("Future timed out: \n" +
> > ex.getMessage(), ex);
> > > >              } catch (InterruptedException ex) {
> > > >                    interrupted = true;
> > > >                    logger.error ("Future interrupted: \n" +
> > ex.getMessage(), ex);
> > > >              } catch (Exception ex) {
> > > >                    logger.error(ex.getMessage(), ex);
> > > >              }
> > > >              finally {
> > > >                  f.cancel(true);
> > > >                  logger.debug("CURRENT STATE: " + getMessage(flag));
> > > >
> > > >              }
> > > >              if (interrupted) {
> > > >                  Thread.currentThread().interrupt();
> > > >              }
> > > >          }
> > > >      } // end inner class PingTask
> > > >
> > > > Thanks for the feedback!
> > > > Robert
> > > >
> > >
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From robertlazarski at gmail.com  Tue Aug 22 19:50:18 2006
From: robertlazarski at gmail.com (robert lazarski)
Date: Tue, 22 Aug 2006 20:50:18 -0300
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <aa067ea10608221645o4fac00e5p3d2395a9691ba2c4@mail.gmail.com>
References: <f87675ee0608170756o3df9b556k2dabcfdbfcae3cae@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEHDHBAA.dcholmes@optusnet.com.au>
	<f87675ee0608220628l2a1cd2b2h19ce39af3105ad99@mail.gmail.com>
	<63b4e4050608220642r2bf9b44ek562f485519c73a15@mail.gmail.com>
	<63b4e4050608220647t57901da2i564fcf1bc4c681c7@mail.gmail.com>
	<f87675ee0608220703v670e467ak33db20283dee8933@mail.gmail.com>
	<aa067ea10608221645o4fac00e5p3d2395a9691ba2c4@mail.gmail.com>
Message-ID: <f87675ee0608221650y256edabby633792e2c6d18fef@mail.gmail.com>

It was due to advice from Joe BowBeer:

" 1. setFlag is synchronized but there is no synchronized getFlag method.

Either added synchronized getFlag, or declare flag to be "volatile". "

Robert

On 8/22/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> Im curious, what is the purpose of declaring flag volatile AND
> synchronizing setter access to it?
>
> If it is volatile it will (could) be overwritten concurrently in a
> visible manner anyway. Afaik the purpose of synchronizing access to a
> field is to prevent diverging concurrent states (i.e. multiple states
> of the same variable cached in separate threads and merged back
> non-deterministically), afaik this is a moot point since the field is
> volatile--a read should yield the same value of "flag" for all threads
> should it not?
>
> Since there is no happens-before edge established in setFlag(), I fail
> to see how synchronizing it does anything useful?
>
> I may very well be missing something here...
>
> On 8/23/06, robert lazarski <robertlazarski at gmail.com> wrote:
> > Thanks Tim. If its any consolation, I did buy the concurrency in
> > practice book and I'm reading it every day, though I just started ;-)
> > . PingTask is an inner class and can't have static vars , so this is
> > the entire new version. Thanks!
> >
> > package org;
> >
> > import java.io.BufferedReader;
> > import java.io.IOException;
> > import java.io.InputStream;
> > import java.io.InputStreamReader;
> > import java.net.InetAddress;
> > import java.net.Socket;
> > import java.net.URL;
> > import java.net.URLConnection;
> > import java.util.HashMap;
> > import java.util.Map;
> > import java.util.concurrent.Executors;
> > import java.util.concurrent.FutureTask;
> > import java.util.concurrent.ScheduledExecutorService;
> > import java.util.concurrent.ScheduledFuture;
> > import java.util.concurrent.TimeUnit;
> > import java.util.concurrent.ExecutorService;
> > import java.util.concurrent.Executors;
> > import java.util.concurrent.Future;
> > import java.util.concurrent.TimeoutException;
> > import java.util.concurrent.ExecutionException;
> > import java.util.concurrent.CancellationException;
> >
> > import org.apache.commons.logging.Log;
> > import org.apache.commons.logging.LogFactory;
> >
> > public class Ping {
> >
> >      // for the inner class PingTask
> >      static ExecutorService exec = Executors.newCachedThreadPool();
> >      private volatile int  flag = 0;
> >      private static int STOPPED = new Integer(0);
> >      private static int BEGIN_INIT = new Integer(1);
> >      private static int RUNNING = new Integer(2);
> >          private static Map <Integer, String> map;
> >
> >      /** commons logging declaration. */
> >      private static Log logger = LogFactory.getLog(
> >                Ping.class);
> >
> >      public static void main(String[] args) throws Exception {
> >
> >              new Ping();
> >      }
> >
> >      Ping () {
> >          ScheduledExecutorService ses =
> > Executors.newSingleThreadScheduledExecutor();
> >          // Do pings, starting now, with a 2 second delay in between
> >          ScheduledFuture <?> ping = ses.scheduleWithFixedDelay(new PingTask(),
> >              0L, 2000L, TimeUnit.MILLISECONDS);
> >      }
> >
> >      static {
> >          map = new HashMap<Integer, String>();
> >          map.put(STOPPED, "STOPPED");
> >          map.put(BEGIN_INIT, "BEGIN_INIT");
> >          map.put(RUNNING, "RUNNING");
> >      }
> >
> >      private synchronized void setFlag(int var) {
> >          flag = var;
> >      }
> >
> >      /** Get message via an int.
> >       * @param code Integer mapped to message
> >       * @return String mapped message
> >       */
> >      public final String getMessage(int code) {
> >          return map.get(code);
> >      }
> >
> >      class PingFuture implements Runnable {
> >          private void doConnect(String host, int port, boolean
> > on_connect, int state) {
> >              try {
> >                  logger.debug("connecting to host: " +host+ ", port: " + port);
> >                  InetAddress addr = InetAddress.getByName(host);
> >                  // will throw an exception if could not connect
> >                  Socket s = new Socket(addr, port);
> >                  s.close();
> >                  if (on_connect) {
> >                      logger.debug("Found port: " + port);
> >                      setFlag(state);
> >                  }
> >
> >              } catch (Exception ex) {
> >                  logger.error("Can't find port: " + port);
> >                  logger.error(ex.getMessage(), ex);
> >                  if (!on_connect) {
> >                      setFlag(state);
> >                  }
> >              }
> >
> >          }
> >
> >          private void doConnect(URL host, boolean on_connect, int
> > state) throws IOException {
> >              InputStream is = null;
> >              BufferedReader in = null;
> >              try {
> >                  logger.debug("connecting to url: " + host.toString());
> >                  URLConnection uc = host.openConnection();
> >                  if (uc == null) {
> >                      logger.error("Got a null URLConnection object!");
> >                      return;
> >                  }
> >                  is = uc.getInputStream();
> >                  if (is == null) {
> >                      logger.error("Got a null content object!");
> >                      return;
> >                  }
> >                  in = new BufferedReader(new InputStreamReader(
> >                        is));
> >                  String inputLine;
> >                  // just test that its readable for now
> >                  while ((inputLine = in.readLine()) != null)  {
> >                        ;
> >                  }
> >                  if (on_connect) {
> >                      logger.debug("Found url: " + host.toString());
> >                      setFlag(state);
> >                  }
> >
> >              } catch (Exception ex) {
> >                  logger.error("Can't find url: " + host.toString());
> >                  logger.error(ex.getMessage(), ex);
> >                  if (!on_connect) {
> >                      setFlag(state);
> >                  }
> >              } finally {
> >                  if (is != null) {
> >                      is.close();
> >                  }
> >                  if (in != null) {
> >                      in.close();
> >                  }
> >              }
> >
> >          }
> >
> >          public void run() {
> >
> >              try {
> >                  if (flag == STOPPED) {
> >                      doConnect("localhost", 1099, true, BEGIN_INIT);
> >                  }
> >                  if (flag == BEGIN_INIT) {
> >                      // test state of stopped to prevent endless loop
> >                      doConnect("localhost", 1099, false, STOPPED);
> >                      doConnect(new
> > URL("http://localhost:8080/maragato/"), true, RUNNING);
> >
> >                  }
> >                  if (flag == RUNNING) {
> >                      doConnect(new
> > URL("http://localhost:8080/maragato/"), false, STOPPED);
> >                  }
> >
> >              } catch (Exception ex) {
> >                    logger.error(ex.getMessage(), ex);
> >              }
> >          }
> >      } // end inner class PingFuture
> >
> >      class PingTask implements Runnable {
> >
> >
> >          public void run() {
> >
> >              Future f = null;
> >              boolean interrupted = false;
> >              try {
> >                  f = exec.submit(new PingFuture());
> >                  f.get(5000, TimeUnit.MILLISECONDS);
> >
> >              } catch (ExecutionException ex) {
> >                    interrupted = true;
> >                    logger.error("Future threw an error: \n" +
> > ex.getCause(), ex);
> >              } catch (CancellationException ex) {
> >                    interrupted = true;
> >                    logger.error("Future cancelled: \n" + ex.getCause(), ex);
> >              } catch (TimeoutException ex) {
> >                    interrupted = true;
> >                    logger.error("Future timed out: \n" + ex.getCause(), ex);
> >              } catch (InterruptedException ex) {
> >                    interrupted = true;
> >                    logger.error("Future interrupted: \n" + ex.getCause(), ex);
> >              } catch (Exception ex) {
> >                    logger.error("Unexpected error: \n" + ex.getMessage(), ex);
> >              }
> >              finally {
> >                  f.cancel(true);
> >                  logger.debug("CURRENT STATE: " + getMessage(flag));
> >
> >              }
> >              if (interrupted) {
> >                  Thread.currentThread().interrupt();
> >              }
> >          }
> >      } // end inner class PingTask
> > }
> >
> >
> > On 8/22/06, Tim Peierls <tim at peierls.net> wrote:
> >
> >
> > On 8/22/06, Tim Peierls <tim at peierls.net> wrote:
> > > Also, instead of catching Exception, you can catch the more specific
> > > ExecutionException -- thrown by Future.get() -- and examine the underlying
> > > Throwable with getCause().
> > >
> > >
> > > --tim
> > >
> > >
> > > >
> > > >
> > > > On 8/22/06, robert lazarski <robertlazarski at gmail.com> wrote:
> > > > > I finally got some time to implement the latest suggestions of David
> > > > > and Tim. This is what I came up with:
> > > > >
> > > > > class PingTask implements Runnable {
> > > > >
> > > > >          public void run() {
> > > > >
> > > > >              Future f = null;
> > > > >              boolean interrupted = false;
> > > > >              try {
> > > > >                  ExecutorService exec = Executors.newCachedThreadPool();
> > > > >                  f = exec.submit(new PingFuture());
> > > > >                  f.get(5000, TimeUnit.MILLISECONDS);
> > > > >
> > > > >              } catch (TimeoutException ex) {
> > > > >                    interrupted = true;
> > > > >                    logger.error("Future timed out: \n" +
> > > ex.getMessage(), ex);
> > > > >              } catch (InterruptedException ex) {
> > > > >                    interrupted = true;
> > > > >                    logger.error ("Future interrupted: \n" +
> > > ex.getMessage(), ex);
> > > > >              } catch (Exception ex) {
> > > > >                    logger.error(ex.getMessage(), ex);
> > > > >              }
> > > > >              finally {
> > > > >                  f.cancel(true);
> > > > >                  logger.debug("CURRENT STATE: " + getMessage(flag));
> > > > >
> > > > >              }
> > > > >              if (interrupted) {
> > > > >                  Thread.currentThread().interrupt();
> > > > >              }
> > > > >          }
> > > > >      } // end inner class PingTask
> > > > >
> > > > > Thanks for the feedback!
> > > > > Robert
> > > > >
> > > >
> > >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>

From dcholmes at optusnet.com.au  Tue Aug 22 20:06:53 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 23 Aug 2006 10:06:53 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <aa067ea10608221645o4fac00e5p3d2395a9691ba2c4@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEKIHBAA.dcholmes@optusnet.com.au>

> Dhanji R. Prasanna writes:
> Im curious, what is the purpose of declaring flag volatile AND
> synchronizing setter access to it?

It gives you a simple/crude read/write lock.

David Holmes

From dhanji at gmail.com  Tue Aug 22 20:09:41 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Wed, 23 Aug 2006 10:09:41 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEKIHBAA.dcholmes@optusnet.com.au>
References: <aa067ea10608221645o4fac00e5p3d2395a9691ba2c4@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEKIHBAA.dcholmes@optusnet.com.au>
Message-ID: <aa067ea10608221709x20e635aem5cb56f563c69aafe@mail.gmail.com>

so the volatile field cant be read when a thread is in its synchronized setter?

On 8/23/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > Dhanji R. Prasanna writes:
> > Im curious, what is the purpose of declaring flag volatile AND
> > synchronizing setter access to it?
>
> It gives you a simple/crude read/write lock.
>
> David Holmes
>

From dcholmes at optusnet.com.au  Tue Aug 22 20:12:51 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 23 Aug 2006 10:12:51 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <aa067ea10608221709x20e635aem5cb56f563c69aafe@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEKIHBAA.dcholmes@optusnet.com.au>

> so the volatile field cant be read when a thread is in its
> synchronized setter?

Yes it can, but the assignment in the setter is atomic so the semantics are
"as if" the read occurred just before or just after the synchronized
operation.

It's a degenerate case of a read/write lock. You never have to exclude the
writer with respect to the reader because the action of the writer is atomic
with respect to the reader anyway. Of course that breaks down if more than
one assignment were involved.

Cheers,
David Holmes

> On 8/23/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > > Dhanji R. Prasanna writes:
> > > Im curious, what is the purpose of declaring flag volatile AND
> > > synchronizing setter access to it?
> >
> > It gives you a simple/crude read/write lock.
> >
> > David Holmes
> >


From dcholmes at optusnet.com.au  Tue Aug 22 20:34:22 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 23 Aug 2006 10:34:22 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEKIHBAA.dcholmes@optusnet.com.au>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEKJHBAA.dcholmes@optusnet.com.au>

I hasten to add that if the setter is simply of the form:

synchronized void set(int newValue) {
   field = newValue;
}

and field is volatile, then making the setter synchronized is unnecessary.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of David
> Holmes
> Sent: Wednesday, 23 August 2006 10:13 AM
> To: Dhanji R. Prasanna
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Simple ScheduledFuture problem
>
>
> > so the volatile field cant be read when a thread is in its
> > synchronized setter?
>
> Yes it can, but the assignment in the setter is atomic so the
> semantics are
> "as if" the read occurred just before or just after the synchronized
> operation.
>
> It's a degenerate case of a read/write lock. You never have to exclude the
> writer with respect to the reader because the action of the
> writer is atomic
> with respect to the reader anyway. Of course that breaks down if more than
> one assignment were involved.
>
> Cheers,
> David Holmes
>
> > On 8/23/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > > > Dhanji R. Prasanna writes:
> > > > Im curious, what is the purpose of declaring flag volatile AND
> > > > synchronizing setter access to it?
> > >
> > > It gives you a simple/crude read/write lock.
> > >
> > > David Holmes
> > >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From dhanji at gmail.com  Tue Aug 22 20:40:09 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Wed, 23 Aug 2006 10:40:09 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEKJHBAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCIEKIHBAA.dcholmes@optusnet.com.au>
	<NFBBKALFDCPFIDBNKAPCCEKJHBAA.dcholmes@optusnet.com.au>
Message-ID: <aa067ea10608221740s1318c425tb0a51fbd858e63f@mail.gmail.com>

On 8/23/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> I hasten to add that if the setter is simply of the form:
>
> synchronized void set(int newValue) {
>    field = newValue;
> }
>
> and field is volatile, then making the setter synchronized is unnecessary.

This was pretty much my whole argument =)

Dhanji

>
> David
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of David
> > Holmes
> > Sent: Wednesday, 23 August 2006 10:13 AM
> > To: Dhanji R. Prasanna
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Simple ScheduledFuture problem
> >
> >
> > > so the volatile field cant be read when a thread is in its
> > > synchronized setter?
> >
> > Yes it can, but the assignment in the setter is atomic so the
> > semantics are
> > "as if" the read occurred just before or just after the synchronized
> > operation.
> >
> > It's a degenerate case of a read/write lock. You never have to exclude the
> > writer with respect to the reader because the action of the
> > writer is atomic
> > with respect to the reader anyway. Of course that breaks down if more than
> > one assignment were involved.
> >
> > Cheers,
> > David Holmes
> >
> > > On 8/23/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > > > > Dhanji R. Prasanna writes:
> > > > > Im curious, what is the purpose of declaring flag volatile AND
> > > > > synchronizing setter access to it?
> > > >
> > > > It gives you a simple/crude read/write lock.
> > > >
> > > > David Holmes
> > > >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From dcholmes at optusnet.com.au  Tue Aug 22 20:41:35 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 23 Aug 2006 10:41:35 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <aa067ea10608221740s1318c425tb0a51fbd858e63f@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEKJHBAA.dcholmes@optusnet.com.au>

Sorry. I focussed on the general question rather then the specific code in
this case.

David

> -----Original Message-----
> From: Dhanji R. Prasanna [mailto:dhanji at gmail.com]
> Sent: Wednesday, 23 August 2006 10:40 AM
> To: dholmes at ieee.org
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Simple ScheduledFuture problem
>
>
> On 8/23/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > I hasten to add that if the setter is simply of the form:
> >
> > synchronized void set(int newValue) {
> >    field = newValue;
> > }
> >
> > and field is volatile, then making the setter synchronized is
> unnecessary.
>
> This was pretty much my whole argument =)
>
> Dhanji
>
> >
> > David
> >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of David
> > > Holmes
> > > Sent: Wednesday, 23 August 2006 10:13 AM
> > > To: Dhanji R. Prasanna
> > > Cc: concurrency-interest at cs.oswego.edu
> > > Subject: Re: [concurrency-interest] Simple ScheduledFuture problem
> > >
> > >
> > > > so the volatile field cant be read when a thread is in its
> > > > synchronized setter?
> > >
> > > Yes it can, but the assignment in the setter is atomic so the
> > > semantics are
> > > "as if" the read occurred just before or just after the synchronized
> > > operation.
> > >
> > > It's a degenerate case of a read/write lock. You never have
> to exclude the
> > > writer with respect to the reader because the action of the
> > > writer is atomic
> > > with respect to the reader anyway. Of course that breaks down
> if more than
> > > one assignment were involved.
> > >
> > > Cheers,
> > > David Holmes
> > >
> > > > On 8/23/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > > > > > Dhanji R. Prasanna writes:
> > > > > > Im curious, what is the purpose of declaring flag volatile AND
> > > > > > synchronizing setter access to it?
> > > > >
> > > > > It gives you a simple/crude read/write lock.
> > > > >
> > > > > David Holmes
> > > > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >


From dhanji at gmail.com  Wed Aug 23 00:06:48 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Wed, 23 Aug 2006 14:06:48 +1000
Subject: [concurrency-interest] atomic references
Message-ID: <aa067ea10608222106y193cb07fm4960053b6524ed46@mail.gmail.com>

Hi

Ive a bit of an issue with AtomicReference. Semantically all the
atomic wrappers (AtomicInteger, AtomicLong etc.) perform an equals
comparison on a compareAndSet or weakCompareAndSet.

However, it is not clear if AtomicReference performs an == or an
equals() comparison. As we know v1 == v2 can be entirely different
from v1.equals(v2). Can anyone shed some light on which type of
comparison is done?

Furthermore, assuming the former (==), is it not incongruous for
AtomicReference to do a reference comparison while other atomics do a
value comparison (on primitives)? Im curious about this one.

Thanks

Dhanji.

From jmanson at cs.umd.edu  Wed Aug 23 00:31:08 2006
From: jmanson at cs.umd.edu (Jeremy Manson)
Date: Tue, 22 Aug 2006 21:31:08 -0700
Subject: [concurrency-interest] atomic references
In-Reply-To: <aa067ea10608222106y193cb07fm4960053b6524ed46@mail.gmail.com>
References: <aa067ea10608222106y193cb07fm4960053b6524ed46@mail.gmail.com>
Message-ID: <44EBDA0C.9060904@cs.umd.edu>

Dhanji R. Prasanna wrote:

> However, it is not clear if AtomicReference performs an == or an 
> equals() comparison. As we know v1 == v2 can be entirely different 
> from v1.equals(v2). Can anyone shed some light on which type of 
> comparison is done?

 From the JavaDoc:

> compareAndSet(V expect, V update)
> Atomically set the value to the given updated value if the current
> value == the expected value.

(and similarly for weakCompareAndSet)

So I would say you are getting a == comparison.  :)

> Furthermore, assuming the former (==), is it not incongruous for 
> AtomicReference to do a reference comparison while other atomics do a
> value comparison (on primitives)? Im curious about this one.

I think that the thing that must be understood about these classes is
that they are basically wrappers for hardware level atomic operations.
If there were a widely available hardware level atomic operation that
allowed you to do a CAS on more than 64 bits, then you would probably
get it.

OTOH, equals() doesn't have to test for equality at all.  It can do
something completely different.  Making it look atomic would be an
enormous undertaking.  If you are interested in that sort of thing,
you can look at the literature on software transactions, but none of it
is ready for deployment on a production system, really.

					Jeremy

From dcholmes at optusnet.com.au  Wed Aug 23 00:37:52 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 23 Aug 2006 14:37:52 +1000
Subject: [concurrency-interest] atomic references
In-Reply-To: <aa067ea10608222106y193cb07fm4960053b6524ed46@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEKLHBAA.dcholmes@optusnet.com.au>

Dhanji,

> However, it is not clear if AtomicReference performs an == or an
> equals() comparison. As we know v1 == v2 can be entirely different
> from v1.equals(v2). Can anyone shed some light on which type of
> comparison is done?

If you think about the purpose of atomics it can only be a reference
comparison ==. These are "raw" memory operations. And this is documented in
AtomicReference.compareAndSet/weakCompareAndSet


> Furthermore, assuming the former (==), is it not incongruous for
> AtomicReference to do a reference comparison while other atomics do a
> value comparison (on primitives)? Im curious about this one.

== is always a value comparison - for AtomicReference the value being
compared is a reference.

For non-objects identity and equivalence are the same thing.

David Holmes


From alarmnummer at gmail.com  Wed Aug 23 05:30:47 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 23 Aug 2006 11:30:47 +0200
Subject: [concurrency-interest] Primitives wrappers and visibility problems
Message-ID: <1466c1d60608230230y3bffbea3rbc291aed89381547@mail.gmail.com>

I have another question about visibility problems. Someone suggested
to me that the primitve wrappers (like Integer) don't use a final
field for the primitive they contain. This would make them not
threadsafe. Is this correct?

From kav at it.edu  Wed Aug 23 05:45:43 2006
From: kav at it.edu (Kasper Nielsen)
Date: Wed, 23 Aug 2006 11:45:43 +0200
Subject: [concurrency-interest] Primitives wrappers and visibility
	problems
In-Reply-To: <1466c1d60608230230y3bffbea3rbc291aed89381547@mail.gmail.com>
References: <1466c1d60608230230y3bffbea3rbc291aed89381547@mail.gmail.com>
Message-ID: <44EC23C6.1090605@it.edu>

Peter Veentjer wrote:
> I have another question about visibility problems. Someone suggested
> to me that the primitve wrappers (like Integer) don't use a final
> field for the primitive they contain. This would make them not
> threadsafe. Is this correct?
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

You could take a peek in the source:

     /**
      * The value of the <code>Integer</code>.
      *
      * @serial
      */
     private final int value;

     /**
      * Constructs a newly allocated <code>Integer</code> object that
      * represents the specified <code>int</code> value.
      *
      * @param   value   the value to be represented by the
      *			<code>Integer</code> object.
      */
     public Integer(int value) {
	this.value = value;
     }

- Kasper

From matthias.ernst at coremedia.com  Wed Aug 23 05:52:16 2006
From: matthias.ernst at coremedia.com (Ernst, Matthias)
Date: Wed, 23 Aug 2006 11:52:16 +0200
Subject: [concurrency-interest] Primitives wrappers and visibility
	problems
Message-ID: <9DC7096A2275564C9E2CF5042569976D28B5DD@hermes.coremedia.com>

> I have another question about visibility problems. Someone suggested
> to me that the primitve wrappers (like Integer) don't use a final
> field for the primitive they contain. This would make them not
> threadsafe. Is this correct?

I was about to write a lengthy response. It turns out that someone's
suggestion is just wrong:

java.lang.Integer at Java 1.5.0_07:
    /**
     * The value of the <code>Integer</code>.
     *
     * @serial
     */
    private final int value;


Matthias


From alarmnummer at gmail.com  Wed Aug 23 05:55:29 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 23 Aug 2006 11:55:29 +0200
Subject: [concurrency-interest] Primitives wrappers and visibility
	problems
In-Reply-To: <44EC23C6.1090605@it.edu>
References: <1466c1d60608230230y3bffbea3rbc291aed89381547@mail.gmail.com>
	<44EC23C6.1090605@it.edu>
Message-ID: <1466c1d60608230255h36a21b39v7ca60b278d7fbbae@mail.gmail.com>

I have checked the source of java 1.3.1.18 and it doesn't contain a
final. The final must have been introduced in 1.4 or 1.5.

And the final doesn't add any value in vm that 'support' the older JMM anyway ;)

But it is good to know it is final in the newest version of Java.

On 8/23/06, Kasper Nielsen <kav at it.edu> wrote:
> Peter Veentjer wrote:
> > I have another question about visibility problems. Someone suggested
> > to me that the primitve wrappers (like Integer) don't use a final
> > field for the primitive they contain. This would make them not
> > threadsafe. Is this correct?
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
> You could take a peek in the source:
>
>     /**
>      * The value of the <code>Integer</code>.
>      *
>      * @serial
>      */
>     private final int value;
>
>     /**
>      * Constructs a newly allocated <code>Integer</code> object that
>      * represents the specified <code>int</code> value.
>      *
>      * @param   value   the value to be represented by the
>      *                 <code>Integer</code> object.
>      */
>     public Integer(int value) {
>        this.value = value;
>     }
>
> - Kasper
>

From joe.bowbeer at gmail.com  Wed Aug 23 05:55:51 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 23 Aug 2006 02:55:51 -0700
Subject: [concurrency-interest] Primitives wrappers and visibility
	problems
In-Reply-To: <1466c1d60608230230y3bffbea3rbc291aed89381547@mail.gmail.com>
References: <1466c1d60608230230y3bffbea3rbc291aed89381547@mail.gmail.com>
Message-ID: <31f2a7bd0608230255u5c9afc97x91a8975dd4eafc0e@mail.gmail.com>

On 8/23/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> I have another question about visibility problems. Someone suggested
> to me that the primitve wrappers (like Integer) don't use a final
> field for the primitive they contain. This would make them not
> threadsafe. Is this correct?

In Java 5, Integer *does* use a final.  See below.

If it didn't use final, then it would still be thread safe -- because
it is immutable.  But it would not be immune to unsafe publication.

    private final int value;

    public Integer(int value) {
	this.value = value;
    }

--Joe

From alarmnummer at gmail.com  Wed Aug 23 06:43:13 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 23 Aug 2006 12:43:13 +0200
Subject: [concurrency-interest] Primitives wrappers and visibility
	problems
In-Reply-To: <31f2a7bd0608230255u5c9afc97x91a8975dd4eafc0e@mail.gmail.com>
References: <1466c1d60608230230y3bffbea3rbc291aed89381547@mail.gmail.com>
	<31f2a7bd0608230255u5c9afc97x91a8975dd4eafc0e@mail.gmail.com>
Message-ID: <1466c1d60608230343y4c6194b0n882b004f4326fc03@mail.gmail.com>

If the field isn't final, it could be subject to out of order reads
and writes, meaning that a different thread could see a partially
created object -> not threadsafe.

If I'm missing something, please enlighten me :) The subject is very
interesting and the best way to get a better understanding is to ask
questions.

On 8/23/06, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> On 8/23/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> > I have another question about visibility problems. Someone suggested
> > to me that the primitve wrappers (like Integer) don't use a final
> > field for the primitive they contain. This would make them not
> > threadsafe. Is this correct?
>
> In Java 5, Integer *does* use a final.  See below.
>
> If it didn't use final, then it would still be thread safe -- because
> it is immutable.  But it would not be immune to unsafe publication.
>
>    private final int value;
>
>    public Integer(int value) {
>        this.value = value;
>    }
>
> --Joe
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From alarmnummer at gmail.com  Wed Aug 23 07:05:57 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 23 Aug 2006 13:05:57 +0200
Subject: [concurrency-interest] Primitives wrappers and visibility
	problems
In-Reply-To: <9DC7096A2275564C9E2CF5042569976D28B5DD@hermes.coremedia.com>
References: <9DC7096A2275564C9E2CF5042569976D28B5DD@hermes.coremedia.com>
Message-ID: <1466c1d60608230405j5ee98aeeudfad12384a836f68@mail.gmail.com>

But what if it wasn't final. Example:

public class MyInt{
    private int value;

    public MyInt(int value){
        this.value = value;
    }

    public int getValue(){
        return value;
    }
}

Is the following class threadsafe?

1) because it is subject to out of order writes, other threads could
see a partially created MyInt (with the default value 0). A moment
later (when the constructor is called) they could see it with the
correct value.

2) because value is not safely published, it could happen that other
threads never see the new value.

So I would call this class not threadsafe.

Maybe something is wrong with my definition of threadsafe. Maybe I'm
missing something.

On 8/23/06, Ernst, Matthias <matthias.ernst at coremedia.com> wrote:
> > I have another question about visibility problems. Someone suggested
> > to me that the primitve wrappers (like Integer) don't use a final
> > field for the primitive they contain. This would make them not
> > threadsafe. Is this correct?
>
> I was about to write a lengthy response. It turns out that someone's
> suggestion is just wrong:
>
> java.lang.Integer at Java 1.5.0_07:
>    /**
>     * The value of the <code>Integer</code>.
>     *
>     * @serial
>     */
>    private final int value;
>
>
> Matthias
>

From Stefan.Skoglund at it-huset.se  Wed Aug 23 07:19:33 2006
From: Stefan.Skoglund at it-huset.se (Stefan Skoglund)
Date: Wed, 23 Aug 2006 13:19:33 +0200
Subject: [concurrency-interest] Primitives wrappers and
	visibilityproblems
References: <9DC7096A2275564C9E2CF5042569976D28B5DD@hermes.coremedia.com>
	<1466c1d60608230405j5ee98aeeudfad12384a836f68@mail.gmail.com>
Message-ID: <2FDD14551F535345BE46817D94D8DBEC406E3F@ripley.it-huset.se>

 
No, its not thread safe, and you got the idea. The final fields is not guaranteed to be written until after the ctor.
So, don't let this leak within your ctor, your final field could be used from another thread, before its actually written.
 
Correct me if I'm wrong
Cheers Stefan

________________________________

Fr?n: concurrency-interest-bounces at cs.oswego.edu genom Peter Veentjer
Skickat: on 2006-08-23 13:05
Till: Ernst, Matthias
Kopia: concurrency-interest at cs.oswego.edu
?mne: Re: [concurrency-interest] Primitives wrappers and visibilityproblems



But what if it wasn't final. Example:

public class MyInt{
    private int value;

    public MyInt(int value){
        this.value = value;
    }

    public int getValue(){
        return value;
    }
}

Is the following class threadsafe?

1) because it is subject to out of order writes, other threads could
see a partially created MyInt (with the default value 0). A moment
later (when the constructor is called) they could see it with the
correct value.

2) because value is not safely published, it could happen that other
threads never see the new value.

So I would call this class not threadsafe.

Maybe something is wrong with my definition of threadsafe. Maybe I'm
missing something.

On 8/23/06, Ernst, Matthias <matthias.ernst at coremedia.com> wrote:
> > I have another question about visibility problems. Someone suggested
> > to me that the primitve wrappers (like Integer) don't use a final
> > field for the primitive they contain. This would make them not
> > threadsafe. Is this correct?
>
> I was about to write a lengthy response. It turns out that someone's
> suggestion is just wrong:
>
> java.lang.Integer at Java 1.5.0_07:
>    /**
>     * The value of the <code>Integer</code>.
>     *
>     * @serial
>     */
>    private final int value;
>
>
> Matthias
>
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060823/3dd365a4/attachment.html 

From alarmnummer at gmail.com  Wed Aug 23 07:29:38 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 23 Aug 2006 13:29:38 +0200
Subject: [concurrency-interest] Primitives wrappers and
	visibilityproblems
In-Reply-To: <2FDD14551F535345BE46817D94D8DBEC406E3F@ripley.it-huset.se>
References: <9DC7096A2275564C9E2CF5042569976D28B5DD@hermes.coremedia.com>
	<1466c1d60608230405j5ee98aeeudfad12384a836f68@mail.gmail.com>
	<2FDD14551F535345BE46817D94D8DBEC406E3F@ripley.it-huset.se>
Message-ID: <1466c1d60608230429n121cf65w1cb375da81614356@mail.gmail.com>

There also is another way the value of the 'myint' could leak. The vm
is allowed to reorden instructions as long as the reordening is not
visible in the executing thread.

eg:

1) mem = allocmem(MyInt)
2) mem.value = 10
3) globalfield = mem

This could be reordened to:

1) mem = allocmem(MyInt)
2) globalfield = mem
3) mem.value = 10

In this case the MyInt is visible in other threads (they can see the
globalfield) before the mem.value=10 is called. The consequence is
that other threads can see a partially created MyInt.

And this is not threadsafe imho.

On 8/23/06, Stefan Skoglund <Stefan.Skoglund at it-huset.se> wrote:
>
>
>
> No, its not thread safe, and you got the idea. The final fields is not
> guaranteed to be written until after the ctor.
> So, don't let this leak within your ctor, your final field could be used
> from another thread, before its actually written.
>
> Correct me if I'm wrong
> Cheers Stefan
>
> ________________________________
> Fr?n: concurrency-interest-bounces at cs.oswego.edu genom
> Peter Veentjer
> Skickat: on 2006-08-23 13:05
> Till: Ernst, Matthias
> Kopia: concurrency-interest at cs.oswego.edu
> ?mne: Re: [concurrency-interest] Primitives wrappers and visibilityproblems
>
>
>
> But what if it wasn't final. Example:
>
> public class MyInt{
>     private int value;
>
>     public MyInt(int value){
>         this.value = value;
>     }
>
>     public int getValue(){
>         return value;
>     }
> }
>
> Is the following class threadsafe?
>
> 1) because it is subject to out of order writes, other threads could
> see a partially created MyInt (with the default value 0). A moment
> later (when the constructor is called) they could see it with the
> correct value.
>
> 2) because value is not safely published, it could happen that other
> threads never see the new value.
>
> So I would call this class not threadsafe.
>
> Maybe something is wrong with my definition of threadsafe. Maybe I'm
> missing something.
>
> On 8/23/06, Ernst, Matthias <matthias.ernst at coremedia.com> wrote:
> > > I have another question about visibility problems. Someone suggested
> > > to me that the primitve wrappers (like Integer) don't use a final
> > > field for the primitive they contain. This would make them not
> > > threadsafe. Is this correct?
> >
> > I was about to write a lengthy response. It turns out that someone's
> > suggestion is just wrong:
> >
> > java.lang.Integer at Java 1.5.0_07:
> >    /**
> >     * The value of the <code>Integer</code>.
> >     *
> >     * @serial
> >     */
> >    private final int value;
> >
> >
> > Matthias
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> But what if it wasn't final. Example:
>
> public class MyInt{
>     private int value;
>
>     public MyInt(int value){
>         this.value = value;
>     }
>
>     public int getValue(){
>         return value;
>     }
> }
>
> Is the following class threadsafe?
>
> 1) because it is subject to out of order writes, other threads could
> see a partially created MyInt (with the default value 0). A moment
> later (when the constructor is called) they could see it with the
> correct value.
>
> 2) because value is not safely published, it could happen that other
> threads never see the new value.
>
> So I would call this class not threadsafe.
>
> Maybe something is wrong with my definition of threadsafe. Maybe I'm
> missing something.
>
> On 8/23/06, Ernst, Matthias <matthias.ernst at coremedia.com> wrote:
> > > I have another question about visibility problems. Someone suggested
> > > to me that the primitve wrappers (like Integer) don't use a final
> > > field for the primitive they contain. This would make them not
> > > threadsafe. Is this correct?
> >
> > I was about to write a lengthy response. It turns out that someone's
> > suggestion is just wrong:
> >
> > java.lang.Integer at Java 1.5.0_07:
> >    /**
> >     * The value of the <code>Integer</code>.
> >     *
> >     * @serial
> >     */
> >    private final int value;
> >
> >
> > Matthias
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>


From joe.bowbeer at gmail.com  Wed Aug 23 07:32:12 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 23 Aug 2006 04:32:12 -0700
Subject: [concurrency-interest] Primitives wrappers and visibility
	problems
In-Reply-To: <1466c1d60608230405j5ee98aeeudfad12384a836f68@mail.gmail.com>
References: <9DC7096A2275564C9E2CF5042569976D28B5DD@hermes.coremedia.com>
	<1466c1d60608230405j5ee98aeeudfad12384a836f68@mail.gmail.com>
Message-ID: <31f2a7bd0608230432l28359809x24075111c488b406@mail.gmail.com>

The distinction between thread safety and safe publication was
discussed earlier on this list (Aug 2) as "concurrency errors in
java.lang.Throwable".

David Holmes wrote:

"Being safely publishable even when published without synchronization
goes a step beyond basic thread-safety."

Immutable classes like Integer are in fact easy to innoculate against
unsafe publication, but they are "thread-safe" (according to our
definition) even without the extra security boost.

Does the earlier discussion help clarify this?


On 8/23/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> But what if it wasn't final. Example:
>
> public class MyInt{
>     private int value;
>
>     public MyInt(int value){
>         this.value = value;
>     }
>
>     public int getValue(){
>         return value;
>     }
> }
>
> Is the following class threadsafe?
>
> 1) because it is subject to out of order writes, other threads could
> see a partially created MyInt (with the default value 0). A moment
> later (when the constructor is called) they could see it with the
> correct value.
>
> 2) because value is not safely published, it could happen that other
> threads never see the new value.
>
> So I would call this class not threadsafe.
>
> Maybe something is wrong with my definition of threadsafe. Maybe I'm
> missing something.
>
> On 8/23/06, Ernst, Matthias <matthias.ernst at coremedia.com> wrote:
> > > I have another question about visibility problems. Someone suggested
> > > to me that the primitve wrappers (like Integer) don't use a final
> > > field for the primitive they contain. This would make them not
> > > threadsafe. Is this correct?
> >
> > I was about to write a lengthy response. It turns out that someone's
> > suggestion is just wrong:
> >
> > java.lang.Integer at Java 1.5.0_07:
> >    /**
> >     * The value of the <code>Integer</code>.
> >     *
> >     * @serial
> >     */
> >    private final int value;
> >
> >
> > Matthias
> >

From chris.purcell.39 at gmail.com  Wed Aug 23 07:56:40 2006
From: chris.purcell.39 at gmail.com (Chris Purcell)
Date: Wed, 23 Aug 2006 12:56:40 +0100
Subject: [concurrency-interest] Primitives wrappers and
	visibilityproblems
In-Reply-To: <1466c1d60608230429n121cf65w1cb375da81614356@mail.gmail.com>
References: <9DC7096A2275564C9E2CF5042569976D28B5DD@hermes.coremedia.com>
	<1466c1d60608230405j5ee98aeeudfad12384a836f68@mail.gmail.com>
	<2FDD14551F535345BE46817D94D8DBEC406E3F@ripley.it-huset.se>
	<1466c1d60608230429n121cf65w1cb375da81614356@mail.gmail.com>
Message-ID: <14164939-BE48-4652-AE4C-826ED49FD261@gmail.com>

> 1) mem = allocmem(MyInt)
> 2) mem.value = 10
> 3) globalfield = mem

If 2 is properly ensconced in a constructor, and 3 is executed  
outside of the constructor, the language guarantees that 2 happens- 
before 3, even if globalfield is not volatile.

Chris


From Stefan.Skoglund at it-huset.se  Wed Aug 23 08:10:55 2006
From: Stefan.Skoglund at it-huset.se (Stefan Skoglund)
Date: Wed, 23 Aug 2006 14:10:55 +0200
Subject: [concurrency-interest] Primitives wrappers and
	visibilityproblems
References: <9DC7096A2275564C9E2CF5042569976D28B5DD@hermes.coremedia.com><1466c1d60608230405j5ee98aeeudfad12384a836f68@mail.gmail.com><2FDD14551F535345BE46817D94D8DBEC406E3F@ripley.it-huset.se>
	<1466c1d60608230429n121cf65w1cb375da81614356@mail.gmail.com>
Message-ID: <2FDD14551F535345BE46817D94D8DBEC406E41@ripley.it-huset.se>

Yes! Euh, what is the first way the int could leak?
 
The final field is gurateed to be written after the ctor. A non final field could be written just about whenever, unless other synchronization means are used. I.e. the reordering will not reach past the ctor for a final field. Right? A write of a non final int could potentially be stopped from having go any further than to a CPU register, according to spec. Right?
 
/Stefan

________________________________

Fr?n: Peter Veentjer [mailto:alarmnummer at gmail.com]
Skickat: on 2006-08-23 13:29
Till: Stefan Skoglund
Kopia: Ernst, Matthias; concurrency-interest at cs.oswego.edu
?mne: Re: [concurrency-interest] Primitives wrappers and visibilityproblems



There also is another way the value of the 'myint' could leak. The vm
is allowed to reorden instructions as long as the reordening is not
visible in the executing thread.

eg:

1) mem = allocmem(MyInt)
2) mem.value = 10
3) globalfield = mem

This could be reordened to:

1) mem = allocmem(MyInt)
2) globalfield = mem
3) mem.value = 10

In this case the MyInt is visible in other threads (they can see the
globalfield) before the mem.value=10 is called. The consequence is
that other threads can see a partially created MyInt.

And this is not threadsafe imho.

On 8/23/06, Stefan Skoglund <Stefan.Skoglund at it-huset.se> wrote:
>
>
>
> No, its not thread safe, and you got the idea. The final fields is not
> guaranteed to be written until after the ctor.
> So, don't let this leak within your ctor, your final field could be used
> from another thread, before its actually written.
>
> Correct me if I'm wrong
> Cheers Stefan
>
> ________________________________
> Fr?n: concurrency-interest-bounces at cs.oswego.edu genom
> Peter Veentjer
> Skickat: on 2006-08-23 13:05
> Till: Ernst, Matthias
> Kopia: concurrency-interest at cs.oswego.edu
> ?mne: Re: [concurrency-interest] Primitives wrappers and visibilityproblems
>
>
>
> But what if it wasn't final. Example:
>
> public class MyInt{
>     private int value;
>
>     public MyInt(int value){
>         this.value = value;
>     }
>
>     public int getValue(){
>         return value;
>     }
> }
>
> Is the following class threadsafe?
>
> 1) because it is subject to out of order writes, other threads could
> see a partially created MyInt (with the default value 0). A moment
> later (when the constructor is called) they could see it with the
> correct value.
>
> 2) because value is not safely published, it could happen that other
> threads never see the new value.
>
> So I would call this class not threadsafe.
>
> Maybe something is wrong with my definition of threadsafe. Maybe I'm
> missing something.
>
> On 8/23/06, Ernst, Matthias <matthias.ernst at coremedia.com> wrote:
> > > I have another question about visibility problems. Someone suggested
> > > to me that the primitve wrappers (like Integer) don't use a final
> > > field for the primitive they contain. This would make them not
> > > threadsafe. Is this correct?
> >
> > I was about to write a lengthy response. It turns out that someone's
> > suggestion is just wrong:
> >
> > java.lang.Integer at Java 1.5.0_07:
> >    /**
> >     * The value of the <code>Integer</code>.
> >     *
> >     * @serial
> >     */
> >    private final int value;
> >
> >
> > Matthias
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> But what if it wasn't final. Example:
>
> public class MyInt{
>     private int value;
>
>     public MyInt(int value){
>         this.value = value;
>     }
>
>     public int getValue(){
>         return value;
>     }
> }
>
> Is the following class threadsafe?
>
> 1) because it is subject to out of order writes, other threads could
> see a partially created MyInt (with the default value 0). A moment
> later (when the constructor is called) they could see it with the
> correct value.
>
> 2) because value is not safely published, it could happen that other
> threads never see the new value.
>
> So I would call this class not threadsafe.
>
> Maybe something is wrong with my definition of threadsafe. Maybe I'm
> missing something.
>
> On 8/23/06, Ernst, Matthias <matthias.ernst at coremedia.com> wrote:
> > > I have another question about visibility problems. Someone suggested
> > > to me that the primitve wrappers (like Integer) don't use a final
> > > field for the primitive they contain. This would make them not
> > > threadsafe. Is this correct?
> >
> > I was about to write a lengthy response. It turns out that someone's
> > suggestion is just wrong:
> >
> > java.lang.Integer at Java 1.5.0_07:
> >    /**
> >     * The value of the <code>Integer</code>.
> >     *
> >     * @serial
> >     */
> >    private final int value;
> >
> >
> > Matthias
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060823/3d454365/attachment.html 

From kav at it.edu  Wed Aug 23 10:48:55 2006
From: kav at it.edu (Kasper Nielsen)
Date: Wed, 23 Aug 2006 16:48:55 +0200
Subject: [concurrency-interest] Adapting ConcurrentLinkedQueue to a LRU Queue
Message-ID: <44EC6AD7.1050801@it.edu>

Hi,

I am trying to implement a concurrent LRU-based cache. In order to do so 
I need somehow to keep track of the least recently used objects. 
Normally this is no problem because you easily use an index-based LRU 
structure and support o(1) removal/insertion. However, since I want to 
avoid locking I need to do something else.

I was thinking of adapting ConcurrentLinkedQueue a bit.
1. Make ConcurrentLinkedQueue.Node public (or least package private) to 
have a direct reference to it in order to allow fast removal.
2. Whenever an item in the cache is accessed get hold of the 
corresponding node in the LRU-queue from the given cache entry and use

if (node.casItem(cacheValue, null))
    Node newNode = lruQueue.add(item);
    update volatile reference in the cache entry to newNode


There are two main downsides to this idea.
1. I need to maintain an almost identical copy of ConcurrentLinkedQueue.
2. I need to create a new Node on every access to the cache.

anyone can come up with something better/easier/faster?

- Kasper

From brian at quiotix.com  Wed Aug 23 17:57:43 2006
From: brian at quiotix.com (Brian Goetz)
Date: Wed, 23 Aug 2006 17:57:43 -0400
Subject: [concurrency-interest] Primitives wrappers and
	visibility	problems
In-Reply-To: <1466c1d60608230343y4c6194b0n882b004f4326fc03@mail.gmail.com>
References: <1466c1d60608230230y3bffbea3rbc291aed89381547@mail.gmail.com>	<31f2a7bd0608230255u5c9afc97x91a8975dd4eafc0e@mail.gmail.com>
	<1466c1d60608230343y4c6194b0n882b004f4326fc03@mail.gmail.com>
Message-ID: <44ECCF57.9000606@quiotix.com>

> If the field isn't final, it could be subject to out of order reads
> and writes, meaning that a different thread could see a partially
> created object -> not threadsafe.

Only if the object is improperly published -- published using a data 
race.  If it is properly published (statically initialized, published 
via a volatile, published/consumed with synchronization), it is 
guaranteed to work because it is effectively immutable.

From xavier at brittanysoftware.com  Thu Aug 24 16:54:19 2006
From: xavier at brittanysoftware.com (Xavier Le Vourch)
Date: Thu, 24 Aug 2006 13:54:19 -0700
Subject: [concurrency-interest] Backport: serialization bug in Collections
Message-ID: <44EE11FB.6030807@brittanysoftware.com>


I've just used FindBugs on my code and it shows an error in Collections:

=============
Se: Class is Serializable but its superclass doesn't define a void
constructor

This class implements the Serializable interface and its superclass does
not. When such an object is deserialized, the fields of the superclass
need to be initialized by invoking the void constructor of the
superclass. Since the superclass does
 not have one, serialization and deserialization will fail at runtime.
=============


The test case below works with the 5.0 Collections class but fails with
the backport version.

When I made the CheckedMap class implement Serializable, the code worked
and all tests in the test suite still passed.



=============
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import edu.emory.mathcs.backport.java.util.Collections;
import java.util.SortedMap;
import java.util.TreeMap;

public class Bug {

  public static void main(String args[]) throws Exception {
    SortedMap<String, String> m = new TreeMap<String, String>();

    m = Collections.checkedSortedMap(m, String.class, String.class);

    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
    ObjectOutputStream os = new ObjectOutputStream(bytes);

    os.writeObject(m);
    os.close();

    Object o = new ObjectInputStream(
        new ByteArrayInputStream(bytes.toByteArray())).readObject();

    System.out.println("Type: " + o.getClass());
  }
}
=============



-- 
Xavier Le Vourch
Brittany Software, Inc.
<xavier at brittanysoftware.com>

PGP Key: http://brittanysoftware.com/gpg_key.asc

From hanson.char at gmail.com  Thu Aug 24 21:01:45 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Thu, 24 Aug 2006 18:01:45 -0700
Subject: [concurrency-interest] FooTreeCache
Message-ID: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>

Hi,

For some reason I need to cache a large but bounded number of of items
in a SortedMap and be able to preload the cache concurrently (ie
without significantly impacting the handling of service requests.)
Actually the closes thing I need is probably ConcurrentSkipListMap in
Java 6, but suffice to say I can't use it yet.  Below is a much
simplified version of such hypothetical cache.

The basic idea is to combine the use of
1) Read/Write Lock;
2) volatile; and
3) AtomicReference

to maximize concurrency.

Can someone spot any significant concurrency issue with it ?

(I know there is ConcurrentHashMap, but let's say for some reason I
need an internal SortedMap and not just Map.)

Many thanks!

Hanson Char

/**
  * A simple concurrent cache that, for some reasons, needs to have a
SortedMap internally.
 */
@ThreadSafe
public class FooTreeCache {
    /** Uses a non-synchronized map for optimal performance both for
read and write. */
    @GuardedBy("rwLock")
    private static volatile SortedMap<String,String> sortedMap = new
TreeMap<String,String>();
    private static final Lock readLock;
    private static final Lock writeLock;
    static {
        ReadWriteLock rwLock = new ReentrantReadWriteLock();
        readLock = rwLock.readLock();
        writeLock = rwLock.writeLock();
    }
    /** Atomic Cache status reference. */
    private static final AtomicReference<Status> status = new
AtomicReference<Status>(Status.INIT);

    private FooTreeCache() {
    }

    /**
     * Cache Status.
     *
     * Valid state transitions:
     * INIT       -> TRANSIENT
     * TRANSIENT  -> PRE_LOADED
     * PRE_LOADED -> TRANSIENT
     * TRANSIENT  -> INIT
     */
    public static enum Status {
        INIT,
        TRANSIENT,
        PRE_LOADED;
    }

    /** Preloads from db. */
    public static void preload() {
        if (!status.compareAndSet(Status.INIT, Status.TRANSIENT))
        {   // already loading or preloaded by another thread.
            return;
        }
        Thread t = new Thread("FooTreeCachePreLoader")
        {
            @Override
            public void run()
            {
                Collection<Map.Entry<String,String>> col = // ...
lenghty IO to load or whatever
                SortedMap<String,String> temp = new TreeMap<String,String>();
                for (Map.Entry<String,String> ccbr : col)
                    temp.put(ccbr.getKey(), ccbr.getValue());
                // Replace the cache with a preloaded one.
                sortedMap = temp;
                status.set(Status.PRE_LOADED);
            }
        };
        t.setDaemon(true);
        t.start();
    }

    public static String get(int key)
    {
        readLock.lock();
        try {
            return sortedMap.get(key);
        } finally {
            readLock.unlock();
        }
    }

    public static void put(String key, String value)
    {
        writeLock.lock();
        try {
            sortedMap.put(key, value);
        } finally {
            writeLock.unlock();
        }
    }

    public static int size() {
        readLock.lock();
        try {
            return sortedMap.size();
        } finally {
            readLock.unlock();
        }
    }

    public static void clear() {
        if (!status.compareAndSet(Status.PRE_LOADED, Status.TRANSIENT))
            if (!status.compareAndSet(Status.INIT, Status.TRANSIENT))
                return;
        SortedMap<String,String> temp = sortedMap;
        // Replace the cache with an empty one.
        sortedMap = new TreeMap<String,String>();
        status.set(Status.INIT);
        // Clear the old one for better garbage collection ?
        temp.clear();
    }
}
// End

From kav at it.edu  Fri Aug 25 04:21:27 2006
From: kav at it.edu (Kasper Nielsen)
Date: Fri, 25 Aug 2006 10:21:27 +0200
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>
Message-ID: <44EEB307.5040003@it.edu>

Hanson Char wrote:
> Hi,
> 
> For some reason I need to cache a large but bounded number of of items
> in a SortedMap and be able to preload the cache concurrently (ie
> without significantly impacting the handling of service requests.)
> Actually the closes thing I need is probably ConcurrentSkipListMap in
> Java 6, but suffice to say I can't use it yet. 

The source is released to the public domain, so why don't use it? I 
think ConcurrentSkipListMap will only need minor changes to compile on 
5.0. (missing interfaces etc.)

- Kasper

From hanson.char at gmail.com  Fri Aug 25 04:29:02 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Fri, 25 Aug 2006 01:29:02 -0700
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <44EEB307.5040003@it.edu>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>
	<44EEB307.5040003@it.edu>
Message-ID: <ca53c8f80608250129v10945b49m8bd813bd67459863@mail.gmail.com>

Yes, thanks for the pointer.  David Holmes also made the same point.
Will look into replacing the use of the ReadWriteLock+SortedMap with a
ConcurrentSkipListMap.

However, the need for the volatile and AtomicReference in FooTreeCache
will still hold.

Any problem anyone can spot ?

Hanson Char

On 8/25/06, Kasper Nielsen <kav at it.edu> wrote:
> Hanson Char wrote:
> > Hi,
> >
> > For some reason I need to cache a large but bounded number of of items
> > in a SortedMap and be able to preload the cache concurrently (ie
> > without significantly impacting the handling of service requests.)
> > Actually the closes thing I need is probably ConcurrentSkipListMap in
> > Java 6, but suffice to say I can't use it yet.
>
> The source is released to the public domain, so why don't use it? I
> think ConcurrentSkipListMap will only need minor changes to compile on
> 5.0. (missing interfaces etc.)
>
> - Kasper
>

From hanson.char at gmail.com  Fri Aug 25 23:05:46 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Fri, 25 Aug 2006 20:05:46 -0700
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <ca53c8f80608250129v10945b49m8bd813bd67459863@mail.gmail.com>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>
	<44EEB307.5040003@it.edu>
	<ca53c8f80608250129v10945b49m8bd813bd67459863@mail.gmail.com>
Message-ID: <ca53c8f80608252005x629947e9w34a6631fb5bc6937@mail.gmail.com>

When I look at the source code in Java 6, I see something like:

/*
 * @(#)ConcurrentSkipListMap.java   1.3 05/11/17
 *
 * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
 * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

I thought the source code of ConcurrentSkipListMap is in the public
domain.  Does this header comment mean anything ?

Hanson Char

> > The source is released to the public domain, so why don't use it? I
> > think ConcurrentSkipListMap will only need minor changes to compile on
> > 5.0. (missing interfaces etc.)
> >
> > - Kasper

From joe.bowbeer at gmail.com  Sat Aug 26 01:40:30 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri, 25 Aug 2006 22:40:30 -0700
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <ca53c8f80608252005x629947e9w34a6631fb5bc6937@mail.gmail.com>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>
	<44EEB307.5040003@it.edu>
	<ca53c8f80608250129v10945b49m8bd813bd67459863@mail.gmail.com>
	<ca53c8f80608252005x629947e9w34a6631fb5bc6937@mail.gmail.com>
Message-ID: <31f2a7bd0608252240s2087eb22qb27cc22f05da3823@mail.gmail.com>

On 8/25/06, Hanson Char <hanson.char at gmail.com> wrote:
> When I look at the source code in Java 6, I see something like:
>
> /*
>  * @(#)ConcurrentSkipListMap.java   1.3 05/11/17
>  *
>  * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
>  * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
>  */
>
> I thought the source code of ConcurrentSkipListMap is in the public
> domain.  Does this header comment mean anything ?
>

The source at the link below is in the public domain:

http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/

/*
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/licenses/publicdomain
 */

--Joe

From gergg at cox.net  Sat Aug 26 11:58:12 2006
From: gergg at cox.net (Gregg Wonderly)
Date: Sat, 26 Aug 2006 10:58:12 -0500
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <31f2a7bd0608252240s2087eb22qb27cc22f05da3823@mail.gmail.com>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>	<44EEB307.5040003@it.edu>	<ca53c8f80608250129v10945b49m8bd813bd67459863@mail.gmail.com>	<ca53c8f80608252005x629947e9w34a6631fb5bc6937@mail.gmail.com>
	<31f2a7bd0608252240s2087eb22qb27cc22f05da3823@mail.gmail.com>
Message-ID: <44F06F94.5060302@cox.net>

Joe Bowbeer wrote:
> The source at the link below is in the public domain:
> 
> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/
> 
> /*
>  * Written by Doug Lea with assistance from members of JCP JSR-166
>  * Expert Group and released to the public domain, as explained at
>  * http://creativecommons.org/licenses/publicdomain
>  */

There are some dependencies to compile that class which seem to be Sun 
proprietary labeled.

Gregg Wonderly

From hanson.char at gmail.com  Sat Aug 26 20:13:35 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Sat, 26 Aug 2006 17:13:35 -0700
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <44EEB307.5040003@it.edu>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>
	<44EEB307.5040003@it.edu>
Message-ID: <ca53c8f80608261713n46ac1e5auec5540b764b1e287@mail.gmail.com>

Just in case anyone is interested in using ConcurrentSkipListMap
immediately in Java 5 (ie without Java 6), it's available at:

http://beanlib.sourceforge.net/3.2.2/api/net/sf/beanlib/util/concurrent/ConcurrentSkipListMap.html

Hanson

> The source is released to the public domain, so why don't use it? I
> think ConcurrentSkipListMap will only need minor changes to compile on
> 5.0. (missing interfaces etc.)
>
> - Kasper
>

From dl at cs.oswego.edu  Sat Aug 26 20:15:46 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 26 Aug 2006 20:15:46 -0400
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <44F06F94.5060302@cox.net>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>	<44EEB307.5040003@it.edu>	<ca53c8f80608250129v10945b49m8bd813bd67459863@mail.gmail.com>	<ca53c8f80608252005x629947e9w34a6631fb5bc6937@mail.gmail.com>	<31f2a7bd0608252240s2087eb22qb27cc22f05da3823@mail.gmail.com>
	<44F06F94.5060302@cox.net>
Message-ID: <44F0E432.80704@cs.oswego.edu>

Gregg Wonderly wrote:
> J
> There are some dependencies to compile that class which seem to be Sun 
> proprietary labeled.
> 

All the ones you need to actually make ConcurrentSkipList{Map, Set}
minimally compilable can be taken from the jsr166x version of this class.
(Mostly, just local versions of the little AbstractMap utility
classes that should have been in Tiger/Java5 but weren't.)

Sorry that we've put a low priority on meshing the initial jsr166x
versions with the final Java 6 versions. Someone once sent in
a partial reconciliation, but that was before final Java 6 API
was settled. Volunteers would be welcome.

-Doug

From dl at cs.oswego.edu  Sat Aug 26 20:17:44 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 26 Aug 2006 20:17:44 -0400
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <ca53c8f80608261713n46ac1e5auec5540b764b1e287@mail.gmail.com>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>	<44EEB307.5040003@it.edu>
	<ca53c8f80608261713n46ac1e5auec5540b764b1e287@mail.gmail.com>
Message-ID: <44F0E4A8.4030900@cs.oswego.edu>

Hanson Char wrote:
> Just in case anyone is interested in using ConcurrentSkipListMap
> immediately in Java 5 (ie without Java 6), it's available at:
> 
> http://beanlib.sourceforge.net/3.2.2/api/net/sf/beanlib/util/concurrent/ConcurrentSkipListMap.html
> 

Great; thanks!
I should have waited ten more seconds before sending out my
last reply :-)

-Doug


From hanson.char at gmail.com  Sun Aug 27 00:57:41 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Sat, 26 Aug 2006 21:57:41 -0700
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <44F0E432.80704@cs.oswego.edu>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>
	<44EEB307.5040003@it.edu>
	<ca53c8f80608250129v10945b49m8bd813bd67459863@mail.gmail.com>
	<ca53c8f80608252005x629947e9w34a6631fb5bc6937@mail.gmail.com>
	<31f2a7bd0608252240s2087eb22qb27cc22f05da3823@mail.gmail.com>
	<44F06F94.5060302@cox.net> <44F0E432.80704@cs.oswego.edu>
Message-ID: <ca53c8f80608262157t3b6876b4m4ad609d3a8144490@mail.gmail.com>

Just curious.  Why is it that all the classes in jsr166x exist in Java
6 beta, except the ConcurrentLinkedDeque ?

Hanson

On 8/26/06, Doug Lea <dl at cs.oswego.edu> wrote:
> Gregg Wonderly wrote:
> > J
> > There are some dependencies to compile that class which seem to be Sun
> > proprietary labeled.
> >
>
> All the ones you need to actually make ConcurrentSkipList{Map, Set}
> minimally compilable can be taken from the jsr166x version of this class.
> (Mostly, just local versions of the little AbstractMap utility
> classes that should have been in Tiger/Java5 but weren't.)
>
> Sorry that we've put a low priority on meshing the initial jsr166x
> versions with the final Java 6 versions. Someone once sent in
> a partial reconciliation, but that was before final Java 6 API
> was settled. Volunteers would be welcome.
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From hanson.char at gmail.com  Sun Aug 27 01:33:52 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Sat, 26 Aug 2006 22:33:52 -0700
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <ca53c8f80608262157t3b6876b4m4ad609d3a8144490@mail.gmail.com>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>
	<44EEB307.5040003@it.edu>
	<ca53c8f80608250129v10945b49m8bd813bd67459863@mail.gmail.com>
	<ca53c8f80608252005x629947e9w34a6631fb5bc6937@mail.gmail.com>
	<31f2a7bd0608252240s2087eb22qb27cc22f05da3823@mail.gmail.com>
	<44F06F94.5060302@cox.net> <44F0E432.80704@cs.oswego.edu>
	<ca53c8f80608262157t3b6876b4m4ad609d3a8144490@mail.gmail.com>
Message-ID: <ca53c8f80608262233n3060b9a6w7d6ecd3b3186ade0@mail.gmail.com>

It seems java.util.Deque has an extra method than jsr166x.Deque:

    Iterator<E> descendingIterator();

In jsr166x.ConcurrentLinkedDeque, there exists the implementation for the method

    public Iterator<E> iterator();

However, there is no existing implementation for the method
"descendingIterator".

If one were to provide the missing implementation in
jsr166x.ConcurrentLinkedDeque, would it be something like the one
given below ?

Hanson

    public Iterator<E> descendingIterator() {
        return new CLDDescendingIterator();
    }

    final class CLDDescendingIterator implements Iterator<E>
    {
        Node<E> last;
        Node<E> next = trailer.back();

        public boolean hasNext() {
            return next != null;
        }

        public E next() {
            Node<E> l = last = next;
            if (l == null)
                throw new NoSuchElementException();
            next = next.back();
            return l.element;
        }

        public void remove() {
            Node<E> l = last;
            if (l == null)
                throw new IllegalStateException();
            while (!l.delete() && !l.isDeleted())
                ;
        }
    }

On 8/26/06, Hanson Char <hanson.char at gmail.com> wrote:
> Just curious.  Why is it that all the classes in jsr166x exist in Java
> 6 beta, except the ConcurrentLinkedDeque ?
>
> Hanson

From hanson.char at gmail.com  Sun Aug 27 02:11:09 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Sat, 26 Aug 2006 23:11:09 -0700
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <ca53c8f80608262233n3060b9a6w7d6ecd3b3186ade0@mail.gmail.com>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>
	<44EEB307.5040003@it.edu>
	<ca53c8f80608250129v10945b49m8bd813bd67459863@mail.gmail.com>
	<ca53c8f80608252005x629947e9w34a6631fb5bc6937@mail.gmail.com>
	<31f2a7bd0608252240s2087eb22qb27cc22f05da3823@mail.gmail.com>
	<44F06F94.5060302@cox.net> <44F0E432.80704@cs.oswego.edu>
	<ca53c8f80608262157t3b6876b4m4ad609d3a8144490@mail.gmail.com>
	<ca53c8f80608262233n3060b9a6w7d6ecd3b3186ade0@mail.gmail.com>
Message-ID: <ca53c8f80608262311n483c8edbw4e23869d825804a0@mail.gmail.com>

Everything classes of jsr166x are now included and "augmented" with
the source from Java 6 beta (with also the missing method addded for
ConcurrentLinkedDeque):

http://beanlib.sourceforge.net/3.2.3/api/net/sf/beanlib/util/concurrent/package-summary.html

Please let me know if I screwed up anything.  Otherwise, I can start
enjoying jsr166x in Java 5 :)

Hanson

On 8/26/06, Hanson Char <hanson.char at gmail.com> wrote:
> It seems java.util.Deque has an extra method than jsr166x.Deque:
>
>     Iterator<E> descendingIterator();
>
> In jsr166x.ConcurrentLinkedDeque, there exists the implementation for the method
>
>     public Iterator<E> iterator();
>
> However, there is no existing implementation for the method
> "descendingIterator".
>
> If one were to provide the missing implementation in
> jsr166x.ConcurrentLinkedDeque, would it be something like the one
> given below ?
>
> Hanson
>
>     public Iterator<E> descendingIterator() {
>         return new CLDDescendingIterator();
>     }
>
>     final class CLDDescendingIterator implements Iterator<E>
>     {
>         Node<E> last;
>         Node<E> next = trailer.back();
>
>         public boolean hasNext() {
>             return next != null;
>         }
>
>         public E next() {
>             Node<E> l = last = next;
>             if (l == null)
>                 throw new NoSuchElementException();
>             next = next.back();
>             return l.element;
>         }
>
>         public void remove() {
>             Node<E> l = last;
>             if (l == null)
>                 throw new IllegalStateException();
>             while (!l.delete() && !l.isDeleted())
>                 ;
>         }
>     }
>
> On 8/26/06, Hanson Char <hanson.char at gmail.com> wrote:
> > Just curious.  Why is it that all the classes in jsr166x exist in Java
> > 6 beta, except the ConcurrentLinkedDeque ?
> >
> > Hanson
>

From hanson.char at gmail.com  Sun Aug 27 04:07:37 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Sun, 27 Aug 2006 01:07:37 -0700
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <ca53c8f80608262311n483c8edbw4e23869d825804a0@mail.gmail.com>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>
	<44EEB307.5040003@it.edu>
	<ca53c8f80608250129v10945b49m8bd813bd67459863@mail.gmail.com>
	<ca53c8f80608252005x629947e9w34a6631fb5bc6937@mail.gmail.com>
	<31f2a7bd0608252240s2087eb22qb27cc22f05da3823@mail.gmail.com>
	<44F06F94.5060302@cox.net> <44F0E432.80704@cs.oswego.edu>
	<ca53c8f80608262157t3b6876b4m4ad609d3a8144490@mail.gmail.com>
	<ca53c8f80608262233n3060b9a6w7d6ecd3b3186ade0@mail.gmail.com>
	<ca53c8f80608262311n483c8edbw4e23869d825804a0@mail.gmail.com>
Message-ID: <ca53c8f80608270107m6a1c76a3nafa56cac1fc3be1@mail.gmail.com>

Further updated with the latest sources from Java 6 beta 2 (from beta).

  http://prdownloads.sourceforge.net/beanlib/beanlib-3.2.4.tar.gz?download

Hanson

On 8/26/06, Hanson Char <hanson.char at gmail.com> wrote:
> Everything classes of jsr166x are now included and "augmented" with
> the source from Java 6 beta (with also the missing method addded for
> ConcurrentLinkedDeque):
>
> http://beanlib.sourceforge.net/3.2.3/api/net/sf/beanlib/util/concurrent/package-summary.html
>
> Please let me know if I screwed up anything.  Otherwise, I can start
> enjoying jsr166x in Java 5 :)
>
> Hanson

From dl at cs.oswego.edu  Sun Aug 27 10:06:09 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 27 Aug 2006 10:06:09 -0400
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <ca53c8f80608262157t3b6876b4m4ad609d3a8144490@mail.gmail.com>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>	
	<44EEB307.5040003@it.edu>	
	<ca53c8f80608250129v10945b49m8bd813bd67459863@mail.gmail.com>	
	<ca53c8f80608252005x629947e9w34a6631fb5bc6937@mail.gmail.com>	
	<31f2a7bd0608252240s2087eb22qb27cc22f05da3823@mail.gmail.com>	
	<44F06F94.5060302@cox.net> <44F0E432.80704@cs.oswego.edu>
	<ca53c8f80608262157t3b6876b4m4ad609d3a8144490@mail.gmail.com>
Message-ID: <44F1A6D1.9080003@cs.oswego.edu>

Hanson Char wrote:
> Just curious.  Why is it that all the classes in jsr166x exist in Java
> 6 beta, except the ConcurrentLinkedDeque ?
> 

This was a judgement call about its utility. While the current
implementation is OK for some applications, it is not the best
approach for one of the most common parallel applications of
Deques, as work-stealing queues. See for example the FJ
Fork/join framework in dl.util.concurrent, which we plan to
finally revive in much improved form for JDK7 and supply some
nice lightweight and fast loop-parallelization utilities.
So all in all, it seemed better to not commit to having this
class in JDK6.

That's why we put all those disclaimers on the the jsr166x
package. (And will do likewise probably within a few months
for a "jsr166y" package (for lack of a better name, unless
someone suggests something better) with candidate classes
for JDK7.

If I were you, I might not include ConcurrentLinkedQueue in
a JDK6-workalike package for JDK5.

Thanks again for taking this on!

-Doug




From hanson.char at gmail.com  Sun Aug 27 11:47:54 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Sun, 27 Aug 2006 08:47:54 -0700
Subject: [concurrency-interest] FooTreeCache
In-Reply-To: <44F1A6D1.9080003@cs.oswego.edu>
References: <ca53c8f80608241801h42de8f2epf5128e5a54b9c90@mail.gmail.com>
	<44EEB307.5040003@it.edu>
	<ca53c8f80608250129v10945b49m8bd813bd67459863@mail.gmail.com>
	<ca53c8f80608252005x629947e9w34a6631fb5bc6937@mail.gmail.com>
	<31f2a7bd0608252240s2087eb22qb27cc22f05da3823@mail.gmail.com>
	<44F06F94.5060302@cox.net> <44F0E432.80704@cs.oswego.edu>
	<ca53c8f80608262157t3b6876b4m4ad609d3a8144490@mail.gmail.com>
	<44F1A6D1.9080003@cs.oswego.edu>
Message-ID: <ca53c8f80608270847k3be416ees9ebc32944ad8ac25@mail.gmail.com>

ConcurrentLinkedDeque removed in beanlib 3.2.5:

  http://prdownloads.sourceforge.net/beanlib/beanlib-3.2.5.tar.gz?download

Hanson

On 8/27/06, Doug Lea <dl at cs.oswego.edu> wrote:
> Hanson Char wrote:
> > Just curious.  Why is it that all the classes in jsr166x exist in Java
> > 6 beta, except the ConcurrentLinkedDeque ?
> >
>
> This was a judgement call about its utility. While the current
> implementation is OK for some applications, it is not the best
> approach for one of the most common parallel applications of
> Deques, as work-stealing queues. See for example the FJ
> Fork/join framework in dl.util.concurrent, which we plan to
> finally revive in much improved form for JDK7 and supply some
> nice lightweight and fast loop-parallelization utilities.
> So all in all, it seemed better to not commit to having this
> class in JDK6.
>
> That's why we put all those disclaimers on the the jsr166x
> package. (And will do likewise probably within a few months
> for a "jsr166y" package (for lack of a better name, unless
> someone suggests something better) with candidate classes
> for JDK7.
>
> If I were you, I might not include ConcurrentLinkedQueue in
> a JDK6-workalike package for JDK5.
>
> Thanks again for taking this on!
>
> -Doug

From serkandemir007 at gmail.com  Tue Aug 29 02:55:04 2006
From: serkandemir007 at gmail.com (Serkan Demir)
Date: Tue, 29 Aug 2006 09:55:04 +0300
Subject: [concurrency-interest] When a pool is blocked ?
Message-ID: <c060a6cb0608282355p7f555c72td4464713547785b9@mail.gmail.com>

Hi guys,
In javadocs it is written that "If the maximum pool size or queue size
is bounded, then it is possible for incoming execute requests to
block."
In our application, we have set PooledExecutor's abortWhenBlocked()
method and want Runtime exceptions when the queue is full. Although
our queue is full and our threads cannot serve new jobs, i cannot get
this Runtime exception. What is the policy for this blocking and when
a pool is blocked?



-- 
-----------------------------------------------
Serkan
blog: serkandemir.blogspot.com
web: www.serkandemir.com

From alarmnummer at gmail.com  Tue Aug 29 04:04:19 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Tue, 29 Aug 2006 10:04:19 +0200
Subject: [concurrency-interest] When a pool is blocked ?
In-Reply-To: <c060a6cb0608282355p7f555c72td4464713547785b9@mail.gmail.com>
References: <c060a6cb0608282355p7f555c72td4464713547785b9@mail.gmail.com>
Message-ID: <1466c1d60608290104p347b99bta99f70f2561e3133@mail.gmail.com>

Did you use the java.util.concurrent.ThreadPoolExecutor?

If you use that Executor implementation, you can set the
RejectedExecutionHandler. One of the implementation is one that abort:
ThreadPoolExecutor.AbortPolicy and it throws a
RejectedExecutionException when the queue if full and a new task is
added.

Does this answer your question?

On 8/29/06, Serkan Demir <serkandemir007 at gmail.com> wrote:
> Hi guys,
> In javadocs it is written that "If the maximum pool size or queue size
> is bounded, then it is possible for incoming execute requests to
> block."
> In our application, we have set PooledExecutor's abortWhenBlocked()
> method and want Runtime exceptions when the queue is full. Although
> our queue is full and our threads cannot serve new jobs, i cannot get
> this Runtime exception. What is the policy for this blocking and when
> a pool is blocked?
>
>
>
> --
> -----------------------------------------------
> Serkan
> blog: serkandemir.blogspot.com
> web: www.serkandemir.com
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From alarmnummer at gmail.com  Tue Aug 29 04:32:08 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Tue, 29 Aug 2006 10:32:08 +0200
Subject: [concurrency-interest] When a pool is blocked ?
In-Reply-To: <c060a6cb0608290122p5b2f387dhd0a17ce2602fddd1@mail.gmail.com>
References: <c060a6cb0608282355p7f555c72td4464713547785b9@mail.gmail.com>
	<1466c1d60608290104p347b99bta99f70f2561e3133@mail.gmail.com>
	<c060a6cb0608290122p5b2f387dhd0a17ce2602fddd1@mail.gmail.com>
Message-ID: <1466c1d60608290132l77f41a6bw2683b49025d1526@mail.gmail.com>

I haven't used the old version of the concurrency library. You know
there is a backport from the concurrency library for java 1.4 ?

http://dcl.mathcs.emory.edu/util/backport-util-concurrent/

On 8/29/06, Serkan Demir <serkandemir007 at gmail.com> wrote:
> sorry i forgot to say which release i used. it is concurrent-1.3.4
> (oswego jar). I have already set abortWhenBlocked() and waiting for
> Runtime exceptions whenever queue is full.
> Is exception thrown when both the queue is full and all threads are
> unavailable or either queue is full or threads in the pool are
> unavailable?
>
>
>
> On 8/29/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> > Did you use the java.util.concurrent.ThreadPoolExecutor?
> >
> > If you use that Executor implementation, you can set the
> > RejectedExecutionHandler. One of the implementation is one that abort:
> > ThreadPoolExecutor.AbortPolicy and it throws a
> > RejectedExecutionException when the queue if full and a new task is
> > added.
> >
> > Does this answer your question?
> >
> > On 8/29/06, Serkan Demir <serkandemir007 at gmail.com> wrote:
> > > Hi guys,
> > > In javadocs it is written that "If the maximum pool size or queue size
> > > is bounded, then it is possible for incoming execute requests to
> > > block."
> > > In our application, we have set PooledExecutor's abortWhenBlocked()
> > > method and want Runtime exceptions when the queue is full. Although
> > > our queue is full and our threads cannot serve new jobs, i cannot get
> > > this Runtime exception. What is the policy for this blocking and when
> > > a pool is blocked?
> > >
> > >
> > >
> > > --
> > > -----------------------------------------------
> > > Serkan
> > > blog: serkandemir.blogspot.com
> > > web: www.serkandemir.com
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> >
>
>
> --
> -----------------------------------------------
> Serkan
> blog: serkandemir.blogspot.com
> web: www.serkandemir.com
>

From seth.m.green at gmail.com  Wed Aug 30 15:48:08 2006
From: seth.m.green at gmail.com (Seth Green)
Date: Wed, 30 Aug 2006 15:48:08 -0400
Subject: [concurrency-interest] Threadpoolexecutor.maximumPoolSize
Message-ID: <44F5EB78.9060109@gmail.com>

I had no idea the java.util.concurrency library had been backported, and 
I was so fired up to use it. I have some code that uses a 
ThreadPoolExecuter, but it seems that although I have set the 
maximumPoolSize to 50 the pool never grows beyond my corePoolSize.

Does anyone have a suggestion as to why this would be the case. Is there 
something I should be doing differently?

I check getMaximimPoolSize() in a number of places and it is always 50, 
but even though I try to assign 50 threads at once, it only ever start 5 
(my corePoolSize).

Any insight would be greatly appreciated.

thanks,
seth

From alarmnummer at gmail.com  Wed Aug 30 16:14:20 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 30 Aug 2006 22:14:20 +0200
Subject: [concurrency-interest] difference latch and lock
Message-ID: <1466c1d60608301314r13ed0416k5c44cffd69455175@mail.gmail.com>

Who can tell me what the difference between a Latch and a Lock is. I
have read multiple times that a Latch is considered a more lightweight
lock than the lock (maybe only in the context of databases and heavy
weight locks).

But in Java all Locks and synchronized blocks are lightweight.. so are
there differences?

From brian at quiotix.com  Wed Aug 30 16:29:44 2006
From: brian at quiotix.com (Brian Goetz)
Date: Wed, 30 Aug 2006 16:29:44 -0400
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <aa067ea10608221740s1318c425tb0a51fbd858e63f@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCIEKIHBAA.dcholmes@optusnet.com.au>	<NFBBKALFDCPFIDBNKAPCCEKJHBAA.dcholmes@optusnet.com.au>
	<aa067ea10608221740s1318c425tb0a51fbd858e63f@mail.gmail.com>
Message-ID: <44F5F538.5000505@quiotix.com>

>> I hasten to add that if the setter is simply of the form:
>>
>> synchronized void set(int newValue) {
>>    field = newValue;
>> }
>>
>> and field is volatile, then making the setter synchronized is unnecessary.
> 
> This was pretty much my whole argument =)

Right.  What David was getting at is the case where you want to do some 
sort of nontrivial update, like increment.  The modification 
operation(s) use synchronized to make them atomic, and the read 
operations use volatile to reduce the cost / improve the scalability 
where reads outnumber writes.  Like a read-write lock, but cheaper.

As you've pointed out, this is a very fragile pattern -- if using it, 
document it carefully!

From dhanji at gmail.com  Wed Aug 30 16:34:18 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 31 Aug 2006 06:34:18 +1000
Subject: [concurrency-interest] Threadpoolexecutor.maximumPoolSize
In-Reply-To: <44F5EB78.9060109@gmail.com>
References: <44F5EB78.9060109@gmail.com>
Message-ID: <aa067ea10608301334n5c5aae7aw725f75b5e2c2ddb3@mail.gmail.com>

The TPE always starts at corePoolSize. use the prestartCoreThread()
methods to get the threads up to max if needed. Though if they are
idle, it will shrink back down I believe.

Also if you are using ScheduledThreadPoolExecutor implementation, note
that maximumPoolSize has no effect.

On 8/31/06, Seth Green <seth.m.green at gmail.com> wrote:
> I had no idea the java.util.concurrency library had been backported, and
> I was so fired up to use it. I have some code that uses a
> ThreadPoolExecuter, but it seems that although I have set the
> maximumPoolSize to 50 the pool never grows beyond my corePoolSize.
>
> Does anyone have a suggestion as to why this would be the case. Is there
> something I should be doing differently?
>
> I check getMaximimPoolSize() in a number of places and it is always 50,
> but even though I try to assign 50 threads at once, it only ever start 5
> (my corePoolSize).
>
> Any insight would be greatly appreciated.
>
> thanks,
> seth
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From seth.m.green at gmail.com  Wed Aug 30 16:37:02 2006
From: seth.m.green at gmail.com (Seth Green)
Date: Wed, 30 Aug 2006 16:37:02 -0400
Subject: [concurrency-interest] Threadpoolexecutor.maximumPoolSize
In-Reply-To: <44F5EB78.9060109@gmail.com>
References: <44F5EB78.9060109@gmail.com>
Message-ID: <44F5F6EE.6060401@gmail.com>

Sorry. I think I get it now.  I wasn't fully understanding the details 
of corePoolSize and maximimPoolSize.

Now I see that corePoolSize, is the number of threads that will get 
started before handing requests to my queue.  Assumeing my queue is 
large enough to keep them, the number of threads won't go above 
corePoolSize.  If my queue gets full, then new threads will get created 
until I reach maxPoolSize(). right?

So if I am looking for speed (when I want assign a task, I want it to 
run as soon as possible) I should make my queue small and my core and 
max large right?

I know I could use a cached executer but I do need to keep some bounds 
on my pool.

Seth Green wrote:
> I had no idea the java.util.concurrency library had been backported, and 
> I was so fired up to use it. I have some code that uses a 
> ThreadPoolExecuter, but it seems that although I have set the 
> maximumPoolSize to 50 the pool never grows beyond my corePoolSize.
> 
> Does anyone have a suggestion as to why this would be the case. Is there 
> something I should be doing differently?
> 
> I check getMaximimPoolSize() in a number of places and it is always 50, 
> but even though I try to assign 50 threads at once, it only ever start 5 
> (my corePoolSize).
> 
> Any insight would be greatly appreciated.
> 
> thanks,
> seth
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From dhanji at gmail.com  Wed Aug 30 16:37:51 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 31 Aug 2006 06:37:51 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <44F5F538.5000505@quiotix.com>
References: <NFBBKALFDCPFIDBNKAPCIEKIHBAA.dcholmes@optusnet.com.au>
	<NFBBKALFDCPFIDBNKAPCCEKJHBAA.dcholmes@optusnet.com.au>
	<aa067ea10608221740s1318c425tb0a51fbd858e63f@mail.gmail.com>
	<44F5F538.5000505@quiotix.com>
Message-ID: <aa067ea10608301337w1c9ec3cega4b4e0f8386a563c@mail.gmail.com>

Yep, seems like there's a misunderstanding of volatile/synchronized
going on. Several questions recently have revolved around it.

Thanks David and Brian for  your responses.

On 8/31/06, Brian Goetz <brian at quiotix.com> wrote:
> >> I hasten to add that if the setter is simply of the form:
> >>
> >> synchronized void set(int newValue) {
> >>    field = newValue;
> >> }
> >>
> >> and field is volatile, then making the setter synchronized is unnecessary.
> >
> > This was pretty much my whole argument =)
>
> Right.  What David was getting at is the case where you want to do some
> sort of nontrivial update, like increment.  The modification
> operation(s) use synchronized to make them atomic, and the read
> operations use volatile to reduce the cost / improve the scalability
> where reads outnumber writes.  Like a read-write lock, but cheaper.
>
> As you've pointed out, this is a very fragile pattern -- if using it,
> document it carefully!
>

From dcholmes at optusnet.com.au  Wed Aug 30 16:51:10 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Thu, 31 Aug 2006 06:51:10 +1000
Subject: [concurrency-interest] Threadpoolexecutor.maximumPoolSize
In-Reply-To: <44F5EB78.9060109@gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEPBHBAA.dcholmes@optusnet.com.au>

Seth,

TPE only grows beyond coresize if your queue is bounded and becomes full. If
your queue is unbounded then core is the limit.

David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Seth
> Green
> Sent: Thursday, 31 August 2006 5:48 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Threadpoolexecutor.maximumPoolSize
>
>
> I had no idea the java.util.concurrency library had been backported, and
> I was so fired up to use it. I have some code that uses a
> ThreadPoolExecuter, but it seems that although I have set the
> maximumPoolSize to 50 the pool never grows beyond my corePoolSize.
>
> Does anyone have a suggestion as to why this would be the case. Is there
> something I should be doing differently?
>
> I check getMaximimPoolSize() in a number of places and it is always 50,
> but even though I try to assign 50 threads at once, it only ever start 5
> (my corePoolSize).
>
> Any insight would be greatly appreciated.
>
> thanks,
> seth
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From dcholmes at optusnet.com.au  Wed Aug 30 16:55:04 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Thu, 31 Aug 2006 06:55:04 +1000
Subject: [concurrency-interest] difference latch and lock
In-Reply-To: <1466c1d60608301314r13ed0416k5c44cffd69455175@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEPCHBAA.dcholmes@optusnet.com.au>

Peter,

Depends exactly what you mean by "latch". A latch or gate is a
synchronization barrier that is either open or closed. If open anyone can
pass, if closed no one can pass. A Lock is intended to let through one
thread at a time.

I don't know what they meant by a latch being more lightweight than a lock
???

David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> Veentjer
> Sent: Thursday, 31 August 2006 6:14 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] difference latch and lock
>
>
> Who can tell me what the difference between a Latch and a Lock is. I
> have read multiple times that a Latch is considered a more lightweight
> lock than the lock (maybe only in the context of databases and heavy
> weight locks).
>
> But in Java all Locks and synchronized blocks are lightweight.. so are
> there differences?
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From alarmnummer at gmail.com  Wed Aug 30 17:26:03 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 30 Aug 2006 23:26:03 +0200
Subject: [concurrency-interest] difference latch and lock
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEPCHBAA.dcholmes@optusnet.com.au>
References: <1466c1d60608301314r13ed0416k5c44cffd69455175@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEPCHBAA.dcholmes@optusnet.com.au>
Message-ID: <1466c1d60608301426t4dbbe8eene6725c464068e07b@mail.gmail.com>

I don't know what a latch is supposed to do. I see the term in
documentation (especially in concurrency control documentation of
Oracle). And I think a Latch can be compared to a Lock, but I don't
know for sure and I can't find any usefull documentation about what a
Latch is supposed to do.

So I want to know what it does.

On 8/30/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> Peter,
>
> Depends exactly what you mean by "latch". A latch or gate is a
> synchronization barrier that is either open or closed. If open anyone can
> pass, if closed no one can pass. A Lock is intended to let through one
> thread at a time.
>
> I don't know what they meant by a latch being more lightweight than a lock
> ???
>
> David Holmes
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> > Veentjer
> > Sent: Thursday, 31 August 2006 6:14 AM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: [concurrency-interest] difference latch and lock
> >
> >
> > Who can tell me what the difference between a Latch and a Lock is. I
> > have read multiple times that a Latch is considered a more lightweight
> > lock than the lock (maybe only in the context of databases and heavy
> > weight locks).
> >
> > But in Java all Locks and synchronized blocks are lightweight.. so are
> > there differences?
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From alarmnummer at gmail.com  Wed Aug 30 17:32:07 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 30 Aug 2006 23:32:07 +0200
Subject: [concurrency-interest] difference latch and lock
In-Reply-To: <1466c1d60608301426t4dbbe8eene6725c464068e07b@mail.gmail.com>
References: <1466c1d60608301314r13ed0416k5c44cffd69455175@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEPCHBAA.dcholmes@optusnet.com.au>
	<1466c1d60608301426t4dbbe8eene6725c464068e07b@mail.gmail.com>
Message-ID: <1466c1d60608301432x54dbf481yd8e12614c9da6ffd@mail.gmail.com>

Ps: a 'lock' in Oracle is something that is kept for a longer period
of time (in most cases a lock is maintained untill the transaction
completes).

Maybe this is the reason why they have introduced Locks and Latches?

A Latch is a Lock that is invisible from the outside and only locked
for a small period of time (to prevent multiple threads screwing
around with internal system structures)

A (Database) Lock is a Lock that is visible from the outside. If I
have locked a record, you can't update it untill I have released the
lock.A Database lock prevent isolation problems: acid)

Could that be the reason why there is a difference between Latches
(internal Locks) and Locks (database locks)?

On 8/30/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> I don't know what a latch is supposed to do. I see the term in
> documentation (especially in concurrency control documentation of
> Oracle). And I think a Latch can be compared to a Lock, but I don't
> know for sure and I can't find any usefull documentation about what a
> Latch is supposed to do.
>
> So I want to know what it does.
>
> On 8/30/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > Peter,
> >
> > Depends exactly what you mean by "latch". A latch or gate is a
> > synchronization barrier that is either open or closed. If open anyone can
> > pass, if closed no one can pass. A Lock is intended to let through one
> > thread at a time.
> >
> > I don't know what they meant by a latch being more lightweight than a lock
> > ???
> >
> > David Holmes
> >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> > > Veentjer
> > > Sent: Thursday, 31 August 2006 6:14 AM
> > > To: concurrency-interest at cs.oswego.edu
> > > Subject: [concurrency-interest] difference latch and lock
> > >
> > >
> > > Who can tell me what the difference between a Latch and a Lock is. I
> > > have read multiple times that a Latch is considered a more lightweight
> > > lock than the lock (maybe only in the context of databases and heavy
> > > weight locks).
> > >
> > > But in Java all Locks and synchronized blocks are lightweight.. so are
> > > there differences?
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>

From dcholmes at optusnet.com.au  Wed Aug 30 17:36:45 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Thu, 31 Aug 2006 07:36:45 +1000
Subject: [concurrency-interest] difference latch and lock
In-Reply-To: <1466c1d60608301432x54dbf481yd8e12614c9da6ffd@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEPDHBAA.dcholmes@optusnet.com.au>

Peter,

It may be that they are using "latch" as a lightweight internal lock. Pretty
poor choice of name if you ask me though.

Cheers,
David Holmes

> -----Original Message-----
> From: Peter Veentjer [mailto:alarmnummer at gmail.com]
> Sent: Thursday, 31 August 2006 7:32 AM
> To: dholmes at ieee.org
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] difference latch and lock
>
>
> Ps: a 'lock' in Oracle is something that is kept for a longer period
> of time (in most cases a lock is maintained untill the transaction
> completes).
>
> Maybe this is the reason why they have introduced Locks and Latches?
>
> A Latch is a Lock that is invisible from the outside and only locked
> for a small period of time (to prevent multiple threads screwing
> around with internal system structures)
>
> A (Database) Lock is a Lock that is visible from the outside. If I
> have locked a record, you can't update it untill I have released the
> lock.A Database lock prevent isolation problems: acid)
>
> Could that be the reason why there is a difference between Latches
> (internal Locks) and Locks (database locks)?
>
> On 8/30/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> > I don't know what a latch is supposed to do. I see the term in
> > documentation (especially in concurrency control documentation of
> > Oracle). And I think a Latch can be compared to a Lock, but I don't
> > know for sure and I can't find any usefull documentation about what a
> > Latch is supposed to do.
> >
> > So I want to know what it does.
> >
> > On 8/30/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > > Peter,
> > >
> > > Depends exactly what you mean by "latch". A latch or gate is a
> > > synchronization barrier that is either open or closed. If
> open anyone can
> > > pass, if closed no one can pass. A Lock is intended to let through one
> > > thread at a time.
> > >
> > > I don't know what they meant by a latch being more
> lightweight than a lock
> > > ???
> > >
> > > David Holmes
> > >
> > > > -----Original Message-----
> > > > From: concurrency-interest-bounces at cs.oswego.edu
> > > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On
> Behalf Of Peter
> > > > Veentjer
> > > > Sent: Thursday, 31 August 2006 6:14 AM
> > > > To: concurrency-interest at cs.oswego.edu
> > > > Subject: [concurrency-interest] difference latch and lock
> > > >
> > > >
> > > > Who can tell me what the difference between a Latch and a Lock is. I
> > > > have read multiple times that a Latch is considered a more
> lightweight
> > > > lock than the lock (maybe only in the context of databases and heavy
> > > > weight locks).
> > > >
> > > > But in Java all Locks and synchronized blocks are
> lightweight.. so are
> > > > there differences?
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> >


From jean.morissette at gmail.com  Wed Aug 30 17:43:47 2006
From: jean.morissette at gmail.com (Jean Morissette)
Date: Wed, 30 Aug 2006 17:43:47 -0400
Subject: [concurrency-interest] difference latch and lock
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEPCHBAA.dcholmes@optusnet.com.au>
References: <1466c1d60608301314r13ed0416k5c44cffd69455175@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEPCHBAA.dcholmes@optusnet.com.au>
Message-ID: <97ad10900608301443h425d3facv9a66ae9ea51f85a2@mail.gmail.com>

In the database context, locks are related to transactions, while
latchs are short lived locks used, by example, to access the indices.

Jean Morissette

2006/8/30, David Holmes <dcholmes at optusnet.com.au>:
> Peter,
>
> Depends exactly what you mean by "latch". A latch or gate is a
> synchronization barrier that is either open or closed. If open anyone can
> pass, if closed no one can pass. A Lock is intended to let through one
> thread at a time.
>
> I don't know what they meant by a latch being more lightweight than a lock
> ???
>
> David Holmes
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> > Veentjer
> > Sent: Thursday, 31 August 2006 6:14 AM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: [concurrency-interest] difference latch and lock
> >
> >
> > Who can tell me what the difference between a Latch and a Lock is. I
> > have read multiple times that a Latch is considered a more lightweight
> > lock than the lock (maybe only in the context of databases and heavy
> > weight locks).
> >
> > But in Java all Locks and synchronized blocks are lightweight.. so are
> > there differences?
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dawidk at mathcs.emory.edu  Wed Aug 30 20:11:24 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed, 30 Aug 2006 20:11:24 -0400
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <44F5F538.5000505@quiotix.com>
References: <NFBBKALFDCPFIDBNKAPCIEKIHBAA.dcholmes@optusnet.com.au><NFBBKALF	DCPFIDBNKAPCCEKJHBAA.dcholmes@optusnet.com.au><aa067ea10608221740s1318c425t	b0a51fbd858e63f@mail.gmail.com>
	<44F5F538.5000505@quiotix.com>
Message-ID: <44F6292C.3050500@mathcs.emory.edu>

Brian Goetz wrote:
>>> I hasten to add that if the setter is simply of the form:
>>>
>>> synchronized void set(int newValue) {
>>>    field = newValue;
>>> }
>>>
>>> and field is volatile, then making the setter synchronized is unnecessary.
>>>       
>> This was pretty much my whole argument =)
>>     
>
> Right.  What David was getting at is the case where you want to do some 
> sort of nontrivial update, like increment.  The modification 
> operation(s) use synchronized to make them atomic, and the read 
> operations use volatile to reduce the cost / improve the scalability 
> where reads outnumber writes.  Like a read-write lock, but cheaper.
>
> As you've pointed out, this is a very fragile pattern -- if using it, 
> document it carefully!

Just my 2c (to explicitly point out what David and Brian smuggled 
between the lines): the synchronization on setter can only be skipped if 
there are no other setters. For instance, in the AtomicInteger in 
backport-util-concurrent:

private volatile int value;
public final int get() { return value; }
public final synchronized void set(int newValue) { value = newValue; }
public final synchronized int getAndAdd(int delta) {
    int old = value; value += delta; return old;
}

It is tempting to drop "synchronized" from set(newValue), but it would 
be wrong: it would break atomicity of read-modify-write methods such as 
getAndAdd etc. by allowing set(newValue) to perform the update in the 
middle.

Regards,
Dawid


From dhanji at gmail.com  Wed Aug 30 20:34:45 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 31 Aug 2006 10:34:45 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <44F6292C.3050500@mathcs.emory.edu>
References: <NFBBKALFDCPFIDBNKAPCIEKIHBAA.dcholmes@optusnet.com.au>
	<44F5F538.5000505@quiotix.com> <44F6292C.3050500@mathcs.emory.edu>
Message-ID: <aa067ea10608301734h5721b10ev76b7cb156d1972a0@mail.gmail.com>

On 8/31/06, Dawid Kurzyniec <dawidk at mathcs.emory.edu> wrote:
> Just my 2c (to explicitly point out what David and Brian smuggled
> between the lines): the synchronization on setter can only be skipped if
> there are no other setters.
>
> It is tempting to drop "synchronized" from set(newValue), but it would
> be wrong: it would break atomicity of read-modify-write methods such as
> getAndAdd etc. by allowing set(newValue) to perform the update in the
> middle.

yes, but presumably a more elegant solution is for the other "setting
methods" to invoke the single setter, and treat the volatile field as
a javabeans property.

Just my 20c that we should be encouraging this approach. =)

>
> Regards,
> Dawid
>
>

Dhanji

From dhanji at gmail.com  Wed Aug 30 20:36:27 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 31 Aug 2006 10:36:27 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <aa067ea10608301734h5721b10ev76b7cb156d1972a0@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCIEKIHBAA.dcholmes@optusnet.com.au>
	<44F5F538.5000505@quiotix.com> <44F6292C.3050500@mathcs.emory.edu>
	<aa067ea10608301734h5721b10ev76b7cb156d1972a0@mail.gmail.com>
Message-ID: <aa067ea10608301736p4d1e297apc4397da829ed7c0c@mail.gmail.com>

I hasten (too) to add, would it break atomicity if the synchronized
setter were called concurrently (say from a different class)? I assume
yes.

On 8/31/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> On 8/31/06, Dawid Kurzyniec <dawidk at mathcs.emory.edu> wrote:
> > Just my 2c (to explicitly point out what David and Brian smuggled
> > between the lines): the synchronization on setter can only be skipped if
> > there are no other setters.
> >
> > It is tempting to drop "synchronized" from set(newValue), but it would
> > be wrong: it would break atomicity of read-modify-write methods such as
> > getAndAdd etc. by allowing set(newValue) to perform the update in the
> > middle.
>
> yes, but presumably a more elegant solution is for the other "setting
> methods" to invoke the single setter, and treat the volatile field as
> a javabeans property.
>
> Just my 20c that we should be encouraging this approach. =)
>
> >
> > Regards,
> > Dawid
> >
> >
>
> Dhanji
>

From dcholmes at optusnet.com.au  Wed Aug 30 21:21:33 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Thu, 31 Aug 2006 11:21:33 +1000
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <aa067ea10608301734h5721b10ev76b7cb156d1972a0@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEPFHBAA.dcholmes@optusnet.com.au>

Dhanji R. Prasanna writes:
> yes, but presumably a more elegant solution is for the other "setting
> methods" to invoke the single setter, and treat the volatile field as
> a javabeans property.

You don't get atomicity of updates when doing that. Two threads can read the
same value, compute the same incremented value and then use the
single-setter to "atomically" write back the wrong value.

David


From tim at peierls.net  Wed Aug 30 22:02:39 2006
From: tim at peierls.net (Tim Peierls)
Date: Wed, 30 Aug 2006 22:02:39 -0400
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <aa067ea10608301734h5721b10ev76b7cb156d1972a0@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCIEKIHBAA.dcholmes@optusnet.com.au>
	<44F5F538.5000505@quiotix.com> <44F6292C.3050500@mathcs.emory.edu>
	<aa067ea10608301734h5721b10ev76b7cb156d1972a0@mail.gmail.com>
Message-ID: <63b4e4050608301902g417f4cffh7974ceb73aea822f@mail.gmail.com>

On 8/30/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
>
> On 8/31/06, Dawid Kurzyniec <dawidk at mathcs.emory.edu> wrote:
> > Just my 2c (to explicitly point out what David and Brian smuggled
> > between the lines): the synchronization on setter can only be skipped if
> > there are no other setters.
> >
> > It is tempting to drop "synchronized" from set(newValue), but it would
> > be wrong: it would break atomicity of read-modify-write methods such as
> > getAndAdd etc. by allowing set(newValue) to perform the update in the
> > middle.
>
> yes, but presumably a more elegant solution is for the other "setting
> methods" to invoke the single setter, and treat the volatile field as
> a javabeans property.
>
> Just my 20c that we should be encouraging this approach. =)
>


Encouraging what approach? I can only think of two approaches for a pre-Java
5 AtomicInteger:

1. Volatile value, unsynchronized get, synchronized setters.
2. Non-volatile value, synchronized get *and* setters.

I'm not sure which of these is more "elegant", but Dawid presumably chose #1
at least partly on the grounds that the backport is intended for use on
platforms where volatile reads are likely to be cheaper than synchronizing
around a non-volatile read.


I hasten (too) to add, would it break atomicity if the synchronized
> setter were called concurrently (say from a different class)? I assume
> yes.


Not sure what you mean: it wouldn't be much of an AtomicInteger if its
methods couldn't be called concurrently.

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060830/85ca1d0b/attachment.html 

From joe.bowbeer at gmail.com  Wed Aug 30 22:07:52 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 30 Aug 2006 19:07:52 -0700
Subject: [concurrency-interest] Simple ScheduledFuture problem
In-Reply-To: <44F5F538.5000505@quiotix.com>
References: <NFBBKALFDCPFIDBNKAPCIEKIHBAA.dcholmes@optusnet.com.au>
	<NFBBKALFDCPFIDBNKAPCCEKJHBAA.dcholmes@optusnet.com.au>
	<aa067ea10608221740s1318c425tb0a51fbd858e63f@mail.gmail.com>
	<44F5F538.5000505@quiotix.com>
Message-ID: <31f2a7bd0608301907v7f58df37mdf42e4cb893ecc83@mail.gmail.com>

On 8/30/06, Brian Goetz <brian at quiotix.com> wrote:
> >> I hasten to add that if the setter is simply of the form:
> >>
> >> synchronized void set(int newValue) {
> >>    field = newValue;
> >> }
> >>
> >> and field is volatile, then making the setter synchronized is unnecessary.
> >
> > This was pretty much my whole argument =)
>
> Right.  What David was getting at is the case where you want to do some
> sort of nontrivial update, like increment.  The modification
> operation(s) use synchronized to make them atomic, and the read
> operations use volatile to reduce the cost / improve the scalability
> where reads outnumber writes.  Like a read-write lock, but cheaper.
>
> As you've pointed out, this is a very fragile pattern -- if using it,
> document it carefully!
>

To be clear: I was suggesting *either* synchronized *or* volatile
(exclusive) originally.

Combining them for synchronized writing and volatile reading hadn't
occurred to me, and would probably confuse me if I saw it in someone
else's code.

(I'm less easily confused by off-the-shelf components with descriptive
names, such as, say, ReentrantReadWriteLock.)

From yangjs at alibaba-inc.com  Thu Aug 31 00:02:04 2006
From: yangjs at alibaba-inc.com (yangjs)
Date: Thu, 31 Aug 2006 12:02:04 +0800
Subject: [concurrency-interest] question about ExecutorCompletionService
Message-ID: <009901c6ccb2$389b3aa0$4c44000a@alibabahz.com>

hi,all
  I have a Consumer poll task from ExecutorCompletionService ,this class has  no method such as isTerminated, when app is shutdown, I don't know when to shutdown my Consumer ,even if poll return null,.I can't accept consumer lost task . if  ExecutorCompletionService have method isTerminated as follow,thing will be simple. I can check when service poll return null and service isTerminated, my consumer can shutdown safely. is right??
why not provide such method ?

public boolean isTerminated(){
   return executor.isTerminated();
 }
  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060831/536c9467/attachment.html 

From dl at cs.oswego.edu  Thu Aug 31 07:46:45 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 31 Aug 2006 07:46:45 -0400
Subject: [concurrency-interest] question about ExecutorCompletionService
In-Reply-To: <009901c6ccb2$389b3aa0$4c44000a@alibabahz.com>
References: <009901c6ccb2$389b3aa0$4c44000a@alibabahz.com>
Message-ID: <44F6CC25.7010503@cs.oswego.edu>

yangjs wrote:
> hi,all
>   I have a Consumer poll task from ExecutorCompletionService ,this 
> class has  no method such as /isTerminated/, when app is shutdown, I 
> don't know when to shutdown my Consumer ,even if poll return null,.I 
> can't accept consumer lost task . if  ExecutorCompletionService have 
> method isTerminated as follow,thing will be simple. I can check when 
> service poll return null and service isTerminated, my consumer can 
> shutdown safely. is right??
> why not provide such method ?
>  
> public boolean isTerminated(){
>    return executor.isTerminated();
>  }
>  
>  

This is a pretty good suggestion; thanks!
Except that ExecutorCompletionService requires only an Executor,
not an ExecutorService, and Executors don't necessarily
have lifetime control methods (shutdown, isTerminated, etc).
So in cases where people use some custom Executor that is
not also an ExecutorService, the method can't be implemented.

So the best we could do is add method
   public Executor getExecutor() { return executor; }
And you would then need to check termination using the ugly:
   ((ExecutorService)(ecs.getExecutor()).isTerminated();
(and being prepared for cast failure.)

We could in fact compatibly add method getExecutor() because
this is a concrete class and so doesn't impact other interfaces
etc. And it would be handy in those cases where you
don't otherwise have a reference to the executor used to create
the ExecutorCompletionService. But unfortunately, nearly all
uses of this would require casting of result, making it
a bit ugly. Perhaps there is some better way of going about
this with equivalent but nicer effect?

-Doug




From dhanji at gmail.com  Thu Aug 31 08:43:07 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 31 Aug 2006 22:43:07 +1000
Subject: [concurrency-interest] question about ExecutorCompletionService
In-Reply-To: <44F6CC25.7010503@cs.oswego.edu>
References: <009901c6ccb2$389b3aa0$4c44000a@alibabahz.com>
	<44F6CC25.7010503@cs.oswego.edu>
Message-ID: <aa067ea10608310543m3037da8cmf06465673644d8b6@mail.gmail.com>

How about using generics to type ExecutorCompletionService?
Something like:

class ExecutorCompletionService<EX extends Executor, V> {
//...

EX getExecutor()..

}

then you could do:
ecs = new ExecutorCompletionService<ExecutorService, ..>(..);
ecs.getExecutor().isTerminated();

It's not much but you avoid the ugly cast.

On 8/31/06, Doug Lea <dl at cs.oswego.edu> wrote:
> yangjs wrote:
> > hi,all
> >   I have a Consumer poll task from ExecutorCompletionService ,this
> > class has  no method such as /isTerminated/, when app is shutdown, I
> > don't know when to shutdown my Consumer ,even if poll return null,.I
> > can't accept consumer lost task . if  ExecutorCompletionService have
> > method isTerminated as follow,thing will be simple. I can check when
> > service poll return null and service isTerminated, my consumer can
> > shutdown safely. is right??
> > why not provide such method ?
> >
> > public boolean isTerminated(){
> >    return executor.isTerminated();
> >  }
> >
> >
>
> This is a pretty good suggestion; thanks!
> Except that ExecutorCompletionService requires only an Executor,
> not an ExecutorService, and Executors don't necessarily
> have lifetime control methods (shutdown, isTerminated, etc).
> So in cases where people use some custom Executor that is
> not also an ExecutorService, the method can't be implemented.
>
> So the best we could do is add method
>    public Executor getExecutor() { return executor; }
> And you would then need to check termination using the ugly:
>    ((ExecutorService)(ecs.getExecutor()).isTerminated();
> (and being prepared for cast failure.)
>
> We could in fact compatibly add method getExecutor() because
> this is a concrete class and so doesn't impact other interfaces
> etc. And it would be handy in those cases where you
> don't otherwise have a reference to the executor used to create
> the ExecutorCompletionService. But unfortunately, nearly all
> uses of this would require casting of result, making it
> a bit ugly. Perhaps there is some better way of going about
> this with equivalent but nicer effect?
>
> -Doug
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From forax at univ-mlv.fr  Thu Aug 31 09:35:28 2006
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Thu, 31 Aug 2006 15:35:28 +0200
Subject: [concurrency-interest] question about ExecutorCompletionService
In-Reply-To: <aa067ea10608310543m3037da8cmf06465673644d8b6@mail.gmail.com>
References: <009901c6ccb2$389b3aa0$4c44000a@alibabahz.com>	<44F6CC25.7010503@cs.oswego.edu>
	<aa067ea10608310543m3037da8cmf06465673644d8b6@mail.gmail.com>
Message-ID: <44F6E5A0.5050906@univ-mlv.fr>

Dhanji R. Prasanna a ?crit :
> How about using generics to type ExecutorCompletionService?
> Something like:
> 
> class ExecutorCompletionService<EX extends Executor, V> {
> //...
> 
> EX getExecutor()..
> 
> }
> 
> then you could do:
> ecs = new ExecutorCompletionService<ExecutorService, ..>(..);
> ecs.getExecutor().isTerminated();
> 
> It's not much but you avoid the ugly cast.

Not possible, the new ExecutorCompletionService will be not
backward compatible with the old one.

In Java, there is a compatibility between raw type
(type without type parameter) and parameterized type
but not between parameterized type with 1 parameter and
parameterized type with 2 parameters.

R?mi Forax


From hanson.char at gmail.com  Thu Aug 31 10:09:49 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Thu, 31 Aug 2006 07:09:49 -0700
Subject: [concurrency-interest] question about ExecutorCompletionService
In-Reply-To: <44F6E5A0.5050906@univ-mlv.fr>
References: <009901c6ccb2$389b3aa0$4c44000a@alibabahz.com>
	<44F6CC25.7010503@cs.oswego.edu>
	<aa067ea10608310543m3037da8cmf06465673644d8b6@mail.gmail.com>
	<44F6E5A0.5050906@univ-mlv.fr>
Message-ID: <ca53c8f80608310709n27d70cdi1f13baf7ecb6eea9@mail.gmail.com>

How about:

public class ExecutorCompletionService<V> implements CompletionService<V> {
...
    // return whatever Executor as the caller wish
    public <E extends Executor> E getExecutor() {
        return executor;
    }
}

Hanson

On 8/31/06, R?mi Forax <forax at univ-mlv.fr> wrote:
>
> Dhanji R. Prasanna a ?crit :
> > How about using generics to type ExecutorCompletionService?
> > Something like:
> >
> > class ExecutorCompletionService<EX extends Executor, V> {
> > //...
> >
> > EX getExecutor()..
> >
> > }
> >
> > then you could do:
> > ecs = new ExecutorCompletionService<ExecutorService, ..>(..);
> > ecs.getExecutor().isTerminated();
> >
> > It's not much but you avoid the ugly cast.
>
> Not possible, the new ExecutorCompletionService will be not
> backward compatible with the old one.
>
> In Java, there is a compatibility between raw type
> (type without type parameter) and parameterized type
> but not between parameterized type with 1 parameter and
> parameterized type with 2 parameters.
>
> R?mi Forax
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060831/a5d970d7/attachment.html 

From tim at peierls.net  Thu Aug 31 14:31:00 2006
From: tim at peierls.net (Tim Peierls)
Date: Thu, 31 Aug 2006 14:31:00 -0400
Subject: [concurrency-interest] question about ExecutorCompletionService
In-Reply-To: <44F6CC25.7010503@cs.oswego.edu>
References: <009901c6ccb2$389b3aa0$4c44000a@alibabahz.com>
	<44F6CC25.7010503@cs.oswego.edu>
Message-ID: <63b4e4050608311131x76e97c0fy19861b26cd525dfa@mail.gmail.com>

On 8/31/06, Doug Lea <dl at cs.oswego.edu> wrote:
>
> We could in fact compatibly add method getExecutor() because
> this is a concrete class and so doesn't impact other interfaces
> etc. And it would be handy in those cases where you
> don't otherwise have a reference to the executor used to create
> the ExecutorCompletionService. But unfortunately, nearly all
> uses of this would require casting of result, making it
> a bit ugly. Perhaps there is some better way of going about
> this with equivalent but nicer effect?


It's not hard to roll your own:

public class TrackedExecutorCompletionService<V, E extends Executor>
        extends ExecutorCompletionService<V> {

    private final E exec;

    public TrackedExecutorCompletionService(E exec) {
        super(exec);
        this.exec = exec;
    }

    public TrackedExecutorCompletionService(
            E exec, BlockingQueue<Future<V>> queue) {
        super(exec, queue);
        this.exec = exec;
    }

    public E getExecutor() { return exec; }
}

--tim

On 8/31/06, Doug Lea <dl at cs.oswego.edu> wrote:
>
> yangjs wrote:
> > hi,all
> >   I have a Consumer poll task from ExecutorCompletionService ,this
> > class has  no method such as /isTerminated/, when app is shutdown, I
> > don't know when to shutdown my Consumer ,even if poll return null,.I
> > can't accept consumer lost task . if  ExecutorCompletionService have
> > method isTerminated as follow,thing will be simple. I can check when
> > service poll return null and service isTerminated, my consumer can
> > shutdown safely. is right??
> > why not provide such method ?
> >
> > public boolean isTerminated(){
> >    return executor.isTerminated();
> >  }
> >
> >
>
> This is a pretty good suggestion; thanks!
> Except that ExecutorCompletionService requires only an Executor,
> not an ExecutorService, and Executors don't necessarily
> have lifetime control methods (shutdown, isTerminated, etc).
> So in cases where people use some custom Executor that is
> not also an ExecutorService, the method can't be implemented.
>
> So the best we could do is add method
>    public Executor getExecutor() { return executor; }
> And you would then need to check termination using the ugly:
>    ((ExecutorService)(ecs.getExecutor()).isTerminated();
> (and being prepared for cast failure.)
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060831/41c20b5f/attachment.html 

From forax at univ-mlv.fr  Thu Aug 31 16:46:03 2006
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Thu, 31 Aug 2006 22:46:03 +0200
Subject: [concurrency-interest] question about ExecutorCompletionService
In-Reply-To: <ca53c8f80608310709n27d70cdi1f13baf7ecb6eea9@mail.gmail.com>
References: <009901c6ccb2$389b3aa0$4c44000a@alibabahz.com>	
	<44F6CC25.7010503@cs.oswego.edu>	
	<aa067ea10608310543m3037da8cmf06465673644d8b6@mail.gmail.com>	
	<44F6E5A0.5050906@univ-mlv.fr>
	<ca53c8f80608310709n27d70cdi1f13baf7ecb6eea9@mail.gmail.com>
Message-ID: <44F74A8B.8020601@univ-mlv.fr>

Hanson Char wrote:

> How about:
>
> public class ExecutorCompletionService<V> implements 
> CompletionService<V> {
> ...
>     // return whatever Executor as the caller wish
>     public <E extends Executor> E getExecutor() {
>         return executor;
>     }
> }
>
> Hanson

???,
i don't a big difference between
(ExecutorService)executionService.getExecutor();
and
executionService.<ExecutorService>getExceutor(); +an unsafe cast in 
getExecutor()

R?mi


From hanson.char at gmail.com  Thu Aug 31 18:00:09 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Thu, 31 Aug 2006 15:00:09 -0700
Subject: [concurrency-interest] question about ExecutorCompletionService
In-Reply-To: <44F74A8B.8020601@univ-mlv.fr>
References: <009901c6ccb2$389b3aa0$4c44000a@alibabahz.com>
	<44F6CC25.7010503@cs.oswego.edu>
	<aa067ea10608310543m3037da8cmf06465673644d8b6@mail.gmail.com>
	<44F6E5A0.5050906@univ-mlv.fr>
	<ca53c8f80608310709n27d70cdi1f13baf7ecb6eea9@mail.gmail.com>
	<44F74A8B.8020601@univ-mlv.fr>
Message-ID: <ca53c8f80608311500t6b781bb3me131783827406d60@mail.gmail.com>

The difference is you could do something like:

        ExecutorCompletionService ecs  = ...
        ExecutorService es = ecs.getExecutor();

        if (es.isTerminated()) {
           ...
        }

No casting needed.

Hanson

On 8/31/06, R?mi Forax <forax at univ-mlv.fr> wrote:
>
> Hanson Char wrote:
>
> > How about:
> >
> > public class ExecutorCompletionService<V> implements
> > CompletionService<V> {
> > ...
> >     // return whatever Executor as the caller wish
> >     public <E extends Executor> E getExecutor() {
> >         return executor;
> >     }
> > }
> >
> > Hanson
>
> ???,
> i don't a big difference between
> (ExecutorService)executionService.getExecutor();
> and
> executionService.<ExecutorService>getExceutor(); +an unsafe cast in
> getExecutor()
>
> R?mi
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060831/16d2e939/attachment.html 

From hanson.char at gmail.com  Thu Aug 31 18:17:54 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Thu, 31 Aug 2006 15:17:54 -0700
Subject: [concurrency-interest] question about ExecutorCompletionService
In-Reply-To: <ca53c8f80608311500t6b781bb3me131783827406d60@mail.gmail.com>
References: <009901c6ccb2$389b3aa0$4c44000a@alibabahz.com>
	<44F6CC25.7010503@cs.oswego.edu>
	<aa067ea10608310543m3037da8cmf06465673644d8b6@mail.gmail.com>
	<44F6E5A0.5050906@univ-mlv.fr>
	<ca53c8f80608310709n27d70cdi1f13baf7ecb6eea9@mail.gmail.com>
	<44F74A8B.8020601@univ-mlv.fr>
	<ca53c8f80608311500t6b781bb3me131783827406d60@mail.gmail.com>
Message-ID: <ca53c8f80608311517q50aa7e16hd2ae0ae26cd29f16@mail.gmail.com>

>     public <E extends Executor> E getExecutor() {
>         return executor;
>     }

should be:

     public <E extends Executor> E getExecutor() {
         return (E)executor;  // casting done here once and for all;
     }

Hanson

On 8/31/06, Hanson Char <hanson.char at gmail.com> wrote:
>
> The difference is you could do something like:
>
>         ExecutorCompletionService ecs  = ...
>         ExecutorService es = ecs.getExecutor();
>
>         if (es.isTerminated()) {
>            ...
>         }
>
> No casting needed.
>
> Hanson
>
> On 8/31/06, R?mi Forax <forax at univ-mlv.fr> wrote:
>
> > Hanson Char wrote:
> >
> > > How about:
> > >
> > > public class ExecutorCompletionService<V> implements
> > > CompletionService<V> {
> > > ...
> > >     // return whatever Executor as the caller wish
> > >     public <E extends Executor> E getExecutor() {
> > >         return executor;
> > >     }
> > > }
> > >
> > > Hanson
> >
> > ???,
> > i don't a big difference between
> > (ExecutorService)executionService.getExecutor();
> > and
> > executionService.<ExecutorService>getExceutor(); +an unsafe cast in
> > getExecutor()
> >
> > R?mi
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060831/365188ec/attachment.html 

