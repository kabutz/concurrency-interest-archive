From lfrench1 at gmu.edu  Fri Dec  5 16:42:22 2008
From: lfrench1 at gmu.edu (Lindley M French)
Date: Fri, 05 Dec 2008 16:42:22 -0500
Subject: [concurrency-interest] backport: ReentrantReadWriteLock question
Message-ID: <f72389873c286.493959ee@gmu.edu>

I notice that the Backport implementation of ReentrantReadWriteLock does not quite match the Java 1.5 version, in particular its imposition without option of a writer preference.

I have a circumstance where I need reader preference. Under Java 1.5, it seems that the ReentrantReadWriteLock::ReadLock::tryLock() function provides "barging" behavior which would allow one to effectively enforce reader preference no matter what scheduling policy the lock tries to use normally.

The javadoc for the Backport version *claims* to have this same behavior, but I'm left wondering whether it's really true or just a copy/paste from the 1.5 version's javadoc. I'm especially suspicious since Java 1.5's javadoc claims to have "barging" behavior for the tryLock function of the *write* lock as well, even though that doesn't make any sense.

Could it be clarified whether there is a means to enforce reader preference using backport or not?

From pugh at cs.umd.edu  Fri Dec  5 21:02:28 2008
From: pugh at cs.umd.edu (Bill Pugh)
Date: Fri, 5 Dec 2008 18:02:28 -0800
Subject: [concurrency-interest] Why does new ScheduledThreadPoolExecutor(0)
	not throw an exception?
Message-ID: <562895B0-82A0-4A4A-800E-A148E6514A0E@cs.umd.edu>

The JavaDoc for Java 1.5 says that new ScheduledThreadPoolExecutor(0)  
throws illegal argument exception.

It should, since such a created ScheduledThreadPoolExecutor is  
useless. It will silently ignore all requests to execute anything.

But in Java 1.6, the spec was changed to say that it throws an  
execution only if the argument is < 0.

Bill



From martinrb at google.com  Fri Dec  5 21:37:16 2008
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 5 Dec 2008 18:37:16 -0800
Subject: [concurrency-interest] Why does new
	ScheduledThreadPoolExecutor(0) not throw an exception?
In-Reply-To: <562895B0-82A0-4A4A-800E-A148E6514A0E@cs.umd.edu>
References: <562895B0-82A0-4A4A-800E-A148E6514A0E@cs.umd.edu>
Message-ID: <1ccfd1c10812051837r6d34d04dhba0bc3da0c397bb1@mail.gmail.com>

Hmmmm... I don't remember the details of this change.
corepoolsize of 0 makes sense for ThreadPoolExecutor.

The STPE spec does use the word "almost"
to warn about this possibility.

It might provide a way to make a pool quiescent.
Set corepoolsize to zero during certain times of the day?
Probably there are better ways to do that.

Doug?

 * <p>While this class inherits from {@link ThreadPoolExecutor}, a few
 * of the inherited tuning methods are not useful for it. In
 * particular, because it acts as a fixed-sized pool using
 * {@code corePoolSize} threads and an unbounded queue, adjustments
 * to {@code maximumPoolSize} have no useful effect. Additionally, it
 * is almost never a good idea to set {@code corePoolSize} to zero or
 * use {@code allowCoreThreadTimeOut} because this may leave the pool
 * without threads to handle tasks once they become eligible to run.

Martin


On Fri, Dec 5, 2008 at 18:02, Bill Pugh <pugh at cs.umd.edu> wrote:
> The JavaDoc for Java 1.5 says that new ScheduledThreadPoolExecutor(0) throws
> illegal argument exception.
>
> It should, since such a created ScheduledThreadPoolExecutor is useless. It
> will silently ignore all requests to execute anything.
>
> But in Java 1.6, the spec was changed to say that it throws an execution
> only if the argument is < 0.
>
> Bill
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dl at cs.oswego.edu  Sat Dec  6 10:26:17 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 06 Dec 2008 10:26:17 -0500
Subject: [concurrency-interest] Why does new
 ScheduledThreadPoolExecutor(0) not throw an exception?
In-Reply-To: <562895B0-82A0-4A4A-800E-A148E6514A0E@cs.umd.edu>
References: <562895B0-82A0-4A4A-800E-A148E6514A0E@cs.umd.edu>
Message-ID: <493A9999.20903@cs.oswego.edu>

Bill Pugh wrote:
> The JavaDoc for Java 1.5 says that new ScheduledThreadPoolExecutor(0) 
> throws illegal argument exception.
> 
> It should, since such a created ScheduledThreadPoolExecutor is useless. 
> It will silently ignore all requests to execute anything.
> 
> But in Java 1.6, the spec was changed to say that it throws an execution 
> only if the argument is < 0.
> 

As Martin mentioned, zero is legal, but very rarely useful
(as mentioned in the javadoc) -- it won't completely
ignore requests, it just won't execute them.
Although I can't find it, I think this change helped
satisfy a request to better support phased initialization.

-Doug


From pugh at cs.umd.edu  Sat Dec  6 12:45:20 2008
From: pugh at cs.umd.edu (Bill Pugh)
Date: Sat, 6 Dec 2008 09:45:20 -0800
Subject: [concurrency-interest] Why does new
	ScheduledThreadPoolExecutor(0) not throw an exception?
In-Reply-To: <1ccfd1c10812051837r6d34d04dhba0bc3da0c397bb1@mail.gmail.com>
References: <562895B0-82A0-4A4A-800E-A148E6514A0E@cs.umd.edu>
	<1ccfd1c10812051837r6d34d04dhba0bc3da0c397bb1@mail.gmail.com>
Message-ID: <2A17FD64-E457-477B-AFFD-58C942EAFEB5@cs.umd.edu>


On Dec 5, 2008, at 6:37 PM, Martin Buchholz wrote:

> Hmmmm... I don't remember the details of this change.
> corepoolsize of 0 makes sense for ThreadPoolExecutor.
>
> The STPE spec does use the word "almost"
> to warn about this possibility.
>
> It might provide a way to make a pool quiescent.
> Set corepoolsize to zero during certain times of the day?
> Probably there are better ways to do that.

Yeah, sorry, it slipped that you could later call setCorePoolSize.  
setMaximumPoolSize doesn't work, but calling setCorePoolSize does.

Bill


From unmesh_joshi at hotmail.com  Sun Dec  7 12:10:08 2008
From: unmesh_joshi at hotmail.com (unmesh_joshi at hotmail.com)
Date: Sun, 7 Dec 2008 09:10:08 -0800
Subject: [concurrency-interest] Vacation reply
In-Reply-To: <mailman.1.1228669200.14640.concurrency-interest@cs.oswego.edu>
Message-ID: <BAY0-MC12-F99781573A47596E1C5103EFFC0@phx.gbl>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081207/d53b5dde/attachment.html>

From dl at cs.oswego.edu  Tue Dec  9 19:35:45 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 09 Dec 2008 19:35:45 -0500
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
Message-ID: <493F0EE1.4030907@cs.oswego.edu>

Concrete plans for Java7 release finally appear to be starting, and
we've been asked which JSR166 follow-ons should be slated for
inclusion. Here is the tentative list. Comments appreciated.

1. Phasers
    A generalization of various kinds of barriers.
2. LinkedTransferQueue (and TransferQueue interface)
    A generalization of nonblocking, blocking and synchronous queues
3. ConcurrentReferenceHashMap
    A concurrent hash map allowing weak, soft, etc keys and values.
4. Fences (in java.util.concurrent.atomic)
    Low-level memory fences
5. ForkJoin framework.
    (See below)

Preliminary versions of these can be found in various places.
Phasers and LinkedTransferQueues are in jsr166y at
http://gee.cs.oswego.edu/dl/concurrency-interest/index.html

The Fences API is listed at
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html
The specs need a little bit of work, and Java JVMs will need to
support it. (Any VM can support it now extremely expensively, but it
is not useful unless supported efficiently.)  Among other reasons for
including this API is to better correspond to the similar upcoming
C++0x APIs.

Jason Greene created a version of ConcurrentReferenceHashMap based on
ConcurrentHashMap. I think the most recent version is at:
http://viewvc.jboss.org/cgi-bin/viewvc.cgi/jbosscache/experimental/jsr166/src/jsr166y/ConcurrentReferenceHashMap.java?view=markup
We postponed integrating this awaiting possible GC support for
Ephemerons (a solution to  weak key-value chains), which
might drive different internals.  But I don't think Ephemeron support
is too likely to be in place soon, so we should consider incorporating
without this.

As most people know, existing ForkJoin support consists of two parts,
the base ForkJoin{Pool,Task} framework, and the parallel collections
(currently only ParallelArray) on top if it.  I'm thinking to only
recommend inclusion of the base framework into JDK, and to resume
working on parallel collections as a non-JDK package.  Doing this
sidesteps the interface explosion issue (the 96 interfaces like
IntAndLongToInt etc etc) and expressiveness issues (closures etc) that
make inclusion in JDK hard to argue for, while better motivating
development and usage of parallelCollections package over the
medium-term future, and as well as possible development of
associated IDE support, language extensions and/or other JVM languages

At the same time, I've been working on revisions of the base support
that provide full integration of FJ with the Executor framework --
ForkJoinPool will implement Executor service and ForkJoinTask will
implement Future. (The main idea making this possible is to allow
controlled blocking and spawning spare threads when necessary to
maintain parallelism.) Among the motivations is to accommodate usages
in both Fortress and X10 (which are or will be compiled to run on
JVMs) requiring this sort of capability. But it also comes into play
in constructions that people have wanted but hadn't worked, like
creating a set of looping (non-FJ-like) tasks, each of which
sometimes spawns FJ tasks.

More details will follow (getting the internal parallelism maintenance
working well is going slowly), but this invites simply adding the base
framework to java.util.concurrent proper: class ForkJoinPool (with class
ForkJoinWorkerThread still available for advanced usages and tuning)
plus abstract class ForkJoinTask, with support
for the three basic flavors via abstract subclasses RecursiveAction,
RecursiveTask, AsyncForkJoinAction (the last one revamped to enable
construction of classes like BinaryAsyncAction without needing to
provide them.)

I'll await comments and suggestions on all this before putting
it into place. (Where putting in place means initially
reorganizing package jsr166y along these lines, and later
transferring to java.util.concurrent.)

-Doug



From ben_manes at yahoo.com  Tue Dec  9 20:55:56 2008
From: ben_manes at yahoo.com (Ben Manes)
Date: Tue, 9 Dec 2008 17:55:56 -0800 (PST)
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
References: <493F0EE1.4030907@cs.oswego.edu>
Message-ID: <690295.97250.qm@web38803.mail.mud.yahoo.com>

I'm curious as to what design aspects make ConcurrentReferenceHashMap superior to Google's ReferenceMap.  It looks to have implemented its own hash table, versus delegating to a backing ConcurrentMap, but I don't immediately understand why this is preferable.

Thanks,
Ben



________________________________
From: Doug Lea <dl at cs.oswego.edu>
To: Concurrency-interest at cs.oswego.edu
Sent: Tuesday, December 9, 2008 4:35:45 PM
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans

Concrete plans for Java7 release finally appear to be starting, and
we've been asked which JSR166 follow-ons should be slated for
inclusion. Here is the tentative list. Comments appreciated.

1. Phasers
   A generalization of various kinds of barriers.
2. LinkedTransferQueue (and TransferQueue interface)
   A generalization of nonblocking, blocking and synchronous queues
3. ConcurrentReferenceHashMap
   A concurrent hash map allowing weak, soft, etc keys and values.
4. Fences (in java.util.concurrent.atomic)
   Low-level memory fences
5. ForkJoin framework.
   (See below)

Preliminary versions of these can be found in various places.
Phasers and LinkedTransferQueues are in jsr166y at
http://gee.cs.oswego.edu/dl/concurrency-interest/index.html

The Fences API is listed at
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html
The specs need a little bit of work, and Java JVMs will need to
support it. (Any VM can support it now extremely expensively, but it
is not useful unless supported efficiently.)  Among other reasons for
including this API is to better correspond to the similar upcoming
C++0x APIs.

Jason Greene created a version of ConcurrentReferenceHashMap based on
ConcurrentHashMap. I think the most recent version is at:
http://viewvc.jboss.org/cgi-bin/viewvc.cgi/jbosscache/experimental/jsr166/src/jsr166y/ConcurrentReferenceHashMap.java?view=markup
We postponed integrating this awaiting possible GC support for
Ephemerons (a solution to  weak key-value chains), which
might drive different internals.  But I don't think Ephemeron support
is too likely to be in place soon, so we should consider incorporating
without this.

As most people know, existing ForkJoin support consists of two parts,
the base ForkJoin{Pool,Task} framework, and the parallel collections
(currently only ParallelArray) on top if it.  I'm thinking to only
recommend inclusion of the base framework into JDK, and to resume
working on parallel collections as a non-JDK package.  Doing this
sidesteps the interface explosion issue (the 96 interfaces like
IntAndLongToInt etc etc) and expressiveness issues (closures etc) that
make inclusion in JDK hard to argue for, while better motivating
development and usage of parallelCollections package over the
medium-term future, and as well as possible development of
associated IDE support, language extensions and/or other JVM languages

At the same time, I've been working on revisions of the base support
that provide full integration of FJ with the Executor framework --
ForkJoinPool will implement Executor service and ForkJoinTask will
implement Future. (The main idea making this possible is to allow
controlled blocking and spawning spare threads when necessary to
maintain parallelism.) Among the motivations is to accommodate usages
in both Fortress and X10 (which are or will be compiled to run on
JVMs) requiring this sort of capability. But it also comes into play
in constructions that people have wanted but hadn't worked, like
creating a set of looping (non-FJ-like) tasks, each of which
sometimes spawns FJ tasks.

More details will follow (getting the internal parallelism maintenance
working well is going slowly), but this invites simply adding the base
framework to java.util.concurrent proper: class ForkJoinPool (with class
ForkJoinWorkerThread still available for advanced usages and tuning)
plus abstract class ForkJoinTask, with support
for the three basic flavors via abstract subclasses RecursiveAction,
RecursiveTask, AsyncForkJoinAction (the last one revamped to enable
construction of classes like BinaryAsyncAction without needing to
provide them.)

I'll await comments and suggestions on all this before putting
it into place. (Where putting in place means initially
reorganizing package jsr166y along these lines, and later
transferring to java.util.concurrent.)

-Doug


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



      
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081209/87718aac/attachment.html>

From crazybob at crazybob.org  Tue Dec  9 21:31:06 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Tue, 9 Dec 2008 18:31:06 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <690295.97250.qm@web38803.mail.mud.yahoo.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<690295.97250.qm@web38803.mail.mud.yahoo.com>
Message-ID: <a74683f90812091831y3d066aci5b3d6cd93d0ffdf1@mail.gmail.com>

On Tue, Dec 9, 2008 at 5:55 PM, Ben Manes <ben_manes at yahoo.com> wrote:

> I'm curious as to what design aspects make ConcurrentReferenceHashMap
> superior to Google's ReferenceMap.  It looks to have implemented its own
> hash table, versus delegating to a backing ConcurrentMap, but I don't
> immediately understand why this is preferable.
>

ReferenceMap must create an object every time you call get() and it must
repeatedly lock/unlock in some situations whereas ConcurrentReferenceHashMap
can just grab the lock once and get the job done. I haven't looked at the
semantics of CRHM in awhile, but we have plenty of time to hammer those out.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081209/6d5b4573/attachment.html>

From kevinb at google.com  Tue Dec  9 21:52:55 2008
From: kevinb at google.com (Kevin Bourrillion)
Date: Tue, 9 Dec 2008 18:52:55 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <a74683f90812091831y3d066aci5b3d6cd93d0ffdf1@mail.gmail.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<690295.97250.qm@web38803.mail.mud.yahoo.com>
	<a74683f90812091831y3d066aci5b3d6cd93d0ffdf1@mail.gmail.com>
Message-ID: <108fcdeb0812091852g18d44905r741a20687abba70e@mail.gmail.com>

On Tue, Dec 9, 2008 at 6:31 PM, Bob Lee <crazybob at crazybob.org> wrote:

I'm curious as to what design aspects make ConcurrentReferenceHashMap
>> superior to Google's ReferenceMap.  It looks to have implemented its own
>> hash table, versus delegating to a backing ConcurrentMap, but I don't
>> immediately understand why this is preferable.
>>
>
> ReferenceMap must create an object every time you call get() and it must
> repeatedly lock/unlock in some situations whereas ConcurrentReferenceHashMap
> can just grab the lock once and get the job done. I haven't looked at the
> semantics of CRHM in awhile, but we have plenty of time to hammer those out.
>

A ReferenceMap that lives outside java.util, without access to java.util
internals, is forced to make this choice (either reimplement its own entire
data structure, or discard a dummy instance on every query like ours does).
We chose one way and Jason chose the other, but I'd still like to think that
neither horrible fate must be suffered for the JDK code.

For the record, Google's ReferenceMap is phenomenally well-tested and has
been in production in Google apps for more than three years.  The
performance impact of these discarded dummy instances has not been a serious
problem in practice (I still think it's unsuitable for JDK code, but also
unnecessary as explained above).  It's currently being used in 167 distinct
projects.  Through this we've worked out a lot of fiendish bugs.  The JDK is
welcome to as much or as little of its distilled wisdom as you please!


-- 
Kevin Bourrillion @ Google
internal:  go/javalibraries
google-collections.googlecode.com
google-guice.googlecode.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081209/bd7c4710/attachment.html>

From osvaldo at visionnaire.com.br  Wed Dec 10 06:48:21 2008
From: osvaldo at visionnaire.com.br (Osvaldo Pinali Doederlein)
Date: Wed, 10 Dec 2008 09:48:21 -0200
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <108fcdeb0812091852g18d44905r741a20687abba70e@mail.gmail.com>
References: <493F0EE1.4030907@cs.oswego.edu>	<690295.97250.qm@web38803.mail.mud.yahoo.com>	<a74683f90812091831y3d066aci5b3d6cd93d0ffdf1@mail.gmail.com>
	<108fcdeb0812091852g18d44905r741a20687abba70e@mail.gmail.com>
Message-ID: <493FAC85.10305@visionnaire.com.br>

Kevin Bourrillion wrote:
> A ReferenceMap that lives outside java.util, without access to 
> java.util internals, is forced to make this choice (either reimplement 
> its own entire data structure, or discard a dummy instance on every 
> query like ours does).  We chose one way and Jason chose the other, 
> but I'd still like to think that neither horrible fate must be 
> suffered for the JDK code.
Shouldnt't JSRs 277/294 (modules) fix that? I suppose that a lot of 
package-private implementation artifacts could be promoted to 
module-private, enabling higher code sharing across java.util and its 
many subpackages and also across the entire Java SE APIs. And 
differently from closures, these JSRs are something we can rely on, for 
Java 7.

A+
Osvaldo

-- 
-----------------------------------------------------------------------
Osvaldo Pinali Doederlein                        Visionnaire Virtus S/A
osvaldo at visionnaire.com.br                http://www.visionnaire.com.br
Arquiteto de Tecnologia                          +55 (41) 337-1000 #226


From crazybob at crazybob.org  Wed Dec 10 10:43:06 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Wed, 10 Dec 2008 07:43:06 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <493F0EE1.4030907@cs.oswego.edu>
References: <493F0EE1.4030907@cs.oswego.edu>
Message-ID: <a74683f90812100743v7f38272bxaa1fa8bc16e6d39d@mail.gmail.com>

On Tue, Dec 9, 2008 at 4:35 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> 3. ConcurrentReferenceHashMap
>   A concurrent hash map allowing weak, soft, etc keys and values.


BTW, I like the name "ReferenceMap" better.

  - It's obviously concurrent because it's in the "concurrent" package.
  - It doesn't makes sense to use anything but a hash-based implementation
with references.
  - We won't want a non-concurrent reference map because it will retain
garbage for too long.
  - I like shorter names.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081210/b9cfffdc/attachment.html>

From neal at gafter.com  Wed Dec 10 10:45:31 2008
From: neal at gafter.com (Neal Gafter)
Date: Wed, 10 Dec 2008 07:45:31 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <493FAC85.10305@visionnaire.com.br>
References: <493F0EE1.4030907@cs.oswego.edu>
	<690295.97250.qm@web38803.mail.mud.yahoo.com>
	<a74683f90812091831y3d066aci5b3d6cd93d0ffdf1@mail.gmail.com>
	<108fcdeb0812091852g18d44905r741a20687abba70e@mail.gmail.com>
	<493FAC85.10305@visionnaire.com.br>
Message-ID: <15e8b9d20812100745u274163b6u159a8715c5493e1@mail.gmail.com>

I get the impression that language modularity may be off the table for
Java 7.  Hopefully we'll have more clarity about that in the next few
weeks.

On Wed, Dec 10, 2008 at 3:48 AM, Osvaldo Pinali Doederlein
<osvaldo at visionnaire.com.br> wrote:
> Kevin Bourrillion wrote:
>>
>> A ReferenceMap that lives outside java.util, without access to java.util
>> internals, is forced to make this choice (either reimplement its own entire
>> data structure, or discard a dummy instance on every query like ours does).
>>  We chose one way and Jason chose the other, but I'd still like to think
>> that neither horrible fate must be suffered for the JDK code.
>
> Shouldnt't JSRs 277/294 (modules) fix that? I suppose that a lot of
> package-private implementation artifacts could be promoted to
> module-private, enabling higher code sharing across java.util and its many
> subpackages and also across the entire Java SE APIs. And differently from
> closures, these JSRs are something we can rely on, for Java 7.
>
> A+
> Osvaldo
>
> --
> -----------------------------------------------------------------------
> Osvaldo Pinali Doederlein                        Visionnaire Virtus S/A
> osvaldo at visionnaire.com.br                http://www.visionnaire.com.br
> Arquiteto de Tecnologia                          +55 (41) 337-1000 #226
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From joe.bowbeer at gmail.com  Wed Dec 10 11:02:58 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 10 Dec 2008 08:02:58 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <a74683f90812100743v7f38272bxaa1fa8bc16e6d39d@mail.gmail.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<a74683f90812100743v7f38272bxaa1fa8bc16e6d39d@mail.gmail.com>
Message-ID: <31f2a7bd0812100802o1990b1abn893d079d0115b382@mail.gmail.com>

On Wed, Dec 10, 2008 at 7:43 AM, Bob Lee wrote:

> On Tue, Dec 9, 2008 at 4:35 PM, Doug Lea wrote:
>
>> 3. ConcurrentReferenceHashMap
>>   A concurrent hash map allowing weak, soft, etc keys and values.
>
>
> BTW, I like the name "ReferenceMap" better.
>
>   - It's obviously concurrent because it's in the "concurrent" package.
>   - It doesn't makes sense to use anything but a hash-based implementation
> with references.
>   - We won't want a non-concurrent reference map because it will retain
> garbage for too long.
>   - I like shorter names.
>
> Bob
>
>
I like shorter names, but I also like consistency.

ConcurrentReferenceHashMap is more consistent with the naming of its sibling
classes, such as ConcurrentHashMap, whereas ReferenceMap is more consistent
with the naming of interfaces.

Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081210/7d4c8124/attachment.html>

From crazybob at crazybob.org  Wed Dec 10 11:13:07 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Wed, 10 Dec 2008 08:13:07 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <31f2a7bd0812100802o1990b1abn893d079d0115b382@mail.gmail.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<a74683f90812100743v7f38272bxaa1fa8bc16e6d39d@mail.gmail.com>
	<31f2a7bd0812100802o1990b1abn893d079d0115b382@mail.gmail.com>
Message-ID: <a74683f90812100813n194800d4x7d52c352bae6d4f@mail.gmail.com>

On Wed, Dec 10, 2008 at 8:02 AM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> ConcurrentReferenceHashMap is more consistent with the naming of its
> sibling classes, such as ConcurrentHashMap, whereas ReferenceMap is more
> consistent with the naming of interfaces.
>

We should definitely consider consistency, but it doesn't trump all other
factors, like making the name twice as long and much less catchy and
memorable. "Joe, I think you want a concurrent reference hash map here," vs,
"Joe, I think you want a reference map here."

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081210/6c943fae/attachment.html>

From joe.bowbeer at gmail.com  Wed Dec 10 11:30:06 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 10 Dec 2008 08:30:06 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <a74683f90812100813n194800d4x7d52c352bae6d4f@mail.gmail.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<a74683f90812100743v7f38272bxaa1fa8bc16e6d39d@mail.gmail.com>
	<31f2a7bd0812100802o1990b1abn893d079d0115b382@mail.gmail.com>
	<a74683f90812100813n194800d4x7d52c352bae6d4f@mail.gmail.com>
Message-ID: <31f2a7bd0812100830h2f76c4cen32143154fceb262f@mail.gmail.com>

On Wed, Dec 10, 2008 at 8:13 AM, Bob Lee wrote:

> On Wed, Dec 10, 2008 at 8:02 AM, Joe Bowbeer wrote:
>
>> ConcurrentReferenceHashMap is more consistent with the naming of its
>> sibling classes, such as ConcurrentHashMap, whereas ReferenceMap is more
>> consistent with the naming of interfaces.
>>
>
> We should definitely consider consistency, but it doesn't trump all other
> factors, like making the name twice as long and much less catchy and
> memorable. "Joe, I think you want a concurrent reference hash map here," vs,
> "Joe, I think you want a reference map here."
>
> Bob
>

Right.  And as you know;) I prefer to reference instances by their interface
name rather than their class name.

Btw, would ReferenceMap implement ConcurrentMap?  I think that'd be
unexpected given its name.

I think this motivates ConcurrentReferenceMap at the least.

Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081210/eccf7544/attachment.html>

From crazybob at crazybob.org  Wed Dec 10 11:49:01 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Wed, 10 Dec 2008 08:49:01 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <31f2a7bd0812100830h2f76c4cen32143154fceb262f@mail.gmail.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<a74683f90812100743v7f38272bxaa1fa8bc16e6d39d@mail.gmail.com>
	<31f2a7bd0812100802o1990b1abn893d079d0115b382@mail.gmail.com>
	<a74683f90812100813n194800d4x7d52c352bae6d4f@mail.gmail.com>
	<31f2a7bd0812100830h2f76c4cen32143154fceb262f@mail.gmail.com>
Message-ID: <a74683f90812100849o721adb71md2d5a8e288a53bf1@mail.gmail.com>

On Wed, Dec 10, 2008 at 8:30 AM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> Btw, would ReferenceMap implement ConcurrentMap?


It does.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081210/4a331f53/attachment.html>

From elizarov at devexperts.com  Wed Dec 10 13:28:05 2008
From: elizarov at devexperts.com (Roman Elizarov)
Date: Wed, 10 Dec 2008 21:28:05 +0300
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
Message-ID: <568388113.20081210212805@devexperts.com>

Hello, Doug!

> Concrete plans for Java7 release finally appear to be starting, and
> we've been asked which JSR166 follow-ons should be slated for
> inclusion. Here is the tentative list. Comments appreciated.

We badly need a fast way to work with AtomicIntegerArray and
AtomicReferenceArray. It does not neccessary need any API changes. One
approach is to have JVM team make sure that a call get(i) is as fast
as array access and enjoys all the same optimizations during
translation to machine code. Other approaches involve API changes. One
of the following API changes will suffice:
* Provide a method to "wrap" existing array without copying it.
* Provide a method to get an underlying array.
* Provide AtomicXXXArrayUpdater class.

Otherwise, all high-performance code (like Cliff Click's
high-scale-lib and the kind of code we are writing to process millions
of quotes per second) is forced to use sun.misc.Unsafe which is a kind
of ugly last-resort approach.

Also, we had recently stumbled into an absence of "compareAndPoll"
method on ConcurrentLinkedQueue (you "peek", then you try to do
something with the object and only if you successfull you do
"compareAndPoll"). A minor issue, though, and might not deserve an API
change.

Sincerely,
Roman Elizarov



From dl at cs.oswego.edu  Wed Dec 10 15:17:35 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 10 Dec 2008 15:17:35 -0500
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <568388113.20081210212805@devexperts.com>
References: <568388113.20081210212805@devexperts.com>
Message-ID: <494023DF.5040405@cs.oswego.edu>

Roman Elizarov wrote:
> We badly need a fast way to work with AtomicIntegerArray and
> AtomicReferenceArray. It does not neccessary need any API changes. One
> approach is to have JVM team make sure that a call get(i) is as fast
> as array access and enjoys all the same optimizations during
> translation to machine code. Other approaches involve API changes. One
> of the following API changes will suffice:
> * Provide a method to "wrap" existing array without copying it.
> * Provide a method to get an underlying array.
> * Provide AtomicXXXArrayUpdater class.
> 

Thanks for the reminder! As a follow-on about some fence
issues, I had put together  AtomicReferenceArrayUpdater:
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/AtomicReferenceArrayUpdater.html
Would this suffice? The same could be done for at least
Int and Long versions.


-Doug




From David.Biesack at sas.com  Wed Dec 10 18:31:52 2008
From: David.Biesack at sas.com (David J. Biesack)
Date: Wed, 10 Dec 2008 18:31:52 -0500
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 47,
	Issue 3
In-Reply-To: <mailman.1.1228909810.3743.concurrency-interest@cs.oswego.edu>
	(concurrency-interest-request@cs.oswego.edu)
References: <mailman.1.1228909810.3743.concurrency-interest@cs.oswego.edu>
Message-ID: <uej0fli8n.fsf@sas.com>

> [...] I'm thinking to only
> recommend inclusion of the base framework into JDK, and to resume
> working on parallel collections as a non-JDK package.  Doing this
> sidesteps the interface explosion issue (the 96 interfaces like
> IntAndLongToInt etc etc) and expressiveness issues (closures etc) that
> make inclusion in JDK hard to argue for, while better motivating
> development and usage of parallelCollections package over the
> medium-term future, and as well as possible development of
> associated IDE support, language extensions and/or other JVM languages

I agree with this plan. As much as I like the idea of a standard
ParallelArray API, I'm sorry to say that in several of the applications I've tried
implementing with ParallelArray, the framework just did not provide an
{intuitive|elegant|complete}+ enough solution to merit its inclusion. Perhaps it's
my own lack of imagination. I certainly don't have a better API in mind,
but PA just does not seem to fit as many "real" use cases as I'd like.
I like the idea of deferring this to a general parallel collection API.

-- 
David J. Biesack, SAS
SAS Campus Dr. Cary, NC 27513
www.sas.com    (919) 531-7771

From elizarov at devexperts.com  Thu Dec 11 02:30:58 2008
From: elizarov at devexperts.com (Roman Elizarov)
Date: Thu, 11 Dec 2008 10:30:58 +0300
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <494023DF.5040405@cs.oswego.edu>
References: <568388113.20081210212805@devexperts.com>
	<494023DF.5040405@cs.oswego.edu>
Message-ID: <11710495463.20081211103058@devexperts.com>

Hello Doug!

On Wednesday, December 10, 2008 11:17:35 PM you wrote:

DL> Thanks for the reminder! As a follow-on about some fence
DL> issues, I had put together  AtomicReferenceArrayUpdater:
DL> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/AtomicReferenceArrayUpdater.html
DL> Would this suffice? The same could be done for at least
DL> Int and Long versions.

Reference, Int and Long versions should suffice. The API looks
somewhat superfluous, though:

* eagerGet and lazySet are simple wrappers on plain array access and
  their presense in API, IMHO, is just confusing.
* Constuructors for this classes should not be exposed at all. I would
  prefer a singleton pattern with a static generic "getInstance" method.
  Not only this is cleaner (each user does not define its own
  instance), but it also integrates with Java generic type inference.

Now, I belive that core libraries need more efficient ready-to-use
array based algorithms. Due to better memory locality and cache
utilization array-based algorithms typically outpeform linked
structures by a significant factor on all modern arhitectures. I know
that research is somewhat lagging there, especially into the
dynamically sized councurrent array-based structures. But even simple
optimizations to the existing structures can have huge benefit. For
example, many linked data strucutures get an immediate performance
boost when you unroll them.

One of my students recently studied a combination of Michael&Scott
concurrent queue (the underlying algorithm for ConcurrentLinkedQueue)
and unrolled list. While still fully lock-free, it significantly
outperforms ConcurentLinkedQueue on addition, removal and iteration.
We don't currently have access to migh-multi-core machines, so I
cannot relly comment on its scalability under high contetion vs
existing ConcurrentLinkedQueue implementation.

Btw, the implementation of ConcurrentLinkedQueue (being based of
Michael&Scott paper) implements their algorithm almost "verbatim".
Original M&S paper assumed that the memory is being managed by the
code itself, while in Java this is done by GC. The obvious benefit of
having no ABA problem is already being used by ConcurrentLinkedQueue.
However, there are some other checks in M&S code that are superflous
in the presence of GC (they were incuded into M&S code only because
they had to make sure that the memory they are attempting to modify
was not already reclaimed by the other thread). Thus,
ConcurrentLinkedQueue can be slighltly sped up simply by removing
those superfluous checks. Speedup can be significant on some
architectures, since it reduces the number of volatile reads per
operation.

Sincerely,
Roman Elizarov

P.S. I've noticed AtomicReferencePair class. What use does it have if
it does not provide any methods for atomic snapshot or atomic update
of both references at the same time?



From elizarov at devexperts.com  Thu Dec 11 07:13:24 2008
From: elizarov at devexperts.com (Roman Elizarov)
Date: Thu, 11 Dec 2008 15:13:24 +0300
Subject: [concurrency-interest] MORE ON: Re[2]: RFC -- Java7
	java.util.concurrent plans
In-Reply-To: <494023DF.5040405@cs.oswego.edu>
References: <568388113.20081210212805@devexperts.com>
	<494023DF.5040405@cs.oswego.edu>
Message-ID: <1278092740.20081211151324@devexperts.com>

Hello Doug!

I have to correct a statement from my previous email:

> * Constuructors for this classes should not be exposed at all. I
> would prefer a singleton pattern with a static generic "getInstance"
> method. Not only this is cleaner (each user does not define its own
> instance), but it also integrates with Java generic type inference.

Unfortunately, getInstance method does not solve inferrence problem,
so this AtomicReferenceArrayUpdater is bound to be hard to use in
practice. The fix is to make all methods static, but then it does not
make sense to keep those methods in this class. I would rather create
a separate "AtomicArrays" class where compareAndSet, set, and get
methods are declared for Object[], int[], and long[]. There will be
analogy with "java.util.Arrays". It will be easy to learn and use just
like "Arrays".

It would be utterly cool for certain algorithms if this class also
contains a method with the following signature:
  void set(int[] a, int index, int value0, int value1);
which atomically does:
  a[index] = value0;
  a[index+1] = value1;

now, the paired get for this would look ugly, so it might be a better
aproach to pack the pair into long from the very start:
  void setLittleEndian(int[] a, int index, long value);
  void setBigEndian(int[] a, int index, long value);
  long getLittleEndian(int[] a, int index);
  long getBigEndian(int[] a, int index);

// or figure out a better set of suffixes than BigEndian/LittleEndian

This will close yet another Java vs native performance gap. Actually,
there are only few places left where Java algorithm running on HotSpot
significantly underperform compared to C/C++. One place is related to
high-performance/concurrent data strucutures. Consider a hash map from
int to Object. In C++ you would implement it as an array of structs.
But in Java the only way to implement it is to have a separate int[]
and a separate Object[]. Makes it twice as slow in practice, since
there are twice as many cache rows to load. We badly need
heterogenous/struct arrays. How pity that this complain should go to
some other place....

Sincerely,
Roman Elizarov



From dl at cs.oswego.edu  Thu Dec 11 12:29:24 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 11 Dec 2008 12:29:24 -0500
Subject: [concurrency-interest] MORE ON: Re[2]: RFC --
 Java7	java.util.concurrent plans
In-Reply-To: <1278092740.20081211151324@devexperts.com>
References: <568388113.20081210212805@devexperts.com>	<494023DF.5040405@cs.oswego.edu>
	<1278092740.20081211151324@devexperts.com>
Message-ID: <49414DF4.7060203@cs.oswego.edu>

Roman Elizarov wrote:
>  I would rather create
> a separate "AtomicArrays" class where compareAndSet, set, and get
> methods are declared for Object[], int[], and long[]. There will be
> analogy with "java.util.Arrays". It will be easy to learn and use just
> like "Arrays".

This might indeed be a better compromise. It would take some hard work
to make the reference version efficient -- it would need to
emulate ArrayStoreException checks at Java level, but in
a way that JVMs could subject to the usual machinations that
usually optimize them away. I'll look into it.

> 
> It would be utterly cool for certain algorithms if this class also
> contains a method with the following signature:
>   void set(int[] a, int index, int value0, int value1);
> which atomically does:
>   a[index] = value0;
>   a[index+1] = value1;

Assuming you mean "int" only, you are probably better off manually
packing into longs. Most machines require 8byte alignment of
CAS/atomic-set of 64bit locations, which packing into longs would
automatically provide.

> now, the paired get for this would look ugly, so it might be a better
> aproach to pack the pair into long from the very start:
>   void setLittleEndian(int[] a, int index, long value);
>   void setBigEndian(int[] a, int index, long value);
>   long getLittleEndian(int[] a, int index);
>   long getBigEndian(int[] a, int index);

But this still doesn't force "long" alignment of even numbered
locations, which you'd need to ensure.

> This will close yet another Java vs native performance gap. Actually,
> there are only few places left where Java algorithm running on HotSpot
> significantly underperform compared to C/C++. One place is related to
> high-performance/concurrent data strucutures. Consider a hash map from
> int to Object. In C++ you would implement it as an array of structs.
> But in Java the only way to implement it is to have a separate int[]
> and a separate Object[]. Makes it twice as slow in practice, since
> there are twice as many cache rows to load. We badly need
> heterogenous/struct arrays. 

I completely agree. I've been arguing for this for years.
If anyone is looking for a good JVM project (on openJDK or elsewhere)
to sink a lot of time into, this is among the most needed for
supporting higher-performance data structures and algorithms
(not just parallel ones).

-Doug


From Online at stolsvik.com  Thu Dec 11 12:37:21 2008
From: Online at stolsvik.com (=?UTF-8?Q?Endre_St=C3=B8lsvik?=)
Date: Thu, 11 Dec 2008 18:37:21 +0100
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <31f2a7bd0812100802o1990b1abn893d079d0115b382@mail.gmail.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<a74683f90812100743v7f38272bxaa1fa8bc16e6d39d@mail.gmail.com>
	<31f2a7bd0812100802o1990b1abn893d079d0115b382@mail.gmail.com>
Message-ID: <1501fdf40812110937v596d3a09x86bf494e1fce27b4@mail.gmail.com>

On Wed, Dec 10, 2008 at 17:02, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> On Wed, Dec 10, 2008 at 7:43 AM, Bob Lee wrote:
>>
>> On Tue, Dec 9, 2008 at 4:35 PM, Doug Lea wrote:
>>>
>>> 3. ConcurrentReferenceHashMap
>>>   A concurrent hash map allowing weak, soft, etc keys and values.
>>
>> BTW, I like the name "ReferenceMap" better.
>>   - It's obviously concurrent because it's in the "concurrent" package.
>>   - It doesn't makes sense to use anything but a hash-based implementation
>> with references.
>>   - We won't want a non-concurrent reference map because it will retain
>> garbage for too long.
>>   - I like shorter names.
>> Bob
>
> I like shorter names, but I also like consistency.
>
> ConcurrentReferenceHashMap is more consistent with the naming of its sibling
> classes, such as ConcurrentHashMap, whereas ReferenceMap is more consistent
> with the naming of interfaces.

Agree - consistency and clarity. IMO, this is way more important than
the 'spoken name argument' that Bob gives - it is really not that
often I tell Joe to use a particular class - it is much more often I
have to understand a type of a variable, remember a name, read the
code. I find it easier to remember a clear, consistent name, than a
"catchy" one - like in what aspects of its function was it they had
left out in that name? The "Concurrent" or "Hash" aspect? Ah, both,
actually. I find it annoying to have to check the package name to
understand a class's function. On the point of "brain parsing time"
that can be raised in such naming discussion, it is shown (!) that we
humans tend to parse entire words as an image, rather than reading
each letter (which actually gives an important naming-argument: Don't
let names be the same length and visually look the same). On writing
time, one code in IDE's, not notepad. Lastly, taking this shortening
logic further, one will end up with name clashes and hence
misunderstandings, like in "Awh, damn, it is a NORMAL DingDong, not
the package.blue version - no wonder everything crashes!".

Endre.

From crazybob at crazybob.org  Thu Dec 11 12:52:28 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Thu, 11 Dec 2008 09:52:28 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <1501fdf40812110937v596d3a09x86bf494e1fce27b4@mail.gmail.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<a74683f90812100743v7f38272bxaa1fa8bc16e6d39d@mail.gmail.com>
	<31f2a7bd0812100802o1990b1abn893d079d0115b382@mail.gmail.com>
	<1501fdf40812110937v596d3a09x86bf494e1fce27b4@mail.gmail.com>
Message-ID: <a74683f90812110952l25b7c196md8cba04645298b8@mail.gmail.com>

I'd argue that "ReferenceMap" *is* consistent with other types. For example,
we don't call DelayQueue "ConcurrentDelayedPriorityQueue".

Bob

On Thu, Dec 11, 2008 at 9:37 AM, Endre St?lsvik <Online at stolsvik.com> wrote:

> On Wed, Dec 10, 2008 at 17:02, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> > On Wed, Dec 10, 2008 at 7:43 AM, Bob Lee wrote:
> >>
> >> On Tue, Dec 9, 2008 at 4:35 PM, Doug Lea wrote:
> >>>
> >>> 3. ConcurrentReferenceHashMap
> >>>   A concurrent hash map allowing weak, soft, etc keys and values.
> >>
> >> BTW, I like the name "ReferenceMap" better.
> >>   - It's obviously concurrent because it's in the "concurrent" package.
> >>   - It doesn't makes sense to use anything but a hash-based
> implementation
> >> with references.
> >>   - We won't want a non-concurrent reference map because it will retain
> >> garbage for too long.
> >>   - I like shorter names.
> >> Bob
> >
> > I like shorter names, but I also like consistency.
> >
> > ConcurrentReferenceHashMap is more consistent with the naming of its
> sibling
> > classes, such as ConcurrentHashMap, whereas ReferenceMap is more
> consistent
> > with the naming of interfaces.
>
> Agree - consistency and clarity. IMO, this is way more important than
> the 'spoken name argument' that Bob gives - it is really not that
> often I tell Joe to use a particular class - it is much more often I
> have to understand a type of a variable, remember a name, read the
> code. I find it easier to remember a clear, consistent name, than a
> "catchy" one - like in what aspects of its function was it they had
> left out in that name? The "Concurrent" or "Hash" aspect? Ah, both,
> actually. I find it annoying to have to check the package name to
> understand a class's function. On the point of "brain parsing time"
> that can be raised in such naming discussion, it is shown (!) that we
> humans tend to parse entire words as an image, rather than reading
> each letter (which actually gives an important naming-argument: Don't
> let names be the same length and visually look the same). On writing
> time, one code in IDE's, not notepad. Lastly, taking this shortening
> logic further, one will end up with name clashes and hence
> misunderstandings, like in "Awh, damn, it is a NORMAL DingDong, not
> the package.blue version - no wonder everything crashes!".
>
> Endre.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081211/804c0ba3/attachment.html>

From elizarov at devexperts.com  Thu Dec 11 13:10:26 2008
From: elizarov at devexperts.com (Roman Elizarov)
Date: Thu, 11 Dec 2008 21:10:26 +0300
Subject: [concurrency-interest] MORE ON: Re[2]: RFC -- Java7
	java.util.concurrent plans
In-Reply-To: <49414DF4.7060203@cs.oswego.edu>
References: <568388113.20081210212805@devexperts.com>
	<494023DF.5040405@cs.oswego.edu>
	<1278092740.20081211151324@devexperts.com>
	<49414DF4.7060203@cs.oswego.edu>
Message-ID: <1724976871.20081211211026@devexperts.com>

Hello Doug!

>> It would be utterly cool for certain algorithms if this class also
>> contains a method with the following signature:
>>   void set(int[] a, int index, int value0, int value1);
>> which atomically does:
>>   a[index] = value0;
>>   a[index+1] = value1;

DL> Assuming you mean "int" only, you are probably better off manually
DL> packing into longs. Most machines require 8byte alignment of
DL> CAS/atomic-set of 64bit locations, which packing into longs would
DL> automatically provide.

In my case there is mostly int-sized data that I often access which is
interspersed with some "long" items which I want to change atomically.
It will be slow to unpack a long each time I need an int from it. You
can see that this is just a poor-man's replacement for a struct[].
That is our Javish way to do array of structs that contain just
primite data. Since most of our data is int-sized, we pack an array of
structs into int[].

Unfortunately, alignment spoils the idea of doing it that way. Thanks
for pointing it out!

>> This will close yet another Java vs native performance gap. Actually,
>> there are only few places left where Java algorithm running on HotSpot
>> significantly underperform compared to C/C++. One place is related to
>> high-performance/concurrent data strucutures. Consider a hash map from
>> int to Object. In C++ you would implement it as an array of structs.
>> But in Java the only way to implement it is to have a separate int[]
>> and a separate Object[]. Makes it twice as slow in practice, since
>> there are twice as many cache rows to load. We badly need
>> heterogenous/struct arrays. 

DL> I completely agree. I've been arguing for this for years.
DL> If anyone is looking for a good JVM project (on openJDK or elsewhere)
DL> to sink a lot of time into, this is among the most needed for
DL> supporting higher-performance data structures and algorithms
DL> (not just parallel ones).

The effort will be enourmous... I doubt that it can really payoff for
any one particular business project. In my case I'd rather buy faster
hardware that invest time into this project. Even though many people
will obvously benefit, it is not clear how to "pool" the resource they
could contribute (Create a fund? "Donate $1000 for structs in Java!"
;)

Sincerely,
Roman Elizarov


From alexdmiller at yahoo.com  Fri Dec 12 14:19:41 2008
From: alexdmiller at yahoo.com (Alex Miller)
Date: Fri, 12 Dec 2008 11:19:41 -0800 (PST)
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
References: <mailman.1.1229101200.23244.concurrency-interest@cs.oswego.edu>
Message-ID: <686921.75012.qm@web32103.mail.mud.yahoo.com>

I'd vote with Bob.  

I think having things in the concurrent package is a strong enough signal that the map itself is "concurrent".  I don't see why every class needs to repeat the "concurrent" as in java.util.concurrent.ConcurrentBeardTugger (maybe a future addition).  

The only benefit I see of ReferenceHashMap over ReferenceMap is that the latter sounds like an interface in collections language and the former sounds more like implementation, which it is.  That's kind a weak enough argument that I'd be happy to take the shorter path.

Alex
  

On Thu, Dec 11, 2008 at 9:52 AM, Bob Lee <crazybob at crazybob.org> wrote:


> I'd argue that "ReferenceMap" *is* consistent with other types. For example,
> we don't call DelayQueue "ConcurrentDelayedPriorityQueue".
>
> Bob

From kevinb at google.com  Fri Dec 12 14:35:02 2008
From: kevinb at google.com (Kevin Bourrillion)
Date: Fri, 12 Dec 2008 11:35:02 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <686921.75012.qm@web32103.mail.mud.yahoo.com>
References: <mailman.1.1229101200.23244.concurrency-interest@cs.oswego.edu>
	<686921.75012.qm@web32103.mail.mud.yahoo.com>
Message-ID: <108fcdeb0812121135g1d7aa9efw5d51629aee9193b9@mail.gmail.com>

In the debate between descriptiveness and usability concerns, I'd just
remind us that every name always represents a compromise between those two.
So we're not really debating one vs. the other, just at what point we feel
the right balance is struck.

If I had a vote, I'm with ReferenceMap (and DelayQueue).  ReferenceHashMap
is also livable.  ConcurrentReferenceHashMap is, to me, over the line; I
believe it would actually in practice be lesser-known and lesser-used for
its handicap of a name.



On Fri, Dec 12, 2008 at 11:19 AM, Alex Miller <alexdmiller at yahoo.com> wrote:

> I'd vote with Bob.
>
> I think having things in the concurrent package is a strong enough signal
> that the map itself is "concurrent".  I don't see why every class needs to
> repeat the "concurrent" as in java.util.concurrent.ConcurrentBeardTugger
> (maybe a future addition).
>
> The only benefit I see of ReferenceHashMap over ReferenceMap is that the
> latter sounds like an interface in collections language and the former
> sounds more like implementation, which it is.  That's kind a weak enough
> argument that I'd be happy to take the shorter path.
>
> Alex
>
>
> On Thu, Dec 11, 2008 at 9:52 AM, Bob Lee <crazybob at crazybob.org> wrote:
>
>
> > I'd argue that "ReferenceMap" *is* consistent with other types. For
> example,
> > we don't call DelayQueue "ConcurrentDelayedPriorityQueue".
> >
> > Bob
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Kevin Bourrillion @ Google
internal:  http://go/javalibraries
google-collections.googlecode.com
google-guice.googlecode.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081212/148cfba8/attachment.html>

From matthias at mernst.org  Fri Dec 12 14:41:24 2008
From: matthias at mernst.org (Matthias Ernst)
Date: Fri, 12 Dec 2008 20:41:24 +0100
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <686921.75012.qm@web32103.mail.mud.yahoo.com>
References: <mailman.1.1229101200.23244.concurrency-interest@cs.oswego.edu>
	<686921.75012.qm@web32103.mail.mud.yahoo.com>
Message-ID: <22ec15240812121141y7f62eeebqc1cee7d38ef96d8c@mail.gmail.com>

> "ConcurrentBeardTugger"

Would that be a euphemism for a Dining Philosopher?
(Sorry couldn't resist)

On Fri, Dec 12, 2008 at 8:19 PM, Alex Miller <alexdmiller at yahoo.com> wrote:
> I'd vote with Bob.
>
> I think having things in the concurrent package is a strong enough signal that the map itself is "concurrent".  I don't see why every class needs to repeat the "concurrent" as in java.util.concurrent.ConcurrentBeardTugger (maybe a future addition).
>
> The only benefit I see of ReferenceHashMap over ReferenceMap is that the latter sounds like an interface in collections language and the former sounds more like implementation, which it is.  That's kind a weak enough argument that I'd be happy to take the shorter path.
>
> Alex
>
>
> On Thu, Dec 11, 2008 at 9:52 AM, Bob Lee <crazybob at crazybob.org> wrote:
>
>
>> I'd argue that "ReferenceMap" *is* consistent with other types. For example,
>> we don't call DelayQueue "ConcurrentDelayedPriorityQueue".
>>
>> Bob
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From kevinb at google.com  Fri Dec 12 15:40:30 2008
From: kevinb at google.com (Kevin Bourrillion)
Date: Fri, 12 Dec 2008 12:40:30 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <1501fdf40812121231x29077d6an77fe7c9dd8fd235d@mail.gmail.com>
References: <mailman.1.1229101200.23244.concurrency-interest@cs.oswego.edu>
	<686921.75012.qm@web32103.mail.mud.yahoo.com>
	<108fcdeb0812121135g1d7aa9efw5d51629aee9193b9@mail.gmail.com>
	<1501fdf40812121231x29077d6an77fe7c9dd8fd235d@mail.gmail.com>
Message-ID: <108fcdeb0812121240v1746ee2di52959d46bbc8d760@mail.gmail.com>

On Fri, Dec 12, 2008 at 12:31 PM, Endre St?lsvik <Endre at stolsvik.com> wrote:

> ConcurrentReferenceHashMap is, to me, over the line; I
> > believe it would actually in practice be lesser-known and lesser-used for
> > its handicap of a name.
>
> "Lesser-known and lesser-used"?!


Yes.

I get what you're saying: your comments imply quite strongly that you don't
believe there is any such concept as "usability."  If a feature exists, then
people will use it, right?

But in my experience, usability matters -- a lot.  It is not only the
quality and utility of a feature, but also how appropriately that feature is
presented (from the *users'* perspective, not the authors'), that governs
how much that feature will pay off.


-- 
Kevin Bourrillion @ Google
internal:  go/javalibraries
google-collections.googlecode.com
google-guice.googlecode.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081212/7d2c8407/attachment.html>

From joe.bowbeer at gmail.com  Fri Dec 12 16:19:50 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri, 12 Dec 2008 13:19:50 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <108fcdeb0812121240v1746ee2di52959d46bbc8d760@mail.gmail.com>
References: <mailman.1.1229101200.23244.concurrency-interest@cs.oswego.edu>
	<686921.75012.qm@web32103.mail.mud.yahoo.com>
	<108fcdeb0812121135g1d7aa9efw5d51629aee9193b9@mail.gmail.com>
	<1501fdf40812121231x29077d6an77fe7c9dd8fd235d@mail.gmail.com>
	<108fcdeb0812121240v1746ee2di52959d46bbc8d760@mail.gmail.com>
Message-ID: <31f2a7bd0812121319ya74d25t7bd270d9405b0ac7@mail.gmail.com>

On Fri, Dec 12, 2008 at 12:40 PM, Kevin Bourrillion wrote:

> On Fri, Dec 12, 2008 at 12:31 PM, Endre St?lsvik wrote:
>
> > ConcurrentReferenceHashMap is, to me, over the line; I
>> > believe it would actually in practice be lesser-known and lesser-used
>> for
>> > its handicap of a name.
>>
>> "Lesser-known and lesser-used"?!
>
>
> Yes.
>
> I get what you're saying: your comments imply quite strongly that you don't
> believe there is any such concept as "usability."  If a feature exists, then
> people will use it, right?
>
> But in my experience, usability matters -- a lot.  It is not only the
> quality and utility of a feature, but also how appropriately that feature is
> presented (from the *users'* perspective, not the authors'), that governs
> how much that feature will pay off.
>


Endre expresses the sentiment of this API user fairly accurately.
Consistency contributes to usability.

I think ConcurrentReferenceMap is the best solution.  It combines
consistency and clarity in their proper proportions.

Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081212/b7722d15/attachment.html>

From crazybob at crazybob.org  Fri Dec 12 16:29:51 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Fri, 12 Dec 2008 13:29:51 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <31f2a7bd0812121319ya74d25t7bd270d9405b0ac7@mail.gmail.com>
References: <mailman.1.1229101200.23244.concurrency-interest@cs.oswego.edu>
	<686921.75012.qm@web32103.mail.mud.yahoo.com>
	<108fcdeb0812121135g1d7aa9efw5d51629aee9193b9@mail.gmail.com>
	<1501fdf40812121231x29077d6an77fe7c9dd8fd235d@mail.gmail.com>
	<108fcdeb0812121240v1746ee2di52959d46bbc8d760@mail.gmail.com>
	<31f2a7bd0812121319ya74d25t7bd270d9405b0ac7@mail.gmail.com>
Message-ID: <a74683f90812121329i344cf91fpdf0d10164a909d@mail.gmail.com>

On Fri, Dec 12, 2008 at 1:19 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> I think ConcurrentReferenceMap is the best solution.  It combines
> consistency and clarity in their proper proportions.
>

As for consistency, only 33% of the collection types in the util.concurrent
package start with "Concurrent". As a rule, I think a type should start with
"Concurrent" if it conflicts with a type of the same name in a different
package (like HashMap and ConcurrentHashMap), but that isn't the case here.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081212/9e2931aa/attachment.html>

From joe.bowbeer at gmail.com  Fri Dec 12 16:35:54 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri, 12 Dec 2008 13:35:54 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <a74683f90812121329i344cf91fpdf0d10164a909d@mail.gmail.com>
References: <mailman.1.1229101200.23244.concurrency-interest@cs.oswego.edu>
	<686921.75012.qm@web32103.mail.mud.yahoo.com>
	<108fcdeb0812121135g1d7aa9efw5d51629aee9193b9@mail.gmail.com>
	<1501fdf40812121231x29077d6an77fe7c9dd8fd235d@mail.gmail.com>
	<108fcdeb0812121240v1746ee2di52959d46bbc8d760@mail.gmail.com>
	<31f2a7bd0812121319ya74d25t7bd270d9405b0ac7@mail.gmail.com>
	<a74683f90812121329i344cf91fpdf0d10164a909d@mail.gmail.com>
Message-ID: <31f2a7bd0812121335w307ed494j4613996eac6825fd@mail.gmail.com>

On Fri, Dec 12, 2008 at 1:29 PM, Bob Lee wrote:

> On Fri, Dec 12, 2008 at 1:19 PM, Joe Bowbeer wrote:
>
>> I think ConcurrentReferenceMap is the best solution.  It combines
>> consistency and clarity in their proper proportions.
>>
>
> As for consistency, only 33% of the collection types in the util.concurrent
> package start with "Concurrent". As a rule, I think a type should start with
> "Concurrent" if it conflicts with a type of the same name in a different
> package (like HashMap and ConcurrentHashMap), but that isn't the case here.
>


ConcurrentHashMap and ConcurrentReferenceMap both implement ConcurrentMap.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081212/59a1ec35/attachment-0001.html>

From crazybob at crazybob.org  Fri Dec 12 16:46:53 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Fri, 12 Dec 2008 13:46:53 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <31f2a7bd0812121335w307ed494j4613996eac6825fd@mail.gmail.com>
References: <mailman.1.1229101200.23244.concurrency-interest@cs.oswego.edu>
	<686921.75012.qm@web32103.mail.mud.yahoo.com>
	<108fcdeb0812121135g1d7aa9efw5d51629aee9193b9@mail.gmail.com>
	<1501fdf40812121231x29077d6an77fe7c9dd8fd235d@mail.gmail.com>
	<108fcdeb0812121240v1746ee2di52959d46bbc8d760@mail.gmail.com>
	<31f2a7bd0812121319ya74d25t7bd270d9405b0ac7@mail.gmail.com>
	<a74683f90812121329i344cf91fpdf0d10164a909d@mail.gmail.com>
	<31f2a7bd0812121335w307ed494j4613996eac6825fd@mail.gmail.com>
Message-ID: <a74683f90812121346n369fd5fby1ec8814a250ad792@mail.gmail.com>

On Fri, Dec 12, 2008 at 1:35 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> As for consistency, only 33% of the collection types in the util.concurrent
>> package start with "Concurrent". As a rule, I think a type should start with
>> "Concurrent" if it conflicts with a type of the same name in a different
>> package (like HashMap and ConcurrentHashMap), but that isn't the case here.
>>
>
> ConcurrentHashMap and ConcurrentReferenceMap both implement ConcurrentMap.


We had to prefix CHM with "Concurrent" because of HashMap, not because the
interface name starts with "Concurrent".

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081212/e4406e42/attachment.html>

From joe.bowbeer at gmail.com  Fri Dec 12 17:25:38 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri, 12 Dec 2008 14:25:38 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <31f2a7bd0812121335w307ed494j4613996eac6825fd@mail.gmail.com>
References: <mailman.1.1229101200.23244.concurrency-interest@cs.oswego.edu>
	<686921.75012.qm@web32103.mail.mud.yahoo.com>
	<108fcdeb0812121135g1d7aa9efw5d51629aee9193b9@mail.gmail.com>
	<1501fdf40812121231x29077d6an77fe7c9dd8fd235d@mail.gmail.com>
	<108fcdeb0812121240v1746ee2di52959d46bbc8d760@mail.gmail.com>
	<31f2a7bd0812121319ya74d25t7bd270d9405b0ac7@mail.gmail.com>
	<a74683f90812121329i344cf91fpdf0d10164a909d@mail.gmail.com>
	<31f2a7bd0812121335w307ed494j4613996eac6825fd@mail.gmail.com>
Message-ID: <31f2a7bd0812121425q498378d0jfa89ac4b08137d6e@mail.gmail.com>

On Fri, Dec 12, 2008 at 1:35 PM, Joe Bowbeer wrote:

> On Fri, Dec 12, 2008 at 1:29 PM, Bob Lee wrote:
>
>>
>> As for consistency, only 33% of the collection types in the
>> util.concurrent package start with "Concurrent". As a rule, I think a type
>> should start with "Concurrent" if it conflicts with a type of the same name
>> in a different package (like HashMap and ConcurrentHashMap), but that isn't
>> the case here.
>>
>
>
> ConcurrentHashMap and ConcurrentReferenceMap both implement ConcurrentMap.
>


Concerning the 33% ...

Almost all of the concurrent collections have something in their name that
indicates they are suitable for multi-threaded use.  Words like:

  Blocking
  CopyOnWrite
  Synchronous

Most of the rest have Concurrent.

DelayQueue is the sole exception (right?)

and even there, "delay" implies asynchronous execution.

Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081212/e4197497/attachment.html>

From jason.greene at redhat.com  Fri Dec 12 17:46:43 2008
From: jason.greene at redhat.com (Jason T. Greene)
Date: Fri, 12 Dec 2008 16:46:43 -0600
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <a74683f90812100743v7f38272bxaa1fa8bc16e6d39d@mail.gmail.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<a74683f90812100743v7f38272bxaa1fa8bc16e6d39d@mail.gmail.com>
Message-ID: <4942E9D3.8060906@redhat.com>

Bob Lee wrote:
> On Tue, Dec 9, 2008 at 4:35 PM, Doug Lea <dl at cs.oswego.edu 
> <mailto:dl at cs.oswego.edu>> wrote:
> 
>     3. ConcurrentReferenceHashMap
>       A concurrent hash map allowing weak, soft, etc keys and values.
> 
> 
> BTW, I like the name "ReferenceMap" better. 
> 
>   - It's obviously concurrent because it's in the "concurrent" package.
>   - It doesn't makes sense to use anything but a hash-based 
> implementation with references.

Good points.

>   - We won't want a non-concurrent reference map because it will retain 
> garbage for too long.

I am not so sure about this one. Once there are ephemerons the value 
reference would be cleaned up with the key. If ephemerons aren't 
available, it could be possible to have eager value collection where a 
cleanup thread nullifies the value reference. The only garbage that 
would remain in that case would be a Entry object. Writes would then 
just replace the "tombstoned" entries (potentially cleaning up others).

--
Jason T. Greene
JBoss, a division of Red Hat

From crazybob at crazybob.org  Fri Dec 12 19:38:26 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Fri, 12 Dec 2008 16:38:26 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <4942E9D3.8060906@redhat.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<a74683f90812100743v7f38272bxaa1fa8bc16e6d39d@mail.gmail.com>
	<4942E9D3.8060906@redhat.com>
Message-ID: <a74683f90812121638w27b9a3bfje930d5e787ad9b3a@mail.gmail.com>

On Fri, Dec 12, 2008 at 2:46 PM, Jason T. Greene <jason.greene at redhat.com>wrote:

> I am not so sure about this one. Once there are ephemerons the value
> reference would be cleaned up with the key. If ephemerons aren't available,
> it could be possible to have eager value collection where a cleanup thread
> nullifies the value reference. The only garbage that would remain in that
> case would be a Entry object. Writes would then just replace the
> "tombstoned" entries (potentially cleaning up others).


Good point about ephemerons. Here's a question: does it make sense to bother
with a non-concurrent version at all given that the performance difference
(in the uncontended and read-only cases) is almost indiscernible?

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081212/53695c85/attachment.html>

From dcholmes at optusnet.com.au  Fri Dec 12 21:14:38 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sat, 13 Dec 2008 12:14:38 +1000
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <a74683f90812121346n369fd5fby1ec8814a250ad792@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEOJHOAA.dcholmes@optusnet.com.au>

I disagree - we prefixed CHM with Concurrent because it supports concurrent
access. The "Concurrent" prefix is descriptive giving an indication of the
kind of concurrency support that is given. It is not there simply because
something is in the java.util.concurrent package.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Bob Lee
  Sent: Saturday, 13 December 2008 7:47 AM
  To: Joe Bowbeer
  Cc: concurrency-interest
  Subject: Re: [concurrency-interest] RFC -- Java7 java.util.concurrent
plans


  On Fri, Dec 12, 2008 at 1:35 PM, Joe Bowbeer <joe.bowbeer at gmail.com>
wrote:

      As for consistency, only 33% of the collection types in the
util.concurrent package start with "Concurrent". As a rule, I think a type
should start with "Concurrent" if it conflicts with a type of the same name
in a different package (like HashMap and ConcurrentHashMap), but that isn't
the case here.


    ConcurrentHashMap and ConcurrentReferenceMap both implement
ConcurrentMap.

  We had to prefix CHM with "Concurrent" because of HashMap, not because the
interface name starts with "Concurrent".

  Bob


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081213/68be765c/attachment.html>

From osvaldo at visionnaire.com.br  Sat Dec 13 06:56:33 2008
From: osvaldo at visionnaire.com.br (Osvaldo Pinali Doederlein)
Date: Sat, 13 Dec 2008 09:56:33 -0200
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEOJHOAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCOEOJHOAA.dcholmes@optusnet.com.au>
Message-ID: <4943A2F1.1010107@visionnaire.com.br>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081213/0e7ad917/attachment-0001.html>

From carfield at carfield.com.hk  Sat Dec 13 08:09:18 2008
From: carfield at carfield.com.hk (Carfield Yim)
Date: Sat, 13 Dec 2008 21:09:18 +0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <22ec15240812121141y7f62eeebqc1cee7d38ef96d8c@mail.gmail.com>
References: <mailman.1.1229101200.23244.concurrency-interest@cs.oswego.edu>
	<686921.75012.qm@web32103.mail.mud.yahoo.com>
	<22ec15240812121141y7f62eeebqc1cee7d38ef96d8c@mail.gmail.com>
Message-ID: <b4503c170812130509m4398d7dfi815614c3d7c906ba@mail.gmail.com>

On Sat, Dec 13, 2008 at 3:41 AM, Matthias Ernst <matthias at mernst.org> wrote:

> > "ConcurrentBeardTugger"
>
> Would that be a euphemism for a Dining Philosopher?
> (Sorry couldn't resist)
>
An idea just come up, may be we can have Collections.concurrencyMap,
Collections.concurrencySet and Collections.concurrencyList?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081213/3374eec6/attachment.html>

From chriskessel at verizon.net  Sat Dec 13 13:21:09 2008
From: chriskessel at verizon.net (Chris Kessel/Lou Doherty)
Date: Sat, 13 Dec 2008 10:21:09 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <4943A2F1.1010107@visionnaire.com.br>
Message-ID: <0KBT0077UUVU81I2@vms173003.mailsrvcs.net>

As an user of the libraries, I'd rather see descriptive names rather than
rely on looking at package imports to understand where it's from. Though,
that does depend a bit on expected usage context as I'll mention later.
 
When I'm reading through code and see HashMap, I'm going to think it's the
original hash map, not one from a different implementation. I'm not going to
go check what package it's imported from. I'm just going to make that quick
mental assessment of the feature set and keep reading on, which may very
well mean I've created the wrong mental mindset for reading the rest of that
code. If I see ConcurrentHashMap, that's a nice reminder to keep concurrency
in mind as I read the method/class and think about my modifications to that
code.
 
However, context of usage is an important part of whether or not a generic
or overloaded name is confusing. You'll use a ConcurrentHashMap as a helper
to bring concurrency safety to your work in other domains. You'll typically
only use an Image or Canvas while working on GUI stuff, so it's being used
in a context that makes it's name more obvious. The SQL class Statement is a
horribly generic name, but it's only ever used in the context of a database
call, so there's little confusion. If someone made a 3rd party library that
helped support database work and created a class named Statement, even as
replacement for the original Statement, that'd be terribly confusing because
it corrupts the expected understanding of what "Statement" means in that
context.
 
I suppose, for me, if the class is a helper to other domains, a more
descriptive name helps clarify what it's bringing to the table. If it's a
class used only within it's own domain (GUI, Socket communications, and DB
usage might be examples) then it's less important to clarify the name.
 
Chris

  _____  

From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Osvaldo
Pinali Doederlein
Sent: Saturday, December 13, 2008 3:57 AM
To: dholmes at ieee.org
Cc: concurrency-interest
Subject: Re: [concurrency-interest] RFC -- Java7 java.util.concurrent plans


David Holmes wrote: 

I disagree - we prefixed CHM with Concurrent because it supports concurrent
access. The "Concurrent" prefix is descriptive giving an indication of the
kind of concurrency support that is given. It is not there simply because
something is in the java.util.concurrent package.

As it seems to me, the naming standard of the JavaSE APIs (and remarkably
for the Collections API) is that concrete types carry all the main semantics
and implementation meanings that are relevant to users. CRHM is a concurrent
(scalable / thread-happy), hashing (data structure algorithm / big-O
performance / requires keys to provide decent hashCode()), map (collection
kind) that holds references (memory mgmt behavior) to something. All these
meanings fit clearly in the [unwritten] criteria that's been used at least
since Java2, when API naming and design became much more homogeneous than in
JDK 1.0/1.1.

I understand that some people would like to drop "Concurrent" in the basis
of the DRY principle, as that class lives inside a java.util.concurrent
package. But this principle is not strongly observed in the JavaSE APIs -
for example, the java.lang.ref package is full of classes with "Reference"
prefixes (*). My vote is to favor consistency, but having the entire Java
SE/EE APIs as context. (Even the vast majority of third-party frameworks
tend to follow the same style.) I agree, too, that it's important to avoid
clashes with other collections even from different packages. It's very comon
usage to mix different kinds of collections in a single client class, so you
can' rely on packages alone (and in cases like java.util.List X
java.awt.List, clashes are common exactly because the domains are
orthogonal).

(*) One could argue that names like "Weak" would look odd, incomplete: weak
what? But after Java5's generics you wouldn't write "Weak buffer", you write
"Weak<Image> buffer" that looks much better. It seems that post-generics,
naming style should often consider the full composition with generic
parameters. Although that's a difficult, case-by-case reasoning... for a
scenario like Weak<Image>, the Weak component looks like a trait, as one
reads "a weak image". Better style for Scala? ;-)

A+
Osvaldo


 
David Holmes

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Bob Lee
Sent: Saturday, 13 December 2008 7:47 AM
To: Joe Bowbeer
Cc: concurrency-interest
Subject: Re: [concurrency-interest] RFC -- Java7 java.util.concurrent plans


On Fri, Dec 12, 2008 at 1:35 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:


As for consistency, only 33% of the collection types in the util.concurrent
package start with "Concurrent". As a rule, I think a type should start with
"Concurrent" if it conflicts with a type of the same name in a different
package (like HashMap and ConcurrentHashMap), but that isn't the case here.



ConcurrentHashMap and ConcurrentReferenceMap both implement ConcurrentMap.


We had to prefix CHM with "Concurrent" because of HashMap, not because the
interface name starts with "Concurrent".

Bob 





  _____  


_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu

http://cs.oswego.edu/mailman/listinfo/concurrency-interest

  



-- 

-----------------------------------------------------------------------

Osvaldo Pinali Doederlein                        Visionnaire Virtus S/A

osvaldo at visionnaire.com.br                http://www.visionnaire.com.br

Arquiteto de Tecnologia                          +55 (41) 337-1000 #226
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081213/073d5b6c/attachment.html>

From crazybob at crazybob.org  Sat Dec 13 13:24:37 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Sat, 13 Dec 2008 10:24:37 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <4943A2F1.1010107@visionnaire.com.br>
References: <NFBBKALFDCPFIDBNKAPCOEOJHOAA.dcholmes@optusnet.com.au>
	<4943A2F1.1010107@visionnaire.com.br>
Message-ID: <a74683f90812131024r20edf099v1767d23202efff61@mail.gmail.com>

On Sat, Dec 13, 2008 at 3:56 AM, Osvaldo Pinali Doederlein <
osvaldo at visionnaire.com.br> wrote:

> (*) One could argue that names like "Weak" would look odd, incomplete: weak
> what? But after Java5's generics you wouldn't write "Weak buffer", you write
> "Weak<Image> buffer" that looks much better. It seems that post-generics,
> naming style should often consider the full composition with generic
> parameters. Although that's a difficult, case-by-case reasoning... for a
> scenario like Weak<Image>, the Weak component looks like a trait, as one
> reads "a weak image". Better style for Scala? ;-)
>

I think the naming rules differ a bit for nouns vs. adjectives among other
things.

>From a usability standpoint, we should also consider the verbosity of the
user's code and whether or not they'll have to wrap lines. JBoss's CRHM
currently requires you to write something like this(*):

    static final ConcurrentMap<String, Data> cache
            = new ConcurrentReferenceHashMap<String, Data>(
                        ConcurrentReferenceHashMap.ReferenceType.STRONG,
                        ConcurrentReferenceHashMap.ReferenceType.SOFT);

Here's how it would look with a shorter name:

    static final ConcurrentMap<String, Data> cache
            = new ReferenceMap<String,
Data>(ReferenceMap.ReferenceType.STRONG,
                        ReferenceMap.ReferenceType.SOFT);

I actually think we should use a builder:

    static final ConcurrentMap<String, Data> cache
            = new ReferenceMap.Builder().softValues().build();

Bob

(*) CRHM actually requires you to explicitly specify the capacity, load
factor and concurrency level, too:
http://viewvc.jboss.org/cgi-bin/viewvc.cgi/jbosscache/experimental/jsr166/src/jsr166y/ConcurrentReferenceHashMap.java?revision=5470&view=markup&pathrev=5470
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081213/a2cf1e0c/attachment.html>

From javafreelancer at gmail.com  Sat Dec 13 14:41:12 2008
From: javafreelancer at gmail.com (borderline_ocd-er)
Date: Sat, 13 Dec 2008 19:41:12 +0000
Subject: [concurrency-interest] examples of parallel processing in j2ee web
	apps?
Message-ID: <dc08cd60812131141qf437cf5v8e702b64686c5780@mail.gmail.com>

hello list,

please, can you share with us any examples (real-world or otherwise)
of using the java.util.concurrency api for doing parallel processing
in a j2ee web app?

this article gives one possible use case:

"...many Web applications have a set of tasks that can take advantage
of multithreaded processing, such as building a Web page in response
to a user request that requires queries to different databases and
loading a combination of text and images..." [1]

but is that the best example?

if any of the following is to be believed, the parallel programming
paradigm doesn't apply to j2ee web apps.

"...most web applications already parallelize pretty obviously at the
request level...But after that, it's generally difficult to
parallelize: if your request looks like "add a record to the User
table, then read the list of current users and render them to the UI"
it's just not easy to figure out how to parallelize..." [2]

"...There is simply no need for [parallel computing] in the vast
majority of applications...." [3]


an mdb/jms approach is often suggested as a "best practice" for
concurrency in j2ee web apps [4]; the JSR 237 Work Manager API [5] is
a neat option too. i know that spawning custom threads in j2ee
containers is discouraged. but, of course, people are doing it anyway.
so, please can you share with us any ideas (success stories, or
caveats, or horror stories) for using the java.util.concurrency api
for doing parallel processing in j2ee web apps?

thanks in advance for your replies.


[1] http://www.informationweek.com/news/software/open_source/showArticle.jhtml?articleID=206800900
[2] http://guidewiredevelopment.wordpress.com/2008/10/03/dont-believe-the-hype/
[3] http://blogs.techrepublic.com.com/programming-and-development/?p=745
[4] http://www.javaworld.com/javaworld/jw-07-2003/jw-0718-mdb.html?page=1
[5] http://www.jcp.org/en/jsr/detail?id=237

From javafreelancer at gmail.com  Sat Dec 13 15:58:32 2008
From: javafreelancer at gmail.com (borderline_ocd-er)
Date: Sat, 13 Dec 2008 20:58:32 +0000
Subject: [concurrency-interest] examples of parallel processing in j2ee
	web apps?
In-Reply-To: <dc08cd60812131141qf437cf5v8e702b64686c5780@mail.gmail.com>
References: <dc08cd60812131141qf437cf5v8e702b64686c5780@mail.gmail.com>
Message-ID: <dc08cd60812131258l6adb310focba15c19df3013ce@mail.gmail.com>

i just discovered this:

  http://gee.cs.oswego.edu/dl/concurrencyee-interest/

an evolved version of JSR 237 included  in Java EE 6.

On Sat, Dec 13, 2008 at 7:41 PM, borderline_ocd-er
<javafreelancer at gmail.com> wrote:
> hello list,
>
> please, can you share with us any examples (real-world or otherwise)
> of using the java.util.concurrency api for doing parallel processing
> in a j2ee web app?
>
> this article gives one possible use case:
>
> "...many Web applications have a set of tasks that can take advantage
> of multithreaded processing, such as building a Web page in response
> to a user request that requires queries to different databases and
> loading a combination of text and images..." [1]
>
> but is that the best example?
>
> if any of the following is to be believed, the parallel programming
> paradigm doesn't apply to j2ee web apps.
>
> "...most web applications already parallelize pretty obviously at the
> request level...But after that, it's generally difficult to
> parallelize: if your request looks like "add a record to the User
> table, then read the list of current users and render them to the UI"
> it's just not easy to figure out how to parallelize..." [2]
>
> "...There is simply no need for [parallel computing] in the vast
> majority of applications...." [3]
>
>
> an mdb/jms approach is often suggested as a "best practice" for
> concurrency in j2ee web apps [4]; the JSR 237 Work Manager API [5] is
> a neat option too. i know that spawning custom threads in j2ee
> containers is discouraged. but, of course, people are doing it anyway.
> so, please can you share with us any ideas (success stories, or
> caveats, or horror stories) for using the java.util.concurrency api
> for doing parallel processing in j2ee web apps?
>
> thanks in advance for your replies.
>
>
> [1] http://www.informationweek.com/news/software/open_source/showArticle.jhtml?articleID=206800900
> [2] http://guidewiredevelopment.wordpress.com/2008/10/03/dont-believe-the-hype/
> [3] http://blogs.techrepublic.com.com/programming-and-development/?p=745
> [4] http://www.javaworld.com/javaworld/jw-07-2003/jw-0718-mdb.html?page=1
> [5] http://www.jcp.org/en/jsr/detail?id=237
>

From jeremy.manson at gmail.com  Sat Dec 13 17:22:29 2008
From: jeremy.manson at gmail.com (Jeremy Manson)
Date: Sat, 13 Dec 2008 14:22:29 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <108fcdeb0812091852g18d44905r741a20687abba70e@mail.gmail.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<690295.97250.qm@web38803.mail.mud.yahoo.com>
	<a74683f90812091831y3d066aci5b3d6cd93d0ffdf1@mail.gmail.com>
	<108fcdeb0812091852g18d44905r741a20687abba70e@mail.gmail.com>
Message-ID: <1631da7d0812131422g688fb343lb951b2ddd95ed3c2@mail.gmail.com>

Actually, I had a performance problem with those dummy instances about
a week ago.  I ended up figuring out a way to call into it less,
though.

Jeremy

On Tue, Dec 9, 2008 at 6:52 PM, Kevin Bourrillion <kevinb at google.com> wrote:
> On Tue, Dec 9, 2008 at 6:31 PM, Bob Lee <crazybob at crazybob.org> wrote:
>
>>> I'm curious as to what design aspects make ConcurrentReferenceHashMap
>>> superior to Google's ReferenceMap.  It looks to have implemented its own
>>> hash table, versus delegating to a backing ConcurrentMap, but I don't
>>> immediately understand why this is preferable.
>>
>> ReferenceMap must create an object every time you call get() and it must
>> repeatedly lock/unlock in some situations whereas ConcurrentReferenceHashMap
>> can just grab the lock once and get the job done. I haven't looked at the
>> semantics of CRHM in awhile, but we have plenty of time to hammer those out.
>
> A ReferenceMap that lives outside java.util, without access to java.util
> internals, is forced to make this choice (either reimplement its own entire
> data structure, or discard a dummy instance on every query like ours does).
> We chose one way and Jason chose the other, but I'd still like to think that
> neither horrible fate must be suffered for the JDK code.
>
> For the record, Google's ReferenceMap is phenomenally well-tested and has
> been in production in Google apps for more than three years.  The
> performance impact of these discarded dummy instances has not been a serious
> problem in practice (I still think it's unsuitable for JDK code, but also
> unnecessary as explained above).  It's currently being used in 167 distinct
> projects.  Through this we've worked out a lot of fiendish bugs.  The JDK is
> welcome to as much or as little of its distilled wisdom as you please!
>
>
> --
> Kevin Bourrillion @ Google
> internal:  go/javalibraries
> google-collections.googlecode.com
> google-guice.googlecode.com
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From crazybob at crazybob.org  Sun Dec 14 11:41:57 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Sun, 14 Dec 2008 08:41:57 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <1501fdf40812140539n28a23e42q725a3b94dd4620a6@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCOEOJHOAA.dcholmes@optusnet.com.au>
	<4943A2F1.1010107@visionnaire.com.br>
	<a74683f90812131024r20edf099v1767d23202efff61@mail.gmail.com>
	<1501fdf40812140539n28a23e42q725a3b94dd4620a6@mail.gmail.com>
Message-ID: <a74683f90812140841i537ce74cy24ec51f79030fb9@mail.gmail.com>

On Sun, Dec 14, 2008 at 5:39 AM, Endre St?lsvik <Endre at stolsvik.com> wrote:

> You could import ReferenceType, right? Even import static STRONG and SOFT?
>
>     static final ConcurrentMap<String, Data> cache
>              = new ConcurrentReferenceHashMap<String, Data>(STRONG, SOFT);
>

Yes, of course. Premature senior moment. ;-)
Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081214/b20ac5d1/attachment.html>

From osvaldo at visionnaire.com.br  Sun Dec 14 13:15:57 2008
From: osvaldo at visionnaire.com.br (Osvaldo Pinali Doederlein)
Date: Sun, 14 Dec 2008 16:15:57 -0200
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <a74683f90812140841i537ce74cy24ec51f79030fb9@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCOEOJHOAA.dcholmes@optusnet.com.au>	
	<4943A2F1.1010107@visionnaire.com.br>	
	<a74683f90812131024r20edf099v1767d23202efff61@mail.gmail.com>	
	<1501fdf40812140539n28a23e42q725a3b94dd4620a6@mail.gmail.com>
	<a74683f90812140841i537ce74cy24ec51f79030fb9@mail.gmail.com>
Message-ID: <49454D5D.9070804@visionnaire.com.br>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081214/20917d95/attachment.html>

From javafreelancer at gmail.com  Mon Dec 15 13:39:29 2008
From: javafreelancer at gmail.com (borderline_ocd-er)
Date: Mon, 15 Dec 2008 18:39:29 +0000
Subject: [concurrency-interest] ThreadFactory.newThread(Runnable) and
	user-defined Runnables?
Message-ID: <dc08cd60812151039h48d73c60lbb70ede479dcf55c@mail.gmail.com>

using jdk 1.6.0_04 on win xp/sp 3.

given this implementation of Runnable:

abstract class NamedRunnable implements Runnable{
	
	private String name;
	
	public NamedRunnable(String name){
		this.name = name;
	}
	
	protected String getName(){
		return this.name;
	}
	
}


how come neither the compiler nor the runtime have a problem with
either of these uses of NamedRunnable as a legal Runnable
implementation :


		Collection<Callable<Object>> tasks = new ArrayList<Callable<Object>>();
		
		tasks.add(Executors.callable(new NamedRunnable("Thread X"){
			public void run(){...this.getName();...}
		}));


		Thread thread1 = new Thread(new NamedRunnable("Thread Y"){
			public void run(){...this.getName();...}
		});		
		
but the compiler complains about this:
		
   class NamingThreadFactory implements ThreadFactory {

      public Thread newThread(NamedRunnable runnable){
	      return new Thread(runnable);
      }
   }

with the message: "The type NamingThreadFactory must implement the
inherited abstract method ThreadFactory.newThread(Runnable)"

that is, as far as the "Executors.callable(Runnable)" utility method
and the "Thread(Runnable)" constructor are concerned, NamedRunnable is
a legal implementation of Runnable. why does
"ThreadFactory.newThread(Runnable)" disagree?

thanks in advance for your reply.

From matthias at mernst.org  Mon Dec 15 14:46:20 2008
From: matthias at mernst.org (Matthias Ernst)
Date: Mon, 15 Dec 2008 20:46:20 +0100
Subject: [concurrency-interest] ThreadFactory.newThread(Runnable) and
	user-defined Runnables?
In-Reply-To: <dc08cd60812151039h48d73c60lbb70ede479dcf55c@mail.gmail.com>
References: <dc08cd60812151039h48d73c60lbb70ede479dcf55c@mail.gmail.com>
Message-ID: <22ec15240812151146w5926555ci82fe2371726aa87@mail.gmail.com>

On Mon, Dec 15, 2008 at 7:39 PM, borderline_ocd-er
<javafreelancer at gmail.com> wrote:
> using jdk 1.6.0_04 on win xp/sp 3.
>
> given this implementation of Runnable:
>
> abstract class NamedRunnable implements Runnable{
>
>        private String name;
>
>        public NamedRunnable(String name){
>                this.name = name;
>        }
>
>        protected String getName(){
>                return this.name;
>        }
>
> }
>
>
> how come neither the compiler nor the runtime have a problem with
> either of these uses of NamedRunnable as a legal Runnable
> implementation :
>
>
>                Collection<Callable<Object>> tasks = new ArrayList<Callable<Object>>();
>
>                tasks.add(Executors.callable(new NamedRunnable("Thread X"){
>                        public void run(){...this.getName();...}
>                }));
>
>
>                Thread thread1 = new Thread(new NamedRunnable("Thread Y"){
>                        public void run(){...this.getName();...}
>                });
>
> but the compiler complains about this:
>
>   class NamingThreadFactory implements ThreadFactory {
>
>      public Thread newThread(NamedRunnable runnable){
>              return new Thread(runnable);
>      }
>   }
>
> with the message: "The type NamingThreadFactory must implement the
> inherited abstract method ThreadFactory.newThread(Runnable)"
>
> that is, as far as the "Executors.callable(Runnable)" utility method
> and the "Thread(Runnable)" constructor are concerned, NamedRunnable is
> a legal implementation of Runnable. why does
> "ThreadFactory.newThread(Runnable)" disagree?

Interface ThreadFactory promises to create a Thread for any Runnable.
Your NamingThreadFactory doesn't hold up to that promise. Google
covariant parameter types.

From javafreelancer at gmail.com  Mon Dec 15 16:12:03 2008
From: javafreelancer at gmail.com (borderline_ocd-er)
Date: Mon, 15 Dec 2008 21:12:03 +0000
Subject: [concurrency-interest] ThreadFactory.newThread(Runnable) and
	user-defined Runnables?
In-Reply-To: <dc08cd60812151039h48d73c60lbb70ede479dcf55c@mail.gmail.com>
References: <dc08cd60812151039h48d73c60lbb70ede479dcf55c@mail.gmail.com>
Message-ID: <dc08cd60812151312xf44e985l59db738379b52c76@mail.gmail.com>

thanks to everybody who replied,

what a dolt i am! i see where i went wrong now. oh well, everybody
make mistrakes... ;?)

many thanks

On Mon, Dec 15, 2008 at 6:39 PM, borderline_ocd-er
<javafreelancer at gmail.com> wrote:
> using jdk 1.6.0_04 on win xp/sp 3.
>
> given this implementation of Runnable:
>
> abstract class NamedRunnable implements Runnable{
>
>        private String name;
>
>        public NamedRunnable(String name){
>                this.name = name;
>        }
>
>        protected String getName(){
>                return this.name;
>        }
>
> }
>
>
> how come neither the compiler nor the runtime have a problem with
> either of these uses of NamedRunnable as a legal Runnable
> implementation :
>
>
>                Collection<Callable<Object>> tasks = new ArrayList<Callable<Object>>();
>
>                tasks.add(Executors.callable(new NamedRunnable("Thread X"){
>                        public void run(){...this.getName();...}
>                }));
>
>
>                Thread thread1 = new Thread(new NamedRunnable("Thread Y"){
>                        public void run(){...this.getName();...}
>                });
>
> but the compiler complains about this:
>
>   class NamingThreadFactory implements ThreadFactory {
>
>      public Thread newThread(NamedRunnable runnable){
>              return new Thread(runnable);
>      }
>   }
>
> with the message: "The type NamingThreadFactory must implement the
> inherited abstract method ThreadFactory.newThread(Runnable)"
>
> that is, as far as the "Executors.callable(Runnable)" utility method
> and the "Thread(Runnable)" constructor are concerned, NamedRunnable is
> a legal implementation of Runnable. why does
> "ThreadFactory.newThread(Runnable)" disagree?
>
> thanks in advance for your reply.
>


From elizarov at devexperts.com  Tue Dec 16 02:08:58 2008
From: elizarov at devexperts.com (Roman Elizarov)
Date: Tue, 16 Dec 2008 10:08:58 +0300
Subject: [concurrency-interest] ThreadFactory.newThread(Runnable) and
	user-defined Runnables?
In-Reply-To: <dc08cd60812151039h48d73c60lbb70ede479dcf55c@mail.gmail.com>
References: <dc08cd60812151039h48d73c60lbb70ede479dcf55c@mail.gmail.com>
Message-ID: <1947931098.20081216100858@devexperts.com>

Hello!

be>    class NamingThreadFactory implements ThreadFactory {
  ^^^^^^^^
be> with the message: "The type NamingThreadFactory must implement the
be> inherited abstract method ThreadFactory.newThread(Runnable)"

You should add the keyword "abtract" here or implement a method
"newThread" as the compiler warning advises you to. Your NamedRunnable
class is legal because it is marked as "abstract".

See Java Language Specification, 3rd Edition, Item 8.1.1.1 - abstract
classes.

Sincerely,
Roman Elizarov


From dl at cs.oswego.edu  Tue Dec 16 15:18:26 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 16 Dec 2008 15:18:26 -0500
Subject: [concurrency-interest]  Array element compareAndSet
In-Reply-To: <49414DF4.7060203@cs.oswego.edu>
References: <568388113.20081210212805@devexperts.com>	<494023DF.5040405@cs.oswego.edu>
	<1278092740.20081211151324@devexperts.com>
	<49414DF4.7060203@cs.oswego.edu>
Message-ID: <49480D12.8090602@cs.oswego.edu>

Doug Lea wrote:
> Roman Elizarov wrote:
>>  I would rather create
>> a separate "AtomicArrays" class where compareAndSet, set, and get
>> methods are declared for Object[], int[], and long[]. There will be
>> analogy with "java.util.Arrays". It will be easy to learn and use just
>> like "Arrays".
> 
> This might indeed be a better compromise. It would take some hard work
> to make the reference version efficient -- it would need to
> emulate ArrayStoreException checks at Java level, but in
> a way that JVMs could subject to the usual machinations that
> usually optimize them away. I'll look into it.
> 

It seems that a better way to do this is to add three
methods to java.lang.reflect.Array:
   compareAndSetObject(Object target, int i, Object exp, Object val)
   compareAndSetInt(Object target, int i, int exp, int val)
   compareAndSetLong(Object target, int i, long exp, long val)
This is a little delicate but ought to lead to better performance.
I'll try this out under openJDK. If successful, it may be time to
also allow people to evade ugly/painful AtomicXYUpdaters by
adding similar methods to java.lang.reflect.Field:
   compareAndSetObject(Object target, Object exp, Object val)
   compareAndSetInt(Object target, int exp, int val)
   compareAndSetLong(Object target, long exp, long val)
It will a few weeks at best before I can report on enough
experience to decide to argue for Java7 inclusion.

-Doug





From jason.greene at redhat.com  Tue Dec 16 17:18:40 2008
From: jason.greene at redhat.com (Jason T. Greene)
Date: Tue, 16 Dec 2008 16:18:40 -0600
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <a74683f90812121638w27b9a3bfje930d5e787ad9b3a@mail.gmail.com>
References: <493F0EE1.4030907@cs.oswego.edu>	
	<a74683f90812100743v7f38272bxaa1fa8bc16e6d39d@mail.gmail.com>	
	<4942E9D3.8060906@redhat.com>
	<a74683f90812121638w27b9a3bfje930d5e787ad9b3a@mail.gmail.com>
Message-ID: <49482940.3070509@redhat.com>

Bob Lee wrote:
> On Fri, Dec 12, 2008 at 2:46 PM, Jason T. Greene 
> <jason.greene at redhat.com <mailto:jason.greene at redhat.com>> wrote:
> 
>     I am not so sure about this one. Once there are ephemerons the value
>     reference would be cleaned up with the key. If ephemerons aren't
>     available, it could be possible to have eager value collection where
>     a cleanup thread nullifies the value reference. The only garbage
>     that would remain in that case would be a Entry object. Writes would
>     then just replace the "tombstoned" entries (potentially cleaning up
>     others).
> 
> 
> Good point about ephemerons. Here's a question: does it make sense to 
> bother with a non-concurrent version at all given that the performance 
> difference (in the uncontended and read-only cases) is almost indiscernible?

This is definitely not an easy question to answer.

The memory overhead will be higher, especially if they take the default 
concurrency-level. Write performance would definitely be impacted from 
all of the unnecessary fences, as well as the chain rebuilding that's 
not necessary in a non-concurrent algorithm. Read performance is 
impacted on platforms that require load barriers.

Although, to your point, reference tables do tend to have low write to 
read ratios, and a number of cpus today don't need load barriers. So it 
could very well be that the difference is small for the majority of 
scenarios. This could change in the future, depending on the direction 
hardware takes.

-- 
Jason T. Greene
JBoss, a division of Red Hat

From elizarov at devexperts.com  Wed Dec 17 06:02:44 2008
From: elizarov at devexperts.com (Roman Elizarov)
Date: Wed, 17 Dec 2008 14:02:44 +0300
Subject: [concurrency-interest] Array element compareAndSet
In-Reply-To: <49480D12.8090602@cs.oswego.edu>
References: <568388113.20081210212805@devexperts.com>
	<494023DF.5040405@cs.oswego.edu>
	<1278092740.20081211151324@devexperts.com>
	<49414DF4.7060203@cs.oswego.edu> <49480D12.8090602@cs.oswego.edu>
Message-ID: <1353352175.20081217140244@devexperts.com>

Hello Doug!

On Tuesday, December 16, 2008 11:18:26 PM you wrote:

DL> It seems that a better way to do this is to add three
DL> methods to java.lang.reflect.Array:
DL>    compareAndSetObject(Object target, int i, Object exp, Object val)
DL>    compareAndSetInt(Object target, int i, int exp, int val)
DL>    compareAndSetLong(Object target, int i, long exp, long val)

How about volatile get/set methods? You could change
Array.getInt/setInt to work as volatile and introduce lazySet/eagerGet
for non-volatile accesses (old get/set), but that would be a semantic
change of the existing methods (although a compatible one).

The other problem with Array is that a target array is declared as
"Object" argument in its methods, and there is always a performance
penalty for a type check (Array.getInt works for short[] and byte[]
according to its javadoc).

Btw, it is strange, that java.lang.reflect.Array class is still
written via native methods instead of sun.mics.Unsafe, so it is hard
to see what it really does inside. The actual implementation is quite
scary performance-wise.

Sincerely,
Roman Elizarov

DL> This is a little delicate but ought to lead to better performance.
DL> I'll try this out under openJDK. If successful, it may be time to
DL> also allow people to evade ugly/painful AtomicXYUpdaters by
DL> adding similar methods to java.lang.reflect.Field:
DL>    compareAndSetObject(Object target, Object exp, Object val)
DL>    compareAndSetInt(Object target, int exp, int val)
DL>    compareAndSetLong(Object target, long exp, long val)
DL> It will a few weeks at best before I can report on enough
DL> experience to decide to argue for Java7 inclusion.

DL> -Doug





Sincerely,
Roman Elizarov


From dl at cs.oswego.edu  Wed Dec 17 18:59:42 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 17 Dec 2008 18:59:42 -0500
Subject: [concurrency-interest] Array element compareAndSet
In-Reply-To: <1353352175.20081217140244@devexperts.com>
References: <568388113.20081210212805@devexperts.com>
	<494023DF.5040405@cs.oswego.edu>
	<1278092740.20081211151324@devexperts.com>
	<49414DF4.7060203@cs.oswego.edu> <49480D12.8090602@cs.oswego.edu>
	<1353352175.20081217140244@devexperts.com>
Message-ID: <4949926E.40803@cs.oswego.edu>

Roman Elizarov wrote:
>
> DL> It seems that a better way to do this is to add three
> DL> methods to java.lang.reflect.Array:
> DL>    compareAndSetObject(Object target, int i, Object exp, Object val)
> DL>    compareAndSetInt(Object target, int i, int exp, int val)
> DL>    compareAndSetLong(Object target, int i, long exp, long val)
> 
> How about volatile get/set methods? You could change
> Array.getInt/setInt to work as volatile and introduce lazySet/eagerGet

More likely, keeping existing ones as-is, and adding
   Object atomicGet(Object target, int i);
   void atomicSet(Object target, int i, Object val)
   void atomicLazySet(Object target, int i, Object val)

> 
> Btw, it is strange, that java.lang.reflect.Array class is still
> written via native methods instead of sun.mics.Unsafe, so it is hard
> to see what it really does inside. The actual implementation is quite
> scary performance-wise.

The idea is to subject these to the dynamic compilation
strategy used for java.lang.reflect.Field methods, so that the
type checks can then in turn be subject to the usual optimizations.
This is probably the only path to reliably removing unnecessary
checks. But it will be a lot of work. If anyone else out there is
interested in taking this on, please feel free.

-Doug





From elizarov at devexperts.com  Thu Dec 18 07:58:06 2008
From: elizarov at devexperts.com (Roman Elizarov)
Date: Thu, 18 Dec 2008 15:58:06 +0300
Subject: [concurrency-interest] Array element compareAndSet
In-Reply-To: <4949926E.40803@cs.oswego.edu>
References: <568388113.20081210212805@devexperts.com>
	<494023DF.5040405@cs.oswego.edu>
	<1278092740.20081211151324@devexperts.com>
	<49414DF4.7060203@cs.oswego.edu> <49480D12.8090602@cs.oswego.edu>
	<1353352175.20081217140244@devexperts.com>
	<4949926E.40803@cs.oswego.edu>
Message-ID: <323543689.20081218155806@devexperts.com>

Hello Doug!

On Thursday, December 18, 2008 2:59:42 AM you wrote:

DL> The idea is to subject these to the dynamic compilation
DL> strategy used for java.lang.reflect.Field methods, so that the
DL> type checks can then in turn be subject to the usual optimizations.
DL> This is probably the only path to reliably removing unnecessary
DL> checks.

This is the only path for API that takes "Object target" as an
argument. However, if API takes "int[] target" as an argument for int
operation, then it is straightforward to implement via sun.mics.Unsafe
(which uses intrinsics in HotSpot).

DL> But it will be a lot of work. If anyone else out there is
DL> interested in taking this on, please feel free.

Speedup of java.lang.reflect.Array operations may be of an interest to
a wider community (not just for concurrency). According to comment in
reflection.hpp:

// Class Reflection contains utility methods needed for implementing the
// reflection api. 
//
// Used by functions in the JVM interface.
//
// NOTE that in JDK 1.4 most of reflection is now implemented in Java
// using dynamic bytecode generation. The Array class has not yet been
// rewritten using bytecodes; if it were, most of the rest of this
// class could go away, as well as a few more entry points in jvm.cpp.

Sincerely,
Roman Elizarov



From jim.andreou at gmail.com  Thu Dec 25 11:45:10 2008
From: jim.andreou at gmail.com (Andreou Dimitris)
Date: Thu, 25 Dec 2008 18:45:10 +0200
Subject: [concurrency-interest] CHM, key/entry.key equality test,
	and reference maps
Message-ID: <4953B896.8050102@csd.uoc.gr>

Hi,

In CHM (as also in HashMap), when a get() occurs, the equality test 
happens like "key.equals(entry.key))". Is there any reason that forbids 
the inverse route to be taken? (This question extends to value equality 
tests too).

It seems to me that, from the correctness of CHM point of view, it 
doesn't matter. Yet, I think that if it was consistently implemented the 
other way, then anyone could built an extension that transparently 
offers any kind of indirection in keys and values (like a reference map 
does), without pushing to the reader the burden of creating keys with 
special knowledge about the indirection (i.e. no need for dummy 
objects). Instead, only the writer would define equality for wrapped 
values it creates (by delegating to the unwrapped values), letting 
readers be faster.

So, what do I miss there?

Thanks,
Dimitris Andreou

From ben_manes at yahoo.com  Tue Dec 30 05:35:58 2008
From: ben_manes at yahoo.com (Ben Manes)
Date: Tue, 30 Dec 2008 02:35:58 -0800 (PST)
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
References: <493F0EE1.4030907@cs.oswego.edu>
Message-ID: <877317.86703.qm@web38807.mail.mud.yahoo.com>

In regards to the ConcurrentReferenceHashMap, there does not seem to be a way to be notified when an entry has been evicted.  Google's ReferenceMap has a similar issue, since neither expose listeners or their reference queues, but does allow a partial work-around.  In my usage, I supply a backing map whose "remove" methods invokes an eviction listener after performing the operation.  This allows me to update the cache's statistics, as well as perform various cleanup logic (e.g. a decorator allows mapping N keys -> value, so when evicted a call-back cleans up the index keys).  This works out fairly well, with the flaw being that removal coming down the decorator call-stack would spuriously increment the statistic's eviction count.  Since my users are forced to allow the framework to handle consistency issues, they are not able to explicitly request a removal and its a non-issue.  However, many other caching frameworks do allow direct removal as well as
 attaching custom listeners for eviction, which would make it difficult to adapt either implementation.  For the decorated approach, one would probably need to use a fairly hacking method like inspecting a ThreadLocal flag to determine which route the method was invoked from.  For the proposed Java-7 version, I can't think of any approach at the moment.




________________________________
From: Doug Lea <dl at cs.oswego.edu>
To: Concurrency-interest at cs.oswego.edu
Sent: Tuesday, December 9, 2008 4:35:45 PM
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans

Concrete plans for Java7 release finally appear to be starting, and
we've been asked which JSR166 follow-ons should be slated for
inclusion. Here is the tentative list. Comments appreciated.

1. Phasers
   A generalization of various kinds of barriers.
2. LinkedTransferQueue (and TransferQueue interface)
   A generalization of nonblocking, blocking and synchronous queues
3. ConcurrentReferenceHashMap
   A concurrent hash map allowing weak, soft, etc keys and values.
4. Fences (in java.util.concurrent.atomic)
   Low-level memory fences
5. ForkJoin framework.
   (See below)

Preliminary versions of these can be found in various places.
Phasers and LinkedTransferQueues are in jsr166y at
http://gee.cs.oswego.edu/dl/concurrency-interest/index.html

The Fences API is listed at
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html
The specs need a little bit of work, and Java JVMs will need to
support it. (Any VM can support it now extremely expensively, but it
is not useful unless supported efficiently.)  Among other reasons for
including this API is to better correspond to the similar upcoming
C++0x APIs.

Jason Greene created a version of ConcurrentReferenceHashMap based on
ConcurrentHashMap. I think the most recent version is at:
http://viewvc.jboss.org/cgi-bin/viewvc.cgi/jbosscache/experimental/jsr166/src/jsr166y/ConcurrentReferenceHashMap.java?view=markup
We postponed integrating this awaiting possible GC support for
Ephemerons (a solution to  weak key-value chains), which
might drive different internals.  But I don't think Ephemeron support
is too likely to be in place soon, so we should consider incorporating
without this.

As most people know, existing ForkJoin support consists of two parts,
the base ForkJoin{Pool,Task} framework, and the parallel collections
(currently only ParallelArray) on top if it.  I'm thinking to only
recommend inclusion of the base framework into JDK, and to resume
working on parallel collections as a non-JDK package.  Doing this
sidesteps the interface explosion issue (the 96 interfaces like
IntAndLongToInt etc etc) and expressiveness issues (closures etc) that
make inclusion in JDK hard to argue for, while better motivating
development and usage of parallelCollections package over the
medium-term future, and as well as possible development of
associated IDE support, language extensions and/or other JVM languages

At the same time, I've been working on revisions of the base support
that provide full integration of FJ with the Executor framework --
ForkJoinPool will implement Executor service and ForkJoinTask will
implement Future. (The main idea making this possible is to allow
controlled blocking and spawning spare threads when necessary to
maintain parallelism.) Among the motivations is to accommodate usages
in both Fortress and X10 (which are or will be compiled to run on
JVMs) requiring this sort of capability. But it also comes into play
in constructions that people have wanted but hadn't worked, like
creating a set of looping (non-FJ-like) tasks, each of which
sometimes spawns FJ tasks.

More details will follow (getting the internal parallelism maintenance
working well is going slowly), but this invites simply adding the base
framework to java.util.concurrent proper: class ForkJoinPool (with class
ForkJoinWorkerThread still available for advanced usages and tuning)
plus abstract class ForkJoinTask, with support
for the three basic flavors via abstract subclasses RecursiveAction,
RecursiveTask, AsyncForkJoinAction (the last one revamped to enable
construction of classes like BinaryAsyncAction without needing to
provide them.)

I'll await comments and suggestions on all this before putting
it into place. (Where putting in place means initially
reorganizing package jsr166y along these lines, and later
transferring to java.util.concurrent.)

-Doug


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



      
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081230/4c76dce0/attachment.html>

From crazybob at crazybob.org  Tue Dec 30 09:27:16 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Tue, 30 Dec 2008 06:27:16 -0800
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <877317.86703.qm@web38807.mail.mud.yahoo.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<877317.86703.qm@web38807.mail.mud.yahoo.com>
Message-ID: <a74683f90812300627g6b276351o4e42f62dd577c8f2@mail.gmail.com>

I think adding eviction callbacks is beyond the scope of ReferenceMap, but
caching frameworks can use the underlying "finalizable reference" API
directly to get what you want.

This is what I'm doing in our own caching classes anyway (rather than try to
wrap ReferenceMap).

Bob

On Tue, Dec 30, 2008 at 2:35 AM, Ben Manes <ben_manes at yahoo.com> wrote:

> In regards to the ConcurrentReferenceHashMap, there does not seem to be a
> way to be notified when an entry has been evicted.  Google's ReferenceMap
> has a similar issue, since neither expose listeners or their reference
> queues, but does allow a partial work-around.  In my usage, I supply a
> backing map whose "remove" methods invokes an eviction listener after
> performing the operation.  This allows me to update the cache's statistics,
> as well as perform various cleanup logic (e.g. a decorator allows mapping N
> keys -> value, so when evicted a call-back cleans up the index keys).  This
> works out fairly well, with the flaw being that removal coming down the
> decorator call-stack would spuriously increment the statistic's eviction
> count.  Since my users are forced to allow the framework to handle
> consistency issues, they are not able to explicitly request a removal and
> its a non-issue.  However, many other caching frameworks do allow direct
> removal as well as attaching custom listeners for eviction, which would make
> it difficult to adapt either implementation.  For the decorated approach,
> one would probably need to use a fairly hacking method like inspecting a
> ThreadLocal flag to determine which route the method was invoked from.  For
> the proposed Java-7 version, I can't think of any approach at the moment.
>
> ------------------------------
> *From:* Doug Lea <dl at cs.oswego.edu>
> *To:* Concurrency-interest at cs.oswego.edu
> *Sent:* Tuesday, December 9, 2008 4:35:45 PM
> *Subject:* [concurrency-interest] RFC -- Java7 java.util.concurrent plans
>
> Concrete plans for Java7 release finally appear to be starting, and
> we've been asked which JSR166 follow-ons should be slated for
> inclusion. Here is the tentative list. Comments appreciated.
>
> 1. Phasers
>   A generalization of various kinds of barriers.
> 2. LinkedTransferQueue (and TransferQueue interface)
>   A generalization of nonblocking, blocking and synchronous queues
> 3. ConcurrentReferenceHashMap
>   A concurrent hash map allowing weak, soft, etc keys and values.
> 4. Fences (in java.util.concurrent.atomic)
>   Low-level memory fences
> 5. ForkJoin framework.
>   (See below)
>
> Preliminary versions of these can be found in various places.
> Phasers and LinkedTransferQueues are in jsr166y at
> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>
> The Fences API is listed at
>
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html
> The specs need a little bit of work, and Java JVMs will need to
> support it. (Any VM can support it now extremely expensively, but it
> is not useful unless supported efficiently.)  Among other reasons for
> including this API is to better correspond to the similar upcoming
> C++0x APIs.
>
> Jason Greene created a version of ConcurrentReferenceHashMap based on
> ConcurrentHashMap. I think the most recent version is at:
>
> http://viewvc.jboss.org/cgi-bin/viewvc.cgi/jbosscache/experimental/jsr166/src/jsr166y/ConcurrentReferenceHashMap.java?view=markup
> We postponed integrating this awaiting possible GC support for
> Ephemerons (a solution to  weak key-value chains), which
> might drive different internals.  But I don't think Ephemeron support
> is too likely to be in place soon, so we should consider incorporating
> without this.
>
> As most people know, existing ForkJoin support consists of two parts,
> the base ForkJoin{Pool,Task} framework, and the parallel collections
> (currently only ParallelArray) on top if it.  I'm thinking to only
> recommend inclusion of the base framework into JDK, and to resume
> working on parallel collections as a non-JDK package.  Doing this
> sidesteps the interface explosion issue (the 96 interfaces like
> IntAndLongToInt etc etc) and expressiveness issues (closures etc) that
> make inclusion in JDK hard to argue for, while better motivating
> development and usage of parallelCollections package over the
> medium-term future, and as well as possible development of
> associated IDE support, language extensions and/or other JVM languages
>
> At the same time, I've been working on revisions of the base support
> that provide full integration of FJ with the Executor framework --
> ForkJoinPool will implement Executor service and ForkJoinTask will
> implement Future. (The main idea making this possible is to allow
> controlled blocking and spawning spare threads when necessary to
> maintain parallelism.) Among the motivations is to accommodate usages
> in both Fortress and X10 (which are or will be compiled to run on
> JVMs) requiring this sort of capability. But it also comes into play
> in constructions that people have wanted but hadn't worked, like
> creating a set of looping (non-FJ-like) tasks, each of which
> sometimes spawns FJ tasks.
>
> More details will follow (getting the internal parallelism maintenance
> working well is going slowly), but this invites simply adding the base
> framework to java.util.concurrent proper: class ForkJoinPool (with class
> ForkJoinWorkerThread still available for advanced usages and tuning)
> plus abstract class ForkJoinTask, with support
> for the three basic flavors via abstract subclasses RecursiveAction,
> RecursiveTask, AsyncForkJoinAction (the last one revamped to enable
> construction of classes like BinaryAsyncAction without needing to
> provide them.)
>
> I'll await comments and suggestions on all this before putting
> it into place. (Where putting in place means initially
> reorganizing package jsr166y along these lines, and later
> transferring to java.util.concurrent.)
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081230/1d759395/attachment-0001.html>

From gregg at cytetech.com  Tue Dec 30 14:40:48 2008
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 30 Dec 2008 13:40:48 -0600
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
In-Reply-To: <877317.86703.qm@web38807.mail.mud.yahoo.com>
References: <493F0EE1.4030907@cs.oswego.edu>
	<877317.86703.qm@web38807.mail.mud.yahoo.com>
Message-ID: <495A7940.90806@cytetech.com>

Ben Manes wrote:
> In regards to the ConcurrentReferenceHashMap, there does not seem to be 
> a way to be notified when an entry has been evicted.

I've always kept maps and tracking in separate classes.  I use a 
PhantomReference->some-resource mapping in the attached class to manage this for 
me.  I can create an instance of this class for tracking specific types of 
resources, and then I can manage the reference tracking more granularly.

The biggest consideration in the use of this class, is that the resource to be 
released is never referenced directly (a held reference that is) in the 
application.  There is always a delegate object that holds a reference and 
everyone uses the resource object through that reference.  The resource object 
is strongly referenced by this class, and the delegating/holder object is the 
weakly referenced value.

Gregg Wonderly

=============================================================================

import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
  * This class provides a way for tracking the loss of reference of one type of
  * object to allow a secondary reference to be used to perform some cleanup
  * activity.  The most common use of this is with one object which might
  * contain or refer to another object that needs some cleanup performed
  * when the referer is no longer referenced.
  * <p>
  * An example might be an object of type Holder, which refers to or uses a
  * Socket connection.  When the reference is lost, the socket should be
  * closed.  Thus, an instance might be created as in
  * <pre>
  *	ReferenceTracker<Holder,Socket> trker = ReferenceTracker<Holder,Socket>() {
  *		public void released( Socket s ) {
  *			try {
  *				s.close();
  *			} catch( Exception ex ) {
  *				log.log( Level.SEVERE, ex.toString(), ex );
  *			}
  *		}
  *  };
  * </pre>
  * Somewhere, there might be calls such as the following.
  * <pre>
  *		interface Holder<T> {
  *			public T get();
  *		}
  *		class SocketHolder implements Holder<Socket> {
  *			Socket s;
  *			public SocketHolder( Socket sock ) {
  *				s = sock;
  *			}
  *			public Socket get() {
  *				return s;
  *			}
  *		}
  * </pre>
  * This defines an implementation of the Holder interface which holds
  * a reference to Socket objects.  The use of the <code>trker</code>
  * object, above, might then include the use of a method for creating
  * the objects and registering the references as shown below.
  * <pre>
  *	public SocketHolder connect( String host, int port ) throws IOException {
  *		Socket s = new Socket( host, port );
  *		SocketHolder h = new SocketHolder( s );
  *		trker.trackReference( h, s );
  *		return h;
  *	}
  * </pre>
  * Software wishing to use a socket connection, and pass it around would
  * use SocketHolder.get() to reference the Socket instance, in all cases.
  * then, when all SocketHolder references are dropped, the socket would
  * be closed by the <code>released(java.net.Socket)</code> method shown
  * above.
  */
public abstract class ReferenceTracker<T,K> {
	/**
	 * The thread instance that is removing entries from the reference queue, 
refqueue, as they appear.
	 */
	private volatile RefQueuePoll poll;
	/**
	 * The Logger instance used for this instance.  It will include the name as a 
suffix
	 * if that constructor is used.
	 */
	private final Logger log;
	/**
	 * The name indicating which instance this is for logging and other separation of
	 * instances needed.
	 */
	private final String which;

	/**
	 * Creates a new instance of ReferenceTracker using the passed name to 
differentiate
	 * the instance in logging and toString() implementation.
	 * @param which The name of this instance for differentiation of multiple 
instances in logging etc.
	 */
	public ReferenceTracker( String which  ) {
		this.which = which;
		log = Logger.getLogger( getClass().getName()+"."+which );
	}

	/**
	 * Creates a new instance of ReferenceTracker with no qualifying name.
	 */
	public ReferenceTracker( ) {
		this.which = null;
		log = Logger.getLogger( getClass().getName() );
	}

	/**
	 * Provides access to the name of this instance.
	 * @return The name of this instance.
	 */
	public String toString() {
		if( which == null )
			return super.toString();
		return "ReferenceTracker["+which+"]";
	}

	/**
	 * Subclasses must implement this method.  It will be called when all 
references to the
	 * associated holder object are dropped.
	 * @param val The value passed as the second argument to a corresponding call 
to {@link #trackReference(T,K)}
	 */
	public abstract void released( K val );

	/** The reference queueu for references to the holder objects */
	private final ReferenceQueue<T>refqueue = new ReferenceQueue<T>();
	/**
	 * The count of the total number of threads that have been created and then 
destroyed as entries have
	 * been tracked.  When there are zero tracked references, there is no queue 
running.
	 */
	private final AtomicInteger tcnt = new AtomicInteger();
	/**
	 * A Thread implementation that polls {@link #refqueue} to subsequently call 
{@link released(K)}
	 * as references to T objects are dropped.
	 */
	private class RefQueuePoll extends Thread {
		/**
		 * The thread number associated with this instance.  There might briefly be 
two instances of
		 * this class that exists in a volatile system.  If that is the case, this 
value will
		 * be visible in some of the logging to differentiate the active ones.
		 */
		private final int mycnt;
		/**
		 * Creates an instance of this class.
		 */
		public RefQueuePoll() {
			setDaemon( true );
			setName( getClass().getName()+": ReferenceTracker ("+which+")" );
			mycnt = tcnt.incrementAndGet();
		}
		/**
		 * This method provides all the activity of performing 
<code>refqueue.remove()</code>
		 * calls and then calling <code>released(K)</code> to let the application 
release the
		 * resources needed.
		 */
		public void run() {
			boolean done = false;
			while( !done ) {
				try {
					Reference<? extends T> ref = refqueue.remove();
					K ctl;
					synchronized( refmap ) {
						ctl = refmap.remove( ref );
						done = actCnt.decrementAndGet() == 0;
						if( log.isLoggable( Level.FINE ) )
							log.fine("current act refs="+actCnt.get());
					}
					if( log.isLoggable( Level.FINER ) )
						log.finer("reference released for: "+ref+", dep="+ctl );
					if( ctl != null ) {
						try {
							released( ctl );
							if( log.isLoggable( Level.FINE ) )
								log.fine("dependant object released: "+ctl );
						} catch( Exception ex ) {
							log.log( Level.SEVERE, ex.toString(), ex );
						}
					}
				} catch( Exception ex ) {
					log.log( Level.SEVERE, ex.toString(), ex );
				}
			}
			if( log.isLoggable( Level.FINE ) )
				log.fine("poll thread "+mycnt+" shutdown for "+this );
		}
	}

	/**
	 * A count of the active references.
	 */
	private final AtomicInteger actCnt = new AtomicInteger();
	/**
	 * Map from T References to K objects to be used for the released(K) call
	 */
	private final ConcurrentHashMap<Reference<? extends T>,K>refmap = new 
ConcurrentHashMap<Reference<? extends T>,K>();
	/**
	 *  Adds a tracked reference.  dep should not refer to ref in any way except 
possibly
	 *  a WeakReference.  dep is almost always something referred to by ref.
	 * @throw IllegalArgumentException of ref and dep are the same object.
	 * @param dep The dependent object that needs cleanup when ref is no longer 
referenced.
	 * @param ref the object whose reference is to be tracked
	 */
	public void trackReference( T ref, K dep ) {
		if( ref == dep ) {
			throw new IllegalArgumentException( "Referenced object and dependent object 
can not be the same" );
		}
		PhantomReference<T> p = new PhantomReference<T>( ref, refqueue );
		synchronized( refmap ) {
			refmap.put( p, dep );
			if( actCnt.getAndIncrement() == 0 ) {
				poll = new RefQueuePoll();
				poll.start();
				if( log.isLoggable( Level.FINE ) )
					log.fine( "poll thread #"+tcnt.get()+" created for "+this );
			}
		}
	}

	/**
	 *  This method can be called if the JVM that the tracker is in, is being
	 *  shutdown, or someother context is being shutdown and the objects tracked
	 *  by the tracker should now be released.  This method will result in
	 *  {@link #released(K)} being called for each outstanding refernce.
	 */
	public void shutdown() {
		List<K>rem;
		// Copy the values and clear the map so that released
		// is only ever called once, incase GC later evicts references
		synchronized( refmap ) {
			rem = new ArrayList<K>( refmap.values() );
			refmap.clear();
		}
		for( K dep : rem ) {
			try {
				released( dep );
			} catch( Exception ex ) {
				log.log( Level.SEVERE, ex.toString(), ex );
			}
		}
	}
}

From ben_manes at yahoo.com  Tue Dec 30 15:55:34 2008
From: ben_manes at yahoo.com (Ben Manes)
Date: Tue, 30 Dec 2008 12:55:34 -0800 (PST)
Subject: [concurrency-interest] RFC -- Java7 java.util.concurrent plans
References: <493F0EE1.4030907@cs.oswego.edu>
	<877317.86703.qm@web38807.mail.mud.yahoo.com>
	<495A7940.90806@cytetech.com>
Message-ID: <48260.6066.qm@web38807.mail.mud.yahoo.com>

Okay, both solutions are far cleaner than my quick-and-dirty approach.  I'll probably go back and clean it up the next time I get some bandwidth.  :-)

Thanks!




________________________________
From: Gregg Wonderly <gregg at cytetech.com>
To: Ben Manes <ben_manes at yahoo.com>
Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>; dholmes at ieee.org
Sent: Tuesday, December 30, 2008 11:40:48 AM
Subject: Re: [concurrency-interest] RFC -- Java7 java.util.concurrent plans

Ben Manes wrote:
> In regards to the ConcurrentReferenceHashMap, there does not seem to be a way to be notified when an entry has been evicted.

I've always kept maps and tracking in separate classes.  I use a PhantomReference->some-resource mapping in the attached class to manage this for me.  I can create an instance of this class for tracking specific types of resources, and then I can manage the reference tracking more granularly.

The biggest consideration in the use of this class, is that the resource to be released is never referenced directly (a held reference that is) in the application.  There is always a delegate object that holds a reference and everyone uses the resource object through that reference.  The resource object is strongly referenced by this class, and the delegating/holder object is the weakly referenced value.

Gregg Wonderly

=============================================================================

import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
* This class provides a way for tracking the loss of reference of one type of
* object to allow a secondary reference to be used to perform some cleanup
* activity.  The most common use of this is with one object which might
* contain or refer to another object that needs some cleanup performed
* when the referer is no longer referenced.
* <p>
* An example might be an object of type Holder, which refers to or uses a
* Socket connection.  When the reference is lost, the socket should be
* closed.  Thus, an instance might be created as in
* <pre>
*    ReferenceTracker<Holder,Socket> trker = ReferenceTracker<Holder,Socket>() {
*        public void released( Socket s ) {
*            try {
*                s.close();
*            } catch( Exception ex ) {
*                log.log( Level.SEVERE, ex.toString(), ex );
*            }
*        }
*  };
* </pre>
* Somewhere, there might be calls such as the following.
* <pre>
*        interface Holder<T> {
*            public T get();
*        }
*        class SocketHolder implements Holder<Socket> {
*            Socket s;
*            public SocketHolder( Socket sock ) {
*                s = sock;
*            }
*            public Socket get() {
*                return s;
*            }
*        }
* </pre>
* This defines an implementation of the Holder interface which holds
* a reference to Socket objects.  The use of the <code>trker</code>
* object, above, might then include the use of a method for creating
* the objects and registering the references as shown below.
* <pre>
*    public SocketHolder connect( String host, int port ) throws IOException {
*        Socket s = new Socket( host, port );
*        SocketHolder h = new SocketHolder( s );
*        trker.trackReference( h, s );
*        return h;
*    }
* </pre>
* Software wishing to use a socket connection, and pass it around would
* use SocketHolder.get() to reference the Socket instance, in all cases.
* then, when all SocketHolder references are dropped, the socket would
* be closed by the <code>released(java.net.Socket)</code> method shown
* above.
*/
public abstract class ReferenceTracker<T,K> {
    /**
     * The thread instance that is removing entries from the reference queue, refqueue, as they appear.
     */
    private volatile RefQueuePoll poll;
    /**
     * The Logger instance used for this instance.  It will include the name as a suffix
     * if that constructor is used.
     */
    private final Logger log;
    /**
     * The name indicating which instance this is for logging and other separation of
     * instances needed.
     */
    private final String which;

    /**
     * Creates a new instance of ReferenceTracker using the passed name to differentiate
     * the instance in logging and toString() implementation.
     * @param which The name of this instance for differentiation of multiple instances in logging etc.
     */
    public ReferenceTracker( String which  ) {
        this.which = which;
        log = Logger.getLogger( getClass().getName()+"."+which );
    }

    /**
     * Creates a new instance of ReferenceTracker with no qualifying name.
     */
    public ReferenceTracker( ) {
        this.which = null;
        log = Logger.getLogger( getClass().getName() );
    }

    /**
     * Provides access to the name of this instance.
     * @return The name of this instance.
     */
    public String toString() {
        if( which == null )
            return super.toString();
        return "ReferenceTracker["+which+"]";
    }

    /**
     * Subclasses must implement this method.  It will be called when all references to the
     * associated holder object are dropped.
     * @param val The value passed as the second argument to a corresponding call to {@link #trackReference(T,K)}
     */
    public abstract void released( K val );

    /** The reference queueu for references to the holder objects */
    private final ReferenceQueue<T>refqueue = new ReferenceQueue<T>();
    /**
     * The count of the total number of threads that have been created and then destroyed as entries have
     * been tracked.  When there are zero tracked references, there is no queue running.
     */
    private final AtomicInteger tcnt = new AtomicInteger();
    /**
     * A Thread implementation that polls {@link #refqueue} to subsequently call {@link released(K)}
     * as references to T objects are dropped.
     */
    private class RefQueuePoll extends Thread {
        /**
         * The thread number associated with this instance.  There might briefly be two instances of
         * this class that exists in a volatile system.  If that is the case, this value will
         * be visible in some of the logging to differentiate the active ones.
         */
        private final int mycnt;
        /**
         * Creates an instance of this class.
         */
        public RefQueuePoll() {
            setDaemon( true );
            setName( getClass().getName()+": ReferenceTracker ("+which+")" );
            mycnt = tcnt.incrementAndGet();
        }
        /**
         * This method provides all the activity of performing <code>refqueue.remove()</code>
         * calls and then calling <code>released(K)</code> to let the application release the
         * resources needed.
         */
        public void run() {
            boolean done = false;
            while( !done ) {
                try {
                    Reference<? extends T> ref = refqueue.remove();
                    K ctl;
                    synchronized( refmap ) {
                        ctl = refmap.remove( ref );
                        done = actCnt.decrementAndGet() == 0;
                        if( log.isLoggable( Level.FINE ) )
                            log.fine("current act refs="+actCnt.get());
                    }
                    if( log.isLoggable( Level.FINER ) )
                        log.finer("reference released for: "+ref+", dep="+ctl );
                    if( ctl != null ) {
                        try {
                            released( ctl );
                            if( log.isLoggable( Level.FINE ) )
                                log.fine("dependant object released: "+ctl );
                        } catch( Exception ex ) {
                            log.log( Level.SEVERE, ex.toString(), ex );
                        }
                    }
                } catch( Exception ex ) {
                    log.log( Level.SEVERE, ex.toString(), ex );
                }
            }
            if( log.isLoggable( Level.FINE ) )
                log.fine("poll thread "+mycnt+" shutdown for "+this );
        }
    }

    /**
     * A count of the active references.
     */
    private final AtomicInteger actCnt = new AtomicInteger();
    /**
     * Map from T References to K objects to be used for the released(K) call
     */
    private final ConcurrentHashMap<Reference<? extends T>,K>refmap = new ConcurrentHashMap<Reference<? extends T>,K>();
    /**
     *  Adds a tracked reference.  dep should not refer to ref in any way except possibly
     *  a WeakReference.  dep is almost always something referred to by ref.
     * @throw IllegalArgumentException of ref and dep are the same object.
     * @param dep The dependent object that needs cleanup when ref is no longer referenced.
     * @param ref the object whose reference is to be tracked
     */
    public void trackReference( T ref, K dep ) {
        if( ref == dep ) {
            throw new IllegalArgumentException( "Referenced object and dependent object can not be the same" );
        }
        PhantomReference<T> p = new PhantomReference<T>( ref, refqueue );
        synchronized( refmap ) {
            refmap.put( p, dep );
            if( actCnt.getAndIncrement() == 0 ) {
                poll = new RefQueuePoll();
                poll.start();
                if( log.isLoggable( Level.FINE ) )
                    log.fine( "poll thread #"+tcnt.get()+" created for "+this );
            }
        }
    }

    /**
     *  This method can be called if the JVM that the tracker is in, is being
     *  shutdown, or someother context is being shutdown and the objects tracked
     *  by the tracker should now be released.  This method will result in
     *  {@link #released(K)} being called for each outstanding refernce.
     */
    public void shutdown() {
        List<K>rem;
        // Copy the values and clear the map so that released
        // is only ever called once, incase GC later evicts references
        synchronized( refmap ) {
            rem = new ArrayList<K>( refmap.values() );
            refmap.clear();
        }
        for( K dep : rem ) {
            try {
                released( dep );
            } catch( Exception ex ) {
                log.log( Level.SEVERE, ex.toString(), ex );
            }
        }
    }
}



      
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20081230/a5d1a6fc/attachment-0001.html>

