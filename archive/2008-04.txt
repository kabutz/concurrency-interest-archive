From jim.andreou at gmail.com  Tue Apr  1 00:02:00 2008
From: jim.andreou at gmail.com (Dimitris Andreou)
Date: Tue, 01 Apr 2008 07:02:00 +0300
Subject: [concurrency-interest] Termination of daemon threads
Message-ID: <47F1B3B8.7020400@gmail.com>

Hi all,

Here is my question: How are daemon threads terminated? What if they are 
in the middle of a critical operation, like writing to a file? They seem 
to exit immediately. How could that be safe? Or a daemon thread should 
never do anything critical, but always delegate such work to a 
non-daemon thread? If any case, shouldn't it be documented in 
java.lang.Thread?

Thanks
Dimitris Andreou


From dcholmes at optusnet.com.au  Tue Apr  1 00:41:50 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 1 Apr 2008 14:41:50 +1000
Subject: [concurrency-interest] Termination of daemon threads
In-Reply-To: <47F1B3B8.7020400@gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEBLHLAA.dcholmes@optusnet.com.au>

A daemon thread should never do anything critical. Daemon threads just
"vanish" when the process is terminated. Though for Sun's VM they are at
least brought to a system "safe-point" first - though executing native code
is considered being at a "safe-point" ie outside of the VM.

It probably could be documented better.

David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Dimitris
> Andreou
> Sent: Tuesday, 1 April 2008 2:02 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Termination of daemon threads
>
>
> Hi all,
>
> Here is my question: How are daemon threads terminated? What if they are
> in the middle of a critical operation, like writing to a file? They seem
> to exit immediately. How could that be safe? Or a daemon thread should
> never do anything critical, but always delegate such work to a
> non-daemon thread? If any case, shouldn't it be documented in
> java.lang.Thread?
>
> Thanks
> Dimitris Andreou
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From richard.zschech at velsys.com  Tue Apr  1 02:19:59 2008
From: richard.zschech at velsys.com (Richard Zschech)
Date: Tue, 1 Apr 2008 15:49:59 +0930
Subject: [concurrency-interest] Termination of daemon threads
References: <NFBBKALFDCPFIDBNKAPCAEBLHLAA.dcholmes@optusnet.com.au>
Message-ID: <9595F39E2D27654A9184E2F7476D0F1746B3F8@velmail03.velsys.local>

Couldn't you go setDaemon(false) / setDaemon(true) around your critical
sections?

>From Richard.


-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
Holmes
Sent: Tuesday, 1 April 2008 3:12 PM
To: jim.andreou at gmail.com; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Termination of daemon threads

A daemon thread should never do anything critical. Daemon threads just
"vanish" when the process is terminated. Though for Sun's VM they are at
least brought to a system "safe-point" first - though executing native
code
is considered being at a "safe-point" ie outside of the VM.

It probably could be documented better.

David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
Dimitris
> Andreou
> Sent: Tuesday, 1 April 2008 2:02 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Termination of daemon threads
>
>
> Hi all,
>
> Here is my question: How are daemon threads terminated? What if they
are
> in the middle of a critical operation, like writing to a file? They
seem
> to exit immediately. How could that be safe? Or a daemon thread should
> never do anything critical, but always delegate such work to a
> non-daemon thread? If any case, shouldn't it be documented in
> java.lang.Thread?
>
> Thanks
> Dimitris Andreou
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

!DSPAM:1,47f1c9bc745732238521400!



From dcholmes at optusnet.com.au  Tue Apr  1 02:44:18 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 1 Apr 2008 16:44:18 +1000
Subject: [concurrency-interest] Termination of daemon threads
In-Reply-To: <9595F39E2D27654A9184E2F7476D0F1746B3F8@velmail03.velsys.local>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEBLHLAA.dcholmes@optusnet.com.au>

No, daemon status can only be modified before a thread is started.

David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Richard
> Zschech
> Sent: Tuesday, 1 April 2008 4:20 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Termination of daemon threads
> 
> 
> Couldn't you go setDaemon(false) / setDaemon(true) around your critical
> sections?
> 
> >From Richard.
> 
> 
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
> Holmes
> Sent: Tuesday, 1 April 2008 3:12 PM
> To: jim.andreou at gmail.com; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Termination of daemon threads
> 
> A daemon thread should never do anything critical. Daemon threads just
> "vanish" when the process is terminated. Though for Sun's VM they are at
> least brought to a system "safe-point" first - though executing native
> code
> is considered being at a "safe-point" ie outside of the VM.
> 
> It probably could be documented better.
> 
> David Holmes
> 
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
> Dimitris
> > Andreou
> > Sent: Tuesday, 1 April 2008 2:02 PM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: [concurrency-interest] Termination of daemon threads
> >
> >
> > Hi all,
> >
> > Here is my question: How are daemon threads terminated? What if they
> are
> > in the middle of a critical operation, like writing to a file? They
> seem
> > to exit immediately. How could that be safe? Or a daemon thread should
> > never do anything critical, but always delegate such work to a
> > non-daemon thread? If any case, shouldn't it be documented in
> > java.lang.Thread?
> >
> > Thanks
> > Dimitris Andreou
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> !DSPAM:1,47f1c9bc745732238521400!
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From forax at univ-mlv.fr  Tue Apr  1 03:04:48 2008
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Tue, 01 Apr 2008 09:04:48 +0200
Subject: [concurrency-interest] Termination of daemon threads
In-Reply-To: <9595F39E2D27654A9184E2F7476D0F1746B3F8@velmail03.velsys.local>
References: <NFBBKALFDCPFIDBNKAPCAEBLHLAA.dcholmes@optusnet.com.au>
	<9595F39E2D27654A9184E2F7476D0F1746B3F8@velmail03.velsys.local>
Message-ID: <47F1DE90.604@univ-mlv.fr>

Richard Zschech a ?crit :
> Couldn't you go setDaemon(false) / setDaemon(true) around your critical
> sections?
>   
setDeamon() can't be called after the thread starts.
http://download.java.net/jdk7/docs/api/java/lang/Thread.html#setDaemon(boolean)

R?mi
> >From Richard.
>
>
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
> Holmes
> Sent: Tuesday, 1 April 2008 3:12 PM
> To: jim.andreou at gmail.com; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Termination of daemon threads
>
> A daemon thread should never do anything critical. Daemon threads just
> "vanish" when the process is terminated. Though for Sun's VM they are at
> least brought to a system "safe-point" first - though executing native
> code
> is considered being at a "safe-point" ie outside of the VM.
>
> It probably could be documented better.
>
> David Holmes
>
>   
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
>>     
> Dimitris
>   
>> Andreou
>> Sent: Tuesday, 1 April 2008 2:02 PM
>> To: concurrency-interest at cs.oswego.edu
>> Subject: [concurrency-interest] Termination of daemon threads
>>
>>
>> Hi all,
>>
>> Here is my question: How are daemon threads terminated? What if they
>>     
> are
>   
>> in the middle of a critical operation, like writing to a file? They
>>     
> seem
>   
>> to exit immediately. How could that be safe? Or a daemon thread should
>> never do anything critical, but always delegate such work to a
>> non-daemon thread? If any case, shouldn't it be documented in
>> java.lang.Thread?
>>
>> Thanks
>> Dimitris Andreou
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at altair.cs.oswego.edu
>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>     
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> !DSPAM:1,47f1c9bc745732238521400!
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>   


From peter.kovacs.1.0rc at gmail.com  Tue Apr  1 05:43:07 2008
From: peter.kovacs.1.0rc at gmail.com (Peter Kovacs)
Date: Tue, 1 Apr 2008 11:43:07 +0200
Subject: [concurrency-interest] Termination of daemon threads
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEBLHLAA.dcholmes@optusnet.com.au>
References: <47F1B3B8.7020400@gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEBLHLAA.dcholmes@optusnet.com.au>
Message-ID: <b6e8f2e80804010243g60f1ae43n96bde9fd2900724e@mail.gmail.com>

David,

I wonder what "critical" may mean here. The process is going to be
terminated: resources are freed, memory recovered, locks released...
Nature is at work here making room for a new life... What is critical
for me (e.g. a big salary raise, dating with the handsome assistant
from the 99th floor) will not be critical after my death. In other
words: what can be critical as I am just dying.

OK, I try to put my egotism aside: may "critical" mean "something"
which other processes rely on? Should the answer then not be: a daemon
thread can do anything, just be prepared for it being abruptly
terminated? Just as if the process itself would be killed -- I assume.
So the advice goes: don't do anything critical in non-daemon threads
either, because your process may get killed. :-)

Peter

On Tue, Apr 1, 2008 at 6:41 AM, David Holmes <dcholmes at optusnet.com.au> wrote:
> A daemon thread should never do anything critical. Daemon threads just
>  "vanish" when the process is terminated. Though for Sun's VM they are at
>  least brought to a system "safe-point" first - though executing native code
>  is considered being at a "safe-point" ie outside of the VM.
>
>  It probably could be documented better.
>
>  David Holmes
>
>
>
>  > -----Original Message-----
>  > From: concurrency-interest-bounces at cs.oswego.edu
>  > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Dimitris
>  > Andreou
>  > Sent: Tuesday, 1 April 2008 2:02 PM
>  > To: concurrency-interest at cs.oswego.edu
>  > Subject: [concurrency-interest] Termination of daemon threads
>  >
>  >
>  > Hi all,
>  >
>  > Here is my question: How are daemon threads terminated? What if they are
>  > in the middle of a critical operation, like writing to a file? They seem
>  > to exit immediately. How could that be safe? Or a daemon thread should
>  > never do anything critical, but always delegate such work to a
>  > non-daemon thread? If any case, shouldn't it be documented in
>  > java.lang.Thread?
>  >
>  > Thanks
>  > Dimitris Andreou
>  >
>  > _______________________________________________
>  > Concurrency-interest mailing list
>  > Concurrency-interest at altair.cs.oswego.edu
>  > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  >
>
>  _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From matthias at mernst.org  Tue Apr  1 06:17:04 2008
From: matthias at mernst.org (Matthias Ernst)
Date: Tue, 1 Apr 2008 12:17:04 +0200
Subject: [concurrency-interest] Termination of daemon threads
In-Reply-To: <22ec15240804010029w22c990c7id3546208d0b61d8d@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEBLHLAA.dcholmes@optusnet.com.au>
	<9595F39E2D27654A9184E2F7476D0F1746B3F8@velmail03.velsys.local>
	<47F1DE90.604@univ-mlv.fr>
	<22ec15240804010029w22c990c7id3546208d0b61d8d@mail.gmail.com>
Message-ID: <22ec15240804010317i61fd2ba6iceff269977e32106@mail.gmail.com>

[Never went to the list due to wrong sender address]

On Tue, Apr 1, 2008 at 9:29 AM, Matthias Ernst <ernst.matthias at gmail.com> wrote:
> SwingWorker has to deal with this, too. It doesn't want its threadpool
>  threads to inhibit VM exit, OTOH doesn't want the VM to exit when
>  they're actually doing something! #setDaemon would have been ideal. I
>  think they solved it by using deamon threads for the pool and adding a
>  shutdown hook that calls pool#shutdown&awaitTermination.
>
>  Matthias
>
>
>
>
>  On Tue, Apr 1, 2008 at 8:04 AM, R?mi Forax <forax at univ-mlv.fr> wrote:
>  > Richard Zschech a ?crit :
>  >
>  > > Couldn't you go setDaemon(false) / setDaemon(true) around your critical
>  >  > sections?
>  >  >
>  >  setDeamon() can't be called after the thread starts.
>  >  http://download.java.net/jdk7/docs/api/java/lang/Thread.html#setDaemon(boolean)
>  >
>  >  R?mi
>  >
>  >
>  > > >From Richard.
>  >  >
>  >  >
>  >  > -----Original Message-----
>  >  > From: concurrency-interest-bounces at cs.oswego.edu
>  >  > [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
>  >  > Holmes
>  >  > Sent: Tuesday, 1 April 2008 3:12 PM
>  >  > To: jim.andreou at gmail.com; concurrency-interest at cs.oswego.edu
>  >  > Subject: Re: [concurrency-interest] Termination of daemon threads
>  >  >
>  >  > A daemon thread should never do anything critical. Daemon threads just
>  >  > "vanish" when the process is terminated. Though for Sun's VM they are at
>  >  > least brought to a system "safe-point" first - though executing native
>  >  > code
>  >  > is considered being at a "safe-point" ie outside of the VM.
>  >  >
>  >  > It probably could be documented better.
>  >  >
>  >  > David Holmes
>  >  >
>  >  >
>  >  >> -----Original Message-----
>  >  >> From: concurrency-interest-bounces at cs.oswego.edu
>  >  >> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
>  >  >>
>  >  > Dimitris
>  >  >
>  >  >> Andreou
>  >  >> Sent: Tuesday, 1 April 2008 2:02 PM
>  >  >> To: concurrency-interest at cs.oswego.edu
>  >  >> Subject: [concurrency-interest] Termination of daemon threads
>  >  >>
>  >  >>
>  >  >> Hi all,
>  >  >>
>  >  >> Here is my question: How are daemon threads terminated? What if they
>  >  >>
>  >  > are
>  >  >
>  >  >> in the middle of a critical operation, like writing to a file? They
>  >  >>
>  >  > seem
>  >  >
>  >  >> to exit immediately. How could that be safe? Or a daemon thread should
>  >  >> never do anything critical, but always delegate such work to a
>  >  >> non-daemon thread? If any case, shouldn't it be documented in
>  >  >> java.lang.Thread?
>  >  >>
>  >  >> Thanks
>  >  >> Dimitris Andreou
>  >  >>
>  >  >> _______________________________________________
>  >  >> Concurrency-interest mailing list
>  >  >> Concurrency-interest at altair.cs.oswego.edu
>  >  >> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  >  >>
>  >  >>
>  >  >
>  >  > _______________________________________________
>  >  > Concurrency-interest mailing list
>  >  > Concurrency-interest at altair.cs.oswego.edu
>  >  > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  >  >
>  >  > !DSPAM:1,47f1c9bc745732238521400!
>  >  >
>  >  >
>  >  > _______________________________________________
>  >  > Concurrency-interest mailing list
>  >  > Concurrency-interest at altair.cs.oswego.edu
>  >  > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  >  >
>  >
>  >  _______________________________________________
>  >  Concurrency-interest mailing list
>  >  Concurrency-interest at altair.cs.oswego.edu
>  >  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  >
>


From matthias at mernst.org  Tue Apr  1 06:18:56 2008
From: matthias at mernst.org (Matthias Ernst)
Date: Tue, 1 Apr 2008 12:18:56 +0200
Subject: [concurrency-interest] CHM#replace(key, null, newValue)
In-Reply-To: <22ec15240801120115r43b1826aqb40ccd3f9f674bf7@mail.gmail.com>
References: <22ec15240801120115r43b1826aqb40ccd3f9f674bf7@mail.gmail.com>
Message-ID: <22ec15240804010318hc9e6a42ta76d6cb39fd94c8@mail.gmail.com>

[Never went to the list due to wrong sender address]

On Sat, Jan 12, 2008 at 11:15 AM, Matthias Ernst
<ernst.matthias at gmail.com> wrote:
> Hi,
>
>  I found myself writing a loop to atomically update a ConcurrentHashMap
>  like this:
>
>  ConcurrentHashmap<K, V> map = ...;
>  K key = ...;
>
>  V oldValue, newValue;
>  while(!map.replace(key, oldValue=map.get(key), newValue=add(oldValue, delta)));
>
>  Unfortunately it doesn't work, if the key is not present in the map yet.
>  Instead, I have to do something like:
>
>  success =
>    (oldValue==null) ?
>      (null==chm.putIfAbsent(key, newValue)) :
>      chm.replace(key, oldValue, newValue).
>
>
>  I think it would be both intuitive and reduce cruft, if #replace could
>  call #putIfAbsent itself.
>  What do you think? Wouldn't this come up in every piece of code that
>  uses replace and an unknown set of keys?
>
>  Matthias
>

From dl at cs.oswego.edu  Tue Apr  1 07:32:20 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 01 Apr 2008 07:32:20 -0400
Subject: [concurrency-interest] This list now drops non-member posts
Message-ID: <47F21D44.1020906@cs.oswego.edu>


Matthias and others: Due to the big increase of spam sent to
this list (like most lists that have been around for years),
non-member posts are no longer held for approval and bounced,
but simply dropped.

If you post to this list but don't receive it for more
than a few hours, you might check to see if you sent it from
your subscribed address. (Click on the link below.) Note
that you can add multiple addresses, with all but one
setting the 'nomail" option, which allows posts but doesn't
send them to that address.


-Doug

From alarmnummer at gmail.com  Tue Apr  1 08:04:59 2008
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Tue, 1 Apr 2008 14:04:59 +0200
Subject: [concurrency-interest] Question about reordering and volatile
Message-ID: <1466c1d60804010504wb48c02cj4b4ac933b89d4063@mail.gmail.com>

I have a question about reorderings and volatile writes.

Reorderings and volatile writes follow the 'roach motel'  (just like
synchronized blocks) that prevents instructions from jumping over.

Allowing an instruction before a volatile write on variable x to jump
over that write, can lead to not seeing the effects of that
instruction when you do the volatile read on x.This is not allowed
according to the JMM: all changes made in thread a when it does a
volatile write on  x, are visible when thread b does a volatile read
on x. Ok.. no problem so far.

But what about instructions after the volatile write? If these were
allowed (and they are not according to the roach motel principle) to
jump in front of the volatile write of x, thread b could see these
changes as well. The results are exactly the same as the situation
that the read of x (by thread b) happens after the instruction after
the volatile write has executed (by thread a). So the letting the
instruction after the write to (volatile variable) x, in front of this
write, would not cause any havoc.

So what is the reason that instructions after the volatile write are
not allowed to jump over this volatile write?

From dhanji at gmail.com  Tue Apr  1 09:23:40 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Tue, 1 Apr 2008 18:53:40 +0530
Subject: [concurrency-interest] Question about reordering and volatile
In-Reply-To: <1466c1d60804010504wb48c02cj4b4ac933b89d4063@mail.gmail.com>
References: <1466c1d60804010504wb48c02cj4b4ac933b89d4063@mail.gmail.com>
Message-ID: <aa067ea10804010623k3b8cb89fq8526ff3591efcb92@mail.gmail.com>

On Tue, Apr 1, 2008 at 5:34 PM, Peter Veentjer <alarmnummer at gmail.com>
wrote:

> I have a question about reorderings and volatile writes.
>
> Reorderings and volatile writes follow the 'roach motel'  (just like
> synchronized blocks) that prevents instructions from jumping over.
>
> Allowing an instruction before a volatile write on variable x to jump
> over that write, can lead to not seeing the effects of that
> instruction when you do the volatile read on x.This is not allowed
> according to the JMM: all changes made in thread a when it does a
> volatile write on  x, are visible when thread b does a volatile read
> on x. Ok.. no problem so far.
>
> But what about instructions after the volatile write? If these were
> allowed (and they are not according to the roach motel principle) to
> jump in front of the volatile write of x, thread b could see these
> changes as well. The results are exactly the same as the situation
> that the read of x (by thread b) happens after the instruction after
> the volatile write has executed (by thread a). So the letting the
> instruction after the write to (volatile variable) x, in front of this
> write, would not cause any havoc.


I'm not sure I understand correctly--are you saying that volatile operations
can safely be reordered (wrt other threads) to occur prior to a given
volatile write? Won't that make it no different than a non-volatile
variable?

Or do you mean non-volatile operations (i.e. not involving a volatile
variable) can be reordered around the volatile write?

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080401/a61a8377/attachment.html 

From dhanji at gmail.com  Tue Apr  1 09:31:42 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Tue, 1 Apr 2008 19:01:42 +0530
Subject: [concurrency-interest] Termination of daemon threads
In-Reply-To: <b6e8f2e80804010243g60f1ae43n96bde9fd2900724e@mail.gmail.com>
References: <47F1B3B8.7020400@gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEBLHLAA.dcholmes@optusnet.com.au>
	<b6e8f2e80804010243g60f1ae43n96bde9fd2900724e@mail.gmail.com>
Message-ID: <aa067ea10804010631q54db7708tfd7dd722722e40e9@mail.gmail.com>

On Tue, Apr 1, 2008 at 3:13 PM, Peter Kovacs <peter.kovacs.1.0rc at gmail.com>
wrote:

> David,
>
> I wonder what "critical" may mean here. The process is going to be
> terminated: resources are freed, memory recovered, locks released...
> Nature is at work here making room for a new life... What is critical
> for me (e.g. a big salary raise, dating with the handsome assistant
> from the 99th floor) will not be critical after my death. In other
> words: what can be critical as I am just dying.
>
> OK, I try to put my egotism aside: may "critical" mean "something"
> which other processes rely on?


How about closing a file stream? Which would result in corrupt data if the
daemon thread dies?

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080401/984d85e9/attachment.html 

From alarmnummer at gmail.com  Tue Apr  1 09:56:08 2008
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Tue, 1 Apr 2008 15:56:08 +0200
Subject: [concurrency-interest] Question about reordering and volatile
In-Reply-To: <aa067ea10804010623k3b8cb89fq8526ff3591efcb92@mail.gmail.com>
References: <1466c1d60804010504wb48c02cj4b4ac933b89d4063@mail.gmail.com>
	<aa067ea10804010623k3b8cb89fq8526ff3591efcb92@mail.gmail.com>
Message-ID: <1466c1d60804010656wc66342erf79c54f757f412d@mail.gmail.com>

Sorry for my unclarity.  I mean one volatile write, and other non
special and of course non dependent operations.

so something like:

int a;
volatile int b;

void original_foo(){
    a=1;
    b=10;
}

void illegal_reordened_foo(){
    b=10;
    a=1;
}

On Tue, Apr 1, 2008 at 3:23 PM, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
>
>
>
>
> On Tue, Apr 1, 2008 at 5:34 PM, Peter Veentjer <alarmnummer at gmail.com>
> wrote:
> > I have a question about reorderings and volatile writes.
> >
> > Reorderings and volatile writes follow the 'roach motel'  (just like
> > synchronized blocks) that prevents instructions from jumping over.
> >
> > Allowing an instruction before a volatile write on variable x to jump
> > over that write, can lead to not seeing the effects of that
> > instruction when you do the volatile read on x.This is not allowed
> > according to the JMM: all changes made in thread a when it does a
> > volatile write on  x, are visible when thread b does a volatile read
> > on x. Ok.. no problem so far.
> >
> > But what about instructions after the volatile write? If these were
> > allowed (and they are not according to the roach motel principle) to
> > jump in front of the volatile write of x, thread b could see these
> > changes as well. The results are exactly the same as the situation
> > that the read of x (by thread b) happens after the instruction after
> > the volatile write has executed (by thread a). So the letting the
> > instruction after the write to (volatile variable) x, in front of this
> > write, would not cause any havoc.
>
> I'm not sure I understand correctly--are you saying that volatile operations
> can safely be reordered (wrt other threads) to occur prior to a given
> volatile write? Won't that make it no different than a non-volatile
> variable?
>
> Or do you mean non-volatile operations (i.e. not involving a volatile
> variable) can be reordered around the volatile write?
>
> Dhanji.

From crazybob at crazybob.org  Tue Apr  1 10:19:48 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Tue, 1 Apr 2008 07:19:48 -0700
Subject: [concurrency-interest] CHM#replace(key, null, newValue)
In-Reply-To: <22ec15240804010318hc9e6a42ta76d6cb39fd94c8@mail.gmail.com>
References: <22ec15240801120115r43b1826aqb40ccd3f9f674bf7@mail.gmail.com>
	<22ec15240804010318hc9e6a42ta76d6cb39fd94c8@mail.gmail.com>
Message-ID: <a74683f90804010719i2453604i882fd72112ffb080@mail.gmail.com>

It's part of an interface (ConcurrentMap). You can't really break
backward compatibility.

You could write a static utility method:

  /** Repeatedly calls replace or putIfAbsent... */
  static <K, V> void replaceOrPut(ConcurrentMap<K, V> m, K key, V
oldValue, V newValue) { ... }

Bob

On Tue, Apr 1, 2008 at 3:18 AM, Matthias Ernst <matthias at mernst.org> wrote:
> [Never went to the list due to wrong sender address]
>
>  On Sat, Jan 12, 2008 at 11:15 AM, Matthias Ernst
>  <ernst.matthias at gmail.com> wrote:
>  > Hi,
>  >
>  >  I found myself writing a loop to atomically update a ConcurrentHashMap
>  >  like this:
>  >
>  >  ConcurrentHashmap<K, V> map = ...;
>  >  K key = ...;
>  >
>  >  V oldValue, newValue;
>  >  while(!map.replace(key, oldValue=map.get(key), newValue=add(oldValue, delta)));
>  >
>  >  Unfortunately it doesn't work, if the key is not present in the map yet.
>  >  Instead, I have to do something like:
>  >
>  >  success =
>  >    (oldValue==null) ?
>  >      (null==chm.putIfAbsent(key, newValue)) :
>  >      chm.replace(key, oldValue, newValue).
>  >
>  >
>  >  I think it would be both intuitive and reduce cruft, if #replace could
>  >  call #putIfAbsent itself.
>  >  What do you think? Wouldn't this come up in every piece of code that
>  >  uses replace and an unknown set of keys?
>  >
>  >  Matthias
>  >
>  _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From matthias at mernst.org  Tue Apr  1 10:45:35 2008
From: matthias at mernst.org (Matthias Ernst)
Date: Tue, 1 Apr 2008 16:45:35 +0200
Subject: [concurrency-interest] CHM#replace(key, null, newValue)
In-Reply-To: <a74683f90804010719i2453604i882fd72112ffb080@mail.gmail.com>
References: <22ec15240801120115r43b1826aqb40ccd3f9f674bf7@mail.gmail.com>
	<22ec15240804010318hc9e6a42ta76d6cb39fd94c8@mail.gmail.com>
	<a74683f90804010719i2453604i882fd72112ffb080@mail.gmail.com>
Message-ID: <22ec15240804010745v22651342o1c007151587de13@mail.gmail.com>

On Tue, Apr 1, 2008 at 4:19 PM, Bob Lee <crazybob at crazybob.org> wrote:
> It's part of an interface (ConcurrentMap). You can't really break
>  backward compatibility.

I guess you're right. I was just wondering whether that interface was
specified in an unfortunate manner or whether I'm missing something.
That if-statement is boilerplate everyone trying to update a CHM will
have to write.

>
>  You could write a static utility method:

in commons-helpers?

>
>   /** Repeatedly calls replace or putIfAbsent... */
>   static <K, V> void replaceOrPut(ConcurrentMap<K, V> m, K key, V
>  oldValue, V newValue) { ... }

Rather boolean replaceOrPut(ConcurrentMap<K, V> m, K key, V oldValue,
V newValue) { ... }

The full monty would require a closure:
>   static <K, V> void replaceOrPut(ConcurrentMap<K, V> m, K key, {V=>V} updateFunction)


Matthias


>
>  On Tue, Apr 1, 2008 at 3:18 AM, Matthias Ernst <matthias at mernst.org> wrote:
>  > [Never went to the list due to wrong sender address]
>  >
>  >  On Sat, Jan 12, 2008 at 11:15 AM, Matthias Ernst
>  >  <ernst.matthias at gmail.com> wrote:
>  >  > Hi,
>  >  >
>  >  >  I found myself writing a loop to atomically update a ConcurrentHashMap
>  >  >  like this:
>  >  >
>  >  >  ConcurrentHashmap<K, V> map = ...;
>  >  >  K key = ...;
>  >  >
>  >  >  V oldValue, newValue;
>  >  >  while(!map.replace(key, oldValue=map.get(key), newValue=add(oldValue, delta)));
>  >  >
>  >  >  Unfortunately it doesn't work, if the key is not present in the map yet.
>  >  >  Instead, I have to do something like:
>  >  >
>  >  >  success =
>  >  >    (oldValue==null) ?
>  >  >      (null==chm.putIfAbsent(key, newValue)) :
>  >  >      chm.replace(key, oldValue, newValue).
>  >  >
>  >  >
>  >  >  I think it would be both intuitive and reduce cruft, if #replace could
>  >  >  call #putIfAbsent itself.
>  >  >  What do you think? Wouldn't this come up in every piece of code that
>  >  >  uses replace and an unknown set of keys?
>  >  >
>  >  >  Matthias
>  >  >
>  >  _______________________________________________
>  >  Concurrency-interest mailing list
>  >  Concurrency-interest at altair.cs.oswego.edu
>  >  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  >
>

From peter.kovacs.1.0rc at gmail.com  Tue Apr  1 10:56:51 2008
From: peter.kovacs.1.0rc at gmail.com (Peter Kovacs)
Date: Tue, 1 Apr 2008 16:56:51 +0200
Subject: [concurrency-interest] Termination of daemon threads
In-Reply-To: <aa067ea10804010631q54db7708tfd7dd722722e40e9@mail.gmail.com>
References: <47F1B3B8.7020400@gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEBLHLAA.dcholmes@optusnet.com.au>
	<b6e8f2e80804010243g60f1ae43n96bde9fd2900724e@mail.gmail.com>
	<aa067ea10804010631q54db7708tfd7dd722722e40e9@mail.gmail.com>
Message-ID: <b6e8f2e80804010756j7f740552we8d9b195f3a29004@mail.gmail.com>

I see. If the data that is left in a corrupt state is critical, then
this is something critical. That is plausible.

What I am still not sure about is that you can categorically make the
statement: one shouldn't do critical things in a daemon thread just
because it will "vanish" at some point in time. Again: the entire
process will end at some point in time. That is no reason for avoiding
doing critical things in a Java program in general.

On Tue, Apr 1, 2008 at 3:31 PM, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
>
>
>
> On Tue, Apr 1, 2008 at 3:13 PM, Peter Kovacs <peter.kovacs.1.0rc at gmail.com>
> wrote:
> > David,
> >
> > I wonder what "critical" may mean here. The process is going to be
> > terminated: resources are freed, memory recovered, locks released...
> > Nature is at work here making room for a new life... What is critical
> > for me (e.g. a big salary raise, dating with the handsome assistant
> > from the 99th floor) will not be critical after my death. In other
> > words: what can be critical as I am just dying.
> >
> > OK, I try to put my egotism aside: may "critical" mean "something"
> > which other processes rely on?
>
> How about closing a file stream? Which would result in corrupt data if the
> daemon thread dies?
>
> Dhanji.

From alarmnummer at gmail.com  Tue Apr  1 11:14:00 2008
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Tue, 1 Apr 2008 17:14:00 +0200
Subject: [concurrency-interest] CHM#replace(key, null, newValue)
In-Reply-To: <22ec15240804010745v22651342o1c007151587de13@mail.gmail.com>
References: <22ec15240801120115r43b1826aqb40ccd3f9f674bf7@mail.gmail.com>
	<22ec15240804010318hc9e6a42ta76d6cb39fd94c8@mail.gmail.com>
	<a74683f90804010719i2453604i882fd72112ffb080@mail.gmail.com>
	<22ec15240804010745v22651342o1c007151587de13@mail.gmail.com>
Message-ID: <1466c1d60804010814v129fe829teacd3ec532c47c09@mail.gmail.com>

It is a shame that the value to be placed in the hashmap can't be
created lazy. At the moment you always need to create an object.
Passing a factory just for this purpose could in some cases be a
better performing alternative to eager creation.

On Tue, Apr 1, 2008 at 4:45 PM, Matthias Ernst <matthias at mernst.org> wrote:
> On Tue, Apr 1, 2008 at 4:19 PM, Bob Lee <crazybob at crazybob.org> wrote:
>  > It's part of an interface (ConcurrentMap). You can't really break
>  >  backward compatibility.
>
>  I guess you're right. I was just wondering whether that interface was
>  specified in an unfortunate manner or whether I'm missing something.
>  That if-statement is boilerplate everyone trying to update a CHM will
>  have to write.
>
>
>  >
>  >  You could write a static utility method:
>
>  in commons-helpers?
>
>
>  >
>  >   /** Repeatedly calls replace or putIfAbsent... */
>  >   static <K, V> void replaceOrPut(ConcurrentMap<K, V> m, K key, V
>  >  oldValue, V newValue) { ... }
>
>  Rather boolean replaceOrPut(ConcurrentMap<K, V> m, K key, V oldValue,
>  V newValue) { ... }
>
>  The full monty would require a closure:
>  >   static <K, V> void replaceOrPut(ConcurrentMap<K, V> m, K key, {V=>V} updateFunction)
>
>
>  Matthias
>
>
>
>
>  >
>  >  On Tue, Apr 1, 2008 at 3:18 AM, Matthias Ernst <matthias at mernst.org> wrote:
>  >  > [Never went to the list due to wrong sender address]
>  >  >
>  >  >  On Sat, Jan 12, 2008 at 11:15 AM, Matthias Ernst
>  >  >  <ernst.matthias at gmail.com> wrote:
>  >  >  > Hi,
>  >  >  >
>  >  >  >  I found myself writing a loop to atomically update a ConcurrentHashMap
>  >  >  >  like this:
>  >  >  >
>  >  >  >  ConcurrentHashmap<K, V> map = ...;
>  >  >  >  K key = ...;
>  >  >  >
>  >  >  >  V oldValue, newValue;
>  >  >  >  while(!map.replace(key, oldValue=map.get(key), newValue=add(oldValue, delta)));
>  >  >  >
>  >  >  >  Unfortunately it doesn't work, if the key is not present in the map yet.
>  >  >  >  Instead, I have to do something like:
>  >  >  >
>  >  >  >  success =
>  >  >  >    (oldValue==null) ?
>  >  >  >      (null==chm.putIfAbsent(key, newValue)) :
>  >  >  >      chm.replace(key, oldValue, newValue).
>  >  >  >
>  >  >  >
>  >  >  >  I think it would be both intuitive and reduce cruft, if #replace could
>  >  >  >  call #putIfAbsent itself.
>  >  >  >  What do you think? Wouldn't this come up in every piece of code that
>  >  >  >  uses replace and an unknown set of keys?
>  >  >  >
>  >  >  >  Matthias
>  >  >  >
>  >  >  _______________________________________________
>  >  >  Concurrency-interest mailing list
>  >  >  Concurrency-interest at altair.cs.oswego.edu
>  >  >  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  >  >
>  >
>  _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From alarmnummer at gmail.com  Tue Apr  1 11:22:05 2008
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Tue, 1 Apr 2008 17:22:05 +0200
Subject: [concurrency-interest] CHM#replace(key, null, newValue)
In-Reply-To: <1466c1d60804010814v129fe829teacd3ec532c47c09@mail.gmail.com>
References: <22ec15240801120115r43b1826aqb40ccd3f9f674bf7@mail.gmail.com>
	<22ec15240804010318hc9e6a42ta76d6cb39fd94c8@mail.gmail.com>
	<a74683f90804010719i2453604i882fd72112ffb080@mail.gmail.com>
	<22ec15240804010745v22651342o1c007151587de13@mail.gmail.com>
	<1466c1d60804010814v129fe829teacd3ec532c47c09@mail.gmail.com>
Message-ID: <1466c1d60804010822l568d0109y3ef5fb26661b0b3b@mail.gmail.com>

My comment was about this method:

http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html#putIfAbsent(K,%20V)

So it could be that I'm starting a completely different discussion here ;)

On Tue, Apr 1, 2008 at 5:14 PM, Peter Veentjer <alarmnummer at gmail.com> wrote:
> It is a shame that the value to be placed in the hashmap can't be
>  created lazy. At the moment you always need to create an object.
>  Passing a factory just for this purpose could in some cases be a
>  better performing alternative to eager creation.
>
>
>
>  On Tue, Apr 1, 2008 at 4:45 PM, Matthias Ernst <matthias at mernst.org> wrote:
>  > On Tue, Apr 1, 2008 at 4:19 PM, Bob Lee <crazybob at crazybob.org> wrote:
>  >  > It's part of an interface (ConcurrentMap). You can't really break
>  >  >  backward compatibility.
>  >
>  >  I guess you're right. I was just wondering whether that interface was
>  >  specified in an unfortunate manner or whether I'm missing something.
>  >  That if-statement is boilerplate everyone trying to update a CHM will
>  >  have to write.
>  >
>  >
>  >  >
>  >  >  You could write a static utility method:
>  >
>  >  in commons-helpers?
>  >
>  >
>  >  >
>  >  >   /** Repeatedly calls replace or putIfAbsent... */
>  >  >   static <K, V> void replaceOrPut(ConcurrentMap<K, V> m, K key, V
>  >  >  oldValue, V newValue) { ... }
>  >
>  >  Rather boolean replaceOrPut(ConcurrentMap<K, V> m, K key, V oldValue,
>  >  V newValue) { ... }
>  >
>  >  The full monty would require a closure:
>  >  >   static <K, V> void replaceOrPut(ConcurrentMap<K, V> m, K key, {V=>V} updateFunction)
>  >
>  >
>  >  Matthias
>  >
>  >
>  >
>  >
>  >  >
>  >  >  On Tue, Apr 1, 2008 at 3:18 AM, Matthias Ernst <matthias at mernst.org> wrote:
>  >  >  > [Never went to the list due to wrong sender address]
>  >  >  >
>  >  >  >  On Sat, Jan 12, 2008 at 11:15 AM, Matthias Ernst
>  >  >  >  <ernst.matthias at gmail.com> wrote:
>  >  >  >  > Hi,
>  >  >  >  >
>  >  >  >  >  I found myself writing a loop to atomically update a ConcurrentHashMap
>  >  >  >  >  like this:
>  >  >  >  >
>  >  >  >  >  ConcurrentHashmap<K, V> map = ...;
>  >  >  >  >  K key = ...;
>  >  >  >  >
>  >  >  >  >  V oldValue, newValue;
>  >  >  >  >  while(!map.replace(key, oldValue=map.get(key), newValue=add(oldValue, delta)));
>  >  >  >  >
>  >  >  >  >  Unfortunately it doesn't work, if the key is not present in the map yet.
>  >  >  >  >  Instead, I have to do something like:
>  >  >  >  >
>  >  >  >  >  success =
>  >  >  >  >    (oldValue==null) ?
>  >  >  >  >      (null==chm.putIfAbsent(key, newValue)) :
>  >  >  >  >      chm.replace(key, oldValue, newValue).
>  >  >  >  >
>  >  >  >  >
>  >  >  >  >  I think it would be both intuitive and reduce cruft, if #replace could
>  >  >  >  >  call #putIfAbsent itself.
>  >  >  >  >  What do you think? Wouldn't this come up in every piece of code that
>  >  >  >  >  uses replace and an unknown set of keys?
>  >  >  >  >
>  >  >  >  >  Matthias
>  >  >  >  >
>  >  >  >  _______________________________________________
>  >  >  >  Concurrency-interest mailing list
>  >  >  >  Concurrency-interest at altair.cs.oswego.edu
>  >  >  >  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  >  >  >
>  >  >
>  >  _______________________________________________
>  >  Concurrency-interest mailing list
>  >  Concurrency-interest at altair.cs.oswego.edu
>  >  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  >
>

From jmanson at cs.umd.edu  Tue Apr  1 17:06:25 2008
From: jmanson at cs.umd.edu (Jeremy Manson)
Date: Tue, 01 Apr 2008 14:06:25 -0700
Subject: [concurrency-interest] Question about reordering and volatile
In-Reply-To: <1466c1d60804010504wb48c02cj4b4ac933b89d4063@mail.gmail.com>
References: <1466c1d60804010504wb48c02cj4b4ac933b89d4063@mail.gmail.com>
Message-ID: <47F2A3D1.3000200@cs.umd.edu>

"Roach Motel" applies to synchronized blocks -- instructions can move 
into them, but not out.  So, normal accesses can be moved from after a 
monitorexit to before it, and from before a monitorenter to after it. 
That's the roach motel principle.

The same reasoning applies to volatiles under the assumption that a 
volatile write is "the same" as a monitorexit and that a volatile read 
is "the same" as a monitorenter.

So, your answer is that you *can* move normal accesses that occur after 
a volatile write to before it.

					Jeremy

Peter Veentjer wrote:
> I have a question about reorderings and volatile writes.
> 
> Reorderings and volatile writes follow the 'roach motel'  (just like
> synchronized blocks) that prevents instructions from jumping over.
> 
> Allowing an instruction before a volatile write on variable x to jump
> over that write, can lead to not seeing the effects of that
> instruction when you do the volatile read on x.This is not allowed
> according to the JMM: all changes made in thread a when it does a
> volatile write on  x, are visible when thread b does a volatile read
> on x. Ok.. no problem so far.
> 
> But what about instructions after the volatile write? If these were
> allowed (and they are not according to the roach motel principle) to
> jump in front of the volatile write of x, thread b could see these
> changes as well. The results are exactly the same as the situation
> that the read of x (by thread b) happens after the instruction after
> the volatile write has executed (by thread a). So the letting the
> instruction after the write to (volatile variable) x, in front of this
> write, would not cause any havoc.
> 
> So what is the reason that instructions after the volatile write are
> not allowed to jump over this volatile write?
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From joe.bowbeer at gmail.com  Tue Apr  1 18:23:29 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 1 Apr 2008 15:23:29 -0700
Subject: [concurrency-interest] Question about reordering and volatile
In-Reply-To: <47F2A3D1.3000200@cs.umd.edu>
References: <1466c1d60804010504wb48c02cj4b4ac933b89d4063@mail.gmail.com>
	<47F2A3D1.3000200@cs.umd.edu>
Message-ID: <31f2a7bd0804011523i3547ac23v3bb5de4602fefd8e@mail.gmail.com>

On Tue, Apr 1, 2008 at 2:06 PM, Jeremy Manson wrote:

> "Roach Motel" applies to synchronized blocks -- instructions can move
> into them, but not out.  So, normal accesses can be moved from after a
> monitorexit to before it, and from before a monitorenter to after it.
> That's the roach motel principle.
>
> The same reasoning applies to volatiles under the assumption that a
> volatile write is "the same" as a monitorexit and that a volatile read
> is "the same" as a monitorenter.
>
> So, your answer is that you *can* move normal accesses that occur after
> a volatile write to before it.
>
>
Jeremy,

Is it wrong or misleading for the FAQ to say:

"Under the new memory model, accesses to volatile variables cannot be
reordered with each other or nonvolatile variable accesses."

  http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile

I'd interpret that to mean that nothing can jump over a volatile access in
either direction...

By the way, the FAQ does later clarify that without a matching read, the
volatile write doesn't happen-before anything, which suggests that unread
volatile writes can be elided.

--Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080401/7ab63c06/attachment.html 

From jmanson at cs.umd.edu  Tue Apr  1 18:37:50 2008
From: jmanson at cs.umd.edu (Jeremy Manson)
Date: Tue, 01 Apr 2008 15:37:50 -0700
Subject: [concurrency-interest] Question about reordering and volatile
In-Reply-To: <31f2a7bd0804011523i3547ac23v3bb5de4602fefd8e@mail.gmail.com>
References: <1466c1d60804010504wb48c02cj4b4ac933b89d4063@mail.gmail.com>	<47F2A3D1.3000200@cs.umd.edu>
	<31f2a7bd0804011523i3547ac23v3bb5de4602fefd8e@mail.gmail.com>
Message-ID: <47F2B93E.8030605@cs.umd.edu>

Joe Bowbeer wrote:
> Jeremy,
> 
> Is it wrong or misleading for the FAQ to say:
> 
> "Under the new memory model, accesses to volatile variables cannot be 
> reordered with each other or nonvolatile variable accesses."
> 
>   http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile
> 
> I'd interpret that to mean that nothing can jump over a volatile access 
> in either direction...
> 
> By the way, the FAQ does later clarify that without a matching read, the 
> volatile write doesn't happen-before anything, which suggests that 
> unread volatile writes can be elided.

Let's go with "misleading" FTW.  That sentence was more intended to draw 
a contrast with the way things used to be.  The following sentence is 
the more accurate one.

I'll fix it.

					Jeremy

From sv_madhuraj at yahoo.com  Tue Apr  1 19:08:00 2008
From: sv_madhuraj at yahoo.com (Madhu Soudathikar)
Date: Tue, 1 Apr 2008 16:08:00 -0700 (PDT)
Subject: [concurrency-interest] unsubscribe me from this mail group
Message-ID: <404019.3700.qm@web33401.mail.mud.yahoo.com>




      ____________________________________________________________________________________
You rock. That's why Blockbuster's offering you one month of Blockbuster Total Access, No Cost.  
http://tc.deals.yahoo.com/tc/blockbuster/text5.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080401/6f8cbbbf/attachment.html 

From dcholmes at optusnet.com.au  Tue Apr  1 20:41:48 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 2 Apr 2008 10:41:48 +1000
Subject: [concurrency-interest] Termination of daemon threads
In-Reply-To: <b6e8f2e80804010243g60f1ae43n96bde9fd2900724e@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCECAHLAA.dcholmes@optusnet.com.au>

Peter,

"critical" in this context means "anything you'd be upset about if it didn't
get done" - which implies it's something visible outside the current
incarnation of the VM, such as writing a log file, updating a database, ...

If you create a daemon thread then you need to be prepared for it being
abruptly terminated when your application ends (by which I mean voluntarily
not by being killed externally :) )

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> Kovacs
> Sent: Tuesday, 1 April 2008 7:43 PM
> To: dholmes at ieee.org
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Termination of daemon threads
>
>
> David,
>
> I wonder what "critical" may mean here. The process is going to be
> terminated: resources are freed, memory recovered, locks released...
> Nature is at work here making room for a new life... What is critical
> for me (e.g. a big salary raise, dating with the handsome assistant
> from the 99th floor) will not be critical after my death. In other
> words: what can be critical as I am just dying.
>
> OK, I try to put my egotism aside: may "critical" mean "something"
> which other processes rely on? Should the answer then not be: a daemon
> thread can do anything, just be prepared for it being abruptly
> terminated? Just as if the process itself would be killed -- I assume.
> So the advice goes: don't do anything critical in non-daemon threads
> either, because your process may get killed. :-)
>
> Peter
>
> On Tue, Apr 1, 2008 at 6:41 AM, David Holmes
> <dcholmes at optusnet.com.au> wrote:
> > A daemon thread should never do anything critical. Daemon threads just
> >  "vanish" when the process is terminated. Though for Sun's VM
> they are at
> >  least brought to a system "safe-point" first - though
> executing native code
> >  is considered being at a "safe-point" ie outside of the VM.
> >
> >  It probably could be documented better.
> >
> >  David Holmes
> >
> >
> >
> >  > -----Original Message-----
> >  > From: concurrency-interest-bounces at cs.oswego.edu
> >  > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
> Of Dimitris
> >  > Andreou
> >  > Sent: Tuesday, 1 April 2008 2:02 PM
> >  > To: concurrency-interest at cs.oswego.edu
> >  > Subject: [concurrency-interest] Termination of daemon threads
> >  >
> >  >
> >  > Hi all,
> >  >
> >  > Here is my question: How are daemon threads terminated? What
> if they are
> >  > in the middle of a critical operation, like writing to a
> file? They seem
> >  > to exit immediately. How could that be safe? Or a daemon
> thread should
> >  > never do anything critical, but always delegate such work to a
> >  > non-daemon thread? If any case, shouldn't it be documented in
> >  > java.lang.Thread?
> >  >
> >  > Thanks
> >  > Dimitris Andreou
> >  >
> >  > _______________________________________________
> >  > Concurrency-interest mailing list
> >  > Concurrency-interest at altair.cs.oswego.edu
> >  > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >  >
> >
> >  _______________________________________________
> >  Concurrency-interest mailing list
> >  Concurrency-interest at altair.cs.oswego.edu
> >  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From serwei at gmail.com  Wed Apr  2 04:42:51 2008
From: serwei at gmail.com (serwei)
Date: Wed, 2 Apr 2008 16:42:51 +0800
Subject: [concurrency-interest] backport: ConcurrentModificationException
	with take() and contains()?
Message-ID: <fdda32c0804020142j649ef636y3c7a4d5a3494015b@mail.gmail.com>

Hi there,

is it a confirmed scenario where a ConcurrentModificationException
will happen when a DelayQueue.contains() is running and a
DelayQueue.take() happens then?

So I have to manually synchronized (something) for the two?

Thanks!

PS: stack below

java.util.ConcurrentModificationException
        at edu.emory.mathcs.backport.java.util.PriorityQueue$Itr.checkForComodification(PriorityQueue.java(Inlined
Compiled Code))
        at edu.emory.mathcs.backport.java.util.PriorityQueue$Itr.next(PriorityQueue.java(Compiled
Code))
        at edu.emory.mathcs.backport.java.util.concurrent.DelayQueue$Itr.next(DelayQueue.java(Compiled
Code))
        at java.util.AbstractCollection.contains(AbstractCollection.java(Compiled
Code))

From dhanji at gmail.com  Wed Apr  2 08:12:26 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Wed, 2 Apr 2008 17:42:26 +0530
Subject: [concurrency-interest] CHM#replace(key, null, newValue)
In-Reply-To: <1466c1d60804010814v129fe829teacd3ec532c47c09@mail.gmail.com>
References: <22ec15240801120115r43b1826aqb40ccd3f9f674bf7@mail.gmail.com>
	<22ec15240804010318hc9e6a42ta76d6cb39fd94c8@mail.gmail.com>
	<a74683f90804010719i2453604i882fd72112ffb080@mail.gmail.com>
	<22ec15240804010745v22651342o1c007151587de13@mail.gmail.com>
	<1466c1d60804010814v129fe829teacd3ec532c47c09@mail.gmail.com>
Message-ID: <aa067ea10804020512w4c18007fq770a522e4b558930@mail.gmail.com>

On Tue, Apr 1, 2008 at 8:44 PM, Peter Veentjer <alarmnummer at gmail.com>
wrote:

> It is a shame that the value to be placed in the hashmap can't be
> created lazy.


You could use a Future<T>. I think there was a thread some time ago
discussing this (about a CHM.putIfAbsent(Callable)). The Future<T> was
crazybob's idea on that thread.

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080402/d7578df1/attachment.html 

From tim at peierls.net  Wed Apr  2 08:55:43 2008
From: tim at peierls.net (Tim Peierls)
Date: Wed, 2 Apr 2008 08:55:43 -0400
Subject: [concurrency-interest] CHM#replace(key, null, newValue)
In-Reply-To: <aa067ea10804020512w4c18007fq770a522e4b558930@mail.gmail.com>
References: <22ec15240801120115r43b1826aqb40ccd3f9f674bf7@mail.gmail.com>
	<22ec15240804010318hc9e6a42ta76d6cb39fd94c8@mail.gmail.com>
	<a74683f90804010719i2453604i882fd72112ffb080@mail.gmail.com>
	<22ec15240804010745v22651342o1c007151587de13@mail.gmail.com>
	<1466c1d60804010814v129fe829teacd3ec532c47c09@mail.gmail.com>
	<aa067ea10804020512w4c18007fq770a522e4b558930@mail.gmail.com>
Message-ID: <63b4e4050804020555tbff707ne439fd9256f363bb@mail.gmail.com>

Maybe it's time to recycle Doug Lea's post on lazy initialization of map
values one more time. I've posted it on the Java Concurrency Wiki:

http://artisans-serverintellect-com.si-eioswww6.com/default.asp?W122

--tim

On Wed, Apr 2, 2008 at 8:12 AM, Dhanji R. Prasanna <dhanji at gmail.com> wrote:

>
>
> On Tue, Apr 1, 2008 at 8:44 PM, Peter Veentjer <alarmnummer at gmail.com>
> wrote:
>
> > It is a shame that the value to be placed in the hashmap can't be
> > created lazy.
>
>
> You could use a Future<T>. I think there was a thread some time ago
> discussing this (about a CHM.putIfAbsent(Callable)). The Future<T> was
> crazybob's idea on that thread.
>
> Dhanji.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080402/51edd555/attachment.html 

From holger at wizards.de  Wed Apr  2 09:32:56 2008
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Wed, 02 Apr 2008 15:32:56 +0200
Subject: [concurrency-interest] backport:
 ConcurrentModificationException with take() and contains()?
In-Reply-To: <fdda32c0804020142j649ef636y3c7a4d5a3494015b@mail.gmail.com>
References: <fdda32c0804020142j649ef636y3c7a4d5a3494015b@mail.gmail.com>
Message-ID: <47F38B08.9010303@wizards.de>

serwei wrote:
> is it a confirmed scenario where a ConcurrentModificationException
> will happen when a DelayQueue.contains() is running and a
> DelayQueue.take() happens then?

That seems wrong. Which version of the backport are you using? Looks like 
an older version. I ask because..

> So I have to manually synchronized (something) for the two?
> 
> Thanks!
> 
> PS: stack below
> 
> java.util.ConcurrentModificationException
>         at edu.emory.mathcs.backport.java.util.PriorityQueue$Itr.checkForComodification(PriorityQueue.java(Inlined
> Compiled Code))
>         at edu.emory.mathcs.backport.java.util.PriorityQueue$Itr.next(PriorityQueue.java(Compiled
> Code))
>         at edu.emory.mathcs.backport.java.util.concurrent.DelayQueue$Itr.next(DelayQueue.java(Compiled
> Code))
>         at java.util.AbstractCollection.contains(AbstractCollection.java(Compiled
> Code))

..looking at this stack trace it seems that the DelayQueue Iterator 
directly accesses the internal PriorityQueue without locking, however that 
is not what's happening in JDK6 or the latest backport (3.1), where the 
inherited contains() iterates over an unshared array snapshot.

Ah yes - this is the old (exception-throwing aka non-concurrent) behaviour 
in JDK5 as implemented by backport 2.x. So the easiest way to fix your 
problem is simply using the latest backport lib. That's a good idea anyway. :)

Holger

From gregg at cytetech.com  Wed Apr  2 13:20:24 2008
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 02 Apr 2008 12:20:24 -0500
Subject: [concurrency-interest] Termination of daemon threads
In-Reply-To: <b6e8f2e80804010243g60f1ae43n96bde9fd2900724e@mail.gmail.com>
References: <47F1B3B8.7020400@gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEBLHLAA.dcholmes@optusnet.com.au>
	<b6e8f2e80804010243g60f1ae43n96bde9fd2900724e@mail.gmail.com>
Message-ID: <47F3C058.8060207@cytetech.com>

Peter Kovacs wrote:
> OK, I try to put my egotism aside: may "critical" mean "something"
> which other processes rely on? Should the answer then not be: a daemon
> thread can do anything, just be prepared for it being abruptly
> terminated? Just as if the process itself would be killed -- I assume.
> So the advice goes: don't do anything critical in non-daemon threads
> either, because your process may get killed. :-)

I think it's a little bit naive to believe that anything that you software is 
doing will always complete successfully.  Stuff Happens!  A daemon thread should 
be used to do things that are not about the lifecycle of the system.  The 
lifecycle related operations should be done with non-daemon threads.  In the 
end, if you need something to happen atomically, you need transactional behavior 
that accounts for aborts of any type in the middle of the operation.  So, for 
example, if you have something like

synchronized( foo ) {
	val1 = foo.get( foo.lastIndex() ).theValue();
	val2 = foo.get( foo.firstIndex() ).theValue();
	foo.nextStep();
}

you need to understand that a RuntimeException, or Error can interrupt the 
execution of any of these statements.  For example, if an ArrayIndexOutOfBounds 
or NullPointerException occurs when computing the value for val2 then val1 may 
be changed, and val2 not.  You have to be careful in the design of this type of 
code.

A daemon thread, would of course allow thread death to interfere with the sanity 
of this set of atomically viewed changes.  But, that would happen because of VM 
termination, so as long as none of these perform operations visible outside of 
the VM, then things are likely okay from that perspective.

Gregg Wonderly

From serwei at gmail.com  Wed Apr  2 23:18:27 2008
From: serwei at gmail.com (serwei)
Date: Thu, 3 Apr 2008 11:18:27 +0800
Subject: [concurrency-interest] backport:
	ConcurrentModificationException with take() and contains()?
Message-ID: <fdda32c0804022018r241aaefs5a1049c833fe5ab@mail.gmail.com>

Ho thanks!
I'll go try!

I couldn't supply a version because the file's MANIFEST only stated
the JDK and the Ant version.... and I couldn't find the binary of
matching size lol

On 02/04/2008, concurrency-interest-request at cs.oswego.edu
<concurrency-interest-request at cs.oswego.edu> wrote:
> Send Concurrency-interest mailing list submissions to
>         concurrency-interest at altair.cs.oswego.edu
>
>  To subscribe or unsubscribe via the World Wide Web, visit
>         http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  or, via email, send a message with subject or body 'help' to
>         concurrency-interest-request at altair.cs.oswego.edu
>
>  You can reach the person managing the list at
>         concurrency-interest-owner at altair.cs.oswego.edu
>
>  When replying, please edit your Subject line so it is more specific
>  than "Re: Contents of Concurrency-interest digest..."
>
>
>  Today's Topics:
>
>    1. Re: Question about reordering and volatile (Jeremy Manson)
>    2. Re: Question about reordering and volatile (Joe Bowbeer)
>    3. Re: Question about reordering and volatile (Jeremy Manson)
>    4. unsubscribe me from this mail group (Madhu Soudathikar)
>    5. Re: Termination of daemon threads (David Holmes)
>    6. backport: ConcurrentModificationException with take() and
>       contains()? (serwei)
>    7. Re: CHM#replace(key, null, newValue) (Dhanji R. Prasanna)
>    8. Re: CHM#replace(key, null, newValue) (Tim Peierls)
>    9. Re: backport: ConcurrentModificationException with take() and
>       contains()? (Holger Hoffst?tte)
>
>
>  ----------------------------------------------------------------------
>
>  Message: 1
>  Date: Tue, 01 Apr 2008 14:06:25 -0700
>  From: Jeremy Manson <jmanson at cs.umd.edu>
>  Subject: Re: [concurrency-interest] Question about reordering and
>         volatile
>  To: Peter Veentjer <alarmnummer at gmail.com>
>  Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
>  Message-ID: <47F2A3D1.3000200 at cs.umd.edu>
>  Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
>  "Roach Motel" applies to synchronized blocks -- instructions can move
>  into them, but not out.  So, normal accesses can be moved from after a
>  monitorexit to before it, and from before a monitorenter to after it.
>  That's the roach motel principle.
>
>  The same reasoning applies to volatiles under the assumption that a
>  volatile write is "the same" as a monitorexit and that a volatile read
>  is "the same" as a monitorenter.
>
>  So, your answer is that you *can* move normal accesses that occur after
>  a volatile write to before it.
>
>                                         Jeremy
>
>  Peter Veentjer wrote:
>  > I have a question about reorderings and volatile writes.
>  >
>  > Reorderings and volatile writes follow the 'roach motel'  (just like
>  > synchronized blocks) that prevents instructions from jumping over.
>  >
>  > Allowing an instruction before a volatile write on variable x to jump
>  > over that write, can lead to not seeing the effects of that
>  > instruction when you do the volatile read on x.This is not allowed
>  > according to the JMM: all changes made in thread a when it does a
>  > volatile write on  x, are visible when thread b does a volatile read
>  > on x. Ok.. no problem so far.
>  >
>  > But what about instructions after the volatile write? If these were
>  > allowed (and they are not according to the roach motel principle) to
>  > jump in front of the volatile write of x, thread b could see these
>  > changes as well. The results are exactly the same as the situation
>  > that the read of x (by thread b) happens after the instruction after
>  > the volatile write has executed (by thread a). So the letting the
>  > instruction after the write to (volatile variable) x, in front of this
>  > write, would not cause any havoc.
>  >
>  > So what is the reason that instructions after the volatile write are
>  > not allowed to jump over this volatile write?
>  > _______________________________________________
>  > Concurrency-interest mailing list
>  > Concurrency-interest at altair.cs.oswego.edu
>  > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>  ------------------------------
>
>  Message: 2
>  Date: Tue, 1 Apr 2008 15:23:29 -0700
>  From: "Joe Bowbeer" <joe.bowbeer at gmail.com>
>  Subject: Re: [concurrency-interest] Question about reordering and
>         volatile
>  To: concurrency-interest <concurrency-interest at cs.oswego.edu>
>  Message-ID:
>         <31f2a7bd0804011523i3547ac23v3bb5de4602fefd8e at mail.gmail.com>
>  Content-Type: text/plain; charset="iso-8859-1"
>
>  On Tue, Apr 1, 2008 at 2:06 PM, Jeremy Manson wrote:
>
>  > "Roach Motel" applies to synchronized blocks -- instructions can move
>  > into them, but not out.  So, normal accesses can be moved from after a
>  > monitorexit to before it, and from before a monitorenter to after it.
>  > That's the roach motel principle.
>  >
>  > The same reasoning applies to volatiles under the assumption that a
>  > volatile write is "the same" as a monitorexit and that a volatile read
>  > is "the same" as a monitorenter.
>  >
>  > So, your answer is that you *can* move normal accesses that occur after
>  > a volatile write to before it.
>  >
>  >
>  Jeremy,
>
>  Is it wrong or misleading for the FAQ to say:
>
>  "Under the new memory model, accesses to volatile variables cannot be
>  reordered with each other or nonvolatile variable accesses."
>
>   http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile
>
>  I'd interpret that to mean that nothing can jump over a volatile access in
>  either direction...
>
>  By the way, the FAQ does later clarify that without a matching read, the
>  volatile write doesn't happen-before anything, which suggests that unread
>  volatile writes can be elided.
>
>  --Joe
>  -------------- next part --------------
>  An HTML attachment was scrubbed...
>  URL: /pipermail/attachments/20080401/7ab63c06/attachment-0001.html
>
>  ------------------------------
>
>  Message: 3
>  Date: Tue, 01 Apr 2008 15:37:50 -0700
>  From: Jeremy Manson <jmanson at cs.umd.edu>
>  Subject: Re: [concurrency-interest] Question about reordering and
>         volatile
>  To: Joe Bowbeer <joe.bowbeer at gmail.com>
>  Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
>  Message-ID: <47F2B93E.8030605 at cs.umd.edu>
>  Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
>  Joe Bowbeer wrote:
>  > Jeremy,
>  >
>  > Is it wrong or misleading for the FAQ to say:
>  >
>  > "Under the new memory model, accesses to volatile variables cannot be
>  > reordered with each other or nonvolatile variable accesses."
>  >
>  >   http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile
>  >
>  > I'd interpret that to mean that nothing can jump over a volatile access
>  > in either direction...
>  >
>  > By the way, the FAQ does later clarify that without a matching read, the
>  > volatile write doesn't happen-before anything, which suggests that
>  > unread volatile writes can be elided.
>
>  Let's go with "misleading" FTW.  That sentence was more intended to draw
>  a contrast with the way things used to be.  The following sentence is
>  the more accurate one.
>
>  I'll fix it.
>
>                                         Jeremy
>
>
>  ------------------------------
>
>  Message: 4
>  Date: Tue, 1 Apr 2008 16:08:00 -0700 (PDT)
>  From: Madhu Soudathikar <sv_madhuraj at yahoo.com>
>  Subject: [concurrency-interest] unsubscribe me from this mail group
>  To: Concurrency-interest at cs.oswego.edu
>  Message-ID: <404019.3700.qm at web33401.mail.mud.yahoo.com>
>  Content-Type: text/plain; charset="us-ascii"
>
>
>
>
>       ____________________________________________________________________________________
>  You rock. That's why Blockbuster's offering you one month of Blockbuster Total Access, No Cost.
>  http://tc.deals.yahoo.com/tc/blockbuster/text5.com
>  -------------- next part --------------
>  An HTML attachment was scrubbed...
>  URL: /pipermail/attachments/20080401/6f8cbbbf/attachment-0001.html
>
>  ------------------------------
>
>  Message: 5
>  Date: Wed, 2 Apr 2008 10:41:48 +1000
>  From: "David Holmes" <dcholmes at optusnet.com.au>
>  Subject: Re: [concurrency-interest] Termination of daemon threads
>  To: "Peter Kovacs" <peter.kovacs.1.0rc at gmail.com>
>  Cc: concurrency-interest at cs.oswego.edu
>  Message-ID: <NFBBKALFDCPFIDBNKAPCCECAHLAA.dcholmes at optusnet.com.au>
>  Content-Type: text/plain;       charset="us-ascii"
>
>  Peter,
>
>  "critical" in this context means "anything you'd be upset about if it didn't
>  get done" - which implies it's something visible outside the current
>  incarnation of the VM, such as writing a log file, updating a database, ...
>
>  If you create a daemon thread then you need to be prepared for it being
>  abruptly terminated when your application ends (by which I mean voluntarily
>  not by being killed externally :) )
>
>  Cheers,
>  David Holmes
>
>  > -----Original Message-----
>  > From: concurrency-interest-bounces at cs.oswego.edu
>  > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
>  > Kovacs
>  > Sent: Tuesday, 1 April 2008 7:43 PM
>  > To: dholmes at ieee.org
>  > Cc: concurrency-interest at cs.oswego.edu
>  > Subject: Re: [concurrency-interest] Termination of daemon threads
>  >
>  >
>  > David,
>  >
>  > I wonder what "critical" may mean here. The process is going to be
>  > terminated: resources are freed, memory recovered, locks released...
>  > Nature is at work here making room for a new life... What is critical
>  > for me (e.g. a big salary raise, dating with the handsome assistant
>  > from the 99th floor) will not be critical after my death. In other
>  > words: what can be critical as I am just dying.
>  >
>  > OK, I try to put my egotism aside: may "critical" mean "something"
>  > which other processes rely on? Should the answer then not be: a daemon
>  > thread can do anything, just be prepared for it being abruptly
>  > terminated? Just as if the process itself would be killed -- I assume.
>  > So the advice goes: don't do anything critical in non-daemon threads
>  > either, because your process may get killed. :-)
>  >
>  > Peter
>  >
>  > On Tue, Apr 1, 2008 at 6:41 AM, David Holmes
>  > <dcholmes at optusnet.com.au> wrote:
>  > > A daemon thread should never do anything critical. Daemon threads just
>  > >  "vanish" when the process is terminated. Though for Sun's VM
>  > they are at
>  > >  least brought to a system "safe-point" first - though
>  > executing native code
>  > >  is considered being at a "safe-point" ie outside of the VM.
>  > >
>  > >  It probably could be documented better.
>  > >
>  > >  David Holmes
>  > >
>  > >
>  > >
>  > >  > -----Original Message-----
>  > >  > From: concurrency-interest-bounces at cs.oswego.edu
>  > >  > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf
>  > Of Dimitris
>  > >  > Andreou
>  > >  > Sent: Tuesday, 1 April 2008 2:02 PM
>  > >  > To: concurrency-interest at cs.oswego.edu
>  > >  > Subject: [concurrency-interest] Termination of daemon threads
>  > >  >
>  > >  >
>  > >  > Hi all,
>  > >  >
>  > >  > Here is my question: How are daemon threads terminated? What
>  > if they are
>  > >  > in the middle of a critical operation, like writing to a
>  > file? They seem
>  > >  > to exit immediately. How could that be safe? Or a daemon
>  > thread should
>  > >  > never do anything critical, but always delegate such work to a
>  > >  > non-daemon thread? If any case, shouldn't it be documented in
>  > >  > java.lang.Thread?
>  > >  >
>  > >  > Thanks
>  > >  > Dimitris Andreou
>  > >  >
>  > >  > _______________________________________________
>  > >  > Concurrency-interest mailing list
>  > >  > Concurrency-interest at altair.cs.oswego.edu
>  > >  > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  > >  >
>  > >
>  > >  _______________________________________________
>  > >  Concurrency-interest mailing list
>  > >  Concurrency-interest at altair.cs.oswego.edu
>  > >  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  > >
>  > _______________________________________________
>  > Concurrency-interest mailing list
>  > Concurrency-interest at altair.cs.oswego.edu
>  > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>  ------------------------------
>
>  Message: 6
>  Date: Wed, 2 Apr 2008 16:42:51 +0800
>  From: serwei <serwei at gmail.com>
>  Subject: [concurrency-interest] backport:
>         ConcurrentModificationException with take() and contains()?
>  To: concurrency-interest at cs.oswego.edu
>  Message-ID:
>         <fdda32c0804020142j649ef636y3c7a4d5a3494015b at mail.gmail.com>
>  Content-Type: text/plain; charset=UTF-8
>
>  Hi there,
>
>  is it a confirmed scenario where a ConcurrentModificationException
>  will happen when a DelayQueue.contains() is running and a
>  DelayQueue.take() happens then?
>
>  So I have to manually synchronized (something) for the two?
>
>  Thanks!
>
>  PS: stack below
>
>  java.util.ConcurrentModificationException
>         at edu.emory.mathcs.backport.java.util.PriorityQueue$Itr.checkForComodification(PriorityQueue.java(Inlined
>  Compiled Code))
>         at edu.emory.mathcs.backport.java.util.PriorityQueue$Itr.next(PriorityQueue.java(Compiled
>  Code))
>         at edu.emory.mathcs.backport.java.util.concurrent.DelayQueue$Itr.next(DelayQueue.java(Compiled
>  Code))
>         at java.util.AbstractCollection.contains(AbstractCollection.java(Compiled
>  Code))
>
>
>  ------------------------------
>
>  Message: 7
>  Date: Wed, 2 Apr 2008 17:42:26 +0530
>  From: "Dhanji R. Prasanna" <dhanji at gmail.com>
>  Subject: Re: [concurrency-interest] CHM#replace(key, null, newValue)
>  To: "Peter Veentjer" <alarmnummer at gmail.com>
>  Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>,
>         Matthias Ernst <matthias at mernst.org>
>  Message-ID:
>         <aa067ea10804020512w4c18007fq770a522e4b558930 at mail.gmail.com>
>  Content-Type: text/plain; charset="iso-8859-1"
>
>  On Tue, Apr 1, 2008 at 8:44 PM, Peter Veentjer <alarmnummer at gmail.com>
>  wrote:
>
>  > It is a shame that the value to be placed in the hashmap can't be
>  > created lazy.
>
>
>  You could use a Future<T>. I think there was a thread some time ago
>  discussing this (about a CHM.putIfAbsent(Callable)). The Future<T> was
>  crazybob's idea on that thread.
>
>  Dhanji.
>  -------------- next part --------------
>  An HTML attachment was scrubbed...
>  URL: /pipermail/attachments/20080402/d7578df1/attachment-0001.html
>
>  ------------------------------
>
>  Message: 8
>  Date: Wed, 2 Apr 2008 08:55:43 -0400
>  From: "Tim Peierls" <tim at peierls.net>
>  Subject: Re: [concurrency-interest] CHM#replace(key, null, newValue)
>  To: concurrency-interest <concurrency-interest at cs.oswego.edu>
>  Message-ID:
>         <63b4e4050804020555tbff707ne439fd9256f363bb at mail.gmail.com>
>  Content-Type: text/plain; charset="iso-8859-1"
>
>  Maybe it's time to recycle Doug Lea's post on lazy initialization of map
>  values one more time. I've posted it on the Java Concurrency Wiki:
>
>  http://artisans-serverintellect-com.si-eioswww6.com/default.asp?W122
>
>  --tim
>
>  On Wed, Apr 2, 2008 at 8:12 AM, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
>
>  >
>  >
>  > On Tue, Apr 1, 2008 at 8:44 PM, Peter Veentjer <alarmnummer at gmail.com>
>  > wrote:
>  >
>  > > It is a shame that the value to be placed in the hashmap can't be
>  > > created lazy.
>  >
>  >
>  > You could use a Future<T>. I think there was a thread some time ago
>  > discussing this (about a CHM.putIfAbsent(Callable)). The Future<T> was
>  > crazybob's idea on that thread.
>  >
>  > Dhanji.
>  >
>  -------------- next part --------------
>  An HTML attachment was scrubbed...
>  URL: /pipermail/attachments/20080402/51edd555/attachment-0001.html
>
>  ------------------------------
>
>  Message: 9
>  Date: Wed, 02 Apr 2008 15:32:56 +0200
>  From: Holger Hoffst?tte <holger at wizards.de>
>  Subject: Re: [concurrency-interest] backport:
>         ConcurrentModificationException with take() and contains()?
>  To: concurrency-interest at cs.oswego.edu
>  Message-ID: <47F38B08.9010303 at wizards.de>
>  Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
>  serwei wrote:
>  > is it a confirmed scenario where a ConcurrentModificationException
>  > will happen when a DelayQueue.contains() is running and a
>  > DelayQueue.take() happens then?
>
>  That seems wrong. Which version of the backport are you using? Looks like
>  an older version. I ask because..
>
>  > So I have to manually synchronized (something) for the two?
>  >
>  > Thanks!
>  >
>  > PS: stack below
>  >
>  > java.util.ConcurrentModificationException
>  >         at edu.emory.mathcs.backport.java.util.PriorityQueue$Itr.checkForComodification(PriorityQueue.java(Inlined
>  > Compiled Code))
>  >         at edu.emory.mathcs.backport.java.util.PriorityQueue$Itr.next(PriorityQueue.java(Compiled
>  > Code))
>  >         at edu.emory.mathcs.backport.java.util.concurrent.DelayQueue$Itr.next(DelayQueue.java(Compiled
>  > Code))
>  >         at java.util.AbstractCollection.contains(AbstractCollection.java(Compiled
>  > Code))
>
>  ..looking at this stack trace it seems that the DelayQueue Iterator
>  directly accesses the internal PriorityQueue without locking, however that
>  is not what's happening in JDK6 or the latest backport (3.1), where the
>  inherited contains() iterates over an unshared array snapshot.
>
>  Ah yes - this is the old (exception-throwing aka non-concurrent) behaviour
>  in JDK5 as implemented by backport 2.x. So the easiest way to fix your
>  problem is simply using the latest backport lib. That's a good idea anyway. :)
>
>  Holger
>
>
>  ------------------------------
>
>  _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>  End of Concurrency-interest Digest, Vol 39, Issue 4
>  ***************************************************
>


-- 
"Dusting it off..."
http://serwei.deviantart.com

From joe.bowbeer at gmail.com  Mon Apr  7 16:10:59 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 7 Apr 2008 13:10:59 -0700
Subject: [concurrency-interest] santa clause problem solved?
Message-ID: <31f2a7bd0804071310v3160457aj168960d20871636@mail.gmail.com>

Does anyone have a nice solution to the Santa Claus Problem using
java.util.concurrent?

I know this is 1/4 turn out of season, but as we all know, Java
concurrency is not "real-time" ...

In Ch. 24 of Beautiful Code, Simon Peyton Jones solves the Santa Claus
Problem in Haskell using Software Transactional Memory (STM).  The
full source of his solution can be found at:

  http://www.crsr.net/Notes/SantaClausProblem.html

There's also a full discussion of a "correct" Ada solution in this
article Mordechai Ben-Ari:

  http://stwww.weizmann.ac.il/g-cs/benari/articles/santa-claus-problem.pdf

Ben-Ari, who wrote that Doug Lea invited the readers of Concurrent
Programming in Java to develop a full solution, also presents the
beginnings of a solution written in ancient BJUC Java.
(BJUC=BeforeJavaUtilConcurrent)

To my eye, a solution in jCSP would look similar to the Haskell and
Erlang solutions.

Has someone written a clean solution with java.util.concurrent?  I'm
thinking a custom AbstractQueuedSynchronizer (AQS) may be involved.

--Joe

From joe.bowbeer at gmail.com  Mon Apr  7 20:45:55 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 7 Apr 2008 17:45:55 -0700
Subject: [concurrency-interest] santa clause problem solved?
In-Reply-To: <31f2a7bd0804071310v3160457aj168960d20871636@mail.gmail.com>
References: <31f2a7bd0804071310v3160457aj168960d20871636@mail.gmail.com>
Message-ID: <31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>

After a tad more thought I think the problem can be solved using a few
cyclic barriers and a priority queue.

A cyclic barrier of 9 parties serves as the stable for the waiting
reindeer.  When this is released, a high-priority "deliver-toys" task
is queued for santa, and the reindeer wait on a cyclic barrier of 10
parties (the sleigh).  When santa arrives at the sleigh, the whole
gang delivers toys (this is the barrier task) and then the reindeer go
off on separate vacations and santa goes back to sleep (until a new
task arrives).

The elves are harder to deal with.  Arriving elves are given a cyclic
barrier of 4 parties to wait on.  This barrier is a reservation for 3
elves to meet with santa.  A reservation generator hands these out.  A
new reservation is generated after every third elf arrives.  When
three elves have arrived and are waiting on their shared reservation,
a low-priority "meet-with-elves" task is queued for santa.  This task
contains a reference to the barrier those elves are waiting on.  When
santa handles this task, he arrives at that barrier, meets with the
elves (this is the barrier task) and then the elves go back to work
and santa goes back to sleep.

Sound reasonable?  I'd be interested to hear of other solutions.

--Joe

On Mon, Apr 7, 2008 at 1:10 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> Does anyone have a nice solution to the Santa Claus Problem using
>  java.util.concurrent?
>
>  I know this is 1/4 turn out of season, but as we all know, Java
>  concurrency is not "real-time" ...
>
>  In Ch. 24 of Beautiful Code, Simon Peyton Jones solves the Santa Claus
>  Problem in Haskell using Software Transactional Memory (STM).  The
>  full source of his solution can be found at:
>
>   http://www.crsr.net/Notes/SantaClausProblem.html
>
>  There's also a full discussion of a "correct" Ada solution in this
>  article Mordechai Ben-Ari:
>
>   http://stwww.weizmann.ac.il/g-cs/benari/articles/santa-claus-problem.pdf
>
>  Ben-Ari, who wrote that Doug Lea invited the readers of Concurrent
>  Programming in Java to develop a full solution, also presents the
>  beginnings of a solution written in ancient BJUC Java.
>  (BJUC=BeforeJavaUtilConcurrent)
>
>  To my eye, a solution in jCSP would look similar to the Haskell and
>  Erlang solutions.
>
>  Has someone written a clean solution with java.util.concurrent?  I'm
>  thinking a custom AbstractQueuedSynchronizer (AQS) may be involved.
>
>  --Joe
>

From dcholmes at optusnet.com.au  Mon Apr  7 21:39:07 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 8 Apr 2008 11:39:07 +1000
Subject: [concurrency-interest] santa clause problem solved?
In-Reply-To: <31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKECMHLAA.dcholmes@optusnet.com.au>

Hi Joe,

Sounds fairly reasonable. :) I'd never heard of this "problem". There are
three main concurrency issues to deal with that I can see:

1.  To have Santa wait for either the elves or the reindeer - different
languages/systems will make that easier than others. In j.u.c the easiest
way to wait for multiple things is as you suggest: wait on a queue (priority
if needed as in this case) and have the other actions post events to the
queue.

2. To give priority to reindeer over elves. This is actually harder in many
languages, but with a priority queue it's quite straight-forward.

3. Having the elves/reindeer wait for each other and then Santa.

The two barriers for the reindeer seems straight-forward enough.

The elves is a little trickier and I didn't quite see how your solution
worked. If the elves wait on a barrier with four parties, what triggers the
event when 3 arrive? Does your "reservation generator" keep track of
requests and post the event after every third request? That seems to work,
but there's a potential delay between an elf requesting the cyclic barrier
and actually waiting on it, so you might wait for thousands of elves to
block before the initial group of three all arrive at the barrier.

Another possibility is for all elves to try and grab a Semaphore with 3
permits. When they have that they wait on a barrier-3, the barrier task for
which posts the event to the queue together with a barrier-4, and then
signals the semaphore so the next 3 elves can get through. The elves then
wait on the barrier-4 until Santa arrives. I'm not sure how to manage the
references to the barrier-4 and it has the same delay problem :) Maybe delay
is unavoidable if all the elves rush to Santa at once :-)

Now back to real work for me!

Cheers,
David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Joe
> Bowbeer
> Sent: Tuesday, 8 April 2008 10:46 AM
> To: concurrency-interest
> Subject: Re: [concurrency-interest] santa clause problem solved?
>
>
> After a tad more thought I think the problem can be solved using a few
> cyclic barriers and a priority queue.
>
> A cyclic barrier of 9 parties serves as the stable for the waiting
> reindeer.  When this is released, a high-priority "deliver-toys" task
> is queued for santa, and the reindeer wait on a cyclic barrier of 10
> parties (the sleigh).  When santa arrives at the sleigh, the whole
> gang delivers toys (this is the barrier task) and then the reindeer go
> off on separate vacations and santa goes back to sleep (until a new
> task arrives).
>
> The elves are harder to deal with.  Arriving elves are given a cyclic
> barrier of 4 parties to wait on.  This barrier is a reservation for 3
> elves to meet with santa.  A reservation generator hands these out.  A
> new reservation is generated after every third elf arrives.  When
> three elves have arrived and are waiting on their shared reservation,
> a low-priority "meet-with-elves" task is queued for santa.  This task
> contains a reference to the barrier those elves are waiting on.  When
> santa handles this task, he arrives at that barrier, meets with the
> elves (this is the barrier task) and then the elves go back to work
> and santa goes back to sleep.
>
> Sound reasonable?  I'd be interested to hear of other solutions.
>
> --Joe
>
> On Mon, Apr 7, 2008 at 1:10 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> > Does anyone have a nice solution to the Santa Claus Problem using
> >  java.util.concurrent?
> >
> >  I know this is 1/4 turn out of season, but as we all know, Java
> >  concurrency is not "real-time" ...
> >
> >  In Ch. 24 of Beautiful Code, Simon Peyton Jones solves the Santa Claus
> >  Problem in Haskell using Software Transactional Memory (STM).  The
> >  full source of his solution can be found at:
> >
> >   http://www.crsr.net/Notes/SantaClausProblem.html
> >
> >  There's also a full discussion of a "correct" Ada solution in this
> >  article Mordechai Ben-Ari:
> >
> >
http://stwww.weizmann.ac.il/g-cs/benari/articles/santa-claus-problem.pdf
>
>  Ben-Ari, who wrote that Doug Lea invited the readers of Concurrent
>  Programming in Java to develop a full solution, also presents the
>  beginnings of a solution written in ancient BJUC Java.
>  (BJUC=BeforeJavaUtilConcurrent)
>
>  To my eye, a solution in jCSP would look similar to the Haskell and
>  Erlang solutions.
>
>  Has someone written a clean solution with java.util.concurrent?  I'm
>  thinking a custom AbstractQueuedSynchronizer (AQS) may be involved.
>
>  --Joe
>
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From joe.bowbeer at gmail.com  Tue Apr  8 03:32:35 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 8 Apr 2008 00:32:35 -0700
Subject: [concurrency-interest] santa clause problem solved?
In-Reply-To: <31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>
References: <31f2a7bd0804071310v3160457aj168960d20871636@mail.gmail.com>
	<31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>
Message-ID: <31f2a7bd0804080032u1913cd76sf48d45916d2ed515@mail.gmail.com>

Here's the Java code.

/*
 * SantaClausProblem.java
 */

import java.util.Random;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * A simulation of the Santa Claus Problem using java.util.concurrent.
 *
 * <p>See <a href="http://www.crsr.net/Notes/SantaClausProblem.html">
 * http://www.crsr.net/Notes/SantaClausProblem.html</a> for a
 * solution using Haskell and Software Transactional Memory (STM).
 * See <a href="http://research.microsoft.com/~nick/santa.pdf">
 * http://research.microsoft.com/~nick/santa.pdf</a> for a solution
 * written in Polyphonic C#.
 *
 * @author Joe Bowbeer
 */
public class SantaClausProblem {

    static final int NUM_REINDEER = 9;
    static final int NUM_ELVES = 10;
    static final int ELF_QUORAM = 3;
    enum Priority {REINDEER, ELF} // Reindeers before elves

    static class Reindeer implements Runnable {

        private final CyclicBarrier stable;
        private final CyclicBarrier sleigh;
        private final Runnable takeHoliday;

        public Reindeer(CyclicBarrier stable, CyclicBarrier sleigh,
                Runnable takeHoliday) {
            this.stable = stable;
            this.sleigh = sleigh;
            this.takeHoliday = takeHoliday;
        }

        public void run() {
            try {
                while (true) {
                    takeHoliday.run();
                    stable.await();
                    sleigh.await();
                }
            } catch (InterruptedException ex) {
                // quit
            } catch (BrokenBarrierException ex) {
                // quit
            }
        }
    }

    static class Elf implements Runnable {

        private final MeetingManager manager;
        private final Runnable makeToys;

        public Elf(MeetingManager manager, Runnable makeToys) {
            this.manager = manager;
            this.makeToys = makeToys;
        }

        public void run() {
            try {
                while (true) {
                    makeToys.run();
                    manager.makeReservation().await();
                }
            } catch (InterruptedException ex) {
                // quit
            } catch (BrokenBarrierException ex) {
                // quit
            }
        }
    }

    static class Santa implements Runnable {

        private final BlockingQueue<SantaTask> queue;

        public Santa(BlockingQueue<SantaTask> queue) {
            this.queue = queue;
        }

        public void run() {
            try {
                while (true) {
                    System.out.println("Santa is sleeping");
                    queue.take().run();
                }
            } catch (InterruptedException ex) {
                // quit
            }
        }
    }

    static class SantaTask implements Comparable<SantaTask>, Runnable {

        private final Priority priority;
        private final CyclicBarrier barrier;

        public SantaTask(Priority priority, CyclicBarrier barrier) {
            this.priority = priority;
            this.barrier = barrier;
        }

        public int compareTo(SantaTask other) {
            return priority.compareTo(other.priority);
        }

        public void run() {
            try {
                barrier.await();
            } catch (InterruptedException ex) {
                Thread.currentThread().interrupt(); // stop Santa
            } catch (BrokenBarrierException ex) {
                Thread.currentThread().interrupt(); // stop Santa
            }
        }
    }

    static class MeetingManager {

        private final BlockingQueue<SantaTask> queue;
        private final Runnable holdMeeting;
        private CyclicBarrier meeting;
        private int attendees;

        public MeetingManager(BlockingQueue<SantaTask> queue,
                Runnable holdMeeting) {
            this.queue = queue;
            this.holdMeeting = holdMeeting;
        }

        public synchronized CyclicBarrier makeReservation() {
            if (meeting == null) {
                meeting = new CyclicBarrier(ELF_QUORAM+1, holdMeeting);
            }
            CyclicBarrier reservation = meeting;
            if (++attendees == ELF_QUORAM) {
                queue.add(new SantaTask(Priority.ELF, meeting));
                meeting = null;
                attendees = 0;
            }
            return reservation;
        }
    }

    static final Random RAND = new Random();

    static Runnable makeRandomDelay(final int delay, final String what) {
        return new Runnable() {
            public void run() {
                try {
                    if (what != null)
                        System.out.println(what);
                    Thread.sleep(RAND.nextInt(delay));
                } catch (InterruptedException ex) {
                    Thread.currentThread().interrupt(); // propogate
                }
            }
        };
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws InterruptedException {

        ExecutorService executor = Executors.newCachedThreadPool();

        final BlockingQueue<SantaTask> queue =
                new PriorityBlockingQueue<SantaTask>();

        Runnable designToys = makeRandomDelay(200,
                "Santa is meeting with elves");
        Runnable makeToys = makeRandomDelay(400, null);
        Runnable deliverToys = makeRandomDelay(400,
                "Santa is delivering toys");
        Runnable takeHoliday = makeRandomDelay(600, null);

        MeetingManager manager = new MeetingManager(queue, designToys);

        for (int i = 0; i < NUM_ELVES; i++)
            executor.execute(new Elf(manager, makeToys));

        final CyclicBarrier sleigh =
                new CyclicBarrier(NUM_REINDEER+1, deliverToys);

        CyclicBarrier stable =
                new CyclicBarrier(NUM_REINDEER, new Runnable() {
            public void run() {
                queue.add(new SantaTask(Priority.REINDEER, sleigh));
            }
        });

        for (int i = 0; i < NUM_REINDEER; i++)
            executor.execute(new Reindeer(stable, sleigh, takeHoliday));

        executor.execute(new Santa(queue));

        // Run simulation for 30 seconds and then shut it down.
        Thread.sleep(30000);
        executor.shutdownNow();
        executor.awaitTermination(2, TimeUnit.SECONDS);
    }
}

From joe.bowbeer at gmail.com  Tue Apr  8 03:41:07 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 8 Apr 2008 00:41:07 -0700
Subject: [concurrency-interest] santa clause problem solved?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKECMHLAA.dcholmes@optusnet.com.au>
References: <31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCKECMHLAA.dcholmes@optusnet.com.au>
Message-ID: <31f2a7bd0804080041l2962f402rb98518ac6de0edad@mail.gmail.com>

On Mon, Apr 7, 2008 at 6:39 PM, David Holmes <dcholmes at optusnet.com.au> wrote:
>  3. Having the elves/reindeer wait for each other and then Santa.
>
>  The elves is a little trickier and I didn't quite see how your solution
>  worked. If the elves wait on a barrier with four parties, what triggers the
>  event when 3 arrive? Does your "reservation generator" keep track of
>  requests and post the event after every third request? That seems to work,
>  but there's a potential delay between an elf requesting the cyclic barrier
>  and actually waiting on it, so you might wait for thousands of elves to
>  block before the initial group of three all arrive at the barrier.
>
>  Another possibility is for all elves to try and grab a Semaphore with 3
>  permits. When they have that they wait on a barrier-3, the barrier task for
>  which posts the event to the queue together with a barrier-4, and then
>  signals the semaphore so the next 3 elves can get through. The elves then
>  wait on the barrier-4 until Santa arrives. I'm not sure how to manage the
>  references to the barrier-4 and it has the same delay problem :) Maybe delay
>  is unavoidable if all the elves rush to Santa at once :-)
>

I meant the former: the MeetingManager (as named in the code) posts a
task to Santa's queue when three Elves have arrived for a meeting.

Thanks for the comments.

--Joe

From joe.bowbeer at gmail.com  Tue Apr  8 07:21:23 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 8 Apr 2008 04:21:23 -0700
Subject: [concurrency-interest] santa clause problem solved?
In-Reply-To: <31f2a7bd0804080032u1913cd76sf48d45916d2ed515@mail.gmail.com>
References: <31f2a7bd0804071310v3160457aj168960d20871636@mail.gmail.com>
	<31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>
	<31f2a7bd0804080032u1913cd76sf48d45916d2ed515@mail.gmail.com>
Message-ID: <31f2a7bd0804080421k57fd3f7axae298b2930fae840@mail.gmail.com>

Btw, I forget that the PriorityQueue doesn't preserve insertion order
for elements of equal priority.  The simulation can be fixed by adding
a sequence number to Santa's tasks.  I can post the updated code if
there's interest.

From pavitar at pramati.com  Tue Apr  8 10:57:07 2008
From: pavitar at pramati.com (Pavitar Singh)
Date: Tue, 8 Apr 2008 20:27:07 +0530 (IST)
Subject: [concurrency-interest] readValueUnderLock in ConcurrentHashMap
In-Reply-To: <31f2a7bd0804080041l2962f402rb98518ac6de0edad@mail.gmail.com>
References: <31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCKECMHLAA.dcholmes@optusnet.com.au>
	<31f2a7bd0804080041l2962f402rb98518ac6de0edad@mail.gmail.com>
Message-ID: <1944.192.168.2.107.1207666627.squirrel@mail.pramati.com>

Hi All,

I didnt understand why do we need readUnderLock during get in
ConcurrentHashMap.

"This is possible only if a compiler happens to reorder a HashEntry
initialization with its table assignment, which is legal under memory
model          but is not known to ever occur."  from the javadoc.

Does that mean :
in put method .

tab[index] will have a HashEntry , but not yet initialized (constructor
invoked)

if this is the case then how HashEntry hash and key will be visible in:
get method.
if (e.hash == hash && key.equals(e.key))

Regards
Pavitar



From jason.greene at redhat.com  Tue Apr  8 15:55:27 2008
From: jason.greene at redhat.com (Jason T. Greene)
Date: Tue, 08 Apr 2008 14:55:27 -0500
Subject: [concurrency-interest] readValueUnderLock in ConcurrentHashMap
In-Reply-To: <1944.192.168.2.107.1207666627.squirrel@mail.pramati.com>
References: <31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCKECMHLAA.dcholmes@optusnet.com.au>	<31f2a7bd0804080041l2962f402rb98518ac6de0edad@mail.gmail.com>
	<1944.192.168.2.107.1207666627.squirrel@mail.pramati.com>
Message-ID: <47FBCDAF.40307@redhat.com>

Pavitar Singh wrote:
> Hi All,
> 
> I didnt understand why do we need readUnderLock during get in
> ConcurrentHashMap.
> 
> "This is possible only if a compiler happens to reorder a HashEntry
> initialization with its table assignment, which is legal under memory
> model          but is not known to ever occur."  from the javadoc.
> 
> Does that mean :
> in put method .
> 
> tab[index] will have a HashEntry , but not yet initialized (constructor
> invoked)

It means that the HashEntry will not be completely initialized. So the 
volatile variable read might see the default initial value, which is null.

> if this is the case then how HashEntry hash and key will be visible in:
> get method.
> if (e.hash == hash && key.equals(e.key))
> 

Because they are final. Final fields are guaranteed to be visible as 
long as the object is not published before the constructor has 
completed. See 17.5 of the JLS:
http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.5

-- 
Jason T. Greene
JBoss, a division of Red Hat

From jdmarshall at gmail.com  Tue Apr  8 18:19:08 2008
From: jdmarshall at gmail.com (jason marshall)
Date: Tue, 8 Apr 2008 15:19:08 -0700
Subject: [concurrency-interest] santa clause problem solved?
In-Reply-To: <31f2a7bd0804080421k57fd3f7axae298b2930fae840@mail.gmail.com>
References: <31f2a7bd0804071310v3160457aj168960d20871636@mail.gmail.com>
	<31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>
	<31f2a7bd0804080032u1913cd76sf48d45916d2ed515@mail.gmail.com>
	<31f2a7bd0804080421k57fd3f7axae298b2930fae840@mail.gmail.com>
Message-ID: <3cf41bb90804081519g43179d66i220548b4ab8c3264@mail.gmail.com>

In the Ada example, Santa knows that there is work to be done (wakes
up), and figures out which is more pressing.  They've elected Santa as
the Actor in the solution, even though the original problem makes the
elves and the reindeer the actors and Santa is more or less acted
upon.  In doing so, they make the prioritization phase trivial, and I
suspect that the 'right' Java solution has to find a way to work in
the same manner.

-Jason




On Tue, Apr 8, 2008 at 4:21 AM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> Btw, I forget that the PriorityQueue doesn't preserve insertion order
>  for elements of equal priority.  The simulation can be fixed by adding
>  a sequence number to Santa's tasks.  I can post the updated code if
>  there's interest.
>
>
> _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
- Jason

From joe.bowbeer at gmail.com  Wed Apr  9 02:20:38 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 8 Apr 2008 23:20:38 -0700
Subject: [concurrency-interest] santa clause problem solved?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKECMHLAA.dcholmes@optusnet.com.au>
References: <31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCKECMHLAA.dcholmes@optusnet.com.au>
Message-ID: <31f2a7bd0804082320ie02c1c9s3f8db1b76ca99f09@mail.gmail.com>

On Mon, Apr 7, 2008 at 6:39 PM, David Holmes wrote:
>
>  Another possibility is for all elves to try and grab a Semaphore with 3
>  permits. When they have that they wait on a barrier-3, the barrier task for
>  which posts the event to the queue together with a barrier-4, and then
>  signals the semaphore so the next 3 elves can get through. The elves then
>  wait on the barrier-4 until Santa arrives. I'm not sure how to manage the
>  references to the barrier-4 and it has the same delay problem :) Maybe delay
>  is unavoidable if all the elves rush to Santa at once :-)
>

I simplified the code quite a bit and added a semaphore to control
access to the barriers.

There are now only three classes:

1. Santa
2. GroupActivity (for "delivering toys" and "meeting with elves")
3. Worker (for reindeer and elves)

Note that I'm using separate barriers for starting and stopping the
group activity, whereas one barrier can often be reused for both
purposes.  Using two barriers allows new permits to be released as
soon as the current activity has started.  This way, a new team can
form while the current activity is in progress -- as you suggest.

By the way, the code now uses a Deque instead of a PriorityQueue.  The
single high-priority reindeer task is added at the head, while the
low-priority elf tasks are added at the tail.

The code:

/*
 *  SantaClausProblem.java
 */

import java.util.Deque;
import java.util.Random;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * A simulation of the Santa Claus Problem using java.util.concurrent.
 *
 * <p>See <a href="http://www.crsr.net/Notes/SantaClausProblem.html">
 * http://www.crsr.net/Notes/SantaClausProblem.html</a> for a
 * solution using Haskell and Software Transactional Memory (STM).
 * See <a href="http://research.microsoft.com/~nick/santa.pdf">
 * http://research.microsoft.com/~nick/santa.pdf</a> for a solution
 * written in Polyphonic C#.
 *
 * @author Joe Bowbeer
 */
public class SantaClausProblem {

    static final int ELF_QUORAM = 3;
    static final int NUM_ELVES = 10;
    static final int NUM_REINDEER = 9;

    /** Santa sleeps, meets with elves and delivers toys with reindeer. */
    static class Santa implements Runnable {
        private final BlockingQueue<Runnable> queue;
        Santa(BlockingQueue<Runnable> queue) {
            this.queue = queue;
        }
        public void run() {
            try {
                while (true) {
                    System.out.println("Santa is sleeping");
                    queue.take().run();
                }
            } catch (InterruptedException ex) {
                // quit
            }
            System.out.println("Santa is done");
        }
    }

    /** An activity performed by Santa with a team of helpers. */
    static class GroupActivity {

        private final String name;
        private final Semaphore permit;
        private final CyclicBarrier groupBarrier;
        private final CyclicBarrier entryBarrier;
        private final CyclicBarrier exitBarrier;

        GroupActivity(String name,
                final int size,
                final Deque<Runnable> deque,
                final boolean prepend, // addFirst if high-priority
                final Runnable action) {

            this.name = name;
            permit = new Semaphore(size, true); // fair
            entryBarrier = new CyclicBarrier(size + 1);
            exitBarrier = new CyclicBarrier(size + 1);

            // Wake up Santa when a sufficiently large group has formed
            groupBarrier = new CyclicBarrier(size, new Runnable() {
                public void run() {
                    Runnable task = new Runnable() {
                        public void run() {
                            try {
                                entryBarrier.await(); // hitch
                                permit.release(size); // form new team
                                System.out.println("Santa is " + action);
                                action.run();
                                exitBarrier.await();  // unhitch
                            } catch (InterruptedException ex) {
                                Thread.currentThread().interrupt();
                            } catch (BrokenBarrierException ex) {
                                Thread.currentThread().interrupt();
                            }
                        }
                    };
                    if (prepend) {
                        deque.addFirst(task);
                    } else {
                        deque.addLast(task);
                    }
                }
            });
        }

        void arrive() throws InterruptedException, BrokenBarrierException {
            permit.acquire();       // join team
            groupBarrier.await();   // wakeup Santa
            entryBarrier.await();   // hitch and go
        }

        void leave() throws InterruptedException, BrokenBarrierException {
            exitBarrier.await();    // unhitch
        }

        @Override public String toString() {
            return name;
        }
    }

    /** Alternates between group activity with Santa and a solo task. */
    static class Worker implements Runnable {
        private final String name;
        private final GroupActivity group;
        private final Runnable soloTask;
        Worker(String name, GroupActivity group, Runnable soloTask) {
            this.name = name;
            this.group = group;
            this.soloTask = soloTask;
        }
        public void run() {
            System.out.println(name + " starting");
            try {
                while (true) {
                    System.out.println(name + " is waiting for Santa");
                    group.arrive();
                    System.out.println(name + " at " + group);
                    group.leave();
                    System.out.println(name + " is " + soloTask);
                    soloTask.run();
                }
            } catch (InterruptedException ex) {
                // quit
            } catch (BrokenBarrierException ex) {
                // quit
            }
            System.out.println(name + " quitting");
        }
    }

    static final Random RAND = new Random();

    /** Represents a time-consuming activity. */
    static Runnable makeRandomDelay(final int delay, final String name) {
        return new Runnable() {
            public void run() {
                try {
                    Thread.sleep(RAND.nextInt(delay));
                } catch (InterruptedException ex) {
                    Thread.currentThread().interrupt(); // propagate
                }
            }
            @Override public String toString() {
                return name;
            }
        };
    }

    /** Simulates the Santa Claus Problem. */
    public static void main(String[] unused) throws InterruptedException {

        ExecutorService executor = Executors.newCachedThreadPool();

        BlockingDeque<Runnable> deque = new LinkedBlockingDeque<Runnable>();

        Runnable deliverToys = makeRandomDelay(1000, "delivering toys");
        Runnable onHoliday = makeRandomDelay(2000, "on holiday");
        Runnable designToys = makeRandomDelay(500, "designing toys");
        Runnable makeToys = makeRandomDelay(1000, "making toys");

        GroupActivity sleigh = new GroupActivity(
                "sleigh", NUM_REINDEER, deque, true, deliverToys);

        for (int i = 0; i < NUM_REINDEER; i++)
            executor.execute(new Worker("reindeer-"+(i+1), sleigh, onHoliday));

        GroupActivity meeting = new GroupActivity(
                "meeting", ELF_QUORAM, deque, false, designToys);

        for (int i = 0; i < NUM_ELVES; i++)
            executor.execute(new Worker("elf-"+(i+1), meeting, makeToys));

        executor.execute(new Santa(deque));

        // Run simulation for 30 seconds and then shut it down.
        Thread.sleep(30000);
        executor.shutdownNow();
        executor.awaitTermination(2, TimeUnit.SECONDS);
    }
}

Generates output like:

...
Santa is sleeping
elf-6 is waiting for Santa
elf-9 is waiting for Santa
elf-6 at meeting
elf-9 at meeting
Santa is designing toys
elf-3 at meeting
elf-1 is waiting for Santa
elf-10 is waiting for Santa
Santa is sleeping
elf-9 is making toys
elf-3 is making toys
elf-6 is making toys
elf-5 is waiting for Santa
elf-10 at meeting
Santa is designing toys
elf-5 at meeting
elf-1 at meeting
elf-9 is waiting for Santa
elf-4 is waiting for Santa
reindeer-2 is waiting for Santa
elf-2 is waiting for Santa
...

From pavitar at pramati.com  Wed Apr  9 02:34:15 2008
From: pavitar at pramati.com (Pavitar Singh)
Date: Wed, 9 Apr 2008 12:04:15 +0530 (IST)
Subject: [concurrency-interest] readValueUnderLock in ConcurrentHashMap
In-Reply-To: <47FBCDAF.40307@redhat.com>
References: <31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCKECMHLAA.dcholmes@optusnet.com.au>	<31f2a7bd0804080041l2962f402rb98518ac6de0edad@mail.gmail.com>
	<1944.192.168.2.107.1207666627.squirrel@mail.pramati.com>
	<47FBCDAF.40307@redhat.com>
Message-ID: <46470.64.95.217.14.1207722855.squirrel@mail.pramati.com>

"Because they are final. Final fields are guaranteed to be visible as
long as the object is not published before the constructor has
completed."

But object has been published even before constructor is completed. As
Threads can see it by going through table(tab)?

> Pavitar Singh wrote:
>> Hi All,
>>
>> I didnt understand why do we need readUnderLock during get in
>> ConcurrentHashMap.
>>
>> "This is possible only if a compiler happens to reorder a HashEntry
>> initialization with its table assignment, which is legal under memory
>> model          but is not known to ever occur."  from the javadoc.
>>
>> Does that mean :
>> in put method .
>>
>> tab[index] will have a HashEntry , but not yet initialized (constructor
>> invoked)
>
> It means that the HashEntry will not be completely initialized. So the
> volatile variable read might see the default initial value, which is null.
>
>> if this is the case then how HashEntry hash and key will be visible in:
>> get method.
>> if (e.hash == hash && key.equals(e.key))
>>
>
> Because they are final. Final fields are guaranteed to be visible as
> long as the object is not published before the constructor has
> completed. See 17.5 of the JLS:
> http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.5
>
> --
> Jason T. Greene
> JBoss, a division of Red Hat
>


From jason.greene at redhat.com  Wed Apr  9 10:23:30 2008
From: jason.greene at redhat.com (Jason T. Greene)
Date: Wed, 09 Apr 2008 09:23:30 -0500
Subject: [concurrency-interest] readValueUnderLock in ConcurrentHashMap
In-Reply-To: <46470.64.95.217.14.1207722855.squirrel@mail.pramati.com>
References: <31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCKECMHLAA.dcholmes@optusnet.com.au>	<31f2a7bd0804080041l2962f402rb98518ac6de0edad@mail.gmail.com>
	<1944.192.168.2.107.1207666627.squirrel@mail.pramati.com>
	<47FBCDAF.40307@redhat.com>
	<46470.64.95.217.14.1207722855.squirrel@mail.pramati.com>
Message-ID: <47FCD162.8040904@redhat.com>

Pavitar Singh wrote:
> "Because they are final. Final fields are guaranteed to be visible as
> long as the object is not published before the constructor has
> completed."
> 
> But object has been published even before constructor is completed. As
> Threads can see it by going through table(tab)?

This is referring to the order as specified in the code (i.e. the 
guarantee does not apply if the constructor leaks "this"). Basically, a 
write to a final field in a constructor is not allowed to be re-orderd 
to occur after a write of the containing object that is after the 
constructor.

-- 
Jason T. Greene
JBoss, a division of Red Hat

From gregg at cytetech.com  Wed Apr  9 12:32:17 2008
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 09 Apr 2008 11:32:17 -0500
Subject: [concurrency-interest] santa clause problem solved?
In-Reply-To: <3cf41bb90804081519g43179d66i220548b4ab8c3264@mail.gmail.com>
References: <31f2a7bd0804071310v3160457aj168960d20871636@mail.gmail.com>
	<31f2a7bd0804071745t46c48a1fs40907f8e99f4fdca@mail.gmail.com>
	<31f2a7bd0804080032u1913cd76sf48d45916d2ed515@mail.gmail.com>
	<31f2a7bd0804080421k57fd3f7axae298b2930fae840@mail.gmail.com>
	<3cf41bb90804081519g43179d66i220548b4ab8c3264@mail.gmail.com>
Message-ID: <47FCEF91.7030801@cytetech.com>

jason marshall wrote:
> In the Ada example, Santa knows that there is work to be done (wakes
> up), and figures out which is more pressing.  They've elected Santa as
> the Actor in the solution, even though the original problem makes the
> elves and the reindeer the actors and Santa is more or less acted
> upon.  In doing so, they make the prioritization phase trivial, and I
> suspect that the 'right' Java solution has to find a way to work in
> the same manner.

It's easy enough to use a single signal with a multi-valued tag along value. 
When you get the signal, you always check if the reindeer are there first...

Gregg Wonderly

From TDugan at prospricing.com  Tue Apr 15 00:04:26 2008
From: TDugan at prospricing.com (Tim Dugan)
Date: Mon, 14 Apr 2008 23:04:26 -0500
Subject: [concurrency-interest] looking for a mapping between oswego
	concurrent lib and jdk 1.5
References: <D7CA8DF8C932594ABEEA9E0B0BC597BF018512E1@pros-mail.prosrm.com>
Message-ID: <D7CA8DF8C932594ABEEA9E0B0BC597BF7BEB75@pros-mail.prosrm.com>

Can anyone give me an explicit mapping between the Oswego concurrent lib and the newer concurrency features in JDK 1.5?  That is...which classes in one are called what in the other?

Thanks
-td

Tim Dugan | PROS | Real-Time Technical Lead, Product Development


-----Original Message-----
From: Doug Lea [mailto:dl at cs.oswego.edu]
Sent: Monday, April 14, 2008 3:00 PM
To: Tim Dugan
Subject: Re: looking for a mapping between your concurrent lib and jdk 1.5

Tim Dugan wrote:
> 
>
> Can you please help me?
>
> 
>
> I'm looking for a list that shows which of your concurrency classes were
> implemented in jdk 1.5 and what the new names are.
>
> 

I don't know offhand anyone who as done a detailed mapping,
but you might ask this on the concurrency-interest list
(See http://gee.cs.oswego.edu/dl/concurrency-interest/index.html to subscribe)

-Doug






The information contained in this email may be confidential and/or legally privileged. It has been sent for the sole use of the intended recipient(s). If the reader of this message is not an intended recipient, you are hereby notified that any unauthorized review, use, disclosure, dissemination, distribution, or copying of this communication, or any of its contents, is strictly prohibited. If you have received this communication in error, please contact the sender by reply email and destroy all copies of the original message. Thank you


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080414/9bd4c2c8/attachment.html 

From joe.bowbeer at gmail.com  Tue Apr 15 05:35:54 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 15 Apr 2008 02:35:54 -0700
Subject: [concurrency-interest] looking for a mapping between oswego
	concurrent lib and jdk 1.5
In-Reply-To: <D7CA8DF8C932594ABEEA9E0B0BC597BF7BEB75@pros-mail.prosrm.com>
References: <D7CA8DF8C932594ABEEA9E0B0BC597BF018512E1@pros-mail.prosrm.com>
	<D7CA8DF8C932594ABEEA9E0B0BC597BF7BEB75@pros-mail.prosrm.com>
Message-ID: <31f2a7bd0804150235l24a51f30nadbd26593966a7f4@mail.gmail.com>

On Mon, Apr 14, 2008 at 9:04 PM, Tim Dugan wrote:

>  Can anyone give me an explicit mapping between the Oswego concurrent lib
> and the newer concurrency features in JDK 1.5?  That is...which classes in
> one are called what in the other?
>
> Thanks
> -td
>
>

This page on updating "Concurrent Programming in Java" to Java 5 might be
helpful as an overview, even though it avoids providing an explicit forward
mapping:

http://gee.cs.oswego.edu/dl/cpj/updates.html

--Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080415/e0aaff3e/attachment.html 

From hallorant at gmail.com  Tue Apr 15 15:43:40 2008
From: hallorant at gmail.com (Tim Halloran)
Date: Tue, 15 Apr 2008 15:43:40 -0400
Subject: [concurrency-interest] ExecutorsTest JUnit test failure...What am I
	doing wrong?
Message-ID: <a36ab4bc0804151243s754b3392ledb6173c62eed9ea@mail.gmail.com>

I'm trying to work with the code at
:pserver:anonymous at gee.cs.oswego.edu:/export/home/jsr166/jsr166
under HEAD and I'm running into a test failure

    [junit] java version "1.6.0_05"
    [junit] Java(TM) SE Runtime Environment (build 1.6.0_05-b13)
    [junit] Java HotSpot(TM) Server VM (build 10.0-b19, mixed mode)
    [junit] Running ExecutorsTest
    [junit] Tests run: 32, Failures: 1, Errors: 0, Time elapsed: 1.851 sec
    [junit] Test ExecutorsTest FAILED

With the specific failure reported in XML as

<testcase classname="ExecutorsTest"
name="testCreatePrivilegedCallableUsingCCLWithNoPrivs" time="0.0050">
  <failure message="Should throw exception"
type="junit.framework.AssertionFailedError">junit.framework.AssertionFailedError:
Should throw exception
  at JSR166TestCase.shouldThrow(JSR166TestCase.java:329)
  at
ExecutorsTest.testCreatePrivilegedCallableUsingCCLWithNoPrivs(ExecutorsTest.java:466)
  </failure>
</testcase>

Strangely, I only get this failure when running the ant 'test' task.  When I
run the specific test case within Eclipse, the test passes.  Both ways of
execution are using the same JRE, however, the compilers are different.

I hope I'm doing something silly, please let me know if I am.

Best Regards,
Tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080415/c60ad4c6/attachment.html 

From dl at cs.oswego.edu  Tue Apr 15 19:08:26 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 15 Apr 2008 19:08:26 -0400
Subject: [concurrency-interest] ExecutorsTest JUnit test failure...What
 am I	doing wrong?
In-Reply-To: <a36ab4bc0804151243s754b3392ledb6173c62eed9ea@mail.gmail.com>
References: <a36ab4bc0804151243s754b3392ledb6173c62eed9ea@mail.gmail.com>
Message-ID: <4805356A.3020805@cs.oswego.edu>

Tim Halloran wrote:

> With the specific failure reported in XML as
> 
> <testcase classname="ExecutorsTest" 
> name="testCreatePrivilegedCallableUsingCCLWithNoPrivs" time="0.0050">

This test is sensitive to run settings.
It can fail if you have a .java directory with policies
that allow unverified etc code to run. You could try
temporarily moving such files or settings.

-Doug

From jason.greene at redhat.com  Wed Apr 16 13:46:25 2008
From: jason.greene at redhat.com (Jason T. Greene)
Date: Wed, 16 Apr 2008 12:46:25 -0500
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to 166 -
	Feedback Requested
Message-ID: <48063B71.3010004@redhat.com>

We are currently considering the inclusion of a ConcurrentReferenceMap 
into a JSR-166 update. This map supports any combination of weak, soft, 
or strong keys and values with similar performance characteristics to 
ConcurrentHashMap (non-blocking reads, striped writes etc). This map can 
also be configured to use identity checking instead of standard equality 
when locating keys (similar to IdentityHashMap).

At this point, we are looking for feedback, in particular on the API.

Some of the open questions are:

1) Should the IDENTITY_COMPARISONS option apply to values and keys, or 
just to keys as it does now? If not, should there be separate options 
for both?

2) Should the key reference type, and the value reference type be merged 
into the option enum, instead of providing separate parameters? This 
reduces the number of overloaded constructors, but introduces the 
problem of having a combination of mutually exclusive options (WEAK_KEYS 
+ SOFT_KEYS).

3) Should the configuration values be exposed via get methods so that 
calling code can introspect the map configuration? Currently none of the 
standard collections allow you to do this (load factor, etc).

4) Should behavioral options be exposed as booleans instead? With only 
one option this makes since; however, depending on the answer to 
question number 1, which would add another option, and some expected GC 
changes to the JVM that would add yet another one, this would introduce 
way too many overloaded constructors.

The javadoc for the initial version is available here:
http://www.stacksmash.com/jsr166y

The source code (public domain) is available here:
http://viewvc.jboss.org/cgi-bin/viewvc.cgi/jbosscache/experimental/jsr166/src/jsr166y/ConcurrentReferenceHashMap.java?view=markup

It should be noted that the API and implementation are extremely subject 
to change, and are also of pre-release quality, so it is not recommended 
for production usage. Also, these links are just temporary.

Thanks!

-- 
Jason T. Greene
JBoss, a division of Red Hat

From dl at cs.oswego.edu  Wed Apr 16 15:33:49 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 16 Apr 2008 15:33:49 -0400 (EDT)
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
 166 - Feedback Requested
In-Reply-To: <48063B71.3010004@redhat.com>
References: <48063B71.3010004@redhat.com>
Message-ID: <34428.24.213.141.35.1208374429.squirrel@cs.oswego.edu>

> We are currently considering the inclusion of a ConcurrentReferenceMap

Jason, thanks for taking this on!

Background for others: We've discussed adding such a class for years,
but have stalled each time for one reason or another. It is great
to see Jason shrugging off the reasons to stall and  putting together
a good candidate (that can be updated if for example ephemeron-like
weak refs are supported).

Suggestions and comments are welcome to try to nail down the
APIs.

-Doug



From TDugan at prospricing.com  Wed Apr 16 16:24:02 2008
From: TDugan at prospricing.com (Tim Dugan)
Date: Wed, 16 Apr 2008 15:24:02 -0500
Subject: [concurrency-interest] looking for a mapping between
	oswegoconcurrent lib and jdk 1.5
In-Reply-To: <31f2a7bd0804150235l24a51f30nadbd26593966a7f4@mail.gmail.com>
References: <D7CA8DF8C932594ABEEA9E0B0BC597BF7BEB75@pros-mail.prosrm.com>
	<31f2a7bd0804150235l24a51f30nadbd26593966a7f4@mail.gmail.com>
Message-ID: <D7CA8DF8C932594ABEEA9E0B0BC597BF01851303@pros-mail.prosrm.com>

 

Thanks.  I've seen that and other information describing the java
concurrent library already...

 

I was hoping to find an explicit mapping of which class in JDK15 can
replace which class in the original concurrent library.

 

Tim Dugan | PROS | Real-Time Technical Lead, Product Development

________________________________

From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Joe
Bowbeer
Sent: Tuesday, April 15, 2008 4:36 AM
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] looking for a mapping between
oswegoconcurrent lib and jdk 1.5

 

On Mon, Apr 14, 2008 at 9:04 PM, Tim Dugan wrote:

	Can anyone give me an explicit mapping between the Oswego
concurrent lib and the newer concurrency features in JDK 1.5?  That
is...which classes in one are called what in the other?
	
	Thanks
	-td



This page on updating "Concurrent Programming in Java" to Java 5 might
be helpful as an overview, even though it avoids providing an explicit
forward mapping:

http://gee.cs.oswego.edu/dl/cpj/updates.html

--Joe



The information contained in this email may be confidential and/or legally privileged. It has been sent for the sole use of the intended recipient(s). If the reader of this message is not an intended recipient, you are hereby notified that any unauthorized review, use, disclosure, dissemination, distribution, or copying of this communication, or any of its contents, is strictly prohibited. If you have received this communication in error, please contact the sender by reply email and destroy all copies of the original message. Thank you


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080416/a0cab53c/attachment.html 

From jason_mehrens at hotmail.com  Wed Apr 16 16:53:35 2008
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Wed, 16 Apr 2008 15:53:35 -0500
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
 166 -	Feedback Requested
Message-ID: <BLU134-W31F80D3ABE77F37AD7BC8383EA0@phx.gbl>


Jason
 
Here is my $0.02. > 1) Should the IDENTITY_COMPARISONS option apply to values and keys, or > just to keys as it does now? If not, should there be separate options > for both?
 
It has reference in the name so I would only allow identity comparisons.
> > 2) Should the key reference type, and the value reference type be merged > into the option enum, instead of providing separate parameters? This > reduces the number of overloaded constructors, but introduces the > problem of having a combination of mutually exclusive options (WEAK_KEYS > + SOFT_KEYS).
 
Probably should keep key type and value type as separate parameters.
Why not use the class type of the references.
I.E. ReferenceMap.newMap(WeakReference.class, Reference.class) //weak keys, strong values.
Maybe that is too much of an enum anti-pattern.
> > 3) Should the configuration values be exposed via get methods so that > calling code can introspect the map configuration? Currently none of the > standard collections allow you to do this (load factor, etc).> No.  
 
-Jason Mehrens
_________________________________________________________________
Get in touch in an instant. Get Windows Live Messenger now.
http://www.windowslive.com/messenger/overview.html?ocid=TXT_TAGLM_WL_Refresh_getintouch_042008
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080416/d235bcea/attachment.html 

From jason.greene at redhat.com  Wed Apr 16 17:39:13 2008
From: jason.greene at redhat.com (Jason T. Greene)
Date: Wed, 16 Apr 2008 16:39:13 -0500
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
 166 -	Feedback Requested
In-Reply-To: <BLU134-W31F80D3ABE77F37AD7BC8383EA0@phx.gbl>
References: <BLU134-W31F80D3ABE77F37AD7BC8383EA0@phx.gbl>
Message-ID: <48067201.8090202@redhat.com>

Jason Mehrens wrote:
> Jason
>  
> Here is my $0.02.

Thanks for the feedback!

>  > 1) Should the IDENTITY_COMPARISONS option apply to values and keys, or
>  > just to keys as it does now? If not, should there be separate options
>  > for both?
>  
> It has reference in the name so I would only allow identity comparisons.

There are a number of good use cases that need standard equality. A 
couple of examples are:

- Soft cache using keys that potentially come from serialization
- An intern pool. (e.g. String.intern())

Also, the general contract of Map requires standard equality 
(technically identity maps violate this contract). So IMO we should 
continue to support this behavior.

> 
>  >
>  > 2) Should the key reference type, and the value reference type be merged
>  > into the option enum, instead of providing separate parameters? This
>  > reduces the number of overloaded constructors, but introduces the
>  > problem of having a combination of mutually exclusive options (WEAK_KEYS
>  > + SOFT_KEYS).
>  
> Probably should keep key type and value type as separate parameters.

Ok.

> Why not use the class type of the references.
> I.E. ReferenceMap.newMap(WeakReference.class, Reference.class) //weak 
> keys, strong values.
> Maybe that is too much of an enum anti-pattern.

Clever/interesting idea. Although, I still think an enum is better 
because you immediately know all possible values, and you have nice 
static type checking.

> 
>  >
>  > 3) Should the configuration values be exposed via get methods so that
>  > calling code can introspect the map configuration? Currently none of the
>  > standard collections allow you to do this (load factor, etc).
>  >
> No. 

Ok, Thanks again.

-- 
Jason T. Greene
JBoss, a division of Red Hat

From jed at atlassian.com  Wed Apr 16 23:28:25 2008
From: jed at atlassian.com (Jed Wesley-Smith)
Date: Thu, 17 Apr 2008 13:28:25 +1000
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
 166 -	Feedback Requested
In-Reply-To: <48067201.8090202@redhat.com>
References: <BLU134-W31F80D3ABE77F37AD7BC8383EA0@phx.gbl>
	<48067201.8090202@redhat.com>
Message-ID: <4806C3D9.1090104@atlassian.com>

Jason T. Greene wrote:
> Jason Mehrens wrote:
>   
>> Why not use the class type of the references.
>> I.E. ReferenceMap.newMap(WeakReference.class, Reference.class) //weak 
>> keys, strong values.
>> Maybe that is too much of an enum anti-pattern.
>>     
>
> Clever/interesting idea. Although, I still think an enum is better 
> because you immediately know all possible values, and you have nice 
> static type checking.
>   


Wouldn't something like the following on ReferenceType give the same 
benefit:

public static ReferenceType forRef(final Class<?> klass) {
    if (WeakReference.class.isAssignableFrom(klass)) {
        return WEAK;
    }
    if (SoftReference.class.isAssignableFrom(klass)) {
         return SOFT;
    }
    // maybe throw IllegalArg if not a Reference class???
    return STRONG;
}

Then you could also have a newMap(Class<?> keyRefClass, Class<?> 
valueRefClass) method
if required.

cheers,
jed.

From dhanji at gmail.com  Thu Apr 17 02:40:04 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 17 Apr 2008 16:40:04 +1000
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
	166 - Feedback Requested
In-Reply-To: <48067201.8090202@redhat.com>
References: <BLU134-W31F80D3ABE77F37AD7BC8383EA0@phx.gbl>
	<48067201.8090202@redhat.com>
Message-ID: <aa067ea10804162340u3be7765ax884b5adc3a95e498@mail.gmail.com>

Hi Jason (Greene)
This is cool =)
I also prefer the enum as it is a tight contract.

Btw, doesn't google-collections have a similar utility? I notice that it
uses a composition pattern with CHM, and that your version does not. Can I
ask about the motivation for this? (I presume, without due research, that a
similar lock-striping strategy to CHM is in use?)

Dhanji.

On Thu, Apr 17, 2008 at 7:39 AM, Jason T. Greene <jason.greene at redhat.com>
wrote:

> Jason Mehrens wrote:
> > Jason
> >
> > Here is my $0.02.
>
> Thanks for the feedback!
>
> >  > 1) Should the IDENTITY_COMPARISONS option apply to values and keys,
> or
> >  > just to keys as it does now? If not, should there be separate options
> >  > for both?
> >
> > It has reference in the name so I would only allow identity comparisons.
>
> There are a number of good use cases that need standard equality. A
> couple of examples are:
>
> - Soft cache using keys that potentially come from serialization
> - An intern pool. (e.g. String.intern())
>
> Also, the general contract of Map requires standard equality
> (technically identity maps violate this contract). So IMO we should
> continue to support this behavior.
>
> >
> >  >
> >  > 2) Should the key reference type, and the value reference type be
> merged
> >  > into the option enum, instead of providing separate parameters? This
> >  > reduces the number of overloaded constructors, but introduces the
> >  > problem of having a combination of mutually exclusive options
> (WEAK_KEYS
> >  > + SOFT_KEYS).
> >
> > Probably should keep key type and value type as separate parameters.
>
> Ok.
>
> > Why not use the class type of the references.
> > I.E. ReferenceMap.newMap(WeakReference.class, Reference.class) //weak
> > keys, strong values.
> > Maybe that is too much of an enum anti-pattern.
>
> Clever/interesting idea. Although, I still think an enum is better
> because you immediately know all possible values, and you have nice
> static type checking.
>
> >
> >  >
> >  > 3) Should the configuration values be exposed via get methods so that
> >  > calling code can introspect the map configuration? Currently none of
> the
> >  > standard collections allow you to do this (load factor, etc).
> >  >
> > No.
>
> Ok, Thanks again.
>
> --
> Jason T. Greene
> JBoss, a division of Red Hat
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080417/1fcecedd/attachment-0001.html 

From hallorant at gmail.com  Thu Apr 17 09:21:35 2008
From: hallorant at gmail.com (Tim Halloran)
Date: Thu, 17 Apr 2008 09:21:35 -0400
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
	166 - Feedback Requested
In-Reply-To: <48063B71.3010004@redhat.com>
References: <48063B71.3010004@redhat.com>
Message-ID: <a36ab4bc0804170621y5113c89kd0a6a19913060f63@mail.gmail.com>

Working with this code, I propose a few (attached) changes for folks to try
out, I sent this to Jason earlier, but here it is for everyone to
examine/critique.

1) Three accessors have been added to allow client code to interrogate the
collection about its options: usingReferenceEquality(),
getKeyReferenceType(), and getValueReferenceType();  Since this is a general
purpose collection these should be able to be interrogated.

2) The Option enum is now just a boolean.  It sounds like the addition of
ephemeron-like weak refs would add another type to ReferenceType Enum.  Also
if a lot of options are added later, the this option enum could be added.
EnumSet won't clash with a current constructor, and the internal
representation of the use reference equality is just a boolean in the
current implementation.  Also the special constructor are probably still
desired, even after that change is made.

3) I added two new constructors:

  public ConcurrentReferenceHashMap(boolean useReferenceEquality)
  public ConcurrentReferenceHashMap(ReferenceType keyReferenceType,
            ReferenceType valueReferenceType, boolean useReferenceEquality)

which are helpful if reference-equality is being used.

4) I tried to make the discussion of reference-equality and object-equality
consistent with Josh Bloch's comments on IdentityHashMap.  I also changed
some field parameter names in this area as part of this effort.  I had
trouble following the variable naming in this area.

5) I did a pass through the Javadoc on the class and on the new
methods/constructors to be clearer.

The test cases I was using are also attached.

Issues I'd like to highlight are:

o The reference-equality option only affects keys at the moment.  (Jason
brought this up in an earlier email; I have not looked into this too much
yet)

o No test cases test the reference-equality option.

o The implementation passes its options into the segments.  Since there are
two references and a boolean, a reference to the outer class might be
cheaper, requiring only one reference.  I did NOT change this, just a note
for consideration.

o The local variables "sum" and "c" (two times) at lines 1248, 1251, and
1259 are never read.  I didn't remove them as this same three unused local
variables exist in ConcurrentHashMap (at lines 807, 810, and 819).  I think
these declarations can be safely removed, but I've been wrong before :-)

Best Regards,
Tim


On Wed, Apr 16, 2008 at 1:46 PM, Jason T. Greene <jason.greene at redhat.com>
wrote:

> We are currently considering the inclusion of a ConcurrentReferenceMap
> into a JSR-166 update. This map supports any combination of weak, soft,
> or strong keys and values with similar performance characteristics to
> ConcurrentHashMap (non-blocking reads, striped writes etc). This map can
> also be configured to use identity checking instead of standard equality
> when locating keys (similar to IdentityHashMap).
>
> At this point, we are looking for feedback, in particular on the API.
>
> Some of the open questions are:
>
> 1) Should the IDENTITY_COMPARISONS option apply to values and keys, or
> just to keys as it does now? If not, should there be separate options
> for both?
>
> 2) Should the key reference type, and the value reference type be merged
> into the option enum, instead of providing separate parameters? This
> reduces the number of overloaded constructors, but introduces the
> problem of having a combination of mutually exclusive options (WEAK_KEYS
> + SOFT_KEYS).
>
> 3) Should the configuration values be exposed via get methods so that
> calling code can introspect the map configuration? Currently none of the
> standard collections allow you to do this (load factor, etc).
>
> 4) Should behavioral options be exposed as booleans instead? With only
> one option this makes since; however, depending on the answer to
> question number 1, which would add another option, and some expected GC
> changes to the JVM that would add yet another one, this would introduce
> way too many overloaded constructors.
>
> The javadoc for the initial version is available here:
> http://www.stacksmash.com/jsr166y
>
> The source code (public domain) is available here:
>
> http://viewvc.jboss.org/cgi-bin/viewvc.cgi/jbosscache/experimental/jsr166/src/jsr166y/ConcurrentReferenceHashMap.java?view=markup
>
> It should be noted that the API and implementation are extremely subject
> to change, and are also of pre-release quality, so it is not recommended
> for production usage. Also, these links are just temporary.
>
> Thanks!
>
> --
> Jason T. Greene
> JBoss, a division of Red Hat
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080417/32233f6d/attachment-0001.html 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ConcurrentReferenceHashMap.java
Type: application/octet-stream
Size: 60418 bytes
Desc: not available
Url : /pipermail/attachments/20080417/32233f6d/attachment-0003.obj 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ConcurrentReferenceHashMapGCTestCase.java
Type: application/octet-stream
Size: 5003 bytes
Desc: not available
Url : /pipermail/attachments/20080417/32233f6d/attachment-0004.obj 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ConcurrentReferenceHashMapTest.java
Type: application/octet-stream
Size: 17955 bytes
Desc: not available
Url : /pipermail/attachments/20080417/32233f6d/attachment-0005.obj 

From jason.greene at redhat.com  Thu Apr 17 10:32:54 2008
From: jason.greene at redhat.com (Jason T. Greene)
Date: Thu, 17 Apr 2008 09:32:54 -0500
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
 166 - Feedback Requested
In-Reply-To: <aa067ea10804162340u3be7765ax884b5adc3a95e498@mail.gmail.com>
References: <BLU134-W31F80D3ABE77F37AD7BC8383EA0@phx.gbl>	
	<48067201.8090202@redhat.com>
	<aa067ea10804162340u3be7765ax884b5adc3a95e498@mail.gmail.com>
Message-ID: <48075F96.2050604@redhat.com>

Dhanji R. Prasanna wrote:
> Hi Jason (Greene)
> 
> This is cool =)
 >
> I also prefer the enum as it is a tight contract. 
> 
> Btw, doesn't google-collections have a similar utility? > I notice that it 
> uses a composition pattern with CHM, and that your version does not. 

Yes, for others that are interested. Google has a similar table here 
(under ASL):
http://google-collections.googlecode.com/svn/trunk/src/com/google/common/collect/ReferenceMap.java

It uses a delegation approach which is more limiting:
- Can't do standard equality with weak/soft types
- Requires a separate application thread for stale entry cleanup
- Needs a lot of extra method dispatch

Doug and I have been talking with some of the folks at Google about 
this. They have been after a standardized solution as well.

 > Can I ask about the motivation for this? (I presume, without due 
research,
 > that a similar lock-striping strategy to CHM is in use?)

The motivation is to maximize performance, and solve the above issues. 
It's actually a derivative of the CHM code, so pretty much the same 
performance aspects, with of course some small additional overhead for 
tracking references. So, reads are non-blocking, writes are striped. 
Each segment has it's own reference queue that is lazily purged when a 
lock is acquired on that segment. There is also a purgeStaleEntries() 
method that can be called from any thread should an application wish to 
do this eagerly, although this triggers a lock acquisition on all 
segments, one at a time.

-- 
Jason T. Greene
JBoss, a division of Red Hat

From crazybob at crazybob.org  Thu Apr 17 12:06:47 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Thu, 17 Apr 2008 09:06:47 -0700
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
	166 - Feedback Requested
In-Reply-To: <48075F96.2050604@redhat.com>
References: <BLU134-W31F80D3ABE77F37AD7BC8383EA0@phx.gbl>
	<48067201.8090202@redhat.com>
	<aa067ea10804162340u3be7765ax884b5adc3a95e498@mail.gmail.com>
	<48075F96.2050604@redhat.com>
Message-ID: <a74683f90804170906p7a55df0ck47deb44cdfc2cbe0@mail.gmail.com>

On Thu, Apr 17, 2008 at 7:32 AM, Jason T. Greene <jason.greene at redhat.com>
wrote:

> - Can't do standard equality with weak/soft


Standard equality doesn't make sense for weak/soft. Weak/soft references are
fundamentally identity based.

You're "interning" use case is a red herring--ReferenceMap is not an
efficient way to implement that.


> - Requires a separate application thread for stale entry cleanup


We use one thread for the whole VM (or optionally more threads). The VM
could even reuse it's reference-enqueing thread like it does for other
internal things. You have a *concurrent* map now. Why make clients do the
work and make the durations of their operations less consistent?


> - Needs a lot of extra method dispatch


I agree that it should not delegate, but I doubt we need to copy CHM 100%,
especially if we're in the same package.


> Doug and I have been talking with some of the folks at Google about
> this. They have been after a standardized solution as well.
>

I've talked to Doug, in that I've sent him a couple ReferenceMap revisions
for review over the past three years. His latest feedback was that he wanted
to wait for the new key/value reference type he's been working on, so we've
been holding off for that.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080417/dcdf5229/attachment.html 

From Thomas.Hawtin at Sun.COM  Thu Apr 17 14:28:15 2008
From: Thomas.Hawtin at Sun.COM (Tom Hawtin)
Date: Thu, 17 Apr 2008 19:28:15 +0100
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
 166 - Feedback Requested
In-Reply-To: <a74683f90804170906p7a55df0ck47deb44cdfc2cbe0@mail.gmail.com>
References: <BLU134-W31F80D3ABE77F37AD7BC8383EA0@phx.gbl>
	<48067201.8090202@redhat.com>
	<aa067ea10804162340u3be7765ax884b5adc3a95e498@mail.gmail.com>
	<48075F96.2050604@redhat.com>
	<a74683f90804170906p7a55df0ck47deb44cdfc2cbe0@mail.gmail.com>
Message-ID: <480796BF.1020606@sun.com>

Bob Lee wrote:
> On Thu, Apr 17, 2008 at 7:32 AM, Jason T. Greene 
> <jason.greene at redhat.com <mailto:jason.greene at redhat.com>> wrote:
> 
>     - Can't do standard equality with weak/soft 
> 
> 
> Standard equality doesn't make sense for weak/soft. Weak/soft references 
> are fundamentally identity based.

Weak certainly. But for soft?

> I agree that it should not delegate, but I doubt we need to copy CHM 
> 100%, especially if we're in the same package.

If it was exposed through an interface and static creation methods (plus 
a serial proxy), the implementation strategy could be hidden. 
Optimisation tradeoffs could then be switched later. OTOH, that is 
different from existing collections.

> I've talked to Doug, in that I've sent him a couple ReferenceMap 
> revisions for review over the past three years. His latest feedback was 
> that he wanted to wait for the new key/value reference type he's been 
> working on, so we've been holding off for that.

http://bugs.sun.com/view_bug.do?bug_id=4630118

If that works out, it makes many things easier.


There's an interesting point from Cliff Click:

http://blogs.azulsystems.com/cliff/2007/08/why-weakhashmap.html

If you "touch" a WeakReference you potentially prevent it from being 
cleared briefly. So there is some danger of ending up with an all 
singing/dancing map and ending up placing a unique WeakReference in the 
key so we never actually have to call get on it.

Tom

From jason.greene at redhat.com  Thu Apr 17 14:49:19 2008
From: jason.greene at redhat.com (Jason T. Greene)
Date: Thu, 17 Apr 2008 13:49:19 -0500
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
 166 - Feedback Requested
In-Reply-To: <a74683f90804170906p7a55df0ck47deb44cdfc2cbe0@mail.gmail.com>
References: <BLU134-W31F80D3ABE77F37AD7BC8383EA0@phx.gbl>	
	<48067201.8090202@redhat.com>	
	<aa067ea10804162340u3be7765ax884b5adc3a95e498@mail.gmail.com>	
	<48075F96.2050604@redhat.com>
	<a74683f90804170906p7a55df0ck47deb44cdfc2cbe0@mail.gmail.com>
Message-ID: <48079BAF.20300@redhat.com>

Bob Lee wrote:
> On Thu, Apr 17, 2008 at 7:32 AM, Jason T. Greene 
> <jason.greene at redhat.com <mailto:jason.greene at redhat.com>> wrote:
> 
>     - Can't do standard equality with weak/soft 
> 
> 
> Standard equality doesn't make sense for weak/soft. Weak/soft references 
> are fundamentally identity based.

I disagree. I think object lifetime and equality are orthogonal. Just 
because a key can be collected earlier than a normal java reference, 
does not mean that a map containing it should allow semantical 
duplicates, or not resolve an object that is semantically equivalent to 
a key.

> 
> You're "interning" use case is a red herring--ReferenceMap is not an 
> efficient way to implement that.

I am referring to an intern pool that does not grow without bounds 
(could be soft or weak), not the exact implementation of String.intern().

Don't forget the soft key cache. If there is no guarantee you are 
reusing the same instance (objects can come from serialization, user 
code, etc), then you are wasting memory and having a higher chance of a 
cache miss.

>  
> 
>     - Requires a separate application thread for stale entry cleanup
> 
> 
> We use one thread for the whole VM (or optionally more threads). The VM 
> could even reuse it's reference-enqueing thread like it does for other 
> internal things. You have a *concurrent* map now. Why make clients do 
> the work and make the durations of their operations less consistent?

It's not a huge deal to require one additional thread, however as more 
and more frameworks do this, it creates a problem in a shared 
environment. Then once you need a pool you now have yet another 
management aspect. So for this to be practical IMO it needs to be part 
of the JVM.

I think the reason reusing the enqueing thread has not been easily 
exposed is that it could be stalled by application code. Although this 
particular case is most likely not an issue for a concurrent table 
modification.

The goal of the lazy implementation is to self-scale, since cleanup is 
reusing mutating threads. It also has a nice secondary benefits of not 
requiring changes to the reference system, so the candidate is easily 
backported (the implementation I posted runs on JDK5). Yet another 
benefit is it will be *very* easy to retrofit it to use ephemerons.

I do see your point that it can effect expected duration of operations, 
so this is definitely something that requires further investigation. 
However, I think we should sideline this, and focus on the API, which 
should be the same no matter what cleanup approach we take.

> 
>     - Needs a lot of extra method dispatch
> 
> 
> I agree that it should not delegate, but I doubt we need to copy CHM 
> 100%, especially if we're in the same package.

It's important that CHM and any kind of concurrent reference map not 
share implementation, so that they can evolve separately, which is very 
likely to happen with all of the wait-free work going on right now.

> 
>     Doug and I have been talking with some of the folks at Google about
>     this. They have been after a standardized solution as well.
> 
> 
> I've talked to Doug, in that I've sent him a couple ReferenceMap 
> revisions for review over the past three years. His latest feedback was 
> that he wanted to wait for the new key/value reference type he's been 
> working on, so we've been holding off for that.

The last thread I saw, he was asking you and Kevin for feedback 
(specifically API feedback), and since you had not yet responded, and 
others where asking for this functionality, we decided to move the 
discussion here.

-- 
Jason T. Greene
JBoss, a division of Red Hat

From crazybob at crazybob.org  Thu Apr 17 16:21:40 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Thu, 17 Apr 2008 13:21:40 -0700
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
	166 - Feedback Requested
In-Reply-To: <48079BAF.20300@redhat.com>
References: <BLU134-W31F80D3ABE77F37AD7BC8383EA0@phx.gbl>
	<48067201.8090202@redhat.com>
	<aa067ea10804162340u3be7765ax884b5adc3a95e498@mail.gmail.com>
	<48075F96.2050604@redhat.com>
	<a74683f90804170906p7a55df0ck47deb44cdfc2cbe0@mail.gmail.com>
	<48079BAF.20300@redhat.com>
Message-ID: <a74683f90804171321u6e84d5b5o45a6184b4e62caa3@mail.gmail.com>

On Thu, Apr 17, 2008 at 11:49 AM, Jason T. Greene <jason.greene at redhat.com>
wrote:

> I disagree. I think object lifetime and equality are orthogonal. Just
> because a key can be collected earlier than a normal java reference, does
> not mean that a map containing it should allow semantical duplicates, or not
> resolve an object that is semantically equivalent to a key.
>

You might be right, but after three years of heavy use, we have yet to
encounter a use case which supports your assertion that we want equality
instead of identity comparisons for weak and soft references. Not that it's
not trivial to support both strategies, but I do like to steer users in the
right direction. I've found that users have always needed identity
comparisons, and I've also seen cases where using equality with weak
references would have introduced subtle bugs (Class objects for example).


> You're "interning" use case is a red herring--ReferenceMap is not an
>> efficient way to implement that.
>>
>
> I am referring to an intern pool that does not grow without bounds (could
> be soft or weak), not the exact implementation of String.intern().
>

I knew what you meant. We implement that sort of thing more efficiently and
cleanly with a different data structure, so we shouldn't bend ReferenceMap
too hard toward that use case.


> It's not a huge deal to require one additional thread, however as more and
> more frameworks do this, it creates a problem in a shared environment. Then
> once you need a pool you now have yet another management aspect. So for this
> to be practical IMO it needs to be part of the JVM.
>

Like I said, we only need one thread here for the whole VM and we can even
reuse an existing thread and avoid the overhead of a reference queue.


> The goal of the lazy implementation is to self-scale, since cleanup is
> reusing mutating threads. It also has a nice secondary benefits of not
> requiring changes to the reference system, so the candidate is easily
> backported (the implementation I posted runs on JDK5).


We've been running ReferenceMap on Java 5 for years.

The last thread I saw, he was asking you and Kevin for feedback
> (specifically API feedback), and since you had not yet responded, and others
> where asking for this functionality, we decided to move the discussion here.


I was forwarded an email where you sent out what amounted to a concurrent
version of WeakHashMap, and we provided feedback--we pointed you to
ReferenceMap.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080417/63997d86/attachment.html 

From crazybob at crazybob.org  Thu Apr 17 16:21:40 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Thu, 17 Apr 2008 13:21:40 -0700
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
	166 - Feedback Requested
In-Reply-To: <48079BAF.20300@redhat.com>
References: <BLU134-W31F80D3ABE77F37AD7BC8383EA0@phx.gbl>
	<48067201.8090202@redhat.com>
	<aa067ea10804162340u3be7765ax884b5adc3a95e498@mail.gmail.com>
	<48075F96.2050604@redhat.com>
	<a74683f90804170906p7a55df0ck47deb44cdfc2cbe0@mail.gmail.com>
	<48079BAF.20300@redhat.com>
Message-ID: <a74683f90804171321u6e84d5b5o45a6184b4e62caa3@mail.gmail.com>

On Thu, Apr 17, 2008 at 11:49 AM, Jason T. Greene <jason.greene at redhat.com>
wrote:

> I disagree. I think object lifetime and equality are orthogonal. Just
> because a key can be collected earlier than a normal java reference, does
> not mean that a map containing it should allow semantical duplicates, or not
> resolve an object that is semantically equivalent to a key.
>

You might be right, but after three years of heavy use, we have yet to
encounter a use case which supports your assertion that we want equality
instead of identity comparisons for weak and soft references. Not that it's
not trivial to support both strategies, but I do like to steer users in the
right direction. I've found that users have always needed identity
comparisons, and I've also seen cases where using equality with weak
references would have introduced subtle bugs (Class objects for example).


> You're "interning" use case is a red herring--ReferenceMap is not an
>> efficient way to implement that.
>>
>
> I am referring to an intern pool that does not grow without bounds (could
> be soft or weak), not the exact implementation of String.intern().
>

I knew what you meant. We implement that sort of thing more efficiently and
cleanly with a different data structure, so we shouldn't bend ReferenceMap
too hard toward that use case.


> It's not a huge deal to require one additional thread, however as more and
> more frameworks do this, it creates a problem in a shared environment. Then
> once you need a pool you now have yet another management aspect. So for this
> to be practical IMO it needs to be part of the JVM.
>

Like I said, we only need one thread here for the whole VM and we can even
reuse an existing thread and avoid the overhead of a reference queue.


> The goal of the lazy implementation is to self-scale, since cleanup is
> reusing mutating threads. It also has a nice secondary benefits of not
> requiring changes to the reference system, so the candidate is easily
> backported (the implementation I posted runs on JDK5).


We've been running ReferenceMap on Java 5 for years.

The last thread I saw, he was asking you and Kevin for feedback
> (specifically API feedback), and since you had not yet responded, and others
> where asking for this functionality, we decided to move the discussion here.


I was forwarded an email where you sent out what amounted to a concurrent
version of WeakHashMap, and we provided feedback--we pointed you to
ReferenceMap.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080417/63997d86/attachment-0003.html 

From markus.kohler at gmail.com  Fri Apr 18 02:59:45 2008
From: markus.kohler at gmail.com (Markus Kohler)
Date: Fri, 18 Apr 2008 08:59:45 +0200
Subject: [concurrency-interest] ConcurrentReferenceMap enhancement to
	166 - Feedback Requested
In-Reply-To: <a74683f90804171321u6e84d5b5o45a6184b4e62caa3@mail.gmail.com>
References: <BLU134-W31F80D3ABE77F37AD7BC8383EA0@phx.gbl>
	<48067201.8090202@redhat.com>
	<aa067ea10804162340u3be7765ax884b5adc3a95e498@mail.gmail.com>
	<48075F96.2050604@redhat.com>
	<a74683f90804170906p7a55df0ck47deb44cdfc2cbe0@mail.gmail.com>
	<48079BAF.20300@redhat.com>
	<a74683f90804171321u6e84d5b5o45a6184b4e62caa3@mail.gmail.com>
Message-ID: <771905290804172359p4bf63e7lfe8cdd609e64d5df@mail.gmail.com>

Hi Bob,


On Thu, Apr 17, 2008 at 10:21 PM, Bob Lee <crazybob at crazybob.org> wrote:

> On Thu, Apr 17, 2008 at 11:49 AM, Jason T. Greene <jason.greene at redhat.com>
> wrote:
>
> > I disagree. I think object lifetime and equality are orthogonal. Just
> > because a key can be collected earlier than a normal java reference, does
> > not mean that a map containing it should allow semantical duplicates, or not
> > resolve an object that is semantically equivalent to a key.
> >
>
> You might be right, but after three years of heavy use, we have yet to
> encounter a use case which supports your assertion that we want equality
> instead of identity comparisons for weak and soft references. Not that it's
> not trivial to support both strategies, but I do like to steer users in the
> right direction. I've found that users have always needed identity
> comparisons, and I've also seen cases where using equality with weak
> references would have introduced subtle bugs (Class objects for example).
>
>
> > You're "interning" use case is a red herring--ReferenceMap is not an
> > > efficient way to implement that.
> > >
> >
> > I am referring to an intern pool that does not grow without bounds
> > (could be soft or weak), not the exact implementation of String.intern().
> >
>
> I knew what you meant. We implement that sort of thing more efficiently
> and cleanly with a different data structure, so we shouldn't bend
> ReferenceMap too hard toward that use case.
>

That sounds very interesting. Can you give us more detail about the data
structure used, or is that confidential ?
We  (SAP) have a special String.intern implementation in our JVM to
implement a pool of Strings efficiently. We considered just using a
WeakConcurrentHashmap implementation,but found the memory overhead per
String would be rather large.

I just got an idea some days ago, how we could reduce the number of Weak
references by loosening the contract of String.intern() .We don't need
actually the exact contract of String.intern for our String pooling
mechanism.

Regards,
Markus


>
> > It's not a huge deal to require one additional thread, however as more
> > and more frameworks do this, it creates a problem in a shared environment.
> > Then once you need a pool you now have yet another management aspect. So for
> > this to be practical IMO it needs to be part of the JVM.
> >
>
> Like I said, we only need one thread here for the whole VM and we can even
> reuse an existing thread and avoid the overhead of a reference queue.
>
>
> > The goal of the lazy implementation is to self-scale, since cleanup is
> > reusing mutating threads. It also has a nice secondary benefits of not
> > requiring changes to the reference system, so the candidate is easily
> > backported (the implementation I posted runs on JDK5).
>
>
> We've been running ReferenceMap on Java 5 for years.
>
> The last thread I saw, he was asking you and Kevin for feedback
> > (specifically API feedback), and since you had not yet responded, and others
> > where asking for this functionality, we decided to move the discussion here.
>
>
> I was forwarded an email where you sent out what amounted to a concurrent
> version of WeakHashMap, and we provided feedback--we pointed you to
> ReferenceMap.
>
> Bob
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080418/029e5fd6/attachment.html 

From dawid.kurzyniec at gmail.com  Sun Apr 20 16:15:07 2008
From: dawid.kurzyniec at gmail.com (Dawid Kurzyniec)
Date: Sun, 20 Apr 2008 22:15:07 +0200
Subject: [concurrency-interest] backport: what is the best way to
	acknowledge usage of backport?
In-Reply-To: <47D7C871.9010207@gmail.com>
References: <47D7C871.9010207@gmail.com>
Message-ID: <3cbaca580804201315l591cd31aw489e2ff15c41832f@mail.gmail.com>

Yes.

(And sorry for delayed response).

Regards,
Dawid


On Wed, Mar 12, 2008 at 2:11 PM, Tom Seelbach <tom.seelbach at gmail.com> wrote:
> Hi,
>  Apache Axis2 was recently updated to depend on backport-util-concurrent
>  3.1 instead of 2.2.   Axis2 distributes a copy of a backport license
>  like this:
>  http://svn.apache.org/viewvc/webservices/axis2/trunk/java/legal/backport-util-concurrent-LICENSE.txt?revision=553578&view=markup
>
>
>  Looks like its outdated.  I looked at the backport 3.1 code and README
>  and it seems that the attribution to Sun for the CopyOnWriteArrayList
>  hasn't been needed since 2.0_01?
>
>  Could someone recommend the best way to update the axis2 license for
>  backport?
>  I see some relevant info in 3 files: LEGAL, README.html (License
>  section) and LICENSE.html.
>  It's kinda confusing to have the legal and license info in 3 files.
>  Maybe it's best that in axis2 we combine them like this:
>
>  ========================================================
>  Acknowledgements:
>  backport-util-concurrent is based in large part on the public
>  domain sources from:
>    1) JSR166,
>    2) package dl.util.concurrent,
>    3) Doug Lea's "collections" package.
>
>  This software is released to the public domain
>  ( http://creativecommons.org/licenses/publicdomain )
>  in the spirit of the original code written by Doug Lea.
>  The code can be used for any purpose, modified, and redistributed
>  without acknowledgment. No warranty is provided, either express or implied.
>
>  Following  is a copy of http://creativecommons.org/licenses/publicdomain
>
>  Creative Commons Public Domain
>  Copyright-Only Dedication (based on United States law) or Public Domain
>  Certification
>
>  The person or persons who have associated work with this document
>  (the "Dedicator" or "Certifier") hereby either (a) certifies that, to the
>  best of his knowledge, the work of authorship identified is in the
>  public domain of the country from which the work is published, or (b)
>  hereby dedicates whatever copyright the dedicators holds in the work of
>  authorship identified below (the "Work") to the public domain. A
>  certifier, moreover, dedicates any copyright interest he may have in the
>  associated work, and for these purposes, is described as a "dedicator"
>  below.
>
>  A certifier has taken reasonable steps to verify
>  the copyright status of this work. Certifier recognizes that his good
>  faith efforts may not shield him from liability if in fact the work
>  certified is not in the public domain.
>
>  Dedicator makes this dedication for the benefit of the public at large and
>  to the detriment of the Dedicator's heirs and successors. Dedicator intends
>  this dedication to be an overt act of relinquishment in perpetuity of
>  all present and future rights under copyright law, whether vested or
>  contingent, in the Work. Dedicator understands that such relinquishment
>  of all rights includes the relinquishment of all rights to enforce (by
>  lawsuit or otherwise) those copyrights in the Work.
>
>  Dedicator recognizes that, once placed in the public domain, the Work
>  may be
>  freely reproduced, distributed, transmitted, used, modified, built
>  upon, or otherwise exploited by anyone for any purpose, commercial or
>  non-commercial, and in any way, including by methods that have not yet
>  been invented or conceived.
>  ===============================
>
>  Does this make sense?
>  thanks,
>  Tom
>
>  _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From dl at cs.oswego.edu  Tue Apr 22 06:07:06 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 22 Apr 2008 06:07:06 -0400
Subject: [concurrency-interest] new book: The Art of Multiprocessor
	Programming
Message-ID: <480DB8CA.6020606@cs.oswego.edu>


Maurice Herlihy and Nir Shavit's book "The Art of Multiprocessor Programming" is
finally available. See
http://www.amazon.com/Art-Multiprocessor-Programming-Maurice-Herlihy/dp/0123705916

This is by far the best source for explaining the ideas and algorithms
underlying java.util.concurrent -- the vast majority of them, plus some
others, including a few that may someday appear. It also uses
Java/java.util.concurrent to illustrate most concepts.
I strongly recommended it.

-Doug




From matthias at mernst.org  Tue Apr 22 07:21:19 2008
From: matthias at mernst.org (Matthias Ernst)
Date: Tue, 22 Apr 2008 13:21:19 +0200
Subject: [concurrency-interest] Direct Byte Buffer memory visibility
Message-ID: <22ec15240804220421o687f3b81o8e44079a006d6203@mail.gmail.com>

Hi,

just musing: is it reasonable to assume that all rules for operations
on object fields and arrays also extend to direct byte buffers?
I.e. is the visibility guaranteed when I construct a happens-before
relationship between the modification and the reading of buffer
contents?
I assume the intrinsification happens-before reordering so the stuff
looks the same to the optimizer?

Thanks
Matthias

From matthias at mernst.org  Mon Apr 28 06:48:53 2008
From: matthias at mernst.org (Matthias Ernst)
Date: Mon, 28 Apr 2008 12:48:53 +0200
Subject: [concurrency-interest] Good terminology for setting up effectively
	immutable objects?
Message-ID: <22ec15240804280348g524f8d0clb67e0264e984154c@mail.gmail.com>

Hi,

often I neither want a huge (number of) constructor(s) nor want to
jump through hoops of using a Builder to guarantee final-ness of my
object's dependencies but want to rely on effective immutability
instead. I want to rely on my clients' common sense that anything that
is not documented as changeable should not be changed during use. I.e.
a number of setters that they may only call a) before starting to use
the object and b) before publishing it to other threads.

Is there a concise term to document this? I don't want to repeat that
sermon above all over. @SetupMethod?
Sorry if this can be found in JCIP. I don't have one handy right now.

Thanks
Matthias

From tim at peierls.net  Mon Apr 28 08:47:37 2008
From: tim at peierls.net (Tim Peierls)
Date: Mon, 28 Apr 2008 08:47:37 -0400
Subject: [concurrency-interest] Good terminology for setting up
	effectively immutable objects?
In-Reply-To: <22ec15240804280348g524f8d0clb67e0264e984154c@mail.gmail.com>
References: <22ec15240804280348g524f8d0clb67e0264e984154c@mail.gmail.com>
Message-ID: <63b4e4050804280547x277716c6p36bd6dd5a304ff41@mail.gmail.com>

I've been griping about the lack of a consensus (let alone a standard) for
this in various places. It's not in JCiP. I think it would be good to
collect ideas, so I added your message to the Java Concurrency wiki and
started a list. Interested parties please add to and comment on the list.

http://artisans-serverintellect-com.si-eioswww6.com/default.asp?W151

--tim

On Mon, Apr 28, 2008 at 6:48 AM, Matthias Ernst <matthias at mernst.org> wrote:

> Hi,
>
> often I neither want a huge (number of) constructor(s) nor want to
> jump through hoops of using a Builder to guarantee final-ness of my
> object's dependencies but want to rely on effective immutability
> instead. I want to rely on my clients' common sense that anything that
> is not documented as changeable should not be changed during use. I.e.
> a number of setters that they may only call a) before starting to use
> the object and b) before publishing it to other threads.
>
> Is there a concise term to document this? I don't want to repeat that
> sermon above all over. @SetupMethod?
> Sorry if this can be found in JCIP. I don't have one handy right now.
>
> Thanks
> Matthias
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080428/4362d42b/attachment.html 

From mthornton at optrak.co.uk  Mon Apr 28 16:46:15 2008
From: mthornton at optrak.co.uk (Mark Thornton)
Date: Mon, 28 Apr 2008 21:46:15 +0100
Subject: [concurrency-interest] Good terminology for setting up
 effectively immutable objects?
In-Reply-To: <22ec15240804280348g524f8d0clb67e0264e984154c@mail.gmail.com>
References: <22ec15240804280348g524f8d0clb67e0264e984154c@mail.gmail.com>
Message-ID: <48163797.8060606@optrak.co.uk>

Matthias Ernst wrote:
> Hi,
>
> often I neither want a huge (number of) constructor(s) nor want to
> jump through hoops of using a Builder to guarantee final-ness of my
> object's dependencies but want to rely on effective immutability
> instead. I want to rely on my clients' common sense that anything that
> is not documented as changeable should not be changed during use. I.e.
> a number of setters that they may only call a) before starting to use
> the object and b) before publishing it to other threads.
>   
While I have written this sort of code often enough, I can't avoid the
feeling that I should have used the builder pattern in most of the
cases. In fact all of them, should probably have been genuinely
immutable and not merely effectively immutable. Can we find a way to
make the builder pattern more palatable?

Mark Thornton



From jed at atlassian.com  Mon Apr 28 20:48:27 2008
From: jed at atlassian.com (Jed Wesley-Smith)
Date: Tue, 29 Apr 2008 10:48:27 +1000
Subject: [concurrency-interest] Good terminology for setting up
 effectively immutable objects?
In-Reply-To: <48163797.8060606@optrak.co.uk>
References: <22ec15240804280348g524f8d0clb67e0264e984154c@mail.gmail.com>
	<48163797.8060606@optrak.co.uk>
Message-ID: <4816705B.4070106@atlassian.com>

I thoroughly agree. Working on a large code-base with init methods 
throughout, there is a lot to like about the guarantees that true 
immutability gives you. Firstly you ensure that your objects are 
correctly set up and all invariants are honoured. Secondly, you get 
memory visibility guarantees regarding the initial values that you need 
safe publication otherwise to achieve (well, true immutability gives you 
safe publication without extra effort). Publication errors are some of 
the most painful to diagnose and reproduce. You can also then make sure 
that any builders are stack local.

As to making builder more palatable, whenever I have pointed out all the 
problems with effective immutability and safe publication and the 
potential gotchas of getting it wrong, the builder overhead starts to 
look very attractive.

cheers,
jed.

Mark Thornton wrote:
> Matthias Ernst wrote:
>   
>> Hi,
>>
>> often I neither want a huge (number of) constructor(s) nor want to
>> jump through hoops of using a Builder to guarantee final-ness of my
>> object's dependencies but want to rely on effective immutability
>> instead. I want to rely on my clients' common sense that anything that
>> is not documented as changeable should not be changed during use. I.e.
>> a number of setters that they may only call a) before starting to use
>> the object and b) before publishing it to other threads.
>>   
>>     
> While I have written this sort of code often enough, I can't avoid the
> feeling that I should have used the builder pattern in most of the
> cases. In fact all of them, should probably have been genuinely
> immutable and not merely effectively immutable. Can we find a way to
> make the builder pattern more palatable?
>
> Mark Thornton
>   


From gregg at cytetech.com  Tue Apr 29 13:29:46 2008
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 29 Apr 2008 12:29:46 -0500
Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown
	permission check.
Message-ID: <48175B0A.1080700@cytetech.com>

I have a STPE that I use in an applet.  At applet shutdown, I'd like to shutdown 
the executor, but alas it requests a Permission check for a RuntimePermission 
that I don't have in an unsigned applet.  It seems kind of silly to demand this 
permission when no other thread management permission exist in the JDK for 
applets.  Am I missing something in consideration of this issue?

Gregg Wonderly

From ben_manes at yahoo.com  Tue Apr 29 16:21:52 2008
From: ben_manes at yahoo.com (Ben Manes)
Date: Tue, 29 Apr 2008 13:21:52 -0700 (PDT)
Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown
	permission check.
Message-ID: <62009.75007.qm@web38802.mail.mud.yahoo.com>

Have you tried using a daemon thread factory?  I haven't done much work
with applets, but I'd venture that this would allow it to shutdown cleanly.


----- Original Message ----
From: Gregg Wonderly <gregg at cytetech.com>
To: concurrency-interest <concurrency-interest at cs.oswego.edu>
Sent: Tuesday, April 29, 2008 10:29:46 AM
Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown permission check.

I have a STPE that I use in an applet.  At applet shutdown, I'd like to shutdown 
the executor, but alas it requests a Permission check for a RuntimePermission 
that I don't have in an unsigned applet.  It seems kind of silly to demand this 
permission when no other thread management permission exist in the JDK for 
applets.  Am I missing something in consideration of this issue?

Gregg Wonderly
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest



      ____________________________________________________________________________________
Be a better friend, newshound, and 
know-it-all with Yahoo! Mobile.  Try it now.  http://mobile.yahoo.com/;_ylt=Ahu06i62sR8HDtDypao8Wcj9tAcJ
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080429/d82e1fb8/attachment.html 

From gregg at cytetech.com  Tue Apr 29 17:23:45 2008
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 29 Apr 2008 16:23:45 -0500
Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown
 permission check.
In-Reply-To: <62009.75007.qm@web38802.mail.mud.yahoo.com>
References: <62009.75007.qm@web38802.mail.mud.yahoo.com>
Message-ID: <481791E1.8060206@cytetech.com>

Ben Manes wrote:
> Have you tried using a daemon thread factory?  I haven't done much work 
> with applets, but I'd venture that this would allow it to shutdown cleanly.

The exception comes out of the STPE when I call shutdown or shutdownNow.  It is 
performing an permission check that is creating the problem.  A different thread 
type wouldn't help in this case.

Gregg Wonderly


> ----- Original Message ----
> From: Gregg Wonderly <gregg at cytetech.com>
> To: concurrency-interest <concurrency-interest at cs.oswego.edu>
> Sent: Tuesday, April 29, 2008 10:29:46 AM
> Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown 
> permission check.
> 
> I have a STPE that I use in an applet.  At applet shutdown, I'd like to 
> shutdown
> the executor, but alas it requests a Permission check for a 
> RuntimePermission
> that I don't have in an unsigned applet.  It seems kind of silly to 
> demand this
> permission when no other thread management permission exist in the JDK for
> applets.  Am I missing something in consideration of this issue?
> 
> Gregg Wonderly
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu 
> <mailto:Concurrency-interest at altair.cs.oswego.edu>
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> ------------------------------------------------------------------------
> Be a better friend, newshound, and know-it-all with Yahoo! Mobile. Try 
> it now. 
> <http://us.rd.yahoo.com/evt=51733/*http://mobile.yahoo.com/;_ylt=Ahu06i62sR8HDtDypao8Wcj9tAcJ 
>  >


From ben_manes at yahoo.com  Tue Apr 29 17:40:05 2008
From: ben_manes at yahoo.com (Ben Manes)
Date: Tue, 29 Apr 2008 14:40:05 -0700 (PDT)
Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown
	permission check.
Message-ID: <507742.51706.qm@web38807.mail.mud.yahoo.com>

Yes, but my point was that there may not be a need for an explicit shutdown and an implicit one when the applet was stopped would solve most use-cases.


----- Original Message ----
From: Gregg Wonderly <gregg at cytetech.com>
To: Ben Manes <ben_manes at yahoo.com>
Cc: gregg.wonderly at pobox.com; concurrency-interest <concurrency-interest at cs.oswego.edu>
Sent: Tuesday, April 29, 2008 2:23:45 PM
Subject: Re: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown permission check.

Ben Manes wrote:
> Have you tried using a daemon thread factory?  I haven't done much work 
> with applets, but I'd venture that this would allow it to shutdown cleanly.

The exception comes out of the STPE when I call shutdown or shutdownNow.  It is 
performing an permission check that is creating the problem.  A different thread 
type wouldn't help in this case.

Gregg Wonderly


> ----- Original Message ----
> From: Gregg Wonderly <gregg at cytetech.com>
> To: concurrency-interest <concurrency-interest at cs.oswego.edu>
> Sent: Tuesday, April 29, 2008 10:29:46 AM
> Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown 
> permission check.
> 
> I have a STPE that I use in an applet.  At applet shutdown, I'd like to 
> shutdown
> the executor, but alas it requests a Permission check for a 
> RuntimePermission
> that I don't have in an unsigned applet.  It seems kind of silly to 
> demand this
> permission when no other thread management permission exist in the JDK for
> applets.  Am I missing something in consideration of this issue?
> 
> Gregg Wonderly
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu 
> <mailto:Concurrency-interest at altair.cs.oswego.edu>
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> ------------------------------------------------------------------------
> Be a better friend, newshound, and know-it-all with Yahoo! Mobile. Try 
> it now. 
> <http://us.rd.yahoo.com/evt=51733/*http://mobile.yahoo.com/;_ylt=Ahu06i62sR8HDtDypao8Wcj9tAcJ 
>  >


      ____________________________________________________________________________________
Be a better friend, newshound, and 
know-it-all with Yahoo! Mobile.  Try it now.  http://mobile.yahoo.com/;_ylt=Ahu06i62sR8HDtDypao8Wcj9tAcJ
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080429/e94b9fbd/attachment.html 

From jason_mehrens at hotmail.com  Tue Apr 29 20:25:51 2008
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Tue, 29 Apr 2008 19:25:51 -0500
Subject: [concurrency-interest] ScheduledThreadPoolExecutor and
	shutdown	permission check.
In-Reply-To: <48175B0A.1080700@cytetech.com>
References: <48175B0A.1080700@cytetech.com>
Message-ID: <BLU134-W1441BEB2C78107149934DC83D80@phx.gbl>


Gregg,
 
Following report is related to your issue. http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6575582
 
Jason
> Date: Tue, 29 Apr 2008 12:29:46 -0500> From: gregg at cytetech.com> To: concurrency-interest at cs.oswego.edu> Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown permission check.> > I have a STPE that I use in an applet. At applet shutdown, I'd like to shutdown > the executor, but alas it requests a Permission check for a RuntimePermission > that I don't have in an unsigned applet. It seems kind of silly to demand this > permission when no other thread management permission exist in the JDK for > applets. Am I missing something in consideration of this issue?> > Gregg Wonderly> _______________________________________________> Concurrency-interest mailing list> Concurrency-interest at altair.cs.oswego.edu> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
_________________________________________________________________
Back to work after baby?how do you know when you?re ready?
http://lifestyle.msn.com/familyandparenting/articleNW.aspx?cp-documentid=5797498&ocid=T067MSN40A0701A
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080429/b0a05f25/attachment.html 

From joe.bowbeer at gmail.com  Tue Apr 29 21:21:03 2008
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 29 Apr 2008 18:21:03 -0700
Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown
	permission check.
In-Reply-To: <48175B0A.1080700@cytetech.com>
References: <48175B0A.1080700@cytetech.com>
Message-ID: <31f2a7bd0804291821w5d4b71b2y3622b1bae72489a2@mail.gmail.com>

On Tue, Apr 29, 2008 at 10:29 AM, Gregg Wonderly wrote:
> I have a STPE that I use in an applet.  At applet shutdown, I'd like to shutdown
>  the executor, but alas it requests a Permission check for a RuntimePermission
>  that I don't have in an unsigned applet.  It seems kind of silly to demand this
>  permission when no other thread management permission exist in the JDK for
>  applets.  Am I missing something in consideration of this issue?
>

Interesting.  So the exception is from TPE.shutdown() when it calls
checkPermission?

    private static final RuntimePermission shutdownPerm =
        new RuntimePermission("modifyThread");

    SecurityManager security = System.getSecurityManager();
    if (security != null)
        security.checkPermission(shutdownPerm);

Before checking to see if the current thread can interrupt the workers
-- even if none of the workers will actually be interrupted...

    if (security != null) { // Check if caller can modify our threads
        for (Worker w : workers)
            security.checkAccess(w.thread);
    }

The rationale is here

     * [ ... ] we must cooperate
     * with the security manager (if present), which may implement
     * policies that make more sense for operations on Threads
     * than they do for ThreadPools. This requires 3 steps:
     *
     * 1. Making sure caller has permission to shut down threads
     * in general (see shutdownPerm).
     *
     * 2. If (1) passes, making sure the caller is allowed to
     * modify each of our threads. This might not be true even if
     * first check passed, if the SecurityManager treats some
     * threads specially. If this check passes, then we can try
     * to set runState.
     *
     * 3. If both (1) and (2) pass, dealing with inconsistent
     * security managers that allow checkAccess but then throw a
     * SecurityException when interrupt() is invoked.  In this
     * third case, because we have already set runState, we can
     * only try to back out from the shutdown as cleanly as
     * possible. Some workers may have been killed but we remain
     * in non-shutdown state (which may entail tryTerminate from
     * workerDone starting a new worker to maintain liveness.)

What should it do?

--Joe

From matthias at mernst.org  Wed Apr 30 09:08:47 2008
From: matthias at mernst.org (Matthias Ernst)
Date: Wed, 30 Apr 2008 15:08:47 +0200
Subject: [concurrency-interest] Good terminology for setting up
	effectively immutable objects?
In-Reply-To: <4816705B.4070106@atlassian.com>
References: <22ec15240804280348g524f8d0clb67e0264e984154c@mail.gmail.com>
	<48163797.8060606@optrak.co.uk> <4816705B.4070106@atlassian.com>
Message-ID: <22ec15240804300608s288c6be4uf16a21fe0456ff5e@mail.gmail.com>

I understand the concern. I just don't see adding this code overhead
to my code. I think that safe publication and happens-before are
wonderful abstractions, good to reason about and I'm so glad we have
them. I believe this should be the canonical style. Unsafe publication
should be forbidden except for the few core cases that required having
it in the first place.

And that leads to what's bugging me (never quite having been able to
phrase it) about your and similar arguments that came up in
discussions about safety of servlet initialization and DI containers:
I know it's defensive engineering but at the same time it's positive
reinforcement for unsafe publication practices. It appears to shifts
responsibility from the client and makes components even more
expensive to write. I would like to take an absolute stance - client
code doing unsafe publication is buggy and must be fixed. I'm not
willing to go out of my way in order to safeguard against other
people's bugs.

Having said that, I love final fields and I've been dreaming about a
way to have _clients_ initialize blank final fields. Something like:

X x = new X() {{
 foo = bar;
}};

where foo is a blank final unassigned in the X() constructor. But
haven't thought that through.

So anyone that does have a name for requiring setters to be only
called during the "setup phase"?

Cheers
Matthias

On Tue, Apr 29, 2008 at 2:48 AM, Jed Wesley-Smith <jed at atlassian.com> wrote:
> I thoroughly agree. Working on a large code-base with init methods
>  throughout, there is a lot to like about the guarantees that true
>  immutability gives you. Firstly you ensure that your objects are
>  correctly set up and all invariants are honoured. Secondly, you get
>  memory visibility guarantees regarding the initial values that you need
>  safe publication otherwise to achieve (well, true immutability gives you
>  safe publication without extra effort). Publication errors are some of
>  the most painful to diagnose and reproduce. You can also then make sure
>  that any builders are stack local.
>
>  As to making builder more palatable, whenever I have pointed out all the
>  problems with effective immutability and safe publication and the
>  potential gotchas of getting it wrong, the builder overhead starts to
>  look very attractive.
>
>  cheers,
>  jed.
>
>
>
>  Mark Thornton wrote:
>  > Matthias Ernst wrote:
>  >
>  >> Hi,
>  >>
>  >> often I neither want a huge (number of) constructor(s) nor want to
>  >> jump through hoops of using a Builder to guarantee final-ness of my
>  >> object's dependencies but want to rely on effective immutability
>  >> instead. I want to rely on my clients' common sense that anything that
>  >> is not documented as changeable should not be changed during use. I.e.
>  >> a number of setters that they may only call a) before starting to use
>  >> the object and b) before publishing it to other threads.
>  >>
>  >>
>  > While I have written this sort of code often enough, I can't avoid the
>  > feeling that I should have used the builder pattern in most of the
>  > cases. In fact all of them, should probably have been genuinely
>  > immutable and not merely effectively immutable. Can we find a way to
>  > make the builder pattern more palatable?
>  >
>  > Mark Thornton
>  >
>
>  _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From gregg at cytetech.com  Wed Apr 30 09:12:29 2008
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 30 Apr 2008 08:12:29 -0500
Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown
 permission check.
In-Reply-To: <507742.51706.qm@web38807.mail.mud.yahoo.com>
References: <507742.51706.qm@web38807.mail.mud.yahoo.com>
Message-ID: <4818703D.8070801@cytetech.com>

Ben Manes wrote:
> Yes, but my point was that there may not be a need for an explicit 
> shutdown and an implicit one when the applet was stopped would solve 
> most use-cases.

The STPE is used in a class which has hundreds of instances created and 
destroyed over the life of the applet.  If I use daemon threads won't they still 
be parked when idle?

Gregg Wonderly

> ----- Original Message ----
> From: Gregg Wonderly <gregg at cytetech.com>
> To: Ben Manes <ben_manes at yahoo.com>
> Cc: gregg.wonderly at pobox.com; concurrency-interest 
> <concurrency-interest at cs.oswego.edu>
> Sent: Tuesday, April 29, 2008 2:23:45 PM
> Subject: Re: [concurrency-interest] ScheduledThreadPoolExecutor and 
> shutdown permission check.
> 
> Ben Manes wrote:
>  > Have you tried using a daemon thread factory?  I haven't done much work
>  > with applets, but I'd venture that this would allow it to shutdown 
> cleanly.
> 
> The exception comes out of the STPE when I call shutdown or 
> shutdownNow.  It is
> performing an permission check that is creating the problem.  A 
> different thread
> type wouldn't help in this case.
> 
> Gregg Wonderly
> 
> 
>  > ----- Original Message ----
>  > From: Gregg Wonderly <gregg at cytetech.com <mailto:gregg at cytetech.com>>
>  > To: concurrency-interest <concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>>
>  > Sent: Tuesday, April 29, 2008 10:29:46 AM
>  > Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown
>  > permission check.
>  >
>  > I have a STPE that I use in an applet.  At applet shutdown, I'd like to
>  > shutdown
>  > the executor, but alas it requests a Permission check for a
>  > RuntimePermission
>  > that I don't have in an unsigned applet.  It seems kind of silly to
>  > demand this
>  > permission when no other thread management permission exist in the 
> JDK for
>  > applets.  Am I missing something in consideration of this issue?
>  >
>  > Gregg Wonderly
>  > _______________________________________________
>  > Concurrency-interest mailing list
>  > Concurrency-interest at altair.cs.oswego.edu 
> <mailto:Concurrency-interest at altair.cs.oswego.edu>
>  > <mailto:Concurrency-interest at altair.cs.oswego.edu 
> <mailto:Concurrency-interest at altair.cs.oswego.edu>>
>  > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  >
>  > ------------------------------------------------------------------------
>  > Be a better friend, newshound, and know-it-all with Yahoo! Mobile. Try
>  > it now.
>  > 
> <http://us.rd.yahoo.com/evt=51733/*http://mobile.yahoo.com/;_ylt=Ahu06i62sR8HDtDypao8Wcj9tAcJ 
> 
>  >  >
> 
> 
> ------------------------------------------------------------------------
> Be a better friend, newshound, and know-it-all with Yahoo! Mobile. Try 
> it now. 
> <http://us.rd.yahoo.com/evt=51733/*http://mobile.yahoo.com/;_ylt=Ahu06i62sR8HDtDypao8Wcj9tAcJ 
>  >


From gregg at cytetech.com  Wed Apr 30 09:25:52 2008
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 30 Apr 2008 08:25:52 -0500
Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown
 permission check.
In-Reply-To: <31f2a7bd0804291821w5d4b71b2y3622b1bae72489a2@mail.gmail.com>
References: <48175B0A.1080700@cytetech.com>
	<31f2a7bd0804291821w5d4b71b2y3622b1bae72489a2@mail.gmail.com>
Message-ID: <48187360.2040505@cytetech.com>

Joe Bowbeer wrote:
> On Tue, Apr 29, 2008 at 10:29 AM, Gregg Wonderly wrote:
>> I have a STPE that I use in an applet.  At applet shutdown, I'd like to shutdown
>>  the executor, but alas it requests a Permission check for a RuntimePermission
>>  that I don't have in an unsigned applet.  It seems kind of silly to demand this
>>  permission when no other thread management permission exist in the JDK for
>>  applets.  Am I missing something in consideration of this issue?
>>
> 
> Interesting.  So the exception is from TPE.shutdown() when it calls
> checkPermission?
> 
>     private static final RuntimePermission shutdownPerm =
>         new RuntimePermission("modifyThread");
> 
>     SecurityManager security = System.getSecurityManager();
>     if (security != null)
>         security.checkPermission(shutdownPerm);
> 
> Before checking to see if the current thread can interrupt the workers
> -- even if none of the workers will actually be interrupted...
> 
>     if (security != null) { // Check if caller can modify our threads
>         for (Worker w : workers)
>             security.checkAccess(w.thread);
>     }
> 
> The rationale is here
> 
>      * [ ... ] we must cooperate
>      * with the security manager (if present), which may implement
>      * policies that make more sense for operations on Threads
>      * than they do for ThreadPools. This requires 3 steps:
>      *
>      * 1. Making sure caller has permission to shut down threads
>      * in general (see shutdownPerm).
>      *
>      * 2. If (1) passes, making sure the caller is allowed to
>      * modify each of our threads. This might not be true even if
>      * first check passed, if the SecurityManager treats some
>      * threads specially. If this check passes, then we can try
>      * to set runState.
>      *
>      * 3. If both (1) and (2) pass, dealing with inconsistent
>      * security managers that allow checkAccess but then throw a
>      * SecurityException when interrupt() is invoked.  In this
>      * third case, because we have already set runState, we can
>      * only try to back out from the shutdown as cleanly as
>      * possible. Some workers may have been killed but we remain
>      * in non-shutdown state (which may entail tryTerminate from
>      * workerDone starting a new worker to maintain liveness.)
> 
> What should it do?

The primary issue is that the STPE object reference is the key to being able to 
shut things down.  If I have a reference, I should be able to use all functions 
of the class, because I am running in the same JVM.  If I was allowed to 
create/start something without a permission, it sure seems like I should be able 
to stop it with the same level of authorization.  The reachability of Threads in 
my ThreadGroup, or in non-root ThreadGroups, is a different issue.  Sure, that 
path should be protected from random access without proper permissions.  But, if 
I have a reference to TPE, that is a non-global reference (except in some 
potential code designs with static instances that are reachable from all threads 
with the same class loader/path based visibility), I think it should really use 
doPrivileged() on my behalf, and override the asserted authorization I have to 
shut things down when I call shutdown.

I'd guess that perhaps someone is thinking of a statically allocated instance 
that might be "referenceable" from rogue code, but I don't know.  I just don't 
see how the classes behavior provides anything useful from a security control 
perspective, especially since this is an instance based mechanism not a static 
reference mechanism, where Permission checks can make a lot more sense.

Does anyone have a pointer to existing JVM classes, or a real scenario of where 
I might be able to get a reference to a STPE, or any TPE I guess, which I didn't 
create, and then should not be able to shut it down?  Those a the cases where a 
wrapped Permission check would apply, and a delegate class/method could provide 
that service instead of it being in the base class.

Gregg Wonderly

From mthornton at optrak.co.uk  Wed Apr 30 09:52:41 2008
From: mthornton at optrak.co.uk (Mark Thornton)
Date: Wed, 30 Apr 2008 14:52:41 +0100
Subject: [concurrency-interest] Good terminology for setting
 up	effectively immutable objects?
In-Reply-To: <22ec15240804300608s288c6be4uf16a21fe0456ff5e@mail.gmail.com>
References: <22ec15240804280348g524f8d0clb67e0264e984154c@mail.gmail.com>	<48163797.8060606@optrak.co.uk>
	<4816705B.4070106@atlassian.com>
	<22ec15240804300608s288c6be4uf16a21fe0456ff5e@mail.gmail.com>
Message-ID: <481879A9.5030902@optrak.co.uk>

Matthias Ernst wrote:
> Having said that, I love final fields and I've been dreaming about a
> way to have _clients_ initialize blank final fields. Something like:
>
> X x = new X() {{
>  foo = bar;
> }};
>
>   
class X {
    final Type foo; ...
   private X(Builder b) {
       foo = b.foo;
    }

  static class Builder {
     protected Type foo;

    public X create() {return new X(this);}
  }
}


...

X x = new X.Builder() {
    public X create() {
       foo = bar;
       return super.create();
    }.create();


No doubt a shorter version is possible.

Mark

From Thomas.Hawtin at Sun.COM  Wed Apr 30 10:24:20 2008
From: Thomas.Hawtin at Sun.COM (Tom Hawtin)
Date: Wed, 30 Apr 2008 15:24:20 +0100
Subject: [concurrency-interest] Good terminology for setting
 up	effectively immutable objects?
In-Reply-To: <22ec15240804300608s288c6be4uf16a21fe0456ff5e@mail.gmail.com>
References: <22ec15240804280348g524f8d0clb67e0264e984154c@mail.gmail.com>
	<48163797.8060606@optrak.co.uk> <4816705B.4070106@atlassian.com>
	<22ec15240804300608s288c6be4uf16a21fe0456ff5e@mail.gmail.com>
Message-ID: <48188114.5070205@sun.com>

Matthias Ernst wrote:
> 
> So anyone that does have a name for requiring setters to be only
> called during the "setup phase"?

It think "two-phase construction" (or initialization) is usual. Usually 
in the context of "antipatterns".

Tom Hawtin

From Online at stolsvik.com  Wed Apr 30 10:56:19 2008
From: Online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Wed, 30 Apr 2008 16:56:19 +0200
Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown
 permission check.
In-Reply-To: <4818703D.8070801@cytetech.com>
References: <507742.51706.qm@web38807.mail.mud.yahoo.com>
	<4818703D.8070801@cytetech.com>
Message-ID: <48188893.6030009@Stolsvik.com>

Gregg Wonderly wrote:
> Ben Manes wrote:
>> Yes, but my point was that there may not be a need for an explicit 
>> shutdown and an implicit one when the applet was stopped would solve 
>> most use-cases.
> 
> The STPE is used in a class which has hundreds of instances created and 
> destroyed over the life of the applet.

While I agree to the problem you're describing (it is downright silly 
that threads you been allowed to create and use shouldn't be 
*controllable* by you too - I mean, what you're really asking is to have 
the threads you've (implicitly) created simply exit their run() 
methods), I find this specific usage you describe here somewhat strange: 
Why not have one pool that these instances share? I thought a big point 
of a threadpool is that thread creation and stopping is rather expensive.

> If I use daemon threads won't they still 
> be parked when idle?

Yes, they should.

You could, I guess, use the timeout functionality of the TPEs, so that 
they'll die after a (very short) while when the queue is empty.

Endre.

From Thomas.Hawtin at Sun.COM  Wed Apr 30 13:27:40 2008
From: Thomas.Hawtin at Sun.COM (Tom Hawtin)
Date: Wed, 30 Apr 2008 18:27:40 +0100
Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown
 permission check.
In-Reply-To: <48175B0A.1080700@cytetech.com>
References: <48175B0A.1080700@cytetech.com>
Message-ID: <4818AC0C.40406@sun.com>

Gregg Wonderly wrote:
> I have a STPE that I use in an applet.  At applet shutdown, I'd like to shutdown 
> the executor, but alas it requests a Permission check for a RuntimePermission 
> that I don't have in an unsigned applet.  It seems kind of silly to demand this 
> permission when no other thread management permission exist in the JDK for 
> applets.  Am I missing something in consideration of this issue?

If you really needed to do this, you could:
  * Supply a custom ThreadFactory that (weakly) records created threads.
  * Supply a custom queue.
  * On requiring your threads to shutdown, make the queue start throwing 
runtime exceptions.
  * Then, interrupt all of your remembered threads.

Tom Hawtin

From gregg at cytetech.com  Wed Apr 30 16:09:30 2008
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 30 Apr 2008 15:09:30 -0500
Subject: [concurrency-interest] ScheduledThreadPoolExecutor and shutdown
 permission check.
In-Reply-To: <48188893.6030009@Stolsvik.com>
References: <507742.51706.qm@web38807.mail.mud.yahoo.com>
	<4818703D.8070801@cytetech.com> <48188893.6030009@Stolsvik.com>
Message-ID: <4818D1FA.3050008@cytetech.com>

Endre St?lsvik wrote:
> Gregg Wonderly wrote:
>> Ben Manes wrote:
>>> Yes, but my point was that there may not be a need for an explicit 
>>> shutdown and an implicit one when the applet was stopped would solve 
>>> most use-cases.
>>
>> The STPE is used in a class which has hundreds of instances created 
>> and destroyed over the life of the applet.
> 
> While I agree to the problem you're describing (it is downright silly 
> that threads you been allowed to create and use shouldn't be 
> *controllable* by you too - I mean, what you're really asking is to have 
> the threads you've (implicitly) created simply exit their run() 
> methods), I find this specific usage you describe here somewhat strange: 
> Why not have one pool that these instances share? I thought a big point 
> of a threadpool is that thread creation and stopping is rather expensive.

The basic problem is that this class is used when the user selects something in 
the GUI, to perform work for that selection.  When they select something new, I 
need to shut that down and create another instance.  The class really is 
standalone.  If I passed in the STPE instance, or had it use a static instance, 
then I could leave that one running.  I really dislike having all that linkage 
between standalone objects and the users of them.  The thread pool use is not a 
publicly describable behavior of the class.  It just does the work and gives the 
results and knowing that the STPE is being used, is "under the covers" knowledge.

I guess I'll just have to do something different for this case...

Gregg Wonderly

