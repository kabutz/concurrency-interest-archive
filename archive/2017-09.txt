From anmiller at redhat.com  Tue Sep  5 13:45:25 2017
From: anmiller at redhat.com (Andrig Miller)
Date: Tue, 5 Sep 2017 11:45:25 -0600
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <da0152f6-3bc6-04c2-831d-d91e8b90de08@gmail.com>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <1df357e5-cee3-ddde-c6aa-e3d061705e25@redhat.com>
 <4da3b132-5698-a79e-0883-a9bffc537658@cs.oswego.edu>
 <da0152f6-3bc6-04c2-831d-d91e8b90de08@gmail.com>
Message-ID: <CAF1-sp5yhWmqZrw0DEbi9qrb2GgeXhfPJ_M9_3ajNGe02w1hFw@mail.gmail.com>

I know of a futex performance issue that remains in the kernel.  Whenever
futex is called when the JVM is running in a virtual machine it performs
very poorly.  In the particular case that made me aware of this issue, the
slowdown was 50%.

To my knowledge, the kernel engineers have never been able to come up with
a way to fix this issue.

Andy

On Fri, Aug 25, 2017 at 10:49 AM, Nathan and Ila Reynolds <
nathanila at gmail.com> wrote:

> Several years ago, I saw Linux futex perform poorly in the kernel.  Futex
> was getting a bad rap by others as well.  In my experience, the kernel
> would spend a lot of CPU time dealing with futexes.  I do not remember the
> circumstances that cause this scenario.  So, I recommend proceeding with
> caution and lots of testing.  Perhaps, this caution is not warranted and
> the problem was fixed in the kernel.
>
> For the blocking case, I would guess there would not be much difference in
> performance.
>
> I recommend running some microbenchmark tests for the non-blocking case
> (i.e. unpark() before park()).  You might see a CPU performance gain.
>
> -Nathan
>
>
> On 8/25/2017 10:28 AM, Doug Lea wrote:
>
>> On 08/25/2017 11:12 AM, Andrew Haley wrote:
>>
>>> On 25/08/17 12:12, Doug Lea wrote:
>>>
>>>> BTW, on linux, it should be more efficient to implement using
>>>> Futex instead of the current scheme based on original Solaris
>>>> version. But no one has ever volunteered to do this.
>>>>
>>> I've done it, and could not measure any difference.
>>>
>> Well, it should still save a few electrons (or millions, across
>> deployments), so still seems to be the Right Thing to do.
>>
>> -Doug
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> --
> -Nathan
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Andrig (Andy) T. Miller
Global Platform Director, Middleware
Red Hat, Inc.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170905/e4747efb/attachment.html>

From davidcholmes at aapt.net.au  Tue Sep  5 16:56:39 2017
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 6 Sep 2017 06:56:39 +1000
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <CAF1-sp5yhWmqZrw0DEbi9qrb2GgeXhfPJ_M9_3ajNGe02w1hFw@mail.gmail.com>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <1df357e5-cee3-ddde-c6aa-e3d061705e25@redhat.com>
 <4da3b132-5698-a79e-0883-a9bffc537658@cs.oswego.edu>
 <da0152f6-3bc6-04c2-831d-d91e8b90de08@gmail.com>
 <CAF1-sp5yhWmqZrw0DEbi9qrb2GgeXhfPJ_M9_3ajNGe02w1hFw@mail.gmail.com>
Message-ID: <003601d32689$78a5e770$69f1b650$@aapt.net.au>

Hi Andy,

 

Can you elaborate further on this issue?

 

But given futex is also the underpinning of the pthread mutex/condvar, wouldn’t you see the same slow down in either case? Or is there something specific about calling futex API directly from the JVM.

 

Thanks,

David

 

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Andrig Miller
Sent: Wednesday, September 6, 2017 3:45 AM
To: Nathan and Ila Reynolds <nathanila at gmail.com>
Cc: Concurrency-interest <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] On park and unpark

 

I know of a futex performance issue that remains in the kernel.  Whenever futex is called when the JVM is running in a virtual machine it performs very poorly.  In the particular case that made me aware of this issue, the slowdown was 50%.

 

To my knowledge, the kernel engineers have never been able to come up with a way to fix this issue.

 

Andy

 

On Fri, Aug 25, 2017 at 10:49 AM, Nathan and Ila Reynolds <nathanila at gmail.com <mailto:nathanila at gmail.com> > wrote:

Several years ago, I saw Linux futex perform poorly in the kernel.  Futex was getting a bad rap by others as well.  In my experience, the kernel would spend a lot of CPU time dealing with futexes.  I do not remember the circumstances that cause this scenario.  So, I recommend proceeding with caution and lots of testing.  Perhaps, this caution is not warranted and the problem was fixed in the kernel.

For the blocking case, I would guess there would not be much difference in performance.

I recommend running some microbenchmark tests for the non-blocking case (i.e. unpark() before park()).  You might see a CPU performance gain.

-Nathan



On 8/25/2017 10:28 AM, Doug Lea wrote:

On 08/25/2017 11:12 AM, Andrew Haley wrote:

On 25/08/17 12:12, Doug Lea wrote:

BTW, on linux, it should be more efficient to implement using
Futex instead of the current scheme based on original Solaris
version. But no one has ever volunteered to do this.

I've done it, and could not measure any difference.

Well, it should still save a few electrons (or millions, across
deployments), so still seems to be the Right Thing to do.

-Doug
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> 
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

-- 
-Nathan



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> 
http://cs.oswego.edu/mailman/listinfo/concurrency-interest





 

-- 

Andrig (Andy) T. Miller

Global Platform Director, Middleware

Red Hat, Inc.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170906/e4018919/attachment.html>

From anmiller at redhat.com  Tue Sep  5 20:47:48 2017
From: anmiller at redhat.com (Andrig Miller)
Date: Tue, 5 Sep 2017 18:47:48 -0600
Subject: [concurrency-interest] On park and unpark
In-Reply-To: <003601d32689$78a5e770$69f1b650$@aapt.net.au>
References: <e2647562-988b-aee7-a2c5-7b3773319e38@redhat.com>
 <a15aac97-479f-db26-0d0b-deb1df9918a4@cs.oswego.edu>
 <1df357e5-cee3-ddde-c6aa-e3d061705e25@redhat.com>
 <4da3b132-5698-a79e-0883-a9bffc537658@cs.oswego.edu>
 <da0152f6-3bc6-04c2-831d-d91e8b90de08@gmail.com>
 <CAF1-sp5yhWmqZrw0DEbi9qrb2GgeXhfPJ_M9_3ajNGe02w1hFw@mail.gmail.com>
 <003601d32689$78a5e770$69f1b650$@aapt.net.au>
Message-ID: <CAF1-sp6M4keciLgsTqZ1V-ETYvzZ8Ez=A6pkf6Kv6NHSwG+v5A@mail.gmail.com>

It took some digging but I found the original bugzilla for this issue.  It
was the JVM running in a KVM guest, on RHEL 6.4.  Unfortunately, all the
details are mostly private, because it originated with a Red Hat customer
case.

Having said that, the issue seems to be related to how the paravirtualized
kernel deals with interrupts and scheduling as a result of the futex call.
The interesting thing here, is that no one was able to actually solve it
with experimental kernel patches.  Lot's of things were tried, but none
truly succeeded.

The issue eventually was just closed as "WON'T FIX".  Looked more like,
"CAN'T FIX" to me.

So, it is an isolated issue, and perhaps it doesn't even happen anymore,
but since I remembered this issue, I wanted to let everyone know.

Andy



On Tue, Sep 5, 2017 at 2:56 PM, David Holmes <davidcholmes at aapt.net.au>
wrote:

> Hi Andy,
>
>
>
> Can you elaborate further on this issue?
>
>
>
> But given futex is also the underpinning of the pthread mutex/condvar,
> wouldn’t you see the same slow down in either case? Or is there something
> specific about calling futex API directly from the JVM.
>
>
>
> Thanks,
>
> David
>
>
>
> *From:* Concurrency-interest [mailto:concurrency-interest-
> bounces at cs.oswego.edu] *On Behalf Of *Andrig Miller
> *Sent:* Wednesday, September 6, 2017 3:45 AM
> *To:* Nathan and Ila Reynolds <nathanila at gmail.com>
> *Cc:* Concurrency-interest <concurrency-interest at cs.oswego.edu>
> *Subject:* Re: [concurrency-interest] On park and unpark
>
>
>
> I know of a futex performance issue that remains in the kernel.  Whenever
> futex is called when the JVM is running in a virtual machine it performs
> very poorly.  In the particular case that made me aware of this issue, the
> slowdown was 50%.
>
>
>
> To my knowledge, the kernel engineers have never been able to come up with
> a way to fix this issue.
>
>
>
> Andy
>
>
>
> On Fri, Aug 25, 2017 at 10:49 AM, Nathan and Ila Reynolds <
> nathanila at gmail.com> wrote:
>
> Several years ago, I saw Linux futex perform poorly in the kernel.  Futex
> was getting a bad rap by others as well.  In my experience, the kernel
> would spend a lot of CPU time dealing with futexes.  I do not remember the
> circumstances that cause this scenario.  So, I recommend proceeding with
> caution and lots of testing.  Perhaps, this caution is not warranted and
> the problem was fixed in the kernel.
>
> For the blocking case, I would guess there would not be much difference in
> performance.
>
> I recommend running some microbenchmark tests for the non-blocking case
> (i.e. unpark() before park()).  You might see a CPU performance gain.
>
> -Nathan
>
>
>
> On 8/25/2017 10:28 AM, Doug Lea wrote:
>
> On 08/25/2017 11:12 AM, Andrew Haley wrote:
>
> On 25/08/17 12:12, Doug Lea wrote:
>
> BTW, on linux, it should be more efficient to implement using
> Futex instead of the current scheme based on original Solaris
> version. But no one has ever volunteered to do this.
>
> I've done it, and could not measure any difference.
>
> Well, it should still save a few electrons (or millions, across
> deployments), so still seems to be the Right Thing to do.
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> --
> -Nathan
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> --
>
> Andrig (Andy) T. Miller
>
> Global Platform Director, Middleware
>
> Red Hat, Inc.
>



-- 
Andrig (Andy) T. Miller
Global Platform Director, Middleware
Red Hat, Inc.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170905/0bdd92d8/attachment-0001.html>

From akarnokd at gmail.com  Thu Sep  7 04:55:51 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Thu, 7 Sep 2017 10:55:51 +0200
Subject: [concurrency-interest] Stopping a java.lang.ref.Cleaner's
	background thread
Message-ID: <CAAWwtm8sfSyY-WixbMZiBe1eiXOEKCBmh1YFJeB_nhKM-qz0PA@mail.gmail.com>

Hello.

Java 9 introduced the handy and official Cleaner infrastructure to replace
the functionality of finally(). It allows us to create the thread it is
going to use for the cleanup, which is set to daemon so that the JVM can
quit.

However, when running in an "app" container such as Tomcat, I'm not sure
how to cleanup the Cleaner itself when the servlet gets unloaded. (We had
similar issues with RxJava's own set of standard schedulers which made us
expose the shutdown of the underlying thread pools so a servlet can stop
them when it gets unloaded.)

I'm not sure what the effect of such shutdown should be beyond stopping the
underlying threadpool. Calling clean() on all registered Cleanables and
rejecting further register() calls? Returning all registered Cleanables?

-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170907/4a7a4de4/attachment.html>

From shevek at anarres.org  Thu Sep  7 07:01:21 2017
From: shevek at anarres.org (Shevek)
Date: Thu, 7 Sep 2017 04:01:21 -0700
Subject: [concurrency-interest] Double Checked Locking and String
Message-ID: <0800c1e2-67a0-951f-1e4a-39237ae11c8f@anarres.org>

Is the following code correct:

Map<T, String> m = new ConcurrentHashMap<>();

public void getString(T t) {
	String out = m.get(t);
	if (out != null)
		return out;
	synchronized (m) {
		out = m.get(t);
		if (out == null) {
			out = String.valueOf(t); // all fields final.
			m.put(t, out);
		}
	}
	return out;
}

The principle being that yes it's a double-checked lock, but the field 
in String is final. Is that enough to cause the publication to be safe? 
I _think_ this is an instance of FinalWrapperFactory from 
https://shipilev.net/blog/2014/safe-public-construction/ but it may be 
that the system thinks that there's another read-path for the variable 
via the Map, and that makes it not be a safe publication.

Thank you.

S.

From shade at redhat.com  Thu Sep  7 07:05:36 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Thu, 7 Sep 2017 13:05:36 +0200
Subject: [concurrency-interest] Double Checked Locking and String
In-Reply-To: <0800c1e2-67a0-951f-1e4a-39237ae11c8f@anarres.org>
References: <0800c1e2-67a0-951f-1e4a-39237ae11c8f@anarres.org>
Message-ID: <1f547cc3-781c-bcf3-4c03-079c04db7a22@redhat.com>

On 09/07/2017 01:01 PM, Shevek wrote:
> Is the following code correct:
> 
> Map<T, String> m = new ConcurrentHashMap<>();
> 
> public void getString(T t) {
>     String out = m.get(t);
>     if (out != null)
>         return out;
>     synchronized (m) {
>         out = m.get(t);
>         if (out == null) {
>             out = String.valueOf(t); // all fields final.
>             m.put(t, out);
>         }
>     }
>     return out;
> }

Unclear what you want here. ConcurrentHashMap gives you most of the memory semantics you want
without having to go through all this. Also, this seems to be the poster child of
putIfAbsent/computeIfAbsent.

-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170907/015573ec/attachment.sig>

From Roger.Riggs at Oracle.com  Thu Sep  7 09:39:05 2017
From: Roger.Riggs at Oracle.com (Roger Riggs)
Date: Thu, 7 Sep 2017 09:39:05 -0400
Subject: [concurrency-interest] Stopping a java.lang.ref.Cleaner's
 background thread
In-Reply-To: <CAAWwtm8sfSyY-WixbMZiBe1eiXOEKCBmh1YFJeB_nhKM-qz0PA@mail.gmail.com>
References: <CAAWwtm8sfSyY-WixbMZiBe1eiXOEKCBmh1YFJeB_nhKM-qz0PA@mail.gmail.com>
Message-ID: <60c0208a-5ac7-df89-db2a-760b06d5a981@Oracle.com>

Hi David,

It should not be necessary to do anything to the Cleaner thread.
The thread is set to be a daemon, so it will not inhibit a clean return 
from main.
Also, the Cleaner thread will stop itself when all of the cleaner 
functions have done their cleanup.

Regards, Roger


On 9/7/2017 4:55 AM, Dávid Karnok wrote:
> Hello.
>
> Java 9 introduced the handy and official Cleaner infrastructure to 
> replace the functionality of finally(). It allows us to create the 
> thread it is going to use for the cleanup, which is set to daemon so 
> that the JVM can quit.
>
> However, when running in an "app" container such as Tomcat, I'm not 
> sure how to cleanup the Cleaner itself when the servlet gets unloaded. 
> (We had similar issues with RxJava's own set of standard schedulers 
> which made us expose the shutdown of the underlying thread pools so a 
> servlet can stop them when it gets unloaded.)
>
> I'm not sure what the effect of such shutdown should be beyond 
> stopping the underlying threadpool. Calling clean() on all registered 
> Cleanables and rejecting further register() calls? Returning all 
> registered Cleanables?
>
> -- 
> Best regards,
> David Karnok
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170907/54088ebe/attachment.html>

From gil at azul.com  Thu Sep  7 10:28:03 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 7 Sep 2017 14:28:03 +0000
Subject: [concurrency-interest] Stopping a java.lang.ref.Cleaner's
 background thread
In-Reply-To: <60c0208a-5ac7-df89-db2a-760b06d5a981@Oracle.com>
References: <CAAWwtm8sfSyY-WixbMZiBe1eiXOEKCBmh1YFJeB_nhKM-qz0PA@mail.gmail.com>,
 <60c0208a-5ac7-df89-db2a-760b06d5a981@Oracle.com>
Message-ID: <7D2FE264-BFB7-4824-BE9C-6A702E7095E9@azul.com>

I think David is asking about "leaking" the associated cleaner thread if it was created by a servlet (e.g. as a shared static member if the servlet?s class or library), and the servlet gets unloaded. The key wording for the Javadoc about this is:

"...The thread runs until all registered cleaning actions have completed and the cleaner itself is reclaimed by the garbage collector."

So when the last strong reference from the servlet to the cleaner goes away (when the servlet is unloaded), the cleaner itself will be presumably be cleaned (using some other systemic cleaner), and that will stop the thread and eventually collect up.

Sent from my iPad

On Sep 7, 2017, at 6:40 AM, Roger Riggs <Roger.Riggs at Oracle.com<mailto:Roger.Riggs at Oracle.com>> wrote:

Hi David,

It should not be necessary to do anything to the Cleaner thread.
The thread is set to be a daemon, so it will not inhibit a clean return from main.
Also, the Cleaner thread will stop itself when all of the cleaner functions have done their cleanup.

Regards, Roger


On 9/7/2017 4:55 AM, D?vid Karnok wrote:
Hello.

Java 9 introduced the handy and official Cleaner infrastructure to replace the functionality of finally(). It allows us to create the thread it is going to use for the cleanup, which is set to daemon so that the JVM can quit.

However, when running in an "app" container such as Tomcat, I'm not sure how to cleanup the Cleaner itself when the servlet gets unloaded. (We had similar issues with RxJava's own set of standard schedulers which made us expose the shutdown of the underlying thread pools so a servlet can stop them when it gets unloaded.)

I'm not sure what the effect of such shutdown should be beyond stopping the underlying threadpool. Calling clean() on all registered Cleanables and rejecting further register() calls? Returning all registered Cleanables?

--
Best regards,
David Karnok



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170907/21b5b856/attachment.html>

From Roger.Riggs at Oracle.com  Thu Sep  7 10:50:01 2017
From: Roger.Riggs at Oracle.com (Roger Riggs)
Date: Thu, 7 Sep 2017 10:50:01 -0400
Subject: [concurrency-interest] Stopping a java.lang.ref.Cleaner's
 background thread
In-Reply-To: <7D2FE264-BFB7-4824-BE9C-6A702E7095E9@azul.com>
References: <CAAWwtm8sfSyY-WixbMZiBe1eiXOEKCBmh1YFJeB_nhKM-qz0PA@mail.gmail.com>
 <60c0208a-5ac7-df89-db2a-760b06d5a981@Oracle.com>
 <7D2FE264-BFB7-4824-BE9C-6A702E7095E9@azul.com>
Message-ID: <c4ef0daa-40fb-2bb5-470b-4052a448eba0@Oracle.com>

Hi Gene,

Right, I didn't think to mention the baseline of needing to completely 
free all objects
related to the library or subsystem.  That's a necessary step to avoid 
leaks in any unloading
scenerio and bottoms out in the classloaders and statics.

Thanks, Roger

On 9/7/2017 10:28 AM, Gil Tene wrote:
> I think David is asking about "leaking" the associated cleaner thread 
> if it was created by a servlet (e.g. as a shared static member if the 
> servlet׳s class or library), and the servlet gets unloaded. The key 
> wording for the Javadoc about this is:
>
> "...The thread runs until all registered cleaning actions have 
> completed and the cleaner itself is reclaimed by the garbage collector."
>
> So when the last strong reference from the servlet to the cleaner goes 
> away (when the servlet is unloaded), the cleaner itself will be 
> presumably be cleaned (using some other systemic cleaner), and that 
> will stop the thread and eventually collect up.
>
> Sent from my iPad
>
> On Sep 7, 2017, at 6:40 AM, Roger Riggs <Roger.Riggs at Oracle.com 
> <mailto:Roger.Riggs at Oracle.com>> wrote:
>
>> Hi David,
>>
>> It should not be necessary to do anything to the Cleaner thread.
>> The thread is set to be a daemon, so it will not inhibit a clean 
>> return from main.
>> Also, the Cleaner thread will stop itself when all of the cleaner 
>> functions have done their cleanup.
>>
>> Regards, Roger
>>
>>
>> On 9/7/2017 4:55 AM, Dávid Karnok wrote:
>>> Hello.
>>>
>>> Java 9 introduced the handy and official Cleaner infrastructure to 
>>> replace the functionality of finally(). It allows us to create the 
>>> thread it is going to use for the cleanup, which is set to daemon so 
>>> that the JVM can quit.
>>>
>>> However, when running in an "app" container such as Tomcat, I'm not 
>>> sure how to cleanup the Cleaner itself when the servlet gets 
>>> unloaded. (We had similar issues with RxJava's own set of standard 
>>> schedulers which made us expose the shutdown of the underlying 
>>> thread pools so a servlet can stop them when it gets unloaded.)
>>>
>>> I'm not sure what the effect of such shutdown should be beyond 
>>> stopping the underlying threadpool. Calling clean() on all 
>>> registered Cleanables and rejecting further register() calls? 
>>> Returning all registered Cleanables?
>>>
>>> -- 
>>> Best regards,
>>> David Karnok
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu 
>> <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170907/ff030a3f/attachment-0001.html>

From shevek at anarres.org  Thu Sep  7 14:58:05 2017
From: shevek at anarres.org (Shevek)
Date: Thu, 7 Sep 2017 11:58:05 -0700
Subject: [concurrency-interest] Double Checked Locking and String
In-Reply-To: <78BFADB7-9979-4842-AA43-FD35C977D227@googlemail.com>
References: <0800c1e2-67a0-951f-1e4a-39237ae11c8f@anarres.org>
 <78BFADB7-9979-4842-AA43-FD35C977D227@googlemail.com>
Message-ID: <37176383-240c-30f3-02c2-61b2b3611da6@anarres.org>

You're all quite right, of course. Simplifying the example from my 
application code blinded me to the obvious. Thank you immensely.

As for what I'm trying to do: Generate unique textual representation per 
IR symbol in the output stage of a multi-threaded compiler, so the 
compute function has to look at another collection to make sure a string 
name isn't yet issued for use.

S.

On 09/07/2017 04:05 AM, Norman Maurer wrote:
> Why not just use computeIfAbsent(...) ?
> 
> https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html#computeIfAbsent-K-java.util.function.Function-
> 
> Am 07.09.2017 um 13:01 schrieb Shevek <shevek at anarres.org 
> <mailto:shevek at anarres.org>>:
> 
>> Is the following code correct:
>>
>> Map<T, String> m = new ConcurrentHashMap<>();
>>
>> public void getString(T t) {
>>    String out = m.get(t);
>>    if (out != null)
>>        return out;
>>    synchronized (m) {
>>        out = m.get(t);
>>        if (out == null) {
>>            out = String.valueOf(t); // all fields final.
>>            m.put(t, out);
>>        }
>>    }
>>    return out;
>> }
>>
>> The principle being that yes it's a double-checked lock, but the field 
>> in String is final. Is that enough to cause the publication to be 
>> safe? I _think_ this is an instance of FinalWrapperFactory from 
>> https://shipilev.net/blog/2014/safe-public-construction/ but it may be 
>> that the system thinks that there's another read-path for the variable 
>> via the Map, and that makes it not be a safe publication.
>>
>> Thank you.
>>
>> S.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu 
>> <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From notcarl at google.com  Mon Sep 18 13:56:38 2017
From: notcarl at google.com (Carl Mastrangelo)
Date: Mon, 18 Sep 2017 10:56:38 -0700
Subject: [concurrency-interest] Realistic expectations of
	AtomicLongFieldUpdater
Message-ID: <CAAcqB+uwu4ALJgpSgwRjqDwbTsMU8YE3UzqXbZ445Wz-1BpwTw@mail.gmail.com>

Hi concurrency-interest,

The classes AtomicLongFieldUpdater, AtomicReferenceFieldUpdater,
and AtomicIntegerFieldUpdater all have the same ominous comment at the top:

 * <p>Note that the guarantees of the {@code compareAndSet}
 * method in this class are weaker than in other atomic classes.
 * Because this class cannot ensure that all uses of the field
 * are appropriate for purposes of atomic access, it can
 * guarantee atomicity only with respect to other invocations of
 * {@code compareAndSet} and {@code set} on the same updater.


I am not sure how the Java memory model describes what happens to field
updaters, especially in regards to class initialization.  For example
consider the following:


class Foo {
  AtomicIntegerFieldUpdater<Foo> updater =
AtomicIntegerFieldUpdater.newUpdater(Foo.class,
"field");
  private volatile int field = 1;

  public void bar() {
    updater.compareAndSet(this, 1, 2);
  }
}

If two threads try to access field:

T1: final Foo f = new Foo();
T2: f.bar();

Is is guaranteed that subsequent reads of field will be 2?   From the docs
it implies that it may fail, since field was not initialized using
updater.set().  It my reading correct?


After talking to Martin Buccholz, it seems like even reads should be done
using the updater, but doesn't this violate the semantics of volatile?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170918/e6437e91/attachment.html>

From davidcholmes at aapt.net.au  Mon Sep 18 16:53:16 2017
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 19 Sep 2017 06:53:16 +1000
Subject: [concurrency-interest] Realistic expectations
	of	AtomicLongFieldUpdater
In-Reply-To: <CAAcqB+uwu4ALJgpSgwRjqDwbTsMU8YE3UzqXbZ445Wz-1BpwTw@mail.gmail.com>
References: <CAAcqB+uwu4ALJgpSgwRjqDwbTsMU8YE3UzqXbZ445Wz-1BpwTw@mail.gmail.com>
Message-ID: <022e01d330c0$27183bb0$7548b310$@aapt.net.au>

The issue is with atomicity not visibility. The volatile semantics of the field ensure visibility provided the Foo instance is not published during construction. Your example doesn’t show how the Foo instance is published. (And your updater reference would normally be a static).

 

The atomicity caveat is just to account for potential interactions between raw updates and updates via the field updater. Though to be honest I’m having trouble recalling exactly what the issue is.

 

David

 

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Carl Mastrangelo
Sent: Tuesday, September 19, 2017 3:57 AM
To: concurrency-interest at cs.oswego.edu
Subject: [concurrency-interest] Realistic expectations of AtomicLongFieldUpdater

 

Hi concurrency-interest,

 

The classes AtomicLongFieldUpdater, AtomicReferenceFieldUpdater, and AtomicIntegerFieldUpdater all have the same ominous comment at the top:

 

 * <p>Note that the guarantees of the {@code compareAndSet}

 * method in this class are weaker than in other atomic classes.

 * Because this class cannot ensure that all uses of the field

 * are appropriate for purposes of atomic access, it can

 * guarantee atomicity only with respect to other invocations of

 * {@code compareAndSet} and {@code set} on the same updater.

 

 

I am not sure how the Java memory model describes what happens to field updaters, especially in regards to class initialization.  For example consider the following:

 

 

class Foo {

  AtomicIntegerFieldUpdater<Foo> updater = AtomicIntegerFieldUpdater.newUpdater(Foo.class, "field");

  private volatile int field = 1;

 

  public void bar() {

    updater.compareAndSet(this, 1, 2);

  }

}

 

If two threads try to access field:

 

T1: final Foo f = new Foo();

T2: f.bar();

 

Is is guaranteed that subsequent reads of field will be 2?   From the docs it implies that it may fail, since field was not initialized using updater.set().  It my reading correct?

 

 

After talking to Martin Buccholz, it seems like even reads should be done using the updater, but doesn't this violate the semantics of volatile?

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170919/98ead906/attachment.html>

From oleksandr.otenko at gmail.com  Mon Sep 18 18:47:09 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 18 Sep 2017 23:47:09 +0100
Subject: [concurrency-interest] Realistic expectations of
	AtomicLongFieldUpdater
In-Reply-To: <022e01d330c0$27183bb0$7548b310$@aapt.net.au>
References: <CAAcqB+uwu4ALJgpSgwRjqDwbTsMU8YE3UzqXbZ445Wz-1BpwTw@mail.gmail.com>
 <022e01d330c0$27183bb0$7548b310$@aapt.net.au>
Message-ID: <21D4D0AB-2F46-4A85-BDE2-746A81EB5BB6@gmail.com>

I reckon that statement is a permission to implement the Field Updaters using synchronized methods. That way you can guarantee individual Updaters behave atomically, but can’t guarantee atomicity of compare-and-set with respect to the other accesses, and cannot guarantee the Updaters behave atomically, if more than one instance is used - because they may be using different locks.

Typically you need only one static final Field Updater, so the problem does not arise in practice.

Alex


> On 18 Sep 2017, at 21:53, David Holmes <davidcholmes at aapt.net.au> wrote:
> 
> The issue is with atomicity not visibility. The volatile semantics of the field ensure visibility provided the Foo instance is not published during construction. Your example doesn’t show how the Foo instance is published. (And your updater reference would normally be a static).
>  
> The atomicity caveat is just to account for potential interactions between raw updates and updates via the field updater. Though to be honest I’m having trouble recalling exactly what the issue is.
>  
> David
>  
> From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Carl Mastrangelo
> Sent: Tuesday, September 19, 2017 3:57 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Realistic expectations of AtomicLongFieldUpdater
>  
> Hi concurrency-interest,
>  
> The classes AtomicLongFieldUpdater, AtomicReferenceFieldUpdater, and AtomicIntegerFieldUpdater all have the same ominous comment at the top:
>  
>  * <p>Note that the guarantees of the {@code compareAndSet}
>  * method in this class are weaker than in other atomic classes.
>  * Because this class cannot ensure that all uses of the field
>  * are appropriate for purposes of atomic access, it can
>  * guarantee atomicity only with respect to other invocations of
>  * {@code compareAndSet} and {@code set} on the same updater.
>  
>  
> I am not sure how the Java memory model describes what happens to field updaters, especially in regards to class initialization.  For example consider the following:
>  
>  
> class Foo {
>   AtomicIntegerFieldUpdater<Foo> updater = AtomicIntegerFieldUpdater.newUpdater(Foo.class, "field");
>   private volatile int field = 1;
>  
>   public void bar() {
>     updater.compareAndSet(this, 1, 2);
>   }
> }
>  
> If two threads try to access field:
>  
> T1: final Foo f = new Foo();
> T2: f.bar();
>  
> Is is guaranteed that subsequent reads of field will be 2?   From the docs it implies that it may fail, since field was not initialized using updater.set().  It my reading correct?
>  
>  
> After talking to Martin Buccholz, it seems like even reads should be done using the updater, but doesn't this violate the semantics of volatile?
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170918/c65649c1/attachment-0001.html>

From notcarl at google.com  Tue Sep 19 16:33:05 2017
From: notcarl at google.com (Carl Mastrangelo)
Date: Tue, 19 Sep 2017 13:33:05 -0700
Subject: [concurrency-interest] Realistic expectations of
	AtomicLongFieldUpdater
In-Reply-To: <022e01d330c0$27183bb0$7548b310$@aapt.net.au>
References: <CAAcqB+uwu4ALJgpSgwRjqDwbTsMU8YE3UzqXbZ445Wz-1BpwTw@mail.gmail.com>
 <022e01d330c0$27183bb0$7548b310$@aapt.net.au>
Message-ID: <CAAcqB+vbG+gJGb2EPFgmiRiLkhww4Ve_jNY+DzKcgkxMD9ENsA@mail.gmail.com>

I left publishing out on purpose, though the non static field updater was a
typo.

The origin of my question was if I needed to use the updater for field
initialization.   The javadoc implies yes, but it feels incorrect.

On Mon, Sep 18, 2017 at 1:53 PM, David Holmes <davidcholmes at aapt.net.au>
wrote:

> The issue is with atomicity not visibility. The volatile semantics of the
> field ensure visibility provided the Foo instance is not published during
> construction. Your example doesn’t show how the Foo instance is published.
> (And your updater reference would normally be a static).
>
>
>
> The atomicity caveat is just to account for potential interactions between
> raw updates and updates via the field updater. Though to be honest I’m
> having trouble recalling exactly what the issue is.
>
>
>
> David
>
>
>
> *From:* Concurrency-interest [mailto:concurrency-interest-
> bounces at cs.oswego.edu] *On Behalf Of *Carl Mastrangelo
> *Sent:* Tuesday, September 19, 2017 3:57 AM
> *To:* concurrency-interest at cs.oswego.edu
> *Subject:* [concurrency-interest] Realistic expectations of
> AtomicLongFieldUpdater
>
>
>
> Hi concurrency-interest,
>
>
>
> The classes AtomicLongFieldUpdater, AtomicReferenceFieldUpdater,
> and AtomicIntegerFieldUpdater all have the same ominous comment at the top:
>
>
>
>  * <p>Note that the guarantees of the {@code compareAndSet}
>
>  * method in this class are weaker than in other atomic classes.
>
>  * Because this class cannot ensure that all uses of the field
>
>  * are appropriate for purposes of atomic access, it can
>
>  * guarantee atomicity only with respect to other invocations of
>
>  * {@code compareAndSet} and {@code set} on the same updater.
>
>
>
>
>
> I am not sure how the Java memory model describes what happens to field
> updaters, especially in regards to class initialization.  For example
> consider the following:
>
>
>
>
>
> class Foo {
>
>   AtomicIntegerFieldUpdater<Foo> updater = AtomicIntegerFieldUpdater.newUpdater(Foo.class,
> "field");
>
>   private volatile int field = 1;
>
>
>
>   public void bar() {
>
>     updater.compareAndSet(this, 1, 2);
>
>   }
>
> }
>
>
>
> If two threads try to access field:
>
>
>
> T1: final Foo f = new Foo();
>
> T2: f.bar();
>
>
>
> Is is guaranteed that subsequent reads of field will be 2?   From the docs
> it implies that it may fail, since field was not initialized using
> updater.set().  It my reading correct?
>
>
>
>
>
> After talking to Martin Buccholz, it seems like even reads should be done
> using the updater, but doesn't this violate the semantics of volatile?
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170919/3273fc73/attachment.html>

From notcarl at google.com  Tue Sep 19 16:35:15 2017
From: notcarl at google.com (Carl Mastrangelo)
Date: Tue, 19 Sep 2017 13:35:15 -0700
Subject: [concurrency-interest] Realistic expectations of
	AtomicLongFieldUpdater
In-Reply-To: <21D4D0AB-2F46-4A85-BDE2-746A81EB5BB6@gmail.com>
References: <CAAcqB+uwu4ALJgpSgwRjqDwbTsMU8YE3UzqXbZ445Wz-1BpwTw@mail.gmail.com>
 <022e01d330c0$27183bb0$7548b310$@aapt.net.au>
 <21D4D0AB-2F46-4A85-BDE2-746A81EB5BB6@gmail.com>
Message-ID: <CAAcqB+vYh1ve2DbWgkq7P0vkCQN8fu1o5OKFHeSQDVi3qJuH6w@mail.gmail.com>

If they are using different locks, wouldn't that imply that reads of a
volatile field might not see all published updates, since the updater might
acquire a different lock  (which would be in violation of the JMM) ?

On Mon, Sep 18, 2017 at 3:47 PM, Alex Otenko <oleksandr.otenko at gmail.com>
wrote:

> I reckon that statement is a permission to implement the Field Updaters
> using synchronized methods. That way you can guarantee individual Updaters
> behave atomically, but can’t guarantee atomicity of compare-and-set with
> respect to the other accesses, and cannot guarantee the Updaters behave
> atomically, if more than one instance is used - because they may be using
> different locks.
>
> Typically you need only one static final Field Updater, so the problem
> does not arise in practice.
>
> Alex
>
>
> On 18 Sep 2017, at 21:53, David Holmes <davidcholmes at aapt.net.au> wrote:
>
> The issue is with atomicity not visibility. The volatile semantics of the
> field ensure visibility provided the Foo instance is not published during
> construction. Your example doesn’t show how the Foo instance is published.
> (And your updater reference would normally be a static).
>
> The atomicity caveat is just to account for potential interactions between
> raw updates and updates via the field updater. Though to be honest I’m
> having trouble recalling exactly what the issue is.
>
> David
>
> *From:* Concurrency-interest [mailto:concurrency-interest-
> bounces at cs.oswego.edu <concurrency-interest-bounces at cs.oswego.edu>] *On
> Behalf Of *Carl Mastrangelo
> *Sent:* Tuesday, September 19, 2017 3:57 AM
> *To:* concurrency-interest at cs.oswego.edu
> *Subject:* [concurrency-interest] Realistic expectations of
> AtomicLongFieldUpdater
>
> Hi concurrency-interest,
>
> The classes AtomicLongFieldUpdater, AtomicReferenceFieldUpdater,
> and AtomicIntegerFieldUpdater all have the same ominous comment at the top:
>
>  * <p>Note that the guarantees of the {@code compareAndSet}
>  * method in this class are weaker than in other atomic classes.
>  * Because this class cannot ensure that all uses of the field
>  * are appropriate for purposes of atomic access, it can
>  * guarantee atomicity only with respect to other invocations of
>  * {@code compareAndSet} and {@code set} on the same updater.
>
>
> I am not sure how the Java memory model describes what happens to field
> updaters, especially in regards to class initialization.  For example
> consider the following:
>
>
> class Foo {
>   AtomicIntegerFieldUpdater<Foo> updater = AtomicIntegerFieldUpdater.newUpdater(Foo.class,
> "field");
>   private volatile int field = 1;
>
>   public void bar() {
>     updater.compareAndSet(this, 1, 2);
>   }
> }
>
> If two threads try to access field:
>
> T1: final Foo f = new Foo();
> T2: f.bar();
>
> Is is guaranteed that subsequent reads of field will be 2?   From the docs
> it implies that it may fail, since field was not initialized using
> updater.set().  It my reading correct?
>
>
> After talking to Martin Buccholz, it seems like even reads should be done
> using the updater, but doesn't this violate the semantics of volatile?
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170919/882d0c75/attachment-0001.html>

From davidcholmes at aapt.net.au  Tue Sep 19 16:40:25 2017
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 20 Sep 2017 06:40:25 +1000
Subject: [concurrency-interest] Realistic expectations of
	AtomicLongFieldUpdater
In-Reply-To: <CAAcqB+vbG+gJGb2EPFgmiRiLkhww4Ve_jNY+DzKcgkxMD9ENsA@mail.gmail.com>
References: <CAAcqB+uwu4ALJgpSgwRjqDwbTsMU8YE3UzqXbZ445Wz-1BpwTw@mail.gmail.com>
 <022e01d330c0$27183bb0$7548b310$@aapt.net.au>
 <CAAcqB+vbG+gJGb2EPFgmiRiLkhww4Ve_jNY+DzKcgkxMD9ENsA@mail.gmail.com>
Message-ID: <029d01d33187$85a2a090$90e7e1b0$@aapt.net.au>

I don’t agree the Javadoc implies that. As I said the issue is atomicity not visibility – the field is volatile. At initialization you have not published the instance and so atomicity is not an issue (not that it would generally be an issue anyway – all loads and stores have to be atomic as it is volatile).

 

Cheers,

David

 

From: Carl Mastrangelo [mailto:notcarl at google.com] 
Sent: Wednesday, September 20, 2017 6:33 AM
To: dholmes at ieee.org
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Realistic expectations of AtomicLongFieldUpdater

 

I left publishing out on purpose, though the non static field updater was a typo.   

 

The origin of my question was if I needed to use the updater for field initialization.   The javadoc implies yes, but it feels incorrect.  

 

On Mon, Sep 18, 2017 at 1:53 PM, David Holmes <davidcholmes at aapt.net.au <mailto:davidcholmes at aapt.net.au> > wrote:

The issue is with atomicity not visibility. The volatile semantics of the field ensure visibility provided the Foo instance is not published during construction. Your example doesn’t show how the Foo instance is published. (And your updater reference would normally be a static).

 

The atomicity caveat is just to account for potential interactions between raw updates and updates via the field updater. Though to be honest I’m having trouble recalling exactly what the issue is.

 

David

 

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu <mailto:concurrency-interest-bounces at cs.oswego.edu> ] On Behalf Of Carl Mastrangelo
Sent: Tuesday, September 19, 2017 3:57 AM
To: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu> 
Subject: [concurrency-interest] Realistic expectations of AtomicLongFieldUpdater

 

Hi concurrency-interest,

 

The classes AtomicLongFieldUpdater, AtomicReferenceFieldUpdater, and AtomicIntegerFieldUpdater all have the same ominous comment at the top:

 

 * <p>Note that the guarantees of the {@code compareAndSet}

 * method in this class are weaker than in other atomic classes.

 * Because this class cannot ensure that all uses of the field

 * are appropriate for purposes of atomic access, it can

 * guarantee atomicity only with respect to other invocations of

 * {@code compareAndSet} and {@code set} on the same updater.

 

 

I am not sure how the Java memory model describes what happens to field updaters, especially in regards to class initialization.  For example consider the following:

 

 

class Foo {

  AtomicIntegerFieldUpdater<Foo> updater = AtomicIntegerFieldUpdater.newUpdater(Foo.class, "field");

  private volatile int field = 1;

 

  public void bar() {

    updater.compareAndSet(this, 1, 2);

  }

}

 

If two threads try to access field:

 

T1: final Foo f = new Foo();

T2: f.bar();

 

Is is guaranteed that subsequent reads of field will be 2?   From the docs it implies that it may fail, since field was not initialized using updater.set().  It my reading correct?

 

 

After talking to Martin Buccholz, it seems like even reads should be done using the updater, but doesn't this violate the semantics of volatile?

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170920/59801369/attachment.html>

From davidcholmes at aapt.net.au  Tue Sep 19 16:41:20 2017
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 20 Sep 2017 06:41:20 +1000
Subject: [concurrency-interest] Realistic expectations of
	AtomicLongFieldUpdater
In-Reply-To: <CAAcqB+vYh1ve2DbWgkq7P0vkCQN8fu1o5OKFHeSQDVi3qJuH6w@mail.gmail.com>
References: <CAAcqB+uwu4ALJgpSgwRjqDwbTsMU8YE3UzqXbZ445Wz-1BpwTw@mail.gmail.com>
 <022e01d330c0$27183bb0$7548b310$@aapt.net.au>
 <21D4D0AB-2F46-4A85-BDE2-746A81EB5BB6@gmail.com>
 <CAAcqB+vYh1ve2DbWgkq7P0vkCQN8fu1o5OKFHeSQDVi3qJuH6w@mail.gmail.com>
Message-ID: <02a701d33187$a69fe8c0$f3dfba40$@aapt.net.au>

The field itself is volatile.

 

David

 

From: Carl Mastrangelo [mailto:notcarl at google.com] 
Sent: Wednesday, September 20, 2017 6:35 AM
To: Alex Otenko <oleksandr.otenko at gmail.com>
Cc: dholmes at ieee.org; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Realistic expectations of AtomicLongFieldUpdater

 

If they are using different locks, wouldn't that imply that reads of a volatile field might not see all published updates, since the updater might acquire a different lock  (which would be in violation of the JMM) ?

 

On Mon, Sep 18, 2017 at 3:47 PM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com> > wrote:

I reckon that statement is a permission to implement the Field Updaters using synchronized methods. That way you can guarantee individual Updaters behave atomically, but can’t guarantee atomicity of compare-and-set with respect to the other accesses, and cannot guarantee the Updaters behave atomically, if more than one instance is used - because they may be using different locks.

 

Typically you need only one static final Field Updater, so the problem does not arise in practice.

 

Alex

 

 

On 18 Sep 2017, at 21:53, David Holmes <davidcholmes at aapt.net.au <mailto:davidcholmes at aapt.net.au> > wrote:

 

The issue is with atomicity not visibility. The volatile semantics of the field ensure visibility provided the Foo instance is not published during construction. Your example doesn’t show how the Foo instance is published. (And your updater reference would normally be a static).

 

The atomicity caveat is just to account for potential interactions between raw updates and updates via the field updater. Though to be honest I’m having trouble recalling exactly what the issue is.

 

David

 

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Carl Mastrangelo
Sent: Tuesday, September 19, 2017 3:57 AM
To: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu> 
Subject: [concurrency-interest] Realistic expectations of AtomicLongFieldUpdater

 

Hi concurrency-interest,

 

The classes AtomicLongFieldUpdater, AtomicReferenceFieldUpdater, and AtomicIntegerFieldUpdater all have the same ominous comment at the top:

 

 * <p>Note that the guarantees of the {@code compareAndSet}

 * method in this class are weaker than in other atomic classes.

 * Because this class cannot ensure that all uses of the field

 * are appropriate for purposes of atomic access, it can

 * guarantee atomicity only with respect to other invocations of

 * {@code compareAndSet} and {@code set} on the same updater.

 

 

I am not sure how the Java memory model describes what happens to field updaters, especially in regards to class initialization.  For example consider the following:

 

 

class Foo {

  AtomicIntegerFieldUpdater<Foo> updater = AtomicIntegerFieldUpdater.newUpdater(Foo.class, "field");

  private volatile int field = 1;

 

  public void bar() {

    updater.compareAndSet(this, 1, 2);

  }

}

 

If two threads try to access field:

 

T1: final Foo f = new Foo();

T2: f.bar();

 

Is is guaranteed that subsequent reads of field will be 2?   From the docs it implies that it may fail, since field was not initialized using updater.set().  It my reading correct?

 

 

After talking to Martin Buccholz, it seems like even reads should be done using the updater, but doesn't this violate the semantics of volatile?

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> 
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170920/076de3f5/attachment-0001.html>

From oleksandr.otenko at gmail.com  Wed Sep 20 02:58:38 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Wed, 20 Sep 2017 07:58:38 +0100
Subject: [concurrency-interest] Realistic expectations of
	AtomicLongFieldUpdater
In-Reply-To: <CAAcqB+vYh1ve2DbWgkq7P0vkCQN8fu1o5OKFHeSQDVi3qJuH6w@mail.gmail.com>
References: <CAAcqB+uwu4ALJgpSgwRjqDwbTsMU8YE3UzqXbZ445Wz-1BpwTw@mail.gmail.com>
 <022e01d330c0$27183bb0$7548b310$@aapt.net.au>
 <21D4D0AB-2F46-4A85-BDE2-746A81EB5BB6@gmail.com>
 <CAAcqB+vYh1ve2DbWgkq7P0vkCQN8fu1o5OKFHeSQDVi3qJuH6w@mail.gmail.com>
Message-ID: <6872D424-0A36-4D49-9012-6C2D0E5C5ADB@gmail.com>

The updates should be observable by all threads, because they are volatile accesses inside, but the statement about “the same updater” means that atomicity of compareAndSet may be implemented through means other than an intrinsic CAS with/or global lock - all other accesses are atomic by JMM.

For example, a store to the volatile may interleave with compareAndSet and you may observe “non-intuitive results”, unless you are using the set method on the same updater.

(“non-intuitive” means “the execution that isn’t observable with atomic compareAndSet”, but JMM doesn’t have a definition of compareAndSet, so you can’t call it “broken” so easily)

Alex

> On 19 Sep 2017, at 21:35, Carl Mastrangelo <notcarl at google.com> wrote:
> 
> If they are using different locks, wouldn't that imply that reads of a volatile field might not see all published updates, since the updater might acquire a different lock  (which would be in violation of the JMM) ?
> 
> On Mon, Sep 18, 2017 at 3:47 PM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
> I reckon that statement is a permission to implement the Field Updaters using synchronized methods. That way you can guarantee individual Updaters behave atomically, but can’t guarantee atomicity of compare-and-set with respect to the other accesses, and cannot guarantee the Updaters behave atomically, if more than one instance is used - because they may be using different locks.
> 
> Typically you need only one static final Field Updater, so the problem does not arise in practice.
> 
> Alex
> 
> 
>> On 18 Sep 2017, at 21:53, David Holmes <davidcholmes at aapt.net.au <mailto:davidcholmes at aapt.net.au>> wrote:
>> 
>> The issue is with atomicity not visibility. The volatile semantics of the field ensure visibility provided the Foo instance is not published during construction. Your example doesn’t show how the Foo instance is published. (And your updater reference would normally be a static).
>>  
>> The atomicity caveat is just to account for potential interactions between raw updates and updates via the field updater. Though to be honest I’m having trouble recalling exactly what the issue is.
>>  
>> David
>>  
>> From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu <mailto:concurrency-interest-bounces at cs.oswego.edu>] On Behalf Of Carl Mastrangelo
>> Sent: Tuesday, September 19, 2017 3:57 AM
>> To: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>
>> Subject: [concurrency-interest] Realistic expectations of AtomicLongFieldUpdater
>>  
>> Hi concurrency-interest,
>>  
>> The classes AtomicLongFieldUpdater, AtomicReferenceFieldUpdater, and AtomicIntegerFieldUpdater all have the same ominous comment at the top:
>>  
>>  * <p>Note that the guarantees of the {@code compareAndSet}
>>  * method in this class are weaker than in other atomic classes.
>>  * Because this class cannot ensure that all uses of the field
>>  * are appropriate for purposes of atomic access, it can
>>  * guarantee atomicity only with respect to other invocations of
>>  * {@code compareAndSet} and {@code set} on the same updater.
>>  
>>  
>> I am not sure how the Java memory model describes what happens to field updaters, especially in regards to class initialization.  For example consider the following:
>>  
>>  
>> class Foo {
>>   AtomicIntegerFieldUpdater<Foo> updater = AtomicIntegerFieldUpdater.newUpdater(Foo.class, "field");
>>   private volatile int field = 1;
>>  
>>   public void bar() {
>>     updater.compareAndSet(this, 1, 2);
>>   }
>> }
>>  
>> If two threads try to access field:
>>  
>> T1: final Foo f = new Foo();
>> T2: f.bar();
>>  
>> Is is guaranteed that subsequent reads of field will be 2?   From the docs it implies that it may fail, since field was not initialized using updater.set().  It my reading correct?
>>  
>>  
>> After talking to Martin Buccholz, it seems like even reads should be done using the updater, but doesn't this violate the semantics of volatile?
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170920/b836649f/attachment.html>

From notcarl at google.com  Wed Sep 20 21:31:28 2017
From: notcarl at google.com (Carl Mastrangelo)
Date: Wed, 20 Sep 2017 18:31:28 -0700
Subject: [concurrency-interest] Realistic expectations of
	AtomicLongFieldUpdater
In-Reply-To: <029d01d33187$85a2a090$90e7e1b0$@aapt.net.au>
References: <CAAcqB+uwu4ALJgpSgwRjqDwbTsMU8YE3UzqXbZ445Wz-1BpwTw@mail.gmail.com>
 <022e01d330c0$27183bb0$7548b310$@aapt.net.au>
 <CAAcqB+vbG+gJGb2EPFgmiRiLkhww4Ve_jNY+DzKcgkxMD9ENsA@mail.gmail.com>
 <029d01d33187$85a2a090$90e7e1b0$@aapt.net.au>
Message-ID: <CAAcqB+ubPiVYbFgakhsqWQWtkZiZzD_T61=XSKubq-xaQYa39g@mail.gmail.com>

I still don't understand.  I have included a copy of the javadoc I am
reading:

"""
Note that the guarantees of the compareAndSet method in this class are
weaker than in other atomic classes. Because this class cannot ensure that
all uses of the field are appropriate for purposes of atomic access, it can
guarantee atomicity only with respect to other invocations of compareAndSet
 and set on the same updater.
"""

So here is my reasoning:

1.  Modifications of a variable using the updater are atomic if and only if
using set() or compareAndSet()
2.  Volatile variable initialization is not done using the set() or
compareAndSet()
3.  Therefore,  compareAndSet is not atomic.

The conclusion seems absurd, but follows the javadoc.  What am I missing?




On Tue, Sep 19, 2017 at 1:40 PM, David Holmes <davidcholmes at aapt.net.au>
wrote:

> I don’t agree the Javadoc implies that. As I said the issue is atomicity
> not visibility – the field is volatile. At initialization you have not
> published the instance and so atomicity is not an issue (not that it would
> generally be an issue anyway – all loads and stores have to be atomic as it
> is volatile).
>
>
>
> Cheers,
>
> David
>
>
>
> *From:* Carl Mastrangelo [mailto:notcarl at google.com]
> *Sent:* Wednesday, September 20, 2017 6:33 AM
> *To:* dholmes at ieee.org
> *Cc:* concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Realistic expectations of
> AtomicLongFieldUpdater
>
>
>
> I left publishing out on purpose, though the non static field updater was
> a typo.
>
>
>
> The origin of my question was if I needed to use the updater for field
> initialization.   The javadoc implies yes, but it feels incorrect.
>
>
>
> On Mon, Sep 18, 2017 at 1:53 PM, David Holmes <davidcholmes at aapt.net.au>
> wrote:
>
> The issue is with atomicity not visibility. The volatile semantics of the
> field ensure visibility provided the Foo instance is not published during
> construction. Your example doesn’t show how the Foo instance is published.
> (And your updater reference would normally be a static).
>
>
>
> The atomicity caveat is just to account for potential interactions between
> raw updates and updates via the field updater. Though to be honest I’m
> having trouble recalling exactly what the issue is.
>
>
>
> David
>
>
>
> *From:* Concurrency-interest [mailto:concurrency-interest-
> bounces at cs.oswego.edu] *On Behalf Of *Carl Mastrangelo
> *Sent:* Tuesday, September 19, 2017 3:57 AM
> *To:* concurrency-interest at cs.oswego.edu
> *Subject:* [concurrency-interest] Realistic expectations of
> AtomicLongFieldUpdater
>
>
>
> Hi concurrency-interest,
>
>
>
> The classes AtomicLongFieldUpdater, AtomicReferenceFieldUpdater,
> and AtomicIntegerFieldUpdater all have the same ominous comment at the top:
>
>
>
>  * <p>Note that the guarantees of the {@code compareAndSet}
>
>  * method in this class are weaker than in other atomic classes.
>
>  * Because this class cannot ensure that all uses of the field
>
>  * are appropriate for purposes of atomic access, it can
>
>  * guarantee atomicity only with respect to other invocations of
>
>  * {@code compareAndSet} and {@code set} on the same updater.
>
>
>
>
>
> I am not sure how the Java memory model describes what happens to field
> updaters, especially in regards to class initialization.  For example
> consider the following:
>
>
>
>
>
> class Foo {
>
>   AtomicIntegerFieldUpdater<Foo> updater = AtomicIntegerFieldUpdater.newUpdater(Foo.class,
> "field");
>
>   private volatile int field = 1;
>
>
>
>   public void bar() {
>
>     updater.compareAndSet(this, 1, 2);
>
>   }
>
> }
>
>
>
> If two threads try to access field:
>
>
>
> T1: final Foo f = new Foo();
>
> T2: f.bar();
>
>
>
> Is is guaranteed that subsequent reads of field will be 2?   From the docs
> it implies that it may fail, since field was not initialized using
> updater.set().  It my reading correct?
>
>
>
>
>
> After talking to Martin Buccholz, it seems like even reads should be done
> using the updater, but doesn't this violate the semantics of volatile?
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170920/7b7e53f1/attachment.html>

From notcarl at google.com  Wed Sep 20 21:33:30 2017
From: notcarl at google.com (Carl Mastrangelo)
Date: Wed, 20 Sep 2017 18:33:30 -0700
Subject: [concurrency-interest] Realistic expectations of
	AtomicLongFieldUpdater
In-Reply-To: <6872D424-0A36-4D49-9012-6C2D0E5C5ADB@gmail.com>
References: <CAAcqB+uwu4ALJgpSgwRjqDwbTsMU8YE3UzqXbZ445Wz-1BpwTw@mail.gmail.com>
 <022e01d330c0$27183bb0$7548b310$@aapt.net.au>
 <21D4D0AB-2F46-4A85-BDE2-746A81EB5BB6@gmail.com>
 <CAAcqB+vYh1ve2DbWgkq7P0vkCQN8fu1o5OKFHeSQDVi3qJuH6w@mail.gmail.com>
 <6872D424-0A36-4D49-9012-6C2D0E5C5ADB@gmail.com>
Message-ID: <CAAcqB+uex8qfP7LZxpv6PDs-bhFpehBR8vk5JR_pvZ4jrg4jGw@mail.gmail.com>

What would be the difficulty be in defining the behavior in the JMM?  Or
has this already been done because of VarHandles?

On Tue, Sep 19, 2017 at 11:58 PM, Alex Otenko <oleksandr.otenko at gmail.com>
wrote:

> The updates should be observable by all threads, because they are volatile
> accesses inside, but the statement about “the same updater” means that
> atomicity of compareAndSet may be implemented through means other than an
> intrinsic CAS with/or global lock - all other accesses are atomic by JMM.
>
> For example, a store to the volatile may interleave with compareAndSet and
> you may observe “non-intuitive results”, unless you are using the set
> method on the same updater.
>
> (“non-intuitive” means “the execution that isn’t observable with atomic
> compareAndSet”, but JMM doesn’t have a definition of compareAndSet, so you
> can’t call it “broken” so easily)
>
> Alex
>
> On 19 Sep 2017, at 21:35, Carl Mastrangelo <notcarl at google.com> wrote:
>
> If they are using different locks, wouldn't that imply that reads of a
> volatile field might not see all published updates, since the updater might
> acquire a different lock  (which would be in violation of the JMM) ?
>
> On Mon, Sep 18, 2017 at 3:47 PM, Alex Otenko <oleksandr.otenko at gmail.com>
> wrote:
>
>> I reckon that statement is a permission to implement the Field Updaters
>> using synchronized methods. That way you can guarantee individual Updaters
>> behave atomically, but can’t guarantee atomicity of compare-and-set with
>> respect to the other accesses, and cannot guarantee the Updaters behave
>> atomically, if more than one instance is used - because they may be using
>> different locks.
>>
>> Typically you need only one static final Field Updater, so the problem
>> does not arise in practice.
>>
>> Alex
>>
>>
>> On 18 Sep 2017, at 21:53, David Holmes <davidcholmes at aapt.net.au> wrote:
>>
>> The issue is with atomicity not visibility. The volatile semantics of the
>> field ensure visibility provided the Foo instance is not published during
>> construction. Your example doesn’t show how the Foo instance is published.
>> (And your updater reference would normally be a static).
>>
>> The atomicity caveat is just to account for potential interactions
>> between raw updates and updates via the field updater. Though to be honest
>> I’m having trouble recalling exactly what the issue is.
>>
>> David
>>
>> *From:* Concurrency-interest [mailto:concurrency-interest-b
>> ounces at cs.oswego.edu <concurrency-interest-bounces at cs.oswego.edu>] *On
>> Behalf Of *Carl Mastrangelo
>> *Sent:* Tuesday, September 19, 2017 3:57 AM
>> *To:* concurrency-interest at cs.oswego.edu
>> *Subject:* [concurrency-interest] Realistic expectations of
>> AtomicLongFieldUpdater
>>
>> Hi concurrency-interest,
>>
>> The classes AtomicLongFieldUpdater, AtomicReferenceFieldUpdater,
>> and AtomicIntegerFieldUpdater all have the same ominous comment at the top:
>>
>>  * <p>Note that the guarantees of the {@code compareAndSet}
>>  * method in this class are weaker than in other atomic classes.
>>  * Because this class cannot ensure that all uses of the field
>>  * are appropriate for purposes of atomic access, it can
>>  * guarantee atomicity only with respect to other invocations of
>>  * {@code compareAndSet} and {@code set} on the same updater.
>>
>>
>> I am not sure how the Java memory model describes what happens to field
>> updaters, especially in regards to class initialization.  For example
>> consider the following:
>>
>>
>> class Foo {
>>   AtomicIntegerFieldUpdater<Foo> updater = AtomicIntegerFieldUpdater.newUpdater(Foo.class,
>> "field");
>>   private volatile int field = 1;
>>
>>   public void bar() {
>>     updater.compareAndSet(this, 1, 2);
>>   }
>> }
>>
>> If two threads try to access field:
>>
>> T1: final Foo f = new Foo();
>> T2: f.bar();
>>
>> Is is guaranteed that subsequent reads of field will be 2?   From the
>> docs it implies that it may fail, since field was not initialized using
>> updater.set().  It my reading correct?
>>
>>
>> After talking to Martin Buccholz, it seems like even reads should be done
>> using the updater, but doesn't this violate the semantics of volatile?
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170920/659f88db/attachment-0001.html>

From davidcholmes at aapt.net.au  Wed Sep 20 21:50:35 2017
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 21 Sep 2017 11:50:35 +1000
Subject: [concurrency-interest] Realistic expectations of
	AtomicLongFieldUpdater
Message-ID: <034801d3327c$05073bd0$0f15b370$@aapt.net.au>

If you use more than one updater to update the same field, or you mix updater use with raw access, then there is no guarantee of atomicity.

 

For initialization, as long as you don’t publish “this” before construction is complete, there can be no atomicity issues because there is no concurrency.

 

David

 

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Carl Mastrangelo
Sent: Thursday, September 21, 2017 11:31 AM
To: dholmes at ieee.org
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Realistic expectations of AtomicLongFieldUpdater

 

I still don't understand.  I have included a copy of the javadoc I am reading:

 

"""

Note that the guarantees of the compareAndSet method in this class are weaker than in other atomic classes. Because this class cannot ensure that all uses of the field are appropriate for purposes of atomic access, it can guarantee atomicity only with respect to other invocations of compareAndSet and set on the same updater.

"""

 

So here is my reasoning:

 

1.  Modifications of a variable using the updater are atomic if and only if using set() or compareAndSet()

2.  Volatile variable initialization is not done using the set() or compareAndSet()

3.  Therefore,  compareAndSet is not atomic.

 

The conclusion seems absurd, but follows the javadoc.  What am I missing?

 

 

 

 

On Tue, Sep 19, 2017 at 1:40 PM, David Holmes <davidcholmes at aapt.net.au <mailto:davidcholmes at aapt.net.au> > wrote:

I don’t agree the Javadoc implies that. As I said the issue is atomicity not visibility – the field is volatile. At initialization you have not published the instance and so atomicity is not an issue (not that it would generally be an issue anyway – all loads and stores have to be atomic as it is volatile).

 

Cheers,

David

 

From: Carl Mastrangelo [mailto:notcarl at google.com <mailto:notcarl at google.com> ] 
Sent: Wednesday, September 20, 2017 6:33 AM
To: dholmes at ieee.org <mailto:dholmes at ieee.org> 
Cc: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu> 
Subject: Re: [concurrency-interest] Realistic expectations of AtomicLongFieldUpdater

 

I left publishing out on purpose, though the non static field updater was a typo.   

 

The origin of my question was if I needed to use the updater for field initialization.   The javadoc implies yes, but it feels incorrect.  

 

On Mon, Sep 18, 2017 at 1:53 PM, David Holmes <davidcholmes at aapt.net.au <mailto:davidcholmes at aapt.net.au> > wrote:

The issue is with atomicity not visibility. The volatile semantics of the field ensure visibility provided the Foo instance is not published during construction. Your example doesn’t show how the Foo instance is published. (And your updater reference would normally be a static).

 

The atomicity caveat is just to account for potential interactions between raw updates and updates via the field updater. Though to be honest I’m having trouble recalling exactly what the issue is.

 

David

 

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu <mailto:concurrency-interest-bounces at cs.oswego.edu> ] On Behalf Of Carl Mastrangelo
Sent: Tuesday, September 19, 2017 3:57 AM
To: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu> 
Subject: [concurrency-interest] Realistic expectations of AtomicLongFieldUpdater

 

Hi concurrency-interest,

 

The classes AtomicLongFieldUpdater, AtomicReferenceFieldUpdater, and AtomicIntegerFieldUpdater all have the same ominous comment at the top:

 

 * <p>Note that the guarantees of the {@code compareAndSet}

 * method in this class are weaker than in other atomic classes.

 * Because this class cannot ensure that all uses of the field

 * are appropriate for purposes of atomic access, it can

 * guarantee atomicity only with respect to other invocations of

 * {@code compareAndSet} and {@code set} on the same updater.

 

 

I am not sure how the Java memory model describes what happens to field updaters, especially in regards to class initialization.  For example consider the following:

 

 

class Foo {

  AtomicIntegerFieldUpdater<Foo> updater = AtomicIntegerFieldUpdater.newUpdater(Foo.class, "field");

  private volatile int field = 1;

 

  public void bar() {

    updater.compareAndSet(this, 1, 2);

  }

}

 

If two threads try to access field:

 

T1: final Foo f = new Foo();

T2: f.bar();

 

Is is guaranteed that subsequent reads of field will be 2?   From the docs it implies that it may fail, since field was not initialized using updater.set().  It my reading correct?

 

 

After talking to Martin Buccholz, it seems like even reads should be done using the updater, but doesn't this violate the semantics of volatile?

 

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170921/04462d61/attachment.html>

From dl at cs.oswego.edu  Thu Sep 21 08:26:53 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 21 Sep 2017 08:26:53 -0400
Subject: [concurrency-interest] Realistic expectations of
 AtomicLongFieldUpdater
In-Reply-To: <CAAcqB+ubPiVYbFgakhsqWQWtkZiZzD_T61=XSKubq-xaQYa39g@mail.gmail.com>
References: <CAAcqB+uwu4ALJgpSgwRjqDwbTsMU8YE3UzqXbZ445Wz-1BpwTw@mail.gmail.com>
 <022e01d330c0$27183bb0$7548b310$@aapt.net.au>
 <CAAcqB+vbG+gJGb2EPFgmiRiLkhww4Ve_jNY+DzKcgkxMD9ENsA@mail.gmail.com>
 <029d01d33187$85a2a090$90e7e1b0$@aapt.net.au>
 <CAAcqB+ubPiVYbFgakhsqWQWtkZiZzD_T61=XSKubq-xaQYa39g@mail.gmail.com>
Message-ID: <0c5b7861-a390-858f-cdfd-467039bb2114@cs.oswego.edu>

On 09/20/2017 09:31 PM, Carl Mastrangelo wrote:
> I still don't understand.  I have included a copy of the javadoc I am
> reading:
> 
> """
> Note that the guarantees of the |compareAndSet| method in this class are
> weaker than in other atomic classes. Because this class cannot ensure
> that all uses of the field are appropriate for purposes of atomic
> access, it can guarantee atomicity only with respect to other
> invocations of |compareAndSet| and |set| on the same updater.
> """
> 
> So here is my reasoning:
> 
> 1.  Modifications of a variable using the updater are atomic if and only
> if using set() or compareAndSet()
> 2.  Volatile variable initialization is not done using the set() or
> compareAndSet()
> 3.  Therefore,  compareAndSet is not atomic.
> 
> The conclusion seems absurd, but follows the javadoc.  What am I missing?
> 

The disclaimer was initially introduced (late in Java 1.5 development)
because of a few seldom-used, now-obsolete processors (Power5, some Via
chips) without a CAS-like operation as wide as the corresponding
bitwise-atomic write.  It is obviously a crummy state of affairs,
in that practically no one ever needed to pay attention to the
disclaimer (but was there just in case), and it does not apply to
any current platforms. It does not appear in VarHandle specs (that
normally replace FieldUpdaters anyway). Since the disclaimer will never
be needed again  (no processor designed after the year 2000 or so would
do this), it should be removed. (It also has no impact on j.u.c
internals, since they all use VarHandles instead of FieldUpdaters).

-Doug



From pavel.rappo at gmail.com  Mon Sep 25 09:21:01 2017
From: pavel.rappo at gmail.com (Pavel Rappo)
Date: Mon, 25 Sep 2017 14:21:01 +0100
Subject: [concurrency-interest] A race in SubmissionPublisher?
Message-ID: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>

Hi,

I've been using SubmissionPublisher in my own publisher implementation in order
to reuse its complex state machine that serializes invocations to subscribers.

While testing my implementation I ran into what I believe might be a race
condition in SubmissionPublisher.

Consider the following example:

    public class SubmissionPublisherTest {

        private final static int N = 1 << 20;

        private final AtomicInteger numbers = new AtomicInteger();
        private final SubmissionPublisher<Integer> pub = new
SubmissionPublisher<>();
        private final ExecutorService pubExecutor =
Executors.newSingleThreadExecutor();
        private final CountDownLatch finished = new CountDownLatch(1);

        public static void main(String[] args) throws InterruptedException {
            new SubmissionPublisherTest().run();
        }

        private void run() throws InterruptedException {
            pub.subscribe(newSubscriber());
            try {
                finished.await(30, TimeUnit.SECONDS);
            } finally {
                pubExecutor.shutdownNow();
            }
            System.out.println("Finished");
        }

        private Flow.Subscriber<Integer> newSubscriber() {
            return new Flow.Subscriber<>() {

                Flow.Subscription sub;
                int received;

                @Override
                public void onSubscribe(Flow.Subscription s) {
                    (this.sub = s).request(N);
                    publish();
                }

                @Override
                public void onNext(Integer item) {
                    if (++received == N) finished.countDown();
                    publish();
                    System.out.println(item);
                }

                @Override public void onError(Throwable t) { }
                @Override public void onComplete() { }
            };
        }

        private void publish() {
            int number = numbers.incrementAndGet();
            BiPredicate<Flow.Subscriber<? super Integer>, Integer>
                    onDropReportError = (s, i) -> { throw new
InternalError(); };
            pubExecutor.execute(() -> pub.offer(number, onDropReportError));
    //        pub.offer(number, onDropReportError);
        }
    }

What happens here?

Subscriber.onSubscribe bulk-requests a number (N = 1048576) of integers from
SubmissionPublisher. Subscriber.onNext prints the integer it has received and
offers a single integer to the publisher. run() waits until all N integers have
been received and then returns.

onSubscribe offers an initial integer to the SubmissionPublisher. This
kick-starts
the "feedback loop".

If you run this snippet, chances are good you will not see all 1048576 integers
printed out to the console before the program terminates. Instead, the output
will stop at some number m < 1048576 for no apparent reason.

However, if you comment out the line:

    pubExecutor.execute(() -> pub.offer(number, onDropReportError));

and uncomment the previously commented line, everything will work as expected.
The difference is that in this case offers of integers happen synchronously
rather than from a separate thread.

P.S. I have debugged a little bit and my guess (I'm not a concurrency expert)
is that accesses to SubmissionPublisher.BufferedSubscription.tail field are
undersynchronized. In particular, it might be the case that updates to this
field are not always seen by the consumer task in
BufferedSubscription.checkEmpty.

Is there any chance `tail` field is simply missing volatile modifier?

Thanks,
-Pavel

From akarnokd at gmail.com  Mon Sep 25 09:55:44 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Mon, 25 Sep 2017 15:55:44 +0200
Subject: [concurrency-interest] A race in SubmissionPublisher?
In-Reply-To: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
References: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
Message-ID: <CAAWwtm-MUombdAU4PW4PnieAjKeAD_OJ8D8DGjqrqH8iy6fnfg@mail.gmail.com>

Interesting. It hangs for me after ~4000 items.

For comparison, I've tried the test with my variant of the
SubmissionPublisher (
https://github.com/akarnokd/akarnokd-misc-java9/blob/master/src/main/java/hu/akarnokd/java9/benchmark/MulticastPublisher.java)
and worked as expected in all cases.

2017-09-25 15:21 GMT+02:00 Pavel Rappo <pavel.rappo at gmail.com>:

> Hi,
>
> I've been using SubmissionPublisher in my own publisher implementation in
> order
> to reuse its complex state machine that serializes invocations to
> subscribers.
>
> While testing my implementation I ran into what I believe might be a race
> condition in SubmissionPublisher.
>
> Consider the following example:
>
>     public class SubmissionPublisherTest {
>
>         private final static int N = 1 << 20;
>
>         private final AtomicInteger numbers = new AtomicInteger();
>         private final SubmissionPublisher<Integer> pub = new
> SubmissionPublisher<>();
>         private final ExecutorService pubExecutor =
> Executors.newSingleThreadExecutor();
>         private final CountDownLatch finished = new CountDownLatch(1);
>
>         public static void main(String[] args) throws InterruptedException
> {
>             new SubmissionPublisherTest().run();
>         }
>
>         private void run() throws InterruptedException {
>             pub.subscribe(newSubscriber());
>             try {
>                 finished.await(30, TimeUnit.SECONDS);
>             } finally {
>                 pubExecutor.shutdownNow();
>             }
>             System.out.println("Finished");
>         }
>
>         private Flow.Subscriber<Integer> newSubscriber() {
>             return new Flow.Subscriber<>() {
>
>                 Flow.Subscription sub;
>                 int received;
>
>                 @Override
>                 public void onSubscribe(Flow.Subscription s) {
>                     (this.sub = s).request(N);
>                     publish();
>                 }
>
>                 @Override
>                 public void onNext(Integer item) {
>                     if (++received == N) finished.countDown();
>                     publish();
>                     System.out.println(item);
>                 }
>
>                 @Override public void onError(Throwable t) { }
>                 @Override public void onComplete() { }
>             };
>         }
>
>         private void publish() {
>             int number = numbers.incrementAndGet();
>             BiPredicate<Flow.Subscriber<? super Integer>, Integer>
>                     onDropReportError = (s, i) -> { throw new
> InternalError(); };
>             pubExecutor.execute(() -> pub.offer(number,
> onDropReportError));
>     //        pub.offer(number, onDropReportError);
>         }
>     }
>
> What happens here?
>
> Subscriber.onSubscribe bulk-requests a number (N = 1048576) of integers
> from
> SubmissionPublisher. Subscriber.onNext prints the integer it has received
> and
> offers a single integer to the publisher. run() waits until all N integers
> have
> been received and then returns.
>
> onSubscribe offers an initial integer to the SubmissionPublisher. This
> kick-starts
> the "feedback loop".
>
> If you run this snippet, chances are good you will not see all 1048576
> integers
> printed out to the console before the program terminates. Instead, the
> output
> will stop at some number m < 1048576 for no apparent reason.
>
> However, if you comment out the line:
>
>     pubExecutor.execute(() -> pub.offer(number, onDropReportError));
>
> and uncomment the previously commented line, everything will work as
> expected.
> The difference is that in this case offers of integers happen synchronously
> rather than from a separate thread.
>
> P.S. I have debugged a little bit and my guess (I'm not a concurrency
> expert)
> is that accesses to SubmissionPublisher.BufferedSubscription.tail field
> are
> undersynchronized. In particular, it might be the case that updates to this
> field are not always seen by the consumer task in
> BufferedSubscription.checkEmpty.
>
> Is there any chance `tail` field is simply missing volatile modifier?
>
> Thanks,
> -Pavel
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170925/59e41e59/attachment.html>

From dl at cs.oswego.edu  Tue Sep 26 07:51:36 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 26 Sep 2017 07:51:36 -0400
Subject: [concurrency-interest] A race in SubmissionPublisher?
In-Reply-To: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
References: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
Message-ID: <70e3f92a-5dd9-86c7-10cb-babe47980001@cs.oswego.edu>

On 09/25/2017 09:21 AM, Pavel Rappo wrote:
> Hi,
> 
> I've been using SubmissionPublisher in my own publisher implementation in order
> to reuse its complex state machine that serializes invocations to subscribers.
> 
> While testing my implementation I ran into what I believe might be a race
> condition in SubmissionPublisher.

Thanks for finding a use case that at first doesn't even seem legal,
but I agree should work according to spec, and breaks assumptions
about produce-consumer relations that can cause a wakeup not to be
issued. I'll post a fix at the corresponding bug report:
  https://bugs.openjdk.java.net/browse/JDK-8187947
after deciding which of a couple of ways to address.

-Doug



From viktor.klang at gmail.com  Tue Sep 26 07:58:31 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 26 Sep 2017 13:58:31 +0200
Subject: [concurrency-interest] A race in SubmissionPublisher?
In-Reply-To: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
References: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
Message-ID: <CANPzfU9doERkdVwHzH8H-qJsP-xD1SjghJRY+opcoC5kqpBJHA@mail.gmail.com>

Hi Pavel,

I trust that the code you submitted is for test case reproduction
primarily, but there are a few spec violations in your Subscriber
implementation that you'll want to address.

We're currently in the process of releasing a bridge jar between
org.reactivestreams and j.u.c.Flow so you can plug in your Flow.* to the RS
TCK to have them verified.

On Mon, Sep 25, 2017 at 3:21 PM, Pavel Rappo <pavel.rappo at gmail.com> wrote:

> Hi,
>
> I've been using SubmissionPublisher in my own publisher implementation in
> order
> to reuse its complex state machine that serializes invocations to
> subscribers.
>
> While testing my implementation I ran into what I believe might be a race
> condition in SubmissionPublisher.
>
> Consider the following example:
>
>     public class SubmissionPublisherTest {
>
>         private final static int N = 1 << 20;
>
>         private final AtomicInteger numbers = new AtomicInteger();
>         private final SubmissionPublisher<Integer> pub = new
> SubmissionPublisher<>();
>         private final ExecutorService pubExecutor =
> Executors.newSingleThreadExecutor();
>         private final CountDownLatch finished = new CountDownLatch(1);
>
>         public static void main(String[] args) throws InterruptedException
> {
>             new SubmissionPublisherTest().run();
>         }
>
>         private void run() throws InterruptedException {
>             pub.subscribe(newSubscriber());
>             try {
>                 finished.await(30, TimeUnit.SECONDS);
>             } finally {
>                 pubExecutor.shutdownNow();
>             }
>             System.out.println("Finished");
>         }
>
>         private Flow.Subscriber<Integer> newSubscriber() {
>             return new Flow.Subscriber<>() {
>
>                 Flow.Subscription sub;
>                 int received;
>
>                 @Override
>                 public void onSubscribe(Flow.Subscription s) {
>                     (this.sub = s).request(N);
>                     publish();
>                 }
>
>                 @Override
>                 public void onNext(Integer item) {
>                     if (++received == N) finished.countDown();
>                     publish();
>                     System.out.println(item);
>                 }
>
>                 @Override public void onError(Throwable t) { }
>                 @Override public void onComplete() { }
>             };
>         }
>
>         private void publish() {
>             int number = numbers.incrementAndGet();
>             BiPredicate<Flow.Subscriber<? super Integer>, Integer>
>                     onDropReportError = (s, i) -> { throw new
> InternalError(); };
>             pubExecutor.execute(() -> pub.offer(number,
> onDropReportError));
>     //        pub.offer(number, onDropReportError);
>         }
>     }
>
> What happens here?
>
> Subscriber.onSubscribe bulk-requests a number (N = 1048576) of integers
> from
> SubmissionPublisher. Subscriber.onNext prints the integer it has received
> and
> offers a single integer to the publisher. run() waits until all N integers
> have
> been received and then returns.
>
> onSubscribe offers an initial integer to the SubmissionPublisher. This
> kick-starts
> the "feedback loop".
>
> If you run this snippet, chances are good you will not see all 1048576
> integers
> printed out to the console before the program terminates. Instead, the
> output
> will stop at some number m < 1048576 for no apparent reason.
>
> However, if you comment out the line:
>
>     pubExecutor.execute(() -> pub.offer(number, onDropReportError));
>
> and uncomment the previously commented line, everything will work as
> expected.
> The difference is that in this case offers of integers happen synchronously
> rather than from a separate thread.
>
> P.S. I have debugged a little bit and my guess (I'm not a concurrency
> expert)
> is that accesses to SubmissionPublisher.BufferedSubscription.tail field
> are
> undersynchronized. In particular, it might be the case that updates to this
> field are not always seen by the consumer task in
> BufferedSubscription.checkEmpty.
>
> Is there any chance `tail` field is simply missing volatile modifier?
>
> Thanks,
> -Pavel
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170926/6fd662e8/attachment.html>

From pavel.rappo at gmail.com  Tue Sep 26 08:09:35 2017
From: pavel.rappo at gmail.com (Pavel Rappo)
Date: Tue, 26 Sep 2017 13:09:35 +0100
Subject: [concurrency-interest] A race in SubmissionPublisher?
In-Reply-To: <CANPzfU9doERkdVwHzH8H-qJsP-xD1SjghJRY+opcoC5kqpBJHA@mail.gmail.com>
References: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
 <CANPzfU9doERkdVwHzH8H-qJsP-xD1SjghJRY+opcoC5kqpBJHA@mail.gmail.com>
Message-ID: <CAChcVumJxqaEoxmNTfRsdqdT_ce8i1Bm+srHFQ7kmangGMf+fw@mail.gmail.com>

Hi Viktor,

On Tue, Sep 26, 2017 at 12:58 PM, Viktor Klang <viktor.klang at gmail.com> wrote:
> there are a few spec violations in your Subscriber implementation that
> you'll want to address.

What violations are you talking about? Maybe you could list
appropriate rule numbers from the RS spec? Thank you.

From akarnokd at gmail.com  Tue Sep 26 08:29:35 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Tue, 26 Sep 2017 14:29:35 +0200
Subject: [concurrency-interest] A race in SubmissionPublisher?
In-Reply-To: <CANPzfU9doERkdVwHzH8H-qJsP-xD1SjghJRY+opcoC5kqpBJHA@mail.gmail.com>
References: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
 <CANPzfU9doERkdVwHzH8H-qJsP-xD1SjghJRY+opcoC5kqpBJHA@mail.gmail.com>
Message-ID: <CAAWwtm9enDc0zj6jHPuPOqv_WwgiEZENpMG=MrMdzqWtR+PoHA@mail.gmail.com>

Viktor, can you be more specific? It just looks uncommon to me but
otherwise legitimate. The fact that there is no cancel() call when all
requested data has arrived is irrelevant from the perspective of the
underlying bug in SubmissionPublisher.

Here is a variant where the Subscriber is just consuming items and counting
how many items have been received. The asynchronous sender reads this count
to know when to send the next value to expose the internal race.

public class SpPublishAlt {
    @Test
    public void test() throws Exception {
        SubmissionPublisher<Integer> sp = new SubmissionPublisher<>();

        ExecutorService exec = Executors.newSingleThreadExecutor();
        try {
            SpConsumer c = new SpConsumer();
            sp.subscribe(c);

            exec.submit(() -> {
                while (c.upstream == null) ;

                int i = 0;
                sp.offer(i, (a, b) -> { throw new RuntimeException(); });

                while (i < SpConsumer.N) {
                    while (c.getAcquire() == i);
                    i++;
                    sp.offer(i, (a, b) -> { throw new RuntimeException(); });
                }
            });

            if (!c.cdl.await(10, TimeUnit.SECONDS)) {
                throw new AssertionError("Timed out " + c.getAcquire());
            }
        } finally {
            exec.shutdownNow();
        }
    }

    static final class SpConsumer extends AtomicInteger implements
Flow.Subscriber<Object> {

        static final int N = 1 << 20;

        final CountDownLatch cdl = new CountDownLatch(1);

        volatile Flow.Subscription upstream;

        @Override
        public void onSubscribe(Flow.Subscription subscription) {
            upstream = subscription;
            subscription.request(N);
        }

        @Override
        public void onNext(Object item) {
            System.out.println(item);
            int i = getPlain() + 1;
            setRelease(i);
            if (i == N) {
                upstream.cancel();
                cdl.countDown();
            }
        }

        @Override
        public void onError(Throwable throwable) {
            throwable.printStackTrace();
            cdl.countDown();
        }

        @Override
        public void onComplete() {
            cdl.countDown();
        }
    }
}


2017-09-26 13:58 GMT+02:00 Viktor Klang <viktor.klang at gmail.com>:

> Hi Pavel,
>
> I trust that the code you submitted is for test case reproduction
> primarily, but there are a few spec violations in your Subscriber
> implementation that you'll want to address.
>
> We're currently in the process of releasing a bridge jar between
> org.reactivestreams and j.u.c.Flow so you can plug in your Flow.* to the RS
> TCK to have them verified.
>
> On Mon, Sep 25, 2017 at 3:21 PM, Pavel Rappo <pavel.rappo at gmail.com>
> wrote:
>
>> Hi,
>>
>> I've been using SubmissionPublisher in my own publisher implementation in
>> order
>> to reuse its complex state machine that serializes invocations to
>> subscribers.
>>
>> While testing my implementation I ran into what I believe might be a race
>> condition in SubmissionPublisher.
>>
>> Consider the following example:
>>
>>     public class SubmissionPublisherTest {
>>
>>         private final static int N = 1 << 20;
>>
>>         private final AtomicInteger numbers = new AtomicInteger();
>>         private final SubmissionPublisher<Integer> pub = new
>> SubmissionPublisher<>();
>>         private final ExecutorService pubExecutor =
>> Executors.newSingleThreadExecutor();
>>         private final CountDownLatch finished = new CountDownLatch(1);
>>
>>         public static void main(String[] args) throws
>> InterruptedException {
>>             new SubmissionPublisherTest().run();
>>         }
>>
>>         private void run() throws InterruptedException {
>>             pub.subscribe(newSubscriber());
>>             try {
>>                 finished.await(30, TimeUnit.SECONDS);
>>             } finally {
>>                 pubExecutor.shutdownNow();
>>             }
>>             System.out.println("Finished");
>>         }
>>
>>         private Flow.Subscriber<Integer> newSubscriber() {
>>             return new Flow.Subscriber<>() {
>>
>>                 Flow.Subscription sub;
>>                 int received;
>>
>>                 @Override
>>                 public void onSubscribe(Flow.Subscription s) {
>>                     (this.sub = s).request(N);
>>                     publish();
>>                 }
>>
>>                 @Override
>>                 public void onNext(Integer item) {
>>                     if (++received == N) finished.countDown();
>>                     publish();
>>                     System.out.println(item);
>>                 }
>>
>>                 @Override public void onError(Throwable t) { }
>>                 @Override public void onComplete() { }
>>             };
>>         }
>>
>>         private void publish() {
>>             int number = numbers.incrementAndGet();
>>             BiPredicate<Flow.Subscriber<? super Integer>, Integer>
>>                     onDropReportError = (s, i) -> { throw new
>> InternalError(); };
>>             pubExecutor.execute(() -> pub.offer(number,
>> onDropReportError));
>>     //        pub.offer(number, onDropReportError);
>>         }
>>     }
>>
>> What happens here?
>>
>> Subscriber.onSubscribe bulk-requests a number (N = 1048576) of integers
>> from
>> SubmissionPublisher. Subscriber.onNext prints the integer it has received
>> and
>> offers a single integer to the publisher. run() waits until all N
>> integers have
>> been received and then returns.
>>
>> onSubscribe offers an initial integer to the SubmissionPublisher. This
>> kick-starts
>> the "feedback loop".
>>
>> If you run this snippet, chances are good you will not see all 1048576
>> integers
>> printed out to the console before the program terminates. Instead, the
>> output
>> will stop at some number m < 1048576 for no apparent reason.
>>
>> However, if you comment out the line:
>>
>>     pubExecutor.execute(() -> pub.offer(number, onDropReportError));
>>
>> and uncomment the previously commented line, everything will work as
>> expected.
>> The difference is that in this case offers of integers happen
>> synchronously
>> rather than from a separate thread.
>>
>> P.S. I have debugged a little bit and my guess (I'm not a concurrency
>> expert)
>> is that accesses to SubmissionPublisher.BufferedSubscription.tail field
>> are
>> undersynchronized. In particular, it might be the case that updates to
>> this
>> field are not always seen by the consumer task in
>> BufferedSubscription.checkEmpty.
>>
>> Is there any chance `tail` field is simply missing volatile modifier?
>>
>> Thanks,
>> -Pavel
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> --
> Cheers,
> √
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170926/90af0e38/attachment-0001.html>

From viktor.klang at gmail.com  Tue Sep 26 08:29:36 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 26 Sep 2017 14:29:36 +0200
Subject: [concurrency-interest] A race in SubmissionPublisher?
In-Reply-To: <CAChcVumJxqaEoxmNTfRsdqdT_ce8i1Bm+srHFQ7kmangGMf+fw@mail.gmail.com>
References: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
 <CANPzfU9doERkdVwHzH8H-qJsP-xD1SjghJRY+opcoC5kqpBJHA@mail.gmail.com>
 <CAChcVumJxqaEoxmNTfRsdqdT_ce8i1Bm+srHFQ7kmangGMf+fw@mail.gmail.com>
Message-ID: <CANPzfU9bA03aRc_8kYNor=ZZ=mDffutHcAf9T071CMETJy2B1g@mail.gmail.com>

Hi Pavel,

Absolutely, here you go: :)

Duplicate subscription management:
https://github.com/reactive-streams/reactive-streams-jvm#2.5
Cancellation when done:
https://github.com/reactive-streams/reactive-streams-jvm#2.6
Must not leak exceptions to caller:
https://github.com/reactive-streams/reactive-streams-jvm#2.13

The above list might not be exhaustive,

Cheers,
√

On Tue, Sep 26, 2017 at 2:09 PM, Pavel Rappo <pavel.rappo at gmail.com> wrote:

> Hi Viktor,
>
> On Tue, Sep 26, 2017 at 12:58 PM, Viktor Klang <viktor.klang at gmail.com>
> wrote:
> > there are a few spec violations in your Subscriber implementation that
> > you'll want to address.
>
> What violations are you talking about? Maybe you could list
> appropriate rule numbers from the RS spec? Thank you.
>



-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170926/171e9e27/attachment.html>

From viktor.klang at gmail.com  Tue Sep 26 08:36:52 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 26 Sep 2017 14:36:52 +0200
Subject: [concurrency-interest] A race in SubmissionPublisher?
In-Reply-To: <CAAWwtm9enDc0zj6jHPuPOqv_WwgiEZENpMG=MrMdzqWtR+PoHA@mail.gmail.com>
References: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
 <CANPzfU9doERkdVwHzH8H-qJsP-xD1SjghJRY+opcoC5kqpBJHA@mail.gmail.com>
 <CAAWwtm9enDc0zj6jHPuPOqv_WwgiEZENpMG=MrMdzqWtR+PoHA@mail.gmail.com>
Message-ID: <CANPzfU9Dk29OgCqtJhndGFhjN_Xkjpx6bFn1G7_Bv525vrAz7g@mail.gmail.com>

On Tue, Sep 26, 2017 at 2:29 PM, Dávid Karnok <akarnokd at gmail.com> wrote:

> Viktor, can you be more specific? It just looks uncommon to me but
> otherwise legitimate. The fact that there is no cancel() call when all
> requested data has arrived is irrelevant from the perspective of the
> underlying bug in SubmissionPublisher.
>

Absolutely, my comment was not about the SubmissionPublisher bug. I was
unsure whether the provided code was for reproduction only, or was written
like that in general, in the latter case it needs a bit of adjustment to
conform to spec.


>
> Here is a variant where the Subscriber is just consuming items and
> counting how many items have been received. The asynchronous sender reads
> this count to know when to send the next value to expose the internal race.
>
> public class SpPublishAlt {
>     @Test
>     public void test() throws Exception {
>         SubmissionPublisher<Integer> sp = new SubmissionPublisher<>();
>
>         ExecutorService exec = Executors.newSingleThreadExecutor();
>         try {
>             SpConsumer c = new SpConsumer();
>             sp.subscribe(c);
>
>             exec.submit(() -> {
>                 while (c.upstream == null) ;
>
>                 int i = 0;
>                 sp.offer(i, (a, b) -> { throw new RuntimeException(); });
>
>                 while (i < SpConsumer.N) {
>                     while (c.getAcquire() == i);
>                     i++;
>                     sp.offer(i, (a, b) -> { throw new RuntimeException(); });
>                 }
>             });
>
>             if (!c.cdl.await(10, TimeUnit.SECONDS)) {
>                 throw new AssertionError("Timed out " + c.getAcquire());
>             }
>         } finally {
>             exec.shutdownNow();
>         }
>     }
>
>     static final class SpConsumer extends AtomicInteger implements Flow.Subscriber<Object> {
>
>         static final int N = 1 << 20;
>
>         final CountDownLatch cdl = new CountDownLatch(1);
>
>         volatile Flow.Subscription upstream;
>
>         @Override
>         public void onSubscribe(Flow.Subscription subscription) {
>             upstream = subscription;
>             subscription.request(N);
>         }
>
>         @Override
>         public void onNext(Object item) {
>             System.out.println(item);
>             int i = getPlain() + 1;
>             setRelease(i);
>             if (i == N) {
>                 upstream.cancel();
>                 cdl.countDown();
>             }
>         }
>
>         @Override
>         public void onError(Throwable throwable) {
>             throwable.printStackTrace();
>             cdl.countDown();
>         }
>
>         @Override
>         public void onComplete() {
>             cdl.countDown();
>         }
>     }
> }
>
>
> 2017-09-26 13:58 GMT+02:00 Viktor Klang <viktor.klang at gmail.com>:
>
>> Hi Pavel,
>>
>> I trust that the code you submitted is for test case reproduction
>> primarily, but there are a few spec violations in your Subscriber
>> implementation that you'll want to address.
>>
>> We're currently in the process of releasing a bridge jar between
>> org.reactivestreams and j.u.c.Flow so you can plug in your Flow.* to the RS
>> TCK to have them verified.
>>
>> On Mon, Sep 25, 2017 at 3:21 PM, Pavel Rappo <pavel.rappo at gmail.com>
>> wrote:
>>
>>> Hi,
>>>
>>> I've been using SubmissionPublisher in my own publisher implementation
>>> in order
>>> to reuse its complex state machine that serializes invocations to
>>> subscribers.
>>>
>>> While testing my implementation I ran into what I believe might be a race
>>> condition in SubmissionPublisher.
>>>
>>> Consider the following example:
>>>
>>>     public class SubmissionPublisherTest {
>>>
>>>         private final static int N = 1 << 20;
>>>
>>>         private final AtomicInteger numbers = new AtomicInteger();
>>>         private final SubmissionPublisher<Integer> pub = new
>>> SubmissionPublisher<>();
>>>         private final ExecutorService pubExecutor =
>>> Executors.newSingleThreadExecutor();
>>>         private final CountDownLatch finished = new CountDownLatch(1);
>>>
>>>         public static void main(String[] args) throws
>>> InterruptedException {
>>>             new SubmissionPublisherTest().run();
>>>         }
>>>
>>>         private void run() throws InterruptedException {
>>>             pub.subscribe(newSubscriber());
>>>             try {
>>>                 finished.await(30, TimeUnit.SECONDS);
>>>             } finally {
>>>                 pubExecutor.shutdownNow();
>>>             }
>>>             System.out.println("Finished");
>>>         }
>>>
>>>         private Flow.Subscriber<Integer> newSubscriber() {
>>>             return new Flow.Subscriber<>() {
>>>
>>>                 Flow.Subscription sub;
>>>                 int received;
>>>
>>>                 @Override
>>>                 public void onSubscribe(Flow.Subscription s) {
>>>                     (this.sub = s).request(N);
>>>                     publish();
>>>                 }
>>>
>>>                 @Override
>>>                 public void onNext(Integer item) {
>>>                     if (++received == N) finished.countDown();
>>>                     publish();
>>>                     System.out.println(item);
>>>                 }
>>>
>>>                 @Override public void onError(Throwable t) { }
>>>                 @Override public void onComplete() { }
>>>             };
>>>         }
>>>
>>>         private void publish() {
>>>             int number = numbers.incrementAndGet();
>>>             BiPredicate<Flow.Subscriber<? super Integer>, Integer>
>>>                     onDropReportError = (s, i) -> { throw new
>>> InternalError(); };
>>>             pubExecutor.execute(() -> pub.offer(number,
>>> onDropReportError));
>>>     //        pub.offer(number, onDropReportError);
>>>         }
>>>     }
>>>
>>> What happens here?
>>>
>>> Subscriber.onSubscribe bulk-requests a number (N = 1048576) of integers
>>> from
>>> SubmissionPublisher. Subscriber.onNext prints the integer it has
>>> received and
>>> offers a single integer to the publisher. run() waits until all N
>>> integers have
>>> been received and then returns.
>>>
>>> onSubscribe offers an initial integer to the SubmissionPublisher. This
>>> kick-starts
>>> the "feedback loop".
>>>
>>> If you run this snippet, chances are good you will not see all 1048576
>>> integers
>>> printed out to the console before the program terminates. Instead, the
>>> output
>>> will stop at some number m < 1048576 for no apparent reason.
>>>
>>> However, if you comment out the line:
>>>
>>>     pubExecutor.execute(() -> pub.offer(number, onDropReportError));
>>>
>>> and uncomment the previously commented line, everything will work as
>>> expected.
>>> The difference is that in this case offers of integers happen
>>> synchronously
>>> rather than from a separate thread.
>>>
>>> P.S. I have debugged a little bit and my guess (I'm not a concurrency
>>> expert)
>>> is that accesses to SubmissionPublisher.BufferedSubscription.tail field
>>> are
>>> undersynchronized. In particular, it might be the case that updates to
>>> this
>>> field are not always seen by the consumer task in
>>> BufferedSubscription.checkEmpty.
>>>
>>> Is there any chance `tail` field is simply missing volatile modifier?
>>>
>>> Thanks,
>>> -Pavel
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>>
>> --
>> Cheers,
>> √
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> --
> Best regards,
> David Karnok
>



-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170926/03bbb34c/attachment-0001.html>

From akarnokd at gmail.com  Tue Sep 26 08:49:14 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Tue, 26 Sep 2017 14:49:14 +0200
Subject: [concurrency-interest] A race in SubmissionPublisher?
In-Reply-To: <CANPzfU9Dk29OgCqtJhndGFhjN_Xkjpx6bFn1G7_Bv525vrAz7g@mail.gmail.com>
References: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
 <CANPzfU9doERkdVwHzH8H-qJsP-xD1SjghJRY+opcoC5kqpBJHA@mail.gmail.com>
 <CAAWwtm9enDc0zj6jHPuPOqv_WwgiEZENpMG=MrMdzqWtR+PoHA@mail.gmail.com>
 <CANPzfU9Dk29OgCqtJhndGFhjN_Xkjpx6bFn1G7_Bv525vrAz7g@mail.gmail.com>
Message-ID: <CAAWwtm-_2MmYoZyskHs2QHzUSw5AwuSzAqUtwHq-HkZvXAgV2Q@mail.gmail.com>

Addendum to the rules listed:

§2.5: in practice, this should not happen with reasonable reactive
libraries. Depending on how you trust the Publisher, omitting such checks
is not a disaster. Plus, the JavaDoc's example is also hints about plain
store of the Flow.Subscription:

http://download.java.net/java/jdk9/docs/api/java/util/concurrent/SubmissionPublisher.html

class TransformProcessor<S,T> extends SubmissionPublisher<T>
   implements Flow.Processor<S,T> {
   final Function<? super S, ? extends T> function;
   Flow.Subscription subscription;
   TransformProcessor(Executor executor, int maxBufferCapacity,
                      Function<? super S, ? extends T> function) {
     super(executor, maxBufferCapacity);
     this.function = function;
   }
   public void onSubscribe(Flow.Subscription subscription) {
     *(this.subscription = subscription).request(1);*
   }
   public void onNext(S item) {
     subscription.request(1);
     *submit(function.apply(item));*
   }
   public void onError(Throwable ex) { closeExceptionally(ex); }
   public void onComplete() { close(); }
 }

§2.13: Yes, pubExecutor.execute() can throw a RejectedExecutionException in
general, but often you can't do much about that case. Plus again, the
example above uses submit() which can also throw:
http://download.java.net/java/jdk9/docs/api/java/util/concurrent/SubmissionPublisher.html#submit-T-

2017-09-26 14:36 GMT+02:00 Viktor Klang <viktor.klang at gmail.com>:

>
>
> On Tue, Sep 26, 2017 at 2:29 PM, Dávid Karnok <akarnokd at gmail.com> wrote:
>
>> Viktor, can you be more specific? It just looks uncommon to me but
>> otherwise legitimate. The fact that there is no cancel() call when all
>> requested data has arrived is irrelevant from the perspective of the
>> underlying bug in SubmissionPublisher.
>>
>
> Absolutely, my comment was not about the SubmissionPublisher bug. I was
> unsure whether the provided code was for reproduction only, or was written
> like that in general, in the latter case it needs a bit of adjustment to
> conform to spec.
>
>
>>
>> Here is a variant where the Subscriber is just consuming items and
>> counting how many items have been received. The asynchronous sender reads
>> this count to know when to send the next value to expose the internal race.
>>
>> public class SpPublishAlt {
>>     @Test
>>     public void test() throws Exception {
>>         SubmissionPublisher<Integer> sp = new SubmissionPublisher<>();
>>
>>         ExecutorService exec = Executors.newSingleThreadExecutor();
>>         try {
>>             SpConsumer c = new SpConsumer();
>>             sp.subscribe(c);
>>
>>             exec.submit(() -> {
>>                 while (c.upstream == null) ;
>>
>>                 int i = 0;
>>                 sp.offer(i, (a, b) -> { throw new RuntimeException(); });
>>
>>                 while (i < SpConsumer.N) {
>>                     while (c.getAcquire() == i);
>>                     i++;
>>                     sp.offer(i, (a, b) -> { throw new RuntimeException(); });
>>                 }
>>             });
>>
>>             if (!c.cdl.await(10, TimeUnit.SECONDS)) {
>>                 throw new AssertionError("Timed out " + c.getAcquire());
>>             }
>>         } finally {
>>             exec.shutdownNow();
>>         }
>>     }
>>
>>     static final class SpConsumer extends AtomicInteger implements Flow.Subscriber<Object> {
>>
>>         static final int N = 1 << 20;
>>
>>         final CountDownLatch cdl = new CountDownLatch(1);
>>
>>         volatile Flow.Subscription upstream;
>>
>>         @Override
>>         public void onSubscribe(Flow.Subscription subscription) {
>>             upstream = subscription;
>>             subscription.request(N);
>>         }
>>
>>         @Override
>>         public void onNext(Object item) {
>>             System.out.println(item);
>>             int i = getPlain() + 1;
>>             setRelease(i);
>>             if (i == N) {
>>                 upstream.cancel();
>>                 cdl.countDown();
>>             }
>>         }
>>
>>         @Override
>>         public void onError(Throwable throwable) {
>>             throwable.printStackTrace();
>>             cdl.countDown();
>>         }
>>
>>         @Override
>>         public void onComplete() {
>>             cdl.countDown();
>>         }
>>     }
>> }
>>
>>
>> 2017-09-26 13:58 GMT+02:00 Viktor Klang <viktor.klang at gmail.com>:
>>
>>> Hi Pavel,
>>>
>>> I trust that the code you submitted is for test case reproduction
>>> primarily, but there are a few spec violations in your Subscriber
>>> implementation that you'll want to address.
>>>
>>> We're currently in the process of releasing a bridge jar between
>>> org.reactivestreams and j.u.c.Flow so you can plug in your Flow.* to the RS
>>> TCK to have them verified.
>>>
>>> On Mon, Sep 25, 2017 at 3:21 PM, Pavel Rappo <pavel.rappo at gmail.com>
>>> wrote:
>>>
>>>> Hi,
>>>>
>>>> I've been using SubmissionPublisher in my own publisher implementation
>>>> in order
>>>> to reuse its complex state machine that serializes invocations to
>>>> subscribers.
>>>>
>>>> While testing my implementation I ran into what I believe might be a
>>>> race
>>>> condition in SubmissionPublisher.
>>>>
>>>> Consider the following example:
>>>>
>>>>     public class SubmissionPublisherTest {
>>>>
>>>>         private final static int N = 1 << 20;
>>>>
>>>>         private final AtomicInteger numbers = new AtomicInteger();
>>>>         private final SubmissionPublisher<Integer> pub = new
>>>> SubmissionPublisher<>();
>>>>         private final ExecutorService pubExecutor =
>>>> Executors.newSingleThreadExecutor();
>>>>         private final CountDownLatch finished = new CountDownLatch(1);
>>>>
>>>>         public static void main(String[] args) throws
>>>> InterruptedException {
>>>>             new SubmissionPublisherTest().run();
>>>>         }
>>>>
>>>>         private void run() throws InterruptedException {
>>>>             pub.subscribe(newSubscriber());
>>>>             try {
>>>>                 finished.await(30, TimeUnit.SECONDS);
>>>>             } finally {
>>>>                 pubExecutor.shutdownNow();
>>>>             }
>>>>             System.out.println("Finished");
>>>>         }
>>>>
>>>>         private Flow.Subscriber<Integer> newSubscriber() {
>>>>             return new Flow.Subscriber<>() {
>>>>
>>>>                 Flow.Subscription sub;
>>>>                 int received;
>>>>
>>>>                 @Override
>>>>                 public void onSubscribe(Flow.Subscription s) {
>>>>                     (this.sub = s).request(N);
>>>>                     publish();
>>>>                 }
>>>>
>>>>                 @Override
>>>>                 public void onNext(Integer item) {
>>>>                     if (++received == N) finished.countDown();
>>>>                     publish();
>>>>                     System.out.println(item);
>>>>                 }
>>>>
>>>>                 @Override public void onError(Throwable t) { }
>>>>                 @Override public void onComplete() { }
>>>>             };
>>>>         }
>>>>
>>>>         private void publish() {
>>>>             int number = numbers.incrementAndGet();
>>>>             BiPredicate<Flow.Subscriber<? super Integer>, Integer>
>>>>                     onDropReportError = (s, i) -> { throw new
>>>> InternalError(); };
>>>>             pubExecutor.execute(() -> pub.offer(number,
>>>> onDropReportError));
>>>>     //        pub.offer(number, onDropReportError);
>>>>         }
>>>>     }
>>>>
>>>> What happens here?
>>>>
>>>> Subscriber.onSubscribe bulk-requests a number (N = 1048576) of integers
>>>> from
>>>> SubmissionPublisher. Subscriber.onNext prints the integer it has
>>>> received and
>>>> offers a single integer to the publisher. run() waits until all N
>>>> integers have
>>>> been received and then returns.
>>>>
>>>> onSubscribe offers an initial integer to the SubmissionPublisher. This
>>>> kick-starts
>>>> the "feedback loop".
>>>>
>>>> If you run this snippet, chances are good you will not see all 1048576
>>>> integers
>>>> printed out to the console before the program terminates. Instead, the
>>>> output
>>>> will stop at some number m < 1048576 for no apparent reason.
>>>>
>>>> However, if you comment out the line:
>>>>
>>>>     pubExecutor.execute(() -> pub.offer(number, onDropReportError));
>>>>
>>>> and uncomment the previously commented line, everything will work as
>>>> expected.
>>>> The difference is that in this case offers of integers happen
>>>> synchronously
>>>> rather than from a separate thread.
>>>>
>>>> P.S. I have debugged a little bit and my guess (I'm not a concurrency
>>>> expert)
>>>> is that accesses to SubmissionPublisher.BufferedSubscription.tail
>>>> field are
>>>> undersynchronized. In particular, it might be the case that updates to
>>>> this
>>>> field are not always seen by the consumer task in
>>>> BufferedSubscription.checkEmpty.
>>>>
>>>> Is there any chance `tail` field is simply missing volatile modifier?
>>>>
>>>> Thanks,
>>>> -Pavel
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>>
>>>
>>> --
>>> Cheers,
>>> √
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>>
>> --
>> Best regards,
>> David Karnok
>>
>
>
>
> --
> Cheers,
> √
>



-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170926/01cf9243/attachment-0001.html>

From viktor.klang at gmail.com  Tue Sep 26 09:42:13 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 26 Sep 2017 15:42:13 +0200
Subject: [concurrency-interest] A race in SubmissionPublisher?
In-Reply-To: <CAAWwtm-_2MmYoZyskHs2QHzUSw5AwuSzAqUtwHq-HkZvXAgV2Q@mail.gmail.com>
References: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
 <CANPzfU9doERkdVwHzH8H-qJsP-xD1SjghJRY+opcoC5kqpBJHA@mail.gmail.com>
 <CAAWwtm9enDc0zj6jHPuPOqv_WwgiEZENpMG=MrMdzqWtR+PoHA@mail.gmail.com>
 <CANPzfU9Dk29OgCqtJhndGFhjN_Xkjpx6bFn1G7_Bv525vrAz7g@mail.gmail.com>
 <CAAWwtm-_2MmYoZyskHs2QHzUSw5AwuSzAqUtwHq-HkZvXAgV2Q@mail.gmail.com>
Message-ID: <CANPzfU-Js+STDvKeHgbWFgJJDursiojYx857QTTiwmJSfPAukA@mail.gmail.com>

On Tue, Sep 26, 2017 at 2:49 PM, Dávid Karnok <akarnokd at gmail.com> wrote:

> Addendum to the rules listed:
>
> §2.5: in practice, this should not happen with reasonable reactive
> libraries. Depending on how you trust the Publisher, omitting such checks
> is not a disaster.
>

It's not a disaster, it's only non-compliance—it is a MUST rule, after all.


> Plus, the JavaDoc's example is also hints about plain store of the
> Flow.Subscription:
>
> http://download.java.net/java/jdk9/docs/api/java/util/concurrent/
> SubmissionPublisher.html
>
> class TransformProcessor<S,T> extends SubmissionPublisher<T>
>    implements Flow.Processor<S,T> {
>    final Function<? super S, ? extends T> function;
>    Flow.Subscription subscription;
>    TransformProcessor(Executor executor, int maxBufferCapacity,
>                       Function<? super S, ? extends T> function) {
>      super(executor, maxBufferCapacity);
>      this.function = function;
>    }
>    public void onSubscribe(Flow.Subscription subscription) {
>
>
I've been meaning to send some JavaDoc contributions, I'll keep this one in
mind! :)


>
>      *(this.subscription = subscription).request(1);*
>    }
>    public void onNext(S item) {
>      subscription.request(1);
>      *submit(function.apply(item));*
>    }
>    public void onError(Throwable ex) { closeExceptionally(ex); }
>    public void onComplete() { close(); }
>  }
>
> §2.13: Yes, pubExecutor.execute() can throw a RejectedExecutionException
> in general, but often you can't do much about that case.
>

Most definitely, but that exception should most definitely not infect the
issuer of the signal. The spec is unambiguous about this (for a reason!). :)


> Plus again, the example above uses submit() which can also throw:
> http://download.java.net/java/jdk9/docs/api/java/util/concurrent/
> SubmissionPublisher.html#submit-T-
>
> 2017-09-26 14:36 GMT+02:00 Viktor Klang <viktor.klang at gmail.com>:
>
>>
>>
>> On Tue, Sep 26, 2017 at 2:29 PM, Dávid Karnok <akarnokd at gmail.com> wrote:
>>
>>> Viktor, can you be more specific? It just looks uncommon to me but
>>> otherwise legitimate. The fact that there is no cancel() call when all
>>> requested data has arrived is irrelevant from the perspective of the
>>> underlying bug in SubmissionPublisher.
>>>
>>
>> Absolutely, my comment was not about the SubmissionPublisher bug. I was
>> unsure whether the provided code was for reproduction only, or was written
>> like that in general, in the latter case it needs a bit of adjustment to
>> conform to spec.
>>
>>
>>>
>>> Here is a variant where the Subscriber is just consuming items and
>>> counting how many items have been received. The asynchronous sender reads
>>> this count to know when to send the next value to expose the internal race.
>>>
>>> public class SpPublishAlt {
>>>     @Test
>>>     public void test() throws Exception {
>>>         SubmissionPublisher<Integer> sp = new SubmissionPublisher<>();
>>>
>>>         ExecutorService exec = Executors.newSingleThreadExecutor();
>>>         try {
>>>             SpConsumer c = new SpConsumer();
>>>             sp.subscribe(c);
>>>
>>>             exec.submit(() -> {
>>>                 while (c.upstream == null) ;
>>>
>>>                 int i = 0;
>>>                 sp.offer(i, (a, b) -> { throw new RuntimeException(); });
>>>
>>>                 while (i < SpConsumer.N) {
>>>                     while (c.getAcquire() == i);
>>>                     i++;
>>>                     sp.offer(i, (a, b) -> { throw new RuntimeException(); });
>>>                 }
>>>             });
>>>
>>>             if (!c.cdl.await(10, TimeUnit.SECONDS)) {
>>>                 throw new AssertionError("Timed out " + c.getAcquire());
>>>             }
>>>         } finally {
>>>             exec.shutdownNow();
>>>         }
>>>     }
>>>
>>>     static final class SpConsumer extends AtomicInteger implements Flow.Subscriber<Object> {
>>>
>>>         static final int N = 1 << 20;
>>>
>>>         final CountDownLatch cdl = new CountDownLatch(1);
>>>
>>>         volatile Flow.Subscription upstream;
>>>
>>>         @Override
>>>         public void onSubscribe(Flow.Subscription subscription) {
>>>             upstream = subscription;
>>>             subscription.request(N);
>>>         }
>>>
>>>         @Override
>>>         public void onNext(Object item) {
>>>             System.out.println(item);
>>>             int i = getPlain() + 1;
>>>             setRelease(i);
>>>             if (i == N) {
>>>                 upstream.cancel();
>>>                 cdl.countDown();
>>>             }
>>>         }
>>>
>>>         @Override
>>>         public void onError(Throwable throwable) {
>>>             throwable.printStackTrace();
>>>             cdl.countDown();
>>>         }
>>>
>>>         @Override
>>>         public void onComplete() {
>>>             cdl.countDown();
>>>         }
>>>     }
>>> }
>>>
>>>
>>> 2017-09-26 13:58 GMT+02:00 Viktor Klang <viktor.klang at gmail.com>:
>>>
>>>> Hi Pavel,
>>>>
>>>> I trust that the code you submitted is for test case reproduction
>>>> primarily, but there are a few spec violations in your Subscriber
>>>> implementation that you'll want to address.
>>>>
>>>> We're currently in the process of releasing a bridge jar between
>>>> org.reactivestreams and j.u.c.Flow so you can plug in your Flow.* to the RS
>>>> TCK to have them verified.
>>>>
>>>> On Mon, Sep 25, 2017 at 3:21 PM, Pavel Rappo <pavel.rappo at gmail.com>
>>>> wrote:
>>>>
>>>>> Hi,
>>>>>
>>>>> I've been using SubmissionPublisher in my own publisher implementation
>>>>> in order
>>>>> to reuse its complex state machine that serializes invocations to
>>>>> subscribers.
>>>>>
>>>>> While testing my implementation I ran into what I believe might be a
>>>>> race
>>>>> condition in SubmissionPublisher.
>>>>>
>>>>> Consider the following example:
>>>>>
>>>>>     public class SubmissionPublisherTest {
>>>>>
>>>>>         private final static int N = 1 << 20;
>>>>>
>>>>>         private final AtomicInteger numbers = new AtomicInteger();
>>>>>         private final SubmissionPublisher<Integer> pub = new
>>>>> SubmissionPublisher<>();
>>>>>         private final ExecutorService pubExecutor =
>>>>> Executors.newSingleThreadExecutor();
>>>>>         private final CountDownLatch finished = new CountDownLatch(1);
>>>>>
>>>>>         public static void main(String[] args) throws
>>>>> InterruptedException {
>>>>>             new SubmissionPublisherTest().run();
>>>>>         }
>>>>>
>>>>>         private void run() throws InterruptedException {
>>>>>             pub.subscribe(newSubscriber());
>>>>>             try {
>>>>>                 finished.await(30, TimeUnit.SECONDS);
>>>>>             } finally {
>>>>>                 pubExecutor.shutdownNow();
>>>>>             }
>>>>>             System.out.println("Finished");
>>>>>         }
>>>>>
>>>>>         private Flow.Subscriber<Integer> newSubscriber() {
>>>>>             return new Flow.Subscriber<>() {
>>>>>
>>>>>                 Flow.Subscription sub;
>>>>>                 int received;
>>>>>
>>>>>                 @Override
>>>>>                 public void onSubscribe(Flow.Subscription s) {
>>>>>                     (this.sub = s).request(N);
>>>>>                     publish();
>>>>>                 }
>>>>>
>>>>>                 @Override
>>>>>                 public void onNext(Integer item) {
>>>>>                     if (++received == N) finished.countDown();
>>>>>                     publish();
>>>>>                     System.out.println(item);
>>>>>                 }
>>>>>
>>>>>                 @Override public void onError(Throwable t) { }
>>>>>                 @Override public void onComplete() { }
>>>>>             };
>>>>>         }
>>>>>
>>>>>         private void publish() {
>>>>>             int number = numbers.incrementAndGet();
>>>>>             BiPredicate<Flow.Subscriber<? super Integer>, Integer>
>>>>>                     onDropReportError = (s, i) -> { throw new
>>>>> InternalError(); };
>>>>>             pubExecutor.execute(() -> pub.offer(number,
>>>>> onDropReportError));
>>>>>     //        pub.offer(number, onDropReportError);
>>>>>         }
>>>>>     }
>>>>>
>>>>> What happens here?
>>>>>
>>>>> Subscriber.onSubscribe bulk-requests a number (N = 1048576) of
>>>>> integers from
>>>>> SubmissionPublisher. Subscriber.onNext prints the integer it has
>>>>> received and
>>>>> offers a single integer to the publisher. run() waits until all N
>>>>> integers have
>>>>> been received and then returns.
>>>>>
>>>>> onSubscribe offers an initial integer to the SubmissionPublisher. This
>>>>> kick-starts
>>>>> the "feedback loop".
>>>>>
>>>>> If you run this snippet, chances are good you will not see all 1048576
>>>>> integers
>>>>> printed out to the console before the program terminates. Instead, the
>>>>> output
>>>>> will stop at some number m < 1048576 for no apparent reason.
>>>>>
>>>>> However, if you comment out the line:
>>>>>
>>>>>     pubExecutor.execute(() -> pub.offer(number, onDropReportError));
>>>>>
>>>>> and uncomment the previously commented line, everything will work as
>>>>> expected.
>>>>> The difference is that in this case offers of integers happen
>>>>> synchronously
>>>>> rather than from a separate thread.
>>>>>
>>>>> P.S. I have debugged a little bit and my guess (I'm not a concurrency
>>>>> expert)
>>>>> is that accesses to SubmissionPublisher.BufferedSubscription.tail
>>>>> field are
>>>>> undersynchronized. In particular, it might be the case that updates to
>>>>> this
>>>>> field are not always seen by the consumer task in
>>>>> BufferedSubscription.checkEmpty.
>>>>>
>>>>> Is there any chance `tail` field is simply missing volatile modifier?
>>>>>
>>>>> Thanks,
>>>>> -Pavel
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>>
>>>>
>>>> --
>>>> Cheers,
>>>> √
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>>
>>> --
>>> Best regards,
>>> David Karnok
>>>
>>
>>
>>
>> --
>> Cheers,
>> √
>>
>
>
>
> --
> Best regards,
> David Karnok
>



-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170926/9e7b31ff/attachment-0001.html>

From akarnokd at gmail.com  Tue Sep 26 10:13:42 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Tue, 26 Sep 2017 16:13:42 +0200
Subject: [concurrency-interest] A race in SubmissionPublisher?
In-Reply-To: <CANPzfU-Js+STDvKeHgbWFgJJDursiojYx857QTTiwmJSfPAukA@mail.gmail.com>
References: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
 <CANPzfU9doERkdVwHzH8H-qJsP-xD1SjghJRY+opcoC5kqpBJHA@mail.gmail.com>
 <CAAWwtm9enDc0zj6jHPuPOqv_WwgiEZENpMG=MrMdzqWtR+PoHA@mail.gmail.com>
 <CANPzfU9Dk29OgCqtJhndGFhjN_Xkjpx6bFn1G7_Bv525vrAz7g@mail.gmail.com>
 <CAAWwtm-_2MmYoZyskHs2QHzUSw5AwuSzAqUtwHq-HkZvXAgV2Q@mail.gmail.com>
 <CANPzfU-Js+STDvKeHgbWFgJJDursiojYx857QTTiwmJSfPAukA@mail.gmail.com>
Message-ID: <CAAWwtm9vwaUe1GQ9C_izTu8QEDUqdpZeqRZRbBFr06LqOZ9qsw@mail.gmail.com>

Well, the spec is the spec. (Consequently, I guess you'll have much fun
with this one:
https://examples.javacodegeeks.com/core-java/java-9-reactive-streams-example/
)

2017-09-26 15:42 GMT+02:00 Viktor Klang <viktor.klang at gmail.com>:

>
>
> On Tue, Sep 26, 2017 at 2:49 PM, Dávid Karnok <akarnokd at gmail.com> wrote:
>
>> Addendum to the rules listed:
>>
>> §2.5: in practice, this should not happen with reasonable reactive
>> libraries. Depending on how you trust the Publisher, omitting such checks
>> is not a disaster.
>>
>
> It's not a disaster, it's only non-compliance—it is a MUST rule, after all.
>
>
>> Plus, the JavaDoc's example is also hints about plain store of the
>> Flow.Subscription:
>>
>> http://download.java.net/java/jdk9/docs/api/java/util/concur
>> rent/SubmissionPublisher.html
>>
>> class TransformProcessor<S,T> extends SubmissionPublisher<T>
>>    implements Flow.Processor<S,T> {
>>    final Function<? super S, ? extends T> function;
>>    Flow.Subscription subscription;
>>    TransformProcessor(Executor executor, int maxBufferCapacity,
>>                       Function<? super S, ? extends T> function) {
>>      super(executor, maxBufferCapacity);
>>      this.function = function;
>>    }
>>    public void onSubscribe(Flow.Subscription subscription) {
>>
>>
> I've been meaning to send some JavaDoc contributions, I'll keep this one
> in mind! :)
>
>
>>
>>      *(this.subscription = subscription).request(1);*
>>    }
>>    public void onNext(S item) {
>>      subscription.request(1);
>>      *submit(function.apply(item));*
>>    }
>>    public void onError(Throwable ex) { closeExceptionally(ex); }
>>    public void onComplete() { close(); }
>>  }
>>
>> §2.13: Yes, pubExecutor.execute() can throw a RejectedExecutionException
>> in general, but often you can't do much about that case.
>>
>
> Most definitely, but that exception should most definitely not infect the
> issuer of the signal. The spec is unambiguous about this (for a reason!). :)
>
>
>> Plus again, the example above uses submit() which can also throw:
>> http://download.java.net/java/jdk9/docs/api/java/util/concur
>> rent/SubmissionPublisher.html#submit-T-
>>
>> 2017-09-26 14:36 GMT+02:00 Viktor Klang <viktor.klang at gmail.com>:
>>
>>>
>>>
>>> On Tue, Sep 26, 2017 at 2:29 PM, Dávid Karnok <akarnokd at gmail.com>
>>> wrote:
>>>
>>>> Viktor, can you be more specific? It just looks uncommon to me but
>>>> otherwise legitimate. The fact that there is no cancel() call when all
>>>> requested data has arrived is irrelevant from the perspective of the
>>>> underlying bug in SubmissionPublisher.
>>>>
>>>
>>> Absolutely, my comment was not about the SubmissionPublisher bug. I was
>>> unsure whether the provided code was for reproduction only, or was written
>>> like that in general, in the latter case it needs a bit of adjustment to
>>> conform to spec.
>>>
>>>
>>>>
>>>> Here is a variant where the Subscriber is just consuming items and
>>>> counting how many items have been received. The asynchronous sender reads
>>>> this count to know when to send the next value to expose the internal race.
>>>>
>>>> public class SpPublishAlt {
>>>>     @Test
>>>>     public void test() throws Exception {
>>>>         SubmissionPublisher<Integer> sp = new SubmissionPublisher<>();
>>>>
>>>>         ExecutorService exec = Executors.newSingleThreadExecutor();
>>>>         try {
>>>>             SpConsumer c = new SpConsumer();
>>>>             sp.subscribe(c);
>>>>
>>>>             exec.submit(() -> {
>>>>                 while (c.upstream == null) ;
>>>>
>>>>                 int i = 0;
>>>>                 sp.offer(i, (a, b) -> { throw new RuntimeException(); });
>>>>
>>>>                 while (i < SpConsumer.N) {
>>>>                     while (c.getAcquire() == i);
>>>>                     i++;
>>>>                     sp.offer(i, (a, b) -> { throw new RuntimeException(); });
>>>>                 }
>>>>             });
>>>>
>>>>             if (!c.cdl.await(10, TimeUnit.SECONDS)) {
>>>>                 throw new AssertionError("Timed out " + c.getAcquire());
>>>>             }
>>>>         } finally {
>>>>             exec.shutdownNow();
>>>>         }
>>>>     }
>>>>
>>>>     static final class SpConsumer extends AtomicInteger implements Flow.Subscriber<Object> {
>>>>
>>>>         static final int N = 1 << 20;
>>>>
>>>>         final CountDownLatch cdl = new CountDownLatch(1);
>>>>
>>>>         volatile Flow.Subscription upstream;
>>>>
>>>>         @Override
>>>>         public void onSubscribe(Flow.Subscription subscription) {
>>>>             upstream = subscription;
>>>>             subscription.request(N);
>>>>         }
>>>>
>>>>         @Override
>>>>         public void onNext(Object item) {
>>>>             System.out.println(item);
>>>>             int i = getPlain() + 1;
>>>>             setRelease(i);
>>>>             if (i == N) {
>>>>                 upstream.cancel();
>>>>                 cdl.countDown();
>>>>             }
>>>>         }
>>>>
>>>>         @Override
>>>>         public void onError(Throwable throwable) {
>>>>             throwable.printStackTrace();
>>>>             cdl.countDown();
>>>>         }
>>>>
>>>>         @Override
>>>>         public void onComplete() {
>>>>             cdl.countDown();
>>>>         }
>>>>     }
>>>> }
>>>>
>>>>
>>>> 2017-09-26 13:58 GMT+02:00 Viktor Klang <viktor.klang at gmail.com>:
>>>>
>>>>> Hi Pavel,
>>>>>
>>>>> I trust that the code you submitted is for test case reproduction
>>>>> primarily, but there are a few spec violations in your Subscriber
>>>>> implementation that you'll want to address.
>>>>>
>>>>> We're currently in the process of releasing a bridge jar between
>>>>> org.reactivestreams and j.u.c.Flow so you can plug in your Flow.* to the RS
>>>>> TCK to have them verified.
>>>>>
>>>>> On Mon, Sep 25, 2017 at 3:21 PM, Pavel Rappo <pavel.rappo at gmail.com>
>>>>> wrote:
>>>>>
>>>>>> Hi,
>>>>>>
>>>>>> I've been using SubmissionPublisher in my own publisher
>>>>>> implementation in order
>>>>>> to reuse its complex state machine that serializes invocations to
>>>>>> subscribers.
>>>>>>
>>>>>> While testing my implementation I ran into what I believe might be a
>>>>>> race
>>>>>> condition in SubmissionPublisher.
>>>>>>
>>>>>> Consider the following example:
>>>>>>
>>>>>>     public class SubmissionPublisherTest {
>>>>>>
>>>>>>         private final static int N = 1 << 20;
>>>>>>
>>>>>>         private final AtomicInteger numbers = new AtomicInteger();
>>>>>>         private final SubmissionPublisher<Integer> pub = new
>>>>>> SubmissionPublisher<>();
>>>>>>         private final ExecutorService pubExecutor =
>>>>>> Executors.newSingleThreadExecutor();
>>>>>>         private final CountDownLatch finished = new CountDownLatch(1);
>>>>>>
>>>>>>         public static void main(String[] args) throws
>>>>>> InterruptedException {
>>>>>>             new SubmissionPublisherTest().run();
>>>>>>         }
>>>>>>
>>>>>>         private void run() throws InterruptedException {
>>>>>>             pub.subscribe(newSubscriber());
>>>>>>             try {
>>>>>>                 finished.await(30, TimeUnit.SECONDS);
>>>>>>             } finally {
>>>>>>                 pubExecutor.shutdownNow();
>>>>>>             }
>>>>>>             System.out.println("Finished");
>>>>>>         }
>>>>>>
>>>>>>         private Flow.Subscriber<Integer> newSubscriber() {
>>>>>>             return new Flow.Subscriber<>() {
>>>>>>
>>>>>>                 Flow.Subscription sub;
>>>>>>                 int received;
>>>>>>
>>>>>>                 @Override
>>>>>>                 public void onSubscribe(Flow.Subscription s) {
>>>>>>                     (this.sub = s).request(N);
>>>>>>                     publish();
>>>>>>                 }
>>>>>>
>>>>>>                 @Override
>>>>>>                 public void onNext(Integer item) {
>>>>>>                     if (++received == N) finished.countDown();
>>>>>>                     publish();
>>>>>>                     System.out.println(item);
>>>>>>                 }
>>>>>>
>>>>>>                 @Override public void onError(Throwable t) { }
>>>>>>                 @Override public void onComplete() { }
>>>>>>             };
>>>>>>         }
>>>>>>
>>>>>>         private void publish() {
>>>>>>             int number = numbers.incrementAndGet();
>>>>>>             BiPredicate<Flow.Subscriber<? super Integer>, Integer>
>>>>>>                     onDropReportError = (s, i) -> { throw new
>>>>>> InternalError(); };
>>>>>>             pubExecutor.execute(() -> pub.offer(number,
>>>>>> onDropReportError));
>>>>>>     //        pub.offer(number, onDropReportError);
>>>>>>         }
>>>>>>     }
>>>>>>
>>>>>> What happens here?
>>>>>>
>>>>>> Subscriber.onSubscribe bulk-requests a number (N = 1048576) of
>>>>>> integers from
>>>>>> SubmissionPublisher. Subscriber.onNext prints the integer it has
>>>>>> received and
>>>>>> offers a single integer to the publisher. run() waits until all N
>>>>>> integers have
>>>>>> been received and then returns.
>>>>>>
>>>>>> onSubscribe offers an initial integer to the SubmissionPublisher. This
>>>>>> kick-starts
>>>>>> the "feedback loop".
>>>>>>
>>>>>> If you run this snippet, chances are good you will not see all
>>>>>> 1048576 integers
>>>>>> printed out to the console before the program terminates. Instead,
>>>>>> the output
>>>>>> will stop at some number m < 1048576 for no apparent reason.
>>>>>>
>>>>>> However, if you comment out the line:
>>>>>>
>>>>>>     pubExecutor.execute(() -> pub.offer(number, onDropReportError));
>>>>>>
>>>>>> and uncomment the previously commented line, everything will work as
>>>>>> expected.
>>>>>> The difference is that in this case offers of integers happen
>>>>>> synchronously
>>>>>> rather than from a separate thread.
>>>>>>
>>>>>> P.S. I have debugged a little bit and my guess (I'm not a concurrency
>>>>>> expert)
>>>>>> is that accesses to SubmissionPublisher.BufferedSubscription.tail
>>>>>> field are
>>>>>> undersynchronized. In particular, it might be the case that updates
>>>>>> to this
>>>>>> field are not always seen by the consumer task in
>>>>>> BufferedSubscription.checkEmpty.
>>>>>>
>>>>>> Is there any chance `tail` field is simply missing volatile modifier?
>>>>>>
>>>>>> Thanks,
>>>>>> -Pavel
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>
>>>>>
>>>>>
>>>>> --
>>>>> Cheers,
>>>>> √
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>>
>>>> --
>>>> Best regards,
>>>> David Karnok
>>>>
>>>
>>>
>>>
>>> --
>>> Cheers,
>>> √
>>>
>>
>>
>>
>> --
>> Best regards,
>> David Karnok
>>
>
>
>
> --
> Cheers,
> √
>



-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170926/ed842135/attachment-0001.html>

From viktor.klang at gmail.com  Tue Sep 26 10:18:06 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 26 Sep 2017 16:18:06 +0200
Subject: [concurrency-interest] A race in SubmissionPublisher?
In-Reply-To: <CAAWwtm9vwaUe1GQ9C_izTu8QEDUqdpZeqRZRbBFr06LqOZ9qsw@mail.gmail.com>
References: <CAChcVukL6vhqsB2cPJOHQho8uq-B4DVxH4PKfa10VQKqHJC=pw@mail.gmail.com>
 <CANPzfU9doERkdVwHzH8H-qJsP-xD1SjghJRY+opcoC5kqpBJHA@mail.gmail.com>
 <CAAWwtm9enDc0zj6jHPuPOqv_WwgiEZENpMG=MrMdzqWtR+PoHA@mail.gmail.com>
 <CANPzfU9Dk29OgCqtJhndGFhjN_Xkjpx6bFn1G7_Bv525vrAz7g@mail.gmail.com>
 <CAAWwtm-_2MmYoZyskHs2QHzUSw5AwuSzAqUtwHq-HkZvXAgV2Q@mail.gmail.com>
 <CANPzfU-Js+STDvKeHgbWFgJJDursiojYx857QTTiwmJSfPAukA@mail.gmail.com>
 <CAAWwtm9vwaUe1GQ9C_izTu8QEDUqdpZeqRZRbBFr06LqOZ9qsw@mail.gmail.com>
Message-ID: <CANPzfU_kgF0ALhkORnPTb+cAVAK2QEvJ5c3RxdrmOKvKxjsNzA@mail.gmail.com>

Thanks for the link.

I think the most scalable approach to help interoperability is to
evangelize the use of the TCK whenever possible, helps people catch subtle
bugs quickly.


On Tue, Sep 26, 2017 at 4:13 PM, Dávid Karnok <akarnokd at gmail.com> wrote:

> Well, the spec is the spec. (Consequently, I guess you'll have much fun
> with this one: https://examples.javacodegeeks.com/core-java/
> java-9-reactive-streams-example/)
>
> 2017-09-26 15:42 GMT+02:00 Viktor Klang <viktor.klang at gmail.com>:
>
>>
>>
>> On Tue, Sep 26, 2017 at 2:49 PM, Dávid Karnok <akarnokd at gmail.com> wrote:
>>
>>> Addendum to the rules listed:
>>>
>>> §2.5: in practice, this should not happen with reasonable reactive
>>> libraries. Depending on how you trust the Publisher, omitting such checks
>>> is not a disaster.
>>>
>>
>> It's not a disaster, it's only non-compliance—it is a MUST rule, after
>> all.
>>
>>
>>> Plus, the JavaDoc's example is also hints about plain store of the
>>> Flow.Subscription:
>>>
>>> http://download.java.net/java/jdk9/docs/api/java/util/concur
>>> rent/SubmissionPublisher.html
>>>
>>> class TransformProcessor<S,T> extends SubmissionPublisher<T>
>>>    implements Flow.Processor<S,T> {
>>>    final Function<? super S, ? extends T> function;
>>>    Flow.Subscription subscription;
>>>    TransformProcessor(Executor executor, int maxBufferCapacity,
>>>                       Function<? super S, ? extends T> function) {
>>>      super(executor, maxBufferCapacity);
>>>      this.function = function;
>>>    }
>>>    public void onSubscribe(Flow.Subscription subscription) {
>>>
>>>
>> I've been meaning to send some JavaDoc contributions, I'll keep this one
>> in mind! :)
>>
>>
>>>
>>>      *(this.subscription = subscription).request(1);*
>>>    }
>>>    public void onNext(S item) {
>>>      subscription.request(1);
>>>      *submit(function.apply(item));*
>>>    }
>>>    public void onError(Throwable ex) { closeExceptionally(ex); }
>>>    public void onComplete() { close(); }
>>>  }
>>>
>>> §2.13: Yes, pubExecutor.execute() can throw a
>>> RejectedExecutionException in general, but often you can't do much about
>>> that case.
>>>
>>
>> Most definitely, but that exception should most definitely not infect the
>> issuer of the signal. The spec is unambiguous about this (for a reason!). :)
>>
>>
>>> Plus again, the example above uses submit() which can also throw:
>>> http://download.java.net/java/jdk9/docs/api/java/util/concur
>>> rent/SubmissionPublisher.html#submit-T-
>>>
>>> 2017-09-26 14:36 GMT+02:00 Viktor Klang <viktor.klang at gmail.com>:
>>>
>>>>
>>>>
>>>> On Tue, Sep 26, 2017 at 2:29 PM, Dávid Karnok <akarnokd at gmail.com>
>>>> wrote:
>>>>
>>>>> Viktor, can you be more specific? It just looks uncommon to me but
>>>>> otherwise legitimate. The fact that there is no cancel() call when all
>>>>> requested data has arrived is irrelevant from the perspective of the
>>>>> underlying bug in SubmissionPublisher.
>>>>>
>>>>
>>>> Absolutely, my comment was not about the SubmissionPublisher bug. I was
>>>> unsure whether the provided code was for reproduction only, or was written
>>>> like that in general, in the latter case it needs a bit of adjustment to
>>>> conform to spec.
>>>>
>>>>
>>>>>
>>>>> Here is a variant where the Subscriber is just consuming items and
>>>>> counting how many items have been received. The asynchronous sender reads
>>>>> this count to know when to send the next value to expose the internal race.
>>>>>
>>>>> public class SpPublishAlt {
>>>>>     @Test
>>>>>     public void test() throws Exception {
>>>>>         SubmissionPublisher<Integer> sp = new SubmissionPublisher<>();
>>>>>
>>>>>         ExecutorService exec = Executors.newSingleThreadExecutor();
>>>>>         try {
>>>>>             SpConsumer c = new SpConsumer();
>>>>>             sp.subscribe(c);
>>>>>
>>>>>             exec.submit(() -> {
>>>>>                 while (c.upstream == null) ;
>>>>>
>>>>>                 int i = 0;
>>>>>                 sp.offer(i, (a, b) -> { throw new RuntimeException(); });
>>>>>
>>>>>                 while (i < SpConsumer.N) {
>>>>>                     while (c.getAcquire() == i);
>>>>>                     i++;
>>>>>                     sp.offer(i, (a, b) -> { throw new RuntimeException(); });
>>>>>                 }
>>>>>             });
>>>>>
>>>>>             if (!c.cdl.await(10, TimeUnit.SECONDS)) {
>>>>>                 throw new AssertionError("Timed out " + c.getAcquire());
>>>>>             }
>>>>>         } finally {
>>>>>             exec.shutdownNow();
>>>>>         }
>>>>>     }
>>>>>
>>>>>     static final class SpConsumer extends AtomicInteger implements Flow.Subscriber<Object> {
>>>>>
>>>>>         static final int N = 1 << 20;
>>>>>
>>>>>         final CountDownLatch cdl = new CountDownLatch(1);
>>>>>
>>>>>         volatile Flow.Subscription upstream;
>>>>>
>>>>>         @Override
>>>>>         public void onSubscribe(Flow.Subscription subscription) {
>>>>>             upstream = subscription;
>>>>>             subscription.request(N);
>>>>>         }
>>>>>
>>>>>         @Override
>>>>>         public void onNext(Object item) {
>>>>>             System.out.println(item);
>>>>>             int i = getPlain() + 1;
>>>>>             setRelease(i);
>>>>>             if (i == N) {
>>>>>                 upstream.cancel();
>>>>>                 cdl.countDown();
>>>>>             }
>>>>>         }
>>>>>
>>>>>         @Override
>>>>>         public void onError(Throwable throwable) {
>>>>>             throwable.printStackTrace();
>>>>>             cdl.countDown();
>>>>>         }
>>>>>
>>>>>         @Override
>>>>>         public void onComplete() {
>>>>>             cdl.countDown();
>>>>>         }
>>>>>     }
>>>>> }
>>>>>
>>>>>
>>>>> 2017-09-26 13:58 GMT+02:00 Viktor Klang <viktor.klang at gmail.com>:
>>>>>
>>>>>> Hi Pavel,
>>>>>>
>>>>>> I trust that the code you submitted is for test case reproduction
>>>>>> primarily, but there are a few spec violations in your Subscriber
>>>>>> implementation that you'll want to address.
>>>>>>
>>>>>> We're currently in the process of releasing a bridge jar between
>>>>>> org.reactivestreams and j.u.c.Flow so you can plug in your Flow.* to the RS
>>>>>> TCK to have them verified.
>>>>>>
>>>>>> On Mon, Sep 25, 2017 at 3:21 PM, Pavel Rappo <pavel.rappo at gmail.com>
>>>>>> wrote:
>>>>>>
>>>>>>> Hi,
>>>>>>>
>>>>>>> I've been using SubmissionPublisher in my own publisher
>>>>>>> implementation in order
>>>>>>> to reuse its complex state machine that serializes invocations to
>>>>>>> subscribers.
>>>>>>>
>>>>>>> While testing my implementation I ran into what I believe might be a
>>>>>>> race
>>>>>>> condition in SubmissionPublisher.
>>>>>>>
>>>>>>> Consider the following example:
>>>>>>>
>>>>>>>     public class SubmissionPublisherTest {
>>>>>>>
>>>>>>>         private final static int N = 1 << 20;
>>>>>>>
>>>>>>>         private final AtomicInteger numbers = new AtomicInteger();
>>>>>>>         private final SubmissionPublisher<Integer> pub = new
>>>>>>> SubmissionPublisher<>();
>>>>>>>         private final ExecutorService pubExecutor =
>>>>>>> Executors.newSingleThreadExecutor();
>>>>>>>         private final CountDownLatch finished = new
>>>>>>> CountDownLatch(1);
>>>>>>>
>>>>>>>         public static void main(String[] args) throws
>>>>>>> InterruptedException {
>>>>>>>             new SubmissionPublisherTest().run();
>>>>>>>         }
>>>>>>>
>>>>>>>         private void run() throws InterruptedException {
>>>>>>>             pub.subscribe(newSubscriber());
>>>>>>>             try {
>>>>>>>                 finished.await(30, TimeUnit.SECONDS);
>>>>>>>             } finally {
>>>>>>>                 pubExecutor.shutdownNow();
>>>>>>>             }
>>>>>>>             System.out.println("Finished");
>>>>>>>         }
>>>>>>>
>>>>>>>         private Flow.Subscriber<Integer> newSubscriber() {
>>>>>>>             return new Flow.Subscriber<>() {
>>>>>>>
>>>>>>>                 Flow.Subscription sub;
>>>>>>>                 int received;
>>>>>>>
>>>>>>>                 @Override
>>>>>>>                 public void onSubscribe(Flow.Subscription s) {
>>>>>>>                     (this.sub = s).request(N);
>>>>>>>                     publish();
>>>>>>>                 }
>>>>>>>
>>>>>>>                 @Override
>>>>>>>                 public void onNext(Integer item) {
>>>>>>>                     if (++received == N) finished.countDown();
>>>>>>>                     publish();
>>>>>>>                     System.out.println(item);
>>>>>>>                 }
>>>>>>>
>>>>>>>                 @Override public void onError(Throwable t) { }
>>>>>>>                 @Override public void onComplete() { }
>>>>>>>             };
>>>>>>>         }
>>>>>>>
>>>>>>>         private void publish() {
>>>>>>>             int number = numbers.incrementAndGet();
>>>>>>>             BiPredicate<Flow.Subscriber<? super Integer>, Integer>
>>>>>>>                     onDropReportError = (s, i) -> { throw new
>>>>>>> InternalError(); };
>>>>>>>             pubExecutor.execute(() -> pub.offer(number,
>>>>>>> onDropReportError));
>>>>>>>     //        pub.offer(number, onDropReportError);
>>>>>>>         }
>>>>>>>     }
>>>>>>>
>>>>>>> What happens here?
>>>>>>>
>>>>>>> Subscriber.onSubscribe bulk-requests a number (N = 1048576) of
>>>>>>> integers from
>>>>>>> SubmissionPublisher. Subscriber.onNext prints the integer it has
>>>>>>> received and
>>>>>>> offers a single integer to the publisher. run() waits until all N
>>>>>>> integers have
>>>>>>> been received and then returns.
>>>>>>>
>>>>>>> onSubscribe offers an initial integer to the SubmissionPublisher.
>>>>>>> This
>>>>>>> kick-starts
>>>>>>> the "feedback loop".
>>>>>>>
>>>>>>> If you run this snippet, chances are good you will not see all
>>>>>>> 1048576 integers
>>>>>>> printed out to the console before the program terminates. Instead,
>>>>>>> the output
>>>>>>> will stop at some number m < 1048576 for no apparent reason.
>>>>>>>
>>>>>>> However, if you comment out the line:
>>>>>>>
>>>>>>>     pubExecutor.execute(() -> pub.offer(number, onDropReportError));
>>>>>>>
>>>>>>> and uncomment the previously commented line, everything will work as
>>>>>>> expected.
>>>>>>> The difference is that in this case offers of integers happen
>>>>>>> synchronously
>>>>>>> rather than from a separate thread.
>>>>>>>
>>>>>>> P.S. I have debugged a little bit and my guess (I'm not a
>>>>>>> concurrency expert)
>>>>>>> is that accesses to SubmissionPublisher.BufferedSubscription.tail
>>>>>>> field are
>>>>>>> undersynchronized. In particular, it might be the case that updates
>>>>>>> to this
>>>>>>> field are not always seen by the consumer task in
>>>>>>> BufferedSubscription.checkEmpty.
>>>>>>>
>>>>>>> Is there any chance `tail` field is simply missing volatile modifier?
>>>>>>>
>>>>>>> Thanks,
>>>>>>> -Pavel
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> --
>>>>>> Cheers,
>>>>>> √
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>> --
>>>>> Best regards,
>>>>> David Karnok
>>>>>
>>>>
>>>>
>>>>
>>>> --
>>>> Cheers,
>>>> √
>>>>
>>>
>>>
>>>
>>> --
>>> Best regards,
>>> David Karnok
>>>
>>
>>
>>
>> --
>> Cheers,
>> √
>>
>
>
>
> --
> Best regards,
> David Karnok
>



-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170926/1c800a77/attachment-0001.html>

From ionutb83 at yahoo.com  Sat Sep 30 02:21:06 2017
From: ionutb83 at yahoo.com (Ionut)
Date: Sat, 30 Sep 2017 06:21:06 +0000 (UTC)
Subject: [concurrency-interest] Asynchronous event processing in Java
References: <512056112.167871.1506752466848.ref@mail.yahoo.com>
Message-ID: <512056112.167871.1506752466848@mail.yahoo.com>

Hello All,
   I am searching for asynchronous event processing APIs in Java. Up to this point I found/used the CompletableFuture / Future and they seem a good fit, but I am wondering if there might be other alternatives I am not aware of.
Can you pls share other Java APIs in regards to asynch event processing ?
ThanksIonut
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170930/58b2c47e/attachment.html>

