From martinrb at google.com  Mon Feb  1 13:45:23 2016
From: martinrb at google.com (Martin Buchholz)
Date: Mon, 1 Feb 2016 10:45:23 -0800
Subject: [concurrency-interest] RFR: jsr166 jdk9 integration wave 4
Message-ID: <CA+kOe0-OXciPNDQktVF4v3-7gzbvT0i=KoYG4L-+ySh4Y4inyA@mail.gmail.com>

After much debate on what to do when CompleteableFuture.whenComplete
encounters an exception in both the source and the action, we chose
what was acceptable to the most people - add the action's exception to
the source exception as a suppressed exception.  And added usage
guidelines.  And gave handle "top billing" over whenComplete.

http://cr.openjdk.java.net/~martin/webrevs/openjdk9/jsr166-jdk9-integration/

and the usual miscellaneous improvements.

From chris.hegarty at oracle.com  Tue Feb  2 09:37:41 2016
From: chris.hegarty at oracle.com (Chris Hegarty)
Date: Tue, 2 Feb 2016 14:37:41 +0000
Subject: [concurrency-interest] RFR: jsr166 jdk9 integration wave 4
In-Reply-To: <CA+kOe0-OXciPNDQktVF4v3-7gzbvT0i=KoYG4L-+ySh4Y4inyA@mail.gmail.com>
References: <CA+kOe0-OXciPNDQktVF4v3-7gzbvT0i=KoYG4L-+ySh4Y4inyA@mail.gmail.com>
Message-ID: <A19E8C1C-909B-4BC4-8EF0-6329A09BABB6@oracle.com>


On 1 Feb 2016, at 18:45, Martin Buchholz <martinrb at google.com> wrote:

> After much debate on what to do when CompleteableFuture.whenComplete
> encounters an exception in both the source and the action, we chose
> what was acceptable to the most people - add the action's exception to
> the source exception as a suppressed exception.  And added usage
> guidelines.  And gave handle "top billing" over whenComplete.
> 
> http://cr.openjdk.java.net/~martin/webrevs/openjdk9/jsr166-jdk9-integration/

This all looks fine to me.

So I assume you only need a small CCC request for CompletionStage, right? 
Everything else is implementation.

-Chris.

From martinrb at google.com  Tue Feb  2 10:23:32 2016
From: martinrb at google.com (Martin Buchholz)
Date: Tue, 2 Feb 2016 07:23:32 -0800
Subject: [concurrency-interest] RFR: jsr166 jdk9 integration wave 4
In-Reply-To: <A19E8C1C-909B-4BC4-8EF0-6329A09BABB6@oracle.com>
References: <CA+kOe0-OXciPNDQktVF4v3-7gzbvT0i=KoYG4L-+ySh4Y4inyA@mail.gmail.com>
	<A19E8C1C-909B-4BC4-8EF0-6329A09BABB6@oracle.com>
Message-ID: <CA+kOe0-fEDy5tYYo9vJ8q-tQt7d1Gk9BtH19h566yvLXikKUcQ@mail.gmail.com>

On Tue, Feb 2, 2016 at 6:37 AM, Chris Hegarty <chris.hegarty at oracle.com> wrote:
>
> On 1 Feb 2016, at 18:45, Martin Buchholz <martinrb at google.com> wrote:
>
>> After much debate on what to do when CompleteableFuture.whenComplete
>> encounters an exception in both the source and the action, we chose
>> what was acceptable to the most people - add the action's exception to
>> the source exception as a suppressed exception.  And added usage
>> guidelines.  And gave handle "top billing" over whenComplete.
>>
>> http://cr.openjdk.java.net/~martin/webrevs/openjdk9/jsr166-jdk9-integration/
>
> This all looks fine to me.
>
> So I assume you only need a small CCC request for CompletionStage, right?
> Everything else is implementation.

If you squint you might argue that CompletionStage's contract hasn't
actually changed,
but yeah, go ahead and do a CCC for CompletionStage.  Publishing a
specdiff would be nice - method reordering (for "top billing") has
made the diffs harder to review.  Thanks.

From openjdk at duigou.org  Thu Feb  4 13:46:58 2016
From: openjdk at duigou.org (Mike Duigou)
Date: Thu, 04 Feb 2016 10:46:58 -0800
Subject: [concurrency-interest] =?utf-8?q?ConcurrentHashMap_entrySet_Itera?=
	=?utf-8?q?tor_remove_issue=3F?=
Message-ID: <fd602129dc74650b895192a24c97c3b1@sonic.net>

Hello all;

I have found what seems like a bug in the way that the remove() method 
of CHM entrySet iterators works. The bug doesn't require concurrent 
behaviour but realistically that is the most likely way it arises. The 
problem is that the entrySet iterator remove() internally uses the 
chm.remove(key) method rather than the chm.remove(key, value) method. If 
there is an intervening replacement of the mapping for a key between the 
iterator next() and the remove() then it is possible to incorrectly 
remove that mapping.

I have made test program which compares the behaviour of 
entryset().remove(staleMapping) to entrySet().iterator() remove() of the 
same mapping.

I encountered the problem in real world code where the entry was 
replaced concurrently. I don't believe that there should be programs 
which expect the existing behaviour though undoubtedly there are some. I 
believe it is more likely that programs would/should expect the 
behaviour in which remove of a stale entry does nothing.

Cheers,

Mike


/*
  * Written by Mike Duigou and released to the public domain, as 
explained at
  * http://creativecommons.org/publicdomain/zero/1.0/
*/

package chm.test;

import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
  * Compares behaviour of removal of a stale entry via entrySet.remove() 
vs.
  * entrySet().iterator().remove()
  */
public class ConcurrentHashMapBug {

     public static void main(String... args) {
         ConcurrentHashMap<String, String> chm = new 
ConcurrentHashMap<>();

         chm.put("fred", "wilma");
         chm.put("barney", "betty");

         Set<Map.Entry<String, String>> entries = chm.entrySet();

         // Attempt removal of a mapping through entrySet with stale 
entry.

         Map.Entry<String, String> fredEntry = null;
         for (Map.Entry<String, String> each : entries) {
             if ("fred".equals(each.getKey())) {
                 fredEntry = each;
                 break;
             }
         }
         assert fredEntry != null : "Entry not found";
         assert "wilma".equals(fredEntry.getValue()) : "wrong value";

         // modify fred mapping
         chm.put("fred", "mildred");
         // fredEntry is now stale
         assert "wilma".equals(fredEntry.getValue()) : "live value?";

         // attempt to remove our stale entry.
         assert !entries.remove(fredEntry) : "fred unexpectedly removed";
         // Mapping was not removed because entry value did not match 
current mapping.
         assert chm.containsKey("fred") : "fred mapping missing";
         assert "mildred".equals(chm.get("fred")) : "fred mapping 
incorrect";

         // Attempt remove of a  mapping through entrySet 
iterator.remove() with stale entry.

         Iterator<Map.Entry<String, String>> iter = entries.iterator();
         Map.Entry<String, String> barneyEntry = null;
         while (iter.hasNext()) {
             Map.Entry<String, String> each = iter.next();
             if ("barney".equals(each.getKey())) {
                 barneyEntry = each;
                 break;
             }
         }

         assert barneyEntry != null : "barney entry not found";
         assert "betty".equals(barneyEntry.getValue()) : "wrong value";

         // modify barney mapping
         chm.put("barney", "hortence");
         // barneyEntry is now stale
         assert chm.containsKey("barney") : "mapping missing";
         assert "hortence".equals(chm.get("barney")) : "mapping 
incorrect";
         assert "betty".equals(barneyEntry.getValue()) : "live value?";

         // attempt to remove our stale entry
         iter.remove();
         assert "betty".equals(barneyEntry.getValue()) : "live value?";
         // XXX Following fails. iter.remove() with stale entry 
incorrectly succeeds.
         // should behave like chm.remove(barneyEntry.getKey(), 
barneyEntry.getValue())
         assert chm.containsKey("barney") : "mapping missing";
         assert "hortence".equals(chm.get("barney")) : "mapping 
incorrect";

         System.out.println("Success!");
     }
}

From joe.bowbeer at gmail.com  Thu Feb  4 14:35:44 2016
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 4 Feb 2016 11:35:44 -0800
Subject: [concurrency-interest] ConcurrentHashMap entrySet Iterator
	remove issue?
In-Reply-To: <fd602129dc74650b895192a24c97c3b1@sonic.net>
References: <fd602129dc74650b895192a24c97c3b1@sonic.net>
Message-ID: <CAHzJPEp8dJqWf_S7V6nTr=Oqc9AUDcQzrQqKK6_4xnXM=b_zhA@mail.gmail.com>

The entrySet iterator is recommended (by IDE's, static analysis, code
reviewers) for efficiency any time the key and value might both be used
during the iteration. As a result, keySet iteration tends to be refactored
to entrySet iteration.

So I don't think we can deduce that it.remove(k,v) necessarily means remove
that *exact* (k,v). And in a concurrent context, the programmer probably
does not have the expectation that it will always do so.

If the intent is to remove any entry corresponding to the key, how would
this be accomplished in an entrySet iteration after your change? How can a
programmer remove only the exact entry with today's behavior?

Futhermore, what should removeAll do? Can it remove nothing if all of the
iterator's mappings are stale? The existing implementation favors removal.

Here is some discussion around this behavior:

http://stackoverflow.com/questions/29876083/behavior-of-entryset-removeif-in-concurrenthashmap

Also this, tangentially:

http://stackoverflow.com/questions/3768554/is-iterating-concurrenthashmap-values-thread-safe

I suspect there are more than a few people who care, and some who have
already worked around the current behavior if it was not their desired one.


On Thu, Feb 4, 2016 at 10:46 AM, Mike Duigou <openjdk at duigou.org> wrote:

> Hello all;
>
> I have found what seems like a bug in the way that the remove() method of
> CHM entrySet iterators works. The bug doesn't require concurrent behaviour
> but realistically that is the most likely way it arises. The problem is
> that the entrySet iterator remove() internally uses the chm.remove(key)
> method rather than the chm.remove(key, value) method. If there is an
> intervening replacement of the mapping for a key between the iterator
> next() and the remove() then it is possible to incorrectly remove that
> mapping.
>
> I have made test program which compares the behaviour of
> entryset().remove(staleMapping) to entrySet().iterator() remove() of the
> same mapping.
>
> I encountered the problem in real world code where the entry was replaced
> concurrently. I don't believe that there should be programs which expect
> the existing behaviour though undoubtedly there are some. I believe it is
> more likely that programs would/should expect the behaviour in which remove
> of a stale entry does nothing.
>
> Cheers,
>
> Mike
>
>
> /*
>  * Written by Mike Duigou and released to the public domain, as explained
> at
>  * http://creativecommons.org/publicdomain/zero/1.0/
> */
>
> package chm.test;
>
> import java.util.Iterator;
> import java.util.Map;
> import java.util.Set;
> import java.util.concurrent.ConcurrentHashMap;
>
> /**
>  * Compares behaviour of removal of a stale entry via entrySet.remove() vs.
>  * entrySet().iterator().remove()
>  */
> public class ConcurrentHashMapBug {
>
>     public static void main(String... args) {
>         ConcurrentHashMap<String, String> chm = new ConcurrentHashMap<>();
>
>         chm.put("fred", "wilma");
>         chm.put("barney", "betty");
>
>         Set<Map.Entry<String, String>> entries = chm.entrySet();
>
>         // Attempt removal of a mapping through entrySet with stale entry.
>
>         Map.Entry<String, String> fredEntry = null;
>         for (Map.Entry<String, String> each : entries) {
>             if ("fred".equals(each.getKey())) {
>                 fredEntry = each;
>                 break;
>             }
>         }
>         assert fredEntry != null : "Entry not found";
>         assert "wilma".equals(fredEntry.getValue()) : "wrong value";
>
>         // modify fred mapping
>         chm.put("fred", "mildred");
>         // fredEntry is now stale
>         assert "wilma".equals(fredEntry.getValue()) : "live value?";
>
>         // attempt to remove our stale entry.
>         assert !entries.remove(fredEntry) : "fred unexpectedly removed";
>         // Mapping was not removed because entry value did not match
> current mapping.
>         assert chm.containsKey("fred") : "fred mapping missing";
>         assert "mildred".equals(chm.get("fred")) : "fred mapping
> incorrect";
>
>         // Attempt remove of a  mapping through entrySet iterator.remove()
> with stale entry.
>
>         Iterator<Map.Entry<String, String>> iter = entries.iterator();
>         Map.Entry<String, String> barneyEntry = null;
>         while (iter.hasNext()) {
>             Map.Entry<String, String> each = iter.next();
>             if ("barney".equals(each.getKey())) {
>                 barneyEntry = each;
>                 break;
>             }
>         }
>
>         assert barneyEntry != null : "barney entry not found";
>         assert "betty".equals(barneyEntry.getValue()) : "wrong value";
>
>         // modify barney mapping
>         chm.put("barney", "hortence");
>         // barneyEntry is now stale
>         assert chm.containsKey("barney") : "mapping missing";
>         assert "hortence".equals(chm.get("barney")) : "mapping incorrect";
>         assert "betty".equals(barneyEntry.getValue()) : "live value?";
>
>         // attempt to remove our stale entry
>         iter.remove();
>         assert "betty".equals(barneyEntry.getValue()) : "live value?";
>         // XXX Following fails. iter.remove() with stale entry incorrectly
> succeeds.
>         // should behave like chm.remove(barneyEntry.getKey(),
> barneyEntry.getValue())
>         assert chm.containsKey("barney") : "mapping missing";
>         assert "hortence".equals(chm.get("barney")) : "mapping incorrect";
>
>         System.out.println("Success!");
>     }
> }
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160204/33557c1b/attachment.html>

From ben_manes at yahoo.com  Thu Feb  4 14:37:15 2016
From: ben_manes at yahoo.com (Ben Manes)
Date: Thu, 4 Feb 2016 19:37:15 +0000 (UTC)
Subject: [concurrency-interest] ConcurrentHashMap entrySet Iterator
 remove issue?
In-Reply-To: <fd602129dc74650b895192a24c97c3b1@sonic.net>
References: <fd602129dc74650b895192a24c97c3b1@sonic.net>
Message-ID: <1200346126.1776269.1454614635881.JavaMail.yahoo@mail.yahoo.com>

This is how the previous ConcurrentHashMap and?ConcurrentSkipListMap work. Most 3rd party ConcurrentMap implementations have followed this pattern for consistency (e.g. NonBlockingHashMap and?ConcurrentLinkedHashMap,?ConcurrentSkipTreeMap,?SnapTreeMap). The behavior for Iterator#remove() is unspecified for concurrent collections, so while perhaps surprising I wouldn't call it a bug. 

    On Thursday, February 4, 2016 11:15 AM, Mike Duigou <openjdk at duigou.org> wrote:
 

 Hello all;

I have found what seems like a bug in the way that the remove() method 
of CHM entrySet iterators works. The bug doesn't require concurrent 
behaviour but realistically that is the most likely way it arises. The 
problem is that the entrySet iterator remove() internally uses the 
chm.remove(key) method rather than the chm.remove(key, value) method. If 
there is an intervening replacement of the mapping for a key between the 
iterator next() and the remove() then it is possible to incorrectly 
remove that mapping.

I have made test program which compares the behaviour of 
entryset().remove(staleMapping) to entrySet().iterator() remove() of the 
same mapping.

I encountered the problem in real world code where the entry was 
replaced concurrently. I don't believe that there should be programs 
which expect the existing behaviour though undoubtedly there are some. I 
believe it is more likely that programs would/should expect the 
behaviour in which remove of a stale entry does nothing.

Cheers,

Mike


/*
? * Written by Mike Duigou and released to the public domain, as 
explained at
? * http://creativecommons.org/publicdomain/zero/1.0/
*/

package chm.test;

import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
? * Compares behaviour of removal of a stale entry via entrySet.remove() 
vs.
? * entrySet().iterator().remove()
? */
public class ConcurrentHashMapBug {

? ? public static void main(String... args) {
? ? ? ? ConcurrentHashMap<String, String> chm = new 
ConcurrentHashMap<>();

? ? ? ? chm.put("fred", "wilma");
? ? ? ? chm.put("barney", "betty");

? ? ? ? Set<Map.Entry<String, String>> entries = chm.entrySet();

? ? ? ? // Attempt removal of a mapping through entrySet with stale 
entry.

? ? ? ? Map.Entry<String, String> fredEntry = null;
? ? ? ? for (Map.Entry<String, String> each : entries) {
? ? ? ? ? ? if ("fred".equals(each.getKey())) {
? ? ? ? ? ? ? ? fredEntry = each;
? ? ? ? ? ? ? ? break;
? ? ? ? ? ? }
? ? ? ? }
? ? ? ? assert fredEntry != null : "Entry not found";
? ? ? ? assert "wilma".equals(fredEntry.getValue()) : "wrong value";

? ? ? ? // modify fred mapping
? ? ? ? chm.put("fred", "mildred");
? ? ? ? // fredEntry is now stale
? ? ? ? assert "wilma".equals(fredEntry.getValue()) : "live value?";

? ? ? ? // attempt to remove our stale entry.
? ? ? ? assert !entries.remove(fredEntry) : "fred unexpectedly removed";
? ? ? ? // Mapping was not removed because entry value did not match 
current mapping.
? ? ? ? assert chm.containsKey("fred") : "fred mapping missing";
? ? ? ? assert "mildred".equals(chm.get("fred")) : "fred mapping 
incorrect";

? ? ? ? // Attempt remove of a? mapping through entrySet 
iterator.remove() with stale entry.

? ? ? ? Iterator<Map.Entry<String, String>> iter = entries.iterator();
? ? ? ? Map.Entry<String, String> barneyEntry = null;
? ? ? ? while (iter.hasNext()) {
? ? ? ? ? ? Map.Entry<String, String> each = iter.next();
? ? ? ? ? ? if ("barney".equals(each.getKey())) {
? ? ? ? ? ? ? ? barneyEntry = each;
? ? ? ? ? ? ? ? break;
? ? ? ? ? ? }
? ? ? ? }

? ? ? ? assert barneyEntry != null : "barney entry not found";
? ? ? ? assert "betty".equals(barneyEntry.getValue()) : "wrong value";

? ? ? ? // modify barney mapping
? ? ? ? chm.put("barney", "hortence");
? ? ? ? // barneyEntry is now stale
? ? ? ? assert chm.containsKey("barney") : "mapping missing";
? ? ? ? assert "hortence".equals(chm.get("barney")) : "mapping 
incorrect";
? ? ? ? assert "betty".equals(barneyEntry.getValue()) : "live value?";

? ? ? ? // attempt to remove our stale entry
? ? ? ? iter.remove();
? ? ? ? assert "betty".equals(barneyEntry.getValue()) : "live value?";
? ? ? ? // XXX Following fails. iter.remove() with stale entry 
incorrectly succeeds.
? ? ? ? // should behave like chm.remove(barneyEntry.getKey(), 
barneyEntry.getValue())
? ? ? ? assert chm.containsKey("barney") : "mapping missing";
? ? ? ? assert "hortence".equals(chm.get("barney")) : "mapping 
incorrect";

? ? ? ? System.out.println("Success!");
? ? }
}
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160204/eff2a18c/attachment-0001.html>

From joe.bowbeer at gmail.com  Thu Feb  4 14:52:41 2016
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 4 Feb 2016 11:52:41 -0800
Subject: [concurrency-interest] ConcurrentHashMap entrySet Iterator
	remove issue?
In-Reply-To: <CAHzJPEp8dJqWf_S7V6nTr=Oqc9AUDcQzrQqKK6_4xnXM=b_zhA@mail.gmail.com>
References: <fd602129dc74650b895192a24c97c3b1@sonic.net>
	<CAHzJPEp8dJqWf_S7V6nTr=Oqc9AUDcQzrQqKK6_4xnXM=b_zhA@mail.gmail.com>
Message-ID: <CAHzJPEoBL62KOfMaeP+zJsjyREnF85vzNYqoFasnF2fVf3xGPg@mail.gmail.com>

Regarding removeAll, I was asking about entrySet.removeAll().

I'm not sure this is really relevant. I was wondering if one might expect
that clear() and entrySet.removeAll and removing each item from an
entrySet's iterator should all have the same behavior.

On Thu, Feb 4, 2016 at 11:35 AM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> The entrySet iterator is recommended (by IDE's, static analysis, code
> reviewers) for efficiency any time the key and value might both be used
> during the iteration. As a result, keySet iteration tends to be refactored
> to entrySet iteration.
>
> So I don't think we can deduce that it.remove(k,v) necessarily means
> remove that *exact* (k,v). And in a concurrent context, the programmer
> probably does not have the expectation that it will always do so.
>
> If the intent is to remove any entry corresponding to the key, how would
> this be accomplished in an entrySet iteration after your change? How can a
> programmer remove only the exact entry with today's behavior?
>
> Futhermore, what should removeAll do? Can it remove nothing if all of the
> iterator's mappings are stale? The existing implementation favors removal.
>
> Here is some discussion around this behavior:
>
>
> http://stackoverflow.com/questions/29876083/behavior-of-entryset-removeif-in-concurrenthashmap
>
> Also this, tangentially:
>
>
> http://stackoverflow.com/questions/3768554/is-iterating-concurrenthashmap-values-thread-safe
>
> I suspect there are more than a few people who care, and some who have
> already worked around the current behavior if it was not their desired one.
>
>
> On Thu, Feb 4, 2016 at 10:46 AM, Mike Duigou <openjdk at duigou.org> wrote:
>
>> Hello all;
>>
>> I have found what seems like a bug in the way that the remove() method of
>> CHM entrySet iterators works. The bug doesn't require concurrent behaviour
>> but realistically that is the most likely way it arises. The problem is
>> that the entrySet iterator remove() internally uses the chm.remove(key)
>> method rather than the chm.remove(key, value) method. If there is an
>> intervening replacement of the mapping for a key between the iterator
>> next() and the remove() then it is possible to incorrectly remove that
>> mapping.
>>
>> I have made test program which compares the behaviour of
>> entryset().remove(staleMapping) to entrySet().iterator() remove() of the
>> same mapping.
>>
>> I encountered the problem in real world code where the entry was replaced
>> concurrently. I don't believe that there should be programs which expect
>> the existing behaviour though undoubtedly there are some. I believe it is
>> more likely that programs would/should expect the behaviour in which remove
>> of a stale entry does nothing.
>>
>> Cheers,
>>
>> Mike
>>
>>
>> /*
>>  * Written by Mike Duigou and released to the public domain, as explained
>> at
>>  * http://creativecommons.org/publicdomain/zero/1.0/
>> */
>>
>> package chm.test;
>>
>> import java.util.Iterator;
>> import java.util.Map;
>> import java.util.Set;
>> import java.util.concurrent.ConcurrentHashMap;
>>
>> /**
>>  * Compares behaviour of removal of a stale entry via entrySet.remove()
>> vs.
>>  * entrySet().iterator().remove()
>>  */
>> public class ConcurrentHashMapBug {
>>
>>     public static void main(String... args) {
>>         ConcurrentHashMap<String, String> chm = new ConcurrentHashMap<>();
>>
>>         chm.put("fred", "wilma");
>>         chm.put("barney", "betty");
>>
>>         Set<Map.Entry<String, String>> entries = chm.entrySet();
>>
>>         // Attempt removal of a mapping through entrySet with stale entry.
>>
>>         Map.Entry<String, String> fredEntry = null;
>>         for (Map.Entry<String, String> each : entries) {
>>             if ("fred".equals(each.getKey())) {
>>                 fredEntry = each;
>>                 break;
>>             }
>>         }
>>         assert fredEntry != null : "Entry not found";
>>         assert "wilma".equals(fredEntry.getValue()) : "wrong value";
>>
>>         // modify fred mapping
>>         chm.put("fred", "mildred");
>>         // fredEntry is now stale
>>         assert "wilma".equals(fredEntry.getValue()) : "live value?";
>>
>>         // attempt to remove our stale entry.
>>         assert !entries.remove(fredEntry) : "fred unexpectedly removed";
>>         // Mapping was not removed because entry value did not match
>> current mapping.
>>         assert chm.containsKey("fred") : "fred mapping missing";
>>         assert "mildred".equals(chm.get("fred")) : "fred mapping
>> incorrect";
>>
>>         // Attempt remove of a  mapping through entrySet
>> iterator.remove() with stale entry.
>>
>>         Iterator<Map.Entry<String, String>> iter = entries.iterator();
>>         Map.Entry<String, String> barneyEntry = null;
>>         while (iter.hasNext()) {
>>             Map.Entry<String, String> each = iter.next();
>>             if ("barney".equals(each.getKey())) {
>>                 barneyEntry = each;
>>                 break;
>>             }
>>         }
>>
>>         assert barneyEntry != null : "barney entry not found";
>>         assert "betty".equals(barneyEntry.getValue()) : "wrong value";
>>
>>         // modify barney mapping
>>         chm.put("barney", "hortence");
>>         // barneyEntry is now stale
>>         assert chm.containsKey("barney") : "mapping missing";
>>         assert "hortence".equals(chm.get("barney")) : "mapping incorrect";
>>         assert "betty".equals(barneyEntry.getValue()) : "live value?";
>>
>>         // attempt to remove our stale entry
>>         iter.remove();
>>         assert "betty".equals(barneyEntry.getValue()) : "live value?";
>>         // XXX Following fails. iter.remove() with stale entry
>> incorrectly succeeds.
>>         // should behave like chm.remove(barneyEntry.getKey(),
>> barneyEntry.getValue())
>>         assert chm.containsKey("barney") : "mapping missing";
>>         assert "hortence".equals(chm.get("barney")) : "mapping incorrect";
>>
>>         System.out.println("Success!");
>>     }
>> }
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160204/63318a80/attachment.html>

From joe.bowbeer at gmail.com  Thu Feb  4 15:01:10 2016
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 4 Feb 2016 12:01:10 -0800
Subject: [concurrency-interest] ConcurrentHashMap entrySet Iterator
	remove issue?
In-Reply-To: <CAHzJPEoBL62KOfMaeP+zJsjyREnF85vzNYqoFasnF2fVf3xGPg@mail.gmail.com>
References: <fd602129dc74650b895192a24c97c3b1@sonic.net>
	<CAHzJPEp8dJqWf_S7V6nTr=Oqc9AUDcQzrQqKK6_4xnXM=b_zhA@mail.gmail.com>
	<CAHzJPEoBL62KOfMaeP+zJsjyREnF85vzNYqoFasnF2fVf3xGPg@mail.gmail.com>
Message-ID: <CAHzJPEoSjp2n5r-GHndyFQsOMPvLxmUyNFCx6kgvw7ejHxBOEw@mail.gmail.com>

Also see: http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8078645

On Thu, Feb 4, 2016 at 11:52 AM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> Regarding removeAll, I was asking about entrySet.removeAll().
>
> I'm not sure this is really relevant. I was wondering if one might expect
> that clear() and entrySet.removeAll and removing each item from an
> entrySet's iterator should all have the same behavior.
>
> On Thu, Feb 4, 2016 at 11:35 AM, Joe Bowbeer <joe.bowbeer at gmail.com>
> wrote:
>
>> The entrySet iterator is recommended (by IDE's, static analysis, code
>> reviewers) for efficiency any time the key and value might both be used
>> during the iteration. As a result, keySet iteration tends to be refactored
>> to entrySet iteration.
>>
>> So I don't think we can deduce that it.remove(k,v) necessarily means
>> remove that *exact* (k,v). And in a concurrent context, the programmer
>> probably does not have the expectation that it will always do so.
>>
>> If the intent is to remove any entry corresponding to the key, how would
>> this be accomplished in an entrySet iteration after your change? How can a
>> programmer remove only the exact entry with today's behavior?
>>
>> Futhermore, what should removeAll do? Can it remove nothing if all of the
>> iterator's mappings are stale? The existing implementation favors removal.
>>
>> Here is some discussion around this behavior:
>>
>>
>> http://stackoverflow.com/questions/29876083/behavior-of-entryset-removeif-in-concurrenthashmap
>>
>> Also this, tangentially:
>>
>>
>> http://stackoverflow.com/questions/3768554/is-iterating-concurrenthashmap-values-thread-safe
>>
>> I suspect there are more than a few people who care, and some who have
>> already worked around the current behavior if it was not their desired one.
>>
>>
>> On Thu, Feb 4, 2016 at 10:46 AM, Mike Duigou <openjdk at duigou.org> wrote:
>>
>>> Hello all;
>>>
>>> I have found what seems like a bug in the way that the remove() method
>>> of CHM entrySet iterators works. The bug doesn't require concurrent
>>> behaviour but realistically that is the most likely way it arises. The
>>> problem is that the entrySet iterator remove() internally uses the
>>> chm.remove(key) method rather than the chm.remove(key, value) method. If
>>> there is an intervening replacement of the mapping for a key between the
>>> iterator next() and the remove() then it is possible to incorrectly remove
>>> that mapping.
>>>
>>> I have made test program which compares the behaviour of
>>> entryset().remove(staleMapping) to entrySet().iterator() remove() of the
>>> same mapping.
>>>
>>> I encountered the problem in real world code where the entry was
>>> replaced concurrently. I don't believe that there should be programs which
>>> expect the existing behaviour though undoubtedly there are some. I believe
>>> it is more likely that programs would/should expect the behaviour in which
>>> remove of a stale entry does nothing.
>>>
>>> Cheers,
>>>
>>> Mike
>>>
>>>
>>> /*
>>>  * Written by Mike Duigou and released to the public domain, as
>>> explained at
>>>  * http://creativecommons.org/publicdomain/zero/1.0/
>>> */
>>>
>>> package chm.test;
>>>
>>> import java.util.Iterator;
>>> import java.util.Map;
>>> import java.util.Set;
>>> import java.util.concurrent.ConcurrentHashMap;
>>>
>>> /**
>>>  * Compares behaviour of removal of a stale entry via entrySet.remove()
>>> vs.
>>>  * entrySet().iterator().remove()
>>>  */
>>> public class ConcurrentHashMapBug {
>>>
>>>     public static void main(String... args) {
>>>         ConcurrentHashMap<String, String> chm = new
>>> ConcurrentHashMap<>();
>>>
>>>         chm.put("fred", "wilma");
>>>         chm.put("barney", "betty");
>>>
>>>         Set<Map.Entry<String, String>> entries = chm.entrySet();
>>>
>>>         // Attempt removal of a mapping through entrySet with stale
>>> entry.
>>>
>>>         Map.Entry<String, String> fredEntry = null;
>>>         for (Map.Entry<String, String> each : entries) {
>>>             if ("fred".equals(each.getKey())) {
>>>                 fredEntry = each;
>>>                 break;
>>>             }
>>>         }
>>>         assert fredEntry != null : "Entry not found";
>>>         assert "wilma".equals(fredEntry.getValue()) : "wrong value";
>>>
>>>         // modify fred mapping
>>>         chm.put("fred", "mildred");
>>>         // fredEntry is now stale
>>>         assert "wilma".equals(fredEntry.getValue()) : "live value?";
>>>
>>>         // attempt to remove our stale entry.
>>>         assert !entries.remove(fredEntry) : "fred unexpectedly removed";
>>>         // Mapping was not removed because entry value did not match
>>> current mapping.
>>>         assert chm.containsKey("fred") : "fred mapping missing";
>>>         assert "mildred".equals(chm.get("fred")) : "fred mapping
>>> incorrect";
>>>
>>>         // Attempt remove of a  mapping through entrySet
>>> iterator.remove() with stale entry.
>>>
>>>         Iterator<Map.Entry<String, String>> iter = entries.iterator();
>>>         Map.Entry<String, String> barneyEntry = null;
>>>         while (iter.hasNext()) {
>>>             Map.Entry<String, String> each = iter.next();
>>>             if ("barney".equals(each.getKey())) {
>>>                 barneyEntry = each;
>>>                 break;
>>>             }
>>>         }
>>>
>>>         assert barneyEntry != null : "barney entry not found";
>>>         assert "betty".equals(barneyEntry.getValue()) : "wrong value";
>>>
>>>         // modify barney mapping
>>>         chm.put("barney", "hortence");
>>>         // barneyEntry is now stale
>>>         assert chm.containsKey("barney") : "mapping missing";
>>>         assert "hortence".equals(chm.get("barney")) : "mapping
>>> incorrect";
>>>         assert "betty".equals(barneyEntry.getValue()) : "live value?";
>>>
>>>         // attempt to remove our stale entry
>>>         iter.remove();
>>>         assert "betty".equals(barneyEntry.getValue()) : "live value?";
>>>         // XXX Following fails. iter.remove() with stale entry
>>> incorrectly succeeds.
>>>         // should behave like chm.remove(barneyEntry.getKey(),
>>> barneyEntry.getValue())
>>>         assert chm.containsKey("barney") : "mapping missing";
>>>         assert "hortence".equals(chm.get("barney")) : "mapping
>>> incorrect";
>>>
>>>         System.out.println("Success!");
>>>     }
>>> }
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160204/2c9882ca/attachment-0001.html>

From martinrb at google.com  Fri Feb  5 21:05:12 2016
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 5 Feb 2016 18:05:12 -0800
Subject: [concurrency-interest] ConcurrentHashMap entrySet Iterator
	remove issue?
In-Reply-To: <CAHzJPEoSjp2n5r-GHndyFQsOMPvLxmUyNFCx6kgvw7ejHxBOEw@mail.gmail.com>
References: <fd602129dc74650b895192a24c97c3b1@sonic.net>
	<CAHzJPEp8dJqWf_S7V6nTr=Oqc9AUDcQzrQqKK6_4xnXM=b_zhA@mail.gmail.com>
	<CAHzJPEoBL62KOfMaeP+zJsjyREnF85vzNYqoFasnF2fVf3xGPg@mail.gmail.com>
	<CAHzJPEoSjp2n5r-GHndyFQsOMPvLxmUyNFCx6kgvw7ejHxBOEw@mail.gmail.com>
Message-ID: <CA+kOe0-6h=1JfPLci9zfM-4RPy2nyRMECXVFif3ihdqpDep9xQ@mail.gmail.com>

It's not entirely clear whether entrySet().iterator().remove() should
remove the entry for the current key or only if still mapped to the
old value.  But acting like the latter seems better for users - I
agree with Mike.  The existence of map.remove(K, V) gives an
expectation that iterator().remove() works likewise.

The counter-arguments against switching now are:
- it is a small added implementation burden for the iterator to keep
track of the old value, that will almost never be used.
- users can just call remove(K, V) - they have the old v in hand, that
the map has already forgotten.
- status quo wins whenever there's doubt!

But the behavior should be documented.

From cowwoc at bbs.darktech.org  Fri Feb  5 22:18:33 2016
From: cowwoc at bbs.darktech.org (cowwoc)
Date: Fri, 5 Feb 2016 20:18:33 -0700 (MST)
Subject: [concurrency-interest] Single-threaded ForkJoinPool
Message-ID: <1454728713539-13232.post@n7.nabble.com>

Hi,

Is this the correct mailing list for discussing ForkJoinPool in JDK9? If
not, please point me to the right place.

I have a feature request for ForkJoinPool which doesn't seem to be possible
to implement without a JDK change: http://stackoverflow.com/q/34012134/14731

Specifically, I need to be able to an application that uses Random and
ForkJoinPool in a deterministic manner when debugging/profiling but run
full-speed in normal execution mode. I have all the moving parts nailing
down except for ForkJoinPool.

If I create ForkJoinPool with a parallelism of 1, sometimes I see two worker
threads getting used. I am guessing that this is caused by
ForkJoinTask.get() invoking ForkJoinPool.common.externalHelpComplete(), but
maybe something else is going on.

Is there a way for me to guarantee that ForkJoinThread will use exactly 1
worker thread, no less, no more? Would you like me to file a formal feature
request?

Thank you,
Gili



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From peter.levart at gmail.com  Sat Feb  6 04:24:07 2016
From: peter.levart at gmail.com (Peter Levart)
Date: Sat, 6 Feb 2016 10:24:07 +0100
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <1454728713539-13232.post@n7.nabble.com>
References: <1454728713539-13232.post@n7.nabble.com>
Message-ID: <56B5BBB7.2000703@gmail.com>

Hi Gili,

Have you thought of using SplittableRandom instead? Initially you create 
it with a predefined seed for the root task. Whenever you fork-off a 
task, you create for it a new instance by invoking 
SplittableRandom.split(). This should give you deterministic behavior 
regardless of how many threads you use for fork-join pool and the 
dynamics of execution. For example:

public class SumRandomInts extends RecursiveTask<Long> {
     final SplittableRandom rnd;
     final int count;

     public SumRandomInts(int count, SplittableRandom rnd) {
         this.rnd = rnd;
         this.count = count;
     }

     @Override
     protected Long compute() {
         if (count < 1000) {
             long sum = 0L;
             for (int i = 0; i < count; i++) {
                 sum += rnd.nextInt();
             }
             return sum;
         } else {
             SumRandomInts t1 = new SumRandomInts(count / 2, rnd.split());
             SumRandomInts t2 = new SumRandomInts(count - count / 2, 
rnd.split());
             t1.fork();
             return t2.compute() + t1.join();
         }
     }

     public static void main(String[] args) throws Exception {
         long result = ForkJoinPool.commonPool().submit(
             new SumRandomInts(100000, new SplittableRandom(12345L))).get();
         System.out.println(result);
     }
}


Regards, Peter

On 02/06/2016 04:18 AM, cowwoc wrote:
> Hi,
>
> Is this the correct mailing list for discussing ForkJoinPool in JDK9? If
> not, please point me to the right place.
>
> I have a feature request for ForkJoinPool which doesn't seem to be possible
> to implement without a JDK change: http://stackoverflow.com/q/34012134/14731
>
> Specifically, I need to be able to an application that uses Random and
> ForkJoinPool in a deterministic manner when debugging/profiling but run
> full-speed in normal execution mode. I have all the moving parts nailing
> down except for ForkJoinPool.
>
> If I create ForkJoinPool with a parallelism of 1, sometimes I see two worker
> threads getting used. I am guessing that this is caused by
> ForkJoinTask.get() invoking ForkJoinPool.common.externalHelpComplete(), but
> maybe something else is going on.
>
> Is there a way for me to guarantee that ForkJoinThread will use exactly 1
> worker thread, no less, no more? Would you like me to file a formal feature
> request?
>
> Thank you,
> Gili
>
>
>
> --
> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160206/dd69b15e/attachment.html>

From viktor.klang at gmail.com  Sat Feb  6 05:21:31 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Sat, 6 Feb 2016 11:21:31 +0100
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <1454728713539-13232.post@n7.nabble.com>
References: <1454728713539-13232.post@n7.nabble.com>
Message-ID: <CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>

What happens if you supply it with a thread factory which only allows a
single thread to be alive at a time, and returns null if it already has
returned a still living thread?

-- 
Cheers,
?
On Feb 6, 2016 05:19, "cowwoc" <cowwoc at bbs.darktech.org> wrote:

> Hi,
>
> Is this the correct mailing list for discussing ForkJoinPool in JDK9? If
> not, please point me to the right place.
>
> I have a feature request for ForkJoinPool which doesn't seem to be possible
> to implement without a JDK change:
> http://stackoverflow.com/q/34012134/14731
>
> Specifically, I need to be able to an application that uses Random and
> ForkJoinPool in a deterministic manner when debugging/profiling but run
> full-speed in normal execution mode. I have all the moving parts nailing
> down except for ForkJoinPool.
>
> If I create ForkJoinPool with a parallelism of 1, sometimes I see two
> worker
> threads getting used. I am guessing that this is caused by
> ForkJoinTask.get() invoking ForkJoinPool.common.externalHelpComplete(), but
> maybe something else is going on.
>
> Is there a way for me to guarantee that ForkJoinThread will use exactly 1
> worker thread, no less, no more? Would you like me to file a formal feature
> request?
>
> Thank you,
> Gili
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160206/4ad49624/attachment.html>

From cowwoc at bbs.darktech.org  Sat Feb  6 06:54:57 2016
From: cowwoc at bbs.darktech.org (cowwoc)
Date: Sat, 6 Feb 2016 04:54:57 -0700 (MST)
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56B5BBB7.2000703@gmail.com>
References: <1454728713539-13232.post@n7.nabble.com>
	<56B5BBB7.2000703@gmail.com>
Message-ID: <56B5EB25.1030607@bbs.darktech.org>

Hi Peter,

I'm not sure I understand. Won't I end up with different random numbers 
depending on runtime conditions? I mean, it sounds as if 
SplittableRandom is only deterministic if threads invoke split() in the 
same order across JVM runs. What happens if task1 runs faster than task2 
in one run, but the opposite is true in another run? Won't I end up with 
numbers?

Thanks,
Gili

On 2016-02-06 3:43 AM, Peter Levart [via JSR166 Concurrency] wrote:
> Hi Gili,
>
> Have you thought of using SplittableRandom instead? Initially you 
> create it with a predefined seed for the root task. Whenever you 
> fork-off a task, you create for it a new instance by invoking 
> SplittableRandom.split(). This should give you deterministic behavior 
> regardless of how many threads you use for fork-join pool and the 
> dynamics of execution. For example:
>
> public class SumRandomInts extends RecursiveTask<Long> {
>     final SplittableRandom rnd;
>     final int count;
>
>     public SumRandomInts(int count, SplittableRandom rnd) {
>         this.rnd = rnd;
>         this.count = count;
>     }
>
>     @Override
>     protected Long compute() {
>         if (count < 1000) {
>             long sum = 0L;
>             for (int i = 0; i < count; i++) {
>                 sum += rnd.nextInt();
>             }
>             return sum;
>         } else {
>             SumRandomInts t1 = new SumRandomInts(count / 2, rnd.split());
>             SumRandomInts t2 = new SumRandomInts(count - count / 2, 
> rnd.split());
>             t1.fork();
>             return t2.compute() + t1.join();
>         }
>     }
>
>     public static void main(String[] args) throws Exception {
>         long result = ForkJoinPool.commonPool().submit(
>             new SumRandomInts(100000, new 
> SplittableRandom(12345L))).get();
>         System.out.println(result);
>     }
> }
>
>
> Regards, Peter
>
> On 02/06/2016 04:18 AM, cowwoc wrote:
>> Hi,
>>
>> Is this the correct mailing list for discussing ForkJoinPool in JDK9? If
>> not, please point me to the right place.
>>
>> I have a feature request for ForkJoinPool which doesn't seem to be possible
>> to implement without a JDK change:http://stackoverflow.com/q/34012134/14731
>>
>> Specifically, I need to be able to an application that uses Random and
>> ForkJoinPool in a deterministic manner when debugging/profiling but run
>> full-speed in normal execution mode. I have all the moving parts nailing
>> down except for ForkJoinPool.
>>
>> If I create ForkJoinPool with a parallelism of 1, sometimes I see two worker
>> threads getting used. I am guessing that this is caused by
>> ForkJoinTask.get() invoking ForkJoinPool.common.externalHelpComplete(), but
>> maybe something else is going on.
>>
>> Is there a way for me to guarantee that ForkJoinThread will use exactly 1
>> worker thread, no less, no more? Would you like me to file a formal feature
>> request?
>>
>> Thank you,
>> Gili
>>
>>
>>
>> --
>> View this message in context:http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>> _______________________________________________
>> Concurrency-interest mailing list
>> [hidden email] </user/SendEmail.jtp?type=node&node=13233&i=0>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> [hidden email] </user/SendEmail.jtp?type=node&node=13233&i=1>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------------------------------------------------
> If you reply to this email, your message will be added to the 
> discussion below:
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13233.html 
>
> To unsubscribe from Single-threaded ForkJoinPool, click here 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=unsubscribe_by_code&node=13232&code=Y293d29jQGJicy5kYXJrdGVjaC5vcmd8MTMyMzJ8MTU3NDMyMTI0Nw==>.
> NAML 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13235.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160206/bb8130da/attachment-0001.html>

From cowwoc at bbs.darktech.org  Sat Feb  6 07:05:12 2016
From: cowwoc at bbs.darktech.org (cowwoc)
Date: Sat, 6 Feb 2016 05:05:12 -0700 (MST)
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
Message-ID: <56B5ED98.6010307@bbs.darktech.org>

Interesting idea.

By the looks of it, returning null causes ForkJoinPool to give up 
creating a new worker thread. If there are no active worker threads, 
then ForkJoinTask.get() hangs forever. Now, I wonder if it's safe to do 
as you mention... don't we run the risk of some sort of race conditions 
where the first thread shuts down at the exact same time that I reject 
the creation of the second thread and as a result ForkJoinTask.get() 
hangs forever?

Gili

On 2016-02-06 4:39 AM, Viktor Klang [via JSR166 Concurrency] wrote:
>
> What happens if you supply it with a thread factory which only allows 
> a single thread to be alive at a time, and returns null if it already 
> has returned a still living thread?
>
> -- 
> Cheers,
> ?
>
> On Feb 6, 2016 05:19, "cowwoc" <[hidden email] 
> </user/SendEmail.jtp?type=node&node=13234&i=0>> wrote:
>
>     Hi,
>
>     Is this the correct mailing list for discussing ForkJoinPool in
>     JDK9? If
>     not, please point me to the right place.
>
>     I have a feature request for ForkJoinPool which doesn't seem to be
>     possible
>     to implement without a JDK change:
>     http://stackoverflow.com/q/34012134/14731
>
>     Specifically, I need to be able to an application that uses Random and
>     ForkJoinPool in a deterministic manner when debugging/profiling
>     but run
>     full-speed in normal execution mode. I have all the moving parts
>     nailing
>     down except for ForkJoinPool.
>
>     If I create ForkJoinPool with a parallelism of 1, sometimes I see
>     two worker
>     threads getting used. I am guessing that this is caused by
>     ForkJoinTask.get() invoking
>     ForkJoinPool.common.externalHelpComplete(), but
>     maybe something else is going on.
>
>     Is there a way for me to guarantee that ForkJoinThread will use
>     exactly 1
>     worker thread, no less, no more? Would you like me to file a
>     formal feature
>     request?
>
>     Thank you,
>     Gili
>
>
>
>     --
>     View this message in context:
>     http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>     Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>     _______________________________________________
>     Concurrency-interest mailing list
>     [hidden email] </user/SendEmail.jtp?type=node&node=13234&i=1>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> [hidden email] </user/SendEmail.jtp?type=node&node=13234&i=2>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------------------------------------------------
> If you reply to this email, your message will be added to the 
> discussion below:
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13234.html 
>
> To unsubscribe from Single-threaded ForkJoinPool, click here 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=unsubscribe_by_code&node=13232&code=Y293d29jQGJicy5kYXJrdGVjaC5vcmd8MTMyMzJ8MTU3NDMyMTI0Nw==>.
> NAML 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13236.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160206/30759826/attachment.html>

From viktor.klang at gmail.com  Sat Feb  6 08:18:39 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Sat, 6 Feb 2016 14:18:39 +0100
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56B5ED98.6010307@bbs.darktech.org>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B5ED98.6010307@bbs.darktech.org>
Message-ID: <CANPzfU_Kz0oR3oqPqZusBhoM1Uqnku32XQJQxzdeWOUewxmZHA@mail.gmail.com>

Try and report back :)

On Sat, Feb 6, 2016 at 1:05 PM, cowwoc <cowwoc at bbs.darktech.org> wrote:

> Interesting idea.
>
> By the looks of it, returning null causes ForkJoinPool to give up creating
> a new worker thread. If there are no active worker threads, then
> ForkJoinTask.get() hangs forever. Now, I wonder if it's safe to do as you
> mention... don't we run the risk of some sort of race conditions where the
> first thread shuts down at the exact same time that I reject the creation
> of the second thread and as a result ForkJoinTask.get() hangs forever?
>
> Gili
>
> On 2016-02-06 4:39 AM, Viktor Klang [via JSR166 Concurrency] wrote:
>
> What happens if you supply it with a thread factory which only allows a
> single thread to be alive at a time, and returns null if it already has
> returned a still living thread?
>
> --
> Cheers,
> ?
> On Feb 6, 2016 05:19, "cowwoc" <[hidden email]
> <http:///user/SendEmail.jtp?type=node&node=13234&i=0>> wrote:
>
>> Hi,
>>
>> Is this the correct mailing list for discussing ForkJoinPool in JDK9? If
>> not, please point me to the right place.
>>
>> I have a feature request for ForkJoinPool which doesn't seem to be
>> possible
>> to implement without a JDK change:
>> http://stackoverflow.com/q/34012134/14731
>>
>> Specifically, I need to be able to an application that uses Random and
>> ForkJoinPool in a deterministic manner when debugging/profiling but run
>> full-speed in normal execution mode. I have all the moving parts nailing
>> down except for ForkJoinPool.
>>
>> If I create ForkJoinPool with a parallelism of 1, sometimes I see two
>> worker
>> threads getting used. I am guessing that this is caused by
>> ForkJoinTask.get() invoking ForkJoinPool.common.externalHelpComplete(),
>> but
>> maybe something else is going on.
>>
>> Is there a way for me to guarantee that ForkJoinThread will use exactly 1
>> worker thread, no less, no more? Would you like me to file a formal
>> feature
>> request?
>>
>> Thank you,
>> Gili
>>
>>
>>
>> --
>> View this message in context:
>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>> _______________________________________________
>> Concurrency-interest mailing list
>> [hidden email] <http:///user/SendEmail.jtp?type=node&node=13234&i=1>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> [hidden email] <http:///user/SendEmail.jtp?type=node&node=13234&i=2>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------
> If you reply to this email, your message will be added to the discussion
> below:
>
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13234.html
> To unsubscribe from Single-threaded ForkJoinPool, click here.
> NAML
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml>
>
>
>
> ------------------------------
> View this message in context: Re: Single-threaded ForkJoinPool
> <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13236.html>
>
> Sent from the JSR166 Concurrency mailing list archive
> <http://jsr166-concurrency.10961.n7.nabble.com/> at Nabble.com.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160206/21927301/attachment.html>

From cowwoc at bbs.darktech.org  Sat Feb  6 08:06:51 2016
From: cowwoc at bbs.darktech.org (cowwoc)
Date: Sat, 6 Feb 2016 06:06:51 -0700 (MST)
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <CANPzfU_Kz0oR3oqPqZusBhoM1Uqnku32XQJQxzdeWOUewxmZHA@mail.gmail.com>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B5ED98.6010307@bbs.darktech.org>
	<CANPzfU_Kz0oR3oqPqZusBhoM1Uqnku32XQJQxzdeWOUewxmZHA@mail.gmail.com>
Message-ID: <56B5FC08.1000305@bbs.darktech.org>

Normally I would, but when it comes to race conditions empirical 
evidence doesn't really cut it :) I am looking for a guarantee (from the 
specification or the implementers) that the design is meant to cover 
this situation.

There is nothing worse than chasing down intermittent bugs :)

Gili

On 2016-02-06 7:37 AM, Viktor Klang [via JSR166 Concurrency] wrote:
> Try and report back :)
>
> On Sat, Feb 6, 2016 at 1:05 PM, cowwoc <[hidden email] 
> </user/SendEmail.jtp?type=node&node=13237&i=0>> wrote:
>
>     Interesting idea.
>
>     By the looks of it, returning null causes ForkJoinPool to give up
>     creating a new worker thread. If there are no active worker
>     threads, then ForkJoinTask.get() hangs forever. Now, I wonder if
>     it's safe to do as you mention... don't we run the risk of some
>     sort of race conditions where the first thread shuts down at the
>     exact same time that I reject the creation of the second thread
>     and as a result ForkJoinTask.get() hangs forever?
>
>     Gili
>
>     On 2016-02-06 4:39 AM, Viktor Klang [via JSR166 Concurrency] wrote:
>>
>>     What happens if you supply it with a thread factory which only
>>     allows a single thread to be alive at a time, and returns null if
>>     it already has returned a still living thread?
>>
>>     -- 
>>     Cheers,
>>     ?
>>
>>     On Feb 6, 2016 05:19, "cowwoc" <[hidden email]
>>     <http:///user/SendEmail.jtp?type=node&node=13234&i=0>> wrote:
>>
>>         Hi,
>>
>>         Is this the correct mailing list for discussing ForkJoinPool
>>         in JDK9? If
>>         not, please point me to the right place.
>>
>>         I have a feature request for ForkJoinPool which doesn't seem
>>         to be possible
>>         to implement without a JDK change:
>>         http://stackoverflow.com/q/34012134/14731
>>
>>         Specifically, I need to be able to an application that uses
>>         Random and
>>         ForkJoinPool in a deterministic manner when
>>         debugging/profiling but run
>>         full-speed in normal execution mode. I have all the moving
>>         parts nailing
>>         down except for ForkJoinPool.
>>
>>         If I create ForkJoinPool with a parallelism of 1, sometimes I
>>         see two worker
>>         threads getting used. I am guessing that this is caused by
>>         ForkJoinTask.get() invoking
>>         ForkJoinPool.common.externalHelpComplete(), but
>>         maybe something else is going on.
>>
>>         Is there a way for me to guarantee that ForkJoinThread will
>>         use exactly 1
>>         worker thread, no less, no more? Would you like me to file a
>>         formal feature
>>         request?
>>
>>         Thank you,
>>         Gili
>>
>>
>>
>>         --
>>         View this message in context:
>>         http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>>         Sent from the JSR166 Concurrency mailing list archive at
>>         Nabble.com.
>>         _______________________________________________
>>         Concurrency-interest mailing list
>>         [hidden email]
>>         <http:///user/SendEmail.jtp?type=node&node=13234&i=1>
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     [hidden email] <http:///user/SendEmail.jtp?type=node&node=13234&i=2>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>     ------------------------------------------------------------------------
>>     If you reply to this email, your message will be added to the
>>     discussion below:
>>     http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13234.html
>>
>>     To unsubscribe from Single-threaded ForkJoinPool, click here.
>>     NAML
>>     <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml>
>>
>
>
>     ------------------------------------------------------------------------
>     View this message in context: Re: Single-threaded ForkJoinPool
>     <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13236.html>
>
>
>     Sent from the JSR166 Concurrency mailing list archive
>     <http://jsr166-concurrency.10961.n7.nabble.com/> at Nabble.com.
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     [hidden email] </user/SendEmail.jtp?type=node&node=13237&i=1>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> -- 
> Cheers,
> ?
>
> _______________________________________________
> Concurrency-interest mailing list
> [hidden email] </user/SendEmail.jtp?type=node&node=13237&i=2>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------------------------------------------------
> If you reply to this email, your message will be added to the 
> discussion below:
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13237.html 
>
> To unsubscribe from Single-threaded ForkJoinPool, click here 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=unsubscribe_by_code&node=13232&code=Y293d29jQGJicy5kYXJrdGVjaC5vcmd8MTMyMzJ8MTU3NDMyMTI0Nw==>.
> NAML 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13238.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160206/5d0e5c35/attachment-0001.html>

From viktor.klang at gmail.com  Sat Feb  6 09:11:59 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Sat, 6 Feb 2016 15:11:59 +0100
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56B5FC08.1000305@bbs.darktech.org>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B5ED98.6010307@bbs.darktech.org>
	<CANPzfU_Kz0oR3oqPqZusBhoM1Uqnku32XQJQxzdeWOUewxmZHA@mail.gmail.com>
	<56B5FC08.1000305@bbs.darktech.org>
Message-ID: <CANPzfU9tDmFpeyBk3Y3Q-0PQYp0RjMotiHErrkpcvqtUi1+w9Q@mail.gmail.com>

A guarantee would seem to imply formal verification. I'm pretty sure the
FJP isn't formally verified which leaves you with either having to go with
empirical evidence or faith? :)

On Sat, Feb 6, 2016 at 2:06 PM, cowwoc <cowwoc at bbs.darktech.org> wrote:

> Normally I would, but when it comes to race conditions empirical evidence
> doesn't really cut it :) I am looking for a guarantee (from the
> specification or the implementers) that the design is meant to cover this
> situation.
>
> There is nothing worse than chasing down intermittent bugs :)
>
> Gili
>
> On 2016-02-06 7:37 AM, Viktor Klang [via JSR166 Concurrency] wrote:
>
> Try and report back :)
>
> On Sat, Feb 6, 2016 at 1:05 PM, cowwoc <[hidden email]
> <http:///user/SendEmail.jtp?type=node&node=13237&i=0>> wrote:
>
>> Interesting idea.
>>
>> By the looks of it, returning null causes ForkJoinPool to give up
>> creating a new worker thread. If there are no active worker threads, then
>> ForkJoinTask.get() hangs forever. Now, I wonder if it's safe to do as you
>> mention... don't we run the risk of some sort of race conditions where the
>> first thread shuts down at the exact same time that I reject the creation
>> of the second thread and as a result ForkJoinTask.get() hangs forever?
>>
>> Gili
>>
>> On 2016-02-06 4:39 AM, Viktor Klang [via JSR166 Concurrency] wrote:
>>
>> What happens if you supply it with a thread factory which only allows a
>> single thread to be alive at a time, and returns null if it already has
>> returned a still living thread?
>>
>> --
>> Cheers,
>> ?
>> On Feb 6, 2016 05:19, "cowwoc" <[hidden email]
>> <http:///user/SendEmail.jtp?type=node&node=13234&i=0>> wrote:
>>
>>> Hi,
>>>
>>> Is this the correct mailing list for discussing ForkJoinPool in JDK9? If
>>> not, please point me to the right place.
>>>
>>> I have a feature request for ForkJoinPool which doesn't seem to be
>>> possible
>>> to implement without a JDK change:
>>> <http://stackoverflow.com/q/34012134/14731>
>>> http://stackoverflow.com/q/34012134/14731
>>>
>>> Specifically, I need to be able to an application that uses Random and
>>> ForkJoinPool in a deterministic manner when debugging/profiling but run
>>> full-speed in normal execution mode. I have all the moving parts nailing
>>> down except for ForkJoinPool.
>>>
>>> If I create ForkJoinPool with a parallelism of 1, sometimes I see two
>>> worker
>>> threads getting used. I am guessing that this is caused by
>>> ForkJoinTask.get() invoking ForkJoinPool.common.externalHelpComplete(),
>>> but
>>> maybe something else is going on.
>>>
>>> Is there a way for me to guarantee that ForkJoinThread will use exactly 1
>>> worker thread, no less, no more? Would you like me to file a formal
>>> feature
>>> request?
>>>
>>> Thank you,
>>> Gili
>>>
>>>
>>>
>>> --
>>> View this message in context:
>>> <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html>
>>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> [hidden email] <http:///user/SendEmail.jtp?type=node&node=13234&i=1>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> [hidden email] <http:///user/SendEmail.jtp?type=node&node=13234&i=2>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> ------------------------------
>> If you reply to this email, your message will be added to the discussion
>> below:
>>
>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13234.html
>> To unsubscribe from Single-threaded ForkJoinPool, click here.
>> NAML
>> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml>
>>
>>
>>
>> ------------------------------
>> View this message in context: Re: Single-threaded ForkJoinPool
>> <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13236.html>
>>
>> Sent from the JSR166 Concurrency mailing list archive
>> <http://jsr166-concurrency.10961.n7.nabble.com/> at Nabble.com.
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> [hidden email] <http:///user/SendEmail.jtp?type=node&node=13237&i=1>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> --
> Cheers,
> ?
>
> _______________________________________________
> Concurrency-interest mailing list
> [hidden email] <http:///user/SendEmail.jtp?type=node&node=13237&i=2>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------
> If you reply to this email, your message will be added to the discussion
> below:
>
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13237.html
> To unsubscribe from Single-threaded ForkJoinPool, click here.
> NAML
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml>
>
>
>
> ------------------------------
> View this message in context: Re: Single-threaded ForkJoinPool
> <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13238.html>
> Sent from the JSR166 Concurrency mailing list archive
> <http://jsr166-concurrency.10961.n7.nabble.com/> at Nabble.com.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160206/f40f5c59/attachment.html>

From peter.levart at gmail.com  Sat Feb  6 13:01:39 2016
From: peter.levart at gmail.com (Peter Levart)
Date: Sat, 6 Feb 2016 19:01:39 +0100
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56B5EB25.1030607@bbs.darktech.org>
References: <1454728713539-13232.post@n7.nabble.com>
	<56B5BBB7.2000703@gmail.com> <56B5EB25.1030607@bbs.darktech.org>
Message-ID: <56B63503.3040509@gmail.com>



On 02/06/2016 12:54 PM, cowwoc wrote:
> Hi Peter,
>
> I'm not sure I understand. Won't I end up with different random 
> numbers depending on runtime conditions?

No. The initial seed for the root SplittableRandom instance will 
determine the sequences for all its descendants.

SplittableRandom r1 = new SplittableRandom(1234);
SplittableRandom r2 = r1.split();

...is conceptually equivalent to:

Random r1 = new Random(1234);
Random r2 = new Random(r1.nextLong());


Consider the following arrangement:

Task1:
Random r1 = new Random(1234);
int i11 = r1.nextInt();
int i12 = r1.nextInt();
Random r2 = new Random(r1.nextLong());
Random r3 = new Random(r1.nextLong());

Task2:
int i21 = r2.nextInt();
int i22 = r2.nextInt();

Task3:
int i31 = r3.nextInt();
int i32 = r3.nextInt();

It doesn't matter when Task2 and Task3 are executed and by which thread 
(as long as they are executed after Task1 which creates the r2 & r3 
instances for them). Each task is using it's own private PRNG instance. 
If you can make the algorithm within the single task deterministic, the 
whole composition will be deterministic.


> I mean, it sounds as if SplittableRandom is only deterministic if 
> threads invoke split() in the same order across JVM runs. What happens 
> if task1 runs faster than task2 in one run, but the opposite is true 
> in another run? Won't I end up with numbers?

If each task is using its own private instance of PRNG, then other tasks 
can't have any effect on it, so it doesn't matter when or by which 
thread they are executed.

Regards, Peter

>
> Thanks,
> Gili
>
> On 2016-02-06 3:43 AM, Peter Levart [via JSR166 Concurrency] wrote:
>> Hi Gili,
>>
>> Have you thought of using SplittableRandom instead? Initially you 
>> create it with a predefined seed for the root task. Whenever you 
>> fork-off a task, you create for it a new instance by invoking 
>> SplittableRandom.split(). This should give you deterministic behavior 
>> regardless of how many threads you use for fork-join pool and the 
>> dynamics of execution. For example:
>>
>> public class SumRandomInts extends RecursiveTask<Long> {
>>     final SplittableRandom rnd;
>>     final int count;
>>
>>     public SumRandomInts(int count, SplittableRandom rnd) {
>>         this.rnd = rnd;
>>         this.count = count;
>>     }
>>
>>     @Override
>>     protected Long compute() {
>>         if (count < 1000) {
>>             long sum = 0L;
>>             for (int i = 0; i < count; i++) {
>>                 sum += rnd.nextInt();
>>             }
>>             return sum;
>>         } else {
>>             SumRandomInts t1 = new SumRandomInts(count / 2, rnd.split());
>>             SumRandomInts t2 = new SumRandomInts(count - count / 2, 
>> rnd.split());
>>             t1.fork();
>>             return t2.compute() + t1.join();
>>         }
>>     }
>>
>>     public static void main(String[] args) throws Exception {
>>         long result = ForkJoinPool.commonPool().submit(
>>             new SumRandomInts(100000, new 
>> SplittableRandom(12345L))).get();
>>         System.out.println(result);
>>     }
>> }
>>
>>
>> Regards, Peter
>>
>> On 02/06/2016 04:18 AM, cowwoc wrote:
>>> Hi,
>>>
>>> Is this the correct mailing list for discussing ForkJoinPool in JDK9? If
>>> not, please point me to the right place.
>>>
>>> I have a feature request for ForkJoinPool which doesn't seem to be possible
>>> to implement without a JDK change:http://stackoverflow.com/q/34012134/14731
>>>
>>> Specifically, I need to be able to an application that uses Random and
>>> ForkJoinPool in a deterministic manner when debugging/profiling but run
>>> full-speed in normal execution mode. I have all the moving parts nailing
>>> down except for ForkJoinPool.
>>>
>>> If I create ForkJoinPool with a parallelism of 1, sometimes I see two worker
>>> threads getting used. I am guessing that this is caused by
>>> ForkJoinTask.get() invoking ForkJoinPool.common.externalHelpComplete(), but
>>> maybe something else is going on.
>>>
>>> Is there a way for me to guarantee that ForkJoinThread will use exactly 1
>>> worker thread, no less, no more? Would you like me to file a formal feature
>>> request?
>>>
>>> Thank you,
>>> Gili
>>>
>>>
>>>
>>> --
>>> View this message in context:http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> [hidden email] </user/SendEmail.jtp?type=node&node=13233&i=0>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> [hidden email] </user/SendEmail.jtp?type=node&node=13233&i=1>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> ------------------------------------------------------------------------
>> If you reply to this email, your message will be added to the 
>> discussion below:
>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13233.html 
>>
>> To unsubscribe from Single-threaded ForkJoinPool, click here.
>> NAML 
>> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>>
>
>
> ------------------------------------------------------------------------
> View this message in context: Re: Single-threaded ForkJoinPool 
> <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13235.html>
> Sent from the JSR166 Concurrency mailing list archive 
> <http://jsr166-concurrency.10961.n7.nabble.com/> at Nabble.com.
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160206/dad7d673/attachment.html>

From jeffhain at rocketmail.com  Sat Feb  6 13:05:05 2016
From: jeffhain at rocketmail.com (Jeff Hain)
Date: Sat, 6 Feb 2016 18:05:05 +0000 (UTC)
Subject: [concurrency-interest] Single-threaded ForkJoinPool
References: <117221259.428166.1454781905266.JavaMail.yahoo.ref@mail.yahoo.com>
Message-ID: <117221259.428166.1454781905266.JavaMail.yahoo@mail.yahoo.com>

Hi

>Specifically, I need to be able to an application that uses Random and
>ForkJoinPool in a deterministic manner when debugging/profiling but run
>full-speed in normal execution mode. I have all the moving parts nailing
>down except for ForkJoinPool.

You could abstract away your usage of ForkJoinPool behind a little interface,
and use a simple sequential implementation for debugging/profiling
(that's what I always do - being able to abstract away all threading issues
is priceless ;).

AFAIK ForkJoinPool is more designed for people to implement threading libraries
on top of it, than to be used directly from the domain code that you want to
debug or profile.

-Jeff

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160206/ae588120/attachment.html>

From peter.levart at gmail.com  Sat Feb  6 13:27:29 2016
From: peter.levart at gmail.com (Peter Levart)
Date: Sat, 6 Feb 2016 19:27:29 +0100
Subject: [concurrency-interest] ClassLoader deadlock
In-Reply-To: <56B5E446.9020205@zeus.net.au>
References: <56B5DB78.1070502@zeus.net.au> <56B5DF8C.5010201@oracle.com>
	<56B5E446.9020205@zeus.net.au>
Message-ID: <56B63B11.20903@gmail.com>



On 02/06/2016 01:17 PM, Peter Firmstone wrote:
> The security manager is non blocking, unfortunately java system 
> classes aren't.

It doesn't seem so. At least, I can't find where main thread locks the 
0x040ebee8 monitor:

"Thread-1":
   waiting to lock monitor 0x142766ac (object 0x040ebee8, a [I),
   which is held by "main"


"main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for monitor 
entry [0x0185e000]
    java.lang.Thread.State: BLOCKED (on object monitor)
         at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
         - waiting to lock <0x03f624b8> (a java.lang.Object)
         at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
         at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
         at 
org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124)
         at 
org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)
         at 
org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44)
         at 
org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57)
         at 
org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64)
         at 
org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128)
         at 
org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44)
         at 
org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)
         at 
org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68)
         at 
org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261)
         at 
org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202)
         at java.lang.System.checkIO(System.java:253)
         at java.lang.System.setErr(System.java:199)
         at org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)


...no mention of 0x040ebee8 in main thread...?!

Peter

>
> The policy provider in use thread confines PermissionCollection 
> instances, which never leave the cpu cache, they are discarded 
> immediately after use.
>
> The problem here is that two different threads are attempting to load 
> the same class at the same time.
>
> I'll have to make sure that all classes are loaded before the security 
> manager becomes the system security manager, either that or eliminate 
> the AccessControlContext check permission cache.
>
> While the standard java security manager and policy provider consume 
> around 10% cpu, this consumes less than 1%.
>
> On 6/02/2016 9:57 PM, David Holmes wrote:
>> On 6/02/2016 9:39 PM, Peter Firmstone wrote:
>>> Hmm, thought the new parallel lock stategy in ClassLoader wasn't
>>> deadlock prone?  Guess I was wrong.
>>
>> The deadlock is introduced by a custom security manager. SM's play a 
>> critical role in many parts of the core libraries so if they utilize 
>> synchronization then they can easily introduce deadlock.
>>
>>> Observation: On an unrelated occassion, I had a URLClassLoader
>>> synchronization hotspot (well not standard URLClassLoader, but a high
>>> performance RFC3986 URL ClassLoader, that use normalized RFC3986 URI
>>> instead of URL DNS lookup), I solved that problem by thread confining
>>> class loading.  I've never experienced deadlock using thread
>>> confinement, initially I was worried that there would be
>>> interdependencies, however I didn't experience a problem, as the single
>>> thread would always load the classes it needed.
>>>
>>> I'm wondering if multiple locks for ClassLoader's might be the wrong
>>> strategy, I found thread confinement was very performant.
>>
>> Are you suggesting that a class-load request is actually transmitted 
>> to a single class-loading thread, while the initial thread blocks 
>> until the loading is complete? That would still seem prone to the 
>> same SM related deadlock scenario. And it would not generally be 
>> particularly performant.
>
> I thought that too, until I tried it.
>
> Would you like to see some performance figures?
>
> Cheers,
>
> Peter.
>
>>
>> David
>>
>>> Regards,
>>>
>>> Peter.
>>>
>>> 2016-02-06 21:06:07
>>> Full thread dump Java HotSpot(TM) Client VM (25.0-b70 mixed mode):
>>>
>>> "Service Thread" #9 daemon prio=9 os_prio=0 tid=0x14387400 nid=0xc54
>>> runnable [0x00000000]
>>>     java.lang.Thread.State: RUNNABLE
>>>
>>> "C1 CompilerThread0" #8 daemon prio=9 os_prio=2 tid=0x14332c00
>>> nid=0x111c waiting on condition [0x00000000]
>>>     java.lang.Thread.State: RUNNABLE
>>>
>>> "Attach Listener" #7 daemon prio=5 os_prio=2 tid=0x14331c00 nid=0x13d8
>>> waiting on condition [0x00000000]
>>>     java.lang.Thread.State: RUNNABLE
>>>
>>> "Signal Dispatcher" #6 daemon prio=9 os_prio=2 tid=0x14331400 
>>> nid=0x10b8
>>> runnable [0x00000000]
>>>     java.lang.Thread.State: RUNNABLE
>>>
>>> "Thread-1" #5 prio=10 os_prio=2 tid=0x14318800 nid=0x4a8 waiting for
>>> monitor entry [0x03ded000]
>>>     java.lang.Thread.State: BLOCKED (on object monitor)
>>>          at
>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)
>>>          at
>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>
>>>          at
>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)
>>>          at
>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>
>>>
>>>          at
>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>
>>>
>>>          at
>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>
>>>
>>>          at
>>> java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447)
>>>          at
>>> java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158) 
>>>
>>>
>>>          at
>>> java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137) 
>>>
>>>          at
>>> java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526) 
>>>
>>>
>>>          at
>>> java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266) 
>>>
>>>
>>>          at
>>> java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070) 
>>>
>>>          at
>>> java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535) 
>>>
>>>
>>>          at 
>>> java.lang.ClassLoader.getClassLoadingLock(ClassLoader.java:463)
>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
>>>          - locked <0x03f624b8> (a java.lang.Object)
>>>          at 
>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>          at
>>> org.cliffc.high_scale_lib.NonBlockingHashMap$SnapshotK.<init>(NonBlockingHashMap.java:1167) 
>>>
>>>
>>>          at
>>> org.cliffc.high_scale_lib.NonBlockingHashMap$2.iterator(NonBlockingHashMap.java:1200) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceProcessor$EnqueGarbageTask.run(ReferenceProcessor.java:166) 
>>>
>>>
>>>          - locked <0x03ef8b30> (a
>>> org.cliffc.high_scale_lib.NonBlockingHashMap)
>>>          at
>>> java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
>>>          at
>>> java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
>>>          at
>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.j 
>>>
>>>
>>> ava:180)
>>>          at
>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294 
>>>
>>>
>>> )
>>>          at
>>> java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) 
>>>
>>>
>>>          at
>>> java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) 
>>>
>>>
>>>          at java.lang.Thread.run(Thread.java:744)
>>>
>>> "Finalizer" #3 daemon prio=8 os_prio=1 tid=0x14277800 nid=0x15cc in
>>> Object.wait() [0x03cff000]
>>>     java.lang.Thread.State: WAITING (on object monitor)
>>>          at java.lang.Object.wait(Native Method)
>>>          - waiting on <0x03e056d8> (a 
>>> java.lang.ref.ReferenceQueue$Lock)
>>>          at 
>>> java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:142)
>>>          - locked <0x03e056d8> (a java.lang.ref.ReferenceQueue$Lock)
>>>          at 
>>> java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:158)
>>>          at 
>>> java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)
>>>
>>> "Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x14271c00
>>> nid=0x1398 in Object.wait() [0x144cf000]
>>>     java.lang.Thread.State: WAITING (on object monitor)
>>>          at java.lang.Object.wait(Native Method)
>>>          - waiting on <0x03e05200> (a java.lang.ref.Reference$Lock)
>>>          at java.lang.Object.wait(Object.java:502)
>>>          at
>>> java.lang.ref.Reference$ReferenceHandler.run(Reference.java:157)
>>>          - locked <0x03e05200> (a java.lang.ref.Reference$Lock)
>>>
>>> "main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for 
>>> monitor
>>> entry [0x0185e000]
>>>     java.lang.Thread.State: BLOCKED (on object monitor)
>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>>          - waiting to lock <0x03f624b8> (a java.lang.Object)
>>>          at 
>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>          at
>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)
>>>          at
>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>
>>>          at
>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)
>>>          at
>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>
>>>
>>>          at
>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>
>>>
>>>          at
>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>
>>>
>>>          at java.lang.System.checkIO(System.java:253)
>>>          at java.lang.System.setErr(System.java:199)
>>>          at 
>>> org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>>
>>> "VM Thread" os_prio=2 tid=0x1426e400 nid=0x16a8 runnable
>>>
>>> "VM Periodic Task Thread" os_prio=2 tid=0x14388400 nid=0x17a8 
>>> waiting on
>>> condition
>>>
>>> JNI global references: 19
>>>
>>>
>>> Found one Java-level deadlock:
>>> =============================
>>> "Thread-1":
>>>    waiting to lock monitor 0x142766ac (object 0x040ebee8, a [I),
>>>    which is held by "main"
>>> "main":
>>>    waiting to lock monitor 0x14274a3c (object 0x03f624b8, a
>>> java.lang.Object),
>>>    which is held by "Thread-1"
>>>
>>> Java stack information for the threads listed above:
>>> ===================================================
>>> "Thread-1":
>>>          at
>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)
>>>          at
>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>
>>>          at
>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)
>>>          at
>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>
>>>
>>>          at
>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>
>>>
>>>          at
>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>
>>>
>>>          at
>>> java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447)
>>>          at
>>> java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158) 
>>>
>>>
>>>          at
>>> java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137) 
>>>
>>>          at
>>> java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526) 
>>>
>>>
>>>          at
>>> java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266) 
>>>
>>>
>>>          at
>>> java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070) 
>>>
>>>          at
>>> java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535) 
>>>
>>>
>>>          at 
>>> java.lang.ClassLoader.getClassLoadingLock(ClassLoader.java:463)
>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
>>>          - locked <0x03f624b8> (a java.lang.Object)
>>>          at 
>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>          at
>>> org.cliffc.high_scale_lib.NonBlockingHashMap$SnapshotK.<init>(NonBlockingHashMap.java:1167) 
>>>
>>>
>>>          at
>>> org.cliffc.high_scale_lib.NonBlockingHashMap$2.iterator(NonBlockingHashMap.java:1200) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceProcessor$EnqueGarbageTask.run(ReferenceProcessor.java:166) 
>>>
>>>
>>>          - locked <0x03ef8b30> (a
>>> org.cliffc.high_scale_lib.NonBlockingHashMap)
>>>          at
>>> java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
>>>          at
>>> java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
>>>          at
>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.j 
>>>
>>>
>>> ava:180)
>>>          at
>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294 
>>>
>>>
>>> )
>>>          at
>>> java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) 
>>>
>>>
>>>          at
>>> java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) 
>>>
>>>
>>>          at java.lang.Thread.run(Thread.java:744)
>>> "main":
>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>>          - waiting to lock <0x03f624b8> (a java.lang.Object)
>>>          at 
>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>          at
>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)
>>>          at
>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>
>>>          at
>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>
>>>
>>>          at
>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)
>>>          at
>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>
>>>
>>>          at
>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>
>>>
>>>          at
>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>
>>>
>>>          at java.lang.System.checkIO(System.java:253)
>>>          at java.lang.System.setErr(System.java:199)
>>>          at 
>>> org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>>
>>> Found 1 deadlock.
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160206/2310a407/attachment-0001.html>

From dl at cs.oswego.edu  Sat Feb  6 15:43:45 2016
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 6 Feb 2016 15:43:45 -0500
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
Message-ID: <56B65B01.7050508@cs.oswego.edu>

On 02/06/2016 05:21 AM, Viktor Klang wrote:
> What happens if you supply it with a thread factory which only allows a single
> thread to be alive at a time, and returns null if it already has returned a
> still living thread?
>

Yes, this will work if you are positive that only one thread
is required for liveness. FJ sometimes conservatively creates
threads when it cannot itself guarantee liveness (for example,
when GC or other system load causes stalls). But it will
respond to null factory returns by rechecking, not failing.
unless a thread really is needed to maintain liveness, in which
case the program may livelock. To reduce transient near-livelock,
you might want to place a Thread.yield() call before the
"return null" in the factory.

-Doug


> --
> Cheers,
> ?
>
> On Feb 6, 2016 05:19, "cowwoc" <cowwoc at bbs.darktech.org
> <mailto:cowwoc at bbs.darktech.org>> wrote:
>
>     Hi,
>
>     Is this the correct mailing list for discussing ForkJoinPool in JDK9? If
>     not, please point me to the right place.
>
>     I have a feature request for ForkJoinPool which doesn't seem to be possible
>     to implement without a JDK change: http://stackoverflow.com/q/34012134/14731
>
>     Specifically, I need to be able to an application that uses Random and
>     ForkJoinPool in a deterministic manner when debugging/profiling but run
>     full-speed in normal execution mode. I have all the moving parts nailing
>     down except for ForkJoinPool.
>
>     If I create ForkJoinPool with a parallelism of 1, sometimes I see two worker
>     threads getting used. I am guessing that this is caused by
>     ForkJoinTask.get() invoking ForkJoinPool.common.externalHelpComplete(), but
>     maybe something else is going on.
>
>     Is there a way for me to guarantee that ForkJoinThread will use exactly 1
>     worker thread, no less, no more? Would you like me to file a formal feature
>     request?
>
>     Thank you,
>     Gili
>
>
>
>     --
>     View this message in context:
>     http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>     Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>




From dl at cs.oswego.edu  Sat Feb  6 15:54:38 2016
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 6 Feb 2016 15:54:38 -0500
Subject: [concurrency-interest] ConcurrentHashMap entrySet Iterator
 remove issue?
In-Reply-To: <CA+kOe0-6h=1JfPLci9zfM-4RPy2nyRMECXVFif3ihdqpDep9xQ@mail.gmail.com>
References: <fd602129dc74650b895192a24c97c3b1@sonic.net>
	<CAHzJPEp8dJqWf_S7V6nTr=Oqc9AUDcQzrQqKK6_4xnXM=b_zhA@mail.gmail.com>
	<CAHzJPEoBL62KOfMaeP+zJsjyREnF85vzNYqoFasnF2fVf3xGPg@mail.gmail.com>
	<CAHzJPEoSjp2n5r-GHndyFQsOMPvLxmUyNFCx6kgvw7ejHxBOEw@mail.gmail.com>
	<CA+kOe0-6h=1JfPLci9zfM-4RPy2nyRMECXVFif3ihdqpDep9xQ@mail.gmail.com>
Message-ID: <56B65D8E.9020100@cs.oswego.edu>

On 02/05/2016 09:05 PM, Martin Buchholz wrote:
> It's not entirely clear whether entrySet().iterator().remove() should
> remove the entry for the current key or only if still mapped to the
> old value.  But acting like the latter seems better for users - I
> agree with Mike.  The existence of map.remove(K, V) gives an
> expectation that iterator().remove() works likewise.

As others have mentioned, iterator.remove is underspecified, so
either behavior is allowed. In general it is a bad idea to use
it in a concurrent program if you care about outcome -- instead use
the version of map.remove that you need/want.

> The counter-arguments against switching now are:
> - it is a small added implementation burden for the iterator to keep
> track of the old value, that will almost never be used.
> - users can just call remove(K, V) - they have the old v in hand, that
> the map has already forgotten.
> - status quo wins whenever there's doubt!
>
> But the behavior should be documented.

Or perhaps the uncertainty of effect should be documented in
the ConcurrentMap interface, since the issue occurs with
all ConcurrentMaps?

-Doug



From jini at zeus.net.au  Sat Feb  6 16:32:58 2016
From: jini at zeus.net.au (Peter)
Date: Sun, 07 Feb 2016 07:32:58 +1000
Subject: [concurrency-interest] ClassLoader deadlock
In-Reply-To: <56B63B11.20903@gmail.com>
References: <56B5DB78.1070502@zeus.net.au>
	<56B5DF8C.5010201@oracle.com>	<56B5E446.9020205@zeus.net.au>
	<56B63B11.20903@gmail.com>
Message-ID: <56B6668A.3030106@zeus.net.au>

The 0x040ebee8 monitor is most likely being held by native code.

Regards,

Peter Firmstone.


On 7/02/2016 4:27 AM, Peter Levart wrote:
>
>
> On 02/06/2016 01:17 PM, Peter Firmstone wrote:
>> The security manager is non blocking, unfortunately java system 
>> classes aren't.
>
> It doesn't seem so. At least, I can't find where main thread locks the 
> 0x040ebee8 monitor:
>
> "Thread-1":
>   waiting to lock monitor 0x142766ac (object 0x040ebee8, a [I),
>   which is held by "main"
>
>
> "main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for 
> monitor entry [0x0185e000]
>    java.lang.Thread.State: BLOCKED (on object monitor)
>         at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>         - waiting to lock <0x03f624b8> (a java.lang.Object)
>         at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>         at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>         at 
> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124)
>         at 
> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)
>         at 
> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44)
>         at 
> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57)
>         at 
> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64)
>         at 
> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128)
>         at 
> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44)
>         at 
> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)
>         at 
> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68)
>         at 
> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261)
>         at 
> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202)
>         at java.lang.System.checkIO(System.java:253)
>         at java.lang.System.setErr(System.java:199)
>         at 
> org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>
>
> ...no mention of 0x040ebee8 in main thread...?!
>
> Peter
>
>>
>> The policy provider in use thread confines PermissionCollection 
>> instances, which never leave the cpu cache, they are discarded 
>> immediately after use.
>>
>> The problem here is that two different threads are attempting to load 
>> the same class at the same time.
>>
>> I'll have to make sure that all classes are loaded before the 
>> security manager becomes the system security manager, either that or 
>> eliminate the AccessControlContext check permission cache.
>>
>> While the standard java security manager and policy provider consume 
>> around 10% cpu, this consumes less than 1%.
>>
>> On 6/02/2016 9:57 PM, David Holmes wrote:
>>> On 6/02/2016 9:39 PM, Peter Firmstone wrote:
>>>> Hmm, thought the new parallel lock stategy in ClassLoader wasn't
>>>> deadlock prone?  Guess I was wrong.
>>>
>>> The deadlock is introduced by a custom security manager. SM's play a 
>>> critical role in many parts of the core libraries so if they utilize 
>>> synchronization then they can easily introduce deadlock.
>>>
>>>> Observation:  On an unrelated occassion, I had a URLClassLoader
>>>> synchronization hotspot (well not standard URLClassLoader, but a high
>>>> performance RFC3986 URL ClassLoader, that use normalized RFC3986 URI
>>>> instead of URL DNS lookup), I solved that problem by thread confining
>>>> class loading.  I've never experienced deadlock using thread
>>>> confinement, initially I was worried that there would be
>>>> interdependencies, however I didn't experience a problem, as the 
>>>> single
>>>> thread would always load the classes it needed.
>>>>
>>>> I'm wondering if multiple locks for ClassLoader's might be the wrong
>>>> strategy, I found thread confinement was very performant.
>>>
>>> Are you suggesting that a class-load request is actually transmitted 
>>> to a single class-loading thread, while the initial thread blocks 
>>> until the loading is complete? That would still seem prone to the 
>>> same SM related deadlock scenario. And it would not generally be 
>>> particularly performant.
>>
>> I thought that too, until I tried it.
>>
>> Would you like to see some performance figures?
>>
>> Cheers,
>>
>> Peter.
>>
>>>
>>> David
>>>
>>>> Regards,
>>>>
>>>> Peter.
>>>>
>>>> 2016-02-06 21:06:07
>>>> Full thread dump Java HotSpot(TM) Client VM (25.0-b70 mixed mode):
>>>>
>>>> "Service Thread" #9 daemon prio=9 os_prio=0 tid=0x14387400 nid=0xc54
>>>> runnable [0x00000000]
>>>>     java.lang.Thread.State: RUNNABLE
>>>>
>>>> "C1 CompilerThread0" #8 daemon prio=9 os_prio=2 tid=0x14332c00
>>>> nid=0x111c waiting on condition [0x00000000]
>>>>     java.lang.Thread.State: RUNNABLE
>>>>
>>>> "Attach Listener" #7 daemon prio=5 os_prio=2 tid=0x14331c00 nid=0x13d8
>>>> waiting on condition [0x00000000]
>>>>     java.lang.Thread.State: RUNNABLE
>>>>
>>>> "Signal Dispatcher" #6 daemon prio=9 os_prio=2 tid=0x14331400 
>>>> nid=0x10b8
>>>> runnable [0x00000000]
>>>>     java.lang.Thread.State: RUNNABLE
>>>>
>>>> "Thread-1" #5 prio=10 os_prio=2 tid=0x14318800 nid=0x4a8 waiting for
>>>> monitor entry [0x03ded000]
>>>>     java.lang.Thread.State: BLOCKED (on object monitor)
>>>>          at
>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>
>>>>
>>>>          at
>>>> java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447) 
>>>>
>>>>          at
>>>> java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158) 
>>>>
>>>>
>>>>          at
>>>> java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137) 
>>>>
>>>>          at
>>>> java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526) 
>>>>
>>>>
>>>>          at
>>>> java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266) 
>>>>
>>>>
>>>>          at
>>>> java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070) 
>>>>
>>>>          at
>>>> java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535) 
>>>>
>>>>
>>>>          at 
>>>> java.lang.ClassLoader.getClassLoadingLock(ClassLoader.java:463)
>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
>>>>          - locked <0x03f624b8> (a java.lang.Object)
>>>>          at 
>>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>          at
>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$SnapshotK.<init>(NonBlockingHashMap.java:1167) 
>>>>
>>>>
>>>>          at
>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$2.iterator(NonBlockingHashMap.java:1200) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceProcessor$EnqueGarbageTask.run(ReferenceProcessor.java:166) 
>>>>
>>>>
>>>>          - locked <0x03ef8b30> (a
>>>> org.cliffc.high_scale_lib.NonBlockingHashMap)
>>>>          at
>>>> java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) 
>>>>
>>>>          at
>>>> java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
>>>>          at
>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.j 
>>>>
>>>>
>>>> ava:180)
>>>>          at
>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294 
>>>>
>>>>
>>>> )
>>>>          at
>>>> java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) 
>>>>
>>>>
>>>>          at
>>>> java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) 
>>>>
>>>>
>>>>          at java.lang.Thread.run(Thread.java:744)
>>>>
>>>> "Finalizer" #3 daemon prio=8 os_prio=1 tid=0x14277800 nid=0x15cc in
>>>> Object.wait() [0x03cff000]
>>>>     java.lang.Thread.State: WAITING (on object monitor)
>>>>          at java.lang.Object.wait(Native Method)
>>>>          - waiting on <0x03e056d8> (a 
>>>> java.lang.ref.ReferenceQueue$Lock)
>>>>          at 
>>>> java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:142)
>>>>          - locked <0x03e056d8> (a java.lang.ref.ReferenceQueue$Lock)
>>>>          at 
>>>> java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:158)
>>>>          at 
>>>> java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)
>>>>
>>>> "Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x14271c00
>>>> nid=0x1398 in Object.wait() [0x144cf000]
>>>>     java.lang.Thread.State: WAITING (on object monitor)
>>>>          at java.lang.Object.wait(Native Method)
>>>>          - waiting on <0x03e05200> (a java.lang.ref.Reference$Lock)
>>>>          at java.lang.Object.wait(Object.java:502)
>>>>          at
>>>> java.lang.ref.Reference$ReferenceHandler.run(Reference.java:157)
>>>>          - locked <0x03e05200> (a java.lang.ref.Reference$Lock)
>>>>
>>>> "main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for 
>>>> monitor
>>>> entry [0x0185e000]
>>>>     java.lang.Thread.State: BLOCKED (on object monitor)
>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>>>          - waiting to lock <0x03f624b8> (a java.lang.Object)
>>>>          at 
>>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>          at
>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>
>>>>
>>>>          at java.lang.System.checkIO(System.java:253)
>>>>          at java.lang.System.setErr(System.java:199)
>>>>          at 
>>>> org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>>>
>>>> "VM Thread" os_prio=2 tid=0x1426e400 nid=0x16a8 runnable
>>>>
>>>> "VM Periodic Task Thread" os_prio=2 tid=0x14388400 nid=0x17a8 
>>>> waiting on
>>>> condition
>>>>
>>>> JNI global references: 19
>>>>
>>>>
>>>> Found one Java-level deadlock:
>>>> =============================
>>>> "Thread-1":
>>>>    waiting to lock monitor 0x142766ac (object 0x040ebee8, a [I),
>>>>    which is held by "main"
>>>> "main":
>>>>    waiting to lock monitor 0x14274a3c (object 0x03f624b8, a
>>>> java.lang.Object),
>>>>    which is held by "Thread-1"
>>>>
>>>> Java stack information for the threads listed above:
>>>> ===================================================
>>>> "Thread-1":
>>>>          at
>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>
>>>>
>>>>          at
>>>> java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447) 
>>>>
>>>>          at
>>>> java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158) 
>>>>
>>>>
>>>>          at
>>>> java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137) 
>>>>
>>>>          at
>>>> java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526) 
>>>>
>>>>
>>>>          at
>>>> java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266) 
>>>>
>>>>
>>>>          at
>>>> java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070) 
>>>>
>>>>          at
>>>> java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535) 
>>>>
>>>>
>>>>          at 
>>>> java.lang.ClassLoader.getClassLoadingLock(ClassLoader.java:463)
>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
>>>>          - locked <0x03f624b8> (a java.lang.Object)
>>>>          at 
>>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>          at
>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$SnapshotK.<init>(NonBlockingHashMap.java:1167) 
>>>>
>>>>
>>>>          at
>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$2.iterator(NonBlockingHashMap.java:1200) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceProcessor$EnqueGarbageTask.run(ReferenceProcessor.java:166) 
>>>>
>>>>
>>>>          - locked <0x03ef8b30> (a
>>>> org.cliffc.high_scale_lib.NonBlockingHashMap)
>>>>          at
>>>> java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) 
>>>>
>>>>          at
>>>> java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
>>>>          at
>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.j 
>>>>
>>>>
>>>> ava:180)
>>>>          at
>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294 
>>>>
>>>>
>>>> )
>>>>          at
>>>> java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) 
>>>>
>>>>
>>>>          at
>>>> java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) 
>>>>
>>>>
>>>>          at java.lang.Thread.run(Thread.java:744)
>>>> "main":
>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>>>          - waiting to lock <0x03f624b8> (a java.lang.Object)
>>>>          at 
>>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>          at
>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>
>>>>          at
>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>
>>>>
>>>>          at
>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>
>>>>
>>>>          at java.lang.System.checkIO(System.java:253)
>>>>          at java.lang.System.setErr(System.java:199)
>>>>          at 
>>>> org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>>>
>>>> Found 1 deadlock.
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From cowwoc at bbs.darktech.org  Sat Feb  6 20:43:58 2016
From: cowwoc at bbs.darktech.org (cowwoc)
Date: Sat, 6 Feb 2016 18:43:58 -0700 (MST)
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56B65B01.7050508@cs.oswego.edu>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B65B01.7050508@cs.oswego.edu>
Message-ID: <56B6AD84.1000405@bbs.darktech.org>

Thanks Doug, I'll give this a try.

Thanks,
Gili

On 2016-02-06 3:02 PM, Doug Lea [via JSR166 Concurrency] wrote:
> On 02/06/2016 05:21 AM, Viktor Klang wrote:
> > What happens if you supply it with a thread factory which only 
> allows a single
> > thread to be alive at a time, and returns null if it already has 
> returned a
> > still living thread?
> >
>
> Yes, this will work if you are positive that only one thread
> is required for liveness. FJ sometimes conservatively creates
> threads when it cannot itself guarantee liveness (for example,
> when GC or other system load causes stalls). But it will
> respond to null factory returns by rechecking, not failing.
> unless a thread really is needed to maintain liveness, in which
> case the program may livelock. To reduce transient near-livelock,
> you might want to place a Thread.yield() call before the
> "return null" in the factory.
>
> -Doug
>
>
> > --
> > Cheers,
> > ?
> >
> > On Feb 6, 2016 05:19, "cowwoc" <[hidden email] 
> </user/SendEmail.jtp?type=node&node=13243&i=0>
> > <mailto:[hidden email] 
> </user/SendEmail.jtp?type=node&node=13243&i=1>>> wrote:
> >
> >     Hi,
> >
> >     Is this the correct mailing list for discussing ForkJoinPool in 
> JDK9? If
> >     not, please point me to the right place.
> >
> >     I have a feature request for ForkJoinPool which doesn't seem to 
> be possible
> >     to implement without a JDK change: 
> http://stackoverflow.com/q/34012134/14731
> >
> >     Specifically, I need to be able to an application that uses 
> Random and
> >     ForkJoinPool in a deterministic manner when debugging/profiling 
> but run
> >     full-speed in normal execution mode. I have all the moving parts 
> nailing
> >     down except for ForkJoinPool.
> >
> >     If I create ForkJoinPool with a parallelism of 1, sometimes I 
> see two worker
> >     threads getting used. I am guessing that this is caused by
> >     ForkJoinTask.get() invoking 
> ForkJoinPool.common.externalHelpComplete(), but
> >     maybe something else is going on.
> >
> >     Is there a way for me to guarantee that ForkJoinThread will use 
> exactly 1
> >     worker thread, no less, no more? Would you like me to file a 
> formal feature
> >     request?
> >
> >     Thank you,
> >     Gili
> >
> >
> >
> >     --
> >     View this message in context:
> > 
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
> >     Sent from the JSR166 Concurrency mailing list archive at 
> Nabble.com.
> >     _______________________________________________
> >     Concurrency-interest mailing list
> > [hidden email] </user/SendEmail.jtp?type=node&node=13243&i=2> 
> <mailto:[hidden email] </user/SendEmail.jtp?type=node&node=13243&i=3>>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > [hidden email] </user/SendEmail.jtp?type=node&node=13243&i=4>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> [hidden email] </user/SendEmail.jtp?type=node&node=13243&i=5>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------------------------------------------------
> If you reply to this email, your message will be added to the 
> discussion below:
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13243.html 
>
> To unsubscribe from Single-threaded ForkJoinPool, click here 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=unsubscribe_by_code&node=13232&code=Y293d29jQGJicy5kYXJrdGVjaC5vcmd8MTMyMzJ8MTU3NDMyMTI0Nw==>.
> NAML 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13246.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160206/51853a94/attachment-0001.html>

From peter.levart at gmail.com  Sun Feb  7 03:37:16 2016
From: peter.levart at gmail.com (Peter Levart)
Date: Sun, 7 Feb 2016 09:37:16 +0100
Subject: [concurrency-interest] ClassLoader deadlock
In-Reply-To: <56B6668A.3030106@zeus.net.au>
References: <56B5DB78.1070502@zeus.net.au> <56B5DF8C.5010201@oracle.com>
	<56B5E446.9020205@zeus.net.au> <56B63B11.20903@gmail.com>
	<56B6668A.3030106@zeus.net.au>
Message-ID: <56B7023C.5030708@gmail.com>



On 02/06/2016 10:32 PM, Peter wrote:
> The 0x040ebee8 monitor is most likely being held by native code.
>
> Regards,
>
> Peter Firmstone.

Ok, but where? The deadlock report says it is held by main thread. 
Somewhere between the following two java frames?

"main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for monitor 
entry [0x0185e000]
...
...
         at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
--here--
         at 
org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124)


As I understand this is where JVM resolves some class that for the 1st 
time while ReferenceCollection.iterator is being executed. So before 
calling-back into ClassLoader.loadClass, it acquires a monitor lock on 
some int[] object?


Anyway. Looking at the following part of Thread-1 stacktrace:

         at 
org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202)
         at 
java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447)
         at 
java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158)
         at 
java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137)
         at 
java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526)
         at 
java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266)
         at 
java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070)
         at 
java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535)

...I can see you are using some early release of JDK 8 where 
ThreadLocalRandom initialization involved obtaining a hardware address 
of some interface. This in turn checks for security manager. Since JDK 
8u45 this code has been removed and only current time is used to derive 
initial seed, so you might not see this deadlock any more with JDK 8u45 
and later.

Regards, Peter

>
>
> On 7/02/2016 4:27 AM, Peter Levart wrote:
>>
>>
>> On 02/06/2016 01:17 PM, Peter Firmstone wrote:
>>> The security manager is non blocking, unfortunately java system 
>>> classes aren't.
>>
>> It doesn't seem so. At least, I can't find where main thread locks 
>> the 0x040ebee8 monitor:
>>
>> "Thread-1":
>>   waiting to lock monitor 0x142766ac (object 0x040ebee8, a [I),
>>   which is held by "main"
>>
>>
>> "main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for 
>> monitor entry [0x0185e000]
>>    java.lang.Thread.State: BLOCKED (on object monitor)
>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>         - waiting to lock <0x03f624b8> (a java.lang.Object)
>>         at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>         at 
>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124)
>>         at 
>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)
>>         at 
>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44)
>>         at 
>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57)
>>         at 
>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64)
>>         at 
>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128)
>>         at 
>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44)
>>         at 
>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)
>>         at 
>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68)
>>         at 
>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261)
>>         at 
>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202)
>>         at java.lang.System.checkIO(System.java:253)
>>         at java.lang.System.setErr(System.java:199)
>>         at 
>> org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>
>>
>> ...no mention of 0x040ebee8 in main thread...?!
>>
>> Peter
>>
>>>
>>> The policy provider in use thread confines PermissionCollection 
>>> instances, which never leave the cpu cache, they are discarded 
>>> immediately after use.
>>>
>>> The problem here is that two different threads are attempting to 
>>> load the same class at the same time.
>>>
>>> I'll have to make sure that all classes are loaded before the 
>>> security manager becomes the system security manager, either that or 
>>> eliminate the AccessControlContext check permission cache.
>>>
>>> While the standard java security manager and policy provider consume 
>>> around 10% cpu, this consumes less than 1%.
>>>
>>> On 6/02/2016 9:57 PM, David Holmes wrote:
>>>> On 6/02/2016 9:39 PM, Peter Firmstone wrote:
>>>>> Hmm, thought the new parallel lock stategy in ClassLoader wasn't
>>>>> deadlock prone?  Guess I was wrong.
>>>>
>>>> The deadlock is introduced by a custom security manager. SM's play 
>>>> a critical role in many parts of the core libraries so if they 
>>>> utilize synchronization then they can easily introduce deadlock.
>>>>
>>>>> Observation: On an unrelated occassion, I had a URLClassLoader
>>>>> synchronization hotspot (well not standard URLClassLoader, but a high
>>>>> performance RFC3986 URL ClassLoader, that use normalized RFC3986 URI
>>>>> instead of URL DNS lookup), I solved that problem by thread confining
>>>>> class loading.  I've never experienced deadlock using thread
>>>>> confinement, initially I was worried that there would be
>>>>> interdependencies, however I didn't experience a problem, as the 
>>>>> single
>>>>> thread would always load the classes it needed.
>>>>>
>>>>> I'm wondering if multiple locks for ClassLoader's might be the wrong
>>>>> strategy, I found thread confinement was very performant.
>>>>
>>>> Are you suggesting that a class-load request is actually 
>>>> transmitted to a single class-loading thread, while the initial 
>>>> thread blocks until the loading is complete? That would still seem 
>>>> prone to the same SM related deadlock scenario. And it would not 
>>>> generally be particularly performant.
>>>
>>> I thought that too, until I tried it.
>>>
>>> Would you like to see some performance figures?
>>>
>>> Cheers,
>>>
>>> Peter.
>>>
>>>>
>>>> David
>>>>
>>>>> Regards,
>>>>>
>>>>> Peter.
>>>>>
>>>>> 2016-02-06 21:06:07
>>>>> Full thread dump Java HotSpot(TM) Client VM (25.0-b70 mixed mode):
>>>>>
>>>>> "Service Thread" #9 daemon prio=9 os_prio=0 tid=0x14387400 nid=0xc54
>>>>> runnable [0x00000000]
>>>>>     java.lang.Thread.State: RUNNABLE
>>>>>
>>>>> "C1 CompilerThread0" #8 daemon prio=9 os_prio=2 tid=0x14332c00
>>>>> nid=0x111c waiting on condition [0x00000000]
>>>>>     java.lang.Thread.State: RUNNABLE
>>>>>
>>>>> "Attach Listener" #7 daemon prio=5 os_prio=2 tid=0x14331c00 
>>>>> nid=0x13d8
>>>>> waiting on condition [0x00000000]
>>>>>     java.lang.Thread.State: RUNNABLE
>>>>>
>>>>> "Signal Dispatcher" #6 daemon prio=9 os_prio=2 tid=0x14331400 
>>>>> nid=0x10b8
>>>>> runnable [0x00000000]
>>>>>     java.lang.Thread.State: RUNNABLE
>>>>>
>>>>> "Thread-1" #5 prio=10 os_prio=2 tid=0x14318800 nid=0x4a8 waiting for
>>>>> monitor entry [0x03ded000]
>>>>>     java.lang.Thread.State: BLOCKED (on object monitor)
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>>
>>>>>
>>>>>          at
>>>>> java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447) 
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158) 
>>>>>
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137) 
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526) 
>>>>>
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266) 
>>>>>
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070) 
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535) 
>>>>>
>>>>>
>>>>>          at 
>>>>> java.lang.ClassLoader.getClassLoadingLock(ClassLoader.java:463)
>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
>>>>>          - locked <0x03f624b8> (a java.lang.Object)
>>>>>          at 
>>>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>>          at
>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$SnapshotK.<init>(NonBlockingHashMap.java:1167) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$2.iterator(NonBlockingHashMap.java:1200) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceProcessor$EnqueGarbageTask.run(ReferenceProcessor.java:166) 
>>>>>
>>>>>
>>>>>          - locked <0x03ef8b30> (a
>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap)
>>>>>          at
>>>>> java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) 
>>>>>
>>>>>          at
>>>>> java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
>>>>>          at
>>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.j 
>>>>>
>>>>>
>>>>> ava:180)
>>>>>          at
>>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294 
>>>>>
>>>>>
>>>>> )
>>>>>          at
>>>>> java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) 
>>>>>
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) 
>>>>>
>>>>>
>>>>>          at java.lang.Thread.run(Thread.java:744)
>>>>>
>>>>> "Finalizer" #3 daemon prio=8 os_prio=1 tid=0x14277800 nid=0x15cc in
>>>>> Object.wait() [0x03cff000]
>>>>>     java.lang.Thread.State: WAITING (on object monitor)
>>>>>          at java.lang.Object.wait(Native Method)
>>>>>          - waiting on <0x03e056d8> (a 
>>>>> java.lang.ref.ReferenceQueue$Lock)
>>>>>          at 
>>>>> java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:142)
>>>>>          - locked <0x03e056d8> (a java.lang.ref.ReferenceQueue$Lock)
>>>>>          at 
>>>>> java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:158)
>>>>>          at 
>>>>> java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)
>>>>>
>>>>> "Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x14271c00
>>>>> nid=0x1398 in Object.wait() [0x144cf000]
>>>>>     java.lang.Thread.State: WAITING (on object monitor)
>>>>>          at java.lang.Object.wait(Native Method)
>>>>>          - waiting on <0x03e05200> (a java.lang.ref.Reference$Lock)
>>>>>          at java.lang.Object.wait(Object.java:502)
>>>>>          at
>>>>> java.lang.ref.Reference$ReferenceHandler.run(Reference.java:157)
>>>>>          - locked <0x03e05200> (a java.lang.ref.Reference$Lock)
>>>>>
>>>>> "main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for 
>>>>> monitor
>>>>> entry [0x0185e000]
>>>>>     java.lang.Thread.State: BLOCKED (on object monitor)
>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>>>>          - waiting to lock <0x03f624b8> (a java.lang.Object)
>>>>>          at 
>>>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>>
>>>>>
>>>>>          at java.lang.System.checkIO(System.java:253)
>>>>>          at java.lang.System.setErr(System.java:199)
>>>>>          at 
>>>>> org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>>>>
>>>>> "VM Thread" os_prio=2 tid=0x1426e400 nid=0x16a8 runnable
>>>>>
>>>>> "VM Periodic Task Thread" os_prio=2 tid=0x14388400 nid=0x17a8 
>>>>> waiting on
>>>>> condition
>>>>>
>>>>> JNI global references: 19
>>>>>
>>>>>
>>>>> Found one Java-level deadlock:
>>>>> =============================
>>>>> "Thread-1":
>>>>>    waiting to lock monitor 0x142766ac (object 0x040ebee8, a [I),
>>>>>    which is held by "main"
>>>>> "main":
>>>>>    waiting to lock monitor 0x14274a3c (object 0x03f624b8, a
>>>>> java.lang.Object),
>>>>>    which is held by "Thread-1"
>>>>>
>>>>> Java stack information for the threads listed above:
>>>>> ===================================================
>>>>> "Thread-1":
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>>
>>>>>
>>>>>          at
>>>>> java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447) 
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158) 
>>>>>
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137) 
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526) 
>>>>>
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266) 
>>>>>
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070) 
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535) 
>>>>>
>>>>>
>>>>>          at 
>>>>> java.lang.ClassLoader.getClassLoadingLock(ClassLoader.java:463)
>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
>>>>>          - locked <0x03f624b8> (a java.lang.Object)
>>>>>          at 
>>>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>>          at
>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$SnapshotK.<init>(NonBlockingHashMap.java:1167) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$2.iterator(NonBlockingHashMap.java:1200) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceProcessor$EnqueGarbageTask.run(ReferenceProcessor.java:166) 
>>>>>
>>>>>
>>>>>          - locked <0x03ef8b30> (a
>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap)
>>>>>          at
>>>>> java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) 
>>>>>
>>>>>          at
>>>>> java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
>>>>>          at
>>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.j 
>>>>>
>>>>>
>>>>> ava:180)
>>>>>          at
>>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294 
>>>>>
>>>>>
>>>>> )
>>>>>          at
>>>>> java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) 
>>>>>
>>>>>
>>>>>          at
>>>>> java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) 
>>>>>
>>>>>
>>>>>          at java.lang.Thread.run(Thread.java:744)
>>>>> "main":
>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>>>>          - waiting to lock <0x03f624b8> (a java.lang.Object)
>>>>>          at 
>>>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>>
>>>>>          at
>>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>>
>>>>>
>>>>>          at
>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>>
>>>>>
>>>>>          at java.lang.System.checkIO(System.java:253)
>>>>>          at java.lang.System.setErr(System.java:199)
>>>>>          at 
>>>>> org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>>>>
>>>>> Found 1 deadlock.
>>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160207/7ff0dab6/attachment-0001.html>

From jini at zeus.net.au  Sun Feb  7 04:54:08 2016
From: jini at zeus.net.au (Peter)
Date: Sun, 07 Feb 2016 19:54:08 +1000
Subject: [concurrency-interest] ClassLoader deadlock
In-Reply-To: <56B7023C.5030708@gmail.com>
References: <56B5DB78.1070502@zeus.net.au> <56B5DF8C.5010201@oracle.com>
	<56B5E446.9020205@zeus.net.au> <56B63B11.20903@gmail.com>
	<56B6668A.3030106@zeus.net.au> <56B7023C.5030708@gmail.com>
Message-ID: <56B71440.5000108@zeus.net.au>

Thanks Peter & David,

That's good to know.

I've altered the SecurityManager to perform a permission check prior to 
becoming the security manager, this ensures the cache has been created, 
to avoid any recursive deadlock prone calls.

The class that both threads are attempting to load and init is called 
org.apache.river.concurrent.ReferenceIterator.

The code can be found here:

https://github.com/pfirmstone/river-internet/tree/Input-validation-for-Serialization

Cheers,

Peter.


On 7/02/2016 6:37 PM, Peter Levart wrote:
>
>
> On 02/06/2016 10:32 PM, Peter wrote:
>> The 0x040ebee8 monitor is most likely being held by native code.
>>
>> Regards,
>>
>> Peter Firmstone.
>
> Ok, but where? The deadlock report says it is held by main thread. 
> Somewhere between the following two java frames?
>
> "main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for 
> monitor entry [0x0185e000]
> ...
> ...
>         at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
> --here--
>         at 
> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124)
>
>
> As I understand this is where JVM resolves some class that for the 1st 
> time while ReferenceCollection.iterator is being executed. So before 
> calling-back into ClassLoader.loadClass, it acquires a monitor lock on 
> some int[] object?
>
>
> Anyway. Looking at the following part of Thread-1 stacktrace:
>
>         at 
> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202)
>         at 
> java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447)
>         at 
> java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158)
>         at 
> java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137)
>         at 
> java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526)
>         at 
> java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266)
>         at 
> java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070)
>         at 
> java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535)
>
> ...I can see you are using some early release of JDK 8 where 
> ThreadLocalRandom initialization involved obtaining a hardware address 
> of some interface. This in turn checks for security manager. Since JDK 
> 8u45 this code has been removed and only current time is used to 
> derive initial seed, so you might not see this deadlock any more with 
> JDK 8u45 and later.
>
> Regards, Peter
>
>>
>>
>> On 7/02/2016 4:27 AM, Peter Levart wrote:
>>>
>>>
>>> On 02/06/2016 01:17 PM, Peter Firmstone wrote:
>>>> The security manager is non blocking, unfortunately java system 
>>>> classes aren't.
>>>
>>> It doesn't seem so. At least, I can't find where main thread locks 
>>> the 0x040ebee8 monitor:
>>>
>>> "Thread-1":
>>>   waiting to lock monitor 0x142766ac (object 0x040ebee8, a [I),
>>>   which is held by "main"
>>>
>>>
>>> "main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for 
>>> monitor entry [0x0185e000]
>>>    java.lang.Thread.State: BLOCKED (on object monitor)
>>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>>         - waiting to lock <0x03f624b8> (a java.lang.Object)
>>>         at 
>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>         at 
>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124)
>>>         at 
>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)
>>>         at 
>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44)
>>>         at 
>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57)
>>>         at 
>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64)
>>>         at 
>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128)
>>>         at 
>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44)
>>>         at 
>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)
>>>         at 
>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68)
>>>         at 
>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261)
>>>         at 
>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202)
>>>         at java.lang.System.checkIO(System.java:253)
>>>         at java.lang.System.setErr(System.java:199)
>>>         at 
>>> org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>>
>>>
>>> ...no mention of 0x040ebee8 in main thread...?!
>>>
>>> Peter
>>>
>>>>
>>>> The policy provider in use thread confines PermissionCollection 
>>>> instances, which never leave the cpu cache, they are discarded 
>>>> immediately after use.
>>>>
>>>> The problem here is that two different threads are attempting to 
>>>> load the same class at the same time.
>>>>
>>>> I'll have to make sure that all classes are loaded before the 
>>>> security manager becomes the system security manager, either that 
>>>> or eliminate the AccessControlContext check permission cache.
>>>>
>>>> While the standard java security manager and policy provider 
>>>> consume around 10% cpu, this consumes less than 1%.
>>>>
>>>> On 6/02/2016 9:57 PM, David Holmes wrote:
>>>>> On 6/02/2016 9:39 PM, Peter Firmstone wrote:
>>>>>> Hmm, thought the new parallel lock stategy in ClassLoader wasn't
>>>>>> deadlock prone?  Guess I was wrong.
>>>>>
>>>>> The deadlock is introduced by a custom security manager. SM's play 
>>>>> a critical role in many parts of the core libraries so if they 
>>>>> utilize synchronization then they can easily introduce deadlock.
>>>>>
>>>>>> Observation:  On an unrelated occassion, I had a URLClassLoader
>>>>>> synchronization hotspot (well not standard URLClassLoader, but a 
>>>>>> high
>>>>>> performance RFC3986 URL ClassLoader, that use normalized RFC3986 URI
>>>>>> instead of URL DNS lookup), I solved that problem by thread 
>>>>>> confining
>>>>>> class loading.  I've never experienced deadlock using thread
>>>>>> confinement, initially I was worried that there would be
>>>>>> interdependencies, however I didn't experience a problem, as the 
>>>>>> single
>>>>>> thread would always load the classes it needed.
>>>>>>
>>>>>> I'm wondering if multiple locks for ClassLoader's might be the wrong
>>>>>> strategy, I found thread confinement was very performant.
>>>>>
>>>>> Are you suggesting that a class-load request is actually 
>>>>> transmitted to a single class-loading thread, while the initial 
>>>>> thread blocks until the loading is complete? That would still seem 
>>>>> prone to the same SM related deadlock scenario. And it would not 
>>>>> generally be particularly performant.
>>>>
>>>> I thought that too, until I tried it.
>>>>
>>>> Would you like to see some performance figures?
>>>>
>>>> Cheers,
>>>>
>>>> Peter.
>>>>
>>>>>
>>>>> David
>>>>>
>>>>>> Regards,
>>>>>>
>>>>>> Peter.
>>>>>>
>>>>>> 2016-02-06 21:06:07
>>>>>> Full thread dump Java HotSpot(TM) Client VM (25.0-b70 mixed mode):
>>>>>>
>>>>>> "Service Thread" #9 daemon prio=9 os_prio=0 tid=0x14387400 nid=0xc54
>>>>>> runnable [0x00000000]
>>>>>>     java.lang.Thread.State: RUNNABLE
>>>>>>
>>>>>> "C1 CompilerThread0" #8 daemon prio=9 os_prio=2 tid=0x14332c00
>>>>>> nid=0x111c waiting on condition [0x00000000]
>>>>>>     java.lang.Thread.State: RUNNABLE
>>>>>>
>>>>>> "Attach Listener" #7 daemon prio=5 os_prio=2 tid=0x14331c00 
>>>>>> nid=0x13d8
>>>>>> waiting on condition [0x00000000]
>>>>>>     java.lang.Thread.State: RUNNABLE
>>>>>>
>>>>>> "Signal Dispatcher" #6 daemon prio=9 os_prio=2 tid=0x14331400 
>>>>>> nid=0x10b8
>>>>>> runnable [0x00000000]
>>>>>>     java.lang.Thread.State: RUNNABLE
>>>>>>
>>>>>> "Thread-1" #5 prio=10 os_prio=2 tid=0x14318800 nid=0x4a8 waiting for
>>>>>> monitor entry [0x03ded000]
>>>>>>     java.lang.Thread.State: BLOCKED (on object monitor)
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447) 
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137) 
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070) 
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535) 
>>>>>>
>>>>>>
>>>>>>          at 
>>>>>> java.lang.ClassLoader.getClassLoadingLock(ClassLoader.java:463)
>>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
>>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
>>>>>>          - locked <0x03f624b8> (a java.lang.Object)
>>>>>>          at 
>>>>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>>>          at
>>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$SnapshotK.<init>(NonBlockingHashMap.java:1167) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$2.iterator(NonBlockingHashMap.java:1200) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceProcessor$EnqueGarbageTask.run(ReferenceProcessor.java:166) 
>>>>>>
>>>>>>
>>>>>>          - locked <0x03ef8b30> (a
>>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap)
>>>>>>          at
>>>>>> java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) 
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
>>>>>>          at
>>>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.j 
>>>>>>
>>>>>>
>>>>>> ava:180)
>>>>>>          at
>>>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294 
>>>>>>
>>>>>>
>>>>>> )
>>>>>>          at
>>>>>> java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) 
>>>>>>
>>>>>>
>>>>>>          at java.lang.Thread.run(Thread.java:744)
>>>>>>
>>>>>> "Finalizer" #3 daemon prio=8 os_prio=1 tid=0x14277800 nid=0x15cc in
>>>>>> Object.wait() [0x03cff000]
>>>>>>     java.lang.Thread.State: WAITING (on object monitor)
>>>>>>          at java.lang.Object.wait(Native Method)
>>>>>>          - waiting on <0x03e056d8> (a 
>>>>>> java.lang.ref.ReferenceQueue$Lock)
>>>>>>          at 
>>>>>> java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:142)
>>>>>>          - locked <0x03e056d8> (a java.lang.ref.ReferenceQueue$Lock)
>>>>>>          at 
>>>>>> java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:158)
>>>>>>          at 
>>>>>> java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)
>>>>>>
>>>>>> "Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x14271c00
>>>>>> nid=0x1398 in Object.wait() [0x144cf000]
>>>>>>     java.lang.Thread.State: WAITING (on object monitor)
>>>>>>          at java.lang.Object.wait(Native Method)
>>>>>>          - waiting on <0x03e05200> (a java.lang.ref.Reference$Lock)
>>>>>>          at java.lang.Object.wait(Object.java:502)
>>>>>>          at
>>>>>> java.lang.ref.Reference$ReferenceHandler.run(Reference.java:157)
>>>>>>          - locked <0x03e05200> (a java.lang.ref.Reference$Lock)
>>>>>>
>>>>>> "main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for 
>>>>>> monitor
>>>>>> entry [0x0185e000]
>>>>>>     java.lang.Thread.State: BLOCKED (on object monitor)
>>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>>>>>          - waiting to lock <0x03f624b8> (a java.lang.Object)
>>>>>>          at 
>>>>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>>>
>>>>>>
>>>>>>          at java.lang.System.checkIO(System.java:253)
>>>>>>          at java.lang.System.setErr(System.java:199)
>>>>>>          at 
>>>>>> org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>>>>>
>>>>>> "VM Thread" os_prio=2 tid=0x1426e400 nid=0x16a8 runnable
>>>>>>
>>>>>> "VM Periodic Task Thread" os_prio=2 tid=0x14388400 nid=0x17a8 
>>>>>> waiting on
>>>>>> condition
>>>>>>
>>>>>> JNI global references: 19
>>>>>>
>>>>>>
>>>>>> Found one Java-level deadlock:
>>>>>> =============================
>>>>>> "Thread-1":
>>>>>>    waiting to lock monitor 0x142766ac (object 0x040ebee8, a [I),
>>>>>>    which is held by "main"
>>>>>> "main":
>>>>>>    waiting to lock monitor 0x14274a3c (object 0x03f624b8, a
>>>>>> java.lang.Object),
>>>>>>    which is held by "Thread-1"
>>>>>>
>>>>>> Java stack information for the threads listed above:
>>>>>> ===================================================
>>>>>> "Thread-1":
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447) 
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137) 
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070) 
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535) 
>>>>>>
>>>>>>
>>>>>>          at 
>>>>>> java.lang.ClassLoader.getClassLoadingLock(ClassLoader.java:463)
>>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
>>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
>>>>>>          - locked <0x03f624b8> (a java.lang.Object)
>>>>>>          at 
>>>>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>>>          at
>>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$SnapshotK.<init>(NonBlockingHashMap.java:1167) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$2.iterator(NonBlockingHashMap.java:1200) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceProcessor$EnqueGarbageTask.run(ReferenceProcessor.java:166) 
>>>>>>
>>>>>>
>>>>>>          - locked <0x03ef8b30> (a
>>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap)
>>>>>>          at
>>>>>> java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) 
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
>>>>>>          at
>>>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.j 
>>>>>>
>>>>>>
>>>>>> ava:180)
>>>>>>          at
>>>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294 
>>>>>>
>>>>>>
>>>>>> )
>>>>>>          at
>>>>>> java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) 
>>>>>>
>>>>>>
>>>>>>          at java.lang.Thread.run(Thread.java:744)
>>>>>> "main":
>>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>>>>>          - waiting to lock <0x03f624b8> (a java.lang.Object)
>>>>>>          at 
>>>>>> sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>>>          at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>>>
>>>>>>
>>>>>>          at
>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>>>
>>>>>>
>>>>>>          at java.lang.System.checkIO(System.java:253)
>>>>>>          at java.lang.System.setErr(System.java:199)
>>>>>>          at 
>>>>>> org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>>>>>
>>>>>> Found 1 deadlock.
>>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>


From cowwoc at bbs.darktech.org  Mon Feb  8 02:13:51 2016
From: cowwoc at bbs.darktech.org (cowwoc)
Date: Mon, 8 Feb 2016 00:13:51 -0700 (MST)
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56B63503.3040509@gmail.com>
References: <1454728713539-13232.post@n7.nabble.com>
	<56B5BBB7.2000703@gmail.com> <56B5EB25.1030607@bbs.darktech.org>
	<56B63503.3040509@gmail.com>
Message-ID: <56B84C52.4080300@bbs.darktech.org>

Peter,

This is an excellent idea! Whoever came up with it was pretty clever :)

I still need to iron out some other aspects of deterministic behavior 
(e.g. making sure items are added to collections in the same order) but 
this is a huge step in the right direction. Thank you!

Gili

On 2016-02-06 12:58 PM, Peter Levart [via JSR166 Concurrency] wrote:
>
>
> On 02/06/2016 12:54 PM, cowwoc wrote:
>> Hi Peter,
>>
>> I'm not sure I understand. Won't I end up with different random 
>> numbers depending on runtime conditions?
>
> No. The initial seed for the root SplittableRandom instance will 
> determine the sequences for all its descendants.
>
> SplittableRandom r1 = new SplittableRandom(1234);
> SplittableRandom r2 = r1.split();
>
> ...is conceptually equivalent to:
>
> Random r1 = new Random(1234);
> Random r2 = new Random(r1.nextLong());
>
>
> Consider the following arrangement:
>
> Task1:
> Random r1 = new Random(1234);
> int i11 = r1.nextInt();
> int i12 = r1.nextInt();
> Random r2 = new Random(r1.nextLong());
> Random r3 = new Random(r1.nextLong());
>
> Task2:
> int i21 = r2.nextInt();
> int i22 = r2.nextInt();
>
> Task3:
> int i31 = r3.nextInt();
> int i32 = r3.nextInt();
>
> It doesn't matter when Task2 and Task3 are executed and by which 
> thread (as long as they are executed after Task1 which creates the r2 
> & r3 instances for them). Each task is using it's own private PRNG 
> instance. If you can make the algorithm within the single task 
> deterministic, the whole composition will be deterministic.
>
>
>> I mean, it sounds as if SplittableRandom is only deterministic if 
>> threads invoke split() in the same order across JVM runs. What 
>> happens if task1 runs faster than task2 in one run, but the opposite 
>> is true in another run? Won't I end up with numbers?
>
> If each task is using its own private instance of PRNG, then other 
> tasks can't have any effect on it, so it doesn't matter when or by 
> which thread they are executed.
>
> Regards, Peter
>
>>
>> Thanks,
>> Gili
>>
>> On 2016-02-06 3:43 AM, Peter Levart [via JSR166 Concurrency] wrote:
>>> Hi Gili,
>>>
>>> Have you thought of using SplittableRandom instead? Initially you 
>>> create it with a predefined seed for the root task. Whenever you 
>>> fork-off a task, you create for it a new instance by invoking 
>>> SplittableRandom.split(). This should give you deterministic 
>>> behavior regardless of how many threads you use for fork-join pool 
>>> and the dynamics of execution. For example:
>>>
>>> public class SumRandomInts extends RecursiveTask<Long> {
>>>     final SplittableRandom rnd;
>>>     final int count;
>>>
>>>     public SumRandomInts(int count, SplittableRandom rnd) {
>>>         this.rnd = rnd;
>>>         this.count = count;
>>>     }
>>>
>>>     @Override
>>>     protected Long compute() {
>>>         if (count < 1000) {
>>>             long sum = 0L;
>>>             for (int i = 0; i < count; i++) {
>>>                 sum += rnd.nextInt();
>>>             }
>>>             return sum;
>>>         } else {
>>>             SumRandomInts t1 = new SumRandomInts(count / 2, 
>>> rnd.split());
>>>             SumRandomInts t2 = new SumRandomInts(count - count / 2, 
>>> rnd.split());
>>>             t1.fork();
>>>             return t2.compute() + t1.join();
>>>         }
>>>     }
>>>
>>>     public static void main(String[] args) throws Exception {
>>>         long result = ForkJoinPool.commonPool().submit(
>>>             new SumRandomInts(100000, new 
>>> SplittableRandom(12345L))).get();
>>>         System.out.println(result);
>>>     }
>>> }
>>>
>>>
>>> Regards, Peter
>>>
>>> On 02/06/2016 04:18 AM, cowwoc wrote:
>>>> Hi,
>>>>
>>>> Is this the correct mailing list for discussing ForkJoinPool in JDK9? If
>>>> not, please point me to the right place.
>>>>
>>>> I have a feature request for ForkJoinPool which doesn't seem to be possible
>>>> to implement without a JDK change:http://stackoverflow.com/q/34012134/14731
>>>>
>>>> Specifically, I need to be able to an application that uses Random and
>>>> ForkJoinPool in a deterministic manner when debugging/profiling but run
>>>> full-speed in normal execution mode. I have all the moving parts nailing
>>>> down except for ForkJoinPool.
>>>>
>>>> If I create ForkJoinPool with a parallelism of 1, sometimes I see two worker
>>>> threads getting used. I am guessing that this is caused by
>>>> ForkJoinTask.get() invoking ForkJoinPool.common.externalHelpComplete(), but
>>>> maybe something else is going on.
>>>>
>>>> Is there a way for me to guarantee that ForkJoinThread will use exactly 1
>>>> worker thread, no less, no more? Would you like me to file a formal feature
>>>> request?
>>>>
>>>> Thank you,
>>>> Gili
>>>>
>>>>
>>>>
>>>> --
>>>> View this message in context:http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>>>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> [hidden email] </user/SendEmail.jtp?type=node&node=13233&i=0>
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> [hidden email] </user/SendEmail.jtp?type=node&node=13233&i=1>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>> ------------------------------------------------------------------------
>>> If you reply to this email, your message will be added to the 
>>> discussion below:
>>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13233.html 
>>>
>>> To unsubscribe from Single-threaded ForkJoinPool, click here.
>>> NAML 
>>> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>>>
>>
>>
>> ------------------------------------------------------------------------
>> View this message in context: Re: Single-threaded ForkJoinPool 
>> <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13235.html>
>> Sent from the JSR166 Concurrency mailing list archive 
>> <http://jsr166-concurrency.10961.n7.nabble.com/> at Nabble.com.
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> [hidden email] </user/SendEmail.jtp?type=node&node=13240&i=0>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> [hidden email] </user/SendEmail.jtp?type=node&node=13240&i=1>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------------------------------------------------
> If you reply to this email, your message will be added to the 
> discussion below:
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13240.html 
>
> To unsubscribe from Single-threaded ForkJoinPool, click here 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=unsubscribe_by_code&node=13232&code=Y293d29jQGJicy5kYXJrdGVjaC5vcmd8MTMyMzJ8MTU3NDMyMTI0Nw==>.
> NAML 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13249.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160208/ec82b3f9/attachment.html>

From cowwoc at bbs.darktech.org  Mon Feb  8 02:47:46 2016
From: cowwoc at bbs.darktech.org (cowwoc)
Date: Mon, 8 Feb 2016 00:47:46 -0700 (MST)
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56B65B01.7050508@cs.oswego.edu>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B65B01.7050508@cs.oswego.edu>
Message-ID: <56B85443.1000101@bbs.darktech.org>

So, it turns out this solution isn't actually safe.

1. I used the following thread factory:

                 ForkJoinWorkerThreadFactory factory = new 
ForkJoinWorkerThreadFactory()
                 {
                     private WeakReference<Thread> currentWorker = new 
WeakReference<>(null);

                     @Override
                     public synchronized ForkJoinWorkerThread 
newThread(ForkJoinPool pool)
                     {
                         // If the pool already has a live thread, 
return null.
                         Thread thread = currentWorker.get();
                         if (thread != null && thread.isAlive())
                         {
                             System.out.println("Thread: " + 
thread.getName() + " is already alive, returning null.");
                             return null;
                         }
                         ForkJoinWorkerThread result = new 
MyForkJoinWorkerThread(pool);
                         currentWorker = new WeakReference<>(result);
                         // According to Doug Lea this will reduce the 
probability of short livelocks
                         Thread.yield();
                         return result;
                     }
                 };

2. I started a debugging session.
3. I suspended all threads long enough for the worker thread to get 
flagged as idle (approximately 10 seconds).
4. I allowed all threads to continue execution.
5. Upon resuming, the worker thread shut down and at the same time the 
factory printed "Thread: X is already alive, returning null."
6. If I run the above scenario without suspending all threads (only 
suspending the "main" thread) then the worker thread shuts down, I 
resume execution, and a new worker thread spins up.

In other words, the proposed solution is vulnerable to a race condition.

Gili

On 2016-02-06 9:35 PM, cowwoc wrote:
> Thanks Doug, I'll give this a try.
>
> Thanks,
> Gili
>
> On 2016-02-06 3:02 PM, Doug Lea [via JSR166 Concurrency] wrote:
>> On 02/06/2016 05:21 AM, Viktor Klang wrote:
>> > What happens if you supply it with a thread factory which only 
>> allows a single
>> > thread to be alive at a time, and returns null if it already has 
>> returned a
>> > still living thread?
>> >
>>
>> Yes, this will work if you are positive that only one thread
>> is required for liveness. FJ sometimes conservatively creates
>> threads when it cannot itself guarantee liveness (for example,
>> when GC or other system load causes stalls). But it will
>> respond to null factory returns by rechecking, not failing.
>> unless a thread really is needed to maintain liveness, in which
>> case the program may livelock. To reduce transient near-livelock,
>> you might want to place a Thread.yield() call before the
>> "return null" in the factory.
>>
>> -Doug
>>
>>
>> > --
>> > Cheers,
>> > ?
>> >
>> > On Feb 6, 2016 05:19, "cowwoc" <[hidden email] 
>> </user/SendEmail.jtp?type=node&node=13243&i=0>
>> > <mailto:[hidden email] 
>> </user/SendEmail.jtp?type=node&node=13243&i=1>>> wrote:
>> >
>> >     Hi,
>> >
>> >     Is this the correct mailing list for discussing ForkJoinPool in 
>> JDK9? If
>> >     not, please point me to the right place.
>> >
>> >     I have a feature request for ForkJoinPool which doesn't seem to 
>> be possible
>> >     to implement without a JDK change: 
>> http://stackoverflow.com/q/34012134/14731
>> >
>> >     Specifically, I need to be able to an application that uses 
>> Random and
>> >     ForkJoinPool in a deterministic manner when debugging/profiling 
>> but run
>> >     full-speed in normal execution mode. I have all the moving 
>> parts nailing
>> >     down except for ForkJoinPool.
>> >
>> >     If I create ForkJoinPool with a parallelism of 1, sometimes I 
>> see two worker
>> >     threads getting used. I am guessing that this is caused by
>> >     ForkJoinTask.get() invoking 
>> ForkJoinPool.common.externalHelpComplete(), but
>> >     maybe something else is going on.
>> >
>> >     Is there a way for me to guarantee that ForkJoinThread will use 
>> exactly 1
>> >     worker thread, no less, no more? Would you like me to file a 
>> formal feature
>> >     request?
>> >
>> >     Thank you,
>> >     Gili
>> >
>> >
>> >
>> >     --
>> >     View this message in context:
>> > 
>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>> >     Sent from the JSR166 Concurrency mailing list archive at 
>> Nabble.com.
>> >     _______________________________________________
>> >     Concurrency-interest mailing list
>> > [hidden email] </user/SendEmail.jtp?type=node&node=13243&i=2> 
>> <mailto:[hidden email] </user/SendEmail.jtp?type=node&node=13243&i=3>>
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > [hidden email] </user/SendEmail.jtp?type=node&node=13243&i=4>
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> [hidden email] </user/SendEmail.jtp?type=node&node=13243&i=5>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> ------------------------------------------------------------------------
>> If you reply to this email, your message will be added to the 
>> discussion below:
>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13243.html 
>>
>> To unsubscribe from Single-threaded ForkJoinPool, click here 
>> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=unsubscribe_by_code&node=13232&code=Y293d29jQGJicy5kYXJrdGVjaC5vcmd8MTMyMzJ8MTU3NDMyMTI0Nw==>.
>> NAML 
>> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>>
>





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13250.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160208/d50d2578/attachment-0001.html>

From cowwoc at bbs.darktech.org  Mon Feb  8 03:10:37 2016
From: cowwoc at bbs.darktech.org (cowwoc)
Date: Mon, 8 Feb 2016 01:10:37 -0700 (MST)
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56B65B01.7050508@cs.oswego.edu>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B65B01.7050508@cs.oswego.edu>
Message-ID: <56B859A5.8080207@bbs.darktech.org>

I stepped through the ForkJoinPool code and saw the following execution 
path:

 1. ForkJoinPool.execute() -> ForkJoinPool.externalPush() ->
    ForkJoinPool.signalWork() -> ForkJoinPool.tryAddWorker() ->
    ForkJoinPool.createWorker() -> ForkJoinWorkerThreadFactory.newThread()
 2. When the factory returns null, createWorker() tries to clean up any
    exceptions (there are none) and all other methods return normally
    (as if a new thread had been created).
 3. This means that ForkJoinTask.get() will block indefinitely.

Doug is right that ForkJoinPool doesn't fail if a factory returns null, 
but it doesn't seem to recheck if a new worker is required unless 
someone adds additional tasks.

My guess is that tryAddWorker() should check if a worker was actually 
added as opposed to always breaking out of the loop.

Gili

On 2016-02-08 3:39 AM, cowwoc wrote:
> So, it turns out this solution isn't actually safe.
>
> 1. I used the following thread factory:
>
>                 ForkJoinWorkerThreadFactory factory = new 
> ForkJoinWorkerThreadFactory()
>                 {
>                     private WeakReference<Thread> currentWorker = new 
> WeakReference<>(null);
>
>                     @Override
>                     public synchronized ForkJoinWorkerThread 
> newThread(ForkJoinPool pool)
>                     {
>                         // If the pool already has a live thread, 
> return null.
>                         Thread thread = currentWorker.get();
>                         if (thread != null && thread.isAlive())
>                         {
>                             System.out.println("Thread: " + 
> thread.getName() + " is already alive, returning null.");
>                             return null;
>                         }
>                         ForkJoinWorkerThread result = new 
> MyForkJoinWorkerThread(pool);
>                         currentWorker = new WeakReference<>(result);
>                         // According to Doug Lea this will reduce the 
> probability of short livelocks
>                         Thread.yield();
>                         return result;
>                     }
>                 };
>
> 2. I started a debugging session.
> 3. I suspended all threads long enough for the worker thread to get 
> flagged as idle (approximately 10 seconds).
> 4. I allowed all threads to continue execution.
> 5. Upon resuming, the worker thread shut down and at the same time the 
> factory printed "Thread: X is already alive, returning null."
> 6. If I run the above scenario without suspending all threads (only 
> suspending the "main" thread) then the worker thread shuts down, I 
> resume execution, and a new worker thread spins up.
>
> In other words, the proposed solution is vulnerable to a race condition.
>
> Gili
>
> On 2016-02-06 9:35 PM, cowwoc wrote:
>> Thanks Doug, I'll give this a try.
>>
>> Thanks,
>> Gili
>>
>> On 2016-02-06 3:02 PM, Doug Lea [via JSR166 Concurrency] wrote:
>>> On 02/06/2016 05:21 AM, Viktor Klang wrote:
>>> > What happens if you supply it with a thread factory which only 
>>> allows a single
>>> > thread to be alive at a time, and returns null if it already has 
>>> returned a
>>> > still living thread?
>>> >
>>>
>>> Yes, this will work if you are positive that only one thread
>>> is required for liveness. FJ sometimes conservatively creates
>>> threads when it cannot itself guarantee liveness (for example,
>>> when GC or other system load causes stalls). But it will
>>> respond to null factory returns by rechecking, not failing.
>>> unless a thread really is needed to maintain liveness, in which
>>> case the program may livelock. To reduce transient near-livelock,
>>> you might want to place a Thread.yield() call before the
>>> "return null" in the factory.
>>>
>>> -Doug
>>>
>>>
>>> > --
>>> > Cheers,
>>> > ?
>>> >
>>> > On Feb 6, 2016 05:19, "cowwoc" <[hidden email] 
>>> </user/SendEmail.jtp?type=node&node=13243&i=0>
>>> > <mailto:[hidden email] 
>>> </user/SendEmail.jtp?type=node&node=13243&i=1>>> wrote:
>>> >
>>> >     Hi,
>>> >
>>> >     Is this the correct mailing list for discussing ForkJoinPool 
>>> in JDK9? If
>>> >     not, please point me to the right place.
>>> >
>>> >     I have a feature request for ForkJoinPool which doesn't seem 
>>> to be possible
>>> >     to implement without a JDK change: 
>>> http://stackoverflow.com/q/34012134/14731
>>> >
>>> >     Specifically, I need to be able to an application that uses 
>>> Random and
>>> >     ForkJoinPool in a deterministic manner when 
>>> debugging/profiling but run
>>> >     full-speed in normal execution mode. I have all the moving 
>>> parts nailing
>>> >     down except for ForkJoinPool.
>>> >
>>> >     If I create ForkJoinPool with a parallelism of 1, sometimes I 
>>> see two worker
>>> >     threads getting used. I am guessing that this is caused by
>>> >     ForkJoinTask.get() invoking 
>>> ForkJoinPool.common.externalHelpComplete(), but
>>> >     maybe something else is going on.
>>> >
>>> >     Is there a way for me to guarantee that ForkJoinThread will 
>>> use exactly 1
>>> >     worker thread, no less, no more? Would you like me to file a 
>>> formal feature
>>> >     request?
>>> >
>>> >     Thank you,
>>> >     Gili
>>> >
>>> >
>>> >
>>> >     --
>>> >     View this message in context:
>>> > 
>>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>>> >     Sent from the JSR166 Concurrency mailing list archive at 
>>> Nabble.com.
>>> >     _______________________________________________
>>> >     Concurrency-interest mailing list
>>> > [hidden email] </user/SendEmail.jtp?type=node&node=13243&i=2> 
>>> <mailto:[hidden email] </user/SendEmail.jtp?type=node&node=13243&i=3>>
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >
>>> >
>>> >
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > [hidden email] </user/SendEmail.jtp?type=node&node=13243&i=4>
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> >
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> [hidden email] </user/SendEmail.jtp?type=node&node=13243&i=5>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>> ------------------------------------------------------------------------
>>> If you reply to this email, your message will be added to the 
>>> discussion below:
>>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13243.html 
>>>
>>> To unsubscribe from Single-threaded ForkJoinPool, click here 
>>> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=unsubscribe_by_code&node=13232&code=Y293d29jQGJicy5kYXJrdGVjaC5vcmd8MTMyMzJ8MTU3NDMyMTI0Nw==>.
>>> NAML 
>>> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>>>
>>
>





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13251.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160208/b58f4e55/attachment.html>

From viktor.klang at gmail.com  Mon Feb  8 04:53:45 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Mon, 8 Feb 2016 10:53:45 +0100
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56B85443.1000101@bbs.darktech.org>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B65B01.7050508@cs.oswego.edu> <56B85443.1000101@bbs.darktech.org>
Message-ID: <CANPzfU9oQbOQvKgsykPRCNHJYcWJVKy-ZfE6sHdHnm_8z=nOKw@mail.gmail.com>

I was thinking something along the lines of this:

https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L65
https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L68

(no need for WeakReferences to Threads, synchronized etc)

On Mon, Feb 8, 2016 at 8:47 AM, cowwoc <cowwoc at bbs.darktech.org> wrote:

> So, it turns out this solution isn't actually safe.
>
> 1. I used the following thread factory:
>
>                 ForkJoinWorkerThreadFactory factory = new
> ForkJoinWorkerThreadFactory()
>                 {
>                     private WeakReference<Thread> currentWorker = new
> WeakReference<>(null);
>
>                     @Override
>                     public synchronized ForkJoinWorkerThread
> newThread(ForkJoinPool pool)
>                     {
>                         // If the pool already has a live thread, return
> null.
>                         Thread thread = currentWorker.get();
>                         if (thread != null && thread.isAlive())
>                         {
>                             System.out.println("Thread: " +
> thread.getName() + " is already alive, returning null.");
>                             return null;
>                         }
>                         ForkJoinWorkerThread result = new
> MyForkJoinWorkerThread(pool);
>                         currentWorker = new WeakReference<>(result);
>                         // According to Doug Lea this will reduce the
> probability of short livelocks
>                         Thread.yield();
>                         return result;
>                     }
>                 };
>
> 2. I started a debugging session.
> 3. I suspended all threads long enough for the worker thread to get
> flagged as idle (approximately 10 seconds).
> 4. I allowed all threads to continue execution.
> 5. Upon resuming, the worker thread shut down and at the same time the
> factory printed "Thread: X is already alive, returning null."
> 6. If I run the above scenario without suspending all threads (only
> suspending the "main" thread) then the worker thread shuts down, I resume
> execution, and a new worker thread spins up.
>
> In other words, the proposed solution is vulnerable to a race condition.
>
> Gili
>
> On 2016-02-06 9:35 PM, cowwoc wrote:
>
> Thanks Doug, I'll give this a try.
>
> Thanks,
> Gili
>
> On 2016-02-06 3:02 PM, Doug Lea [via JSR166 Concurrency] wrote:
>
> On 02/06/2016 05:21 AM, Viktor Klang wrote:
> > What happens if you supply it with a thread factory which only allows a
> single
> > thread to be alive at a time, and returns null if it already has
> returned a
> > still living thread?
> >
>
> Yes, this will work if you are positive that only one thread
> is required for liveness. FJ sometimes conservatively creates
> threads when it cannot itself guarantee liveness (for example,
> when GC or other system load causes stalls). But it will
> respond to null factory returns by rechecking, not failing.
> unless a thread really is needed to maintain liveness, in which
> case the program may livelock. To reduce transient near-livelock,
> you might want to place a Thread.yield() call before the
> "return null" in the factory.
>
> -Doug
>
>
> > --
> > Cheers,
> > ?
> >
> > On Feb 6, 2016 05:19, "cowwoc" <[hidden email]
> <http:///user/SendEmail.jtp?type=node&node=13243&i=0>
> > <mailto:[hidden email]
> <http:///user/SendEmail.jtp?type=node&node=13243&i=1>>> wrote:
> >
> >     Hi,
> >
> >     Is this the correct mailing list for discussing ForkJoinPool in
> JDK9? If
> >     not, please point me to the right place.
> >
> >     I have a feature request for ForkJoinPool which doesn't seem to be
> possible
> >     to implement without a JDK change:
> <http://stackoverflow.com/q/34012134/14731>
> http://stackoverflow.com/q/34012134/14731
> >
> >     Specifically, I need to be able to an application that uses Random
> and
> >     ForkJoinPool in a deterministic manner when debugging/profiling but
> run
> >     full-speed in normal execution mode. I have all the moving parts
> nailing
> >     down except for ForkJoinPool.
> >
> >     If I create ForkJoinPool with a parallelism of 1, sometimes I see
> two worker
> >     threads getting used. I am guessing that this is caused by
> >     ForkJoinTask.get() invoking
> ForkJoinPool.common.externalHelpComplete(), but
> >     maybe something else is going on.
> >
> >     Is there a way for me to guarantee that ForkJoinThread will use
> exactly 1
> >     worker thread, no less, no more? Would you like me to file a formal
> feature
> >     request?
> >
> >     Thank you,
> >     Gili
> >
> >
> >
> >     --
> >     View this message in context:
> >
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
> >     Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> >     _______________________________________________
> >     Concurrency-interest mailing list
> >     [hidden email] <http:///user/SendEmail.jtp?type=node&node=13243&i=2>
> <mailto:[hidden email]
> <http:///user/SendEmail.jtp?type=node&node=13243&i=3>>
> >     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > [hidden email] <http:///user/SendEmail.jtp?type=node&node=13243&i=4>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> [hidden email] <http:///user/SendEmail.jtp?type=node&node=13243&i=5>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------
> If you reply to this email, your message will be added to the discussion
> below:
>
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13243.html
> To unsubscribe from Single-threaded ForkJoinPool, click here.
> NAML
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml>
>
>
>
>
> ------------------------------
> View this message in context: Re: Single-threaded ForkJoinPool
> <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13250.html>
>
> Sent from the JSR166 Concurrency mailing list archive
> <http://jsr166-concurrency.10961.n7.nabble.com/> at Nabble.com.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160208/7c584f75/attachment-0001.html>

From cowwoc at bbs.darktech.org  Mon Feb  8 05:00:49 2016
From: cowwoc at bbs.darktech.org (cowwoc)
Date: Mon, 8 Feb 2016 05:00:49 -0500
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <CANPzfU9oQbOQvKgsykPRCNHJYcWJVKy-ZfE6sHdHnm_8z=nOKw@mail.gmail.com>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B65B01.7050508@cs.oswego.edu> <56B85443.1000101@bbs.darktech.org>
	<CANPzfU9oQbOQvKgsykPRCNHJYcWJVKy-ZfE6sHdHnm_8z=nOKw@mail.gmail.com>
Message-ID: <56B86751.5050003@bbs.darktech.org>

You're still vulnerable to the same race condition:

 1. [main] Invokes ForkJoinPool.execute(task)
 2. [WorkerThread] Finishes running a task, reaches the point
    immediately before deregisterThread() at
    https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L61
 3. [main] ForkJoinPool invokes tryAddWorker(),
    https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L65
    returns null
 4. [WorkerThread] Invokes deregisterThread().

Now we have an enqueued task, no worker threads and no one is trying to 
spin up a new thread.

Gili

On 2016-02-08 4:53 AM, Viktor Klang wrote:
> I was thinking something along the lines of this:
>
> https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L65
> https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L68
>
> (no need for WeakReferences to Threads, synchronized etc)
>
> On Mon, Feb 8, 2016 at 8:47 AM, cowwoc <cowwoc at bbs.darktech.org 
> <mailto:cowwoc at bbs.darktech.org>> wrote:
>
>     So, it turns out this solution isn't actually safe.
>
>     1. I used the following thread factory:
>
>                     ForkJoinWorkerThreadFactory factory = new
>     ForkJoinWorkerThreadFactory()
>                     {
>                         private WeakReference<Thread> currentWorker =
>     new WeakReference<>(null);
>
>                         @Override
>                         public synchronized ForkJoinWorkerThread
>     newThread(ForkJoinPool pool)
>                         {
>                             // If the pool already has a live thread,
>     return null.
>                             Thread thread = currentWorker.get();
>                             if (thread != null && thread.isAlive())
>                             {
>                                 System.out.println("Thread: " +
>     thread.getName() + " is already alive, returning null.");
>                                 return null;
>                             }
>                             ForkJoinWorkerThread result = new
>     MyForkJoinWorkerThread(pool);
>                             currentWorker = new WeakReference<>(result);
>                             // According to Doug Lea this will reduce
>     the probability of short livelocks
>                             Thread.yield();
>                             return result;
>                         }
>                     };
>
>     2. I started a debugging session.
>     3. I suspended all threads long enough for the worker thread to
>     get flagged as idle (approximately 10 seconds).
>     4. I allowed all threads to continue execution.
>     5. Upon resuming, the worker thread shut down and at the same time
>     the factory printed "Thread: X is already alive, returning null."
>     6. If I run the above scenario without suspending all threads
>     (only suspending the "main" thread) then the worker thread shuts
>     down, I resume execution, and a new worker thread spins up.
>
>     In other words, the proposed solution is vulnerable to a race
>     condition.
>
>     Gili
>
>     On 2016-02-06 9:35 PM, cowwoc wrote:
>>     Thanks Doug, I'll give this a try.
>>
>>     Thanks,
>>     Gili
>>
>>     On 2016-02-06 3:02 PM, Doug Lea [via JSR166 Concurrency] wrote:
>>>     On 02/06/2016 05:21 AM, Viktor Klang wrote:
>>>     > What happens if you supply it with a thread factory which only
>>>     allows a single
>>>     > thread to be alive at a time, and returns null if it already
>>>     has returned a
>>>     > still living thread?
>>>     >
>>>
>>>     Yes, this will work if you are positive that only one thread
>>>     is required for liveness. FJ sometimes conservatively creates
>>>     threads when it cannot itself guarantee liveness (for example,
>>>     when GC or other system load causes stalls). But it will
>>>     respond to null factory returns by rechecking, not failing.
>>>     unless a thread really is needed to maintain liveness, in which
>>>     case the program may livelock. To reduce transient near-livelock,
>>>     you might want to place a Thread.yield() call before the
>>>     "return null" in the factory.
>>>
>>>     -Doug
>>>
>>>
>>>     > --
>>>     > Cheers,
>>>     > ?
>>>     >
>>>     > On Feb 6, 2016 05:19, "cowwoc" <[hidden email]
>>>     <http:///user/SendEmail.jtp?type=node&node=13243&i=0>
>>>     > <mailto:[hidden email]
>>>     <http:///user/SendEmail.jtp?type=node&node=13243&i=1>>> wrote:
>>>     >
>>>     >     Hi,
>>>     >
>>>     >     Is this the correct mailing list for discussing
>>>     ForkJoinPool in JDK9? If
>>>     >     not, please point me to the right place.
>>>     >
>>>     >     I have a feature request for ForkJoinPool which doesn't
>>>     seem to be possible
>>>     >     to implement without a JDK change:
>>>     http://stackoverflow.com/q/34012134/14731
>>>     >
>>>     >     Specifically, I need to be able to an application that
>>>     uses Random and
>>>     >     ForkJoinPool in a deterministic manner when
>>>     debugging/profiling but run
>>>     >     full-speed in normal execution mode. I have all the moving
>>>     parts nailing
>>>     >     down except for ForkJoinPool.
>>>     >
>>>     >     If I create ForkJoinPool with a parallelism of 1,
>>>     sometimes I see two worker
>>>     >     threads getting used. I am guessing that this is caused by
>>>     >     ForkJoinTask.get() invoking
>>>     ForkJoinPool.common.externalHelpComplete(), but
>>>     >     maybe something else is going on.
>>>     >
>>>     >     Is there a way for me to guarantee that ForkJoinThread
>>>     will use exactly 1
>>>     >     worker thread, no less, no more? Would you like me to file
>>>     a formal feature
>>>     >     request?
>>>     >
>>>     >     Thank you,
>>>     >     Gili
>>>     >
>>>     >
>>>     >
>>>     >     --
>>>     >     View this message in context:
>>>     >
>>>     http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>>>     >     Sent from the JSR166 Concurrency mailing list archive at
>>>     Nabble.com.
>>>     > _______________________________________________
>>>     >     Concurrency-interest mailing list
>>>     > [hidden email]
>>>     <http:///user/SendEmail.jtp?type=node&node=13243&i=2>
>>>     <mailto:[hidden email]
>>>     <http:///user/SendEmail.jtp?type=node&node=13243&i=3>>
>>>     > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>     >
>>>     >
>>>     >
>>>     > _______________________________________________
>>>     > Concurrency-interest mailing list
>>>     > [hidden email]
>>>     <http:///user/SendEmail.jtp?type=node&node=13243&i=4>
>>>     > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>     >
>>>
>>>
>>>
>>>     _______________________________________________
>>>     Concurrency-interest mailing list
>>>     [hidden email]
>>>     <http:///user/SendEmail.jtp?type=node&node=13243&i=5>
>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>>     ------------------------------------------------------------------------
>>>     If you reply to this email, your message will be added to the
>>>     discussion below:
>>>     http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13243.html
>>>
>>>     To unsubscribe from Single-threaded ForkJoinPool, click here.
>>>     NAML
>>>     <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml>
>>>
>>
>
>
>     ------------------------------------------------------------------------
>     View this message in context: Re: Single-threaded ForkJoinPool
>     <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13250.html>
>
>
>     Sent from the JSR166 Concurrency mailing list archive
>     <http://jsr166-concurrency.10961.n7.nabble.com/> at Nabble.com.
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> -- 
> Cheers,
> ?

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160208/4411be61/attachment.html>

From paul.sandoz at oracle.com  Mon Feb  8 05:09:46 2016
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Mon, 8 Feb 2016 11:09:46 +0100
Subject: [concurrency-interest] RFR: jsr166 jdk9 integration wave 4
In-Reply-To: <CA+kOe0-OXciPNDQktVF4v3-7gzbvT0i=KoYG4L-+ySh4Y4inyA@mail.gmail.com>
References: <CA+kOe0-OXciPNDQktVF4v3-7gzbvT0i=KoYG4L-+ySh4Y4inyA@mail.gmail.com>
Message-ID: <A176A578-8054-4529-B6A1-869E0F175B53@oracle.com>


> On 1 Feb 2016, at 19:45, Martin Buchholz <martinrb at google.com> wrote:
> 
> After much debate on what to do when CompleteableFuture.whenComplete
> encounters an exception in both the source and the action, we chose
> what was acceptable to the most people - add the action's exception to
> the source exception as a suppressed exception.  And added usage
> guidelines.  And gave handle "top billing" over whenComplete.
> 
> http://cr.openjdk.java.net/~martin/webrevs/openjdk9/jsr166-jdk9-integration/
> 
> and the usual miscellaneous improvements.


+1

Looks like the diffs got swapped for EmptyNavigableSet.java in the misc patch:

http://cr.openjdk.java.net/~martin/webrevs/openjdk9/jsr166-jdk9-integration/patches/jsr166-jdk9-integration-miscellaneous

diff --git a/test/java/util/Collections/EmptyNavigableSet.java b/test/java/util/Collections/EmptyNavigableSet.java
--- a/test/java/util/Collections/EmptyNavigableSet.java
+++ b/test/java/util/Collections/EmptyNavigableSet.java
@@ -284,7 +284,7 @@
                     navigableSet.subSet(last, true, first, false);
                 },
                 IllegalArgumentException.class, description
-                + ": Must throw IllegalArgumentException when fromElement is not less than toElement.");
+                + ": Must throw IllegalArgumentException when fromElement is not less then then toElement.?);

Paul.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 841 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160208/1f6343de/attachment-0001.bin>

From pavel.rappo at gmail.com  Mon Feb  8 12:32:55 2016
From: pavel.rappo at gmail.com (Pavel Rappo)
Date: Mon, 8 Feb 2016 17:32:55 +0000
Subject: [concurrency-interest] Flow.Subscription's javadoc
In-Reply-To: <CANPzfU8Wk1LgPQePVaQXBKBzvxTALtAtzeW3WxhZsN4My=6wLw@mail.gmail.com>
References: <CAChcVuk3+L66Y_NuRqZH5p28YwMM8azEEAp9AQVtGJoc1t+FzA@mail.gmail.com>
	<CAAWwtm8DfoqvosXp=tvFd0iAkh29MK+V0=CSi-08qTujZp4cpA@mail.gmail.com>
	<CABY0rKMQ2ZFCTxZV05kCFGk8shVz9E7J3D7T7oFEgZMf4cBzfQ@mail.gmail.com>
	<CANPzfU8Wk1LgPQePVaQXBKBzvxTALtAtzeW3WxhZsN4My=6wLw@mail.gmail.com>
Message-ID: <CAChcVumiXkk_OQ7CG=C=xoeiRbi4e+3Xidj2x1=Tq3S1rEPepg@mail.gmail.com>

On Sun, Jan 31, 2016 at 6:49 PM, Viktor Klang <viktor.klang at gmail.com> wrote:
> Does that make sense?

Yes it does. It's good the excerpt I've referred to in my initial
email doesn't have any connotation beyond what's been explained to me
in this thread. In other words, business as usual: an object should be
interacted with through some interface by anyone who knows and
understands the semantics of that interface. Thanks.

From mandy.chung at oracle.com  Mon Feb  8 17:14:39 2016
From: mandy.chung at oracle.com (Mandy Chung)
Date: Mon, 8 Feb 2016 14:14:39 -0800
Subject: [concurrency-interest] ClassLoader deadlock
In-Reply-To: <56B71440.5000108@zeus.net.au>
References: <56B5DB78.1070502@zeus.net.au> <56B5DF8C.5010201@oracle.com>
	<56B5E446.9020205@zeus.net.au> <56B63B11.20903@gmail.com>
	<56B6668A.3030106@zeus.net.au> <56B7023C.5030708@gmail.com>
	<56B71440.5000108@zeus.net.au>
Message-ID: <A8FCC1ED-079D-4E0D-B969-5865F7168463@oracle.com>

Out of curiousity, what class loader is using to define org.apache.river.api.security.CombinerSecurityManager?

Mandy

> On Feb 7, 2016, at 1:54 AM, Peter <jini at zeus.net.au> wrote:
> 
> Thanks Peter & David,
> 
> That's good to know.
> 
> I've altered the SecurityManager to perform a permission check prior to becoming the security manager, this ensures the cache has been created, to avoid any recursive deadlock prone calls.
> 
> The class that both threads are attempting to load and init is called org.apache.river.concurrent.ReferenceIterator.
> 
> The code can be found here:
> 
> https://github.com/pfirmstone/river-internet/tree/Input-validation-for-Serialization
> 
> Cheers,
> 
> Peter.
> 
> 
> On 7/02/2016 6:37 PM, Peter Levart wrote:
>> 
>> 
>> On 02/06/2016 10:32 PM, Peter wrote:
>>> The 0x040ebee8 monitor is most likely being held by native code.
>>> 
>>> Regards,
>>> 
>>> Peter Firmstone.
>> 
>> Ok, but where? The deadlock report says it is held by main thread. Somewhere between the following two java frames?
>> 
>> "main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for monitor entry [0x0185e000]
>> ...
>> ...
>>        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>> --here--
>>        at org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124)
>> 
>> 
>> As I understand this is where JVM resolves some class that for the 1st time while ReferenceCollection.iterator is being executed. So before calling-back into ClassLoader.loadClass, it acquires a monitor lock on some int[] object?
>> 
>> 
>> Anyway. Looking at the following part of Thread-1 stacktrace:
>> 
>>        at org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202)
>>        at java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447)
>>        at java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158)
>>        at java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137)
>>        at java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526)
>>        at java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266)
>>        at java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070)
>>        at java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535)
>> 
>> ...I can see you are using some early release of JDK 8 where ThreadLocalRandom initialization involved obtaining a hardware address of some interface. This in turn checks for security manager. Since JDK 8u45 this code has been removed and only current time is used to derive initial seed, so you might not see this deadlock any more with JDK 8u45 and later.
>> 
>> Regards, Peter
>> 
>>> 
>>> 
>>> On 7/02/2016 4:27 AM, Peter Levart wrote:
>>>> 
>>>> 
>>>> On 02/06/2016 01:17 PM, Peter Firmstone wrote:
>>>>> The security manager is non blocking, unfortunately java system classes aren't.
>>>> 
>>>> It doesn't seem so. At least, I can't find where main thread locks the 0x040ebee8 monitor:
>>>> 
>>>> "Thread-1":
>>>>  waiting to lock monitor 0x142766ac (object 0x040ebee8, a [I),
>>>>  which is held by "main"
>>>> 
>>>> 
>>>> "main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for monitor entry [0x0185e000]
>>>>   java.lang.Thread.State: BLOCKED (on object monitor)
>>>>        at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>>>        - waiting to lock <0x03f624b8> (a java.lang.Object)
>>>>        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>        at org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124)
>>>>        at org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)
>>>>        at org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44)
>>>>        at org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57)
>>>>        at org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64)
>>>>        at org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128)
>>>>        at org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44)
>>>>        at org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)
>>>>        at org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68)
>>>>        at org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261)
>>>>        at org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202)
>>>>        at java.lang.System.checkIO(System.java:253)
>>>>        at java.lang.System.setErr(System.java:199)
>>>>        at org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>>> 
>>>> 
>>>> ...no mention of 0x040ebee8 in main thread...?!
>>>> 
>>>> Peter
>>>> 
>>>>> 
>>>>> The policy provider in use thread confines PermissionCollection instances, which never leave the cpu cache, they are discarded immediately after use.
>>>>> 
>>>>> The problem here is that two different threads are attempting to load the same class at the same time.
>>>>> 
>>>>> I'll have to make sure that all classes are loaded before the security manager becomes the system security manager, either that or eliminate the AccessControlContext check permission cache.
>>>>> 
>>>>> While the standard java security manager and policy provider consume around 10% cpu, this consumes less than 1%.
>>>>> 
>>>>> On 6/02/2016 9:57 PM, David Holmes wrote:
>>>>>> On 6/02/2016 9:39 PM, Peter Firmstone wrote:
>>>>>>> Hmm, thought the new parallel lock stategy in ClassLoader wasn't
>>>>>>> deadlock prone?  Guess I was wrong.
>>>>>> 
>>>>>> The deadlock is introduced by a custom security manager. SM's play a critical role in many parts of the core libraries so if they utilize synchronization then they can easily introduce deadlock.
>>>>>> 
>>>>>>> Observation:  On an unrelated occassion, I had a URLClassLoader
>>>>>>> synchronization hotspot (well not standard URLClassLoader, but a high
>>>>>>> performance RFC3986 URL ClassLoader, that use normalized RFC3986 URI
>>>>>>> instead of URL DNS lookup), I solved that problem by thread confining
>>>>>>> class loading.  I've never experienced deadlock using thread
>>>>>>> confinement, initially I was worried that there would be
>>>>>>> interdependencies, however I didn't experience a problem, as the single
>>>>>>> thread would always load the classes it needed.
>>>>>>> 
>>>>>>> I'm wondering if multiple locks for ClassLoader's might be the wrong
>>>>>>> strategy, I found thread confinement was very performant.
>>>>>> 
>>>>>> Are you suggesting that a class-load request is actually transmitted to a single class-loading thread, while the initial thread blocks until the loading is complete? That would still seem prone to the same SM related deadlock scenario. And it would not generally be particularly performant.
>>>>> 
>>>>> I thought that too, until I tried it.
>>>>> 
>>>>> Would you like to see some performance figures?
>>>>> 
>>>>> Cheers,
>>>>> 
>>>>> Peter.
>>>>> 
>>>>>> 
>>>>>> David
>>>>>> 
>>>>>>> Regards,
>>>>>>> 
>>>>>>> Peter.
>>>>>>> 
>>>>>>> 2016-02-06 21:06:07
>>>>>>> Full thread dump Java HotSpot(TM) Client VM (25.0-b70 mixed mode):
>>>>>>> 
>>>>>>> "Service Thread" #9 daemon prio=9 os_prio=0 tid=0x14387400 nid=0xc54
>>>>>>> runnable [0x00000000]
>>>>>>>    java.lang.Thread.State: RUNNABLE
>>>>>>> 
>>>>>>> "C1 CompilerThread0" #8 daemon prio=9 os_prio=2 tid=0x14332c00
>>>>>>> nid=0x111c waiting on condition [0x00000000]
>>>>>>>    java.lang.Thread.State: RUNNABLE
>>>>>>> 
>>>>>>> "Attach Listener" #7 daemon prio=5 os_prio=2 tid=0x14331c00 nid=0x13d8
>>>>>>> waiting on condition [0x00000000]
>>>>>>>    java.lang.Thread.State: RUNNABLE
>>>>>>> 
>>>>>>> "Signal Dispatcher" #6 daemon prio=9 os_prio=2 tid=0x14331400 nid=0x10b8
>>>>>>> runnable [0x00000000]
>>>>>>>    java.lang.Thread.State: RUNNABLE
>>>>>>> 
>>>>>>> "Thread-1" #5 prio=10 os_prio=2 tid=0x14318800 nid=0x4a8 waiting for
>>>>>>> monitor entry [0x03ded000]
>>>>>>>    java.lang.Thread.State: BLOCKED (on object monitor)
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>>>> 
>>>>>>>         at
>>>>>>> java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447) 
>>>>>>>         at
>>>>>>> java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158) 
>>>>>>> 
>>>>>>>         at
>>>>>>> java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137) 
>>>>>>>         at
>>>>>>> java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526) 
>>>>>>> 
>>>>>>>         at
>>>>>>> java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266) 
>>>>>>> 
>>>>>>>         at
>>>>>>> java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070) 
>>>>>>>         at
>>>>>>> java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535) 
>>>>>>> 
>>>>>>>         at java.lang.ClassLoader.getClassLoadingLock(ClassLoader.java:463)
>>>>>>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
>>>>>>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
>>>>>>>         - locked <0x03f624b8> (a java.lang.Object)
>>>>>>>         at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>>>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>>>>         at
>>>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$SnapshotK.<init>(NonBlockingHashMap.java:1167) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$2.iterator(NonBlockingHashMap.java:1200) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceProcessor$EnqueGarbageTask.run(ReferenceProcessor.java:166) 
>>>>>>> 
>>>>>>>         - locked <0x03ef8b30> (a
>>>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap)
>>>>>>>         at
>>>>>>> java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) 
>>>>>>>         at
>>>>>>> java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
>>>>>>>         at
>>>>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.j 
>>>>>>> 
>>>>>>> ava:180)
>>>>>>>         at
>>>>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294 
>>>>>>> 
>>>>>>> )
>>>>>>>         at
>>>>>>> java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) 
>>>>>>> 
>>>>>>>         at
>>>>>>> java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) 
>>>>>>> 
>>>>>>>         at java.lang.Thread.run(Thread.java:744)
>>>>>>> 
>>>>>>> "Finalizer" #3 daemon prio=8 os_prio=1 tid=0x14277800 nid=0x15cc in
>>>>>>> Object.wait() [0x03cff000]
>>>>>>>    java.lang.Thread.State: WAITING (on object monitor)
>>>>>>>         at java.lang.Object.wait(Native Method)
>>>>>>>         - waiting on <0x03e056d8> (a java.lang.ref.ReferenceQueue$Lock)
>>>>>>>         at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:142)
>>>>>>>         - locked <0x03e056d8> (a java.lang.ref.ReferenceQueue$Lock)
>>>>>>>         at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:158)
>>>>>>>         at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)
>>>>>>> 
>>>>>>> "Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x14271c00
>>>>>>> nid=0x1398 in Object.wait() [0x144cf000]
>>>>>>>    java.lang.Thread.State: WAITING (on object monitor)
>>>>>>>         at java.lang.Object.wait(Native Method)
>>>>>>>         - waiting on <0x03e05200> (a java.lang.ref.Reference$Lock)
>>>>>>>         at java.lang.Object.wait(Object.java:502)
>>>>>>>         at
>>>>>>> java.lang.ref.Reference$ReferenceHandler.run(Reference.java:157)
>>>>>>>         - locked <0x03e05200> (a java.lang.ref.Reference$Lock)
>>>>>>> 
>>>>>>> "main" #1 prio=5 os_prio=0 tid=0x017cf400 nid=0x1284 waiting for monitor
>>>>>>> entry [0x0185e000]
>>>>>>>    java.lang.Thread.State: BLOCKED (on object monitor)
>>>>>>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>>>>>>         - waiting to lock <0x03f624b8> (a java.lang.Object)
>>>>>>>         at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>>>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>>>> 
>>>>>>>         at java.lang.System.checkIO(System.java:253)
>>>>>>>         at java.lang.System.setErr(System.java:199)
>>>>>>>         at org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>>>>>> 
>>>>>>> "VM Thread" os_prio=2 tid=0x1426e400 nid=0x16a8 runnable
>>>>>>> 
>>>>>>> "VM Periodic Task Thread" os_prio=2 tid=0x14388400 nid=0x17a8 waiting on
>>>>>>> condition
>>>>>>> 
>>>>>>> JNI global references: 19
>>>>>>> 
>>>>>>> 
>>>>>>> Found one Java-level deadlock:
>>>>>>> =============================
>>>>>>> "Thread-1":
>>>>>>>   waiting to lock monitor 0x142766ac (object 0x040ebee8, a [I),
>>>>>>>   which is held by "main"
>>>>>>> "main":
>>>>>>>   waiting to lock monitor 0x14274a3c (object 0x03f624b8, a
>>>>>>> java.lang.Object),
>>>>>>>   which is held by "Thread-1"
>>>>>>> 
>>>>>>> Java stack information for the threads listed above:
>>>>>>> ===================================================
>>>>>>> "Thread-1":
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>>>> 
>>>>>>>         at
>>>>>>> java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447) 
>>>>>>>         at
>>>>>>> java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158) 
>>>>>>> 
>>>>>>>         at
>>>>>>> java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137) 
>>>>>>>         at
>>>>>>> java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526) 
>>>>>>> 
>>>>>>>         at
>>>>>>> java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266) 
>>>>>>> 
>>>>>>>         at
>>>>>>> java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070) 
>>>>>>>         at
>>>>>>> java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535) 
>>>>>>> 
>>>>>>>         at java.lang.ClassLoader.getClassLoadingLock(ClassLoader.java:463)
>>>>>>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
>>>>>>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
>>>>>>>         - locked <0x03f624b8> (a java.lang.Object)
>>>>>>>         at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>>>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>>>>         at
>>>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$SnapshotK.<init>(NonBlockingHashMap.java:1167) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap$2.iterator(NonBlockingHashMap.java:1200) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceProcessor$EnqueGarbageTask.run(ReferenceProcessor.java:166) 
>>>>>>> 
>>>>>>>         - locked <0x03ef8b30> (a
>>>>>>> org.cliffc.high_scale_lib.NonBlockingHashMap)
>>>>>>>         at
>>>>>>> java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) 
>>>>>>>         at
>>>>>>> java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
>>>>>>>         at
>>>>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.j 
>>>>>>> 
>>>>>>> ava:180)
>>>>>>>         at
>>>>>>> java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294 
>>>>>>> 
>>>>>>> )
>>>>>>>         at
>>>>>>> java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) 
>>>>>>> 
>>>>>>>         at
>>>>>>> java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) 
>>>>>>> 
>>>>>>>         at java.lang.Thread.run(Thread.java:744)
>>>>>>> "main":
>>>>>>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:406)
>>>>>>>         - waiting to lock <0x03f624b8> (a java.lang.Object)
>>>>>>>         at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
>>>>>>>         at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>>>>         at
>>>>>>> org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>>>> 
>>>>>>>         at
>>>>>>> org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>>>> 
>>>>>>>         at java.lang.System.checkIO(System.java:253)
>>>>>>>         at java.lang.System.setErr(System.java:199)
>>>>>>>         at org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84)
>>>>>>> 
>>>>>>> Found 1 deadlock.
>>>>> 
>>>> 
>>>> 
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> 
>> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From martinrb at google.com  Mon Feb  8 17:29:01 2016
From: martinrb at google.com (Martin Buchholz)
Date: Mon, 8 Feb 2016 14:29:01 -0800
Subject: [concurrency-interest] RFR: jsr166 jdk9 integration wave 4
In-Reply-To: <A176A578-8054-4529-B6A1-869E0F175B53@oracle.com>
References: <CA+kOe0-OXciPNDQktVF4v3-7gzbvT0i=KoYG4L-+ySh4Y4inyA@mail.gmail.com>
	<A176A578-8054-4529-B6A1-869E0F175B53@oracle.com>
Message-ID: <CA+kOe0-7NRThmqFEUs=hR-hZ52ETxhJWt5G4W-uG3i54dJnpSA@mail.gmail.com>

On Mon, Feb 8, 2016 at 2:09 AM, Paul Sandoz <paul.sandoz at oracle.com> wrote:
>
>> On 1 Feb 2016, at 19:45, Martin Buchholz <martinrb at google.com> wrote:
>>
>> After much debate on what to do when CompleteableFuture.whenComplete
>> encounters an exception in both the source and the action, we chose
>> what was acceptable to the most people - add the action's exception to
>> the source exception as a suppressed exception.  And added usage
>> guidelines.  And gave handle "top billing" over whenComplete.
>>
>> http://cr.openjdk.java.net/~martin/webrevs/openjdk9/jsr166-jdk9-integration/
>>
>> and the usual miscellaneous improvements.
>
>
> +1
>
> Looks like the diffs got swapped for EmptyNavigableSet.java in the misc patch:

Thanks, fixed.

This is a result of having bidirectional changes flowing between
different source code control systems and no merge bridging tool.  (I
don't think I've regressed an upstream change yet, but I'm careful
before doing any hg push.  I've modified my upstreaming script to warn
me about such conflicts in the future)

From jini at zeus.net.au  Tue Feb  9 01:06:40 2016
From: jini at zeus.net.au (Peter)
Date: Tue, 9 Feb 2016 16:06:40 +1000 (AEST)
Subject: [concurrency-interest] ClassLoader deadlock
Message-ID: <23c29a1b8db14394cd3a58f04c032f00@org.tizen.email>

The application ClassLoader.

It's loaded using the -Djava.security.manager argument.

The policy is loaded by the extension class loader for historical reasons, with the extension directory argument.

Regards,

Peter.



Sent from my Samsung device.
?
??Include original message
---- Original message ----
From: Mandy Chung <mandy.chung at oracle.com>
Sent: 09/02/2016 08:14:39 am
To: Peter <jini at zeusnet.au>
Cc: Mandy Chung <mandy.chung at oracle.com>; Peter Levart <peter.levart at gmail.com>; core-libs-dev <core-libs-dev at openjdk.java.net>; David Holmes <david.holmes at oracle.com>; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] ClassLoader deadlock

Out?of?curiousity,?what?class?loader?is?using?to?define?org.apache.river.api.security.CombinerSecurityManager? 

Mandy 

>?On?Feb?7,?2016,?at?1:54?AM,?Peter?<jini at zeus.net.au>?wrote: 
>? 
>?Thanks?Peter?&?David, 
>? 
>?That's?good?to?know. 
>? 
>?I've?altered?the?SecurityManager?to?perform?a?permission?check?prior?to?becoming?the?security?manager,?this?ensures?the?cache?has?been?created,?to?avoid?any?recursive?deadlock?prone?calls. 
>? 
>?The?class?that?both?threads?are?attempting?to?load?and?init?is?called?org.apache.river.concurrent.ReferenceIterator. 
>? 
>?The?code?can?be?found?here: 
>? 
>?https://github.com/pfirmstone/river-internet/tree/Input-validation-for-Serialization 
>? 
>?Cheers, 
>? 
>?Peter 
>? 
>? 
>?On?7/02/2016?6:37?PM,?Peter?Levart?wrote: 
>>? 
>>? 
>>?On?02/06/2016?10:32?PM,?Peter?wrote: 
>>>?The?0x040ebee8?monitor?is?most?likely?being?held?by?native?code. 
>>>? 
>>>?Regards, 
>>>? 
>>>?Peter?Firmstone. 
>>? 
>>?Ok,?but?where??The?deadlock?report?says?it?is?held?by?main?thread.?Somewhere?between?the?following?two?java?frames? 
>>? 
>>?"main"?#1?prio=5?os_prio=0?tid=0x017cf400?nid=0x1284?waiting?for?monitor?entry?[0x0185e000] 
>>?... 
>>?... 
>>????????at?java.lang.ClassLoader.loadClass(ClassLoader.java:357) 
>>?--here-- 
>>????????at?org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>? 
>>? 
>>?As?I?understand?this?is?where?JVM?resolves?some?class?that?for?the?1st?time?while?ReferenceCollection.iterator?is?being?executed.?So?before?calling-back?into?ClassLoader.loadClass,?it?acquires?a?monitor?lock?on?some?int[]?object? 
>>? 
>>? 
>>?Anyway.?Looking?at?the?following?part?of?Thread-1?stacktrace: 
>>? 
>>????????at?org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>????????at?java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447) 
>>????????at?java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158) 
>>????????at?java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137) 
>>????????at?java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526) 
>>????????at?java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266) 
>>????????at?java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070) 
>>????????at?java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535) 
>>? 
>>?...I?can?see?you?are?using?some?early?release?of?JDK?8?where?ThreadLocalRandom?initialization?involved?obtaining?a?hardware?address?of?some?interface.?This?in?turn?checks?for?security?manager.?Since?JDK?8u45?this?code?has?been?removed?and?only?current?time?is?used?to?derive?initial?seed,?so?you?might?not?see?this?deadlock?any?more?with?JDK?8u45?and?later. 
>>? 
>>?Regards,?Peter 
>>? 
>>>? 
>>>? 
>>>?On?7/02/2016?4:27?AM,?Peter?Levart?wrote: 
>>>>? 
>>>>? 
>>>>?On?02/06/2016?01:17?PM,?Peter?Firmstone?wrote: 
>>>>>?The?security?manager?is?non?blocking,?unfortunately?java?system?classes?aren't. 
>>>>? 
>>>>?It?doesn't?seem?so.?At?least,?I?can't?find?where?main?thread?locks?the?0x040ebee8?monitor: 
>>>>? 
>>>>?"Thread-1": 
>>>>??waiting?to?lock?monitor?0x142766ac?(object?0x040ebee8,?a?[I), 
>>>>??which?is?held?by?"main" 
>>>>? 
>>>>? 
>>>>?"main"?#1?prio=5?os_prio=0?tid=0x017cf400?nid=0x1284?waiting?for?monitor?entry?[0x0185e000] 
>>>>???java.lang.Thread.State:?BLOCKED?(on?object?monitor) 
>>>>????????at?java.lang.ClassLoader.loadClass(ClassLoader.java:406) 
>>>>????????-?waiting?to?lock?<0x03f624b8>?(a?java.lang.Object) 
>>>>????????at?sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) 
>>>>????????at?java.lang.ClassLoader.loadClass(ClassLoader.java:357) 
>>>>????????at?org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124) 
>>>>????????at?org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65) 
>>>>????????at?org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44) 
>>>>????????at?org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57) 
>>>>????????at?org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64) 
>>>>????????at?org.apache.river.concurrent.ReferenceProcessorreferenced(ReferenceProcessor.java:128) 
>>>>????????at?org.apache.river.concurrent.ReferenceProcessorreferenced(ReferenceProcessor.java:44) 
>>>>????????at?org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244) 
>>>>????????at?org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68) 
>>>>????????at?org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261) 
>>>>????????at?org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202) 
>>>>????????at?java.lang.System.checkIO(System.java:253) 
>>>>????????at?java.lang.System.setErr(System.java:199) 
>>>>????????at?org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84) 
>>>>? 
>>>>? 
>>>>?...no?mention?of?0x040ebee8?in?main?thread...?! 
>>>>? 
>>>>?Peter 
>>>>? 
>>>>>? 
>>>>>?The?policy?provider?in?use?thread?confines?PermissionCollection?instances,?which?never?leave?the?cpu?cache,?they?are?discarded?immediately?after?use. 
>>>>>? 
>>>>>?The?problem?here?is?that?two?different?threads?are?attempting?to?load?the?same?class?at?the?same?time. 
>>>>>? 
>>>>>?I'll?have?to?make?sure?that?all?classes?are?loaded?before?the?security?manager?becomes?the?system?security?manager,?either?that?or?eliminate?the?AccessControlContext?check?permission?cache. 
>>>>>? 
>>>>>?While?the?standard?java?security?manager?and?policy?provider?consume?around?10%?cpu,?this?consumes?less?than?1%. 
>>>>>? 
>>>>>?On?6/02/2016?9:57?PM,?David?Holmes?wrote: 
>>>>>>?On?6/02/2016?9:39?PM,?Peter?Firmstone?wrote: 
>>>>>>>?Hmm,?thought?the?new?parallel?lock?stategy?in?ClassLoader?wasn't 
>>>>>>>?deadlock?prone???Guess?I?was?wrong. 
>>>>>>? 
>>>>>>?The?deadlock?is?introduced?by?a?custom?security?manager.?SM's?play?a?critical?role?in?many?parts?of?the?core?libraries?so?if?they?utilize?synchronization?then?they?can?easily?introduce?deadlock. 
>>>>>>? 
>>>>>>>?Observation:??On?an?unrelated?occassion,?I?had?a?URLClassLoader 
>>>>>>>?synchronization?hotspot?(well?not?standard?URLClassLoader,?but?a?high 
>>>>>>>?performance?RFC3986?URL?ClassLoader,?that?use?normalized?RFC3986?URI 
>>>>>>>?instead?of?URL?DNS?lookup),?I?solved?that?problem?by?thread?confining 
>>>>>>>?class?loading.??I've?never?experienced?deadlock?using?thread 
>>>>>>>?confinement,?initially?I?was?worried?that?there?would?be 
>>>>>>>?interdependencies,?however?I?didn't?experience?a?problem,?as?the?single 
>>>>>>>?thread?would?always?load?the?classes?it?needed. 
>>>>>>>? 
>>>>>>>?I'm?wondering?if?multiple?locks?for?ClassLoader's?might?be?the?wrong 
>>>>>>>?strategy,?I?found?thread?confinement?was?very?performant. 
>>>>>>? 
>>>>>>?Are?you?suggesting?that?a?class-load?request?is?actually?transmitted?to?a?single?class-loading?thread,?while?the?initial?thread?blocks?until?the?loading?is?complete??That?would?still?seem?prone?to?the?same?SM?related?deadlock?scenario.?And?it?would?not?generally?be?particularly?performant. 
>>>>>? 
>>>>>?I?thought?that?too,?until?I?tried?it. 
>>>>>? 
>>>>>?Would?you?like?to?see?some?performance?figures? 
>>>>>? 
>>>>>?Cheers, 
>>>>>? 
>>>>>?Peter. 
>>>>>? 
>>>>>>? 
>>>>>>?David 
>>>>>>? 
>>>>>>>?Regards, 
>>>>>>>? 
>>>>>>>?Peter. 
>>>>>>>? 
>>>>>>>?2016-02-06?21:06:07 
>>>>>>>?Full?thread?dump?Java?HotSpot(TM)?Client?VM?(25.0-b70?mixed?mode): 
>>>>>>>? 
>>>>>>>?"Service?Thread"?#9?daemon?prio=9?os_prio=0?tid=0x14387400?nid=0xc54 
>>>>>>>?runnable?[0x00000000] 
>>>>>>>????java.lang.Thread.State:?RUNNABLE 
>>>>>>>? 
>>>>>>>?"C1?CompilerThread0"?#8?daemon?prio=9?os_prio=2?tid=0x14332c00 
>>>>>>>?nid=0x111c?waiting?on?condition?[0x00000000] 
>>>>>>>????java.lang.Thread.State:?RUNNABLE 
>>>>>>>? 
>>>>>>>?"Attach?Listener"?#7?daemon?prio=5?os_prio=2?tid=0x14331c00?nid=0x13d8 
>>>>>>>?waiting?on?condition?[0x00000000] 
>>>>>>>????java.lang.Thread.State:?RUNNABLE 
>>>>>>>? 
>>>>>>>?"Signal?Dispatcher"?#6?daemon?prio=9?os_prio=2?tid=0x14331400?nid=0x10b8 
>>>>>>>?runnable?[0x00000000] 
>>>>>>>????java.lang.Thread.State:?RUNNABLE 
>>>>>>>? 
>>>>>>>?"Thread-1"?#5?prio=10?os_prio=2?tid=0x14318800?nid=0x4a8?waiting?for 
>>>>>>>?monitor?entry?[0x03ded000] 
>>>>>>>????java.lang.Thread.State:?BLOCKED?(on?object?monitor) 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447)? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137)? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070)? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535)? 
>>>>>>>? 
>>>>>>>?????????at?java.lang.ClassLoader.getClassLoadingLock(ClassLoader.java:463) 
>>>>>>>?????????at?java.lang.ClassLoader.loadClass(ClassLoader.java:404) 
>>>>>>>?????????at?java.lang.ClassLoader.loadClass(ClassLoader.java:411) 
>>>>>>>?????????-?locked?<0x03f624b8>?(a?java.lang.Object) 
>>>>>>>?????????at?sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) 
>>>>>>>?????????at?java.lang.ClassLoader.loadClass(ClassLoader.java:357) 
>>>>>>>?????????at 
>>>>>>>?org.cliffc.high_scale_lib.NonBlockingHashMap$SnapshotK.<init>(NonBlockingHashMap.java:1167)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.cliffc.high_scale_lib.NonBlockingHashMap$2.iterator(NonBlockingHashMap.java:1200)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceProcessor$EnqueGarbageTask.run(ReferenceProcessor.java:166)? 
>>>>>>>? 
>>>>>>>?????????-?locked?<0x03ef8b30>?(a 
>>>>>>>?org.cliffc.high_scale_lib.NonBlockingHashMap)
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.j? 
>>>>>>>? 
>>>>>>>?ava:180) 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294? 
>>>>>>>? 
>>>>>>>?) 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutorjava:617)? 
>>>>>>>? 
>>>>>>>?????????at?java.lang.Thread.run(Thread.java:744) 
>>>>>>>? 
>>>>>>>?"Finalizer"?#3?daemon?prio=8?os_prio=1?tid=0x14277800?nid=0x15cc?in 
>>>>>>>?Object.wait()?[0x03cff000] 
>>>>>>>????java.lang.Thread.State:?WAITING?(on?object?monitor) 
>>>>>>>?????????at?java.lang.Object.wait(Native?Method) 
>>>>>>>?????????-?waiting?on?<0x03e056d8>?(a?java.lang.ref.ReferenceQueue$Lock) 
>>>>>>>?????????at?java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:142) 
>>>>>>>?????????-?locked?<0x03e056d8>?(a?java.lang.ref.ReferenceQueue$Lock) 
>>>>>>>?????????at?java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:158) 
>>>>>>>?????????at?java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209) 
>>>>>>>? 
>>>>>>>?"Reference?Handler"?#2?daemon?prio=10?os_prio=2?tid=0x14271c00 
>>>>>>>?nid=0x1398?in?Object.wait()?[0x144cf000] 
>>>>>>>????java.lang.Thread.State:?WAITING?(on?object?monitor) 
>>>>>>>?????????at?java.lang.Object.wait(Native?Method) 
>>>>>>>?????????-?waiting?on?<0x03e05200>?(a?java.lang.ref.Reference$Lock) 
>>>>>>>?????????at?java.lang.Object.wait(Object.java:502) 
>>>>>>>?????????at 
>>>>>>>?java.lang.ref.Reference$ReferenceHandler.run(Reference.java:157) 
>>>>>>>?????????-?locked?<0x03e05200>?(a?java.lang.ref.Reference$Lock) 
>>>>>>>? 
>>>>>>>?"main"?#1?prio=5?os_prio=0?tid=0x017cf400?nid=0x1284?waiting?for?monitor 
>>>>>>>?entry?[0x0185e000] 
>>>>>>>????java.lang.Thread.State:?BLOCKED?(on?object?monitor) 
>>>>>>>?????????at?java.lang.ClassLoader.loadClass(ClassLoaderjava:406) 
>>>>>>>?????????-?waiting?to?lock?<0x03f624b8>?(a?java.lang.Object) 
>>>>>>>?????????at?sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) 
>>>>>>>?????????at?java.lang.ClassLoader.loadClass(ClassLoader.java:357) 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceCollectioniterator(ReferenceCollection.java:124)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.StrongReference.<init>(StrongReferencejava:44)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessorjava:128)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202)? 
>>>>>>>? 
>>>>>>>?????????at?java.lang.System.checkIO(System.java:253) 
>>>>>>>?????????at?java.lang.System.setErr(System.java:199) 
>>>>>>>?????????at?org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84) 
>>>>>>>? 
>>>>>>>?"VM?Thread"?os_prio=2?tid=0x1426e400?nid=0x16a8?runnable 
>>>>>>>? 
>>>>>>>?"VM?Periodic?Task?Thread"?os_prio=2?tid=0x14388400?nid=0x17a8?waiting?on 
>>>>>>>?condition 
>>>>>>>? 
>>>>>>>?JNI?global?references:?19 
>>>>>>>? 
>>>>>>>? 
>>>>>>>?Found?one?Java-level?deadlock: 
>>>>>>>?============================= 
>>>>>>>?"Thread-1": 
>>>>>>>???waiting?to?lock?monitor?0x142766ac?(object?0x040ebee8,?a?[I), 
>>>>>>>???which?is?held?by?"main" 
>>>>>>>?"main": 
>>>>>>>???waiting?to?lock?monitor?0x14274a3c?(object?0x03f624b8,?a 
>>>>>>>?java.lang.Object), 
>>>>>>>???which?is?held?by?"Thread-1" 
>>>>>>>? 
>>>>>>>?Java?stack?information?for?the?threads?listed?above: 
>>>>>>>?=================================================== 
>>>>>>>?"Thread-1": 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceFactory.create(ReferenceFactory.java:64)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?java.net.NetworkInterface.getHardwareAddress(NetworkInterface.java:447)? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ThreadLocalRandom.initialSeed(ThreadLocalRandom.java:158)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ThreadLocalRandom.<clinit>(ThreadLocalRandom.java:137)? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ConcurrentHashMap.fullAddCount(ConcurrentHashMap.java:2526)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2266)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1070)? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535)? 
>>>>>>>? 
>>>>>>>?????????at?java.lang.ClassLoader.getClassLoadingLock(ClassLoader.java:463) 
>>>>>>>?????????at?java.lang.ClassLoader.loadClass(ClassLoader.java:404) 
>>>>>>>?????????at?java.lang.ClassLoader.loadClass(ClassLoader.java:411) 
>>>>>>>?????????-?locked?<0x03f624b8>?(a?java.lang.Object) 
>>>>>>>?????????at?sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) 
>>>>>>>?????????at?java.lang.ClassLoader.loadClass(ClassLoaderjava:357) 
>>>>>>>?????????at 
>>>>>>>?org.cliffc.high_scale_lib.NonBlockingHashMap$SnapshotK.<init>(NonBlockingHashMap.java:1167)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.cliffc.high_scale_lib.NonBlockingHashMap$2.iterator(NonBlockingHashMap.java:1200)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceProcessor$EnqueGarbageTask.run(ReferenceProcessor.java:166)? 
>>>>>>>? 
>>>>>>>?????????-?locked?<0x03ef8b30>?(a 
>>>>>>>?org.cliffc.high_scale_lib.NonBlockingHashMap)
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.j? 
>>>>>>>? 
>>>>>>>?ava:180) 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294? 
>>>>>>>? 
>>>>>>>?) 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)? 
>>>>>>>? 
>>>>>>>?????????at?java.lang.Thread.run(Thread.java:744) 
>>>>>>>?"main": 
>>>>>>>?????????at?java.lang.ClassLoader.loadClass(ClassLoader.java:406) 
>>>>>>>?????????-?waiting?to?lock?<0x03f624b8>?(a?java.lang.Object) 
>>>>>>>?????????at?sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) 
>>>>>>>?????????at?java.lang.ClassLoader.loadClass(ClassLoader.java:357) 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceCollection.iterator(ReferenceCollection.java:124)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceSet.hashCode(ReferenceSet.java:65)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:44)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.StrongReference.<init>(StrongReference.java:57)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceFactorycreate(ReferenceFactory.java:64)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:128)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceProcessor.referenced(ReferenceProcessor.java:44)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceMap.wrapVal(ReferenceMap.java:244)? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.concurrent.ReferenceConcurrentMap.putIfAbsent(ReferenceConcurrentMap.java:68)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:261)? 
>>>>>>>? 
>>>>>>>?????????at 
>>>>>>>?org.apache.river.api.security.CombinerSecurityManager.checkPermission(CombinerSecurityManager.java:202)? 
>>>>>>>? 
>>>>>>>?????????at?java.lang.System.checkIO(System.java:253) 
>>>>>>>?????????at?java.lang.System.setErr(System.java:199) 
>>>>>>>?????????at?org.apache.river.qa.harness.MasterTest.main(MasterTest.java:84) 
>>>>>>>? 
>>>>>>>?Found?1?deadlock. 
>>>>>? 
>>>>? 
>>>>? 
>>>>?_______________________________________________ 
>>>>?Concurrency-interest?mailing?list 
>>>>?Concurrency-interest at cs.oswego.edu 
>>>>?http://cs.oswego.edu/mailman/listinfo/concurrency-interest 
>>>? 
>>? 
>? 
>?_______________________________________________ 
>?Concurrency-interest?mailing?list 
>?Concurrency-interest at cs.oswego.edu 
>?http://cs.oswego.edu/mailman/listinfo/concurrency-interest 


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160209/80a32497/attachment-0001.html>

From viktor.klang at gmail.com  Thu Feb 11 06:57:24 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 11 Feb 2016 12:57:24 +0100
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56B86751.5050003@bbs.darktech.org>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B65B01.7050508@cs.oswego.edu>
	<56B85443.1000101@bbs.darktech.org>
	<CANPzfU9oQbOQvKgsykPRCNHJYcWJVKy-ZfE6sHdHnm_8z=nOKw@mail.gmail.com>
	<56B86751.5050003@bbs.darktech.org>
Message-ID: <CANPzfU-jjfwmn1FPAu9DA5KF2FT8Yb+X7euDvkA2UP23igafFQ@mail.gmail.com>

Haven't had time to think about this yet.

I think in general it is best to model the task in terms of dependency
rather than tweaking the execution engine to get the effect you want.

-- 
Cheers,
?
On Feb 8, 2016 11:00 AM, "cowwoc" <cowwoc at bbs.darktech.org> wrote:

> You're still vulnerable to the same race condition:
>
>    1. [main] Invokes ForkJoinPool.execute(task)
>    2. [WorkerThread] Finishes running a task, reaches the point
>    immediately before deregisterThread() at
>    https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L61
>    3. [main] ForkJoinPool invokes tryAddWorker(),
>    https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L65
>    returns null
>    4. [WorkerThread] Invokes deregisterThread().
>
> Now we have an enqueued task, no worker threads and no one is trying to
> spin up a new thread.
>
> Gili
> On 2016-02-08 4:53 AM, Viktor Klang wrote:
>
> I was thinking something along the lines of this:
>
>
> https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L65
>
> https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L68
>
> (no need for WeakReferences to Threads, synchronized etc)
>
> On Mon, Feb 8, 2016 at 8:47 AM, cowwoc <cowwoc at bbs.darktech.org> wrote:
>
>> So, it turns out this solution isn't actually safe.
>>
>> 1. I used the following thread factory:
>>
>>                 ForkJoinWorkerThreadFactory factory = new
>> ForkJoinWorkerThreadFactory()
>>                 {
>>                     private WeakReference<Thread> currentWorker = new
>> WeakReference<>(null);
>>
>>                     @Override
>>                     public synchronized ForkJoinWorkerThread
>> newThread(ForkJoinPool pool)
>>                     {
>>                         // If the pool already has a live thread, return
>> null.
>>                         Thread thread = currentWorker.get();
>>                         if (thread != null && thread.isAlive())
>>                         {
>>                             System.out.println("Thread: " +
>> thread.getName() + " is already alive, returning null.");
>>                             return null;
>>                         }
>>                         ForkJoinWorkerThread result = new
>> MyForkJoinWorkerThread(pool);
>>                         currentWorker = new WeakReference<>(result);
>>                         // According to Doug Lea this will reduce the
>> probability of short livelocks
>>                         Thread.yield();
>>                         return result;
>>                     }
>>                 };
>>
>> 2. I started a debugging session.
>> 3. I suspended all threads long enough for the worker thread to get
>> flagged as idle (approximately 10 seconds).
>> 4. I allowed all threads to continue execution.
>> 5. Upon resuming, the worker thread shut down and at the same time the
>> factory printed "Thread: X is already alive, returning null."
>> 6. If I run the above scenario without suspending all threads (only
>> suspending the "main" thread) then the worker thread shuts down, I resume
>> execution, and a new worker thread spins up.
>>
>> In other words, the proposed solution is vulnerable to a race condition.
>>
>> Gili
>>
>> On 2016-02-06 9:35 PM, cowwoc wrote:
>>
>> Thanks Doug, I'll give this a try.
>>
>> Thanks,
>> Gili
>>
>> On 2016-02-06 3:02 PM, Doug Lea [via JSR166 Concurrency] wrote:
>>
>> On 02/06/2016 05:21 AM, Viktor Klang wrote:
>> > What happens if you supply it with a thread factory which only allows a
>> single
>> > thread to be alive at a time, and returns null if it already has
>> returned a
>> > still living thread?
>> >
>>
>> Yes, this will work if you are positive that only one thread
>> is required for liveness. FJ sometimes conservatively creates
>> threads when it cannot itself guarantee liveness (for example,
>> when GC or other system load causes stalls). But it will
>> respond to null factory returns by rechecking, not failing.
>> unless a thread really is needed to maintain liveness, in which
>> case the program may livelock. To reduce transient near-livelock,
>> you might want to place a Thread.yield() call before the
>> "return null" in the factory.
>>
>> -Doug
>>
>>
>> > --
>> > Cheers,
>> > ?
>> >
>> > On Feb 6, 2016 05:19, "cowwoc" <[hidden email]
>> <http:///user/SendEmail.jtp?type=node&node=13243&i=0>
>> > <mailto:[hidden email]
>> <http:///user/SendEmail.jtp?type=node&node=13243&i=1>>> wrote:
>> >
>> >     Hi,
>> >
>> >     Is this the correct mailing list for discussing ForkJoinPool in
>> JDK9? If
>> >     not, please point me to the right place.
>> >
>> >     I have a feature request for ForkJoinPool which doesn't seem to be
>> possible
>> >     to implement without a JDK change:
>> http://stackoverflow.com/q/34012134/14731
>> >
>> >     Specifically, I need to be able to an application that uses Random
>> and
>> >     ForkJoinPool in a deterministic manner when debugging/profiling but
>> run
>> >     full-speed in normal execution mode. I have all the moving parts
>> nailing
>> >     down except for ForkJoinPool.
>> >
>> >     If I create ForkJoinPool with a parallelism of 1, sometimes I see
>> two worker
>> >     threads getting used. I am guessing that this is caused by
>> >     ForkJoinTask.get() invoking
>> ForkJoinPool.common.externalHelpComplete(), but
>> >     maybe something else is going on.
>> >
>> >     Is there a way for me to guarantee that ForkJoinThread will use
>> exactly 1
>> >     worker thread, no less, no more? Would you like me to file a formal
>> feature
>> >     request?
>> >
>> >     Thank you,
>> >     Gili
>> >
>> >
>> >
>> >     --
>> >     View this message in context:
>> >
>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>> >     Sent from the JSR166 Concurrency mailing list archive at
>> Nabble.com.
>> >     _______________________________________________
>> >     Concurrency-interest mailing list
>> >     [hidden email]
>> <http:///user/SendEmail.jtp?type=node&node=13243&i=2> <mailto:[hidden
>> email] <http:///user/SendEmail.jtp?type=node&node=13243&i=3>>
>> >     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > [hidden email] <http:///user/SendEmail.jtp?type=node&node=13243&i=4>
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> [hidden email] <http:///user/SendEmail.jtp?type=node&node=13243&i=5>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> ------------------------------
>> If you reply to this email, your message will be added to the discussion
>> below:
>>
>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13243.html
>> To unsubscribe from Single-threaded ForkJoinPool, click here.
>> NAML
>> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml>
>>
>>
>>
>>
>> ------------------------------
>> View this message in context: Re: Single-threaded ForkJoinPool
>> <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13250.html>
>>
>> Sent from the JSR166 Concurrency mailing list archive
>> <http://jsr166-concurrency.10961.n7.nabble.com/> at Nabble.com.
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> --
> Cheers,
> ?
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160211/19c34b48/attachment-0001.html>

From dl at cs.oswego.edu  Thu Feb 11 09:28:30 2016
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 11 Feb 2016 09:28:30 -0500
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <CANPzfU-jjfwmn1FPAu9DA5KF2FT8Yb+X7euDvkA2UP23igafFQ@mail.gmail.com>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B65B01.7050508@cs.oswego.edu> <56B85443.1000101@bbs.darktech.org>
	<CANPzfU9oQbOQvKgsykPRCNHJYcWJVKy-ZfE6sHdHnm_8z=nOKw@mail.gmail.com>
	<56B86751.5050003@bbs.darktech.org>
	<CANPzfU-jjfwmn1FPAu9DA5KF2FT8Yb+X7euDvkA2UP23igafFQ@mail.gmail.com>
Message-ID: <56BC9A8E.5070102@cs.oswego.edu>

On 02/11/2016 06:57 AM, Viktor Klang wrote:
> Haven't had time to think about this yet.

In his case, one way to force race outcome is for the factory
to join the existing single thread before returning it. This
is not in general a good practice of course...

-Doug



>
> I think in general it is best to model the task in terms of dependency rather
> than tweaking the execution engine to get the effect you want.
>
> --
> Cheers,
> ?
>
> On Feb 8, 2016 11:00 AM, "cowwoc" <cowwoc at bbs.darktech.org
> <mailto:cowwoc at bbs.darktech.org>> wrote:
>
>     You're still vulnerable to the same race condition:
>
>      1. [main] Invokes ForkJoinPool.execute(task)
>      2. [WorkerThread] Finishes running a task, reaches the point immediately
>         before deregisterThread() at
>         https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L61
>      3. [main] ForkJoinPool invokes tryAddWorker(),
>         https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L65
>         returns null
>      4. [WorkerThread] Invokes deregisterThread().
>
>     Now we have an enqueued task, no worker threads and no one is trying to spin
>     up a new thread.
>
>     Gili
>
>     On 2016-02-08 4:53 AM, Viktor Klang wrote:
>>     I was thinking something along the lines of this:
>>
>>     https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L65
>>     https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L68
>>
>>     (no need for WeakReferences to Threads, synchronized etc)
>>
>>     On Mon, Feb 8, 2016 at 8:47 AM, cowwoc <cowwoc at bbs.darktech.org
>>     <mailto:cowwoc at bbs.darktech.org>> wrote:
>>
>>         So, it turns out this solution isn't actually safe.
>>
>>         1. I used the following thread factory:
>>
>>                         ForkJoinWorkerThreadFactory factory = new
>>         ForkJoinWorkerThreadFactory()
>>                         {
>>                             private WeakReference<Thread> currentWorker = new
>>         WeakReference<>(null);
>>
>>                             @Override
>>                             public synchronized ForkJoinWorkerThread
>>         newThread(ForkJoinPool pool)
>>                             {
>>                                 // If the pool already has a live thread,
>>         return null.
>>                                 Thread thread = currentWorker.get();
>>                                 if (thread != null && thread.isAlive())
>>                                 {
>>                                     System.out.println("Thread: " +
>>         thread.getName() + " is already alive, returning null.");
>>                                     return null;
>>                                 }
>>                                 ForkJoinWorkerThread result = new
>>         MyForkJoinWorkerThread(pool);
>>                                 currentWorker = new WeakReference<>(result);
>>                                 // According to Doug Lea this will reduce the
>>         probability of short livelocks
>>                                 Thread.yield();
>>                                 return result;
>>                             }
>>                         };
>>
>>         2. I started a debugging session.
>>         3. I suspended all threads long enough for the worker thread to get
>>         flagged as idle (approximately 10 seconds).
>>         4. I allowed all threads to continue execution.
>>         5. Upon resuming, the worker thread shut down and at the same time the
>>         factory printed "Thread: X is already alive, returning null."
>>         6. If I run the above scenario without suspending all threads (only
>>         suspending the "main" thread) then the worker thread shuts down, I
>>         resume execution, and a new worker thread spins up.
>>
>>         In other words, the proposed solution is vulnerable to a race condition.
>>
>>         Gili
>>
>>         On 2016-02-06 9:35 PM, cowwoc wrote:
>>>         Thanks Doug, I'll give this a try.
>>>
>>>         Thanks,
>>>         Gili
>>>
>>>         On 2016-02-06 3:02 PM, Doug Lea [via JSR166 Concurrency] wrote:
>>>>         On 02/06/2016 05:21 AM, Viktor Klang wrote:
>>>>         > What happens if you supply it with a thread factory which only
>>>>         allows a single
>>>>         > thread to be alive at a time, and returns null if it already has
>>>>         returned a
>>>>         > still living thread?
>>>>         >
>>>>
>>>>         Yes, this will work if you are positive that only one thread
>>>>         is required for liveness. FJ sometimes conservatively creates
>>>>         threads when it cannot itself guarantee liveness (for example,
>>>>         when GC or other system load causes stalls). But it will
>>>>         respond to null factory returns by rechecking, not failing.
>>>>         unless a thread really is needed to maintain liveness, in which
>>>>         case the program may livelock. To reduce transient near-livelock,
>>>>         you might want to place a Thread.yield() call before the
>>>>         "return null" in the factory.
>>>>
>>>>         -Doug
>>>>
>>>>
>>>>         > --
>>>>         > Cheers,
>>>>         > ?
>>>>         >
>>>>         > On Feb 6, 2016 05:19, "cowwoc" <[hidden email]
>>>>         <http:///user/SendEmail.jtp?type=node&node=13243&i=0>
>>>>         > <mailto:[hidden email]
>>>>         <http:///user/SendEmail.jtp?type=node&node=13243&i=1>>> wrote:
>>>>         >
>>>>         >     Hi,
>>>>         >
>>>>         >     Is this the correct mailing list for discussing ForkJoinPool
>>>>         in JDK9? If
>>>>         >     not, please point me to the right place.
>>>>         >
>>>>         >     I have a feature request for ForkJoinPool which doesn't seem
>>>>         to be possible
>>>>         >     to implement without a JDK change:
>>>>         <http://stackoverflow.com/q/34012134/14731>http://stackoverflow.com/q/34012134/14731
>>>>         >
>>>>         >     Specifically, I need to be able to an application that uses
>>>>         Random and
>>>>         >     ForkJoinPool in a deterministic manner when
>>>>         debugging/profiling but run
>>>>         >     full-speed in normal execution mode. I have all the moving
>>>>         parts nailing
>>>>         >     down except for ForkJoinPool.
>>>>         >
>>>>         >     If I create ForkJoinPool with a parallelism of 1, sometimes I
>>>>         see two worker
>>>>         >     threads getting used. I am guessing that this is caused by
>>>>         >     ForkJoinTask.get() invoking
>>>>         ForkJoinPool.common.externalHelpComplete(), but
>>>>         >     maybe something else is going on.
>>>>         >
>>>>         >     Is there a way for me to guarantee that ForkJoinThread will
>>>>         use exactly 1
>>>>         >     worker thread, no less, no more? Would you like me to file a
>>>>         formal feature
>>>>         >     request?
>>>>         >
>>>>         >     Thank you,
>>>>         >     Gili
>>>>         >
>>>>         >
>>>>         >
>>>>         >     --
>>>>         >     View this message in context:
>>>>         >
>>>>         http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>>>>         >     Sent from the JSR166 Concurrency mailing list archive at
>>>>         Nabble.com.
>>>>         > _______________________________________________
>>>>         >     Concurrency-interest mailing list
>>>>         > [hidden email]
>>>>         <http:///user/SendEmail.jtp?type=node&node=13243&i=2>
>>>>         <mailto:[hidden email]
>>>>         <http:///user/SendEmail.jtp?type=node&node=13243&i=3>>
>>>>         >
>>>>         <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>         >
>>>>         >
>>>>         >
>>>>         > _______________________________________________
>>>>         > Concurrency-interest mailing list
>>>>         > [hidden email] <http:///user/SendEmail.jtp?type=node&node=13243&i=4>
>>>>         > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>         >
>>>>
>>>>
>>>>
>>>>         _______________________________________________
>>>>         Concurrency-interest mailing list
>>>>         [hidden email] <http:///user/SendEmail.jtp?type=node&node=13243&i=5>
>>>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>         --------------------------------------------------------------------------------
>>>>         If you reply to this email, your message will be added to the
>>>>         discussion below:
>>>>         http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13243.html
>>>>
>>>>         To unsubscribe from Single-threaded ForkJoinPool, click here.
>>>>         NAML
>>>>         <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml>
>>>>
>>>
>>
>>
>>         --------------------------------------------------------------------------------
>>         View this message in context: Re: Single-threaded ForkJoinPool
>>         <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13250.html>
>>
>>
>>         Sent from the JSR166 Concurrency mailing list archive
>>         <http://jsr166-concurrency.10961.n7.nabble.com/> at Nabble.com.
>>
>>         _______________________________________________
>>         Concurrency-interest mailing list
>>         Concurrency-interest at cs.oswego.edu
>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>>
>>     --
>>     Cheers,
>>     ?
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>




From cowwoc at bbs.darktech.org  Thu Feb 11 08:57:12 2016
From: cowwoc at bbs.darktech.org (cowwoc)
Date: Thu, 11 Feb 2016 06:57:12 -0700 (MST)
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56BC9A8E.5070102@cs.oswego.edu>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B65B01.7050508@cs.oswego.edu>
	<56B85443.1000101@bbs.darktech.org>
	<CANPzfU9oQbOQvKgsykPRCNHJYcWJVKy-ZfE6sHdHnm_8z=nOKw@mail.gmail.com>
	<56B86751.5050003@bbs.darktech.org>
	<CANPzfU-jjfwmn1FPAu9DA5KF2FT8Yb+X7euDvkA2UP23igafFQ@mail.gmail.com>
	<56BC9A8E.5070102@cs.oswego.edu>
Message-ID: <56BC9F7C.60204@bbs.darktech.org>

Not a bad idea :) I'll give it a try.

Gili

On 2016-02-11 8:46 AM, Doug Lea [via JSR166 Concurrency] wrote:
> On 02/11/2016 06:57 AM, Viktor Klang wrote:
> > Haven't had time to think about this yet.
>
> In his case, one way to force race outcome is for the factory
> to join the existing single thread before returning it. This
> is not in general a good practice of course...
>
> -Doug
>
>
>
> >
> > I think in general it is best to model the task in terms of 
> dependency rather
> > than tweaking the execution engine to get the effect you want.
> >
> > --
> > Cheers,
> > ?
> >
> > On Feb 8, 2016 11:00 AM, "cowwoc" <[hidden email] 
> </user/SendEmail.jtp?type=node&node=13260&i=0>
> > <mailto:[hidden email] 
> </user/SendEmail.jtp?type=node&node=13260&i=1>>> wrote:
> >
> >     You're still vulnerable to the same race condition:
> >
> >      1. [main] Invokes ForkJoinPool.execute(task)
> >      2. [WorkerThread] Finishes running a task, reaches the point 
> immediately
> >         before deregisterThread() at
> > 
> https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L61
> >      3. [main] ForkJoinPool invokes tryAddWorker(),
> > 
> https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L65
> >         returns null
> >      4. [WorkerThread] Invokes deregisterThread().
> >
> >     Now we have an enqueued task, no worker threads and no one is 
> trying to spin
> >     up a new thread.
> >
> >     Gili
> >
> >     On 2016-02-08 4:53 AM, Viktor Klang wrote:
> >>     I was thinking something along the lines of this:
> >>
> >> 
> https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L65
> >> 
> https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L68
> >>
> >>     (no need for WeakReferences to Threads, synchronized etc)
> >>
> >>     On Mon, Feb 8, 2016 at 8:47 AM, cowwoc <[hidden email] 
> </user/SendEmail.jtp?type=node&node=13260&i=2>
> >>     <mailto:[hidden email] 
> </user/SendEmail.jtp?type=node&node=13260&i=3>>> wrote:
> >>
> >>         So, it turns out this solution isn't actually safe.
> >>
> >>         1. I used the following thread factory:
> >>
> >>                         ForkJoinWorkerThreadFactory factory = new
> >>         ForkJoinWorkerThreadFactory()
> >>                         {
> >>                             private WeakReference<Thread> 
> currentWorker = new
> >>         WeakReference<>(null);
> >>
> >>                             @Override
> >>                             public synchronized ForkJoinWorkerThread
> >>         newThread(ForkJoinPool pool)
> >>                             {
> >>                                 // If the pool already has a live 
> thread,
> >>         return null.
> >>                                 Thread thread = currentWorker.get();
> >>                                 if (thread != null && 
> thread.isAlive())
> >>                                 {
> >> System.out.println("Thread: " +
> >>         thread.getName() + " is already alive, returning null.");
> >>                                     return null;
> >>                                 }
> >>                                 ForkJoinWorkerThread result = new
> >>         MyForkJoinWorkerThread(pool);
> >>                                 currentWorker = new 
> WeakReference<>(result);
> >>                                 // According to Doug Lea this will 
> reduce the
> >>         probability of short livelocks
> >>                                 Thread.yield();
> >>                                 return result;
> >>                             }
> >>                         };
> >>
> >>         2. I started a debugging session.
> >>         3. I suspended all threads long enough for the worker 
> thread to get
> >>         flagged as idle (approximately 10 seconds).
> >>         4. I allowed all threads to continue execution.
> >>         5. Upon resuming, the worker thread shut down and at the 
> same time the
> >>         factory printed "Thread: X is already alive, returning null."
> >>         6. If I run the above scenario without suspending all 
> threads (only
> >>         suspending the "main" thread) then the worker thread shuts 
> down, I
> >>         resume execution, and a new worker thread spins up.
> >>
> >>         In other words, the proposed solution is vulnerable to a 
> race condition.
> >>
> >>         Gili
> >>
> >>         On 2016-02-06 9:35 PM, cowwoc wrote:
> >>>         Thanks Doug, I'll give this a try.
> >>>
> >>>         Thanks,
> >>>         Gili
> >>>
> >>>         On 2016-02-06 3:02 PM, Doug Lea [via JSR166 Concurrency] 
> wrote:
> >>>>         On 02/06/2016 05:21 AM, Viktor Klang wrote:
> >>>>         > What happens if you supply it with a thread factory 
> which only
> >>>>         allows a single
> >>>>         > thread to be alive at a time, and returns null if it 
> already has
> >>>>         returned a
> >>>>         > still living thread?
> >>>>         >
> >>>>
> >>>>         Yes, this will work if you are positive that only one thread
> >>>>         is required for liveness. FJ sometimes conservatively 
> creates
> >>>>         threads when it cannot itself guarantee liveness (for 
> example,
> >>>>         when GC or other system load causes stalls). But it will
> >>>>         respond to null factory returns by rechecking, not failing.
> >>>>         unless a thread really is needed to maintain liveness, in 
> which
> >>>>         case the program may livelock. To reduce transient 
> near-livelock,
> >>>>         you might want to place a Thread.yield() call before the
> >>>>         "return null" in the factory.
> >>>>
> >>>>         -Doug
> >>>>
> >>>>
> >>>>         > --
> >>>>         > Cheers,
> >>>>         > ?
> >>>>         >
> >>>>         > On Feb 6, 2016 05:19, "cowwoc" <[hidden email]
> >>>>         <http:///user/SendEmail.jtp?type=node&node=13243&i=0>
> >>>>         > <mailto:[hidden email]
> >>>>         <http:///user/SendEmail.jtp?type=node&node=13243&i=1>>> 
> wrote:
> >>>>         >
> >>>>         >     Hi,
> >>>>         >
> >>>>         >     Is this the correct mailing list for discussing 
> ForkJoinPool
> >>>>         in JDK9? If
> >>>>         >     not, please point me to the right place.
> >>>>         >
> >>>>         >     I have a feature request for ForkJoinPool which 
> doesn't seem
> >>>>         to be possible
> >>>>         >     to implement without a JDK change:
> >>>>         
> <http://stackoverflow.com/q/34012134/14731>http://stackoverflow.com/q/34012134/14731
> >>>>         >
> >>>>         >     Specifically, I need to be able to an application 
> that uses
> >>>>         Random and
> >>>>         >     ForkJoinPool in a deterministic manner when
> >>>>         debugging/profiling but run
> >>>>         >     full-speed in normal execution mode. I have all the 
> moving
> >>>>         parts nailing
> >>>>         >     down except for ForkJoinPool.
> >>>>         >
> >>>>         >     If I create ForkJoinPool with a parallelism of 1, 
> sometimes I
> >>>>         see two worker
> >>>>         >     threads getting used. I am guessing that this is 
> caused by
> >>>>         >     ForkJoinTask.get() invoking
> >>>> ForkJoinPool.common.externalHelpComplete(), but
> >>>>         >     maybe something else is going on.
> >>>>         >
> >>>>         >     Is there a way for me to guarantee that 
> ForkJoinThread will
> >>>>         use exactly 1
> >>>>         >     worker thread, no less, no more? Would you like me 
> to file a
> >>>>         formal feature
> >>>>         >     request?
> >>>>         >
> >>>>         >     Thank you,
> >>>>         >     Gili
> >>>>         >
> >>>>         >
> >>>>         >
> >>>>         >     --
> >>>>         >     View this message in context:
> >>>>         >
> >>>> 
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
> >>>>         >     Sent from the JSR166 Concurrency mailing list 
> archive at
> >>>>         Nabble.com.
> >>>>         > _______________________________________________
> >>>>         >     Concurrency-interest mailing list
> >>>>         > [hidden email]
> >>>>         <http:///user/SendEmail.jtp?type=node&node=13243&i=2>
> >>>>         <mailto:[hidden email]
> >>>>         <http:///user/SendEmail.jtp?type=node&node=13243&i=3>>
> >>>>         >
> >>>>         
> <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>         >
> >>>>         >
> >>>>         >
> >>>>         > _______________________________________________
> >>>>         > Concurrency-interest mailing list
> >>>>         > [hidden email] 
> <http:///user/SendEmail.jtp?type=node&node=13243&i=4>
> >>>>         > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>         >
> >>>>
> >>>>
> >>>>
> >>>> _______________________________________________
> >>>>         Concurrency-interest mailing list
> >>>>         [hidden email] 
> <http:///user/SendEmail.jtp?type=node&node=13243&i=5>
> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>
> >>>>
> >>>> 
> --------------------------------------------------------------------------------
> >>>>         If you reply to this email, your message will be added to 
> the
> >>>>         discussion below:
> >>>> 
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13243.html
> >>>>
> >>>>         To unsubscribe from Single-threaded ForkJoinPool, click 
> here.
> >>>>         NAML
> >>>>         
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>
> >>>>
> >>>
> >>
> >>
> >> 
> --------------------------------------------------------------------------------
> >>         View this message in context: Re: Single-threaded ForkJoinPool
> >>         
> <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13250.html> 
>
> >>
> >>
> >>         Sent from the JSR166 Concurrency mailing list archive
> >>         <http://jsr166-concurrency.10961.n7.nabble.com/> at 
> Nabble.com.
> >>
> >>         _______________________________________________
> >>         Concurrency-interest mailing list
> >> [hidden email] </user/SendEmail.jtp?type=node&node=13260&i=4>
> >>         <mailto:[hidden email] 
> </user/SendEmail.jtp?type=node&node=13260&i=5>>
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >>
> >>
> >>
> >>     --
> >>     Cheers,
> >>     ?
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > [hidden email] </user/SendEmail.jtp?type=node&node=13260&i=6>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> [hidden email] </user/SendEmail.jtp?type=node&node=13260&i=7>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------------------------------------------------
> If you reply to this email, your message will be added to the 
> discussion below:
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13260.html 
>
> To unsubscribe from Single-threaded ForkJoinPool, click here 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=unsubscribe_by_code&node=13232&code=Y293d29jQGJicy5kYXJrdGVjaC5vcmd8MTMyMzJ8MTU3NDMyMTI0Nw==>.
> NAML 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13261.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160211/01878d01/attachment-0001.html>

From cowwoc at bbs.darktech.org  Thu Feb 11 23:35:46 2016
From: cowwoc at bbs.darktech.org (cowwoc)
Date: Thu, 11 Feb 2016 21:35:46 -0700 (MST)
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56BC9A8E.5070102@cs.oswego.edu>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B65B01.7050508@cs.oswego.edu>
	<56B85443.1000101@bbs.darktech.org>
	<CANPzfU9oQbOQvKgsykPRCNHJYcWJVKy-ZfE6sHdHnm_8z=nOKw@mail.gmail.com>
	<56B86751.5050003@bbs.darktech.org>
	<CANPzfU-jjfwmn1FPAu9DA5KF2FT8Yb+X7euDvkA2UP23igafFQ@mail.gmail.com>
	<56BC9A8E.5070102@cs.oswego.edu>
Message-ID: <56BD6D67.505@bbs.darktech.org>

Doug,

As an aside, do you plan on fixing tryAddWorker() so it retries 
launching a new thread if one is still needed? Your workaround will 
probably work for me, but the current implementation is still vulnerable 
to race conditions if the thread factory ever runs null. This could 
impact people with different use-cases than my own, where it doesn't 
make sense to join on the existing thread.

Gili

On 2016-02-11 9:49 AM, cowwoc wrote:
> Not a bad idea :) I'll give it a try.
>
> Gili
>
> On 2016-02-11 8:46 AM, Doug Lea [via JSR166 Concurrency] wrote:
>> On 02/11/2016 06:57 AM, Viktor Klang wrote:
>> > Haven't had time to think about this yet.
>>
>> In his case, one way to force race outcome is for the factory
>> to join the existing single thread before returning it. This
>> is not in general a good practice of course...
>>
>> -Doug
>>
>>
>>
>> >
>> > I think in general it is best to model the task in terms of 
>> dependency rather
>> > than tweaking the execution engine to get the effect you want.
>> >
>> > --
>> > Cheers,
>> > ?
>> >
>> > On Feb 8, 2016 11:00 AM, "cowwoc" <[hidden email] 
>> </user/SendEmail.jtp?type=node&node=13260&i=0>
>> > <mailto:[hidden email] 
>> </user/SendEmail.jtp?type=node&node=13260&i=1>>> wrote:
>> >
>> >     You're still vulnerable to the same race condition:
>> >
>> >      1. [main] Invokes ForkJoinPool.execute(task)
>> >      2. [WorkerThread] Finishes running a task, reaches the point 
>> immediately
>> >         before deregisterThread() at
>> > 
>> https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L61
>> >      3. [main] ForkJoinPool invokes tryAddWorker(),
>> > 
>> https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L65
>> >         returns null
>> >      4. [WorkerThread] Invokes deregisterThread().
>> >
>> >     Now we have an enqueued task, no worker threads and no one is 
>> trying to spin
>> >     up a new thread.
>> >
>> >     Gili
>> >
>> >     On 2016-02-08 4:53 AM, Viktor Klang wrote:
>> >>     I was thinking something along the lines of this:
>> >>
>> >> 
>> https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L65
>> >> 
>> https://github.com/scala/scala/blob/2.12.x/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L68
>> >>
>> >>     (no need for WeakReferences to Threads, synchronized etc)
>> >>
>> >>     On Mon, Feb 8, 2016 at 8:47 AM, cowwoc <[hidden email] 
>> </user/SendEmail.jtp?type=node&node=13260&i=2>
>> >>     <mailto:[hidden email] 
>> </user/SendEmail.jtp?type=node&node=13260&i=3>>> wrote:
>> >>
>> >>         So, it turns out this solution isn't actually safe.
>> >>
>> >>         1. I used the following thread factory:
>> >>
>> >>                         ForkJoinWorkerThreadFactory factory = new
>> >>         ForkJoinWorkerThreadFactory()
>> >>                         {
>> >>                             private WeakReference<Thread> 
>> currentWorker = new
>> >>         WeakReference<>(null);
>> >>
>> >>                             @Override
>> >>                             public synchronized ForkJoinWorkerThread
>> >>         newThread(ForkJoinPool pool)
>> >>                             {
>> >>                                 // If the pool already has a live 
>> thread,
>> >>         return null.
>> >>                                 Thread thread = currentWorker.get();
>> >>                                 if (thread != null && 
>> thread.isAlive())
>> >>                                 {
>> >> System.out.println("Thread: " +
>> >>         thread.getName() + " is already alive, returning null.");
>> >>                                     return null;
>> >>                                 }
>> >>                                 ForkJoinWorkerThread result = new
>> >>         MyForkJoinWorkerThread(pool);
>> >>                                 currentWorker = new 
>> WeakReference<>(result);
>> >>                                 // According to Doug Lea this will 
>> reduce the
>> >>         probability of short livelocks
>> >>                                 Thread.yield();
>> >>                                 return result;
>> >>                             }
>> >>                         };
>> >>
>> >>         2. I started a debugging session.
>> >>         3. I suspended all threads long enough for the worker 
>> thread to get
>> >>         flagged as idle (approximately 10 seconds).
>> >>         4. I allowed all threads to continue execution.
>> >>         5. Upon resuming, the worker thread shut down and at the 
>> same time the
>> >>         factory printed "Thread: X is already alive, returning null."
>> >>         6. If I run the above scenario without suspending all 
>> threads (only
>> >>         suspending the "main" thread) then the worker thread shuts 
>> down, I
>> >>         resume execution, and a new worker thread spins up.
>> >>
>> >>         In other words, the proposed solution is vulnerable to a 
>> race condition.
>> >>
>> >>         Gili
>> >>
>> >>         On 2016-02-06 9:35 PM, cowwoc wrote:
>> >>>         Thanks Doug, I'll give this a try.
>> >>>
>> >>>         Thanks,
>> >>>         Gili
>> >>>
>> >>>         On 2016-02-06 3:02 PM, Doug Lea [via JSR166 Concurrency] 
>> wrote:
>> >>>>         On 02/06/2016 05:21 AM, Viktor Klang wrote:
>> >>>>         > What happens if you supply it with a thread factory 
>> which only
>> >>>>         allows a single
>> >>>>         > thread to be alive at a time, and returns null if it 
>> already has
>> >>>>         returned a
>> >>>>         > still living thread?
>> >>>>         >
>> >>>>
>> >>>>         Yes, this will work if you are positive that only one 
>> thread
>> >>>>         is required for liveness. FJ sometimes conservatively 
>> creates
>> >>>>         threads when it cannot itself guarantee liveness (for 
>> example,
>> >>>>         when GC or other system load causes stalls). But it will
>> >>>>         respond to null factory returns by rechecking, not failing.
>> >>>>         unless a thread really is needed to maintain liveness, 
>> in which
>> >>>>         case the program may livelock. To reduce transient 
>> near-livelock,
>> >>>>         you might want to place a Thread.yield() call before the
>> >>>>         "return null" in the factory.
>> >>>>
>> >>>>         -Doug
>> >>>>
>> >>>>
>> >>>>         > --
>> >>>>         > Cheers,
>> >>>>         > ?
>> >>>>         >
>> >>>>         > On Feb 6, 2016 05:19, "cowwoc" <[hidden email]
>> >>>>         <http:///user/SendEmail.jtp?type=node&node=13243&i=0>
>> >>>>         > <mailto:[hidden email]
>> >>>>         <http:///user/SendEmail.jtp?type=node&node=13243&i=1>>> 
>> wrote:
>> >>>>         >
>> >>>>         >     Hi,
>> >>>>         >
>> >>>>         >     Is this the correct mailing list for discussing 
>> ForkJoinPool
>> >>>>         in JDK9? If
>> >>>>         >     not, please point me to the right place.
>> >>>>         >
>> >>>>         >     I have a feature request for ForkJoinPool which 
>> doesn't seem
>> >>>>         to be possible
>> >>>>         >     to implement without a JDK change:
>> >>>>         
>> <http://stackoverflow.com/q/34012134/14731>http://stackoverflow.com/q/34012134/14731
>> >>>>         >
>> >>>>         >     Specifically, I need to be able to an application 
>> that uses
>> >>>>         Random and
>> >>>>         >     ForkJoinPool in a deterministic manner when
>> >>>>         debugging/profiling but run
>> >>>>         >     full-speed in normal execution mode. I have all 
>> the moving
>> >>>>         parts nailing
>> >>>>         >     down except for ForkJoinPool.
>> >>>>         >
>> >>>>         >     If I create ForkJoinPool with a parallelism of 1, 
>> sometimes I
>> >>>>         see two worker
>> >>>>         >     threads getting used. I am guessing that this is 
>> caused by
>> >>>>         >     ForkJoinTask.get() invoking
>> >>>> ForkJoinPool.common.externalHelpComplete(), but
>> >>>>         >     maybe something else is going on.
>> >>>>         >
>> >>>>         >     Is there a way for me to guarantee that 
>> ForkJoinThread will
>> >>>>         use exactly 1
>> >>>>         >     worker thread, no less, no more? Would you like me 
>> to file a
>> >>>>         formal feature
>> >>>>         >     request?
>> >>>>         >
>> >>>>         >     Thank you,
>> >>>>         >     Gili
>> >>>>         >
>> >>>>         >
>> >>>>         >
>> >>>>         >     --
>> >>>>         >     View this message in context:
>> >>>>         >
>> >>>> 
>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232.html
>> >>>>         >     Sent from the JSR166 Concurrency mailing list 
>> archive at
>> >>>>         Nabble.com.
>> >>>>         > _______________________________________________
>> >>>>         >     Concurrency-interest mailing list
>> >>>>         > [hidden email]
>> >>>>         <http:///user/SendEmail.jtp?type=node&node=13243&i=2>
>> >>>>         <mailto:[hidden email]
>> >>>>         <http:///user/SendEmail.jtp?type=node&node=13243&i=3>>
>> >>>>         >
>> >>>>         
>> <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>>         >
>> >>>>         >
>> >>>>         >
>> >>>>         > _______________________________________________
>> >>>>         > Concurrency-interest mailing list
>> >>>>         > [hidden email] 
>> <http:///user/SendEmail.jtp?type=node&node=13243&i=4>
>> >>>>         > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>>         >
>> >>>>
>> >>>>
>> >>>>
>> >>>> _______________________________________________
>> >>>>         Concurrency-interest mailing list
>> >>>>         [hidden email] 
>> <http:///user/SendEmail.jtp?type=node&node=13243&i=5>
>> >>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>>
>> >>>>
>> >>>> 
>> --------------------------------------------------------------------------------
>> >>>>         If you reply to this email, your message will be added 
>> to the
>> >>>>         discussion below:
>> >>>> 
>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13243.html
>> >>>>
>> >>>>         To unsubscribe from Single-threaded ForkJoinPool, click 
>> here.
>> >>>>         NAML
>> >>>>         
>> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>>
>> >>>>
>> >>>
>> >>
>> >>
>> >> 
>> --------------------------------------------------------------------------------
>> >>         View this message in context: Re: Single-threaded 
>> ForkJoinPool
>> >>         
>> <http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13250.html> 
>>
>> >>
>> >>
>> >>         Sent from the JSR166 Concurrency mailing list archive
>> >>         <http://jsr166-concurrency.10961.n7.nabble.com/> at 
>> Nabble.com.
>> >>
>> >> _______________________________________________
>> >>         Concurrency-interest mailing list
>> >> [hidden email] </user/SendEmail.jtp?type=node&node=13260&i=4>
>> >>         <mailto:[hidden email] 
>> </user/SendEmail.jtp?type=node&node=13260&i=5>>
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>
>> >>
>> >>
>> >>
>> >>     --
>> >>     Cheers,
>> >>     ?
>> >
>> >
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > [hidden email] </user/SendEmail.jtp?type=node&node=13260&i=6>
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> [hidden email] </user/SendEmail.jtp?type=node&node=13260&i=7>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> ------------------------------------------------------------------------
>> If you reply to this email, your message will be added to the 
>> discussion below:
>> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13260.html 
>>
>> To unsubscribe from Single-threaded ForkJoinPool, click here 
>> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=unsubscribe_by_code&node=13232&code=Y293d29jQGJicy5kYXJrdGVjaC5vcmd8MTMyMzJ8MTU3NDMyMTI0Nw==>.
>> NAML 
>> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>>
>





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13262.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160211/18fba3d7/attachment-0001.html>

From pettermahlen at gmail.com  Fri Feb 12 03:36:57 2016
From: pettermahlen at gmail.com (=?UTF-8?B?UGV0dGVyIE3DpWhsw6lu?=)
Date: Fri, 12 Feb 2016 08:36:57 +0000
Subject: [concurrency-interest] CompletionStage.handle() with function
	returning CompletionStage
Message-ID: <CAGpHYSUkVw_0aGZGMhs49Kd_xDK+zpqc4zrFQBFpFH3tJiJOow@mail.gmail.com>

Hi,

One thing that I and my colleagues have felt is missing in CompletionStage
is a version of handle() (and exceptionally()) taking a function that
returns a CompletionStage<U> (or T) instead of a plain U. This is
particularly useful when doing things like fallbacks or retries for remote
service calls.

We've implemented those methods ourselves, calling them 'handleCompose' and
'exceptionallyCompose':
https://github.com/spotify/futures-extra/blob/master/src/main/java/com/spotify/futures/CompletableFuturesExtra.java#L110,
but of course using a static method like that reads less well than the
normal fluent API.

What is the rationale for not including those versions?

/ Petter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160212/ab62ef6e/attachment.html>

From dl at cs.oswego.edu  Sun Feb 21 15:48:28 2016
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 21 Feb 2016 15:48:28 -0500
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56BD6D67.505@bbs.darktech.org>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B65B01.7050508@cs.oswego.edu> <56B85443.1000101@bbs.darktech.org>
	<CANPzfU9oQbOQvKgsykPRCNHJYcWJVKy-ZfE6sHdHnm_8z=nOKw@mail.gmail.com>
	<56B86751.5050003@bbs.darktech.org>
	<CANPzfU-jjfwmn1FPAu9DA5KF2FT8Yb+X7euDvkA2UP23igafFQ@mail.gmail.com>
	<56BC9A8E.5070102@cs.oswego.edu> <56BD6D67.505@bbs.darktech.org>
Message-ID: <56CA229C.6030604@cs.oswego.edu>


Sorry for the delay...

On 02/11/2016 11:35 PM, cowwoc wrote:

> As an aside, do you plan on fixing tryAddWorker() so it retries launching a new
> thread if one is still needed?

It's a feature (not a bug) also used in ThreadPoolExecutor
to avoid infinitely looping failures (including for example
OutOfMemoryErrors):
A failed (null or exceptional) call to newThread is not
retried until the next opportunity to call it.
We should clarify the documentation, as below.

Not directly relevantly, but I'm also finally getting to think
that we should add some control/tuning parameters to ForkJoinPool.
More on that soon.


     /**
      * Factory for creating new {@link ForkJoinWorkerThread}s.
      * A {@code ForkJoinWorkerThreadFactory} must be defined and used
      * for {@code ForkJoinWorkerThread} subclasses that extend base
      * functionality or initialize threads with different contexts.
      */
     public static interface ForkJoinWorkerThreadFactory {
         /**
          * Returns a new worker thread operating in the given pool.
          * Returning null or throwing an exception may result in tasks
          * never being executed.  If this method throws an exception,
          * it is relayed to the caller of the method (for example
          * {@code execute}) causing attempted thread creation. If this
          * method returns null or throws an exception, it is not
          * retried until the next attempted creation (for example
          * another call to {@code execute}).
          *
          * @param pool the pool this thread works in
          * @return the new worker thread, or {@code null} if the request
          *         to create a thread is rejected.
          * @throws NullPointerException if the pool is null
          */
         public ForkJoinWorkerThread newThread(ForkJoinPool pool);
     }



From dl at cs.oswego.edu  Sun Feb 21 15:54:03 2016
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 21 Feb 2016 15:54:03 -0500
Subject: [concurrency-interest] CompletionStage.handle() with function
 returning CompletionStage
In-Reply-To: <CAGpHYSUkVw_0aGZGMhs49Kd_xDK+zpqc4zrFQBFpFH3tJiJOow@mail.gmail.com>
References: <CAGpHYSUkVw_0aGZGMhs49Kd_xDK+zpqc4zrFQBFpFH3tJiJOow@mail.gmail.com>
Message-ID: <56CA23EB.9070303@cs.oswego.edu>

On 02/12/2016 03:36 AM, Petter M?hl?n wrote:
> Hi,
>
> One thing that I and my colleagues have felt is missing in CompletionStage is a
> version of handle() (and exceptionally()) taking a function that returns a
> CompletionStage<U> (or T) instead of a plain U. This is particularly useful when
> doing things like fallbacks or retries for remote service calls.

> We've implemented those methods ourselves, calling them 'handleCompose' and
> 'exceptionallyCompose':
> https://github.com/spotify/futures-extra/blob/master/src/main/java/com/spotify/futures/CompletableFuturesExtra.java#L110,
> but of course using a static method like that reads less well than the normal
> fluent API.
>
> What is the rationale for not including those versions?
>

I can see how this would be useful in some styles of programming using
CompletionStages. But when coming up with the APIs, no one predicted
this style might become common, so no one made a case for including it
in the main CompletionStage interface.

I was thinking that by letting this post sit a while, others might
try to make this case. But not yet.

-Doug




From cowwoc at bbs.darktech.org  Sun Feb 21 15:33:10 2016
From: cowwoc at bbs.darktech.org (cowwoc)
Date: Sun, 21 Feb 2016 13:33:10 -0700 (MST)
Subject: [concurrency-interest] Single-threaded ForkJoinPool
In-Reply-To: <56CA229C.6030604@cs.oswego.edu>
References: <1454728713539-13232.post@n7.nabble.com>
	<CANPzfU8-pox_ZW9osZYyfOoS-vGOuHspUPBvoa18U+CskVRP1g@mail.gmail.com>
	<56B65B01.7050508@cs.oswego.edu>
	<56B85443.1000101@bbs.darktech.org>
	<CANPzfU9oQbOQvKgsykPRCNHJYcWJVKy-ZfE6sHdHnm_8z=nOKw@mail.gmail.com>
	<56B86751.5050003@bbs.darktech.org>
	<CANPzfU-jjfwmn1FPAu9DA5KF2FT8Yb+X7euDvkA2UP23igafFQ@mail.gmail.com>
	<56BC9A8E.5070102@cs.oswego.edu> <56BD6D67.505@bbs.darktech.org>
	<56CA229C.6030604@cs.oswego.edu>
Message-ID: <56CA2BA1.3020208@bbs.darktech.org>

+1 for the updated documentation.

Looking forward to hearing more about the ForkJoinPool control/turning 
parameters you have in mind.

Thanks,
Gili

On 2016-02-21 3:18 PM, Doug Lea [via JSR166 Concurrency] wrote:
>
> Sorry for the delay...
>
> On 02/11/2016 11:35 PM, cowwoc wrote:
>
> > As an aside, do you plan on fixing tryAddWorker() so it retries 
> launching a new
> > thread if one is still needed?
>
> It's a feature (not a bug) also used in ThreadPoolExecutor
> to avoid infinitely looping failures (including for example
> OutOfMemoryErrors):
> A failed (null or exceptional) call to newThread is not
> retried until the next opportunity to call it.
> We should clarify the documentation, as below.
>
> Not directly relevantly, but I'm also finally getting to think
> that we should add some control/tuning parameters to ForkJoinPool.
> More on that soon.
>
>
>      /**
>       * Factory for creating new {@link ForkJoinWorkerThread}s.
>       * A {@code ForkJoinWorkerThreadFactory} must be defined and used
>       * for {@code ForkJoinWorkerThread} subclasses that extend base
>       * functionality or initialize threads with different contexts.
>       */
>      public static interface ForkJoinWorkerThreadFactory {
>          /**
>           * Returns a new worker thread operating in the given pool.
>           * Returning null or throwing an exception may result in tasks
>           * never being executed.  If this method throws an exception,
>           * it is relayed to the caller of the method (for example
>           * {@code execute}) causing attempted thread creation. If this
>           * method returns null or throws an exception, it is not
>           * retried until the next attempted creation (for example
>           * another call to {@code execute}).
>           *
>           * @param pool the pool this thread works in
>           * @return the new worker thread, or {@code null} if the request
>           *         to create a thread is rejected.
>           * @throws NullPointerException if the pool is null
>           */
>          public ForkJoinWorkerThread newThread(ForkJoinPool pool);
>      }
>
>
> _______________________________________________
> Concurrency-interest mailing list
> [hidden email] </user/SendEmail.jtp?type=node&node=13264&i=0>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------------------------------------------------
> If you reply to this email, your message will be added to the 
> discussion below:
> http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13264.html 
>
> To unsubscribe from Single-threaded ForkJoinPool, click here 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=unsubscribe_by_code&node=13232&code=Y293d29jQGJicy5kYXJrdGVjaC5vcmd8MTMyMzJ8MTU3NDMyMTI0Nw==>.
> NAML 
> <http://jsr166-concurrency.10961.n7.nabble.com/template/NamlServlet.jtp?macro=macro_viewer&id=instant_html%21nabble%3Aemail.naml&base=nabble.naml.namespaces.BasicNamespace-nabble.view.web.template.NabbleNamespace-nabble.view.web.template.NodeNamespace&breadcrumbs=notify_subscribers%21nabble%3Aemail.naml-instant_emails%21nabble%3Aemail.naml-send_instant_email%21nabble%3Aemail.naml> 
>





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Single-threaded-ForkJoinPool-tp13232p13266.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160221/6dc4d70a/attachment.html>

From ben_manes at yahoo.com  Mon Feb 22 04:33:20 2016
From: ben_manes at yahoo.com (Ben Manes)
Date: Mon, 22 Feb 2016 09:33:20 +0000 (UTC)
Subject: [concurrency-interest] CHM trySplit of a map with odd size
References: <788119363.7669128.1456133600116.JavaMail.yahoo.ref@mail.yahoo.com>
Message-ID: <788119363.7669128.1456133600116.JavaMail.yahoo@mail.yahoo.com>

I checked Doug's CVS repository and I didn't see a fix for this off-by-one issue.
When writing?parameterized tests?for a custom Spliterator view, the tests failed for maps of size 1. ConcurrentHashMap trySplit will return a new Spliterator with an?estimated size of zero and set the source spliterator to zero as well. The contract states that trySplit should return null in that case and leave the source spliterator unchanged. When the map is an odd size larger than 1, the two spliterators have an even estimated count. For size 3 this means that the estimate is 2. This resulted in tests with a population size of 25 to fail. These issues occur for keySet, values, and entrySet views.
To verify my expectations, I then tested with ConcurrentSkipListMap. A split always returns null and the resulting source spliterator has an estimated count of Integer.MAX_VALUE. This happens for any non-empty map. Perhaps this should have been Long.MAX_VALUE as according to the JavaDoc that indicates an infinite, unknown, or too computationally expensive size.
The JavaDoc says the estimate may be arbitrarily inaccurate. It would be nice if either the implementations were more accurate or included a comment hinting to their behavior.
@Testpublic void keySpliterator_trySplit() {? Map<Integer, Integer> map = new ConcurrentHashMap<>();? map.put(1, 1);
? Spliterator<Integer> spliterator = map.keySet().spliterator();? Spliterator<Integer> other = spliterator.trySplit();? // 1. Split should return null, but is present? // assertThat(other, is(nullValue()));
? // 2. Size should be 1, but is 0? // int size = (int) (spliterator.estimateSize() + other.estimateSize());? // assertThat(size, is(map.size()));}
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160222/06a1aeb2/attachment.html>

From dl at cs.oswego.edu  Mon Feb 22 10:04:44 2016
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 22 Feb 2016 10:04:44 -0500
Subject: [concurrency-interest] CHM trySplit of a map with odd size
In-Reply-To: <788119363.7669128.1456133600116.JavaMail.yahoo@mail.yahoo.com>
References: <788119363.7669128.1456133600116.JavaMail.yahoo.ref@mail.yahoo.com>
	<788119363.7669128.1456133600116.JavaMail.yahoo@mail.yahoo.com>
Message-ID: <56CB238C.6040600@cs.oswego.edu>

On 02/22/2016 04:33 AM, Ben Manes wrote:

> When writing parameterized tests
> a custom Spliterator view, the tests failed for maps of size 1.
> ConcurrentHashMap trySplit will return a new Spliterator with an estimated size
> of zero and set the source spliterator to zero as well.

I believe that plain HashMap and some other classes can do this as well.
They return regions that should (statistically) hold elements but might not.
Similarly for some IO-based spliterators.

> The contract states that
> trySplit should return null in that case

It says that it must eventually return null.

>
> The JavaDoc says the estimate may be arbitrarily inaccurate. It would be nice if
> either the implementations were more accurate or included a comment hinting to
> their behavior.

That's what the SIZED characteristic is for. Non-exact spliterators
don't set SIZED.

I agree that these rules make writing unit tests more complicated, but
the underlying idea is not to force implementations to do things that
are slow or impossible for some sources or sata structures.

-Doug



From paul.sandoz at oracle.com  Mon Feb 22 10:44:45 2016
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Mon, 22 Feb 2016 16:44:45 +0100
Subject: [concurrency-interest] CHM trySplit of a map with odd size
In-Reply-To: <56CB238C.6040600@cs.oswego.edu>
References: <788119363.7669128.1456133600116.JavaMail.yahoo.ref@mail.yahoo.com>
	<788119363.7669128.1456133600116.JavaMail.yahoo@mail.yahoo.com>
	<56CB238C.6040600@cs.oswego.edu>
Message-ID: <B1C990D6-51D1-473D-9760-9A40793A3153@oracle.com>


> On 22 Feb 2016, at 16:04, Doug Lea <dl at cs.oswego.edu> wrote:
> 
> On 02/22/2016 04:33 AM, Ben Manes wrote:
> 
>> When writing parameterized tests
>> a custom Spliterator view, the tests failed for maps of size 1.
>> ConcurrentHashMap trySplit will return a new Spliterator with an estimated size
>> of zero and set the source spliterator to zero as well.
> 
> I believe that plain HashMap and some other classes can do this as well.

HashMap does, you are faster than me in replying :-)


> They return regions that should (statistically) hold elements but might not.

e.g. in the case of certain maps, the entry table is split in two and we don?t know which half of the table the single entry resides.

Paul.

> Similarly for some IO-based spliterators.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 841 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160222/23e3464a/attachment-0001.bin>

From ben_manes at yahoo.com  Mon Feb 22 12:29:25 2016
From: ben_manes at yahoo.com (Ben Manes)
Date: Mon, 22 Feb 2016 17:29:25 +0000 (UTC)
Subject: [concurrency-interest] CHM replaceAll
References: <619503465.7638117.1456162165970.JavaMail.yahoo.ref@mail.yahoo.com>
Message-ID: <619503465.7638117.1456162165970.JavaMail.yahoo@mail.yahoo.com>

ConcurrentHashMap#replaceAll(bifunction) performs the computation optimistically per key, retrying until successful. This is a valid implementation, but slightly surprising due to the map's ability to perform the per-key operations pessimistically. In the case of a map holding a resource that should be explicitly closed, these races could result in a leak. That of course is a user error, but one that I think is easily corrected without a negative loss for the hash table. This of course is more important for my case of a cache, where I provide a custom implementation for a variety of reasons.
The request is to use computeIfPresent per key. The function would have to be decorated with a lambda that disallows null values. I suspect this single allocation is preferable to the cost of retrying on a conflict. That allocation could be removed with a more complex replacement, but that is probably unnecessary.
Cheers,Ben

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160222/cfb0759a/attachment.html>

From ben_manes at yahoo.com  Mon Feb 22 14:57:40 2016
From: ben_manes at yahoo.com (Ben Manes)
Date: Mon, 22 Feb 2016 19:57:40 +0000 (UTC)
Subject: [concurrency-interest] CHM trySplit of a map with odd size
In-Reply-To: <B1C990D6-51D1-473D-9760-9A40793A3153@oracle.com>
References: <B1C990D6-51D1-473D-9760-9A40793A3153@oracle.com>
Message-ID: <851932849.7692700.1456171060960.JavaMail.yahoo@mail.yahoo.com>

Thanks. I realized that my unit test expectations were unreasonable and undesirable. This wasn't meant as a bug report but rather sharing my experience as an easy mistake to make. The request was that it might be beneficial to add a short bit of JavaDoc stating some of the behavior to the implementations. An additional nice to have would be a slightly stronger estimated size, if not prohibitively expensive, that matched my naive expectations in a single threaded context. 

    On Monday, February 22, 2016 7:44 AM, Paul Sandoz <paul.sandoz at oracle.com> wrote:
 

 
> On 22 Feb 2016, at 16:04, Doug Lea <dl at cs.oswego.edu> wrote:
> 
> On 02/22/2016 04:33 AM, Ben Manes wrote:
> 
>> When writing parameterized tests
>> a custom Spliterator view, the tests failed for maps of size 1.
>> ConcurrentHashMap trySplit will return a new Spliterator with an estimated size
>> of zero and set the source spliterator to zero as well.
> 
> I believe that plain HashMap and some other classes can do this as well.

HashMap does, you are faster than me in replying :-)


> They return regions that should (statistically) hold elements but might not.

e.g. in the case of certain maps, the entry table is split in two and we don?t know which half of the table the single entry resides.

Paul.

> Similarly for some IO-based spliterators.

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160222/2312b588/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 841 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160222/2312b588/attachment.bin>

From cpovirk at google.com  Mon Feb 22 16:15:32 2016
From: cpovirk at google.com (Chris Povirk)
Date: Mon, 22 Feb 2016 16:15:32 -0500
Subject: [concurrency-interest] CompletionStage.handle() with function
 returning CompletionStage
In-Reply-To: <CAGpHYSUkVw_0aGZGMhs49Kd_xDK+zpqc4zrFQBFpFH3tJiJOow@mail.gmail.com>
References: <CAGpHYSUkVw_0aGZGMhs49Kd_xDK+zpqc4zrFQBFpFH3tJiJOow@mail.gmail.com>
Message-ID: <CAEvq2no8iiyKS6RgTSFM0B01tyMr=9buETwUz2=mHT5EMU_kiw@mail.gmail.com>

FWIW, some data from Guava:

Our Futures class used to have the opposite problem: It had *only* the
CompletionState version of exceptionally(). (In our terms, this was
withFallback(...,
FutureFallback), where FutureFallback returns a Future or throws). We found
that ~15% of users needed that power.

There's an asterisk on that "15%": While I *think* my notes mean "15% of
users need to return a Future," they might mean something else: Because we
were evaluating a switch to Function<Throwable, V>, we needed to consider
what would happen to users who threw a checked exception. It's possible
that I lumped them into the "15%" along with the users who needed to return
a Future. I probably didn't, but I can't guarantee it. And
CompletionStage.exceptionallCompose wouldn't be offering the ability to
throw a checked exception.

We ended up deciding to provide both
<http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching(com.google.common.util.concurrent.ListenableFuture,%20java.lang.Class,%20com.google.common.base.Function,%20java.util.concurrent.Executor)>.
But it's possible that our users differ from CompletionStage's. For
example, maybe we slant more toward application developers and less toward
tool developers. Or maybe we just hate checked exceptions marginally less
than other people :)

(RE: handle(): We don't have anything like it.)

(Ideally I would have provided this information 10 days ago or, better yet,
during the review of CompletableFuture. Sorry. We didn't get around to
reviewing our method until last year.)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160222/cfdad08f/attachment.html>

From pavel.rappo at gmail.com  Wed Feb 24 06:29:10 2016
From: pavel.rappo at gmail.com (Pavel Rappo)
Date: Wed, 24 Feb 2016 11:29:10 +0000
Subject: [concurrency-interest] Flow API tools for working with cold
	observables
Message-ID: <CAChcVumWR3_4yi5skwiejy8-XdLb85NQJ56LjD=J-D5d6MGkdw@mail.gmail.com>

Hi,

I wonder if there are any plans on creating some intermediary working between a
publisher and a subscriber that would take care of buffering? I believe it might
become a common need for Flow API adopters as it seems to represent a highly
reusable component. As I understand, j.u.c.SubmissionPublisher is not
particularly good for working with "cold" observables. It provides buffering but
for a different reason and it also relies on "drop handling and/or blocking" for
flow control. I don't think any of these options are particularly good when
working with cold observables in a non-blocking fashion.

What is needed in its essence is a some kind of "elastic coupling" working
between 2 subscribers that effectively manages a steady flow of items
prefetching them (if stock drops below some level) from the input side and
transferring them to the output side.

-Pavel

From akarnokd at gmail.com  Wed Feb 24 06:48:16 2016
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Wed, 24 Feb 2016 12:48:16 +0100
Subject: [concurrency-interest] Flow API tools for working with cold
	observables
In-Reply-To: <CAChcVumWR3_4yi5skwiejy8-XdLb85NQJ56LjD=J-D5d6MGkdw@mail.gmail.com>
References: <CAChcVumWR3_4yi5skwiejy8-XdLb85NQJ56LjD=J-D5d6MGkdw@mail.gmail.com>
Message-ID: <CAAWwtm8PW1DGAtcB1xiUhgT7kCjoB4wMMs3VB4sU+GeGpm9XDw@mail.gmail.com>

Popular reactive libraries have converters / ports to j.u.c.Flow already so
you have the option to work with a plethora of operators over cold sources:

https://github.com/akarnokd/RxJavaUtilConcurrentFlow
https://github.com/reactor/reactor-core/blob/master/src/main/java/reactor/core/converter/FlowPublisherConverter.java




2016-02-24 12:29 GMT+01:00 Pavel Rappo <pavel.rappo at gmail.com>:

> Hi,
>
> I wonder if there are any plans on creating some intermediary working
> between a
> publisher and a subscriber that would take care of buffering? I believe it
> might
> become a common need for Flow API adopters as it seems to represent a
> highly
> reusable component. As I understand, j.u.c.SubmissionPublisher is not
> particularly good for working with "cold" observables. It provides
> buffering but
> for a different reason and it also relies on "drop handling and/or
> blocking" for
> flow control. I don't think any of these options are particularly good when
> working with cold observables in a non-blocking fashion.
>
> What is needed in its essence is a some kind of "elastic coupling" working
> between 2 subscribers that effectively manages a steady flow of items
> prefetching them (if stock drops below some level) from the input side and
> transferring them to the output side.
>
> -Pavel
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160224/0b554cb2/attachment.html>

From pavel.rappo at gmail.com  Wed Feb 24 11:47:21 2016
From: pavel.rappo at gmail.com (Pavel Rappo)
Date: Wed, 24 Feb 2016 16:47:21 +0000
Subject: [concurrency-interest] Flow API tools for working with cold
	observables
In-Reply-To: <CAAWwtm8PW1DGAtcB1xiUhgT7kCjoB4wMMs3VB4sU+GeGpm9XDw@mail.gmail.com>
References: <CAChcVumWR3_4yi5skwiejy8-XdLb85NQJ56LjD=J-D5d6MGkdw@mail.gmail.com>
	<CAAWwtm8PW1DGAtcB1xiUhgT7kCjoB4wMMs3VB4sU+GeGpm9XDw@mail.gmail.com>
Message-ID: <CAChcVu=_XPHg86b3-ChPDPiYE2zbnnTtPC=-xgogTWk49QK7nQ@mail.gmail.com>

Thanks D?vid, I don't have a luxury of using 3rd party libraries. I
wonder what would others say? Is the "coupling" I've described is
essential enough to become a part of Flow API along with
SubmissionPublisher or I am missing something and it could *easily* be
assembled from already existing java.util.concurrent objects?

-Pavel

On Wed, Feb 24, 2016 at 11:48 AM, D?vid Karnok <akarnokd at gmail.com> wrote:
> Popular reactive libraries have converters / ports to j.u.c.Flow already so
> you have the option to work with a plethora of operators over cold sources:
>
> https://github.com/akarnokd/RxJavaUtilConcurrentFlow
> https://github.com/reactor/reactor-core/blob/master/src/main/java/reactor/core/converter/FlowPublisherConverter.java
>
>
>
>
> 2016-02-24 12:29 GMT+01:00 Pavel Rappo <pavel.rappo at gmail.com>:
>>
>> Hi,
>>
>> I wonder if there are any plans on creating some intermediary working
>> between a
>> publisher and a subscriber that would take care of buffering? I believe it
>> might
>> become a common need for Flow API adopters as it seems to represent a
>> highly
>> reusable component. As I understand, j.u.c.SubmissionPublisher is not
>> particularly good for working with "cold" observables. It provides
>> buffering but
>> for a different reason and it also relies on "drop handling and/or
>> blocking" for
>> flow control. I don't think any of these options are particularly good
>> when
>> working with cold observables in a non-blocking fashion.
>>
>> What is needed in its essence is a some kind of "elastic coupling" working
>> between 2 subscribers that effectively manages a steady flow of items
>> prefetching them (if stock drops below some level) from the input side and
>> transferring them to the output side.
>>
>> -Pavel
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> --
> Best regards,
> David Karnok


From vshalts at gmail.com  Wed Feb 24 18:37:37 2016
From: vshalts at gmail.com (Vadim Shalts)
Date: Thu, 25 Feb 2016 00:37:37 +0100
Subject: [concurrency-interest] CompletableFuture as part of APIs and
 defensive copying
Message-ID: <56CE3EC1.60406@gmail.com>

Hello,

I am thinking about creating API with CompletableFuture usage.
CompletableFuture is great candidate to be used in interfaces of async 
APIs for long running methods.
Also we often want to cache result (return the same heavy result a lot 
of times).
Lets imagine some simple API for that (only CompletableFuture usage is 
important here):

class SomeAPI {
     private CompletionStage<Integer> longRunningTask = null;
     private final ScheduledExecutorService scheduler = 
Executors.newScheduledThreadPool(1);

     public synchronized CompletionStage<Integer> longRunningEvenNumber() {
         if (longRunningTask == null) {
             final CompletableFuture<Integer> promise = new 
CompletableFuture();
             scheduler.schedule(() -> promise.complete(100), 1L, 
TimeUnit.SECONDS);
             longRunningTask = promise;
         }
         return longRunningTask;//.thenApply(x -> x);
     }

     public void breakApiContract() {
         CompletionStage<Integer> f = longRunningEvenNumber();
         f.toCompletableFuture().complete(101);
     }
}

I see three variants how this can be done:
1) return "promise" directly. Not good for public API due we can easily 
break contract by  toCompletableFuture().complete
2) Use defensive copying with thenApply(x -> x). Error-prone due easy to 
forget. And will cause memory allocation on every call even if we will 
not subscribe for results.
3) Implement custom read-only CompletionStage that will wrap "promise" 
and cache this wrapper instead of original "promise". Still error-prone, 
but I think it easier to understand and will no cost memory allocation 
per each call. But maybe some other hidden costs which I missed.

Because this task look like useful in many cases for me I think that 
third variant can be supported out of the box:

public synchronized CompletionStage<Integer> longRunningEvenNumber() {
         if (longRunningTask == null) {
             final CompletableFuture<Integer> promise = new 
CompletableFuture();
             scheduler.schedule(() -> promise.complete(100), 1L, 
TimeUnit.SECONDS);
             longRunningTask = promise.toReadOnlyStage();
         }
         return longRunningTask;
     }

Here imaginary method toReadOnlyStage() will return read-only 
CompletionStage (which will return new instances for each call of 
toCompletableFuture).

What do think?

Anyway, I believe that issue with toCompletableFuture().complete is not 
obvious (was not obvious for me) and people may not see that they need 
to use defensive copying in many cases when creating public APIs. Java 9 
will receive copy() method, but this is not enough to spot issue. Maybe 
some samples or notes should became part of documentation header of 
CompletableFuture?

Best regards,
   Vadim Shalts.

From christian.schudt at gmx.de  Fri Feb 26 07:58:24 2016
From: christian.schudt at gmx.de (Christian Schudt)
Date: Fri, 26 Feb 2016 13:58:24 +0100
Subject: [concurrency-interest] ConcurrentLinkedQueue vs.
	ConcurrentLinkedDeque
Message-ID: <trinity-71b0400b-80e9-4e08-94a8-267a8f9e6544-1456491504335@3capp-gmx-bs51>

Hello,
?
I've had performance problems (high CPU) in my app and after research I suspected ConcurrentLinkedQueue to be a possible source (due to [1], [2]).
?
Although I am still not sure it's really the source for my problem, I discovered significant performance differences between ConcurrentLinkedQueue and ConcurrentLinkedDeque:
?
    public static void main(String[] args) {

        Queue<String> queue = new ConcurrentLinkedDeque<>();
        String a = "a";
        String b = "b";
        queue.offer(a);
        for (int i = 0; ; i++) {
            if (i % 1024 == 0) {
                System.out.println("i = " + i);
            }
            queue.offer(b);
            queue.remove(b);
        }
    }

ConcurrentLinkedDeque is much faster! (Just replace it with ConcurrentLinkedQueue, the output becomes very slow)

Not sure, if this is related to JDK-8054446 [2] or if it's "normal".
Any comments?

Is there any reason to prefer ConcurrentLinkedQueue over ConcurrentLinkedDeque? 

(I am using JDK 8u60.)

Kind regards,
Christian

[1]: https://perfstories.wordpress.com/2012/08/01/why-does-cpu-utilization-happen-sometimes/
[2]: https://bugs.openjdk.java.net/browse/JDK-8054446


From martinrb at google.com  Fri Feb 26 11:38:15 2016
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 26 Feb 2016 08:38:15 -0800
Subject: [concurrency-interest] ConcurrentLinkedQueue vs.
	ConcurrentLinkedDeque
In-Reply-To: <trinity-71b0400b-80e9-4e08-94a8-267a8f9e6544-1456491504335@3capp-gmx-bs51>
References: <trinity-71b0400b-80e9-4e08-94a8-267a8f9e6544-1456491504335@3capp-gmx-bs51>
Message-ID: <CA+kOe0_s0P018chyqaC4=PJrUxNHF8REOMPg7Ss=NuK24Ozk5g@mail.gmail.com>

It's not really expected.  The expectation is (as is written in the source)

     * Empirically, microbenchmarks suggest that this class adds about
     * 40% overhead relative to ConcurrentLinkedQueue, which feels as
     * good as we can hope for.

You're using "interior removes" (remove(Object), which the
implementations support, but we have sometimes regretted that.  If we
could outlaw interior removes, the code would be much simpler.

I'll poke at this a bit.

On Fri, Feb 26, 2016 at 4:58 AM, Christian Schudt
<christian.schudt at gmx.de> wrote:
> Hello,
>
> I've had performance problems (high CPU) in my app and after research I suspected ConcurrentLinkedQueue to be a possible source (due to [1], [2]).
>
> Although I am still not sure it's really the source for my problem, I discovered significant performance differences between ConcurrentLinkedQueue and ConcurrentLinkedDeque:
>
>     public static void main(String[] args) {
>
>         Queue<String> queue = new ConcurrentLinkedDeque<>();
>         String a = "a";
>         String b = "b";
>         queue.offer(a);
>         for (int i = 0; ; i++) {
>             if (i % 1024 == 0) {
>                 System.out.println("i = " + i);
>             }
>             queue.offer(b);
>             queue.remove(b);
>         }
>     }
>
> ConcurrentLinkedDeque is much faster! (Just replace it with ConcurrentLinkedQueue, the output becomes very slow)
>
> Not sure, if this is related to JDK-8054446 [2] or if it's "normal".
> Any comments?
>
> Is there any reason to prefer ConcurrentLinkedQueue over ConcurrentLinkedDeque?
>
> (I am using JDK 8u60.)
>
> Kind regards,
> Christian
>
> [1]: https://perfstories.wordpress.com/2012/08/01/why-does-cpu-utilization-happen-sometimes/
> [2]: https://bugs.openjdk.java.net/browse/JDK-8054446
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From martinrb at google.com  Fri Feb 26 12:01:32 2016
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 26 Feb 2016 09:01:32 -0800
Subject: [concurrency-interest] ConcurrentLinkedQueue vs.
	ConcurrentLinkedDeque
In-Reply-To: <CA+kOe0_s0P018chyqaC4=PJrUxNHF8REOMPg7Ss=NuK24Ozk5g@mail.gmail.com>
References: <trinity-71b0400b-80e9-4e08-94a8-267a8f9e6544-1456491504335@3capp-gmx-bs51>
	<CA+kOe0_s0P018chyqaC4=PJrUxNHF8REOMPg7Ss=NuK24Ozk5g@mail.gmail.com>
Message-ID: <CA+kOe09ORcfxRuFC86ia4oE-1zduNSKXPAhypmassNTZeRUJrA@mail.gmail.com>

I had completely forgotten about
https://bugs.openjdk.java.net/browse/JDK-8054446
Repeated offer and remove on ConcurrentLinkedQueue lead to an OutOfMemoryError

which is fixed in jdk9, but not backported to jdk8

From christian.schudt at gmx.de  Fri Feb 26 12:04:33 2016
From: christian.schudt at gmx.de (Christian Schudt)
Date: Fri, 26 Feb 2016 18:04:33 +0100
Subject: [concurrency-interest] ConcurrentLinkedQueue vs.
	ConcurrentLinkedDeque
In-Reply-To: <CA+kOe09ORcfxRuFC86ia4oE-1zduNSKXPAhypmassNTZeRUJrA@mail.gmail.com>
References: <trinity-71b0400b-80e9-4e08-94a8-267a8f9e6544-1456491504335@3capp-gmx-bs51>
	<CA+kOe0_s0P018chyqaC4=PJrUxNHF8REOMPg7Ss=NuK24Ozk5g@mail.gmail.com>
	<CA+kOe09ORcfxRuFC86ia4oE-1zduNSKXPAhypmassNTZeRUJrA@mail.gmail.com>
Message-ID: <50592279-6C4F-4711-99BE-0674ED13C872@gmx.de>

I?ve seen that. Is that also the reason for the worse performance?


> Am 26.02.2016 um 18:01 schrieb Martin Buchholz <martinrb at google.com>:
> 
> I had completely forgotten about
> https://bugs.openjdk.java.net/browse/JDK-8054446
> Repeated offer and remove on ConcurrentLinkedQueue lead to an OutOfMemoryError
> 
> which is fixed in jdk9, but not backported to jdk8



From martinrb at google.com  Fri Feb 26 12:14:39 2016
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 26 Feb 2016 09:14:39 -0800
Subject: [concurrency-interest] ConcurrentLinkedQueue vs.
	ConcurrentLinkedDeque
In-Reply-To: <50592279-6C4F-4711-99BE-0674ED13C872@gmx.de>
References: <trinity-71b0400b-80e9-4e08-94a8-267a8f9e6544-1456491504335@3capp-gmx-bs51>
	<CA+kOe0_s0P018chyqaC4=PJrUxNHF8REOMPg7Ss=NuK24Ozk5g@mail.gmail.com>
	<CA+kOe09ORcfxRuFC86ia4oE-1zduNSKXPAhypmassNTZeRUJrA@mail.gmail.com>
	<50592279-6C4F-4711-99BE-0674ED13C872@gmx.de>
Message-ID: <CA+kOe089k++kY6uHRfZYqH+-JcgKgQHr1fvNtqZaMKVu2h2yQQ@mail.gmail.com>

Seems very likely.  You could try to prove it...

On Fri, Feb 26, 2016 at 9:04 AM, Christian Schudt
<christian.schudt at gmx.de> wrote:
> I?ve seen that. Is that also the reason for the worse performance?


From haim at performize-it.com  Sat Feb 27 09:00:20 2016
From: haim at performize-it.com (Haim Yadid)
Date: Sat, 27 Feb 2016 16:00:20 +0200
Subject: [concurrency-interest] ConcurrentLinkedQueue vs.
	ConcurrentLinkedDeque
In-Reply-To: <CA+kOe089k++kY6uHRfZYqH+-JcgKgQHr1fvNtqZaMKVu2h2yQQ@mail.gmail.com>
References: <trinity-71b0400b-80e9-4e08-94a8-267a8f9e6544-1456491504335@3capp-gmx-bs51>
	<CA+kOe0_s0P018chyqaC4=PJrUxNHF8REOMPg7Ss=NuK24Ozk5g@mail.gmail.com>
	<CA+kOe09ORcfxRuFC86ia4oE-1zduNSKXPAhypmassNTZeRUJrA@mail.gmail.com>
	<50592279-6C4F-4711-99BE-0674ED13C872@gmx.de>
	<CA+kOe089k++kY6uHRfZYqH+-JcgKgQHr1fvNtqZaMKVu2h2yQQ@mail.gmail.com>
Message-ID: <CAJ-ba_OWEc0rKxb_EwGhp2dxL0x7prdmtt6e4_HCfS6wFHVzqg@mail.gmail.com>

Hi Martin
I wrote a simple JMH benchmark to prove it.
When using ConcurrenLinkedQueue without your fix at JDK-8054446 it is
extremely slow your fix solves the problem
Here are the results :

Benchmark                          Mode  Cnt         Score         Error
              Units
QBench.measureABQ           thrpt    5  17031943.831 ? 8468127.395  ops/s
QBench.measureCLD           thrpt    5  15410606.543 ?  551687.064  ops/s
QBench.measureCLQFixed  thrpt    5  27674624.318 ? 1849425.328  ops/s
QBench.measureCLQOrig    thrpt    5      5527.394 ?    2371.913        ops/s

Here is the code :




import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Threads;
import org.openjdk.jmh.annotations.Warmup;

import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentLinkedDeque;

import java.util.concurrent.ExecutionException;


@Fork(1)
@Threads(1)
@BenchmarkMode({Mode.Throughput})
@Warmup(iterations = 5)
@Measurement(iterations = 5)
public class QBench {
  static final String a = "a";
  static final String b = "b";
  public static final int NUM_PRE = 1;
  @State(Scope.Benchmark)
  public static class ArrayBlockingQueueState {
    Queue<String> queue = new ArrayBlockingQueue<String>(1000);
    @Setup
    public void setup() throws ExecutionException, InterruptedException {
      for(int i=0;i<NUM_PRE;i++) queue.offer(a);
    }
  }
  @Benchmark
  public Object measureABQ(final ArrayBlockingQueueState
arrayBlockingQueueState) throws Exception {
    Queue queue = arrayBlockingQueueState.queue;
    queue.offer(b);
    return queue.remove(b);

  }



  @State(Scope.Benchmark)
  public static class ConcurrentLinkedDequeState {
    Queue<String> queue = new ConcurrentLinkedDeque<>();
    @Setup
    public void setup() throws ExecutionException, InterruptedException {
      for(int i=0;i<NUM_PRE;i++) queue.offer(a);
    }
  }
  @Benchmark
  public Object measureCLD(final ConcurrentLinkedDequeState
concurrentLinkedDequeState) throws Exception {
    Queue queue = concurrentLinkedDequeState.queue;
    queue.offer(b);
    return  queue.remove(b);
  }


  @State(Scope.Benchmark)
  public static class ConcurrentLinkedQueueState {
    Queue<String> queue = new ConcurrentLinkedQueue<>();
    @Setup
    public void setup() throws ExecutionException, InterruptedException {
      for(int i=0;i<NUM_PRE;i++) queue.offer(a);
    }
  }

  @Benchmark
  public Object measureCLQFixed(final ConcurrentLinkedQueueState
concurrentLinkedQueueState) throws Exception {
    Queue queue = concurrentLinkedQueueState.queue;
    queue.offer(b);
    return queue.remove(b);
  }

  @State(Scope.Benchmark)
  public static class ConcurrentLinkedQueueOrigState {
    Queue<String> queue = new java.util.concurrent.ConcurrentLinkedQueue<>();
    @Setup
    public void setup() throws ExecutionException, InterruptedException {
      for(int i=0;i<NUM_PRE;i++) queue.offer(a);
    }
  }

  @Benchmark
  public Object measureCLQOrig(final ConcurrentLinkedQueueOrigState
state) throws Exception {
    Queue queue = state.queue;
    queue.offer(b);
    return queue.remove(b);
  }
}


On Fri, Feb 26, 2016 at 7:14 PM, Martin Buchholz <martinrb at google.com>
wrote:

> Seems very likely.  You could try to prove it...
>
> On Fri, Feb 26, 2016 at 9:04 AM, Christian Schudt
> <christian.schudt at gmx.de> wrote:
> > I?ve seen that. Is that also the reason for the worse performance?
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Haim Yadid | Performization Expert
Performize-IT | t +972-54-7777132
www.performize-it.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160227/a1209ad9/attachment-0001.html>

From christian.schudt at gmx.de  Sat Feb 27 16:47:34 2016
From: christian.schudt at gmx.de (Christian Schudt)
Date: Sat, 27 Feb 2016 22:47:34 +0100
Subject: [concurrency-interest] ConcurrentLinkedQueue vs.
	ConcurrentLinkedDeque
In-Reply-To: <CAJ-ba_OWEc0rKxb_EwGhp2dxL0x7prdmtt6e4_HCfS6wFHVzqg@mail.gmail.com>
References: <trinity-71b0400b-80e9-4e08-94a8-267a8f9e6544-1456491504335@3capp-gmx-bs51>
	<CA+kOe0_s0P018chyqaC4=PJrUxNHF8REOMPg7Ss=NuK24Ozk5g@mail.gmail.com>
	<CA+kOe09ORcfxRuFC86ia4oE-1zduNSKXPAhypmassNTZeRUJrA@mail.gmail.com>
	<50592279-6C4F-4711-99BE-0674ED13C872@gmx.de>
	<CA+kOe089k++kY6uHRfZYqH+-JcgKgQHr1fvNtqZaMKVu2h2yQQ@mail.gmail.com>
	<CAJ-ba_OWEc0rKxb_EwGhp2dxL0x7prdmtt6e4_HCfS6wFHVzqg@mail.gmail.com>
Message-ID: <BBAD8B86-924F-4606-8113-525093FA59C0@gmx.de>

Hi,

thanks for proving :-)

Do you think it?s fairly safe to assume, that the OOM issue (JDK-8054446) is also the cause for a high CPU usage?

We use CLQ in a simple LRU cache implementation, where a remove() happens every time an element is added to or get from cache (in order to rearrange elements for the least-recently-used logic). After a few hours/days our app has very high CPU, maybe because the remove() takes longer and longer?

This seems to be the same issue:
https://issues.apache.org/jira/browse/AMQ-5337

Ok, even when it?s fixed in JDK 9, when would you use a CLQ over a CLDeque? Is it ?only? to save 40% performance when only needing a queue? (of course still worth it). Maybe the public JavaDoc should mention it.

Best,
Christian


> Am 27.02.2016 um 15:00 schrieb Haim Yadid <haim at performize-it.com>:
> 
> Hi Martin 
> I wrote a simple JMH benchmark to prove it.
> When using ConcurrenLinkedQueue without your fix at JDK-8054446 it is extremely slow your fix solves the problem 
> Here are the results :
> 
> Benchmark                          Mode  Cnt         Score         Error                 Units
> QBench.measureABQ           thrpt    5  17031943.831 ? 8468127.395  ops/s
> QBench.measureCLD           thrpt    5  15410606.543 ?  551687.064  ops/s
> QBench.measureCLQFixed  thrpt    5  27674624.318 ? 1849425.328  ops/s
> QBench.measureCLQOrig    thrpt    5      5527.394 ?    2371.913        ops/s
> 
> Here is the code :
> 
> 
> 
> 
> import org.openjdk.jmh.annotations.Benchmark;
> import org.openjdk.jmh.annotations.BenchmarkMode;
> import org.openjdk.jmh.annotations.Fork;
> import org.openjdk.jmh.annotations.Measurement;
> import org.openjdk.jmh.annotations.Mode;
> import org.openjdk.jmh.annotations.Scope;
> import org.openjdk.jmh.annotations.Setup;
> import org.openjdk.jmh.annotations.State;
> import org.openjdk.jmh.annotations.Threads;
> import org.openjdk.jmh.annotations.Warmup;
> 
> import java.util.Queue;
> import java.util.concurrent.ArrayBlockingQueue;
> import java.util.concurrent.ConcurrentLinkedDeque;
> 
> import java.util.concurrent.ExecutionException;
> 
> 
> @Fork(1)
> @Threads(1)
> @BenchmarkMode({Mode.Throughput})
> @Warmup(iterations = 5)
> @Measurement(iterations = 5)
> public class QBench {
>   static final String a = "a";
>   static final String b = "b";
>   public static final int NUM_PRE = 1;
>   @State(Scope.Benchmark)
>   public static class ArrayBlockingQueueState {
>     Queue<String> queue = new ArrayBlockingQueue<String>(1000);
>     @Setup
>     public void setup() throws ExecutionException, InterruptedException {
>       for(int i=0;i<NUM_PRE;i++) queue.offer(a);
>     }
>   }
>   @Benchmark
>   public Object measureABQ(final ArrayBlockingQueueState arrayBlockingQueueState) throws Exception {
>     Queue queue = arrayBlockingQueueState.queue;
>     queue.offer(b);
>     return queue.remove(b);
> 
>   }
> 
> 
> 
>   @State(Scope.Benchmark)
>   public static class ConcurrentLinkedDequeState {
>     Queue<String> queue = new ConcurrentLinkedDeque<>();
>     @Setup
>     public void setup() throws ExecutionException, InterruptedException {
>       for(int i=0;i<NUM_PRE;i++) queue.offer(a);
>     }
>   }
>   @Benchmark
>   public Object measureCLD(final ConcurrentLinkedDequeState concurrentLinkedDequeState) throws Exception {
>     Queue queue = concurrentLinkedDequeState.queue;
>     queue.offer(b);
>     return  queue.remove(b);
>   }
> 
> 
>   @State(Scope.Benchmark)
>   public static class ConcurrentLinkedQueueState {
>     Queue<String> queue = new ConcurrentLinkedQueue<>();
>     @Setup
>     public void setup() throws ExecutionException, InterruptedException {
>       for(int i=0;i<NUM_PRE;i++) queue.offer(a);
>     }
>   }
> 
>   @Benchmark
>   public Object measureCLQFixed(final ConcurrentLinkedQueueState concurrentLinkedQueueState) throws Exception {
>     Queue queue = concurrentLinkedQueueState.queue;
>     queue.offer(b);
>     return queue.remove(b);
>   }
> 
>   @State(Scope.Benchmark)
>   public static class ConcurrentLinkedQueueOrigState {
>     Queue<String> queue = new java.util.concurrent.ConcurrentLinkedQueue<>();
>     @Setup
>     public void setup() throws ExecutionException, InterruptedException {
>       for(int i=0;i<NUM_PRE;i++) queue.offer(a);
>     }
>   }
> 
>   @Benchmark
>   public Object measureCLQOrig(final ConcurrentLinkedQueueOrigState state) throws Exception {
>     Queue queue = state.queue;
>     queue.offer(b);
>     return queue.remove(b);
>   }
> }
> 
> On Fri, Feb 26, 2016 at 7:14 PM, Martin Buchholz <martinrb at google.com> wrote:
> Seems very likely.  You could try to prove it...
> 
> On Fri, Feb 26, 2016 at 9:04 AM, Christian Schudt
> <christian.schudt at gmx.de> wrote:
> > I?ve seen that. Is that also the reason for the worse performance?
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> 
> -- 
> Haim Yadid | Performization Expert 
> Performize-IT | t +972-54-7777132
> www.performize-it.com



From martinrb at google.com  Sat Feb 27 22:44:19 2016
From: martinrb at google.com (Martin Buchholz)
Date: Sat, 27 Feb 2016 19:44:19 -0800
Subject: [concurrency-interest] ConcurrentLinkedQueue vs.
	ConcurrentLinkedDeque
In-Reply-To: <BBAD8B86-924F-4606-8113-525093FA59C0@gmx.de>
References: <trinity-71b0400b-80e9-4e08-94a8-267a8f9e6544-1456491504335@3capp-gmx-bs51>
	<CA+kOe0_s0P018chyqaC4=PJrUxNHF8REOMPg7Ss=NuK24Ozk5g@mail.gmail.com>
	<CA+kOe09ORcfxRuFC86ia4oE-1zduNSKXPAhypmassNTZeRUJrA@mail.gmail.com>
	<50592279-6C4F-4711-99BE-0674ED13C872@gmx.de>
	<CA+kOe089k++kY6uHRfZYqH+-JcgKgQHr1fvNtqZaMKVu2h2yQQ@mail.gmail.com>
	<CAJ-ba_OWEc0rKxb_EwGhp2dxL0x7prdmtt6e4_HCfS6wFHVzqg@mail.gmail.com>
	<BBAD8B86-924F-4606-8113-525093FA59C0@gmx.de>
Message-ID: <CA+kOe09qqESazF6YbFvgxMdc=HJ29AYG+=VCtuONR2kkQ_WuVw@mail.gmail.com>

Well done! Y'all guilted me into backporting to jdk8
https://bugs.openjdk.java.net/browse/JDK-8150780
There's even a test.

On Sat, Feb 27, 2016 at 1:47 PM, Christian Schudt
<christian.schudt at gmx.de> wrote:
> Hi,
>
> thanks for proving :-)
>
> Do you think it?s fairly safe to assume, that the OOM issue (JDK-8054446) is also the cause for a high CPU usage?
>
> We use CLQ in a simple LRU cache implementation, where a remove() happens every time an element is added to or get from cache (in order to rearrange elements for the least-recently-used logic). After a few hours/days our app has very high CPU, maybe because the remove() takes longer and longer?
>
> This seems to be the same issue:
> https://issues.apache.org/jira/browse/AMQ-5337
>
> Ok, even when it?s fixed in JDK 9, when would you use a CLQ over a CLDeque? Is it ?only? to save 40% performance when only needing a queue? (of course still worth it). Maybe the public JavaDoc should mention it.
>
> Best,
> Christian
>
>
>> Am 27.02.2016 um 15:00 schrieb Haim Yadid <haim at performize-it.com>:
>>
>> Hi Martin
>> I wrote a simple JMH benchmark to prove it.
>> When using ConcurrenLinkedQueue without your fix at JDK-8054446 it is extremely slow your fix solves the problem
>> Here are the results :
>>
>> Benchmark                          Mode  Cnt         Score         Error                 Units
>> QBench.measureABQ           thrpt    5  17031943.831 ? 8468127.395  ops/s
>> QBench.measureCLD           thrpt    5  15410606.543 ?  551687.064  ops/s
>> QBench.measureCLQFixed  thrpt    5  27674624.318 ? 1849425.328  ops/s
>> QBench.measureCLQOrig    thrpt    5      5527.394 ?    2371.913        ops/s
>>
>> Here is the code :
>>
>>
>>
>>
>> import org.openjdk.jmh.annotations.Benchmark;
>> import org.openjdk.jmh.annotations.BenchmarkMode;
>> import org.openjdk.jmh.annotations.Fork;
>> import org.openjdk.jmh.annotations.Measurement;
>> import org.openjdk.jmh.annotations.Mode;
>> import org.openjdk.jmh.annotations.Scope;
>> import org.openjdk.jmh.annotations.Setup;
>> import org.openjdk.jmh.annotations.State;
>> import org.openjdk.jmh.annotations.Threads;
>> import org.openjdk.jmh.annotations.Warmup;
>>
>> import java.util.Queue;
>> import java.util.concurrent.ArrayBlockingQueue;
>> import java.util.concurrent.ConcurrentLinkedDeque;
>>
>> import java.util.concurrent.ExecutionException;
>>
>>
>> @Fork(1)
>> @Threads(1)
>> @BenchmarkMode({Mode.Throughput})
>> @Warmup(iterations = 5)
>> @Measurement(iterations = 5)
>> public class QBench {
>>   static final String a = "a";
>>   static final String b = "b";
>>   public static final int NUM_PRE = 1;
>>   @State(Scope.Benchmark)
>>   public static class ArrayBlockingQueueState {
>>     Queue<String> queue = new ArrayBlockingQueue<String>(1000);
>>     @Setup
>>     public void setup() throws ExecutionException, InterruptedException {
>>       for(int i=0;i<NUM_PRE;i++) queue.offer(a);
>>     }
>>   }
>>   @Benchmark
>>   public Object measureABQ(final ArrayBlockingQueueState arrayBlockingQueueState) throws Exception {
>>     Queue queue = arrayBlockingQueueState.queue;
>>     queue.offer(b);
>>     return queue.remove(b);
>>
>>   }
>>
>>
>>
>>   @State(Scope.Benchmark)
>>   public static class ConcurrentLinkedDequeState {
>>     Queue<String> queue = new ConcurrentLinkedDeque<>();
>>     @Setup
>>     public void setup() throws ExecutionException, InterruptedException {
>>       for(int i=0;i<NUM_PRE;i++) queue.offer(a);
>>     }
>>   }
>>   @Benchmark
>>   public Object measureCLD(final ConcurrentLinkedDequeState concurrentLinkedDequeState) throws Exception {
>>     Queue queue = concurrentLinkedDequeState.queue;
>>     queue.offer(b);
>>     return  queue.remove(b);
>>   }
>>
>>
>>   @State(Scope.Benchmark)
>>   public static class ConcurrentLinkedQueueState {
>>     Queue<String> queue = new ConcurrentLinkedQueue<>();
>>     @Setup
>>     public void setup() throws ExecutionException, InterruptedException {
>>       for(int i=0;i<NUM_PRE;i++) queue.offer(a);
>>     }
>>   }
>>
>>   @Benchmark
>>   public Object measureCLQFixed(final ConcurrentLinkedQueueState concurrentLinkedQueueState) throws Exception {
>>     Queue queue = concurrentLinkedQueueState.queue;
>>     queue.offer(b);
>>     return queue.remove(b);
>>   }
>>
>>   @State(Scope.Benchmark)
>>   public static class ConcurrentLinkedQueueOrigState {
>>     Queue<String> queue = new java.util.concurrent.ConcurrentLinkedQueue<>();
>>     @Setup
>>     public void setup() throws ExecutionException, InterruptedException {
>>       for(int i=0;i<NUM_PRE;i++) queue.offer(a);
>>     }
>>   }
>>
>>   @Benchmark
>>   public Object measureCLQOrig(final ConcurrentLinkedQueueOrigState state) throws Exception {
>>     Queue queue = state.queue;
>>     queue.offer(b);
>>     return queue.remove(b);
>>   }
>> }
>>
>> On Fri, Feb 26, 2016 at 7:14 PM, Martin Buchholz <martinrb at google.com> wrote:
>> Seems very likely.  You could try to prove it...
>>
>> On Fri, Feb 26, 2016 at 9:04 AM, Christian Schudt
>> <christian.schudt at gmx.de> wrote:
>> > I?ve seen that. Is that also the reason for the worse performance?
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>> --
>> Haim Yadid | Performization Expert
>> Performize-IT | t +972-54-7777132
>> www.performize-it.com
>


From martinrb at google.com  Sun Feb 28 01:14:41 2016
From: martinrb at google.com (Martin Buchholz)
Date: Sat, 27 Feb 2016 22:14:41 -0800
Subject: [concurrency-interest] ConcurrentLinkedQueue vs.
	ConcurrentLinkedDeque
In-Reply-To: <BBAD8B86-924F-4606-8113-525093FA59C0@gmx.de>
References: <trinity-71b0400b-80e9-4e08-94a8-267a8f9e6544-1456491504335@3capp-gmx-bs51>
	<CA+kOe0_s0P018chyqaC4=PJrUxNHF8REOMPg7Ss=NuK24Ozk5g@mail.gmail.com>
	<CA+kOe09ORcfxRuFC86ia4oE-1zduNSKXPAhypmassNTZeRUJrA@mail.gmail.com>
	<50592279-6C4F-4711-99BE-0674ED13C872@gmx.de>
	<CA+kOe089k++kY6uHRfZYqH+-JcgKgQHr1fvNtqZaMKVu2h2yQQ@mail.gmail.com>
	<CAJ-ba_OWEc0rKxb_EwGhp2dxL0x7prdmtt6e4_HCfS6wFHVzqg@mail.gmail.com>
	<BBAD8B86-924F-4606-8113-525093FA59C0@gmx.de>
Message-ID: <CA+kOe0-hdaXD+gtO5cV_T_QjGK7n=WDktqkNjFnqrzETrj1rig@mail.gmail.com>

On Sat, Feb 27, 2016 at 1:47 PM, Christian Schudt
<christian.schudt at gmx.de> wrote:
> Ok, even when it?s fixed in JDK 9, when would you use a CLQ over a CLDeque? Is it ?only? to save 40% performance when only needing a queue? (of course still worth it). Maybe the public JavaDoc should mention it.

It's funny you ask that.  I love ConcurrentLinkedDeque, but mostly for
the cool tech ("it's impossible to safely update a lock-free doubly
linked list"), but I don't have a good example of when you need it -
in practice a concurrent queue is usually good enough.
ConcurrentLinkedQueue is simpler and uses less computing resources


From peter.levart at gmail.com  Sun Feb 28 08:19:00 2016
From: peter.levart at gmail.com (Peter Levart)
Date: Sun, 28 Feb 2016 14:19:00 +0100
Subject: [concurrency-interest] ConcurrentLinkedQueue vs.
 ConcurrentLinkedDeque
In-Reply-To: <CA+kOe0-hdaXD+gtO5cV_T_QjGK7n=WDktqkNjFnqrzETrj1rig@mail.gmail.com>
References: <trinity-71b0400b-80e9-4e08-94a8-267a8f9e6544-1456491504335@3capp-gmx-bs51>
	<CA+kOe0_s0P018chyqaC4=PJrUxNHF8REOMPg7Ss=NuK24Ozk5g@mail.gmail.com>
	<CA+kOe09ORcfxRuFC86ia4oE-1zduNSKXPAhypmassNTZeRUJrA@mail.gmail.com>
	<50592279-6C4F-4711-99BE-0674ED13C872@gmx.de>
	<CA+kOe089k++kY6uHRfZYqH+-JcgKgQHr1fvNtqZaMKVu2h2yQQ@mail.gmail.com>
	<CAJ-ba_OWEc0rKxb_EwGhp2dxL0x7prdmtt6e4_HCfS6wFHVzqg@mail.gmail.com>
	<BBAD8B86-924F-4606-8113-525093FA59C0@gmx.de>
	<CA+kOe0-hdaXD+gtO5cV_T_QjGK7n=WDktqkNjFnqrzETrj1rig@mail.gmail.com>
Message-ID: <56D2F3C4.70705@gmail.com>



On 02/28/2016 07:14 AM, Martin Buchholz wrote:
> On Sat, Feb 27, 2016 at 1:47 PM, Christian Schudt
> <christian.schudt at gmx.de> wrote:
>> Ok, even when it?s fixed in JDK 9, when would you use a CLQ over a CLDeque? Is it ?only? to save 40% performance when only needing a queue? (of course still worth it). Maybe the public JavaDoc should mention it.
> It's funny you ask that.  I love ConcurrentLinkedDeque, but mostly for
> the cool tech ("it's impossible to safely update a lock-free doubly
> linked list"), but I don't have a good example of when you need it -
> in practice a concurrent queue is usually good enough.
> ConcurrentLinkedQueue is simpler and uses less computing resources

ConcurrentLinkedDeque would be very nice if there was a way to get 
access to internal node when adding an element to the deque. One would 
then be able to remove the element in constant time. Something in the 
lines of this:

http://cr.openjdk.java.net/~plevart/jdk9-dev/ConcurrentLinkedDeque.Insert/webrev.01/

Regards, Peter

> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160228/ea63643b/attachment.html>

From martinrb at google.com  Sun Feb 28 14:25:19 2016
From: martinrb at google.com (Martin Buchholz)
Date: Sun, 28 Feb 2016 11:25:19 -0800
Subject: [concurrency-interest] ConcurrentLinkedQueue vs.
	ConcurrentLinkedDeque
In-Reply-To: <56D2F3C4.70705@gmail.com>
References: <trinity-71b0400b-80e9-4e08-94a8-267a8f9e6544-1456491504335@3capp-gmx-bs51>
	<CA+kOe0_s0P018chyqaC4=PJrUxNHF8REOMPg7Ss=NuK24Ozk5g@mail.gmail.com>
	<CA+kOe09ORcfxRuFC86ia4oE-1zduNSKXPAhypmassNTZeRUJrA@mail.gmail.com>
	<50592279-6C4F-4711-99BE-0674ED13C872@gmx.de>
	<CA+kOe089k++kY6uHRfZYqH+-JcgKgQHr1fvNtqZaMKVu2h2yQQ@mail.gmail.com>
	<CAJ-ba_OWEc0rKxb_EwGhp2dxL0x7prdmtt6e4_HCfS6wFHVzqg@mail.gmail.com>
	<BBAD8B86-924F-4606-8113-525093FA59C0@gmx.de>
	<CA+kOe0-hdaXD+gtO5cV_T_QjGK7n=WDktqkNjFnqrzETrj1rig@mail.gmail.com>
	<56D2F3C4.70705@gmail.com>
Message-ID: <CA+kOe0_BqNqOU4+O=e_eOBE6Do7+FbZAQDPYui9N_8nOMuVFAg@mail.gmail.com>

On Sun, Feb 28, 2016 at 5:19 AM, Peter Levart <peter.levart at gmail.com> wrote:
> ConcurrentLinkedDeque would be very nice if there was a way to get access to
> internal node when adding an element to the deque. One would then be able to
> remove the element in constant time. Something in the lines of this:

People have had similar ideas before.  Google has experimented with
extensions to Collection that exposes internal Node objects, but they
haven't become very popular.  I support the idea in principle, but we
don't know how to best construct such a public API.  The Iterator
interface is similar, and also contains a remove method (unfortunately
with void return).  In some of our other classes (ArrayBlockingQueue)
herculean efforts are required to support Iterator because the current
position of an element is dynamic.  We know how to remove Nodes
efficiently from concurrent double linked lists, but not from single
linked lists.... well ... actually we try to do this for the internal
list of Iterators in ABQ:

        /**
         * Sweeps itrs, looking for and expunging stale iterators.
         * If at least one was found, tries harder to find more.
         * Called only from iterating thread.
         *
         * @param tryHarder whether to start in try-harder mode, because
         * there is known to be at least one iterator to collect
         */
        void doSomeSweeping(boolean tryHarder) {

From nader at aeinehchi.com  Mon Feb 29 14:17:58 2016
From: nader at aeinehchi.com (Nader Aeinehchi)
Date: Mon, 29 Feb 2016 20:17:58 +0100
Subject: [concurrency-interest] Is this a pattern or an anti-pattern for
	check-and-act?
Message-ID: <CAMjJYBmW+VzbOqa86uCgEudMAJAhXkS194Xq-GcQEUyP5h41_g@mail.gmail.com>

Hello

I saw this pattern on an open source project, and wonder if it is thread
safe?  If so, would it scale?

    private final static Object lock = new Object();

    private static Foo foo;

    public static Foo getInstance(){

        if(foo == null){
            synchronized (lock){
                if(foo == null){
                    foo = new Foo();
                }
            }
        }

        return foo;
    }

In advance, thank you very much

Nader
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160229/eb6b1537/attachment.html>

From christian.schudt at gmx.de  Mon Feb 29 14:37:38 2016
From: christian.schudt at gmx.de (Christian Schudt)
Date: Mon, 29 Feb 2016 20:37:38 +0100
Subject: [concurrency-interest] Is this a pattern or an anti-pattern for
	check-and-act?
In-Reply-To: <CAMjJYBmW+VzbOqa86uCgEudMAJAhXkS194Xq-GcQEUyP5h41_g@mail.gmail.com>
References: <CAMjJYBmW+VzbOqa86uCgEudMAJAhXkS194Xq-GcQEUyP5h41_g@mail.gmail.com>
Message-ID: <B4FB6FF7-94EC-40E8-999C-854B0A974EAF@gmx.de>

Hi,

foo should be volatile. Why is explained in the following link.

You want to read into ?Double-Checked Locking?:
https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java

It also recommends to copy foo to a local variable to save expensive reads on the volatile variable, "which can improve the method's overall performance by as much as 25 percent?.

This seems to be the best version:

class Foo {
    private volatile Helper helper;
    public Helper getHelper() {
        Helper result = helper;
        if (result == null) {
            synchronized(this) {
                result = helper;
                if (result == null) {
                    helper = result = new Helper();
                }
            }
        }
        return result;
    }
}


? Christian


> Am 29.02.2016 um 20:17 schrieb Nader Aeinehchi <nader at aeinehchi.com>:
> 
> Hello
> 
> I saw this pattern on an open source project, and wonder if it is thread safe?  If so, would it scale?
> 
>     private final static Object lock = new Object();
> 
>     private static Foo foo;
> 
>     public static Foo getInstance(){
> 
>         if(foo == null){
>             synchronized (lock){
>                 if(foo == null){
>                     foo = new Foo();
>                 }
>             }
>         }
> 
>         return foo;
>     }
> 
> In advance, thank you very much
> 
> Nader
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From arno.haase at haase-consulting.com  Mon Feb 29 15:06:10 2016
From: arno.haase at haase-consulting.com (Arno Haase)
Date: Mon, 29 Feb 2016 21:06:10 +0100
Subject: [concurrency-interest] Is this a pattern or an anti-pattern for
 check-and-act?
In-Reply-To: <B4FB6FF7-94EC-40E8-999C-854B0A974EAF@gmx.de>
References: <CAMjJYBmW+VzbOqa86uCgEudMAJAhXkS194Xq-GcQEUyP5h41_g@mail.gmail.com>
	<B4FB6FF7-94EC-40E8-999C-854B0A974EAF@gmx.de>
Message-ID: <56D4A4B2.1050405@haase-consulting.com>

Yes, it works, i.e. it ensures thread-safe lazy initialization - if the
doubly checked variable is volatile, as pointed out by Christian.

Regarding 'scaling', I am not sure what you mean, Nader. Your original
code snippet initializes a static variable, i.e. a singleton - what do
you mean by scaling singleton initialization?

While there are valid use cases for lazy initialization (e.g. Scala's
'lazy val'), if performance and scaling is a priority, there is a
variety of ways to safely publish state changes. For some problems,
there are solutions that do not incur the overhead of even a volatile
read on every access.

If you explain the problem you are trying to solve, we could discuss
alternative approaches.

- Arno


Am 29.02.2016 um 20:37 schrieb Christian Schudt:
> Hi,
> 
> foo should be volatile. Why is explained in the following link.
> 
> You want to read into ?Double-Checked Locking?:
> https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java
> 
> It also recommends to copy foo to a local variable to save expensive reads on the volatile variable, "which can improve the method's overall performance by as much as 25 percent?.
> 
> This seems to be the best version:
> 
> class Foo {
>     private volatile Helper helper;
>     public Helper getHelper() {
>         Helper result = helper;
>         if (result == null) {
>             synchronized(this) {
>                 result = helper;
>                 if (result == null) {
>                     helper = result = new Helper();
>                 }
>             }
>         }
>         return result;
>     }
> }
> 
> 
> ? Christian
> 
> 
>> Am 29.02.2016 um 20:17 schrieb Nader Aeinehchi <nader at aeinehchi.com>:
>>
>> Hello
>>
>> I saw this pattern on an open source project, and wonder if it is thread safe?  If so, would it scale?
>>
>>     private final static Object lock = new Object();
>>
>>     private static Foo foo;
>>
>>     public static Foo getInstance(){
>>
>>         if(foo == null){
>>             synchronized (lock){
>>                 if(foo == null){
>>                     foo = new Foo();
>>                 }
>>             }
>>         }
>>
>>         return foo;
>>     }
>>
>> In advance, thank you very much
>>
>> Nader
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From aleksey.shipilev at oracle.com  Mon Feb 29 15:31:24 2016
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Mon, 29 Feb 2016 23:31:24 +0300
Subject: [concurrency-interest] Is this a pattern or an anti-pattern for
 check-and-act?
In-Reply-To: <CAMjJYBmW+VzbOqa86uCgEudMAJAhXkS194Xq-GcQEUyP5h41_g@mail.gmail.com>
References: <CAMjJYBmW+VzbOqa86uCgEudMAJAhXkS194Xq-GcQEUyP5h41_g@mail.gmail.com>
Message-ID: <56D4AA9C.6040900@oracle.com>

On 02/29/2016 10:17 PM, Nader Aeinehchi wrote:
> I saw this pattern on an open source project, and wonder if it is thread
> safe?  If so, would it scale?

See:
 http://shipilev.net/blog/2014/safe-public-construction/

-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160229/20e1cbd6/attachment.bin>

