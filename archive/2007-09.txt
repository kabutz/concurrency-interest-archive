From hanson.char at gmail.com  Sat Sep  1 02:31:34 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Fri, 31 Aug 2007 23:31:34 -0700
Subject: [concurrency-interest] Parametric Initialization On Demand
	Holder Idiom ?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEHAHIAA.dcholmes@optusnet.com.au>
References: <ca53c8f80708302141s76040adbh2523f771fd29bda3@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCMEHAHIAA.dcholmes@optusnet.com.au>
Message-ID: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>

David,

After reviewing JLS 17.5.1 Semantics of Final Fields, I agree the lack
of happens-before relationship makes it unsafe in the general case.
In other words, despite the use of the final qualifier, a mere
thread-safe (but not super-safe like immutable) object passed to the
SomethingMore.getInstance(params) could cause a partially-initialized
object to be seen, similar to the double-checked locking problem.

However, what if the object passed to the
SomethingMore.getInstance(params) is required to be an immutable
object ?  That would make the unsafe publication irrelevant, and allow
this proposed idiom to be thread-safe.  Correct ?

Hanson Char

On 8/31/07, David Holmes <dcholmes at optusnet.com.au> wrote:
> Hanson, Joe,
>
> > Agree.  However, is it possible to contrive an example where a
> > thread-safe (but not super-safe like  immutable) value passed to the
> > SomethingMore.getInstance(params) would cause a
> > surprising/unexpected/corrupted/partially-initialized result ?
>
> I think the general answer is yes. If thread-1 sets valueHolder and thread-2
> does LazySomethingMoreHolder.something (because concurrent calls to
> getInstance are interleaved) and then thread-2 uses the object created by
> thread-1, then it is using an unsafely published object. There is no
> happens-before relationship between the construction of the object by
> thread-1 and its use in thread-2.
>
> Now Joe has pointed out the rule for final fields, but I don't think that
> quite applies to this situation - or if it does then there is a problem for
> VM implementors.
>
> The final-field rule allows you to unsafely publish an object but have final
> fields of that object safely visible and "the objects to which they refer".
> But I believe the intent there was to cover the case where the thread
> setting the final field *also* constructed the object. That is not the case
> here.
>
> Suppose the final-field rule does apply, then when thread-1 does:
>
>  Foo f = new Foo();
>  SomethingMore.valueHolder = f;
>
> the VM has to know that valueHolder will soon be assigned to a final field
> in another thread, and force a happens-before ordering between the two
> actions. But the VM can't know that will happen so it won't do anything to
> enforce happens before.
>
> Of course, depending on the nature of the object itself it might be harmless
> to unsafely publish it.
>
> That's my take anyway  - perhaps we need to discuss this on the JMM mailing
> list :)
>
> Cheers,
> David Holmes
>
>

From hanson.char at gmail.com  Sun Sep  2 00:17:06 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Sat, 1 Sep 2007 21:17:06 -0700
Subject: [concurrency-interest] Parametric Initialization On Demand
	Holder Idiom ?
In-Reply-To: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
References: <ca53c8f80708302141s76040adbh2523f771fd29bda3@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCMEHAHIAA.dcholmes@optusnet.com.au>
	<ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
Message-ID: <ca53c8f80709012117p4c4a1619oa4e3b55dc62e0368@mail.gmail.com>

I think the two implementations are now thread-safe:

  http://hansonchar.blogspot.com/#piodhi-immutable
  http://hansonchar.blogspot.com/#piodhi-thread-safe

Please let me know if anyone spots anything otherwise.  Thanks in advance.

Hanson Char

From dcholmes at optusnet.com.au  Sun Sep  2 19:02:58 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 3 Sep 2007 09:02:58 +1000
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>

Hi Hanson,

If the object is safe even under unsafe-publication, then there is no
problem. Immutability itself is not sufficient, the object must use final
fields to enforce immutability - ie it must be written to be safe even in
the face of un-safe publication.

Cheers,
David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Hanson
> Char
> Sent: Saturday, 1 September 2007 4:32 PM
> To: dholmes at ieee.org
> Cc: Joe Bowbeer; concurrency-interest
> Subject: Re: [concurrency-interest] Parametric Initialization On
> DemandHolder Idiom ?
>
>
> David,
>
> After reviewing JLS 17.5.1 Semantics of Final Fields, I agree the lack
> of happens-before relationship makes it unsafe in the general case.
> In other words, despite the use of the final qualifier, a mere
> thread-safe (but not super-safe like immutable) object passed to the
> SomethingMore.getInstance(params) could cause a partially-initialized
> object to be seen, similar to the double-checked locking problem.
>
> However, what if the object passed to the
> SomethingMore.getInstance(params) is required to be an immutable
> object ?  That would make the unsafe publication irrelevant, and allow
> this proposed idiom to be thread-safe.  Correct ?
>
> Hanson Char
>
> On 8/31/07, David Holmes <dcholmes at optusnet.com.au> wrote:
> > Hanson, Joe,
> >
> > > Agree.  However, is it possible to contrive an example where a
> > > thread-safe (but not super-safe like  immutable) value passed to the
> > > SomethingMore.getInstance(params) would cause a
> > > surprising/unexpected/corrupted/partially-initialized result ?
> >
> > I think the general answer is yes. If thread-1 sets valueHolder
> and thread-2
> > does LazySomethingMoreHolder.something (because concurrent calls to
> > getInstance are interleaved) and then thread-2 uses the object
> created by
> > thread-1, then it is using an unsafely published object. There is no
> > happens-before relationship between the construction of the object by
> > thread-1 and its use in thread-2.
> >
> > Now Joe has pointed out the rule for final fields, but I don't
> think that
> > quite applies to this situation - or if it does then there is a
> problem for
> > VM implementors.
> >
> > The final-field rule allows you to unsafely publish an object
> but have final
> > fields of that object safely visible and "the objects to which
> they refer".
> > But I believe the intent there was to cover the case where the thread
> > setting the final field *also* constructed the object. That is
> not the case
> > here.
> >
> > Suppose the final-field rule does apply, then when thread-1 does:
> >
> >  Foo f = new Foo();
> >  SomethingMore.valueHolder = f;
> >
> > the VM has to know that valueHolder will soon be assigned to a
> final field
> > in another thread, and force a happens-before ordering between the two
> > actions. But the VM can't know that will happen so it won't do
> anything to
> > enforce happens before.
> >
> > Of course, depending on the nature of the object itself it
> might be harmless
> > to unsafely publish it.
> >
> > That's my take anyway  - perhaps we need to discuss this on the
> JMM mailing
> > list :)
> >
> > Cheers,
> > David Holmes
> >
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From hanson.char at gmail.com  Mon Sep  3 01:37:36 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Sun, 2 Sep 2007 22:37:36 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>
Message-ID: <ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>

Hi David,

Agree.  I always thought the term "Immutability" in Java implies the
use of final fields.

  "Final fields must be used to provide a guarantee of immutability."

  - Section 17.5 (Final Field Semantics) of JLS 3.0 p.573.

Hanson Char

On 9/2/07, David Holmes <dcholmes at optusnet.com.au> wrote:
> Hi Hanson,
>
> If the object is safe even under unsafe-publication, then there is no
> problem. Immutability itself is not sufficient, the object must use final
> fields to enforce immutability - ie it must be written to be safe even in
> the face of un-safe publication.
>
> Cheers,
> David
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Hanson
> > Char
> > Sent: Saturday, 1 September 2007 4:32 PM
> > To: dholmes at ieee.org
> > Cc: Joe Bowbeer; concurrency-interest
> > Subject: Re: [concurrency-interest] Parametric Initialization On
> > DemandHolder Idiom ?
> >
> >
> > David,
> >
> > After reviewing JLS 17.5.1 Semantics of Final Fields, I agree the lack
> > of happens-before relationship makes it unsafe in the general case.
> > In other words, despite the use of the final qualifier, a mere
> > thread-safe (but not super-safe like immutable) object passed to the
> > SomethingMore.getInstance(params) could cause a partially-initialized
> > object to be seen, similar to the double-checked locking problem.
> >
> > However, what if the object passed to the
> > SomethingMore.getInstance(params) is required to be an immutable
> > object ?  That would make the unsafe publication irrelevant, and allow
> > this proposed idiom to be thread-safe.  Correct ?
> >
> > Hanson Char
> >
> > On 8/31/07, David Holmes <dcholmes at optusnet.com.au> wrote:
> > > Hanson, Joe,
> > >
> > > > Agree.  However, is it possible to contrive an example where a
> > > > thread-safe (but not super-safe like  immutable) value passed to the
> > > > SomethingMore.getInstance(params) would cause a
> > > > surprising/unexpected/corrupted/partially-initialized result ?
> > >
> > > I think the general answer is yes. If thread-1 sets valueHolder
> > and thread-2
> > > does LazySomethingMoreHolder.something (because concurrent calls to
> > > getInstance are interleaved) and then thread-2 uses the object
> > created by
> > > thread-1, then it is using an unsafely published object. There is no
> > > happens-before relationship between the construction of the object by
> > > thread-1 and its use in thread-2.
> > >
> > > Now Joe has pointed out the rule for final fields, but I don't
> > think that
> > > quite applies to this situation - or if it does then there is a
> > problem for
> > > VM implementors.
> > >
> > > The final-field rule allows you to unsafely publish an object
> > but have final
> > > fields of that object safely visible and "the objects to which
> > they refer".
> > > But I believe the intent there was to cover the case where the thread
> > > setting the final field *also* constructed the object. That is
> > not the case
> > > here.
> > >
> > > Suppose the final-field rule does apply, then when thread-1 does:
> > >
> > >  Foo f = new Foo();
> > >  SomethingMore.valueHolder = f;
> > >
> > > the VM has to know that valueHolder will soon be assigned to a
> > final field
> > > in another thread, and force a happens-before ordering between the two
> > > actions. But the VM can't know that will happen so it won't do
> > anything to
> > > enforce happens before.
> > >
> > > Of course, depending on the nature of the object itself it
> > might be harmless
> > > to unsafely publish it.
> > >
> > > That's my take anyway  - perhaps we need to discuss this on the
> > JMM mailing
> > > list :)
> > >
> > > Cheers,
> > > David Holmes
> > >
> > >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From glyn.normington at gmail.com  Mon Sep  3 05:52:36 2007
From: glyn.normington at gmail.com (Glyn Normington)
Date: Mon, 3 Sep 2007 10:52:36 +0100
Subject: [concurrency-interest] Fwd:  Fixed thread pool problem?
In-Reply-To: <5668a1520709030251t2885883bla26904f40ef2d942@mail.gmail.com>
References: <5668a1520708310910n4d896c64u19a9dd55a0e10827@mail.gmail.com>
	<46D8A112.20705@cs.oswego.edu>
	<5668a1520709030251t2885883bla26904f40ef2d942@mail.gmail.com>
Message-ID: <5668a1520709030252t7fad8cdcw51cc230e0be640f4@mail.gmail.com>

Forgot to cc the list...

---------- Forwarded message ----------
From: Glyn Normington <glyn.normington at gmail.com>
Date: 03-Sep-2007 10:51
Subject: Re: [concurrency-interest] Fixed thread pool problem?
To: Doug Lea <dl at cs.oswego.edu>



On 01/09/07, Doug Lea <dl at cs.oswego.edu> wrote:
>
> Glyn Normington wrote:
> > so the
> > only source code I've found for the concurrency utilities is some early
> > "public domain" code, so I haven't been able to get much further in
> > analysis.
> >
>
> (Not that you needed see them to answer this,
> but the definitive public domain sources
> for j.u.c. are always in our CVS -- see the usual links at
> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html --
> although we don't always know exactly which CVS revisions
> any particular version of any JVM is based on.)


Ok - thanks.

> and watch the CPU utilisation using a system monitor. On a dual or quad
> > CPU system, this stays at around one processor's worth.
> >
>
> I think the lack of speedup is mostly due to synchronization
> in Generation.equals? It seems that there's a lot of
> lock contention there. (This is in addition to the explanation
> of the infinite loop anomalies by Joe.)


Disregarding my failed attempt to analyse the lack of speedup by inserting
infinite loops, I'd still like to understand the lack of speedup.

I attempted to avoid the contention you refer to by cloning the current
Generation in the Scanner constructor. Each Scanner instance should run on a
separate element of the previous array and should use its own clone of the
current Generation. Did you measure actual contention or spot it as likely
in the source code?

(BTW, For fun, someone might want to try a ParallelArray version
> of this code?)
>
> -Doug
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070903/4679bea4/attachment.html 

From dhanji at gmail.com  Mon Sep  3 06:10:22 2007
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Mon, 3 Sep 2007 20:10:22 +1000
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
Message-ID: <aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>

Is the lack of methods to alter an objects state after construction also
considered immutability? I would say yes in the following case:

public class Immutable { private boolean t; }

Would I be wrong?

On 9/3/07, Hanson Char <hanson.char at gmail.com> wrote:
>
> Hi David,
>
> Agree.  I always thought the term "Immutability" in Java implies the
> use of final fields.
>
>   "Final fields must be used to provide a guarantee of immutability."
>
>   - Section 17.5 (Final Field Semantics) of JLS 3.0 p.573.
>
> Hanson Char
>
> On 9/2/07, David Holmes <dcholmes at optusnet.com.au> wrote:
> > Hi Hanson,
> >
> > If the object is safe even under unsafe-publication, then there is no
> > problem. Immutability itself is not sufficient, the object must use
> final
> > fields to enforce immutability - ie it must be written to be safe even
> in
> > the face of un-safe publication.
> >
> > Cheers,
> > David
> >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Hanson
> > > Char
> > > Sent: Saturday, 1 September 2007 4:32 PM
> > > To: dholmes at ieee.org
> > > Cc: Joe Bowbeer; concurrency-interest
> > > Subject: Re: [concurrency-interest] Parametric Initialization On
> > > DemandHolder Idiom ?
> > >
> > >
> > > David,
> > >
> > > After reviewing JLS 17.5.1 Semantics of Final Fields, I agree the lack
> > > of happens-before relationship makes it unsafe in the general case.
> > > In other words, despite the use of the final qualifier, a mere
> > > thread-safe (but not super-safe like immutable) object passed to the
> > > SomethingMore.getInstance(params) could cause a partially-initialized
> > > object to be seen, similar to the double-checked locking problem.
> > >
> > > However, what if the object passed to the
> > > SomethingMore.getInstance(params) is required to be an immutable
> > > object ?  That would make the unsafe publication irrelevant, and allow
> > > this proposed idiom to be thread-safe.  Correct ?
> > >
> > > Hanson Char
> > >
> > > On 8/31/07, David Holmes <dcholmes at optusnet.com.au> wrote:
> > > > Hanson, Joe,
> > > >
> > > > > Agree.  However, is it possible to contrive an example where a
> > > > > thread-safe (but not super-safe like  immutable) value passed to
> the
> > > > > SomethingMore.getInstance(params) would cause a
> > > > > surprising/unexpected/corrupted/partially-initialized result ?
> > > >
> > > > I think the general answer is yes. If thread-1 sets valueHolder
> > > and thread-2
> > > > does LazySomethingMoreHolder.something (because concurrent calls to
> > > > getInstance are interleaved) and then thread-2 uses the object
> > > created by
> > > > thread-1, then it is using an unsafely published object. There is no
> > > > happens-before relationship between the construction of the object
> by
> > > > thread-1 and its use in thread-2.
> > > >
> > > > Now Joe has pointed out the rule for final fields, but I don't
> > > think that
> > > > quite applies to this situation - or if it does then there is a
> > > problem for
> > > > VM implementors.
> > > >
> > > > The final-field rule allows you to unsafely publish an object
> > > but have final
> > > > fields of that object safely visible and "the objects to which
> > > they refer".
> > > > But I believe the intent there was to cover the case where the
> thread
> > > > setting the final field *also* constructed the object. That is
> > > not the case
> > > > here.
> > > >
> > > > Suppose the final-field rule does apply, then when thread-1 does:
> > > >
> > > >  Foo f = new Foo();
> > > >  SomethingMore.valueHolder = f;
> > > >
> > > > the VM has to know that valueHolder will soon be assigned to a
> > > final field
> > > > in another thread, and force a happens-before ordering between the
> two
> > > > actions. But the VM can't know that will happen so it won't do
> > > anything to
> > > > enforce happens before.
> > > >
> > > > Of course, depending on the nature of the object itself it
> > > might be harmless
> > > > to unsafely publish it.
> > > >
> > > > That's my take anyway  - perhaps we need to discuss this on the
> > > JMM mailing
> > > > list :)
> > > >
> > > > Cheers,
> > > > David Holmes
> > > >
> > > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070903/48b0fcb6/attachment-0001.html 

From dl at cs.oswego.edu  Mon Sep  3 12:35:43 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 03 Sep 2007 12:35:43 -0400
Subject: [concurrency-interest] Fwd:  Fixed thread pool problem?
In-Reply-To: <5668a1520709030252t7fad8cdcw51cc230e0be640f4@mail.gmail.com>
References: <5668a1520708310910n4d896c64u19a9dd55a0e10827@mail.gmail.com>	<46D8A112.20705@cs.oswego.edu>	<5668a1520709030251t2885883bla26904f40ef2d942@mail.gmail.com>
	<5668a1520709030252t7fad8cdcw51cc230e0be640f4@mail.gmail.com>
Message-ID: <46DC37DF.50402@cs.oswego.edu>

Glyn Normington wrote:
> F
> 
> Disregarding my failed attempt to analyse the lack of speedup by 
> inserting infinite loops, I'd still like to understand the lack of speedup.
> 

Actually, on recheck, I think the main issue is just that
the scans for repetitions are a small enough portion of
execution time that you aren't seeing much benefit from splitting it
in the way you did.
This was compounded by your concurrent versions continuing through all,
but sequential version breaking at fist match.

I tried replacing your Scanner.call (as well as sequential repeated())
with a version with an outer loop, plus some simple microbenchmark
protection to avoid compiler collapsing all loops:

        public Boolean call() throws Exception {
             int reps = 0;
             synchronized (list) {
                 for (int i = 0; i < 1000; ++i) {
                     for (Generation p : list) {
                         if (curGen.equals(p)) {
                             reps += i + p.dim;
                         }
                     }
                 }
             }
             // true if any rep but compiler is not smart enough to know this
             return reps > 2000;
         }
     }

and saw a factor of 5 speedup of concurrent vs sequential
on an 8way machine. The synchronization of list and
equals had only a small effect.

(I also had to reset random number generator to fixed seed
and re-fill after each run to get reasonable comparisons.
There seems to be a lot of variation across runs.)

-Doug

From hanson.char at gmail.com  Mon Sep  3 12:53:03 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Mon, 3 Sep 2007 09:53:03 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
Message-ID: <ca53c8f80709030953r44f5213ap21fc01aba8d504c4@mail.gmail.com>

I think you are right.  Thanks for pointing this out.  I've updated
the proposed idiom with David's comment.

  http://hansonchar.blogspot.com/#piodhi-immutable



Hanson Char

On 9/3/07, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> Is the lack of methods to alter an objects state after construction also
> considered immutability? I would say yes in the following case:
>
> public class Immutable { private boolean t; }
>
> Would I be wrong?

From jmanson at cs.umd.edu  Mon Sep  3 16:21:42 2007
From: jmanson at cs.umd.edu (Jeremy Manson)
Date: Mon, 03 Sep 2007 13:21:42 -0700
Subject: [concurrency-interest] Parametric Initialization
 On	DemandHolder Idiom ?
In-Reply-To: <aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
Message-ID: <46DC6CD6.9000807@cs.umd.edu>

Dhanji --

Nope.  Java provides a guarantee that the correctly initialized values 
of final fields will be seen after construction even in the presence of 
a data race, but it doesn't provide any such guarantee for non-final 
fields.  For example, if I have:

class Foo {
   public static Foo global;
   private int bar;
   Foo() {
     bar = 1;
   }
   public int getBar() { return bar; }
}

and I have (where global is initially null)

Thread 1:
global = new Foo();

Thread 2:
if (global != null) {
   System.out.println(global.getBar());
}

Then if bar is *not* final, the value 0 or the value 1 might be printed, 
but if bar *is* final, then only the value 1 may be printed.

This is because the guarantees about the kinds of reordering 
transformations compilers can perform on final fields are different from 
and more strict than the ones that compilers can perform on non-final 
fields.

I haven't looked at this thread in a couple of days, but my recollection 
is that this property is important for Hanson's IODH variant, because 
valueHolder can potentially be read in the static initializer by a 
thread that didn't set it -- thus, you need to guarantee that the Object 
is safe in the presence of data races.

					Jeremy


Dhanji R. Prasanna wrote:
> Is the lack of methods to alter an objects state after construction also 
> considered immutability? I would say yes in the following case:
> 
> public class Immutable { private boolean t; }
> 
> Would I be wrong?
> 
> On 9/3/07, *Hanson Char* <hanson.char at gmail.com 
> <mailto:hanson.char at gmail.com>> wrote:
> 
>     Hi David,
> 
>     Agree.  I always thought the term "Immutability" in Java implies the
>     use of final fields.
> 
>       "Final fields must be used to provide a guarantee of immutability."
> 
>       - Section 17.5 (Final Field Semantics) of JLS 3.0 p.573.
> 
>     Hanson Char
> 
>     On 9/2/07, David Holmes <dcholmes at optusnet.com.au
>     <mailto:dcholmes at optusnet.com.au>> wrote:
>      > Hi Hanson,
>      >
>      > If the object is safe even under unsafe-publication, then there
>     is no
>      > problem. Immutability itself is not sufficient, the object must
>     use final
>      > fields to enforce immutability - ie it must be written to be safe
>     even in
>      > the face of un-safe publication.
>      >
>      > Cheers,
>      > David
>      >
>      > > -----Original Message-----
>      > > From: concurrency-interest-bounces at cs.oswego.edu
>     <mailto:concurrency-interest-bounces at cs.oswego.edu>
>      > > [mailto: concurrency-interest-bounces at cs.oswego.edu
>     <mailto:concurrency-interest-bounces at cs.oswego.edu>]On Behalf Of Hanson
>      > > Char
>      > > Sent: Saturday, 1 September 2007 4:32 PM
>      > > To: dholmes at ieee.org <mailto:dholmes at ieee.org>
>      > > Cc: Joe Bowbeer; concurrency-interest
>      > > Subject: Re: [concurrency-interest] Parametric Initialization On
>      > > DemandHolder Idiom ?
>      > >
>      > >
>      > > David,
>      > >
>      > > After reviewing JLS 17.5.1 Semantics of Final Fields, I agree
>     the lack
>      > > of happens-before relationship makes it unsafe in the general case.
>      > > In other words, despite the use of the final qualifier, a mere
>      > > thread-safe (but not super-safe like immutable) object passed
>     to the
>      > > SomethingMore.getInstance(params) could cause a
>     partially-initialized
>      > > object to be seen, similar to the double-checked locking problem.
>      > >
>      > > However, what if the object passed to the
>      > > SomethingMore.getInstance(params) is required to be an immutable
>      > > object ?  That would make the unsafe publication irrelevant,
>     and allow
>      > > this proposed idiom to be thread-safe.  Correct ?
>      > >
>      > > Hanson Char
>      > >
>      > > On 8/31/07, David Holmes <dcholmes at optusnet.com.au
>     <mailto:dcholmes at optusnet.com.au>> wrote:
>      > > > Hanson, Joe,
>      > > >
>      > > > > Agree.  However, is it possible to contrive an example where a
>      > > > > thread-safe (but not super-safe like  immutable) value
>     passed to the
>      > > > > SomethingMore.getInstance (params) would cause a
>      > > > > surprising/unexpected/corrupted/partially-initialized result ?
>      > > >
>      > > > I think the general answer is yes. If thread-1 sets valueHolder
>      > > and thread-2
>      > > > does LazySomethingMoreHolder.something (because concurrent
>     calls to
>      > > > getInstance are interleaved) and then thread-2 uses the object
>      > > created by
>      > > > thread-1, then it is using an unsafely published object.
>     There is no
>      > > > happens-before relationship between the construction of the
>     object by
>      > > > thread-1 and its use in thread-2.
>      > > >
>      > > > Now Joe has pointed out the rule for final fields, but I don't
>      > > think that
>      > > > quite applies to this situation - or if it does then there is a
>      > > problem for
>      > > > VM implementors.
>      > > >
>      > > > The final-field rule allows you to unsafely publish an object
>      > > but have final
>      > > > fields of that object safely visible and "the objects to which
>      > > they refer".
>      > > > But I believe the intent there was to cover the case where
>     the thread
>      > > > setting the final field *also* constructed the object. That is
>      > > not the case
>      > > > here.
>      > > >
>      > > > Suppose the final-field rule does apply, then when thread-1
>     does:
>      > > >
>      > > >  Foo f = new Foo();
>      > > >  SomethingMore.valueHolder = f;
>      > > >
>      > > > the VM has to know that valueHolder will soon be assigned to a
>      > > final field
>      > > > in another thread, and force a happens-before ordering
>     between the two
>      > > > actions. But the VM can't know that will happen so it won't do
>      > > anything to
>      > > > enforce happens before.
>      > > >
>      > > > Of course, depending on the nature of the object itself it
>      > > might be harmless
>      > > > to unsafely publish it.
>      > > >
>      > > > That's my take anyway  - perhaps we need to discuss this on the
>      > > JMM mailing
>      > > > list :)
>      > > >
>      > > > Cheers,
>      > > > David Holmes
>      > > >
>      > > >
>      > > _______________________________________________
>      > > Concurrency-interest mailing list
>      > > Concurrency-interest at altair.cs.oswego.edu
>     <mailto:Concurrency-interest at altair.cs.oswego.edu>
>      > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>      >
>      >
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at altair.cs.oswego.edu
>     <mailto:Concurrency-interest at altair.cs.oswego.edu>
>     http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> 
> ------------------------------------------------------------------------
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From hanson.char at gmail.com  Mon Sep  3 16:36:40 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Mon, 3 Sep 2007 13:36:40 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <46DC6CD6.9000807@cs.umd.edu>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
	<46DC6CD6.9000807@cs.umd.edu>
Message-ID: <ca53c8f80709031336g6cf4e241y114b0cfc46d28785@mail.gmail.com>

It seems there are two perspectives of immutability:

1) a strong definition of immutability as implied by the JLS which
requires the use of final fields to guarantee thread-safeness even in
the face of unsafe publication;

2) a casual definition meaning a (non-final) field that can be read
but not written to once it's initialized (as I understand it from
Dhanji's email).

And of course (1) but not (2) is required for the proposed idiom, as
Jeremy and David rightly pointed out.

Hanson Char

On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> Dhanji --
>
> Nope.  Java provides a guarantee that the correctly initialized values
> of final fields will be seen after construction even in the presence of
> a data race, but it doesn't provide any such guarantee for non-final
> fields.  For example, if I have:
>
> class Foo {
>    public static Foo global;
>    private int bar;
>    Foo() {
>      bar = 1;
>    }
>    public int getBar() { return bar; }
> }
>
> and I have (where global is initially null)
>
> Thread 1:
> global = new Foo();
>
> Thread 2:
> if (global != null) {
>    System.out.println(global.getBar());
> }
>
> Then if bar is *not* final, the value 0 or the value 1 might be printed,
> but if bar *is* final, then only the value 1 may be printed.
>
> This is because the guarantees about the kinds of reordering
> transformations compilers can perform on final fields are different from
> and more strict than the ones that compilers can perform on non-final
> fields.
>
> I haven't looked at this thread in a couple of days, but my recollection
> is that this property is important for Hanson's IODH variant, because
> valueHolder can potentially be read in the static initializer by a
> thread that didn't set it -- thus, you need to guarantee that the Object
> is safe in the presence of data races.
>
>                                         Jeremy
>
>
> Dhanji R. Prasanna wrote:
> > Is the lack of methods to alter an objects state after construction also
> > considered immutability? I would say yes in the following case:
> >
> > public class Immutable { private boolean t; }
> >
> > Would I be wrong?

From joe.bowbeer at gmail.com  Mon Sep  3 17:07:52 2007
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 3 Sep 2007 14:07:52 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <46DC6CD6.9000807@cs.umd.edu>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
	<46DC6CD6.9000807@cs.umd.edu>
Message-ID: <31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>

On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
>
> Nope.  Java provides a guarantee that the correctly initialized values
> of final fields will be seen after construction even in the presence of
> a data race, but it doesn't provide any such guarantee for non-final
> fields.
>

Jeremy,

Can you elaborate on "correctly initialized"?  Is not leaking "this"
during construction the only requirement?

It's easy to infer from the FAQ that the "final" guarantee applies to
object references that are written by other threads before the object
is constructed, as in Hanson Char's idiom.  But I suspect David is
right in concluding that it doesn't.  Can you point to the part of the
spec that clarifies this?

Thanks.

--Joe

From hanson.char at gmail.com  Mon Sep  3 17:47:50 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Mon, 3 Sep 2007 14:47:50 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
	<46DC6CD6.9000807@cs.umd.edu>
	<31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>
Message-ID: <ca53c8f80709031447y2d41cad8vf6f48d74a9242fe9@mail.gmail.com>

> It's easy to infer from the FAQ that the "final" guarantee applies to
> object references that are written by other threads before the object
> is constructed, as in Hanson Char's idiom.  But I suspect David is
> right in concluding that it doesn't.  Can you point to the part of the
> spec that clarifies this?

I concur.  FYI, it's the last 2 paragraphs (p. 576) in Section 17.5.1
Semantics of Final Fields of JLS 3.0 that convinced me of David's
conclusion.

Hanson Char

On 9/3/07, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> >
> > Nope.  Java provides a guarantee that the correctly initialized values
> > of final fields will be seen after construction even in the presence of
> > a data race, but it doesn't provide any such guarantee for non-final
> > fields.
> >
>
> Jeremy,
>
> Can you elaborate on "correctly initialized"?  Is not leaking "this"
> during construction the only requirement?
>
> It's easy to infer from the FAQ that the "final" guarantee applies to
> object references that are written by other threads before the object
> is constructed, as in Hanson Char's idiom.  But I suspect David is
> right in concluding that it doesn't.  Can you point to the part of the
> spec that clarifies this?
>
> Thanks.
>
> --Joe
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From jmanson at cs.umd.edu  Mon Sep  3 18:40:49 2007
From: jmanson at cs.umd.edu (Jeremy Manson)
Date: Mon, 03 Sep 2007 15:40:49 -0700
Subject: [concurrency-interest] Parametric Initialization On
 DemandHolder Idiom ?
In-Reply-To: <31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>	
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>	
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>	
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>	
	<46DC6CD6.9000807@cs.umd.edu>
	<31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>
Message-ID: <46DC8D71.60701@cs.umd.edu>

Joe Bowbeer wrote:

> Can you elaborate on "correctly initialized"?  Is not leaking "this"
> during construction the only requirement?

That's correct publication, which is a little subtle.  See below.  What 
I meant by "correctly initialized" (which I was using loosely) was that 
if you use a final field, then you will see values for the field (and 
everything transitively reachable from the field that are at least as up 
to date as they were at the end of the object's constructor.

You are correct that you only get these guarantees if you only follow 
correctly published references.  "Correctly published" means that the 
object reference was written after the constructor finished.  Here's an 
example:

class FinalHolder {
   static FinalHolder badHolder;
   static FinalHolder goodHolder;

   final int f;
   FinalHolder() {
     badHolder = this;  // incorrect publication
     f = 1;
   }
   void printFinal() {
     System.out.println(f);
   }
}

Thread 1:
goodHolder = new FinalHolder();  // correct publication

(We'll assume that none of the following throw a NullPointerException)
Thread 2;
goodHolder.printFinal();  // will only print 1

Thread 3:
badHolder.printFinal();  // can print 1 or 0

Thread 4:
badHolder.printFinal();  // can print 1 or 0
goodHolder.printFinal();  // can print 1 or 0


> It's easy to infer from the FAQ that the "final" guarantee applies to
> object references that are written by other threads before the object
> is constructed, as in Hanson Char's idiom.  But I suspect David is
> right in concluding that it doesn't.  Can you point to the part of the
> spec that clarifies this?

I'm not sure what you are asking.  The immutability guarantee applies 
only to final fields, and only to those that are read from threads which 
only read correctly published references to the containing object.

All this correct publication stuff is somewhat orthogonal to the problem 
in Hanson's IODH idiom.  There, the thread performing static 
initialization of LazySomethingMoreHolder may not be the thread that 
wrote the object reference to valueHolder.  Since the reference is being 
passed between threads via a data race, it is vital that you make the 
object immutable -- properly immutable, in the sense that all of its 
fields are final fields.  getInstance has to be passed an immutable 
object, which is guaranteed by the use of final fields.

In short, David's analysis is correct, and if the FAQ is misleading on 
this point, it should be cleaned up.  Just point me to it, and I'll 
clean it.

					Jeremy

From dcholmes at optusnet.com.au  Mon Sep  3 19:52:03 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 4 Sep 2007 09:52:03 +1000
Subject: [concurrency-interest] Parametric Initialization OnDemandHolder
	Idiom ?
In-Reply-To: <ca53c8f80709031336g6cf4e241y114b0cfc46d28785@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEIBHIAA.dcholmes@optusnet.com.au>

Hanson writes:
> It seems there are two perspectives of immutability:
>
> 1) a strong definition of immutability as implied by the JLS which
> requires the use of final fields to guarantee thread-safeness even in
> the face of unsafe publication;
>
> 2) a casual definition meaning a (non-final) field that can be read
> but not written to once it's initialized (as I understand it from
> Dhanji's email).

Right. In Java Concurrency in Practice we defined immutability as follows:

An object is immutable if:
- It's state cannot be modified after construction
- All its fields are final; ** and
- It is properly constructed (the this reference does not escape during
construction)

** Strictly speaking you can have immutability without all fields being
final - eg a String is. But it "relies on delicate reasoning about benign
data races that require a deep understanding of the Java Memory Model".

Cheers,
David


From hanson.char at gmail.com  Mon Sep  3 23:33:07 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Mon, 3 Sep 2007 20:33:07 -0700
Subject: [concurrency-interest] Parametric Initialization OnDemandHolder
	Idiom ?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEIBHIAA.dcholmes@optusnet.com.au>
References: <ca53c8f80709031336g6cf4e241y114b0cfc46d28785@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEIBHIAA.dcholmes@optusnet.com.au>
Message-ID: <ca53c8f80709032033l62e8d3d4x438ca25d04ae4a1d@mail.gmail.com>

Hi David,

> ** Strictly speaking you can have immutability without all fields being
> final - eg a String is. But it "relies on delicate reasoning about benign
> data races that require a deep understanding of the Java Memory Model".

Out of curiosity, are you referring to the

    private int hash;

in String ?  (Since all the other member fields appear to be final.)

Hanson Char

From dhanji at gmail.com  Mon Sep  3 23:51:04 2007
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Tue, 4 Sep 2007 13:51:04 +1000
Subject: [concurrency-interest] Parametric Initialization OnDemandHolder
	Idiom ?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEIBHIAA.dcholmes@optusnet.com.au>
References: <ca53c8f80709031336g6cf4e241y114b0cfc46d28785@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEIBHIAA.dcholmes@optusnet.com.au>
Message-ID: <aa067ea10709032051t39e8d145o11b1cb62200dcaaa@mail.gmail.com>

On 9/4/07, David Holmes <dcholmes at optusnet.com.au> wrote:
> Hanson writes:
> > It seems there are two perspectives of immutability:
> >
> > 1) a strong definition of immutability as implied by the JLS which
> > requires the use of final fields to guarantee thread-safeness even in
> > the face of unsafe publication;
> >
> > 2) a casual definition meaning a (non-final) field that can be read
> > but not written to once it's initialized (as I understand it from
> > Dhanji's email).

Yea that is roughly what I meant (about the extended life of the object).
>
> Right. In Java Concurrency in Practice we defined immutability as follows:

JCiP not sold in Brisbane =(
will have to hop onto Amazon...

>
> An object is immutable if:
> - It's state cannot be modified after construction
> - All its fields are final; ** and
> - It is properly constructed (the this reference does not escape during
> construction)
>
> ** Strictly speaking you can have immutability without all fields being
> final - eg a String is. But it "relies on delicate reasoning about benign
> data races that require a deep understanding of the Java Memory Model".

OK, thanks guys--I think that there is a common misperception about
immutability as Hanson pointed out (speaking for myself atleast),
though I did realize this-leaking was the only way to break non-final
immutability.

How about an object with no mutators and no "this" leak; is it correct
that it *can* be considered immutable? i.e., the same value is visible
to all threads?

//something like
public class AmISafe {
   private Integer i;

   public AmISafe() { i = 1; }

   public Integer get() { return i; }
}

//elsewhere:
static final AmISafe ais = new AmISafe();

ais.get();  //do all threads see 1?

I cannot see a datarace... and the object is "unmodifiable." I assume
that is what you mean David, by not necessarily having final fields?
Is it kosher to call such an instance immutable?
Thanks,

Dhanji.

From hanson.char at gmail.com  Mon Sep  3 23:56:50 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Mon, 3 Sep 2007 20:56:50 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <46DC8D71.60701@cs.umd.edu>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
	<46DC6CD6.9000807@cs.umd.edu>
	<31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>
	<46DC8D71.60701@cs.umd.edu>
Message-ID: <ca53c8f80709032056j7794a5b0w11cbe7f85114c2b1@mail.gmail.com>

Hi Jeremy,

As I see it, goodHolder can either be null or holds a reference to an
immutable object (FinalHolder) which is correctly (albeit unsafely)
published.  So why would Thread 4's

    goodHolder.printFinal()

"can print 1 or 0" ?  Shouldn't it always print 1 as in Thread 2 ?
What am I missing ?

Hanson Char

On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> Joe Bowbeer wrote:
>
> > Can you elaborate on "correctly initialized"?  Is not leaking "this"
> > during construction the only requirement?
>
> That's correct publication, which is a little subtle.  See below.  What
> I meant by "correctly initialized" (which I was using loosely) was that
> if you use a final field, then you will see values for the field (and
> everything transitively reachable from the field that are at least as up
> to date as they were at the end of the object's constructor.
>
> You are correct that you only get these guarantees if you only follow
> correctly published references.  "Correctly published" means that the
> object reference was written after the constructor finished.  Here's an
> example:
>
> class FinalHolder {
>    static FinalHolder badHolder;
>    static FinalHolder goodHolder;
>
>    final int f;
>    FinalHolder() {
>      badHolder = this;  // incorrect publication
>      f = 1;
>    }
>    void printFinal() {
>      System.out.println(f);
>    }
> }
>
> Thread 1:
> goodHolder = new FinalHolder();  // correct publication
>
> (We'll assume that none of the following throw a NullPointerException)
> Thread 2;
> goodHolder.printFinal();  // will only print 1
>
> Thread 3:
> badHolder.printFinal();  // can print 1 or 0
>
> Thread 4:
> badHolder.printFinal();  // can print 1 or 0
> goodHolder.printFinal();  // can print 1 or 0

From hanson.char at gmail.com  Tue Sep  4 00:14:14 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Mon, 3 Sep 2007 21:14:14 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <46DC8D71.60701@cs.umd.edu>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
	<46DC6CD6.9000807@cs.umd.edu>
	<31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>
	<46DC8D71.60701@cs.umd.edu>
Message-ID: <ca53c8f80709032114v15f46719xf347e7729499c5f8@mail.gmail.com>

Hi Jeremy,

As I see it, the "misleading" or perhaps missing part is the first paragraph at:

  http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalRight

In particular:

"Assuming the object is constructed "correctly", once an object is
constructed, the values assigned to the final fields in the
constructor will be visible to all other threads without
synchronization."

The missing part is that the values assigned to the final fields must
not be involved in a data race (or involved in unsafe publication) or
else such values need to be immutable.

Hanson Char

On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> > It's easy to infer from the FAQ that the "final" guarantee applies to
> > object references that are written by other threads before the object
> > is constructed, as in Hanson Char's idiom.  But I suspect David is
> > right in concluding that it doesn't.  Can you point to the part of the
> > spec that clarifies this?
>
> I'm not sure what you are asking.  The immutability guarantee applies
> only to final fields, and only to those that are read from threads which
> only read correctly published references to the containing object.
>
> All this correct publication stuff is somewhat orthogonal to the problem
> in Hanson's IODH idiom.  There, the thread performing static
> initialization of LazySomethingMoreHolder may not be the thread that
> wrote the object reference to valueHolder.  Since the reference is being
> passed between threads via a data race, it is vital that you make the
> object immutable -- properly immutable, in the sense that all of its
> fields are final fields.  getInstance has to be passed an immutable
> object, which is guaranteed by the use of final fields.
>
> In short, David's analysis is correct, and if the FAQ is misleading on
> this point, it should be cleaned up.  Just point me to it, and I'll
> clean it.

From hanson.char at gmail.com  Tue Sep  4 00:19:54 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Mon, 3 Sep 2007 21:19:54 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <ca53c8f80709032114v15f46719xf347e7729499c5f8@mail.gmail.com>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
	<46DC6CD6.9000807@cs.umd.edu>
	<31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>
	<46DC8D71.60701@cs.umd.edu>
	<ca53c8f80709032114v15f46719xf347e7729499c5f8@mail.gmail.com>
Message-ID: <ca53c8f80709032119j453f11ach71d2c9c1c836cfca@mail.gmail.com>

Also, the concept of (un)safe publication is not mentioned anywhere in
the FAQ.  That seems to be an important and subtle concept.

I guess that's what the JLS is there for :)

Hanson Char

On 9/3/07, Hanson Char <hanson.char at gmail.com> wrote:
> Hi Jeremy,
>
> As I see it, the "misleading" or perhaps missing part is the first paragraph at:
>
>   http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalRight
>
> In particular:
>
> "Assuming the object is constructed "correctly", once an object is
> constructed, the values assigned to the final fields in the
> constructor will be visible to all other threads without
> synchronization."
>
> The missing part is that the values assigned to the final fields must
> not be involved in a data race (or involved in unsafe publication) or
> else such values need to be immutable.
>
> Hanson Char
>
> On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> > > It's easy to infer from the FAQ that the "final" guarantee applies to
> > > object references that are written by other threads before the object
> > > is constructed, as in Hanson Char's idiom.  But I suspect David is
> > > right in concluding that it doesn't.  Can you point to the part of the
> > > spec that clarifies this?
> >
> > I'm not sure what you are asking.  The immutability guarantee applies
> > only to final fields, and only to those that are read from threads which
> > only read correctly published references to the containing object.
> >
> > All this correct publication stuff is somewhat orthogonal to the problem
> > in Hanson's IODH idiom.  There, the thread performing static
> > initialization of LazySomethingMoreHolder may not be the thread that
> > wrote the object reference to valueHolder.  Since the reference is being
> > passed between threads via a data race, it is vital that you make the
> > object immutable -- properly immutable, in the sense that all of its
> > fields are final fields.  getInstance has to be passed an immutable
> > object, which is guaranteed by the use of final fields.
> >
> > In short, David's analysis is correct, and if the FAQ is misleading on
> > this point, it should be cleaned up.  Just point me to it, and I'll
> > clean it.
>

From hanson.char at gmail.com  Tue Sep  4 00:52:22 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Mon, 3 Sep 2007 21:52:22 -0700
Subject: [concurrency-interest] Parametric Initialization OnDemandHolder
	Idiom ?
In-Reply-To: <aa067ea10709032051t39e8d145o11b1cb62200dcaaa@mail.gmail.com>
References: <ca53c8f80709031336g6cf4e241y114b0cfc46d28785@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEIBHIAA.dcholmes@optusnet.com.au>
	<aa067ea10709032051t39e8d145o11b1cb62200dcaaa@mail.gmail.com>
Message-ID: <ca53c8f80709032152m5ea23249hbab5d4269aee9a50@mail.gmail.com>

I would say the static final instance "ais" is immutable, but it's
class AmlSafe is not.  Although all threads are guaranteed to see 1
from

    ais.get();

, the ais instance is made immutable not because of the class AmlSafe
per se (ie lack of mutator methods), but because of the (class
initialization) context in which it is constructed.

Hanson Char

On 9/3/07, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> How about an object with no mutators and no "this" leak; is it correct
> that it *can* be considered immutable? i.e., the same value is visible
> to all threads?
>
> //something like
> public class AmISafe {
>    private Integer i;
>
>    public AmISafe() { i = 1; }
>
>    public Integer get() { return i; }
> }
>
> //elsewhere:
> static final AmISafe ais = new AmISafe();
>
> ais.get();  //do all threads see 1?
>
> I cannot see a datarace... and the object is "unmodifiable." I assume
> that is what you mean David, by not necessarily having final fields?
> Is it kosher to call such an instance immutable?

From dhanji at gmail.com  Tue Sep  4 01:43:57 2007
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Tue, 4 Sep 2007 15:43:57 +1000
Subject: [concurrency-interest] Parametric Initialization OnDemandHolder
	Idiom ?
In-Reply-To: <ca53c8f80709032152m5ea23249hbab5d4269aee9a50@mail.gmail.com>
References: <ca53c8f80709031336g6cf4e241y114b0cfc46d28785@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEIBHIAA.dcholmes@optusnet.com.au>
	<aa067ea10709032051t39e8d145o11b1cb62200dcaaa@mail.gmail.com>
	<ca53c8f80709032152m5ea23249hbab5d4269aee9a50@mail.gmail.com>
Message-ID: <aa067ea10709032243j38ce1198md0dbe74ad89acfed@mail.gmail.com>

On 9/4/07, Hanson Char <hanson.char at gmail.com> wrote:
> I would say the static final instance "ais" is immutable, but it's
> class AmlSafe is not.  Although all threads are guaranteed to see 1
> from
>
>     ais.get();

right. the guard is in the static field's publication.

>
> , the ais instance is made immutable not because of the class AmlSafe
> per se (ie lack of mutator methods), but because of the (class
> initialization) context in which it is constructed.

Is it conceivable that you can have a race condition if you remove the
static final instance declaration? I can only see that competing
threads will either throw an NPE or return 1 for ais.get(). Is it
possible for a thread to see a half-constructed AmISafe in ais (if it
were not final)? I am curious...

Dhanji.

From dcholmes at optusnet.com.au  Tue Sep  4 02:03:43 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 4 Sep 2007 16:03:43 +1000
Subject: [concurrency-interest] Parametric Initialization
	OnDemandHolderIdiom ?
In-Reply-To: <aa067ea10709032051t39e8d145o11b1cb62200dcaaa@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEIDHIAA.dcholmes@optusnet.com.au>

Hanson: yes it is the hashCode in String that is referred to.

Dhanji writes:
> OK, thanks guys--I think that there is a common misperception about
> immutability as Hanson pointed out (speaking for myself atleast),
> though I did realize this-leaking was the only way to break non-final
> immutability.

"safe-publication" is the step-0 of thread-safety that many people are
unaware of. But it is easily handled.

> public class AmISafe {
>    private Integer i;
>
>    public AmISafe() { i = 1; }
>
>    public Integer get() { return i; }
> }

For an unsafely-published instance, get() may return either null or the
correct Integer object. The object itself is always fully constructed
(allocated, has the right vtable, class reference etc etc) but its fields
might only have their default initialized values, rather than their
constructor-based values.

Cheers,
David Holmes


From jmanson at cs.umd.edu  Tue Sep  4 02:22:46 2007
From: jmanson at cs.umd.edu (Jeremy Manson)
Date: Mon, 03 Sep 2007 23:22:46 -0700
Subject: [concurrency-interest] Parametric Initialization On
 DemandHolder Idiom ?
In-Reply-To: <ca53c8f80709032056j7794a5b0w11cbe7f85114c2b1@mail.gmail.com>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>	
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>	
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>	
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>	
	<46DC6CD6.9000807@cs.umd.edu>	
	<31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>	
	<46DC8D71.60701@cs.umd.edu>
	<ca53c8f80709032056j7794a5b0w11cbe7f85114c2b1@mail.gmail.com>
Message-ID: <46DCF9B6.4020804@cs.umd.edu>

Hanson Char wrote:
> Hi Jeremy,
> 
> As I see it, goodHolder can either be null or holds a reference to an
> immutable object (FinalHolder) which is correctly (albeit unsafely)
> published.  So why would Thread 4's
> 
>     goodHolder.printFinal()
> 
> "can print 1 or 0" ?  Shouldn't it always print 1 as in Thread 2 ?
> What am I missing ?

We decided that if a thread ever sees an incorrectly published 
reference, it is forever tainted.  That way, you could imagine a 
compiler transformation that, if you can tell that goodHolder and 
badHolder are the same reference, you can reuse the value read for the 
final field without reloading it.  The JIT writers wanted to take 
advantage of this.

The trick to this, as with so much of the Java memory model work, is 
that it will work as expected as long as you write your programs 
correctly.  If you don't publish your references early, you'll be fine...

					Jeremy


> 
> Hanson Char
> 
> On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
>> Joe Bowbeer wrote:
>>
>>> Can you elaborate on "correctly initialized"?  Is not leaking "this"
>>> during construction the only requirement?
>> That's correct publication, which is a little subtle.  See below.  What
>> I meant by "correctly initialized" (which I was using loosely) was that
>> if you use a final field, then you will see values for the field (and
>> everything transitively reachable from the field that are at least as up
>> to date as they were at the end of the object's constructor.
>>
>> You are correct that you only get these guarantees if you only follow
>> correctly published references.  "Correctly published" means that the
>> object reference was written after the constructor finished.  Here's an
>> example:
>>
>> class FinalHolder {
>>    static FinalHolder badHolder;
>>    static FinalHolder goodHolder;
>>
>>    final int f;
>>    FinalHolder() {
>>      badHolder = this;  // incorrect publication
>>      f = 1;
>>    }
>>    void printFinal() {
>>      System.out.println(f);
>>    }
>> }
>>
>> Thread 1:
>> goodHolder = new FinalHolder();  // correct publication
>>
>> (We'll assume that none of the following throw a NullPointerException)
>> Thread 2;
>> goodHolder.printFinal();  // will only print 1
>>
>> Thread 3:
>> badHolder.printFinal();  // can print 1 or 0
>>
>> Thread 4:
>> badHolder.printFinal();  // can print 1 or 0
>> goodHolder.printFinal();  // can print 1 or 0


From hanson.char at gmail.com  Tue Sep  4 14:46:11 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Tue, 4 Sep 2007 11:46:11 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <46DCF9B6.4020804@cs.umd.edu>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
	<46DC6CD6.9000807@cs.umd.edu>
	<31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>
	<46DC8D71.60701@cs.umd.edu>
	<ca53c8f80709032056j7794a5b0w11cbe7f85114c2b1@mail.gmail.com>
	<46DCF9B6.4020804@cs.umd.edu>
Message-ID: <ca53c8f80709041146g3add821fp28d8dc2c3b461acf@mail.gmail.com>

Hi Jeremy,

This is very interesting.  If I understand this correctly, had
Thread-5 invoked the printFinal method of goodHolder prior to that of
badHolder, it would always print 1 instead of "either 1 or 0".  Am I
right ?  What about the subsequent badHolder invokation (ie would it
always print 1 also or there is no such guarantee) ?

  Thread 5:
  goodHolder.printFinal();  // will only print 1
  badHolder.printFinal();    // would this also always print 1 or no
such guarantee ?

Hanson Char

On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> Hanson Char wrote:
> > Hi Jeremy,
> >
> > As I see it, goodHolder can either be null or holds a reference to an
> > immutable object (FinalHolder) which is correctly (albeit unsafely)
> > published.  So why would Thread 4's
> >
> >     goodHolder.printFinal()
> >
> > "can print 1 or 0" ?  Shouldn't it always print 1 as in Thread 2 ?
> > What am I missing ?
>
> We decided that if a thread ever sees an incorrectly published
> reference, it is forever tainted.  That way, you could imagine a
> compiler transformation that, if you can tell that goodHolder and
> badHolder are the same reference, you can reuse the value read for the
> final field without reloading it.  The JIT writers wanted to take
> advantage of this.
>
> The trick to this, as with so much of the Java memory model work, is
> that it will work as expected as long as you write your programs
> correctly.  If you don't publish your references early, you'll be fine...
>
>                                         Jeremy
>
>
> >
> > Hanson Char
> >
> > On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> >> Joe Bowbeer wrote:
> >>
> >>> Can you elaborate on "correctly initialized"?  Is not leaking "this"
> >>> during construction the only requirement?
> >> That's correct publication, which is a little subtle.  See below.  What
> >> I meant by "correctly initialized" (which I was using loosely) was that
> >> if you use a final field, then you will see values for the field (and
> >> everything transitively reachable from the field that are at least as up
> >> to date as they were at the end of the object's constructor.
> >>
> >> You are correct that you only get these guarantees if you only follow
> >> correctly published references.  "Correctly published" means that the
> >> object reference was written after the constructor finished.  Here's an
> >> example:
> >>
> >> class FinalHolder {
> >>    static FinalHolder badHolder;
> >>    static FinalHolder goodHolder;
> >>
> >>    final int f;
> >>    FinalHolder() {
> >>      badHolder = this;  // incorrect publication
> >>      f = 1;
> >>    }
> >>    void printFinal() {
> >>      System.out.println(f);
> >>    }
> >> }
> >>
> >> Thread 1:
> >> goodHolder = new FinalHolder();  // correct publication
> >>
> >> (We'll assume that none of the following throw a NullPointerException)
> >> Thread 2;
> >> goodHolder.printFinal();  // will only print 1
> >>
> >> Thread 3:
> >> badHolder.printFinal();  // can print 1 or 0
> >>
> >> Thread 4:
> >> badHolder.printFinal();  // can print 1 or 0
> >> goodHolder.printFinal();  // can print 1 or 0
>
>

From hanson.char at gmail.com  Tue Sep  4 14:58:37 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Tue, 4 Sep 2007 11:58:37 -0700
Subject: [concurrency-interest] Parametric Initialization OnDemandHolder
	Idiom ?
In-Reply-To: <aa067ea10709032243j38ce1198md0dbe74ad89acfed@mail.gmail.com>
References: <ca53c8f80709031336g6cf4e241y114b0cfc46d28785@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEIBHIAA.dcholmes@optusnet.com.au>
	<aa067ea10709032051t39e8d145o11b1cb62200dcaaa@mail.gmail.com>
	<ca53c8f80709032152m5ea23249hbab5d4269aee9a50@mail.gmail.com>
	<aa067ea10709032243j38ce1198md0dbe74ad89acfed@mail.gmail.com>
Message-ID: <ca53c8f80709041158y3b193215ocdd8147614259f3@mail.gmail.com>

> Is it
> possible for a thread to see a half-constructed AmISafe in ais (if it
> were not final)? I am curious...

As I understand it, the short answer is yes.  The reason being there
would then be nothing to prevent multiple threads writing to and
reading from "ais" concurrently, causing data race (with no
happens-before relationship among these threads).

However, had there been some extrinsic guarantee that the static
non-final "ais" would only be initialized once during class
initialization and not to be written to again afterwards, the AmiSafe
instance initially constructed and assigned to "ais" during class
initialization would still remain thread-safe and safely published.

Please correct me if mistaken.

Hanson Char

On 9/3/07, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> On 9/4/07, Hanson Char <hanson.char at gmail.com> wrote:
> > I would say the static final instance "ais" is immutable, but it's
> > class AmlSafe is not.  Although all threads are guaranteed to see 1
> > from
> >
> >     ais.get();
>
> right. the guard is in the static field's publication.
>
> >
> > , the ais instance is made immutable not because of the class AmlSafe
> > per se (ie lack of mutator methods), but because of the (class
> > initialization) context in which it is constructed.
>
> Is it conceivable that you can have a race condition if you remove the
> static final instance declaration? I can only see that competing
> threads will either throw an NPE or return 1 for ais.get(). Is it
> possible for a thread to see a half-constructed AmISafe in ais (if it
> were not final)? I am curious...

From joe.bowbeer at gmail.com  Tue Sep  4 18:49:40 2007
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 4 Sep 2007 15:49:40 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <46DC8D71.60701@cs.umd.edu>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
	<46DC6CD6.9000807@cs.umd.edu>
	<31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>
	<46DC8D71.60701@cs.umd.edu>
Message-ID: <31f2a7bd0709041549u5c4ade93i2cba311bd1700051@mail.gmail.com>

On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> Joe Bowbeer wrote:
>
> > Can you elaborate on "correctly initialized"?  Is not leaking "this"
> > during construction the only requirement?
> >
> > It's easy to infer from the FAQ that the "final" guarantee applies to
> > object references that are written by other threads before the object
> > is constructed, as in Hanson Char's idiom.  But I suspect David is
> > right in concluding that it doesn't.  Can you point to the part of the
> > spec that clarifies this?
>
> If the FAQ is misleading on this point, it should be cleaned up.
> Just point me to it, and I'll clean it.
>

The FAQ says this concerning final fields under the new model:

* Assuming the object is constructed "correctly", once an object is
constructed, the values assigned to the final fields in the
constructor will be visible to all other threads without
synchronization. In addition, the visible values for any other object
or array referenced by those final fields will be at least as
up-to-date as the final fields.

Where constructed "correctly" is defined in the same FAQ entry:

* What does it mean for an object to be properly constructed? It
simply means that no reference to the object being constructed is
allowed to "escape" during construction.

 http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalRight

The confusing part is where it states that "the visible values for any
other object or array referenced by those final fields will be at
least as up-to-date as the final fields".

What does up-to-date mean?

Consider the following trivialization of Hanson Char's example:

class A {

  private static int[] temp;
  private final int[] val;
  private A() { val = temp; }

  public static A create(int[] val) {
    A.temp = val;
    return new A();
  }

  public int get() { return val[0]; }
}

Where multiple threads are executing:

  assert A.create(new int[] { 1 }).get() == 1;

The assertion above can fail, and this seems at odds with the
statement in that FAQ that the visible value for any array referenced
by a final field will be at least as up-to-date as the final field.

I think "up-to-date" is the source of the confusion.  Many readers
will assume it's saying something intuitive, based on program order.
But it's really saying something about happens-before edges.

--Joe

From jmanson at cs.umd.edu  Wed Sep  5 02:32:27 2007
From: jmanson at cs.umd.edu (Jeremy Manson)
Date: Tue, 04 Sep 2007 23:32:27 -0700
Subject: [concurrency-interest] Parametric Initialization On
 DemandHolder Idiom ?
In-Reply-To: <ca53c8f80709041146g3add821fp28d8dc2c3b461acf@mail.gmail.com>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>	
	<NFBBKALFDCPFIDBNKAPCAEHJHIAA.dcholmes@optusnet.com.au>	
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>	
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>	
	<46DC6CD6.9000807@cs.umd.edu>	
	<31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>	
	<46DC8D71.60701@cs.umd.edu>	
	<ca53c8f80709032056j7794a5b0w11cbe7f85114c2b1@mail.gmail.com>	
	<46DCF9B6.4020804@cs.umd.edu>
	<ca53c8f80709041146g3add821fp28d8dc2c3b461acf@mail.gmail.com>
Message-ID: <46DE4D7B.1090706@cs.umd.edu>

No such guarantee.  You are even tainted retroactively, so both 
printFinals in Thread 5 can *still* print 0 or 1.  This is because it is 
really easy to reorder code[1].  The moral, as always, is to make sure 
that you never let a reference escape the constructor (or to use proper 
synchronization).

					Jeremy

[1] Especially in a case like this, where there are no data or control 
dependencies!  Not that anything would change if they were in present.



Hanson Char wrote:
> Hi Jeremy,
> 
> This is very interesting.  If I understand this correctly, had
> Thread-5 invoked the printFinal method of goodHolder prior to that of
> badHolder, it would always print 1 instead of "either 1 or 0".  Am I
> right ?  What about the subsequent badHolder invokation (ie would it
> always print 1 also or there is no such guarantee) ?
> 
>   Thread 5:
>   goodHolder.printFinal();  // will only print 1
>   badHolder.printFinal();    // would this also always print 1 or no
> such guarantee ?
> 
> Hanson Char
> 
> On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
>> Hanson Char wrote:
>>> Hi Jeremy,
>>>
>>> As I see it, goodHolder can either be null or holds a reference to an
>>> immutable object (FinalHolder) which is correctly (albeit unsafely)
>>> published.  So why would Thread 4's
>>>
>>>     goodHolder.printFinal()
>>>
>>> "can print 1 or 0" ?  Shouldn't it always print 1 as in Thread 2 ?
>>> What am I missing ?
>> We decided that if a thread ever sees an incorrectly published
>> reference, it is forever tainted.  That way, you could imagine a
>> compiler transformation that, if you can tell that goodHolder and
>> badHolder are the same reference, you can reuse the value read for the
>> final field without reloading it.  The JIT writers wanted to take
>> advantage of this.
>>
>> The trick to this, as with so much of the Java memory model work, is
>> that it will work as expected as long as you write your programs
>> correctly.  If you don't publish your references early, you'll be fine...
>>
>>                                         Jeremy
>>
>>
>>> Hanson Char
>>>
>>> On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
>>>> Joe Bowbeer wrote:
>>>>
>>>>> Can you elaborate on "correctly initialized"?  Is not leaking "this"
>>>>> during construction the only requirement?
>>>> That's correct publication, which is a little subtle.  See below.  What
>>>> I meant by "correctly initialized" (which I was using loosely) was that
>>>> if you use a final field, then you will see values for the field (and
>>>> everything transitively reachable from the field that are at least as up
>>>> to date as they were at the end of the object's constructor.
>>>>
>>>> You are correct that you only get these guarantees if you only follow
>>>> correctly published references.  "Correctly published" means that the
>>>> object reference was written after the constructor finished.  Here's an
>>>> example:
>>>>
>>>> class FinalHolder {
>>>>    static FinalHolder badHolder;
>>>>    static FinalHolder goodHolder;
>>>>
>>>>    final int f;
>>>>    FinalHolder() {
>>>>      badHolder = this;  // incorrect publication
>>>>      f = 1;
>>>>    }
>>>>    void printFinal() {
>>>>      System.out.println(f);
>>>>    }
>>>> }
>>>>
>>>> Thread 1:
>>>> goodHolder = new FinalHolder();  // correct publication
>>>>
>>>> (We'll assume that none of the following throw a NullPointerException)
>>>> Thread 2;
>>>> goodHolder.printFinal();  // will only print 1
>>>>
>>>> Thread 3:
>>>> badHolder.printFinal();  // can print 1 or 0
>>>>
>>>> Thread 4:
>>>> badHolder.printFinal();  // can print 1 or 0
>>>> goodHolder.printFinal();  // can print 1 or 0
>>


From hanson.char at gmail.com  Wed Sep  5 02:45:52 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Tue, 4 Sep 2007 23:45:52 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <46DE4D7B.1090706@cs.umd.edu>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>
	<46DC6CD6.9000807@cs.umd.edu>
	<31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>
	<46DC8D71.60701@cs.umd.edu>
	<ca53c8f80709032056j7794a5b0w11cbe7f85114c2b1@mail.gmail.com>
	<46DCF9B6.4020804@cs.umd.edu>
	<ca53c8f80709041146g3add821fp28d8dc2c3b461acf@mail.gmail.com>
	<46DE4D7B.1090706@cs.umd.edu>
Message-ID: <ca53c8f80709042345o7a40d0ecv8bccee6b6ab44706@mail.gmail.com>

Hi Jeremy,

Agree with the moral.  I am curious about the details of your example.
 Since Thread-2 only invokes goodHolder.printFinal() and that results
in "will only print 1", are you saying that as long as the
badHolder.printFinal() is not invoked in a Thread,
goodHolder.printFinal() is guaranteed to always print 1 ?  In other
words, once badHolder.printFinal() is invoked in a Thread, the
printFinal of both badHolder and goodHolder would be tainted (ie may
print 1 or 0).

Hanson Char

On 9/4/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> No such guarantee.  You are even tainted retroactively, so both
> printFinals in Thread 5 can *still* print 0 or 1.  This is because it is
> really easy to reorder code[1].  The moral, as always, is to make sure
> that you never let a reference escape the constructor (or to use proper
> synchronization).
>
>                                         Jeremy
>
> [1] Especially in a case like this, where there are no data or control
> dependencies!  Not that anything would change if they were in present.
>
>
>
> Hanson Char wrote:
> > Hi Jeremy,
> >
> > This is very interesting.  If I understand this correctly, had
> > Thread-5 invoked the printFinal method of goodHolder prior to that of
> > badHolder, it would always print 1 instead of "either 1 or 0".  Am I
> > right ?  What about the subsequent badHolder invokation (ie would it
> > always print 1 also or there is no such guarantee) ?
> >
> >   Thread 5:
> >   goodHolder.printFinal();  // will only print 1
> >   badHolder.printFinal();    // would this also always print 1 or no
> > such guarantee ?
> >
> > Hanson Char
> >
> > On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> >> Hanson Char wrote:
> >>> Hi Jeremy,
> >>>
> >>> As I see it, goodHolder can either be null or holds a reference to an
> >>> immutable object (FinalHolder) which is correctly (albeit unsafely)
> >>> published.  So why would Thread 4's
> >>>
> >>>     goodHolder.printFinal()
> >>>
> >>> "can print 1 or 0" ?  Shouldn't it always print 1 as in Thread 2 ?
> >>> What am I missing ?
> >> We decided that if a thread ever sees an incorrectly published
> >> reference, it is forever tainted.  That way, you could imagine a
> >> compiler transformation that, if you can tell that goodHolder and
> >> badHolder are the same reference, you can reuse the value read for the
> >> final field without reloading it.  The JIT writers wanted to take
> >> advantage of this.
> >>
> >> The trick to this, as with so much of the Java memory model work, is
> >> that it will work as expected as long as you write your programs
> >> correctly.  If you don't publish your references early, you'll be fine...
> >>
> >>                                         Jeremy
> >>
> >>
> >>> Hanson Char
> >>>
> >>> On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> >>>> Joe Bowbeer wrote:
> >>>>
> >>>>> Can you elaborate on "correctly initialized"?  Is not leaking "this"
> >>>>> during construction the only requirement?
> >>>> That's correct publication, which is a little subtle.  See below.  What
> >>>> I meant by "correctly initialized" (which I was using loosely) was that
> >>>> if you use a final field, then you will see values for the field (and
> >>>> everything transitively reachable from the field that are at least as up
> >>>> to date as they were at the end of the object's constructor.
> >>>>
> >>>> You are correct that you only get these guarantees if you only follow
> >>>> correctly published references.  "Correctly published" means that the
> >>>> object reference was written after the constructor finished.  Here's an
> >>>> example:
> >>>>
> >>>> class FinalHolder {
> >>>>    static FinalHolder badHolder;
> >>>>    static FinalHolder goodHolder;
> >>>>
> >>>>    final int f;
> >>>>    FinalHolder() {
> >>>>      badHolder = this;  // incorrect publication
> >>>>      f = 1;
> >>>>    }
> >>>>    void printFinal() {
> >>>>      System.out.println(f);
> >>>>    }
> >>>> }
> >>>>
> >>>> Thread 1:
> >>>> goodHolder = new FinalHolder();  // correct publication
> >>>>
> >>>> (We'll assume that none of the following throw a NullPointerException)
> >>>> Thread 2;
> >>>> goodHolder.printFinal();  // will only print 1
> >>>>
> >>>> Thread 3:
> >>>> badHolder.printFinal();  // can print 1 or 0
> >>>>
> >>>> Thread 4:
> >>>> badHolder.printFinal();  // can print 1 or 0
> >>>> goodHolder.printFinal();  // can print 1 or 0
> >>
>
>

From jmanson at cs.umd.edu  Wed Sep  5 03:48:48 2007
From: jmanson at cs.umd.edu (Jeremy Manson)
Date: Wed, 05 Sep 2007 00:48:48 -0700
Subject: [concurrency-interest] Parametric Initialization On
 DemandHolder Idiom ?
In-Reply-To: <ca53c8f80709042345o7a40d0ecv8bccee6b6ab44706@mail.gmail.com>
References: <ca53c8f80708312331r58465b92h2f40afb10b21869f@mail.gmail.com>	
	<ca53c8f80709022237oe5f4541u8a62b57a9e090f62@mail.gmail.com>	
	<aa067ea10709030310o4158c3e6g7bc958435e2a0f12@mail.gmail.com>	
	<46DC6CD6.9000807@cs.umd.edu>	
	<31f2a7bd0709031407q5f523388o599d20784e4d51af@mail.gmail.com>	
	<46DC8D71.60701@cs.umd.edu>	
	<ca53c8f80709032056j7794a5b0w11cbe7f85114c2b1@mail.gmail.com>	
	<46DCF9B6.4020804@cs.umd.edu>	
	<ca53c8f80709041146g3add821fp28d8dc2c3b461acf@mail.gmail.com>	
	<46DE4D7B.1090706@cs.umd.edu>
	<ca53c8f80709042345o7a40d0ecv8bccee6b6ab44706@mail.gmail.com>
Message-ID: <46DE5F60.7010703@cs.umd.edu>

Yup!

					Jeremy

Hanson Char wrote:
> Hi Jeremy,
> 
> Agree with the moral.  I am curious about the details of your example.
>  Since Thread-2 only invokes goodHolder.printFinal() and that results
> in "will only print 1", are you saying that as long as the
> badHolder.printFinal() is not invoked in a Thread,
> goodHolder.printFinal() is guaranteed to always print 1 ?  In other
> words, once badHolder.printFinal() is invoked in a Thread, the
> printFinal of both badHolder and goodHolder would be tainted (ie may
> print 1 or 0).
> 
> Hanson Char
> 
> On 9/4/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
>> No such guarantee.  You are even tainted retroactively, so both
>> printFinals in Thread 5 can *still* print 0 or 1.  This is because it is
>> really easy to reorder code[1].  The moral, as always, is to make sure
>> that you never let a reference escape the constructor (or to use proper
>> synchronization).
>>
>>                                         Jeremy
>>
>> [1] Especially in a case like this, where there are no data or control
>> dependencies!  Not that anything would change if they were in present.
>>
>>
>>
>> Hanson Char wrote:
>>> Hi Jeremy,
>>>
>>> This is very interesting.  If I understand this correctly, had
>>> Thread-5 invoked the printFinal method of goodHolder prior to that of
>>> badHolder, it would always print 1 instead of "either 1 or 0".  Am I
>>> right ?  What about the subsequent badHolder invokation (ie would it
>>> always print 1 also or there is no such guarantee) ?
>>>
>>>   Thread 5:
>>>   goodHolder.printFinal();  // will only print 1
>>>   badHolder.printFinal();    // would this also always print 1 or no
>>> such guarantee ?
>>>
>>> Hanson Char
>>>
>>> On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
>>>> Hanson Char wrote:
>>>>> Hi Jeremy,
>>>>>
>>>>> As I see it, goodHolder can either be null or holds a reference to an
>>>>> immutable object (FinalHolder) which is correctly (albeit unsafely)
>>>>> published.  So why would Thread 4's
>>>>>
>>>>>     goodHolder.printFinal()
>>>>>
>>>>> "can print 1 or 0" ?  Shouldn't it always print 1 as in Thread 2 ?
>>>>> What am I missing ?
>>>> We decided that if a thread ever sees an incorrectly published
>>>> reference, it is forever tainted.  That way, you could imagine a
>>>> compiler transformation that, if you can tell that goodHolder and
>>>> badHolder are the same reference, you can reuse the value read for the
>>>> final field without reloading it.  The JIT writers wanted to take
>>>> advantage of this.
>>>>
>>>> The trick to this, as with so much of the Java memory model work, is
>>>> that it will work as expected as long as you write your programs
>>>> correctly.  If you don't publish your references early, you'll be fine...
>>>>
>>>>                                         Jeremy
>>>>
>>>>
>>>>> Hanson Char
>>>>>
>>>>> On 9/3/07, Jeremy Manson <jmanson at cs.umd.edu> wrote:
>>>>>> Joe Bowbeer wrote:
>>>>>>
>>>>>>> Can you elaborate on "correctly initialized"?  Is not leaking "this"
>>>>>>> during construction the only requirement?
>>>>>> That's correct publication, which is a little subtle.  See below.  What
>>>>>> I meant by "correctly initialized" (which I was using loosely) was that
>>>>>> if you use a final field, then you will see values for the field (and
>>>>>> everything transitively reachable from the field that are at least as up
>>>>>> to date as they were at the end of the object's constructor.
>>>>>>
>>>>>> You are correct that you only get these guarantees if you only follow
>>>>>> correctly published references.  "Correctly published" means that the
>>>>>> object reference was written after the constructor finished.  Here's an
>>>>>> example:
>>>>>>
>>>>>> class FinalHolder {
>>>>>>    static FinalHolder badHolder;
>>>>>>    static FinalHolder goodHolder;
>>>>>>
>>>>>>    final int f;
>>>>>>    FinalHolder() {
>>>>>>      badHolder = this;  // incorrect publication
>>>>>>      f = 1;
>>>>>>    }
>>>>>>    void printFinal() {
>>>>>>      System.out.println(f);
>>>>>>    }
>>>>>> }
>>>>>>
>>>>>> Thread 1:
>>>>>> goodHolder = new FinalHolder();  // correct publication
>>>>>>
>>>>>> (We'll assume that none of the following throw a NullPointerException)
>>>>>> Thread 2;
>>>>>> goodHolder.printFinal();  // will only print 1
>>>>>>
>>>>>> Thread 3:
>>>>>> badHolder.printFinal();  // can print 1 or 0
>>>>>>
>>>>>> Thread 4:
>>>>>> badHolder.printFinal();  // can print 1 or 0
>>>>>> goodHolder.printFinal();  // can print 1 or 0
>>


From sanders at cise.ufl.edu  Wed Sep  5 10:26:40 2007
From: sanders at cise.ufl.edu (Beverly Sanders)
Date: Wed, 5 Sep 2007 10:26:40 -0400 (EDT)
Subject: [concurrency-interest] Parametric Initialization On	DemandHolder
	Idiom ?
In-Reply-To: <mailman.403.1188978510.7147.concurrency-interest@altair.cs.oswego.edu
	>
References: <mailman.403.1188978510.7147.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <2430.128.227.35.83.1189002400.squirrel@webmail.cise.ufl.edu>



Most of the (interesting) discussion of this example has focused on
the value of f that can be seen when a reference is leaked in the
constructor.  But suppose we got rid of  badHolder and eliminated that
problem.  Wouldn't this program have a race on goodHolder
itself unless something is done to create hb edges?   For example,
by making goodHolder volatile, or ensuring that  goodHolder is assigned
by some thread before other threads that read it are started, or
otherwise "safely publish" the reference?  But if we still need
safe publication, then the special semantics for final fields don't
add anything.  What am I missing?

In this example, safe publication is needed (it is safe when
goodHolder is volatile)


class FinalHolder {
  static [volatile] FinalHolder goodHolder;

final int f;
FinalHolder() {
  f = 1;
}
void printFinal() {
System.out.println(f);
}


Thread1:
Thread2.start();
goodHolder = new FinalHolder();

Thread2:
while(goodHolder==null){}
           //termination guaranteed only if goodHolder volatile
goodHolder.print();
           //if thread gets here, it will print 1 due to
           //correct construction (no leak of ref from consructor)
           //and final field semantics.
           //But if goodHolder volatile, f doesn't need to be
           //final except to ensure that the value is not modified--special
           //treatment in the memory model is not needed.



Thanks,
Beverly Sanders


From hanson.char at gmail.com  Wed Sep  5 11:39:44 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Wed, 5 Sep 2007 08:39:44 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <2430.128.227.35.83.1189002400.squirrel@webmail.cise.ufl.edu>
References: <mailman.403.1188978510.7147.concurrency-interest@altair.cs.oswego.edu>
	<2430.128.227.35.83.1189002400.squirrel@webmail.cise.ufl.edu>
Message-ID: <ca53c8f80709050839w21b72a15wca8f7bb29f926868@mail.gmail.com>

>On 9/5/07, Beverly Sanders <sanders at cise.ufl.edu> wrote:
> Most of the (interesting) discussion of this example has focused on
> the value of f that can be seen when a reference is leaked in the
> constructor.  But suppose we got rid of  badHolder and eliminated that
> problem.  Wouldn't this program have a race on goodHolder
> itself unless something is done to create hb edges?

Yes, this program would have a data race.

>For example,
> by making goodHolder volatile, or ensuring that  goodHolder is assigned
> by some thread before other threads that read it are started, or
> otherwise "safely publish" the reference?  But if we still need
> safe publication, then the special semantics for final fields don't
> add anything.  What am I missing?

True, but we don't need safe publication for (correctly constructed)
immutable object in the first place.

> In this example, safe publication is needed (it is safe when
> goodHolder is volatile)

It is safe publication in your example (with the volatile) but it is
not needed in this case, given FinalHolder is immutable and is
correctly/safely constructed.

Cheers,
Hanson Char

>
> class FinalHolder {
>   static [volatile] FinalHolder goodHolder;
>
> final int f;
> FinalHolder() {
>   f = 1;
> }
> void printFinal() {
> System.out.println(f);
> }
>
>
> Thread1:
> Thread2.start();
> goodHolder = new FinalHolder();
>
> Thread2:
> while(goodHolder==null){}
>            //termination guaranteed only if goodHolder volatile
> goodHolder.print();
>            //if thread gets here, it will print 1 due to
>            //correct construction (no leak of ref from consructor)
>            //and final field semantics.
>            //But if goodHolder volatile, f doesn't need to be
>            //final except to ensure that the value is not modified--special
>            //treatment in the memory model is not needed.
>
>
>
> Thanks,
> Beverly Sanders

From sanders at cise.ufl.edu  Wed Sep  5 13:05:19 2007
From: sanders at cise.ufl.edu (Beverly Sanders)
Date: Wed, 5 Sep 2007 13:05:19 -0400 (EDT)
Subject: [concurrency-interest] Parametric Initialization On
 DemandHolder Idiom ?
Message-ID: <2491.128.227.35.83.1189011919.squirrel@webmail.cise.ufl.edu>


Thanks for the quick reply,


>> On 9/5/07, Beverly Sanders <sanders at cise.ufl.edu> wrote:
>> Most of the (interesting) discussion of this example has focused on
>> the value of f that can be seen when a reference is leaked in the
>> constructor.  But suppose we got rid of  badHolder and eliminated that
>> problem.  Wouldn't this program have a race on goodHolder itself unless
>> something is done to create hb edges?
>
> Yes, this program would have a data race.
>
>
>> For example,
>> by making goodHolder volatile, or ensuring that  goodHolder is assigned
>> by some thread before other threads that read it are started, or
>> otherwise "safely publish" the reference?  But if we still need safe
>> publication, then the special semantics for final fields don't add
>> anything.  What am I missing?
>
> True, but we don't need safe publication for (correctly constructed)
> immutable object in the first place.
>
>> In this example, safe publication is needed (it is safe when
>> goodHolder is volatile)
>
> It is safe publication in your example (with the volatile) but it is
> not needed in this case, given FinalHolder is immutable and is
> correctly/safely constructed.
>

Safe publication _is_ needed to ensure that thread2 will
terminate, right?  The point is that a data race on the reference to
the published object is probably bad for reasons that may have nothing to
do with the final fields, but that getting rid of that data race also
eliminates the need for the special semantics for final fields for
safely constructed objects.  This latter claim could be wrong--but
if it is, I'd appreciate an explanation.

Thanks.
Beverly Sanders



> Cheers,
> Hanson Char
>
>
>>
>> class FinalHolder { static [volatile] FinalHolder goodHolder;
>>
>> final int f; FinalHolder() {
>> f = 1; }
>> void printFinal() { System.out.println(f);
>> }
>>
>>
>>
>> Thread1:
>> Thread2.start();
>> goodHolder = new FinalHolder();
>>
>> Thread2:
>> while(goodHolder==null){} //termination guaranteed only if goodHolder
>> volatile goodHolder.print(); //if thread gets here, it will print 1 due
>> to //correct construction (no leak of ref from consructor)
>> //and final field semantics.
>> //But if goodHolder volatile, f doesn't need to be
>> //final except to ensure that the value is not modified--special
>> //treatment in the memory model is not needed.
>>
>>
>>
>>
>> Thanks,
>> Beverly Sanders
>>
>
>




-- 
Beverly A. Sanders, Associate Professor
Department of Computer & Information Science & Engineering
P.O. Box 116120
University of Florida
Gainesville, FL 32611-6120
www.cise.ufl.edu/~sanders
tel: (352) 392-1528
fax: (352) 392-1220


From hanson.char at gmail.com  Wed Sep  5 16:08:06 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Wed, 5 Sep 2007 13:08:06 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <2430.128.227.35.83.1189002400.squirrel@webmail.cise.ufl.edu>
References: <mailman.403.1188978510.7147.concurrency-interest@altair.cs.oswego.edu>
	<2430.128.227.35.83.1189002400.squirrel@webmail.cise.ufl.edu>
Message-ID: <ca53c8f80709051308r7e456f51l88906a5aa2d4e53b@mail.gmail.com>

On 9/5/07, Beverly Sanders <sanders at cise.ufl.edu> wrote:
> In this example, safe publication is needed (it is safe when
> goodHolder is volatile)
>
> class FinalHolder {
>   static [volatile] FinalHolder goodHolder;
>
> final int f;
> FinalHolder() {
>   f = 1;
> }
> void printFinal() {
> System.out.println(f);
> }
>
> Thread1:
> Thread2.start();
> goodHolder = new FinalHolder();
>
> Thread2:
> while(goodHolder==null){}
>            //termination guaranteed only if goodHolder volatile

True.

> goodHolder.print();
>            //if thread gets here, it will print 1 due to
>            //correct construction (no leak of ref from consructor)
>            //and final field semantics.
>            //But if goodHolder volatile, f doesn't need to be
>            //final except to ensure that the value is not modified--special
>            //treatment in the memory model is not needed.

True also.

Hanson Char

From hanson.char at gmail.com  Wed Sep  5 16:12:36 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Wed, 5 Sep 2007 13:12:36 -0700
Subject: [concurrency-interest] Parametric Initialization On
	DemandHolder Idiom ?
In-Reply-To: <2491.128.227.35.83.1189011919.squirrel@webmail.cise.ufl.edu>
References: <2491.128.227.35.83.1189011919.squirrel@webmail.cise.ufl.edu>
Message-ID: <ca53c8f80709051312j1f36243du27747b4e57f810df@mail.gmail.com>

> Safe publication _is_ needed to ensure that thread2 will
> terminate, right?

Right.

>The point is that a data race on the reference to
> the published object is probably bad for reasons that may have nothing to
> do with the final fields, but that getting rid of that data race also
> eliminates the need for the special semantics for final fields for
> safely constructed objects.  This latter claim could be wrong--but
> if it is, I'd appreciate an explanation.

True in your code sample.  However, in general, safely constructed
objects with non-final fields are potentially subject to further
modification, and therefore potential data races.

As far as thread-safety is concerned, final fields are preferred over
non-final fields, whenever it is permissible.

Hanson Char

From dl at cs.oswego.edu  Mon Sep 10 08:44:55 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 10 Sep 2007 08:44:55 -0400
Subject: [concurrency-interest]  Possible changes to parallel array APIs
In-Reply-To: <46D40FA9.70505@cs.oswego.edu>
References: <46D330B8.3020907@cs.oswego.edu>	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>	<46D40844.8060906@cs.oswego.edu>
	<46D40FA9.70505@cs.oswego.edu>
Message-ID: <46E53C47.8060005@cs.oswego.edu>

Here are some further potential directions for aggregate
parallel operations we'd like some feedback about:

1. 64bit arrays
The desire for parallel operations on array-like collections
is probably strongly correlated with need for very large arrays.
But Java arrays have a maximum size of about 2 billion elements.
It would be possible however to support 64-bit addressible
contiguous arrays on all the existing production JVMs using
internal JVM APIs. (Actually, only 63bits because of signedness.)
So we are contemplating doing this -- basically to use
longs rather than ints for index-related operations.
There are a few minor disadvantages though:
   * Basic element access will be a little slower on most machines
   * They cannot interoperate with native arrays.
   * People running on 32bit machines will have all the overhead
     but none of the benefit, since they still won't be able
     to create giant arrays (they'll get OutOfMemoryErrors).
   * Because of cross-mapping issues, we'd probably drop the
     special-case version for int (leaving only long and double).

My opinion at the moment is that none of these are good enough
reasons not to do it. And further, if it is done, there's not
a good argument to even keep the current 32bit versions. (*)


2. Integration with Lists
Under the current APIs, if you want to first add, remove, resize, etc.,
a bunch of elements before performing parallel aggregate operations,
you need to either manually manage a native array, or use something
like an ArrayList, and then copy out the elements to be used as
a ParallelArray.  This is not much fun. Plus, copying out is
a sequential bottleneck that could sometimes negate opportunities
for parallel speedups.  Most people would
rather instead have, say, a single ParallelArrayList where they
could do both sorts of operations.
One reason for at first resisting this is that the
semantics seem a little error-prone. For example, add(element) is
a sequential (not parallel) operation, that is not thread-safe
with respect to any parallel operation that might be executing
(which, in that case could only be due to a parallel operation
being executed by some other thread). In other words, it would be a
bad idea to share access to a single ParallelArrayList across
multiple threads without some sort of externally imposed locks
or synchronization, in the same sense in which this holds for
plain ArrayLists. But given the familiarity of this rule for
ArrayLists, it seems no worse an idea to do it, and it would be
a lot more convenient. Does anyone have a strong disagreement about
this?

3. Combining (1) and (2)
If we evolved parallel array APIs to support both 64bits
and lists, we'll also need to add a corresponding
"BigList" (or maybe "List64" or "LongList"?) interface that
either:
  (a) is just like java.util.List, but is not a List because
      it uses longs instead of ints.  As in having method:
      long indexOf(E x);
  (b) extends java.util.List, but adds, for example
      long longIndexOf(E x) in addition to existing int version.
Option (a) is probably more sensible, but option (b) is
much friendlier to working alongside existing List code.
Does anyone have any strong feelings about this?

Note that under either option, we'd need to add a
   long longSize()
method to even fit it under Collection (which has "int size()"
method). This is ugly but surely tolerable. (To quote Josh,
"size() doesn't matter".)

Footnote (*): If we do this, then the corresponding jsr166y
releases will require that people use -Xbootclasspath switches
to run it for a while (like maybe even a year) before we
integrate into Java7 builds. I know this causes logistic
problems for some of you, but there's not much we can do about it.

-Doug





From gregg at cytetech.com  Mon Sep 10 11:14:47 2007
From: gregg at cytetech.com (Gregg Wonderly)
Date: Mon, 10 Sep 2007 10:14:47 -0500
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46E53C47.8060005@cs.oswego.edu>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
	<46D40844.8060906@cs.oswego.edu> <46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu>
Message-ID: <46E55F67.4070408@cytetech.com>

Doug Lea wrote:
>   (a) is just like java.util.List, but is not a List because
>       it uses longs instead of ints.  As in having method:
>       long indexOf(E x);
>   (b) extends java.util.List, but adds, for example
>       long longIndexOf(E x) in addition to existing int version.
> Option (a) is probably more sensible, but option (b) is
> much friendlier to working alongside existing List code.
> Does anyone have any strong feelings about this?

For option b, I worry that people will write code, intending to use the 64 bit 
indexing, but fail, and code using the 32bit methods instead.  Then they'll 
start downcasting long to int to make the signatures compatible, and create 
silently failing code.

What if there were defined a new list interface, such as

interface IndexedList<I,T> {
	public T get( I idx );
	public I size();
	public void add( T val );
	public T remove( I idx );
	...etc as per java.util.List...
}

so that we had a more open limit on indexing, as well as the ability to create 
more abstract list forms.

Would the logic declaration of

interface LongList<T> extends IndexedList<Long,T> {
	...
}

be too much of a performance problem with autoboxing in use?  Is there ever 
going to be any work on an @native(Long,long) or some such annotation which when 
placed on a generified declaration, would require that any java.util.Long use be 
rewritten to long native type use (by the compiler) and disallow autoboxing 
altogether?

Gregg Wonderly

From neal at gafter.com  Mon Sep 10 11:59:43 2007
From: neal at gafter.com (Neal Gafter)
Date: Mon, 10 Sep 2007 08:59:43 -0700
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46E53C47.8060005@cs.oswego.edu>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
	<46D40844.8060906@cs.oswego.edu> <46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu>
Message-ID: <15e8b9d20709100859h52aa8be1qcddf123264ed9b3b@mail.gmail.com>

What would be the result type of ParallelArray.withFilter and withMapping?
Would they also derive from collections?

On 9/10/07, Doug Lea <dl at cs.oswego.edu> wrote:
>
> Here are some further potential directions for aggregate
> parallel operations we'd like some feedback about:
>
> 1. 64bit arrays
> The desire for parallel operations on array-like collections
> is probably strongly correlated with need for very large arrays.
> But Java arrays have a maximum size of about 2 billion elements.
> It would be possible however to support 64-bit addressible
> contiguous arrays on all the existing production JVMs using
> internal JVM APIs. (Actually, only 63bits because of signedness.)
> So we are contemplating doing this -- basically to use
> longs rather than ints for index-related operations.
> There are a few minor disadvantages though:
>    * Basic element access will be a little slower on most machines
>    * They cannot interoperate with native arrays.
>    * People running on 32bit machines will have all the overhead
>      but none of the benefit, since they still won't be able
>      to create giant arrays (they'll get OutOfMemoryErrors).
>    * Because of cross-mapping issues, we'd probably drop the
>      special-case version for int (leaving only long and double).
>
> My opinion at the moment is that none of these are good enough
> reasons not to do it. And further, if it is done, there's not
> a good argument to even keep the current 32bit versions. (*)
>
>
> 2. Integration with Lists
> Under the current APIs, if you want to first add, remove, resize, etc.,
> a bunch of elements before performing parallel aggregate operations,
> you need to either manually manage a native array, or use something
> like an ArrayList, and then copy out the elements to be used as
> a ParallelArray.  This is not much fun. Plus, copying out is
> a sequential bottleneck that could sometimes negate opportunities
> for parallel speedups.  Most people would
> rather instead have, say, a single ParallelArrayList where they
> could do both sorts of operations.
> One reason for at first resisting this is that the
> semantics seem a little error-prone. For example, add(element) is
> a sequential (not parallel) operation, that is not thread-safe
> with respect to any parallel operation that might be executing
> (which, in that case could only be due to a parallel operation
> being executed by some other thread). In other words, it would be a
> bad idea to share access to a single ParallelArrayList across
> multiple threads without some sort of externally imposed locks
> or synchronization, in the same sense in which this holds for
> plain ArrayLists. But given the familiarity of this rule for
> ArrayLists, it seems no worse an idea to do it, and it would be
> a lot more convenient. Does anyone have a strong disagreement about
> this?
>
> 3. Combining (1) and (2)
> If we evolved parallel array APIs to support both 64bits
> and lists, we'll also need to add a corresponding
> "BigList" (or maybe "List64" or "LongList"?) interface that
> either:
>   (a) is just like java.util.List, but is not a List because
>       it uses longs instead of ints.  As in having method:
>       long indexOf(E x);
>   (b) extends java.util.List, but adds, for example
>       long longIndexOf(E x) in addition to existing int version.
> Option (a) is probably more sensible, but option (b) is
> much friendlier to working alongside existing List code.
> Does anyone have any strong feelings about this?
>
> Note that under either option, we'd need to add a
>    long longSize()
> method to even fit it under Collection (which has "int size()"
> method). This is ugly but surely tolerable. (To quote Josh,
> "size() doesn't matter".)
>
> Footnote (*): If we do this, then the corresponding jsr166y
> releases will require that people use -Xbootclasspath switches
> to run it for a while (like maybe even a year) before we
> integrate into Java7 builds. I know this causes logistic
> problems for some of you, but there's not much we can do about it.
>
> -Doug
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070910/762e0338/attachment.html 

From dl at cs.oswego.edu  Mon Sep 10 12:18:00 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 10 Sep 2007 12:18:00 -0400
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46E55F67.4070408@cytetech.com>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
	<46D40844.8060906@cs.oswego.edu> <46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu> <46E55F67.4070408@cytetech.com>
Message-ID: <46E56E38.4050801@cs.oswego.edu>

Gregg Wonderly wrote:

> Would the logic declaration of
> 
> interface LongList<T> extends IndexedList<Long,T> {
>     ...
> }
> 
> be too much of a performance problem with autoboxing in use?  

Yes. Until someone out there puts in all the effort to
make template-expanded scalars work efficiently and seamlessly,
I don't think it would be a service for us to release something promising
impressive parallel speedups but usually instead encountering
so much boxing overhead that most programs usually see slowdowns.

> Is there 
> ever going to be any work on an @native(Long,long) or some such 
> annotation which when placed on a generified declaration, would require 
> that any java.util.Long use be rewritten to long native type use (by the 
> compiler) and disallow autoboxing altogether?
> 

Maybe if we all keep whining about this every week, one of
the handfull of people out there capable of pulling this off
will be motivated enough to do it :-)

-Doug




From dl at cs.oswego.edu  Mon Sep 10 12:21:56 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 10 Sep 2007 12:21:56 -0400
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <15e8b9d20709100859h52aa8be1qcddf123264ed9b3b@mail.gmail.com>
References: <46D330B8.3020907@cs.oswego.edu>	
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>	
	<46D40844.8060906@cs.oswego.edu> <46D40FA9.70505@cs.oswego.edu>	
	<46E53C47.8060005@cs.oswego.edu>
	<15e8b9d20709100859h52aa8be1qcddf123264ed9b3b@mail.gmail.com>
Message-ID: <46E56F24.7070504@cs.oswego.edu>

Neal Gafter wrote:
> What would be the result type of ParallelArray.withFilter and 
> withMapping?  Would they also derive from collections?
> 

Under ParallelArrayList scheme, they would probably need to derive
from Collection, and be super {classes, interfaces ?} of that for
ParallelArrayList. If so, they would have to throw UnsupportedOperation
for some methods. This doesn't seem to be a huge issue compared
to the others though.

-Doug



From jnewsham at referentia.com  Mon Sep 10 19:44:19 2007
From: jnewsham at referentia.com (Jim Newsham)
Date: Mon, 10 Sep 2007 13:44:19 -1000
Subject: [concurrency-interest] safe interruption
Message-ID: <006b01c7f404$85045a50$8700a8c0@referentia.com>

 

Hi everyone,

 

I'm new to this list.  I'm trying to find an appropriate place for questions
and discussions of concurrency in Java.  If this isn't the best place, I'd
appreciate some pointers on where to go.

 

One thing that bothers me about the interruption model is that it breaks
object-oriented encapsulation.  Whether I like it or not, an interrupt may
be signaled at any time, to the thread which is running my code.  And even
worse, my code will typically make calls to other code (such as core Java
classes or third party libraries), which I have no control over.  Even if I
can handle or ignore interruption of my own code, I have no way of handling
or ignoring interruption of third party code which I called, and there's no
way of knowing how it might respond to such an interruption.  Even if they
interpret interrupt as a request for cancellation (which is just one
interpretation), their definition of cancellation may not fit with mine.
Cancellation may mean to immediately give up what you're doing, even if it
means corrupting files on disk, or it might mean gracefully cleaning up
first.

 

Let's take a practical example.  I want to implement asynchronous
cancellation of my code by interruption, and my code makes calls to other
code.  The other code in this case includes standard Java stuff such as
reading and writing files, but also using external libraries, such as the
Derby embedded database.

 

In my code, I can be careful to handle interrupts, such as checking the
interrupt status periodically, and handling InterruptionException when
sleeping or waiting.  But how do I know that the third party code I'm
calling will do the right thing when interrupted?  For example, how do I
know that when the Derby library (which does a lot of disk IO) is
interrupted, it won't close connections or give up halfway through writing a
file?  I guess I'm asserting that since I don't know how third party code
will react to interruption, it is not safe to interrupt third party code at
all.  Could I get some response to this assertion?

 

If I can't safely interrupt third party code, then I need to mask interrupts
from that code somehow.  The only way I can think of to do this is to run
that code on another thread which is never interrupted.  So now I have:

 

Controller (monitors state/progress of work and implements interruption).
This might be the UI with a "Cancel" button or something else.

 

Worker thread.  Runs my code, which is in Runnable.run().  This code is
written to handle interruption.  Whenever it calls third party code, it must
spawn another thread (or queue a task on a pool), so that interrupts are
never sent to third party code.

 

Uninterrupted worker thread.  A thread (or thread pool) which the worker
thread initiates to run third party code.  This thread is never interrupted.
This could be implemented as a static method invokeUninterruptibly(Runnable
r) which uses a thread pool.

 

This is a lot of extra work and makes my code a lot less straightforward to
write and maintain.  So please tell me. am I out in left field here?  

 

Thanks,

Jim

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070910/10e6957d/attachment.html 

From dcholmes at optusnet.com.au  Mon Sep 10 20:10:04 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 11 Sep 2007 10:10:04 +1000
Subject: [concurrency-interest] safe interruption
In-Reply-To: <006b01c7f404$85045a50$8700a8c0@referentia.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEJNHIAA.dcholmes@optusnet.com.au>

Jim,

This is absolutely the right/best place to ask these questions - welcome!

All of what you write is true - there are no guarantees. You don't know if
third-party code handles interrupt requests in a sensible/robust manner, nor
whether it issues interrupts itself. Ultimately you have to trust the code
that you are using to be servicable code. If a thread interrupt caused a
library to leave a corrupt database then that library is not going to be
used for long. Ask the vendor how their code responds to interrupts - it's
information any reputable vendor should be willing to share (and the usual
answer is that interrupts are ignored - hopefully without clearing them of
course).

If you are trying to be responsive to interrupts, as a cancellation request,
then you can't be more responsive than the code that you call.

Interrupt is for cooperative cancellation not asynchronous cancellation.
Async cancellation is unusable in all but the most constrained contexts.

This topic is covered in depth in Chapter 7 of "Java Concurrency in
Practice".

I'm sure others will chime in with their opinions ;-)

Cheers,
David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Jim Newsham
  Sent: Tuesday, 11 September 2007 9:44 AM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] safe interruption




  Hi everyone,



  I'm new to this list.  I'm trying to find an appropriate place for
questions and discussions of concurrency in Java.  If this isn't the best
place, I'd appreciate some pointers on where to go.



  One thing that bothers me about the interruption model is that it breaks
object-oriented encapsulation.  Whether I like it or not, an interrupt may
be signaled at any time, to the thread which is running my code.  And even
worse, my code will typically make calls to other code (such as core Java
classes or third party libraries), which I have no control over.  Even if I
can handle or ignore interruption of my own code, I have no way of handling
or ignoring interruption of third party code which I called, and there's no
way of knowing how it might respond to such an interruption.  Even if they
interpret interrupt as a request for cancellation (which is just one
interpretation), their definition of cancellation may not fit with mine.
Cancellation may mean to immediately give up what you're doing, even if it
means corrupting files on disk, or it might mean gracefully cleaning up
first.



  Let's take a practical example.  I want to implement asynchronous
cancellation of my code by interruption, and my code makes calls to other
code.  The other code in this case includes standard Java stuff such as
reading and writing files, but also using external libraries, such as the
Derby embedded database.



  In my code, I can be careful to handle interrupts, such as checking the
interrupt status periodically, and handling InterruptionException when
sleeping or waiting.  But how do I know that the third party code I'm
calling will do the right thing when interrupted?  For example, how do I
know that when the Derby library (which does a lot of disk IO) is
interrupted, it won't close connections or give up halfway through writing a
file?  I guess I'm asserting that since I don't know how third party code
will react to interruption, it is not safe to interrupt third party code at
all.  Could I get some response to this assertion?



  If I can't safely interrupt third party code, then I need to mask
interrupts from that code somehow.  The only way I can think of to do this
is to run that code on another thread which is never interrupted.  So now I
have:



  Controller (monitors state/progress of work and implements interruption).
This might be the UI with a "Cancel" button or something else.



  Worker thread.  Runs my code, which is in Runnable.run().  This code is
written to handle interruption.  Whenever it calls third party code, it must
 spawn another thread (or queue a task on a pool), so that interrupts are
never sent to third party code.



  Uninterrupted worker thread.  A thread (or thread pool) which the worker
thread initiates to run third party code.  This thread is never interrupted.
This could be implemented as a static method invokeUninterruptibly(Runnable
r) which uses a thread pool.



  This is a lot of extra work and makes my code a lot less straightforward
to write and maintain.  So please tell me. am I out in left field here?



  Thanks,

  Jim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070911/b3476332/attachment-0001.html 

From jnewsham at referentia.com  Mon Sep 10 20:50:15 2007
From: jnewsham at referentia.com (Jim Newsham)
Date: Mon, 10 Sep 2007 14:50:15 -1000
Subject: [concurrency-interest] safe interruption
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEJNHIAA.dcholmes@optusnet.com.au>
References: <006b01c7f404$85045a50$8700a8c0@referentia.com>
	<NFBBKALFDCPFIDBNKAPCKEJNHIAA.dcholmes@optusnet.com.au>
Message-ID: <007901c7f40d$bae60f20$8700a8c0@referentia.com>

 

Hi David,

 

Thank you for your reply.  I meant cooperative cancellation, signaled via
interrupt.  Excuse me for not saying it correctly.

 

I have Java Concurrency in Practice, as well as several other books on
concurrency for Java (Doug Lea's Concurrent Programming in Java 2nd ed., and
O'Reilly's Java Threads 3rd ed.).  I really appreciate JCP as it's made a
lot of the topic more understandable, tractable, and practical to me than
previous books I've read, which I'm sure was one of their primary goals.
Doug Lea's book is great, but focuses on theory and concept.  I'll re-read
JCP chapter 7 when I have some time.

 

Back to the subject.  I know when calling third party code that I need to
trust that they'll do the right thing.  So I guess my uneasiness stems from
uncertainty about the following:

 

1.  Reasonable expectation.  Is it reasonable to expect and trust third
party code to properly handle interruption?  In my opinion, most developers
don't even give interruption any thought whatsoever, when writing code.  I
certainly don't, unless I'm writing code which explicitly uses interruption,
and I'm an experienced developer.  Also, discovering concurrency bugs is hit
and miss -- they may not always happen.  So I don't want to rely solely on
the fact that the library is established and very successful.

 

2.  Default behavior.  Supposing the developer does nothing to handle
interruption, what is the default behavior that methods will exhibit, in the
face of interruption?  That code may perform a number of operations which
don't care about interruption, but as soon as they call a method which is
interruption-sensitive, that method needs to make a choice of how to
respond: (1) ignore; (2) ignore and re-set; (3) immediately stop; (4) clean
up and stop; (5) ???.  I guess I just answered my question - no default is
possible because the code must perform some behavior.

 

3.  Interrupt-sensitive code.  What code is normally interrupt-sensitive?  I
guess potentially any method is (having "throws InterruptedException" is not
a requirement).  It's my understanding that some IO methods are
interrupt-sensitive - throwing InterruptedIOException.  If I'm calling into
library code which is calling these IO methods, then unless the library is
performing the IO on another thread, isn't that library broken?

 

4.  Worst-case scenario.  What's the worst that can happen?  Maybe deadlock.
that thought by itself is enough to make me do the extra work.  However if I
can be satisfied that this won't happen I can save a bit of time and effort,
and also sleep better at night.

 

Looking forward to other opinions.

Jim

 

 

  _____  

From: David Holmes [mailto:dcholmes at optusnet.com.au] 
Sent: Monday, September 10, 2007 2:10 PM
To: Jim Newsham; concurrency-interest at cs.oswego.edu
Subject: RE: [concurrency-interest] safe interruption

 

Jim,

 

This is absolutely the right/best place to ask these questions - welcome!

 

All of what you write is true - there are no guarantees. You don't know if
third-party code handles interrupt requests in a sensible/robust manner, nor
whether it issues interrupts itself. Ultimately you have to trust the code
that you are using to be servicable code. If a thread interrupt caused a
library to leave a corrupt database then that library is not going to be
used for long. Ask the vendor how their code responds to interrupts - it's
information any reputable vendor should be willing to share (and the usual
answer is that interrupts are ignored - hopefully without clearing them of
course).

 

If you are trying to be responsive to interrupts, as a cancellation request,
then you can't be more responsive than the code that you call.

 

Interrupt is for cooperative cancellation not asynchronous cancellation.
Async cancellation is unusable in all but the most constrained contexts.

 

This topic is covered in depth in Chapter 7 of "Java Concurrency in
Practice".

 

I'm sure others will chime in with their opinions ;-)

 

Cheers,

David Holmes

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Jim Newsham
Sent: Tuesday, 11 September 2007 9:44 AM
To: concurrency-interest at cs.oswego.edu
Subject: [concurrency-interest] safe interruption

 

Hi everyone,

 

I'm new to this list.  I'm trying to find an appropriate place for questions
and discussions of concurrency in Java.  If this isn't the best place, I'd
appreciate some pointers on where to go.

 

One thing that bothers me about the interruption model is that it breaks
object-oriented encapsulation.  Whether I like it or not, an interrupt may
be signaled at any time, to the thread which is running my code.  And even
worse, my code will typically make calls to other code (such as core Java
classes or third party libraries), which I have no control over.  Even if I
can handle or ignore interruption of my own code, I have no way of handling
or ignoring interruption of third party code which I called, and there's no
way of knowing how it might respond to such an interruption.  Even if they
interpret interrupt as a request for cancellation (which is just one
interpretation), their definition of cancellation may not fit with mine.
Cancellation may mean to immediately give up what you're doing, even if it
means corrupting files on disk, or it might mean gracefully cleaning up
first.

 

Let's take a practical example.  I want to implement asynchronous
cancellation of my code by interruption, and my code makes calls to other
code.  The other code in this case includes standard Java stuff such as
reading and writing files, but also using external libraries, such as the
Derby embedded database.

 

In my code, I can be careful to handle interrupts, such as checking the
interrupt status periodically, and handling InterruptionException when
sleeping or waiting.  But how do I know that the third party code I'm
calling will do the right thing when interrupted?  For example, how do I
know that when the Derby library (which does a lot of disk IO) is
interrupted, it won't close connections or give up halfway through writing a
file?  I guess I'm asserting that since I don't know how third party code
will react to interruption, it is not safe to interrupt third party code at
all.  Could I get some response to this assertion?

 

If I can't safely interrupt third party code, then I need to mask interrupts
from that code somehow.  The only way I can think of to do this is to run
that code on another thread which is never interrupted.  So now I have:

 

Controller (monitors state/progress of work and implements interruption).
This might be the UI with a "Cancel" button or something else.

 

Worker thread.  Runs my code, which is in Runnable.run().  This code is
written to handle interruption.  Whenever it calls third party code, it must
spawn another thread (or queue a task on a pool), so that interrupts are
never sent to third party code.

 

Uninterrupted worker thread.  A thread (or thread pool) which the worker
thread initiates to run third party code.  This thread is never interrupted.
This could be implemented as a static method invokeUninterruptibly(Runnable
r) which uses a thread pool.

 

This is a lot of extra work and makes my code a lot less straightforward to
write and maintain.  So please tell me. am I out in left field here?  

 

Thanks,

Jim

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070910/9a119b6e/attachment-0001.html 

From joe.bowbeer at gmail.com  Mon Sep 10 21:21:44 2007
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 10 Sep 2007 18:21:44 -0700
Subject: [concurrency-interest] safe interruption
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEJNHIAA.dcholmes@optusnet.com.au>
References: <006b01c7f404$85045a50$8700a8c0@referentia.com>
	<NFBBKALFDCPFIDBNKAPCKEJNHIAA.dcholmes@optusnet.com.au>
Message-ID: <31f2a7bd0709101821u6d790d61s97175b2d3cdd4574@mail.gmail.com>

On 9/10/07, David Holmes <dcholmes at optusnet.com.au> wrote:
>
> This is absolutely the right/best place to ask these questions - welcome!
>
> All of what you write is true - there are no guarantees. [...] If you are trying
> to be responsive to interrupts, as a cancellation request, then you can't be
> more responsive than the code that you call.
>
> I'm sure others will chime in with their opinions ;-)
>

If the third party code doesn't block, then interrupts won't pose a
problem (almost certainly).

If the third-party code does block, then there are two different
issues: (1) how do you "cancel" it if you want to, (2) how do you
prevent your interrupts from harming it.

Third-party code that mishandles interrupts is unfortunately fairly
common.  Mishandling may take the form of silent consumption or silent
corruption, among others.  If you're lucky you'll find a report of the
mishap in the log.

Third-party code that does not provide an effective means of
cancellation (interrupt or otherwise) is also fairly common.

Issuing your requests to third-party code in an additional thread (in
addition to your non-UI background thread) is one way to mitigate
these problems.  When your background thread is interrupted, you can
relay this to the third-party thread using its cancellation mechanism
of choice.  If the third-party thread doesn't respond within your
allotted time then your background thread may need to take more
drastic action.

--
Joe Bowbeer

From peger at automotive.com  Mon Sep 10 21:23:04 2007
From: peger at automotive.com (Patrick Eger)
Date: Mon, 10 Sep 2007 18:23:04 -0700
Subject: [concurrency-interest] safe interruption
In-Reply-To: <007901c7f40d$bae60f20$8700a8c0@referentia.com>
References: <006b01c7f404$85045a50$8700a8c0@referentia.com><NFBBKALFDCPFIDBNKAPCKEJNHIAA.dcholmes@optusnet.com.au>
	<007901c7f40d$bae60f20$8700a8c0@referentia.com>
Message-ID: <A7487BEC58632D46B8C7E8BC69B3EB1204B12630@mail-001.corp.automotive.com>

In almost every application I've ever written, for exactly the reasons
you list below, I try to keep a *healthy* distance from implementing
anything to rely on interruption. IE avoid it like the plague :-) The
real kicker is that 1) most I/O and 2) intrinsic synchronization is
generally not interruptible in the first place, making it useless for
the exact cases it would be possibly useful for. I've always used custom
asynchronous cancellation patterns a la .shutdown(), .cancel(), etc.
Most 3rd party libs (at least that I've seen) eschew documenting their
interruption behaviour in favor of a similar sane shutdown/cancel api,
which I think is good and correct, and the only way to ensure that you
don't do nasty things like corrupt your files or memory state. 

 

________________________________

From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Jim
Newsham
Sent: Monday, September 10, 2007 5:50 PM
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] safe interruption

 

 

Hi David,

 

Thank you for your reply.  I meant cooperative cancellation, signaled
via interrupt.  Excuse me for not saying it correctly.

 

I have Java Concurrency in Practice, as well as several other books on
concurrency for Java (Doug Lea's Concurrent Programming in Java 2nd ed.,
and O'Reilly's Java Threads 3rd ed.).  I really appreciate JCP as it's
made a lot of the topic more understandable, tractable, and practical to
me than previous books I've read, which I'm sure was one of their
primary goals.  Doug Lea's book is great, but focuses on theory and
concept.  I'll re-read JCP chapter 7 when I have some time.

 

Back to the subject.  I know when calling third party code that I need
to trust that they'll do the right thing.  So I guess my uneasiness
stems from uncertainty about the following:

 

1.  Reasonable expectation.  Is it reasonable to expect and trust third
party code to properly handle interruption?  In my opinion, most
developers don't even give interruption any thought whatsoever, when
writing code.  I certainly don't, unless I'm writing code which
explicitly uses interruption, and I'm an experienced developer.  Also,
discovering concurrency bugs is hit and miss -- they may not always
happen.  So I don't want to rely solely on the fact that the library is
established and very successful.

 

2.  Default behavior.  Supposing the developer does nothing to handle
interruption, what is the default behavior that methods will exhibit, in
the face of interruption?  That code may perform a number of operations
which don't care about interruption, but as soon as they call a method
which is interruption-sensitive, that method needs to make a choice of
how to respond: (1) ignore; (2) ignore and re-set; (3) immediately stop;
(4) clean up and stop; (5) ???.  I guess I just answered my question -
no default is possible because the code must perform some behavior.

 

3.  Interrupt-sensitive code.  What code is normally
interrupt-sensitive?  I guess potentially any method is (having "throws
InterruptedException" is not a requirement).  It's my understanding that
some IO methods are interrupt-sensitive - throwing
InterruptedIOException.  If I'm calling into library code which is
calling these IO methods, then unless the library is performing the IO
on another thread, isn't that library broken?

 

4.  Worst-case scenario.  What's the worst that can happen?  Maybe
deadlock... that thought by itself is enough to make me do the extra
work.  However if I can be satisfied that this won't happen I can save a
bit of time and effort, and also sleep better at night.

 

Looking forward to other opinions...

Jim

 

 

________________________________

From: David Holmes [mailto:dcholmes at optusnet.com.au] 
Sent: Monday, September 10, 2007 2:10 PM
To: Jim Newsham; concurrency-interest at cs.oswego.edu
Subject: RE: [concurrency-interest] safe interruption

 

Jim,

 

This is absolutely the right/best place to ask these questions -
welcome!

 

All of what you write is true - there are no guarantees. You don't know
if third-party code handles interrupt requests in a sensible/robust
manner, nor whether it issues interrupts itself. Ultimately you have to
trust the code that you are using to be servicable code. If a thread
interrupt caused a library to leave a corrupt database then that library
is not going to be used for long. Ask the vendor how their code responds
to interrupts - it's information any reputable vendor should be willing
to share (and the usual answer is that interrupts are ignored -
hopefully without clearing them of course).

 

If you are trying to be responsive to interrupts, as a cancellation
request, then you can't be more responsive than the code that you call.

 

Interrupt is for cooperative cancellation not asynchronous cancellation.
Async cancellation is unusable in all but the most constrained contexts.

 

This topic is covered in depth in Chapter 7 of "Java Concurrency in
Practice".

 

I'm sure others will chime in with their opinions ;-)

 

Cheers,

David Holmes

	-----Original Message-----
	From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Jim
Newsham
	Sent: Tuesday, 11 September 2007 9:44 AM
	To: concurrency-interest at cs.oswego.edu
	Subject: [concurrency-interest] safe interruption

	 

	Hi everyone,

	 

	I'm new to this list.  I'm trying to find an appropriate place
for questions and discussions of concurrency in Java.  If this isn't the
best place, I'd appreciate some pointers on where to go.

	 

	One thing that bothers me about the interruption model is that
it breaks object-oriented encapsulation.  Whether I like it or not, an
interrupt may be signaled at any time, to the thread which is running my
code.  And even worse, my code will typically make calls to other code
(such as core Java classes or third party libraries), which I have no
control over.  Even if I can handle or ignore interruption of my own
code, I have no way of handling or ignoring interruption of third party
code which I called, and there's no way of knowing how it might respond
to such an interruption.  Even if they interpret interrupt as a request
for cancellation (which is just one interpretation), their definition of
cancellation may not fit with mine.  Cancellation may mean to
immediately give up what you're doing, even if it means corrupting files
on disk, or it might mean gracefully cleaning up first.

	 

	Let's take a practical example.  I want to implement
asynchronous cancellation of my code by interruption, and my code makes
calls to other code.  The other code in this case includes standard Java
stuff such as reading and writing files, but also using external
libraries, such as the Derby embedded database.

	 

	In my code, I can be careful to handle interrupts, such as
checking the interrupt status periodically, and handling
InterruptionException when sleeping or waiting.  But how do I know that
the third party code I'm calling will do the right thing when
interrupted?  For example, how do I know that when the Derby library
(which does a lot of disk IO) is interrupted, it won't close connections
or give up halfway through writing a file?  I guess I'm asserting that
since I don't know how third party code will react to interruption, it
is not safe to interrupt third party code at all.  Could I get some
response to this assertion?

	 

	If I can't safely interrupt third party code, then I need to
mask interrupts from that code somehow.  The only way I can think of to
do this is to run that code on another thread which is never
interrupted.  So now I have:

	 

	Controller (monitors state/progress of work and implements
interruption).  This might be the UI with a "Cancel" button or something
else.

	 

	Worker thread.  Runs my code, which is in Runnable.run().  This
code is written to handle interruption.  Whenever it calls third party
code, it must spawn another thread (or queue a task on a pool), so that
interrupts are never sent to third party code.

	 

	Uninterrupted worker thread.  A thread (or thread pool) which
the worker thread initiates to run third party code.  This thread is
never interrupted.  This could be implemented as a static method
invokeUninterruptibly(Runnable r) which uses a thread pool.

	 

	This is a lot of extra work and makes my code a lot less
straightforward to write and maintain.  So please tell me... am I out in
left field here?  

	 

	Thanks,

	Jim

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070910/ebc9c947/attachment-0001.html 

From jason.greene at redhat.com  Mon Sep 10 21:43:39 2007
From: jason.greene at redhat.com (Jason T. Greene)
Date: Mon, 10 Sep 2007 20:43:39 -0500
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46E53C47.8060005@cs.oswego.edu>
References: <46D330B8.3020907@cs.oswego.edu>	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>	<46D40844.8060906@cs.oswego.edu>	<46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu>
Message-ID: <46E5F2CB.5010602@redhat.com>

Doug Lea wrote:

-snip-

> Footnote (*): If we do this, then the corresponding jsr166y
> releases will require that people use -Xbootclasspath switches
> to run it for a while (like maybe even a year) before we
> integrate into Java7 builds. I know this causes logistic
> problems for some of you, but there's not much we can do about it.
> 

Are you referring to using Unsafe? If so, why not attempt the reflection 
hack if Xbootclasspath is not used.

-Jason

From dl at cs.oswego.edu  Tue Sep 11 07:28:17 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 11 Sep 2007 07:28:17 -0400
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46E5F2CB.5010602@redhat.com>
References: <46D330B8.3020907@cs.oswego.edu>	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>	<46D40844.8060906@cs.oswego.edu>	<46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu> <46E5F2CB.5010602@redhat.com>
Message-ID: <46E67BD1.7070505@cs.oswego.edu>

Jason T. Greene wrote:
> Doug Lea wrote:
> 
> -snip-
> 
>> Footnote (*): If we do this, then the corresponding jsr166y
>> releases will require that people use -Xbootclasspath switches
>> to run it for a while (like maybe even a year) before we
>> integrate into Java7 builds. I know this causes logistic
>> problems for some of you, but there's not much we can do about it.
>>
> 
> Are you referring to using Unsafe? If so, why not attempt the reflection 
> hack if Xbootclasspath is not used.
> 

Thanks. I probably ought to start doing this. It's a little
uncomfortable because it requires "setAccessible"
on Unsafe objects, which widens visibility (assuming
lack of a SecurityManager that prevents this.) And
Unsafe *really* is unsafe -- incorrect use can cause JVM
crashes and security breaches. No one except low-level library
writers should ever use it.  But it is a good compromise
stance for us while code is in preliminary release state,
since it usually eliminates need for -Xbootclasspath switches
that causes people to have edit all their build scripts etc.

Actually, as a middle ground, it is probably better idea to
issue preliminary releases using a form of this that fails
if a security manager is installed (regardless of its policies)
but  -Xbootclasspath was not used.

-Doug

From hanson.char at gmail.com  Tue Sep 11 11:59:05 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Tue, 11 Sep 2007 08:59:05 -0700
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46E67BD1.7070505@cs.oswego.edu>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
	<46D40844.8060906@cs.oswego.edu> <46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu> <46E5F2CB.5010602@redhat.com>
	<46E67BD1.7070505@cs.oswego.edu>
Message-ID: <ca53c8f80709110859x672c17a5ud53b5d9dd7687f3e@mail.gmail.com>

>incorrect use can cause JVM crashes

Out of curiosity, what would be a simple (ie easily committed) use case
where it is incorrectly used that would lead to a JVM crash ?  I ask for
accessing the Unsafe object via reflection seems like a de facto hack
nowadays.  Would  be good to understand the potential hazard more fully :)

Hanson Char

On 9/11/07, Doug Lea <dl at cs.oswego.edu> wrote:
>
> Jason T. Greene wrote:
> > Doug Lea wrote:
> >
> > -snip-
> >
> >> Footnote (*): If we do this, then the corresponding jsr166y
> >> releases will require that people use -Xbootclasspath switches
> >> to run it for a while (like maybe even a year) before we
> >> integrate into Java7 builds. I know this causes logistic
> >> problems for some of you, but there's not much we can do about it.
> >>
> >
> > Are you referring to using Unsafe? If so, why not attempt the reflection
> > hack if Xbootclasspath is not used.
> >
>
> Thanks. I probably ought to start doing this. It's a little
> uncomfortable because it requires "setAccessible"
> on Unsafe objects, which widens visibility (assuming
> lack of a SecurityManager that prevents this.) And
> Unsafe *really* is unsafe -- incorrect use can cause JVM
> crashes and security breaches. No one except low-level library
> writers should ever use it.  But it is a good compromise
> stance for us while code is in preliminary release state,
> since it usually eliminates need for -Xbootclasspath switches
> that causes people to have edit all their build scripts etc.
>
> Actually, as a middle ground, it is probably better idea to
> issue preliminary releases using a form of this that fails
> if a security manager is installed (regardless of its policies)
> but  -Xbootclasspath was not used.
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070911/025ec359/attachment.html 

From jason.greene at redhat.com  Tue Sep 11 15:13:42 2007
From: jason.greene at redhat.com (Jason T. Greene)
Date: Tue, 11 Sep 2007 14:13:42 -0500
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46E67BD1.7070505@cs.oswego.edu>
References: <46D330B8.3020907@cs.oswego.edu>	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>	<46D40844.8060906@cs.oswego.edu>	<46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu> <46E5F2CB.5010602@redhat.com>
	<46E67BD1.7070505@cs.oswego.edu>
Message-ID: <46E6E8E6.6000605@redhat.com>

Doug Lea wrote:
> Jason T. Greene wrote:
>> Doug Lea wrote:
>>
>> -snip-
>>
>>> Footnote (*): If we do this, then the corresponding jsr166y
>>> releases will require that people use -Xbootclasspath switches
>>> to run it for a while (like maybe even a year) before we
>>> integrate into Java7 builds. I know this causes logistic
>>> problems for some of you, but there's not much we can do about it.
>>>
>>
>> Are you referring to using Unsafe? If so, why not attempt the 
>> reflection hack if Xbootclasspath is not used.
>>
> 
> Thanks. I probably ought to start doing this. It's a little
> uncomfortable because it requires "setAccessible"
> on Unsafe objects, which widens visibility (assuming
> lack of a SecurityManager that prevents this.) 

Yes, but unless I am missing something, the widened visibility is 
limited to just the Field object instance that called setAccesible(), 
and this instance would be temporary, and hidden.

> And Unsafe *really* is unsafe -- incorrect use can cause JVM
> crashes and security breaches. No one except low-level library
> writers should ever use it.  

IMO, for these reasons, it would be nice if unsafe access was 
standardized in the JVM, and a special privilege was created to use it.

> But it is a good compromise
> stance for us while code is in preliminary release state,
> since it usually eliminates need for -Xbootclasspath switches
> that causes people to have edit all their build scripts etc.

Right. The easier it is to use the library, the more feedback you will 
get, which is important for a library such as this IMO.

> Actually, as a middle ground, it is probably better idea to
> issue preliminary releases using a form of this that fails
> if a security manager is installed (regardless of its policies)
> but  -Xbootclasspath was not used.

Ok, but is this really necessary? I mean if the policy allows it, 
someone can get access to it regardless of whether or not the library is 
  being used.

-Jason

From kevinb at google.com  Tue Sep 11 15:31:03 2007
From: kevinb at google.com (kevin bourrillion)
Date: Tue, 11 Sep 2007 12:31:03 -0700
Subject: [concurrency-interest] Google Collections Library 0.5 ALPHA
Message-ID: <108fcdeb0709111231mb2d1d0fnab0ae6eb4b3c0ff8@mail.gmail.com>

Hello concurrency-interest,

I hope you'll forgive the spam, but I realize that
"concurrency-interest" is also in many ways "collections-interest" and
I think the readers will be interested in this.

We've just posted the first public alpha of what we're calling (with
all our typical cleverness in product naming!), "the Google
Collections Library."  This is a package chock full of collections and
related utilities that fill in what we most felt was missing in the
JDK.  We built it to support our legions of Java developers and
projects internally, but now we're opening it up to the world.

The project page is http://google-collections.googlecode.com, and I'll
paste a quick overview from that page right here:

----- snip -----

The major new types are:

    * BiMap. A Map that guarantees unique values, and supports an inverse view.
    * Multiset. A Collection that may contain duplicate values like a
List, yet has order-independent equality like a Set. Often used to
represent a histogram.
    * Multimap. Similar to Map, but may contain duplicate keys. Has
subtypes SetMultimap and ListMultimap providing more specific
behavior.

There are also more than a dozen collection implementations, mostly of
the interfaces above, but not all. ReferenceMap, for example, is a Map
implementation which easily handles any combination of strong, soft or
weak keys with strong, soft or weak values.

Static utility classes include:

    * Comparators. Natural order, compound, null-friendly, ad-hoc . . .
    * Iterators and Iterables. Element-based equality, cycle, concat,
partition, filter with predicate, transform with function . . .
    * Lists, Sets and Maps. A plethora of convenient factory methods
and much more.
    * PrimitiveArrays: "boxing"/"unboxing" of primitive arrays

And there's more:

    * Forwarding collections
    * Constrained collections
    * Implementation helpers like AbstractIterator

----- snip -----

(There's a shortage of concurrent collections, but we do have a
ConcurrentMultiset that should be ready pretty soon.)

You're all very welcome to check out what we have here so far, and
please send us your feedback!

-- 
Kevin Bourrillion @ Google
google-collections.googlecode.com
google-guice.googlecode.com

From dl at cs.oswego.edu  Tue Sep 11 15:35:45 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 11 Sep 2007 15:35:45 -0400
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <ca53c8f80709110859x672c17a5ud53b5d9dd7687f3e@mail.gmail.com>
References: <46D330B8.3020907@cs.oswego.edu>	
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>	
	<46D40844.8060906@cs.oswego.edu> <46D40FA9.70505@cs.oswego.edu>	
	<46E53C47.8060005@cs.oswego.edu> <46E5F2CB.5010602@redhat.com>	
	<46E67BD1.7070505@cs.oswego.edu>
	<ca53c8f80709110859x672c17a5ud53b5d9dd7687f3e@mail.gmail.com>
Message-ID: <46E6EE11.8030708@cs.oswego.edu>

Hanson Char wrote:
>  >incorrect use can cause JVM crashes
> 
> Out of curiosity, what would be a simple (ie easily committed) use case 
> where it is incorrectly used that would lead to a JVM crash ? 

Try using Random.nextLong() as just about any argument
for just about any of these methods.

> I ask for 
> accessing the Unsafe object via reflection seems like a de facto hack 
> nowadays.  Would  be good to understand the potential hazard more fully :)
> 

Scary. I really hope people don't do this unless they have no
choice. Unsafe is not a general-purpose facility. (*)
We and other core library implementors don't have a choice when
providing new natively supported functionality. But once we do,
almost nobody else should ever need to use the internal APIs.
Unsafe is a means for low-level libraries to efficiently implement
APIs tied to native capabilities in part by moving
responsibility for maintaining Java safety guarantees
to Java library code, not JVM code. So anyone using them must
thoroughly understand Java safety guarantees and how to
enforce them. It is arguably a bug that there is any way at all
to access Unsafe outside of core libraries.
But still, convenient for our current purposes of getting out
prerelease code so people can gather experience with it before
arguing for incorporation into releases.

(*) In fact, it is not even a part of Java(tm). Yet I
think all the production JVMs support it in one way or another
because there is no other reasonable way to provide this
JVM<->coreLibrary bridge. Presumably all the JVM implementors
figure that if they need to do something like this anyway,
they might as well simplify their lives a little by using an
API with a common intersection so can tie into low-level Java
libraries without rewriting them. I'm not so sure that this
is a bad way for this to have evolved considering that the
the main alternative would have been to standardize on
new bytecodes, which is a glacial process.

-Doug



From dl at cs.oswego.edu  Tue Sep 11 16:37:40 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 11 Sep 2007 16:37:40 -0400
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46E6E8E6.6000605@redhat.com>
References: <46D330B8.3020907@cs.oswego.edu>	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>	<46D40844.8060906@cs.oswego.edu>	<46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu> <46E5F2CB.5010602@redhat.com>
	<46E67BD1.7070505@cs.oswego.edu> <46E6E8E6.6000605@redhat.com>
Message-ID: <46E6FC94.2030800@cs.oswego.edu>

Jason T. Greene wrote:
>
>> Thanks. I probably ought to start doing this. It's a little
>> uncomfortable because it requires "setAccessible"
>> on Unsafe objects, which widens visibility (assuming
>> lack of a SecurityManager that prevents this.) 
> 
> Yes, but unless I am missing something, the widened visibility is 
> limited to just the Field object instance that called setAccesible(), 
> and this instance would be temporary, and hidden.

So long as it is temporary and hidden, which you are right
is the best way to implement this.

> 
>> And Unsafe *really* is unsafe -- incorrect use can cause JVM
>> crashes and security breaches. No one except low-level library
>> writers should ever use it.  
> 
> IMO, for these reasons, it would be nice if unsafe access was 
> standardized in the JVM, and a special privilege was created to use it.
> 

Aside: Five years ago or so, I discussed with the various
JVM providers plans for doing something like this. Most didn't want to,
so it never led to a JSR. The main argument against standardization was
it was their only vehicle for trying out new forms of native support
that might vary from others or even across releases.
And given that everyone wants to save
having to rewrite j.u.c., nio, etc., library code, a common intersection
would become defacto standard anyway. Which is basically what has
happened. But the non-officialness of this defacto standard does
seem to have led to misunderstandings and misuse as well, so maybe
it is time to try again.

>> Actually, as a middle ground, it is probably better idea to
>> issue preliminary releases using a form of this that fails
>> if a security manager is installed (regardless of its policies)
>> but  -Xbootclasspath was not used.
> 
> Ok, but is this really necessary? I mean if the policy allows it, 
> someone can get access to it regardless of whether or not the library is 
>  being used.
> 

My thought here is that you want this to be strictly opt-in
if there is any security policy at all. Given that there is no
defined permission, the only way to opt-in is to use
-Xbootclasspath on each run.  It's probably overkill though.

-Doug

From jason.greene at redhat.com  Tue Sep 11 16:57:53 2007
From: jason.greene at redhat.com (Jason T. Greene)
Date: Tue, 11 Sep 2007 15:57:53 -0500
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <ca53c8f80709110859x672c17a5ud53b5d9dd7687f3e@mail.gmail.com>
References: <46D330B8.3020907@cs.oswego.edu>	
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>	
	<46D40844.8060906@cs.oswego.edu> <46D40FA9.70505@cs.oswego.edu>	
	<46E53C47.8060005@cs.oswego.edu> <46E5F2CB.5010602@redhat.com>	
	<46E67BD1.7070505@cs.oswego.edu>
	<ca53c8f80709110859x672c17a5ud53b5d9dd7687f3e@mail.gmail.com>
Message-ID: <46E70151.7010108@redhat.com>

Hanson Char wrote:
>  >incorrect use can cause JVM crashes
> 
> Out of curiosity, what would be a simple (ie easily committed) use case 
> where it is incorrectly used that would lead to a JVM crash ?  I ask for 
> accessing the Unsafe object via reflection seems like a de facto hack 
> nowadays.  Would  be good to understand the potential hazard more fully :)
> 

What are you using Unsafe for? Perhaps we can suggest a safe and 
portable alternative.

-Jason

From hanson.char at gmail.com  Wed Sep 12 01:26:51 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Tue, 11 Sep 2007 22:26:51 -0700
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46E70151.7010108@redhat.com>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
	<46D40844.8060906@cs.oswego.edu> <46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu> <46E5F2CB.5010602@redhat.com>
	<46E67BD1.7070505@cs.oswego.edu>
	<ca53c8f80709110859x672c17a5ud53b5d9dd7687f3e@mail.gmail.com>
	<46E70151.7010108@redhat.com>
Message-ID: <ca53c8f80709112226h7b3edc14h5ecd066192e9bdb5@mail.gmail.com>

I know of at least one popular open source project, XStream, that uses
the Sun's Unsafe object (via hacking it out):

See:

http://fisheye.codehaus.org/browse/xstream/trunk/xstream/src/java/com/thoughtworks/xstream/converters/reflection/Sun14ReflectionProvider.java?r=1125

Hanson Char

On 9/11/07, Jason T. Greene <jason.greene at redhat.com> wrote:
>
> What are you using Unsafe for? Perhaps we can suggest a safe and
> portable alternative.

From hanson.char at gmail.com  Wed Sep 12 01:36:02 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Tue, 11 Sep 2007 22:36:02 -0700
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <ca53c8f80709112226h7b3edc14h5ecd066192e9bdb5@mail.gmail.com>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
	<46D40844.8060906@cs.oswego.edu> <46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu> <46E5F2CB.5010602@redhat.com>
	<46E67BD1.7070505@cs.oswego.edu>
	<ca53c8f80709110859x672c17a5ud53b5d9dd7687f3e@mail.gmail.com>
	<46E70151.7010108@redhat.com>
	<ca53c8f80709112226h7b3edc14h5ecd066192e9bdb5@mail.gmail.com>
Message-ID: <ca53c8f80709112236g443d302ax79f508dc612401a8@mail.gmail.com>

I guess the most likely/common use case of Unsafe would be whenever
some new code need to do something similar to but not exactly the same
as certain part of what the jdk is doing, and that certain part (of
jdk) is using Unsafe, it would then lead the new code to hack out the
Unsafe and use it.  There seems no other easier/direct route than
this.

Hanson Char

On 9/11/07, Hanson Char <hanson.char at gmail.com> wrote:
> I know of at least one popular open source project, XStream, that uses
> the Sun's Unsafe object (via hacking it out):
>
> See:
>
> http://fisheye.codehaus.org/browse/xstream/trunk/xstream/src/java/com/thoughtworks/xstream/converters/reflection/Sun14ReflectionProvider.java?r=1125
>
> Hanson Char
>
> On 9/11/07, Jason T. Greene <jason.greene at redhat.com> wrote:
> >
> > What are you using Unsafe for? Perhaps we can suggest a safe and
> > portable alternative.
>

From hanson.char at gmail.com  Wed Sep 12 11:51:23 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Wed, 12 Sep 2007 08:51:23 -0700
Subject: [concurrency-interest] forkjoin.ParallelArray and friends
In-Reply-To: <46D330B8.3020907@cs.oswego.edu>
References: <46D330B8.3020907@cs.oswego.edu>
Message-ID: <ca53c8f80709120851h30e46478gbc4e2aed1249d5ec@mail.gmail.com>

Got 404 Not Found when clicking on:

http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/forkjoin/ParallelArray.html

Where has it moved ?

Hanson

On 8/27/07, Doug Lea <dl at cs.oswego.edu> wrote:
> As people who have been keeping track of the new fine-grained parallelism
> framework might have noticed, we are firming up the aggregate operations
> APIs. The main APIs surround class ParallelArray, which provides
> apply, map, reduce, select, transform etc operations. For javadocs, see:
> http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/forkjoin/ParallelArray.html
>
> (And for jars, sources etc, see the usual places linked at
> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html)
>
> While I expect a few minor changes will occur, unlike some previous
> forms, these classes no longer say that they are standins for
> functionality that will be developed. We think the APIs and
> code are just about ready for routine (non-production) use,
> and so invite you to uses them and report back any comments
> and suggestions. (Now is your big chance before things become
> too entrenched to change.)
>
> Here's something pasted from javadocs that gives a feeling
> for how you use ParallelArrays:
>
>    import static Ops.*;
>    class StudentStatistics {
>      ParallelArray<Student> students = ...
>      // ...
>      public double getMaxSeniorGpa() {
>        return students.withFilter(isSenior).withMapping(gpaField).max();
>      }
>
>      // helpers:
>      static final class IsSenior implements Predicate<Student> {
>        public boolean evaluate(Student s) { return s.credits > 90; }
>      }
>      static final IsSenior isSenior = new IsSenior();
>      static final class GpaField implements MappertoDouble<Student> {
>        public double map(Student s) { return s.gpa; }
>      }
>      static final GpaField gpaField = new GpaField();
>    }
>
>
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From hanson.char at gmail.com  Wed Sep 12 11:52:59 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Wed, 12 Sep 2007 08:52:59 -0700
Subject: [concurrency-interest] forkjoin.ParallelArray and friends
In-Reply-To: <ca53c8f80709120851h30e46478gbc4e2aed1249d5ec@mail.gmail.com>
References: <46D330B8.3020907@cs.oswego.edu>
	<ca53c8f80709120851h30e46478gbc4e2aed1249d5ec@mail.gmail.com>
Message-ID: <ca53c8f80709120852m2432bc2dvddc1baaa5e5147b0@mail.gmail.com>

Also, it seems

  CVSROOT=:pserver:anonymous at gee.cs.oswego.edu:/export/home/jsr166/jsr166

no longer works:

connect to gee.cs.oswego.edu:2401 failed: A connection attempt failed
because the connected party did not properly respond after a period of
time, or established connection failed because connected host has
failed to respond.

On 9/12/07, Hanson Char <hanson.char at gmail.com> wrote:
> Got 404 Not Found when clicking on:
>
> http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/forkjoin/ParallelArray.html
>
> Where has it moved ?
>
> Hanson
>
> On 8/27/07, Doug Lea <dl at cs.oswego.edu> wrote:
> > As people who have been keeping track of the new fine-grained parallelism
> > framework might have noticed, we are firming up the aggregate operations
> > APIs. The main APIs surround class ParallelArray, which provides
> > apply, map, reduce, select, transform etc operations. For javadocs, see:
> > http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/forkjoin/ParallelArray.html
> >
> > (And for jars, sources etc, see the usual places linked at
> > http://gee.cs.oswego.edu/dl/concurrency-interest/index.html)
> >
> > While I expect a few minor changes will occur, unlike some previous
> > forms, these classes no longer say that they are standins for
> > functionality that will be developed. We think the APIs and
> > code are just about ready for routine (non-production) use,
> > and so invite you to uses them and report back any comments
> > and suggestions. (Now is your big chance before things become
> > too entrenched to change.)
> >
> > Here's something pasted from javadocs that gives a feeling
> > for how you use ParallelArrays:
> >
> >    import static Ops.*;
> >    class StudentStatistics {
> >      ParallelArray<Student> students = ...
> >      // ...
> >      public double getMaxSeniorGpa() {
> >        return students.withFilter(isSenior).withMapping(gpaField).max();
> >      }
> >
> >      // helpers:
> >      static final class IsSenior implements Predicate<Student> {
> >        public boolean evaluate(Student s) { return s.credits > 90; }
> >      }
> >      static final IsSenior isSenior = new IsSenior();
> >      static final class GpaField implements MappertoDouble<Student> {
> >        public double map(Student s) { return s.gpa; }
> >      }
> >      static final GpaField gpaField = new GpaField();
> >    }
> >
> >
> >
> > -Doug
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>

From dl at cs.oswego.edu  Wed Sep 12 11:56:32 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 12 Sep 2007 11:56:32 -0400
Subject: [concurrency-interest] forkjoin.ParallelArray and friends
In-Reply-To: <ca53c8f80709120851h30e46478gbc4e2aed1249d5ec@mail.gmail.com>
References: <46D330B8.3020907@cs.oswego.edu>
	<ca53c8f80709120851h30e46478gbc4e2aed1249d5ec@mail.gmail.com>
Message-ID: <46E80C30.50406@cs.oswego.edu>

Hanson Char wrote:
> Got 404 Not Found when clicking on:
> 
> http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/forkjoin/ParallelArray.html
> 
> Where has it moved ?
> 

It's back. I generate javadocs from live workspaces, and sometimes
it takes a few tries to get them created right (this morning,
as separated by a few interruptions). Sorry about that.

-Doug

From hanson.char at gmail.com  Thu Sep 13 01:53:34 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Wed, 12 Sep 2007 22:53:34 -0700
Subject: [concurrency-interest] forkjoin.ParallelArray and friends
In-Reply-To: <46D330B8.3020907@cs.oswego.edu>
References: <46D330B8.3020907@cs.oswego.edu>
Message-ID: <ca53c8f80709122253r62e269f8o52bdddccd9d29fc1@mail.gmail.com>

On 8/27/07, Doug Lea <dl at cs.oswego.edu> wrote:
> (And for jars, sources etc, see the usual places linked at
> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html)

"Note; Usually the easiest way to build these yourself is to "download
tarball" of  full sources and then unpack and use "ant jsr166ydist" to
create jar and javadocs."

The ant target "jsr166ydist" doesn't exist.  Not checked in to CVS, or
am I missing something ?

Hanson Char

From hanson.char at gmail.com  Thu Sep 13 02:09:11 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Wed, 12 Sep 2007 23:09:11 -0700
Subject: [concurrency-interest] forkjoin.ParallelArray and friends
In-Reply-To: <63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
Message-ID: <ca53c8f80709122309p7954fcc7gda9259788444a08d@mail.gmail.com>

On 8/27/07, Tim Peierls <tim at peierls.net> wrote:
http://dev.priorartisans.com/tim/jsr166y/src/main/java/net/jcip/jsr166y/ParallelArrayVsHandCodedLoop.java

A small typo:

    new App(numStudents, warmups, trials).run();

should probably be:

  new ParallelArrayVsHandCodedLoop(numStudents, warmups, trials).run();

?

Hanson Char

From hanson.char at gmail.com  Thu Sep 13 02:50:24 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Wed, 12 Sep 2007 23:50:24 -0700
Subject: [concurrency-interest] forkjoin.ParallelArray and friends
In-Reply-To: <63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
Message-ID: <ca53c8f80709122350t1dec0473j947d8ab3d5966ef6@mail.gmail.com>

On 8/27/07, Tim Peierls <tim at peierls.net> wrote:
> Doug warned us not to expect too much from ForkJoin-based programs running
> on only one or two processors, so when I tried a comparison of ParallelArray
> vs. a hand-coded loop on a single hyper-threaded processor laptop, I was
> just hoping the fork-join overhead wouldn't be too egregious. Instead, to my
> surprise, the ParallelArray version consistently outperformed the loop
> version by 10-20%!

On my single CPU laptop, I found the opposite result.

This test program only performs CPU computation and memory I/O.   In
general, when executed on a platform with a single processor, how can
a program (with no other I/O operations besides memory read/write)
written to use a parallel computation framework (and therefore induces
additional overhead) ever perform faster than one with a simple loop ?
 Is it true/possible that memory read/write operations can be
parallelized (ie made concurrent) even on a single processor platform
?  If so, is that common ?  I apologize for my ignorance.

Hanson Char

From tim at peierls.net  Thu Sep 13 08:34:42 2007
From: tim at peierls.net (Tim Peierls)
Date: Thu, 13 Sep 2007 08:34:42 -0400
Subject: [concurrency-interest] forkjoin.ParallelArray and friends
In-Reply-To: <ca53c8f80709122350t1dec0473j947d8ab3d5966ef6@mail.gmail.com>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
	<ca53c8f80709122350t1dec0473j947d8ab3d5966ef6@mail.gmail.com>
Message-ID: <63b4e4050709130534y5c495efek8628f8f14cacd89c@mail.gmail.com>

On 9/13/07, Hanson Char <hanson.char at gmail.com> wrote:
>
> This test program only performs CPU computation and memory I/O.   In
> general, when executed on a platform with a single processor, how can a
> program (with no other I/O operations besides memory read/write) written to
> use a parallel computation framework (and therefore induces additional
> overhead) ever perform faster than one with a simple loop?
> Is it true/possible that memory read/write operations can be parallelized
> (ie made concurrent) even on a single processor platform?  If so, is that
> common?  I apologize for my ignorance.
>

One hyper-threaded CPU with 2 logical processors can in some cases do better
than a single processor. If a read in the first logical processor has a
cache miss, say, a different read in the other logical processor might be
able to proceed. It doesn't sound like much of an advantage, and in fact I
was skeptical about ever being able to make much of that advantage in Java.
That's why I was so surprised and pleased with the ParallelArray
performance.

It's also quite possible that my measurements are flawed, which is why I was
hoping someone else could reproduce them (or not).


A small typo:
>
>     new App(numStudents, warmups, trials).run();
>
> should probably be:
>
>   new ParallelArrayVsHandCodedLoop(numStudents, warmups, trials).run();
>

Yup, sorry. I'll fix it when I can, but for now just
s/App/ParallelArrayVsHandCodedLoop/.

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070913/f78d6a7f/attachment.html 

From gregg at cytetech.com  Thu Sep 13 12:55:15 2007
From: gregg at cytetech.com (Gregg Wonderly)
Date: Thu, 13 Sep 2007 11:55:15 -0500
Subject: [concurrency-interest] forkjoin.ParallelArray and friends
In-Reply-To: <ca53c8f80709122350t1dec0473j947d8ab3d5966ef6@mail.gmail.com>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
	<ca53c8f80709122350t1dec0473j947d8ab3d5966ef6@mail.gmail.com>
Message-ID: <46E96B73.4020907@cytetech.com>

Hanson Char wrote:
> On 8/27/07, Tim Peierls <tim at peierls.net> wrote:
>>... so when I tried a comparison of ParallelArray
>>vs. a hand-coded loop on a single hyper-threaded processor laptop,

So that is effectively a multi-CPU machine...

> On my single CPU laptop, I found the opposite result.

Can you give specifics on the processor?  Was it hyperthreaded?

> This test program only performs CPU computation and memory I/O.   In
> general, when executed on a platform with a single processor, how can
> a program (with no other I/O operations besides memory read/write)
> written to use a parallel computation framework (and therefore induces
> additional overhead) ever perform faster than one with a simple loop ?
>  Is it true/possible that memory read/write operations can be
> parallelized (ie made concurrent) even on a single processor platform
> ?  If so, is that common ?  I apologize for my ignorance.

Depending on system memory architecture, a cache read is fast compared to a RAM 
write.  So for memory I/O, multi-threading READ-COMPUTE, separate from WRITE can 
be an optimization.

Gregg Wonderly

From hanson.char at gmail.com  Thu Sep 13 14:11:45 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Thu, 13 Sep 2007 11:11:45 -0700
Subject: [concurrency-interest] forkjoin.ParallelArray and friends
In-Reply-To: <46E96B73.4020907@cytetech.com>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
	<ca53c8f80709122350t1dec0473j947d8ab3d5966ef6@mail.gmail.com>
	<46E96B73.4020907@cytetech.com>
Message-ID: <ca53c8f80709131111uf0f31ctf49933794f637658@mail.gmail.com>

On 9/13/07, Gregg Wonderly <gregg at cytetech.com> wrote:
> Hanson Char wrote:
> > On 8/27/07, Tim Peierls <tim at peierls.net> wrote:
> >>... so when I tried a comparison of ParallelArray
> >>vs. a hand-coded loop on a single hyper-threaded processor laptop,
>
> So that is effectively a multi-CPU machine...
>
> > On my single CPU laptop, I found the opposite result.
>
> Can you give specifics on the processor?  Was it hyperthreaded?

Intel Pentium M Processor 1.86 GHz.  It's not hyperthreaded, afaik.

Hanson Char

From gergg at cox.net  Thu Sep 13 16:05:04 2007
From: gergg at cox.net (Gregg Wonderly)
Date: Thu, 13 Sep 2007 15:05:04 -0500
Subject: [concurrency-interest] forkjoin.ParallelArray and friends
In-Reply-To: <ca53c8f80709131111uf0f31ctf49933794f637658@mail.gmail.com>
References: <46D330B8.3020907@cs.oswego.edu>	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>	<ca53c8f80709122350t1dec0473j947d8ab3d5966ef6@mail.gmail.com>	<46E96B73.4020907@cytetech.com>
	<ca53c8f80709131111uf0f31ctf49933794f637658@mail.gmail.com>
Message-ID: <46E997F0.6000609@cox.net>

Hanson Char wrote:
> On 9/13/07, Gregg Wonderly <gregg at cytetech.com> wrote:
> 
>>Hanson Char wrote:
>>
>>>On 8/27/07, Tim Peierls <tim at peierls.net> wrote:
>>>
>>>>... so when I tried a comparison of ParallelArray
>>>>vs. a hand-coded loop on a single hyper-threaded processor laptop,
>>
>>So that is effectively a multi-CPU machine...
>>
>>
>>>On my single CPU laptop, I found the opposite result.
>>
>>Can you give specifics on the processor?  Was it hyperthreaded?
> 
> Intel Pentium M Processor 1.86 GHz.  It's not hyperthreaded, afaik.

Okay, so not much opportunity for the types of parallelization that 
hyperthreading and multicore CPUs are affording.  It is very clear that this 
multi-core, multi-threaded CPU design is the next step in parallel computing 
solutions.  I find a great deal of benefits to it on my hyper threaded laptop 
(HP zd8000 series).

I think it's great to see something concreate being done to exploit this 
capability as much as possible without the developer or user having to 
"configure" or program it to happen explicitly!

Gregg Wonderly

From dawid.kurzyniec at gmail.com  Sat Sep 15 17:55:52 2007
From: dawid.kurzyniec at gmail.com (Dawid Kurzyniec)
Date: Sat, 15 Sep 2007 23:55:52 +0200
Subject: [concurrency-interest] new home for backport-util-concurrent
Message-ID: <3cbaca580709151455u7a738832x5b3a0e7328c4afc4@mail.gmail.com>

Hi all,

I've moved backport-util-concurrent to SourceForge:

http://backport-jsr166.sourceforge.net/

Main reason for migration is that the old server has been down for
several days, and since I am no longer with Emory University, I can't
fix such problems quickly.

BTW, there's a new release available there, which includes a dedicated
version optimized for 6.0+.

The migration is not complete yet; particularly, the Subversion
repository is still at the old place (thus not currently working).

Regards,
Dawid

From dhanji at gmail.com  Sun Sep 16 05:26:43 2007
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Sun, 16 Sep 2007 19:26:43 +1000
Subject: [concurrency-interest] copy on write semantics
Message-ID: <aa067ea10709160226s1eb7b939gd3fdef3d05cf1c7d@mail.gmail.com>

Hi

I have a map that is read a lot but written to rarely (both operations by
concurrent threads). Here is what I have:

public class MyMapWrapper {

   private volatile Map map = new WeakHashMap();  //generics implied for
convenience

   //called concurrently
   public V get(K k) {
      return map.get(k);
   }

   //called concurrently
   public synchronized void put(K k, V v) {
         Map copy = new WeakHashMap();
         copy.putAll(map);
         copy.put(k, v);

         map = copy;
   }
}


My reasoning is that copy-on-write putting needs to be synchronized (atomic
publications to "map"), and that get() does not need to be synchronized
because all threads are guaranteed to see a fully constructed map in "map"
(whether before or after any put). Am I correct in this reasoning?

Is there any value to my placing map inside an AtomicReference instead? Put
another way, is the cost of atomic reads different than the cost of reading
from volatiles?

Thanks!!

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070916/a4e9741e/attachment.html 

From joe.bowbeer at gmail.com  Sun Sep 16 07:05:46 2007
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sun, 16 Sep 2007 04:05:46 -0700
Subject: [concurrency-interest] copy on write semantics
In-Reply-To: <aa067ea10709160226s1eb7b939gd3fdef3d05cf1c7d@mail.gmail.com>
References: <aa067ea10709160226s1eb7b939gd3fdef3d05cf1c7d@mail.gmail.com>
Message-ID: <31f2a7bd0709160405i35e41126mfe01f4cec0cd71ea@mail.gmail.com>

On 9/16/07, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
>
> I have a map that is read a lot but written to rarely (both operations by
> concurrent threads). Here is what I have:
>
> public class MyMapWrapper {
>
>    private volatile Map map = new WeakHashMap();  //generics implied for
> convenience
>
>    //called concurrently
>    public V get(K k) {
>       return map.get(k);
>    }
>
>    //called concurrently
>    public synchronized void put(K k, V v) {
>          Map copy = new WeakHashMap();
>          copy.putAll(map);
>          copy.put(k, v);
>
>          map = copy;
>    }
> }
>
> My reasoning is that copy-on-write putting needs to be synchronized (atomic
> publications to "map"), and that get() does not need to be synchronized
> because all threads are guaranteed to see a fully constructed map in "map"
> (whether before or after any put). Am I correct in this reasoning?
>

The volatile provides safe publication of the new map, but there are
no guarantees that map.get() is thread safe, or that the various
hashcode and equals methods it uses are thread safe.

In the WeakHashMap implementations I've seen, get() may cause stale
entries to be expunged.

--
Joe Bowbeer

From dhanji at gmail.com  Sun Sep 16 07:12:49 2007
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Sun, 16 Sep 2007 21:12:49 +1000
Subject: [concurrency-interest] copy on write semantics
In-Reply-To: <22ec15240709160321j7594bb4fma6fb5d64063ea13e@mail.gmail.com>
References: <aa067ea10709160226s1eb7b939gd3fdef3d05cf1c7d@mail.gmail.com>
	<22ec15240709160321j7594bb4fma6fb5d64063ea13e@mail.gmail.com>
Message-ID: <aa067ea10709160412p13ae0122w539b33c207ec395d@mail.gmail.com>

On 9/16/07, Matthias Ernst <ernst.matthias at gmail.com> wrote:
>
> Dhanji,
>
> your reasoning is fine. I've used this pattern myself a few times. I
> do not see any benefit from using an AtomicReference when all you
> would use is #get/#set.
>
> However, this code has a race where a copy made by one thread may be
> overridden by another thread's copy (typically not harmful if this is
> just a cache).


Yep! I should have mentioned I am ok with the race for same-key overwrites.
Perhaps I could introduce a containsKey() test at the top of the
synchronized put() and abort if it returns true (for "putIfAbsent" style
semantics). That should obviate the copy-on-overwrite overhead (!) ...

Also, when we're talking several thousand entries, the
> copy overhead becomes noticeable. A better alternative would be to use
> ConcurrentHashMap.


Yea I thought of this but it's a reflection cache so I am ok with the warm
up period.

Thanks Matthias.

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070916/3afa2a8c/attachment.html 

From dl at cs.oswego.edu  Sun Sep 16 16:38:46 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 16 Sep 2007 16:38:46 -0400
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46E6E8E6.6000605@redhat.com>
References: <46D330B8.3020907@cs.oswego.edu>	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>	<46D40844.8060906@cs.oswego.edu>	<46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu> <46E5F2CB.5010602@redhat.com>
	<46E67BD1.7070505@cs.oswego.edu> <46E6E8E6.6000605@redhat.com>
Message-ID: <46ED9456.8040901@cs.oswego.edu>

Jason T. Greene wrote:
>>> Are you referring to using Unsafe? If so, why not attempt the 
>>> reflection hack if Xbootclasspath is not used.

I checked into CVS versions that do this. (They also include some
internal initial support of the other changes I mentioned,
but the overall Parallel*Array APIs are as yet unchanged.) This
version compiles (with warnings) and runs on various Java5+
platforms I've tried it on. Assuming this does work, this
makes my life easier from here on out in not having to keep
pre-Java7 vs Java7 variants around.

Everyone: could you give a try to
"download tarball" of  full sources at 
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/#dirlist
and then unpack and build via "ant jsr166ydist".
You can also go into test/jsr166y and then compile
and run things like MapReduceDemo and SortDemo.

(As always, recall that this is designed mainly for the
dozens- to hundreds- of CPUs/cores world. It is almost
sure not to speed things up on uniprocessors, will
give only percentage speedups on hyperthreaded x86s,
is worth the effort on duals, and starts becoming impressive
on 8ways and above.)

While I'm at it, a related caveat and question: The forkjoin package
relies critically on decent native support of 64bit CAS
(in particular the equivalent of AtomicLongFieldUpdater.compareAndSet).
There are three j2se platforms I know for which this is not so:
old pre-Pentium x86, old pre-Ultra sparcs,
and pre-power5 PPCs, or, I believe any PPC JVM running on a 32bit OS.
The first two are unlikely to affect anyone using this.
But if you are running a PPC-based Mac, or a PPC on AIX 3.5,
performance is truly dreadful because of the need for
global locks for internal JVM emulation.
It is a tough call whether to do anything about this.
By the time this code is fully integrated
(assuming it is :-) in java releases, it will be unlikely to
affect many users. It is possible to release a version that
uses 32bit CASes instead of 64bit, but at the cost of not
being able to completely rule out erroneous behavior:
Basically, these bits are used as tags. With
only 32 bits, it is theoretically possible that if a
thread stalls out at a very unlucky point for more than about
3hrs (at current machine speeds), it could perform an
incorrect update. With 64bits, this interval is about 6billion hrs,
which is many orders of magnitude longer than the longest known
uptime of any machine. I could however release a semi-sanctioned
workaround version with lots of disclaimers if enough people
think it is worthwhile to be able to experiment with it with
this known (very tiny) risk. Advice welcome.


-Doug



From joe.bowbeer at gmail.com  Sun Sep 16 17:36:17 2007
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sun, 16 Sep 2007 14:36:17 -0700
Subject: [concurrency-interest] copy on write semantics
In-Reply-To: <31f2a7bd0709160405i35e41126mfe01f4cec0cd71ea@mail.gmail.com>
References: <aa067ea10709160226s1eb7b939gd3fdef3d05cf1c7d@mail.gmail.com>
	<31f2a7bd0709160405i35e41126mfe01f4cec0cd71ea@mail.gmail.com>
Message-ID: <31f2a7bd0709161436x7c107970jb8115c96bece0327@mail.gmail.com>

I think I should restate this point in stronger terms:

In *all* the WeakHashMap implementations I've seen, get() will expunge
stale entries.

In other words, the get() method is not thread safe.  In Java 6, see
the private getTable method.

WeakHashMap is probably the worst case here, but I would consider this
technique a hack when used with any non-thread-safe class unless one
knew precisely how it was implemented.  There's really no telling what
get() might do internally.

On 9/16/07, Joe Bowbeer wrote:
> On 9/16/07, Dhanji R. Prasanna wrote:
> >
> > I have a map that is read a lot but written to rarely (both operations by
> > concurrent threads). Here is what I have:
> >
> > public class MyMapWrapper {
> >
> >    private volatile Map map = new WeakHashMap();  //generics implied for
> > convenience
> >
> >    //called concurrently
> >    public V get(K k) {
> >       return map.get(k);
> >    }
> >
> >    //called concurrently
> >    public synchronized void put(K k, V v) {
> >          Map copy = new WeakHashMap();
> >          copy.putAll(map);
> >          copy.put(k, v);
> >
> >          map = copy;
> >    }
> > }
> >
> > My reasoning is that copy-on-write putting needs to be synchronized (atomic
> > publications to "map"), and that get() does not need to be synchronized
> > because all threads are guaranteed to see a fully constructed map in "map"
> > (whether before or after any put). Am I correct in this reasoning?
> >
>
> The volatile provides safe publication of the new map, but there are
> no guarantees that map.get() is thread safe, or that the various
> hashcode and equals methods it uses are thread safe.
>
> In the WeakHashMap implementations I've seen, get() may cause stale
> entries to be expunged.
>
> --
> Joe Bowbeer
>

From studdugie at gmail.com  Sun Sep 16 18:02:51 2007
From: studdugie at gmail.com (studdugie)
Date: Sun, 16 Sep 2007 18:02:51 -0400
Subject: [concurrency-interest] The Missing Minute
Message-ID: <5a59ce530709161502r6d6bf83cj60cc6e4ff0acad9b@mail.gmail.com>

I lot of time is spent on this list in the academic discussion of
concurrency issues. Yesterday I came across a concurrency issue in
some code of mine that's always been there, but was hidden in plain
site because none of my previous test cases had a small enough data
set to trigger it. But instead of delving into a academic discussion
of what the problem was and how I fixed it I offer you the following:

 The Missing Minute

Sometime earlier today
A minute of mine went away
So I thought about main
But that was in vain
The minute was hiding away.

I opened the profiler quick
And attach to the app in a nick
I collected a sample
It wasn't quite ample
The minute continued to tick.

I decided to give it a rest
In order to give it my best
I went for a drive
And in about five
My mind was finally unstressed.

On the way home I found it
The minute that had me confounded
It was caught in a latch
With a timer dispatch
But no interrupt handler around it.

Let this be a lesson to all
When debugging processes stall
Take a step back and maybe a nap
And the bug is likely to fall.


This is modified more Java centric version . The original is posted on my blog.
http://designdecisions.blogspot.com/2007/09/missing-minute.html

Regards,

Dane

From studdugie at gmail.com  Sun Sep 16 21:30:41 2007
From: studdugie at gmail.com (studdugie)
Date: Sun, 16 Sep 2007 21:30:41 -0400
Subject: [concurrency-interest] The Missing Minute
Message-ID: <5a59ce530709161830rf5a4db4kbcbf609eceaaf3c2@mail.gmail.com>

I lot of time is spent on this list in the academic discussion of
concurrency issues. Yesterday I came across a concurrency issue in
some code of mine that's always been there, but was hidden in plain
site because none of my previous test cases had a small enough data
set to trigger it. But instead of delving into a academic discussion
of what the problem was and how I fixed it I offer you the following:

 The Missing Minute

Sometime earlier today
A minute of mine went away
So I thought about main
But that was in vain
The minute was hiding away.

I opened the profiler quick
And attach to the app in a nick
I collected a sample
It wasn't quite ample
The minute continued to tick.

I decided to give it a rest
In order to give it my best
I went for a drive
And in about five
My mind was finally unstressed.

On the way home I found it
The minute that had me confounded
It was caught in a latch
With a timer dispatch
But no interrupt handler around it.

Let this be a lesson to all
When debugging processes stall
Take a step back and maybe a nap
And the bug is likely to fall.


This is modified more Java centric version . The original is posted on my blog.
http://designdecisions.blogspot.com/2007/09/missing-minute.html

Regards,

Dane

From matthias at mernst.org  Mon Sep 17 02:57:54 2007
From: matthias at mernst.org (Matthias Ernst)
Date: Mon, 17 Sep 2007 08:57:54 +0200
Subject: [concurrency-interest] copy on write semantics
In-Reply-To: <31f2a7bd0709161436x7c107970jb8115c96bece0327@mail.gmail.com>
References: <aa067ea10709160226s1eb7b939gd3fdef3d05cf1c7d@mail.gmail.com>
	<31f2a7bd0709160405i35e41126mfe01f4cec0cd71ea@mail.gmail.com>
	<31f2a7bd0709161436x7c107970jb8115c96bece0327@mail.gmail.com>
Message-ID: <22ec15240709162357w6146d277i9408c09360b5d4bd@mail.gmail.com>

> WeakHashMap is probably the worst case here, but I would consider this
> technique a hack when used with any non-thread-safe class unless one
> knew precisely how it was implemented.  There's really no telling what
> get() might do internally.

From dhanji at gmail.com  Mon Sep 17 08:55:56 2007
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Mon, 17 Sep 2007 22:55:56 +1000
Subject: [concurrency-interest] copy on write semantics
In-Reply-To: <31f2a7bd0709161436x7c107970jb8115c96bece0327@mail.gmail.com>
References: <aa067ea10709160226s1eb7b939gd3fdef3d05cf1c7d@mail.gmail.com>
	<31f2a7bd0709160405i35e41126mfe01f4cec0cd71ea@mail.gmail.com>
	<31f2a7bd0709161436x7c107970jb8115c96bece0327@mail.gmail.com>
Message-ID: <aa067ea10709170555i64753266ma888a16066862d8e@mail.gmail.com>

Hi Joe

That's pretty relevant to my use case, thanks for pointing it out. I'll
probably switch to a plain HashMap.
Regards,

Dhanji.

On 9/17/07, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
>
> I think I should restate this point in stronger terms:
>
> In *all* the WeakHashMap implementations I've seen, get() will expunge
> stale entries.
>
> In other words, the get() method is not thread safe.  In Java 6, see
> the private getTable method.
>
> WeakHashMap is probably the worst case here, but I would consider this
> technique a hack when used with any non-thread-safe class unless one
> knew precisely how it was implemented.  There's really no telling what
> get() might do internally.
>
> On 9/16/07, Joe Bowbeer wrote:
> > On 9/16/07, Dhanji R. Prasanna wrote:
> > >
> > > I have a map that is read a lot but written to rarely (both operations
> by
> > > concurrent threads). Here is what I have:
> > >
> > > public class MyMapWrapper {
> > >
> > >    private volatile Map map = new WeakHashMap();  //generics implied
> for
> > > convenience
> > >
> > >    //called concurrently
> > >    public V get(K k) {
> > >       return map.get(k);
> > >    }
> > >
> > >    //called concurrently
> > >    public synchronized void put(K k, V v) {
> > >          Map copy = new WeakHashMap();
> > >          copy.putAll(map);
> > >          copy.put(k, v);
> > >
> > >          map = copy;
> > >    }
> > > }
> > >
> > > My reasoning is that copy-on-write putting needs to be synchronized
> (atomic
> > > publications to "map"), and that get() does not need to be
> synchronized
> > > because all threads are guaranteed to see a fully constructed map in
> "map"
> > > (whether before or after any put). Am I correct in this reasoning?
> > >
> >
> > The volatile provides safe publication of the new map, but there are
> > no guarantees that map.get() is thread safe, or that the various
> > hashcode and equals methods it uses are thread safe.
> >
> > In the WeakHashMap implementations I've seen, get() may cause stale
> > entries to be expunged.
> >
> > --
> > Joe Bowbeer
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070917/f6b6151b/attachment.html 

From osvaldo at visionnaire.com.br  Mon Sep 17 08:55:47 2007
From: osvaldo at visionnaire.com.br (Osvaldo Pinali Doederlein)
Date: Mon, 17 Sep 2007 09:55:47 -0300
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46ED9456.8040901@cs.oswego.edu>
References: <46D330B8.3020907@cs.oswego.edu>	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>	<46D40844.8060906@cs.oswego.edu>	<46D40FA9.70505@cs.oswego.edu>	<46E53C47.8060005@cs.oswego.edu>
	<46E5F2CB.5010602@redhat.com>	<46E67BD1.7070505@cs.oswego.edu>
	<46E6E8E6.6000605@redhat.com> <46ED9456.8040901@cs.oswego.edu>
Message-ID: <46EE7953.8050601@visionnaire.com.br>

Doug Lea escreveu:
> With 64bits, this interval is about 6billion hrs,
> which is many orders of magnitude longer than the longest known
> uptime of any machine.
Well 6 billion hours is less than 700K years, but the Deep Thought 
computer will take 7,5 million years to compute the Answer to Life, the 
Universe and Everything!  :)

A+
Osvaldo

-- 
-----------------------------------------------------------------------
Osvaldo Pinali Doederlein                   Visionnaire Inform?tica S/A
osvaldo at visionnaire.com.br                http://www.visionnaire.com.br
Arquiteto de Tecnologia                          +55 (41) 337-1000 #223


From jason.greene at redhat.com  Mon Sep 17 09:01:52 2007
From: jason.greene at redhat.com (Jason T. Greene)
Date: Mon, 17 Sep 2007 08:01:52 -0500
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46EE7953.8050601@visionnaire.com.br>
References: <46D330B8.3020907@cs.oswego.edu>	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>	<46D40844.8060906@cs.oswego.edu>	<46D40FA9.70505@cs.oswego.edu>	<46E53C47.8060005@cs.oswego.edu>
	<46E5F2CB.5010602@redhat.com>	<46E67BD1.7070505@cs.oswego.edu>
	<46E6E8E6.6000605@redhat.com> <46ED9456.8040901@cs.oswego.edu>
	<46EE7953.8050601@visionnaire.com.br>
Message-ID: <46EE7AC0.9050800@redhat.com>

Osvaldo Pinali Doederlein wrote:
> Doug Lea escreveu:
>> With 64bits, this interval is about 6billion hrs,
>> which is many orders of magnitude longer than the longest known
>> uptime of any machine.
> Well 6 billion hours is less than 700K years, but the Deep Thought 
> computer will take 7,5 million years to compute the Answer to Life, the 
> Universe and Everything!  :)
>

I'm sure Deep Thought will have at least a 128 bit address space :)

-Jason


From jason.greene at redhat.com  Mon Sep 17 09:01:52 2007
From: jason.greene at redhat.com (Jason T. Greene)
Date: Mon, 17 Sep 2007 08:01:52 -0500
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46EE7953.8050601@visionnaire.com.br>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
	<46D40844.8060906@cs.oswego.edu> <46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu> <46E5F2CB.5010602@redhat.com>
	<46E67BD1.7070505@cs.oswego.edu> <46E6E8E6.6000605@redhat.com>
	<46ED9456.8040901@cs.oswego.edu> <46EE7953.8050601@visionnaire.com.br>
Message-ID: <46EE7AC0.9050800@redhat.com>

Osvaldo Pinali Doederlein wrote:
> Doug Lea escreveu:
>> With 64bits, this interval is about 6billion hrs,
>> which is many orders of magnitude longer than the longest known
>> uptime of any machine.
> Well 6 billion hours is less than 700K years, but the Deep Thought 
> computer will take 7,5 million years to compute the Answer to Life, the 
> Universe and Everything!  :)
>

I'm sure Deep Thought will have at least a 128 bit address space :)

-Jason


From elihusmails at gmail.com  Mon Sep 17 10:51:51 2007
From: elihusmails at gmail.com (Mark)
Date: Mon, 17 Sep 2007 10:51:51 -0400
Subject: [concurrency-interest] copy on write semantics
In-Reply-To: <aa067ea10709170555i64753266ma888a16066862d8e@mail.gmail.com>
References: <aa067ea10709160226s1eb7b939gd3fdef3d05cf1c7d@mail.gmail.com>
	<31f2a7bd0709160405i35e41126mfe01f4cec0cd71ea@mail.gmail.com>
	<31f2a7bd0709161436x7c107970jb8115c96bece0327@mail.gmail.com>
	<aa067ea10709170555i64753266ma888a16066862d8e@mail.gmail.com>
Message-ID: <9f066ee90709170751r26344e7dif9b15a7aea45253@mail.gmail.com>

I wrote this class for the Apache MINA program.

http://mina.apache.org/report/trunk/apidocs/org/apache/mina/util/CopyOnWriteMap.html

If you are just looking for a copy on write Map implementation, this might
fill your need.

-- 
..Cheers
Mark

On 9/17/07, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
>
> Hi Joe
>
> That's pretty relevant to my use case, thanks for pointing it out. I'll
> probably switch to a plain HashMap.
> Regards,
>
> Dhanji.
>
> On 9/17/07, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> >
> > I think I should restate this point in stronger terms:
> >
> > In *all* the WeakHashMap implementations I've seen, get() will expunge
> > stale entries.
> >
> > In other words, the get() method is not thread safe.  In Java 6, see
> > the private getTable method.
> >
> > WeakHashMap is probably the worst case here, but I would consider this
> > technique a hack when used with any non-thread-safe class unless one
> > knew precisely how it was implemented.  There's really no telling what
> > get() might do internally.
> >
> > On 9/16/07, Joe Bowbeer wrote:
> > > On 9/16/07, Dhanji R. Prasanna wrote:
> > > >
> > > > I have a map that is read a lot but written to rarely (both
> > operations by
> > > > concurrent threads). Here is what I have:
> > > >
> > > > public class MyMapWrapper {
> > > >
> > > >    private volatile Map map = new WeakHashMap();  //generics implied
> > for
> > > > convenience
> > > >
> > > >    //called concurrently
> > > >    public V get(K k) {
> > > >       return map.get(k);
> > > >    }
> > > >
> > > >    //called concurrently
> > > >    public synchronized void put(K k, V v) {
> > > >          Map copy = new WeakHashMap();
> > > >          copy.putAll(map);
> > > >          copy.put(k, v);
> > > >
> > > >          map = copy;
> > > >    }
> > > > }
> > > >
> > > > My reasoning is that copy-on-write putting needs to be synchronized
> > (atomic
> > > > publications to "map"), and that get() does not need to be
> > synchronized
> > > > because all threads are guaranteed to see a fully constructed map in
> > "map"
> > > > (whether before or after any put). Am I correct in this reasoning?
> > > >
> > >
> > > The volatile provides safe publication of the new map, but there are
> > > no guarantees that map.get() is thread safe, or that the various
> > > hashcode and equals methods it uses are thread safe.
> > >
> > > In the WeakHashMap implementations I've seen, get() may cause stale
> > > entries to be expunged.
> > >
> > > --
> > > Joe Bowbeer
> > >
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070917/bae2bc3d/attachment.html 

From gregg at cytetech.com  Mon Sep 17 13:36:09 2007
From: gregg at cytetech.com (Gregg Wonderly)
Date: Mon, 17 Sep 2007 12:36:09 -0500
Subject: [concurrency-interest] Possible changes to parallel array APIs
In-Reply-To: <46EE7953.8050601@visionnaire.com.br>
References: <46D330B8.3020907@cs.oswego.edu>
	<63b4e4050708271955p47a28860scbd5dfbd83ac560@mail.gmail.com>
	<46D40844.8060906@cs.oswego.edu>	<46D40FA9.70505@cs.oswego.edu>
	<46E53C47.8060005@cs.oswego.edu> <46E5F2CB.5010602@redhat.com>
	<46E67BD1.7070505@cs.oswego.edu> <46E6E8E6.6000605@redhat.com>
	<46ED9456.8040901@cs.oswego.edu>
	<46EE7953.8050601@visionnaire.com.br>
Message-ID: <46EEBB09.9060105@cytetech.com>

Osvaldo Pinali Doederlein wrote:
> Doug Lea escreveu:
> 
>>With 64bits, this interval is about 6billion hrs,
>>which is many orders of magnitude longer than the longest known
>>uptime of any machine.
> 
> Well 6 billion hours is less than 700K years, but the Deep Thought 
> computer will take 7,5 million years to compute the Answer to Life, the 
> Universe and Everything!  :)

If only the inter-galactic highway project wouldn't have killed the mice...

Gregg Wonderly

From hans.boehm at hp.com  Mon Sep 17 16:30:29 2007
From: hans.boehm at hp.com (Boehm, Hans)
Date: Mon, 17 Sep 2007 20:30:29 -0000
Subject: [concurrency-interest] copy on write semantics
In-Reply-To: <aa067ea10709170555i64753266ma888a16066862d8e@mail.gmail.com>
References: <aa067ea10709160226s1eb7b939gd3fdef3d05cf1c7d@mail.gmail.com><31f2a7bd0709160405i35e41126mfe01f4cec0cd71ea@mail.gmail.com><31f2a7bd0709161436x7c107970jb8115c96bece0327@mail.gmail.com>
	<aa067ea10709170555i64753266ma888a16066862d8e@mail.gmail.com>
Message-ID: <BDA38860DCFD334EAEA905E44EE8E7EFF7F393@G3W0067.americas.hpqcorp.net>

In my view, WeakHashMap is (hopefully) an outlier here, and is in
serious need of at least a documentation overhaul.  As I recall, this
has been previously discussed
 
In general, containers should be safe for concurrent access if all
accesses are reads.  If a read access performs an update behind the
scenes, either that needs to be documented or, preferably, the container
should do enough synchronization internally to hide that fact.  It's
certainly common to create a data structure and then have multiple
threads read it.  That can't be allowed to fail.
 
The next C++ standard is likely to contain this rule in a fairly
explicit form.  My assumption has always been that it was the intent for
Java as well, but just hasn't been written down very well, at least not
that I have found.  But I think it's critical to the usability of the
language.
 
Hans


________________________________

	From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Dhanji
R. Prasanna
	Sent: Monday, September 17, 2007 5:56 AM
	To: Joe Bowbeer
	Cc: concurrency-interest
	Subject: Re: [concurrency-interest] copy on write semantics
	
	
	Hi Joe
	
	That's pretty relevant to my use case, thanks for pointing it
out. I'll probably switch to a plain HashMap.
	Regards,
	
	Dhanji.
	
	
	On 9/17/07, Joe Bowbeer <joe.bowbeer at gmail.com> wrote: 

		I think I should restate this point in stronger terms:
		
		In *all* the WeakHashMap implementations I've seen,
get() will expunge
		stale entries.
		
		In other words, the get() method is not thread safe.  In
Java 6, see 
		the private getTable method.
		
		WeakHashMap is probably the worst case here, but I would
consider this
		technique a hack when used with any non-thread-safe
class unless one
		knew precisely how it was implemented.  There's really
no telling what 
		get() might do internally.
		
		On 9/16/07, Joe Bowbeer wrote:
		> On 9/16/07, Dhanji R. Prasanna wrote:
		> >
		> > I have a map that is read a lot but written to
rarely (both operations by
		> > concurrent threads). Here is what I have: 
		> >
		> > public class MyMapWrapper {
		> >
		> >    private volatile Map map = new WeakHashMap();
//generics implied for
		> > convenience
		> >
		> >    //called concurrently 
		> >    public V get(K k) {
		> >       return map.get(k);
		> >    }
		> >
		> >    //called concurrently
		> >    public synchronized void put(K k, V v) {
		> >          Map copy = new WeakHashMap(); 
		> >          copy.putAll(map);
		> >          copy.put(k, v);
		> >
		> >          map = copy;
		> >    }
		> > }
		> >
		> > My reasoning is that copy-on-write putting needs to
be synchronized (atomic 
		> > publications to "map"), and that get() does not need
to be synchronized
		> > because all threads are guaranteed to see a fully
constructed map in "map"
		> > (whether before or after any put). Am I correct in
this reasoning? 
		> >
		>
		> The volatile provides safe publication of the new map,
but there are
		> no guarantees that map.get() is thread safe, or that
the various
		> hashcode and equals methods it uses are thread safe. 
		>
		> In the WeakHashMap implementations I've seen, get()
may cause stale
		> entries to be expunged.
		>
		> --
		> Joe Bowbeer
		>
		


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070917/e919993a/attachment.html 

From joe.bowbeer at gmail.com  Mon Sep 17 17:18:08 2007
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 17 Sep 2007 14:18:08 -0700
Subject: [concurrency-interest] copy on write semantics
In-Reply-To: <BDA38860DCFD334EAEA905E44EE8E7EFF7F393@G3W0067.americas.hpqcorp.net>
References: <aa067ea10709160226s1eb7b939gd3fdef3d05cf1c7d@mail.gmail.com>
	<31f2a7bd0709160405i35e41126mfe01f4cec0cd71ea@mail.gmail.com>
	<31f2a7bd0709161436x7c107970jb8115c96bece0327@mail.gmail.com>
	<aa067ea10709170555i64753266ma888a16066862d8e@mail.gmail.com>
	<BDA38860DCFD334EAEA905E44EE8E7EFF7F393@G3W0067.americas.hpqcorp.net>
Message-ID: <31f2a7bd0709171418h2810ef4ax281b77bcb616a7d2@mail.gmail.com>

I agree that some doc cleanup is in order.

1. LinkedHashMap doc says:

"If multiple threads access a linked hash map concurrently, and at
least one of the threads modifies the map structurally, it must be
synchronized externally."

But it also says "a special constructor is provided to create a linked
hash map whose order of iteration is the order in which its entries
were last accessed".

So the first statement is wrong, right?

2. WeakHashMap only says:

"Like most collection classes, this class is not synchronized."

Not very telling!

3. HashMap says:

"If multiple threads access a hash map concurrently, and at least one
of the threads modifies the map structurally, it must be synchronized
externally."

4. Map makes no guarantees.

--Joe

On 9/17/07, Boehm, Hans <hans.boehm at hp.com> wrote:
>
> In my view, WeakHashMap is (hopefully) an outlier here, and is in serious
> need of at least a documentation overhaul.  As I recall, this has been
> previously discussed
>
> In general, containers should be safe for concurrent access if all accesses
> are reads.  If a read access performs an update behind the scenes, either
> that needs to be documented or, preferably, the container should do enough
> synchronization internally to hide that fact.  It's certainly common to
> create a data structure and then have multiple threads read it.  That can't
> be allowed to fail.
>
> The next C++ standard is likely to contain this rule in a fairly explicit
> form.  My assumption has always been that it was the intent for Java as
> well, but just hasn't been written down very well, at least not that I have
> found.  But I think it's critical to the usability of the language.
>
> Hans
>
>
>  ________________________________
>  From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On
> Behalf Of Dhanji R. Prasanna
> Sent: Monday, September 17, 2007 5:56 AM
> To: Joe Bowbeer
> Cc: concurrency-interest
> Subject: Re: [concurrency-interest] copy on write semantics
>
>
> Hi Joe
>
> That's pretty relevant to my use case, thanks for pointing it out. I'll
> probably switch to a plain HashMap.
> Regards,
>
> Dhanji.
>
>
> On 9/17/07, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> > I think I should restate this point in stronger terms:
> >
> > In *all* the WeakHashMap implementations I've seen, get() will expunge
> > stale entries.
> >
> > In other words, the get() method is not thread safe.  In Java 6, see
> > the private getTable method.
> >
> > WeakHashMap is probably the worst case here, but I would consider this
> > technique a hack when used with any non-thread-safe class unless one
> > knew precisely how it was implemented.  There's really no telling what
> > get() might do internally.
> >
> > On 9/16/07, Joe Bowbeer wrote:
> > > On 9/16/07, Dhanji R. Prasanna wrote:
> > > >
> > > > I have a map that is read a lot but written to rarely (both operations
> by
> > > > concurrent threads). Here is what I have:
> > > >
> > > > public class MyMapWrapper {
> > > >
> > > >    private volatile Map map = new WeakHashMap();  //generics implied
> for
> > > > convenience
> > > >
> > > >    //called concurrently
> > > >    public V get(K k) {
> > > >       return map.get(k);
> > > >    }
> > > >
> > > >    //called concurrently
> > > >    public synchronized void put(K k, V v) {
> > > >          Map copy = new WeakHashMap();
> > > >          copy.putAll(map);
> > > >          copy.put(k, v);
> > > >
> > > >          map = copy;
> > > >    }
> > > > }
> > > >
> > > > My reasoning is that copy-on-write putting needs to be synchronized
> (atomic
> > > > publications to "map"), and that get() does not need to be
> synchronized
> > > > because all threads are guaranteed to see a fully constructed map in
> "map"
> > > > (whether before or after any put). Am I correct in this reasoning?
> > > >
> > >
> > > The volatile provides safe publication of the new map, but there are
> > > no guarantees that map.get() is thread safe, or that the various
> > > hashcode and equals methods it uses are thread safe.
> > >
> > > In the WeakHashMap implementations I've seen, get() may cause stale
> > > entries to be expunged.
> > >
> > > --
> > > Joe Bowbeer
> > >
> >
>
>

From dawid.kurzyniec at gmail.com  Tue Sep 18 06:18:29 2007
From: dawid.kurzyniec at gmail.com (Dawid Kurzyniec)
Date: Tue, 18 Sep 2007 12:18:29 +0200
Subject: [concurrency-interest] Fwd: new home for backport-util-concurrent
In-Reply-To: <3cbaca580709151455u7a738832x5b3a0e7328c4afc4@mail.gmail.com>
References: <3cbaca580709151455u7a738832x5b3a0e7328c4afc4@mail.gmail.com>
Message-ID: <3cbaca580709180318w68a64feam82b3bf1a11f768b@mail.gmail.com>

For some reason, the prev mail did not seem to go through. Resending.

>>

Hi all,

I've moved backport-util-concurrent to SourceForge:

http://backport-jsr166.sourceforge.net/

Main reason for migration is that the old server has been down for
several days, and since I am no longer with Emory University, I can't
fix such problems quickly.

BTW, there's a new release available there, which includes a dedicated
version optimized for 6.0+.

The migration is not complete yet; particularly, the Subversion
repository is still at the old place (thus not currently working).

--
Regards,
Dawid

From Tony.Dean at sas.com  Sun Sep 23 13:53:23 2007
From: Tony.Dean at sas.com (Tony Dean)
Date: Sun, 23 Sep 2007 13:53:23 -0400
Subject: [concurrency-interest] producer-consumer model with synchronousQ
Message-ID: <C3BBBDFBE6D92C4EAA62BBE9793DECCF03401D0C@MERCMBX07.na.sas.com>

Hi,

I'm trying to implement a producer-consumer model where consumer threads
are limited between core threads and max threads.  That is, start with
core threads and grow thread pool to max threads during peak usage and
then release the excess threads (max-core) when usage is no longer
required.  I have this working nicely with ThreadPoolExecutor using
SynchronousQ.  The only pitfall is that since I have a bounded max queue
contraint I have to test whether or not the active thread count will
push me over the limit before trying to execute a new task (if I go over
the max limit, my request will be rejected with
RejectedExecutionException).  (threadPool.getActiveCount() < MAX) test
will work nicely...  The problem I'm trying to solve is how to wait for
this condition.  I thought about adding my own afterExecute() and signal
that an existing thread is becoming free... the problem here is that the
internal ThreadPoolExecutor structures do not set that the thread is
free until after the afterExecute() call so I could actually come off my
wait a tad early.  The other alternatives that I have is to use
Thread.sleep or Thread.yield to wait awhile before retrying the
(threadPool.getActiveCount() < MAX) test condition... but, I'm not sure
how efficient that is.  Any ideas?  Thanks for your time!

Tony Dean
SAS Institute Inc.
919.531.6704
tony.dean at sas.com

SAS... The Power to Know
http://www.sas.com



From alarmnummer at gmail.com  Mon Sep 24 16:02:21 2007
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 24 Sep 2007 22:02:21 +0200
Subject: [concurrency-interest] producer-consumer model with synchronousQ
In-Reply-To: <C3BBBDFBE6D92C4EAA62BBE9793DECCF03401D0C@MERCMBX07.na.sas.com>
References: <C3BBBDFBE6D92C4EAA62BBE9793DECCF03401D0C@MERCMBX07.na.sas.com>
Message-ID: <1466c1d60709241302g27b38bfcm38860b91446c2c1c@mail.gmail.com>

It is a shame that the blocking behaviour was removed from the
executor, because this behaviour is what you want.

What you can do is create a custom rejected execution handler, and
place the runnable on the workqueue yourself. As soon as space gets
available, the job can be placed on the queue and the task eventually
is executed.

You could have a look at the scheduledthreadpoolexecutor to see how it
works. The workqueue also is accessed directly if my memory serves me
right.

On 9/23/07, Tony Dean <Tony.Dean at sas.com> wrote:
> Hi,
>
> I'm trying to implement a producer-consumer model where consumer threads
> are limited between core threads and max threads.  That is, start with
> core threads and grow thread pool to max threads during peak usage and
> then release the excess threads (max-core) when usage is no longer
> required.  I have this working nicely with ThreadPoolExecutor using
> SynchronousQ.  The only pitfall is that since I have a bounded max queue
> contraint I have to test whether or not the active thread count will
> push me over the limit before trying to execute a new task (if I go over
> the max limit, my request will be rejected with
> RejectedExecutionException).  (threadPool.getActiveCount() < MAX) test
> will work nicely...  The problem I'm trying to solve is how to wait for
> this condition.  I thought about adding my own afterExecute() and signal
> that an existing thread is becoming free... the problem here is that the
> internal ThreadPoolExecutor structures do not set that the thread is
> free until after the afterExecute() call so I could actually come off my
> wait a tad early.  The other alternatives that I have is to use
> Thread.sleep or Thread.yield to wait awhile before retrying the
> (threadPool.getActiveCount() < MAX) test condition... but, I'm not sure
> how efficient that is.  Any ideas?  Thanks for your time!
>
> Tony Dean
> SAS Institute Inc.
> 919.531.6704
> tony.dean at sas.com
>
> SAS... The Power to Know
> http://www.sas.com
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From Tony.Dean at sas.com  Mon Sep 24 22:11:26 2007
From: Tony.Dean at sas.com (Tony Dean)
Date: Mon, 24 Sep 2007 22:11:26 -0400
Subject: [concurrency-interest] producer-consumer model with synchronousQ
In-Reply-To: <1466c1d60709241302g27b38bfcm38860b91446c2c1c@mail.gmail.com>
Message-ID: <C3BBBDFBE6D92C4EAA62BBE9793DECCF0340252E@MERCMBX07.na.sas.com>

yes, thanks Peter... I think catching RejectedExecutionException (or
using RejectedExecutionHandler) is just the trick.  When that happens I
just workerQ.put(task) which essentially waits until a thread becomes
available to run this task; thereby, essentially performing the blocking
logic that I wanted.

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu 
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf 
> Of Peter Veentjer
> Sent: Monday, September 24, 2007 4:02 PM
> To: Tony Dean
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] producer-consumer model 
> with synchronousQ
> 
> It is a shame that the blocking behaviour was removed from 
> the executor, because this behaviour is what you want.
> 
> What you can do is create a custom rejected execution 
> handler, and place the runnable on the workqueue yourself. As 
> soon as space gets available, the job can be placed on the 
> queue and the task eventually is executed.
> 
> You could have a look at the scheduledthreadpoolexecutor to 
> see how it works. The workqueue also is accessed directly if 
> my memory serves me right.
> 
> On 9/23/07, Tony Dean <Tony.Dean at sas.com> wrote:
> > Hi,
> >
> > I'm trying to implement a producer-consumer model where consumer 
> > threads are limited between core threads and max threads.  That is, 
> > start with core threads and grow thread pool to max threads during 
> > peak usage and then release the excess threads (max-core) 
> when usage 
> > is no longer required.  I have this working nicely with 
> > ThreadPoolExecutor using SynchronousQ.  The only pitfall is 
> that since 
> > I have a bounded max queue contraint I have to test whether 
> or not the 
> > active thread count will push me over the limit before trying to 
> > execute a new task (if I go over the max limit, my request will be 
> > rejected with RejectedExecutionException).  
> > (threadPool.getActiveCount() < MAX) test will work nicely...  The 
> > problem I'm trying to solve is how to wait for this condition.  I 
> > thought about adding my own afterExecute() and signal that 
> an existing 
> > thread is becoming free... the problem here is that the internal 
> > ThreadPoolExecutor structures do not set that the thread is 
> free until 
> > after the afterExecute() call so I could actually come off 
> my wait a 
> > tad early.  The other alternatives that I have is to use 
> Thread.sleep 
> > or Thread.yield to wait awhile before retrying the
> > (threadPool.getActiveCount() < MAX) test condition... but, I'm not 
> > sure how efficient that is.  Any ideas?  Thanks for your time!
> >
> > Tony Dean
> > SAS Institute Inc.
> > 919.531.6704
> > tony.dean at sas.com
> >
> > SAS... The Power to Know
> > http://www.sas.com
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From elihusmails at gmail.com  Tue Sep 25 09:19:52 2007
From: elihusmails at gmail.com (Mark)
Date: Tue, 25 Sep 2007 09:19:52 -0400
Subject: [concurrency-interest] [OT] Java NIO mailing list
Message-ID: <9f066ee90709250619m730a0b0dle95ee2a85e9f2422@mail.gmail.com>

I am interested to find out if there is a Java NIO (or NIO2) mailing list.
For much of the work that I do, concurrency and I/O go hand-in-hand and
would like to join in on a mailing list that was NIO based.  If anyone knows
where I can sign up for one, please let me know.

Thank you.

-- 
..Cheers
Mark
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070925/af621a37/attachment.html 

From matthias at mernst.org  Tue Sep 25 09:36:58 2007
From: matthias at mernst.org (Matthias Ernst)
Date: Tue, 25 Sep 2007 15:36:58 +0200
Subject: [concurrency-interest] [OT] Java NIO mailing list
In-Reply-To: <9f066ee90709250619m730a0b0dle95ee2a85e9f2422@mail.gmail.com>
References: <9f066ee90709250619m730a0b0dle95ee2a85e9f2422@mail.gmail.com>
Message-ID: <22ec15240709250636n17ae6e98s2751a49b4bae0ed7@mail.gmail.com>

Check out http://groups.google.com/group/jsr203-interest. Alan Bateman
usually hangs out there.

Matthias

On 9/25/07, Mark <elihusmails at gmail.com> wrote:
> I am interested to find out if there is a Java NIO (or NIO2) mailing list.
> For much of the work that I do, concurrency and I/O go hand-in-hand and
> would like to join in on a mailing list that was NIO based.  If anyone knows
> where I can sign up for one, please let me know.

