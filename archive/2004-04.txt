From ziba@summa-tech.com  Mon Apr  5 15:45:52 2004
From: ziba@summa-tech.com (Eduardo Issao Ito)
Date: Mon, 05 Apr 2004 11:45:52 -0300
Subject: [concurrency-interest] PooledExecutor question
Message-ID: <40717120.2030604@summa-tech.com>

I've a question about the behavior of class 
EDU.oswego.cs.dl.util.concurrent.PooledExecutor when used with a Channel.

The javadoc says that after getMinimumPoolSize threads running, new commands 
will be put in the queue. So actually getMaximumPoolSize will never be reached, 
am I correct? Or there is some situation when new threads are added beyond 
getMinimumPoolSize?


From matthias.ernst@coremedia.com  Mon Apr  5 17:54:28 2004
From: matthias.ernst@coremedia.com (matthias.ernst@coremedia.com)
Date: Mon, 5 Apr 2004 18:54:28 +0200 (CEST)
Subject: [concurrency-interest] PooledExecutor question
In-Reply-To: <40717120.2030604@summa-tech.com>
Message-ID: <Pine.LNX.4.33.0404051849300.1555-100000@bebop.coremedia.com>

On Mon, 5 Apr 2004, Eduardo Issao Ito wrote:

> I've a question about the behavior of class
> EDU.oswego.cs.dl.util.concurrent.PooledExecutor when used with a Channel.
>
> The javadoc says that after getMinimumPoolSize threads running, new commands
> will be put in the queue. So actually getMaximumPoolSize will never be reached,
> am I correct? Or there is some situation when new threads are added beyond
> getMinimumPoolSize?

That depends on the channel. PooledExecutor will #offer the job to the
channel - if it accepts, no new thread will be added. Otherwise a new
thread will be added (up to maxThreads).

Thus, with a never-blocking, always-accepting channel such as a
LinkedQueue, you're right, no threads beyond minimumPoolSize will be
added.

Matthias
-- 
Matthias Ernst
CoreMedia - The Content Technology Experts

"Toll takes its time."


From jasper@jasperpotts.com  Thu Apr 15 11:21:29 2004
From: jasper@jasperpotts.com (Jasper Potts)
Date: Thu, 15 Apr 2004 11:21:29 +0100
Subject: [concurrency-interest] Porting Latch to 1.5
Message-ID: <006101c422d3$6f556dd0$6e05a8c0@canon>

This is a multi-part message in MIME format.

------=_NextPart_000_005E_01C422DB.CC4458F0
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

I have a image cache that had a image fetching thread that is loading =
requested images. There is a method getImage(id) that is called by =
another thread to get an image, it needs to block till the image is =
available. I was implementing this with a Map of Latches keyed by the =
image id. A Latch was added to the map when an image is requested that =
is not available and released and removed when it has been loaded.

What would the best way to achive this using the 1.5 =
java.util.concurrent and will I be ok with beta 1 or will I need the =
latest JSr166 jar file.

Many Thanks

Jasper Potts
------=_NextPart_000_005E_01C422DB.CC4458F0
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.2800.1400" name=3DGENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=3D#ffffff>
<DIV><FONT face=3DArial size=3D2>I have a image cache that had a image =
fetching=20
thread that is loading requested images. There is a method getImage(id) =
that is=20
called by another thread to get an image, it needs to block till the =
image is=20
available. I was implementing this with a Map of Latches keyed by the =
image id.=20
A Latch was added to the map when an image is requested that is not =
available=20
and released and removed when it has been loaded.</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>What would the best way to achive this =
using the=20
1.5 java.util.concurrent and will I be ok with beta 1 or will I need the =
latest=20
JSr166 jar file.</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>Many Thanks</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>Jasper Potts</FONT></DIV></BODY></HTML>

------=_NextPart_000_005E_01C422DB.CC4458F0--


From tim@peierls.net  Thu Apr 15 13:01:36 2004
From: tim@peierls.net (Tim Peierls)
Date: Thu, 15 Apr 2004 08:01:36 -0400
Subject: [concurrency-interest] Porting Latch to 1.5
In-Reply-To: <006101c422d3$6f556dd0$6e05a8c0@canon>
References: <006101c422d3$6f556dd0$6e05a8c0@canon>
Message-ID: <407E79A0.1090609@peierls.net>

Jasper Potts wrote:
> I have a image cache that had a image fetching thread that is loading 
> requested images. There is a method getImage(id) that is called by 
> another thread to get an image, it needs to block till the image is 
> available. I was implementing this with a Map of Latches keyed by the 
> image id. A Latch was added to the map when an image is requested that 
> is not available and released and removed when it has been loaded.
>  
> What would the best way to achive this using the 1.5 java.util.concurrent? 


Use Executors/Futures for this sort of thing:

   Image getImage(final String id) {
       try {
           return threadPool.submit(new Callable<Image>() {
               public Image call() { return blockingGetImage(id); }
           }).get();
       } catch (Exception e) { return null; } // IE, ExecutionException
   }
   private final ExecutorService threadPool =
       Executors.newCachedThreadPool();


Use a variant of the "memo-ize" technique if you need subsequent
calls to getImage(id) to return the cached Image:

   interface Function<A, V> {
       V call(A arg);
   }

   class MemoizedFunction<A, V> implements Function<A, V> {
       MemoizedFunction(Function<A, V> function, Executor executor) {
           this.function = function;
           this.executor = executor;
       }
       public V call(final A arg) {
           try {
               Future<V> future = cache.get(arg);
               if (future != null) return future.get();

               Callable<V> functionCall = new Callable<V>() {
                   public V call() { return function.call(arg); }
               };
               FutureTask<V> task = new FutureTask<V>(functionCall);
               future = cache.putIfAbsent(arg, task);
               if (future == null) {
                   future = task;
                   executor.execute(task);
               }
               return future.get();
           } catch (Exception e) { return null; }
       }
       private final Function<A, V> function;
       private final Executor executor;
       private final ConcurrentMap<A, Future<V>> cache =
           new ConcurrentHashMap<A, Future<V>>();
   }

   private final ExecutorService threadPool =
       Executors.newCachedThreadPool();

   private final Function<String, Image> blockingGetImageFunc =
       new Function<String, Image>() {
           public Image call(String id) { return blockingGetImage(id); }
       };

   private final Function<String, Image> getImageFunc =
       new MemoizedFunction<String, Image>(blockingGetImageFunc, threadPool);

   Image getImage(String id) {
       return getImageFunc.call(id);
   }


> and will I be ok with beta 1 or will I need the latest JSr166 jar file.

Depends on which platform you are using. For Windows, beta 1 may not
work, even with the latest jsr166 jar, but beta 2 will. For other
supported platforms, beta 1 should be OK as is.

--tim


From tim@peierls.net  Thu Apr 15 16:05:07 2004
From: tim@peierls.net (Tim Peierls)
Date: Thu, 15 Apr 2004 11:05:07 -0400
Subject: [concurrency-interest] Porting Latch to 1.5
In-Reply-To: <407E79A0.1090609@peierls.net>
References: <006101c422d3$6f556dd0$6e05a8c0@canon> <407E79A0.1090609@peierls.net>
Message-ID: <407EA4A3.402@peierls.net>

Three clarifications, one omission, and one (long) further thought:

1. (clarification) I should have mentioned that there is a
    CountDownLatch class in 1.5 j.u.c that is similar to
    dl.u.c CountDown; when constructed with an argument
    of 1, it behaves just like a dl.u.c Latch. You don't
    need it in this case, but it exists.

2. (clarification) The first part of my response begs your
    question; it only serves to introduce the second part.

3. (clarification) It is possible to propagate checked
    exceptions instead of just returning null when
    blockingGetImage(id) throws, say, IOException, but I
    wanted to simplify the presentation.

4. (omission) There needs to be a way to prefetch images
    without blocking:

   void prefetchImage(String id) {
       threadPool.execute(new Runnable() {
           public void run() { getImage(id); }
       }
   }

5. (further thought) Here's a sample usage, which assumes
   that this functionality is provided by class ImageCache:

   Collection<String> imageIds = ...;
   for (String id : imageIds) imageCache.prefetchImage(id);
   ... do other stuff ...
   for (String id : imageIds) render(imageCache.getImage(id));

A problem with this is that the images may be ready in a
different order than the one given by the imageIds iteration.
To get them in the order that they become ready, use a
CompletionService:

   interface ImageHandler {
       void handleImage(Image image);
   }

   void getImages(final Collection<String> imageIds,
                  long timeout, TimeUnit unit,
                  ImageHandler handler) {

       final CompletionService<Image> completion =
           new ExecutorCompletionService<Image>(threadPool);
       int n = 0;
       for (final String id : imageIds) {
           completion.submit(new Callable<Image>() {
               public Image call() { return getImage(id); }
           });
           ++n;
       }

       for (int i = 0; i < n; ++i)
           try {
               Future<Image> future = completion.poll(timeout, unit);
               if (future == null) return;
               handler.handleImage(future.get());
           }
           catch (InterruptedException e) { return; }
           catch (ExecutionException e) { continue; }
   }

Sample usage:

   Collection<String> imageIds = ...;
   imageCache.getImages(imageIds, timeout, unit, new ImageHandler() {
       public void handleImage(Image image) { render(image); }
   });


--tim

Tim Peierls wrote:
> Jasper Potts wrote:
> 
>> I have a image cache that had a image fetching thread that is loading 
>> requested images. There is a method getImage(id) that is called by 
>> another thread to get an image, it needs to block till the image is 
>> available. I was implementing this with a Map of Latches keyed by the 
>> image id. A Latch was added to the map when an image is requested that 
>> is not available and released and removed when it has been loaded.
>>  
>> What would the best way to achive this using the 1.5 
>> java.util.concurrent? 
> 
> 
> 
> Use Executors/Futures for this sort of thing:
> 
>   Image getImage(final String id) {
>       try {
>           return threadPool.submit(new Callable<Image>() {
>               public Image call() { return blockingGetImage(id); }
>           }).get();
>       } catch (Exception e) { return null; } // IE, ExecutionException
>   }
>   private final ExecutorService threadPool =
>       Executors.newCachedThreadPool();
> 
> 
> Use a variant of the "memo-ize" technique if you need subsequent
> calls to getImage(id) to return the cached Image:
> 
>   interface Function<A, V> {
>       V call(A arg);
>   }
> 
>   class MemoizedFunction<A, V> implements Function<A, V> {
>       MemoizedFunction(Function<A, V> function, Executor executor) {
>           this.function = function;
>           this.executor = executor;
>       }
>       public V call(final A arg) {
>           try {
>               Future<V> future = cache.get(arg);
>               if (future != null) return future.get();
> 
>               Callable<V> functionCall = new Callable<V>() {
>                   public V call() { return function.call(arg); }
>               };
>               FutureTask<V> task = new FutureTask<V>(functionCall);
>               future = cache.putIfAbsent(arg, task);
>               if (future == null) {
>                   future = task;
>                   executor.execute(task);
>               }
>               return future.get();
>           } catch (Exception e) { return null; }
>       }
>       private final Function<A, V> function;
>       private final Executor executor;
>       private final ConcurrentMap<A, Future<V>> cache =
>           new ConcurrentHashMap<A, Future<V>>();
>   }
> 
>   private final ExecutorService threadPool =
>       Executors.newCachedThreadPool();
> 
>   private final Function<String, Image> blockingGetImageFunc =
>       new Function<String, Image>() {
>           public Image call(String id) { return blockingGetImage(id); }
>       };
> 
>   private final Function<String, Image> getImageFunc =
>       new MemoizedFunction<String, Image>(blockingGetImageFunc, 
> threadPool);
> 
>   Image getImage(String id) {
>       return getImageFunc.call(id);
>   }
> 
> 
>> and will I be ok with beta 1 or will I need the latest JSr166 jar file.
> 
> 
> Depends on which platform you are using. For Windows, beta 1 may not
> work, even with the latest jsr166 jar, but beta 2 will. For other
> supported platforms, beta 1 should be OK as is.
> 
> --tim
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 



From jasper@jasperpotts.com  Thu Apr 15 17:27:41 2004
From: jasper@jasperpotts.com (Jasper Potts)
Date: Thu, 15 Apr 2004 17:27:41 +0100
Subject: [concurrency-interest] Porting Latch to 1.5
References: <006101c422d3$6f556dd0$6e05a8c0@canon> <407E79A0.1090609@peierls.net> <407EA4A3.402@peierls.net>
Message-ID: <008c01c42306$95de5b50$6e05a8c0@canon>

Thank you; That is very helpful, it covers most of what I am trying to do in
a more elegant way than I have done it. There is one more part to what I am
trying to do that I didn't mention in the first email to simplify things,
but I am not sure how you could fit it in with this solution. I want to have
control over the queuing of images to load. So that images that are not
currently visible but are likely to be visible in the near future can be
added to the queue with a low priority. Also requests can be removed from
the queue if they become unneeded before they get to being loaded: eg. when
scrolling quickly the images may not get loaded before the view are moves on
and a new set of images are required.

The way I saw of controlling the queuing is providing a custom
implementation of BlockingQueue to ThreadPoolExecutor. Is there a better
way?

What I am trying to do is implement a file browser scrollable panel that
shows thumbnails for all the image files it understands. The problem is Java
is quite slow loading and scaling images for the thumbnails and I may not
have enough memory to load all the images. So I am trying to create a
SoftLink cache with a background thread loading and processing the
thumbnail, trying to keep up with the users view.

Many Thanks

Jasper Potts


----- Original Message ----- 
From: "Tim Peierls" <tim@peierls.net>
To: "Jasper Potts" <jasper@jasperpotts.com>
Cc: <concurrency-interest@altair.cs.oswego.edu>
Sent: Thursday, April 15, 2004 4:05 PM
Subject: Re: [concurrency-interest] Porting Latch to 1.5


> Three clarifications, one omission, and one (long) further thought:
>
> 1. (clarification) I should have mentioned that there is a
>     CountDownLatch class in 1.5 j.u.c that is similar to
>     dl.u.c CountDown; when constructed with an argument
>     of 1, it behaves just like a dl.u.c Latch. You don't
>     need it in this case, but it exists.
>
> 2. (clarification) The first part of my response begs your
>     question; it only serves to introduce the second part.
>
> 3. (clarification) It is possible to propagate checked
>     exceptions instead of just returning null when
>     blockingGetImage(id) throws, say, IOException, but I
>     wanted to simplify the presentation.
>
> 4. (omission) There needs to be a way to prefetch images
>     without blocking:
>
>    void prefetchImage(String id) {
>        threadPool.execute(new Runnable() {
>            public void run() { getImage(id); }
>        }
>    }
>
> 5. (further thought) Here's a sample usage, which assumes
>    that this functionality is provided by class ImageCache:
>
>    Collection<String> imageIds = ...;
>    for (String id : imageIds) imageCache.prefetchImage(id);
>    ... do other stuff ...
>    for (String id : imageIds) render(imageCache.getImage(id));
>
> A problem with this is that the images may be ready in a
> different order than the one given by the imageIds iteration.
> To get them in the order that they become ready, use a
> CompletionService:
>
>    interface ImageHandler {
>        void handleImage(Image image);
>    }
>
>    void getImages(final Collection<String> imageIds,
>                   long timeout, TimeUnit unit,
>                   ImageHandler handler) {
>
>        final CompletionService<Image> completion =
>            new ExecutorCompletionService<Image>(threadPool);
>        int n = 0;
>        for (final String id : imageIds) {
>            completion.submit(new Callable<Image>() {
>                public Image call() { return getImage(id); }
>            });
>            ++n;
>        }
>
>        for (int i = 0; i < n; ++i)
>            try {
>                Future<Image> future = completion.poll(timeout, unit);
>                if (future == null) return;
>                handler.handleImage(future.get());
>            }
>            catch (InterruptedException e) { return; }
>            catch (ExecutionException e) { continue; }
>    }
>
> Sample usage:
>
>    Collection<String> imageIds = ...;
>    imageCache.getImages(imageIds, timeout, unit, new ImageHandler() {
>        public void handleImage(Image image) { render(image); }
>    });
>
>
> --tim
>
> Tim Peierls wrote:
> > Jasper Potts wrote:
> >
> >> I have a image cache that had a image fetching thread that is loading
> >> requested images. There is a method getImage(id) that is called by
> >> another thread to get an image, it needs to block till the image is
> >> available. I was implementing this with a Map of Latches keyed by the
> >> image id. A Latch was added to the map when an image is requested that
> >> is not available and released and removed when it has been loaded.
> >>
> >> What would the best way to achive this using the 1.5
> >> java.util.concurrent?
> >
> >
> >
> > Use Executors/Futures for this sort of thing:
> >
> >   Image getImage(final String id) {
> >       try {
> >           return threadPool.submit(new Callable<Image>() {
> >               public Image call() { return blockingGetImage(id); }
> >           }).get();
> >       } catch (Exception e) { return null; } // IE, ExecutionException
> >   }
> >   private final ExecutorService threadPool =
> >       Executors.newCachedThreadPool();
> >
> >
> > Use a variant of the "memo-ize" technique if you need subsequent
> > calls to getImage(id) to return the cached Image:
> >
> >   interface Function<A, V> {
> >       V call(A arg);
> >   }
> >
> >   class MemoizedFunction<A, V> implements Function<A, V> {
> >       MemoizedFunction(Function<A, V> function, Executor executor) {
> >           this.function = function;
> >           this.executor = executor;
> >       }
> >       public V call(final A arg) {
> >           try {
> >               Future<V> future = cache.get(arg);
> >               if (future != null) return future.get();
> >
> >               Callable<V> functionCall = new Callable<V>() {
> >                   public V call() { return function.call(arg); }
> >               };
> >               FutureTask<V> task = new FutureTask<V>(functionCall);
> >               future = cache.putIfAbsent(arg, task);
> >               if (future == null) {
> >                   future = task;
> >                   executor.execute(task);
> >               }
> >               return future.get();
> >           } catch (Exception e) { return null; }
> >       }
> >       private final Function<A, V> function;
> >       private final Executor executor;
> >       private final ConcurrentMap<A, Future<V>> cache =
> >           new ConcurrentHashMap<A, Future<V>>();
> >   }
> >
> >   private final ExecutorService threadPool =
> >       Executors.newCachedThreadPool();
> >
> >   private final Function<String, Image> blockingGetImageFunc =
> >       new Function<String, Image>() {
> >           public Image call(String id) { return blockingGetImage(id); }
> >       };
> >
> >   private final Function<String, Image> getImageFunc =
> >       new MemoizedFunction<String, Image>(blockingGetImageFunc,
> > threadPool);
> >
> >   Image getImage(String id) {
> >       return getImageFunc.call(id);
> >   }
> >
> >
> >> and will I be ok with beta 1 or will I need the latest JSr166 jar file.
> >
> >
> > Depends on which platform you are using. For Windows, beta 1 may not
> > work, even with the latest jsr166 jar, but beta 2 will. For other
> > supported platforms, beta 1 should be OK as is.
> >
> > --tim
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest@altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
>


From tim@peierls.net  Fri Apr 16 17:52:38 2004
From: tim@peierls.net (Tim Peierls)
Date: Fri, 16 Apr 2004 12:52:38 -0400
Subject: [concurrency-interest] Porting Latch to 1.5
In-Reply-To: <008c01c42306$95de5b50$6e05a8c0@canon>
References: <006101c422d3$6f556dd0$6e05a8c0@canon> <407E79A0.1090609@peierls.net> <407EA4A3.402@peierls.net> <008c01c42306$95de5b50$6e05a8c0@canon>
Message-ID: <40800F56.5000705@peierls.net>

Jasper Potts wrote:
> I want to have control over the queuing of images to load. So that
> images that are not currently visible but are likely to be visible
> in the near future can be added to the queue with a low priority.
> ...
> The way I saw of controlling the queuing is providing a custom
> implementation of BlockingQueue to ThreadPoolExecutor. 

You can control the queue that runs tasks, but once the task is
dequeued and running, there's no easy way to lower its priority.

However, if you run your loading tasks in a single thread, then the
order that you ask for the images will be the order that they are loaded.

Ask for onscreen images first, then offscreen-but-likely-to-be-onscreen
images. In this case, the CompletionService approach is unnecessary,
since completion order == submission order.

If this is what you want, just change Executors.newCachedThreadPool()
to Executors.newSingleThreadExecutor() in the code I posted yesterday,
and don't use the CompletionService stuff.


> Also requests can be removed from the queue if they become unneeded before
> they get to being loaded: eg. when scrolling quickly the images may not get
> loaded before the view are moves on and a new set of images are required.

That's easy enough: Futures are cancellable, so all you need is a method
that takes an id and cancels the Future associated with that id. (The code
that actually loads images needs to check for interrupts periodically for
this to work.)


I think there's a useful framework hovering around this problem, and
I started to work on it yesterday, but will have to put it off for a
while. I'll post again if/when I have something usable.

--tim


From Satish Duggana" <satish@pramati.com  Mon Apr 19 11:01:57 2004
From: Satish Duggana" <satish@pramati.com (Satish Duggana)
Date: Mon, 19 Apr 2004 15:31:57 +0530
Subject: [concurrency-interest] Why do we need to take a lock before invoking wait()/notify() on an Object??
Message-ID: <001601c425f5$5a150a00$6201a8c0@SATISHDUGGANA>

This is a multi-part message in MIME format.

------=_NextPart_000_0013_01C42623.73AD3AE0
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Hi,

Why do we need to take a lock before invoking wait()/notify() on an =
Object? i know that we shud take otherwise illegalstateexception is =
thrown.

what is the reason to take a lock bfefore invoking the above methods. =
why does jvm expects from the programmer?

if my requirement is such that i don't want to synchronize on =
wait/notify, then why java semantics forces me to synchronize?=20

Cheers,
Sato.
Phone: (off) +91- 40-23411672 Xtn 635
            (h)   +91- 9885147885




------=_NextPart_000_0013_01C42623.73AD3AE0
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.2800.1106" name=3DGENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=3D#ffffff>
<DIV><FONT face=3DArial size=3D2><!--StartFragment --><FONT =
size=3D-1>Hi,<BR><BR>Why=20
do we need to take a lock before invoking wait()/notify() on an Object? =
i know=20
that we shud take otherwise illegalstateexception is thrown.<BR><BR>what =
is the=20
reason to take a lock bfefore invoking the above methods. why does jvm =
expects=20
from the programmer?</FONT></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><FONT =
size=3D-1></FONT></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><FONT size=3D-1>if my requirement is =
such that i=20
don't want to&nbsp;synchronize on wait/notify, then why java semantics =
forces me=20
to synchronize? </FONT></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><FONT size=3D-1><BR></FONT></FONT><FONT =
face=3DArial=20
size=3D2>Cheers,<BR>Sato.<BR>Phone: (off) +91- 40-23411672 Xtn=20
635<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
=20
(h)&nbsp;&nbsp; +91- 9885147885</DIV>
<DIV>&nbsp;</DIV>
<DIV>&nbsp;</DIV>
<DIV>&nbsp;</DIV>
<DIV></FONT>&nbsp;</DIV></BODY></HTML>

------=_NextPart_000_0013_01C42623.73AD3AE0--



From Satish Duggana" <satish@pramati.com  Mon Apr 19 11:25:09 2004
From: Satish Duggana" <satish@pramati.com (Satish Duggana)
Date: Mon, 19 Apr 2004 15:55:09 +0530
Subject: [concurrency-interest] srcs of concurrent package...
Message-ID: <002701c425f8$97922130$6201a8c0@SATISHDUGGANA>

This is a multi-part message in MIME format.

------=_NextPart_000_0024_01C42626.B142BC10
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Hi,

How can i get concurrent package sources?

Cheers,
Sato.
Phone: (off) +91- 40-23411672 Xtn 635
            (h)   +91- 9885147885




------=_NextPart_000_0024_01C42626.B142BC10
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.2800.1106" name=3DGENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=3D#ffffff>
<DIV><FONT face=3DArial size=3D2>Hi,</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>How can i get concurrent package=20
sources?</FONT></DIV><FONT face=3DArial size=3D2>
<DIV><BR>Cheers,<BR>Sato.<BR>Phone: (off) +91- 40-23411672 Xtn=20
635<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
=20
(h)&nbsp;&nbsp; +91- 9885147885</DIV>
<DIV>&nbsp;</DIV>
<DIV>&nbsp;</DIV>
<DIV>&nbsp;</DIV>
<DIV></FONT>&nbsp;</DIV></BODY></HTML>

------=_NextPart_000_0024_01C42626.B142BC10--



From mwh@cs.umd.edu  Mon Apr 19 12:40:49 2004
From: mwh@cs.umd.edu (Michael Hicks)
Date: 19 Apr 2004 07:40:49 -0400
Subject: [concurrency-interest] Why do we need to take a lock before
 invoking wait()/notify() on an Object??
In-Reply-To: <001601c425f5$5a150a00$6201a8c0@SATISHDUGGANA>
References: <001601c425f5$5a150a00$6201a8c0@SATISHDUGGANA>
Message-ID: <1082374849.3582.5.camel@mwhlaptop.cs.umd.edu>

On Mon, 2004-04-19 at 06:01, Satish Duggana wrote:
> Why do we need to take a lock before invoking wait()/notify() on an
> Object? i know that we shud take otherwise illegalstateexception is
> thrown.

Conceptually, each object has associated with it a "wait list" of all of
the threads waiting on that object.  When a thread calls o.wait(), it is
added to o's wait list and no longer runnable.  Similarly, when some
thread calls o.notify(), another thread is removed from o's wait list
and made runnable once again.

This wait list is a shared datastructure---different threads are adding
and removing elements from it---and therefore must be synchronized to
avoid data corruption.

Mike


From Satish Duggana" <satish@pramati.com  Mon Apr 19 12:50:28 2004
From: Satish Duggana" <satish@pramati.com (Satish Duggana)
Date: Mon, 19 Apr 2004 17:20:28 +0530
Subject: [concurrency-interest] Why do we need to take a lock beforeinvoking wait()/notify() on an Object??
References: <001601c425f5$5a150a00$6201a8c0@SATISHDUGGANA> <1082374849.3582.5.camel@mwhlaptop.cs.umd.edu>
Message-ID: <000c01c42604$824f3450$6201a8c0@SATISHDUGGANA>

Hi Mike,
Thanks. I think, if  wait list to be synchronized then it can be done by jvm
only why a programmer should lock the object for vm, vm can take a lock on
waitset before adding/removing it to wait set,
i am trying to understand the semantics.

Cheers,
Sato.
Phone: (off) +91- 40-23411672 Xtn 635
            (h)   +91- 9885147885




----- Original Message -----
From: "Michael Hicks" <mwh@cs.umd.edu>
To: "Satish Duggana" <satish@pramati.com>
Cc: <concurrency-interest@altair.cs.oswego.edu>
Sent: Monday, April 19, 2004 5:10 PM
Subject: Re: [concurrency-interest] Why do we need to take a lock
beforeinvoking wait()/notify() on an Object??


> On Mon, 2004-04-19 at 06:01, Satish Duggana wrote:
> > Why do we need to take a lock before invoking wait()/notify() on an
> > Object? i know that we shud take otherwise illegalstateexception is
> > thrown.
>
> Conceptually, each object has associated with it a "wait list" of all of
> the threads waiting on that object.  When a thread calls o.wait(), it is
> added to o's wait list and no longer runnable.  Similarly, when some
> thread calls o.notify(), another thread is removed from o's wait list
> and made runnable once again.
>
> This wait list is a shared datastructure---different threads are adding
> and removing elements from it---and therefore must be synchronized to
> avoid data corruption.
>
> Mike
>
>



From mwh@cs.umd.edu  Mon Apr 19 13:57:08 2004
From: mwh@cs.umd.edu (Michael Hicks)
Date: 19 Apr 2004 08:57:08 -0400
Subject: [concurrency-interest] Why do we need to take a lock
 beforeinvoking wait()/notify() on an Object??
In-Reply-To: <000c01c42604$824f3450$6201a8c0@SATISHDUGGANA>
References: <001601c425f5$5a150a00$6201a8c0@SATISHDUGGANA>
 <1082374849.3582.5.camel@mwhlaptop.cs.umd.edu>
 <000c01c42604$824f3450$6201a8c0@SATISHDUGGANA>
Message-ID: <1082379427.3542.6.camel@mwhlaptop.cs.umd.edu>

> Thanks. I think, if  wait list to be synchronized then it can be done by jvm
> only why a programmer should lock the object for vm, vm can take a lock on
> waitset before adding/removing it to wait set,
> i am trying to understand the semantics.

Calls to wait() MUST be synchronized for the reason I mentioned before.
However, calls to wait() TYPICALLY fall within another synchronized
block within which you want the lock to be held after the thread is
notified:

synchronized (o) {
  ...
  while (condition does not hold) {
    o.wait();
  }
  do something here
}

This is because checking that the condition is true and acting on it
frequently must be atomic.  The semantics of the JVM support and
encourage programmers to use this idiom.  The semantics you suggest
would likely lead novices to subtle bugs.

Others may have other (better) reasons that I'm not thinking of offhand.

Mike


From eamonn.mcmanus@sun.com  Mon Apr 19 14:36:17 2004
From: eamonn.mcmanus@sun.com (Eamonn McManus)
Date: Mon, 19 Apr 2004 15:36:17 +0200
Subject: [concurrency-interest] Why do we need to take a lock before	invoking
 wait()/notify() on an Object??
In-Reply-To: <1082374849.3582.5.camel@mwhlaptop.cs.umd.edu>
References: <001601c425f5$5a150a00$6201a8c0@SATISHDUGGANA> <1082374849.3582.5.camel@mwhlaptop.cs.umd.edu>
Message-ID: <4083D5D1.3010406@sun.com>

Michael Hicks wrote:
> On Mon, 2004-04-19 at 06:01, Satish Duggana wrote:
> 
>>Why do we need to take a lock before invoking wait()/notify() on an
>>Object? i know that we shud take otherwise illegalstateexception is
>>thrown.
> 
> 
> Conceptually, each object has associated with it a "wait list" of all of
> the threads waiting on that object.  When a thread calls o.wait(), it is
> added to o's wait list and no longer runnable.  Similarly, when some
> thread calls o.notify(), another thread is removed from o's wait list
> and made runnable once again.
> 
> This wait list is a shared datastructure---different threads are adding
> and removing elements from it---and therefore must be synchronized to
> avoid data corruption.

I wouldn't have seen that as the main reason.  If that were the only 
concern, then it would be sufficient for the implementations of 
Object.wait and Object.notify to be synchronized.  Users wouldn't have 
to bothered with that.

What's more important is the way these are typically used:

Waiter:
     while (!someCondition())
         wait();

Notifier:
     ...make someCondition() true...
     notify();

If the waiter were not synchronized, then between the moment it checks 
someCondition() and the moment it wait()s, the condition could become 
true.  Worse, after someCondition() becoming true, the notifier could 
have already called notify(), and the waiter would wait forever.  The 
wait/notify mechanism doesn't remember notify calls -- if nobody is 
waiting when notify() is called, the notify() is lost forever.

Similarly, if the notifier were not synchronized, there would be little 
point in the waiter being synchronized, because the notify() could still 
be lost before the wait() starts.

The key point here is the interaction between wait() and the 
synchronized mechanism.  When you call wait() you do two things at once: 
release the lock on the object, and wait.  There is no possibility for a 
notify() to arrive between those two things.

Regards,
-- 
Éamonn


From brian@quiotix.com  Mon Apr 19 23:29:17 2004
From: brian@quiotix.com (Brian Goetz)
Date: Mon, 19 Apr 2004 15:29:17 -0700
Subject: [concurrency-interest] Why do we need to take a lock
 before invoking wait()/notify() on an Object??
In-Reply-To: <001601c425f5$5a150a00$6201a8c0@SATISHDUGGANA>
References: <001601c425f5$5a150a00$6201a8c0@SATISHDUGGANA>
Message-ID: <6.0.3.0.2.20040419151748.0290cd20@pop.quiotix.com>

>Why do we need to take a lock before invoking wait()/notify() on an 
>Object? i know that we shud take otherwise illegalstateexception is thrown.
>
>what is the reason to take a lock bfefore invoking the above methods. why 
>does jvm expects from the programmer?
>
>if my requirement is such that i don't want to synchronize on wait/notify, 
>then why java semantics forces me to synchronize?

The short answer is "you just do."  But if you're asking this question, it 
is almost certainly the case that what you want is not wait/notify (which 
are low-level and very easy to use incorrectly), but instead use a 
higher-level synchronization tool, such as Semaphore, CyclicBarrier, 
Exchanger, or CountdownLatch.  If you post your use case I'm sure someone 
here can suggest a better, easier, more maintainable solution using either 
u.c or j.u.c.

The longer answer: wait/notify is more than simply a signalling 
mechanism.  It is a scheduling mechanism as well -- it gives you a means of 
saying to the scheduler, "when this condition becomes true (because someone 
called notify()), place these threads back in the runnable state."  Without 
using synchronization around wait/notify, there are numerous possible race 
conditions implicit in nearly all anticipated use cases.  You want to 
guarantee that between the time that thread T is chosen to be awakened due 
to notify() and the time it actually accesses the shared resource, that the 
condition is still true.  In order to do so, the lock granting needs to be 
part of the wakeup, and in order to do that, you need to hold the lock when 
calling wait().



--
Brian Goetz
Quiotix Corporation
brian@quiotix.com           Tel: 650-843-1300            Fax: 650-324-8032

http://www.quiotix.com



From larryr@saturn.sdsu.edu  Tue Apr 20 01:31:14 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 20 Apr 2004 00:31:14 -0000
Subject: [concurrency-interest] Re: Why do we need to take a lock before invoking wait()/notify() on an Object??
In-Reply-To: <001601c425f5$5a150a00$6201a8c0@SATISHDUGGANA>
Message-ID: <20040420003114.24037.qmail@home19.riedel.org>


> Why do we need to take a lock before invoking
> wait()/notify() on an Object?

Maybe because we /should/ want to.  I feel a paternalistic
theme in the Java language/APIs-- you should want to do
this, therefore it is required, or, you should not want to
do this, therefore it is forbidden/impossible; it would be
too difficult or too dangerous for programmers if things
were less strict.


> if my requirement is such that i don't want to
> synchronize on wait/notify, then why java semantics
> forces me to synchronize?

My uninformed guess is there was a presumed larger
context where wait/notify should be used, and while
that context may not be explicitly required by the
language/API specification, the API was nevertheless
designed to enforce the corresponding preconditions.


Larry


From dholmes@dltech.com.au  Tue Apr 20 02:08:12 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Tue, 20 Apr 2004 11:08:12 +1000
Subject: [concurrency-interest] Re: Why do we need to take a lock before invoking wait()/notify() on an Object??
In-Reply-To: <20040420003114.24037.qmail@home19.riedel.org>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEGKEBAA.dholmes@dltech.com.au>

It's a bit worrying seeing some of the answers here. Only Brian has really
hit the nail on the head.

The job of Object.wait() is to atomically release the monitor of the object
being waited upon and suspend the current thread. This atomic operation is
impossible to achieve by any other means. As wait() releases the monitor
lock the current thread must hold the monitor lock.

Now why does wait() work this way? The purpose of wait() is to allow a
thread to block until a specific condition holds. So to determine if a
thread should wait() it needs to check the condition. Further, once the
wait() completes (due to a notify or notifyAll being invoked) it usually
expects that the condition it was waiting for is now true AND WILL REMAIN
true while the thread acts upon it. To ensure that the condition cannot
change between testing its value and wait()ing we must use synchronization -
that is the test and the wait() must be within a synchronized block. To
ensure that the condition actually holds after the wait() we test the
condition in a loop, re-waiting if necessary, and to ensure the condition
doesn't change while we act upon it being true we extend the synchronized
block to cover the action code. Because we need to hold the lock before
waiting we need someway to release the lock while waiting - and that is why
wait() is defined to do what it does.

Hence the general form of using wait() (ignoring interrupts or timeouts)
looks like this:

  synchronized (lockObj) {
      while (!condition)
           lockObj.wait();

      // now act knowing that condition is true and can't change
  }

Once you wait() for a condition there is an expectation that some other
thread will cause the condition to become true and notify you of that fact.
The notification must only occur before the waiter sees the condition
doesn't hold, or after the waiter enters the actual wait, otherwise the
notification won't be seen. Hence the notifying thread has to hold the same
lock while it sets the condition and performs the notification:

   synchronized (lockObj) {
       condition = true;
       lockObj.notifyAll(); // or notify() if correct
   }

Now strictly speaking in terms of synchronization correctness it is not
necessary to hold a lock when you do a condition signal - as long as you
signal AFTER changing the state. However Java requires that you do hold the
lock - why? Because otherwise people would forget to hold the lock when
setting the condition and the program would be incorrect. The situation
where doing a notification/signal without holding the lock is beneficial
only in rare circumstances as a potential performance optimisation. This is
an example of the language designers choosing what's best for the majority
of programmers.

In Java, because the monitor lock must be held, the notifications can be
done as a simple queue transfer and the monitor itself can be used to
protected access to the wait/notify mechanics - as other posters have
mentioned. This can benefit performance more than that achieved using an
unsynchronized notification.

The only reason you would not want synchronization around the wait() is if
you weren't testing any condition, but then what are you waiting for? If you
just want to delay for a period of time use Thread.sleep(ms) not wait(ms).

I hope this clarifies things.  I strongly recommend that Satish get a book
on concurrent programming / multi-threaded programming to understand how to
use these synchronization primitives. Of course I recommend Doug Lea's book.
:)

David Holmes

David Holmes


From gregg.wonderly@pobox.com  Tue Apr 20 03:13:50 2004
From: gregg.wonderly@pobox.com (Gregg G. Wonderly)
Date: Mon, 19 Apr 2004 21:13:50 -0500
Subject: [concurrency-interest] Re: Why do we need to take a lock before
 invoking wait()/notify() on an Object??
In-Reply-To: Your message of 20 Apr 2004 00:31:14 -0000.
 <20040420003114.24037.qmail@home19.riedel.org>
Message-ID: <27990.1082427230@skymaster.cytetech.com>

>My uninformed guess is there was a presumed larger
>context where wait/notify should be used, and while
>that context may not be explicitly required by the
>language/API specification, the API was nevertheless
>designed to enforce the corresponding preconditions.

The JLS tells you everything you need to know about synchronized code.  The
important thing is that only one, runnable thread can be in a synchronized 
section at a time.  This, as others have stated, protects the state of the 
datastructures associated with the synchronized object allowing, only one 
thread at a time can manipulate its state.

The import thing is this very simple capability provides the 'monitor' 
concept. From monitor, you can create semaphores and many other very important 
program control structures needed for multi-threaded environments.

It sounds like the original question was asking how to use wait() and notify() 
to allow threads to talk to each other, communicating state back and forth.  
In a multi-processor environment, you have processor caches, and related 
memory consistancy issues to worry about.  The synchronized keyword is 
specified by the JLS to provide cache coeherency promises.  These make it 
possible for multiple threads running in the same JVM to take advantage of 
multi-processor hardware.  When used correctly, synchronized and Object.wait 
and Object.notify(All) provide a form of what you need to manage thread to 
thread communications.

The java.util.concurrent package in jdk1.5 separates out thread state 
synchronization from memory state synchronization.  This creates another set 
of issues that can occur in a multi-threaded application.

The reason for prohibiting certain things in Java, from my reading of much of 
the initial commentary from James Gosling and the others was because these 
things could be done other ways that were not as dangerous to the application. 
 I'm all for less dangers in my software.  Some people want to 'have it their 
way' and are thus frustrated by Java's in ability to let them string 
themselves up with a noose and hold a gun to their head while cutting the trap 
door release with a knife in the other hand.

Java provides the platform.  You can either construct all the things that will 
kill your app, or you can construct a nice structure that will make it 
possible to protect your app.  It's your call...

-----
gregg@cytetech.com  (Cyte Technologies Inc)



From brian@quiotix.com  Tue Apr 20 03:48:15 2004
From: brian@quiotix.com (Brian Goetz)
Date: Mon, 19 Apr 2004 19:48:15 -0700
Subject: [concurrency-interest] Re: Why do we need to take a lock before invoking wait()/notify() on an Object??
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEGKEBAA.dholmes@dltech.com.au>
References: <20040420003114.24037.qmail@home19.riedel.org> <NFBBKALFDCPFIDBNKAPCCEGKEBAA.dholmes@dltech.com.au>
Message-ID: <20040420024815.GA6685@lx.quiotix.com>

> It's a bit worrying seeing some of the answers here. Only Brian has really
> hit the nail on the head.

(Warning, shameless self-congratulation follows)

This only underscores the importance of the JSR 166 effort --
wait/notify are ill-understood, and dangerous when used incorrectly --
a bad combination.  Bill P jokes that there should be a javadoc tag,
akin to @deprecated, called @sharp-edges, and that the compiler would
warn you unless you compiled with --i-am-an-expert flag, and wait()
and notify() are the canonical examples of sharp-edged methods in the
core JDK.

While you may be right to be worried, the fact that of the responders
(already drawn from a self-selected group of those interested in
concurrency!), only the Expert Group members answered the question
right, underscores how important it is to provide alternatives to
wait/notify.  You could interpret that in one of two ways -- I choose
to interpret it as confirmation that wait/notify are simply too
low-level and conceptually challenging for the vast majority of users
to even contemplate using, and therefore we need to offer a better
solution.

And that's where JSR 166 saves the day!  By providing a better,
simpler, less error-prone mechanism for solving 99%+ of the typical
uses for wait/notify, we've reduced the likelihood of wait/notify
misuse substantially.  


From matthias.ernst@coremedia.com  Tue Apr 20 08:48:29 2004
From: matthias.ernst@coremedia.com (Ernst, Matthias)
Date: Tue, 20 Apr 2004 09:48:29 +0200
Subject: [concurrency-interest] Re: Why do we need to take a lock before invoking wait()/notify() on an Object??
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDECA@MARS.coremedia.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C426AC.44719E6D
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Joking aside, why not at least provide a link from Object#wait,notify's =
JavaDoc to the java.util.concurrent package ?
=20
Matthias

________________________________

From: concurrency-interest-admin@cs.oswego.edu on behalf of Brian Goetz

Bill P jokes that there should be a javadoc tag,
akin to @deprecated, called @sharp-edges, and that the compiler would
warn you unless you compiled with --i-am-an-expert flag, and wait()
and notify() are the canonical examples of sharp-edged methods in the
core JDK.


------_=_NextPart_001_01C426AC.44719E6D
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Diso-8859-1">=0A=
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">=0A=
<HTML>=0A=
<HEAD>=0A=
=0A=
<META NAME=3D"Generator" CONTENT=3D"MS Exchange Server version =
6.5.6944.0">=0A=
<TITLE>Re: [concurrency-interest] Re: Why do we need to take a lock =
before invoking wait()/notify() on an Object??</TITLE>=0A=
</HEAD>=0A=
<BODY>=0A=
<DIV id=3DidOWAReplyText76432 dir=3Dltr>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 =
size=3D2>Joking aside, why not =0A=
at least provide a link from Object#wait,notify's JavaDoc&nbsp;to the =0A=
java.util.concurrent package ?</FONT></DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" =
size=3D2>Matthias</FONT></DIV></DIV>=0A=
<DIV dir=3Dltr><BR>=0A=
<HR tabIndex=3D-1>=0A=
<FONT face=3DTahoma size=3D2><B>From:</B> =
concurrency-interest-admin@cs.oswego.edu =0A=
on behalf of Brian Goetz<BR></FONT><BR><FONT size=3D2>Bill P jokes that =
there =0A=
should be a javadoc tag,<BR>akin to @deprecated, called @sharp-edges, =
and that =0A=
the compiler would<BR>warn you unless you compiled with --i-am-an-expert =
flag, =0A=
and wait()<BR>and notify() are the canonical examples of sharp-edged =
methods in =0A=
the<BR>core JDK.<BR></FONT></DIV>=0A=
=0A=
</BODY>=0A=
</HTML>
------_=_NextPart_001_01C426AC.44719E6D--


From TEREKHOV@de.ibm.com  Tue Apr 20 11:41:23 2004
From: TEREKHOV@de.ibm.com (Alexander Terekhov)
Date: Tue, 20 Apr 2004 12:41:23 +0200
Subject: [concurrency-interest] Re: Why do we need to take a lock before
 invoking wait()/notify() on an Object??
In-Reply-To: <20040420024815.GA6685@lx.quiotix.com>
Message-ID: <OF4A77C281.3CE69352-ONC1256E7C.00392C68-C1256E7C.003AB88F@de.ibm.com>

Brian Goetz wrote:
[...]
> And that's where JSR 166 saves the day! 

Right. IIRC, JSR-166's condvars allow signalling without 
holding the associated lock. ;-) In POSIX, the only reason 
(apart from precluding the race while setting and 
communicating "you may delete this condvar" predicate) to 
hold the lock while signalling is "predictable scheduling" 
(the realtime thing). Signalling after releasing the lock 
can result in more efficient execution but slightly less 
predictable scheduling.

regards,
alexander.


From dl@cs.oswego.edu  Tue Apr 20 15:00:57 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Tue, 20 Apr 2004 10:00:57 -0400
Subject: [concurrency-interest] Re: Why do we need to take a lock before
 invoking wait()/notify() on an Object??
In-Reply-To: <OF4A77C281.3CE69352-ONC1256E7C.00392C68-C1256E7C.003AB88F@de.ibm.com>
References: <20040420024815.GA6685@lx.quiotix.com>
 <OF4A77C281.3CE69352-ONC1256E7C.00392C68-C1256E7C.003AB88F@de.ibm.com>
Message-ID: <16517.11545.99933.187899@altair.cs.oswego.edu>

> IIRC, JSR-166's condvars allow signalling without 
> holding the associated lock.

No. (I bet you are remembering that the pre-JSR166
dl.util.concurrent.CondVar class did use pthread rules.)  While the
Lock and Condition interfaces allow you to make any policy you like,
the concrete locks with conditions that we supply (ReentrantLock and
ReeentrantReadWriteLock) use the standard Java monitor rules.  Besides
being a sensible policy, as David Holmes pointed out, this turns out
to be more efficient, at least in the normal case where you must hold
the lock to change a field and then signal -- the implementation can
take advantage of the fact that the lock must be held. A discussion of
some of the underlying design, implementation, and performance issues
here is in a preliminary paper I wrote on JSR166 synchronizers, at
http://gee.cs.oswego.edu/dl/papers/aqs.pdf

Those interested in the range of possible monitor wait/signal policies
might want to read Peter Buhr's now-classic ``Monitor
Classification'' paper, that you can get from
http://plg.uwaterloo.ca/~pabuhr/papers.html


-Doug


From ccox@tripos.com  Tue Apr 20 15:08:05 2004
From: ccox@tripos.com (Curt Cox)
Date: Tue, 20 Apr 2004 09:08:05 -0500
Subject: [concurrency-interest] Re: Why do we need to take a lock before invoking wait()/notify() on an Object??
In-Reply-To: <20040420024815.GA6685@lx.quiotix.com>
Message-ID: <MDEIJLCNINPJGNEJMGODKECACLAA.ccox@tripos.com>

Why not add Javadoc saying that?

http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait(long)
http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#notify()

-----Original Message-----
From: concurrency-interest-admin@cs.oswego.edu
[mailto:concurrency-interest-admin@cs.oswego.edu]On Behalf Of Brian
Goetz
Sent: Monday, April 19, 2004 9:48 PM
To: David Holmes
Cc: concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest] Re: Why do we need to take a lock
before invoking wait()/notify() on an Object??


> It's a bit worrying seeing some of the answers here. Only Brian has really
> hit the nail on the head.

(Warning, shameless self-congratulation follows)

This only underscores the importance of the JSR 166 effort --
wait/notify are ill-understood, and dangerous when used incorrectly --
a bad combination.  Bill P jokes that there should be a javadoc tag,
akin to @deprecated, called @sharp-edges, and that the compiler would
warn you unless you compiled with --i-am-an-expert flag, and wait()
and notify() are the canonical examples of sharp-edged methods in the
core JDK.

While you may be right to be worried, the fact that of the responders
(already drawn from a self-selected group of those interested in
concurrency!), only the Expert Group members answered the question
right, underscores how important it is to provide alternatives to
wait/notify.  You could interpret that in one of two ways -- I choose
to interpret it as confirmation that wait/notify are simply too
low-level and conceptually challenging for the vast majority of users
to even contemplate using, and therefore we need to offer a better
solution.

And that's where JSR 166 saves the day!  By providing a better,
simpler, less error-prone mechanism for solving 99%+ of the typical
uses for wait/notify, we've reduced the likelihood of wait/notify
misuse substantially.

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest







From dl@cs.oswego.edu  Tue Apr 20 15:29:47 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Tue, 20 Apr 2004 10:29:47 -0400
Subject: [concurrency-interest] beta2
Message-ID: <16517.13275.299303.375570@altair.cs.oswego.edu>

The APIs etc currently at JSR166 site
  http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
is, to the best of our knowledge, exactly as it will appear in the
JDK1.5 beta2 release. I think this will be out in 3 weeks or so.

There have been only a few minor internal implementation and
documentation improvements here and there over the past two
months. The only API change is, due to JSR163/174 but with our
cooperation, a handy Thread.State enum in class java.lang.Thread.

The official policy is basically that the only changes that will be
allowed between beta2 and FCS are bugfixes. However, minor
documentation improvements and the like might also be let in.

One downside of freezing in beta2-compatible form is that the
jsr166.jar file on our site is now unusable if you are running beta1
because of unrelated compiler, library, and JVM changes. I believe
that it is still possible to grab the sources and compile most of them
using beta1 though and make your own jar.

-Doug


From gregg.wonderly@pobox.com  Tue Apr 20 15:48:09 2004
From: gregg.wonderly@pobox.com (Gregg G. Wonderly)
Date: Tue, 20 Apr 2004 09:48:09 -0500
Subject: [ Brian Goetz ] [concurrency-interest] Re: Why do we need to take
 a lock before invoking wait()/notify() on an Object??
In-Reply-To: Your message of Mon, 19 Apr 2004 19:48:15 -0700.
 <20040420024815.GA6685@lx.quiotix.com>
Message-ID: <20745.1082472489@skymaster.cytetech.com>

>And that's where JSR 166 saves the day!  By providing a better,
>simpler, less error-prone mechanism for solving 99%+ of the typical
>uses for wait/notify, we've reduced the likelihood of wait/notify
>misuse substantially.  

Without really trying to start an argument, I would certainly like to say that

synchronized( lock ) {
	// do something
}

will never leave lock stuck whereas if you forget to call Lock.unlock(),
you will have a stuck lock.  The programming construct,

Lock lock = ...
lock.lock();
try {
	// do something
} finally {
	lock.unlock();
}

to me, is more to get right.  It might be more to understand synchronized, but 
that goes right along with my feelings that software is engineered, not 
programmed.  If you are a programmer, then you shouldn't be adding locking 
constructs to software.  Only those that have the knowledge to engineer how 
these constructs should be used in a particular application should be using 
them.

So, I would prefer to create the class,

class LockedOperation {
	Lock l;
	public LockedOperation( Lock l ) {
		this.l = l;
	}
	public void execute( Runnable r ) {
		l.lock();
		try {
			r.run();
		} finally {
			l.unlock();
		}
	}
}

for the programmers to use so that there is a lot less chance that the lock 
will be left in a locked state.

If you were not able to take a course that involved in-depth study of the 
dining philosophers problem, and you have no real grasp of multi-processor 
cache coeherency issues, and all the other things that synchronized wraps up 
into one convenient concept, then I'd suggest you find a book or two to read 
up on these subjects, if you are going to be engineering software that needs 
to be multi-threaded...

This is an important concept.  From my perspective, this part of programming 
is an evolutionary issue.  Think of the memory allocation problem;

simple vars -> arrays -> stack based arrays ->
	dynamic allocation -> garbage collection

This evolution resulted in a significant amount of software work being done 
for the programmer, under the covers.  Patterns were recognized over time, and 
the rest is history.  The JSR work done here, provides some great ways to 
express many common control constructs that need synchronized behavior.  
That's great! But, I still feel like we are at the C++ dividing line.  There 
is now some convenience classes that solve many problems, but much like C++ 
'MyObj *o = new MyObj()', there are cases where the user 'will need to', 'be 
allowed to' hang themselves due to oversight (e.g. missing finally { 
lock.unlock() }).

-----
gregg@cytetech.com  (Cyte Technologies Inc)



From larryr@saturn.sdsu.edu  Tue Apr 20 16:13:30 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 20 Apr 2004 15:13:30 -0000
Subject: [concurrency-interest] Re: Why do we need to take a lock before invoking wait()/notify() on an Object??
In-Reply-To: <27990.1082427230@skymaster.cytetech.com>
Message-ID: <20040420151330.28671.qmail@home19.riedel.org>

> > My uninformed guess is there was a presumed larger
> > context where wait/notify should be used, and while
> > that context may not be explicitly required by the
> > language/API specification, the API was nevertheless
> > designed to enforce the corresponding preconditions.
> 
> The JLS tells you everything you need to know about synchronized
> code.  The important thing is that only one, runnable thread can
> be in a synchronized section at a time.  This, as others have
> stated, protects the state of the datastructures associated with
> the synchronized object allowing, only one thread at a time can
> manipulate its state.

It is not clear to me how this is relevant to the question of
why threads are required to have already synchronized on an
object before entering its wait() method.  I have seen what
JLS 17.14 says about the requirement, and it does not make
it clear at all to me /why/ that requirement exists.


> The reason for prohibiting certain things in Java, from my
> reading of much of the initial commentary from James Gosling
> and the others was because these things could be done other
> ways that were not as dangerous to the application. 

That is consistent with my perception of paternalism.


Larry


From noel@devtech.com  Tue Apr 20 16:13:31 2004
From: noel@devtech.com (Noel J. Bergman)
Date: Tue, 20 Apr 2004 11:13:31 -0400
Subject: [ Brian Goetz ] [concurrency-interest] Re: Why do we need to take  a lock before invoking wait()/notify() on an Object??
In-Reply-To: <20745.1082472489@skymaster.cytetech.com>
Message-ID: <NBBBJGEAGJAKLIDBKJOPMEGLINAB.noel@devtech.com>

> The programming construct,

> Lock lock = ...
> lock.lock();
> try {
> 	// do something
> } finally {
> 	lock.unlock();
> }

> to me, is more to get right.

In fact, I've just been finding errors in a variation of that pattern in
long-standing code, where a refactoring of code that had been working into a
new form didn't take some things into account, and has resulted in stuck
locks and a memory leak.

	--- Noel


From dl@cs.oswego.edu  Tue Apr 20 16:46:15 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Tue, 20 Apr 2004 11:46:15 -0400
Subject: [concurrency-interest] Re: Why do we need to take a lock before invoking wait()/notify() on an Object??
In-Reply-To: <20040420151330.28671.qmail@home19.riedel.org>
References: <27990.1082427230@skymaster.cytetech.com>
 <20040420151330.28671.qmail@home19.riedel.org>
Message-ID: <16517.17863.665017.695751@altair.cs.oswego.edu>

At this point, we have some people arguing that some contructs are too
inflexible/paternalistic and some people arguing that others are too
flexible/error-prone. I'd just mutter "you can't win", except I think
you can -- JSR166 adds constructs at several levels, and people should
choose carefully which ones they want to use. So, if don't like
lock-holding policiies for signalling in monitors, please make your
own (out of park/unpark etc). And if you don't like the possiblility
of dropping unlocks, please stick with synchronized, or use findBugs,
which now includes detectors for Lock class mistakes.
http://findbugs.sourceforge.net/

-Doug

From larryr@saturn.sdsu.edu  Wed Apr 21 01:38:33 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 21 Apr 2004 00:38:33 -0000
Subject: [concurrency-interest] Re: Why do we need to take a lock before invoking wait()/notify() on an Object??
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEGKEBAA.dholmes@dltech.com.au>
Message-ID: <20040421003833.31554.qmail@home19.riedel.org>

> The job of Object.wait() is to atomically release
> the monitor of the object being waited upon and
> suspend the current thread. This atomic operation is
> impossible to achieve by any other means.  As wait()
> releases the monitor lock the current thread must hold
> the monitor lock.

The Subject: asks "Why do we need to take a lock BEFORE
INVOKING wait()/notify()?".


> The purpose of wait() is to allow a thread to block until
> a specific condition holds. [...]
> The only reason you would not want synchronization around
> the wait() is if you weren't testing any condition, but
> then what are you waiting for?

Waiting for the occurrence of a single event, where the only
information to be conveyed by notify() is that the event
occurred, and the constraint that notify() must be invoked
after wait() will be satisfied without explicit/imperative
coordination between the wait()ing and notify()ing threads.


Larry


From dholmes@dltech.com.au  Wed Apr 21 02:17:49 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Wed, 21 Apr 2004 11:17:49 +1000
Subject: [concurrency-interest] Re: Why do we need to take a lock before invoking wait()/notify() on an Object??
Message-ID: <NFBBKALFDCPFIDBNKAPCGEHOEBAA.dholmes@dltech.com.au>

Larry Riedel wrote:
> The Subject: asks "Why do we need to take a lock BEFORE
> INVOKING wait()/notify()?".

And I answered that. To understand why you need to lock before calling
wait() you have to understand the purpose of wait() and what it does.

> > The only reason you would not want synchronization around
> > the wait() is if you weren't testing any condition, but
> > then what are you waiting for?
>
> Waiting for the occurrence of a single event, where the only
> information to be conveyed by notify() is that the event
> occurred, and the constraint that notify() must be invoked
> after wait() will be satisfied without explicit/imperative
> coordination between the wait()ing and notify()ing threads.

Neither Java's monitor methods (wait()/notify()) nor POSIX's condition
variables & mutexes can be reliably/portably used in this "raw" way due to
the possibility of spurious wakeups - as now explicitly allowed and always
intended to be allowed in Java.

There must be a state variable associated with the condition being waited
upon, for correct & portable synchronization/communication between the
threads.

David Holmes


From chussenet@yahoo.com  Wed Apr 21 04:09:59 2004
From: chussenet@yahoo.com (Claude Hussenet)
Date: Tue, 20 Apr 2004 20:09:59 -0700 (PDT)
Subject: [concurrency-interest] AOP Asynchronous Method Invocation with CONCURRENT
Message-ID: <20040421030959.50133.qmail@web41502.mail.yahoo.com>

For people interested in asynchronous call,
I have just contributed to the JBOSS project a new
Aspect for asynchronous method invocation based on the
CONCURRENT package.

See below a simple example illustrating the AOP
service for asynchronous method invocation.
I am using Doclet tag(@@) to define a method as an
asynchronous method.
 
/---------------------------------------------------/
/** @@asynchronous */
public class POJO {

/** @@asynchronous timeout=2000 */ 
public long processBusinessModel(...){}
 
}
/---------------------------------------------------/
/*
Main program
------------
*/
POJO pojo = new POJO(...);

/* Asynchronous Method Invocation */ 
long result=pojo.processBusinessModel(...);
...
...

/* non-blocking call */ 
if (((AsynchronousFacade)pojo).isDone())
{
AsynchronousFacade aF=(AsynchronousFacade)pojo;


/* Test response code returned */ 
if (aF.getResponseCode()==OK)

/* get method response processed asynchronously */ 
result = ((Long)aF.getReturnValue()).longValue();

/* Test if method timed out */ 
else if (aF.getResponseCode()==TIMEOUT)
{...}
else
... 
}

else {

/* blocking call */ 
AsynchronousResponse aR =
((AsynchronousFacade)pojo).waitForResponse();
If (aR.getResponseCode()==OK)

/* get method response processed asynchronously */ 
result=((Long)aR.getReturnValue()).longValue();

/* Test if method timed out */ 
else if (aR.getReponseCode()==TIMEOUT)
{...}
else
{...}
}

For more information,u can read some documentation
on JBOSS site at
http://jboss.org/wiki/Wiki.jsp?page=AOPAsynchronousMethodInvocation

The AOP Asynchronous aspect will be bundled with the
future release of JBOSS-AOP planned in a couple of
weeks.

Rgds,Claude








=====
Claude Hussenet
Independent Consultant.
(516)942-8214 (Home Office)
(516)782-2614 (Mobile Phone)
www.portalsmart.com (Showcase Not Always up)


	
		
__________________________________
Do you Yahoo!?
Yahoo! Photos: High-quality 4x6 digital prints for 25¢
http://photos.yahoo.com/ph/print_splash

From jon.rowland@anite.com  Wed Apr 21 17:11:05 2004
From: jon.rowland@anite.com (Jon Rowland)
Date: Wed, 21 Apr 2004 17:11:05 +0100
Subject: [concurrency-interest] Problem with an ArrayBlockingQueue and fixed thread pool
Message-ID: <7B91F5F17CAAD411984E00508BDD077CA4CCB1@BOSSI>

Hi,

I'm trying to create a fixed-size thread-pool processing an array blocking
queue, so I have something like:

ExecutorService es = new ThreadPoolExecutor(8, 8, Long.MAX_VALUE,
TimeUnit.NANOSECONDS,
							new
ArrayBlockingQueue<Runnable>(1000));

I then have a loop which creates lots of tasks via the es.execute() method.

However, during processing I am getting the following exception:

java.util.concurrent.RejectedExecutionException
	at
java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(Thread
PoolExecutor.java:1329)
	at
java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:323)
	at
java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:815)
	at Translation.processFile(Translation.java:96)
	at Translation.main(Translation.java:32)

This looks to me like the array blocking queue isn't blocking, but is
returning null causing the exception to be thrown.

Am I doing something wrong here? Apologies if it's an obvious one.

I believe that I'm using the latest version of the jsr166.jar against the
sun jdk1.5 beta 1.

Thanks and regards,
Jon Rowland


Scanned for viruses by MessageLabs. The integrity and security of this message cannot be guaranteed. This email is intended for the named recipient only, and may contain confidential information and proprietary material. Any unauthorised use or disclosure is prohibited.

From gregg.wonderly@pobox.com  Wed Apr 21 18:04:05 2004
From: gregg.wonderly@pobox.com (Gregg G. Wonderly)
Date: Wed, 21 Apr 2004 12:04:05 -0500
Subject: [ Larry Riedel ] [concurrency-interest] Re: Why do we need to
 take a lock before invoking wait()/notify() on an Object??
In-Reply-To: Your message of 20 Apr 2004 15:13:30 -0000.
 <20040420151330.28671.qmail@home19.riedel.org>
Message-ID: <8402.1082567045@skymaster.cytetech.com>

>It is not clear to me how this is relevant to the question of
>why threads are required to have already synchronized on an
>object before entering its wait() method.  I have seen what
>JLS 17.14 says about the requirement, and it does not make
>it clear at all to me /why/ that requirement exists.

The JSR-133 documentation does a good job of discussing some of the pitfalls 
that developers fall into.  I'll offer an analogy.  The sychronized keyword is 
like the crossing gate where a railroad track crosses a roadway.  If the gate 
was not there, people would be more prone to trying to beat the train.  
Putting the gate their protects people from their own mistakes, without really 
creating an unusual amount of disturbance of safe and typical practices.  We 
could probably save more lives and property damage if we put such gates at 
every pedestrian crossing of every street.  But, doing so would be like 
synching the cache to memory on every instruction, and not allowing compilers 
to reorder statement execution.  As a society, we've decided that street 
crossing gates are not necessary because people can, in general, see up and 
down the street, and make educated decisions about when to cross.  We could 
all make educated decisions about when to use 'synchronize'.  But, we'd all 
get hit by the train eventually, when in  a hurry, and eventually there'd be 
noone left!

Taking JSR-133 and the original memory model and JLS into account, you need to 
synchronize on the variable that you will call wait on, to make sure that its 
value is actually assigned (in certain scenarios instruction reordering may 
cause its value to not be assigned when another thread has assigned it).  
Then, your method call to wait() or notify() will actually work.

This is the crucial issue that is vital to understand!

-----
gregg@cytetech.com  (Cyte Technologies Inc)



From gregg.wonderly@pobox.com  Wed Apr 21 18:07:12 2004
From: gregg.wonderly@pobox.com (Gregg G. Wonderly)
Date: Wed, 21 Apr 2004 12:07:12 -0500
Subject: [concurrency-interest] Re: Why do we need to take a lock before
 invoking wait()/notify() on an Object??
In-Reply-To: Your message of Tue, 20 Apr 2004 11:46:15 -0400.
 <16517.17863.665017.695751@altair.cs.oswego.edu>
Message-ID: <8472.1082567232@skymaster.cytetech.com>

>
>At this point, we have some people arguing that some contructs are too
>inflexible/paternalistic and some people arguing that others are too
>flexible/error-prone. I'd just mutter "you can't win", except I think
>you can -- JSR166 adds constructs at several levels, and people should
>choose carefully which ones they want to use.

My statement was supposed to allow Larry to see that there are several things 
to consider.  The JSR-166 constructs are, in fact, helpful in eleminating many 
problems for the types of flow control that they mediate!  Everyone can still 
take whatever path is best for them, no doubt!

-----
gregg@cytetech.com  (Cyte Technologies Inc)



From larryr@saturn.sdsu.edu  Wed Apr 21 20:32:34 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 21 Apr 2004 19:32:34 -0000
Subject: [concurrency-interest] Re: Why do we need to take a lock before invoking wait()/notify() on an Object??
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEHOEBAA.dholmes@dltech.com.au>
Message-ID: <20040421193234.6331.qmail@home19.riedel.org>

> > The Subject: asks "Why do we need to take a lock BEFORE
> > INVOKING wait()/notify()?".
> 
> And I answered that. To understand why you need to lock
> before calling wait() you have to understand the purpose
> of wait() and what it does.

I meant to express that I do not think questioning why the API
requires the lock to be held /before/ invoking wait() suggests
a lack of understanding of what the wait() implementation does.


> There must be a state variable associated with the
> condition being waited upon, for correct & portable
> synchronization/communication between the threads.

While I think it is critical that wait()/notify() _supports_
guaranteed reliable delivery, I do not think an application
cannot be "correct" if it ever utilizes wait()/notify() for
only best effort delivery.


> > Waiting for the occurrence of a single event, where the only
> > information to be conveyed by notify() is that the event
> > occurred, and the constraint that notify() must be invoked
> > after wait() will be satisfied without explicit/imperative
> > coordination between the wait()ing and notify()ing threads.
> 
> Neither Java's monitor methods (wait()/notify()) nor POSIX's
> condition variables & mutexes can be reliably/portably used in
> this "raw" way due to the possibility of spurious wakeups [...]

Is it not possible for the wait()ing thread to determine without
information other than provided via wait() that a wakeup was
not caused by a thread invoking notify() for that object?  Or I
guess I really want to know about the general JDK 1.5+ policy:
for methods conceptually related to wait() which block until
some other thread invokes a corresponding method conceptually
related to notify(), is the contract such that the wait() style
method is not responsible for communicating back to its caller
whether another thread invoked the corresponding notify()
style method, rather than that something [spurious] happened?


Larry


From matthias.ernst@coremedia.com  Wed Apr 21 23:17:22 2004
From: matthias.ernst@coremedia.com (Ernst, Matthias)
Date: Thu, 22 Apr 2004 00:17:22 +0200
Subject: [concurrency-interest] Problem with an ArrayBlockingQueue and fixed thread pool
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDED4@MARS.coremedia.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C427EE.6AC5C147
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

John,
=20
you should check=20
http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ThreadPoolEx=
ecutor.html
regarding "Rejected Tasks".
=20
The queue is full and all threads are busy. Now the =
RejectedExecutionPolicy of the Executor comes into play. The default is =
throwing an exception. Interestingly the option "block until a slot is =
free" is no longer available in j.u.c when it used to be in dl.u.c.
=20
Matthias
=20
=20
________________________________

From: concurrency-interest-admin@cs.oswego.edu on behalf of Jon Rowland
Sent: Wed 4/21/2004 6:11 PM
To: concurrency-interest@altair.cs.oswego.edu
Subject: [concurrency-interest] Problem with an ArrayBlockingQueue and =
fixed thread pool



However, during processing I am getting the following exception:

java.util.concurrent.RejectedExecutionException
        at
java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(Thr=
ead



------_=_NextPart_001_01C427EE.6AC5C147
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Diso-8859-1">=0A=
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">=0A=
<HTML>=0A=
<HEAD>=0A=
=0A=
<META NAME=3D"Generator" CONTENT=3D"MS Exchange Server version =
6.5.6944.0">=0A=
<TITLE>[concurrency-interest] Problem with an ArrayBlockingQueue and =
fixed thread pool</TITLE>=0A=
</HEAD>=0A=
<BODY>=0A=
<DIV id=3DidOWAReplyText77280 dir=3Dltr>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 =
size=3D2>John,</FONT></DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" =
size=3D2></FONT>&nbsp;</DIV></DIV>=0A=
<DIV dir=3Dltr>you should check </DIV>=0A=
<DIV dir=3Dltr><A =0A=
href=3D"http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/Thre=
adPoolExecutor.html">http://java.sun.com/j2se/1.5.0/docs/api/java/util/co=
ncurrent/ThreadPoolExecutor.html</A></DIV>=0A=
<DIV dir=3Dltr>regarding&nbsp;"Rejected Tasks".</DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV>=0A=
<DIV dir=3Dltr>The queue is full and all threads are busy. Now the =0A=
RejectedExecutionPolicy of the Executor comes into play. The default is =
throwing =0A=
an exception. Interestingly the option "block until a slot is free" is =
no longer =0A=
available in j.u.c when it used to be in dl.u.c.</DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV>=0A=
<DIV dir=3Dltr>Matthias</DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV>=0A=
<DIV dir=3Dltr>=0A=
<HR tabIndex=3D-1>=0A=
</DIV>=0A=
<DIV dir=3Dltr><FONT face=3DTahoma size=3D2><B>From:</B> =0A=
concurrency-interest-admin@cs.oswego.edu on behalf of Jon =0A=
Rowland<BR><B>Sent:</B> Wed 4/21/2004 6:11 PM<BR><B>To:</B> =0A=
concurrency-interest@altair.cs.oswego.edu<BR><B>Subject:</B> =0A=
[concurrency-interest] Problem with an ArrayBlockingQueue and fixed =
thread =0A=
pool<BR></FONT><BR></DIV>=0A=
<DIV>=0A=
<P><FONT size=3D2>However, during processing I am getting the following =0A=
exception:<BR><BR>java.util.concurrent.RejectedExecutionException<BR>&nbs=
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =0A=
at<BR>java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecuti=
on(Thread<BR></FONT></P></DIV>=0A=
=0A=
</BODY>=0A=
</HTML>
------_=_NextPart_001_01C427EE.6AC5C147--


From dholmes@dltech.com.au  Wed Apr 21 23:52:48 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Thu, 22 Apr 2004 08:52:48 +1000
Subject: [concurrency-interest] Re: Why do we need to take a lock before invoking wait()/notify() on an Object??
In-Reply-To: <20040421193234.6331.qmail@home19.riedel.org>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEIOEBAA.dholmes@dltech.com.au>

> Is it not possible for the wait()ing thread to determine without
> information other than provided via wait() that a wakeup was
> not caused by a thread invoking notify() for that object?  Or I
> guess I really want to know about the general JDK 1.5+ policy:
> for methods conceptually related to wait() which block until
> some other thread invokes a corresponding method conceptually
> related to notify(), is the contract such that the wait() style
> method is not responsible for communicating back to its caller
> whether another thread invoked the corresponding notify()
> style method, rather than that something [spurious] happened?

No. Spurious wakeups are allowed. You can't tell a spurious return from
wait() from a return caused by a notification. You may be able to infer the
wakeup was spurious by examining other state in your program, or through
program knowledge eg. that no thread ever does a notify hence it must have
been spurious.

The JSR-166 ReentrantLock.Condition allows spurious wakeups. The
LockSupport.park mechanism allows for spurious unparks. In neither case can
you tell (if the system could tell you it was a spurious wakeup it wouldn't
need to spuriously wake you).

Things like Semaphore, CountDownLatch, CyclicBarrier and Exchanger will
never give a spurious wakeup as they only wakeup threads based on actual
internal state.

David Holmes


From dl@cs.oswego.edu  Thu Apr 22 01:48:07 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 21 Apr 2004 20:48:07 -0400
Subject: [concurrency-interest] Problem with an ArrayBlockingQueue and fixed thread pool
In-Reply-To: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDED4@MARS.coremedia.com>
References: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDED4@MARS.coremedia.com>
Message-ID: <16519.5703.45305.881762@altair.cs.oswego.edu>

> Interestingly the option "block until a slot is free" is no longer available in j.u.c when it used to be in dl.u.c.
>  

While you can still define this yourself, we do not predefine it.
I've gotten several reports of freeze-ups and deadlocks in
dl.u.c.PooledExecutor applications ultimately traceable to this. 

In general, if you need to bound capacity, then when the capacity is
reached, you must either shed load or slow down task producers.
People hate to think about shedding load.  You often cannot block
producers though because they may be dependent on some queued or
executing tasks (or vice versa). So my standard advice is to use
CallerRuns policy, which will slow it down (because it has to run some
tasks) without freezing it up. This strategy also has a long history
of use in realms like telecom.

And even if you do use some kind of blocking policy, you probably want
some kind of timeout or cancellation control that is application
specific so we can't provide in a predefined policy object.

-Doug

From jon.rowland@anite.com  Thu Apr 22 09:51:55 2004
From: jon.rowland@anite.com (Jon Rowland)
Date: Thu, 22 Apr 2004 09:51:55 +0100
Subject: [concurrency-interest] Problem with an ArrayBlockingQueue and
 fixed thread pool
Message-ID: <7B91F5F17CAAD411984E00508BDD077CA4CCC4@BOSSI>

This message is in MIME format. Since your mail reader does not understand
this format, some or all of this message may not be legible.

------_=_NextPart_001_01C42847.1067E590
Content-Type: text/plain

OK - I see now. It was the name of the queue (ArrayBlockingQueue) that threw
me off.
 
Thanks for your help Matthias and Doug.
 
Regards, Jon
 

-----Original Message-----
From: Ernst, Matthias [mailto:matthias.ernst@coremedia.com] 
Sent: 21 April 2004 23:17
To: Jon Rowland; concurrency-interest@altair.cs.oswego.edu
Subject: RE: [concurrency-interest] Problem with an ArrayBlockingQueue and
fixed thread pool


John,
 
you should check 
http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ThreadPoolExecu
tor.html
<http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ThreadPoolExec
utor.html> 
regarding "Rejected Tasks".
 
The queue is full and all threads are busy. Now the RejectedExecutionPolicy
of the Executor comes into play. The default is throwing an exception.
Interestingly the option "block until a slot is free" is no longer available
in j.u.c when it used to be in dl.u.c.
 
Matthias
 
 
  _____  

From: concurrency-interest-admin@cs.oswego.edu on behalf of Jon Rowland
Sent: Wed 4/21/2004 6:11 PM
To: concurrency-interest@altair.cs.oswego.edu
Subject: [concurrency-interest] Problem with an ArrayBlockingQueue and fixed
thread pool



However, during processing I am getting the following exception:

java.util.concurrent.RejectedExecutionException
        at
java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(Thread




Scanned for viruses by MessageLabs





Scanned for viruses by MessageLabs. The integrity and security of this message cannot be guaranteed. This email is intended for the named recipient only, and may contain confidential information and proprietary material. Any unauthorised use or disclosure is prohibited.
------_=_NextPart_001_01C42847.1067E590
Content-Type: text/html
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE=20HTML=20PUBLIC=20"-//W3C//DTD=20HTML=204.0=20Transitional//EN">=

<HTML><HEAD>
<META=20HTTP-EQUIV=3D"Content-Type"=20CONTENT=3D"text/html;=20charset=3DUS=
-ASCII">
<TITLE>Message</TITLE>

<META=20content=3D"MSHTML=206.00.2800.1400"=20name=3DGENERATOR></HEAD>
<BODY>
<DIV><FONT=20face=3DArial=20color=3D#0000ff=20size=3D2><SPAN=20class=3D712=
085208-22042004>OK=20-=20I=20
see=20now.=20It=20was=20the=20name=20of=20the=20queue=20(ArrayBlockingQueu=
e)=20that=20threw=20me=20
off.</SPAN></FONT></DIV>
<DIV><FONT=20face=3DArial=20color=3D#0000ff=20size=3D2><SPAN=20
class=3D712085208-22042004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT=20face=3DArial=20color=3D#0000ff=20size=3D2><SPAN=20class=3D712=
085208-22042004>Thanks=20
for=20your=20help=20Matthias=20and=20Doug.</SPAN></FONT></DIV>
<DIV><FONT=20face=3DArial=20color=3D#0000ff=20size=3D2><SPAN=20
class=3D712085208-22042004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT=20face=3DArial=20color=3D#0000ff=20size=3D2><SPAN=20
class=3D712085208-22042004>Regards,=20Jon</SPAN></FONT></DIV>
<DIV><FONT=20face=3DArial=20color=3D#0000ff=20size=3D2><SPAN=20
class=3D712085208-22042004></SPAN></FONT>&nbsp;</DIV>
<BLOCKQUOTE=20style=3D"MARGIN-RIGHT:=200px">
=20=20<DIV></DIV>
=20=20<DIV=20class=3DOutlookMessageHeader=20lang=3Den-us=20dir=3Dltr=20ali=
gn=3Dleft><FONT=20
=20=20face=3DTahoma=20size=3D2>-----Original=20Message-----<BR><B>From:</B=
>=20Ernst,=20Matthias=20
=20=20[mailto:matthias.ernst@coremedia.com]=20<BR><B>Sent:</B>=2021=20Apri=
l=202004=20
=20=2023:17<BR><B>To:</B>=20Jon=20Rowland;=20
=20=20concurrency-interest@altair.cs.oswego.edu<BR><B>Subject:</B>=20RE:=20=

=20=20[concurrency-interest]=20Problem=20with=20an=20ArrayBlockingQueue=20=
and=20fixed=20thread=20
=20=20pool<BR><BR></FONT></DIV>
=20=20<DIV=20id=3DidOWAReplyText77280=20dir=3Dltr>
=20=20<DIV=20dir=3Dltr><FONT=20face=3D"Courier=20New"=20color=3D#000000=20=
size=3D2>John,</FONT></DIV>
=20=20<DIV=20dir=3Dltr><FONT=20face=3D"Courier=20New"=20size=3D2></FONT>&n=
bsp;</DIV></DIV>
=20=20<DIV=20dir=3Dltr>you=20should=20check=20</DIV>
=20=20<DIV=20dir=3Dltr><A=20
=20=20href=3D"http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent=
/ThreadPoolExecutor.html">http://java.sun.com/j2se/1.5.0/docs/api/java/uti=
l/concurrent/ThreadPoolExecutor.html</A></DIV>
=20=20<DIV=20dir=3Dltr>regarding&nbsp;"Rejected=20Tasks".</DIV>
=20=20<DIV=20dir=3Dltr>&nbsp;</DIV>
=20=20<DIV=20dir=3Dltr>The=20queue=20is=20full=20and=20all=20threads=20are=
=20busy.=20Now=20the=20
=20=20RejectedExecutionPolicy=20of=20the=20Executor=20comes=20into=20play.=
=20The=20default=20is=20
=20=20throwing=20an=20exception.=20Interestingly=20the=20option=20"block=20=
until=20a=20slot=20is=20free"=20
=20=20is=20no=20longer=20available=20in=20j.u.c=20when=20it=20used=20to=20=
be=20in=20dl.u.c.</DIV>
=20=20<DIV=20dir=3Dltr>&nbsp;</DIV>
=20=20<DIV=20dir=3Dltr>Matthias</DIV>
=20=20<DIV=20dir=3Dltr>&nbsp;</DIV>
=20=20<DIV=20dir=3Dltr>&nbsp;</DIV>
=20=20<DIV=20dir=3Dltr>
=20=20<HR=20tabIndex=3D-1>
=20=20</DIV>
=20=20<DIV=20dir=3Dltr><FONT=20face=3DTahoma=20size=3D2><B>From:</B>=20
=20=20concurrency-interest-admin@cs.oswego.edu=20on=20behalf=20of=20Jon=20=

=20=20Rowland<BR><B>Sent:</B>=20Wed=204/21/2004=206:11=20PM<BR><B>To:</B>=20=

=20=20concurrency-interest@altair.cs.oswego.edu<BR><B>Subject:</B>=20
=20=20[concurrency-interest]=20Problem=20with=20an=20ArrayBlockingQueue=20=
and=20fixed=20thread=20
=20=20pool<BR></FONT><BR></DIV>
=20=20<DIV>
=20=20<P><FONT=20size=3D2>However,=20during=20processing=20I=20am=20gettin=
g=20the=20following=20
=20=20exception:<BR><BR>java.util.concurrent.RejectedExecutionException<BR=
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=20
=20=20at<BR>java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedEx=
ecution(Thread<BR></FONT></P></DIV><BR><BR>Scanned=20
=20=20for=20viruses=20by=20MessageLabs<BR></BLOCKQUOTE>
<BR>
<BR>
Scanned=20for=20viruses=20by=20MessageLabs.=20The=20integrity=20and=20secu=
rity=20of=20this=20message=20cannot=20be=20guaranteed.=20This=20email=20is=
=20intended=20for=20the=20named=20recipient=20only,=20and=20may=20contain=20=
confidential=20information=20and=20proprietary=20material.=20Any=20unautho=
rised=20use=20or=20disclosure=20is=20prohibited.<BR>
</BODY></HTML>

------_=_NextPart_001_01C42847.1067E590--

From Satish Duggana" <satish@pramati.com  Thu Apr 22 12:37:55 2004
From: Satish Duggana" <satish@pramati.com (Satish Duggana)
Date: Thu, 22 Apr 2004 17:07:55 +0530
Subject: [concurrency-interest] Re: Why do we need to take a lock before invoking wait()/notify() on an Object??
References: <NFBBKALFDCPFIDBNKAPCIEIOEBAA.dholmes@dltech.com.au>
Message-ID: <000a01c4285e$40f98df0$6201a8c0@SATISHDUGGANA>

Thanks to all of you whoever replied to my query.

Hi David,

Actually I wanted to know why wait/notify are designed like that,  I do not
have any requirement as such, invoking wait/notify without taking a lock. I
wanted to presume if some body needs like that. I was little confused, now
things are more clear.

I have read Concurrent Programming earlier, great book, after that i
registered to concurrency-interest.

Cheers,
Sato.
Phone: (off) +91- 40-23411672 Xtn 635
            (h)   +91- 9885147885


----- Original Message -----
From: "David Holmes" <dholmes@dltech.com.au>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Thursday, April 22, 2004 4:22 AM
Subject: RE: [concurrency-interest] Re: Why do we need to take a lock before
invoking wait()/notify() on an Object??


> > Is it not possible for the wait()ing thread to determine without
> > information other than provided via wait() that a wakeup was
> > not caused by a thread invoking notify() for that object?  Or I
> > guess I really want to know about the general JDK 1.5+ policy:
> > for methods conceptually related to wait() which block until
> > some other thread invokes a corresponding method conceptually
> > related to notify(), is the contract such that the wait() style
> > method is not responsible for communicating back to its caller
> > whether another thread invoked the corresponding notify()
> > style method, rather than that something [spurious] happened?
>
> No. Spurious wakeups are allowed. You can't tell a spurious return from
> wait() from a return caused by a notification. You may be able to infer
the
> wakeup was spurious by examining other state in your program, or through
> program knowledge eg. that no thread ever does a notify hence it must have
> been spurious.
>
> The JSR-166 ReentrantLock.Condition allows spurious wakeups. The
> LockSupport.park mechanism allows for spurious unparks. In neither case
can
> you tell (if the system could tell you it was a spurious wakeup it
wouldn't
> need to spuriously wake you).
>
> Things like Semaphore, CountDownLatch, CyclicBarrier and Exchanger will
> never give a spurious wakeup as they only wakeup threads based on actual
> internal state.
>
> David Holmes
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>



From leou@us.ibm.com  Fri Apr 23 14:12:55 2004
From: leou@us.ibm.com (Leo Uzcategui)
Date: Fri, 23 Apr 2004 07:12:55 -0600
Subject: [concurrency-interest] Leo Uzcategui/Austin/IBM is out of the office.
Message-ID: <OFDB38AE35.C99D2DA1-ON87256E7F.00489823-87256E7F.00489823@us.ibm.com>

--0__=08BBE4ECDFDB1EB38f9e8a93df938690918c08BBE4ECDFDB1EB3
Content-type: text/plain; charset=US-ASCII





I will be out of the office starting  04/22/2004 and will not return until
04/26/2004.

For assistance, please contact Robin Redden at (512) 838-1542.
--0__=08BBE4ECDFDB1EB38f9e8a93df938690918c08BBE4ECDFDB1EB3
Content-type: text/html; charset=US-ASCII
Content-Disposition: inline

<html><body>
<p>I will be out of the office starting  04/22/2004 and will not return until 04/26/2004.<br>
<br>
For assistance, please contact Robin Redden at (512) 838-1542.<br>
</body></html>
--0__=08BBE4ECDFDB1EB38f9e8a93df938690918c08BBE4ECDFDB1EB3--


From mike.skells@ebizz-consulting.com  Fri Apr 30 09:56:12 2004
From: mike.skells@ebizz-consulting.com (Mike Skells)
Date: Fri, 30 Apr 2004 09:56:12 +0100
Subject: [concurrency-interest] locks and the JMM
Message-ID: <005401c42e90$ff59a590$0100a8c0@mikework>

This is a multi-part message in MIME format.

------=_NextPart_000_0055_01C42E99.611E0D90
Content-Type: text/plain;
	charset="us-ascii"
Content-Transfer-Encoding: 7bit

Hi,
I have just read read jsr 133 and 166 info on java.net, and I am
perplexed by a few points
Sorry if this has been answered already , I scanned the archive ...
 
As the lock is described as similar to using a syncronised block but
with performance advantages, and a synchronized code now has semantics
relating to the visibility of variables modifiied within the
synchronised block, and when they are seen in other threads.
 
How is this accomplished with the use of locks. As a lock is not a
language construct, the ordering of the memory reads and writes be
controlled (can it?), so how is the data modified within the lock
protected area reflected in other threads
 
In the example below calling inc2 guarantees that the modified variable
'count' is consistent between threads.
is the same true for inc1
 
class x {
    static int count = 1;
    public static inc1() {
        Lock l = ...;
        l.lock();
        try {
            // access the resource protected by this lock
            count ++;
            return count;
        } finally {
            l.unlock();
        }
    } 
    public synchronized static inc2() {
        count ++;
        return count;

    }
}
 
 
My second question is this. Why wasnt the lock included in the language
as a construct. I understand that there is a reluctance to add keywords
to the language but couldnt we have somethink like
 
        Lock lock = ...;
        synchronised : lock {
            // access the resource protected by this lock
        }
 
Yours perplexed
 
Mike Skells

------=_NextPart_000_0055_01C42E99.611E0D90
Content-Type: text/html;
	charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Dus-ascii">
<TITLE>Message</TITLE>

<META content=3D"MSHTML 6.00.2800.1400" name=3DGENERATOR></HEAD>
<BODY>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004>Hi,</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D948322108-30042004>I have =
just read=20
read jsr 133 and 166 info on java.net, and I am perplexed by a few=20
points</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D948322108-30042004>Sorry =
if this has=20
been answered already , I scanned the archive ...</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D948322108-30042004>As the =
lock is=20
described as similar to using a syncronised block but with performance=20
advantages, and a synchronized code now has semantics relating to the =
visibility=20
of variables modifiied within the synchronised block, and when they are =
seen in=20
other threads.</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D948322108-30042004>How is =
this=20
accomplished with the use of locks. As a lock is not a language =
construct, the=20
ordering of the memory reads and writes be controlled (can it?), so how =
is the=20
data modified within the lock protected area reflected in other=20
threads</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D948322108-30042004>In the =
example below=20
calling inc2 guarantees that the modified variable 'count' is consistent =
between=20
threads.</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D948322108-30042004>is the =
same true for=20
inc1</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D948322108-30042004>class =
x=20
{</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN =
class=3D948322108-30042004>&nbsp;&nbsp;&nbsp;=20
static int count =3D 1;</SPAN></FONT></DIV><FONT face=3DArial =
size=3D2><SPAN=20
class=3D948322108-30042004>
<DIV><FONT face=3DArial size=3D2><SPAN =
class=3D948322108-30042004>&nbsp;&nbsp;&nbsp;=20
public static inc1() {</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
Lock l =3D=20
...;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=20
l.lock();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try=20
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
//=20
access the resource protected by this lock</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs=
p;&nbsp;&nbsp;&nbsp;=20
count ++;</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs=
p;&nbsp;&nbsp;&nbsp;=20
return count;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } finally=20
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=20
l.unlock();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
}</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN =
class=3D948322108-30042004>&nbsp;&nbsp;&nbsp; }
<DIV><FONT face=3DArial size=3D2><SPAN =
class=3D948322108-30042004>&nbsp;&nbsp;&nbsp;=20
public synchronized static inc2() {</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
count=20
++;</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
return=20
count;<BR></SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN =
class=3D948322108-30042004>&nbsp;&nbsp;&nbsp;=20
}</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004>}</SPAN></FONT></DIV></SPAN></FONT></DIV>
<DIV></SPAN></FONT><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D948322108-30042004>My =
second question=20
is this. Why wasnt the lock included in the language as a construct. I=20
understand that there is a reluctance to add keywords to the language =
but=20
couldnt we have somethink like</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D948322108-30042004>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
Lock lock =3D=20
...;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronised : lock=20
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
//=20
access the resource protected by this lock</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=20
}</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D948322108-30042004>Yours=20
perplexed</SPAN></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><SPAN=20
class=3D948322108-30042004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2><SPAN class=3D948322108-30042004>Mike=20
Skells</SPAN></FONT></DIV></SPAN></FONT></DIV></BODY></HTML>

------=_NextPart_000_0055_01C42E99.611E0D90--



From matthias.ernst@coremedia.com  Fri Apr 30 10:21:01 2004
From: matthias.ernst@coremedia.com (Ernst, Matthias)
Date: Fri, 30 Apr 2004 11:21:01 +0200
Subject: [concurrency-interest] locks and the JMM
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDEF5@MARS.coremedia.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C42E95.19EF1737
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Internally, a lock synchronizes through atomic operations on volatile =
fields. As I understand it, JSR 133 specs reads and writes on volatiles =
to impose a global ordering as opposed to the current "spec". Thus two =
threads that synchronize via a Lock or any volatile will see the right =
things.=20
=20
BTW: this means that double-checked locking (on a volatile) finally =
works (does it?) ;-)
=20
Matthias
=20

------_=_NextPart_001_01C42E95.19EF1737
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Diso-8859-1">=0A=
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">=0A=
<HTML><HEAD>=0A=
=0A=
<TITLE>Message</TITLE>=0A=
=0A=
<META content=3D"MSHTML 6.00.2800.1400" name=3DGENERATOR></HEAD>=0A=
<BODY>=0A=
<DIV id=3DidOWAReplyText53683 dir=3Dltr>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 =
size=3D2>Internally, a lock =0A=
synchronizes through atomic operations on volatile fields. As I =
understand it, =0A=
JSR 133 specs reads and writes on volatiles to impose a global ordering =
as =0A=
opposed to the current "spec". Thus two threads that synchronize via a =
Lock or =0A=
any volatile will see the right things. </FONT></DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2>BTW: this means that =
double-checked =0A=
locking (on a volatile) finally works (does it?) ;-)</FONT></DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" =
size=3D2>Matthias</FONT></DIV></DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV></BODY></HTML>
------_=_NextPart_001_01C42E95.19EF1737--


From brian@quiotix.com  Fri Apr 30 11:25:43 2004
From: brian@quiotix.com (Brian Goetz)
Date: Fri, 30 Apr 2004 03:25:43 -0700
Subject: [concurrency-interest] locks and the JMM
In-Reply-To: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDEF5@MARS.coremedia.com>
References: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDEF5@MARS.coremedia.com>
Message-ID: <20040430102543.GE5745@lx.quiotix.com>

> Internally, a lock synchronizes through atomic operations on volatile fields. As I understand it, JSR 133 specs reads and writes on volatiles to impose a global ordering as opposed to the current "spec". Thus two threads that synchronize via a Lock or any volatile will see the right things. 
>  
> BTW: this means that double-checked locking (on a volatile) finally works (does it?) ;-)

It depends what you mean by "works". Technically, the idiom becomes
thread-safe under the new JMM when you make the holder field volatile.
However, the whole purpose of DCL was to be an optimization; between
the lower cost of uncontended sync in JVMs after 1.1 and the higher
cost of volatile as of JSR 133, it may not be aperformance win, and if
it is, it probably is small.  So I would contend that it is not a
successful idiom even if it is "correct".

From mike.skells@ebizz-consulting.com  Fri Apr 30 12:06:28 2004
From: mike.skells@ebizz-consulting.com (Mike Skells)
Date: Fri, 30 Apr 2004 12:06:28 +0100
Subject: [concurrency-interest] locks and the JMM
In-Reply-To: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDEF5@MARS.coremedia.com>
Message-ID: <006e01c42ea3$31d9f0d0$0100a8c0@mikework>

This is a multi-part message in MIME format.

------=_NextPart_000_006F_01C42EAB.939E58D0
Content-Type: text/plain;
	charset="us-ascii"
Content-Transfer-Encoding: 7bit

Hi Matthias,
Thanks for the answer, but it is not quite the question that I was
trying to ask!
 
I understand that the lock data structures work OK, but what about the
data that is protected by the lock, ie the int variable that I described
in the example
 
Mike

-----Original Message-----
From: concurrency-interest-admin@cs.oswego.edu
[mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf Of Ernst,
Matthias
Sent: Friday 30 April 2004 10:21
To: mike.skells@ebizz-consulting.com;
concurrency-interest@altair.cs.oswego.edu
Subject: RE: [concurrency-interest] locks and the JMM


Internally, a lock synchronizes through atomic operations on volatile
fields. As I understand it, JSR 133 specs reads and writes on volatiles
to impose a global ordering as opposed to the current "spec". Thus two
threads that synchronize via a Lock or any volatile will see the right
things. 
 
BTW: this means that double-checked locking (on a volatile) finally
works (does it?) ;-)
 
Matthias
 


------=_NextPart_000_006F_01C42EAB.939E58D0
Content-Type: text/html;
	charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Dus-ascii">
<TITLE>Message</TITLE>

<META content=3D"MSHTML 6.00.2800.1400" name=3DGENERATOR></HEAD>
<BODY>
<DIV><SPAN class=3D517020411-30042004><FONT face=3DArial color=3D#0000ff =
size=3D2>Hi=20
Matthias,</FONT></SPAN></DIV>
<DIV><SPAN class=3D517020411-30042004><FONT face=3DArial color=3D#0000ff =
size=3D2>Thanks=20
for the answer, but it is not quite the question that I was trying to=20
ask!</FONT></SPAN></DIV>
<DIV><SPAN class=3D517020411-30042004><FONT face=3DArial color=3D#0000ff =

size=3D2></FONT></SPAN>&nbsp;</DIV>
<DIV><SPAN class=3D517020411-30042004><FONT face=3DArial color=3D#0000ff =
size=3D2>I=20
understand that the lock data structures work OK, but what about the =
data that=20
is protected by the lock, ie the int variable that I described in the=20
example</FONT></SPAN></DIV>
<DIV><SPAN class=3D517020411-30042004><FONT face=3DArial color=3D#0000ff =

size=3D2></FONT></SPAN>&nbsp;</DIV>
<DIV><SPAN class=3D517020411-30042004><FONT face=3DArial color=3D#0000ff =

size=3D2>Mike</FONT></SPAN></DIV>
<BLOCKQUOTE dir=3Dltr=20
style=3D"PADDING-LEFT: 5px; MARGIN-LEFT: 5px; BORDER-LEFT: #0000ff 2px =
solid; MARGIN-RIGHT: 0px">
  <DIV></DIV>
  <DIV class=3DOutlookMessageHeader lang=3Den-us dir=3Dltr =
align=3Dleft><FONT=20
  face=3DTahoma size=3D2>-----Original Message-----<BR><B>From:</B>=20
  concurrency-interest-admin@cs.oswego.edu=20
  [mailto:concurrency-interest-admin@cs.oswego.edu] <B>On Behalf Of =
</B>Ernst,=20
  Matthias<BR><B>Sent:</B> Friday 30 April 2004 10:21<BR><B>To:</B>=20
  mike.skells@ebizz-consulting.com;=20
  concurrency-interest@altair.cs.oswego.edu<BR><B>Subject:</B> RE:=20
  [concurrency-interest] locks and the JMM<BR><BR></FONT></DIV>
  <DIV id=3DidOWAReplyText53683 dir=3Dltr>
  <DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 =
size=3D2>Internally, a lock=20
  synchronizes through atomic operations on volatile fields. As I =
understand it,=20
  JSR 133 specs reads and writes on volatiles to impose a global =
ordering as=20
  opposed to the current "spec". Thus two threads that synchronize via a =
Lock or=20
  any volatile will see the right things. </FONT></DIV>
  <DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>
  <DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2>BTW: this means =
that=20
  double-checked locking (on a volatile) finally works (does it?)=20
  ;-)</FONT></DIV>
  <DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>
  <DIV dir=3Dltr><FONT face=3D"Courier New" =
size=3D2>Matthias</FONT></DIV></DIV>
  <DIV dir=3Dltr>&nbsp;</DIV></BLOCKQUOTE></BODY></HTML>

------=_NextPart_000_006F_01C42EAB.939E58D0--



From matthias.ernst@coremedia.com  Fri Apr 30 12:13:30 2004
From: matthias.ernst@coremedia.com (Ernst, Matthias)
Date: Fri, 30 Apr 2004 13:13:30 +0200
Subject: [concurrency-interest] locks and the JMM
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDEF7@MARS.coremedia.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C42EA4.938A25EB
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Sorry if I didn't make myself clear. The fact that the lock operates on =
a volatile makes *all* heap accesses consistent, even to 'count'.=20
=20
BTW, I assume correctly that your code does not allocate a new Lock in =
'...' every time !?
=20
Matthias
=20

------_=_NextPart_001_01C42EA4.938A25EB
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Diso-8859-1">=0A=
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">=0A=
<HTML><HEAD>=0A=
=0A=
<TITLE>Message</TITLE>=0A=
=0A=
<META content=3D"MSHTML 6.00.2800.1400" name=3DGENERATOR></HEAD>=0A=
<BODY>=0A=
<DIV id=3DidOWAReplyText28438 dir=3Dltr>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 size=3D2>Sorry =
if I didn't =0A=
make myself clear. The fact that the lock operates on a volatile makes =
*all* =0A=
heap accesses consistent, even to 'count'. </FONT></DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 =
size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 size=3D2>BTW, =
I assume =0A=
correctly that your code does not allocate a new Lock in '...' every =
time =0A=
!?</FONT></DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2>Matthias</FONT></DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV></DIV></BODY></HTML>
------_=_NextPart_001_01C42EA4.938A25EB--


From mike.skells@ebizz-consulting.com  Fri Apr 30 12:54:21 2004
From: mike.skells@ebizz-consulting.com (Mike Skells)
Date: Fri, 30 Apr 2004 12:54:21 +0100
Subject: [concurrency-interest] locks and the JMM
In-Reply-To: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDEF7@MARS.coremedia.com>
Message-ID: <007901c42ea9$e27d9c10$0100a8c0@mikework>

This is a multi-part message in MIME format.

------=_NextPart_000_007A_01C42EB2.44420410
Content-Type: text/plain;
	charset="us-ascii"
Content-Transfer-Encoding: 7bit

I presume that by heap you mean thread local
I was not aware that volatile forced all thread local variables to be
flushed to the global memory from the thread memory ( ie processor cache
purge) I presumed that a volatile write caused the volatile to be
written only ( the old JMM) 
I have now read the new JMM FAQ on volatile
 
 
The code was just make up, Ihave only just come across this JSR!
 
Thanks 
Mike

-----Original Message-----
From: concurrency-interest-admin@cs.oswego.edu
[mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf Of Ernst,
Matthias
Sent: Friday 30 April 2004 12:14
To: mike.skells@ebizz-consulting.com;
concurrency-interest@altair.cs.oswego.edu
Subject: RE: [concurrency-interest] locks and the JMM


Sorry if I didn't make myself clear. The fact that the lock operates on
a volatile makes *all* heap accesses consistent, even to 'count'. 
 
BTW, I assume correctly that your code does not allocate a new Lock in
'...' every time !?
 
Matthias
 


------=_NextPart_000_007A_01C42EB2.44420410
Content-Type: text/html;
	charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Dus-ascii">
<TITLE>Message</TITLE>

<META content=3D"MSHTML 6.00.2800.1400" name=3DGENERATOR></HEAD>
<BODY>
<DIV><SPAN class=3D898163911-30042004><FONT face=3DArial color=3D#0000ff =
size=3D2>I=20
presume that by heap you mean thread local</FONT></SPAN></DIV>
<DIV><SPAN class=3D898163911-30042004><FONT face=3DArial color=3D#0000ff =
size=3D2>I was=20
not aware that volatile forced all thread local variables to be flushed =
to the=20
global memory from the thread memory ( ie processor cache purge) I =
presumed that=20
a volatile write caused the volatile to be written only ( the old JMM)=20
</FONT></SPAN></DIV>
<DIV><SPAN class=3D898163911-30042004><FONT face=3DArial color=3D#0000ff =
size=3D2>I have=20
now read the new JMM FAQ on volatile</FONT></SPAN></DIV>
<DIV><SPAN class=3D898163911-30042004><FONT face=3DArial color=3D#0000ff =

size=3D2></FONT></SPAN>&nbsp;</DIV>
<DIV><SPAN class=3D898163911-30042004><FONT face=3DArial color=3D#0000ff =

size=3D2></FONT></SPAN>&nbsp;</DIV>
<DIV><SPAN class=3D898163911-30042004><FONT face=3DArial color=3D#0000ff =
size=3D2>The=20
code was just make up, Ihave only just come across this =
JSR!</FONT></SPAN></DIV>
<DIV><SPAN class=3D898163911-30042004><FONT face=3DArial color=3D#0000ff =

size=3D2></FONT></SPAN>&nbsp;</DIV>
<DIV><SPAN class=3D898163911-30042004><FONT face=3DArial color=3D#0000ff =
size=3D2>Thanks=20
</FONT></SPAN></DIV>
<DIV><SPAN class=3D898163911-30042004><FONT face=3DArial color=3D#0000ff =

size=3D2>Mike</FONT></SPAN></DIV>
<BLOCKQUOTE dir=3Dltr=20
style=3D"PADDING-LEFT: 5px; MARGIN-LEFT: 5px; BORDER-LEFT: #0000ff 2px =
solid; MARGIN-RIGHT: 0px">
  <DIV></DIV>
  <DIV class=3DOutlookMessageHeader lang=3Den-us dir=3Dltr =
align=3Dleft><FONT=20
  face=3DTahoma size=3D2>-----Original Message-----<BR><B>From:</B>=20
  concurrency-interest-admin@cs.oswego.edu=20
  [mailto:concurrency-interest-admin@cs.oswego.edu] <B>On Behalf Of =
</B>Ernst,=20
  Matthias<BR><B>Sent:</B> Friday 30 April 2004 12:14<BR><B>To:</B>=20
  mike.skells@ebizz-consulting.com;=20
  concurrency-interest@altair.cs.oswego.edu<BR><B>Subject:</B> RE:=20
  [concurrency-interest] locks and the JMM<BR><BR></FONT></DIV>
  <DIV id=3DidOWAReplyText28438 dir=3Dltr>
  <DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 =
size=3D2>Sorry if I didn't=20
  make myself clear. The fact that the lock operates on a volatile makes =
*all*=20
  heap accesses consistent, even to 'count'. </FONT></DIV>
  <DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 =
size=3D2></FONT>&nbsp;</DIV>
  <DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 =
size=3D2>BTW, I assume=20
  correctly that your code does not allocate a new Lock in '...' every =
time=20
  !?</FONT></DIV>
  <DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>
  <DIV dir=3Dltr><FONT face=3D"Courier New" =
size=3D2>Matthias</FONT></DIV>
  <DIV dir=3Dltr>&nbsp;</DIV></DIV></BLOCKQUOTE></BODY></HTML>

------=_NextPart_000_007A_01C42EB2.44420410--



From brian@quiotix.com  Fri Apr 30 23:54:32 2004
From: brian@quiotix.com (Brian Goetz)
Date: Fri, 30 Apr 2004 15:54:32 -0700
Subject: [concurrency-interest] locks and the JMM
In-Reply-To: <005401c42e90$ff59a590$0100a8c0@mikework>
References: <005401c42e90$ff59a590$0100a8c0@mikework>
Message-ID: <20040430225432.GA17040@lx.quiotix.com>

> How is this accomplished with the use of locks. As a lock is not a
> language construct, the ordering of the memory reads and writes be
> controlled (can it?), so how is the data modified within the lock
> protected area reflected in other threads

JSR 166 included some JVM improvements, including some low-level tools
for building lock classes which are employed by Lock implementations.

> My second question is this. Why wasnt the lock included in the language
> as a construct. I understand that there is a reluctance to add keywords
> to the language but couldnt we have somethink like

For exactly the reasons you state -- the bar for changing the language
is pretty high, and it was possible to add locks without adding any 
new constructs.  

THe change you suggest could be entirely implemented in the compiler (as
were many of the other 1.5 language changes) and so it is possible such
a change could be introduced later.

