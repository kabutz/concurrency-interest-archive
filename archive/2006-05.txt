From josh at bloch.us  Mon May  1 02:35:03 2006
From: josh at bloch.us (Joshua Bloch)
Date: Mon May  1 02:35:08 2006
Subject: [concurrency-interest] ConcurrentNavigableMap additional methods:
	6415641
In-Reply-To: <44553A4A.8000806@cs.oswego.edu>
References: <BAY105-F13A4F1376C34D29C74DD9F83BD0@phx.gbl>
	<44553A4A.8000806@cs.oswego.edu>
Message-ID: <b097ac510604302335g50feaebfs31c21eab5e45d271@mail.gmail.com>

Congrats Jason!  Did you get the machine?  Way cool.

That said, I'm with Doug and Tim on this API issue.

        Regards,

        Josh

On 4/30/06, Doug Lea <dl@cs.oswego.edu> wrote:
> Jason Mehrens wrote:
> > The only use case I can think of would be clearing a global cache and using
> > the resulting Map to log the entries ejected from the cache at that point in
> > time.  ...  Which is why it "might" be useful to have a drainTo specified in
> > the interface.
>
> Well, I'm afraid I'm with Tim that it's probably not worth adding to API.
> If there were such a thing as a BlockingNavigableMap
> (i.e., that extended ConcurrentNavigableMap to support
> methods like takeFirst), then drainTo should
> surely be in such an API. But no one has asked us for such
> a thing yet.
>
> (BTW, everyone should congratulate Jason for winning the Sun Mustang
> Regression contest by pointing out failure to maintain interrupt
> conventions in our SynchronousQueue update!)
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From jason_mehrens at hotmail.com  Mon May  1 10:59:43 2006
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Mon May  1 10:59:54 2006
Subject: [concurrency-interest] ConcurrentNavigableMap additional methods:
	6415641
Message-ID: <BAY105-F28DA9EDF9388DA68C4C8A683B10@phx.gbl>

Thanks Josh and Doug for the congrats and the API review.

I haven't received the machine yet.  It would be funny if it arrives the 
week of Java ONE.

Process.waitFor has the same issue (in 5.0 and 6.0) but the bug report 
(503840) I filled for it wasn't accepted. I find that funny since the 
SynchronousQueue bug was a winner.

Regards,

Jason


>From: "Joshua Bloch" <josh@bloch.us>
>To: "Doug Lea" <dl@cs.oswego.edu>
>CC: "Jason Mehrens" <jason_mehrens@hotmail.com>, 
>concurrency-interest@cs.oswego.edu
>Subject: Re: [concurrency-interest] ConcurrentNavigableMap additional 
>methods: 6415641
>Date: Sun, 30 Apr 2006 23:35:03 -0700
>
>Congrats Jason!  Did you get the machine?  Way cool.
>
>That said, I'm with Doug and Tim on this API issue.
>
>        Regards,
>
>        Josh
>
>On 4/30/06, Doug Lea <dl@cs.oswego.edu> wrote:
>>Jason Mehrens wrote:
>> > The only use case I can think of would be clearing a global cache and 
>>using
>> > the resulting Map to log the entries ejected from the cache at that 
>>point in
>> > time.  ...  Which is why it "might" be useful to have a drainTo 
>>specified in
>> > the interface.
>>
>>Well, I'm afraid I'm with Tim that it's probably not worth adding to API.
>>If there were such a thing as a BlockingNavigableMap
>>(i.e., that extended ConcurrentNavigableMap to support
>>methods like takeFirst), then drainTo should
>>surely be in such an API. But no one has asked us for such
>>a thing yet.
>>
>>(BTW, everyone should congratulate Jason for winning the Sun Mustang
>>Regression contest by pointing out failure to maintain interrupt
>>conventions in our SynchronousQueue update!)
>>
>>-Doug
>>_______________________________________________
>>Concurrency-interest mailing list
>>Concurrency-interest@altair.cs.oswego.edu
>>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>


From the.mindstorm.mailinglist at gmail.com  Mon May  1 13:28:38 2006
From: the.mindstorm.mailinglist at gmail.com (Alexandru Popescu)
Date: Mon May  1 13:28:43 2006
Subject: [concurrency-interest] implementing a DB write-behind algorithm
In-Reply-To: <63b4e4050604301136hdbe14b5je76bf4ea10f088e9@mail.gmail.com>
References: <c6f400460604300637s11032d5ah8583355f8cbc7990@mail.gmail.com>
	<63b4e4050604301136hdbe14b5je76bf4ea10f088e9@mail.gmail.com>
Message-ID: <c6f400460605011028q4f78ecc6h134dcad24d5a3886@mail.gmail.com>

One more question about the code sample: what is the
[code]@GuardedBy("this")[/code] annotation responsible for? Mark that
any operations on that field must be synched?

./alex
--
.w( the_mindstorm )p.


On 4/30/06, Tim Peierls <tim@peierls.net> wrote:
> On 4/30/06, Alexandru Popescu
> <the.mindstorm.mailinglist@gmail.com > wrote:
>
> > I firstly have to confess that when getting to concurrency related
> > problems, I am getting confused quite quickly :-).
>
>
> You're not alone! :-)
>
>
> > Now, the current problem I am trying to solve is: I am trying to
> > figure out how to implement a DB write-behind strategy. Multiple
> > processes will post records to be written to the DB, but the actual
> > writes should happen on a separate process. So, far I was thinking
> > about 2 possible approaches:
> > a) continous write-behind: multiple processes write to a queue which
> > is continously polled by a separate process. When an element is found
> > on the queue, than the write process removes it from queue and
> > attempts to write it to the DB.
> >
> > To have this done, I was looking in the direction of
> ConcurrentLinkedQueue.
> >
> > b) batched write-behind: multiple processes post to a size-bounded
> > queue. When the max size is reached, the original queue is passed to
> > the parallel write process and replaced with a new queue.
> >
> > To have this done, I was looking in the direction of
> > LinkedBlockingQueue with an additional atomic operation of swapping
> > the old queue with the new empty one.
> >
> > My question is: am I looking in the right direction or I am completely
> > wrong. Any ideas and help are highly appreciated.
> >
>
> The use of BlockingQueue.put makes it possible to implement strategies that
> make the caller block, while still permitting strategies that don't block.
> So I would avoid ConcurrentLinkedQueue here, because it does not implement
> the BlockingQueue interface.
>
> You can use an unbounded LinkedBlockingQueue for continuous write-behind,
> and ArrayBlockingQueue (always bounded) for batched write-behind. Instead of
> swapping in a new queue, the consumer thread could just poll until the batch
> size was reached (using a timeout to avoid the risk of batches never
> completing), and then send the batch. The batch size need not be the same as
> the queue capacity.
>
> Here's an uncompiled, untested fragment that illustrates the idea:
>
>  public interface WriteBehind<T> {
>     void put(T record) throws InterruptedException;
> }
>
> public interface RecordWriter<T> {
>     void write(List<T> records) throws InterruptedException;
>  }
>
> class AbstractWriteBehind<T> implements WriteBehind<T> {
>     private final BlockingQueue<T> queue;
>     private final RecordWriter<T> writer;
>     @GuardedBy("this") private Future<Void> consumer = null;
>
>     protected AbstractWriteBehind(BlockingQueue<T> queue,
> RecordWriter<T> writer) {
>         this.queue = queue;
>         this.writer = writer;
>     }
>
>     class Consumer implements Callable<Void> {
>         public Void call() throws InterruptedException {
>             consume(queue, writer);
>             return null;
>         }
>     }
>
>     public synchronized void start() {
>         if (consumer == null) {
>             ExecutorService exec =
> Executors.newSingleThreadExecutor();
>             try {
>                 consumer = exec.submit(new Consumer());
>             } finally {
>                 exec.shutdown();
>              }
>         }
>     }
>
>     public synchronized boolean isRunning() {
>         return consumer != null;
>     }
>
>     public synchronized void stop() {
>         if (consumer != null) {
>             consumer.cancel(true);
>             consumer = null;
>         }
>     }
>
>     public final void put(T record) throws InterruptedException {
>         queue.put(record);
>     }
>
>     protected abstract void consume(BlockingQueue<T> queue, RecordWriter<T>
> writer)
>         throws InterruptedException;
> }
>
> class ContinuousWriteBehind<T> extends AbstractWriteBehind<T> {
>     ContinousWriteBehind(RecordWriter<T> writer) {
>         super(new LinkedBlockingQueue<T>(), writer);
>     }
>
>     protected void consume(BlockingQueue<T> q, RecordWriter<T> writer)
>             throws InterruptedException {
>         for (T rec; (rec = q.take()) != null; )
>             writer.write (Collections.singletonList(rec));
>     }
> }
>
> class BatchedWriteBehind<T> extends AbstractWriteBehind<T> {
>     private final int maxBuf;
>     private final List<T> buf;
>     private final long time;
>     private final TimeUnit unit;
>
>     BatchedWriteBehind(RecordWriter<T> writer, int
> capacity, int maxBuf,
>                        long time, TimeUnit unit) {
>         super(new ArrayBlockingQueue<T>(capacity), writer);
>         this.maxBuf = maxBuf;
>         this.buf = new ArrayList<T>(maxBuf);
>         this.time = time;
>         this.unit = unit;
>     }
>
>     protected void consume(BlockingQueue<T> q, RecordWriter<T> writer)
>             throws InterruptedException {
>         for (T rec; (rec = q.take()) != null; ) {
>             buf.add(rec);
>             while (buf.size() < maxBuf && (rec = q.poll(time, unit)) !=
> null)
>                  buf.add(rec);
>             writer.write(buf);
>             buf.clear();
>         }
>     }
> }
>
>  --tim
>

From tim at peierls.net  Mon May  1 17:15:35 2006
From: tim at peierls.net (Tim Peierls)
Date: Mon May  1 17:15:45 2006
Subject: [concurrency-interest] implementing a DB write-behind algorithm
In-Reply-To: <c6f400460605011028q4f78ecc6h134dcad24d5a3886@mail.gmail.com>
References: <c6f400460604300637s11032d5ah8583355f8cbc7990@mail.gmail.com>
	<63b4e4050604301136hdbe14b5je76bf4ea10f088e9@mail.gmail.com>
	<c6f400460605011028q4f78ecc6h134dcad24d5a3886@mail.gmail.com>
Message-ID: <63b4e4050605011415q69ddbdcex15b9974d1c3a67a2@mail.gmail.com>

Short answer: Yes.

Longer answer:
<shamelessPlug>
We introduce the @GuardedBy annotation in Java Concurrency in Practice.
@GuardedBy(lock) documents that a field or method should be accessed only
with the specific lock held. In particular, @GuardedBy("this") means that
all accesses must be done while holding the intrinsic lock of the containing
object. Documenting the synchronization policy of a class through such
annotations makes it easier to reason about its correctness and easier to
maintain the class without breaking it.

All non-volatile, non-final fields of a class that can be accessed by
multiple threads must be guarded in this way. In that code example, the
start, stop, and isRunning methods all access the consumer field. I would
have made the field volatile, but the first two methods are check-then-act
sequences that must be performed atomically with respect to each other, so
volatile isn't enough in this case.
</shamelessPlug>

Regarding your concern about polling from the database writer thread:

BlockingQueue is generally the appropriate interface to use when dealing
with producer-consumer designs, because it gives you the most flexibility in
dealing with overproduction (producers adding work faster than consumers can
process it) or underproduction (consumers processing work faster than
producers can supply them).  It's perfectly reasonable for a consumer thread
to loop calling take() and timed poll(). You normally don't want to spin in
an untimed poll() loop -- but that's what you'd be forced to do with a
ConcurrentLinkedQueue.

As Richie Jefts hinted, you should to be prepared to handle saturation from
the upstream (producer) end. You have two main choices: use a timed
queue.put() behind the scenes and throw an application-level checked
exception on timeout -- forcing clients to catch that checked exception --
or simply use an untimed queue.put() and document that WriteBehind.put can
block indefinitely by putting "throws InterruptedException" in the
signature, as in the sample code.

--tim



On 5/1/06, Alexandru Popescu <the.mindstorm.mailinglist@gmail.com> wrote:
>
> One more question about the code sample: what is the
> [code]@GuardedBy("this")[/code] annotation responsible for? Mark that
> any operations on that field must be synched?
>
> ./alex
> --
> .w( the_mindstorm )p.
>
>
> On 4/30/06, Tim Peierls <tim@peierls.net> wrote:
> > On 4/30/06, Alexandru Popescu
> > <the.mindstorm.mailinglist@gmail.com > wrote:
> >
> > > I firstly have to confess that when getting to concurrency related
> > > problems, I am getting confused quite quickly :-).
> >
> >
> > You're not alone! :-)
> >
> >
> > > Now, the current problem I am trying to solve is: I am trying to
> > > figure out how to implement a DB write-behind strategy. Multiple
> > > processes will post records to be written to the DB, but the actual
> > > writes should happen on a separate process. So, far I was thinking
> > > about 2 possible approaches:
> > > a) continous write-behind: multiple processes write to a queue which
> > > is continously polled by a separate process. When an element is found
> > > on the queue, than the write process removes it from queue and
> > > attempts to write it to the DB.
> > >
> > > To have this done, I was looking in the direction of
> > ConcurrentLinkedQueue.
> > >
> > > b) batched write-behind: multiple processes post to a size-bounded
> > > queue. When the max size is reached, the original queue is passed to
> > > the parallel write process and replaced with a new queue.
> > >
> > > To have this done, I was looking in the direction of
> > > LinkedBlockingQueue with an additional atomic operation of swapping
> > > the old queue with the new empty one.
> > >
> > > My question is: am I looking in the right direction or I am completely
> > > wrong. Any ideas and help are highly appreciated.
> > >
> >
> > The use of BlockingQueue.put makes it possible to implement strategies
> that
> > make the caller block, while still permitting strategies that don't
> block.
> > So I would avoid ConcurrentLinkedQueue here, because it does not
> implement
> > the BlockingQueue interface.
> >
> > You can use an unbounded LinkedBlockingQueue for continuous
> write-behind,
> > and ArrayBlockingQueue (always bounded) for batched write-behind.
> Instead of
> > swapping in a new queue, the consumer thread could just poll until the
> batch
> > size was reached (using a timeout to avoid the risk of batches never
> > completing), and then send the batch. The batch size need not be the
> same as
> > the queue capacity.
> >
> > Here's an uncompiled, untested fragment that illustrates the idea:
> >
> >  public interface WriteBehind<T> {
> >     void put(T record) throws InterruptedException;
> > }
> >
> > public interface RecordWriter<T> {
> >     void write(List<T> records) throws InterruptedException;
> >  }
> >
> > class AbstractWriteBehind<T> implements WriteBehind<T> {
> >     private final BlockingQueue<T> queue;
> >     private final RecordWriter<T> writer;
> >     @GuardedBy("this") private Future<Void> consumer = null;
> >
> >     protected AbstractWriteBehind(BlockingQueue<T> queue,
> > RecordWriter<T> writer) {
> >         this.queue = queue;
> >         this.writer = writer;
> >     }
> >
> >     class Consumer implements Callable<Void> {
> >         public Void call() throws InterruptedException {
> >             consume(queue, writer);
> >             return null;
> >         }
> >     }
> >
> >     public synchronized void start() {
> >         if (consumer == null) {
> >             ExecutorService exec =
> > Executors.newSingleThreadExecutor();
> >             try {
> >                 consumer = exec.submit(new Consumer());
> >             } finally {
> >                 exec.shutdown();
> >              }
> >         }
> >     }
> >
> >     public synchronized boolean isRunning() {
> >         return consumer != null;
> >     }
> >
> >     public synchronized void stop() {
> >         if (consumer != null) {
> >             consumer.cancel(true);
> >             consumer = null;
> >         }
> >     }
> >
> >     public final void put(T record) throws InterruptedException {
> >         queue.put(record);
> >     }
> >
> >     protected abstract void consume(BlockingQueue<T> queue,
> RecordWriter<T>
> > writer)
> >         throws InterruptedException;
> > }
> >
> > class ContinuousWriteBehind<T> extends AbstractWriteBehind<T> {
> >     ContinousWriteBehind(RecordWriter<T> writer) {
> >         super(new LinkedBlockingQueue<T>(), writer);
> >     }
> >
> >     protected void consume(BlockingQueue<T> q, RecordWriter<T> writer)
> >             throws InterruptedException {
> >         for (T rec; (rec = q.take()) != null; )
> >             writer.write (Collections.singletonList(rec));
> >     }
> > }
> >
> > class BatchedWriteBehind<T> extends AbstractWriteBehind<T> {
> >     private final int maxBuf;
> >     private final List<T> buf;
> >     private final long time;
> >     private final TimeUnit unit;
> >
> >     BatchedWriteBehind(RecordWriter<T> writer, int
> > capacity, int maxBuf,
> >                        long time, TimeUnit unit) {
> >         super(new ArrayBlockingQueue<T>(capacity), writer);
> >         this.maxBuf = maxBuf;
> >         this.buf = new ArrayList<T>(maxBuf);
> >         this.time = time;
> >         this.unit = unit;
> >     }
> >
> >     protected void consume(BlockingQueue<T> q, RecordWriter<T> writer)
> >             throws InterruptedException {
> >         for (T rec; (rec = q.take()) != null; ) {
> >             buf.add(rec);
> >             while (buf.size() < maxBuf && (rec = q.poll(time, unit)) !=
> > null)
> >                  buf.add(rec);
> >             writer.write(buf);
> >             buf.clear();
> >         }
> >     }
> > }
> >
> >  --tim
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060501/b0719e42/attachment-0001.html
From brian at quiotix.com  Mon May  1 17:15:41 2006
From: brian at quiotix.com (Brian Goetz)
Date: Mon May  1 17:18:44 2006
Subject: [concurrency-interest] implementing a DB write-behind algorithm
In-Reply-To: <c6f400460605011028q4f78ecc6h134dcad24d5a3886@mail.gmail.com>
References: <c6f400460604300637s11032d5ah8583355f8cbc7990@mail.gmail.com>	<63b4e4050604301136hdbe14b5je76bf4ea10f088e9@mail.gmail.com>
	<c6f400460605011028q4f78ecc6h134dcad24d5a3886@mail.gmail.com>
Message-ID: <44567A7D.3050902@quiotix.com>

> One more question about the code sample: what is the
> [code]@GuardedBy("this")[/code] annotation responsible for? Mark that
> any operations on that field must be synched?

This is an annotation we introduce in the book.

@ThreadSafe
public class Counter {
   @GuardedBy("this") private int value;

   public synchronized int getNext() { return value++; }
}

In this case, we say value is guarded-by 'this' because we achieve 
thread safety by ensuring that whenever a thread accesses value, it must 
hold the Counter lock.  Its a way of documenting your synchroinzation 
policy, so that when the class is extended/maintained, you know how the 
locks are used to ensure thread safety and therefore are less likely to 
break it.
From studdugie at gmail.com  Mon May  1 19:39:32 2006
From: studdugie at gmail.com (studdugie)
Date: Mon May  1 19:39:40 2006
Subject: [concurrency-interest] implementing a DB write-behind algorithm
In-Reply-To: <c6f400460604300637s11032d5ah8583355f8cbc7990@mail.gmail.com>
References: <c6f400460604300637s11032d5ah8583355f8cbc7990@mail.gmail.com>
Message-ID: <5a59ce530605011639j1375b9cdwc5ebe772f8919c1a@mail.gmail.com>

Another option is to use a CLQ w/ an AtomicBoolean or (now that I
think about it) an AtomicInteger (AI).

The logic goes like this. Thread has database write so it increments
AtomicInteger and compares it against guard variable
(MAX_CONCURR_WRITERS). If AI <= MAX_CONCURR_WRITERS then enter write
loop and drain the CLQ.

The code may look something like this.

void dbPut(DbData data)
{
    dbWriteCLQ.offer( data );

    try
    {
        if(AI.incrementAndGet() <= MAX_CONCURR_WRITERS )
            while(null !=(data = dbWriteCLQ.poll()))
                doDatabaseWrite( data );
    }
    finally
    {
        AI.decrementAndGet();
    }
}

I call it the hijack approach because instead of having one or more
specialist threads to do the job you use a CAS to "hijack" any thread
that happens to be passing by at the wrong (or right) place at the
wrong (or right) time.

Like I said in the first paragraph, you could also use an
AtomicBoolean to do the hijacking (CAS) but that limits you to one
thread.

Obviously hijacking isn't the best solution all the time because
you've pulled a thread away from its normal flow and that flow may be
time sensitive (ex. responding to an HTTP request). But if you have
complete control over every thread that can get hijacked you may be
able to get away w/ it. Your best bet (as always) is slap a profiler
on the code w/ varying loads after you've determined your throughput
minimum.

Love, peace, and hair grease,

Dane

On 4/30/06, Alexandru Popescu <the.mindstorm.mailinglist@gmail.com> wrote:
> Hi!
>
> I firstly have to confess that when getting to concurrency related
> problems, I am getting confused quite quickly :-).
>
> Now, the current problem I am trying to solve is: I am trying to
> figure out how to implement a DB write-behind strategy. Multiple
> processes will post records to be written to the DB, but the actual
> writes should happen on a separate process. So, far I was thinking
> about 2 possible approaches:
> a) continous write-behind: multiple processes write to a queue which
> is continously polled by a separate process. When an element is found
> on the queue, than the write process removes it from queue and
> attempts to write it to the DB.
>
> To have this done, I was looking in the direction of ConcurrentLinkedQueue.
>
> b) batched write-behind: multiple processes post to a size-bounded
> queue. When the max size is reached, the original queue is passed to
> the parallel write process and replaced with a new queue.
>
> To have this done, I was looking in the direction of
> LinkedBlockingQueue with an additional atomic operation of swapping
> the old queue with the new empty one.
>
> My question is: am I looking in the right direction or I am completely
> wrong. Any ideas and help are highly appreciated.
>
> ./alex
> --
> .w( the_mindstorm )p.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From mike.skells at validsoft.com  Tue May  2 05:31:01 2006
From: mike.skells at validsoft.com (Mike Skells)
Date: Tue May  2 06:52:29 2006
Subject: [concurrency-interest] Backport limitations
Message-ID: <01c101c66dcb$20538150$0b02a8c0@MikeSkellsLT>

Hi 
I noticed (which backporting some code) that the semaphores do not allow for
multi acquires
 
Is there a specific reason for this is it just lack of dev resources. I use
this is current J5 code and I am looking to not try to rewrite that code to
do the backport
 
Mike
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060502/4810ab1e/attachment.html
From bsder at allcaps.org  Tue May  2 19:06:14 2006
From: bsder at allcaps.org (Andrew Lentvorski)
Date: Tue May  2 19:06:11 2006
Subject: [concurrency-interest] backport: unchecked exceptions swallowed
	by	executor service
In-Reply-To: <200604051620.k35GKKvW020224@e450.epcc.ed.ac.uk>
References: <200604051620.k35GKKvW020224@e450.epcc.ed.ac.uk>
Message-ID: <4457E5E6.10308@allcaps.org>

Tom Sugden wrote:
> Hi,
> 
> I was surprised by the behaviour that occurs when an unchecked exception is
> raised by an overridden implementation of FutureTask#done() method. The
> exception seems to be swallowed and the executor maintains a user thread for
> some time afterwards. This isn't causing any problems for me at the moment,
> but I was just wondering whether it was the intended behaviour? It could be
> difficult to debug if your done() implementation had a programming error
> that raised an unchecked exception.

I got burnt by something similar.  The big problem is that you get into 
the habit of assuming that unchecked exceptions will always squawk when 
programming Java.  That fails when you start using concurrent.

I understand *why* they needed to use Exception, but, man, the first 
time you get burnt by a NullPointerException which silently shuts down 
your Callable you pull your hair out.

I now wrap all code that might let exceptions into Executor/Callables 
like so:

> 		public Object captiveCall() throws InterruptedException, IOException {
> 			return obj;
> 		}
> 		
> 		public Object call() throws Exception {
> 			Object retval = null;
> 			try {
> 				retval = captiveCall();
> 			} catch (InterruptedException e) {
> 				l4j.debug("InterruptedException", e);
> 				throw e;
> 			} catch (IOException e) {
> 				l4j.debug("IOException", e);
> 				throw e;
> 			} catch (Exception e) {
> 				// This normally bad code of catch on Exception is here for a *reason*.
> 				// Future *eats* all exceptions *silently*.  This clause at least allows
> 				// the exception to emit noise for debugging.  This is particularly pernicious
> 				// if you have something like a NullPointerException
> 				l4j.debug("Exception", e);
> 				throw e;
> 			}
> 
> 			return retval;
> 		}

-a
From gergg at cox.net  Tue May  2 19:34:43 2006
From: gergg at cox.net (Gregg Wonderly)
Date: Tue May  2 19:34:53 2006
Subject: [concurrency-interest] backport: unchecked exceptions swallowed
	by	executor service
In-Reply-To: <4457E5E6.10308@allcaps.org>
References: <200604051620.k35GKKvW020224@e450.epcc.ed.ac.uk>
	<4457E5E6.10308@allcaps.org>
Message-ID: <4457EC93.4000609@cox.net>

Andrew Lentvorski wrote:
> I now wrap all code that might let exceptions into Executor/Callables 
> like so:
> 
>>         public Object captiveCall() throws InterruptedException, 
>> IOException {
>>             return obj;
>>         }
>>        
>>         public Object call() throws Exception {
>>             Object retval = null;
>>             try {
>>                 retval = captiveCall();
>>             } catch (InterruptedException e) {

This is an important pattern to utilize.  It allows you to focus your exception 
processing for your application, and then if you make the captiveCall method 
public, other applications that need different exception processing can do that. 
  I've done this for quite some time, and it is nice to see this issue come up 
on this list so that others can see this concept.

Gregg Wonderly
From joe.bowbeer at gmail.com  Tue May  2 20:06:22 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue May  2 20:06:26 2006
Subject: [concurrency-interest] backport: unchecked exceptions swallowed
	by executor service
In-Reply-To: <4457E5E6.10308@allcaps.org>
References: <200604051620.k35GKKvW020224@e450.epcc.ed.ac.uk>
	<4457E5E6.10308@allcaps.org>
Message-ID: <31f2a7bd0605021706r86c20f2y4b24e34b8b775802@mail.gmail.com>

On 5/2/06, Andrew Lentvorski <bsder@allcaps.org> wrote:
>
> I now wrap all code that might let exceptions into Executor/Callables
> like so:

FutureTask can also be thought of as a "captive" Callable.  And
captive Runnable as well (don't forget the unchecked exceptions...).

The standard FutureTask isn't as proactive as your creation when it
comes to reporting the exceptions, though.  It relies on someone to
check the result and deal with the exception at that time.

If you're not checking the results of the task explicitly, the I would
still recommend (even in light of Tom Sugden's message) overriding
done() to handle exceptions proactively.

=> Then, if you want to go one step further, to report exceptions
thrown in done(), for example, you can override the afterExecute
method of the ThreadPoolExecutor.


On 5/2/06, Andrew Lentvorski <bsder@allcaps.org> wrote:
> Tom Sugden wrote:
> > Hi,
> >
> > I was surprised by the behaviour that occurs when an unchecked exception is
> > raised by an overridden implementation of FutureTask#done() method. The
> > exception seems to be swallowed and the executor maintains a user thread for
> > some time afterwards. This isn't causing any problems for me at the moment,
> > but I was just wondering whether it was the intended behaviour? It could be
> > difficult to debug if your done() implementation had a programming error
> > that raised an unchecked exception.
>
> I got burnt by something similar.  The big problem is that you get into
> the habit of assuming that unchecked exceptions will always squawk when
> programming Java.  That fails when you start using concurrent.
>
> I understand *why* they needed to use Exception, but, man, the first
> time you get burnt by a NullPointerException which silently shuts down
> your Callable you pull your hair out.
>
> I now wrap all code that might let exceptions into Executor/Callables
> like so:
>
> >               public Object captiveCall() throws InterruptedException, IOException {
> >                       return obj;
> >               }
> >
> >               public Object call() throws Exception {
> >                       Object retval = null;
> >                       try {
> >                               retval = captiveCall();
> >                       } catch (InterruptedException e) {
> >                               l4j.debug("InterruptedException", e);
> >                               throw e;
> >                       } catch (IOException e) {
> >                               l4j.debug("IOException", e);
> >                               throw e;
> >                       } catch (Exception e) {
> >                               // This normally bad code of catch on Exception is here for a *reason*.
> >                               // Future *eats* all exceptions *silently*.  This clause at least allows
> >                               // the exception to emit noise for debugging.  This is particularly pernicious
> >                               // if you have something like a NullPointerException
> >                               l4j.debug("Exception", e);
> >                               throw e;
> >                       }
> >
> >                       return retval;
> >               }
>
> -a

From the.mindstorm.mailinglist at gmail.com  Tue May  2 20:10:57 2006
From: the.mindstorm.mailinglist at gmail.com (Alexandru Popescu)
Date: Tue May  2 20:11:01 2006
Subject: [concurrency-interest] implementing a DB write-behind algorithm
In-Reply-To: <5a59ce530605011639j1375b9cdwc5ebe772f8919c1a@mail.gmail.com>
References: <c6f400460604300637s11032d5ah8583355f8cbc7990@mail.gmail.com>
	<5a59ce530605011639j1375b9cdwc5ebe772f8919c1a@mail.gmail.com>
Message-ID: <c6f400460605021710h440f69edo30796c7db4d7445b@mail.gmail.com>

This is gonna be stupid, but I've seen it used on different places
(sourcecode included), and couldn't find a definition [blushing/]:
CAS=Compair-and-swap?

./alex
--
.w( the_mindstorm )p.


On 5/2/06, studdugie <studdugie@gmail.com> wrote:
> Another option is to use a CLQ w/ an AtomicBoolean or (now that I
> think about it) an AtomicInteger (AI).
>
> The logic goes like this. Thread has database write so it increments
> AtomicInteger and compares it against guard variable
> (MAX_CONCURR_WRITERS). If AI <= MAX_CONCURR_WRITERS then enter write
> loop and drain the CLQ.
>
> The code may look something like this.
>
> void dbPut(DbData data)
> {
>     dbWriteCLQ.offer( data );
>
>     try
>     {
>         if(AI.incrementAndGet() <= MAX_CONCURR_WRITERS )
>             while(null !=(data = dbWriteCLQ.poll()))
>                 doDatabaseWrite( data );
>     }
>     finally
>     {
>         AI.decrementAndGet();
>     }
> }
>
> I call it the hijack approach because instead of having one or more
> specialist threads to do the job you use a CAS to "hijack" any thread
> that happens to be passing by at the wrong (or right) place at the
> wrong (or right) time.
>
> Like I said in the first paragraph, you could also use an
> AtomicBoolean to do the hijacking (CAS) but that limits you to one
> thread.
>
> Obviously hijacking isn't the best solution all the time because
> you've pulled a thread away from its normal flow and that flow may be
> time sensitive (ex. responding to an HTTP request). But if you have
> complete control over every thread that can get hijacked you may be
> able to get away w/ it. Your best bet (as always) is slap a profiler
> on the code w/ varying loads after you've determined your throughput
> minimum.
>
> Love, peace, and hair grease,
>
> Dane
>
> On 4/30/06, Alexandru Popescu <the.mindstorm.mailinglist@gmail.com> wrote:
> > Hi!
> >
> > I firstly have to confess that when getting to concurrency related
> > problems, I am getting confused quite quickly :-).
> >
> > Now, the current problem I am trying to solve is: I am trying to
> > figure out how to implement a DB write-behind strategy. Multiple
> > processes will post records to be written to the DB, but the actual
> > writes should happen on a separate process. So, far I was thinking
> > about 2 possible approaches:
> > a) continous write-behind: multiple processes write to a queue which
> > is continously polled by a separate process. When an element is found
> > on the queue, than the write process removes it from queue and
> > attempts to write it to the DB.
> >
> > To have this done, I was looking in the direction of ConcurrentLinkedQueue.
> >
> > b) batched write-behind: multiple processes post to a size-bounded
> > queue. When the max size is reached, the original queue is passed to
> > the parallel write process and replaced with a new queue.
> >
> > To have this done, I was looking in the direction of
> > LinkedBlockingQueue with an additional atomic operation of swapping
> > the old queue with the new empty one.
> >
> > My question is: am I looking in the right direction or I am completely
> > wrong. Any ideas and help are highly appreciated.
> >
> > ./alex
> > --
> > .w( the_mindstorm )p.
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest@altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>

From tim at peierls.net  Tue May  2 20:19:07 2006
From: tim at peierls.net (Tim Peierls)
Date: Tue May  2 20:19:19 2006
Subject: [concurrency-interest] backport: unchecked exceptions swallowed
	by executor service
In-Reply-To: <4457E5E6.10308@allcaps.org>
References: <200604051620.k35GKKvW020224@e450.epcc.ed.ac.uk>
	<4457E5E6.10308@allcaps.org>
Message-ID: <63b4e4050605021719i4dfc79d6i292efc0120452fbb@mail.gmail.com>

Please note that implementations of Callable may use more restrictive throws
signatures than "throws Exception". If your Callable only throws IE and IOE,
then you can just say so:

public class MyCallable<T> implements Callable<T> {
    public T call() throws InterruptedException, IOException { ... }
}

Exceptions thrown during execution are not eaten, they are rethrown by
Future.get, wrapped in an ExecutionException.

And as Joe said, talking specifically about Tom Sugden's
FutureTask.doneissue, you can also override afterExecute to get common
exception handling
for a thread pool.

--tim


On 5/2/06, Andrew Lentvorski <bsder@allcaps.org> wrote:
>
> Tom Sugden wrote:
> > Hi,
> >
> > I was surprised by the behaviour that occurs when an unchecked exception
> is
> > raised by an overridden implementation of FutureTask#done() method. The
> > exception seems to be swallowed and the executor maintains a user thread
> for
> > some time afterwards. This isn't causing any problems for me at the
> moment,
> > but I was just wondering whether it was the intended behaviour? It could
> be
> > difficult to debug if your done() implementation had a programming error
>
> > that raised an unchecked exception.
>
> I got burnt by something similar.  The big problem is that you get into
> the habit of assuming that unchecked exceptions will always squawk when
> programming Java.  That fails when you start using concurrent.
>
> I understand *why* they needed to use Exception, but, man, the first
> time you get burnt by a NullPointerException which silently shuts down
> your Callable you pull your hair out.
>
> I now wrap all code that might let exceptions into Executor/Callables
> like so:
>
> >               public Object captiveCall() throws InterruptedException,
> IOException {
> >                       return obj;
> >               }
> >
> >               public Object call() throws Exception {
> >                       Object retval = null;
> >                       try {
> >                               retval = captiveCall();
> >                       } catch (InterruptedException e) {
> >                               l4j.debug("InterruptedException", e);
> >                               throw e;
> >                       } catch (IOException e) {
> >                               l4j.debug("IOException", e);
> >                               throw e;
> >                       } catch (Exception e) {
> >                               // This normally bad code of catch on
> Exception is here for a *reason*.
> >                               // Future *eats* all exceptions
> *silently*.  This clause at least allows
> >                               // the exception to emit noise for
> debugging.  This is particularly pernicious
> >                               // if you have something like a
> NullPointerException
> >                               l4j.debug("Exception", e);
> >                               throw e;
> >                       }
> >
> >                       return retval;
> >               }
>
> -a
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060502/9339c30d/attachment-0001.html
From joe.bowbeer at gmail.com  Tue May  2 21:07:08 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue May  2 21:07:16 2006
Subject: [concurrency-interest] implementing a DB write-behind algorithm
In-Reply-To: <c6f400460605021710h440f69edo30796c7db4d7445b@mail.gmail.com>
References: <c6f400460604300637s11032d5ah8583355f8cbc7990@mail.gmail.com>
	<5a59ce530605011639j1375b9cdwc5ebe772f8919c1a@mail.gmail.com>
	<c6f400460605021710h440f69edo30796c7db4d7445b@mail.gmail.com>
Message-ID: <31f2a7bd0605021807x4e807378h651c759c38c08a4@mail.gmail.com>

Here's a good reference:

http://www-128.ibm.com/developerworks/java/library/j-jtp11234/

Compare and swap is the original name, apparently, though I think of
it as "compare and set", or test and set.

It's an instruction on some machines that could be used to atomically
twiddle bits in memory (including hardware device registers).

On 5/2/06, Alexandru Popescu <the.mindstorm.mailinglist@gmail.com> wrote:
> This is gonna be stupid, but I've seen it used on different places
> (sourcecode included), and couldn't find a definition [blushing/]:
> CAS=Compair-and-swap?
>
> ./alex
> --
> .w( the_mindstorm )p.
>
>
> On 5/2/06, studdugie <studdugie@gmail.com> wrote:
> > Another option is to use a CLQ w/ an AtomicBoolean or (now that I
> > think about it) an AtomicInteger (AI).
> >
> > The logic goes like this. Thread has database write so it increments
> > AtomicInteger and compares it against guard variable
> > (MAX_CONCURR_WRITERS). If AI <= MAX_CONCURR_WRITERS then enter write
> > loop and drain the CLQ.
> >
> > The code may look something like this.
> >
> > void dbPut(DbData data)
> > {
> >     dbWriteCLQ.offer( data );
> >
> >     try
> >     {
> >         if(AI.incrementAndGet() <= MAX_CONCURR_WRITERS )
> >             while(null !=(data = dbWriteCLQ.poll()))
> >                 doDatabaseWrite( data );
> >     }
> >     finally
> >     {
> >         AI.decrementAndGet();
> >     }
> > }
> >
> > I call it the hijack approach because instead of having one or more
> > specialist threads to do the job you use a CAS to "hijack" any thread
> > that happens to be passing by at the wrong (or right) place at the
> > wrong (or right) time.
> >
> > Like I said in the first paragraph, you could also use an
> > AtomicBoolean to do the hijacking (CAS) but that limits you to one
> > thread.
> >
> > Obviously hijacking isn't the best solution all the time because
> > you've pulled a thread away from its normal flow and that flow may be
> > time sensitive (ex. responding to an HTTP request). But if you have
> > complete control over every thread that can get hijacked you may be
> > able to get away w/ it. Your best bet (as always) is slap a profiler
> > on the code w/ varying loads after you've determined your throughput
> > minimum.
> >
> > Love, peace, and hair grease,
> >
> > Dane
> >
> > On 4/30/06, Alexandru Popescu <the.mindstorm.mailinglist@gmail.com> wrote:
> > > Hi!
> > >
> > > I firstly have to confess that when getting to concurrency related
> > > problems, I am getting confused quite quickly :-).
> > >
> > > Now, the current problem I am trying to solve is: I am trying to
> > > figure out how to implement a DB write-behind strategy. Multiple
> > > processes will post records to be written to the DB, but the actual
> > > writes should happen on a separate process. So, far I was thinking
> > > about 2 possible approaches:
> > > a) continous write-behind: multiple processes write to a queue which
> > > is continously polled by a separate process. When an element is found
> > > on the queue, than the write process removes it from queue and
> > > attempts to write it to the DB.
> > >
> > > To have this done, I was looking in the direction of ConcurrentLinkedQueue.
> > >
> > > b) batched write-behind: multiple processes post to a size-bounded
> > > queue. When the max size is reached, the original queue is passed to
> > > the parallel write process and replaced with a new queue.
> > >
> > > To have this done, I was looking in the direction of
> > > LinkedBlockingQueue with an additional atomic operation of swapping
> > > the old queue with the new empty one.
> > >
> > > My question is: am I looking in the right direction or I am completely
> > > wrong. Any ideas and help are highly appreciated.
> > >
> > > ./alex
> > > --
> > > .w( the_mindstorm )p.
> > >

From studdugie at gmail.com  Tue May  2 22:02:36 2006
From: studdugie at gmail.com (studdugie)
Date: Tue May  2 22:02:40 2006
Subject: [concurrency-interest] implementing a DB write-behind algorithm
In-Reply-To: <c6f400460605021710h440f69edo30796c7db4d7445b@mail.gmail.com>
References: <c6f400460604300637s11032d5ah8583355f8cbc7990@mail.gmail.com>
	<5a59ce530605011639j1375b9cdwc5ebe772f8919c1a@mail.gmail.com>
	<c6f400460605021710h440f69edo30796c7db4d7445b@mail.gmail.com>
Message-ID: <5a59ce530605021902k5c883559t27834f7ea4fb0544@mail.gmail.com>

> CAS=Compair-and-swap?
Yes.

Hijacking is nothing new. As a matter of fact you'll be hard pressed
to find anything totally new in computer science. I just liked the
term _hijacking_ as it applies to this specific case plus I didn't see
the technique offered in any of the other responses to your post,
unless I missed it. Apologies if I missed it.

On 5/2/06, Alexandru Popescu <the.mindstorm.mailinglist@gmail.com> wrote:
> This is gonna be stupid, but I've seen it used on different places
> (sourcecode included), and couldn't find a definition [blushing/]:
> CAS=Compair-and-swap?
>
> ./alex
> --
> .w( the_mindstorm )p.
>
>
> On 5/2/06, studdugie <studdugie@gmail.com> wrote:
> > Another option is to use a CLQ w/ an AtomicBoolean or (now that I
> > think about it) an AtomicInteger (AI).
> >
> > The logic goes like this. Thread has database write so it increments
> > AtomicInteger and compares it against guard variable
> > (MAX_CONCURR_WRITERS). If AI <= MAX_CONCURR_WRITERS then enter write
> > loop and drain the CLQ.
> >
> > The code may look something like this.
> >
> > void dbPut(DbData data)
> > {
> >     dbWriteCLQ.offer( data );
> >
> >     try
> >     {
> >         if(AI.incrementAndGet() <= MAX_CONCURR_WRITERS )
> >             while(null !=(data = dbWriteCLQ.poll()))
> >                 doDatabaseWrite( data );
> >     }
> >     finally
> >     {
> >         AI.decrementAndGet();
> >     }
> > }
> >
> > I call it the hijack approach because instead of having one or more
> > specialist threads to do the job you use a CAS to "hijack" any thread
> > that happens to be passing by at the wrong (or right) place at the
> > wrong (or right) time.
> >
> > Like I said in the first paragraph, you could also use an
> > AtomicBoolean to do the hijacking (CAS) but that limits you to one
> > thread.
> >
> > Obviously hijacking isn't the best solution all the time because
> > you've pulled a thread away from its normal flow and that flow may be
> > time sensitive (ex. responding to an HTTP request). But if you have
> > complete control over every thread that can get hijacked you may be
> > able to get away w/ it. Your best bet (as always) is slap a profiler
> > on the code w/ varying loads after you've determined your throughput
> > minimum.
> >
> > Love, peace, and hair grease,
> >
> > Dane
> >
> > On 4/30/06, Alexandru Popescu <the.mindstorm.mailinglist@gmail.com> wrote:
> > > Hi!
> > >
> > > I firstly have to confess that when getting to concurrency related
> > > problems, I am getting confused quite quickly :-).
> > >
> > > Now, the current problem I am trying to solve is: I am trying to
> > > figure out how to implement a DB write-behind strategy. Multiple
> > > processes will post records to be written to the DB, but the actual
> > > writes should happen on a separate process. So, far I was thinking
> > > about 2 possible approaches:
> > > a) continous write-behind: multiple processes write to a queue which
> > > is continously polled by a separate process. When an element is found
> > > on the queue, than the write process removes it from queue and
> > > attempts to write it to the DB.
> > >
> > > To have this done, I was looking in the direction of ConcurrentLinkedQueue.
> > >
> > > b) batched write-behind: multiple processes post to a size-bounded
> > > queue. When the max size is reached, the original queue is passed to
> > > the parallel write process and replaced with a new queue.
> > >
> > > To have this done, I was looking in the direction of
> > > LinkedBlockingQueue with an additional atomic operation of swapping
> > > the old queue with the new empty one.
> > >
> > > My question is: am I looking in the right direction or I am completely
> > > wrong. Any ideas and help are highly appreciated.
> > >
> > > ./alex
> > > --
> > > .w( the_mindstorm )p.
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest@altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dawidk at mathcs.emory.edu  Tue May  2 22:08:40 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue May  2 22:09:01 2006
Subject: [concurrency-interest] Backport limitations
In-Reply-To: <01c101c66dcb$20538150$0b02a8c0@MikeSkellsLT>
References: <01c101c66dcb$20538150$0b02a8c0@MikeSkellsLT>
Message-ID: <445810A8.9070305@mathcs.emory.edu>

Mike Skells wrote:
> Hi
> I noticed (which backporting some code) that the semaphores do not 
> allow for multi acquires
>  
> Is there a specific reason for this is it just lack of dev resources. 
> I use this is current J5 code and I am looking to not try to rewrite 
> that code to do the backport
It is the latter (dev resources), plus it seemed low priority comparing 
to other things. I didn't have time to sit and analyze how the j.u.c. 
implementation avoids the risk of deadlock / starvation, which I suppose 
it must do at least for fair semaphores.

I'll try to look into this soon.
Regards,
Dawid

From dcholmes at optusnet.com.au  Tue May  2 22:29:39 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue May  2 22:29:52 2006
Subject: [concurrency-interest] Backport limitations
In-Reply-To: <445810A8.9070305@mathcs.emory.edu>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEDMGOAA.dcholmes@optusnet.com.au>

Dawid,

> It is the latter (dev resources), plus it seemed low priority comparing
> to other things. I didn't have time to sit and analyze how the j.u.c.
> implementation avoids the risk of deadlock / starvation, which I suppose
> it must do at least for fair semaphores.

j.u.c doesn't do anything special with this. What deadlock/starvation risks
where you thinking of?

Cheers,
David Holmes

From dawidk at mathcs.emory.edu  Tue May  2 22:39:02 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue May  2 22:39:20 2006
Subject: [concurrency-interest] Backport limitations
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEDMGOAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCKEDMGOAA.dcholmes@optusnet.com.au>
Message-ID: <445817C6.6010604@mathcs.emory.edu>

David Holmes wrote:
> Dawid,
>
>   
>> It is the latter (dev resources), plus it seemed low priority comparing
>> to other things. I didn't have time to sit and analyze how the j.u.c.
>> implementation avoids the risk of deadlock / starvation, which I suppose
>> it must do at least for fair semaphores.
>>     
>
> j.u.c doesn't do anything special with this. What deadlock/starvation risks
> where you thinking of?
>
>   
Well, the same as in dining philosophers scenario. Say my semaphore has 
10 permits. I have 50 threads competing. 49 of them always acquire then 
release a single permit, and the 50th thread attempts to acquire 10 
permits at once. Then, if implemented that no permits are "grabbed" 
until all of them can be acquired, the 50th thread runs a risk of being 
starved.

On the other hand, with greedy implementation (i.e. grab all that you 
can until you get as many as you need), if I have two threads both 
trying to get 8 permits (out of 10), they may get stuck after getting, 
say, 5 each.

Regards,
Dawid

From dcholmes at optusnet.com.au  Tue May  2 22:50:49 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue May  2 22:51:01 2006
Subject: [concurrency-interest] Backport limitations
In-Reply-To: <445817C6.6010604@mathcs.emory.edu>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEDNGOAA.dcholmes@optusnet.com.au>

Dawid Kurzyniec writes:
> Well, the same as in dining philosophers scenario. Say my semaphore has
> 10 permits. I have 50 threads competing. 49 of them always acquire then
> release a single permit, and the 50th thread attempts to acquire 10
> permits at once. Then, if implemented that no permits are "grabbed"
> until all of them can be acquired, the 50th thread runs a risk of being
> starved.

The implementation requires that all permits be available at the same time -
so you can't grab one, hold it, wait for the next etc. But in a fair
semaphore the fact that one thread is waiting for 10 permits say, when less
than 10 are available, will cause other acquires to block until after the
first thread is satisfied. So to avoid starvation you need a fair semaphore.

But also be aware that tryAcquire can barge even in a fair implementation.

> On the other hand, with greedy implementation (i.e. grab all that you
> can until you get as many as you need), if I have two threads both
> trying to get 8 permits (out of 10), they may get stuck after getting,
> say, 5 each.

The implementation isn't greedy so with a fair semaphore the first to ask
will be the first to get.

Hope that clarifies the behaviour.

BTW way back when there was a Semaphore class and a FairSemaphore class, the
bulk operations were only in the FairSemaphore class. For a non-fair
semaphore there's no practical difference between a bulk acquire(n) and a
loop doing n seperate acquires.

Cheers,
David Holmes

From dawidk at mathcs.emory.edu  Tue May  2 23:06:33 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue May  2 23:06:55 2006
Subject: [concurrency-interest] Backport limitations
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEDNGOAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCIEDNGOAA.dcholmes@optusnet.com.au>
Message-ID: <44581E39.5070206@mathcs.emory.edu>

David Holmes wrote:
> Dawid Kurzyniec writes:
>   
>> Well, the same as in dining philosophers scenario. Say my semaphore has
>> 10 permits. I have 50 threads competing. 49 of them always acquire then
>> release a single permit, and the 50th thread attempts to acquire 10
>> permits at once. Then, if implemented that no permits are "grabbed"
>> until all of them can be acquired, the 50th thread runs a risk of being
>> starved.
>>     
>
> The implementation requires that all permits be available at the same time -
> so you can't grab one, hold it, wait for the next etc. But in a fair
> semaphore the fact that one thread is waiting for 10 permits say, when less
> than 10 are available, will cause other acquires to block until after the
> first thread is satisfied. So to avoid starvation you need a fair semaphore.
>
> But also be aware that tryAcquire can barge even in a fair implementation.
>
>   
So you're saying it's a strict FIFO? (Except for tryAcquire(n) which can 
still succeed even though acquire(n) would block?)
> BTW way back when there was a Semaphore class and a FairSemaphore class, the
> bulk operations were only in the FairSemaphore class. For a non-fair
> semaphore there's no practical difference between a bulk acquire(n) and a
> loop doing n seperate acquires.
>
>   
Hmmm... wouldn't loop be equivalent to a greedy implementation though, 
and prone to deadlocks? (That is, unless the loop was smart enough to be 
able to back off)

Anyway, I think I understand the behavior now. Thanks!

Regards,
Dawid

From dcholmes at optusnet.com.au  Tue May  2 23:14:23 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue May  2 23:14:39 2006
Subject: [concurrency-interest] Backport limitations
In-Reply-To: <44581E39.5070206@mathcs.emory.edu>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEDOGOAA.dcholmes@optusnet.com.au>

> Dawid Kurzyniec writes:
> So you're saying it's a strict FIFO? (Except for tryAcquire(n) which can
> still succeed even though acquire(n) would block?)

Yes.

> Hmmm... wouldn't loop be equivalent to a greedy implementation though,
> and prone to deadlocks? (That is, unless the loop was smart enough to be
> able to back off)

Yes a loop would be equivalent to greedy. But for non-fair you have a choice
between:
 - greedy and risk deadlock; or
 - non-greedy and risk starvation

I think I'm mis-remembering some things. :)

Cheers,
David

From reddyj at gmail.com  Wed May  3 22:34:35 2006
From: reddyj at gmail.com (Jagadheeswar Reddy)
Date: Thu May  4 05:55:48 2006
Subject: [concurrency-interest] ThreadPoolExecutor.afterExecute(Runnable r,
	Throwable t) is not behaving as per documentation 
Message-ID: <000801c66f23$483ccb00$7764000a@Reddy>

Hi ,
 
I have created a runnable task and deliberately created an unchecked
exception in my run method.
 
My class TaskExecutor extends  ThreadPoolExecutor  and overrides
afterExecute method .
 
When I check for Throwable object in this method, it is still null,
inspite of throwing unchecked exception in run method
 
My code:
 
public class TaskExecutor extends ThreadPoolExecutor {
        
            public TaskExecutor() {
 
                        super(2, 2, 10, TimeUnit.SECONDS, new
ArrayBlockingQueue<Runnable>(5));
}
 
 
            public boolean scheduleTask(Runnable r) {
                                    Future<Object> resultFetcher;
                                    Object result = "hello runnable
executed successfully";
                                    resultFetcher =submit(r, result);
                                    return true;
            }
            protected void afterExecute(Runnable r,Throwable t){
                                    try{
                                                
                                    super.afterExecute(r,t);
                                    System.out.println("inside the
method afterExecute");
                                    
                                    if(t!=null){
 
System.out.println("Exception is thrown in Runnable method");
                                    }           
                            
                        }catch(Exception e){
                                    e.printStackTrace();
                        }
                        
            }
 
}
 
 
My runnable task run method throws NullPointerException :
 
  public void  run(){
             Object out=null;
            System.out.println("inside the runnable task
method"+out.toString());
     }
 
 
Please let me know if iam doing something wrong
 
Thanks& Regards
Reddy
 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060503/897dc686/attachment.html
From joe.bowbeer at gmail.com  Thu May  4 06:43:13 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu May  4 06:43:18 2006
Subject: [concurrency-interest] ThreadPoolExecutor.afterExecute(Runnable r,
	Throwable t) is not behaving as per documentation
In-Reply-To: <000801c66f23$483ccb00$7764000a@Reddy>
References: <000801c66f23$483ccb00$7764000a@Reddy>
Message-ID: <31f2a7bd0605040343g7603da4bje63b3eba9ec99bca@mail.gmail.com>

On 5/3/06, Jagadheeswar Reddy <reddyj@gmail.com> wrote:
>
> I have created a runnable task and deliberately created an unchecked
> exception in my run method.
>
> My class TaskExecutor extends ThreadPoolExecutor  and overrides
> afterExecute method .
>
> When I check for Throwable object in this method, it is still null, inspite
> of throwing unchecked exception in run method
>

The ThreadPool is "executing" a FutureTask rather than a Runnable, and
FutureTask is catching the exception:

    public boolean scheduleTask(Runnable r) {
        Future<Object> resultFetcher;
        Object result = "hello runnable executed successfully";
        resultFetcher =submit(r, result);
        return true;
    }

Try this:

    public boolean scheduleTask(Runnable r) {
        execute(r);
        return true;
    }

--Joe

From mike.quilleash at azuresolutions.com  Mon May  8 12:05:22 2006
From: mike.quilleash at azuresolutions.com (Mike Quilleash)
Date: Mon May  8 12:05:49 2006
Subject: [concurrency-interest] Protecting sensitive resources
Message-ID: <F1689FB09456E347A6E38343B99E680D01960D74@THHS2EXBE2X.hostedservice2.net>

Hi there,
 
I have a class that is responsible for delegating resources to other
classes.
 
Snapshot of the code below...
 
initalise() handles refreshing the internal state (other internal
variables which are not shown).
openSession() should create a new session and return it (unless
currently refreshing).
releaseSession() should return a session to the class and mark it as no
longer used.
 
 
The requirements for how this class should work is...
 
The class should keep track of current in-use session objects
(UsageSession) which must be threadsafe.
UsageSessions must be returned to the class when they are no longer
used.
The class may be reinitialised at any time in which case:
    It should not refresh until all Sessions have been returned.
    It should not allow any new sessions to be delegated out until
reinitialise is complete.
 
 
I'd appreciate any feedback or problems anyone sees with the
implementation below, I've stared at it for a while now and run through
the different possible scenarios of thread states etc but can't see any
problems.
 
Appreciate it.
 
Mike Quilleash.
 
 
 
 
 
    // set of currently open sessions
    private Set< UsageSession > openSessions;
 
    // locks and conditions protecting the open sessions list
    private Lock openSessionsLock = new ReentrantLock();
    private Condition openSessionsEmptyCondition =
openSessionsLock.newCondition();
    private Condition openSessionsNotRefreshingCondition =
openSessionsLock.newCondition();
    private volatile boolean refreshing = false;
 
    void initialise()
    {
        openSessionsLock.lock();
        try
        {
            // set refreshing flag
            refreshing = true;
 
            // wait for the open sessions list to be empty
            while( openSessions.size() > 0 )
            {
                openSessionsEmptyCondition.awaitUninterruptibly();
            }
 
            // clear out the open sessions - will already be empty
            openSessions = new HashSet< UsageSession >();
 
            // TODO: do initialisation here
 
            // clear refreshing flag
            refreshing = false;
 
            // signal all threads waiting on this condition
            openSessionsNotRefreshingCondition.signalAll();
        }
        finally
        {
            openSessionsLock.unlock();
        }
    }
 
    // open a usage session for use
    public UsageSession openSession()
    {
        // lock on the open sessions list
        openSessionsLock.lock();
        try
        {
            // if refreshing then wait for the refreshing condition
            while ( refreshing )
            {
                // wait on the not refreshing condition
 
openSessionsNotRefreshingCondition.awaitUninterruptibly();
            }
 
            UsageSession usageSession = new UsageSession( this );
 
            openSessions.add( usageSession );
 
            return usageSession;
        }
        finally
        {
            openSessionsLock.unlock();
        }
    }
 
    // call back made from the usage session when it is closed
    void releaseSession( UsageSession usageSession )
    {
        openSessionsLock.lock();
        try
        {
            if ( !openSessions.remove( usageSession ) )
                throw new IllegalArgumentException( "Attempted to
release unknown usage session" );
 
            // signal that the open sessions set is empty incase
something is waiting
            if ( openSessions.isEmpty() )
                openSessionsEmptyCondition.signalAll();
        }
        finally
        {
            openSessionsLock.unlock();
        }
    }

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060508/d5f1baaa/attachment.html
From jlawrence at uk.ibm.com  Mon May  8 12:09:12 2006
From: jlawrence at uk.ibm.com (Jonathan P Lawrence)
Date: Mon May  8 12:09:37 2006
Subject: [concurrency-interest] implementing a DB write-behind algorithm
In-Reply-To: <31f2a7bd0605040343g7603da4bje63b3eba9ec99bca@mail.gmail.com>
Message-ID: <OF2E81BC9F.79ECD963-ON80257168.00581F0E-80257168.0058BBD5@uk.ibm.com>

Hi,

This response partly overlaps with some of last week's (notably those
discussing hijacking & CAS algorithms).
I've come across a *very* similar problem before, in connection with
batching log writes from multiple threads, using twin bounded size buffers
to hold the records prior to flushing them to a backing store.

The main design parameters were:
- multiple concurrent client threads writing records.
- twin bounded size buffers to hold records prior to flushing to the
backing store.
- a single asynchronous backend process to flush the filled buffers.

Design:
- Employs a controlling monitor component to manage interactions between
threads and the system. This involves hijacking, but only to trigger rather
than perform the backend writes.
- Buffers may be written to concurrently but exclusive access is required
to flush.  This ensures that the records have been fully written before the
buffers are flushed.
- Prevents overtaking (i.e. all records written by a thread appear in the
correct order in the backing store).
- Has been modelled in a formal process algebra and verified using an
automated model-checking tool.

Java implementation.

There is an existing Java implementation of the design which is really a
model of the intended target implementation on another platform, which
would have used low-level primitives such as CAS directly.
The implementation pre-dates JSR 166 and so it uses wait-notify and
synchronization (with highly granular scope) to manage concurrency, however
it could be easily adapted to use the new features such as concurrent
queues & atomic variables instead.

Optional extensions.
The following features could readily be added to the basic design:
- Thread may force record(s) it has written (i.e. request and block until
the record has been committed to the backing store).
- Such requests may be suspended (with timeout) to allow further records to
be added to a partially filled buffer.

If you are interested I could give more details here or offline.

Jonathan.

================
Jonathan Lawrence
Java Technology Centre
IBM United Kingdom Ltd., Hursley Park, Winchester,  SO21 2JN.
Tel: +44 (0)1962 816197  Internal: 246197  Mobex: 272322
jlawrence@uk.ibm.com

From tim at peierls.net  Tue May  9 00:23:36 2006
From: tim at peierls.net (Tim Peierls)
Date: Tue May  9 00:23:41 2006
Subject: [concurrency-interest] Protecting sensitive resources
In-Reply-To: <F1689FB09456E347A6E38343B99E680D01960D74@THHS2EXBE2X.hostedservice2.net>
References: <F1689FB09456E347A6E38343B99E680D01960D74@THHS2EXBE2X.hostedservice2.net>
Message-ID: <63b4e4050605082123s3e6d6a61t8dd0f424fed14e58@mail.gmail.com>

It looks OK to me. I find the explicit Lock/Condition stuff difficult to
read. Are you sure you need uninterruptible waits here? If not, and if you
are willing to stick IE in the throws clause of initialise and openSession,
plain wait/notifyAll is easier to read and reason about.

// set of currently open sessions
@GuardedBy("this") private final Set<UsageSession> openSessions =
    new HashSet<UsageSession>();
@GuardedBy("this") private boolean refreshing = false;
// CONDITION-PREDICATE: noOpenSessions (openSessions.isEmpty())
// CONDITION-PREDICATE: notRefreshing (!refreshing)

// BLOCKS-UNTIL: noOpenSessions
synchronized void initialise() throws InterruptedException {
    refreshing = true;
    while (!openSessions.isEmpty()) wait();
    refreshing = false;
    notifyAll(); // notRefreshing

    // TODO: do initialisation here
}

// open a usage session for use
// BLOCKS-UNTIL: notRefreshing
public synchronized UsageSession openSession() throws InterruptedException {
    while (refreshing) wait();

    UsageSession result = new UsageSession(this);
    openSessions.add(usageSession);
    return result;
}

// call back made from the usage session when it is closed
synchronized void releaseSession(UsageSession usageSession) {
    if (!openSessions.remove(usageSession))
        throw new IllegalArgumentException( "Attempted to release unknown
usage session" );
    if (openSessions.isEmpty())
        notifyAll(); // noOpenSessions
}

The boolean refreshing field doesn't need to be volatile since all access to
it is done while holding the lock.

Also, why set openSessions to a new empty hash map when it is already empty?
By sticking with the same set instance, you can make openSessions a final
field.

--tim

On 5/8/06, Mike Quilleash <mike.quilleash@azuresolutions.com> wrote:
>
>  Hi there,
>
> I have a class that is responsible for delegating resources to other
> classes.
>
> Snapshot of the code below...
>
> initalise() handles refreshing the internal state (other internal
> variables which are not shown).
> openSession() should create a new session and return it (unless currently
> refreshing).
> releaseSession() should return a session to the class and mark it as no
> longer used.
>
>
> The requirements for how this class should work is...
>
> The class should keep track of current in-use session objects
> (UsageSession) which must be threadsafe.
> UsageSessions must be returned to the class when they are no longer used.
> The class may be reinitialised at any time in which case:
>     It should not refresh until all Sessions have been returned.
>     It should not allow any new sessions to be delegated out until
> reinitialise is complete.
>
>
> I'd appreciate any feedback or problems anyone sees with the
> implementation below, I've stared at it for a while now and run through the
> different possible scenarios of thread states etc but can't see any
> problems.
>
> Appreciate it.
>
> Mike Quilleash.
>
>
>
>
>
>     // set of currently open sessions
>     private Set< UsageSession > openSessions;
>
>     // locks and conditions protecting the open sessions list
>     private Lock openSessionsLock = new ReentrantLock();
>     private Condition openSessionsEmptyCondition =
> openSessionsLock.newCondition();
>     private Condition openSessionsNotRefreshingCondition =
> openSessionsLock.newCondition();
>     private volatile boolean refreshing = false;
>
>     void initialise()
>     {
>         openSessionsLock.lock();
>         try
>         {
>             // set refreshing flag
>             refreshing = true;
>
>             // wait for the open sessions list to be empty
>             while( openSessions.size() > 0 )
>             {
>                 openSessionsEmptyCondition.awaitUninterruptibly();
>             }
>
>             // clear out the open sessions - will already be empty
>             openSessions = new HashSet< UsageSession >();
>
>             // TODO: do initialisation here
>
>             // clear refreshing flag
>             refreshing = false;
>
>             // signal all threads waiting on this condition
>             openSessionsNotRefreshingCondition.signalAll();
>         }
>         finally
>         {
>             openSessionsLock.unlock();
>         }
>     }
>
>     // open a usage session for use
>     public UsageSession openSession()
>     {
>         // lock on the open sessions list
>         openSessionsLock.lock();
>         try
>         {
>             // if refreshing then wait for the refreshing condition
>             while ( refreshing )
>             {
>                 // wait on the not refreshing condition
>                 openSessionsNotRefreshingCondition.awaitUninterruptibly();
>             }
>
>             UsageSession usageSession = new UsageSession( this );
>
>             openSessions.add( usageSession );
>
>             return usageSession;
>         }
>         finally
>         {
>             openSessionsLock.unlock();
>         }
>     }
>
>     // call back made from the usage session when it is closed
>     void releaseSession( UsageSession usageSession )
>     {
>         openSessionsLock.lock();
>         try
>         {
>             if ( !openSessions.remove( usageSession ) )
>                 throw new IllegalArgumentException( "Attempted to release
> unknown usage session" );
>
>             // signal that the open sessions set is empty incase something
> is waiting
>             if ( openSessions.isEmpty() )
>                 openSessionsEmptyCondition.signalAll();
>         }
>         finally
>         {
>             openSessionsLock.unlock();
>         }
>     }
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060509/99f43bfc/attachment-0001.html
From kav at it.edu  Tue May  9 15:16:51 2006
From: kav at it.edu (Kasper Nielsen)
Date: Tue May  9 15:17:32 2006
Subject: [concurrency-interest] ConcurrentHashMap + readValueUnderLock
Message-ID: <4460EAA3.3010206@it.edu>

Hi,

Im trying to customize ConcurrentHashMap for my own needs. And I have a 
problem understanding why ValueIterator and HashIterator does not need 
to check for null values (as get does). And possible resort to 
readValueUnderLock when they return an entry/value?

Cheers
   Kasper
From mike.quilleash at azuresolutions.com  Wed May 10 05:29:20 2006
From: mike.quilleash at azuresolutions.com (Mike Quilleash)
Date: Wed May 10 05:29:36 2006
Subject: [concurrency-interest] Protecting sensitive resources
Message-ID: <F1689FB09456E347A6E38343B99E680D01991F7B@THHS2EXBE2X.hostedservice2.net>

Thanks for your reply.
 
I agree using wait()/notify() is far simpler and I've changed it to be
similar to your solution below.  I guess the only minor downside is that
with two wait conditions a notifyAll() will wake all the waiting threads
even if their condition hasn't been met but this class isn't heavily
travelled enough to worry about that.
 
A couple of questions, your comment about the boolean not needing to be
volatile is that only when using the standard java synchronized, or does
it also apply to the Lock method too?  I was having difficulty seeing
how the lock implementation could figure out what variables need to be
synched up so maybe for Lock you have to use volatile.
 
What advantages does making the openSessions field final have?  Is it
for the JVM to optimise and/or protect the field itself from getting
modified, just the Set contents.
 
Thanks again for you time.
 
Mike.


________________________________

From: tpeierls@gmail.com [mailto:tpeierls@gmail.com] On Behalf Of Tim
Peierls
Sent: 09 May 2006 05:24
To: Mike Quilleash
Cc: concurrency-interest@cs.oswego.edu
Subject: Re: [concurrency-interest] Protecting sensitive resources


It looks OK to me. I find the explicit Lock/Condition stuff difficult to
read. Are you sure you need uninterruptible waits here? If not, and if
you are willing to stick IE in the throws clause of initialise and
openSession, plain wait/notifyAll is easier to read and reason about. 


// set of currently open sessions
@GuardedBy("this") private final Set<UsageSession> openSessions = 
    new HashSet<UsageSession>();
@GuardedBy("this") private boolean refreshing = false;
// CONDITION-PREDICATE: noOpenSessions (openSessions.isEmpty())
// CONDITION-PREDICATE: notRefreshing (!refreshing) 

// BLOCKS-UNTIL: noOpenSessions
synchronized void initialise() throws InterruptedException {
    refreshing = true;
    while (!openSessions.isEmpty()) wait();
    refreshing = false;
    notifyAll(); // notRefreshing 

    // TODO: do initialisation here
}

// open a usage session for use
// BLOCKS-UNTIL: notRefreshing
public synchronized UsageSession openSession() throws
InterruptedException {
    while (refreshing) wait(); 

    UsageSession result = new UsageSession(this);
    openSessions.add(usageSession);
    return result;
}

// call back made from the usage session when it is closed
synchronized void releaseSession(UsageSession usageSession) { 
    if (!openSessions.remove(usageSession))
        throw new IllegalArgumentException( "Attempted to release
unknown usage session" );
    if (openSessions.isEmpty())
        notifyAll(); // noOpenSessions 
}


The boolean refreshing field doesn't need to be volatile since all
access to it is done while holding the lock.

Also, why set openSessions to a new empty hash map when it is already
empty? By sticking with the same set instance, you can make openSessions
a final field.

--tim


On 5/8/06, Mike Quilleash <mike.quilleash@azuresolutions.com> wrote: 

	Hi there,
	 
	I have a class that is responsible for delegating resources to
other classes.
	 
	Snapshot of the code below...
	 
	initalise() handles refreshing the internal state (other
internal variables which are not shown).
	openSession() should create a new session and return it (unless
currently refreshing).
	releaseSession() should return a session to the class and mark
it as no longer used.
	 
	
	 
	The requirements for how this class should work is...
	 
	The class should keep track of current in-use session objects
(UsageSession) which must be threadsafe.
	UsageSessions must be returned to the class when they are no
longer used.
	The class may be reinitialised at any time in which case:
	    It should not refresh until all Sessions have been returned.
	    It should not allow any new sessions to be delegated out
until reinitialise is complete.
	 
	 
	I'd appreciate any feedback or problems anyone sees with the
implementation below, I've stared at it for a while now and run through
the different possible scenarios of thread states etc but can't see any
problems.
	 
	Appreciate it.
	 
	Mike Quilleash.
	 
	 
	 
	 
	 
	    // set of currently open sessions
	    private Set< UsageSession > openSessions;
	 
	    // locks and conditions protecting the open sessions list
	    private Lock openSessionsLock = new ReentrantLock();
	    private Condition openSessionsEmptyCondition =
openSessionsLock.newCondition();
	    private Condition openSessionsNotRefreshingCondition =
openSessionsLock.newCondition();
	    private volatile boolean refreshing = false;
	 
	    void initialise()
	    {
	        openSessionsLock.lock();
	        try
	        {
	            // set refreshing flag
	            refreshing = true;
	 
	            // wait for the open sessions list to be empty
	            while( openSessions.size() > 0 )
	            {
	
openSessionsEmptyCondition.awaitUninterruptibly();
	            }
	 
	            // clear out the open sessions - will already be
empty
	            openSessions = new HashSet< UsageSession >();
	 
	            // TODO: do initialisation here
	 
	            // clear refreshing flag
	            refreshing = false;
	 
	            // signal all threads waiting on this condition
	            openSessionsNotRefreshingCondition.signalAll();
	        }
	        finally
	        {
	            openSessionsLock.unlock();
	        }
	    }
	 
	    // open a usage session for use
	    public UsageSession openSession()
	    {
	        // lock on the open sessions list
	        openSessionsLock.lock();
	        try
	        {
	            // if refreshing then wait for the refreshing
condition
	            while ( refreshing )
	            {
	                // wait on the not refreshing condition
	
openSessionsNotRefreshingCondition.awaitUninterruptibly();
	            }
	 
	            UsageSession usageSession = new UsageSession( this
);
	 
	            openSessions.add( usageSession );
	 
	            return usageSession;
	        }
	        finally
	        {
	            openSessionsLock.unlock();
	        }
	    }
	 
	    // call back made from the usage session when it is closed
	    void releaseSession( UsageSession usageSession )
	    {
	        openSessionsLock.lock();
	        try
	        {
	            if ( !openSessions.remove( usageSession ) )
	                throw new IllegalArgumentException( "Attempted
to release unknown usage session" );
	 
	            // signal that the open sessions set is empty incase
something is waiting
	            if ( openSessions.isEmpty() )
	                openSessionsEmptyCondition.signalAll();
	        }
	        finally
	        {
	            openSessionsLock.unlock();
	        }
	    }
	


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060510/f7d104e4/attachment.html
From tim at peierls.net  Wed May 10 09:16:34 2006
From: tim at peierls.net (Tim Peierls)
Date: Wed May 10 09:16:37 2006
Subject: [concurrency-interest] Protecting sensitive resources
In-Reply-To: <F1689FB09456E347A6E38343B99E680D01991F7B@THHS2EXBE2X.hostedservice2.net>
References: <F1689FB09456E347A6E38343B99E680D01991F7B@THHS2EXBE2X.hostedservice2.net>
Message-ID: <63b4e4050605100616u58cadb3bycf19ff8d6e5255c@mail.gmail.com>

On 5/10/06, Mike Quilleash <mike.quilleash@azuresolutions.com> wrote:
>
> A couple of questions, your comment about the boolean not needing to be
> volatile is that only when using the standard java synchronized, or does it
> also apply to the Lock method too?  I was having difficulty seeing how the
> lock implementation could figure out what variables need to be synched up so
> maybe for Lock you have to use volatile.
>

Nope, it applies to Lock implementations, too. From the javadoc class
comment for j.u.c.locks.Lock:
Memory Synchronization

All Lock implementations *must* enforce the same memory synchronization
semantics as provided by the built-in monitor lock:

   - A successful lock operation acts like a successful monitorEnteraction
   - A successful unlock operation acts like a successful monitorExitaction

Unsuccessful locking and unlocking operations, and reentrant
locking/unlocking operations, do not require any memory synchronization
effects.


What advantages does making the openSessions field final have?  Is it for
> the JVM to optimise and/or protect the field itself from getting modified,
> just the Set contents.
>

It's not for optimization. It just makes it slightly easier to reason about
whether the synchronization policy of your class is correctly observed.
Without final, you have to ensure that there is no unguarded access of any
kind (write or read) to the openSessions field itself. With final, you only
have to worry about avoiding unguarded access to the field's contents.

It's a small thing in this case, but it's a good habit to get into when
dealing with larger classes and more complicated synchronization policies:
If you can make a field final without contortions, do so. Sometimes it isn't
possible, as with the setter injection pattern used by frameworks like
Spring, where you should normally use volatile instead.

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060510/6ec9ce9d/attachment-0001.html
From chakritsus at yahoo.com  Fri May 12 03:28:03 2006
From: chakritsus at yahoo.com (Tutika Chakravarthy)
Date: Fri May 12 03:28:13 2006
Subject: [concurrency-interest] Implementing Cache
Message-ID: <20060512072803.58395.qmail@web35701.mail.mud.yahoo.com>

Hi All,
I have seen the sample code to implement cache using
FutureTask and ConcuurentHashMap in one of the threads
in this mailing list :

code snippet : 

public interface Computable<A, V> {
     V compute(A arg) throws Exception;
}

public class Memoize<A, V> implements Computable<A, V>
{
     public Memoize(Computable<A, V> c) {
         this.c = c;
     }
     public V compute(final A arg) throws Exception {
         Future<V> f = cache.get(arg);
         if (f == null) {
             Callable<V> eval = new Callable<V>() {
                 public V call() throws Exception {
                     return c.compute(arg);
                 }
             };
             FutureTask<V> ft = new
FutureTask<V>(eval);
             f = cache.putIfAbsent(arg, ft);
             if (f == null) { f = ft; ft.run(); }
         }
         return f.get();
     }
     private final ConcurrentMap<A, Future<V>> cache =
         new ConcurrentHashMap<A, Future<V>>();
     private final Computable<A, V> c;
}

 I would like to know how put method in Cache can be
 implemented using FutureTask .
 
 My put method will be put(key,value). 
 
 I tried creating a dummy task with callable object
 which returns the value we passed to it  and  it
 worked fine.
 
 Is there any good way of implementing the put method?

 
 Tutika


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From joe.bowbeer at gmail.com  Fri May 12 04:53:03 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri May 12 04:53:10 2006
Subject: [concurrency-interest] Implementing Cache
In-Reply-To: <20060512072803.58395.qmail@web35701.mail.mud.yahoo.com>
References: <20060512072803.58395.qmail@web35701.mail.mud.yahoo.com>
Message-ID: <31f2a7bd0605120153q10e5e976mbef8e14dbc651e32@mail.gmail.com>

On 5/12/06, Tutika Chakravarthy <chakritsus@yahoo.com> wrote:
>  I would like to know how put method in Cache can be
>  implemented using FutureTask .
>

If you wanted to add a "put" method in order to seed the cache, you
might implement it as follows:

  public FutureTask<V> put(A arg, final V val) {
      Future<V> f = cache.get(arg);
      if (f == null) {
          Callable<V> eval = new Callable<V>() {
              public V call() {
                  return val;
              }
          };
          FutureTask<V> ft = new FutureTask<V>(eval);
          f = cache.putIfAbsent(arg, ft);
          if (f == null) {
              f = ft;
              ft.run();
          }
      }
      return f;
  }

Note that the FutureTask "trick" is useful when computing a new value
for the cache can take a long time.  If the computation time is not an
issue, however, then you can cache the raw values directly rather than
using a FutureTask (which can be thought of as a promise to produce a
value).

If you're using raw values, then your cache could be an instance of
ConcurrentHashMap and your API could be as simple as cache.get(key)
and cache.put(key, val).

Also, it might help you to know that the memo-cache example was
covered in the Bowbeer/Holmes talk at JavaOne 2005, and I believe it
was also covered in the Goetz/Holmes talk.  Both talks are viewable
online.

http://java.sun.com/javaone/sf/speaker_awards.jsp
 http://developers.sun.com/learning/javaoneonline/2005/coreplatform/TS-3423.html
 http://developers.sun.com/learning/javaoneonline/2005/coreplatform/TS-5807.html


On 5/12/06, Tutika Chakravarthy <chakritsus@yahoo.com> wrote:
> Hi All,
> I have seen the sample code to implement cache using
> FutureTask and ConcuurentHashMap in one of the threads
> in this mailing list :
>
> code snippet :
>
> public interface Computable<A, V> {
>      V compute(A arg) throws Exception;
> }
>
> public class Memoize<A, V> implements Computable<A, V>
> {
>      public Memoize(Computable<A, V> c) {
>          this.c = c;
>      }
>      public V compute(final A arg) throws Exception {
>          Future<V> f = cache.get(arg);
>          if (f == null) {
>              Callable<V> eval = new Callable<V>() {
>                  public V call() throws Exception {
>                      return c.compute(arg);
>                  }
>              };
>              FutureTask<V> ft = new
> FutureTask<V>(eval);
>              f = cache.putIfAbsent(arg, ft);
>              if (f == null) { f = ft; ft.run(); }
>          }
>          return f.get();
>      }
>      private final ConcurrentMap<A, Future<V>> cache =
>          new ConcurrentHashMap<A, Future<V>>();
>      private final Computable<A, V> c;
> }
>
>  I would like to know how put method in Cache can be
>  implemented using FutureTask .
>
>  My put method will be put(key,value).
>
>  I tried creating a dummy task with callable object
>  which returns the value we passed to it  and  it
>  worked fine.
>
>  Is there any good way of implementing the put method?
>
>
>  Tutika
>

From joe.bowbeer at gmail.com  Fri May 12 05:03:50 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri May 12 05:03:53 2006
Subject: [concurrency-interest] Implementing Cache
In-Reply-To: <31f2a7bd0605120153q10e5e976mbef8e14dbc651e32@mail.gmail.com>
References: <20060512072803.58395.qmail@web35701.mail.mud.yahoo.com>
	<31f2a7bd0605120153q10e5e976mbef8e14dbc651e32@mail.gmail.com>
Message-ID: <31f2a7bd0605120203m38b3c93bs2c8d0e13c4178fca@mail.gmail.com>

PS -

Note that my "put" method implementation is more accurately
"putIfAbsent".  If the key is already present in the cache, it returns
the existing FutureTask, else it creates a new FutureTask.

If you really wanted to overwrite/change values in the cache, you
could implement "put" as:

   public void put(A arg, final V val) {
       Callable<V> eval = new Callable<V>() {
           public V call() {
               return val;
           }
       };
       FutureTask<V> ft = new FutureTask<V>(eval);
       cache.put(arg, ft);
       ft.run();
   }

But please read my earlier comments first.  Do you really need the
FutureTask indirection in your application?


On 5/12/06, Joe Bowbeer <joe.bowbeer@gmail.com> wrote:
> On 5/12/06, Tutika Chakravarthy <chakritsus@yahoo.com> wrote:
> >  I would like to know how put method in Cache can be
> >  implemented using FutureTask .
> >
>
> If you wanted to add a "put" method in order to seed the cache, you
> might implement it as follows:
>
>   public FutureTask<V> put(A arg, final V val) {
>       Future<V> f = cache.get(arg);
>       if (f == null) {
>           Callable<V> eval = new Callable<V>() {
>               public V call() {
>                   return val;
>               }
>           };
>           FutureTask<V> ft = new FutureTask<V>(eval);
>           f = cache.putIfAbsent(arg, ft);
>           if (f == null) {
>               f = ft;
>               ft.run();
>           }
>       }
>       return f;
>   }
>
> Note that the FutureTask "trick" is useful when computing a new value
> for the cache can take a long time.  If the computation time is not an
> issue, however, then you can cache the raw values directly rather than
> using a FutureTask (which can be thought of as a promise to produce a
> value).
>
> If you're using raw values, then your cache could be an instance of
> ConcurrentHashMap and your API could be as simple as cache.get(key)
> and cache.put(key, val).
>
> Also, it might help you to know that the memo-cache example was
> covered in the Bowbeer/Holmes talk at JavaOne 2005, and I believe it
> was also covered in the Goetz/Holmes talk.  Both talks are viewable
> online.
>
> http://java.sun.com/javaone/sf/speaker_awards.jsp
>  http://developers.sun.com/learning/javaoneonline/2005/coreplatform/TS-3423.html
>  http://developers.sun.com/learning/javaoneonline/2005/coreplatform/TS-5807.html
>
>
> On 5/12/06, Tutika Chakravarthy <chakritsus@yahoo.com> wrote:
> > Hi All,
> > I have seen the sample code to implement cache using
> > FutureTask and ConcuurentHashMap in one of the threads
> > in this mailing list :
> >
> > code snippet :
> >
> > public interface Computable<A, V> {
> >      V compute(A arg) throws Exception;
> > }
> >
> > public class Memoize<A, V> implements Computable<A, V>
> > {
> >      public Memoize(Computable<A, V> c) {
> >          this.c = c;
> >      }
> >      public V compute(final A arg) throws Exception {
> >          Future<V> f = cache.get(arg);
> >          if (f == null) {
> >              Callable<V> eval = new Callable<V>() {
> >                  public V call() throws Exception {
> >                      return c.compute(arg);
> >                  }
> >              };
> >              FutureTask<V> ft = new
> > FutureTask<V>(eval);
> >              f = cache.putIfAbsent(arg, ft);
> >              if (f == null) { f = ft; ft.run(); }
> >          }
> >          return f.get();
> >      }
> >      private final ConcurrentMap<A, Future<V>> cache =
> >          new ConcurrentHashMap<A, Future<V>>();
> >      private final Computable<A, V> c;
> > }
> >
> >  I would like to know how put method in Cache can be
> >  implemented using FutureTask .
> >
> >  My put method will be put(key,value).
> >
> >  I tried creating a dummy task with callable object
> >  which returns the value we passed to it  and  it
> >  worked fine.
> >
> >  Is there any good way of implementing the put method?
> >
> >
> >  Tutika
> >
>

From chakritsus at yahoo.com  Fri May 12 05:47:43 2006
From: chakritsus at yahoo.com (Tutika Chakravarthy)
Date: Fri May 12 05:47:57 2006
Subject: [concurrency-interest] Re: Implementing Cache
Message-ID: <20060512094743.44537.qmail@web35701.mail.mud.yahoo.com>


Note: forwarded message attached.


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
-------------- next part --------------
An embedded message was scrubbed...
From: Tutika Chakravarthy <chakritsus@yahoo.com>
Subject: Re: Implementing Cache
Date: Fri, 12 May 2006 02:46:32 -0700 (PDT)
Size: 2052
Url: /pipermail/attachments/20060512/043db629/attachment.mht
From chakritsus at yahoo.com  Fri May 12 05:50:34 2006
From: chakritsus at yahoo.com (Tutika Chakravarthy)
Date: Fri May 12 05:50:43 2006
Subject: [concurrency-interest] Implementing Cache
Message-ID: <20060512095034.91273.qmail@web35715.mail.mud.yahoo.com>

> Note that the FutureTask "trick" is useful when
computing a new value
> for the cache can take a long time.  If the
computation time is not an
> issue, however, then you can cache the raw values
directly rather than
> using a FutureTask (which can be thought of as a
promise to produce a
> value)


Sorry for my previous post

Thanks for quick reply. Actually our cache requires
this feature. if someone calls get() , if data is not
present in the Cache , we should load it from DataBase
. 
So we are planning to use FeatureTask for achiveing
this .

Since we used FeatureTask in get() method , we will
use  FutureTask in put method also , even though there
is no "task" involved in it .

Thanks again for your suggestion.

__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From chakritsus at yahoo.com  Fri May 12 06:01:45 2006
From: chakritsus at yahoo.com (Tutika Chakravarthy)
Date: Fri May 12 06:01:54 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
Message-ID: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>

Hi ,
I would like to replace some Hashmaps in our
application, which are prone to multi threading issues
with ConCurrentHashMap.

Currently we keep null key and values in hashmap
without any issues as HashMap allows them.

But ConcurrentHashMap does not allow any null key and
values .

I would like to know whether anybody is following any
general practice to tackle this issue .

It is very difficult to check for null keys and values
in my entire application .


I thought of writing a wrapper around
ConcurrentHashMap which will mask and unmask key and
values with some other object, when null values are
getting inserted .

But the issue is that in certain bulk operations like
keySet() , values() etc, it is very difficult unmask
them.

If anybody has ideas in resolving this kind of issue,
Please let me know.
It would be helpful to us .

Tutika

__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From chakritsus at yahoo.com  Fri May 12 06:52:14 2006
From: chakritsus at yahoo.com (Tutika Chakravarthy)
Date: Fri May 12 06:52:22 2006
Subject: [concurrency-interest] Suitable replacement for LinkedHashSet in
	util.concurrent package
Message-ID: <20060512105214.102.qmail@web35713.mail.mud.yahoo.com>

Hi,
Is there any Suitable replacement class for
LinkedHashSet in java.util.concurrent package.

I have seen javadocs for ConcurrentSkipListSet and
CopyOnWriteArraySet. But both of them don't maintain
the order of elements the way they are inserted into.

LinkedHashSet maintains insertion-order while
iterating.

I would like to know whether any other concurrent set
is avaible which behaves in a similar way.


Tutika

__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From holger at wizards.de  Fri May 12 07:22:03 2006
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Fri May 12 07:24:20 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
In-Reply-To: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
References: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
Message-ID: <44646FDB.3060005@wizards.de>

Tutika Chakravarthy wrote:
> I would like to replace some Hashmaps in our
> application, which are prone to multi threading issues
> with ConCurrentHashMap.

You must understand upfront that this may or may not give you the desired
results, though it will 'likely' 'work' in your case. The
ConcurrentModificationExceptions that you probably see are just a symptom
of a deeper root cause; it is a good idea to fix that instead of taping up
the symptom, simply because it is very likely that you will simply see
other concurrency bugs after this visible problem has been 'fixed'.

The problem with concurrency is not the bugs that you see (like CME); be
thankful for those.

> Currently we keep null key and values in hashmap
> without any issues as HashMap allows them.

Yes, this is a terrible error in the Java Map classes.

> But ConcurrentHashMap does not allow any null key and
> values .
> I would like to know whether anybody is following any
> general practice to tackle this issue .

Make it caller's policy to check for both key and value to be not null.
Include tests for this policy in your unit tests (if you have any).

> It is very difficult to check for null keys and values
> in my entire application .

This is just the price to pay for using the broken HashMap behaviour in
the first place. The "standard" Java libraries are full of these hidden
long-term cost factors. :-(

> I thought of writing a wrapper around
> ConcurrentHashMap which will mask and unmask key and
> values with some other object, when null values are
> getting inserted .
> 
> But the issue is that in certain bulk operations like
> keySet() , values() etc, it is very difficult unmask
> them.

Right. Even then you'd still have the problem that you need to find all
callers of the existing Map constructors and fix them up; this may or may
not be possible, e.g. if you get the Map from somewhere else.

> If anybody has ideas in resolving this kind of issue,
> Please let me know.

You have several options.

1) accept that you have a concurrency problem and fix the root cause, not
just the symptoms by trying to "fix" the Map behaviour; it is just an
indicator that something else is wrong. This may mean a full, partial or
subsystem-limited concurrency analysis of either the whole application or
the affected subsystem (if there are any). This also means that you have
to come up with a stringent definition of what it means for your
application (or the relevant part) to be concurrent. This will expose the
critical sections that you can then address, _for example_ by simply using
a Collections.synchronizedMap() around the original, or by using a
ConcurrentHashMap.

2) invert the above approach and 'invade' all offending code parts with
AOP; this would enable you to fix existing JARs as well. I have attached a
simple AspectJ MapCheck aspect with example that you can weave into your
application. Currently this will throw IllegalArgumentExceptions, but of
course you could modify this by skipping the put operation or using
default values. Please think VERY hard whether this works for your case,
because you may end up replacing values with the default key because a
caller erroneously passed a null key, or vice versa. The existing aspect
was meant to expose the null key/value problems as early as possible.
Skipping the operation may or may not be a viable option in your case.

There is no easy solution/quick fix to your problem.

Holger
-------------- next part --------------

package mapcheck;

import java.util.Map;

public aspect MapNullCheck
{

	pointcut methodsToCheck(Object key, Object value):
	    call(public Object Map.put(Object, Object))
	    && args(key, value)
	    && within(MapAccess);

	Object around(Object key, Object value): methodsToCheck(key, value)
	{
		if (key != null)
		{
			if (value != null)
			{
				return proceed(key, value);
			}
			else
			{
				throw new IllegalArgumentException("no null values!");
			}
		}
		else
		{
			throw new IllegalArgumentException("no null keys!");
		}
	}

}
-------------- next part --------------

package mapcheck;

import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;

public class MapAccess
{
    private static Logger log = Logger.getLogger(MapAccess.class);

    public static void main(String[] args)
    {
        Map<String, String> m = new HashMap<String, String>();
        m.put("foo", "bar");
        m.put("keyForNullValue", null);
        m.put(null, "valueForNullKey");
        log.info("map with nulls: " + m);
    }

}
From dl at cs.oswego.edu  Fri May 12 08:02:32 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri May 12 08:02:35 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
In-Reply-To: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
References: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
Message-ID: <44647958.4070907@cs.oswego.edu>

Tutika Chakravarthy wrote:
> Hi ,
> I would like to replace some Hashmaps in our
> application, which are prone to multi threading issues
> with ConCurrentHashMap.
> 
> Currently we keep null key and values in hashmap
> without any issues as HashMap allows them.
> 
> But ConcurrentHashMap does not allow any null key and
> values .
> 

Try to take Holger's advice. As mostly an aside though...

The main reason that nulls aren't allowed in ConcurrentMaps
(ConcurrentHashMaps, ConcurrentSkipListMaps) is that
ambiguities that may be just barely tolerable in non-concurrent
maps can't be accommodated. The main one is that if
map.get(key) returns null, you can't detect whether the
key explicitly maps to null vs the key isn't mapped.
In a non-concurrent map, you can check this via map.contains(key),
but in a concurrent one, the map might have changed between calls.

Further digressing: I personally think that allowing
nulls in Maps (also Sets) is an open invitation for programs
to contain errors that remain undetected until
they break at just the wrong time. (Whether to allow nulls even
in non-concurrent Maps/Sets is one of the few design issues surrounding
Collections that Josh Bloch and I have long disagreed about.)

> 
> It is very difficult to check for null keys and values
> in my entire application .
> 

Would it be easier to declare somewhere
   static final Object NULL = new Object();
and replace all use of nulls in uses of maps with NULL?

-Doug
From josh at bloch.us  Fri May 12 12:22:06 2006
From: josh at bloch.us (Joshua Bloch)
Date: Fri May 12 12:22:11 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
In-Reply-To: <44647958.4070907@cs.oswego.edu>
References: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
	<44647958.4070907@cs.oswego.edu>
Message-ID: <b097ac510605120922r3b211857u6ef860f5295a941f@mail.gmail.com>

Doug,

On 5/12/06, Doug Lea <dl@cs.oswego.edu> wrote:

> Further digressing: I personally think that allowing
> nulls in Maps (also Sets) is an open invitation for programs
> to contain errors that remain undetected until
> they break at just the wrong time. (Whether to allow nulls even
> in non-concurrent Maps/Sets is one of the few design issues surrounding
> Collections that Josh Bloch and I have long disagreed about.)

I have moved towards your position over the years.  It was probably a
mistake to allow null keys in Maps and null elements in Sets.  I'm
still not sure about Map values and List elements.

In other words, Doug hates null more than I do, but over the years
I've come to see it as quite troublesome.

       Josh

From josh at bloch.us  Fri May 12 12:23:11 2006
From: josh at bloch.us (Joshua Bloch)
Date: Fri May 12 12:23:14 2006
Subject: [concurrency-interest] Suitable replacement for LinkedHashSet in
	util.concurrent package
In-Reply-To: <20060512105214.102.qmail@web35713.mail.mud.yahoo.com>
References: <20060512105214.102.qmail@web35713.mail.mud.yahoo.com>
Message-ID: <b097ac510605120923u4c7e8f68x78cbf0fb7d7a5aaa@mail.gmail.com>

No such animal exists (yet).

      Josh

On 5/12/06, Tutika Chakravarthy <chakritsus@yahoo.com> wrote:
> Hi,
> Is there any Suitable replacement class for
> LinkedHashSet in java.util.concurrent package.
>
> I have seen javadocs for ConcurrentSkipListSet and
> CopyOnWriteArraySet. But both of them don't maintain
> the order of elements the way they are inserted into.
>
> LinkedHashSet maintains insertion-order while
> iterating.
>
> I would like to know whether any other concurrent set
> is avaible which behaves in a similar way.
>
>
> Tutika
>
> __________________________________________________
> Do You Yahoo!?
> Tired of spam?  Yahoo! Mail has the best spam protection around
> http://mail.yahoo.com
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From crazybob at crazybob.org  Fri May 12 12:30:34 2006
From: crazybob at crazybob.org (Bob Lee)
Date: Fri May 12 12:30:38 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
In-Reply-To: <44647958.4070907@cs.oswego.edu>
References: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
	<44647958.4070907@cs.oswego.edu>
Message-ID: <a74683f90605120930o3cd58a68r25a6afeab7656211@mail.gmail.com>

On 5/12/06, Doug Lea <dl@cs.oswego.edu> wrote:
> Would it be easier to declare somewhere
>    static final Object NULL = new Object();
> and replace all use of nulls in uses of maps with NULL?

Enums also work great here:
http://crazybob.org/2005/12/null-placeholders-in-jdk-15.html

Bob

From tim at peierls.net  Fri May 12 13:51:22 2006
From: tim at peierls.net (Tim Peierls)
Date: Fri May 12 13:51:26 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
In-Reply-To: <a74683f90605120930o3cd58a68r25a6afeab7656211@mail.gmail.com>
References: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
	<44647958.4070907@cs.oswego.edu>
	<a74683f90605120930o3cd58a68r25a6afeab7656211@mail.gmail.com>
Message-ID: <63b4e4050605121051uf1ebe78sc8d6cd5ac6c2e6cc@mail.gmail.com>

On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
>
> On 5/12/06, Doug Lea <dl@cs.oswego.edu> wrote:
> > Would it be easier to declare somewhere
> >    static final Object NULL = new Object();
> > and replace all use of nulls in uses of maps with NULL?
>
> Enums also work great here:
> http://crazybob.org/2005/12/null-placeholders-in-jdk-15.html


And for getting around in a generics-enabled world:

public class Null<T> {
    private static final Object NULL = new Object();
    public static T null() { return (T) NULL; }
    public static boolean isNull(T x) { return x == NULL; }
    private Null() {}
}

Get a null value for type Foo with Null.<Foo>null(). Test it with
Null.isNull(foo) or get CCEs in the same way that you would get NPE if you
were using primitive null.

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060512/0947c9c6/attachment.html
From mvogel08 at hotmail.com  Fri May 12 14:00:20 2006
From: mvogel08 at hotmail.com (Michael Vogel)
Date: Fri May 12 14:00:32 2006
Subject: FW: Re: [concurrency-interest] Suitable replacement for LinkedHashSet
	inutil.con
Message-ID: <BAY104-F20D531B1ED81DEFEB99CE7DDAC0@phx.gbl>

Please remove me from the list.


>From: "Joshua Bloch" <josh@bloch.us>
>To: "Tutika Chakravarthy" <chakritsus@yahoo.com>
>CC: concurrency-interest@cs.oswego.edu
>Subject: Re: [concurrency-interest] Suitable replacement for LinkedHashSet 
>inutil.concurrent package
>Date: Fri, 12 May 2006 09:23:11 -0700
>

_________________________________________________________________
Dont just search. Find. Check out the new MSN Search! 
http://search.msn.click-url.com/go/onm00200636ave/direct/01/
-------------- next part --------------
No such animal exists (yet).

      Josh

On 5/12/06, Tutika Chakravarthy <chakritsus@yahoo.com> wrote:
>Hi,
>Is there any Suitable replacement class for
>LinkedHashSet in java.util.concurrent package.
>
>I have seen javadocs for ConcurrentSkipListSet and
>CopyOnWriteArraySet. But both of them don't maintain
>the order of elements the way they are inserted into.
>
>LinkedHashSet maintains insertion-order while
>iterating.
>
>I would like to know whether any other concurrent set
>is avaible which behaves in a similar way.
>
>
>Tutika
>
>__________________________________________________
>Do You Yahoo!?
>Tired of spam?  Yahoo! Mail has the best spam protection around
>http://mail.yahoo.com
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest@altair.cs.oswego.edu
>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

From crazybob at crazybob.org  Fri May 12 14:17:29 2006
From: crazybob at crazybob.org (Bob Lee)
Date: Fri May 12 14:17:32 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
In-Reply-To: <63b4e4050605121051uf1ebe78sc8d6cd5ac6c2e6cc@mail.gmail.com>
References: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
	<44647958.4070907@cs.oswego.edu>
	<a74683f90605120930o3cd58a68r25a6afeab7656211@mail.gmail.com>
	<63b4e4050605121051uf1ebe78sc8d6cd5ac6c2e6cc@mail.gmail.com>
Message-ID: <a74683f90605121117l4b23e204o8e0a2dae099e7629@mail.gmail.com>

The nice part about using an enum is that everything works even after
you serialize and deserialize your object.

Bob

On 5/12/06, Tim Peierls <tim@peierls.net> wrote:
> On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
>
> > On 5/12/06, Doug Lea <dl@cs.oswego.edu> wrote:
> > > Would it be easier to declare somewhere
> > >    static final Object NULL = new Object();
> > > and replace all use of nulls in uses of maps with NULL?
> >
> > Enums also work great here:
> >
> http://crazybob.org/2005/12/null-placeholders-in-jdk-15.html
>
>
> And for getting around in a generics-enabled world:
>
> public class Null<T> {
>     private static final Object NULL = new Object();
>     public static T null() { return (T) NULL; }
>     public static boolean isNull(T x) { return x == NULL; }
>     private Null() {}
> }
>
> Get a null value for type Foo with Null.<Foo>null(). Test it with
> Null.isNull(foo) or get CCEs in the same way that you would get NPE if you
> were using primitive null.
>
> --tim

From tim at peierls.net  Fri May 12 14:28:16 2006
From: tim at peierls.net (Tim Peierls)
Date: Fri May 12 14:29:07 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
In-Reply-To: <a74683f90605121117l4b23e204o8e0a2dae099e7629@mail.gmail.com>
References: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
	<44647958.4070907@cs.oswego.edu>
	<a74683f90605120930o3cd58a68r25a6afeab7656211@mail.gmail.com>
	<63b4e4050605121051uf1ebe78sc8d6cd5ac6c2e6cc@mail.gmail.com>
	<a74683f90605121117l4b23e204o8e0a2dae099e7629@mail.gmail.com>
Message-ID: <63b4e4050605121128n156c56c0ne09839b4cd7e7d0b@mail.gmail.com>

So how about something like this?

public enum Null {
    VALUE;
    public static T null() { return (T) VALUE; }
    public static boolean isNull(T x) { return x == VALUE; }
}

--tim

On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
>
> The nice part about using an enum is that everything works even after
> you serialize and deserialize your object.
>
> Bob
>
> On 5/12/06, Tim Peierls <tim@peierls.net> wrote:
> > On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
> >
> > > On 5/12/06, Doug Lea <dl@cs.oswego.edu> wrote:
> > > > Would it be easier to declare somewhere
> > > >    static final Object NULL = new Object();
> > > > and replace all use of nulls in uses of maps with NULL?
> > >
> > > Enums also work great here:
> > >
> > http://crazybob.org/2005/12/null-placeholders-in-jdk-15.html
> >
> >
> > And for getting around in a generics-enabled world:
> >
> > public class Null<T> {
> >     private static final Object NULL = new Object();
> >     public static T null() { return (T) NULL; }
> >     public static boolean isNull(T x) { return x == NULL; }
> >     private Null() {}
> > }
> >
> > Get a null value for type Foo with Null.<Foo>null(). Test it with
> > Null.isNull(foo) or get CCEs in the same way that you would get NPE if
> you
> > were using primitive null.
> >
> > --tim
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060512/6bfdb8dc/attachment.html
From tim at peierls.net  Fri May 12 14:30:32 2006
From: tim at peierls.net (Tim Peierls)
Date: Fri May 12 14:30:36 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
In-Reply-To: <a74683f90605121117l4b23e204o8e0a2dae099e7629@mail.gmail.com>
References: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
	<44647958.4070907@cs.oswego.edu>
	<a74683f90605120930o3cd58a68r25a6afeab7656211@mail.gmail.com>
	<63b4e4050605121051uf1ebe78sc8d6cd5ac6c2e6cc@mail.gmail.com>
	<a74683f90605121117l4b23e204o8e0a2dae099e7629@mail.gmail.com>
Message-ID: <63b4e4050605121130m584aca27r9d6191683de9aea4@mail.gmail.com>

So how about something like this?

public enum Null {
    VALUE;
    public static T value() { return (T) VALUE; }
    public static boolean isNull(T value) { return value == VALUE; }
}

Use Null.<Foo>value() in Set<Foo>, but don't forget to check Null.isNull
(foo).

--tim

On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
>
> The nice part about using an enum is that everything works even after
> you serialize and deserialize your object.
>
> Bob
>
> On 5/12/06, Tim Peierls <tim@peierls.net> wrote:
> > On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
> >
> > > On 5/12/06, Doug Lea <dl@cs.oswego.edu> wrote:
> > > > Would it be easier to declare somewhere
> > > >    static final Object NULL = new Object();
> > > > and replace all use of nulls in uses of maps with NULL?
> > >
> > > Enums also work great here:
> > >
> > http://crazybob.org/2005/12/null-placeholders-in-jdk-15.html
> >
> >
> > And for getting around in a generics-enabled world:
> >
> > public class Null<T> {
> >     private static final Object NULL = new Object();
> >     public static T null() { return (T) NULL; }
> >     public static boolean isNull(T x) { return x == NULL; }
> >     private Null() {}
> > }
> >
> > Get a null value for type Foo with Null.<Foo>null(). Test it with
> > Null.isNull(foo) or get CCEs in the same way that you would get NPE if
> you
> > were using primitive null.
> >
> > --tim
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060512/82bcb86f/attachment-0001.html
From josh at bloch.us  Fri May 12 15:43:59 2006
From: josh at bloch.us (Joshua Bloch)
Date: Fri May 12 15:44:04 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
In-Reply-To: <63b4e4050605121130m584aca27r9d6191683de9aea4@mail.gmail.com>
References: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
	<44647958.4070907@cs.oswego.edu>
	<a74683f90605120930o3cd58a68r25a6afeab7656211@mail.gmail.com>
	<63b4e4050605121051uf1ebe78sc8d6cd5ac6c2e6cc@mail.gmail.com>
	<a74683f90605121117l4b23e204o8e0a2dae099e7629@mail.gmail.com>
	<63b4e4050605121130m584aca27r9d6191683de9aea4@mail.gmail.com>
Message-ID: <b097ac510605121243x6769e214n27ca31766cd6a81a@mail.gmail.com>

Tim and Bob,

These are interesting/cool patterns, but they're a bit scary, as they
cast something that isn't a T to (T).  You have to be very careful
what you do with the the pseudo-null.  I can see using this inside a
library, but I would think more than twice before putting it in the
JDK.

       Josh

On 5/12/06, Tim Peierls <tim@peierls.net> wrote:
> So how about something like this?
>
>
> public enum Null {
>     VALUE;
>     public static T value() { return (T) VALUE; }
>     public static boolean isNull(T value) { return value == VALUE; }
> }
>
> Use Null.<Foo>value() in Set<Foo>, but don't forget to check
> Null.isNull(foo).
>
> --tim
>
>
> --tim
>
>
> On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
> > The nice part about using an enum is that everything works even after
> > you serialize and deserialize your object.
> >
> > Bob
> >
> > On 5/12/06, Tim Peierls <tim@peierls.net> wrote:
> > > On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
> > >
> > > > On 5/12/06, Doug Lea <dl@cs.oswego.edu> wrote:
> > > > > Would it be easier to declare somewhere
> > > > >    static final Object NULL = new Object();
> > > > > and replace all use of nulls in uses of maps with NULL?
> > > >
> > > > Enums also work great here:
> > > >
> > >
> http://crazybob.org/2005/12/null-placeholders-in-jdk-15.html
> > >
> > >
> > > And for getting around in a generics-enabled world:
> > >
> > > public class Null<T> {
> > >     private static final Object NULL = new Object();
> > >     public static T null() { return (T) NULL; }
> > >     public static boolean isNull(T x) { return x == NULL; }
> > >     private Null() {}
> > > }
> > >
> > > Get a null value for type Foo with Null.<Foo>null(). Test it with
> > > Null.isNull(foo) or get CCEs in the same way that you would get NPE if
> you
> > > were using primitive null.
> > >
> > > --tim
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>

From crazybob at crazybob.org  Fri May 12 15:52:27 2006
From: crazybob at crazybob.org (Bob Lee)
Date: Fri May 12 15:52:30 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
In-Reply-To: <b097ac510605121243x6769e214n27ca31766cd6a81a@mail.gmail.com>
References: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
	<44647958.4070907@cs.oswego.edu>
	<a74683f90605120930o3cd58a68r25a6afeab7656211@mail.gmail.com>
	<63b4e4050605121051uf1ebe78sc8d6cd5ac6c2e6cc@mail.gmail.com>
	<a74683f90605121117l4b23e204o8e0a2dae099e7629@mail.gmail.com>
	<63b4e4050605121130m584aca27r9d6191683de9aea4@mail.gmail.com>
	<b097ac510605121243x6769e214n27ca31766cd6a81a@mail.gmail.com>
Message-ID: <a74683f90605121252k30e09472u428d33718ead505b@mail.gmail.com>

Hey! I didn't recommend that. ;)

In the blog I linked to, I said:

"Things can still get a little hairy when you mix null placeholders
with generic types. Your placeholder can implement the same type as
the value, or you can resort to casting hacks."

OK, I said, "you can," but I wouldn't do it myself.

The nice thing about the enum null placeholder is that it's so short
and sweet you don't have to refactor it out into a common place and
risk infecting others with bad ideas. ;)

Bob

On 5/12/06, Joshua Bloch <josh@bloch.us> wrote:
> Tim and Bob,
>
> These are interesting/cool patterns, but they're a bit scary, as they
> cast something that isn't a T to (T).  You have to be very careful
> what you do with the the pseudo-null.  I can see using this inside a
> library, but I would think more than twice before putting it in the
> JDK.
>
>        Josh
>
> On 5/12/06, Tim Peierls <tim@peierls.net> wrote:
> > So how about something like this?
> >
> >
> > public enum Null {
> >     VALUE;
> >     public static T value() { return (T) VALUE; }
> >     public static boolean isNull(T value) { return value == VALUE; }
> > }
> >
> > Use Null.<Foo>value() in Set<Foo>, but don't forget to check
> > Null.isNull(foo).
> >
> > --tim
> >
> >
> > --tim
> >
> >
> > On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
> > > The nice part about using an enum is that everything works even after
> > > you serialize and deserialize your object.
> > >
> > > Bob
> > >
> > > On 5/12/06, Tim Peierls <tim@peierls.net> wrote:
> > > > On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
> > > >
> > > > > On 5/12/06, Doug Lea <dl@cs.oswego.edu> wrote:
> > > > > > Would it be easier to declare somewhere
> > > > > >    static final Object NULL = new Object();
> > > > > > and replace all use of nulls in uses of maps with NULL?
> > > > >
> > > > > Enums also work great here:
> > > > >
> > > >
> > http://crazybob.org/2005/12/null-placeholders-in-jdk-15.html
> > > >
> > > >
> > > > And for getting around in a generics-enabled world:
> > > >
> > > > public class Null<T> {
> > > >     private static final Object NULL = new Object();
> > > >     public static T null() { return (T) NULL; }
> > > >     public static boolean isNull(T x) { return x == NULL; }
> > > >     private Null() {}
> > > > }
> > > >
> > > > Get a null value for type Foo with Null.<Foo>null(). Test it with
> > > > Null.isNull(foo) or get CCEs in the same way that you would get NPE if
> > you
> > > > were using primitive null.
> > > >
> > > > --tim
> > >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest@altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
>

From tim at peierls.net  Fri May 12 17:34:43 2006
From: tim at peierls.net (Tim Peierls)
Date: Fri May 12 17:34:51 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
In-Reply-To: <a74683f90605121252k30e09472u428d33718ead505b@mail.gmail.com>
References: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
	<44647958.4070907@cs.oswego.edu>
	<a74683f90605120930o3cd58a68r25a6afeab7656211@mail.gmail.com>
	<63b4e4050605121051uf1ebe78sc8d6cd5ac6c2e6cc@mail.gmail.com>
	<a74683f90605121117l4b23e204o8e0a2dae099e7629@mail.gmail.com>
	<63b4e4050605121130m584aca27r9d6191683de9aea4@mail.gmail.com>
	<b097ac510605121243x6769e214n27ca31766cd6a81a@mail.gmail.com>
	<a74683f90605121252k30e09472u428d33718ead505b@mail.gmail.com>
Message-ID: <63b4e4050605121434k4a9233b7pdad5612927302838@mail.gmail.com>

And I would certainly recommend avoiding null in the first place over any of
this. This was all in the context of Doug's reaction to an expressed need to
deal with null values in collections.

--tim

On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
>
> Hey! I didn't recommend that. ;)
>
> In the blog I linked to, I said:
>
> "Things can still get a little hairy when you mix null placeholders
> with generic types. Your placeholder can implement the same type as
> the value, or you can resort to casting hacks."
>
> OK, I said, "you can," but I wouldn't do it myself.
>
> The nice thing about the enum null placeholder is that it's so short
> and sweet you don't have to refactor it out into a common place and
> risk infecting others with bad ideas. ;)
>
> Bob
>
> On 5/12/06, Joshua Bloch <josh@bloch.us> wrote:
> > Tim and Bob,
> >
> > These are interesting/cool patterns, but they're a bit scary, as they
> > cast something that isn't a T to (T).  You have to be very careful
> > what you do with the the pseudo-null.  I can see using this inside a
> > library, but I would think more than twice before putting it in the
> > JDK.
> >
> >        Josh
> >
> > On 5/12/06, Tim Peierls <tim@peierls.net> wrote:
> > > So how about something like this?
> > >
> > >
> > > public enum Null {
> > >     VALUE;
> > >     public static T value() { return (T) VALUE; }
> > >     public static boolean isNull(T value) { return value == VALUE; }
> > > }
> > >
> > > Use Null.<Foo>value() in Set<Foo>, but don't forget to check
> > > Null.isNull(foo).
> > >
> > > --tim
> > >
> > >
> > > --tim
> > >
> > >
> > > On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
> > > > The nice part about using an enum is that everything works even
> after
> > > > you serialize and deserialize your object.
> > > >
> > > > Bob
> > > >
> > > > On 5/12/06, Tim Peierls <tim@peierls.net> wrote:
> > > > > On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
> > > > >
> > > > > > On 5/12/06, Doug Lea <dl@cs.oswego.edu> wrote:
> > > > > > > Would it be easier to declare somewhere
> > > > > > >    static final Object NULL = new Object();
> > > > > > > and replace all use of nulls in uses of maps with NULL?
> > > > > >
> > > > > > Enums also work great here:
> > > > > >
> > > > >
> > > http://crazybob.org/2005/12/null-placeholders-in-jdk-15.html
> > > > >
> > > > >
> > > > > And for getting around in a generics-enabled world:
> > > > >
> > > > > public class Null<T> {
> > > > >     private static final Object NULL = new Object();
> > > > >     public static T null() { return (T) NULL; }
> > > > >     public static boolean isNull(T x) { return x == NULL; }
> > > > >     private Null() {}
> > > > > }
> > > > >
> > > > > Get a null value for type Foo with Null.<Foo>null(). Test it with
> > > > > Null.isNull(foo) or get CCEs in the same way that you would get
> NPE if
> > > you
> > > > > were using primitive null.
> > > > >
> > > > > --tim
> > > >
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest@altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060512/be78bb1e/attachment.html
From dcholmes at optusnet.com.au  Sat May 13 06:19:12 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sat May 13 06:19:34 2006
Subject: [concurrency-interest] Suitable replacement for LinkedHashSet
	inutil.concurrent package
In-Reply-To: <20060512105214.102.qmail@web35713.mail.mud.yahoo.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEHJGOAA.dcholmes@optusnet.com.au>

> Tutika Chakravarthy writes:
> I have seen javadocs for ConcurrentSkipListSet and
> CopyOnWriteArraySet. But both of them don't maintain
> the order of elements the way they are inserted into.

Why do you say CopyOnWriteArraySet doesn't maintain the order of insertion?
The docs don't say anything one way or another, but an implementation would
have to go out of its way to not return things in order.

Cheers,
David Holmes

From chakritsus at yahoo.com  Sat May 13 08:03:11 2006
From: chakritsus at yahoo.com (Tutika Chakravarthy)
Date: Sat May 13 08:03:23 2006
Subject: [concurrency-interest] Suitable replacement for LinkedHashSet
	inutil.concurrent package
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEHJGOAA.dcholmes@optusnet.com.au>
Message-ID: <20060513120311.89481.qmail@web35709.mail.mud.yahoo.com>

> Why do you say CopyOnWriteArraySet doesn't maintain
> the order of insertion?
> The docs don't say anything one way or another, but
> an implementation would
> have to go out of its way to not return things in
> order.


I am sorry . I did not read it properly.Actually the
doc says that  CopyOnWriteArraySet is suitable when
read-only operations vastly outnumber mutative
operations. But I am looking for a set which can
handle both the operations equally well.


Tutika

__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From tim at peierls.net  Sat May 13 08:22:23 2006
From: tim at peierls.net (Tim Peierls)
Date: Sat May 13 08:22:35 2006
Subject: [concurrency-interest] Handling Null Values in ConcurrentHashMap
In-Reply-To: <63b4e4050605121434k4a9233b7pdad5612927302838@mail.gmail.com>
References: <20060512100145.81818.qmail@web35710.mail.mud.yahoo.com>
	<44647958.4070907@cs.oswego.edu>
	<a74683f90605120930o3cd58a68r25a6afeab7656211@mail.gmail.com>
	<63b4e4050605121051uf1ebe78sc8d6cd5ac6c2e6cc@mail.gmail.com>
	<a74683f90605121117l4b23e204o8e0a2dae099e7629@mail.gmail.com>
	<63b4e4050605121130m584aca27r9d6191683de9aea4@mail.gmail.com>
	<b097ac510605121243x6769e214n27ca31766cd6a81a@mail.gmail.com>
	<a74683f90605121252k30e09472u428d33718ead505b@mail.gmail.com>
	<63b4e4050605121434k4a9233b7pdad5612927302838@mail.gmail.com>
Message-ID: <63b4e4050605130522g42d49077o4810360ee828cf60@mail.gmail.com>

David Holmes says that a retraction is in order. He points out that the code
I posted not only doesn't compile, it doesn't even work if you fix the code!
You may be able to insert Null-ish values into collections of other types,
but when you iterate over the collection, you'll get a ClassCastException.

So I take back the suggestion. Generics are tricky. Stick to non-null values
(and keys!) in collections and maps. Try to rewrite code that depends on
sticking nulls in collections to use the Null *pattern* instead -- that's
the one where you provide a special implementation of your interface that
can be tested for nullity. It preserves type-safety and is strongly
recommended over using the primitive null value.

Next time I'll write a test program before mouthing off. :-(

--tim

On 5/12/06, Tim Peierls <tim@peierls.net> wrote:
>
> And I would certainly recommend avoiding null in the first place over any
> of this. This was all in the context of Doug's reaction to an expressed need
> to deal with null values in collections.
>
>
> --tim
>
> On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
> >
> > Hey! I didn't recommend that. ;)
> >
> > In the blog I linked to, I said:
> >
> > "Things can still get a little hairy when you mix null placeholders
> > with generic types. Your placeholder can implement the same type as
> > the value, or you can resort to casting hacks."
> >
> > OK, I said, "you can," but I wouldn't do it myself.
> >
> > The nice thing about the enum null placeholder is that it's so short
> > and sweet you don't have to refactor it out into a common place and
> > risk infecting others with bad ideas. ;)
> >
> > Bob
> >
> > On 5/12/06, Joshua Bloch <josh@bloch.us> wrote:
> > > Tim and Bob,
> > >
> > > These are interesting/cool patterns, but they're a bit scary, as they
> > > cast something that isn't a T to (T).  You have to be very careful
> > > what you do with the the pseudo-null.  I can see using this inside a
> > > library, but I would think more than twice before putting it in the
> > > JDK.
> > >
> > >        Josh
> > >
> > > On 5/12/06, Tim Peierls <tim@peierls.net> wrote:
> > > > So how about something like this?
> > > >
> > > >
> > > > public enum Null {
> > > >     VALUE;
> > > >     public static T value() { return (T) VALUE; }
> > > >     public static boolean isNull(T value) { return value == VALUE; }
> > > > }
> > > >
> > > > Use Null.<Foo>value() in Set<Foo>, but don't forget to check
> > > > Null.isNull(foo).
> > > >
> > > > --tim
> > > >
> > > >
> > > > --tim
> > > >
> > > >
> > > > On 5/12/06, Bob Lee <crazybob@crazybob.org> wrote:
> > > > > The nice part about using an enum is that everything works even
> > after
> > > > > you serialize and deserialize your object.
> > > > >
> > > > > Bob
> > > > >
> > > > > On 5/12/06, Tim Peierls <tim@peierls.net> wrote:
> > > > > > On 5/12/06, Bob Lee < crazybob@crazybob.org> wrote:
> > > > > >
> > > > > > > On 5/12/06, Doug Lea <dl@cs.oswego.edu> wrote:
> > > > > > > > Would it be easier to declare somewhere
> > > > > > > >    static final Object NULL = new Object();
> > > > > > > > and replace all use of nulls in uses of maps with NULL?
> > > > > > >
> > > > > > > Enums also work great here:
> > > > > > >
> > > > > >
> > > > http://crazybob.org/2005/12/null-placeholders-in-jdk-15.html
> > > > > >
> > > > > >
> > > > > > And for getting around in a generics-enabled world:
> > > > > >
> > > > > > public class Null<T> {
> > > > > >     private static final Object NULL = new Object();
> > > > > >     public static T null() { return (T) NULL; }
> > > > > >     public static boolean isNull(T x) { return x == NULL; }
> > > > > >     private Null() {}
> > > > > > }
> > > > > >
> > > > > > Get a null value for type Foo with Null.<Foo>null(). Test it
> > with
> > > > > > Null.isNull(foo) or get CCEs in the same way that you would get
> > NPE if
> > > > you
> > > > > > were using primitive null.
> > > > > >
> > > > > > --tim
> > > > >
> > > >
> > > >
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest@altair.cs.oswego.edu
> > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >
> > > >
> > > >
> > >
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060513/ca09289f/attachment-0001.html
From dawidk at mathcs.emory.edu  Sat May 13 12:57:00 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Sat May 13 12:57:27 2006
Subject: [concurrency-interest] Backport limitations
In-Reply-To: <01c101c66dcb$20538150$0b02a8c0@MikeSkellsLT>
References: <01c101c66dcb$20538150$0b02a8c0@MikeSkellsLT>
Message-ID: <44660FDC.6090406@mathcs.emory.edu>

Mike Skells wrote:
> Hi
> I noticed (which backporting some code) that the semaphores do not 
> allow for multi acquires
>  
> Is there a specific reason for this is it just lack of dev resources. 
> I use this is current J5 code and I am looking to not try to rewrite 
> that code to do the backport
>  

I have just finished implementing multi-acquires for fair semaphores; 
the code is available in backport CVS and the latest daily build at 
http://dcl.mathcs.emory.edu/util/backport-util-concurrent/. (It passes 
unit tests, but if anybody is able to more thoroughly test it, I would 
appreciate some feedback). For non-fair semaphores, the problem is a bit 
more fundamental. Current implementation of release(n) wakes up exactly 
n threads using notify(). If all of the waiters turn out to be 
multi-acquirers however, it might be the case that all awoken threads 
must go back to sleep, and no thread would proceed at least until next 
notify. Is this acceptable?

An alternative would be to notifyAll(), but it would affect performance 
- using the fair version instead might actually be a better idea.

Thus far, I have taken a conservative approach and left multi-acquires 
for non-fair semaphores unimplemented (UnsupportedOperationException 
thrown from blocking acquire(n) etc if n >= 2). Non-blocking 
tryAcquire(n) works, however.

Regards,
Dawid

From hanson.char at gmail.com  Sun May 14 03:05:17 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Sun May 14 03:05:21 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "May
	fail spuriously"?
In-Reply-To: <43E1F409.3050407@cs.oswego.edu>
References: <20060202055446.27226.qmail@web30612.mail.mud.yahoo.com>
	<43E1F409.3050407@cs.oswego.edu>
Message-ID: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>

I've gone thru the javadoc, but would like to clarify further.

In case when the invocation of

  weakCompareAndSet

does fail, what behavior could we expect from the failure ?

1) corrupted data being set ? or
2) runtime exception or error being thrown ? or
3) the method (weakCompareAndSet) did not set the value but return true ? or
4) the method did set the value but return false ? or
5) the method just failed but the behavior is non-deterministic ?

Hanson

On 2/2/06, Doug Lea <dl@cs.oswego.edu> wrote:
>
> Robert Kuhar wrote:
> > I was strolling through the Docs one day, and came upon the JDK 1.5Javadocs
> > for Class java.util.concurrent.atomic.AtomicReference.  The description
> for the
> > weakCompareAndSet method confuses me:
> >
> >   public final boolean weakCompareAndSet(V expect, V update)
> >
> >   Atomically set the value to the given updated value if the current
> >   value == the expected value. May fail spuriously.
> >
> >   Parameters:
> >     expect - the expected value
> >     update - the new value
> >   Returns:
> >     true if successful.
> >
> > What does "May fail spuriously" mean?  Why would it fail
> spuriously?  When the
> > spurious failures occur, is the return value always false?  Why would
> anyone
> > call this method having been warned that "spurious failure" is
> possible?  I
> > think I'm missing something here.
> >
>
> See
>
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/package-summary.html
>
> The javadocs in the atomic package also mention that this form may be more
> efficient. (At least on some processors; on most (in fact all supported by
> hotspot) it actually compiles to the same code.) The reason that it may be
> more
> efficient is that some processors perform CAS via a pair of Load-linked /
> Store-conditional instructions, which may fail if some other processor
> happened to write to the same cache line, among other reasons that have
> nothing to do with the CAS. In some cases, this is acceptable. On
> such processors, a full strong CAS must actually be coded internally
> as a loop. There are a handfull of non-blocking algorithms out there
> where you don't actually want that loop, so we include this method
> so you can avoid it. We expect use of this method to be uncommon.
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060514/5ae4e9a8/attachment.html
From dcholmes at optusnet.com.au  Sun May 14 05:14:53 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sun May 14 05:15:12 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "Mayfail
	spuriously"?
In-Reply-To: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>

If it fails it just returns false and doesn't set the value.

The "weak" aspect of this is that it can fail for reasons other than the
current value not matching the expected value. It still has well-defined
behaviour.

If you are interested in the details on platforms that provide load-linked
and store-conditional instructions (ll/sc), these are used to emulate
CompareAndSwap. But a store conditional can fail for reasons other than the
target memory location being written to by some other thread - the
granularity is typically a cache-line, so a write to a close variable can
cause the SC to fail. Even if the same value was written into the variable
the SC would still fail. So typically you use ll/sc in a retry loop until
you either succeed or determine the failure was due to the current value not
being the expected value. This gives you the strong compareAndSet semantics.
The weakCompareAndSet doesn't use the loop.

Cheers,
David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of Hanson Char
  Sent: Sunday, 14 May 2006 5:05 PM
  To: Doug Lea
  Cc: concurrency-interest@cs.oswego.edu
  Subject: Re: [concurrency-interest] AtomicReference weakCompareAndSet
"Mayfail spuriously"?


  I've gone thru the javadoc, but would like to clarify further.

  In case when the invocation of

    weakCompareAndSet

  does fail, what behavior could we expect from the failure ?

  1) corrupted data being set ? or
  2) runtime exception or error being thrown ? or
  3) the method (weakCompareAndSet) did not set the value but return true ?
or
  4) the method did set the value but return false ? or
  5) the method just failed but the behavior is non-deterministic ?

  Hanson


  On 2/2/06, Doug Lea <dl@cs.oswego.edu > wrote:
    Robert Kuhar wrote:
    > I was strolling through the Docs one day, and came upon the JDK 1.5
Javadocs
    > for Class java.util.concurrent.atomic.AtomicReference.  The
description for the
    > weakCompareAndSet method confuses me:
    >
    >   public final boolean weakCompareAndSet(V expect, V update)
    >
    >   Atomically set the value to the given updated value if the current
    >   value == the expected value. May fail spuriously.
    >
    >   Parameters:
    >     expect - the expected value
    >     update - the new value
    >   Returns:
    >     true if successful.
    >
    > What does "May fail spuriously" mean?  Why would it fail spuriously?
When the
    > spurious failures occur, is the return value always false?  Why would
anyone
    > call this method having been warned that "spurious failure" is
possible?  I
    > think I'm missing something here.
    >

    See

http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/pac
kage-summary.html

    The javadocs in the atomic package also mention that this form may be
more
    efficient. (At least on some processors; on most (in fact all supported
by
    hotspot) it actually compiles to the same code.) The reason that it may
be more
    efficient is that some processors perform CAS via a pair of Load-linked
/
    Store-conditional instructions, which may fail if some other processor
    happened to write to the same cache line, among other reasons that have
    nothing to do with the CAS. In some cases, this is acceptable. On
    such processors, a full strong CAS must actually be coded internally
    as a loop. There are a handfull of non-blocking algorithms out there
    where you don't actually want that loop, so we include this method
    so you can avoid it. We expect use of this method to be uncommon.

    -Doug
    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest@altair.cs.oswego.edu
    http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060514/6ce89034/attachment.html
From chakritsus at yahoo.com  Sun May 14 05:17:26 2006
From: chakritsus at yahoo.com (Tutika Chakravarthy)
Date: Sun May 14 05:17:37 2006
Subject: [concurrency-interest] Question about Double-checked locking
Message-ID: <20060514091726.52208.qmail@web35714.mail.mud.yahoo.com>

Hi All,
I have some code like this : 

result = map.get(key);


if (result == null ) {

Object mutex = mutexFactory.getMutex(key);

synchronized (mutex) {
result = map.get(key);

if (result == null) {
	result = dataSource.load(key);

	if (result != null) 
	map.put(key, result);
	else
	mutexFactory.removeMutex(key);

	}
 }
}

Here mutexFactory returns different monitors based on
the key . 
I am using HashMap to store and retrieve the values . 
If the value is not there in the map , I should load
the value from DataBase using dataSource.

I would like to know whether the above code falls
under "Double-checked locking" problem.


If so , Can I avoid it using new util.concurrent.Lock
interface classes ?

__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From dcholmes at optusnet.com.au  Sun May 14 05:30:15 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sun May 14 05:30:30 2006
Subject: [concurrency-interest] Question about Double-checked locking
In-Reply-To: <20060514091726.52208.qmail@web35714.mail.mud.yahoo.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEIDGOAA.dcholmes@optusnet.com.au>

Yes it is the failed double-checked-locking idiom. But it is also broken in
the locking strategy anyway - see below.

No changing from synchronized to Lock doesn't make a difference to the
double-check part. You must establish a "happens-before" relationship
between the thread setting the value in the map, and the thread reading it.

The locking strategy is broken because you use a different Object for
different keys. So multiple threads can be concurrently trying to put()
different key/result pairs. The hashtable must be protected from concurrent
access using the *same* Lock/object in all threads.

Cheers,
David Holmes


> -----Original Message-----
> From: concurrency-interest-bounces@cs.oswego.edu
> [mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of Tutika
> Chakravarthy
> Sent: Sunday, 14 May 2006 7:17 PM
> To: concurrency-interest@cs.oswego.edu
> Subject: [concurrency-interest] Question about Double-checked locking
>
>
> Hi All,
> I have some code like this :
>
> result = map.get(key);
>
>
> if (result == null ) {
>
> Object mutex = mutexFactory.getMutex(key);
>
> synchronized (mutex) {
> result = map.get(key);
>
> if (result == null) {
> 	result = dataSource.load(key);
>
> 	if (result != null)
> 	map.put(key, result);
> 	else
> 	mutexFactory.removeMutex(key);
>
> 	}
>  }
> }
>
> Here mutexFactory returns different monitors based on
> the key .
> I am using HashMap to store and retrieve the values .
> If the value is not there in the map , I should load
> the value from DataBase using dataSource.
>
> I would like to know whether the above code falls
> under "Double-checked locking" problem.
>
>
> If so , Can I avoid it using new util.concurrent.Lock
> interface classes ?
>
> __________________________________________________
> Do You Yahoo!?
> Tired of spam?  Yahoo! Mail has the best spam protection around
> http://mail.yahoo.com
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

From dcholmes at optusnet.com.au  Sun May 14 05:41:18 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sun May 14 05:41:34 2006
Subject: [concurrency-interest] Question about Double-checked locking
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEIDGOAA.dcholmes@optusnet.com.au>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEIDGOAA.dcholmes@optusnet.com.au>

I forgot to mention that the HashMap isn't protected by a lock at all during
the get() operations, and get()'s can't happen concurrently with put()'s
(though multiple get()'s can be concurrent).

David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces@cs.oswego.edu
> [mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of David
> Holmes
> Sent: Sunday, 14 May 2006 7:30 PM
> To: Tutika Chakravarthy; concurrency-interest@cs.oswego.edu
> Subject: RE: [concurrency-interest] Question about Double-checked
> locking
>
>
> Yes it is the failed double-checked-locking idiom. But it is also
> broken in
> the locking strategy anyway - see below.
>
> No changing from synchronized to Lock doesn't make a difference to the
> double-check part. You must establish a "happens-before" relationship
> between the thread setting the value in the map, and the thread
> reading it.
>
> The locking strategy is broken because you use a different Object for
> different keys. So multiple threads can be concurrently trying to put()
> different key/result pairs. The hashtable must be protected from
> concurrent
> access using the *same* Lock/object in all threads.
>
> Cheers,
> David Holmes
>
>
> > -----Original Message-----
> > From: concurrency-interest-bounces@cs.oswego.edu
> > [mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of Tutika
> > Chakravarthy
> > Sent: Sunday, 14 May 2006 7:17 PM
> > To: concurrency-interest@cs.oswego.edu
> > Subject: [concurrency-interest] Question about Double-checked locking
> >
> >
> > Hi All,
> > I have some code like this :
> >
> > result = map.get(key);
> >
> >
> > if (result == null ) {
> >
> > Object mutex = mutexFactory.getMutex(key);
> >
> > synchronized (mutex) {
> > result = map.get(key);
> >
> > if (result == null) {
> > 	result = dataSource.load(key);
> >
> > 	if (result != null)
> > 	map.put(key, result);
> > 	else
> > 	mutexFactory.removeMutex(key);
> >
> > 	}
> >  }
> > }
> >
> > Here mutexFactory returns different monitors based on
> > the key .
> > I am using HashMap to store and retrieve the values .
> > If the value is not there in the map , I should load
> > the value from DataBase using dataSource.
> >
> > I would like to know whether the above code falls
> > under "Double-checked locking" problem.
> >
> >
> > If so , Can I avoid it using new util.concurrent.Lock
> > interface classes ?
> >
> > __________________________________________________
> > Do You Yahoo!?
> > Tired of spam?  Yahoo! Mail has the best spam protection around
> > http://mail.yahoo.com
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest@altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

From chakritsus at yahoo.com  Sun May 14 08:34:41 2006
From: chakritsus at yahoo.com (Tutika Chakravarthy)
Date: Sun May 14 08:34:52 2006
Subject: [concurrency-interest] Question about Double-checked locking
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEIDGOAA.dcholmes@optusnet.com.au>
Message-ID: <20060514123441.24210.qmail@web35703.mail.mud.yahoo.com>

> > No changing from synchronized to Lock doesn't make
> a difference to the
> > double-check part. You must establish a
> "happens-before" relationship
> > between the thread setting the value in the map,
> and the thread
> > reading it.

Can you elaborate "happens-before" relationship part?
Suppose If I replace HashMap wih ConcurrentHashMap,
How can I avoid double-checked locking problem.
My Aim is that if the value is not present in the map
for a key , load it from Database. Otherwise simply
use get() method  and return it.

Tutika

__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From doron at rajwan.org  Sun May 14 10:00:20 2006
From: doron at rajwan.org (Doron Rajwan)
Date: Sun May 14 10:00:34 2006
Subject: [concurrency-interest] RE: Question about Double-checked locking 
Message-ID: <20060514140020.79094.qmail@web52610.mail.yahoo.com>


It seems to me that you want two different type of
locks here:
1. locking the map, for "fast" actions.
2. locking a specific key, in order not to load it
from database twice.

If this is correct, just change the map to
sychronizedMap or to ConcurrentHashMap, and the code
will be correct. It will still have locks, even in the
read-only case, however.

Doron


______________________________________________________
Doron Rajwan, doron@rajwan.org, http://www.rajwan.org

From dcholmes at optusnet.com.au  Sun May 14 17:35:50 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sun May 14 17:36:15 2006
Subject: [concurrency-interest] Question about Double-checked locking
In-Reply-To: <20060514123441.24210.qmail@web35703.mail.mud.yahoo.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEIGGOAA.dcholmes@optusnet.com.au>

> Can you elaborate "happens-before" relationship part?

The happens-before relationship is the formal part of the Java Memory Model
that controls the possible outcomes for concurrent reads and writes of a
variable. If a thread A writes a value V to a variable X and thread B reads
X, then for B to see V the write by A must "happen-before" the read by B.
Otherwise B can see a value previously written to X.

Within a thread each program statement happens-before the next, according to
program order. To create cross-thread happens-before relationships you have
to use synchronization tools, like Locks, sync regions, or volatiles. In
simple terms if thread B acquires a given lock after thread A releases it,
then everything that happened in thread A before the releases happens-before
anything in thread B that occurs after the acquire - so any values written
by A will be read by B.

I'm sure someone else can give you a quick link to further details.

> Suppose If I replace HashMap wih ConcurrentHashMap,
> How can I avoid double-checked locking problem.
> My Aim is that if the value is not present in the map
> for a key , load it from Database. Otherwise simply
> use get() method  and return it.

There's a good answer coming on this - stay tuned.

Right now I have to fly.

Cheers,
David Holmes

From dawidk at mathcs.emory.edu  Sun May 14 23:31:49 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Sun May 14 23:31:57 2006
Subject: [concurrency-interest] interrupt / notify races even in 6.0 beta?
Message-ID: <4467F625.60103@mathcs.emory.edu>

The following code:

*public* *class* Test {
    *public* static void main(*String*[] args) *throws* *Exception* {
        final *Object* lock = *new* *Object*();
        *Thread* t = *new* *Thread*() {
            *public* void run() {
                *try* {
                    *synchronized* (lock) { lock.wait(); }
                    *System*.out.println("Awaken");
                } *catch* (*InterruptedException* e) {
                    *System*.out.println("Interrupted");
                }
            }
        };
        t.start();
        *Thread*.sleep(100);
        t.interrupt();
        *synchronized* (lock) { lock.notify(); }
        t.join();
    }
}


reports "Awaken" instead of "Interrupted" on all JVMs I tested it, 
including jdk6.0beta for Linux, as well as the latest 5.0 and 1.4.2 JVMs 
from SUN and IBM. I thought that the race between notify and interrupt 
has been long fixed?... This problem causes the backported ReentrantLock 
to miss the interruption and fail on 
ReentrantLockTest.testLockInterruptibly1(). What to think? And how come 
j.u.c.ReentrantLock is not affected?

Regards,
Dawid

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060514/d13f3824/attachment.html
From hanson.char at gmail.com  Sun May 14 23:54:49 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Sun May 14 23:54:57 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "Mayfail
	spuriously"?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>
References: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>
Message-ID: <ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>

Thanks for explaining.

Does the following code look good to you ?  Is it a good case or "proper"
use of weakCompareAndSet ?
Hanson

public class Foo {
    private volatile int latency = -1;
    private final AtomicInteger maxLatency = new AtomicInteger(-1);

    public void setLatency(int latency)
    {
        this.latency = latency;
        updateMaxLatency(latency);
    }

    private void updateMaxLatency(int latency)
    {
        for (;;) {
            int maxLatencySnapshot = this.maxLatency.get();

            if (latency > maxLatencySnapshot)
            {
                if (this.maxLatency.weakCompareAndSet(maxLatencySnapshot,
latency))
                    return; // new max succesfully set
                // race condition or just fail spuriously; so let's retry
                continue;
            }
            return;
        }
    }
}


On 5/14/06, David Holmes <dcholmes@optusnet.com.au> wrote:
>
>  If it fails it just returns false and doesn't set the value.
>
> The "weak" aspect of this is that it can fail for reasons other than the
> current value not matching the expected value. It still has well-defined
> behaviour.
>
> If you are interested in the details on platforms that provide load-linked
> and store-conditional instructions (ll/sc), these are used to emulate
> CompareAndSwap. But a store conditional can fail for reasons other than the
> target memory location being written to by some other thread - the
> granularity is typically a cache-line, so a write to a close variable can
> cause the SC to fail. Even if the same value was written into the variable
> the SC would still fail. So typically you use ll/sc in a retry loop until
> you either succeed or determine the failure was due to the current value not
> being the expected value. This gives you the strong compareAndSet semantics.
> The weakCompareAndSet doesn't use the loop.
>
> Cheers,
> David Holmes
>
> -----Original Message-----
> *From:* concurrency-interest-bounces@cs.oswego.edu [mailto:
> concurrency-interest-bounces@cs.oswego.edu]*On Behalf Of *Hanson Char
> *Sent:* Sunday, 14 May 2006 5:05 PM
> *To:* Doug Lea
> *Cc:* concurrency-interest@cs.oswego.edu
> *Subject:* Re: [concurrency-interest] AtomicReference weakCompareAndSet
> "Mayfail spuriously"?
>
> I've gone thru the javadoc, but would like to clarify further.
>
> In case when the invocation of
>
>   weakCompareAndSet
>
> does fail, what behavior could we expect from the failure ?
>
> 1) corrupted data being set ? or
> 2) runtime exception or error being thrown ? or
> 3) the method (weakCompareAndSet) did not set the value but return true ?
> or
> 4) the method did set the value but return false ? or
> 5) the method just failed but the behavior is non-deterministic ?
>
> Hanson
>
> On 2/2/06, Doug Lea <dl@cs.oswego.edu > wrote:
> >
> > Robert Kuhar wrote:
> > > I was strolling through the Docs one day, and came upon the JDK 1.5Javadocs
> > > for Class java.util.concurrent.atomic.AtomicReference.  The
> > description for the
> > > weakCompareAndSet method confuses me:
> > >
> > >   public final boolean weakCompareAndSet(V expect, V update)
> > >
> > >   Atomically set the value to the given updated value if the current
> > >   value == the expected value. May fail spuriously.
> > >
> > >   Parameters:
> > >     expect - the expected value
> > >     update - the new value
> > >   Returns:
> > >     true if successful.
> > >
> > > What does "May fail spuriously" mean?  Why would it fail
> > spuriously?  When the
> > > spurious failures occur, is the return value always false?  Why would
> > anyone
> > > call this method having been warned that "spurious failure" is
> > possible?  I
> > > think I'm missing something here.
> > >
> >
> > See
> > http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/package-summary.html
> >
> >
> > The javadocs in the atomic package also mention that this form may be
> > more
> > efficient. (At least on some processors; on most (in fact all supported
> > by
> > hotspot) it actually compiles to the same code.) The reason that it may
> > be more
> > efficient is that some processors perform CAS via a pair of Load-linked
> > /
> > Store-conditional instructions, which may fail if some other processor
> > happened to write to the same cache line, among other reasons that have
> > nothing to do with the CAS. In some cases, this is acceptable. On
> > such processors, a full strong CAS must actually be coded internally
> > as a loop. There are a handfull of non-blocking algorithms out there
> > where you don't actually want that loop, so we include this method
> > so you can avoid it. We expect use of this method to be uncommon.
> >
> > -Doug
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest@altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060514/61797fdc/attachment.html
From dl at cs.oswego.edu  Mon May 15 06:53:06 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon May 15 06:53:09 2006
Subject: [concurrency-interest] Lazy concurrent map value initialization
Message-ID: <44685D92.4020504@cs.oswego.edu>

Lazy initialization of map values in ConcurrentMaps is starting to be
a FAQ. It is a variant of the famous double-checked lazy
initialization problem. In both cases, there are no universal answers, but
some common approaches.  Here's a start, including some variants that
Joe has posted in reply to similar questions.  Feel free to add
others.

Problem:
   You have a ConcurrentMap map, where each key maps to a value that
   should be constructed and put into the map only if the key is not
   already mapped.

Solutions

1. Just use map.putIfAbsent(key, new Value(...)).

This applies when constructing the Value doesn't have any irreversible
side effects, so it doesn't hurt to throw it away if already entered
into the map. When contention is expected to be rare, it is even OK if
constructing a new Value is expensive, since it will rarely happen.
(In general, don't be too afraid of occasionally wasting effort
especially on multiprocessors. It is usually cheaper than
blocking. But always verify whether this holds in your application.)

(Aside. The Java Concurrency in Practice book has some examples of
such usages.)

1a. You can further minimize wasted effort by using:
     if (!map.contains(key))
       map.putIfAbsent(key, new Value(...));

This narrows the window in which you might create multiple Values,
but adds overhead for each put.

1b. If applicable, you can also invoke a rollback action if you
lose race to insert, as in:
     if (!map.contains(key))
       if (map.putIfAbsent(key, new Value(...) != null))
          undoEffectsOfCallingNewValue(...);

This might apply if you need to close a connection or somesuch.


2. Use a wrapper around Value classes that perform lazy initialization
on first access. One way to do this is to declare the map as Map<Key,
Future<Value>>, and define a simple custom Future<Value> such as:

   class FutureValue implements Future<Value> {
      private volatile Value value;
      public Value get() {
         Value v = value;
         if (v == null)
            value = v = // initialize, probably under some lock
         return v;
      }
      public boolean isDone() { return value != null; }
      public Value get(long timeout, TimeUnit unit) { return get(); }
      // Don't need cancellation support:
      public boolean isCancelled() { return false; }
      public boolean cancel(boolean interrupt) { return false; }
   }

Or use a FutureTask, especially if you'd like this run in a different
thread. (Java Concurrency in Practice also has some examples of this.)

The main disadvantage is that it imposes an extra level of
indirection, which is usually not a performance concern but may be a
usage concern.  All users of the map must be prepared for map.get(key)
to return a Future, which if non-null, must be dereferenced via
future.get() in order to use.


3. Define the Value class to itself perform lazy initialization on
first use. As in:

   class Value {
      private volatile boolean initialized;
      // lots more fields ...
      public void someMethod() {
         if (!initialized) initialize(); // probably under some lock
         // ... perform method action
      }
   }

This has the disadvantage of requiring initialization checks
on each method call.


4. Define a special RESERVED sentinel Value, and use it as a
reservation, in code looking something like (there are many variants):

    Value v = map.get(key);
    if (v == null && (v = map.putIfAbsent(key, RESERVED)) == null)
       v = RESERVED;
    if (v == RESERVED) {
       v = // initialize, probably under some lock
       if (!map.replace(key, RESERVED, v))
           v = map.get(key);
    }

This has the disadvantage that all users will need to deal with
RESERVED as a value for get, put, etc. You can/should avoid this by
declaring a special purpose Map class that delegates get, put etc to a
ConcurrentMap, and performs these actions inside get, put, etc.  Also,
it only applies when you can come up with a reasonable RESERVED
value. Without generics, you can use
   static final RESERVED = new Object();
With generics, you'd need to either find a way for RESERVED to be an
actual instance of Value class, or internally use a raw Object type,
and use casts within each method.


5. Instead of calling new Value(...) call a factory method that
returns an existing instance if available, as in
   map.putIfAbsent(key, Value.create(...));
This just defers the issue one level deeper, but might apply if for
example Value is a singleton object, in which case you can use either
double-check (with a volatile reference!) or static holders.


6. Give up on ConcurrentMaps, and use custom synchronization wrappers
on unsynchronized maps (HashMap, TreeMap). You can then define
   synchronized void createIfAbsent(K key) {
     if (!map.contains(key))
         map.put(key, new Value())
    }

The disadvantage is much poorer throughput for concurrent operations.

From dl at cs.oswego.edu  Mon May 15 07:41:12 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon May 15 07:41:16 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "Mayfail
	spuriously"?
In-Reply-To: <ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>
References: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>
	<ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>
Message-ID: <446868D8.4080305@cs.oswego.edu>

Hanson Char wrote:
> 
> Does the following code look good to you ?  Is it a good case or 
> "proper" use of weakCompareAndSet ? 


Yes, this is fine; it is a good example where either the plain or
the weak form would work just as well, so you might as well use
the weak form.

> 
> public class Foo {
>     private volatile int latency = -1;
>     private final AtomicInteger maxLatency = new AtomicInteger(-1);
> 
>     public void setLatency(int latency)
>     {
>         this.latency = latency;
>         updateMaxLatency(latency);
>     }
> 
>     private void updateMaxLatency(int latency)
>     {
>         for (;;) {
>             int maxLatencySnapshot = this.maxLatency.get();
>            
>             if (latency > maxLatencySnapshot)
>             {
>                 if (this.maxLatency.weakCompareAndSet 
> (maxLatencySnapshot, latency))
>                     return; // new max succesfully set
>                 // race condition or just fail spuriously; so let's retry
>                 continue;
>             }
>             return;
>         }
>     }
> }
> 
> 


-Doug

From crazybob at crazybob.org  Mon May 15 17:48:54 2006
From: crazybob at crazybob.org (Bob Lee)
Date: Mon May 15 17:49:00 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "Mayfail
	spuriously"?
In-Reply-To: <446868D8.4080305@cs.oswego.edu>
References: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>
	<ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>
	<446868D8.4080305@cs.oswego.edu>
Message-ID: <a74683f90605151448y4dd4440ej440c12b16e1adb9e@mail.gmail.com>

On 5/15/06, Doug Lea <dl@cs.oswego.edu> wrote:
> Yes, this is fine; it is a good example where either the plain or
> the weak form would work just as well, so you might as well use
> the weak form.

Can you please provide an example of when you'd use one or the other?

Bob

From dl at cs.oswego.edu  Mon May 15 20:17:39 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon May 15 20:17:42 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "Mayfail
	spuriously"?
In-Reply-To: <a74683f90605151448y4dd4440ej440c12b16e1adb9e@mail.gmail.com>
References: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>	<ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>	<446868D8.4080305@cs.oswego.edu>
	<a74683f90605151448y4dd4440ej440c12b16e1adb9e@mail.gmail.com>
Message-ID: <44691A23.7040803@cs.oswego.edu>

Bob Lee wrote:
> On 5/15/06, Doug Lea <dl@cs.oswego.edu> wrote:
>> Yes, this is fine; it is a good example where either the plain or
>> the weak form would work just as well, so you might as well use
>> the weak form.
> 
> Can you please provide an example of when you'd use one or the other?
> 

Plain compareAndSet is always preferred when failure is informative.
A false return from x.compareAndSet(expected, newValue) tells you that the
current value is NOT equal to expected.

For example, suppose you have an AtomicInteger x serving as a lock or semaphore
of some sort. In that case you can write
   if (!x.compareAndSet(0, 1))
     // then lock must already be busy
     // ...



-Doug
From dawidk at mathcs.emory.edu  Tue May 16 00:17:28 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue May 16 00:17:34 2006
Subject: [concurrency-interest] Re: interrupt / notify races even in 6.0
	beta?
In-Reply-To: <44686AAE.1010801@cs.oswego.edu>
References: <4467F625.60103@mathcs.emory.edu> <44686AAE.1010801@cs.oswego.edu>
Message-ID: <44695258.5000404@mathcs.emory.edu>

Doug Lea wrote:
> Dawid Kurzyniec wrote:
>>
>>
>> reports "Awaken" instead of "Interrupted" on all JVMs I tested it, 
>
> Are you sure?? It reports "interrupted" on all that I've tried it
> on, including 5.0 and mustang on both linux and solaris, and IBM 5.0
> on linux.

OK, so here's what I got after running a revised test program below on 
the machines I have access to:

*public* *class* Test *extends* *Thread* {

    final static *Object* lock = *new* *Object*();

    *public* void run() {
        *try* {
            *synchronized* (lock) { lock.wait(); }
            *System*.out.println("Awaken");
        } *catch* (*InterruptedException* e) {
            *System*.out.println("Interrupted");
        }
    }

    *public* static void main(*String*[] args) *throws* *Exception* {
        *Thread* t;
        t = *new* Test();
        t.start();
        *Thread*.sleep(100);
        t.interrupt();
        *synchronized* (lock) { lock.notify(); }
        t.join();
        t = *new* Test();
        t.start();
        *Thread*.sleep(100);
        *synchronized* (lock) { lock.notify(); }
        t.interrupt();
        t.join();
        *System*.out.println("Should be: first Interrupted; then Awaken");
        *System*.out.flush();
    }
}


Linux, 2 different machines but both with Mandriva 2006 and kernel 
2.6.12-12mdk-i686-up-4GB:

IBM 1.4.2, build cxia32142ifx-20060209 (SR4-1): Interrupted, Interrupted
IBM 1.5.0, build 2.3 x86-32 j9vmxi3223ifx-20060124: Awaken, Awaken

SUN: 1.4.1, 1.4.1_01, 1.4.2, 1.4.2_03, 1.4.2_06, 1.4.2_08, 1.5.0-beta, 
1.5.0-beta2, 1.5.0, 1.5.0_06, 1.6.0-beta (b59g): all Awaken, Awaken!


Solaris SPARC, SunOS 5.10 Generic_118822-25 sun4u:

SUN 1.3.1_02, 1.4.0_01, 1.4.1_01, 1.4.2_02, 1.4.2_06: Awaken, Awaken
SUN 1.5.0: Interrupted, Awaken (correct)
SUN 1.2.1_03: Interrupted, Interrupted (ocassionally the 2nd one is Awaken)

Windows XP SP2:

1.4.2_05, 1.5.0_06: Interrupted, Awaken (correct)


I suspect that on IBM SP2, I'd probably see Interrupted, Interrupted - 
judging from past backport bug reports.

It seems that this race is more pervasive that I thought. (I had the 
impression that it has been fixed somewhere in the 1.4 line). It means 
that the backport must bite the bullet. I am probably going to relax the 
unit test a little bit (by inserting a short sleep between interrupt() 
and notify()) to make it pass. (For anxious backport users: I wouldn't 
worry too much about it; the revised unit test is arguably unfairly 
pessimistic from the usage patterns point of view, and the code that now 
started failing the test is exactly the same as the one that we all 
happily used since dl.util.concurrent).

The continuous presence of this race in 1.5 and Mustang on Linux is the 
troubling, though. Since Doug says it's working for him, I am guessing 
that the problem may have something to do with the kernel version?... It 
would be good if somebody tested it on some other Linux boxes.

Regards,
Dawid

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060516/c6a9150f/attachment.html
From moran at gigaspaces.com  Tue May 16 04:23:49 2006
From: moran at gigaspaces.com (Moran Avigdor)
Date: Tue May 16 03:23:45 2006
Subject: [concurrency-interest] ReadWriteUpgradeLock
Message-ID: <44698C15.1020302@gigaspaces.com>

An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060516/e1eddd99/attachment.html
From holger at wizards.de  Tue May 16 04:02:44 2006
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Tue May 16 04:03:01 2006
Subject: [concurrency-interest] interrupt / notify races even in 6.0 beta?
In-Reply-To: <4467F625.60103@mathcs.emory.edu>
References: <4467F625.60103@mathcs.emory.edu>
Message-ID: <44698724.5000506@wizards.de>

Dawid,

I extended the test to collect results for multiple runs. I then ran this
for longer periods and got some more interesting results.
	
1) Linux version 2.6.16.9 (Gentoo), no preemptible scheduler or other toys
configured ('vanilla' as it can get), glibc 2.4 and Sun JDKs 1.4.2.11,
1.5.0.06 and Mustang b82 consistently gives A-A (i.e. 'wrong' behaviour)
every time, regardless how many samples I run.

2) Windows XP SP1, Sun JDK 1.4.2.09, 1.5.0.06 and Mustang b82 relatively
consistently give I-A with the occasional A-A. Multipe test runs are
necessary to observe this; in other words it happens on Windows too.

The modified test is attached.

Holger
-------------- next part --------------

import java.util.List;
import java.util.ArrayList;

public class Test extends Thread {

	public static int NUM = 10;
	public static int SLEEP = 100;
	public static List values = new ArrayList();

	public static volatile char s;

    final static Object lock = new Object();

    public void run() {
        try {
            synchronized (lock) { lock.wait(); }
            s = 'A';
        } catch (InterruptedException e) {
        	s = 'I';
        }
    }

    public static void main(String[] args) throws Exception {
    
		for (int i = 0; i < NUM; i++)
		{
			Thread t;
			t = new Test();
			t.start();
			Thread.sleep(SLEEP);
			t.interrupt();
			synchronized (lock) { lock.notify(); }
			t.join();
			char s1 = s;

			t = new Test();
			t.start();
			Thread.sleep(SLEEP);
			synchronized (lock) { lock.notify(); }
			t.interrupt();
			t.join();
			char s2 = s;

			values.add(new String(new char[]{s1, s2}));

			Thread.sleep(SLEEP*2);
		}

		System.out.println(values);
    }
}

From dl at cs.oswego.edu  Tue May 16 09:11:56 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue May 16 09:12:00 2006
Subject: [concurrency-interest] Re: interrupt / notify races even in 6.0
	beta?
In-Reply-To: <44695258.5000404@mathcs.emory.edu>
References: <4467F625.60103@mathcs.emory.edu> <44686AAE.1010801@cs.oswego.edu>
	<44695258.5000404@mathcs.emory.edu>
Message-ID: <4469CF9C.4000402@cs.oswego.edu>

First, note that the JLS-3 specs allow some non-determinism here. See
   http://java.sun.com/docs/books/jls/third_edition/html/memory.html
Which says...
[Sec 17.8.4]
   The above specifications allow us to determine several properties having to do
   with the interaction of waits, notification and interruption. If a thread is
   both notified and interrupted while waiting, it may either:

     * return normally from wait, while still having a pending interrupt (in 
other works, a call to Thread.interrupted would return true)
     * return from wait by throwing an InterruptedException

   The thread may not reset its interrupt status and return normally from the
   call to wait.

   Similarly, notifications cannot be lost due to interrupts. Assume that a set s
   of threads is in the wait set of an object m, and another thread performs a
   notify on m. Then either

     * at least one thread in s must return normally from wait, or
     * all of the threads in s must exit wait by throwing InterruptedException

   Note that if a thread is both interrupted and woken via notify, and that
   thread returns from wait by throwing an InterruptedException, then some other
   thread in the wait set must be notified.
[BTW: notice the typo "in other works"!]

This boils down to saying that there are two forbidden outcomes:
   1. A thread woken up via notify does not "lose" its interrupt status.
   2. An InterruptedException does not "lose" the fact there is a
      pending notification (that may wake up some other waiting thread).

These are the "bugs" fixed in 1.5 JVMs in accord with JSR133 specs.

I just threw together a little test program (attached) to verify that
#1 does not happen. It doesn't on the JVMs/platforms I've checked.
(This is not a pretty program because it has to
use spins/yields to advance the threads so as not to contaminate
with additional locks, waits, or sleeps.)

However, it is the case that on all platforms I've tried, sometimes
the "notifyBeforeInterrupt" method says it was interrupted before
notified, and vice versa. This reflects the unavoidable race here,
that will come out one way or the other depending on exactly what
the target thread is doing when signaller invokes notify or interrupt.

(There are also some tests for #2 around developed during JSR133,
but I'm not sure where they are.)


-Doug
-------------- next part --------------
A non-text attachment was scrubbed...
Name: T516.java
Type: text/x-java
Size: 2720 bytes
Desc: not available
Url : /pipermail/attachments/20060516/5c4a3caa/T516.bin
From bart.jacobs at cs.kuleuven.ac.be  Tue May 16 10:35:51 2006
From: bart.jacobs at cs.kuleuven.ac.be (Bart Jacobs)
Date: Tue May 16 10:40:02 2006
Subject: [concurrency-interest] Re: interrupt / notify races even in 6.0
	beta?
In-Reply-To: <4469CF9C.4000402@cs.oswego.edu>
References: <4467F625.60103@mathcs.emory.edu>
	<44686AAE.1010801@cs.oswego.edu>	<44695258.5000404@mathcs.emory.edu>
	<4469CF9C.4000402@cs.oswego.edu>
Message-ID: <4469E347.5090207@cs.kuleuven.ac.be>

Dawid's test case has the special circumstance that the notify() and the 
interrupt() occur in the same thread. The question is: are both of these 
calls considered to occur "while [the target thread is] waiting" or not?

Arguments pro:
- There is no synchronizes-with edge from the wait to the 
notify()/interrupt() call.
- Section 17.8.1 says:

Each thread must determine an order over the events that could cause it 
to be removed from a wait set. That order does not have to be consistent 
with other orderings, but the thread must behave as though those events 
occurred in that order.

So the order does not have to be consistent with program order.

Argument contra:
- A reader could be forgiven for thinking that after a 
notify()/interrupt() call, the target thread is not longer considered to 
be waiting, and therefore, operations that happen-after the 
notify()/interrupt() call do not occur "while [the target thread is] 
waiting" and "could [not] cause it to be removed from a wait set". As a 
result, neither 17.8.1 nor 17.8.4 would apply in the first place.

So it seems it would help if the JLS clarified the meaning of "while 
waiting" (both for 17.8.1 and 17.8.4), by saying that the thread "stops 
waiting" sometime after the notify()/interrupt() call, and therefore is 
still considered to "be waiting" until such time.

Bart

Doug Lea wrote:

> First, note that the JLS-3 specs allow some non-determinism here. See
>   http://java.sun.com/docs/books/jls/third_edition/html/memory.html
> Which says...
> [Sec 17.8.4]
>   The above specifications allow us to determine several properties 
> having to do
>   with the interaction of waits, notification and interruption. If a 
> thread is
>   both notified and interrupted while waiting, it may either:
>
>     * return normally from wait, while still having a pending 
> interrupt (in other works, a call to Thread.interrupted would return 
> true)
>     * return from wait by throwing an InterruptedException
>
>   The thread may not reset its interrupt status and return normally 
> from the
>   call to wait.
>
>   Similarly, notifications cannot be lost due to interrupts. Assume 
> that a set s
>   of threads is in the wait set of an object m, and another thread 
> performs a
>   notify on m. Then either
>
>     * at least one thread in s must return normally from wait, or
>     * all of the threads in s must exit wait by throwing 
> InterruptedException
>
>   Note that if a thread is both interrupted and woken via notify, and 
> that
>   thread returns from wait by throwing an InterruptedException, then 
> some other
>   thread in the wait set must be notified.
> [BTW: notice the typo "in other works"!]
>
> This boils down to saying that there are two forbidden outcomes:
>   1. A thread woken up via notify does not "lose" its interrupt status.
>   2. An InterruptedException does not "lose" the fact there is a
>      pending notification (that may wake up some other waiting thread).
>
> These are the "bugs" fixed in 1.5 JVMs in accord with JSR133 specs.
>
> I just threw together a little test program (attached) to verify that
> #1 does not happen. It doesn't on the JVMs/platforms I've checked.
> (This is not a pretty program because it has to
> use spins/yields to advance the threads so as not to contaminate
> with additional locks, waits, or sleeps.)
>
> However, it is the case that on all platforms I've tried, sometimes
> the "notifyBeforeInterrupt" method says it was interrupted before
> notified, and vice versa. This reflects the unavoidable race here,
> that will come out one way or the other depending on exactly what
> the target thread is doing when signaller invokes notify or interrupt.
>
> (There are also some tests for #2 around developed during JSR133,
> but I'm not sure where they are.)
>
>
> -Doug
>
>------------------------------------------------------------------------
>
>public class T516 extends Thread {
>    static final int NTESTS = 100;
>    static final int ITERS_PER_TEST = 50;
>    static final int NORMAL = 1;
>    static final int INTERRUPTED = 2;
>    volatile int waitStatus;
>    volatile int exitStatus;
>    volatile boolean started;
>    volatile boolean stop;
>    final Object lock = new Object();
>
>    public void run() {
>        started = true;
>        synchronized(lock) {
>            try {
>                lock.wait(); 
>                waitStatus = NORMAL;
>            } catch (InterruptedException e) {
>                waitStatus = INTERRUPTED;
>            }
>        }
>        while (!stop) 
>            Thread.yield();
>        exitStatus = interrupted()? INTERRUPTED : NORMAL;
>    }
>
>    public static void main(String[] args) throws Exception {
>        for (int i = 0; i < NTESTS; ++i) {
>            interruptBeforeNotify();
>            notifyBeforeInterrupt();
>        }
>    }
>
>    static void interruptBeforeNotify() throws Exception {
>        for (int i = 0; i < ITERS_PER_TEST; i++) {
>            T516 t = new T516();
>            t.start();
>            while (!t.started)
>                Thread.yield();
>            t.interrupt();
>            synchronized (t.lock) { t.lock.notify(); }
>            while(t.waitStatus == 0)
>                Thread.yield();
>            t.stop = true;
>            while(t.exitStatus == 0)
>                Thread.yield();
>            int r = t.waitStatus;
>            int e = t.exitStatus;
>            if (r == NORMAL && e == NORMAL) 
>                throw new Error("Notified but not interrupted");
>            else if (r == NORMAL) System.out.print("n");
>            else if (r == INTERRUPTED) System.out.print("i");
>            else throw new Error("Cannot happen");
>            t.join();
>        }
>
>        System.out.println();
>    }
>
>    
>    static void notifyBeforeInterrupt() throws Exception {
>        for (int i = 0; i < ITERS_PER_TEST; i++) {
>            T516 t = new T516();
>            t.start();
>            while (!t.started)
>                Thread.yield();
>            synchronized (t.lock) { t.lock.notify(); }
>            t.interrupt();
>            while(t.waitStatus == 0)
>                Thread.yield();
>            t.stop = true;
>            while(t.exitStatus == 0)
>                Thread.yield();
>            int r = t.waitStatus;
>            int e = t.exitStatus;
>            if (r == NORMAL && e == NORMAL) 
>                throw new Error("Notified but not interrupted");
>            else if (r == NORMAL) System.out.print("N");
>            else if (r == INTERRUPTED) System.out.print("I");
>            else throw new Error("Cannot happen");
>            t.join();
>        }
>        System.out.println();
>    }
>}
>
>
>
>  
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest@altair.cs.oswego.edu
>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  
>


Disclaimer: http://www.kuleuven.be/cwis/email_disclaimer.htm

From dawidk at mathcs.emory.edu  Tue May 16 10:59:51 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue May 16 11:00:04 2006
Subject: [concurrency-interest] Re: interrupt / notify races even in 
	6.0beta?
In-Reply-To: <4469E347.5090207@cs.kuleuven.ac.be>
References: <4467F625.60103@mathcs.emory.edu> 
	<44686AAE.1010801@cs.oswego.edu>	<44695258.5000404@mathcs.emory.edu> 
	<4469CF9C.4000402@cs.oswego.edu> <4469E347.5090207@cs.kuleuven.ac.be>
Message-ID: <4469E8E7.6010608@mathcs.emory.edu>

Bart Jacobs wrote:
> (...)
> Argument contra:
> - A reader could be forgiven for thinking that after a 
> notify()/interrupt() call, the target thread is not longer considered 
> to be waiting, and therefore, operations that happen-after the 
> notify()/interrupt() call do not occur "while [the target thread is] 
> waiting" and "could [not] cause it to be removed from a wait set". As 
> a result, neither 17.8.1 nor 17.8.4 would apply in the first place.
>

Exactly. My intuitive expectation would be that the call to interrupt() 
is synchronous, i.e. does not return until the thread has the interrupt 
flag set, and has been removed from the wait set. If that happened, the 
subsequent notify() from the same thread would have no effect. It seems 
that most JVMs currently implement interrupt() asynchronously, which 
leads to the possibility that the notify() shortly following interrupt() 
may succeed before the interrupt() finishes. If keeping the weaker 
asynchronous semantics is necessary due to practical purposes, I think 
it should be documented in Thread.interrupt() javadoc. Although I can't 
see what would be wrong with making interrupt synchronous?...

Regards,
Dawid

From dl at cs.oswego.edu  Tue May 16 11:26:48 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue May 16 11:26:53 2006
Subject: [concurrency-interest] Re: interrupt / notify races even in 6.0
	beta?
In-Reply-To: <4469E347.5090207@cs.kuleuven.ac.be>
References: <4467F625.60103@mathcs.emory.edu>	<44686AAE.1010801@cs.oswego.edu>	<44695258.5000404@mathcs.emory.edu>	<4469CF9C.4000402@cs.oswego.edu>
	<4469E347.5090207@cs.kuleuven.ac.be>
Message-ID: <4469EF38.2000204@cs.oswego.edu>

Bart Jacobs wrote:
> 
> So it seems it would help if the JLS clarified the meaning of "while 
> waiting" (both for 17.8.1 and 17.8.4), by saying that the thread "stops 
> waiting" sometime after the notify()/interrupt() call, and therefore is 
> still considered to "be waiting" until such time.
> 

Yes; this is a good idea.

The effects seen here might seem less mysterious if you know
the basic implementation scheme, which is typically the one
documented for AbstractQueuedSynchronizer.Condition.await; see
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html

        1. If current thread is interrupted, throw InterruptedException
        2. Save lock state returned by AbstractQueuedSynchronizer.getState()
        3. Invoke AbstractQueuedSynchronizer.release(int) with saved state as 
argument, throwing IllegalMonitorStateException if it fails.
        4. Block until signalled or interrupted
        5. Reacquire by invoking specialized version of 
AbstractQueuedSynchronizer.acquire(int) with saved state as argument.
        6. If interrupted while blocked in step 4, throw exception


Notice that interrupt status is checked (at least) twice -- on entry, and then
again during/after an OS-level blocking.

This means that response to (notify; interrupt) or (interrupt; notify)
can go either way, depending on whether each came at/before
step 1, or step 4, or later. So even though in the test programs
here, the caller "knows" which came first, it cannot control the
points at which the waiting thread is paying attention to which of these
events.

(This is not a bug; it's a feature! People would not like to use
a condition wait implementation that disables either the "early"
or the "late" checks.)

-Doug


From tim at peierls.net  Tue May 16 20:35:51 2006
From: tim at peierls.net (Tim Peierls)
Date: Tue May 16 20:35:56 2006
Subject: [concurrency-interest] ReadWriteUpgradeLock
In-Reply-To: <44698C15.1020302@gigaspaces.com>
References: <44698C15.1020302@gigaspaces.com>
Message-ID: <63b4e4050605161735n9291858tfe3788eea75a3c23@mail.gmail.com>

If you find yourself rolling your own read-to-write upgradeable lock, you
might find it useful to go through some earlier discussion on a related
topic on this list. A reasonable starting point is
http://altair.cs.oswego.edu/mailman/private/concurrency-interest/2005-February/001341.html--
not much progress since then, sad to say.

--tim

On 5/16/06, Moran Avigdor <moran@gigaspaces.com> wrote:
>
>  Hi,
>     I was looking for something similar to *ReadWriteUpgradeLock* in the
> concurrency package.
>     see:
> http://jakarta.apache.org/commons/transaction/apidocs/org/apache/commons/transaction/locking/ReadWriteUpgradeLock.html
>
>     Upgrading from a read lock to a write lock with *
> java.util.concurrent.locks.ReentrantReadWriteLock *is not possible unless
> the read lock
>     is released. This entails that if conditions were met prior to the
> write lock, they need to be re-checked.
>
>     Is there a way, so that a thread that holds a read lock can acquire a
> write lock without releasing the read lock first?
>
>     Thanks in advance.
>
> *Moran Avigdor* R&D Engineer
> Cell: +972 54 2112783
> moran@gigaspaces.comwww.gigaspaces.com
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060516/41d4fd29/attachment.html
From dawidk at mathcs.emory.edu  Wed May 17 00:45:09 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed May 17 00:45:29 2006
Subject: [concurrency-interest] Re: interrupt / notify races even in 
	6.0beta?
In-Reply-To: <4469EF38.2000204@cs.oswego.edu>
References: <4467F625.60103@mathcs.emory.edu>	<44686AAE.1010801@cs.oswego.ed
	u>	<44695258.5000404@mathcs.emory.edu>	<4469CF9C.4000402@cs.oswego.edu><44
	6	9E347.5090207@cs.kuleuven.ac.be> <4469EF38.2000204@cs.oswego.edu>
Message-ID: <446AAA55.4050301@mathcs.emory.edu>

Doug Lea wrote:
> Bart Jacobs wrote:
>>
>> So it seems it would help if the JLS clarified the meaning of "while 
>> waiting" (both for 17.8.1 and 17.8.4), by saying that the thread 
>> "stops waiting" sometime after the notify()/interrupt() call, and 
>> therefore is still considered to "be waiting" until such time.
>>
>
> Yes; this is a good idea.
>
> The effects seen here might seem less mysterious if you know
> the basic implementation scheme, which is typically the one
> documented for AbstractQueuedSynchronizer.Condition.await; see
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html 
>
>
>        1. If current thread is interrupted, throw InterruptedException
>        2. Save lock state returned by 
> AbstractQueuedSynchronizer.getState()
>        3. Invoke AbstractQueuedSynchronizer.release(int) with saved 
> state as argument, throwing IllegalMonitorStateException if it fails.
>        4. Block until signalled or interrupted
>        5. Reacquire by invoking specialized version of 
> AbstractQueuedSynchronizer.acquire(int) with saved state as argument.
>        6. If interrupted while blocked in step 4, throw exception
>
>
> Notice that interrupt status is checked (at least) twice -- on entry, 
> and then
> again during/after an OS-level blocking.
>
> This means that response to (notify; interrupt) or (interrupt; notify)
> can go either way, depending on whether each came at/before
> step 1, or step 4, or later. So even though in the test programs
> here, the caller "knows" which came first, it cannot control the
> points at which the waiting thread is paying attention to which of these
> events.
>

I guess in this particular case we're only talking about the 
interruption during OS-level blocking in step 4.

I realize that you (EG) have dealt with this issue for decades now; so 
please have a little patience with me here; I'd like to understand the 
problem fully to make sure that I don't screw up anything in the 
backport. It is no mystery that there is a possible race between notify 
/ interrupt, as it is between memory read / write, when there is no 
happens-before relationship between these operations. Ideally, and 
intuitively however, I would expect that the ordering of notify / 
interrupt becomes deterministic when there is a happens-before 
relationship, e.g. if the operations are invoked from the same thread. 
Apparently, it is not the case, and the spec does not actually promise 
it. I am trying to understand why it can't be made to be the case. For 
instance, why can't the interruption status be combined with a thread 
state (runnable, blocked, waiting, io) into an atomic state variable - 
having interrupt() CAS-ing it to INTERRUPTED, removing the tread from 
the condition's wait set if was WAITING, and having notify() loop 
CAS-ing the state of a candidate thread to RUNNABLE if was WAITING, and 
skipping it over if was INTERRUPTED. Perhaps the problem is that the OS 
layer does not expose things this way?... But then again, with the 
low-level primitives like those used by park/unpark, wouldn't it be 
possible to implement it at the JVM side, without relying on OS-level 
wait sets etc?

In any case, since the ordering is not deterministic, the aforementioned 
ReentrantLock unit test is probably too strict. Would a Thread.yield() 
or a delay inserted between interrupt and notify be a reasonable fix?...

Regards,
Dawid

From dl at cs.oswego.edu  Wed May 17 07:43:24 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed May 17 07:43:28 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "Mayfail
	spuriously"?
In-Reply-To: <a74683f90605151448y4dd4440ej440c12b16e1adb9e@mail.gmail.com>
References: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>	<ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>	<446868D8.4080305@cs.oswego.edu>
	<a74683f90605151448y4dd4440ej440c12b16e1adb9e@mail.gmail.com>
Message-ID: <446B0C5C.4090405@cs.oswego.edu>

Bob Lee wrote:
> On 5/15/06, Doug Lea <dl@cs.oswego.edu> wrote:
>> Yes, this is fine; it is a good example where either the plain or
>> the weak form would work just as well, so you might as well use
>> the weak form.
> 
> Can you please provide an example of when you'd use one or the other?
> 

Thanks to Bill Pugh for reminding me about a second difference
between weakCompareAndSet vs plain compareAndSet, that normally
goes hand-in-hand with the main difference of failure being
uninformative:

A plain compareAndSet has volatile-write memory model semantics, while a
weakCompareAndSet has non-volatile-write memory model semantics.

This mainly means that the visibility of a value written
using weakCompareAndSet does not imply visibility of previous writes by the
thread performing the weakCompareAndSet. This does hold for plain
compareAndSet though. For example

class C { int a; AtomicInteger b = new AtomicInteger(); }
static C c = new C();

Thread 1:
   c.a = 1;
   c.b.compareAndSet(0, 1);

Thread 2;
    if (c.b.get() == 1) assert(c.a == 1);

But if Thread 1 used weakCompareAndSet, the assertion in
Thread 2 need not hold.

This is a little subtle, but is in keeping with the
"uninformativeness" property of weakCompareAndSet.
It implies that weakCompareAndSet is not a good choice for
implementing locks, semaphores, initialization flags, etc, but
we already saw why this was so in last example.

-Doug
From tackline at tackline.plus.com  Wed May 17 09:01:17 2006
From: tackline at tackline.plus.com (Thomas Hawtin)
Date: Wed May 17 09:50:45 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet
	"Mayfailspuriously"?
In-Reply-To: <446B0C5C.4090405@cs.oswego.edu>
References: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>	<ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>	<446868D8.4080305@cs.oswego.edu><a74683f90605151448y4dd4440ej440c12b16e1adb9e@mail.gmail.com>
	<446B0C5C.4090405@cs.oswego.edu>
Message-ID: <446B1E9D.5030104@tackline.plus.com>

Doug Lea wrote:
> 
> A plain compareAndSet has volatile-write memory model semantics, while a
> weakCompareAndSet has non-volatile-write memory model semantics.

And the same for (non-)volatile-read memory model semantics, if my 
reading of the package JavaDocs is correct.

Is there any particular reason for not having a "weakGet" method? Going 
back to Hanson Char's example:

  int maxLatencySnapshot = this.maxLatency.get();
  if (latency > maxLatencySnapshot) {
    if (this.maxLatency.weakCompareAndSet(maxLatencySnapshot, latency)) {

Most of the gains that may be made from using weakCompareAndSet seem to 
be blown away by the get. (Sun's implementation doesn't seem to 
differentiate between weakCompareAndSet and compareAndSet, at the moment.)


Tom Hawtin
From dl at cs.oswego.edu  Wed May 17 10:55:36 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed May 17 10:55:39 2006
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <446B1E9D.5030104@tackline.plus.com>
References: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>	<ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>	<446868D8.4080305@cs.oswego.edu><a74683f90605151448y4dd4440ej440c12b16e1adb9e@mail.gmail.com>	<446B0C5C.4090405@cs.oswego.edu>
	<446B1E9D.5030104@tackline.plus.com>
Message-ID: <446B3968.8030502@cs.oswego.edu>

Thomas Hawtin wrote:
> Doug Lea wrote:
>>
>> A plain compareAndSet has volatile-write memory model semantics, while a
>> weakCompareAndSet has non-volatile-write memory model semantics.
> 
> And the same for (non-)volatile-read memory model semantics, if my 
> reading of the package JavaDocs is correct.
> 
> Is there any particular reason for not having a "weakGet" method? Going 
> back to Hanson Char's example:
> 
>  int maxLatencySnapshot = this.maxLatency.get();
>  if (latency > maxLatencySnapshot) {
>    if (this.maxLatency.weakCompareAndSet(maxLatencySnapshot, latency)) {
> 
> Most of the gains that may be made from using weakCompareAndSet seem to 
> be blown away by the get. (Sun's implementation doesn't seem to 
> differentiate between weakCompareAndSet and compareAndSet, at the moment.)
> 

Generally, volatile-reads are cheap -- the main cost
is suppressing optimizations/reorderings. On most machines,
they don't generate machine-level barriers, and
on the ones where they do (mainly: Itanium/IA64), they are the
cheapest kind, and so barely measurable.

And the suppressed optimizations/orderings are exactly those you'd need to
suppress in uses like this. Without this, a VM might (depending on
context) forever cache a single read of the value, which would rarely
be useful for an AtomicX. There may be a few use-cases for some kind of
weakGet, but I think they are most rare.

-Doug
From gykwok at yahoo.com  Wed May 17 11:25:43 2006
From: gykwok at yahoo.com (Grace Kwok)
Date: Wed May 17 11:32:20 2006
Subject: [concurrency-interest] Blocking queue
Message-ID: <20060517152543.2785.qmail@web50101.mail.yahoo.com>

Hi,

Conceptually, this is what I'd like to achieve.
Suppose I have two types of tasks they are put in some
kind of queue.

I want to have some number of threads desginated to
block on take() only on type 1 task.

I also want to have some number of threads designated
to take type 2 task and process.
However, if none of the type 2 tasks is available,
then it should take the type 1 task and starts
processing.

Is there any neat way of doing it besides making two
queues and poll on them alternatively?

Thanks!

__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From dawidk at mathcs.emory.edu  Wed May 17 14:06:38 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed May 17 14:06:48 2006
Subject: [concurrency-interest] Blocking queue
In-Reply-To: <20060517152543.2785.qmail@web50101.mail.yahoo.com>
References: <20060517152543.2785.qmail@web50101.mail.yahoo.com>
Message-ID: <446B662E.9080007@mathcs.emory.edu>

Grace Kwok wrote:
> Hi,
>
> Conceptually, this is what I'd like to achieve.
> Suppose I have two types of tasks they are put in some
> kind of queue.
>
> I want to have some number of threads desginated to
> block on take() only on type 1 task.
>
> I also want to have some number of threads designated
> to take type 2 task and process.
> However, if none of the type 2 tasks is available,
> then it should take the type 1 task and starts
> processing.
>
> Is there any neat way of doing it besides making two
> queues and poll on them alternatively?
>   

I'd implement it by writing a custom blocking queue implementation (not 
necessarily implementing the BlockingQueue interface) using two 
non-blocking queues internally and providing its own wait/notification 
mechanisms on top of that, using condition variables. For instance, 
type1queueNotEmpty, anyQueueNotEmpty, type1queueNotFull, and 
type2queueNotFull might be your conditions; the put(type2obj) would 
await on type2queueNotFull, then put, then signal anyQueueNotEmpty. Your 
"takeType1task()" would wait on type1queueNotEmpty, then take, then 
signal type1queueNotFull, etc.

Regards,
Dawid

From pugh at cs.umd.edu  Wed May 17 15:39:36 2006
From: pugh at cs.umd.edu (Bill Pugh)
Date: Wed May 17 15:40:26 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "Mayfail
	spuriously"?
In-Reply-To: <446B0C5C.4090405@cs.oswego.edu>
References: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>	<ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>	<446868D8.4080305@cs.oswego.edu>
	<a74683f90605151448y4dd4440ej440c12b16e1adb9e@mail.gmail.com>
	<446B0C5C.4090405@cs.oswego.edu>
Message-ID: <BE06AD6C-6C95-4ABA-8809-8889C74E9A31@cs.umd.edu>


On May 17, 2006, at 4:43 AM, Doug Lea wrote:

> Bob Lee wrote:
>> On 5/15/06, Doug Lea <dl@cs.oswego.edu> wrote:
>>> Yes, this is fine; it is a good example where either the plain or
>>> the weak form would work just as well, so you might as well use
>>> the weak form.
>> Can you please provide an example of when you'd use one or the other?
>
> Thanks to Bill Pugh for reminding me about a second difference
> between weakCompareAndSet vs plain compareAndSet, that normally
> goes hand-in-hand with the main difference of failure being
> uninformative:
>
> A plain compareAndSet has volatile-write memory model semantics,  
> while a
> weakCompareAndSet has non-volatile-write memory model semantics.
]

I would explain this differently (actually, the JMM requires that it  
be explained differently):

weakCompareAndSet has volatile semantics, _except_ that it doesn't  
create any happens-before
edges.

Thus, using weakCompareAndSet is ideal for things such as performance  
counters,
unique identifiers and reference counting.

However, what about AtomicReference? If you actually try to pass  
references between threads,
you need to establish a happens-before relationship between the two  
threads, so that the contents of
the object are communicated as well.

So, here is the question we should discuss:

**********

Should weakCompareAndSet on an AtomicReference create happens before  
edges (just as
compareAndSwap does)?

**********

For AtomicInteger, and similar classes, there isn't a question. Just  
for AtomicReference classes.

I talked with Doug, and we agreed that we didn't have enough use  
cases to really decide.

The only possible use for a weakCompareAndSet on a reference where  
you don't need a happens-before
edge is if you can prove that a happens-before edge is created by  
some other mechanism.

So, if weakCompareAndSet does not establish a happens-before  
ordering, then a few people (i.e, just Doug)
might be able to effectively use it to superoptimize some code.  
However, without the happens-before ordering,
some potential use cases are invalid, and many people trying to use  
it will create a data race.

Thoughts?

	Bill



From hans.boehm at hp.com  Wed May 17 20:40:42 2006
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed May 17 20:44:19 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet
	"Mayfailspuriously"?
In-Reply-To: <BE06AD6C-6C95-4ABA-8809-8889C74E9A31@cs.umd.edu>
Message-ID: <65953E8166311641A685BDF71D865826B17827@cacexc12.americas.cpqcorp.net>

I'm not completely convinced that the issue is really different for
references.

I think that fundamentally spurious failures and ordering are quite
different.  Allowing spurious failures is occasionally useful, and I
think something that's relatively easily understood.  Relaxing the
ordering can occasionally also be very useful, especially for low level
libraries, but I think it gets you considerably further into
"wizards-only" territory.

My impression, based in part on recent discussions in a C++ context, is
that few people really understand that in the absence of the ordering
semantics, data- or control-dependence does not imply ordering.  This
may be less of an issue with CompareAndSet, but I still think that the
fact that the changes to x and y in

if(x.weakCompareAndSet(a, b)) {
	y = 17;
}

can appear out of order is really unintuitive for most people.  And such
code is essentially untestable, since the ordering is in fact implied in
most cases, with most compilers, on most current hardware.  If you
require ordering, this sort of issue just goes away.

It seems to me that references are special, only in that the
weakCompareAndSet is often dereferenced before or after the
WeakCompareAndSet.  But that's a statistical property; not a guarantee.
It's certainly conceivable that references are used in an algorithm in
which they are only compared and never dereferenced.  Thus the contents
don't need to be communicated.  (I know of one large C++ program for
which the contents corresponding to many references were in fact dead
and had been explicitly deallocated.)  And I'm not sure that the
reference situation in which the contents of the reference are used is
much different from the AtomicInteger situation for which a later load
is dependent on the weakCompareAndSet result, as above.

Thus I think I would argue against resolving this differently for
AtomicReference and AtomicInteger.

I would be more positive on strengthening ordering of weakCompareAndSet
for both.  If you really want relaxed ordering variants for
CompareAndSet, my intuition is that all four possible variants (no
ordering, acquire, release, both) have about equal utility, and the "no
ordering" variant is the hardest to understand.  (It's usually
insufficient for reference counting, as I recall.)  And each weakening
potentially involves a performance gain. On the other hand, I'm not at
all sure that this is a sufficient argument for change at this point.

Hans

> -----Original Message-----
> From: Bill Pugh
> 
> weakCompareAndSet has volatile semantics, _except_ that it 
> doesn't create any happens-before edges.
> 
> Thus, using weakCompareAndSet is ideal for things such as 
> performance counters, unique identifiers and reference counting.
> 
> However, what about AtomicReference? If you actually try to 
> pass references between threads, you need to establish a 
> happens-before relationship between the two threads, so that 
> the contents of the object are communicated as well.
> 
> So, here is the question we should discuss:
> 
> **********
> 
> Should weakCompareAndSet on an AtomicReference create happens 
> before edges (just as compareAndSwap does)?
> 
> **********
> 
> For AtomicInteger, and similar classes, there isn't a 
> question. Just for AtomicReference classes.
> 
> I talked with Doug, and we agreed that we didn't have enough 
> use cases to really decide.
> 
> The only possible use for a weakCompareAndSet on a reference 
> where you don't need a happens-before edge is if you can 
> prove that a happens-before edge is created by some other mechanism.
> 
> So, if weakCompareAndSet does not establish a happens-before 
> ordering, then a few people (i.e, just Doug) might be able to 
> effectively use it to superoptimize some code.  
> However, without the happens-before ordering, some potential 
> use cases are invalid, and many people trying to use it will 
> create a data race.
> 
> Thoughts?
> 
> 	Bill
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From dawidk at mathcs.emory.edu  Wed May 17 22:15:49 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed May 17 22:16:12 2006
Subject: [concurrency-interest] Blocking queue
In-Reply-To: <20060518014448.35328.qmail@web50105.mail.yahoo.com>
References: <20060518014448.35328.qmail@web50105.mail.yahoo.com>
Message-ID: <446BD8D5.7030605@mathcs.emory.edu>

Grace Kwok wrote:
> Presumably, the takeType2BeforeType1Task() method
> waits for anyQueueNotEmpty.  But the one who signals
> it is the put(type2obj).  So, the
> takeType2BeforeType1Task() method would really only be
> the takeType2Task() method if I understand correctly.
>
>   
The put(type1) may signal _both_ "nonEmpty" conditions (they belong to 
the same lock).

Regards,
Dawid

From gykwok at yahoo.com  Wed May 17 21:44:48 2006
From: gykwok at yahoo.com (Grace Kwok)
Date: Thu May 18 05:54:07 2006
Subject: [concurrency-interest] Blocking queue
Message-ID: <20060518014448.35328.qmail@web50105.mail.yahoo.com>

Presumably, the takeType2BeforeType1Task() method
waits for anyQueueNotEmpty.  But the one who signals
it is the put(type2obj).  So, the
takeType2BeforeType1Task() method would really only be
the takeType2Task() method if I understand correctly.

Thanks, Grace

On 5/17/06, Dawid Kurzyniec <dawidk@mathcs.emory.edu>
wrote:


    I'd implement it by writing a custom blocking
queue implementation (not
    necessarily implementing the BlockingQueue
interface) using two
    non-blocking queues internally and providing its
own wait/notification
    mechanisms on top of that, using condition
variables. For instance,
    type1queueNotEmpty, anyQueueNotEmpty,
type1queueNotFull, and
    type2queueNotFull might be your conditions; the
put(type2obj) would
    await on type2queueNotFull, then put, then signal
anyQueueNotEmpty. Your
    "takeType1task()" would wait on
type1queueNotEmpty, then take, then
    signal type1queueNotFull, etc.

    Regards,
    Dawid

__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From cliffc at acm.org  Thu May 18 02:00:44 2006
From: cliffc at acm.org (Cliff Click)
Date: Thu May 18 05:54:08 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "Mayfail
	spuriously"?
In-Reply-To: <BE06AD6C-6C95-4ABA-8809-8889C74E9A31@cs.umd.edu>
References: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>	<ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>	<446868D8.4080305@cs.oswego.edu>
	<a74683f90605151448y4dd4440ej440c12b16e1adb9e@mail.gmail.com>
	<446B0C5C.4090405@cs.oswego.edu>
	<BE06AD6C-6C95-4ABA-8809-8889C74E9A31@cs.umd.edu>
Message-ID: <446C0D8C.1@acm.org>

My use-case for AtomicInteger NOT forcing a happens-before is in 
high-performance perf-counters.  Since it's a perf-counter I've no need 
of a happens-before; but I can't tolerate the very high level of 
count-dropping that happens if I don't use a CAS.

In my case I've got 380 CPUs busy incrementing a counter; the counter 
goes up about 790,000 increments/sec (one increment per piece of 'real' 
work).  If I use a lock, I'm limited to about 50 CPUs and 60,000 
ops/sec.  If I use a strong CAS (CAS+fence) I get ~400,000 ops/sec.  If 
I use a CAS-no-fence I get 790,000 ops/sec.  That extra fence really 
costs!  This is admittedly an extreme case, but it's going to be less 
extreme going forward: next year we'll have double the CPU count.

For AtomicRef's I agree with Bill's statement: for ease of correct 
coding we should just require the happens-before.

The other option worth mentioning is just to define all variations, 
which can be trivially implemented by using the strong version, but 
would allow experts some lea-way on more interesting hardware.

Cliff


Bill Pugh wrote:

>
> On May 17, 2006, at 4:43 AM, Doug Lea wrote:
>
>> Bob Lee wrote:
>>
>>> On 5/15/06, Doug Lea <dl@cs.oswego.edu> wrote:
>>>
>>>> Yes, this is fine; it is a good example where either the plain or
>>>> the weak form would work just as well, so you might as well use
>>>> the weak form.
>>>
>>> Can you please provide an example of when you'd use one or the other?
>>
>>
>> Thanks to Bill Pugh for reminding me about a second difference
>> between weakCompareAndSet vs plain compareAndSet, that normally
>> goes hand-in-hand with the main difference of failure being
>> uninformative:
>>
>> A plain compareAndSet has volatile-write memory model semantics,  
>> while a
>> weakCompareAndSet has non-volatile-write memory model semantics.
>
> ]
>
> I would explain this differently (actually, the JMM requires that it  
> be explained differently):
>
> weakCompareAndSet has volatile semantics, _except_ that it doesn't  
> create any happens-before
> edges.
>
> Thus, using weakCompareAndSet is ideal for things such as performance  
> counters,
> unique identifiers and reference counting.
>
> However, what about AtomicReference? If you actually try to pass  
> references between threads,
> you need to establish a happens-before relationship between the two  
> threads, so that the contents of
> the object are communicated as well.
>
> So, here is the question we should discuss:
>
> **********
>
> Should weakCompareAndSet on an AtomicReference create happens before  
> edges (just as
> compareAndSwap does)?
>
> **********
>
> For AtomicInteger, and similar classes, there isn't a question. Just  
> for AtomicReference classes.
>
> I talked with Doug, and we agreed that we didn't have enough use  
> cases to really decide.
>
> The only possible use for a weakCompareAndSet on a reference where  
> you don't need a happens-before
> edge is if you can prove that a happens-before edge is created by  
> some other mechanism.
>
> So, if weakCompareAndSet does not establish a happens-before  
> ordering, then a few people (i.e, just Doug)
> might be able to effectively use it to superoptimize some code.  
> However, without the happens-before ordering,
> some potential use cases are invalid, and many people trying to use  
> it will create a data race.
>
> Thoughts?
>
>     Bill
>
>
>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cliffc.vcf
Type: text/x-vcard
Size: 136 bytes
Desc: not available
Url : /pipermail/attachments/20060518/8163d2f0/cliffc.vcf
From dl at cs.oswego.edu  Thu May 18 06:42:32 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu May 18 06:42:34 2006
Subject: [concurrency-interest] Re: interrupt / notify races even in 
	6.0beta?
In-Reply-To: <446AAA55.4050301@mathcs.emory.edu>
References: <4467F625.60103@mathcs.emory.edu>	<44686AAE.1010801@cs.oswego.ed		u>	<44695258.5000404@mathcs.emory.edu>	<4469CF9C.4000402@cs.oswego.edu><44	6	9E347.5090207@cs.kuleuven.ac.be>
	<4469EF38.2000204@cs.oswego.edu>
	<446AAA55.4050301@mathcs.emory.edu>
Message-ID: <446C4F98.6060105@cs.oswego.edu>

Dawid Kurzyniec wrote:
> 
> ...
> Perhaps the problem is that the OS 
> layer does not expose things this way?

Yes. This is the main issue. For example, on some platforms,
Java-level interrupts may sometimes entail OS-level signals. There is better
(although as-yet unexploited) OS integration possible using park/unpark,
but even here, the interaction with interrupts is messy.


> In any case, since the ordering is not deterministic, the aforementioned 
> ReentrantLock unit test is probably too strict. Would a Thread.yield() 
> or a delay inserted between interrupt and notify be a reasonable fix?...
> 

Thanks! You are right that a few TCK tests implicitly assumed orderings
that aren't mandated by any specs, and so should force delays. Updated
versions are now in our CVS.

-Doug

From dl at cs.oswego.edu  Thu May 18 07:26:45 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu May 18 07:26:49 2006
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <65953E8166311641A685BDF71D865826B17827@cacexc12.americas.cpqcorp.net>
References: <65953E8166311641A685BDF71D865826B17827@cacexc12.americas.cpqcorp.net>
Message-ID: <446C59F5.1040609@cs.oswego.edu>

Backing up a little first, the intent of weakCAS is to provide the
cheapest possible conditional atomic update available on a machine,
that may entail tradeoffs wrt determinism and ordering.
It is mainly useful for things like collecting statistics
as in Hanson Char's example code, which is a common and useful use case.
It is almost never used inside java.util.concurrent, because atomics
used within synchronizers almost always need to rely on comparison
outcome and/or to ensure happens-before orderings, so the opportunity
to use it rarely arises.


Boehm, Hans wrote:
> I'm not completely convinced that the issue is really different for 
> references.

I agree. I think that weakCAS is even less commonly useful
for references, but not qualitatively different.

> This may be less of an issue with CompareAndSet, but I still think that the 
> fact that the changes to x and y in
> 
> if(x.weakCompareAndSet(a, b)) { y = 17; }
> 
> can appear out of order is really unintuitive for most people.

I'm not sure what you have in mind here though. For this ordering to
be guaranteed, "y" would need to be volatile, which would cause
this to hold regardless of weakCAS ordering. As it stands now,
it would basically have the same outcome ordering semantics as, for
some variable z,
   if (z == a) {
      z = b;
      y = 17;
   }

Where the main ordering constraint relies on whether "y" is volatile,
not whether "z" is.

> 
> 
> I would be more positive on strengthening ordering of weakCompareAndSet for
> both.

But then people like Cliff will be unhappy.

> On the other hand, I'm not at all sure that this is a sufficient argument for
> change at this point.
> 

I'm completely open about adding variants distinguishing
determinism vs ordering, but I don't see a very compelling
argument for it either.

-Doug
From bart.jacobs at cs.kuleuven.ac.be  Thu May 18 07:30:04 2006
From: bart.jacobs at cs.kuleuven.ac.be (Bart Jacobs)
Date: Thu May 18 07:39:37 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "Mayfail
	spuriously"?
In-Reply-To: <446C0D8C.1@acm.org>
References: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>	<ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>	<446868D8.4080305@cs.oswego.edu>	<a74683f90605151448y4dd4440ej440c12b16e1adb9e@mail.gmail.com>	<446B0C5C.4090405@cs.oswego.edu>	<BE06AD6C-6C95-4ABA-8809-8889C74E9A31@cs.umd.edu>
	<446C0D8C.1@acm.org>
Message-ID: <446C5ABC.7070404@cs.kuleuven.ac.be>

Wouldn't it be better to increase the granularity of your counter? Use 
thread-local counters and increment the shared counter per thousand 
pieces of real work?

Note: it's probably best to use some app-specific mechanism for 
thread-local counters, since ThreadLocal may have high overhead.

Thanks,-
Bart

Cliff Click wrote:
> My use-case for AtomicInteger NOT forcing a happens-before is in 
> high-performance perf-counters.  Since it's a perf-counter I've no need 
> of a happens-before; but I can't tolerate the very high level of 
> count-dropping that happens if I don't use a CAS.
> 
> In my case I've got 380 CPUs busy incrementing a counter; the counter 
> goes up about 790,000 increments/sec (one increment per piece of 'real' 
> work).  If I use a lock, I'm limited to about 50 CPUs and 60,000 
> ops/sec.  If I use a strong CAS (CAS+fence) I get ~400,000 ops/sec.  If 
> I use a CAS-no-fence I get 790,000 ops/sec.  That extra fence really 
> costs!  This is admittedly an extreme case, but it's going to be less 
> extreme going forward: next year we'll have double the CPU count.
> 
> For AtomicRef's I agree with Bill's statement: for ease of correct 
> coding we should just require the happens-before.
> 
> The other option worth mentioning is just to define all variations, 
> which can be trivially implemented by using the strong version, but 
> would allow experts some lea-way on more interesting hardware.
> 
> Cliff
> 
> 
> Bill Pugh wrote:
> 
>>
>> On May 17, 2006, at 4:43 AM, Doug Lea wrote:
>>
>>> Bob Lee wrote:
>>>
>>>> On 5/15/06, Doug Lea <dl@cs.oswego.edu> wrote:
>>>>
>>>>> Yes, this is fine; it is a good example where either the plain or
>>>>> the weak form would work just as well, so you might as well use
>>>>> the weak form.
>>>>
>>>> Can you please provide an example of when you'd use one or the other?
>>>
>>>
>>> Thanks to Bill Pugh for reminding me about a second difference
>>> between weakCompareAndSet vs plain compareAndSet, that normally
>>> goes hand-in-hand with the main difference of failure being
>>> uninformative:
>>>
>>> A plain compareAndSet has volatile-write memory model semantics,  
>>> while a
>>> weakCompareAndSet has non-volatile-write memory model semantics.
>>
>> ]
>>
>> I would explain this differently (actually, the JMM requires that it  
>> be explained differently):
>>
>> weakCompareAndSet has volatile semantics, _except_ that it doesn't  
>> create any happens-before
>> edges.
>>
>> Thus, using weakCompareAndSet is ideal for things such as performance  
>> counters,
>> unique identifiers and reference counting.
>>
>> However, what about AtomicReference? If you actually try to pass  
>> references between threads,
>> you need to establish a happens-before relationship between the two  
>> threads, so that the contents of
>> the object are communicated as well.
>>
>> So, here is the question we should discuss:
>>
>> **********
>>
>> Should weakCompareAndSet on an AtomicReference create happens before  
>> edges (just as
>> compareAndSwap does)?
>>
>> **********
>>
>> For AtomicInteger, and similar classes, there isn't a question. Just  
>> for AtomicReference classes.
>>
>> I talked with Doug, and we agreed that we didn't have enough use  
>> cases to really decide.
>>
>> The only possible use for a weakCompareAndSet on a reference where  
>> you don't need a happens-before
>> edge is if you can prove that a happens-before edge is created by  
>> some other mechanism.
>>
>> So, if weakCompareAndSet does not establish a happens-before  
>> ordering, then a few people (i.e, just Doug)
>> might be able to effectively use it to superoptimize some code.  
>> However, without the happens-before ordering,
>> some potential use cases are invalid, and many people trying to use  
>> it will create a data race.
>>
>> Thoughts?
>>
>>     Bill
>>
>>
>>
> 
> ------------------------------------------------------------------------
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

Disclaimer: http://www.kuleuven.be/cwis/email_disclaimer.htm

From cliffc at azulsystems.com  Thu May 18 11:43:46 2006
From: cliffc at azulsystems.com (Cliff Click)
Date: Thu May 18 11:46:06 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet "Mayfail
	spuriously"?
In-Reply-To: <446C5ABC.7070404@cs.kuleuven.ac.be>
References: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>	<ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>	<446868D8.4080305@cs.oswego.edu>	<a74683f90605151448y4dd4440ej440c12b16e1adb9e@mail.gmail.com>	<446B0C5C.4090405@cs.oswego.edu>	<BE06AD6C-6C95-4ABA-8809-8889C74E9A31@cs.umd.edu>
	<446C0D8C.1@acm.org> <446C5ABC.7070404@cs.kuleuven.ac.be>
Message-ID: <446C9632.3070608@azulsystems.com>

Better yes, but I'm looking for a cheapo solution I can tell customers 
to slap into their code.
Thread-local counters work where the ratio of increments-to-reads is 
real high, but not if reads are common.  That distinction requires me to 
know something about the application, i.e., it's not a no-brainer 
drop-in solution.

In one case I can say "use this standard API which you can read about in 
Sun's online javadoc's and even exists in 1.4.2 (sun.misc.atomic)" 
versus "if you aren't reading the counter alot, download this code from 
Azul and use it instead and also it requires 5.0".

It would help if a very-high-performance counter class made it into the 
JRE, so we can start moving people towards a portably-performant solution.

Cliff


Bart Jacobs wrote:
> Wouldn't it be better to increase the granularity of your counter? Use 
> thread-local counters and increment the shared counter per thousand 
> pieces of real work?
>
> Note: it's probably best to use some app-specific mechanism for 
> thread-local counters, since ThreadLocal may have high overhead.
>
> Thanks,-
> Bart
>
> Cliff Click wrote:
>> My use-case for AtomicInteger NOT forcing a happens-before is in 
>> high-performance perf-counters.  Since it's a perf-counter I've no 
>> need of a happens-before; but I can't tolerate the very high level of 
>> count-dropping that happens if I don't use a CAS.
>>
>> In my case I've got 380 CPUs busy incrementing a counter; the counter 
>> goes up about 790,000 increments/sec (one increment per piece of 
>> 'real' work).  If I use a lock, I'm limited to about 50 CPUs and 
>> 60,000 ops/sec.  If I use a strong CAS (CAS+fence) I get ~400,000 
>> ops/sec.  If I use a CAS-no-fence I get 790,000 ops/sec.  That extra 
>> fence really costs!  This is admittedly an extreme case, but it's 
>> going to be less extreme going forward: next year we'll have double 
>> the CPU count.
>>
>> For AtomicRef's I agree with Bill's statement: for ease of correct 
>> coding we should just require the happens-before.
>>
>> The other option worth mentioning is just to define all variations, 
>> which can be trivially implemented by using the strong version, but 
>> would allow experts some lea-way on more interesting hardware.
>>
>> Cliff
>>
>>
>> Bill Pugh wrote:
>>
>>>
>>> On May 17, 2006, at 4:43 AM, Doug Lea wrote:
>>>
>>>> Bob Lee wrote:
>>>>
>>>>> On 5/15/06, Doug Lea <dl@cs.oswego.edu> wrote:
>>>>>
>>>>>> Yes, this is fine; it is a good example where either the plain or
>>>>>> the weak form would work just as well, so you might as well use
>>>>>> the weak form.
>>>>>
>>>>> Can you please provide an example of when you'd use one or the other?
>>>>
>>>>
>>>> Thanks to Bill Pugh for reminding me about a second difference
>>>> between weakCompareAndSet vs plain compareAndSet, that normally
>>>> goes hand-in-hand with the main difference of failure being
>>>> uninformative:
>>>>
>>>> A plain compareAndSet has volatile-write memory model semantics,  
>>>> while a
>>>> weakCompareAndSet has non-volatile-write memory model semantics.
>>>
>>> ]
>>>
>>> I would explain this differently (actually, the JMM requires that 
>>> it  be explained differently):
>>>
>>> weakCompareAndSet has volatile semantics, _except_ that it doesn't  
>>> create any happens-before
>>> edges.
>>>
>>> Thus, using weakCompareAndSet is ideal for things such as 
>>> performance  counters,
>>> unique identifiers and reference counting.
>>>
>>> However, what about AtomicReference? If you actually try to pass  
>>> references between threads,
>>> you need to establish a happens-before relationship between the two  
>>> threads, so that the contents of
>>> the object are communicated as well.
>>>
>>> So, here is the question we should discuss:
>>>
>>> **********
>>>
>>> Should weakCompareAndSet on an AtomicReference create happens 
>>> before  edges (just as
>>> compareAndSwap does)?
>>>
>>> **********
>>>
>>> For AtomicInteger, and similar classes, there isn't a question. 
>>> Just  for AtomicReference classes.
>>>
>>> I talked with Doug, and we agreed that we didn't have enough use  
>>> cases to really decide.
>>>
>>> The only possible use for a weakCompareAndSet on a reference where  
>>> you don't need a happens-before
>>> edge is if you can prove that a happens-before edge is created by  
>>> some other mechanism.
>>>
>>> So, if weakCompareAndSet does not establish a happens-before  
>>> ordering, then a few people (i.e, just Doug)
>>> might be able to effectively use it to superoptimize some code.  
>>> However, without the happens-before ordering,
>>> some potential use cases are invalid, and many people trying to use  
>>> it will create a data race.
>>>
>>> Thoughts?
>>>
>>>     Bill
>>>
>>>
>>>
>>
>> ------------------------------------------------------------------------
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest@altair.cs.oswego.edu
>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> Disclaimer: http://www.kuleuven.be/cwis/email_disclaimer.htm
>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cliffc.vcf
Type: text/x-vcard
Size: 266 bytes
Desc: not available
Url : /pipermail/attachments/20060518/d6de84dd/cliffc.vcf
From hans.boehm at hp.com  Thu May 18 14:19:37 2006
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu May 18 14:25:20 2006
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <446C59F5.1040609@cs.oswego.edu>
Message-ID: <65953E8166311641A685BDF71D865826B178B9@cacexc12.americas.cpqcorp.net>

I think we basically agree, so this is only a detail:

> From: Doug Lea [mailto:dl@cs.oswego.edu] 
> I agree. I think that weakCAS is even less commonly useful 
> for references, but not qualitatively different.
> 
> > This may be less of an issue with CompareAndSet, but I still think 
> > that the fact that the changes to x and y in
> > 
> > if(x.weakCompareAndSet(a, b)) { y = 17; }
> > 
> > can appear out of order is really unintuitive for most people.
> 
> I'm not sure what you have in mind here though. For this 
> ordering to be guaranteed, "y" would need to be volatile, 
> which would cause this to hold regardless of weakCAS 
> ordering. As it stands now, it would basically have the same 
> outcome ordering semantics as, for some variable z,
>    if (z == a) {
>       z = b;
>       y = 17;
>    }
> 
> Where the main ordering constraint relies on whether "y" is 
> volatile, not whether "z" is.
> 
Let me revise the example slightly, though I'm still not sure this is
convincing enough to motivate a change.  Assume x is AtomicSomething
initially not a, y not volatile.

Thread 1:
y = 17; x.set(a);

Thread 2:
if(x.weakCompareAndSet(a, b)) { r1 = y; }

Currently r1 does not have to be 17.  With an ordered weakCompareAndSet,
it would have to be.  I think the current situation is hard to explain,
because there is a data race only in a somewhat technical sense (atomics
are supposed to be used for thread communication after all, and y cannot
actually be accessed concurrently in the sequentially consistent
interpretation), and the program does not behave sequentially
consistently.  It is even less intuitive, since any attempt to explain
this operation runs into the problem that the two memory operations in
thread 2 are dependent, which everyone expects to imply ordering.  (I'd
be the first to agree that it cannot, but still that's the expectation.)
The nice thing about dealing with ordered operations is that they
usually make the dependency issues irrelevant.

Hans

From hans.boehm at hp.com  Thu May 18 17:18:32 2006
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu May 18 18:41:24 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet
	"Mayfailspuriously"?
In-Reply-To: <446C0D8C.1@acm.org>
Message-ID: <65953E8166311641A685BDF71D865826B1790B@cacexc12.americas.cpqcorp.net>

> From: Cliff Click
> For AtomicRef's I agree with Bill's statement: for ease of 
> correct coding we should just require the happens-before.
> 
It still strikes me as very weird to distinguish the two.  If I
implement a single bit counter as an integer, I would get different
semantics than if I implement it via switching between references to two
preinitialized Boolean objects.  In cases like these, the user's
requirements are absolutely the same for both.

If you want to do this, I think the operations should at least have
different names.

The real issue here may be the current documentation for
AtomicReference.weakCompareAndSet, which seems to be lacking the
requisite warnings, like: "This provides weaker memory visibility
guarantees than compareAndSet.  If you have any doubt whether you should
be using weakCompareAndSet or compareAndSet, then use compareAndSet."

Hans

From dl at cs.oswego.edu  Thu May 18 19:50:02 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu May 18 19:50:06 2006
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <65953E8166311641A685BDF71D865826B1790B@cacexc12.americas.cpqcorp.net>
References: <65953E8166311641A685BDF71D865826B1790B@cacexc12.americas.cpqcorp.net>
Message-ID: <446D082A.8000402@cs.oswego.edu>

Boehm, Hans wrote:

> 
> The real issue here may be the current documentation for
> AtomicReference.weakCompareAndSet, 

Presciently, Marting Buchholz filed a documentation bug for
weakCompareAndSet last week, so we should be able to do this soon.
(http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6425639)

> which seems to be lacking the
> requisite warnings, like: "This provides weaker memory visibility
> guarantees than compareAndSet.  If you have any doubt whether you should
> be using weakCompareAndSet or compareAndSet, then use compareAndSet."

Thanks. This is a good start.
Additional wording suggestions (from everyone!) would be welcome.

-Doug


From robertkuhar at yahoo.com  Thu May 18 19:57:43 2006
From: robertkuhar at yahoo.com (Robert Kuhar)
Date: Thu May 18 19:57:57 2006
Subject: [concurrency-interest] Question about "happens-before" and
	reordering
Message-ID: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>

At a JavaOne session today entitled "Secure Coding Antipatterns:  Avoiding
Vunerabilities" the following code snippet was presented.

  Antipattern 6: Believing a Constructor Exception Destroys the Object
  Problem
    Throwing an exception from a constructor does not prevent a partially
    initialized instance from being acquired
      - Attacker can override finalize method to obtain the object

To solve this problem, they presented the following snippet and explanation:

  Secure Coding Guidelines:
    - If finalize method can be overridden, ensure partially initialized 
      instances are unusable
    - Do not set fields until all checks have completed
    - Use an initialized flag

  public class ClassLoader {
    private boolean initialized = false;
    ClassLoader() {
      securityCheck(); // can throw an Exception
      init();
      initialized = true; // check flag in all relevant methods
    }
  }

I asserted that they had two problems with this code.  As I understand it, the
runtime is free to reorder the instructions in this constructor.  This means
that initialized=true may occur before the calls to either securityCheck() or
init().  If that is the case, its value cannot be trusted as this code stands
now.

Second, even if initialized boolean field gets set correctly, the fact that it
is not covered by any synchronization or volatile means that any thread
(remember, the problem they are trying to solve has to do with malicious
finalizer code) other than the one that new'ed this kid up, may not see the
current value of the initialized boolean field.  Garbage Collection usually
runs on its own thread, no?

It is my opinion that this code is not thread-safe.

The reply was that somehow the Exception that can come out of securityCheck()
establishes some "happens-before" and therefore this code is thread-safe.  I am
skeptical as I have never heard that before (or didn't understand it if I did).

Point by point how right or wrong am I and why.

Thanks.

Bob


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From giuliano.mega at gmail.com  Thu May 18 21:29:44 2006
From: giuliano.mega at gmail.com (Giuliano Mega)
Date: Thu May 18 21:29:50 2006
Subject: [concurrency-interest] Question about "happens-before" and
	reordering
In-Reply-To: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
Message-ID: <7547a9ff0605181829n5ac1220jc6d06875af18110a@mail.gmail.com>

Hi,

> The reply was that somehow the Exception that can come out of securityCheck()
> establishes some "happens-before" and therefore this code is thread-safe.  I am
> skeptical as I have never heard that before (or didn't understand it if I did).

The language spec says that there is a happens-before edge that goes
from the end of the constructor to the start of the finalizer of that
same object. (see
http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.4.5)

So, unless I'm talking nonsense (in which case I would politely ask
for someone to correct me), this means that what happens at the
constructor must be visible at the finalizer, for all threads.
Although the instructions may be reordered, the resulting execution
must be "legal" in the sense that it must reflect a possible
execution. In your example, if an exception is thrown at the security
check, then the flag must be seen as false at the finalizer as it is
the only legal option.

Best,

-- 
Giuliano Mega <giuliano@ime.usp.br>

From giuliano.mega at gmail.com  Fri May 19 00:58:05 2006
From: giuliano.mega at gmail.com (Giuliano Mega)
Date: Fri May 19 00:58:10 2006
Subject: [concurrency-interest] Question about "happens-before" and
	reordering
In-Reply-To: <7547a9ff0605181829n5ac1220jc6d06875af18110a@mail.gmail.com>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
	<7547a9ff0605181829n5ac1220jc6d06875af18110a@mail.gmail.com>
Message-ID: <7547a9ff0605182158p3b4947b2w7cef2e71dea19676@mail.gmail.com>

> So, unless I'm talking nonsense (in which case I would politely ask
> for someone to correct me), this means that what happens at the
> constructor must be visible at the finalizer, for all threads.
> Although the instructions may be reordered, the resulting execution
> must be "legal" in the sense that it must reflect a possible
> execution. In your example, if an exception is thrown at the security
> check, then the flag must be seen as false at the finalizer as it is
> the only legal option.

I'm sorry for posting again, but I just re-read my answer and found it
confusing. What I wanted to say is that the reordering that occurs
inside of the constructor must respect local ordering within a single
thread of control, and that the changes that were performed by the
constructor must have been already commited to main memory when the
finalizer begins, or the constructor won't appear to have
happenned-before the finalizer (and the spec says it must).

Best,

-- 
Giuliano Mega <giuliano@ime.usp.br>

From tackline at tackline.plus.com  Fri May 19 05:20:33 2006
From: tackline at tackline.plus.com (Thomas Hawtin)
Date: Fri May 19 05:20:43 2006
Subject: [concurrency-interest] Question about "happens-before"
	andreordering
In-Reply-To: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
Message-ID: <446D8DE1.7000702@tackline.plus.com>

Robert Kuhar wrote:
>   Secure Coding Guidelines:
>     - If finalize method can be overridden, ensure partially initialized 
>       instances are unusable

I think it's a little more subtle than that, particularly prior to 1.6.

>   public class ClassLoader {
>     private boolean initialized = false;

I think the "= false" bit here is misleading. I certainly would not want 
to see "= true" in a similar situation.

>     ClassLoader() {
>       securityCheck(); // can throw an Exception
>       init();
>       initialized = true; // check flag in all relevant methods
>     }
>   }
> 
> I asserted that they had two problems with this code.  As I understand it, the
> runtime is free to reorder the instructions in this constructor.  This means
> that initialized=true may occur before the calls to either securityCheck() or
> init().  If that is the case, its value cannot be trusted as this code stands
> now.

If securityCheck does throw an exception, then the initialized = true 
statement must never be executed. So there is no security problem there.

If securityCheck does not throw, then theoretically you could see a 
non-working, partially-initialised instance. However, that would be your 
own fault.

Tom Hawtin
From tackline at tackline.plus.com  Fri May 19 05:45:31 2006
From: tackline at tackline.plus.com (Thomas Hawtin)
Date: Fri May 19 05:45:42 2006
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <446B3968.8030502@cs.oswego.edu>
References: <ca53c8f80605140005uca39b24k12b043a59fbefa38@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCIEICGOAA.dcholmes@optusnet.com.au>	<ca53c8f80605142054u542a7dcap6d41786aac3d64c1@mail.gmail.com>	<446868D8.4080305@cs.oswego.edu><a74683f90605151448y4dd4440ej440c12b16e1adb9e@mail.gmail.com>	<446B0C5C.4090405@cs.oswego.edu>
	<446B1E9D.5030104@tackline.plus.com>
	<446B3968.8030502@cs.oswego.edu>
Message-ID: <446D93BB.5070503@tackline.plus.com>

Doug Lea wrote:
> Thomas Hawtin wrote:
>>
>> Is there any particular reason for not having a "weakGet" method? 
>> Going back to Hanson Char's example:
>>
>>  int maxLatencySnapshot = this.maxLatency.get();
>>  if (latency > maxLatencySnapshot) {
>>    if (this.maxLatency.weakCompareAndSet(maxLatencySnapshot, latency)) {
>>
>> Most of the gains that may be made from using weakCompareAndSet seem 
>> to be blown away by the get. (Sun's implementation doesn't seem to 
>> differentiate between weakCompareAndSet and compareAndSet, at the 
>> moment.)
>>
> 
> Generally, volatile-reads are cheap -- the main cost
> is suppressing optimizations/reorderings. On most machines,
> they don't generate machine-level barriers, and
> on the ones where they do (mainly: Itanium/IA64), they are the
> cheapest kind, and so barely measurable.
> 
> And the suppressed optimizations/orderings are exactly those you'd need to
> suppress in uses like this. Without this, a VM might (depending on
> context) forever cache a single read of the value, which would rarely
> be useful for an AtomicX. There may be a few use-cases for some kind of
> weakGet, but I think they are most rare.

As I understand it, weakCompareAndSet always gets to see the "current" 
value (unless it fails). An obvious constraints for weakGet is that it 
atomically reads a variable, is ordered with respect to other memory 
operations on that variable, but otherwise acts as an ordinary 
non-volatile memory operation (to adapt from weakCompareAndSet). 
(Actually you could go weaker than that - so long as weakCompareAndSet 
imposes some ordering on it. Say, weakGet returns some value that the 
variable had between the last ordering constraint and the next.)

So, for the particular variable it is ordered, which is enough to make 
the code correct. For other variables it is not ordered, which is enough 
to make most optimisations valid.

Tom Hawtin
From cliffc at azulsystems.com  Thu May 18 23:13:17 2006
From: cliffc at azulsystems.com (Cliff Click)
Date: Fri May 19 06:05:18 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet
	"Mayfailspuriously"?
In-Reply-To: <65953E8166311641A685BDF71D865826B1790B@cacexc12.americas.cpqcorp.net>
References: <65953E8166311641A685BDF71D865826B1790B@cacexc12.americas.cpqcorp.net>
Message-ID: <446D37CD.1060107@azulsystems.com>

An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060518/7fc28dfb/attachment-0001.html
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cliffc.vcf
Type: text/x-vcard
Size: 266 bytes
Desc: not available
Url : /pipermail/attachments/20060518/7fc28dfb/cliffc-0001.vcf
From morisil at ncdc.pl  Fri May 19 06:11:43 2006
From: morisil at ncdc.pl (Kazimierz Pogoda)
Date: Fri May 19 06:11:56 2006
Subject: [concurrency-interest] reordering
Message-ID: <1148033504.4447.18.camel@localhost.localdomain>

This "reordering" idea made me suspicious about my own code. I know this
is not directly connected with concurrent programming, but I want to ask
experts, if this code fragment works as it is expected to:


public void execute(final String sql) throws SQLException {
	final Connection conn = getConnection(); //throws SQLException
	boolean executed = false;
	try {
		execute(conn, sql); //throws SQLException
		executed = true;
	} finally {
		boolean commited = false;
		if (executed) {
			try {
				conn.commit();
				commited = true;
			} catch (SQLException e) {
				log("cannot commit connection", e);
			}
		}
		if (!commited) {
			try {
				conn.rollback();
			} catch (SQLException e) {
				log("cannot rollback connection", e);
			}
		}
		try {
			conn.close();
		} catch (SQLException e) {
			log("cannot close connection", e);
		}
	}
}

The intent of this code is to throw to caller the original SQLException
(thrown by execute(conn, sql) method), not SQLException indicating that
connection cannot be commited or closed. In case of any Throwable
(RuntimeException, Error) thrown in execute(conn, sql) method I expect
also an attempt to rollback the connection (If connection is taken from
the pool, other thread can commit it later).

I'm using boolean flags "executed" to indicate if Throwable has been
throw, and boolean flag "commited" for SQLException on commit().

Is it possible, that "reordering" will effect in unexpected state of
those flags after some thrown Throwable?

-- 
"the spirit can only withdraw into a corner. And yet, it is not at all 
 worn out or superfluous, but, like an (eternal) witness, floats above 
 the rubble of culture - almost like an  avenger of God.  As though it 
 awaited a new incarnation."
                                        -- Ludwig Wittgenstein --
Kazimierz Pogoda
mailto:morisil@ncdc.pl

From bart.jacobs at cs.kuleuven.be  Fri May 19 07:44:31 2006
From: bart.jacobs at cs.kuleuven.be (Bart Jacobs)
Date: Fri May 19 07:45:24 2006
Subject: [concurrency-interest] reordering
In-Reply-To: <1148033504.4447.18.camel@localhost.localdomain>
References: <1148033504.4447.18.camel@localhost.localdomain>
Message-ID: <446DAF9F.1000500@cs.kuleuven.be>

There are multiple ways to explain the Java memory model. One uses the 
notion of "reorderings".

There is also a different explanation, which is not in terms of 
"reorderings", and which may be clarifying for you. In this other 
explanation, in each program execution, all actions performed by a given 
thread occur in the order specified by the program (known as the program 
order). The only difference with the single-threaded semantics is that, 
for fields accessed concurrently by multiple threads, field reads do not 
necessarily yield the value written by the most recent preceding write.

In short, the memory model has no effect on single-threaded programs, 
and it affects only fields accessed concurrently by multiple threads.

Bart

Kazimierz Pogoda wrote:
> This "reordering" idea made me suspicious about my own code. I know this
> is not directly connected with concurrent programming, but I want to ask
> experts, if this code fragment works as it is expected to:
>
>
> public void execute(final String sql) throws SQLException {
> 	final Connection conn = getConnection(); //throws SQLException
> 	boolean executed = false;
> 	try {
> 		execute(conn, sql); //throws SQLException
> 		executed = true;
> 	} finally {
> 		boolean commited = false;
> 		if (executed) {
> 			try {
> 				conn.commit();
> 				commited = true;
> 			} catch (SQLException e) {
> 				log("cannot commit connection", e);
> 			}
> 		}
> 		if (!commited) {
> 			try {
> 				conn.rollback();
> 			} catch (SQLException e) {
> 				log("cannot rollback connection", e);
> 			}
> 		}
> 		try {
> 			conn.close();
> 		} catch (SQLException e) {
> 			log("cannot close connection", e);
> 		}
> 	}
> }
>
> The intent of this code is to throw to caller the original SQLException
> (thrown by execute(conn, sql) method), not SQLException indicating that
> connection cannot be commited or closed. In case of any Throwable
> (RuntimeException, Error) thrown in execute(conn, sql) method I expect
> also an attempt to rollback the connection (If connection is taken from
> the pool, other thread can commit it later).
>
> I'm using boolean flags "executed" to indicate if Throwable has been
> throw, and boolean flag "commited" for SQLException on commit().
>
> Is it possible, that "reordering" will effect in unexpected state of
> those flags after some thrown Throwable?
>
>   


Disclaimer: http://www.kuleuven.be/cwis/email_disclaimer.htm

From jws at cs.mu.OZ.AU  Fri May 19 09:06:58 2006
From: jws at cs.mu.OZ.AU (Jeff Schultz)
Date: Fri May 19 09:05:32 2006
Subject: [concurrency-interest] ScheduledExecutorService
Message-ID: <24466.1148044018@blunt.localdomain>

Does anyone have a ScheduledExecutorService that uses a varying number
of Threads?  ScheduledThreadPoolExecutor's "acts as a fixed-sized pool
using corePoolSize threads and an unbounded queue" is not what I need
for a particularly bursty workload.


    Jeff Schultz
From Pete.Soper at Sun.COM  Fri May 19 09:23:47 2006
From: Pete.Soper at Sun.COM (Pete Soper)
Date: Fri May 19 09:30:12 2006
Subject: [concurrency-interest] Question about "happens-before"
	andreordering
In-Reply-To: <446D8DE1.7000702@tackline.plus.com>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
	<446D8DE1.7000702@tackline.plus.com>
Message-ID: <446DC6E3.4010602@Sun.COM>

Thomas Hawtin wrote:
> Robert Kuhar wrote:
> 
>>   Secure Coding Guidelines:
>>     - If finalize method can be overridden, ensure partially 
>> initialized       instances are unusable
> 
> 
> I think it's a little more subtle than that, particularly prior to 1.6.
> 
>>   public class ClassLoader {
>>     private boolean initialized = false;
> 
> 
> I think the "= false" bit here is misleading. I certainly would not want 
> to see "= true" in a similar situation.
> 
>>     ClassLoader() {
>>       securityCheck(); // can throw an Exception
>>       init();
>>       initialized = true; // check flag in all relevant methods
>>     }
>>   }
>>
>> I asserted that they had two problems with this code.  As I understand 
>> it, the
>> runtime is free to reorder the instructions in this constructor.  This 
>> means
>> that initialized=true may occur before the calls to either 
>> securityCheck() or
>> init().  If that is the case, its value cannot be trusted as this code 
>> stands
>> now.
> 
> 
> If securityCheck does throw an exception, then the initialized = true 
> statement must never be executed. So there is no security problem there.

Because compilers are not free to do this kind of code motion? In the 
old 3GL days, compilers for some languages were free to determine if an 
initialized reference (or maybe an extremely subtle alias for the same 
storage) is possible in the called routine and, if not, hoist the 
assignment up for the sake of better instruction scheduling, getting it 
out of a loop, etc.

I don't recall if it was mentioned that init is assumed to be a method 
of ClassLoader with the body judged irrelevant to show. If init is a 
method of ClassLoader, then the compiler (the dynamic one we typically 
enjoy, not javac) is free to determine if init can assign to 
initialized, I think. (If it's free to suck the code inline, then it's 
surely OK to treat it like just another set of statements).

But it seems impossible for securityCheck to be able to assign to 
initialized by any means, as it can't have a reference to the object 
being constructed. So the init call is the barrier to code motion, I 
think. But I don't know for sure and the compiler writer that sits next 
door to me is at J1.

Cliff would know.

-Pete

> 
> If securityCheck does not throw, then theoretically you could see a 
> non-working, partially-initialised instance. However, that would be your 
> own fault.
> 
> Tom Hawtin
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

From Pete.Soper at Sun.COM  Fri May 19 09:29:14 2006
From: Pete.Soper at Sun.COM (Pete Soper)
Date: Fri May 19 09:35:31 2006
Subject: [concurrency-interest] Question about "happens-before"
	andreordering
In-Reply-To: <446DC6E3.4010602@Sun.COM>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
	<446D8DE1.7000702@tackline.plus.com> <446DC6E3.4010602@Sun.COM>
Message-ID: <446DC82A.1010202@Sun.COM>

Pete Soper wrote:
> But it seems impossible for securityCheck to be able to assign to 
> initialized by any means, as it can't have a reference to the object 
> being constructed. So the init call is the barrier to code motion, I 

I meant potential barrier.

-Pete

From Pete.Soper at Sun.COM  Fri May 19 10:05:04 2006
From: Pete.Soper at Sun.COM (Pete Soper)
Date: Fri May 19 10:11:18 2006
Subject: [concurrency-interest] Question about "happens-before" and
	reordering
In-Reply-To: <7547a9ff0605182158p3b4947b2w7cef2e71dea19676@mail.gmail.com>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
	<7547a9ff0605181829n5ac1220jc6d06875af18110a@mail.gmail.com>
	<7547a9ff0605182158p3b4947b2w7cef2e71dea19676@mail.gmail.com>
Message-ID: <446DD090.4050106@Sun.COM>

Giuliano Mega wrote:
>> So, unless I'm talking nonsense (in which case I would politely ask
>> for someone to correct me), this means that what happens at the
>> constructor must be visible at the finalizer, for all threads.
>> Although the instructions may be reordered, the resulting execution
>> must be "legal" in the sense that it must reflect a possible
>> execution. In your example, if an exception is thrown at the security
>> check, then the flag must be seen as false at the finalizer as it is
>> the only legal option.
> 
> 
> I'm sorry for posting again, but I just re-read my answer and found it
> confusing. What I wanted to say is that the reordering that occurs
> inside of the constructor must respect local ordering within a single
> thread of control, and that the changes that were performed by the
> constructor must have been already commited to main memory when the
> finalizer begins, or the constructor won't appear to have
> happenned-before the finalizer (and the spec says it must).

This seemed quite clear the first time. More fundamentally, if the 
constructor never completes, the finalizer's running is impossible, right?

> 
> Best,
> 

From Bjorn.Antonsson at bea.com  Fri May 19 10:33:17 2006
From: Bjorn.Antonsson at bea.com (Bjorn Antonsson)
Date: Fri May 19 10:33:05 2006
Subject: [concurrency-interest] Question about
	"happens-before"andreordering
Message-ID: <9B70FBA69A3CB442AE548CBFF526DA2302EF8709@ukhwex01.emea.bea.com>

Let's just back up here a bit.

The only way for the ClassLoader constructor not to reach the
initialized assignement is to throw an exception. Either in
securityCheck() or in init(). No matter how amazingly inlining
or optimizing your jit-compiler is, it must still guarantee that
it doesn't move statements that have visible side effects before
possibly faulting instructions. That is a requirement of the
language. No matter what memory model or reordering stuff you
throw at it.

/Bj?rn
--
If you see a nasty sig at the bottom, it has been forced upon my email
by my employer.

> -----Original Message-----
> From: concurrency-interest-bounces@cs.oswego.edu 
> [mailto:concurrency-interest-bounces@cs.oswego.edu] On Behalf 
> Of Pete Soper
> Sent: den 19 maj 2006 15:24
> To: Thomas Hawtin
> Cc: concurrency-interest@cs.oswego.edu
> Subject: Re: [concurrency-interest] Question about 
> "happens-before"andreordering
> 
> Thomas Hawtin wrote:
> > Robert Kuhar wrote:
> > 
> >>   Secure Coding Guidelines:
> >>     - If finalize method can be overridden, ensure partially 
> >> initialized       instances are unusable
> > 
> > 
> > I think it's a little more subtle than that, particularly 
> prior to 1.6.
> > 
> >>   public class ClassLoader {
> >>     private boolean initialized = false;
> > 
> > 
> > I think the "= false" bit here is misleading. I certainly would not 
> > want to see "= true" in a similar situation.
> > 
> >>     ClassLoader() {
> >>       securityCheck(); // can throw an Exception
> >>       init();
> >>       initialized = true; // check flag in all relevant methods
> >>     }
> >>   }
> >>
> >> I asserted that they had two problems with this code.  As I 
> >> understand it, the runtime is free to reorder the instructions in 
> >> this constructor.  This means that initialized=true may 
> occur before 
> >> the calls to either
> >> securityCheck() or
> >> init().  If that is the case, its value cannot be trusted as this 
> >> code stands now.
> > 
> > 
> > If securityCheck does throw an exception, then the 
> initialized = true 
> > statement must never be executed. So there is no security 
> problem there.
> 
> Because compilers are not free to do this kind of code 
> motion? In the old 3GL days, compilers for some languages 
> were free to determine if an initialized reference (or maybe 
> an extremely subtle alias for the same
> storage) is possible in the called routine and, if not, hoist 
> the assignment up for the sake of better instruction 
> scheduling, getting it out of a loop, etc.
> 
> I don't recall if it was mentioned that init is assumed to be 
> a method of ClassLoader with the body judged irrelevant to 
> show. If init is a method of ClassLoader, then the compiler 
> (the dynamic one we typically enjoy, not javac) is free to 
> determine if init can assign to initialized, I think. (If 
> it's free to suck the code inline, then it's surely OK to 
> treat it like just another set of statements).
> 
> But it seems impossible for securityCheck to be able to 
> assign to initialized by any means, as it can't have a 
> reference to the object being constructed. So the init call 
> is the barrier to code motion, I think. But I don't know for 
> sure and the compiler writer that sits next door to me is at J1.
> 
> Cliff would know.
> 
> -Pete
> 
> > 
> > If securityCheck does not throw, then theoretically you could see a 
> > non-working, partially-initialised instance. However, that would be 
> > your own fault.
> > 
> > Tom Hawtin
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest@altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
_______________________________________________________________________
Notice:  This email message, together with any attachments, may contain
information  of  BEA Systems,  Inc.,  its subsidiaries  and  affiliated
entities,  that may be confidential,  proprietary,  copyrighted  and/or
legally privileged, and is intended solely for the use of the individual
or entity named in this message. If you are not the intended recipient,
and have received this message in error, please immediately return this
by email and then delete it.

From Pete.Soper at Sun.COM  Fri May 19 10:39:49 2006
From: Pete.Soper at Sun.COM (Pete Soper)
Date: Fri May 19 10:46:09 2006
Subject: [concurrency-interest] reordering
In-Reply-To: <446DAF9F.1000500@cs.kuleuven.be>
References: <1148033504.4447.18.camel@localhost.localdomain>
	<446DAF9F.1000500@cs.kuleuven.be>
Message-ID: <446DD8B5.8020306@Sun.COM>

Bart Jacobs wrote:
> There are multiple ways to explain the Java memory model. One uses the 
> notion of "reorderings".
> 
> There is also a different explanation, which is not in terms of 
> "reorderings", and which may be clarifying for you. In this other 
> explanation, in each program execution, all actions performed by a given 
> thread occur in the order specified by the program (known as the program 
> order). The only difference with the single-threaded semantics is that, 
> for fields accessed concurrently by multiple threads, field reads do not 
> necessarily yield the value written by the most recent preceding write.
> 
> In short, the memory model has no effect on single-threaded programs, 
> and it affects only fields accessed concurrently by multiple threads.

But it's important to realize that "program order" is a certified Java 
tricky term, because modern compilers and modern hardware frequently 
make this order VERY different from the lexical order of the source code 
statements. I believe this is a major point Hans has been stressing.

A bit of history. Since the 80s compilers have been doing things that 
the average developer would flatly declare impossible, illegal, or at 
least cruel with respect to true understanding of what's happening at 
runtime. The situation gets worse with concurrency added to the picture. 
In the 80s there were two supercompiler camps developing concurrency 
detection to do automatic parallelization and to get the most out of 
programs making use of extended "parallel" version of languages like 
Fortran (before these features were standardized). But in both of those 
cases it fell on the compiler to avoid races and the worst that would 
happen to a developer was that his loops didn't run faster because he 
had a dependency that inhibited optimization and they ran partially or 
entirely as sequential code. By contrast, Java with the j.u.c. APIs is 
absolute freedom and absolute responsibility for the developer.

When David Holmes mentioned "program order" recently I found myself 
struggling to come up with a simple explanation for what this means in 
the context of the JMM with concurrent apps, to amplify this part of 
David's remarks. It needs to communicate the two dimensions of data 
dependencies on the one hand while not requiring a degree in 
supercompiler writing to be comprehensible on the other. The JLS 
definition of "program order" in chapter 17 says what needs to be said, 
but for a very limited readership!! But in my opinion the sooner folks 
get this "program order" term straight in their heads, the sooner they 
can climb higher up the JMM mountain.

David's key point recently was:

  "To create cross-thread happens-before relationships you have
to use synchronization tools, like Locks, sync regions, or volatiles."

But back to your statement. I don't agree. The memory model *does* have 
relevance to single threaded programs, as the "constructor completion 
happens-before finalizer runs" rule shows us. At least I hope it does! 
It would be terrible if the finalizer thread can say "well, we're tired 
of waiting: lets just run this thing anyway."  Put a different way, even 
if the developer thinks they have a 100% single-threaded application, 
it's not running in a single-threaded environment.

-Pete

> 
> Bart
> 
> Kazimierz Pogoda wrote:
> 
>> This "reordering" idea made me suspicious about my own code. I know this
>> is not directly connected with concurrent programming, but I want to ask
>> experts, if this code fragment works as it is expected to:
>>
>>
>> public void execute(final String sql) throws SQLException {
>>     final Connection conn = getConnection(); //throws SQLException
>>     boolean executed = false;
>>     try {
>>         execute(conn, sql); //throws SQLException
>>         executed = true;
>>     } finally {
>>         boolean commited = false;
>>         if (executed) {
>>             try {
>>                 conn.commit();
>>                 commited = true;
>>             } catch (SQLException e) {
>>                 log("cannot commit connection", e);
>>             }
>>         }
>>         if (!commited) {
>>             try {
>>                 conn.rollback();
>>             } catch (SQLException e) {
>>                 log("cannot rollback connection", e);
>>             }
>>         }
>>         try {
>>             conn.close();
>>         } catch (SQLException e) {
>>             log("cannot close connection", e);
>>         }
>>     }
>> }
>>
>> The intent of this code is to throw to caller the original SQLException
>> (thrown by execute(conn, sql) method), not SQLException indicating that
>> connection cannot be commited or closed. In case of any Throwable
>> (RuntimeException, Error) thrown in execute(conn, sql) method I expect
>> also an attempt to rollback the connection (If connection is taken from
>> the pool, other thread can commit it later).
>>
>> I'm using boolean flags "executed" to indicate if Throwable has been
>> throw, and boolean flag "commited" for SQLException on commit().
>>
>> Is it possible, that "reordering" will effect in unexpected state of
>> those flags after some thrown Throwable?
>>
>>   
> 
> 
> 
> Disclaimer: http://www.kuleuven.be/cwis/email_disclaimer.htm
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From tackline at tackline.plus.com  Fri May 19 10:57:53 2006
From: tackline at tackline.plus.com (Thomas Hawtin)
Date: Fri May 19 10:58:04 2006
Subject: [concurrency-interest] Question about "happens-before"
	andreordering
In-Reply-To: <446DD090.4050106@Sun.COM>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com><7547a9ff0605181829n5ac1220jc6d06875af18110a@mail.gmail.com><7547a9ff0605182158p3b4947b2w7cef2e71dea19676@mail.gmail.com>
	<446DD090.4050106@Sun.COM>
Message-ID: <446DDCF1.8000404@tackline.plus.com>

Pete Soper wrote:
> 
> This seemed quite clear the first time. More fundamentally, if the 
> constructor never completes, the finalizer's running is impossible, right?

JLS 3 states that the finaliser may (because it never must) run if the 
Object constructor exited normally. 1.6 complies with this (apparently 
even if instrumentation rewrites the Object constructor).

I believe earlier editions of the JLS are silent on this. 1.5 (and I 
presumably earlier versions) will call the finaliser on any object that 
has been allocated. Possibly not even calling the derived most 
constructor. IIRC, javac produced byte code does the new, dups the 
uninitialised reference, evaluates the arguments, then calls the 
<init>(...)V, so even if the arguments are not fully evaluated the 
finaliser is called.

http://www.mernst.org/blog/archives/03-01-2006_03-31-2006.html#46
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4034630

Tom Hawtin
From robertkuhar at yahoo.com  Fri May 19 11:48:23 2006
From: robertkuhar at yahoo.com (Robert Kuhar)
Date: Fri May 19 11:48:32 2006
Subject: [concurrency-interest] Question about "happens-before" and
	reordering
In-Reply-To: <7547a9ff0605182158p3b4947b2w7cef2e71dea19676@mail.gmail.com>
Message-ID: <20060519154823.92985.qmail@web30608.mail.mud.yahoo.com>

> This seemed quite clear the first time. More fundamentally, if the 
> constructor never completes, the finalizer's running is impossible, right?
> 
The finalizer running in either the success or failure of the constructor is
the vunerability the example is trying to solve.  Somewhere on the show-floor,
as I was running around trying to gain enlightenment, the assertion was made
that the root cause of this problem is exactly that; the constructor failed,
but the object existed for the GC to find and finalize.

It appears that what makes the example thread-safe is a special case of the
relationship between the constructor and the finalizer of which I was unaware. 

  "...or the constructor won't appear to have happenned-before the finalizer
(and the spec says it must)." - Giuliano Mega
So that now makes sense.  However, it still strikes me as odd that a similar
pattern is held up as "what not to do" in the discussions of double-checked
locking but, for this case of constructor to finalizer, is somehow correct.

What I really need is "the Visible VM".  Much like "the Visible V8" of my
childhood.  You can do things to it, and watch the effects directly rather than
theorize about what can happen.  Now that would be really useful.

Thanks to all for their replies.  I think I'll just make my classes final and
that's that.  No need to worry about malicious subclasses exploiting finalizer
behavior.  Inheritence be damned!  I'm joking, I like inheritence.

Bob


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From jmanson at cs.purdue.edu  Fri May 19 11:51:35 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Fri May 19 11:52:02 2006
Subject: [concurrency-interest] Question about "happens-before"
	and	reordering
In-Reply-To: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
Message-ID: <446DE987.2040702@cs.purdue.edu>

Robert Kuhar wrote:
> I asserted that they had two problems with this code.  As I understand it, the
> runtime is free to reorder the instructions in this constructor.  This means
> that initialized=true may occur before the calls to either securityCheck() or
> init().  If that is the case, its value cannot be trusted as this code stands
> now.

This is not the case.  In Java, exceptions are precise, and must be 
treated like control flow.  The write will only occur if the exception 
is not thrown.  Neither this thread nor any other can see a write that 
does not occur.  This is one of those very few, tricky to get, 
guarantees for programs with data races that we make.

So, the point that the speaker was probably trying to make, which is 
that you can check the value of "initialized" to determine if 
securityCheck() exited without throwing an exception, is perfectly valid.

The compiler is free to move the write to initialized early if it can 
determine that the exception will not be thrown.  It is also free to 
hoist it above the call to init() (depending on what init() actually 
does).  This means that if another thread can obtain a reference to this 
object via a data race, and reads the "initialized" variable, it can see 
the value "true" even if the object is not fully constructed. 
Alternatively, such a thread could see a value "false" for initialized 
even if the object is fully constructed.

A few things to note:

0) Why isn't this class final?

1) As has been noted, constructors are guaranteed to happen-before 
finalize methods.  Therefore, finalizers will see all the writes that 
occur in the constructor.  For the purposes of whether this code does 
what it is intended to do, though, this is irrelevant, because the 
finalizer (I assume) is just resurrecting the object.

2) The initialized field should probably be final (which would mean that 
you could not put the "initialized = false" line in, but you probably 
don't want that line there anyway, as the default value is false, and 
moving the constructor around / adding more constructors will cause 
confusion).  Otherwise, you could use reflection to set it.

					Jeremy

From jmanson at cs.purdue.edu  Fri May 19 12:06:15 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Fri May 19 12:06:43 2006
Subject: [concurrency-interest] reordering
In-Reply-To: <446DD8B5.8020306@Sun.COM>
References: <1148033504.4447.18.camel@localhost.localdomain>	<446DAF9F.1000500@cs.kuleuven.be>
	<446DD8B5.8020306@Sun.COM>
Message-ID: <446DECF7.8080001@cs.purdue.edu>


Hi,

If you are looking at a single thread in isolation, program order means 
the order in which the statements in the source code occur, and the 
order in which the bytecodes occur.

> But back to your statement. I don't agree. The memory model *does*
> have relevance to single threaded programs, as the "constructor
> completion happens-before finalizer runs" rule shows us. At least I
> hope it does! It would be terrible if the finalizer thread can say
> "well, we're tired of waiting: lets just run this thing anyway."  Put
> a different way, even if the developer thinks they have a 100%
> single-threaded application, it's not running in a single-threaded
> environment.

I think that, rather than saying that the memory model has relevance to 
single-threaded programs, I might instead say that there are no 
single-threaded programs in Java.  Finalizers are a good example of why 
this is true - an object's finalizer will never run in the same thread 
in which the object was constructed, and there is nothing in the spec 
that suggests that it might.  This is one of the reasons why having some 
understanding of multithreaded programming and the memory model is so 
important.

Kazimierz's original code should do what it was intended to do because, 
once again, of the precision of exceptions.  Again, the write to the 
committed variable, for example, will only occur if the exception is not 
thrown.

					Jeremy
From jmanson at cs.purdue.edu  Fri May 19 12:15:04 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Fri May 19 12:15:24 2006
Subject: [concurrency-interest] Question about
	"happens-before"	and	reordering
In-Reply-To: <446DE987.2040702@cs.purdue.edu>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
	<446DE987.2040702@cs.purdue.edu>
Message-ID: <446DEF08.4030901@cs.purdue.edu>

Jeremy Manson wrote:

> 
> 2) The initialized field should probably be final (which would mean that 
> you could not put the "initialized = false" line in, but you probably 
> don't want that line there anyway, as the default value is false, and 
> moving the constructor around / adding more constructors will cause 
> confusion).  Otherwise, you could use reflection to set it.
> 

Whoops!  I didn't mean that last bit!  But it should probably be final 
anyway.

					Jeremy
From Pete.Soper at Sun.COM  Fri May 19 12:57:44 2006
From: Pete.Soper at Sun.COM (Pete Soper)
Date: Fri May 19 13:03:59 2006
Subject: [concurrency-interest] Question about "happens-before"
	andreordering
In-Reply-To: <446DDCF1.8000404@tackline.plus.com>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
	<7547a9ff0605181829n5ac1220jc6d06875af18110a@mail.gmail.com>
	<7547a9ff0605182158p3b4947b2w7cef2e71dea19676@mail.gmail.com>
	<446DD090.4050106@Sun.COM> <446DDCF1.8000404@tackline.plus.com>
Message-ID: <446DF908.2050500@Sun.COM>

Thomas Hawtin wrote:
> Pete Soper wrote:
> 
>>
>> This seemed quite clear the first time. More fundamentally, if the 
>> constructor never completes, the finalizer's running is impossible, 
>> right?
> 
> 
> JLS 3 states that the finaliser may (because it never must) run if the 
> Object constructor exited normally. 1.6 complies with this (apparently 
> even if instrumentation rewrites the Object constructor).
> 
> I believe earlier editions of the JLS are silent on this. 1.5 (and I 
> presumably earlier versions) will call the finaliser on any object that 
> has been allocated. Possibly not even calling the derived most 
> constructor. IIRC, javac produced byte code does the new, dups the 
> uninitialised reference, evaluates the arguments, then calls the 
> <init>(...)V, so even if the arguments are not fully evaluated the 
> finaliser is called.
> 
> http://www.mernst.org/blog/archives/03-01-2006_03-31-2006.html#46
> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4034630

  This is a dupe of 5092933 which I'm happy to say was fixed in build 59 
of Mustang.
   JLS 17.4.5 says the edge is from the end of the constructor, which 
presumably can't be reached if an exception is thrown or the thread 
stops making progress through the constructor. If a more tricky 
definition of "end" is being used, then I shouldn't be surprised, but 
will be anyway.

-Pete

> 
> Tom Hawtin
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From jmanson at cs.purdue.edu  Fri May 19 13:14:40 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Fri May 19 13:15:00 2006
Subject: [concurrency-interest] Question about
	"happens-before"	andreordering
In-Reply-To: <446DF908.2050500@Sun.COM>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>	<7547a9ff0605181829n5ac1220jc6d06875af18110a@mail.gmail.com>	<7547a9ff0605182158p3b4947b2w7cef2e71dea19676@mail.gmail.com>	<446DD090.4050106@Sun.COM>
	<446DDCF1.8000404@tackline.plus.com> <446DF908.2050500@Sun.COM>
Message-ID: <446DFD00.3020001@cs.purdue.edu>

Pete Soper wrote:

>   JLS 17.4.5 says the edge is from the end of the constructor, which 
> presumably can't be reached if an exception is thrown or the thread 
> stops making progress through the constructor. If a more tricky 
> definition of "end" is being used, then I shouldn't be surprised, but 
> will be anyway.

The section on finalization to which 17.4.5 points clarifies this to 
mean that the constructor's "completion" happens-before the finalize 
method.  In the context of the JLS, "completion" means completion via 
normal means or via exceptional (also called abrupt) means.

So "end" here means via an exception, as well.  We probably should have 
used the word "completion" in 17.4.5 to make it clearer.

OTOH, if the thread hangs, then completion is never reached, as you 
point out.

					Jeremy
From Pete.Soper at Sun.COM  Fri May 19 13:18:30 2006
From: Pete.Soper at Sun.COM (Pete Soper)
Date: Fri May 19 13:24:49 2006
Subject: [concurrency-interest] Question about "happens-before" and
	reordering
In-Reply-To: <20060519154823.92985.qmail@web30608.mail.mud.yahoo.com>
References: <20060519154823.92985.qmail@web30608.mail.mud.yahoo.com>
Message-ID: <446DFDE6.1040306@Sun.COM>

Robert Kuhar wrote:
>>This seemed quite clear the first time. More fundamentally, if the 
>>constructor never completes, the finalizer's running is impossible, right?
>>
> 
> The finalizer running in either the success or failure of the constructor is
> the vunerability the example is trying to solve.  Somewhere on the show-floor,
> as I was running around trying to gain enlightenment, the assertion was made
> that the root cause of this problem is exactly that; the constructor failed,
> but the object existed for the GC to find and finalize.

I'm slow on the uptake some times (by approximately 7 1/2 years) and 
missed understanding what started this mail thread. Thanks to Tom for 
making the bug to do with this apparent, and to Jeremy for explaining 
the exception handling (probably) being the big roadblock for preventing 
the code motion in that example constructor.

And I just spotted Bill Pugh's comment about the older of the two bugs. 
I do need something for my stomach.

-Pete

> 
> It appears that what makes the example thread-safe is a special case of the
> relationship between the constructor and the finalizer of which I was unaware. 
> 
>   "...or the constructor won't appear to have happenned-before the finalizer
> (and the spec says it must)." - Giuliano Mega
> So that now makes sense.  However, it still strikes me as odd that a similar
> pattern is held up as "what not to do" in the discussions of double-checked
> locking but, for this case of constructor to finalizer, is somehow correct.
> 
> What I really need is "the Visible VM".  Much like "the Visible V8" of my
> childhood.  You can do things to it, and watch the effects directly rather than
> theorize about what can happen.  Now that would be really useful.
> 
> Thanks to all for their replies.  I think I'll just make my classes final and
> that's that.  No need to worry about malicious subclasses exploiting finalizer
> behavior.  Inheritence be damned!  I'm joking, I like inheritence.
> 
> Bob
> 
> 
> __________________________________________________
> Do You Yahoo!?
> Tired of spam?  Yahoo! Mail has the best spam protection around 
> http://mail.yahoo.com 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From Pete.Soper at Sun.COM  Fri May 19 13:32:01 2006
From: Pete.Soper at Sun.COM (Pete Soper)
Date: Fri May 19 13:38:18 2006
Subject: [concurrency-interest] Question about "happens-before"
	andreordering
In-Reply-To: <446DFD00.3020001@cs.purdue.edu>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
	<7547a9ff0605181829n5ac1220jc6d06875af18110a@mail.gmail.com>
	<7547a9ff0605182158p3b4947b2w7cef2e71dea19676@mail.gmail.com>
	<446DD090.4050106@Sun.COM> <446DDCF1.8000404@tackline.plus.com>
	<446DF908.2050500@Sun.COM> <446DFD00.3020001@cs.purdue.edu>
Message-ID: <446E0111.4040101@Sun.COM>

Jeremy Manson wrote:
> Pete Soper wrote:
> 
>>   JLS 17.4.5 says the edge is from the end of the constructor, which 
>> presumably can't be reached if an exception is thrown or the thread 
>> stops making progress through the constructor. If a more tricky 
>> definition of "end" is being used, then I shouldn't be surprised, but 
>> will be anyway.
> 
> 
> The section on finalization to which 17.4.5 points clarifies this to 
> mean that the constructor's "completion" happens-before the finalize 
> method.  In the context of the JLS, "completion" means completion via 
> normal means or via exceptional (also called abrupt) means.
> 
> So "end" here means via an exception, as well.  We probably should have

Oh, so what I asserted to Tom is wrong. Thanks for this clarification.

If a finalizer method might run on an object for which construction is 
incomplete in an arbitrary manner (by virtue of the ctor throwing an 
exception), it means writing a good finalizer method is more challenging 
than writing correct concurrent code for the uninitiated, or at least 
just as challenging. It tells me if I ever get tempted to write a 
finalizer method I'll put an edge between the last statement of the ctor 
and the first statement of the finalizer as the first lines of code 
written. And it's difficult to reconcile this with Bill Pugh's comment 
about 4034630 on the page Tom pointed to. Is the JLS being updated for 
Mustang to go along with the implementation change, or am I still not 
getting it?

-Pete

> used the word "completion" in 17.4.5 to make it clearer.
> 
> OTOH, if the thread hangs, then completion is never reached, as you 
> point out.
> 
>                     Jeremy
> 

From jmanson at cs.purdue.edu  Fri May 19 14:01:03 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Fri May 19 14:01:25 2006
Subject: [concurrency-interest] Question about
	"happens-before"	andreordering
In-Reply-To: <446E0111.4040101@Sun.COM>
References: <20060518235743.92204.qmail@web30602.mail.mud.yahoo.com>
	<7547a9ff0605181829n5ac1220jc6d06875af18110a@mail.gmail.com>
	<7547a9ff0605182158p3b4947b2w7cef2e71dea19676@mail.gmail.com>
	<446DD090.4050106@Sun.COM> <446DDCF1.8000404@tackline.plus.com>
	<446DF908.2050500@Sun.COM> <446DFD00.3020001@cs.purdue.edu>
	<446E0111.4040101@Sun.COM>
Message-ID: <446E07DF.9030000@cs.purdue.edu>

Pete Soper wrote:

> Oh, so what I asserted to Tom is wrong. Thanks for this clarification.
> 
> If a finalizer method might run on an object for which construction is 
> incomplete in an arbitrary manner (by virtue of the ctor throwing an 
> exception), it means writing a good finalizer method is more challenging 
> than writing correct concurrent code for the uninitiated, or at least 
> just as challenging. It tells me if I ever get tempted to write a 
> finalizer method I'll put an edge between the last statement of the ctor 
> and the first statement of the finalizer as the first lines of code 
> written. 

Hopefully, you shouldn't be too tempted to write finalizer methods. 
There is a reason we say that there is an edge from the end of the 
constructor to the finalizer.  Uses of the object after completion of 
the constructor are not guaranteed to happen-before the finalizer.  In 
simpler terms, *the finalizer will not necessarily see updates that 
occur to an object after the constructor completes*.  You can set a 
field of that object, and the finalizer might not see it!

To get around this, you need a happens-before edge from the last use of 
the object in the rest of the code to the finalizer.  I urge people 
interested in writing finalizers to read Section 12.6.1 in JLS3.

Actually, I urge people interested in writing finalizers not to write 
finalizers.

 > And it's difficult to reconcile this with Bill Pugh's comment
> about 4034630 on the page Tom pointed to. Is the JLS being updated for 
> Mustang to go along with the implementation change, or am I still not 
> getting it?
> 

I had forgotten to mention that issue.  There is a special case to my 
comments - the constructor for class Object needs to be invoked and 
complete normally for finalization to occur at all.  Other constructors 
may terminate by throwing exceptions.  The details are in JLS section 12.6.

Thanks for the clarification.

					Jeremy
From brian at quiotix.com  Fri May 19 14:17:14 2006
From: brian at quiotix.com (Brian Goetz)
Date: Fri May 19 14:20:41 2006
Subject: [concurrency-interest] Top selling book at JavaOne
Message-ID: <446E0BAA.7070705@quiotix.com>

The top selling book at JavaOne this year was Java Concurrency in 
Practice!  For those of you who have asked, Amazon should have their 
stock in a week or two.

   http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69

Congrats also to Josh, who wrote or co-wrote three of the top four 
selling books at the show (JCiP, Puzzlers, EJ).
From Pete.Soper at Sun.COM  Fri May 19 14:46:24 2006
From: Pete.Soper at Sun.COM (Pete Soper)
Date: Fri May 19 14:52:45 2006
Subject: [concurrency-interest] reordering
In-Reply-To: <446DECF7.8080001@cs.purdue.edu>
References: <1148033504.4447.18.camel@localhost.localdomain>
	<446DAF9F.1000500@cs.kuleuven.be> <446DD8B5.8020306@Sun.COM>
	<446DECF7.8080001@cs.purdue.edu>
Message-ID: <446E1280.7060805@Sun.COM>

Jeremy Manson wrote:
> 
> Hi,
> 
> If you are looking at a single thread in isolation, program order means 
> the order in which the statements in the source code occur, and the 
> order in which the bytecodes occur.

But if I'm sitting in gdb it doesn't look quite the same, and my 
interpretation of Robert's "Visible VM" view would show an astonishing 
sequence of memory references, making mapping back to source order and 
complete understanding quite a job for even a short program. But I'm 
getting the message that delving into "program order" is just not 
profitable and I think it's interesting that Java Concurrency in 
Practice gives extremely brief mention of compiler/hardware 
optimizations. Until I find out otherwise I'm going to conclude this 
detail is distraction from the more important points.

> 
>> But back to your statement. I don't agree. The memory model *does*
>> have relevance to single threaded programs, as the "constructor
>> completion happens-before finalizer runs" rule shows us. At least I
>> hope it does! It would be terrible if the finalizer thread can say
>> "well, we're tired of waiting: lets just run this thing anyway."  Put
>> a different way, even if the developer thinks they have a 100%
>> single-threaded application, it's not running in a single-threaded
>> environment.
> 
> 
> I think that, rather than saying that the memory model has relevance to 
> single-threaded programs, I might instead say that there are no 
> single-threaded programs in Java.  Finalizers are a good example of why 

I was attempting to say this.

> this is true - an object's finalizer will never run in the same thread 
> in which the object was constructed, and there is nothing in the spec 
> that suggests that it might.  This is one of the reasons why having some 
> understanding of multithreaded programming and the memory model is so 
> important.

I think this is a key point. Java programmers cannot avoid understanding 
the JMM to some degree. The big question in my mind is what the 
essential subset is to communicate?

> 
> Kazimierz's original code should do what it was intended to do because, 
> once again, of the precision of exceptions.  Again, the write to the 
> committed variable, for example, will only occur if the exception is not 
> thrown.

And you also wrote:

 > Hopefully, you shouldn't be too tempted to write finalizer methods.

A friend's description of a talk by Hans Boehm at JavaOne last year made 
me simply stop thinking about finalizers. It's part of the pain of this 
job to have to deal with the fact that they haven't been yanked out like 
a bad tooth (insert corporate disclaimers here). And you're right, edges 
would have to be laid down in places to allow precise communication 
between object and finalizer, with the one from "last object use" to the 
finalizer being the essential subset.

This has been a very pleasant exercise. Thanks again.

-Pete

> 
>                     Jeremy
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From the.mindstorm.mailinglist at gmail.com  Fri May 19 15:36:31 2006
From: the.mindstorm.mailinglist at gmail.com (Alexandru Popescu)
Date: Fri May 19 15:36:42 2006
Subject: [concurrency-interest] Top selling book at JavaOne
In-Reply-To: <446E0BAA.7070705@quiotix.com>
References: <446E0BAA.7070705@quiotix.com>
Message-ID: <c6f400460605191236p53193861h1cecd3ea4d1ba565@mail.gmail.com>

Congrats Brian!

Hope to get my hands on it quite soon :-).

./alex
--
.w( the_mindstorm )p.

InfoQ.com Architect

On 5/19/06, Brian Goetz <brian@quiotix.com> wrote:
> The top selling book at JavaOne this year was Java Concurrency in
> Practice!  For those of you who have asked, Amazon should have their
> stock in a week or two.
>
>    http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69
>
> Congrats also to Josh, who wrote or co-wrote three of the top four
> selling books at the show (JCiP, Puzzlers, EJ).
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From tim at peierls.net  Fri May 19 16:09:56 2006
From: tim at peierls.net (Tim Peierls)
Date: Fri May 19 16:09:59 2006
Subject: [concurrency-interest] ScheduledExecutorService
In-Reply-To: <24466.1148044018@blunt.localdomain>
References: <24466.1148044018@blunt.localdomain>
Message-ID: <63b4e4050605191309n370b21ep44ce5995f172df61@mail.gmail.com>

No, but STPE can still do the job if you use it to schedule the submission
of work to a secondary (non-scheduled) executor service. When a lot of work
triggers at once, all it has to do is put it on the secondary executor's
queue.

--tim

On 5/19/06, Jeff Schultz <jws@cs.mu.oz.au> wrote:
>
> Does anyone have a ScheduledExecutorService that uses a varying number
> of Threads?  ScheduledThreadPoolExecutor's "acts as a fixed-sized pool
> using corePoolSize threads and an unbounded queue" is not what I need
> for a particularly bursty workload.
>
>
>     Jeff Schultz
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060519/e696a341/attachment.html
From joe.bowbeer at gmail.com  Fri May 19 16:27:21 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri May 19 16:27:24 2006
Subject: [concurrency-interest] reordering
In-Reply-To: <446DD8B5.8020306@Sun.COM>
References: <1148033504.4447.18.camel@localhost.localdomain>
	<446DAF9F.1000500@cs.kuleuven.be> <446DD8B5.8020306@Sun.COM>
Message-ID: <31f2a7bd0605191327k29ecc39awc0c56dc9b87bfd4a@mail.gmail.com>

On 5/19/06, Pete Soper <Pete.Soper@sun.com> wrote:
>
> But it's important to realize that "program order" is a certified Java
> tricky term

To reiterate and hopefully illuminate Jeremy's response:

Program Order *is* an easy concept, and the JMM is designed to
maintain its usefulness as a tool for reasoning about the behavior of
a concurrent program -- while at the same time not preventing many
optimizations that would be prohibited by an even more
programmer-friendly sequential model (such as sequential consistency).

The following description is from

http://www.cs.umd.edu/users/jmanson/java/journal.pdf

1.1 Sequential Consistency

Sequential consistency specifies that memory actions will appear to
execute one at a time in a single total order; actions of a given
thread must appear in this total order in the same order in which they
appear in the program prior to any optimizations ? this is an informal
definition of what we shall refer to as the "program order".

Later in section 2.1:

It is difficult for programmers to reason about specific hardware and
compiler transformations. For ease of use, we therefore specify the
model so that programmers do not have to reason about hardware or
compiler transformations or even our formal semantics for correctly
synchronized code.


Aside: In the JMM literature, I find the term "compiler" more
confusing than "program order".  In these discussions, "compiler"
often refers to the actions of HotSpot (in converting bytecode to
native code) more than it refers to javac.


On 5/19/06, Pete Soper <Pete.Soper@sun.com> wrote:
>
> I think it's interesting that Java Concurrency in Practice gives extremely
> brief mention of compiler/hardware optimizations. Until I find out otherwise
> I'm going to conclude this detail is distraction from the more important
> points.

Good idea :-)  I agree that a Visible VM would be illuminating.  I
think many programmers would find it satisfying.  After all, some
programmers *like* to reason about specific compiler and hardware
transformations rather than abstract models.  That's why they're
programmers!  But optimization is a fast-moving target today, and only
the formal model describes the full, as yet unrealized, potential of
future VM's.


On 5/19/06, Pete Soper <Pete.Soper@sun.com> wrote:
> Bart Jacobs wrote:
> > There are multiple ways to explain the Java memory model. One uses the
> > notion of "reorderings".
> >
> > There is also a different explanation, which is not in terms of
> > "reorderings", and which may be clarifying for you. In this other
> > explanation, in each program execution, all actions performed by a given
> > thread occur in the order specified by the program (known as the program
> > order). The only difference with the single-threaded semantics is that,
> > for fields accessed concurrently by multiple threads, field reads do not
> > necessarily yield the value written by the most recent preceding write.
> >
> > In short, the memory model has no effect on single-threaded programs,
> > and it affects only fields accessed concurrently by multiple threads.
>
> But it's important to realize that "program order" is a certified Java
> tricky term, because modern compilers and modern hardware frequently
> make this order VERY different from the lexical order of the source code
> statements. I believe this is a major point Hans has been stressing.
>
> A bit of history. Since the 80s compilers have been doing things that
> the average developer would flatly declare impossible, illegal, or at
> least cruel with respect to true understanding of what's happening at
> runtime. The situation gets worse with concurrency added to the picture.
> In the 80s there were two supercompiler camps developing concurrency
> detection to do automatic parallelization and to get the most out of
> programs making use of extended "parallel" version of languages like
> Fortran (before these features were standardized). But in both of those
> cases it fell on the compiler to avoid races and the worst that would
> happen to a developer was that his loops didn't run faster because he
> had a dependency that inhibited optimization and they ran partially or
> entirely as sequential code. By contrast, Java with the j.u.c. APIs is
> absolute freedom and absolute responsibility for the developer.
>
> When David Holmes mentioned "program order" recently I found myself
> struggling to come up with a simple explanation for what this means in
> the context of the JMM with concurrent apps, to amplify this part of
> David's remarks. It needs to communicate the two dimensions of data
> dependencies on the one hand while not requiring a degree in
> supercompiler writing to be comprehensible on the other. The JLS
> definition of "program order" in chapter 17 says what needs to be said,
> but for a very limited readership!! But in my opinion the sooner folks
> get this "program order" term straight in their heads, the sooner they
> can climb higher up the JMM mountain.
>
> David's key point recently was:
>
>   "To create cross-thread happens-before relationships you have
> to use synchronization tools, like Locks, sync regions, or volatiles."
>
> But back to your statement. I don't agree. The memory model *does* have
> relevance to single threaded programs, as the "constructor completion
> happens-before finalizer runs" rule shows us. At least I hope it does!
> It would be terrible if the finalizer thread can say "well, we're tired
> of waiting: lets just run this thing anyway."  Put a different way, even
> if the developer thinks they have a 100% single-threaded application,
> it's not running in a single-threaded environment.
>
> -Pete
>

From mattocks at mac.com  Fri May 19 21:33:30 2006
From: mattocks at mac.com (Craig Mattocks)
Date: Fri May 19 21:33:40 2006
Subject: [concurrency-interest] Top selling book at JavaOne
Message-ID: <9598ac29634c978078a18267a2f47b9f@mac.com>

On Fri, 19 May 2006 14:17:14 -0400 Brian Goetz <brian@quiotix.com> 
wrote:

> The top selling book at JavaOne this year was Java Concurrency in
> Practice!  For those of you who have asked, Amazon should have their
> stock in a week or two.
>
> http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69

Finally shipping!

The following items have been shipped to you by Amazon.com:
---------------------------------------------------------------------
Qty      Item                           Price  Shipped  Subtotal
---------------------------------------------------------------------
    1     Java Concurrency in Practice    $26.39      1   $26.39

Craig

From dcholmes at optusnet.com.au  Sun May 21 17:34:23 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sun May 21 17:34:51 2006
Subject: [concurrency-interest] Re: interrupt / notify races even in
	6.0beta?
In-Reply-To: <446AAA55.4050301@mathcs.emory.edu>
Message-ID: <NFBBKALFDCPFIDBNKAPCKELAGOAA.dcholmes@optusnet.com.au>

Dawid,

> Dawid Kurzyniec wrote:
> I realize that you (EG) have dealt with this issue for decades now; so
> please have a little patience with me here; I'd like to understand the
> problem fully to make sure that I don't screw up anything in the
> backport. It is no mystery that there is a possible race between notify
> / interrupt, as it is between memory read / write, when there is no
> happens-before relationship between these operations. Ideally, and
> intuitively however, I would expect that the ordering of notify /
> interrupt becomes deterministic when there is a happens-before
> relationship, e.g. if the operations are invoked from the same thread.
> Apparently, it is not the case, and the spec does not actually promise
> it. I am trying to understand why it can't be made to be the case. For
> instance, why can't the interruption status be combined with a thread
> state (runnable, blocked, waiting, io) into an atomic state variable -
> having interrupt() CAS-ing it to INTERRUPTED, removing the tread from
> the condition's wait set if was WAITING, and having notify() loop
> CAS-ing the state of a candidate thread to RUNNABLE if was WAITING, and
> skipping it over if was INTERRUPTED. Perhaps the problem is that the OS
> layer does not expose things this way?...

I fully sympathise with you as I was in the exact same position asking the
exact same questions and wanting similar answers. Since then I have learned
the "why" of it.

Anything is possible, and a design as outlined above is possible, but that
isn't the way hotspot evolved in this area. In simple terms there are two
things going on here:

1. interrupt() is only loosely coupled to the use of monitors. interrupt()
ensures that a blocked thread wakes up but it doesn't check to see why (or
even if) the thread was blocked in the first place, and so in this case it
doesn't make any change to the wait-set. So in a sense, yes it is
"asynchronous".

2. Contrary to what Doug indicated the VM actually favours notification over
interruption (while jsr-166 stuff does the opposite).

Hence by the time the thread wakes up due to the interrupt, the main thread
has also removed it from the wait-set. The VM favours notification and so
you get a normal return with the interrupt bit set.

The OS issues are more to do with timeouts - because the OS sometimes lies
and you can't tell you timed-out. That is something else I lament - that
even with jsr-166 you can't truly tell for certain whether or not you
timed-out. :(

> But then again, with the
> low-level primitives like those used by park/unpark, wouldn't it be
> possible to implement it at the JVM side, without relying on OS-level
> wait sets etc?

If at some point in the future the same mechanism were to be used for
jsr-166 sync and monitor sync, then you would get the same (unspecified)
behaviour from each.

So any "test" that assumes the order of notifications and interrupts is
invalid. All you can test is whether the interrupt state is set or cleared
correctly, and that notifications are not lost.

If you want all the gory details sign up at java.net and download the
Mustang snapshots :)

Cheers,
David Holmes

From dcholmes at optusnet.com.au  Sun May 21 18:36:02 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sun May 21 18:36:29 2006
Subject: [concurrency-interest] AtomicReference weakCompareAndSet
	"Mayfailspuriously"?
In-Reply-To: <BE06AD6C-6C95-4ABA-8809-8889C74E9A31@cs.umd.edu>
Message-ID: <NFBBKALFDCPFIDBNKAPCOELDGOAA.dcholmes@optusnet.com.au>

Bill Pugh writes:
> I would explain this differently (actually, the JMM requires that
> it  be explained differently):
>
> weakCompareAndSet has volatile semantics, _except_ that it doesn't
> create any happens-before edges.

But isn't the existence of those edges the only thing that distinguishes
volatile semantics from non-volatile (barring the 64-bit atomicity issue)?

> So, here is the question we should discuss:
>
> **********
>
> Should weakCompareAndSet on an AtomicReference create happens
> before  edges (just as compareAndSwap does)?
>
> **********

For consistency I'd say no. Arguably AtomicReference.weakCompareAndSet was a
mistake and should be deprecated. But one-in all-in.

We probably need to migrate the details from the package docs into the
actual method docs.

To address Cliff's problem I think the best solution is to add a
WeakAtomicInteger class that has no volatile semantics at all. I wonder
whether the JMX implementation would benefit from using such a class?

David

From dl at cs.oswego.edu  Sun May 21 18:47:57 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun May 21 18:48:00 2006
Subject: [concurrency-interest] down time
Message-ID: <4470EE1D.8030401@cs.oswego.edu>


Starting sometime tomorrow, this list will be down for probably
between an hour and a day as altair.cs.oswego.edu is upgraded.

-Doug
From robertlazarski at gmail.com  Mon May 22 20:54:52 2006
From: robertlazarski at gmail.com (robert lazarski)
Date: Mon, 22 May 2006 21:54:52 -0300
Subject: [concurrency-interest] Creating a Set of pings
Message-ID: <f87675ee0605221754o59a18d90s2cab79bef82550@mail.gmail.com>

Could someone please give some advice on these requirements?

1) Find all IP's on a given subnet that responds to ICMP  (ping). So for say
192.168.10.0 with a netmask of 255.255.255.0, attempt a ping to 255
addresses. In java  I believe I can use InetAddress.isReachable(timeout) .

2) On a valid IP, try to connect on port 161 via UDP and snmp.

3) Put the valid IP's inside an implementation of java.util.Set .

4) Compare new Set with a previous Set and show updates.

My questions are:

1) Perform steps 1, 2, and possibly 3 in a Callable or Runnable. On typical
intel hardware does an ExecutorService with a size of 5 sound about right?
2) Should I pass in a Callable and get the results back 255 times, or should
I use Runnable and have the threads write the result to a common area, ie,
an object with a synchronized method ?
3) Should I use one of the concurrent collections to store the results?
CopyOnWriteArrayList seems to fit.

Thanks for any help,
Robert
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060522/9b8d465f/attachment.html 

From tim at peierls.net  Mon May 22 23:19:35 2006
From: tim at peierls.net (Tim Peierls)
Date: Mon, 22 May 2006 23:19:35 -0400
Subject: [concurrency-interest] Creating a Set of pings
In-Reply-To: <f87675ee0605221754o59a18d90s2cab79bef82550@mail.gmail.com>
References: <f87675ee0605221754o59a18d90s2cab79bef82550@mail.gmail.com>
Message-ID: <63b4e4050605222019m2a4e715an791533f530029464@mail.gmail.com>

If you don't mind doing all step 1 work before all step 2/3 work, use
ExecutorService.invokeAll on a collection of Callable<InetAddress> tasks
that test isReachable.

For each of these that succeeds, create a new Callable<InetAddress> that
tries to connect on port 161, and pass a collection these new tasks to
another invocation of ExecutorService.invokeAll.

For each of these that succeeds, put the resulting InetAddress into a plain
HashSet -- CopyOnWriteArrayList is for lists that are frequently read by
different threads but rarely written to. This set need only be accessed by
one thread, the thread that creates it and compares it to some previous
value -- this previous value could be a thread-safe set if other threads
need to access it.

Here's an uncompiled, untested, and possibly completely wrong-headed sketch:

ExecutorService exec = ...;
Collection<InetAddress> addrs = ...;

List<Callable<InetAddress>> testReachableTasks =
    new ArrayList<Callable<InetAddress>>();
for (final InetAddress addr : addrs) {
    testReachableTasks.add(new Callable<InetAddress>() {
        public InetAddress call() {
            return isReachable(addr) ? addr : null;
        }
    });
}
List<Future<InetAddress>> reachables =
    exec.invokeAll(testReachableTasks);

List<Callable<InetAddress>> tryConnectTasks =
    new ArrayList<Callable<InetAddress>>();
for (Future<InetAddress>> reachable : reachables) {
    // need to handle exceptions thrown by Future.get()
    final InetAddress addr = reachable.get();
    if (addr == null) continue;

    tryConnectTasks.add(new Callable<InetAddress>() {
        public InetAddress call() {
            return (canConnectUdp (addr)
                 || canConnectSnmp(addr)) ? addr : null;
        }
    });
}
List<Future<InetAddress>> connectables =
    exec.invokeAll(tryConnectTasks);

Set<InetAddress> result = new HashSet<InetAddress>();
for (Future<InetAddress>> connectable : connectables) {
    // need to handle exceptions thrown by Future.get()
    InetAddress addr = connectable.get();
    if (addr != null) result.add(addr);
}
// compare result to previous result

If you want to start doing step 2/3 work before all step 1 work is complete,
use 2 instances of ExecutorCompletionService, one corresponding to each call
to invokeAll, and pull completed tasks off of one completion queue to insert
it into the next. It's a little trickier, since you have to count
submissions to know when you're done with a completion queue.

I can't advise on how to size the pool. How many network interfaces are
there? How many processors are there? Seems like something you'd want to be
able to tune.

--tim

On 5/22/06, robert lazarski <robertlazarski at gmail.com> wrote:
>
> Could someone please give some advice on these requirements?
>
> 1) Find all IP's on a given subnet that responds to ICMP  (ping). So for
> say 192.168.10.0 with a netmask of 255.255.255.0, attempt a ping to 255
> addresses. In java  I believe I can use InetAddress.isReachable(timeout) .
>
>
> 2) On a valid IP, try to connect on port 161 via UDP and snmp.
>
> 3) Put the valid IP's inside an implementation of java.util.Set .
>
> 4) Compare new Set with a previous Set and show updates.
>
> My questions are:
>
> 1) Perform steps 1, 2, and possibly 3 in a Callable or Runnable. On
> typical intel hardware does an ExecutorService with a size of 5 sound about
> right?
> 2) Should I pass in a Callable and get the results back 255 times, or
> should I use Runnable and have the threads write the result to a common
> area, ie, an object with a synchronized method ?
> 3) Should I use one of the concurrent collections to store the results?
> CopyOnWriteArrayList seems to fit.
>
> Thanks for any help,
> Robert
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060522/9e37001c/attachment.html 

From dawidk at mathcs.emory.edu  Tue May 23 00:01:06 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue, 23 May 2006 00:01:06 -0400
Subject: [concurrency-interest] Creating a Set of pings
In-Reply-To: <f87675ee0605221754o59a18d90s2cab79bef82550@mail.gmail.com>
References: <f87675ee0605221754o59a18d90s2cab79bef82550@mail.gmail.com>
Message-ID: <44728902.7080209@mathcs.emory.edu>

robert lazarski wrote:
> Could someone please give some advice on these requirements?
>
> 1) Find all IP's on a given subnet that responds to ICMP  (ping). So 
> for say 192.168.10.0 <http://192.168.10.0> with a netmask of 
> 255.255.255.0 <http://255.255.255.0>, attempt a ping to 255 addresses. 
> In java  I believe I can use InetAddress.isReachable(timeout) .

Concurrency issues aside, you may want to try to include some measures 
to reduce the amount of generated network traffic (perhaps by using 
broadcast echo instead of the network scanning); otherwise you may run 
into a risk of having your application looking suspicious to security 
administrators. Perhaps see how services like Lisa 
(http://lisa-home.sourceforge.net/) do these things.

Regards,
Dawid


From chakritsus at yahoo.com  Tue May 23 13:24:20 2006
From: chakritsus at yahoo.com (Tutika Chakravarthy)
Date: Tue, 23 May 2006 10:24:20 -0700 (PDT)
Subject: [concurrency-interest] Resetting FutureTask
In-Reply-To: <200605221600.k4MG0Lek029004@cs.oswego.edu>
Message-ID: <20060523172420.83769.qmail@web35703.mail.mud.yahoo.com>

Hi,
I have a small question about the popular Memoize
example
code snippet:
  public class Memoize<A, V> implements Computable<A,
V>
{
     public Memoize(Computable<A, V> c) {
         this.c = c;
     }
     public V compute(final A arg) throws Exception {
         Future<V> f = cache.get(arg);
         if (f == null) {
             Callable<V> eval = new Callable<V>() {
                 public V call() throws Exception {
                     return c.compute(arg);
                 }
             };
             FutureTask<V> ft = new
FutureTask<V>(eval);
             f = cache.putIfAbsent(arg, ft);
             if (f == null) { f = ft; ft.run(); }
         }
         return f.get();
     }
     private final ConcurrentMap<A, Future<V>> cache =
         new ConcurrentHashMap<A, Future<V>>();
     private final Computable<A, V> c;
}

My questions is, if call() method in Callable instance
throws Exception , How can I reset the FutureTask?

I am trying to put some code around "f.get()" like

try{
f.get()

}catch(ExecutionException e)
{
cache.remove(arg,f);

}

But will this solve the problem of reseting the
FutureTask?

If one thread gets an exception in call() method,I am
trying to avoid other threads getting the same
exception.


Tutika


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From jason_mehrens at hotmail.com  Tue May 23 14:12:36 2006
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Tue, 23 May 2006 13:12:36 -0500
Subject: [concurrency-interest] synchronized on construction
Message-ID: <BAY105-F37B42FE3B32171353ED6A4839B0@phx.gbl>

Browsing over the java.util.Vector class I noticed that in the constructors, 
the initial writes to the internal data members (non-final and non-volatile) 
are not performed under a synchronized block.   The same is true for when a 
Vector is deserialized.  Where does happens-before edge occur so that other 
threads don't see uninitialized values of the internals?  The only happens 
before-edges I can think of are during handoff between threads or on the 
call to Thread.start().  Is how this class conforms to the JMM or is 
something else going on?

Thanks,

Jason Mehrens



From joe.bowbeer at gmail.com  Tue May 23 14:57:37 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 23 May 2006 11:57:37 -0700
Subject: [concurrency-interest] Resetting FutureTask
In-Reply-To: <20060523172420.83769.qmail@web35703.mail.mud.yahoo.com>
References: <200605221600.k4MG0Lek029004@cs.oswego.edu>
	<20060523172420.83769.qmail@web35703.mail.mud.yahoo.com>
Message-ID: <31f2a7bd0605231157q454f54d3xbce8f15946ea7762@mail.gmail.com>

When the FutureTask completes it latches onto  a value or an
exception, and it's not designed to let go (i.e., reset).

Either your app needs to be able to deal with failures of this nature.
 Or your Callable needs to be designed not to fail -- using its own
retry mechanism, for example, or returing a special FAILURE value.
(If your value source is anything like a database, I suggest you write
your app to deal with the failures -- or timeouts, at least.)

A third approach would be to add a custom Future to the cache, create
and schedule separate FutureTask(s) to produce a value, and only set
the cached Future's value after a good value has been obtained from
one of the FutureTasks.  This approach might appear to "hang" in the
worst case.  Doug sketches the custom Future part in the FAQ he sent
recently.

--Joe

On 5/23/06, Tutika Chakravarthy <chakritsus at yahoo.com> wrote:
> Hi,
> I have a small question about the popular Memoize
> example
> code snippet:
>   public class Memoize<A, V> implements Computable<A,
> V>
> {
>      public Memoize(Computable<A, V> c) {
>          this.c = c;
>      }
>      public V compute(final A arg) throws Exception {
>          Future<V> f = cache.get(arg);
>          if (f == null) {
>              Callable<V> eval = new Callable<V>() {
>                  public V call() throws Exception {
>                      return c.compute(arg);
>                  }
>              };
>              FutureTask<V> ft = new
> FutureTask<V>(eval);
>              f = cache.putIfAbsent(arg, ft);
>              if (f == null) { f = ft; ft.run(); }
>          }
>          return f.get();
>      }
>      private final ConcurrentMap<A, Future<V>> cache =
>          new ConcurrentHashMap<A, Future<V>>();
>      private final Computable<A, V> c;
> }
>
> My questions is, if call() method in Callable instance
> throws Exception , How can I reset the FutureTask?
>
> I am trying to put some code around "f.get()" like
>
> try{
> f.get()
>
> }catch(ExecutionException e)
> {
> cache.remove(arg,f);
>
> }
>
> But will this solve the problem of reseting the
> FutureTask?
>
> If one thread gets an exception in call() method,I am
> trying to avoid other threads getting the same
> exception.
>
>
> Tutika
>


From jmanson at cs.purdue.edu  Tue May 23 15:40:55 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Tue, 23 May 2006 15:40:55 -0400
Subject: [concurrency-interest] synchronized on construction
In-Reply-To: <BAY105-F37B42FE3B32171353ED6A4839B0@phx.gbl>
References: <BAY105-F37B42FE3B32171353ED6A4839B0@phx.gbl>
Message-ID: <44736547.2050005@cs.purdue.edu>

Jason Mehrens wrote:
> Browsing over the java.util.Vector class I noticed that in the constructors, 
> the initial writes to the internal data members (non-final and non-volatile) 
> are not performed under a synchronized block.   The same is true for when a 
> Vector is deserialized.  Where does happens-before edge occur so that other 
> threads don't see uninitialized values of the internals?  The only happens 
> before-edges I can think of are during handoff between threads or on the 
> call to Thread.start().  Is how this class conforms to the JMM or is 
> something else going on?
> 

Well, bear in mind that only one thread has access to instances of these 
classes during construction.  JMM problems only come up here if you pass 
a reference to the object to another thread via a data race.  These 
classes are not designed to work correctly if you do that - only the 
immutable ones, like String, really are.

If you are using this class, it is therefore imperative to provide 
proper synchronization during a handoff.

This is one of the reasons why people have moved away from Vector and 
Hashtable -- by claiming that they are thread-safe, they make people 
stop worrying about multithreaded behavior.  However, their guarantees 
are illusory - if you examine them too closely, they melt away...

					Jeremy

From joe.bowbeer at gmail.com  Tue May 23 18:47:47 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 23 May 2006 15:47:47 -0700
Subject: [concurrency-interest] Resetting FutureTask
In-Reply-To: <31f2a7bd0605231157q454f54d3xbce8f15946ea7762@mail.gmail.com>
References: <200605221600.k4MG0Lek029004@cs.oswego.edu>
	<20060523172420.83769.qmail@web35703.mail.mud.yahoo.com>
	<31f2a7bd0605231157q454f54d3xbce8f15946ea7762@mail.gmail.com>
Message-ID: <31f2a7bd0605231547g590116d4y64febf589f866891@mail.gmail.com>

More to my answer below.

> On 5/23/06, Tutika Chakravarthy <chakritsus at yahoo.com> wrote:
> I am trying to put some code around "f.get()" like
>
> try{
>     f.get()
> } catch (ExecutionException ex) {
>     cache.remove(arg);
> }
>

This would be another approach.  I would code it more like:

  try{
      return f.get()
  } catch (ExecutionException ex) {
      cache.remove(arg);
      throw ex;
  }

In this case, the calling thread and all threads currently waiting on
this result would see an exception, but future callers would have a
chance to insert a good value in the cache.

--Joe


On 5/23/06, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> When the FutureTask completes it latches onto  a value or an
> exception, and it's not designed to let go (i.e., reset).
>
> Either your app needs to be able to deal with failures of this nature.
>  Or your Callable needs to be designed not to fail -- using its own
> retry mechanism, for example, or returing a special FAILURE value.
> (If your value source is anything like a database, I suggest you write
> your app to deal with the failures -- or timeouts, at least.)
>
> A third approach would be to add a custom Future to the cache, create
> and schedule separate FutureTask(s) to produce a value, and only set
> the cached Future's value after a good value has been obtained from
> one of the FutureTasks.  This approach might appear to "hang" in the
> worst case.  Doug sketches the custom Future part in the FAQ he sent
> recently.
>
> --Joe
>
> On 5/23/06, Tutika Chakravarthy <chakritsus at yahoo.com> wrote:
> > Hi,
> > I have a small question about the popular Memoize
> > example
> > code snippet:
> >   public class Memoize<A, V> implements Computable<A,
> > V>
> > {
> >      public Memoize(Computable<A, V> c) {
> >          this.c = c;
> >      }
> >      public V compute(final A arg) throws Exception {
> >          Future<V> f = cache.get(arg);
> >          if (f == null) {
> >              Callable<V> eval = new Callable<V>() {
> >                  public V call() throws Exception {
> >                      return c.compute(arg);
> >                  }
> >              };
> >              FutureTask<V> ft = new
> > FutureTask<V>(eval);
> >              f = cache.putIfAbsent(arg, ft);
> >              if (f == null) { f = ft; ft.run(); }
> >          }
> >          return f.get();
> >      }
> >      private final ConcurrentMap<A, Future<V>> cache =
> >          new ConcurrentHashMap<A, Future<V>>();
> >      private final Computable<A, V> c;
> > }
> >
> > My questions is, if call() method in Callable instance
> > throws Exception , How can I reset the FutureTask?
> >
> > I am trying to put some code around "f.get()" like
> >
> > try{
> > f.get()
> >
> > }catch(ExecutionException e)
> > {
> > cache.remove(arg,f);
> >
> > }
> >
> > But will this solve the problem of reseting the
> > FutureTask?
> >
> > If one thread gets an exception in call() method,I am
> > trying to avoid other threads getting the same
> > exception.
> >
> >
> > Tutika
> >
>


From yangjs at alibaba-inc.com  Tue May 23 21:52:39 2006
From: yangjs at alibaba-inc.com (yangjs)
Date: Wed, 24 May 2006 09:52:39 +0800
Subject: [concurrency-interest] about Volatile reads/writes
References: <20060523172420.83769.qmail@web35703.mail.mud.yahoo.com>
Message-ID: <02c701c67ed4$bd5a3510$4128000a@alibabahz.com>

hi,all

javaone 2006 session about The JavaT Technology Memory Model:the building block of concurrency
how to explain the follow sentence?

Volatile reads/writes cannot be reordered
Reads/writes become acquire/release pairs




thx
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060524/f0cbade0/attachment.html 

From jmanson at cs.purdue.edu  Tue May 23 22:19:53 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Tue, 23 May 2006 22:19:53 -0400
Subject: [concurrency-interest] about Volatile reads/writes
In-Reply-To: <02c701c67ed4$bd5a3510$4128000a@alibabahz.com>
References: <20060523172420.83769.qmail@web35703.mail.mud.yahoo.com>
	<02c701c67ed4$bd5a3510$4128000a@alibabahz.com>
Message-ID: <4473C2C9.1050903@cs.purdue.edu>

yangjs wrote:
> how to explain the follow sentence?
> 
> Volatile reads/writes cannot be reordered
> Reads/writes become acquire/release pairs

As the speaker for that particular slide, I hate to seem flip, but it 
means what it says.

1) Volatile accesses cannot appear to have been reordered with each 
other.  For example, let's say I have two volatile boolean fields, v1 
and v2, and the following code running in one thread:

v1 = true;
v2 = true;

And the following code running in another:

if (v2)
   assert v1;

The assertion is not allowed to fail.  If the accesses in the first 
thread were reordered, then the assertion could fail - the second thread 
could see v2 being true before it sees v1 being true.

2) A read of a volatile acts like an acquire, and a write to a volatile 
acts like a release.  There is therefore a happens-before relationship 
between a write to a volatile and a read of a volatile.  In the example 
above, this implies that the assertion can't fail even if v1 is not 
volatile, as long as v2 is volatile.

I suggest you read the JSR-133 FAQ for more information:

http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html

Especially the sections on what synchronization does and what volatile 
does.  Better still, run over to amazon.com and get yourself a copy of 
Java Concurrency in Practice.


					Jeremy

From tackline at tackline.plus.com  Wed May 24 06:31:24 2006
From: tackline at tackline.plus.com (Thomas Hawtin)
Date: Wed, 24 May 2006 11:31:24 +0100
Subject: [concurrency-interest] synchronized on construction
In-Reply-To: <44736547.2050005@cs.purdue.edu>
References: <BAY105-F37B42FE3B32171353ED6A4839B0@phx.gbl>
	<44736547.2050005@cs.purdue.edu>
Message-ID: <447435FC.90707@tackline.plus.com>

Jeremy Manson wrote:
> Jason Mehrens wrote:
>> Browsing over the java.util.Vector class I noticed that in the constructors, 
>> the initial writes to the internal data members (non-final and non-volatile) 
>> are not performed under a synchronized block.   The same is true for when a 

Under the new JMM would a synchronised block in the constructor 
guarantee to fix the problem? Does the racy write of the Vector 
reference, outside of the synchronised block, necessarily come after the 
block itself. Could it technically be moved up before the lock is 
acquired? Or am I misinterpreting something?

>> Vector is deserialized.  Where does happens-before edge occur so that other 
>> threads don't see uninitialized values of the internals?  The only happens 
>> before-edges I can think of are during handoff between threads or on the 
>> call to Thread.start().  Is how this class conforms to the JMM or is 
>> something else going on?
>>
> 
> Well, bear in mind that only one thread has access to instances of these 
> classes during construction.  JMM problems only come up here if you pass 
> a reference to the object to another thread via a data race.  These 
> classes are not designed to work correctly if you do that - only the 
> immutable ones, like String, really are.
> 
> If you are using this class, it is therefore imperative to provide 
> proper synchronization during a handoff.

Bug 6379897 deals with the thread safety of Random's seed when 
constructed lazily in Collections. It's interested to see that the fix 
for that attempts to make the use of seed thread-safe, rather than 
construct the Random safely in Collections. Presumably the details of 
that fix (setting of the seed value) require that my first paragraph is 
wrong...

http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6379897

Tom Hawtin

From Pete.Soper at Sun.COM  Wed May 24 09:43:55 2006
From: Pete.Soper at Sun.COM (Pete Soper)
Date: Wed, 24 May 2006 09:43:55 -0400
Subject: [concurrency-interest] synchronized on construction
In-Reply-To: <447435FC.90707@tackline.plus.com>
References: <BAY105-F37B42FE3B32171353ED6A4839B0@phx.gbl>
	<44736547.2050005@cs.purdue.edu> <447435FC.90707@tackline.plus.com>
Message-ID: <4474631B.7060405@Sun.COM>

Thomas Hawtin wrote:
> Jeremy Manson wrote:
> 
>>Jason Mehrens wrote:
>>
>>>Browsing over the java.util.Vector class I noticed that in the constructors, 
>>>the initial writes to the internal data members (non-final and non-volatile) 
>>>are not performed under a synchronized block.   The same is true for when a 
> 
> 
> Under the new JMM would a synchronised block in the constructor 
> guarantee to fix the problem? Does the racy write of the Vector 
> reference, outside of the synchronised block, necessarily come after the 
> block itself. Could it technically be moved up before the lock is 
> acquired? Or am I misinterpreting something?
> 
> 
>>>Vector is deserialized.  Where does happens-before edge occur so that other 
>>>threads don't see uninitialized values of the internals?  The only happens 
>>>before-edges I can think of are during handoff between threads or on the 
>>>call to Thread.start().  Is how this class conforms to the JMM or is 
>>>something else going on?
>>>
>>
>>Well, bear in mind that only one thread has access to instances of these 
>>classes during construction.  JMM problems only come up here if you pass 
>>a reference to the object to another thread via a data race.  These 
>>classes are not designed to work correctly if you do that - only the 
>>immutable ones, like String, really are.
>>
>>If you are using this class, it is therefore imperative to provide 
>>proper synchronization during a handoff.
> 
> 
> Bug 6379897 deals with the thread safety of Random's seed when 
> constructed lazily in Collections. It's interested to see that the fix 
> for that attempts to make the use of seed thread-safe, rather than 
> construct the Random safely in Collections. Presumably the details of 
> that fix (setting of the seed value) require that my first paragraph is 
> wrong...
> 
> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6379897

There is a special guarantee extended to final fields related to 
construction that the experts can explain better than me. And as far as 
I can tell there is no possibility of "this" being published before the 
constructor completes. So this (current Mustang source for) Random looks 
looks OK and I think the attempt was successful.

-Pete

> 
> Tom Hawtin
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From jmanson at cs.purdue.edu  Wed May 24 10:10:21 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Wed, 24 May 2006 10:10:21 -0400
Subject: [concurrency-interest] synchronized on construction
In-Reply-To: <447435FC.90707@tackline.plus.com>
References: <BAY105-F37B42FE3B32171353ED6A4839B0@phx.gbl>	<44736547.2050005@cs.purdue.edu>
	<447435FC.90707@tackline.plus.com>
Message-ID: <4474694D.3020907@cs.purdue.edu>

Thomas Hawtin wrote:
> Under the new JMM would a synchronised block in the constructor 
> guarantee to fix the problem? Does the racy write of the Vector 
> reference, outside of the synchronised block, necessarily come after the 
> block itself. Could it technically be moved up before the lock is 
> acquired? Or am I misinterpreting something?
> 

The system will not move the racy write up before the lock is acquired, 
although it may move it inside the synchronization block.  We have 
"Roach Motel Semantics" - you can move the write up into the 
synchronization block, but you can't move it out of that block.

The reason for this has to do with locking and happens-before, and I 
shall leave it as an exercise to the reader ;) .

I want to reiterate my previous statement.  If you are using this class, 
you have to use synchronization to ensure that the reference to the 
object gets communicated between threads *at all*.  As long as you are 
doing this, the happens-before relationship will be present, so you are 
safe.

If you don't have that synchronization in your code, then there you have 
a bug.  A data race.  Data races rot the brain and corrupt the soul.

> Bug 6379897 deals with the thread safety of Random's seed when 
> constructed lazily in Collections. It's interested to see that the fix 
> for that attempts to make the use of seed thread-safe, rather than 
> construct the Random safely in Collections. Presumably the details of 
> that fix (setting of the seed value) require that my first paragraph is 
> wrong...
> 
> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6379897

This bug discusses making the seed final, which ends up being a separate 
issue from the one in your first paragraph.  Declaring a field final 
means that the correctly constructed value will be visible to threads 
that see a reference to that object, even if you have no additional 
synchronization.  It is an excellent way to provide thread-safe 
initialization, as long as your field doesn't change.  This cannot be 
done for the fields of Vector, though, because its fields can be changed.

The final modifier is a good one in general, and, like "private", should 
be used wherever possible.  A caution: final field guarantees are only 
made to threads that do not see, via a data race, a reference to the 
object that was written in the constructor.

The bug has this comment:

> The submitter is correct (according to the Java Memory Model).
> However, we can't seem to make these bugs actually manifest in the wild.
> We would love an actual test on the Sun JDK that demonstrates the failure
> (even if only once in a million tries).

Maybe it doesn't happen on their testbed, but wait until someone makes 
that one tweak to the VM and tries to run the code on 384 processors...

					Jeremy

From SPILLAI at MAIL.NYSED.GOV  Wed May 24 11:07:14 2006
From: SPILLAI at MAIL.NYSED.GOV (Srini Pillai)
Date: Wed, 24 May 2006 11:07:14 -0400
Subject: [concurrency-interest] BackPort: Threads not under control
Message-ID: <s4743e77.085@mail.nysed.gov>

Hi all,

We are using the Concurrent package (backport) in a J2ee application
which spans several threads to connect with various other sources for
information. I was skeptical to use this package on a J2ee application
due to the popular notion that custom multithreading is not recommended
on J2ee apps. Some people convinced me that this package has more APIs
to control the Threads created. 

Now coming to the real problem, below is the block of code I use to
start the various tasks and control them...

                ExecutorService service =
Executors.newCachedThreadPool();
                List futures = service.invokeAll(tasks, 20,
TimeUnit.SECONDS);
                Iterator futuresIter = futures.iterator();
                while (futuresIter.hasNext()) {
                    Future future = (Future) futuresIter.next();
                    try {
                          searchResults = future.get();
                    } catch(CancellationException ce) {
                        log.warn("Task timed out. Exception Message: "
+ ce);
                        future.cancel(true);
                    } catch(Exception e) {
                        log.warn("Exception occurred for a task.
Exception Message: " + e);
                        future.cancel(true);
                    }
                }
            }
            service.shutdownNow();
            System.out.println("SHUTDOWN ? " + service.isShutdown());
            .....


The 'tasks' that is called in the 'service.invoke()' are a list of
Callable implementations. When a Future task is timedout, as specified
in the invoke() method, control comes back to the exception but the
actual task still executes until it is terminated. The last stmt
(System.out) shows 'true', eventhough the task keeps executing until it
is dead. From the API declaration I believe the service tries to call
interrupt on this task but is it true that it cannot guarantee that the
task will stop and that shutdown will not always cause the task to stop
? Please advice. Also let me know if I am missing something... Really
appreciate your help...

Thanks,
Srini

From joe.bowbeer at gmail.com  Wed May 24 15:17:53 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 24 May 2006 12:17:53 -0700
Subject: [concurrency-interest] BackPort: Threads not under control
In-Reply-To: <s4743e77.085@mail.nysed.gov>
References: <s4743e77.085@mail.nysed.gov>
Message-ID: <31f2a7bd0605241217k153c1e98i6f910e2423a363a7@mail.gmail.com>

Srini,

Strictly speaking, you want to call isTerminated instead of isShutdown
at the end, but I suspect it will also return true.

I suspect the source of your trouble is that the executing tasks are
not responding to interrupts.

invokeAll will cancel tardy tasks via task.cancel(true).  This will
set the task's state to cancelled and will also interrupt the task's
worker thread.  But the task's Callable/Runnable has to respond to the
interrupt (or at least the cancellation) in order for it to actually
stop.  Otherwise, if it ignores the interrupt, say, then it will run
to completion regardless.  The additional cancel(true) handling in
your code is probably wasted effort...


How to tell if a Callable is responsive to interrupts?

Check out the way the Callable<Integer> handles interrupt here:

http://java.sun.com/docs/books/tutorial/essential/threads/pool.html

    public Integer call() {
        for (int i = 0; i <= 100; i += 20) {
            //Perform some work...
            System.out.format("Worker number: %d, percent complete: %d%n",
                workerNumber, i);
            try {
                Thread.sleep((int)(Math.random() * 1000));
            } catch (InterruptedException e) {}
        }
        return(workerNumber);
    }

This is a *good* example of how *not* to respond to an interrupt :-(


To be responsive to interrupt, the task should be written as:

    public Integer call() {
        try {
            for (int i = 0; i <= 100; i += 20) {
                //Perform some work...
                System.out.format("Worker number: %d, percent complete: %d%n",
                    workerNumber, i);
                Thread.sleep((int)(Math.random() * 1000));
            }
        } catch (InterruptedException e) {}
        return(workerNumber);
    }


OR I prefer to simply declare the InterruptedException:

    public Integer call() throws InterruptedException {
        for (int i = 0; i <= 100; i += 20) {
            //Perform some work...
            System.out.format("Worker number: %d, percent complete: %d%n",
                workerNumber, i);
            Thread.sleep((int)(Math.random() * 1000));
        }
        return(workerNumber);
    }

--Joe


On 5/24/06, Srini Pillai <SPILLAI at mail.nysed.gov> wrote:
> Hi all,
>
> We are using the Concurrent package (backport) in a J2ee application
> which spans several threads to connect with various other sources for
> information. I was skeptical to use this package on a J2ee application
> due to the popular notion that custom multithreading is not recommended
> on J2ee apps. Some people convinced me that this package has more APIs
> to control the Threads created.
>
> Now coming to the real problem, below is the block of code I use to
> start the various tasks and control them...
>
>                 ExecutorService service =
> Executors.newCachedThreadPool();
>                 List futures = service.invokeAll(tasks, 20,
> TimeUnit.SECONDS);
>                 Iterator futuresIter = futures.iterator();
>                 while (futuresIter.hasNext()) {
>                     Future future = (Future) futuresIter.next();
>                     try {
>                           searchResults = future.get();
>                     } catch(CancellationException ce) {
>                         log.warn("Task timed out. Exception Message: "
> + ce);
>                         future.cancel(true);
>                     } catch(Exception e) {
>                         log.warn("Exception occurred for a task.
> Exception Message: " + e);
>                         future.cancel(true);
>                     }
>                 }
>             }
>             service.shutdownNow();
>             System.out.println("SHUTDOWN ? " + service.isShutdown());
>             .....
>
>
> The 'tasks' that is called in the 'service.invoke()' are a list of
> Callable implementations. When a Future task is timedout, as specified
> in the invoke() method, control comes back to the exception but the
> actual task still executes until it is terminated. The last stmt
> (System.out) shows 'true', eventhough the task keeps executing until it
> is dead. From the API declaration I believe the service tries to call
> interrupt on this task but is it true that it cannot guarantee that the
> task will stop and that shutdown will not always cause the task to stop
> ? Please advice. Also let me know if I am missing something... Really
> appreciate your help...
>
> Thanks,
> Srini


From tackline at tackline.plus.com  Wed May 24 15:29:28 2006
From: tackline at tackline.plus.com (Thomas Hawtin)
Date: Wed, 24 May 2006 20:29:28 +0100
Subject: [concurrency-interest] synchronized on construction
In-Reply-To: <4474694D.3020907@cs.purdue.edu>
References: <BAY105-F37B42FE3B32171353ED6A4839B0@phx.gbl>	<44736547.2050005@cs.purdue.edu>
	<447435FC.90707@tackline.plus.com> <4474694D.3020907@cs.purdue.edu>
Message-ID: <4474B418.3000905@tackline.plus.com>

Jeremy Manson wrote:
> Thomas Hawtin wrote:
>> Under the new JMM would a synchronised block in the constructor 
>> guarantee to fix the problem? Does the racy write of the Vector 
>> reference, outside of the synchronised block, necessarily come after 
>> the block itself. Could it technically be moved up before the lock is 
>> acquired? Or am I misinterpreting something?
>>
> 
> The system will not move the racy write up before the lock is acquired, 
> although it may move it inside the synchronization block.  We have 
> "Roach Motel Semantics" - you can move the write up into the 
> synchronization block, but you can't move it out of that block.
> 
> The reason for this has to do with locking and happens-before, and I 
> shall leave it as an exercise to the reader ;) .

So, in this situation, as a reader...

Suppose we have thread t that creates an object with a synchronised 
block in the constructor and thread u that uses that object under 
synchronisation.

Suppose further, for the sake of contradiction, that the lock in u 
occurs earlier in the synchronisation order than t. The read of the 
object reference in u must happen-before it uses the lock. The use of 
the lock in t must happen-before the write of the object reference. 
Therefore the read of the reference in u must happen-before the write of 
the reference in t, so will have an old value.

Is that vaguely right?

> If you don't have that synchronization in your code, then there you have 
> a bug.  A data race.  Data races rot the brain and corrupt the soul.

Yeah but my soul is already corrupt and my brain nicely folded.

> This bug discusses making the seed final, which ends up being a separate 
> issue from the one in your first paragraph.  Declaring a field final 
> means that the correctly constructed value will be visible to threads 
> that see a reference to that object, even if you have no additional 
> synchronization.  It is an excellent way to provide thread-safe 
> initialization, as long as your field doesn't change.  This cannot be 
> done for the fields of Vector, though, because its fields can be changed.

It wasn't the reference I was worried about, but the resetting of the 
seed after the final field is assigned. Even ignoring the above, it's 
still fine because the freeze happens at the end of the constructor, not 
at the assignment.

Tom Hawtin

From jmanson at cs.purdue.edu  Wed May 24 15:48:54 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Wed, 24 May 2006 15:48:54 -0400
Subject: [concurrency-interest] synchronized on construction
In-Reply-To: <4474B418.3000905@tackline.plus.com>
References: <BAY105-F37B42FE3B32171353ED6A4839B0@phx.gbl>	<44736547.2050005@cs.purdue.edu>	<447435FC.90707@tackline.plus.com>
	<4474694D.3020907@cs.purdue.edu>
	<4474B418.3000905@tackline.plus.com>
Message-ID: <4474B8A6.7090300@cs.purdue.edu>

Thomas Hawtin wrote:
> Jeremy Manson wrote:
>> The system will not move the racy write up before the lock is acquired, 
>> although it may move it inside the synchronization block.  We have 
>> "Roach Motel Semantics" - you can move the write up into the 
>> synchronization block, but you can't move it out of that block.
>>
>> The reason for this has to do with locking and happens-before, and I 
>> shall leave it as an exercise to the reader ;) .
> 
> So, in this situation, as a reader...
> 
> Suppose we have thread t that creates an object with a synchronised 
> block in the constructor and thread u that uses that object under 
> synchronisation.
> 
> Suppose further, for the sake of contradiction, that the lock in u 
> occurs earlier in the synchronisation order than t. The read of the 
> object reference in u must happen-before it uses the lock. The use of 
> the lock in t must happen-before the write of the object reference. 
> Therefore the read of the reference in u must happen-before the write of 
> the reference in t, so will have an old value.
> 
> Is that vaguely right?
> 

It is along the right lines.  The best way to think about it is to 
consider two, more generic locking regions:

Thread 1:
synchronized (o) {
   r1 = x;
   r2 = y;
}

Thread 2:
synchronized (o) {
   y = 1;
}
x = 1;

Let's say that Thread 1's synchronized block happens-before Thread 2's. 
  Then both reads in Thread 1 are guaranteed to see the value 0 (because 
the reads happen-before the write in Thread 2).

If you move the write to x _inside_ the locking region, the read will 
still not see the value 1, because the read of x will still 
happen-before the write to x.

However, if you move the write to x to _before_ the locking region, then 
the read of x might see the value 1.  Since the read of x happens-before 
the write to x, the system can't do this.

>> If you don't have that synchronization in your code, then there you have 
>> a bug.  A data race.  Data races rot the brain and corrupt the soul.
> 
> Yeah but my soul is already corrupt and my brain nicely folded.

... and I'm sure your clients appreciate when that comes out in your code!

					Jeremy

From SPILLAI at MAIL.NYSED.GOV  Wed May 24 16:54:49 2006
From: SPILLAI at MAIL.NYSED.GOV (Srini Pillai)
Date: Wed, 24 May 2006 16:54:49 -0400
Subject: [concurrency-interest] BackPort: Threads not under control
Message-ID: <s4748fe7.083@mail.nysed.gov>

Joe,

Thanks for the explaination. I found out that the task I was running
(which is an I/O operation, a socket connection) is not interrupted
properly. To respond to the interrupt call I had to place a dummy
Thread.sleep(1) in the loop that is performing the I/O to trap the
Interrupt. This throws the exception and stops the thread but I don't
like the idea of having the Thread.sleep() there... Is there a different
way to trap the interrupt ?

Thanks,
Srini

>>> "Joe Bowbeer" <joe.bowbeer at gmail.com> 5/24/2006 3:17 PM >>>
Srini,

Strictly speaking, you want to call isTerminated instead of isShutdown
at the end, but I suspect it will also return true.

I suspect the source of your trouble is that the executing tasks are
not responding to interrupts.

invokeAll will cancel tardy tasks via task.cancel(true).  This will
set the task's state to cancelled and will also interrupt the task's
worker thread.  But the task's Callable/Runnable has to respond to the
interrupt (or at least the cancellation) in order for it to actually
stop.  Otherwise, if it ignores the interrupt, say, then it will run
to completion regardless.  The additional cancel(true) handling in
your code is probably wasted effort...


How to tell if a Callable is responsive to interrupts?

Check out the way the Callable<Integer> handles interrupt here:

http://java.sun.com/docs/books/tutorial/essential/threads/pool.html 

    public Integer call() {
        for (int i = 0; i <= 100; i += 20) {
            //Perform some work...
            System.out.format("Worker number: %d, percent complete:
%d%n",
                workerNumber, i);
            try {
                Thread.sleep((int)(Math.random() * 1000));
            } catch (InterruptedException e) {}
        }
        return(workerNumber);
    }

This is a *good* example of how *not* to respond to an interrupt :-(


To be responsive to interrupt, the task should be written as:

    public Integer call() {
        try {
            for (int i = 0; i <= 100; i += 20) {
                //Perform some work...
                System.out.format("Worker number: %d, percent complete:
%d%n",
                    workerNumber, i);
                Thread.sleep((int)(Math.random() * 1000));
            }
        } catch (InterruptedException e) {}
        return(workerNumber);
    }


OR I prefer to simply declare the InterruptedException:

    public Integer call() throws InterruptedException {
        for (int i = 0; i <= 100; i += 20) {
            //Perform some work...
            System.out.format("Worker number: %d, percent complete:
%d%n",
                workerNumber, i);
            Thread.sleep((int)(Math.random() * 1000));
        }
        return(workerNumber);
    }

--Joe


On 5/24/06, Srini Pillai <SPILLAI at mail.nysed.gov> wrote:
> Hi all,
>
> We are using the Concurrent package (backport) in a J2ee application
> which spans several threads to connect with various other sources
for
> information. I was skeptical to use this package on a J2ee
application
> due to the popular notion that custom multithreading is not
recommended
> on J2ee apps. Some people convinced me that this package has more
APIs
> to control the Threads created.
>
> Now coming to the real problem, below is the block of code I use to
> start the various tasks and control them...
>
>                 ExecutorService service =
> Executors.newCachedThreadPool();
>                 List futures = service.invokeAll(tasks, 20,
> TimeUnit.SECONDS);
>                 Iterator futuresIter = futures.iterator();
>                 while (futuresIter.hasNext()) {
>                     Future future = (Future) futuresIter.next();
>                     try {
>                           searchResults = future.get();
>                     } catch(CancellationException ce) {
>                         log.warn("Task timed out. Exception Message:
"
> + ce);
>                         future.cancel(true);
>                     } catch(Exception e) {
>                         log.warn("Exception occurred for a task.
> Exception Message: " + e);
>                         future.cancel(true);
>                     }
>                 }
>             }
>             service.shutdownNow();
>             System.out.println("SHUTDOWN ? " +
service.isShutdown());
>             .....
>
>
> The 'tasks' that is called in the 'service.invoke()' are a list of
> Callable implementations. When a Future task is timedout, as
specified
> in the invoke() method, control comes back to the exception but the
> actual task still executes until it is terminated. The last stmt
> (System.out) shows 'true', eventhough the task keeps executing until
it
> is dead. From the API declaration I believe the service tries to
call
> interrupt on this task but is it true that it cannot guarantee that
the
> task will stop and that shutdown will not always cause the task to
stop
> ? Please advice. Also let me know if I am missing something...
Really
> appreciate your help...
>
> Thanks,
> Srini

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu 
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

From hanson.char at gmail.com  Wed May 24 17:07:20 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Wed, 24 May 2006 14:07:20 -0700
Subject: [concurrency-interest] HalfSync
Message-ID: <ca53c8f80605241407ob3cfbd0gec8d431ac34f2f4c@mail.gmail.com>

Consider the code:

// Only the write is synchronized, not the read
public class HalfSync {
    private volatile int count;

    public HalfSync(int count) {
        this.count = count;
    }

    public int getCount() {
        return count;
    }

    public synchronized int increment(int delta) {
        return this.count += delta;
    }
}

As far as I can tell, this code is as thread-safe as it would be the case if
both the increment() and getCount() are synchronized, but would allow higher
level of concurrency.  (Similar to CopyOnWriteArrayList).

How would HalfSync compared to AtomicInteger ?  Which one should perform
faster ?

Hanson
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060524/9e6bdd85/attachment.html 

From jmanson at cs.purdue.edu  Wed May 24 17:15:42 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Wed, 24 May 2006 17:15:42 -0400
Subject: [concurrency-interest] HalfSync
In-Reply-To: <ca53c8f80605241407ob3cfbd0gec8d431ac34f2f4c@mail.gmail.com>
References: <ca53c8f80605241407ob3cfbd0gec8d431ac34f2f4c@mail.gmail.com>
Message-ID: <4474CCFE.6020105@cs.purdue.edu>

Hanson,

This isn't as thread safe as it would be if both were synchronized. 
Consider the following program:

Initially, HalfSync hs = new HalfSync(0);

Thread 1:

while (hs.getCount() == 0) {
  // do stuff
}
System.err.println("T1 Terminates");

Thread 2:

hs.increment(1);
System.err.println("T2 Terminates");

Even if Thread 2 terminates, Thread 1 might not, because there is no 
happens-before edge from Thread 2's increment to Thread 1.  If getCount 
were synchronized, then Thread 1 would terminate if Thread 2 did.

The class would probably be a faster read than AtomicInteger, but a 
slower write (getting a lock is slower than performing a single atomic 
increment).

					Jeremy



Hanson Char wrote:
> Consider the code:
> 
> // Only the write is synchronized, not the read
> public class HalfSync {
>    private volatile int count;
> 
>    public HalfSync(int count) {
>        this.count = count;
>    }
> 
>    public int getCount() {
>        return count;
>    }
> 
>    public synchronized int increment(int delta) {
>        return this.count += delta;
>    }
> }
> 
> As far as I can tell, this code is as thread-safe as it would be the 
> case if
> both the increment() and getCount() are synchronized, but would allow 
> higher
> level of concurrency.  (Similar to CopyOnWriteArrayList).
> 
> How would HalfSync compared to AtomicInteger ?  Which one should perform
> faster ?
> 
> Hanson
> 
> 
> ------------------------------------------------------------------------
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From joe.bowbeer at gmail.com  Wed May 24 17:47:15 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 24 May 2006 14:47:15 -0700
Subject: [concurrency-interest] BackPort: Threads not under control
In-Reply-To: <s4748fe7.084@mail.nysed.gov>
References: <s4748fe7.084@mail.nysed.gov>
Message-ID: <31f2a7bd0605241447j6a7948f9tb06f7d8276a804a1@mail.gmail.com>

On 5/24/06, Srini Pillai <SPILLAI at mail.nysed.gov> wrote:
> Is there a different way to trap the interrupt?

  if (Thread.interrupted())
      throw new InterruptedException();


On 5/24/06, Srini Pillai <SPILLAI at mail.nysed.gov> wrote:
> Joe,
>
> Thanks for the explaination. I found out that the task I was running
> (which is an I/O operation, a socket connection) is not interrupted
> properly. To respond to the interrupt call I had to place a dummy
> Thread.sleep(1) in the loop that is performing the I/O to trap the
> Interrupt. This throws the exception and stops the thread but I don't
> like the idea of having the Thread.sleep() there... Is there a different
> way to trap the interrupt ?
>
> Thanks,
> Srini
>
> >>> "Joe Bowbeer" <joe.bowbeer at gmail.com> 5/24/2006 3:17 PM >>>
> Srini,
>
> Strictly speaking, you want to call isTerminated instead of isShutdown
> at the end, but I suspect it will also return true.
>
> I suspect the source of your trouble is that the executing tasks are
> not responding to interrupts.
>
> invokeAll will cancel tardy tasks via task.cancel(true).  This will
> set the task's state to cancelled and will also interrupt the task's
> worker thread.  But the task's Callable/Runnable has to respond to the
> interrupt (or at least the cancellation) in order for it to actually
> stop.  Otherwise, if it ignores the interrupt, say, then it will run
> to completion regardless.  The additional cancel(true) handling in
> your code is probably wasted effort...
>
>
> How to tell if a Callable is responsive to interrupts?
>
> Check out the way the Callable<Integer> handles interrupt here:
>
> http://java.sun.com/docs/books/tutorial/essential/threads/pool.html
>
>     public Integer call() {
>         for (int i = 0; i <= 100; i += 20) {
>             //Perform some work...
>             System.out.format("Worker number: %d, percent complete:
> %d%n",
>                 workerNumber, i);
>             try {
>                 Thread.sleep((int)(Math.random() * 1000));
>             } catch (InterruptedException e) {}
>         }
>         return(workerNumber);
>     }
>
> This is a *good* example of how *not* to respond to an interrupt :-(
>
>
> To be responsive to interrupt, the task should be written as:
>
>     public Integer call() {
>         try {
>             for (int i = 0; i <= 100; i += 20) {
>                 //Perform some work...
>                 System.out.format("Worker number: %d, percent complete:
> %d%n",
>                     workerNumber, i);
>                 Thread.sleep((int)(Math.random() * 1000));
>             }
>         } catch (InterruptedException e) {}
>         return(workerNumber);
>     }
>
>
> OR I prefer to simply declare the InterruptedException:
>
>     public Integer call() throws InterruptedException {
>         for (int i = 0; i <= 100; i += 20) {
>             //Perform some work...
>             System.out.format("Worker number: %d, percent complete:
> %d%n",
>                 workerNumber, i);
>             Thread.sleep((int)(Math.random() * 1000));
>         }
>         return(workerNumber);
>     }
>
> --Joe
>


From kielstra at ca.ibm.com  Wed May 24 17:49:41 2006
From: kielstra at ca.ibm.com (Allan Kielstra)
Date: Wed, 24 May 2006 17:49:41 -0400
Subject: [concurrency-interest] HalfSync
In-Reply-To: <ca53c8f80605241407ob3cfbd0gec8d431ac34f2f4c@mail.gmail.com>
Message-ID: <OFE83C1DEC.319EE28A-ON85257178.00772542-85257178.0077E8DB@ca.ibm.com>

It looks a lot like AtomicInteger in the sense that the read getCount, 
get) is not synchronized.

Without a Just In Time compiler (JIT) HalfSync would probably be very 
slightly faster in the uncontended case because there's no need to call 
down to Unsafe.compareAndSwap).  With a JIT, it's probably too close to 
call.  (In both cases, the incrementing thread gets a lock immediately 
using inlined code and updates "count" or "value.")

HalfSync does make an assumption:  words are written atomically by 
hardware.  That wasn't always a valid assumption.  If that assumption 
doesn't hold, you do lose the atomic nature of AtomicInteger.

Allan Kielstra
IBM Canada Lab
Phone: +1 (905) 413-3558 T/L 969-3558
kielstra at ca.ibm.com




"Hanson Char" <hanson.char at gmail.com> 
Sent by: concurrency-interest-bounces at cs.oswego.edu
24/05/2006 05:07 PM

To
concurrency-interest at cs.oswego.edu
cc

Subject
[concurrency-interest] HalfSync






Consider the code:

// Only the write is synchronized, not the read
public class HalfSync {
    private volatile int count;
 
    public HalfSync(int count) {
        this.count = count;
    }

    public int getCount() {
        return count;
    }

    public synchronized int increment(int delta) { 
        return this.count += delta;
    }
}

As far as I can tell, this code is as thread-safe as it would be the case 
if both the increment() and getCount() are synchronized, but would allow 
higher level of concurrency.  (Similar to CopyOnWriteArrayList). 

How would HalfSync compared to AtomicInteger ?  Which one should perform 
faster ?

Hanson

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060524/26a4c8cb/attachment.html 

From dcholmes at optusnet.com.au  Wed May 24 18:26:05 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Thu, 25 May 2006 08:26:05 +1000
Subject: [concurrency-interest] HalfSync
In-Reply-To: <4474CCFE.6020105@cs.purdue.edu>
Message-ID: <NFBBKALFDCPFIDBNKAPCKENFGOAA.dcholmes@optusnet.com.au>

Jeremy writes:
> This isn't as thread safe as it would be if both were synchronized.
...
> Even if Thread 2 terminates, Thread 1 might not, because there is no
> happens-before edge from Thread 2's increment to Thread 1.  If getCount
> were synchronized, then Thread 1 would terminate if Thread 2 did.

Huh? count is volatile.

> The class would probably be a faster read than AtomicInteger, but a
> slower write (getting a lock is slower than performing a single atomic
> increment).

My 2c:
 - reads: same
     both do a LD with whatever memory barrier is needed on the
     platform (which is probably none)
 - writes:
    - uncontended: close call
        AtomicInteger.get has a method call with LD and CAS plus MEMBAR
        Half-sync: CAS for synchronized, LD, ST plus MEMBAR (depends if
                   the runtime elides the redundant MEMBARS for
sync+volatile

   - contended:  Half-sync wins by avoiding ctx switches

Cheers,
David Holmes


From dcholmes at optusnet.com.au  Wed May 24 18:28:24 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Thu, 25 May 2006 08:28:24 +1000
Subject: [concurrency-interest] HalfSync
In-Reply-To: <OFE83C1DEC.319EE28A-ON85257178.00772542-85257178.0077E8DB@ca.ibm.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOENFGOAA.dcholmes@optusnet.com.au>

Allan Kielstra writes:
> HalfSync does make an assumption:  words are written atomically
> by hardware.  That wasn't always a valid assumption.  If that
> assumption doesn't hold, you do lose the atomic nature of AtomicInteger.

No, Java guarantees that reads/writes are atomic for all 32-bit values, and
all volatile values (32-bit and 64-bit).

Cheers,
David Holmes


From jmanson at cs.purdue.edu  Wed May 24 18:41:23 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Wed, 24 May 2006 18:41:23 -0400
Subject: [concurrency-interest] HalfSync
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKENFGOAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCKENFGOAA.dcholmes@optusnet.com.au>
Message-ID: <4474E113.50402@cs.purdue.edu>

David Holmes wrote:
> Jeremy writes:
>> This isn't as thread safe as it would be if both were synchronized.
> ...
>> Even if Thread 2 terminates, Thread 1 might not, because there is no
>> happens-before edge from Thread 2's increment to Thread 1.  If getCount
>> were synchronized, then Thread 1 would terminate if Thread 2 did.
> 
> Huh? count is volatile.
> 

Sorry, missed that, my bad.

					Jeremy

From dawidk at mathcs.emory.edu  Wed May 24 19:57:17 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed, 24 May 2006 19:57:17 -0400
Subject: [concurrency-interest] HalfSync
In-Reply-To: <ca53c8f80605241407ob3cfbd0gec8d431ac34f2f4c@mail.gmail.com>
References: <ca53c8f80605241407ob3cfbd0gec8d431ac34f2f4c@mail.gmail.com>
Message-ID: <4474F2DD.2070009@mathcs.emory.edu>

Hanson Char wrote:
> Consider the code:
>
> // Only the write is synchronized, not the read
> public class HalfSync {
>     private volatile int count;
>    
>     public HalfSync(int count) {
>         this.count = count;
>     }
>
>     public int getCount() {
>         return count;
>     }
>
>     public synchronized int increment(int delta) {
>         return this.count += delta;
>     }
> }
>
> As far as I can tell, this code is as thread-safe as it would be the 
> case if both the increment() and getCount() are synchronized, but 
> would allow higher level of concurrency.  (Similar to 
> CopyOnWriteArrayList).
>
> How would HalfSync compared to AtomicInteger ?  Which one should 
> perform faster ?
>

BTW. This is exactly how atomics are implemented in the backport.

Regards,
Dawid


From teknokrat at yahoo.com  Thu May 25 05:23:35 2006
From: teknokrat at yahoo.com (teknokrat)
Date: Thu, 25 May 2006 10:23:35 +0100
Subject: [concurrency-interest] static initializers and threads
Message-ID: <e53t2n$7t7$1@sea.gmane.org>

This a question on static initializers in Java. The answer may be in the 
language spec but I have not been able to find it. I have the following 
class;

static {
	// do some initialization
}

class A {

	public A(){}
}

I have two threads T1, T2 executing

A a = new A();

Assuming T1 enters the static initializer first, what happens to T2? 
Does it block waiting for the initialization to finish before being 
given a reference to a?

Should the static block be synchronized? Are there any conditions under 
which its possible to get a new object a but with the initialization 
incomplete?

thanks


From bart.jacobs at cs.kuleuven.be  Thu May 25 07:39:13 2006
From: bart.jacobs at cs.kuleuven.be (Bart Jacobs)
Date: Thu, 25 May 2006 13:39:13 +0200
Subject: [concurrency-interest] static initializers and threads
In-Reply-To: <e53t2n$7t7$1@sea.gmane.org>
References: <e53t2n$7t7$1@sea.gmane.org>
Message-ID: <44759761.2010306@cs.kuleuven.be>

The answer is in Section 12.4 of the Java Language Specification 
<http://java.sun.com/docs/books/jls/third_edition/html/execution.html#12.4>. 


In fact, T2 waits for the initialization to finish before executing the 
constructor of A.

There's no need to synchronize the static block. As you can read in 
Section 12.4, the virtual machine performs the necessary synchronization 
automatically.

The only way to get a new object of A before the completion (normal or 
abrupt) of the static initializer is if the object is created from 
within the static initializer itself (directly or indirectly), i.e. by 
the thread that is executing the static initializer. But note that this 
includes nested class initializations; for example, if the static 
initializer of A triggers initialization of some class B, which in turn 
creates an object of A, then this object creation succeeds and you get 
an object of A prior to completion of the static initializer of A. 
However, note that such a circularity could also cause a deadlock, 
specifically if some other thread is already initializing B, so this 
would be buggy code to write in any case.

(Note that the static block should of course be inside the class body.)

Bart

teknokrat wrote:
> This a question on static initializers in Java. The answer may be in the 
> language spec but I have not been able to find it. I have the following 
> class;
>
> static {
> 	// do some initialization
> }
>
> class A {
>
> 	public A(){}
> }
>
> I have two threads T1, T2 executing
>
> A a = new A();
>
> Assuming T1 enters the static initializer first, what happens to T2? 
> Does it block waiting for the initialization to finish before being 
> given a reference to a?
>
> Should the static block be synchronized? Are there any conditions under 
> which its possible to get a new object a but with the initialization 
> incomplete?
>
> thanks
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>   

Disclaimer: http://www.kuleuven.be/cwis/email_disclaimer.htm


From yechielf at gigaspaces.com  Thu May 25 09:17:36 2006
From: yechielf at gigaspaces.com (Yechiel Feffer)
Date: Thu, 25 May 2006 15:17:36 +0200
Subject: [concurrency-interest] what does the term "read" from volatile mean-
Message-ID: <D166C96F43D1D611B8E3000255A0C48C6BE96F@OFFICESRV>

only assigning/comparing it (to) other variable, or, if the volatile is an
object reference, does accessing the object via that reference a volatile
"read" too ?
 
Regrds,
Yechiel Fefer
 
 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060525/7fff8a91/attachment.html 

From teknokrat at yahoo.com  Thu May 25 08:12:05 2006
From: teknokrat at yahoo.com (teknokrat)
Date: Thu, 25 May 2006 13:12:05 +0100
Subject: [concurrency-interest] static initializers and threads
In-Reply-To: <44759761.2010306@cs.kuleuven.be>
References: <e53t2n$7t7$1@sea.gmane.org> <44759761.2010306@cs.kuleuven.be>
Message-ID: <e546ul$8v8$1@sea.gmane.org>

thanks a lot. that cleared things up.

Bart Jacobs wrote:
> The answer is in Section 12.4 of the Java Language Specification 
> <http://java.sun.com/docs/books/jls/third_edition/html/execution.html#12.4>. 
> 
> 
> In fact, T2 waits for the initialization to finish before executing the 
> constructor of A.
> 
> There's no need to synchronize the static block. As you can read in 
> Section 12.4, the virtual machine performs the necessary synchronization 
> automatically.
> 
> The only way to get a new object of A before the completion (normal or 
> abrupt) of the static initializer is if the object is created from 
> within the static initializer itself (directly or indirectly), i.e. by 
> the thread that is executing the static initializer. But note that this 
> includes nested class initializations; for example, if the static 
> initializer of A triggers initialization of some class B, which in turn 
> creates an object of A, then this object creation succeeds and you get 
> an object of A prior to completion of the static initializer of A. 
> However, note that such a circularity could also cause a deadlock, 
> specifically if some other thread is already initializing B, so this 
> would be buggy code to write in any case.
> 
> (Note that the static block should of course be inside the class body.)
> 
> Bart
> 
> teknokrat wrote:
>> This a question on static initializers in Java. The answer may be in the 
>> language spec but I have not been able to find it. I have the following 
>> class;
>>
>> static {
>> 	// do some initialization
>> }
>>
>> class A {
>>
>> 	public A(){}
>> }
>>
>> I have two threads T1, T2 executing
>>
>> A a = new A();
>>
>> Assuming T1 enters the static initializer first, what happens to T2? 
>> Does it block waiting for the initialization to finish before being 
>> given a reference to a?
>>
>> Should the static block be synchronized? Are there any conditions under 
>> which its possible to get a new object a but with the initialization 
>> incomplete?
>>
>> thanks
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at altair.cs.oswego.edu
>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>   
> 
> Disclaimer: http://www.kuleuven.be/cwis/email_disclaimer.htm


From bart.jacobs at cs.kuleuven.be  Thu May 25 08:27:16 2006
From: bart.jacobs at cs.kuleuven.be (Bart Jacobs)
Date: Thu, 25 May 2006 14:27:16 +0200
Subject: [concurrency-interest] what does the term "read" from volatile
 mean-
In-Reply-To: <D166C96F43D1D611B8E3000255A0C48C6BE96F@OFFICESRV>
References: <D166C96F43D1D611B8E3000255A0C48C6BE96F@OFFICESRV>
Message-ID: <4475A2A4.3030102@cs.kuleuven.be>

You should distinguish two things: 1) reading a value from a variable, 
and 2) using the value in an operation.

A "read" from a field (volatile or otherwise) means getting the value 
from that field. It doesn't matter what you do with that value 
afterwards. It's not the value that's volatile, it's the field from 
which you read it.

When you use a field dereference (i.e. an expression of the form o.f) as 
the right-hand side of an assignment, an operand of a comparison, or the 
target of a method call, the value is first read from the field and then 
the value is used in the assignment, comparison, or method call.

Best,-
Bart

Yechiel Feffer wrote:
> only assigning/comparing it (to) other variable, or, if the volatile is an
> object reference, does accessing the object via that reference a volatile
> "read" too ?
>  
> Regrds,
> Yechiel Fefer
>  
>  
>
>   
> ------------------------------------------------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>   

Disclaimer: http://www.kuleuven.be/cwis/email_disclaimer.htm


From josh at bloch.us  Fri May 26 00:47:34 2006
From: josh at bloch.us (Joshua Bloch)
Date: Thu, 25 May 2006 21:47:34 -0700
Subject: [concurrency-interest] static initializers and threads
In-Reply-To: <e546ul$8v8$1@sea.gmane.org>
References: <e53t2n$7t7$1@sea.gmane.org> <44759761.2010306@cs.kuleuven.be>
	<e546ul$8v8$1@sea.gmane.org>
Message-ID: <b097ac510605252147l25bf20f6ud9641e2dc0a045aa@mail.gmail.com>

Now the quiz.  What does this program print, and why?

public class Lazy {
    private static boolean initialized = false;
    static {
        Thread t = new Thread(new Runnable() {
            public void run() {
                initialized = true;
            }
        });
        t.start();
        try {
            t.join();
        } catch (InterruptedException e) {
            throw new AssertionError(e);
        }
    }
    public static void main(String[] args) {
        System.out.println(initialized);
    }
}

For the answer, see Puzzle 85 in "Java Puzzlers."


From tackline at tackline.plus.com  Fri May 26 05:29:55 2006
From: tackline at tackline.plus.com (Thomas Hawtin)
Date: Fri, 26 May 2006 10:29:55 +0100
Subject: [concurrency-interest] synchronized on construction
In-Reply-To: <4474B8A6.7090300@cs.purdue.edu>
References: <BAY105-F37B42FE3B32171353ED6A4839B0@phx.gbl>	<44736547.2050005@cs.purdue.edu>	<447435FC.90707@tackline.plus.com>
	<4474694D.3020907@cs.purdue.edu>
	<4474B418.3000905@tackline.plus.com>
	<4474B8A6.7090300@cs.purdue.edu>
Message-ID: <4476CA93.4090105@tackline.plus.com>

Jeremy Manson wrote:
> Thomas Hawtin wrote:
>> Jeremy Manson wrote:
> 
>>> If you don't have that synchronization in your code, then there you 
>>> have a bug.  A data race.  Data races rot the brain and corrupt the 
>>> soul.
>>
>> Yeah but my soul is already corrupt and my brain nicely folded.
> 
> ... and I'm sure your clients appreciate when that comes out in your code!

Clients?

As I'm sure you are aware, most normal people find it very difficult to 
interpret Chapter 17. Applying the rules directly is difficult. Roach 
motel is all well and good, but if it isn't exact, how do I know the set 
of possible things that could go wrong? As someone trying to ensure the 
absence of bugs, I don't care what a compiler can do but what it cannot.

Tom Hawtin
-- 
Unemployed English Java programmer
http://jroller.com/page/tackline/


From jmanson at cs.purdue.edu  Fri May 26 10:01:32 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Fri, 26 May 2006 10:01:32 -0400
Subject: [concurrency-interest] synchronized on construction
In-Reply-To: <4476CA93.4090105@tackline.plus.com>
References: <BAY105-F37B42FE3B32171353ED6A4839B0@phx.gbl>	<44736547.2050005@cs.purdue.edu>	<447435FC.90707@tackline.plus.com>	<4474694D.3020907@cs.purdue.edu>	<4474B418.3000905@tackline.plus.com>	<4474B8A6.7090300@cs.purdue.edu>
	<4476CA93.4090105@tackline.plus.com>
Message-ID: <44770A3C.5050004@cs.purdue.edu>

Thomas Hawtin wrote:
> Jeremy Manson wrote:
>> Thomas Hawtin wrote:
>>> Jeremy Manson wrote:
>>>> If you don't have that synchronization in your code, then there you 
>>>> have a bug.  A data race.  Data races rot the brain and corrupt the 
>>>> soul.
>>> Yeah but my soul is already corrupt and my brain nicely folded.
>> ... and I'm sure your clients appreciate when that comes out in your code!
> 
> Clients?

As in, anyone who uses code you write.  Just a little levity.


> As I'm sure you are aware, most normal people find it very difficult to 
> interpret Chapter 17. Applying the rules directly is difficult. Roach 
> motel is all well and good, but if it isn't exact, how do I know the set 
> of possible things that could go wrong? As someone trying to ensure the 
> absence of bugs, I don't care what a compiler can do but what it cannot.

I am aware of this.  Roach motel is really a rule of thumb for compiler 
writers more than for working programmers.

Working programmers should try to think about these properties in terms 
of happens-before, which is exact, and, although a little tricky, is 
actually a pretty good abstraction once you wrap your mind around it. 
In the example we were discussing, if the read happens-before the write, 
the read is guaranteed not to see the write.  Therefore, the compiler 
cannot move it to a place where the read might see it.

					Jeremy

From vranganath at sbcglobal.net  Fri May 26 15:37:47 2006
From: vranganath at sbcglobal.net (Venkatesh Prasad Ranganath)
Date: Fri, 26 May 2006 14:37:47 -0500
Subject: [concurrency-interest] static initializers and threads
In-Reply-To: <b097ac510605252147l25bf20f6ud9641e2dc0a045aa@mail.gmail.com>
References: <e53t2n$7t7$1@sea.gmane.org> <44759761.2010306@cs.kuleuven.be>
	<e546ul$8v8$1@sea.gmane.org>
	<b097ac510605252147l25bf20f6ud9641e2dc0a045aa@mail.gmail.com>
Message-ID: <1148672267.5420.11.camel@boss.dreamsoft.com>

On Thu, 2006-05-25 at 21:47 -0700, Joshua Bloch wrote:
> Now the quiz.  What does this program print, and why?
> 
> public class Lazy {
>     private static boolean initialized = false;
>     static {
>         Thread t = new Thread(new Runnable() {
>             public void run() {
>                 initialized = true;
>             }
>         });
>         t.start();
>         try {
>             t.join();
>         } catch (InterruptedException e) {
>             throw new AssertionError(e);
>         }
>     }
>     public static void main(String[] args) {
>         System.out.println(initialized);
>     }
> }
> 
> For the answer, see Puzzle 85 in "Java Puzzlers."

Due to the lexical ordering of static initializations and the
uninterrupted execution of the new thread and the join() invocation in
the static initializer will imply the program will print "true".  If the
latter conditions (any one) do not hold, then the program may print
"true" or "false".

For the sake of people who don't know the "Puzzlers", can you please
divulge the answer? :-)

--

Venkatesh Prasad Ranganath

From Pete.Soper at Sun.COM  Fri May 26 15:38:44 2006
From: Pete.Soper at Sun.COM (Pete Soper)
Date: Fri, 26 May 2006 15:38:44 -0400
Subject: [concurrency-interest] JCiP still relatively inexpensive
In-Reply-To: <4476CA93.4090105@tackline.plus.com>
References: <BAY105-F37B42FE3B32171353ED6A4839B0@phx.gbl>
	<44736547.2050005@cs.purdue.edu> <447435FC.90707@tackline.plus.com>
	<4474694D.3020907@cs.purdue.edu> <4474B418.3000905@tackline.plus.com>
	<4474B8A6.7090300@cs.purdue.edu> <4476CA93.4090105@tackline.plus.com>
Message-ID: <44775944.1060703@Sun.COM>

USD$28.34 at Amazon
This is the current deal of the year for Java programmers.

-Pete
(No direct or indirect financial connections to the authors. Just 
marveling that this price can be for real!)

From hanson.char at gmail.com  Fri May 26 16:25:31 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Fri, 26 May 2006 13:25:31 -0700
Subject: [concurrency-interest] static initializers and threads
In-Reply-To: <1148672267.5420.11.camel@boss.dreamsoft.com>
References: <e53t2n$7t7$1@sea.gmane.org> <44759761.2010306@cs.kuleuven.be>
	<e546ul$8v8$1@sea.gmane.org>
	<b097ac510605252147l25bf20f6ud9641e2dc0a045aa@mail.gmail.com>
	<1148672267.5420.11.camel@boss.dreamsoft.com>
Message-ID: <ca53c8f80605261325y92c14f6p2f1740d1292b0a2a@mail.gmail.com>

> For the sake of people who don't know the "Puzzlers", can you please
> divulge the answer? :-)

For the sake of not killing the fun, please don't.

(Venkatesh, have you tried running the code to see ?)

H

On 5/26/06, Venkatesh Prasad Ranganath <vranganath at sbcglobal.net> wrote:
> On Thu, 2006-05-25 at 21:47 -0700, Joshua Bloch wrote:
> > Now the quiz.  What does this program print, and why?
> >
> > public class Lazy {
> >     private static boolean initialized = false;
> >     static {
> >         Thread t = new Thread(new Runnable() {
> >             public void run() {
> >                 initialized = true;
> >             }
> >         });
> >         t.start();
> >         try {
> >             t.join();
> >         } catch (InterruptedException e) {
> >             throw new AssertionError(e);
> >         }
> >     }
> >     public static void main(String[] args) {
> >         System.out.println(initialized);
> >     }
> > }
> >
> > For the answer, see Puzzle 85 in "Java Puzzlers."
>
> Due to the lexical ordering of static initializations and the
> uninterrupted execution of the new thread and the join() invocation in
> the static initializer will imply the program will print "true".  If the
> latter conditions (any one) do not hold, then the program may print
> "true" or "false".
>
> For the sake of people who don't know the "Puzzlers", can you please
> divulge the answer? :-)
>
> --
>
> Venkatesh Prasad Ranganath
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From josh at bloch.us  Fri May 26 17:14:50 2006
From: josh at bloch.us (Joshua Bloch)
Date: Fri, 26 May 2006 14:14:50 -0700
Subject: [concurrency-interest] static initializers and threads
In-Reply-To: <ca53c8f80605261325y92c14f6p2f1740d1292b0a2a@mail.gmail.com>
References: <e53t2n$7t7$1@sea.gmane.org> <44759761.2010306@cs.kuleuven.be>
	<e546ul$8v8$1@sea.gmane.org>
	<b097ac510605252147l25bf20f6ud9641e2dc0a045aa@mail.gmail.com>
	<1148672267.5420.11.camel@boss.dreamsoft.com>
	<ca53c8f80605261325y92c14f6p2f1740d1292b0a2a@mail.gmail.com>
Message-ID: <b097ac510605261414p56675037q92e5a39b37406262@mail.gmail.com>

I'm gonna go with Hanson on this.  If anyone has run the program,
can't figure out why it does what it does, and asks me, I will send
them the solution, but I won't post it for a few days:)

            Josh

On 5/26/06, Hanson Char <hanson.char at gmail.com> wrote:
> > For the sake of people who don't know the "Puzzlers", can you please
> > divulge the answer? :-)
>
> For the sake of not killing the fun, please don't.
>
> (Venkatesh, have you tried running the code to see ?)
>
> H
>
> On 5/26/06, Venkatesh Prasad Ranganath <vranganath at sbcglobal.net> wrote:
> > On Thu, 2006-05-25 at 21:47 -0700, Joshua Bloch wrote:
> > > Now the quiz.  What does this program print, and why?
> > >
> > > public class Lazy {
> > >     private static boolean initialized = false;
> > >     static {
> > >         Thread t = new Thread(new Runnable() {
> > >             public void run() {
> > >                 initialized = true;
> > >             }
> > >         });
> > >         t.start();
> > >         try {
> > >             t.join();
> > >         } catch (InterruptedException e) {
> > >             throw new AssertionError(e);
> > >         }
> > >     }
> > >     public static void main(String[] args) {
> > >         System.out.println(initialized);
> > >     }
> > > }
> > >
> > > For the answer, see Puzzle 85 in "Java Puzzlers."
> >
> > Due to the lexical ordering of static initializations and the
> > uninterrupted execution of the new thread and the join() invocation in
> > the static initializer will imply the program will print "true".  If the
> > latter conditions (any one) do not hold, then the program may print
> > "true" or "false".
> >
> > For the sake of people who don't know the "Puzzlers", can you please
> > divulge the answer? :-)
> >
> > --
> >
> > Venkatesh Prasad Ranganath
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>


From dhanji at gmail.com  Fri May 26 20:27:09 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Sat, 27 May 2006 10:27:09 +1000
Subject: [concurrency-interest] static initializers and threads
In-Reply-To: <b097ac510605261414p56675037q92e5a39b37406262@mail.gmail.com>
References: <e53t2n$7t7$1@sea.gmane.org> <44759761.2010306@cs.kuleuven.be>
	<e546ul$8v8$1@sea.gmane.org>
	<b097ac510605252147l25bf20f6ud9641e2dc0a045aa@mail.gmail.com>
	<1148672267.5420.11.camel@boss.dreamsoft.com>
	<ca53c8f80605261325y92c14f6p2f1740d1292b0a2a@mail.gmail.com>
	<b097ac510605261414p56675037q92e5a39b37406262@mail.gmail.com>
Message-ID: <aa067ea10605261727x4b0b7b7hb770144a85c6422@mail.gmail.com>

Correct me if Im wrong but I think the answer is in the order of the
initializers. The doco says static blocks must complete before static
fields. So when the anonymous class thread starts, it enters run and
attempts to set initialized to true.
However initialized has not been initialized (!) yet because the
static block is still incomplete (waiting for the thread to die on
t.join()), this causes a deadlock and the program never terminates
(never even gets to main body so nothing is printed).

Btw are you withholding the solution for the pure intellectual
titillation it provides us or so a few of us will dash out to amazon
for more copeis of puzzlers, josh?

jk ;)

On 5/27/06, Joshua Bloch <josh at bloch.us> wrote:
> I'm gonna go with Hanson on this.  If anyone has run the program,
> can't figure out why it does what it does, and asks me, I will send
> them the solution, but I won't post it for a few days:)
>
>             Josh
>
> On 5/26/06, Hanson Char <hanson.char at gmail.com> wrote:
> > > For the sake of people who don't know the "Puzzlers", can you please
> > > divulge the answer? :-)
> >
> > For the sake of not killing the fun, please don't.
> >
> > (Venkatesh, have you tried running the code to see ?)
> >
> > H
> >
> > On 5/26/06, Venkatesh Prasad Ranganath <vranganath at sbcglobal.net> wrote:
> > > On Thu, 2006-05-25 at 21:47 -0700, Joshua Bloch wrote:
> > > > Now the quiz.  What does this program print, and why?
> > > >
> > > > public class Lazy {
> > > >     private static boolean initialized = false;
> > > >     static {
> > > >         Thread t = new Thread(new Runnable() {
> > > >             public void run() {
> > > >                 initialized = true;
> > > >             }
> > > >         });
> > > >         t.start();
> > > >         try {
> > > >             t.join();
> > > >         } catch (InterruptedException e) {
> > > >             throw new AssertionError(e);
> > > >         }
> > > >     }
> > > >     public static void main(String[] args) {
> > > >         System.out.println(initialized);
> > > >     }
> > > > }
> > > >
> > > > For the answer, see Puzzle 85 in "Java Puzzlers."
> > >
> > > Due to the lexical ordering of static initializations and the
> > > uninterrupted execution of the new thread and the join() invocation in
> > > the static initializer will imply the program will print "true".  If the
> > > latter conditions (any one) do not hold, then the program may print
> > > "true" or "false".
> > >
> > > For the sake of people who don't know the "Puzzlers", can you please
> > > divulge the answer? :-)
> > >
> > > --
> > >
> > > Venkatesh Prasad Ranganath
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From brian at quiotix.com  Fri May 26 20:29:31 2006
From: brian at quiotix.com (Brian Goetz)
Date: Fri, 26 May 2006 20:29:31 -0400
Subject: [concurrency-interest] JCiP still relatively inexpensive
In-Reply-To: <44775944.1060703@Sun.COM>
References: <BAY105-F37B42FE3B32171353ED6A4839B0@phx.gbl>	<44736547.2050005@cs.purdue.edu>
	<447435FC.90707@tackline.plus.com>	<4474694D.3020907@cs.purdue.edu>
	<4474B418.3000905@tackline.plus.com>	<4474B8A6.7090300@cs.purdue.edu>
	<4476CA93.4090105@tackline.plus.com> <44775944.1060703@Sun.COM>
Message-ID: <44779D6B.6090000@quiotix.com>

Its a screaming deal.  Buy ten!

Pete Soper wrote:
> USD$28.34 at Amazon
> This is the current deal of the year for Java programmers.
> 
> -Pete
> (No direct or indirect financial connections to the authors. Just 
> marveling that this price can be for real!)

From jws at cs.mu.OZ.AU  Fri May 26 20:39:33 2006
From: jws at cs.mu.OZ.AU (Jeff Schultz)
Date: Sat, 27 May 2006 10:39:33 +1000
Subject: [concurrency-interest] JCiP still relatively inexpensive
Message-ID: <8866.1148690373@blunt.localdomain>

> USD$28.34 at Amazon
> This is the current deal of the year for Java programmers.

And, it's even shipping.

> -Pete
> (No direct or indirect financial connections to the authors. Just 
> marveling that this price can be for real!)

Same.


    Jeff

From josh at bloch.us  Sat May 27 01:40:37 2006
From: josh at bloch.us (Joshua Bloch)
Date: Fri, 26 May 2006 22:40:37 -0700
Subject: [concurrency-interest] static initializers and threads
In-Reply-To: <aa067ea10605261727x4b0b7b7hb770144a85c6422@mail.gmail.com>
References: <e53t2n$7t7$1@sea.gmane.org> <44759761.2010306@cs.kuleuven.be>
	<e546ul$8v8$1@sea.gmane.org>
	<b097ac510605252147l25bf20f6ud9641e2dc0a045aa@mail.gmail.com>
	<1148672267.5420.11.camel@boss.dreamsoft.com>
	<ca53c8f80605261325y92c14f6p2f1740d1292b0a2a@mail.gmail.com>
	<b097ac510605261414p56675037q92e5a39b37406262@mail.gmail.com>
	<aa067ea10605261727x4b0b7b7hb770144a85c6422@mail.gmail.com>
Message-ID: <b097ac510605262240i7c273e34k426838b3f9e7aaef@mail.gmail.com>

Dhanji,


> Btw are you withholding the solution for the pure intellectual
> titillation it provides us or so a few of us will dash out to amazon
> for more copeis of puzzlers, josh?

Intellectual titillation, of course.  Would Click and Hack the Type-It
Brothers stoop to shameless commerce? ;)

Perhaps it is time to post the solution.  There have been a number of
partially correct replies.  The next letter from me will contain the
complete solution.  It will have ***SPOILER*** in its subject.  Don't
read it if you still want to puzzle it out.

       Josh


From josh at bloch.us  Sat May 27 01:48:27 2006
From: josh at bloch.us (Joshua Bloch)
Date: Fri, 26 May 2006 22:48:27 -0700
Subject: [concurrency-interest] static initializers and threads
	***SPOILER***
Message-ID: <b097ac510605262248x6e8bafb7s1919e4000a3e9c52@mail.gmail.com>

Here it is, copied verbatim from Java Puzzlers.  So you don't forget, order
before midnight tonight.  They're gong fast!  Etc.

Puzzle 85: Lazy Initialization

This poor little class is too lazy to initialize itself in the usual way, so
it calls on
the help of background thread. What does the program print? Is it guaranteed
to
print the same thing every time you run it?

public class Lazy {
   private static boolean initialized = false;
   static {
       Thread t = new Thread(new Runnable() {
           public void run() {
               initialized = true;
           }
       });
       t.start();
       try {
           t.join();
       } catch (InterruptedException e) {
           throw new AssertionError(e);
       }
   }
   public static void main(String[] args) {
       System.out.println(initialized);
   }
}


Solution 85: Lazy Initialization

This program looks straightforward, if a bit strange. The static field
initialized
is initially set to false. Then the main thread creates a background thread
whose
run method sets initialized to true. The main thread starts the background
thread and waits for it to complete by calling join. Once the background
thread
has completed, there can be no doubt that initialized has been set to true.
Then and only then does the main thread invoke main, which prints the value
of
initialized. Surely the program must print true? If only it were so. If you
ran
the program, you found that it prints nothing; it just hangs.

In order to understand the behavior of this program, we have to simulate its
initialization in detail. When a thread is about to access a member of a
class, the
thread checks to see if the class has been initialized. Ignoring serious
errors, there
are four possible cases [JLS 12.4.2]:

1. The class is not yet initialized.
2. The class is being initialized by the current thread: a recursive request
for initialization.
3. The class is being initialized by some thread other than the current
thread.
4. The class is already initialized.

When the main thread invokes Lazy.main, it checks whether the class Lazy
has been initialized. It hasn't (case 1), so the thread records that
initialization is
now in progress and begins to initialize the class. As per our previous
analysis, the
main thread now sets initialized to false, creates and starts a background
thread whose run method sets initialized to true, and waits for the
background
thread to complete. Then the fun begins.

The background thread invokes its run method. Before the thread sets
Lazy.initialized to true, it too checks whether the class Lazy has been
initialized.
This time, the class is currently being initialized by another thread (case
3).
Under these circumstances, the current thread, which is the background
thread,
waits on the Class object until initialization is complete. Unfortunately,
the thread
that is doing the initialization, the main thread, is waiting for the
background
thread to complete. Because the two threads are now waiting for each other,
the
program is deadlocked. That's all there is to it, and what a pity it is.

There are two ways to fix the problem. By far the best way is not to start
any
background threads during class initialization: Sometimes, two threads
aren't better
than one. More generally, keep class initialization as simple as possible. A
second way to fix the problem is to allow the main thread to finish
initializing the
class before waiting for the background thread:

// Bad way to eliminate the deadlock. Complex and error prone.
public class Lazy {
    private static boolean initialized = false;
    private static Thread t = new Thread(new Runnable() {
            public void run() {
                initialized = true;
            }
        });
    static {
        t.start();
    }
    public static void main(String[] args) {
        try {
            t.join();
        } catch (InterruptedException e) {
            throw new AssertionError(e);
        }
        System.out.println(initialized);
    }
}

Although this does eliminate the deadlock, it is a very bad idea. The main
thread waits for the background thread to finish its work, but other threads
don't
have to. They can use the class Lazy as soon as the main thread has finished
initializing
it, allowing them to observe initialized when its value is still false.

In summary, waiting for a background thread during class initialization is
likely to result in deadlock. Keep class initialization sequences as simple
as possible.
Automatic class initialization is known to be a very difficult language
design
problem, and Java's designers did a fine job in this area. Still, there are
many ways
to shoot yourself in the foot if you write complex class initialization
code.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060526/0fffe994/attachment-0001.html 

From robertlazarski at gmail.com  Sat May 27 10:28:44 2006
From: robertlazarski at gmail.com (robert lazarski)
Date: Sat, 27 May 2006 11:28:44 -0300
Subject: [concurrency-interest] Creating a Set of pings
In-Reply-To: <63b4e4050605222019m2a4e715an791533f530029464@mail.gmail.com>
References: <f87675ee0605221754o59a18d90s2cab79bef82550@mail.gmail.com>
	<63b4e4050605222019m2a4e715an791533f530029464@mail.gmail.com>
Message-ID: <f87675ee0605270728h5a9e9f33q3e0b016e6b1e24e7@mail.gmail.com>

**Tim, thanks for your very insightful help - I've learned alot. I'll be
looking for your book here in Brazil, and Joshua's too ;-) . I've also taken
Dawid's advice about doing scans and have alerted the requirement guys.

I've coded both versions you mentioned - one with two invokeAll() as you
showed, and one with two ExecutorCompletionService . I won't clutter this
post with the invokeAll() version here, but anyone who care's to see them
both in their entirety can here:

invokeAll() version:
http://www.braziloutsource.com/random/CanSnmp.java

ExecutorCompletionService version:
http://www.braziloutsource.com/random/PerfSnmpScan.java

I'm still a little concerned on performance. The invokeAll() version is
taking 32 seconds on a class C subnet (for example, 192.168.10.1 to
192.168.10.254 ) , while under the same circumstances the
ExecutorCompletionService version is taking 25 seconds. I'm running a P4
3GHZ machine with just one NIC under Suse Linux 9.3 . This is for both an
isReachable() and snmp timeout of 1 second.

The other concern I have is that isReachable() with more than 5 threads
starts throwing "java.net.ConnectException: No buffer space available" when
performing on multiple subnets - for example class A with 255.255.248.0 as
the subnet mask, I get this error after about 1000 isReachables() were
performed.

Anyways, here's what I came up with. Any suggestions highly appreciated.
Thanks!

            // autodescoberta == auto discovery

        *public* static *List*<*String*>
autodescobertaSCAN3(final *String* mascara, final
*String* ip,
            final *String* comunidadeLeitura, final
*String* comunidadeEscrita,
            final *Integer* timeout, final
*Integer* porta, final *Long* idMapa)
            *throws* FramexException, *TimeoutException* {
        *try* {
            long scanStart = *System*.currentTimeMillis();
            *ExecutorService* reachableExec = *Executors*.newFixedThreadPool
(10);
            *ExecutorService* snmpConnectExec = *Executors*.newFixedThreadPool
(5);

            *List* <*String*> ips = getValidIPs(mascara, ip);
            *List*<*InetAddress*> addrs = *new* *ArrayList*
<*InetAddress*>();
            *for* (*Iterator* iter = ips.iterator(); iter.hasNext();) {
                addrs.add(*InetAddress*.getByName((
*String*) iter.next()));
            }

            *Collection*<*Callable*<*InetAddress*>> testReachableTasks =

*new* *ArrayList*<*Callable*<*InetAddress* >>(); *for* (final
*InetAddress*addr : addrs) { testReachableTasks.
add(*new* *Callable*<*InetAddress* >() { *public* *InetAddress* call
() { *try* { *return* addr.isReachable(timeout) ? addr : *null*; } *catch* (
*Exception* ex) { ex.printStackTrace(); } *return* *null*; } }); } *//
Manages a blocking queue of testReachableTasks* *// objects, passing their
results to the Snmp connector as they become available.* *
ExecutorCompletionService* reachableService = *new* *
ExecutorCompletionService*(reachableExec); *// Manage a blocking queue of
trySnmpConnectTasks* *// objects, adding their results to the
snmpManagebleResults as they become available.*
*ExecutorCompletionService*snmpService =
*new* *ExecutorCompletionService*(snmpConnectExec); *// * *List*<*Callable*<
*InetAddress*>> trySnmpConnectTasks = *new* *ArrayList*<*Callable*<*
InetAddress* >>(); *for* (*Callable*<*InetAddress*> reachableTask :
testReachableTasks) { reachableService.submit(reachableTask); }
intsnmpTryConnects =
0; *for* (int i = 0; i < testReachableTasks.size(); i++) { *try* { final *
InetAddress* reachableAddr = (*InetAddress*) reachableService. take().get();
*// address was not reachable* *if* (reachableAddr == *null*) { *continue*;
} *// initialize the snmp connect queue* *Callable* snmpCallable = *new* *
Callable*<*InetAddress *>() { *public* *InetAddress* call() *throws* java.
lang .Exception { *// facade.getByName() throws an exception* *try* { *
return* (getSnmpFacade().getByName(reachableAddr.getHostName (), porta,
timeout, comunidadeLeitura, MibConstants.SYS_OBJECT_ID + ".0") != *null*) ?
reachableAddr : *null*; } *catch* (*TimeoutException* ex) { *// this error
is expected to happen alot* } *catch* (*Exception* ex) { ex.printStackTrace();
} *return* *null*; } }; snmpService.submit(snmpCallable); snmpTryConnects++;
} *catch* (*Exception* ex) { ex.printStackTrace(); } } *// shut down the
'reachableExec' pool after all registered tasks have completed,* *// and
prevent new tasks from being assigned* reachableExec.shutdown(); *Set*<*
String*> snmpManagebleResults = *new* *HashSet* <*String*>(); *for* (int i =
0; i < snmpTryConnects; i++) { *try* { final *InetAddress* snmpAddr = (*
InetAddress*) snmpService. take().get(); *if* (snmpAddr != *null*) {
snmpManagebleResults.add(snmpAddr.getHostAddress()); } } *catch* (*Exception
* ex) { ex.printStackTrace(); } } *// shut down the 'snmpConnectExec' pool
after all registered tasks have completed,* *// and prevent new tasks from
being assigned* snmpConnectExec.shutdown(); long scanEnd = *System*.
currentTimeMillis(); out.println("snmp scan completed!!! , Execution time
was " + (scanEnd - scanStart) / 1000 + " seconds ");
*// compare result to previous result*
 } *catch* (*Exception* ex) { ex.printStackTrace(); *throw* *new*
FramexException(ex.getMessage(), ex); } *return* *null*; }Cheers,
 Robert

On 5/23/06, Tim Peierls <tim at peierls.net> wrote:
>
> If you don't mind doing all step 1 work before all step 2/3 work, use
> ExecutorService.invokeAll on a collection of Callable<InetAddress> tasks
> that test isReachable.
>
> For each of these that succeeds, create a new Callable<InetAddress> that
> tries to connect on port 161, and pass a collection these new tasks to
> another invocation of ExecutorService.invokeAll.
>
> For each of these that succeeds, put the resulting InetAddress into a
> plain HashSet -- CopyOnWriteArrayList is for lists that are frequently read
> by different threads but rarely written to. This set need only be accessed
> by one thread, the thread that creates it and compares it to some previous
> value -- this previous value could be a thread-safe set if other threads
> need to access it.
>
> Here's an uncompiled, untested, and possibly completely wrong-headed
> sketch:
>
> ExecutorService exec = ...;
> Collection<InetAddress> addrs = ...;
>
> List<Callable<InetAddress>> testReachableTasks =
>     new ArrayList<Callable<InetAddress>>();
> for (final InetAddress addr : addrs) {
>     testReachableTasks.add(new Callable<InetAddress>() {
>         public InetAddress call() {
>             return isReachable(addr) ? addr : null;
>         }
>     });
> }
> List<Future<InetAddress>> reachables =
>     exec.invokeAll(testReachableTasks);
>
> List<Callable<InetAddress>> tryConnectTasks =
>     new ArrayList<Callable<InetAddress>>();
> for (Future<InetAddress>> reachable : reachables) {
>     // need to handle exceptions thrown by Future.get()
>     final InetAddress addr = reachable.get();
>     if (addr == null) continue;
>
>     tryConnectTasks.add(new Callable<InetAddress>() {
>         public InetAddress call() {
>             return (canConnectUdp (addr)
>                  || canConnectSnmp(addr)) ? addr : null;
>         }
>     });
> }
> List<Future<InetAddress>> connectables =
>     exec.invokeAll(tryConnectTasks);
>
> Set<InetAddress> result = new HashSet<InetAddress>();
> for (Future<InetAddress>> connectable : connectables) {
>     // need to handle exceptions thrown by Future.get()
>     InetAddress addr = connectable.get();
>     if (addr != null) result.add(addr);
> }
> // compare result to previous result
>
> If you want to start doing step 2/3 work before all step 1 work is
> complete, use 2 instances of ExecutorCompletionService, one corresponding to
> each call to invokeAll, and pull completed tasks off of one completion queue
> to insert it into the next. It's a little trickier, since you have to count
> submissions to know when you're done with a completion queue.
>
> I can't advise on how to size the pool. How many network interfaces are
> there? How many processors are there? Seems like something you'd want to be
> able to tune.
>
> --tim
>
> On 5/22/06, robert lazarski <robertlazarski at gmail.com> wrote:
>
> > Could someone please give some advice on these requirements?
>
> 1) Find all IP's on a given subnet that responds to ICMP  (ping). So for
> say 192.168.10.0 with a netmask of 255.255.255.0, attempt a ping to 255
> addresses. In java  I believe I can use InetAddress.isReachable(timeout) .
>
>
> 2) On a valid IP, try to connect on port 161 via UDP and snmp.
>
> 3) Put the valid IP's inside an implementation of java.util.Set .
>
> 4) Compare new Set with a previous Set and show updates.
>
> My questions are:
>
> 1) Perform steps 1, 2, and possibly 3 in a Callable or Runnable. On
> typical intel hardware does an ExecutorService with a size of 5 sound about
> right?
> 2) Should I pass in a Callable and get the results back 255 times, or
> should I use Runnable and have the threads write the result to a common
> area, ie, an object with a synchronized method ?
> 3) Should I use one of the concurrent collections to store the results?
> CopyOnWriteArrayList seems to fit.
>
> Thanks for any help,
> Robert
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060527/1c668929/attachment-0001.html 

From pugh at cs.umd.edu  Sat May 27 18:06:20 2006
From: pugh at cs.umd.edu (Bill Pugh)
Date: Sat, 27 May 2006 18:06:20 -0400
Subject: [concurrency-interest] AtomicReference weakCompareAndSet
	"Mayfailspuriously"?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOELDGOAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCOELDGOAA.dcholmes@optusnet.com.au>
Message-ID: <6EB77AA2-9E1D-4233-8AF4-F3AAC24F861E@cs.umd.edu>


On May 21, 2006, at 6:36 PM, David Holmes wrote:

> Bill Pugh writes:
>> I would explain this differently (actually, the JMM requires that
>> it  be explained differently):
>>
>> weakCompareAndSet has volatile semantics, _except_ that it doesn't
>> create any happens-before edges.
>
> But isn't the existence of those edges the only thing that  
> distinguishes
> volatile semantics from non-volatile (barring the 64-bit atomicity  
> issue)?

Nope. Volatile semantics also mean that it it is a synchronization  
action,
that there is a total order over synchronization actions, and that  
each volatile
read sees the value of the write to that variable that occurred most  
recently
in that total order.

Plus, the CAS happens atomically (or, for weak CAS, fails spuriously).

	Bill


>
>> So, here is the question we should discuss:
>>
>> **********
>>
>> Should weakCompareAndSet on an AtomicReference create happens
>> before  edges (just as compareAndSwap does)?
>>
>> **********
>
> For consistency I'd say no. Arguably  
> AtomicReference.weakCompareAndSet was a
> mistake and should be deprecated. But one-in all-in.
>
> We probably need to migrate the details from the package docs into the
> actual method docs.
>
> To address Cliff's problem I think the best solution is to add a
> WeakAtomicInteger class that has no volatile semantics at all. I  
> wonder
> whether the JMX implementation would benefit from using such a class?
>
> David


From pete at soper.us  Sun May 28 10:01:37 2006
From: pete at soper.us (Pete Soper)
Date: Sun, 28 May 2006 10:01:37 -0400
Subject: [concurrency-interest] AtomicReference
 weakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <6EB77AA2-9E1D-4233-8AF4-F3AAC24F861E@cs.umd.edu>
References: <NFBBKALFDCPFIDBNKAPCOELDGOAA.dcholmes@optusnet.com.au>
	<6EB77AA2-9E1D-4233-8AF4-F3AAC24F861E@cs.umd.edu>
Message-ID: <4479AD41.4000605@soper.us>

Bill Pugh wrote:
> On May 21, 2006, at 6:36 PM, David Holmes wrote:
>
>   
>> Bill Pugh writes:
>>     
>>> I would explain this differently (actually, the JMM requires that
>>> it  be explained differently):
>>>
>>> weakCompareAndSet has volatile semantics, _except_ that it doesn't
>>> create any happens-before edges.
>>>       
>> But isn't the existence of those edges the only thing that  
>> distinguishes
>> volatile semantics from non-volatile (barring the 64-bit atomicity  
>> issue)?
>>     
>
> Nope. Volatile semantics also mean that it it is a synchronization  
> action,
> that there is a total order over synchronization actions, and that  
> each volatile
> read sees the value of the write to that variable that occurred most  
> recently
> in that total order.
>
> Plus, the CAS happens atomically (or, for weak CAS, fails spuriously).
>   
So for weak CAS the write  is  sometimes visible after  read, but for 
CAS, write visible  iff read visible?

That is, given a "visible read" r and a "visible write" w, for CAS  w 
<==> r but for weak CAS it's w "sometimes after" r. That is, the 
visibility of the write of the CAS is stochastic (random), in relation 
to the read done by the CAS.

(mostly rhetorical questions)
If I understand this right then I understand your use of "fails" and I 
understand the unreliable performance counter that Cliff is yearning 
for. I guess the hard part of that API would be the spec? How do you 
specify something like this in a way that is crystal clear to all users 
or else prevents injury if they shouldn't be using it? "Use of this API 
requires certification that you understand Sipser 2nd edition section 
0.3 'finding proofs'"?  How could we (everybody trying to make Java 
better) hope to communicate about visibility of memory operations in a 
lowly piece of API javadoc? It's easy to say we'd just leave 
"happens-before" out of the weak CAS spec, but that would be like a lion 
trap with a sign on the far side that says in an obscure dialect of 
Martian "Read this before proceeding. Look down." I guess I'm yearning 
for a java.spec.philosophy list.

-Pete

PS And this clarifies something I'd been pondering lately while blowing 
some cobwebs out of my math understanding, which is whether 
happens-before is impossible if there is no before or no after. I think 
I finally "get it" and there's hope for me properly writing a 
topological sort after all. It's been 30 years since Steve Schleimer 
(Data General mentor) caused me to wrestle with those and I cried 
"uncle" then (American slang wrestling term for "I concede: you won").
PPS This list is fun!

> 	Bill
>
>
>   
>>> So, here is the question we should discuss:
>>>
>>> **********
>>>
>>> Should weakCompareAndSet on an AtomicReference create happens
>>> before  edges (just as compareAndSwap does)?
>>>
>>> **********
>>>       
>> For consistency I'd say no. Arguably  
>> AtomicReference.weakCompareAndSet was a
>> mistake and should be deprecated. But one-in all-in.
>>
>> We probably need to migrate the details from the package docs into the
>> actual method docs.
>>
>> To address Cliff's problem I think the best solution is to add a
>> WeakAtomicInteger class that has no volatile semantics at all. I  
>> wonder
>> whether the JMX implementation would benefit from using such a class?
>>
>> David
>>     
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>   


From vranganath at sbcglobal.net  Sun May 28 14:56:37 2006
From: vranganath at sbcglobal.net (Venkatesh Prasad Ranganath)
Date: Sun, 28 May 2006 13:56:37 -0500
Subject: [concurrency-interest] static initializers and threads
In-Reply-To: <ca53c8f80605261325y92c14f6p2f1740d1292b0a2a@mail.gmail.com>
References: <e53t2n$7t7$1@sea.gmane.org> <44759761.2010306@cs.kuleuven.be>
	<e546ul$8v8$1@sea.gmane.org>
	<b097ac510605252147l25bf20f6ud9641e2dc0a045aa@mail.gmail.com>
	<1148672267.5420.11.camel@boss.dreamsoft.com>
	<ca53c8f80605261325y92c14f6p2f1740d1292b0a2a@mail.gmail.com>
Message-ID: <1148842597.13531.17.camel@boss.dreamsoft.com>

On Fri, 2006-05-26 at 13:25 -0700, Hanson Char wrote:
> > For the sake of people who don't know the "Puzzlers", can you please
> > divulge the answer? :-)
> 
> For the sake of not killing the fun, please don't.
> 
> (Venkatesh, have you tried running the code to see ?)

Since it was a puzzler, I did not execute the code.  

Josh, thanks for posting the solution.  

"Puzzlers" is now on my to-read list.

 - VPR

> H
> 
> On 5/26/06, Venkatesh Prasad Ranganath <vranganath at sbcglobal.net> wrote:
> > On Thu, 2006-05-25 at 21:47 -0700, Joshua Bloch wrote:
> > > Now the quiz.  What does this program print, and why?
> > >
> > > public class Lazy {
> > >     private static boolean initialized = false;
> > >     static {
> > >         Thread t = new Thread(new Runnable() {
> > >             public void run() {
> > >                 initialized = true;
> > >             }
> > >         });
> > >         t.start();
> > >         try {
> > >             t.join();
> > >         } catch (InterruptedException e) {
> > >             throw new AssertionError(e);
> > >         }
> > >     }
> > >     public static void main(String[] args) {
> > >         System.out.println(initialized);
> > >     }
> > > }
> > >
> > > For the answer, see Puzzle 85 in "Java Puzzlers."
> >
> > Due to the lexical ordering of static initializations and the
> > uninterrupted execution of the new thread and the join() invocation in
> > the static initializer will imply the program will print "true".  If the
> > latter conditions (any one) do not hold, then the program may print
> > "true" or "false".
> >
> > For the sake of people who don't know the "Puzzlers", can you please
> > divulge the answer? :-)
> >
> > --
> >
> > Venkatesh Prasad Ranganath
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >


From josh at bloch.us  Sun May 28 15:15:27 2006
From: josh at bloch.us (Joshua Bloch)
Date: Sun, 28 May 2006 12:15:27 -0700
Subject: [concurrency-interest] static initializers and threads
In-Reply-To: <1148842597.13531.17.camel@boss.dreamsoft.com>
References: <e53t2n$7t7$1@sea.gmane.org> <44759761.2010306@cs.kuleuven.be>
	<e546ul$8v8$1@sea.gmane.org>
	<b097ac510605252147l25bf20f6ud9641e2dc0a045aa@mail.gmail.com>
	<1148672267.5420.11.camel@boss.dreamsoft.com>
	<ca53c8f80605261325y92c14f6p2f1740d1292b0a2a@mail.gmail.com>
	<1148842597.13531.17.camel@boss.dreamsoft.com>
Message-ID: <b097ac510605281215r5698b119p9bbbed6a2929ff6b@mail.gmail.com>

Venkatesh,

Great.  Enjoy the book:)

    Josh


On 5/28/06, Venkatesh Prasad Ranganath <vranganath at sbcglobal.net> wrote:
>
> On Fri, 2006-05-26 at 13:25 -0700, Hanson Char wrote:
> > > For the sake of people who don't know the "Puzzlers", can you please
> > > divulge the answer? :-)
> >
> > For the sake of not killing the fun, please don't.
> >
> > (Venkatesh, have you tried running the code to see ?)
>
> Since it was a puzzler, I did not execute the code.
>
> Josh, thanks for posting the solution.
>
> "Puzzlers" is now on my to-read list.
>
> - VPR
>
> > H
> >
> > On 5/26/06, Venkatesh Prasad Ranganath <vranganath at sbcglobal.net> wrote:
> > > On Thu, 2006-05-25 at 21:47 -0700, Joshua Bloch wrote:
> > > > Now the quiz.  What does this program print, and why?
> > > >
> > > > public class Lazy {
> > > >     private static boolean initialized = false;
> > > >     static {
> > > >         Thread t = new Thread(new Runnable() {
> > > >             public void run() {
> > > >                 initialized = true;
> > > >             }
> > > >         });
> > > >         t.start();
> > > >         try {
> > > >             t.join();
> > > >         } catch (InterruptedException e) {
> > > >             throw new AssertionError(e);
> > > >         }
> > > >     }
> > > >     public static void main(String[] args) {
> > > >         System.out.println(initialized);
> > > >     }
> > > > }
> > > >
> > > > For the answer, see Puzzle 85 in "Java Puzzlers."
> > >
> > > Due to the lexical ordering of static initializations and the
> > > uninterrupted execution of the new thread and the join() invocation in
> > > the static initializer will imply the program will print "true".  If
> the
> > > latter conditions (any one) do not hold, then the program may print
> > > "true" or "false".
> > >
> > > For the sake of people who don't know the "Puzzlers", can you please
> > > divulge the answer? :-)
> > >
> > > --
> > >
> > > Venkatesh Prasad Ranganath
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060528/6086a134/attachment.html 

From pugh at cs.umd.edu  Sun May 28 18:27:49 2006
From: pugh at cs.umd.edu (Bill Pugh)
Date: Sun, 28 May 2006 18:27:49 -0400
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <4479AD41.4000605@soper.us>
References: <NFBBKALFDCPFIDBNKAPCOELDGOAA.dcholmes@optusnet.com.au>
	<6EB77AA2-9E1D-4233-8AF4-F3AAC24F861E@cs.umd.edu>
	<4479AD41.4000605@soper.us>
Message-ID: <E869FBDD-CE0C-4974-BB7A-5A91C928F16A@cs.umd.edu>

No, here is a concrete example of the issue:

	AtomicReference<int []> r = new AtomicReference<int []>();
	
	public void thread1() {
		r.weakCompareAndSet(null, new int [] {1});
	}
	
	public int thread2() {
		int [] a = r.get();
		if (a == null) return -1;
		return a[0];
	}

If weakCompareAndSet does not create a happens-before order, then it is
possible that thread2 will return 0.

With a compareAndSet that creates a happen-before ordering, that  
would not
be possible: the initialization of the array would be ordered before
the read of a[0], and thus seeing the value 0 would be impossible.  
But without
a happens-before ordering, it would be valid to reorder the actions  
in thread 1 to:

	int [] tmp = new int[1];
	r.weakCompareAndSet(null, tmp);
	tmp[0] = 1;

thus allowing thread2 to see the value 0.

	Bill


On May 28, 2006, at 10:01 AM, Pete Soper wrote:

> Bill Pugh wrote:
>> On May 21, 2006, at 6:36 PM, David Holmes wrote:
>>
>>
>>> Bill Pugh writes:
>>>
>>>> I would explain this differently (actually, the JMM requires that
>>>> it  be explained differently):
>>>>
>>>> weakCompareAndSet has volatile semantics, _except_ that it doesn't
>>>> create any happens-before edges.
>>>>
>>> But isn't the existence of those edges the only thing that   
>>> distinguishes
>>> volatile semantics from non-volatile (barring the 64-bit  
>>> atomicity  issue)?
>>>
>>
>> Nope. Volatile semantics also mean that it it is a  
>> synchronization  action,
>> that there is a total order over synchronization actions, and  
>> that  each volatile
>> read sees the value of the write to that variable that occurred  
>> most  recently
>> in that total order.
>>
>> Plus, the CAS happens atomically (or, for weak CAS, fails  
>> spuriously).
>>
> So for weak CAS the write  is  sometimes visible after  read, but  
> for CAS, write visible  iff read visible?
>
> That is, given a "visible read" r and a "visible write" w, for CAS   
> w <==> r but for weak CAS it's w "sometimes after" r. That is, the  
> visibility of the write of the CAS is stochastic (random), in  
> relation to the read done by the CAS.
>
> (mostly rhetorical questions)
> If I understand this right then I understand your use of "fails"  
> and I understand the unreliable performance counter that Cliff is  
> yearning for. I guess the hard part of that API would be the spec?  
> How do you specify something like this in a way that is crystal  
> clear to all users or else prevents injury if they shouldn't be  
> using it? "Use of this API requires certification that you  
> understand Sipser 2nd edition section 0.3 'finding proofs'"?  How  
> could we (everybody trying to make Java better) hope to communicate  
> about visibility of memory operations in a lowly piece of API  
> javadoc? It's easy to say we'd just leave "happens-before" out of  
> the weak CAS spec, but that would be like a lion trap with a sign  
> on the far side that says in an obscure dialect of Martian "Read  
> this before proceeding. Look down." I guess I'm yearning for a  
> java.spec.philosophy list.
>
> -Pete
>
> PS And this clarifies something I'd been pondering lately while  
> blowing some cobwebs out of my math understanding, which is whether  
> happens-before is impossible if there is no before or no after. I  
> think I finally "get it" and there's hope for me properly writing a  
> topological sort after all. It's been 30 years since Steve  
> Schleimer (Data General mentor) caused me to wrestle with those and  
> I cried "uncle" then (American slang wrestling term for "I concede:  
> you won").
> PPS This list is fun!
>
>> 	Bill
>>
>>
>>
>>>> So, here is the question we should discuss:
>>>>
>>>> **********
>>>>
>>>> Should weakCompareAndSet on an AtomicReference create happens
>>>> before  edges (just as compareAndSwap does)?
>>>>
>>>> **********
>>>>
>>> For consistency I'd say no. Arguably   
>>> AtomicReference.weakCompareAndSet was a
>>> mistake and should be deprecated. But one-in all-in.
>>>
>>> We probably need to migrate the details from the package docs  
>>> into the
>>> actual method docs.
>>>
>>> To address Cliff's problem I think the best solution is to add a
>>> WeakAtomicInteger class that has no volatile semantics at all. I   
>>> wonder
>>> whether the JMX implementation would benefit from using such a  
>>> class?
>>>
>>> David
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at altair.cs.oswego.edu
>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>


From dcholmes at optusnet.com.au  Sun May 28 20:11:24 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 29 May 2006 10:11:24 +1000
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet"Mayfailspuriously"?
In-Reply-To: <6EB77AA2-9E1D-4233-8AF4-F3AAC24F861E@cs.umd.edu>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEPGGOAA.dcholmes@optusnet.com.au>

Bill,

I must be missing something.

> > But isn't the existence of those edges the only thing that
> > distinguishes
> > volatile semantics from non-volatile (barring the 64-bit atomicity
> > issue)?
>
> Nope. Volatile semantics also mean that it it is a synchronization
> action,
> that there is a total order over synchronization actions, and that
> each volatile
> read sees the value of the write to that variable that occurred most
> recently in that total order.

But isn't that all just a long-winded way of saything that it creates
happens-before edges?

Otherwise, what on earth does "creates happens-before edges" mean?

Cheers,
David


From pugh at cs.umd.edu  Sun May 28 20:50:30 2006
From: pugh at cs.umd.edu (Bill Pugh)
Date: Sun, 28 May 2006 20:50:30 -0400
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet"Mayfailspuriously"?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEPGGOAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCMEPGGOAA.dcholmes@optusnet.com.au>
Message-ID: <900594D6-7097-41A8-91A2-583C4BB42F66@cs.umd.edu>

> But isn't that all just a long-winded way of saything that it creates
> happens-before edges?

Nope.

> Otherwise, what on earth does "creates happens-before edges" mean?


Say we have:

initially, x = 0 and v = AtomicInteger(0);


Thread 1:
x = 1
while (!v.weakCompareAndSwap(0,1));

Thread 2:
while (v.get() == 0);
r1 = x

If thread 1 terminates, then because the actions on the atomic  
integer are synchronization
actions,  thread 2 is guaranteed to see the update to v and  
terminate. However, no happens-before
order is established between the weakCompareAndSwap in thread 1 and  
the get in thread 2.
Thus, we don't have a happens-before order between the write to x and  
the read of x. Thus,
this program is incorrectly synchronized and the read of x can see  
either 0 or 1.


Bill

From dcholmes at optusnet.com.au  Sun May 28 20:58:15 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 29 May 2006 10:58:15 +1000
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet"Mayfailspuriously"?
In-Reply-To: <900594D6-7097-41A8-91A2-583C4BB42F66@cs.umd.edu>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEPIGOAA.dcholmes@optusnet.com.au>

Bill,

I understand the example you gave but I don't understand how you are
describing this.

To say something has volatile semantics but doesn't create a happens-before
edge seems to me to say nothing - ie volatile without happens-before ==
empty-set.

So while I understand v.weakCompareSet only establishes ordering of v with
respect to itself, I don't see how describing it as "volatile without
happens-before" communicates anything that would convey the way it operates
to the programmer.

Cheers,
David

> -----Original Message-----
> From: Bill Pugh [mailto:pugh at cs.umd.edu]
> Sent: Monday, 29 May 2006 10:51 AM
> To: dholmes at ieee.org
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] AtomicReference
> weakCompareAndSet"Mayfailspuriously"?
>
>
> > But isn't that all just a long-winded way of saything that it creates
> > happens-before edges?
>
> Nope.
>
> > Otherwise, what on earth does "creates happens-before edges" mean?
>
>
> Say we have:
>
> initially, x = 0 and v = AtomicInteger(0);
>
>
> Thread 1:
> x = 1
> while (!v.weakCompareAndSwap(0,1));
>
> Thread 2:
> while (v.get() == 0);
> r1 = x
>
> If thread 1 terminates, then because the actions on the atomic
> integer are synchronization
> actions,  thread 2 is guaranteed to see the update to v and
> terminate. However, no happens-before
> order is established between the weakCompareAndSwap in thread 1 and
> the get in thread 2.
> Thus, we don't have a happens-before order between the write to x and
> the read of x. Thus,
> this program is incorrectly synchronized and the read of x can see
> either 0 or 1.
>
>
> Bill


From pete at soper.us  Sun May 28 21:06:25 2006
From: pete at soper.us (Pete Soper)
Date: Sun, 28 May 2006 21:06:25 -0400
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <E869FBDD-CE0C-4974-BB7A-5A91C928F16A@cs.umd.edu>
References: <NFBBKALFDCPFIDBNKAPCOELDGOAA.dcholmes@optusnet.com.au>
	<6EB77AA2-9E1D-4233-8AF4-F3AAC24F861E@cs.umd.edu>
	<4479AD41.4000605@soper.us>
	<E869FBDD-CE0C-4974-BB7A-5A91C928F16A@cs.umd.edu>
Message-ID: <447A4911.2070301@soper.us>

OK, the happens-before establishes a partial ordering and it's 
irrespective of the number of operations involved with the memory in 
question (any number of reads or writes are divided by the 
happens-before relationship). 

-Pete

Bill Pugh wrote:
> No, here is a concrete example of the issue:
>
>     AtomicReference<int []> r = new AtomicReference<int []>();
>     
>     public void thread1() {
>         r.weakCompareAndSet(null, new int [] {1});
>     }
>     
>     public int thread2() {
>         int [] a = r.get();
>         if (a == null) return -1;
>         return a[0];
>     }
>
> If weakCompareAndSet does not create a happens-before order, then it is
> possible that thread2 will return 0.
>
> With a compareAndSet that creates a happen-before ordering, that would 
> not
> be possible: the initialization of the array would be ordered before
> the read of a[0], and thus seeing the value 0 would be impossible. But 
> without
> a happens-before ordering, it would be valid to reorder the actions in 
> thread 1 to:
>
>     int [] tmp = new int[1];
>     r.weakCompareAndSet(null, tmp);
>     tmp[0] = 1;
>
> thus allowing thread2 to see the value 0.
>
>     Bill
>
>
> On May 28, 2006, at 10:01 AM, Pete Soper wrote:
>
>> Bill Pugh wrote:
>>> On May 21, 2006, at 6:36 PM, David Holmes wrote:
>>>
>>>
>>>> Bill Pugh writes:
>>>>
>>>>> I would explain this differently (actually, the JMM requires that
>>>>> it  be explained differently):
>>>>>
>>>>> weakCompareAndSet has volatile semantics, _except_ that it doesn't
>>>>> create any happens-before edges.
>>>>>
>>>> But isn't the existence of those edges the only thing that  
>>>> distinguishes
>>>> volatile semantics from non-volatile (barring the 64-bit atomicity  
>>>> issue)?
>>>>
>>>
>>> Nope. Volatile semantics also mean that it it is a synchronization  
>>> action,
>>> that there is a total order over synchronization actions, and that  
>>> each volatile
>>> read sees the value of the write to that variable that occurred 
>>> most  recently
>>> in that total order.
>>>
>>> Plus, the CAS happens atomically (or, for weak CAS, fails spuriously).
>>>
>> So for weak CAS the write  is  sometimes visible after  read, but for 
>> CAS, write visible  iff read visible?
>>
>> That is, given a "visible read" r and a "visible write" w, for CAS  w 
>> <==> r but for weak CAS it's w "sometimes after" r. That is, the 
>> visibility of the write of the CAS is stochastic (random), in 
>> relation to the read done by the CAS.
>>
>> (mostly rhetorical questions)
>> If I understand this right then I understand your use of "fails" and 
>> I understand the unreliable performance counter that Cliff is 
>> yearning for. I guess the hard part of that API would be the spec? 
>> How do you specify something like this in a way that is crystal clear 
>> to all users or else prevents injury if they shouldn't be using it? 
>> "Use of this API requires certification that you understand Sipser 
>> 2nd edition section 0.3 'finding proofs'"?  How could we (everybody 
>> trying to make Java better) hope to communicate about visibility of 
>> memory operations in a lowly piece of API javadoc? It's easy to say 
>> we'd just leave "happens-before" out of the weak CAS spec, but that 
>> would be like a lion trap with a sign on the far side that says in an 
>> obscure dialect of Martian "Read this before proceeding. Look down." 
>> I guess I'm yearning for a java.spec.philosophy list.
>>
>> -Pete
>>
>> PS And this clarifies something I'd been pondering lately while 
>> blowing some cobwebs out of my math understanding, which is whether 
>> happens-before is impossible if there is no before or no after. I 
>> think I finally "get it" and there's hope for me properly writing a 
>> topological sort after all. It's been 30 years since Steve Schleimer 
>> (Data General mentor) caused me to wrestle with those and I cried 
>> "uncle" then (American slang wrestling term for "I concede: you won").
>> PPS This list is fun!
>>
>>>     Bill
>>>
>>>
>>>
>>>>> So, here is the question we should discuss:
>>>>>
>>>>> **********
>>>>>
>>>>> Should weakCompareAndSet on an AtomicReference create happens
>>>>> before  edges (just as compareAndSwap does)?
>>>>>
>>>>> **********
>>>>>
>>>> For consistency I'd say no. Arguably  
>>>> AtomicReference.weakCompareAndSet was a
>>>> mistake and should be deprecated. But one-in all-in.
>>>>
>>>> We probably need to migrate the details from the package docs into the
>>>> actual method docs.
>>>>
>>>> To address Cliff's problem I think the best solution is to add a
>>>> WeakAtomicInteger class that has no volatile semantics at all. I  
>>>> wonder
>>>> whether the JMX implementation would benefit from using such a class?
>>>>
>>>> David
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at altair.cs.oswego.edu
>>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>
>


From giuliano.mega at gmail.com  Sun May 28 22:07:36 2006
From: giuliano.mega at gmail.com (Giuliano Mega)
Date: Sun, 28 May 2006 23:07:36 -0300
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet"Mayfailspuriously"?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEPIGOAA.dcholmes@optusnet.com.au>
References: <900594D6-7097-41A8-91A2-583C4BB42F66@cs.umd.edu>
	<NFBBKALFDCPFIDBNKAPCCEPIGOAA.dcholmes@optusnet.com.au>
Message-ID: <7547a9ff0605281907v523c3e59r367912905f6cd560@mail.gmail.com>

I am utterly confused, as always. :-)
weakCompareAndSet does force a memory barrier to happen, right? The
issue is just with reordering within a single thread?

On 5/28/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> Bill,
>
> I understand the example you gave but I don't understand how you are
> describing this.
>
> To say something has volatile semantics but doesn't create a happens-before
> edge seems to me to say nothing - ie volatile without happens-before ==
> empty-set.
>
> So while I understand v.weakCompareSet only establishes ordering of v with
> respect to itself, I don't see how describing it as "volatile without
> happens-before" communicates anything that would convey the way it operates
> to the programmer.
>
> Cheers,
> David
>
> > -----Original Message-----
> > From: Bill Pugh [mailto:pugh at cs.umd.edu]
> > Sent: Monday, 29 May 2006 10:51 AM
> > To: dholmes at ieee.org
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] AtomicReference
> > weakCompareAndSet"Mayfailspuriously"?
> >
> >
> > > But isn't that all just a long-winded way of saything that it creates
> > > happens-before edges?
> >
> > Nope.
> >
> > > Otherwise, what on earth does "creates happens-before edges" mean?
> >
> >
> > Say we have:
> >
> > initially, x = 0 and v = AtomicInteger(0);
> >
> >
> > Thread 1:
> > x = 1
> > while (!v.weakCompareAndSwap(0,1));
> >
> > Thread 2:
> > while (v.get() == 0);
> > r1 = x
> >
> > If thread 1 terminates, then because the actions on the atomic
> > integer are synchronization
> > actions,  thread 2 is guaranteed to see the update to v and
> > terminate. However, no happens-before
> > order is established between the weakCompareAndSwap in thread 1 and
> > the get in thread 2.
> > Thus, we don't have a happens-before order between the write to x and
> > the read of x. Thus,
> > this program is incorrectly synchronized and the read of x can see
> > either 0 or 1.
> >
> >
> > Bill
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
Giuliano Mega <giuliano at ime.usp.br>

From dcholmes at optusnet.com.au  Sun May 28 22:10:21 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 29 May 2006 12:10:21 +1000
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet"Mayfailspuriously"?
In-Reply-To: <7547a9ff0605281907v523c3e59r367912905f6cd560@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEPJGOAA.dcholmes@optusnet.com.au>

No, weakCompareAndSet does not force a "memory barrier" to happen.

The "issue" as now being discussed is how to describe weakCompareAndSets
lack of memory synchronization effects.

Cheers,
David Holmes

> -----Original Message-----
> From: Giuliano Mega [mailto:giuliano.mega at gmail.com]
> Sent: Monday, 29 May 2006 12:08 PM
> To: dholmes at ieee.org
> Cc: Bill Pugh; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] AtomicReference
> weakCompareAndSet"Mayfailspuriously"?
>
>
> I am utterly confused, as always. :-)
> weakCompareAndSet does force a memory barrier to happen, right? The
> issue is just with reordering within a single thread?
>
> On 5/28/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > Bill,
> >
> > I understand the example you gave but I don't understand how you are
> > describing this.
> >
> > To say something has volatile semantics but doesn't create a
> happens-before
> > edge seems to me to say nothing - ie volatile without happens-before ==
> > empty-set.
> >
> > So while I understand v.weakCompareSet only establishes
> ordering of v with
> > respect to itself, I don't see how describing it as "volatile without
> > happens-before" communicates anything that would convey the way
> it operates
> > to the programmer.
> >
> > Cheers,
> > David
> >
> > > -----Original Message-----
> > > From: Bill Pugh [mailto:pugh at cs.umd.edu]
> > > Sent: Monday, 29 May 2006 10:51 AM
> > > To: dholmes at ieee.org
> > > Cc: concurrency-interest at cs.oswego.edu
> > > Subject: Re: [concurrency-interest] AtomicReference
> > > weakCompareAndSet"Mayfailspuriously"?
> > >
> > >
> > > > But isn't that all just a long-winded way of saything that
> it creates
> > > > happens-before edges?
> > >
> > > Nope.
> > >
> > > > Otherwise, what on earth does "creates happens-before edges" mean?
> > >
> > >
> > > Say we have:
> > >
> > > initially, x = 0 and v = AtomicInteger(0);
> > >
> > >
> > > Thread 1:
> > > x = 1
> > > while (!v.weakCompareAndSwap(0,1));
> > >
> > > Thread 2:
> > > while (v.get() == 0);
> > > r1 = x
> > >
> > > If thread 1 terminates, then because the actions on the atomic
> > > integer are synchronization
> > > actions,  thread 2 is guaranteed to see the update to v and
> > > terminate. However, no happens-before
> > > order is established between the weakCompareAndSwap in thread 1 and
> > > the get in thread 2.
> > > Thus, we don't have a happens-before order between the write to x and
> > > the read of x. Thus,
> > > this program is incorrectly synchronized and the read of x can see
> > > either 0 or 1.
> > >
> > >
> > > Bill
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> --
> Giuliano Mega <giuliano at ime.usp.br>


From pete at soper.us  Sun May 28 22:46:45 2006
From: pete at soper.us (Pete Soper)
Date: Sun, 28 May 2006 22:46:45 -0400
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <E869FBDD-CE0C-4974-BB7A-5A91C928F16A@cs.umd.edu>
References: <NFBBKALFDCPFIDBNKAPCOELDGOAA.dcholmes@optusnet.com.au>
	<6EB77AA2-9E1D-4233-8AF4-F3AAC24F861E@cs.umd.edu>
	<4479AD41.4000605@soper.us>
	<E869FBDD-CE0C-4974-BB7A-5A91C928F16A@cs.umd.edu>
Message-ID: <447A6095.1020604@soper.us>

Ah. The original question brought a reference to the atomic package doc, 
which explains that "spurious failure" means a failure without apparent 
reason. This scenario below is an example of a reason that might not be 
apparent.  And Cliff is arguing the value of the weak CAS, and weak == 
not atomic. If the CAS isn't atomic then it's wide open to data races. 
Surely "data race" would give more of a clue where "spurious" does not?

The race is between the write of int[] and int[]{1} but it's enabled by 
the lack of atomicity of the CAS.

I'm ready for the visible VM. Just turn the crank very, very slowly and 
all will be revealed. So in this case the surprising/not 
apparent/spurious/data race order is "read null, write int[], read 
int[], write int[]{1}".

-Pete

Bill Pugh wrote:
> No, here is a concrete example of the issue:
>
>     AtomicReference<int []> r = new AtomicReference<int []>();
>     
>     public void thread1() {
>         r.weakCompareAndSet(null, new int [] {1});
>     }
>     
>     public int thread2() {
>         int [] a = r.get();
>         if (a == null) return -1;
>         return a[0];
>     }
>
> If weakCompareAndSet does not create a happens-before order, then it is
> possible that thread2 will return 0.
>
> With a compareAndSet that creates a happen-before ordering, that would 
> not
> be possible: the initialization of the array would be ordered before
> the read of a[0], and thus seeing the value 0 would be impossible. But 
> without
> a happens-before ordering, it would be valid to reorder the actions in 
> thread 1 to:
>
>     int [] tmp = new int[1];
>     r.weakCompareAndSet(null, tmp);
>     tmp[0] = 1;
>
> thus allowing thread2 to see the value 0.
>
>     Bill
>
>
> On May 28, 2006, at 10:01 AM, Pete Soper wrote:
>
>> Bill Pugh wrote:
>>> On May 21, 2006, at 6:36 PM, David Holmes wrote:
>>>
>>>
>>>> Bill Pugh writes:
>>>>
>>>>> I would explain this differently (actually, the JMM requires that
>>>>> it  be explained differently):
>>>>>
>>>>> weakCompareAndSet has volatile semantics, _except_ that it doesn't
>>>>> create any happens-before edges.
>>>>>
>>>> But isn't the existence of those edges the only thing that  
>>>> distinguishes
>>>> volatile semantics from non-volatile (barring the 64-bit atomicity  
>>>> issue)?
>>>>
>>>
>>> Nope. Volatile semantics also mean that it it is a synchronization  
>>> action,
>>> that there is a total order over synchronization actions, and that  
>>> each volatile
>>> read sees the value of the write to that variable that occurred 
>>> most  recently
>>> in that total order.
>>>
>>> Plus, the CAS happens atomically (or, for weak CAS, fails spuriously).
>>>
>> So for weak CAS the write  is  sometimes visible after  read, but for 
>> CAS, write visible  iff read visible?
>>
>> That is, given a "visible read" r and a "visible write" w, for CAS  w 
>> <==> r but for weak CAS it's w "sometimes after" r. That is, the 
>> visibility of the write of the CAS is stochastic (random), in 
>> relation to the read done by the CAS.
>>
>> (mostly rhetorical questions)
>> If I understand this right then I understand your use of "fails" and 
>> I understand the unreliable performance counter that Cliff is 
>> yearning for. I guess the hard part of that API would be the spec? 
>> How do you specify something like this in a way that is crystal clear 
>> to all users or else prevents injury if they shouldn't be using it? 
>> "Use of this API requires certification that you understand Sipser 
>> 2nd edition section 0.3 'finding proofs'"?  How could we (everybody 
>> trying to make Java better) hope to communicate about visibility of 
>> memory operations in a lowly piece of API javadoc? It's easy to say 
>> we'd just leave "happens-before" out of the weak CAS spec, but that 
>> would be like a lion trap with a sign on the far side that says in an 
>> obscure dialect of Martian "Read this before proceeding. Look down." 
>> I guess I'm yearning for a java.spec.philosophy list.
>>
>> -Pete
>>
>> PS And this clarifies something I'd been pondering lately while 
>> blowing some cobwebs out of my math understanding, which is whether 
>> happens-before is impossible if there is no before or no after. I 
>> think I finally "get it" and there's hope for me properly writing a 
>> topological sort after all. It's been 30 years since Steve Schleimer 
>> (Data General mentor) caused me to wrestle with those and I cried 
>> "uncle" then (American slang wrestling term for "I concede: you won").
>> PPS This list is fun!
>>
>>>     Bill
>>>
>>>
>>>
>>>>> So, here is the question we should discuss:
>>>>>
>>>>> **********
>>>>>
>>>>> Should weakCompareAndSet on an AtomicReference create happens
>>>>> before  edges (just as compareAndSwap does)?
>>>>>
>>>>> **********
>>>>>
>>>> For consistency I'd say no. Arguably  
>>>> AtomicReference.weakCompareAndSet was a
>>>> mistake and should be deprecated. But one-in all-in.
>>>>
>>>> We probably need to migrate the details from the package docs into the
>>>> actual method docs.
>>>>
>>>> To address Cliff's problem I think the best solution is to add a
>>>> WeakAtomicInteger class that has no volatile semantics at all. I  
>>>> wonder
>>>> whether the JMX implementation would benefit from using such a class?
>>>>
>>>> David
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at altair.cs.oswego.edu
>>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>
>


From dcholmes at optusnet.com.au  Sun May 28 23:01:36 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 29 May 2006 13:01:36 +1000
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <447A6095.1020604@soper.us>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>

I think confusion is spreading.

The original question regarding what "may fail spuriously" means was
answered  a while back: it means that weakCAS can fail for reasons other
than the current value not being the expected value. This has nothing to do
with being atomic or volatile, it has to do with how LL/SC works. See old
mail for details.

The weakCAS further does not have the volatile semantics that atomics
otherwise have. This means, as Bill has been describing, that a successful
weakCAS doesn't mean you will see the most recent values of other variables
(where a strong CAS would guarantee that).

What Cliff wants is an atomic integer for use with counters that is not
volatile, so that the extra memory barriers required for violatile semantics
can be elided. This gives rise to a large performance boost in the context
Cliff wants to use it - performance counters. Cliff can use weakCAS for this
purpose.

Bill proposed a way of describing the  non-volatile-ness of weakCAS, in a
way that I disagree with and have subsequently been discussing.

The "atomicity" of the weakCAS is not at issue - it is atomic. It is the
lack of memory barriers (ie volatile happens-before semantics) that means
that the weakCASing of the array reference does not guarantee you will see
the correct array elements.

Hope that clarifies things.

Cheers,
David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Pete
> Soper
> Sent: Monday, 29 May 2006 12:47 PM
> To: Bill Pugh
> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> Subject: Re: [concurrency-interest] AtomicReferenceweakCompareAndSet
> "Mayfailspuriously"?
>
>
> Ah. The original question brought a reference to the atomic package doc,
> which explains that "spurious failure" means a failure without apparent
> reason. This scenario below is an example of a reason that might not be
> apparent.  And Cliff is arguing the value of the weak CAS, and weak ==
> not atomic. If the CAS isn't atomic then it's wide open to data races.
> Surely "data race" would give more of a clue where "spurious" does not?
>
> The race is between the write of int[] and int[]{1} but it's enabled by
> the lack of atomicity of the CAS.
>
> I'm ready for the visible VM. Just turn the crank very, very slowly and
> all will be revealed. So in this case the surprising/not
> apparent/spurious/data race order is "read null, write int[], read
> int[], write int[]{1}".
>
> -Pete
>
> Bill Pugh wrote:
> > No, here is a concrete example of the issue:
> >
> >     AtomicReference<int []> r = new AtomicReference<int []>();
> >
> >     public void thread1() {
> >         r.weakCompareAndSet(null, new int [] {1});
> >     }
> >
> >     public int thread2() {
> >         int [] a = r.get();
> >         if (a == null) return -1;
> >         return a[0];
> >     }
> >
> > If weakCompareAndSet does not create a happens-before order, then it is
> > possible that thread2 will return 0.
> >
> > With a compareAndSet that creates a happen-before ordering, that would
> > not
> > be possible: the initialization of the array would be ordered before
> > the read of a[0], and thus seeing the value 0 would be impossible. But
> > without
> > a happens-before ordering, it would be valid to reorder the actions in
> > thread 1 to:
> >
> >     int [] tmp = new int[1];
> >     r.weakCompareAndSet(null, tmp);
> >     tmp[0] = 1;
> >
> > thus allowing thread2 to see the value 0.
> >
> >     Bill
> >
> >
> > On May 28, 2006, at 10:01 AM, Pete Soper wrote:
> >
> >> Bill Pugh wrote:
> >>> On May 21, 2006, at 6:36 PM, David Holmes wrote:
> >>>
> >>>
> >>>> Bill Pugh writes:
> >>>>
> >>>>> I would explain this differently (actually, the JMM requires that
> >>>>> it  be explained differently):
> >>>>>
> >>>>> weakCompareAndSet has volatile semantics, _except_ that it doesn't
> >>>>> create any happens-before edges.
> >>>>>
> >>>> But isn't the existence of those edges the only thing that
> >>>> distinguishes
> >>>> volatile semantics from non-volatile (barring the 64-bit atomicity
> >>>> issue)?
> >>>>
> >>>
> >>> Nope. Volatile semantics also mean that it it is a synchronization
> >>> action,
> >>> that there is a total order over synchronization actions, and that
> >>> each volatile
> >>> read sees the value of the write to that variable that occurred
> >>> most  recently
> >>> in that total order.
> >>>
> >>> Plus, the CAS happens atomically (or, for weak CAS, fails spuriously).
> >>>
> >> So for weak CAS the write  is  sometimes visible after  read, but for
> >> CAS, write visible  iff read visible?
> >>
> >> That is, given a "visible read" r and a "visible write" w, for CAS  w
> >> <==> r but for weak CAS it's w "sometimes after" r. That is, the
> >> visibility of the write of the CAS is stochastic (random), in
> >> relation to the read done by the CAS.
> >>
> >> (mostly rhetorical questions)
> >> If I understand this right then I understand your use of "fails" and
> >> I understand the unreliable performance counter that Cliff is
> >> yearning for. I guess the hard part of that API would be the spec?
> >> How do you specify something like this in a way that is crystal clear
> >> to all users or else prevents injury if they shouldn't be using it?
> >> "Use of this API requires certification that you understand Sipser
> >> 2nd edition section 0.3 'finding proofs'"?  How could we (everybody
> >> trying to make Java better) hope to communicate about visibility of
> >> memory operations in a lowly piece of API javadoc? It's easy to say
> >> we'd just leave "happens-before" out of the weak CAS spec, but that
> >> would be like a lion trap with a sign on the far side that says in an
> >> obscure dialect of Martian "Read this before proceeding. Look down."
> >> I guess I'm yearning for a java.spec.philosophy list.
> >>
> >> -Pete
> >>
> >> PS And this clarifies something I'd been pondering lately while
> >> blowing some cobwebs out of my math understanding, which is whether
> >> happens-before is impossible if there is no before or no after. I
> >> think I finally "get it" and there's hope for me properly writing a
> >> topological sort after all. It's been 30 years since Steve Schleimer
> >> (Data General mentor) caused me to wrestle with those and I cried
> >> "uncle" then (American slang wrestling term for "I concede: you won").
> >> PPS This list is fun!
> >>
> >>>     Bill
> >>>
> >>>
> >>>
> >>>>> So, here is the question we should discuss:
> >>>>>
> >>>>> **********
> >>>>>
> >>>>> Should weakCompareAndSet on an AtomicReference create happens
> >>>>> before  edges (just as compareAndSwap does)?
> >>>>>
> >>>>> **********
> >>>>>
> >>>> For consistency I'd say no. Arguably
> >>>> AtomicReference.weakCompareAndSet was a
> >>>> mistake and should be deprecated. But one-in all-in.
> >>>>
> >>>> We probably need to migrate the details from the package
> docs into the
> >>>> actual method docs.
> >>>>
> >>>> To address Cliff's problem I think the best solution is to add a
> >>>> WeakAtomicInteger class that has no volatile semantics at all. I
> >>>> wonder
> >>>> whether the JMX implementation would benefit from using such a class?
> >>>>
> >>>> David
> >>>>
> >>>
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at altair.cs.oswego.edu
> >>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>
> >>>
> >
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From crazybob at crazybob.org  Sun May 28 23:08:18 2006
From: crazybob at crazybob.org (Bob Lee)
Date: Sun, 28 May 2006 20:08:18 -0700
Subject: [concurrency-interest] AtomicReference weakCompareAndSet
	"Mayfailspuriously"?
In-Reply-To: <447A6095.1020604@soper.us>
References: <NFBBKALFDCPFIDBNKAPCOELDGOAA.dcholmes@optusnet.com.au>
	<6EB77AA2-9E1D-4233-8AF4-F3AAC24F861E@cs.umd.edu>
	<4479AD41.4000605@soper.us>
	<E869FBDD-CE0C-4974-BB7A-5A91C928F16A@cs.umd.edu>
	<447A6095.1020604@soper.us>
Message-ID: <a74683f90605282008g70c8cc78jbca2c807fcfe347@mail.gmail.com>

On 5/28/06, Pete Soper <pete at soper.us> wrote:
> The race is between the write of int[] and int[]{1} but it's enabled by
> the lack of atomicity of the CAS.

The CAS itself is atomic, right? The problem now is with the int[]
which is exposed to two threads with no barrier. If we were doing a
weak CAS of an int, this wouldn't be an issue, right?

Bob


From crazybob at crazybob.org  Sun May 28 23:10:36 2006
From: crazybob at crazybob.org (Bob Lee)
Date: Sun, 28 May 2006 20:10:36 -0700
Subject: [concurrency-interest] AtomicReference weakCompareAndSet
	"Mayfailspuriously"?
In-Reply-To: <a74683f90605282008g70c8cc78jbca2c807fcfe347@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCOELDGOAA.dcholmes@optusnet.com.au>
	<6EB77AA2-9E1D-4233-8AF4-F3AAC24F861E@cs.umd.edu>
	<4479AD41.4000605@soper.us>
	<E869FBDD-CE0C-4974-BB7A-5A91C928F16A@cs.umd.edu>
	<447A6095.1020604@soper.us>
	<a74683f90605282008g70c8cc78jbca2c807fcfe347@mail.gmail.com>
Message-ID: <a74683f90605282010u12519400l18246a1c519ba5e4@mail.gmail.com>

Oops. David answered my question. ;)

Bob

On 5/28/06, Bob Lee <crazybob at crazybob.org> wrote:
> On 5/28/06, Pete Soper <pete at soper.us> wrote:
> > The race is between the write of int[] and int[]{1} but it's enabled by
> > the lack of atomicity of the CAS.
>
> The CAS itself is atomic, right? The problem now is with the int[]
> which is exposed to two threads with no barrier. If we were doing a
> weak CAS of an int, this wouldn't be an issue, right?
>
> Bob
>


From pete at soper.us  Sun May 28 23:24:28 2006
From: pete at soper.us (Pete Soper)
Date: Sun, 28 May 2006 23:24:28 -0400
Subject: [concurrency-interest] AtomicReference weakCompareAndSet
	"Mayfailspuriously"?
In-Reply-To: <a74683f90605282008g70c8cc78jbca2c807fcfe347@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCOELDGOAA.dcholmes@optusnet.com.au>	
	<6EB77AA2-9E1D-4233-8AF4-F3AAC24F861E@cs.umd.edu>	
	<4479AD41.4000605@soper.us>	
	<E869FBDD-CE0C-4974-BB7A-5A91C928F16A@cs.umd.edu>	
	<447A6095.1020604@soper.us>
	<a74683f90605282008g70c8cc78jbca2c807fcfe347@mail.gmail.com>
Message-ID: <447A696C.40805@soper.us>

Bob Lee wrote:
> On 5/28/06, Pete Soper <pete at soper.us> wrote:
>> The race is between the write of int[] and int[]{1} but it's enabled by
>> the lack of atomicity of the CAS.
>
> The CAS itself is atomic, right? The problem now is with the int[]
> which is exposed to two threads with no barrier. If we were doing a
> weak CAS of an int, this wouldn't be an issue, right?

Yes! OK, I see both the atomicity and the data race now.
>
> Bob
>


From giuliano.mega at gmail.com  Sun May 28 23:27:37 2006
From: giuliano.mega at gmail.com (Giuliano Mega)
Date: Mon, 29 May 2006 00:27:37 -0300
Subject: [concurrency-interest] AtomicReference weakCompareAndSet
	"Mayfailspuriously"?
In-Reply-To: <a74683f90605282008g70c8cc78jbca2c807fcfe347@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCOELDGOAA.dcholmes@optusnet.com.au>
	<6EB77AA2-9E1D-4233-8AF4-F3AAC24F861E@cs.umd.edu>
	<4479AD41.4000605@soper.us>
	<E869FBDD-CE0C-4974-BB7A-5A91C928F16A@cs.umd.edu>
	<447A6095.1020604@soper.us>
	<a74683f90605282008g70c8cc78jbca2c807fcfe347@mail.gmail.com>
Message-ID: <7547a9ff0605282027t65998d14vf634f9728e38783f@mail.gmail.com>

That's what I was trying to ask. :-)

On 5/29/06, Bob Lee <crazybob at crazybob.org> wrote:
> On 5/28/06, Pete Soper <pete at soper.us> wrote:
> > The race is between the write of int[] and int[]{1} but it's enabled by
> > the lack of atomicity of the CAS.
>
> The CAS itself is atomic, right? The problem now is with the int[]
> which is exposed to two threads with no barrier. If we were doing a
> weak CAS of an int, this wouldn't be an issue, right?
>
> Bob
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
Giuliano Mega <giuliano at ime.usp.br>

From giuliano.mega at gmail.com  Sun May 28 23:55:31 2006
From: giuliano.mega at gmail.com (Giuliano Mega)
Date: Mon, 29 May 2006 00:55:31 -0300
Subject: [concurrency-interest] AtomicReference weakCompareAndSet
	"Mayfailspuriously"?
In-Reply-To: <a74683f90605282010u12519400l18246a1c519ba5e4@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCOELDGOAA.dcholmes@optusnet.com.au>
	<6EB77AA2-9E1D-4233-8AF4-F3AAC24F861E@cs.umd.edu>
	<4479AD41.4000605@soper.us>
	<E869FBDD-CE0C-4974-BB7A-5A91C928F16A@cs.umd.edu>
	<447A6095.1020604@soper.us>
	<a74683f90605282008g70c8cc78jbca2c807fcfe347@mail.gmail.com>
	<a74683f90605282010u12519400l18246a1c519ba5e4@mail.gmail.com>
Message-ID: <7547a9ff0605282055t45b59e4bw1752422336fe28c2@mail.gmail.com>

Many thanks David. You just answered my poorly-formulated question as well. :-)

Regards,

On 5/29/06, Bob Lee <crazybob at crazybob.org> wrote:
> Oops. David answered my question. ;)
>
> Bob
>
> On 5/28/06, Bob Lee <crazybob at crazybob.org> wrote:
> > On 5/28/06, Pete Soper <pete at soper.us> wrote:
> > > The race is between the write of int[] and int[]{1} but it's enabled by
> > > the lack of atomicity of the CAS.
> >
> > The CAS itself is atomic, right? The problem now is with the int[]
> > which is exposed to two threads with no barrier. If we were doing a
> > weak CAS of an int, this wouldn't be an issue, right?
> >
> > Bob
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
Giuliano Mega <giuliano at ime.usp.br>

From brian at quiotix.com  Mon May 29 00:49:18 2006
From: brian at quiotix.com (Brian Goetz)
Date: Mon, 29 May 2006 00:49:18 -0400
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>
Message-ID: <447A7D4E.6000602@quiotix.com>

> What Cliff wants is an atomic integer for use with counters that is not
> volatile, so that the extra memory barriers required for violatile semantics
> can be elided. This gives rise to a large performance boost in the context
> Cliff wants to use it - performance counters. Cliff can use weakCAS for this
> purpose.

The behavior Cliff wants is analogous to the meaning of volatile in the 
old memory model, where volatile wasn't required to ensure the 
visibility of any value other than the variable being written/read.

I think what bothers Bill about the proposal (I am confident Bill will 
correct me if I am wrong) is that there is no way to represent the old 
volatile semantics in the new memory model, and therefore there would be 
no mathematical basis for the proposed semantics of wCAS.

Stepping back, what Cliff really wants has nothing to do with wCAS, but 
for AtomicInteger.incrementAndGet to not be required to have any memory 
effects other than guaranteeing that it atomically updates the most 
up-to-date value of the AtomicInteger.  And the spec doesn't say 
anything about memory semantics of Atomic methods other than 
get/set/CAS, so this would be a consistent, though potentially 
confusing, implementation.

To summarize Cliff's argument, which is entirely motivated by practical 
considerations:

  - The specification of CAS currently requires a full fence.
  - Some processors support CAS operations that do not require full 
fences.
  - On these processors, CASing without a fence is far cheaper, and 
scales much better.
  - Performance counters are important in concurrent applications, and 
are, by definition, performance-critical.
  - We're teaching everyone that AtomicInteger.getAndIncrement is the 
right way to implement a performance counter.
  - So, shouldn't getAndIncrement be able to use the fence-less CAS on 
processors that support it?


From dl at cs.oswego.edu  Mon May 29 06:24:34 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 29 May 2006 06:24:34 -0400
Subject: [concurrency-interest] Collections Connection slides
Message-ID: <447ACBE2.7060901@cs.oswego.edu>


Martin Buchholz and Josh Bloch made the slides from their JavaOne
Collections Connection BoF available. You can get them at
   http://gee.cs.oswego.edu/dl/concurrency-interest/Collections-BOF-2006.pdf
   http://gee.cs.oswego.edu/dl/concurrency-interest/Collections-BOF-2006.ppt

These contain summaries of the Mustang Navigable and Deque APIs
(which are not yet described in many other places)
plus a few smaller Mustang features, plus overviews of Tiger features,
plus some possible coming attractions.

-Doug


From dl at cs.oswego.edu  Mon May 29 07:22:07 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 29 May 2006 07:22:07 -0400
Subject: [concurrency-interest] AtomicReference
	weakCompareAndSet"Mayfailspuriously"?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEPIGOAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCCEPIGOAA.dcholmes@optusnet.com.au>
Message-ID: <447AD95F.7070906@cs.oswego.edu>

To try to extend David's summary into action items:

1. The main use of weakCompareAndSet is for collecting statistics
and the like that don't otherwise interestingly affect the
happens-before orderings of a program. There might also be a few
other niche uses, but none of them involve using it for general
purpose synchronization control. We should add a sentence or two
to Javadocs steering people to use weakCAS only in such cases.

2. The details of the weakCompareAndSet specs need improvement.
Bill: Can you suggest rewordings?

3. As Hans Boehm pointed out, supporting only two flavors
of CAS (compareAndSet and weakCompareAndSet) leaves out the
other two possible orderings. The "missing" methods are:
   compareAndSetAcquire that has volatile-read semantics
   compareAndSetRelease that has volatile-write semantics
Neither of these appear to be useful if spurious failures are
allowed, so both are "strong" in that sense. It's worth considering
adding them because some processors (PowerPC and Itanium) may
be able to use instructions for them that are cheaper than full
CAS (but usually less cheap that weakCAS). So these would be
the cheapest ways to implement some synchronization algorithms,
and there is no good way to emulate their effects without
using full CAS. (For what it's worth the upcoming C++ spec
will probably distinguish these cases, although with different
details.) On the other hand, usage would be rare and adding yet
more subtly different variants will probably lead to more
confusion. So I'm still unsure about this.

-Doug





From dl at cs.oswego.edu  Mon May 29 07:35:12 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 29 May 2006 07:35:12 -0400
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <447A7D4E.6000602@quiotix.com>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>
	<447A7D4E.6000602@quiotix.com>
Message-ID: <447ADC70.6080009@cs.oswego.edu>

Brian Goetz wrote:
>> 
>   - The specification of CAS currently requires a full fence.
>   - Some processors support CAS operations that do not require full 
> fences.
>   - On these processors, CASing without a fence is far cheaper, and 
> scales much better.
>   - Performance counters are important in concurrent applications, and 
> are, by definition, performance-critical.
>   - We're teaching everyone that AtomicInteger.getAndIncrement is the 
> right way to implement a performance counter.
>   - So, shouldn't getAndIncrement be able to use the fence-less CAS on 
> processors that support it?
> 

I don't think so. To get the desired effect here, it would be
called "weakMaybeIncrement" or somesuch, which would
expand out into just

void weakMaybeIncrement(AtomicInteger ai) {
   int i = ai.get();
   ai.weakCompareAndSet(i, i+1);
}

I think that anyone sensitive to these issues will be able
to write these two lines themselves.


-Doug

From robertlazarski at gmail.com  Mon May 29 08:47:35 2006
From: robertlazarski at gmail.com (robert lazarski)
Date: Mon, 29 May 2006 09:47:35 -0300
Subject: [concurrency-interest] Creating a Set of pings
In-Reply-To: <f87675ee0605270728h5a9e9f33q3e0b016e6b1e24e7@mail.gmail.com>
References: <f87675ee0605221754o59a18d90s2cab79bef82550@mail.gmail.com>
	<63b4e4050605222019m2a4e715an791533f530029464@mail.gmail.com>
	<f87675ee0605270728h5a9e9f33q3e0b016e6b1e24e7@mail.gmail.com>
Message-ID: <f87675ee0605290547m16c2d0dbgdc3a6b876e9d88e4@mail.gmail.com>

The code I posted in my last post got mangled - sorry about that, I'm going
to try again. The issues I still have are that the performance of 25 seconds
on a class c subnet seems slow, and on bigger subnets I get "
java.net.ConnectException: No buffer space available" after around 1000
InetAddress.isReachable() calls. Any further help highly appreciated,
thanks!

         *public* static *List*<*String*> autodescobertaSCAN3(final
*String* mascara, final *String* ip,
            final *String* comunidadeLeitura, final *String* comunidadeEscrita,
            final *Integer* timeout, final *Integer* porta, final *Long* idMapa)
            *throws* FramexException, *TimeoutException* {
        *try* {
            long scanStart = *System*.currentTimeMillis();
            *ExecutorService* reachableExec =
*Executors*.newFixedThreadPool(10);
            *ExecutorService* snmpConnectExec =
*Executors*.newFixedThreadPool(5);

            *List* <*String*> ips = getValidIPs(mascara, ip);
            *List*<*InetAddress*> addrs = *new* *ArrayList*<*InetAddress*>();
            *for* (*Iterator* iter = ips.iterator(); iter.hasNext();) {
                addrs.add(*InetAddress*.getByName((*String*) iter.next()));
            }

            *Collection*<*Callable*<*InetAddress*>> testReachableTasks =
                *new* *ArrayList*<*Callable*<*InetAddress*>>();
            *for* (final *InetAddress* addr : addrs) {
                testReachableTasks.add(*new* *Callable*<*InetAddress*>() {
                    *public* *InetAddress* call() {
                        *try* {
                           *return* addr.isReachable(timeout) ? addr :
*null*;
                        } *catch* (*Exception* ex) {
                            ex.printStackTrace();
                        }
                        *return* *null*;
                    }
                });
            }

            *// Manages a blocking queue of testReachableTasks*
            *// objects, passing their results to the Snmp connector
as they become available.*
            *ExecutorCompletionService* reachableService = *new*
*ExecutorCompletionService*(reachableExec);

            *// Manage a blocking queue of trySnmpConnectTasks*
            *// objects, adding their results to the
snmpManagebleResults as they become available.*
            *ExecutorCompletionService* snmpService = *new*
*ExecutorCompletionService*(snmpConnectExec);
            *// *
            *List*<*Callable*<*InetAddress*>> trySnmpConnectTasks =
                *new* *ArrayList*<*Callable*<*InetAddress*>>();

            *for* (*Callable*<*InetAddress*> reachableTask :
testReachableTasks) {
                reachableService.submit(reachableTask);
            }
            int snmpTryConnects = 0;
            *for* (int i = 0; i < testReachableTasks.size(); i++) {
                *try* {
                    final *InetAddress* reachableAddr =
(*InetAddress*) reachableService.take().get();
                    *// address was not reachable*
                    *if* (reachableAddr == *null*) {
                        *continue*;
                    }
                    *// initialize the snmp connect queue*
                    *Callable* snmpCallable = *new*
*Callable*<*InetAddress*>() {
                        *public* *InetAddress* call() *throws*
java.lang.Exception {
                        *// facade.getByName() throws an exception*
                        *try* {
                          *return*
(getSnmpFacade().getByName(reachableAddr.getHostName(),
                                  porta,
                                  timeout,
                                  comunidadeLeitura,
                                  MibConstants.SYS_OBJECT_ID + ".0")
                                  != *null*) ? reachableAddr : *null*;
                        } *catch* (*TimeoutException* ex) {
                            *// this error is expected to happen alot*
                        } *catch* (*Exception* ex) {
                            ex.printStackTrace();
                        }
                        *return* *null*;
                        }
                    };
                    snmpService.submit(snmpCallable);
                    snmpTryConnects++;
                } *catch* (*Exception* ex) {
                    ex.printStackTrace();
                }
            }
            *// shut down the 'reachableExec' pool after all
registered tasks have completed,*
            *// and prevent new tasks from being assigned*
            reachableExec.shutdown();


            *Set*<*String*> snmpManagebleResults = *new* *HashSet*<*String*>();

            *for* (int i = 0; i < snmpTryConnects; i++) {
                *try* {
                    final *InetAddress* snmpAddr = (*InetAddress*)
snmpService.take().get();
                    *if* (snmpAddr != *null*) {
                        snmpManagebleResults.add(snmpAddr.getHostAddress());
                    }
                } *catch* (*Exception* ex) {
                    ex.printStackTrace();
                }
            }
            *// shut down the 'snmpConnectExec' pool after all
registered tasks have completed,*
            *// and prevent new tasks from being assigned*
            snmpConnectExec.shutdown();
            long scanEnd = *System*.currentTimeMillis();
            out.println("snmp scan completed!!! , Execution time was "
                        + (scanEnd - scanStart) / 1000 + " seconds ");

            *// compare result to previous result*
        } *catch* (*Exception* ex) {
            ex.printStackTrace();
            *throw* *new* FramexException(ex.getMessage(), ex);
        }

        *return* *null*;
    }

Robert

On 5/27/06, robert lazarski <robertlazarski at gmail.com> wrote:
>
> **Tim, thanks for your very insightful help - I've learned alot. I'll be
> looking for your book here in Brazil, and Joshua's too ;-) . I've also taken
> Dawid's advice about doing scans and have alerted the requirement guys.
>
> I've coded both versions you mentioned - one with two invokeAll() as you
> showed, and one with two ExecutorCompletionService . I won't clutter this
> post with the invokeAll() version here, but anyone who care's to see them
> both in their entirety can here:
>
> invokeAll() version:
> http://www.braziloutsource.com/random/CanSnmp.java
>
> ExecutorCompletionService version:
> http://www.braziloutsource.com/random/PerfSnmpScan.java
>
> I'm still a little concerned on performance. The invokeAll() version is
> taking 32 seconds on a class C subnet (for example, 192.168.10.1 to
> 192.168.10.254 ) , while under the same circumstances the
> ExecutorCompletionService version is taking 25 seconds. I'm running a P4
> 3GHZ machine with just one NIC under Suse Linux 9.3 . This is for both an
> isReachable() and snmp timeout of 1 second.
>
> The other concern I have is that isReachable() with more than 5 threads
> starts throwing "java.net.ConnectException: No buffer space available"
> when performing on multiple subnets - for example class A with
> 255.255.248.0 as the subnet mask, I get this error after about 1000
> isReachables() were performed.
>
> Anyways, here's what I came up with. Any suggestions highly appreciated.
> Thanks!
>
>             // autodescoberta == auto discovery
>
> *public* static *List*<*String*>
> autodescobertaSCAN3(final *String* mascara, final
> *String* ip,
> final *String* comunidadeLeitura, final
> *String* comunidadeEscrita,
> final *Integer* timeout, final
> *Integer* porta, final *Long* idMapa)
> *throws * FramexException, *TimeoutException* {
> *try* {
> long scanStart = *System*.currentTimeMillis();
> *ExecutorService* reachableExec = *Executors*.newFixedThreadPool
> (10);
> *ExecutorService* snmpConnectExec = *Executors*.newFixedThreadPool
> (5);
>
> *List* <*String*> ips = getValidIPs(mascara, ip);
>  *List*<*InetAddress*> addrs = *new* *ArrayList*
> <* InetAddress*>();
> *for* (*Iterator* iter = ips.iterator(); iter. hasNext();) {
> addrs.add(*InetAddress*.getByName((
> *String*) iter.next()));
> }
>
> *Collection*<
> *Callable*<*InetAddress*>> testReachableTasks =
>  *new* *ArrayList*<*Callable*<*InetAddress* >>(); *for* (final *
> InetAddress* addr : addrs) { testReachableTasks.add(*new* *Callable*<*
> InetAddress* >() { *public* *InetAddress* call
> () { *try* { *return* addr.isReachable(timeout) ? addr : *null*; } *catch*(
> *Exception* ex) { ex.printStackTrace(); } *return* *null*; } }); } *//
> Manages a blocking queue of testReachableTasks* *// objects, passing their
> results to the Snmp connector as they become available.* *
> ExecutorCompletionService* reachableService = *new* *
> ExecutorCompletionService*(reachableExec); *// Manage a blocking queue of
> trySnmpConnectTasks* *// objects, adding their results to the
> snmpManagebleResults as they become available.* *ExecutorCompletionService
> * snmpService = *new* *ExecutorCompletionService*(snmpConnectExec); *// *
> *List*<*Callable*<*InetAddress*>> trySnmpConnectTasks = *new* *ArrayList*<
> *Callable*<*InetAddress* >>(); *for* (*Callable*<*InetAddress*>
> reachableTask : testReachableTasks) { reachableService.submit(reachableTask);
> } int snmpTryConnects = 0; *for* (int i = 0; i < testReachableTasks.size();
> i++) { *try* { final *InetAddress* reachableAddr = (*InetAddress*)
> reachableService. take().get(); *// address was not reachable* *if*(reachableAddr ==
> *null*) { *continue*; } *// initialize the snmp connect queue* *Callable*snmpCallable =
> *new* *Callable*<*InetAddress *>() { *public* *InetAddress* call() *throws
> * java.lang .Exception { *// facade.getByName() throws an exception* *try*{
> *return* (getSnmpFacade().getByName(reachableAddr.getHostName (), porta,
> timeout, comunidadeLeitura, MibConstants.SYS_OBJECT_ID + ".0") != *null*)
> ? reachableAddr : *null*; } *catch* (*TimeoutException* ex) { *// this
> error is expected to happen alot* } *catch* (*Exception* ex) { ex.
> printStackTrace(); } *return* *null*; } }; snmpService.submit(snmpCallable);
> snmpTryConnects++; } *catch* (*Exception* ex) { ex.printStackTrace(); } }
> *// shut down the 'reachableExec' pool after all registered tasks have
> completed,* *// and prevent new tasks from being assigned* reachableExec.
> shutdown(); *Set*<*String*> snmpManagebleResults = *new* *HashSet* <*
> String*>(); *for* (int i = 0; i < snmpTryConnects; i++) { *try* { final *
> InetAddress* snmpAddr = (*InetAddress*) snmpService. take().get(); *if*(snmpAddr !=
> *null*) { snmpManagebleResults.add(snmpAddr.getHostAddress()); } } *catch*(
> *Exception* ex) { ex.printStackTrace(); } } *// shut down the
> 'snmpConnectExec' pool after all registered tasks have completed,* *// and
> prevent new tasks from being assigned* snmpConnectExec.shutdown(); longscanEnd =
> *System*.currentTimeMillis(); out.println("snmp scan completed!!! ,
> Execution time was " + (scanEnd - scanStart) / 1000 + " seconds ");
> *// compare result to previous result*
>  } *catch* (*Exception* ex) { ex.printStackTrace(); *throw* *new*
> FramexException(ex.getMessage(), ex); } *return* *null*; }Cheers,
>  Robert
>
> On 5/23/06, Tim Peierls <tim at peierls.net> wrote:
>
> > If you don't mind doing all step 1 work before all step 2/3 work, use
> > ExecutorService.invokeAll on a collection of Callable<InetAddress> tasks
> > that test isReachable.
> >
> > For each of these that succeeds, create a new Callable<InetAddress> that
> > tries to connect on port 161, and pass a collection these new tasks to
> > another invocation of ExecutorService.invokeAll.
> >
> > For each of these that succeeds, put the resulting InetAddress into a
> > plain HashSet -- CopyOnWriteArrayList is for lists that are frequently read
> > by different threads but rarely written to. This set need only be accessed
> > by one thread, the thread that creates it and compares it to some previous
> > value -- this previous value could be a thread-safe set if other threads
> > need to access it.
> >
> > Here's an uncompiled, untested, and possibly completely wrong-headed
> > sketch:
> >
> > ExecutorService exec = ...;
> > Collection<InetAddress> addrs = ...;
> >
> > List<Callable<InetAddress>> testReachableTasks =
> >     new ArrayList<Callable<InetAddress>>();
> > for (final InetAddress addr : addrs) {
> >     testReachableTasks.add(new Callable<InetAddress>() {
> >         public InetAddress call() {
> >             return isReachable(addr) ? addr : null;
> >         }
> >     });
> > }
> > List<Future<InetAddress>> reachables =
> >     exec.invokeAll(testReachableTasks);
> >
> > List<Callable<InetAddress>> tryConnectTasks =
> >     new ArrayList<Callable<InetAddress>>();
> > for (Future<InetAddress>> reachable : reachables) {
> >     // need to handle exceptions thrown by Future.get()
> >     final InetAddress addr = reachable.get();
> >     if (addr == null) continue;
> >
> >     tryConnectTasks.add(new Callable<InetAddress>() {
> >         public InetAddress call() {
> >             return (canConnectUdp (addr)
> >                  || canConnectSnmp(addr)) ? addr : null;
> >         }
> >     });
> > }
> > List<Future<InetAddress>> connectables =
> >     exec.invokeAll(tryConnectTasks);
> >
> > Set<InetAddress> result = new HashSet<InetAddress>();
> > for (Future<InetAddress>> connectable : connectables) {
> >     // need to handle exceptions thrown by Future.get()
> >     InetAddress addr = connectable.get();
> >     if (addr != null) result.add(addr);
> > }
> > // compare result to previous result
> >
> > If you want to start doing step 2/3 work before all step 1 work is
> > complete, use 2 instances of ExecutorCompletionService, one corresponding to
> > each call to invokeAll, and pull completed tasks off of one completion queue
> > to insert it into the next. It's a little trickier, since you have to count
> > submissions to know when you're done with a completion queue.
> >
> > I can't advise on how to size the pool. How many network interfaces are
> > there? How many processors are there? Seems like something you'd want to be
> > able to tune.
> >
> > --tim
> >
> > On 5/22/06, robert lazarski <robertlazarski at gmail.com> wrote:
> >
> > > Could someone please give some advice on these requirements?
> >
> > 1) Find all IP's on a given subnet that responds to ICMP  (ping). So for
> > say 192.168.10.0 with a netmask of 255.255.255.0, attempt a ping to 255
> > addresses. In java  I believe I can use InetAddress.isReachable(timeout)
> > .
> >
> > 2) On a valid IP, try to connect on port 161 via UDP and snmp.
> >
> > 3) Put the valid IP's inside an implementation of java.util.Set .
> >
> > 4) Compare new Set with a previous Set and show updates.
> >
> > My questions are:
> >
> > 1) Perform steps 1, 2, and possibly 3 in a Callable or Runnable. On
> > typical intel hardware does an ExecutorService with a size of 5 sound about
> > right?
> > 2) Should I pass in a Callable and get the results back 255 times, or
> > should I use Runnable and have the threads write the result to a common
> > area, ie, an object with a synchronized method ?
> > 3) Should I use one of the concurrent collections to store the results?
> > CopyOnWriteArrayList seems to fit.
> >
> > Thanks for any help,
> > Robert
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060529/db0cc27a/attachment-0001.html 

From jmanson at cs.purdue.edu  Mon May 29 09:45:53 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Mon, 29 May 2006 09:45:53 -0400
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <447A7D4E.6000602@quiotix.com>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>
	<447A7D4E.6000602@quiotix.com>
Message-ID: <447AFB11.1080909@cs.purdue.edu>

Brian Goetz wrote:

> I think what bothers Bill about the proposal (I am confident Bill will 
> correct me if I am wrong) is that there is no way to represent the old 
> volatile semantics in the new memory model, and therefore there would be 
> no mathematical basis for the proposed semantics of wCAS.

Although I can't speak for him, I am pretty sure that this is _not_ what 
worries Bill.  Any necessary mathematics can be resolved.  It wouldn't 
really matter if it were difficult, anyway; in general, one of the 
things that makes the JMM semantics so complicated is that it has to 
reflect what Java developers and users need, not mathematical simplicity.

More worrisome is the fact that there isn't really any meaningful use 
case for a happens-before-free weakCompareAndSet on an AtomicReference 
(AFAICT).  So do you end up keeping hb for AtomicReference, but losing 
it for AtomicInteger?  Is that a consistent API?

It seems to me that it would be better if you could decide that 
weakCompareAndSet did have hb semantics, and add weakCompareAndSetNoHB 
to the API for everything that is not AtomicReference.  This is not a 
reasonable solution, though, because it seems fairly clear that this 
issue cannot wait until Dolphin to be resolved.

					Jeremy

From dl at cs.oswego.edu  Mon May 29 10:52:11 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 29 May 2006 10:52:11 -0400
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <447AFB11.1080909@cs.purdue.edu>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>	<447A7D4E.6000602@quiotix.com>
	<447AFB11.1080909@cs.purdue.edu>
Message-ID: <447B0A9B.50000@cs.oswego.edu>

Jeremy Manson wrote:
> 
> 
> More worrisome is the fact that there isn't really any meaningful use 
> case for a happens-before-free weakCompareAndSet on an AtomicReference 
> (AFAICT).  

No common ones, but as we've seen, use cases for weakCAS
aren't all that common to begin with. One use case is in
help-out steps of wait-free algorithms, of the form:

retry:
   read-volatile n = head.get();
   read-volatile next = n.next.get();
   if (inconsistent(next)) {
        n.next.weakCompareAndSet(next, fixednext);
        goto retry;
   }
   ...

Because of full retry, and the likelihood that a retry by itself
will suffice (i.e., probably some other thread has already fixed
link), you might as well use the cheapest form. (Or maybe not,
depending on the relative likelihoods. It's an empirical issue though.)

Among others, Michael-Scott queues have steps of this basic form,
although the j.u.c ConcurrentLinkedQueue version use strong CAS in this
sort of case. It could be changed a bit to use weak though.

Aside: It might be nice if there were javadoc tags saying
"you probably {do, don't} want to use this method".  For the
sake of completeness, many APIs have methods that are only
rarely needed. But indispensible when they are needed.


-Doug


From jmanson at cs.purdue.edu  Mon May 29 11:08:26 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Mon, 29 May 2006 11:08:26 -0400
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <447B0A9B.50000@cs.oswego.edu>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>	<447A7D4E.6000602@quiotix.com>
	<447AFB11.1080909@cs.purdue.edu> <447B0A9B.50000@cs.oswego.edu>
Message-ID: <447B0E6A.1040609@cs.purdue.edu>

I'm probably being dim, but why don't you need the happens-before 
relationship here between the setter and a subsequent getter?  It seems 
to me that you need the release on fixedNext...  No?

					Jeremy


Doug Lea wrote:
> Jeremy Manson wrote:
>>
>>
>> More worrisome is the fact that there isn't really any meaningful use 
>> case for a happens-before-free weakCompareAndSet on an AtomicReference 
>> (AFAICT).  
> 
> No common ones, but as we've seen, use cases for weakCAS
> aren't all that common to begin with. One use case is in
> help-out steps of wait-free algorithms, of the form:
> 
> retry:
>   read-volatile n = head.get();
>   read-volatile next = n.next.get();
>   if (inconsistent(next)) {
>        n.next.weakCompareAndSet(next, fixednext);
>        goto retry;
>   }
>   ...
> 
> Because of full retry, and the likelihood that a retry by itself
> will suffice (i.e., probably some other thread has already fixed
> link), you might as well use the cheapest form. (Or maybe not,
> depending on the relative likelihoods. It's an empirical issue though.)
> 
> Among others, Michael-Scott queues have steps of this basic form,
> although the j.u.c ConcurrentLinkedQueue version use strong CAS in this
> sort of case. It could be changed a bit to use weak though.
> 
> Aside: It might be nice if there were javadoc tags saying
> "you probably {do, don't} want to use this method".  For the
> sake of completeness, many APIs have methods that are only
> rarely needed. But indispensible when they are needed.
> 
> 
> -Doug


From dl at cs.oswego.edu  Mon May 29 11:44:23 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 29 May 2006 11:44:23 -0400
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <447B0E6A.1040609@cs.purdue.edu>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>	<447A7D4E.6000602@quiotix.com>	<447AFB11.1080909@cs.purdue.edu>
	<447B0A9B.50000@cs.oswego.edu> <447B0E6A.1040609@cs.purdue.edu>
Message-ID: <447B16D7.5020602@cs.oswego.edu>

Jeremy Manson wrote:
> I'm probably being dim, but why don't you need the happens-before 
> relationship here between the setter and a subsequent getter?  It seems 
> to me that you need the release on fixedNext...  No?
> 

Remember that all threads are running the same code. As long as any
of them see inconsistencies, they will try to fix and then restart.
So, that CAS is OK being asynchronous wrt any of them. Just using
weakCAS might further delay progress of any for which the CAS fails, but
this might empirically be faster than using a hard LL/SC spin underlying
strong CAS on some machines.

-Doug



From jmanson at cs.purdue.edu  Mon May 29 11:46:02 2006
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Mon, 29 May 2006 11:46:02 -0400
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <447B16D7.5020602@cs.oswego.edu>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>	<447A7D4E.6000602@quiotix.com>	<447AFB11.1080909@cs.purdue.edu>
	<447B0A9B.50000@cs.oswego.edu> <447B0E6A.1040609@cs.purdue.edu>
	<447B16D7.5020602@cs.oswego.edu>
Message-ID: <447B173A.1070800@cs.purdue.edu>

Doug Lea wrote:
> Jeremy Manson wrote:
>> I'm probably being dim, but why don't you need the happens-before 
>> relationship here between the setter and a subsequent getter?  It 
>> seems to me that you need the release on fixedNext...  No?
>>
> 
> Remember that all threads are running the same code. As long as any
> of them see inconsistencies, they will try to fix and then restart.
> So, that CAS is OK being asynchronous wrt any of them. Just using
> weakCAS might further delay progress of any for which the CAS fails, but
> this might empirically be faster than using a hard LL/SC spin underlying
> strong CAS on some machines.
> 
> -Doug
> 

Oh, I see.  I didn't understand what inconsistent() did.

					Jeremy

From kimo at webnetic.net  Mon May 29 12:25:18 2006
From: kimo at webnetic.net (Kimo Crossman)
Date: Mon, 29 May 2006 09:25:18 -0700
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet"Mayfailspuriously"?
In-Reply-To: <447AD95F.7070906@cs.oswego.edu>
Message-ID: <02c301c6833c$7acc3ec0$28681948@DesktopSystem>


For those of you wanting to get a better handle on the weak CAS flavors in
different processors - take a look at this article:

Memory Ordering in Modern Microprocessors, Part II

http://www.linuxjournal.com/article/8212


From tackline at tackline.plus.com  Mon May 29 14:50:41 2006
From: tackline at tackline.plus.com (Thomas Hawtin)
Date: Mon, 29 May 2006 19:50:41 +0100
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <447AFB11.1080909@cs.purdue.edu>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au><447A7D4E.6000602@quiotix.com>
	<447AFB11.1080909@cs.purdue.edu>
Message-ID: <447B4281.70605@tackline.plus.com>

Jeremy Manson wrote:
> 
> More worrisome is the fact that there isn't really any meaningful use 
> case for a happens-before-free weakCompareAndSet on an AtomicReference 
> (AFAICT).  So do you end up keeping hb for AtomicReference, but losing 
> it for AtomicInteger?  Is that a consistent API?

It makes sense for referred objects that have been created to be
thread-safe, or the referrer is just interested in identity.

Trawling through the Java library to find meaningful use cases for
AtomicReference/AtomicReferenceFieldUpdater.weakCompareAndSet....


java.io.BufferedInputStream. The only point of the CAS is for the stream
closing case. weakCAS could be tried before the CAS.


java.util.concurrent.ConcurrentLinkedQueue. It looks as if some of the
CAS could be made weak. All Node fields are volatile. There needs to
always be one happens-before edge between enqueing and removal, but
possibly not as many. Here and elsewhere, CASing to null, I guess could
be weak (in a loop). Perhaps there should be a remove() with volatile
read (but not write) happens-before semantics in AtomicReference. OTOH, 
looking getAndSet(,null) adding an extra loop will presumably not help.


java.lang.System.getSecurityManager. We could possibly avoid the
volatile read in common case with something like:

     public static SecurityManager getSecurityManager() {
	if (security.weakCompareAndSet(null, null)) {
              return null;
         } else {
              return security.get();
         }
     }
or
     public static SecurityManager getSecurityManager() {
         SecurityManager securityNV = System.securityNV;
	if (security.weakCompareAndSet(securityNV, securityNV)) {
              return securityNV;
         } else {
              securityNV = security.get();
              System.securityNV = securityNV;
              return securityNV;
         }
     }

A weakGet would suffice in this situation, if it existed. Of course this
code would be must slower with the current quality of implementation.


Tom Hawtin


From pugh at cs.umd.edu  Mon May 29 15:23:45 2006
From: pugh at cs.umd.edu (Bill Pugh)
Date: Mon, 29 May 2006 15:23:45 -0400
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <447A7D4E.6000602@quiotix.com>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>
	<447A7D4E.6000602@quiotix.com>
Message-ID: <A5C12CF8-5B00-434C-B1B3-334AA65B66C8@cs.umd.edu>


On May 29, 2006, at 12:49 AM, Brian Goetz wrote:

>> What Cliff wants is an atomic integer for use with counters that  
>> is not
>> volatile, so that the extra memory barriers required for violatile  
>> semantics
>> can be elided. This gives rise to a large performance boost in the  
>> context
>> Cliff wants to use it - performance counters. Cliff can use  
>> weakCAS for this
>> purpose.
>
> The behavior Cliff wants is analogous to the meaning of volatile in  
> the
> old memory model, where volatile wasn't required to ensure the
> visibility of any value other than the variable being written/read.
>
> I think what bothers Bill about the proposal (I am confident Bill will
> correct me if I am wrong) is that there is no way to represent the old
> volatile semantics in the new memory model, and therefore there  
> would be
> no mathematical basis for the proposed semantics of wCAS.

No, actually, I'm not worried about that.
The way it is described in the current JavaDoc isn't correct,
but the memory model has no problem with synchronization actions that
don't establish happens-before ordering. We can fix the JavaDoc.

My worry is that people using weakCompareAndSet will accidently  
introduce
a synchronization error into their program.

In particular, I think the use case for a  
weakCompareAndSetWithoutHappensBefore
on a AtomicReference is rather limited.

Consider:

   Thread 1 uses a weakCompareAndSet to store a reference to an  
object X into
   an AtomicReference

   Thread 2 uses a get on the AtomicReference to get a reference to  
X. However,
there is no happens-before ordering from the CAS in thread 1 to the  
get in thread 2.
Thus, if thread 1 constructed X, or performed any updates to X before  
performing
the CAS, then there would be a data race if thread 2 tried to read  
any of the fields of X,
and the reads wouldn't be guaranteed to see any of the updates to the  
fields of X
performed by thread 1.

   Doug, and perhaps 3 other people in the world, could figure out  
valid and useful
use cases for a weakCompareAndSet on an AtomicReference that didn't  
create happens-before
orderings.

By the way, one of the things that should be added to  
java.util.concurrent in Java 7 is a
ConcurrentCounter: somethings you can increment quickly, but for  
which reading a value
is more expensive. There are all sorts of games you could play here,  
such as using
thread locals.

Suggested JavaDoc for weakCompareAndSet:

     Atomically sets the value to the given updated value if the  
current value == the expected value.
May fail spuriously. Unlike compareAndSet(), and other operations on  
an AtomicX, the weakCompareAndSet()
operation does not create any happens-before orderings.  Thus, just  
because a thread sees an update to an AtomicX caused
by a weakCompareAndSet doesn't mean it is properly synchronized
with operations that occurred before the weakCompareAndSet(). You  
probably don't want to use this method, but instead
should just use compareAndSet;
as there are few cases where weakCompareAndSet is faster than  
compareAndSet, and there are a number of cases in which
trying to optimizing your code by using weakCompareAndSet rather than  
compareAndSet will introduce subtle and hard to
reproduce synchronization errors into your code.



Bill


From chris.purcell.39 at gmail.com  Mon May 29 15:54:51 2006
From: chris.purcell.39 at gmail.com (Chris Purcell)
Date: Mon, 29 May 2006 20:54:51 +0100
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <447AFB11.1080909@cs.purdue.edu>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>
	<447A7D4E.6000602@quiotix.com> <447AFB11.1080909@cs.purdue.edu>
Message-ID: <B74A7750-8DCC-4DAA-862D-8B5F8DC0EF95@gmail.com>

> More worrisome is the fact that there isn't really any meaningful  
> use case for a happens-before-free weakCompareAndSet on an  
> AtomicReference (AFAICT).

How about for storing immutable objects? Doesn't constructor code  
happen-before subsequent writes?

Cheers,
Chris Purcell


From tim at peierls.net  Mon May 29 17:09:48 2006
From: tim at peierls.net (Tim Peierls)
Date: Mon, 29 May 2006 17:09:48 -0400
Subject: [concurrency-interest] Creating a Set of pings
In-Reply-To: <f87675ee0605290547m16c2d0dbgdc3a6b876e9d88e4@mail.gmail.com>
References: <f87675ee0605221754o59a18d90s2cab79bef82550@mail.gmail.com>
	<63b4e4050605222019m2a4e715an791533f530029464@mail.gmail.com>
	<f87675ee0605270728h5a9e9f33q3e0b016e6b1e24e7@mail.gmail.com>
	<f87675ee0605290547m16c2d0dbgdc3a6b876e9d88e4@mail.gmail.com>
Message-ID: <63b4e4050605291409g12d0e200u29811517993c3c2f@mail.gmail.com>

Maybe the approach you are using just doesn't scale very well? There may be
inherent resource limitations on the use of InetAddress.isReachable, etc.
that dominate everything else. If that's the case, it doesn't matter how
carefully or cleverly you code the thread pool usage; you're still bound by
those limitations.

I'm way out of my depth here, but maybe java.nio.channels.Selector could be
useful?

--tim

On 5/29/06, robert lazarski <robertlazarski at gmail.com> wrote:
>
> The code I posted in my last post got mangled - sorry about that, I'm
> going to try again. The issues I still have are that the performance of 25
> seconds on a class c subnet seems slow, and on bigger subnets I get "
> java.net.ConnectException: No buffer space available" after around 1000
> InetAddress.isReachable() calls. Any further help highly appreciated,
> thanks!
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060529/d61c8ec1/attachment.html 

From Hans.Boehm at hp.com  Tue May 30 01:16:41 2006
From: Hans.Boehm at hp.com (Hans Boehm)
Date: Mon, 29 May 2006 22:16:41 -0700 (PDT)
Subject: [concurrency-interest] AtomicReferenceweakCompareAndSet
 "Mayfailspuriously"?
In-Reply-To: <A5C12CF8-5B00-434C-B1B3-334AA65B66C8@cs.umd.edu>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>
	<447A7D4E.6000602@quiotix.com>
	<A5C12CF8-5B00-434C-B1B3-334AA65B66C8@cs.umd.edu>
Message-ID: <Pine.GHP.4.58.0605292126220.2321@tomil.hpl.hp.com>

Something like Bill's changes to the javadoc would be a great idea.

I still don't like the idea of giving weakCompareAndSet different
semantics in different classes.  In fact, I think I like it less and less
the more we explore this.

The other issue that we discussed a bit in a side conversation is that
there is no way to start with weakCompareAndSwap, and "add" volatile
semantics to either the read and/or the write, without going all the way
to compareAndSwap, and eliminating the possibility of spurious failure as
well.  This again leads me to conclude that weakCompareAndSwap currently
has very limited applicability.  But I think we also agree that any
attempt to improve matters ends up with a wider interface to support some
rather esoteric programs.

Hans

On Mon, 29 May 2006, Bill Pugh wrote:

>
> On May 29, 2006, at 12:49 AM, Brian Goetz wrote:
>
> >> What Cliff wants is an atomic integer for use with counters that
> >> is not
> >> volatile, so that the extra memory barriers required for violatile
> >> semantics
> >> can be elided. This gives rise to a large performance boost in the
> >> context
> >> Cliff wants to use it - performance counters. Cliff can use
> >> weakCAS for this
> >> purpose.
> >
> > The behavior Cliff wants is analogous to the meaning of volatile in
> > the
> > old memory model, where volatile wasn't required to ensure the
> > visibility of any value other than the variable being written/read.
> >
> > I think what bothers Bill about the proposal (I am confident Bill will
> > correct me if I am wrong) is that there is no way to represent the old
> > volatile semantics in the new memory model, and therefore there
> > would be
> > no mathematical basis for the proposed semantics of wCAS.
>
> No, actually, I'm not worried about that.
> The way it is described in the current JavaDoc isn't correct,
> but the memory model has no problem with synchronization actions that
> don't establish happens-before ordering. We can fix the JavaDoc.
>
> My worry is that people using weakCompareAndSet will accidently
> introduce
> a synchronization error into their program.
>
> In particular, I think the use case for a
> weakCompareAndSetWithoutHappensBefore
> on a AtomicReference is rather limited.
>
> Consider:
>
>    Thread 1 uses a weakCompareAndSet to store a reference to an
> object X into
>    an AtomicReference
>
>    Thread 2 uses a get on the AtomicReference to get a reference to
> X. However,
> there is no happens-before ordering from the CAS in thread 1 to the
> get in thread 2.
> Thus, if thread 1 constructed X, or performed any updates to X before
> performing
> the CAS, then there would be a data race if thread 2 tried to read
> any of the fields of X,
> and the reads wouldn't be guaranteed to see any of the updates to the
> fields of X
> performed by thread 1.
>
>    Doug, and perhaps 3 other people in the world, could figure out
> valid and useful
> use cases for a weakCompareAndSet on an AtomicReference that didn't
> create happens-before
> orderings.
>
> By the way, one of the things that should be added to
> java.util.concurrent in Java 7 is a
> ConcurrentCounter: somethings you can increment quickly, but for
> which reading a value
> is more expensive. There are all sorts of games you could play here,
> such as using
> thread locals.
>
> Suggested JavaDoc for weakCompareAndSet:
>
>      Atomically sets the value to the given updated value if the
> current value == the expected value.
> May fail spuriously. Unlike compareAndSet(), and other operations on
> an AtomicX, the weakCompareAndSet()
> operation does not create any happens-before orderings.  Thus, just
> because a thread sees an update to an AtomicX caused
> by a weakCompareAndSet doesn't mean it is properly synchronized
> with operations that occurred before the weakCompareAndSet(). You
> probably don't want to use this method, but instead
> should just use compareAndSet;
> as there are few cases where weakCompareAndSet is faster than
> compareAndSet, and there are a number of cases in which
> trying to optimizing your code by using weakCompareAndSet rather than
> compareAndSet will introduce subtle and hard to
> reproduce synchronization errors into your code.
>
>
>
> Bill
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dl at cs.oswego.edu  Tue May 30 07:38:39 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 30 May 2006 07:38:39 -0400
Subject: [concurrency-interest] Request for comment -- weakCompareAndSet
	specs
In-Reply-To: <Pine.GHP.4.58.0605292126220.2321@tomil.hpl.hp.com>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>	<447A7D4E.6000602@quiotix.com>	<A5C12CF8-5B00-434C-B1B3-334AA65B66C8@cs.umd.edu>
	<Pine.GHP.4.58.0605292126220.2321@tomil.hpl.hp.com>
Message-ID: <447C2EBF.6030509@cs.oswego.edu>


I edited the java.util.concurrent.atomic package docs to
incorporate suggestions. See
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/package-summary.html

You can see diffs most easily as using viewcvs:
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/atomic/package.html

I also summarized this in each AtomicX.weakCompareAndSet method
javadoc, as:
      * May fail spuriously and does not provide ordering guarantees,
      * so is only rarely an appropriate alternative to <tt>compareAndSet</tt>.

These are candidate changes for mustang bug 6425639
   http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6425639

Any further suggestions would be welcome.

I will also submit an RFE for compareAndSetAcquire and
compareAndSetRelease methods, to be considered for Dolphin
(it is much too late for Mustang). Any further arguments
for and against these would also be welcome.

-Doug


From Pete.Soper at Sun.COM  Tue May 30 13:44:14 2006
From: Pete.Soper at Sun.COM (Pete Soper)
Date: Tue, 30 May 2006 13:44:14 -0400
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <A5C12CF8-5B00-434C-B1B3-334AA65B66C8@cs.umd.edu>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>
	<447A7D4E.6000602@quiotix.com>
	<A5C12CF8-5B00-434C-B1B3-334AA65B66C8@cs.umd.edu>
Message-ID: <447C846E.6010700@Sun.COM>

It doesn't appear that Martin Buchholz has filed a Sun change request 
(CR) for this javadoc improvement. If there's a sense of JSR166 expert 
group (EG) concensus I can get the process started and Martin or I will 
follow through to try to make this happen for Mustang (it seems 
possible, but a lot of stuff is trying to happen all at once). You and 
one other EG member should sign off on the final text change and we'll 
assume this is a draft for the moment.

-Pete.

PS I was studying Lamport clocks when your Java SE 7 ("Dolphin") 
proposal hit my laptop and I almost fell out of my chair.

Bill Pugh wrote:
> On May 29, 2006, at 12:49 AM, Brian Goetz wrote:
> 
> 
>>>What Cliff wants is an atomic integer for use with counters that  
>>>is not
>>>volatile, so that the extra memory barriers required for violatile  
>>>semantics
>>>can be elided. This gives rise to a large performance boost in the  
>>>context
>>>Cliff wants to use it - performance counters. Cliff can use  
>>>weakCAS for this
>>>purpose.
>>
>>The behavior Cliff wants is analogous to the meaning of volatile in  
>>the
>>old memory model, where volatile wasn't required to ensure the
>>visibility of any value other than the variable being written/read.
>>
>>I think what bothers Bill about the proposal (I am confident Bill will
>>correct me if I am wrong) is that there is no way to represent the old
>>volatile semantics in the new memory model, and therefore there  
>>would be
>>no mathematical basis for the proposed semantics of wCAS.
> 
> 
> No, actually, I'm not worried about that.
> The way it is described in the current JavaDoc isn't correct,
> but the memory model has no problem with synchronization actions that
> don't establish happens-before ordering. We can fix the JavaDoc.
> 
> My worry is that people using weakCompareAndSet will accidently  
> introduce
> a synchronization error into their program.
> 
> In particular, I think the use case for a  
> weakCompareAndSetWithoutHappensBefore
> on a AtomicReference is rather limited.
> 
> Consider:
> 
>    Thread 1 uses a weakCompareAndSet to store a reference to an  
> object X into
>    an AtomicReference
> 
>    Thread 2 uses a get on the AtomicReference to get a reference to  
> X. However,
> there is no happens-before ordering from the CAS in thread 1 to the  
> get in thread 2.
> Thus, if thread 1 constructed X, or performed any updates to X before  
> performing
> the CAS, then there would be a data race if thread 2 tried to read  
> any of the fields of X,
> and the reads wouldn't be guaranteed to see any of the updates to the  
> fields of X
> performed by thread 1.
> 
>    Doug, and perhaps 3 other people in the world, could figure out  
> valid and useful
> use cases for a weakCompareAndSet on an AtomicReference that didn't  
> create happens-before
> orderings.
> 
> By the way, one of the things that should be added to  
> java.util.concurrent in Java 7 is a
> ConcurrentCounter: somethings you can increment quickly, but for  
> which reading a value
> is more expensive. There are all sorts of games you could play here,  
> such as using
> thread locals.
> 
> Suggested JavaDoc for weakCompareAndSet:
> 
>      Atomically sets the value to the given updated value if the  
> current value == the expected value.
> May fail spuriously. Unlike compareAndSet(), and other operations on  
> an AtomicX, the weakCompareAndSet()
> operation does not create any happens-before orderings.  Thus, just  
> because a thread sees an update to an AtomicX caused
> by a weakCompareAndSet doesn't mean it is properly synchronized
> with operations that occurred before the weakCompareAndSet(). You  
> probably don't want to use this method, but instead
> should just use compareAndSet;
> as there are few cases where weakCompareAndSet is faster than  
> compareAndSet, and there are a number of cases in which
> trying to optimizing your code by using weakCompareAndSet rather than  
> compareAndSet will introduce subtle and hard to
> reproduce synchronization errors into your code.
> 
> 
> 
> Bill
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From Darron_Shaffer at stercomm.com  Tue May 30 14:25:18 2006
From: Darron_Shaffer at stercomm.com (Shaffer, Darron)
Date: Tue, 30 May 2006 14:25:18 -0400
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
Message-ID: <303629700276DF4D9ED7D011221B8FAA05A6EBDB@scidubmsg03.sci.local>

So, as you turn the crank some display would say something like:

   Read of this.field, possible values: 5, 25, 17.

This would be a real challenge to write.  Not just making it figure out
all the possibilities from multiple threads, but also coming up with a
clear an usable display.  And a properly written program would make *no*
use of the hardest part of the work!


-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Pete
Soper
Sent: Sunday, May 28, 2006 9:47 PM
To: Bill Pugh
Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
Subject: Re: [concurrency-interest] AtomicReferenceweakCompareAndSet
"Mayfailspuriously"?

<snip>

I'm ready for the visible VM. Just turn the crank very, very slowly and 
all will be revealed. So in this case the surprising/not 
apparent/spurious/data race order is "read null, write int[], read 
int[], write int[]{1}".

-Pete


From Pete.Soper at Sun.COM  Tue May 30 17:32:29 2006
From: Pete.Soper at Sun.COM (Pete Soper)
Date: Tue, 30 May 2006 17:32:29 -0400
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet	"Mayfailspuriously"?
In-Reply-To: <303629700276DF4D9ED7D011221B8FAA05A6EBDB@scidubmsg03.sci.local>
References: <303629700276DF4D9ED7D011221B8FAA05A6EBDB@scidubmsg03.sci.local>
Message-ID: <447CB9ED.7090306@Sun.COM>

Shaffer, Darron wrote:
> So, as you turn the crank some display would say something like:
> 
>    Read of this.field, possible values: 5, 25, 17.
> 
> This would be a real challenge to write.  Not just making it figure out
> all the possibilities from multiple threads, but also coming up with a
> clear an usable display.  And a properly written program would make *no*
> use of the hardest part of the work!

I was absolutely muddle-headed about that spurious failure example, not 
noticing the array element assignment until I'd sent some silly blather 
to the list that confused the compare in a CAS with its read, etc, etc. 
Color me red.

I was joking about "visible VM". To accurately show what's happening I 
think extra hardware would be a must, and the UI would make a 747 
cockpit look simple or require AI or something. Hotspot or J9 and modern 
computer hardware are to the "visible V8 car engine" mentioned earlier 
on this list as the Space Shuttle is to a spring-operated mousetrap.

-Pete

> 
> 
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Pete
> Soper
> Sent: Sunday, May 28, 2006 9:47 PM
> To: Bill Pugh
> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> Subject: Re: [concurrency-interest] AtomicReferenceweakCompareAndSet
> "Mayfailspuriously"?
> 
> <snip>
> 
> I'm ready for the visible VM. Just turn the crank very, very slowly and 
> all will be revealed. So in this case the surprising/not 
> apparent/spurious/data race order is "read null, write int[], read 
> int[], write int[]{1}".
> 
> -Pete
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From Darron_Shaffer at stercomm.com  Tue May 30 18:47:49 2006
From: Darron_Shaffer at stercomm.com (Shaffer, Darron)
Date: Tue, 30 May 2006 18:47:49 -0400
Subject: [concurrency-interest]
	AtomicReferenceweakCompareAndSet"Mayfailspuriously"?
Message-ID: <303629700276DF4D9ED7D011221B8FAA05A6F05F@scidubmsg03.sci.local>

Building such a "Visible VM" might be an interesting intellectual
challenge, but I don't think you'd start with an existing VM.  My first
thought is "figure out every order that things can happen, display them
all, and select one at random to actually execute".  It's main use would
be to frighten developers away from bad programming practices.  :-)

I suspect that the short list of people who know enough to write it have
better things to do with their time.

-----Original Message-----
From: Pete.Soper at Sun.COM [mailto:Pete.Soper at Sun.COM] 
Sent: Tuesday, May 30, 2006 4:32 PM
To: Shaffer, Darron
Cc: Pete Soper; concurrency-interest at cs.oswego.edu; dholmes at ieee.org
Subject: Re: [concurrency-interest]
AtomicReferenceweakCompareAndSet"Mayfailspuriously"?

Shaffer, Darron wrote:
> So, as you turn the crank some display would say something like:
> 
>    Read of this.field, possible values: 5, 25, 17.
> 
> This would be a real challenge to write.  Not just making it figure
out
> all the possibilities from multiple threads, but also coming up with a
> clear an usable display.  And a properly written program would make
*no*
> use of the hardest part of the work!

I was absolutely muddle-headed about that spurious failure example, not 
noticing the array element assignment until I'd sent some silly blather 
to the list that confused the compare in a CAS with its read, etc, etc. 
Color me red.

I was joking about "visible VM". To accurately show what's happening I 
think extra hardware would be a must, and the UI would make a 747 
cockpit look simple or require AI or something. Hotspot or J9 and modern

computer hardware are to the "visible V8 car engine" mentioned earlier 
on this list as the Space Shuttle is to a spring-operated mousetrap.

-Pete

> 
> 
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Pete
> Soper
> Sent: Sunday, May 28, 2006 9:47 PM
> To: Bill Pugh
> Cc: concurrency-interest at cs.oswego.edu; dholmes at ieee.org
> Subject: Re: [concurrency-interest] AtomicReferenceweakCompareAndSet
> "Mayfailspuriously"?
> 
> <snip>
> 
> I'm ready for the visible VM. Just turn the crank very, very slowly
and 
> all will be revealed. So in this case the surprising/not 
> apparent/spurious/data race order is "read null, write int[], read 
> int[], write int[]{1}".
> 
> -Pete
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 



From pete at soper.us  Tue May 30 20:02:31 2006
From: pete at soper.us (Pete Soper)
Date: Tue, 30 May 2006 20:02:31 -0400
Subject: [concurrency-interest] Request for comment -- weakCompareAndSet
 specs
In-Reply-To: <447C2EBF.6030509@cs.oswego.edu>
References: <NFBBKALFDCPFIDBNKAPCOEPKGOAA.dcholmes@optusnet.com.au>	<447A7D4E.6000602@quiotix.com>	<A5C12CF8-5B00-434C-B1B3-334AA65B66C8@cs.umd.edu>	<Pine.GHP.4.58.0605292126220.2321@tomil.hpl.hp.com>
	<447C2EBF.6030509@cs.oswego.edu>
Message-ID: <447CDD17.3020702@soper.us>

Doug Lea wrote:
> I edited the java.util.concurrent.atomic package docs to
> incorporate suggestions. See
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/package-summary.html
>
> You can see diffs most easily as using viewcvs:
> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/atomic/package.html
>
> I also summarized this in each AtomicX.weakCompareAndSet method
> javadoc, as:
>       * May fail spuriously and does not provide ordering guarantees,
>       * so is only rarely an appropriate alternative to <tt>compareAndSet</tt>.
>
> These are candidate changes for mustang bug 6425639
>    http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6425639
>
>   
Missed this before sending what I did, sorry.

-Pete

From eross at m-Qube.com  Wed May 31 18:33:21 2006
From: eross at m-Qube.com (Elias Ross)
Date: Wed, 31 May 2006 15:33:21 -0700
Subject: [concurrency-interest] Contract of java.io.OutputStream.write(byte
	b[])
Message-ID: <1149114801.15211.189.camel@scrub>


I know this isn't really the forum for asking this, but I've spent a
number of hours looking into a definite yes or no...

I wanted to know if OutputStream.write(byte b[]) was considered atomic.
If two threads are writing to the same file, would the output from
OS.write(...) overlap with another OS.write(...)?

I eventually downloaded the Java source to answer this question.  The
JavaDoc did not specify.  As it turns out, the answer is "no" -- which
is something that you'd only be able to determine by looking at the C
source code for the native calls.

The JDK interpretation of write() is slightly different than the UNIX
one, which looks like this:

       ssize_t write(int fd, const void *buf, size_t count);

so it makes sense that a Java write() call may have to do more than one
system write() call.

I wonder if there some better way that "concurrent" and "atomic" methods
can be documented in the JDK?  It's also very helpful as a user to know
if I should be locking on the OutputStream itself or create my own
locks.



From joe.bowbeer at gmail.com  Wed May 31 19:48:08 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 31 May 2006 16:48:08 -0700
Subject: [concurrency-interest] Contract of
	java.io.OutputStream.write(byte b[])
In-Reply-To: <1149114801.15211.189.camel@scrub>
References: <1149114801.15211.189.camel@scrub>
Message-ID: <31f2a7bd0605311648l4932c22j94efbdeb20b6475f@mail.gmail.com>

New annotations have been created for the purpose of documenting which lock
guards which state.

Watch this space for @GuardedBy and friends:

  http://jcip.net/

In the near term, I recommend providing your own locks unless you're
intimate with the details of the specific OutputStream subclass
implementation (on your specific platform).

  synchronized (outLock) {
    out.write(buffer);
  }

If is often the case that the outputstream object can serve as this lock.

In other cases, no explicit locking is needed.  The write method is
synchronized in the ByteArrayOutputStream implementation I'm looking at
now..

-- 
Joe Bowbeer ~ http://joebowbeer.thruhere.net



On 5/31/06, Elias Ross <eross at m-qube.com> wrote:
>
>
> I know this isn't really the forum for asking this, but I've spent a
> number of hours looking into a definite yes or no...
>
> I wanted to know if OutputStream.write(byte b[]) was considered atomic.
> If two threads are writing to the same file, would the output from
> OS.write(...) overlap with another OS.write(...)?
>
> I eventually downloaded the Java source to answer this question.  The
> JavaDoc did not specify.  As it turns out, the answer is "no" -- which
> is something that you'd only be able to determine by looking at the C
> source code for the native calls.
>
> The JDK interpretation of write() is slightly different than the UNIX
> one, which looks like this:
>
>        ssize_t write(int fd, const void *buf, size_t count);
>
> so it makes sense that a Java write() call may have to do more than one
> system write() call.
>
> I wonder if there some better way that "concurrent" and "atomic" methods
> can be documented in the JDK?  It's also very helpful as a user to know
> if I should be locking on the OutputStream itself or create my own
> locks.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060531/ec38dab2/attachment.html 

From pugh at cs.umd.edu  Wed May 31 20:53:05 2006
From: pugh at cs.umd.edu (Bill Pugh)
Date: Wed, 31 May 2006 20:53:05 -0400
Subject: [concurrency-interest] Contract of
	java.io.OutputStream.write(byte b[])
In-Reply-To: <1149114801.15211.189.camel@scrub>
References: <1149114801.15211.189.camel@scrub>
Message-ID: <E16E3782-0640-4E17-9922-5D028DA1C171@cs.umd.edu>

The fact that many of the implementations of OutputStream are  
synchronized was
a pretty horrible design mistake.

If you have two different threads trying to push bytes into an output  
stream, I'm hard pressed to
imagine situations in which allowing the threads to non- 
deterministically interleave is a good idea.

If you are creating your own implementation of OutputStream, I would  
recommending avoiding any
use of synchronization. It serves no purpose, reduces performance,  
and I don't believe the class
contract (or Sun's TCK tests) require it.

	Bill Pugh


On May 31, 2006, at 6:33 PM, Elias Ross wrote:

>
> I know this isn't really the forum for asking this, but I've spent a
> number of hours looking into a definite yes or no...
>
> I wanted to know if OutputStream.write(byte b[]) was considered  
> atomic.
> If two threads are writing to the same file, would the output from
> OS.write(...) overlap with another OS.write(...)?
>
> I eventually downloaded the Java source to answer this question.  The
> JavaDoc did not specify.  As it turns out, the answer is "no" -- which
> is something that you'd only be able to determine by looking at the C
> source code for the native calls.
>
> The JDK interpretation of write() is slightly different than the UNIX
> one, which looks like this:
>
>        ssize_t write(int fd, const void *buf, size_t count);
>
> so it makes sense that a Java write() call may have to do more than  
> one
> system write() call.
>
> I wonder if there some better way that "concurrent" and "atomic"  
> methods
> can be documented in the JDK?  It's also very helpful as a user to  
> know
> if I should be locking on the OutputStream itself or create my own
> locks.
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From gregg at cytetech.com  Wed May 31 22:47:51 2006
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 31 May 2006 21:47:51 -0500
Subject: [concurrency-interest] Contract
 of	java.io.OutputStream.write(byte b[])
In-Reply-To: <E16E3782-0640-4E17-9922-5D028DA1C171@cs.umd.edu>
References: <1149114801.15211.189.camel@scrub>
	<E16E3782-0640-4E17-9922-5D028DA1C171@cs.umd.edu>
Message-ID: <447E5557.1050405@cytetech.com>



Bill Pugh wrote:
> If you have two different threads trying to push bytes into an output  
> stream, I'm hard pressed to
> imagine situations in which allowing the threads to non- 
> deterministically interleave is a good idea.

A logging stream is one place where letting the writes happen in any order is 
probably okay.  You do want the entire byte[] to go out in one piece, so 
synchronizing on the write call is an easy way to do this.

I've counted on the synchronized OutputStream behavior in more than one place, 
without second thought that its presense in an API's Javadoc doesn't necessarily 
make it a requirement of all implementations extending or using that API.

Humm....

Gregg Wonderly

From dhanji at gmail.com  Wed May 31 23:23:49 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 1 Jun 2006 13:23:49 +1000
Subject: [concurrency-interest] Contract of
	java.io.OutputStream.write(byte b[])
In-Reply-To: <E16E3782-0640-4E17-9922-5D028DA1C171@cs.umd.edu>
References: <1149114801.15211.189.camel@scrub>
	<E16E3782-0640-4E17-9922-5D028DA1C171@cs.umd.edu>
Message-ID: <aa067ea10605312023u6fc732f0pcd58a4a4d8f814dc@mail.gmail.com>

On 6/1/06, Bill Pugh <pugh at cs.umd.edu> wrote:
> The fact that many of the implementations of OutputStream are
> synchronized was
> a pretty horrible design mistake.
>
> If you have two different threads trying to push bytes into an output
> stream, I'm hard pressed to
> imagine situations in which allowing the threads to non-
> deterministically interleave is a good idea.
>
> If you are creating your own implementation of OutputStream, I would
> recommending avoiding any
> use of synchronization. It serves no purpose, reduces performance,
> and I don't believe the class
> contract (or Sun's TCK tests) require it.

that sounds quite sensible.
I would also suggest using wait() and notify() for deterministic
synchronization at the producer level (user of the outputstream) as
opposed to a synchronized block unless the latter is more appropriate
(optimistic stream writes).
In any case isnt it better practise to synchronize on a buffer and
allow only one thread access to the underlying outputstream?

>
>         Bill Pugh
>
>
> On May 31, 2006, at 6:33 PM, Elias Ross wrote:
>
> >
> > I know this isn't really the forum for asking this, but I've spent a
> > number of hours looking into a definite yes or no...
> >
> > I wanted to know if OutputStream.write(byte b[]) was considered
> > atomic.
> > If two threads are writing to the same file, would the output from
> > OS.write(...) overlap with another OS.write(...)?
> >
> > I eventually downloaded the Java source to answer this question.  The
> > JavaDoc did not specify.  As it turns out, the answer is "no" -- which
> > is something that you'd only be able to determine by looking at the C
> > source code for the native calls.
> >
> > The JDK interpretation of write() is slightly different than the UNIX
> > one, which looks like this:
> >
> >        ssize_t write(int fd, const void *buf, size_t count);
> >
> > so it makes sense that a Java write() call may have to do more than
> > one
> > system write() call.
> >
> > I wonder if there some better way that "concurrent" and "atomic"
> > methods
> > can be documented in the JDK?  It's also very helpful as a user to
> > know
> > if I should be locking on the OutputStream itself or create my own
> > locks.
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

