From bryan at systap.com  Mon Feb  1 11:17:27 2010
From: bryan at systap.com (Bryan Thompson)
Date: Mon, 1 Feb 2010 10:17:27 -0600
Subject: [concurrency-interest] Contention on ReferenceQueue#poll()...
Message-ID: <DE10B00CCE0DC54883734F3060AC9ED439F4B11CE3@AUSP01VMBX06.collaborationhost.net>

Hello,

I am observing contention in ReferenceQueue#poll() for the internal lock used by that class.  Our use case is to clear entries from a weak value cache once their References have been cleared.  We are working to minimize contention from the application by controlling which thread calls ReferenceQueue#poll(), but it seems that it would be useful to have a ReferenceQueue#drain(...) method which hands back an array of references which have been cleared, perhaps by writing them into an array provided by the caller.  Regardless of the specific method signature, this would make it faster for a thread to consume the elements from the ReferenceQueue.

Thanks,

Bryan

From alarmnummer at gmail.com  Mon Feb  1 12:23:49 2010
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 1 Feb 2010 18:23:49 +0100
Subject: [concurrency-interest] Contention on ReferenceQueue#poll()...
In-Reply-To: <DE10B00CCE0DC54883734F3060AC9ED439F4B11CE3@AUSP01VMBX06.collaborationhost.net>
References: <DE10B00CCE0DC54883734F3060AC9ED439F4B11CE3@AUSP01VMBX06.collaborationhost.net>
Message-ID: <7C1BACBE-5304-48D6-A11D-5154ED891BB7@gmail.com>

Hi bryan,

Perhaps you could use a stripe of referencequeues instead of a single  
one. This would lower the contention.

On 1 feb 2010, at 17:17, Bryan Thompson <bryan at systap.com> wrote:

> Hello,
>
> I am observing contention in ReferenceQueue#poll() for the internal  
> lock used by that class.  Our use case is to clear entries from a  
> weak value cache once their References have been cleared.  We are  
> working to minimize contention from the application by controlling  
> which thread calls ReferenceQueue#poll(), but it seems that it would  
> be useful to have a ReferenceQueue#drain(...) method which hands  
> back an array of references which have been cleared, perhaps by  
> writing them into an array provided by the caller.  Regardless of  
> the specific method signature, this would make it faster for a  
> thread to consume the elements from the ReferenceQueue.
>
> Thanks,
>
> Bryan
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From Alan.Bateman at Sun.COM  Tue Feb  2 05:53:23 2010
From: Alan.Bateman at Sun.COM (Alan Bateman)
Date: Tue, 02 Feb 2010 10:53:23 +0000
Subject: [concurrency-interest] Contention on ReferenceQueue#poll()...
In-Reply-To: <DE10B00CCE0DC54883734F3060AC9ED439F4B11CE3@AUSP01VMBX06.collaborationhost.net>
References: <DE10B00CCE0DC54883734F3060AC9ED439F4B11CE3@AUSP01VMBX06.collaborationhost.net>
Message-ID: <4B680423.30606@sun.com>

Bryan Thompson wrote:
> Hello,
>
> I am observing contention in ReferenceQueue#poll() for the internal lock used by that class.  Our use case is to clear entries from a weak value cache once their References have been cleared.  We are working to minimize contention from the application by controlling which thread calls ReferenceQueue#poll(), but it seems that it would be useful to have a ReferenceQueue#drain(...) method which hands back an array of references which have been cleared, perhaps by writing them into an array provided by the caller.  Regardless of the specific method signature, this would make it faster for a thread to consume the elements from the ReferenceQueue.
>
> Thanks,
>
> Bryan
>   
Out of curiosity, which version of the JDK is this? I ask because there 
were changes in 6u14 and jdk7 to improvement the scalability of the poll 
method.

-Alan.

From bryan at systap.com  Tue Feb  2 05:55:06 2010
From: bryan at systap.com (Bryan Thompson)
Date: Tue, 2 Feb 2010 04:55:06 -0600
Subject: [concurrency-interest] Contention on ReferenceQueue#poll()...
Message-ID: <4tcse6klj9jpom4lem35ibtr.1265108121421@email.android.com>

1.6.0_18

Alan Bateman <Alan.Bateman at Sun.COM> wrote:


Bryan Thompson wrote:
> Hello,
>
> I am observing contention in ReferenceQueue#poll() for the internal lock used by that class.  Our use case is to clear entries from a weak value cache once their References have been cleared.  We are working to minimize contention from the application by controlling which thread calls ReferenceQueue#poll(), but it seems that it would be useful to have a ReferenceQueue#drain(...) method which hands back an array of references which have been cleared, perhaps by writing them into an array provided by the caller.  Regardless of the specific method signature, this would make it faster for a thread to consume the elements from the ReferenceQueue.
>
> Thanks,
>
> Bryan
>
Out of curiosity, which version of the JDK is this? I ask because there
were changes in 6u14 and jdk7 to improvement the scalability of the poll
method.

-Alan.


From philipp.buluschek at romandie.com  Tue Feb  2 07:22:32 2010
From: philipp.buluschek at romandie.com (Philipp Buluschek)
Date: Tue, 02 Feb 2010 13:22:32 +0100
Subject: [concurrency-interest] backport: Numerous spurious wake ups in
	Condition.await(time)
Message-ID: <4B681908.30503@romandie.com>

Dear all,
Using the test code below with concurrent backport package, I have a 
very different "spurious wake-up" behavior than with the corresponding 
Java 6 classes. Condition.await(time) wakes up on time, but the returned 
boolean, which indicates whether the wake-up was triggered by the 
time-out is not always set correctly.
Is this a known behavior in the backport?

Best regards
  Philipp

Output with the backport:
13:04:00.328 Next try
13:04:03.437 Spurious wakeup
13:04:03.437 Next try
13:04:06.437 Next try
13:04:09.437 Spurious wakeup
13:04:09.437 Next try
13:04:12.437 Next try
13:04:15.437 Spurious wakeup
13:04:15.437 Next try
13:04:18.437 Spurious wakeup
13:04:18.437 Next try
13:04:21.437 Spurious wakeup


Output with Java 6 java.util.concurrent:
13:04:48.093 Next try
13:04:51.093 Next try
13:04:54.093 Next try
13:04:57.109 Next try
13:05:00.109 Next try
13:05:03.109 Next try
13:05:06.109 Next try


Test Code:

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
import edu.emory.mathcs.backport.java.util.concurrent.locks.Condition;
import edu.emory.mathcs.backport.java.util.concurrent.locks.Lock;
import edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantLock;

public class TestAwait2 implements Runnable{
  private static final long MAX_WAIT = 3000;
 
  private Lock lock = new ReentrantLock();
  private Condition cond = lock.newCondition();
  private volatile boolean run = true;
 
 
  private DateFormat f = new SimpleDateFormat("HH:mm:ss.SSS");
  private String date(){
    return f.format(new Date()) + " ";
  }

  public void run(){
    while(run){
      System.out.println(date()+ "Next try");
      lock.lock();
      try{
        boolean timedOut = !cond.await(MAX_WAIT, TimeUnit.MILLISECONDS);
        if(!timedOut){
          System.out.println(date()+ "Spurious wakeup");// there is no 
reason to wake up before time-out!
        }
      } catch (InterruptedException e) {
        e.printStackTrace();
      }finally{
        lock.unlock();
      }
    }
  }

  public static void main(String[] args) throws Exception {
    TestAwait2 ta = new TestAwait2();
    Thread t = new Thread(ta);
    t.start();
    Thread.sleep(20000); // give the other thread some time to work
    ta.run = false;
  }
}





From Robert.Hafner at sas.com  Thu Feb  4 09:56:52 2010
From: Robert.Hafner at sas.com (Robert Hafner)
Date: Thu, 4 Feb 2010 09:56:52 -0500
Subject: [concurrency-interest] backport: Using
	backport-util-concurrent-Java60-3.1 on JRE 1.5.
Message-ID: <304E9E55F6A4BE4B910C2437D4D1B4960C07DC1741@MERCMBX14.na.sas.com>

We support deploying our applications to WAS, WebLogic, and JBoss running on top of JDK 5 and JDK 6. In addition we prefer not to have application sever or JDK Version specific ears. Can you verify whether you would expect backport-util-concurrent-Java60.3.1 to work on JDK/JRE 5? We are looking to deploying a single version of backport to application servers (and clients) running under JDK/JRE 1.5 & 1.6.

Regards,
Rob





From holger.hoffstaette at googlemail.com  Thu Feb  4 10:21:27 2010
From: holger.hoffstaette at googlemail.com (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Thu, 04 Feb 2010 16:21:27 +0100
Subject: [concurrency-interest] backport: Using
 backport-util-concurrent-Java60-3.1 on JRE 1.5.
In-Reply-To: <304E9E55F6A4BE4B910C2437D4D1B4960C07DC1741@MERCMBX14.na.sas.com>
References: <304E9E55F6A4BE4B910C2437D4D1B4960C07DC1741@MERCMBX14.na.sas.com>
Message-ID: <4B6AE5F7.1040005@googlemail.com>

Robert Hafner wrote:
> We support deploying our applications to WAS, WebLogic, and JBoss
> running on top of JDK 5 and JDK 6. In addition we prefer not to have
> application sever or JDK Version specific ears. Can you verify whether
> you would expect backport-util-concurrent-Java60.3.1 to work on JDK/JRE
> 5? We are looking to deploying a single version of backport to
> application servers (and clients) running under JDK/JRE 1.5 & 1.6.

Using the JDK6-backport on JDK5 is pretty much guaranteed not to work as
the library delegates to the base JDK classes in various ways. If you want
to deploy a single code base on both JDK5 and JDK6, you need to use the
JDK5-specific backport version.

-h


From hallorant at gmail.com  Thu Feb  4 10:34:58 2010
From: hallorant at gmail.com (Tim Halloran)
Date: Thu, 4 Feb 2010 10:34:58 -0500
Subject: [concurrency-interest] How to toggle an AtomicBoolean?
Message-ID: <a36ab4bc1002040734k4a1fb519yac91e4a9053fc26c@mail.gmail.com>

Hello, hopefully a simple question for everyone.?I was surprised to
discover that AtomicBoolean does not have an atomic "toggle"
operation.
Looks like folks use code similar to:

  private AtomicBoolean flag = new AtomicBoolean(true);

  public boolean toggleAndGet() {
    boolean temp;
    do {
      temp = flag.get();
    } while(!flag.compareAndSet(temp, !temp));
    return flag.get();
  }

This doesn't seem all that "atomic" to me, thoughts?? So I cooked up a
different approach:

  /**
   * Encoding: even is true; odd is false.
   */
  private final AtomicInteger eFlag = new AtomicInteger(0);

  public boolean toggleAndGet() {
    return toBoolean(eFlag.incrementAndGet());
  }

  public boolean getValue() {
    return toBoolean(eFlag.get());
  }

  private boolean toBoolean(final int value) {
    return (value & 1) == 0;
  }

and it appears to work fine on all the tests I cooked up (including wraparound).

Well, looking at the implementation of AtomicBoolean, it looks like
Doug already thought of this idea as the internal representation is
indeed an "int" not a "boolean".

My question is if "toggleAndGet" could be added to AtomicBoolean using
the encoding scheme I use, i.e., make even be true and odd be false
rather than 0 is true and 1 is false as in the current implementation.
Alternatively, is there a way to implement this method with the
current encoding?

Hopefully, I'm not missing something really simple here :-)

Best,
Tim Halloran


From Robert.Hafner at sas.com  Thu Feb  4 10:56:55 2010
From: Robert.Hafner at sas.com (Robert Hafner)
Date: Thu, 4 Feb 2010 10:56:55 -0500
Subject: [concurrency-interest] backport: Using
 backport-util-concurrent-Java60-3.1 on JRE 1.5.
In-Reply-To: <4B6AE5F7.1040005@googlemail.com>
References: <304E9E55F6A4BE4B910C2437D4D1B4960C07DC1741@MERCMBX14.na.sas.com>
	<4B6AE5F7.1040005@googlemail.com>
Message-ID: <304E9E55F6A4BE4B910C2437D4D1B4960C07DC19BC@MERCMBX14.na.sas.com>

Unfortunately, the JDK 5 backport version does not run on JDK6 due to some changes in JDK classes in Java 6. Some details can be found in this thread:

http://old.nabble.com/Re:-Java-6-support-in-backport-concurrent-p12141441.html


Here is a simple test case running backport-util-concurrent-Java50-3.1 on JRE 6 which shows one of the issues.

import edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch;

public class Test {

	public static void main(String[] args) {
		CountDownLatch cdl = new CountDownLatch(1);
		System.out.println("ok");		
	}
}

Output:
Exception in thread "main" java.lang.VerifyError: class edu.emory.mathcs.backport.java.util.concurrent.helpers.AbstractOwnableQueuedSynchronizer overrides final method setExclusiveOwnerThread.(Ljava/lang/Thread;)V
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClassCond(Unknown Source)
	at java.lang.ClassLoader.defineClass(Unknown Source)
	at java.security.SecureClassLoader.defineClass(Unknown Source)
	at java.net.URLClassLoader.defineClass(Unknown Source)
	at java.net.URLClassLoader.access$000(Unknown Source)
	at java.net.URLClassLoader$1.run(Unknown Source)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(Unknown Source)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClassCond(Unknown Source)
	at java.lang.ClassLoader.defineClass(Unknown Source)
	at java.security.SecureClassLoader.defineClass(Unknown Source)
	at java.net.URLClassLoader.defineClass(Unknown Source)
	at java.net.URLClassLoader.access$000(Unknown Source)
	at java.net.URLClassLoader$1.run(Unknown Source)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(Unknown Source)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch.<init>(CountDownLatch.java:176)
	at Test.main(Test.java:6)


-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Holger Hoffst?tte
Sent: Thursday, February 04, 2010 10:21 AM
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] backport: Using backport-util-concurrent-Java60-3.1 on JRE 1.5.

Robert Hafner wrote:
> We support deploying our applications to WAS, WebLogic, and JBoss
> running on top of JDK 5 and JDK 6. In addition we prefer not to have
> application sever or JDK Version specific ears. Can you verify whether
> you would expect backport-util-concurrent-Java60.3.1 to work on JDK/JRE
> 5? We are looking to deploying a single version of backport to
> application servers (and clients) running under JDK/JRE 1.5 & 1.6.

Using the JDK6-backport on JDK5 is pretty much guaranteed not to work as
the library delegates to the base JDK classes in various ways. If you want
to deploy a single code base on both JDK5 and JDK6, you need to use the
JDK5-specific backport version.

-h

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From hanson.char at gmail.com  Thu Feb  4 11:39:04 2010
From: hanson.char at gmail.com (Hanson Char)
Date: Thu, 4 Feb 2010 08:39:04 -0800
Subject: [concurrency-interest] How to toggle an AtomicBoolean?
In-Reply-To: <a36ab4bc1002040734k4a1fb519yac91e4a9053fc26c@mail.gmail.com>
References: <a36ab4bc1002040734k4a1fb519yac91e4a9053fc26c@mail.gmail.com>
Message-ID: <ca53c8f81002040839h7cd7d6c6m8a8d169f859c4da3@mail.gmail.com>

Would simply returning "temp" instead of flag.get() be atomic for your
purposes ?

    public boolean toggleAndGet() {
        boolean temp;
        do {
            temp = flag.get();
        } while (!flag.compareAndSet(temp, !temp));
        return temp;
    }

Regards,
Hanson

On Thu, Feb 4, 2010 at 7:34 AM, Tim Halloran <hallorant at gmail.com> wrote:

> Hello, hopefully a simple question for everyone. I was surprised to
> discover that AtomicBoolean does not have an atomic "toggle"
> operation.
> Looks like folks use code similar to:
>
>  private AtomicBoolean flag = new AtomicBoolean(true);
>
>  public boolean toggleAndGet() {
>    boolean temp;
>    do {
>      temp = flag.get();
>    } while(!flag.compareAndSet(temp, !temp));
>    return flag.get();
>  }
>
> This doesn't seem all that "atomic" to me, thoughts?? So I cooked up a
> different approach:
>
>  /**
>   * Encoding: even is true; odd is false.
>   */
>  private final AtomicInteger eFlag = new AtomicInteger(0);
>
>  public boolean toggleAndGet() {
>    return toBoolean(eFlag.incrementAndGet());
>  }
>
>  public boolean getValue() {
>    return toBoolean(eFlag.get());
>  }
>
>  private boolean toBoolean(final int value) {
>    return (value & 1) == 0;
>  }
>
> and it appears to work fine on all the tests I cooked up (including
> wraparound).
>
> Well, looking at the implementation of AtomicBoolean, it looks like
> Doug already thought of this idea as the internal representation is
> indeed an "int" not a "boolean".
>
> My question is if "toggleAndGet" could be added to AtomicBoolean using
> the encoding scheme I use, i.e., make even be true and odd be false
> rather than 0 is true and 1 is false as in the current implementation.
> Alternatively, is there a way to implement this method with the
> current encoding?
>
> Hopefully, I'm not missing something really simple here :-)
>
> Best,
> Tim Halloran
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100204/7caf2fef/attachment.html>

From holger.hoffstaette at googlemail.com  Thu Feb  4 12:02:37 2010
From: holger.hoffstaette at googlemail.com (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Thu, 04 Feb 2010 18:02:37 +0100
Subject: [concurrency-interest] backport: Using
 backport-util-concurrent-Java60-3.1 on JRE 1.5.
In-Reply-To: <304E9E55F6A4BE4B910C2437D4D1B4960C07DC19BC@MERCMBX14.na.sas.com>
References: <304E9E55F6A4BE4B910C2437D4D1B4960C07DC1741@MERCMBX14.na.sas.com>
	<4B6AE5F7.1040005@googlemail.com>
	<304E9E55F6A4BE4B910C2437D4D1B4960C07DC19BC@MERCMBX14.na.sas.com>
Message-ID: <4B6AFDAD.1050009@googlemail.com>

Robert Hafner wrote:
> Unfortunately, the JDK 5 backport version does not run on JDK6 due to some changes in JDK classes in Java 6. Some details can be found in this thread:
> 
> http://old.nabble.com/Re:-Java-6-support-in-backport-concurrent-p12141441.html

Yes, you will find that I originally answered in that thread. Bleh..that's
exactly the problem I had in mind but remembered backwards. Sorry for the
confusion.

Anyway I don't see why you are using the backport at all when you deploy
to JDK5 and JDK6. If you want to use JDK6 features (Dequeue, specific
Exector methods etc.) you will either have to stick to JDK5 API, mess with
reflection at runtime or create two separate product releases.

Holger


From holger.hoffstaette at googlemail.com  Thu Feb  4 12:11:14 2010
From: holger.hoffstaette at googlemail.com (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Thu, 04 Feb 2010 18:11:14 +0100
Subject: [concurrency-interest] backport: Using
 backport-util-concurrent-Java60-3.1 on JRE 1.5.
In-Reply-To: <4B6AFDAD.1050009@googlemail.com>
References: <304E9E55F6A4BE4B910C2437D4D1B4960C07DC1741@MERCMBX14.na.sas.com>
	<4B6AE5F7.1040005@googlemail.com>
	<304E9E55F6A4BE4B910C2437D4D1B4960C07DC19BC@MERCMBX14.na.sas.com>
	<4B6AFDAD.1050009@googlemail.com>
Message-ID: <4B6AFFB2.2060305@googlemail.com>

Sorry, forgot something..

Holger Hoffst?tte wrote:
> to JDK5 and JDK6. If you want to use JDK6 features (Dequeue, specific
> Exector methods etc.) you will either have to stick to JDK5 API, mess with
> reflection at runtime or create two separate product releases.

..or use the backport version for JDK 1.4, which works on both JDK5 and
JDK6 - accepting any potential performance hits. Curiously enough,
depending on your app and the deployyment HW the effective performance
might even be better in certain instances. I've seen that several times at
least with JDK6.

hope that helps,
Holger

From Robert.Hafner at sas.com  Thu Feb  4 13:15:03 2010
From: Robert.Hafner at sas.com (Robert Hafner)
Date: Thu, 4 Feb 2010 13:15:03 -0500
Subject: [concurrency-interest] backport: Using
 backport-util-concurrent-Java60-3.1 on JRE 1.5.
In-Reply-To: <4B6AFDAD.1050009@googlemail.com>
References: <304E9E55F6A4BE4B910C2437D4D1B4960C07DC1741@MERCMBX14.na.sas.com>
	<4B6AE5F7.1040005@googlemail.com>
	<304E9E55F6A4BE4B910C2437D4D1B4960C07DC19BC@MERCMBX14.na.sas.com>
	<4B6AFDAD.1050009@googlemail.com>
Message-ID: <304E9E55F6A4BE4B910C2437D4D1B4960C07E4213E@MERCMBX14.na.sas.com>

The reason is some Third Party Jars such as Spring 3.0 and echache 1.6.2 declare a dependency on backport-util-concurrent. Specifically Spring lists a dependency on backport 3.0 and ehcache lists a dependency on 3.1. 

To confirm, the JDK6 version of backport will not run on JDK5. Is that correct?

Assuming that is correct, I believe we have two options.

1) Use the backport version for 1.4 (accepting any performance hits) as you mentioned in another thread.
2) Support multiple codebases (or at least the ability to select the version of backport based upon the JDK/JRE level at config time.)

Regarding option 1, I do not see a 1.4 version of backport listed here: http://sourceforge.net/projects/backport-jsr166/files/backport-jsr166/. I see a 5.0, 6.0, 1.2, and backport-util-concurrent-3.1.zip which doesn't list a JDK version. Is this file the JDK 1.4 version?

Rob




-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Holger Hoffst?tte
Sent: Thursday, February 04, 2010 12:03 PM
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] backport: Using backport-util-concurrent-Java60-3.1 on JRE 1.5.

Robert Hafner wrote:
> Unfortunately, the JDK 5 backport version does not run on JDK6 due to some changes in JDK classes in Java 6. Some details can be found in this thread:
> 
> http://old.nabble.com/Re:-Java-6-support-in-backport-concurrent-p12141441.html

Yes, you will find that I originally answered in that thread. Bleh..that's
exactly the problem I had in mind but remembered backwards. Sorry for the
confusion.

Anyway I don't see why you are using the backport at all when you deploy
to JDK5 and JDK6. If you want to use JDK6 features (Dequeue, specific
Exector methods etc.) you will either have to stick to JDK5 API, mess with
reflection at runtime or create two separate product releases.

Holger

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From holger.hoffstaette at googlemail.com  Thu Feb  4 13:42:20 2010
From: holger.hoffstaette at googlemail.com (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Thu, 04 Feb 2010 19:42:20 +0100
Subject: [concurrency-interest] backport: Using
 backport-util-concurrent-Java60-3.1 on JRE 1.5.
In-Reply-To: <304E9E55F6A4BE4B910C2437D4D1B4960C07E4213E@MERCMBX14.na.sas.com>
References: <304E9E55F6A4BE4B910C2437D4D1B4960C07DC1741@MERCMBX14.na.sas.com>	<4B6AE5F7.1040005@googlemail.com>	<304E9E55F6A4BE4B910C2437D4D1B4960C07DC19BC@MERCMBX14.na.sas.com>
	<4B6AFDAD.1050009@googlemail.com>
	<304E9E55F6A4BE4B910C2437D4D1B4960C07E4213E@MERCMBX14.na.sas.com>
Message-ID: <4B6B150C.2060808@googlemail.com>

Robert Hafner wrote:
> Regarding option 1, I do not see a 1.4 version of backport listed here:
> http://sourceforge.net/projects/backport-jsr166/files/backport-jsr166/.
> I see a 5.0, 6.0, 1.2, and backport-util-concurrent-3.1.zip which
> doesn't list a JDK version. Is this file the JDK 1.4 version?

If I remember correctly the "default" was for 1.4, yes. Only specific
versions were separately named.

Holger


From bryan at systap.com  Mon Feb  8 10:41:04 2010
From: bryan at systap.com (Bryan Thompson)
Date: Mon, 8 Feb 2010 09:41:04 -0600
Subject: [concurrency-interest] CAS spin on modified ConcurrentHashMap?
Message-ID: <DE10B00CCE0DC54883734F3060AC9ED439F4B11D79@AUSP01VMBX06.collaborationhost.net>

Hello,

I am experiencing a problem which appears to be a CAS spin on a modified version on ConcurrentHashMap.  Once the stack gets into this state the thread does not progress.  There is no other thread whose stack involves the same BufferedConcurrentHashMap instance.

Can anyone suggest why the thread would remain in this state?

>>>
>>> "Thread-3" prio=10 tid=0x00002aafec141000 nid=0x41ba runnable [0x0000000040737000]
>>> java.lang.Thread.State: RUNNABLE
>>>      at sun.misc.Unsafe.$$YJP$$compareAndSwapInt(Native Method)
>>>      at sun.misc.Unsafe.compareAndSwapInt(Unsafe.java)
>>>      at java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(AbstractQueuedSynchronizer.java:526)
>>>      at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:183)
>>>      at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:262)
>>>      at org.infinispan.util.concurrent.BufferedConcurrentHashMap$Segment.remove(BufferedConcurrentHashMap.java:745)
>>>      at org.infinispan.util.concurrent.BufferedConcurrentHashMap$Segment$LRU.execute(BufferedConcurrentHashMap.java:832)
>>>      at org.infinispan.util.concurrent.BufferedConcurrentHashMap$Segment.put(BufferedConcurrentHashMap.java:659)
>>>      at org.infinispan.util.concurrent.BufferedConcurrentHashMap.putIfAbsent(BufferedConcurrentHashMap.java:1421)
>>>      at com.bigdata.cache.BCHMGlobalLRU$InnerCacheImpl.putIfAbsent(BCHMGlobalLRU.java:633)
>>>      at com.bigdata.cache.BCHMGlobalLRU$InnerCacheImpl.putIfAbsent(BCHMGlobalLRU.java:557)
>>>      at com.bigdata.btree.AbstractBTree.readNodeOrLeaf(AbstractBTree.java:3624)
>>> 

Thanks,

Bryan


From pmclachlan at gmail.com  Mon Feb  8 11:17:17 2010
From: pmclachlan at gmail.com (Paul McLachlan)
Date: Mon, 8 Feb 2010 08:17:17 -0800
Subject: [concurrency-interest] CAS spin on modified ConcurrentHashMap?
In-Reply-To: <DE10B00CCE0DC54883734F3060AC9ED439F4B11D79@AUSP01VMBX06.collaborationhost.net>
References: <DE10B00CCE0DC54883734F3060AC9ED439F4B11D79@AUSP01VMBX06.collaborationhost.net>
Message-ID: <2bb878aa1002080817w73c3bd91r1b01df27702a8090@mail.gmail.com>

An observation - do you also experience it when not running YourKit?  It has
the CAS instruction instrumented.

- Paul

On Mon, Feb 8, 2010 at 7:41 AM, Bryan Thompson <bryan at systap.com> wrote:

> Hello,
>
> I am experiencing a problem which appears to be a CAS spin on a modified
> version on ConcurrentHashMap.  Once the stack gets into this state the
> thread does not progress.  There is no other thread whose stack involves the
> same BufferedConcurrentHashMap instance.
>
> Can anyone suggest why the thread would remain in this state?
>
> >>>
> >>> "Thread-3" prio=10 tid=0x00002aafec141000 nid=0x41ba runnable
> [0x0000000040737000]
> >>> java.lang.Thread.State: RUNNABLE
> >>>      at sun.misc.Unsafe.$$YJP$$compareAndSwapInt(Native Method)
> >>>      at sun.misc.Unsafe.compareAndSwapInt(Unsafe.java)
> >>>      at
> java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(AbstractQueuedSynchronizer.java:526)
> >>>      at
> java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:183)
> >>>      at
> java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:262)
> >>>      at
> org.infinispan.util.concurrent.BufferedConcurrentHashMap$Segment.remove(BufferedConcurrentHashMap.java:745)
> >>>      at
> org.infinispan.util.concurrent.BufferedConcurrentHashMap$Segment$LRU.execute(BufferedConcurrentHashMap.java:832)
> >>>      at
> org.infinispan.util.concurrent.BufferedConcurrentHashMap$Segment.put(BufferedConcurrentHashMap.java:659)
> >>>      at
> org.infinispan.util.concurrent.BufferedConcurrentHashMap.putIfAbsent(BufferedConcurrentHashMap.java:1421)
> >>>      at
> com.bigdata.cache.BCHMGlobalLRU$InnerCacheImpl.putIfAbsent(BCHMGlobalLRU.java:633)
> >>>      at
> com.bigdata.cache.BCHMGlobalLRU$InnerCacheImpl.putIfAbsent(BCHMGlobalLRU.java:557)
> >>>      at
> com.bigdata.btree.AbstractBTree.readNodeOrLeaf(AbstractBTree.java:3624)
> >>>
>
> Thanks,
>
> Bryan
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100208/293e9759/attachment.html>

From bryan at systap.com  Mon Feb  8 11:52:52 2010
From: bryan at systap.com (Bryan Thompson)
Date: Mon, 8 Feb 2010 10:52:52 -0600
Subject: [concurrency-interest] CAS spin on modified ConcurrentHashMap?
In-Reply-To: <2bb878aa1002080817w73c3bd91r1b01df27702a8090@mail.gmail.com>
References: <DE10B00CCE0DC54883734F3060AC9ED439F4B11D79@AUSP01VMBX06.collaborationhost.net>,
	<2bb878aa1002080817w73c3bd91r1b01df27702a8090@mail.gmail.com>
Message-ID: <DE10B00CCE0DC54883734F3060AC9ED439F4B11D82@AUSP01VMBX06.collaborationhost.net>

Paul,

Thanks for that observation.  I have taken your-kit out.  We also discovered a configuration error for the BufferedConcurrentHashMap as we were using it.  We are still seeing problems for the LRU (vs LIRS) eviction policy.  I will follow up again if the problem appears to be related to the Segment locking.

Thanks,

Bryan
________________________________________
From: Paul McLachlan [pmclachlan at gmail.com]
Sent: Monday, February 08, 2010 11:17 AM
To: Bryan Thompson
Cc: concurrency-interest at cs.oswego.edu; Vladimir Blagojevic
Subject: Re: [concurrency-interest] CAS spin on modified ConcurrentHashMap?

An observation - do you also experience it when not running YourKit?  It has the CAS instruction instrumented.

- Paul

On Mon, Feb 8, 2010 at 7:41 AM, Bryan Thompson <bryan at systap.com<mailto:bryan at systap.com>> wrote:
Hello,

I am experiencing a problem which appears to be a CAS spin on a modified version on ConcurrentHashMap.  Once the stack gets into this state the thread does not progress.  There is no other thread whose stack involves the same BufferedConcurrentHashMap instance.

Can anyone suggest why the thread would remain in this state?

>>>
>>> "Thread-3" prio=10 tid=0x00002aafec141000 nid=0x41ba runnable [0x0000000040737000]
>>> java.lang.Thread.State: RUNNABLE
>>>      at sun.misc.Unsafe.$$YJP$$compareAndSwapInt(Native Method)
>>>      at sun.misc.Unsafe.compareAndSwapInt(Unsafe.java)
>>>      at java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(AbstractQueuedSynchronizer.java:526)
>>>      at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:183)
>>>      at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:262)
>>>      at org.infinispan.util.concurrent.BufferedConcurrentHashMap$Segment.remove(BufferedConcurrentHashMap.java:745)
>>>      at org.infinispan.util.concurrent.BufferedConcurrentHashMap$Segment$LRU.execute(BufferedConcurrentHashMap.java:832)
>>>      at org.infinispan.util.concurrent.BufferedConcurrentHashMap$Segment.put(BufferedConcurrentHashMap.java:659)
>>>      at org.infinispan.util.concurrent.BufferedConcurrentHashMap.putIfAbsent(BufferedConcurrentHashMap.java:1421)
>>>      at com.bigdata.cache.BCHMGlobalLRU$InnerCacheImpl.putIfAbsent(BCHMGlobalLRU.java:633)
>>>      at com.bigdata.cache.BCHMGlobalLRU$InnerCacheImpl.putIfAbsent(BCHMGlobalLRU.java:557)
>>>      at com.bigdata.btree.AbstractBTree.readNodeOrLeaf(AbstractBTree.java:3624)
>>>

Thanks,

Bryan

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From alarmnummer at gmail.com  Mon Feb  8 16:57:41 2010
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 8 Feb 2010 22:57:41 +0100
Subject: [concurrency-interest] Cas contention
Message-ID: <43EB8D1A-9D03-4BE0-8D66-2A5513B2AE7A@gmail.com>

Hi guys

I have a question about contention on cas structures in Java (e.g. the  
atomiclong)

I'm using a single shared atomiclong as central clock in my stm  
implementation. Although doing millions of increases per second is no  
issue, eventually this is going to be a scalability bottleneck. One of  
the future goals is to get rid of this clock, but for time being it  
has to do.

One of the workarounds is to use partitions (each transactional object  
belongs to 1 partition) and give each partition his own clock. This  
means that in theory there is less contention on the clock (of course  
you need to deal with partition crossing)

My big question is if doubling the number of clocks and splitting  
ticks per clock by half, is going to reduce the stress on the memory  
bus since the number of cas instructions remains the same.


From martinrb at google.com  Tue Feb  9 00:26:33 2010
From: martinrb at google.com (Martin Buchholz)
Date: Mon, 8 Feb 2010 21:26:33 -0800
Subject: [concurrency-interest] Cas contention
In-Reply-To: <43EB8D1A-9D03-4BE0-8D66-2A5513B2AE7A@gmail.com>
References: <43EB8D1A-9D03-4BE0-8D66-2A5513B2AE7A@gmail.com>
Message-ID: <1ccfd1c11002082126l61b61200rf24c5aff75c9c3d9@mail.gmail.com>

You could try meditating on chapter 12 of the Art of Multiprocessor Programming.

Martin

On Mon, Feb 8, 2010 at 13:57, Peter Veentjer <alarmnummer at gmail.com> wrote:
> Hi guys
>
> I have a question about contention on cas structures in Java (e.g. the
> atomiclong)
>
> I'm using a single shared atomiclong as central clock in my stm
> implementation. Although doing millions of increases per second is no issue,
> eventually this is going to be a scalability bottleneck. One of the future
> goals is to get rid of this clock, but for time being it has to do.
>
> One of the workarounds is to use partitions (each transactional object
> belongs to 1 partition) and give each partition his own clock. This means
> that in theory there is less contention on the clock (of course you need to
> deal with partition crossing)
>
> My big question is if doubling the number of clocks and splitting ticks per
> clock by half, is going to reduce the stress on the memory bus since the
> number of cas instructions remains the same.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From ben_manes at yahoo.com  Tue Feb  9 01:47:02 2010
From: ben_manes at yahoo.com (Ben Manes)
Date: Mon, 8 Feb 2010 22:47:02 -0800 (PST)
Subject: [concurrency-interest] Cas contention
In-Reply-To: <43EB8D1A-9D03-4BE0-8D66-2A5513B2AE7A@gmail.com>
References: <43EB8D1A-9D03-4BE0-8D66-2A5513B2AE7A@gmail.com>
Message-ID: <87135.46940.qm@web38805.mail.mud.yahoo.com>

If the clocks are stored on different NUMA nodes, then shouldn't this reduce the stress on any individual memory bank?




________________________________
From: Peter Veentjer <alarmnummer at gmail.com>
To: concurrency-interest at cs.oswego.edu
Sent: Mon, February 8, 2010 1:57:41 PM
Subject: [concurrency-interest] Cas contention

Hi guys

I have a question about contention on cas structures in Java (e.g. the atomiclong)

I'm using a single shared atomiclong as central clock in my stm implementation. Although doing millions of increases per second is no issue, eventually this is going to be a scalability bottleneck. One of the future goals is to get rid of this clock, but for time being it has to do.

One of the workarounds is to use partitions (each transactional object belongs to 1 partition) and give each partition his own clock. This means that in theory there is less contention on the clock (of course you need to deal with partition crossing)

My big question is if doubling the number of clocks and splitting ticks per clock by half, is going to reduce the stress on the memory bus since the number of cas instructions remains the same.

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



      
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100208/dfde64f0/attachment.html>

From gkorland at gmail.com  Tue Feb  9 06:11:02 2010
From: gkorland at gmail.com (Guy Korland)
Date: Tue, 9 Feb 2010 13:11:02 +0200
Subject: [concurrency-interest] ConcurrentSkipListMap firstKey() after
	remove() bug?
Message-ID: <79be5fa31002090311i20142023t5e9026609df55220@mail.gmail.com>

Hi,

We see a very strange behavior, we use a ConcurrentSkipListMap and run the
following:

loop:

Object key = m.firstKey()

Object o = m.remove(key)


It seems that from time to time (on a very rare occasion) the firstKey()
returns a key while the following remove returns null.
Then again the firstKey returns the same key while the remove returns null.

1. There should be a value.
2. In this stage there are no concurrent updates on the Map.
3. It can keeps like this forever.

Any ideas?

Thanks,
Guy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100209/b72c53fa/attachment.html>

From i30817 at gmail.com  Tue Feb  9 08:51:40 2010
From: i30817 at gmail.com (Paulo Levi)
Date: Tue, 9 Feb 2010 13:51:40 +0000
Subject: [concurrency-interest] URL connection and threadpoolexecutor
Message-ID: <212322091002090551r1432fd0dv26ad48d851e4fde3@mail.gmail.com>

Hi. I'm sure most of you know that the HttpURLConnection can appear to hang
a thread in ThreadPools because the sockets don't respond to interrupts.

I found 3 "solutions" for this:
1) to set the default timeout values to a lower time, but still enough to
reach the resource.
2) Thread stop()
3) If the resource is contended or it is unknown the response time, or i
need promptness for the execution (for example on termination task
cancellation), use a complicated scheme:
3a) subclass ThreadPoolExecutor, implement a cancellablecallable and save
the instances executed in a threadsafe collection, so on shutdown the cancel
method can be called. In the tasks that use URL save every instanciated
URLConnection into a volatile field that is disconnected in the cancel
method.

3 seems like a awful lot of work for prompt, but not error prone
cancellation. Shouldn't the threadpoolexecutor handle a special subclass of
callable like this already?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100209/98803337/attachment.html>

From martinrb at google.com  Tue Feb  9 09:37:37 2010
From: martinrb at google.com (Martin Buchholz)
Date: Tue, 9 Feb 2010 06:37:37 -0800
Subject: [concurrency-interest] ConcurrentSkipListMap firstKey() after
	remove() bug?
In-Reply-To: <79be5fa31002090311i20142023t5e9026609df55220@mail.gmail.com>
References: <79be5fa31002090311i20142023t5e9026609df55220@mail.gmail.com>
Message-ID: <1ccfd1c11002090637u31206f39m38ed92fc4e4aaccd@mail.gmail.com>

Looks like a bug.
If you've found a bug in ConcurrentSkipListMap,
we'd like to know about it and fix it.
As ever, we'd need to see a small test that can reproduce it.

The other possibility is that there is a bug in the keys
inserted in the map, e.g. the comparator might not be
consistent with equals.

Martin

On Tue, Feb 9, 2010 at 03:11, Guy Korland <gkorland at gmail.com> wrote:
> Hi,
> We see a very strange?behavior, we use a ConcurrentSkipListMap and run the
> following:
> loop:
>
> Object key = m.firstKey()
>
> Object o = m.remove(key)
>
> It seems that from time to time (on a very rare occasion) the firstKey()
> returns a key while the following remove returns null.
> Then again the?firstKey returns the same key while the remove returns null.
> 1. There should be a value.
> 2. In this stage there are no?concurrent updates on the Map.
> 3. It can keeps like this forever.
> Any ideas?
> Thanks,
> Guy
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From gkorland at gmail.com  Tue Feb  9 09:56:22 2010
From: gkorland at gmail.com (Guy Korland)
Date: Tue, 9 Feb 2010 16:56:22 +0200
Subject: [concurrency-interest] ConcurrentSkipListMap firstKey() after
	remove() bug?
In-Reply-To: <1ccfd1c11002090637u31206f39m38ed92fc4e4aaccd@mail.gmail.com>
References: <79be5fa31002090311i20142023t5e9026609df55220@mail.gmail.com>
	<1ccfd1c11002090637u31206f39m38ed92fc4e4aaccd@mail.gmail.com>
Message-ID: <79be5fa31002090656q2123ba9cna66e760491481027@mail.gmail.com>

Hi,

Ok, I think we have an idea, I would like to hear you opinion on this.

We have a place in the code that does the following:
Object k = map.reomve(key);
*key.prop = x;*
*map.put(key, k);
*

The key.prop is being consider as part of the compareTo(), can it be that
because of the lazy nature to the remove() it might break the order in
the ConcurrentSkipListMap?

Regards,
Guy Korland


On Tue, Feb 9, 2010 at 4:37 PM, Martin Buchholz <martinrb at google.com> wrote:

> Looks like a bug.
> If you've found a bug in ConcurrentSkipListMap,
> we'd like to know about it and fix it.
> As ever, we'd need to see a small test that can reproduce it.
>
> The other possibility is that there is a bug in the keys
> inserted in the map, e.g. the comparator might not be
> consistent with equals.
>
> Martin
>
> On Tue, Feb 9, 2010 at 03:11, Guy Korland <gkorland at gmail.com> wrote:
> > Hi,
> > We see a very strange behavior, we use a ConcurrentSkipListMap and run
> the
> > following:
> > loop:
> >
> > Object key = m.firstKey()
> >
> > Object o = m.remove(key)
> >
> > It seems that from time to time (on a very rare occasion) the firstKey()
> > returns a key while the following remove returns null.
> > Then again the firstKey returns the same key while the remove returns
> null.
> > 1. There should be a value.
> > 2. In this stage there are no concurrent updates on the Map.
> > 3. It can keeps like this forever.
> > Any ideas?
> > Thanks,
> > Guy
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100209/5e204504/attachment-0001.html>

From martinrb at google.com  Tue Feb  9 11:24:15 2010
From: martinrb at google.com (Martin Buchholz)
Date: Tue, 9 Feb 2010 08:24:15 -0800
Subject: [concurrency-interest] ConcurrentSkipListMap firstKey() after
	remove() bug?
In-Reply-To: <79be5fa31002090656q2123ba9cna66e760491481027@mail.gmail.com>
References: <79be5fa31002090311i20142023t5e9026609df55220@mail.gmail.com>
	<1ccfd1c11002090637u31206f39m38ed92fc4e4aaccd@mail.gmail.com>
	<79be5fa31002090656q2123ba9cna66e760491481027@mail.gmail.com>
Message-ID: <1ccfd1c11002090824j9d202bbu201e1926212443d@mail.gmail.com>

On Tue, Feb 9, 2010 at 06:56, Guy Korland <gkorland at gmail.com> wrote:
> Hi,
> Ok, I think we have an idea, I would like to hear you opinion on this.
> We have a place in the code that does the following:
> Object k = map.reomve(key);
> key.prop = x;
> map.put(key, k);
>
> The key.prop is being consider as part of the compareTo(), can it be that
> because of the lazy nature to the remove() it might break the order in
> the?ConcurrentSkipListMap?

It seems unlikely to me that a "ghost" of the key
would linger in the map after it had been removed.

More likely to me is that two different threads would
be manipulating the same key, and that when

key.prop = x;

happens, key is actually in the map.

Martin


From gkorland at gmail.com  Tue Feb  9 13:18:25 2010
From: gkorland at gmail.com (Guy Korland)
Date: Tue, 9 Feb 2010 20:18:25 +0200
Subject: [concurrency-interest] ConcurrentSkipListMap firstKey() after
	remove() bug?
In-Reply-To: <1ccfd1c11002090824j9d202bbu201e1926212443d@mail.gmail.com>
References: <79be5fa31002090311i20142023t5e9026609df55220@mail.gmail.com>
	<1ccfd1c11002090637u31206f39m38ed92fc4e4aaccd@mail.gmail.com>
	<79be5fa31002090656q2123ba9cna66e760491481027@mail.gmail.com>
	<1ccfd1c11002090824j9d202bbu201e1926212443d@mail.gmail.com>
Message-ID: <79be5fa31002091018v1ae96958y10e15e36570c79c4@mail.gmail.com>

"It seems unlikely"
Does it mean it can't be? As I understand from the code it seems like
there's a path that might leave the key in the SkipList.
What will happen if in parallel another key is put, does it compare to the
"ghost" key?
If it does and this key is manipulated by the first thread than the
comparison will be faulty, and the new key will get to a wrong place in the
SkipList.

Regards,
Guy


On Tue, Feb 9, 2010 at 6:24 PM, Martin Buchholz <martinrb at google.com> wrote:

> On Tue, Feb 9, 2010 at 06:56, Guy Korland <gkorland at gmail.com> wrote:
> > Hi,
> > Ok, I think we have an idea, I would like to hear you opinion on this.
> > We have a place in the code that does the following:
> > Object k = map.reomve(key);
> > key.prop = x;
> > map.put(key, k);
> >
> > The key.prop is being consider as part of the compareTo(), can it be that
> > because of the lazy nature to the remove() it might break the order in
> > the ConcurrentSkipListMap?
>
> It seems unlikely to me that a "ghost" of the key
> would linger in the map after it had been removed.
>
> More likely to me is that two different threads would
> be manipulating the same key, and that when
>
> key.prop = x;
>
> happens, key is actually in the map.
>
> Martin
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100209/51a92a30/attachment.html>

From martinrb at google.com  Tue Feb  9 15:54:47 2010
From: martinrb at google.com (Martin Buchholz)
Date: Tue, 9 Feb 2010 12:54:47 -0800
Subject: [concurrency-interest] ConcurrentSkipListMap firstKey() after
	remove() bug?
In-Reply-To: <79be5fa31002091018v1ae96958y10e15e36570c79c4@mail.gmail.com>
References: <79be5fa31002090311i20142023t5e9026609df55220@mail.gmail.com>
	<1ccfd1c11002090637u31206f39m38ed92fc4e4aaccd@mail.gmail.com>
	<79be5fa31002090656q2123ba9cna66e760491481027@mail.gmail.com>
	<1ccfd1c11002090824j9d202bbu201e1926212443d@mail.gmail.com>
	<79be5fa31002091018v1ae96958y10e15e36570c79c4@mail.gmail.com>
Message-ID: <1ccfd1c11002091254i1f359d38p1c760544bda7ade8@mail.gmail.com>

On Tue, Feb 9, 2010 at 10:18, Guy Korland <gkorland at gmail.com> wrote:
> "It seems unlikely"

Unlikely because no one has ever noticed such behavior before.
ConcurrentSkipListMap has probably had less review
(and perhaps fewer users?) than other parts of j.u.c.

> Does it mean it can't be? As I understand from the code it seems like
> there's a path that might leave the key in the SkipList.

Please point us at the code that you think might be buggy.

Martin

> What will happen if in?parallel?another key is put, does it compare to the
> "ghost" key?
> If it does and this key is manipulated by the first thread than the
> comparison will be faulty, and the new key will get to a wrong place in the
> SkipList.
> Regards,
> Guy
>
>
> On Tue, Feb 9, 2010 at 6:24 PM, Martin Buchholz <martinrb at google.com> wrote:
>>
>> On Tue, Feb 9, 2010 at 06:56, Guy Korland <gkorland at gmail.com> wrote:
>> > Hi,
>> > Ok, I think we have an idea, I would like to hear you opinion on this.
>> > We have a place in the code that does the following:
>> > Object k = map.reomve(key);
>> > key.prop = x;
>> > map.put(key, k);
>> >
>> > The key.prop is being consider as part of the compareTo(), can it be
>> > that
>> > because of the lazy nature to the remove() it might break the order in
>> > the?ConcurrentSkipListMap?
>>
>> It seems unlikely to me that a "ghost" of the key
>> would linger in the map after it had been removed.
>>
>> More likely to me is that two different threads would
>> be manipulating the same key, and that when
>>
>> key.prop = x;
>>
>> happens, key is actually in the map.
>>
>> Martin
>
>


From bryan at systap.com  Tue Feb  9 18:23:47 2010
From: bryan at systap.com (Bryan Thompson)
Date: Tue, 9 Feb 2010 17:23:47 -0600
Subject: [concurrency-interest] Cas contention
In-Reply-To: <87135.46940.qm@web38805.mail.mud.yahoo.com>
References: <43EB8D1A-9D03-4BE0-8D66-2A5513B2AE7A@gmail.com>
	<87135.46940.qm@web38805.mail.mud.yahoo.com>
Message-ID: <DE10B00CCE0DC54883734F3060AC9ED439F57E05EA@AUSP01VMBX06.collaborationhost.net>

Peter,

I had an AtomicLong that was a performance counter for B+Tree lookup operations.  On B+Tree instances with concurrent readers, this flared into a major hot spot -- the single largest hot spot by far.  Basically, the threads were spinning on the CAS and racing with each other to get a consistent atomic increment of the counter value.  So, no, AtomicLong.incrementAndGet() is not a good choice with many threads.

We simply gave up these performance counters for concurrent read operations.  However, in a different section of the system we do need to keep counters which are hot for concurrent operations.  There we are planning to use either thread-local or stripped counter sets which are periodically combined, basically batching the updates through a lock every N times through the relevant operation.

Bryan

________________________________
From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Ben Manes
Sent: Tuesday, February 09, 2010 1:47 AM
To: Peter Veentjer; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Cas contention

If the clocks are stored on different NUMA nodes, then shouldn't this reduce the stress on any individual memory bank?

________________________________
From: Peter Veentjer <alarmnummer at gmail.com>
To: concurrency-interest at cs.oswego.edu
Sent: Mon, February 8, 2010 1:57:41 PM
Subject: [concurrency-interest] Cas contention

Hi guys

I have a question about contention on cas structures in Java (e.g. the atomiclong)

I'm using a single shared atomiclong as central clock in my stm implementation. Although doing millions of increases per second is no issue, eventually this is going to be a scalability bottleneck. One of the future goals is to get rid of this clock, but for time being it has to do.

One of the workarounds is to use partitions (each transactional object belongs to 1 partition) and give each partition his own clock. This means that in theory there is less contention on the clock (of course you need to deal with partition crossing)

My big question is if doubling the number of clocks and splitting ticks per clock by half, is going to reduce the stress on the memory bus since the number of cas instructions remains the same.

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100209/41db1a99/attachment.html>

From bryan at systap.com  Tue Feb  9 19:38:31 2010
From: bryan at systap.com (Bryan Thompson)
Date: Tue, 9 Feb 2010 18:38:31 -0600
Subject: [concurrency-interest] Cas contention
In-Reply-To: <DE10B00CCE0DC54883734F3060AC9ED439F57E05EA@AUSP01VMBX06.collaborationhost.net>
References: <43EB8D1A-9D03-4BE0-8D66-2A5513B2AE7A@gmail.com>
	<87135.46940.qm@web38805.mail.mud.yahoo.com>
	<DE10B00CCE0DC54883734F3060AC9ED439F57E05EA@AUSP01VMBX06.collaborationhost.net>
Message-ID: <DE10B00CCE0DC54883734F3060AC9ED439F57E0635@AUSP01VMBX06.collaborationhost.net>

Let me follow up on my own post and say that this hotspot was as observed under a profiler using sampling.  I know that profilers can overreport the time in methods when sampling.  I do not have information correlating the actual runtime performance hit.  We simply took out the AtomicLong.incrementAndGet() in that instance as it was not producing critical information and was making it difficult to see what other hot spots there were in the code.

Bryan

________________________________
From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Bryan Thompson
Sent: Tuesday, February 09, 2010 6:24 PM
To: Ben Manes; Peter Veentjer; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Cas contention

Peter,

I had an AtomicLong that was a performance counter for B+Tree lookup operations.  On B+Tree instances with concurrent readers, this flared into a major hot spot -- the single largest hot spot by far.  Basically, the threads were spinning on the CAS and racing with each other to get a consistent atomic increment of the counter value.  So, no, AtomicLong.incrementAndGet() is not a good choice with many threads.

We simply gave up these performance counters for concurrent read operations.  However, in a different section of the system we do need to keep counters which are hot for concurrent operations.  There we are planning to use either thread-local or stripped counter sets which are periodically combined, basically batching the updates through a lock every N times through the relevant operation.

Bryan

________________________________
From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Ben Manes
Sent: Tuesday, February 09, 2010 1:47 AM
To: Peter Veentjer; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Cas contention

If the clocks are stored on different NUMA nodes, then shouldn't this reduce the stress on any individual memory bank?

________________________________
From: Peter Veentjer <alarmnummer at gmail.com>
To: concurrency-interest at cs.oswego.edu
Sent: Mon, February 8, 2010 1:57:41 PM
Subject: [concurrency-interest] Cas contention

Hi guys

I have a question about contention on cas structures in Java (e.g. the atomiclong)

I'm using a single shared atomiclong as central clock in my stm implementation. Although doing millions of increases per second is no issue, eventually this is going to be a scalability bottleneck. One of the future goals is to get rid of this clock, but for time being it has to do.

One of the workarounds is to use partitions (each transactional object belongs to 1 partition) and give each partition his own clock. This means that in theory there is less contention on the clock (of course you need to deal with partition crossing)

My big question is if doubling the number of clocks and splitting ticks per clock by half, is going to reduce the stress on the memory bus since the number of cas instructions remains the same.

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100209/f5a9813c/attachment-0001.html>

From joe.bowbeer at gmail.com  Tue Feb  9 21:35:29 2010
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 9 Feb 2010 18:35:29 -0800
Subject: [concurrency-interest] ConcurrentSkipListMap firstKey() after
	remove() bug?
In-Reply-To: <79be5fa31002090656q2123ba9cna66e760491481027@mail.gmail.com>
References: <79be5fa31002090311i20142023t5e9026609df55220@mail.gmail.com>
	<1ccfd1c11002090637u31206f39m38ed92fc4e4aaccd@mail.gmail.com>
	<79be5fa31002090656q2123ba9cna66e760491481027@mail.gmail.com>
Message-ID: <31f2a7bd1002091835o44760d09rb18d84d5b9485cb@mail.gmail.com>

On Tue, Feb 9, 2010 at 6:56 AM, Guy Korland wrote:

> Hi,
>
> Ok, I think we have an idea, I would like to hear you opinion on this.
>
> We have a place in the code that does the following:
> Object k = map.remove(key);
> *key.prop = x;*
> *map.put(key, k);
> *
>
> The key.prop is being consider as part of the compareTo(), can it be that
> because of the lazy nature to the remove() it might break the order in
> the ConcurrentSkipListMap?
>
> Regards,
> Guy Korland
>


That does sounds like trouble.

After key.prop = x, the dead node is hidden somewhere in the skip list, so
that it may not be unlinked by the subsequent put operation, and other
properties of the skip list may be broken as well.

Aside: To remove the first entry from the map, why not use pollFirstEntry?

Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100209/187b55d4/attachment.html>

From jed at atlassian.com  Wed Feb 10 21:10:01 2010
From: jed at atlassian.com (Jed Wesley-Smith)
Date: Thu, 11 Feb 2010 13:10:01 +1100
Subject: [concurrency-interest] ConcurrentSkipListMap firstKey() after
 remove() bug?
In-Reply-To: <79be5fa31002090656q2123ba9cna66e760491481027@mail.gmail.com>
References: <79be5fa31002090311i20142023t5e9026609df55220@mail.gmail.com>	<1ccfd1c11002090637u31206f39m38ed92fc4e4aaccd@mail.gmail.com>
	<79be5fa31002090656q2123ba9cna66e760491481027@mail.gmail.com>
Message-ID: <4B7366F9.2090805@atlassian.com>

If you have mutable keys are you absolutely sure no-one else is updating 
the key while it is in the map? Mutable keys are an endless source of 
trouble, I can reproduce the behaviour you see here with a HashMap if I 
update the key after putting it in the map. You should also be aware of 
things like safe-publication etc.

As you state, the CSLM would probably have a deletion marker with the 
newly updated key reference ? I would hate to think how complicated the 
design would need to be to cope with that kind of issue.

I would generally consider using mutable keys in any sort of map a 
programming error.

cheers,
jed.

Guy Korland wrote:
> Hi,
>
> Ok, I think we have an idea, I would like to hear you opinion on this.
>
> We have a place in the code that does the following:
> Object k = map.reomve(key);
> *key.prop = x;*
> *map.put(key, k);
> *
>
> The key.prop is being consider as part of the compareTo(), can it be 
> that because of the lazy nature to the remove() it might break the 
> order in the ConcurrentSkipListMap?
>
> Regards,
> Guy Korland
>
>
> On Tue, Feb 9, 2010 at 4:37 PM, Martin Buchholz <martinrb at google.com 
> <mailto:martinrb at google.com>> wrote:
>
>     Looks like a bug.
>     If you've found a bug in ConcurrentSkipListMap,
>     we'd like to know about it and fix it.
>     As ever, we'd need to see a small test that can reproduce it.
>
>     The other possibility is that there is a bug in the keys
>     inserted in the map, e.g. the comparator might not be
>     consistent with equals.
>
>     Martin
>
>     On Tue, Feb 9, 2010 at 03:11, Guy Korland <gkorland at gmail.com
>     <mailto:gkorland at gmail.com>> wrote:
>     > Hi,
>     > We see a very strange behavior, we use a ConcurrentSkipListMap
>     and run the
>     > following:
>     > loop:
>     >
>     > Object key = m.firstKey()
>     >
>     > Object o = m.remove(key)
>     >
>     > It seems that from time to time (on a very rare occasion) the
>     firstKey()
>     > returns a key while the following remove returns null.
>     > Then again the firstKey returns the same key while the remove
>     returns null.
>     > 1. There should be a value.
>     > 2. In this stage there are no concurrent updates on the Map.
>     > 3. It can keeps like this forever.
>     > Any ideas?
>     > Thanks,
>     > Guy
>     >
>


From martinrb at google.com  Wed Feb 10 23:21:50 2010
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 10 Feb 2010 20:21:50 -0800
Subject: [concurrency-interest] ConcurrentSkipListMap firstKey() after
	remove() bug?
In-Reply-To: <31f2a7bd1002091835o44760d09rb18d84d5b9485cb@mail.gmail.com>
References: <79be5fa31002090311i20142023t5e9026609df55220@mail.gmail.com>
	<1ccfd1c11002090637u31206f39m38ed92fc4e4aaccd@mail.gmail.com>
	<79be5fa31002090656q2123ba9cna66e760491481027@mail.gmail.com>
	<31f2a7bd1002091835o44760d09rb18d84d5b9485cb@mail.gmail.com>
Message-ID: <1ccfd1c11002102021i11bf13e9yf12a8857d3ce8330@mail.gmail.com>

CSLM needs to invoke comparison operations on the keys in the map.
Given the absence of locks, there is no way to prevent the key from being
concurrently removed while the comparison operation is in progress.
Subsequent concurrent updates to the key might make the comparison
operation fail in arbitrary ways, perhaps throwing an exception.

Perhaps it is too difficult to support mutable keys in CSLM?
Should the javadoc require that key comparison be always valid
and consistent, even after the key has been removed?

Should there be a check after each key comparison to check
that the nodes have not been concurrently deleted?

Martin

On Tue, Feb 9, 2010 at 18:35, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> That does sounds like trouble.
>
> After key.prop = x, the dead node is hidden somewhere in the skip list, so
> that it may not be unlinked by the subsequent put operation, and other
> properties of the skip list may be broken as well.

From gkorland at gmail.com  Thu Feb 11 01:58:38 2010
From: gkorland at gmail.com (Guy Korland)
Date: Thu, 11 Feb 2010 08:58:38 +0200
Subject: [concurrency-interest] ConcurrentSkipListMap firstKey() after
	remove() bug?
In-Reply-To: <4B7366F9.2090805@atlassian.com>
References: <79be5fa31002090311i20142023t5e9026609df55220@mail.gmail.com> 
	<1ccfd1c11002090637u31206f39m38ed92fc4e4aaccd@mail.gmail.com> 
	<79be5fa31002090656q2123ba9cna66e760491481027@mail.gmail.com> 
	<4B7366F9.2090805@atlassian.com>
Message-ID: <79be5fa31002102258h72f73afek27cf54b3e28b7175@mail.gmail.com>

I already replaced it with an immutable key, I just wanted to make sure that
if this is a possible scenario.

Regards,
Guy Korland


On Thu, Feb 11, 2010 at 4:10 AM, Jed Wesley-Smith <jed at atlassian.com> wrote:

> If you have mutable keys are you absolutely sure no-one else is updating
> the key while it is in the map? Mutable keys are an endless source of
> trouble, I can reproduce the behaviour you see here with a HashMap if I
> update the key after putting it in the map. You should also be aware of
> things like safe-publication etc.
>
> As you state, the CSLM would probably have a deletion marker with the newly
> updated key reference ? I would hate to think how complicated the design
> would need to be to cope with that kind of issue.
>
> I would generally consider using mutable keys in any sort of map a
> programming error.
>
> cheers,
> jed.
>
> Guy Korland wrote:
>
>> Hi,
>>
>> Ok, I think we have an idea, I would like to hear you opinion on this.
>>
>> We have a place in the code that does the following:
>> Object k = map.reomve(key);
>> *key.prop = x;*
>> *map.put(key, k);
>> *
>>
>> The key.prop is being consider as part of the compareTo(), can it be that
>> because of the lazy nature to the remove() it might break the order in the
>> ConcurrentSkipListMap?
>>
>> Regards,
>> Guy Korland
>>
>>
>> On Tue, Feb 9, 2010 at 4:37 PM, Martin Buchholz <martinrb at google.com<mailto:
>> martinrb at google.com>> wrote:
>>
>>    Looks like a bug.
>>    If you've found a bug in ConcurrentSkipListMap,
>>    we'd like to know about it and fix it.
>>    As ever, we'd need to see a small test that can reproduce it.
>>
>>    The other possibility is that there is a bug in the keys
>>    inserted in the map, e.g. the comparator might not be
>>    consistent with equals.
>>
>>    Martin
>>
>>    On Tue, Feb 9, 2010 at 03:11, Guy Korland <gkorland at gmail.com
>>    <mailto:gkorland at gmail.com>> wrote:
>>    > Hi,
>>    > We see a very strange behavior, we use a ConcurrentSkipListMap
>>    and run the
>>    > following:
>>    > loop:
>>    >
>>    > Object key = m.firstKey()
>>    >
>>    > Object o = m.remove(key)
>>    >
>>    > It seems that from time to time (on a very rare occasion) the
>>    firstKey()
>>    > returns a key while the following remove returns null.
>>    > Then again the firstKey returns the same key while the remove
>>    returns null.
>>    > 1. There should be a value.
>>    > 2. In this stage there are no concurrent updates on the Map.
>>    > 3. It can keeps like this forever.
>>    > Any ideas?
>>    > Thanks,
>>    > Guy
>>    >
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100211/26843c35/attachment.html>

From dmdabbs at gmail.com  Thu Feb 11 13:35:11 2010
From: dmdabbs at gmail.com (David Dabbs)
Date: Thu, 11 Feb 2010 12:35:11 -0600
Subject: [concurrency-interest] CVS src/jsr166x vs
	src/main/java/util/concurrent
In-Reply-To: <mailman.1800.1265912764.2997.concurrency-interest@cs.oswego.edu>
References: <mailman.1800.1265912764.2997.concurrency-interest@cs.oswego.edu>
Message-ID: <001301caab48$f2f15e20$d8d41a60$@com>


Today I checked out the jsr166 source tree. It appears that the jsr166x
files are 
present in src/main/java/util/concurrent but are out-of-date w.r.t the
versions in 
/src/jsr166x. 

FWIW the /src/jsr166y files seem to be in sync. Should I consider the
/src/jsr166x files authoritative
and copy to /src/main...?

Thanks,

David Dabbs



From martinrb at google.com  Thu Feb 11 15:04:05 2010
From: martinrb at google.com (Martin Buchholz)
Date: Thu, 11 Feb 2010 12:04:05 -0800
Subject: [concurrency-interest] CVS src/jsr166x vs
	src/main/java/util/concurrent
In-Reply-To: <001301caab48$f2f15e20$d8d41a60$@com>
References: <mailman.1800.1265912764.2997.concurrency-interest@cs.oswego.edu>
	<001301caab48$f2f15e20$d8d41a60$@com>
Message-ID: <1ccfd1c11002111204j5e468f44xe269ad63bd6465f@mail.gmail.com>

Doug and I have agreed in principle that jsr166x should be
sync'ed up with the sources in src/main,
but it has not yet been done.
There is work in progress to make that happen.

For now src/main is authoritative,
and is kept in sync with the corresponding
files in openjdk6 and openjdk7.

(But of course, the files in src/main are in the wrong package
for use with older jdks, and will need other changes to work with
say, jdk5)

Martin

On Thu, Feb 11, 2010 at 10:35, David Dabbs <dmdabbs at gmail.com> wrote:
>
> Today I checked out the jsr166 source tree. It appears that the jsr166x
> files are
> present in src/main/java/util/concurrent but are out-of-date w.r.t the
> versions in
> /src/jsr166x.
>
> FWIW the /src/jsr166y files seem to be in sync. Should I consider the
> /src/jsr166x files authoritative
> and copy to /src/main...?
>
> Thanks,
>
> David Dabbs
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dmdabbs at gmail.com  Thu Feb 11 17:54:00 2010
From: dmdabbs at gmail.com (David Dabbs)
Date: Thu, 11 Feb 2010 16:54:00 -0600
Subject: [concurrency-interest] CVS src/jsr166x vs
	src/main/java/util/concurrent
In-Reply-To: <1ccfd1c11002111204j5e468f44xe269ad63bd6465f@mail.gmail.com>
References: <mailman.1800.1265912764.2997.concurrency-interest@cs.oswego.edu>
	<001301caab48$f2f15e20$d8d41a60$@com>
	<1ccfd1c11002111204j5e468f44xe269ad63bd6465f@mail.gmail.com>
Message-ID: <000001caab6d$1afa0ba0$50ee22e0$@com>

Thank you for the prompt answer and for the caveat re. older jdks. 
I'm strictly interested in running the jsr166 code in the bootclasspath with
J2SE 6/7. 

David


-----Original Message-----
From: Martin Buchholz [mailto:martinrb at google.com] 
Sent: Thursday, February 11, 2010 2:04 PM
To: David Dabbs
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] CVS src/jsr166x vs
src/main/java/util/concurrent

Doug and I have agreed in principle that jsr166x should be
sync'ed up with the sources in src/main,
but it has not yet been done.
There is work in progress to make that happen.

For now src/main is authoritative,
and is kept in sync with the corresponding
files in openjdk6 and openjdk7.

(But of course, the files in src/main are in the wrong package
for use with older jdks, and will need other changes to work with
say, jdk5)

Martin

On Thu, Feb 11, 2010 at 10:35, David Dabbs <dmdabbs at gmail.com> wrote:
>
> Today I checked out the jsr166 source tree. It appears that the jsr166x
> files are
> present in src/main/java/util/concurrent but are out-of-date w.r.t the
> versions in
> /src/jsr166x.
>
> FWIW the /src/jsr166y files seem to be in sync. Should I consider the
> /src/jsr166x files authoritative
> and copy to /src/main...?
>
> Thanks,
>
> David Dabbs
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From martinrb at google.com  Thu Feb 11 18:54:09 2010
From: martinrb at google.com (Martin Buchholz)
Date: Thu, 11 Feb 2010 15:54:09 -0800
Subject: [concurrency-interest] CVS src/jsr166x vs
	src/main/java/util/concurrent
In-Reply-To: <000001caab6d$1afa0ba0$50ee22e0$@com>
References: <mailman.1800.1265912764.2997.concurrency-interest@cs.oswego.edu>
	<001301caab48$f2f15e20$d8d41a60$@com>
	<1ccfd1c11002111204j5e468f44xe269ad63bd6465f@mail.gmail.com>
	<000001caab6d$1afa0ba0$50ee22e0$@com>
Message-ID: <1ccfd1c11002111554w77a0f44es7a952c84347cb9bc@mail.gmail.com>

On Thu, Feb 11, 2010 at 14:54, David Dabbs <dmdabbs at gmail.com> wrote:
> Thank you for the prompt answer and for the caveat re. older jdks.
> I'm strictly interested in running the jsr166 code in the bootclasspath with
> J2SE 6/7.

Everything in jsr166x should be included in standard java se 6+
(except for ConcurrentLinkedDeque, which I happen to care about a lot,
but you probably do not)
so there should be no need to put anything extra on your bootclasspath.
jsr166x should only be useful for folks running jdk5.

Martin

From dl at cs.oswego.edu  Thu Feb 11 20:40:24 2010
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 11 Feb 2010 20:40:24 -0500
Subject: [concurrency-interest] Memory leak on CustomConcurrentHashMap
In-Reply-To: <4B748570.20806@renxo.com>
References: <4A4920A8.2030400@renxo.com> <4A4A2A78.7050705@cs.oswego.edu>
	<4A4CD062.9080206@renxo.com> <4A4CD751.9000008@optrak.co.uk>
	<4A4CDCDC.4000308@renxo.com>
	<58193.89.96.170.50.1246689526.squirrel@altair.cs.oswego.edu>
	<4B748570.20806@renxo.com>
Message-ID: <4B74B188.8000501@cs.oswego.edu>

Manuel Dominguez Sarmiento wrote:
> Hi all,
> 
> We're heavily using CustomConcurrentHashMap on our production servers 
> and have found a memory leak that manifests itself after about a week of 
> heavy usage. There is something wrong with KeySet.intern() and weak 
> keys. I have attached a test that clearly reproduces the problem in a 
> simplified fashion.
> 
> The set in the test should always have size == 1, however after a number 
> of loops, it grows. If this continues to be repeated, the pattern 
> repeats and the set grows indefinitely.
> 

I don't think this test shows an error or leak, just
a transient intrinsic race between insertion and reclamation.

Because your only key is "String str = new String("test");"
there can be at some point in execution no strong reference
to it (see discussions about "reachabilityFences" on this
list last fall.)
In which case it can be reclaimed. Which does appear
to happen here.
When it happens, it is possible for a reclamation
to race with another insert, in which case, transiently, the size
can appear to grow past one (although there is still only one
"actual" usable key) but will shrink back to one
when reclamation completes. Which you might see if you remove
the "break" from your test and adjust accordingly.
Among the morals is to never trust the "size"
method in any kind of weak hash map.

If you instead run with "String str = "test";" as key the
size never grows because it cannot be even transiently
forgotten.


> This test was performed on Windows XP SP3 and JDK 1.6.0_18, but it also 
> manifests itself on Linux 64-bit servers using JDK 1.6.0_5 which is 
> where we first detected there was a problem. The test output from my 
> machine is always the same:
> 
> ERROR, i=138045
> 
> Any ideas? I will begin looking into the CCHM implementation but I'm not 
> really knowledgeable of its internals.

> package com.renxo.cms;
> 
> import jsr166y.CustomConcurrentHashMap;
> import jsr166y.CustomConcurrentHashMap.KeySet;
> 
> public class Test {
> 
> 	public static void main(String[] args) {
> 
> 		KeySet<String> keySet = new KeySet<String>(
> 				CustomConcurrentHashMap.WEAK, CustomConcurrentHashMap.EQUALS, 1);
> 
> 		for (int i = 0; i < 1000000; i++) {
> 
> 			String str = new String("test");
> 
> 			str = keySet.intern(str);
> 
> 			if (keySet.size() > 1) {
> 				System.out.println("ERROR, i=" + i);
> 				break;
> 			}
> 		}
> 	}
> }


From dl at cs.oswego.edu  Fri Feb 12 07:16:19 2010
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 12 Feb 2010 07:16:19 -0500
Subject: [concurrency-interest] Memory leak on CustomConcurrentHashMap
In-Reply-To: <4B74BA2E.5090603@renxo.com>
References: <4A4920A8.2030400@renxo.com> <4A4A2A78.7050705@cs.oswego.edu>
	<4A4CD062.9080206@renxo.com> <4A4CD751.9000008@optrak.co.uk>
	<4A4CDCDC.4000308@renxo.com>
	<58193.89.96.170.50.1246689526.squirrel@altair.cs.oswego.edu>
	<4B748570.20806@renxo.com> <4B74B188.8000501@cs.oswego.edu>
	<4B74BA2E.5090603@renxo.com>
Message-ID: <4B754693.3030208@cs.oswego.edu>

Manuel: your posts are not making it to the list. You might want
to check that you are posting from your subscriber e-mail address.
Also, your tests use the "jsr166y" versions of CCHM, which
were repackaged to "extra166y" last year, and include
a few updates since then, so please get the current versions.

Manuel Dominguez Sarmiento wrote:

>  Please take a look at the new 
> test program I've attached. The size keeps growing, and even after 
> inserting an artificial 5 second delay, no reclamation seems to take 
> place (at least not as reported by size())
> 

You really cannot rely on size() for weak maps (this is also
true for WeakHashMap). When a weak key becomes nulled out by GC,
the entry still exists (but is ignored for all Map operations)
until it is removed by a reclamation thread. It is only at this
point that the map size is adjusted to reflect reclamation.
As you've seen, the lag can be very long. It is
not even bounded. In your test program, this is accentuated
by use of a fixed loop, which has the effect of starving
out the reclamation thread from getting lock. (Plain
WeakHashMap's size() may be more accurate in this situation
because it uses ReferenceQueue polling on each operation.)

The only way to make size() more accurate would be
to implement it by scanning through entire table and counting
non-nulled entries. And even then would not be atomically accurate.
But for the sake of checking for growth, you could for example
use set.toArray().length, which has similar effect of scanning
and ignoring the not-yet-fully-reclaimed entries. If you
change your test to use it, it only prints "1".

Aside: People looking for new Java Puzzlers might
want to try adapting these.

-Doug


import extra166y.CustomConcurrentHashMap; // not jsr166y
import extra166y.CustomConcurrentHashMap.KeySet;

> public class Test2 {
> 
> 	public static void main(String[] args) throws Exception {
> 
> 		KeySet<String> keySet = new KeySet<String>(
> 				CustomConcurrentHashMap.WEAK, CustomConcurrentHashMap.EQUALS, 1);
> 
> 		for (int i = 0; i < 10000000; i++) {
> 
> 			String str = new String("test");
> 
> 			str = keySet.intern(str);
> 
> 			if (i % 1000 == 0) {
> 				System.out.println("size=" + keySet.size());
> 			}
> 		}
> 
> 		System.out.println("START SLEEP");
> 		Thread.sleep(5000L);
> 		System.out.println("END SLEEP");
> 
> 		System.out.println("size=" + keySet.size());
> 	}
> }

From dl at cs.oswego.edu  Fri Feb 12 07:42:35 2010
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 12 Feb 2010 07:42:35 -0500
Subject: [concurrency-interest] Memory leak on CustomConcurrentHashMap
In-Reply-To: <4B754693.3030208@cs.oswego.edu>
References: <4A4920A8.2030400@renxo.com>
	<4A4A2A78.7050705@cs.oswego.edu>	<4A4CD062.9080206@renxo.com>
	<4A4CD751.9000008@optrak.co.uk>	<4A4CDCDC.4000308@renxo.com>	<58193.89.96.170.50.1246689526.squirrel@altair.cs.oswego.edu>	<4B748570.20806@renxo.com>
	<4B74B188.8000501@cs.oswego.edu>	<4B74BA2E.5090603@renxo.com>
	<4B754693.3030208@cs.oswego.edu>
Message-ID: <4B754CBB.2090807@cs.oswego.edu>

Doug Lea wrote:
> Also, your tests use the "jsr166y" versions of CCHM, which
> were repackaged to "extra166y" last year, and include
> a few updates since then, so please get the current versions.
> 

Including one update that hadn't been committed to CVS.
Sorry; they are now in sync.

-Doug


From gkorland at gmail.com  Fri Feb 12 09:59:36 2010
From: gkorland at gmail.com (Guy Korland)
Date: Fri, 12 Feb 2010 16:59:36 +0200
Subject: [concurrency-interest] AutomicBoolean toggleAndGet()
Message-ID: <79be5fa31002120659k40e7ca80h18bc120aec6bf55e@mail.gmail.com>

Hi,

AtomicBoolean.toggleAndGet() and getAndToggle()
It seems like a very usable feature to add to AtomicBoolean and something
that matchs the other AtomicX classes API (*incrementAndGet).*
*Is there any reason why this class was discriminated?*

Regards,
Guy Korland
@g_korland
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100212/d47a05c1/attachment.html>

From martinrb at google.com  Fri Feb 12 11:19:54 2010
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 12 Feb 2010 08:19:54 -0800
Subject: [concurrency-interest] AutomicBoolean toggleAndGet()
In-Reply-To: <79be5fa31002120659k40e7ca80h18bc120aec6bf55e@mail.gmail.com>
References: <79be5fa31002120659k40e7ca80h18bc120aec6bf55e@mail.gmail.com>
Message-ID: <1ccfd1c11002120819t6b4d84f1xbd29df0e68a1fbcd@mail.gmail.com>

AtomicBoolean.toggleAndGet() does seem plausible,
although no obvious use case occurs to me.
But it doesn't buy you much.
Besides a cas loop on AtomicBoolean,
you could also use

(atomicInteger.incrementAndGet() & 0x1) == 0

so without more motivation
I'd be inclined to leave it out.

Martin

On Fri, Feb 12, 2010 at 06:59, Guy Korland <gkorland at gmail.com> wrote:
> Hi,
> AtomicBoolean.toggleAndGet() and getAndToggle()
> It seems like a very usable feature to add to AtomicBoolean and something
> that matchs the other AtomicX classes API (incrementAndGet).
> Is there any reason why this class was?discriminated?


From gkorland at gmail.com  Fri Feb 12 11:34:52 2010
From: gkorland at gmail.com (Guy Korland)
Date: Fri, 12 Feb 2010 18:34:52 +0200
Subject: [concurrency-interest] AutomicBoolean toggleAndGet()
In-Reply-To: <1ccfd1c11002120819t6b4d84f1xbd29df0e68a1fbcd@mail.gmail.com>
References: <79be5fa31002120659k40e7ca80h18bc120aec6bf55e@mail.gmail.com>
	<1ccfd1c11002120819t6b4d84f1xbd29df0e68a1fbcd@mail.gmail.com>
Message-ID: <79be5fa31002120834r66e26e08uc097de412f586918@mail.gmail.com>

Leaving aside the fact that it completes the AtomicX API.
toggleAndGet() is a more natural to concurrent algorithms that are based on
a toggle bit. E.g. diffracting tree, counting network & etc.

Regards,
Guy Korland
@g_korland

On Fri, Feb 12, 2010 at 6:19 PM, Martin Buchholz <martinrb at google.com>wrote:

> AtomicBoolean.toggleAndGet() does seem plausible,
> although no obvious use case occurs to me.
> But it doesn't buy you much.
> Besides a cas loop on AtomicBoolean,
> you could also use
>
> (atomicInteger.incrementAndGet() & 0x1) == 0
>
> so without more motivation
> I'd be inclined to leave it out.
>
> Martin
>
> On Fri, Feb 12, 2010 at 06:59, Guy Korland <gkorland at gmail.com> wrote:
> > Hi,
> > AtomicBoolean.toggleAndGet() and getAndToggle()
> > It seems like a very usable feature to add to AtomicBoolean and something
> > that matchs the other AtomicX classes API (incrementAndGet).
> > Is there any reason why this class was discriminated?
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100212/89b7db43/attachment.html>

From david.lloyd at redhat.com  Fri Feb 12 11:56:33 2010
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Fri, 12 Feb 2010 10:56:33 -0600
Subject: [concurrency-interest] AutomicBoolean toggleAndGet()
In-Reply-To: <79be5fa31002120834r66e26e08uc097de412f586918@mail.gmail.com>
References: <79be5fa31002120659k40e7ca80h18bc120aec6bf55e@mail.gmail.com>	<1ccfd1c11002120819t6b4d84f1xbd29df0e68a1fbcd@mail.gmail.com>
	<79be5fa31002120834r66e26e08uc097de412f586918@mail.gmail.com>
Message-ID: <4B758841.907@redhat.com>

There are several "missing" atomic operations and classes that I've wished 
existed at one point or another - though many of these can be implemented 
in terms of others of these:

// replace int with long for AtomicLong* variants, add "int index" for 
*Array variants
- int getAndSetBits(int original, int bits);    // value |= bits
- int getAndClearBits(int original, int bits);  // value &= bits or value 
&= ~bits, either way
- int getAndToggleBits(int original, int bits); // value ^= bits

One could also add atomic shift & rotate as well, though I don't know of a 
use case offhand for that.

And it would be nice if there were an AtomicReferenceArrayFieldUpdater 
class as well; that always seemed like an odd omission.

- DML

On 02/12/2010 10:34 AM, Guy Korland wrote:
> Leaving aside the fact that it completes the AtomicX API.
> toggleAndGet() is a more natural to concurrent algorithms that are based
> on a toggle bit. E.g. diffracting tree, counting network & etc.
>
> Regards,
> Guy Korland
> @g_korland
>
> On Fri, Feb 12, 2010 at 6:19 PM, Martin Buchholz <martinrb at google.com
> <mailto:martinrb at google.com>> wrote:
>
>     AtomicBoolean.toggleAndGet() does seem plausible,
>     although no obvious use case occurs to me.
>     But it doesn't buy you much.
>     Besides a cas loop on AtomicBoolean,
>     you could also use
>
>     (atomicInteger.incrementAndGet() & 0x1) == 0
>
>     so without more motivation
>     I'd be inclined to leave it out.
>
>     Martin
>
>     On Fri, Feb 12, 2010 at 06:59, Guy Korland <gkorland at gmail.com
>     <mailto:gkorland at gmail.com>> wrote:
>     >  Hi,
>     >  AtomicBoolean.toggleAndGet() and getAndToggle()
>     >  It seems like a very usable feature to add to AtomicBoolean and
>     something
>     >  that matchs the other AtomicX classes API (incrementAndGet).
>     >  Is there any reason why this class was discriminated?
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From dmdabbs at gmail.com  Fri Feb 12 13:08:35 2010
From: dmdabbs at gmail.com (David Dabbs)
Date: Fri, 12 Feb 2010 12:08:35 -0600
Subject: [concurrency-interest] CVS src/jsr166x vs
	src/main/java/util/concurrent
In-Reply-To: <1ccfd1c11002111554w77a0f44es7a952c84347cb9bc@mail.gmail.com>
References: <mailman.1800.1265912764.2997.concurrency-interest@cs.oswego.edu>
	<001301caab48$f2f15e20$d8d41a60$@com>
	<1ccfd1c11002111204j5e468f44xe269ad63bd6465f@mail.gmail.com>
	<000001caab6d$1afa0ba0$50ee22e0$@com>
	<1ccfd1c11002111554w77a0f44es7a952c84347cb9bc@mail.gmail.com>
Message-ID: <003d01caac0e$65aff370$310fda50$@com>



> From: Martin Buchholz [mailto:martinrb at google.com]
> 
> On Thu, Feb 11, 2010 at 14:54, David Dabbs <dmdabbs at gmail.com> wrote:
> > Thank you for the prompt answer and for the caveat re. older jdks.
> > I'm strictly interested in running the jsr166 code in the
> bootclasspath with
> > J2SE 6/7.
> 
> Everything in jsr166x should be included in standard java se 6+
> (except for ConcurrentLinkedDeque, which I happen to care about a lot,
> but you probably do not)
> so there should be no need to put anything extra on your bootclasspath.
> jsr166x should only be useful for folks running jdk5.
> 
> Martin

[David Dabbs] 

But I would need to boot the jsr166y code with JSE6 as it has classes/mods
destined for JDK7, yes?

dd



From martinrb at google.com  Fri Feb 12 13:15:30 2010
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 12 Feb 2010 10:15:30 -0800
Subject: [concurrency-interest] AutomicBoolean toggleAndGet()
In-Reply-To: <4B758841.907@redhat.com>
References: <79be5fa31002120659k40e7ca80h18bc120aec6bf55e@mail.gmail.com>
	<1ccfd1c11002120819t6b4d84f1xbd29df0e68a1fbcd@mail.gmail.com>
	<79be5fa31002120834r66e26e08uc097de412f586918@mail.gmail.com>
	<4B758841.907@redhat.com>
Message-ID: <1ccfd1c11002121015r430cd475rdad81470ca0e20b8@mail.gmail.com>

On Fri, Feb 12, 2010 at 08:56, David M. Lloyd <david.lloyd at redhat.com> wrote:
> There are several "missing" atomic operations and classes that I've wished
> existed at one point or another - though many of these can be implemented in
> terms of others of these:
>
> // replace int with long for AtomicLong* variants, add "int index" for
> *Array variants
> - int getAndSetBits(int original, int bits); ? ?// value |= bits
> - int getAndClearBits(int original, int bits); ?// value &= bits or value &=
> ~bits, either way
> - int getAndToggleBits(int original, int bits); // value ^= bits

These all seem like plausible additions.
But there's no way to "complete" the API this way,
since that would mean supporting all possible operations on ints.

In a language with first class functions, we could have

int applyAndGet(Function<int,int> operation)

In any case, Doug is the person you will really need to convince.

Martin

> One could also add atomic shift & rotate as well, though I don't know of a
> use case offhand for that.
>
> And it would be nice if there were an AtomicReferenceArrayFieldUpdater class
> as well; that always seemed like an odd omission.
>
> - DML
>
> On 02/12/2010 10:34 AM, Guy Korland wrote:
>>
>> Leaving aside the fact that it completes the AtomicX API.
>> toggleAndGet() is a more natural to concurrent algorithms that are based
>> on a toggle bit. E.g. diffracting tree, counting network & etc.
>>
>> Regards,
>> Guy Korland
>> @g_korland
>>
>> On Fri, Feb 12, 2010 at 6:19 PM, Martin Buchholz <martinrb at google.com
>> <mailto:martinrb at google.com>> wrote:
>>
>> ? ?AtomicBoolean.toggleAndGet() does seem plausible,
>> ? ?although no obvious use case occurs to me.
>> ? ?But it doesn't buy you much.
>> ? ?Besides a cas loop on AtomicBoolean,
>> ? ?you could also use
>>
>> ? ?(atomicInteger.incrementAndGet() & 0x1) == 0
>>
>> ? ?so without more motivation
>> ? ?I'd be inclined to leave it out.
>>
>> ? ?Martin
>>
>> ? ?On Fri, Feb 12, 2010 at 06:59, Guy Korland <gkorland at gmail.com
>> ? ?<mailto:gkorland at gmail.com>> wrote:
>> ? ?> ?Hi,
>> ? ?> ?AtomicBoolean.toggleAndGet() and getAndToggle()
>> ? ?> ?It seems like a very usable feature to add to AtomicBoolean and
>> ? ?something
>> ? ?> ?that matchs the other AtomicX classes API (incrementAndGet).
>> ? ?> ?Is there any reason why this class was discriminated?
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From martinrb at google.com  Fri Feb 12 13:20:25 2010
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 12 Feb 2010 10:20:25 -0800
Subject: [concurrency-interest] CVS src/jsr166x vs
	src/main/java/util/concurrent
In-Reply-To: <003d01caac0e$65aff370$310fda50$@com>
References: <mailman.1800.1265912764.2997.concurrency-interest@cs.oswego.edu>
	<001301caab48$f2f15e20$d8d41a60$@com>
	<1ccfd1c11002111204j5e468f44xe269ad63bd6465f@mail.gmail.com>
	<000001caab6d$1afa0ba0$50ee22e0$@com>
	<1ccfd1c11002111554w77a0f44es7a952c84347cb9bc@mail.gmail.com>
	<003d01caac0e$65aff370$310fda50$@com>
Message-ID: <1ccfd1c11002121020n4a076ef7v56a9fb8938281ccc@mail.gmail.com>

On Fri, Feb 12, 2010 at 10:08, David Dabbs <dmdabbs at gmail.com> wrote:
>
>
>> From: Martin Buchholz [mailto:martinrb at google.com]
>>
>> On Thu, Feb 11, 2010 at 14:54, David Dabbs <dmdabbs at gmail.com> wrote:
>> > Thank you for the prompt answer and for the caveat re. older jdks.
>> > I'm strictly interested in running the jsr166 code in the
>> bootclasspath with
>> > J2SE 6/7.
>>
>> Everything in jsr166x should be included in standard java se 6+
>> (except for ConcurrentLinkedDeque, which I happen to care about a lot,
>> but you probably do not)
>> so there should be no need to put anything extra on your bootclasspath.
>> jsr166x should only be useful for folks running jdk5.
>>
>> Martin
>
> [David Dabbs]
>
> But I would need to boot the jsr166y code with JSE6 as it has classes/mods
> destined for JDK7, yes?

If you want to use functionality in jsr166y with jdk 6,
then you use the classes in the jsr166y package,
not the java.util.concurrent package.

The intent is that we maintain the jdk6 backport of jsr166y
indefinitely.

Martin

From dl at cs.oswego.edu  Fri Feb 12 15:39:19 2010
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 12 Feb 2010 15:39:19 -0500
Subject: [concurrency-interest] AutomicBoolean toggleAndGet()
In-Reply-To: <4B758841.907@redhat.com>
References: <79be5fa31002120659k40e7ca80h18bc120aec6bf55e@mail.gmail.com>	<1ccfd1c11002120819t6b4d84f1xbd29df0e68a1fbcd@mail.gmail.com>	<79be5fa31002120834r66e26e08uc097de412f586918@mail.gmail.com>
	<4B758841.907@redhat.com>
Message-ID: <4B75BC77.8080907@cs.oswego.edu>

David M. Lloyd wrote:
> There are several "missing" atomic operations and classes that I've 
> wished existed at one point or another - though many of these can be 
> implemented in terms of others of these:
> 

The original criteria for these classes was to provide only
those for which there are reasonable prospects for
intrinsification --  specialized VM- and instruction- level
support. So for example getAndAdd might be mapped to
a fetchAndAdd instruction on some machines if available.
JVMs haven't taken the opportunity to do this; probably
because these specialized instructions are not usually
noticeably faster than CAS anyway.

So perhaps it is now worth reconsidering others to
include on the basis of convenience instead.
But on these grounds, it not clear to me that
introducing, say, AtomicInteger.getAndSetBits ("gerAndOr")
is worth the potential impact. Since they are just
convenience methods, it's likely that some people out there will
have already added them to their own AtomicInteger subclasses,
which may no longer be compilable/compatible if we add them too.

> 
> And it would be nice if there were an AtomicReferenceArrayFieldUpdater 
> class as well; that always seemed like an odd omission.
> 

This one is always problematic. For non-arrays,
updaters can demand that fields be "volatile" so the
specs for the additional updater methods can be phrased
in reasonable ways. But for an array, plain accesses are
non-volatile. When they are mixed updater accesses, we
cannot even say what you get.

-Doug



From raghuram.nidagal at gmail.com  Fri Feb 12 21:38:14 2010
From: raghuram.nidagal at gmail.com (raghuram nidagal)
Date: Sat, 13 Feb 2010 08:08:14 +0530
Subject: [concurrency-interest] Hash key based thread pool
Message-ID: <7874b1f61002121838g1904f016ibe7a4750b4576241@mail.gmail.com>

Hi,
I wanted to know if anyone has used hashing to allocate jobs to a thread
pool. I see this being useful in systems like processing stocks etc where
instead of locking on the entity we can queue jobs for the same entity into
one thread and avoid synchronizing on the entity.
Thanks
Raghu
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100213/a33a2bec/attachment.html>

From alarmnummer at gmail.com  Fri Feb 12 22:06:03 2010
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Sat, 13 Feb 2010 04:06:03 +0100
Subject: [concurrency-interest] Hash key based thread pool
In-Reply-To: <7874b1f61002121838g1904f016ibe7a4750b4576241@mail.gmail.com>
References: <7874b1f61002121838g1904f016ibe7a4750b4576241@mail.gmail.com>
Message-ID: <9E1402B4-C6BE-46D7-8DB3-3D483AA04708@gmail.com>

You can always use an array of single threaded threadpools and use a  
entity.hashcode % array.length to find the correct threadpool in the  
array



On 13 feb 2010, at 03:38, raghuram nidagal  
<raghuram.nidagal at gmail.com> wrote:

> Hi,
> I wanted to know if anyone has used hashing to allocate jobs to a  
> thread pool. I see this being useful in systems like processing  
> stocks etc where instead of locking on the entity we can queue jobs  
> for the same entity into one thread and avoid synchronizing on the  
> entity.
> Thanks
> Raghu
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From raghuram.nidagal at gmail.com  Fri Feb 12 22:21:48 2010
From: raghuram.nidagal at gmail.com (raghuram nidagal)
Date: Sat, 13 Feb 2010 08:51:48 +0530
Subject: [concurrency-interest] Hash key based thread pool
In-Reply-To: <9E1402B4-C6BE-46D7-8DB3-3D483AA04708@gmail.com>
References: <7874b1f61002121838g1904f016ibe7a4750b4576241@mail.gmail.com>
	<9E1402B4-C6BE-46D7-8DB3-3D483AA04708@gmail.com>
Message-ID: <7874b1f61002121921g7dc519a6sf0edfc5166836abb@mail.gmail.com>

thats right..i was more curious to know if this approach is used and if
people have had any experiences with this approach compared to some other
techniques

On Sat, Feb 13, 2010 at 8:36 AM, Peter Veentjer <alarmnummer at gmail.com>wrote:

> You can always use an array of single threaded threadpools and use a
> entity.hashcode % array.length to find the correct threadpool in the array
>
>
>
>
> On 13 feb 2010, at 03:38, raghuram nidagal <raghuram.nidagal at gmail.com>
> wrote:
>
>   Hi,
>> I wanted to know if anyone has used hashing to allocate jobs to a thread
>> pool. I see this being useful in systems like processing stocks etc where
>> instead of locking on the entity we can queue jobs for the same entity into
>> one thread and avoid synchronizing on the entity.
>> Thanks
>> Raghu
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100213/a53389d7/attachment.html>

From colin.mailinglist at gmail.com  Sat Feb 13 05:33:24 2010
From: colin.mailinglist at gmail.com (Colin Fleming)
Date: Sat, 13 Feb 2010 11:33:24 +0100
Subject: [concurrency-interest] Hash key based thread pool
In-Reply-To: <7874b1f61002121921g7dc519a6sf0edfc5166836abb@mail.gmail.com>
References: <7874b1f61002121838g1904f016ibe7a4750b4576241@mail.gmail.com>
	<9E1402B4-C6BE-46D7-8DB3-3D483AA04708@gmail.com>
	<7874b1f61002121921g7dc519a6sf0edfc5166836abb@mail.gmail.com>
Message-ID: <7c6512111002130233w25b3da76te5572e34680ed5ae@mail.gmail.com>

We've used this approach, it worked well for us. We needed to
distribute work but ensure that jobs were ordered for a particular
entity, so we used an array of single threaded executors as Peter
describes.

Cheers,
Colin

On 13 February 2010 04:21, raghuram nidagal <raghuram.nidagal at gmail.com> wrote:
> thats right..i was more curious to know if this approach is used and if
> people have had any experiences with this approach compared to some other
> techniques
>
> On Sat, Feb 13, 2010 at 8:36 AM, Peter Veentjer <alarmnummer at gmail.com>
> wrote:
>>
>> You can always use an array of single threaded threadpools and use a
>> entity.hashcode % array.length to find the correct threadpool in the array
>>
>>
>>
>> On 13 feb 2010, at 03:38, raghuram nidagal <raghuram.nidagal at gmail.com>
>> wrote:
>>
>>> Hi,
>>> I wanted to know if anyone has used hashing to allocate jobs to a thread
>>> pool. I see this being useful in systems like processing stocks etc where
>>> instead of locking on the entity we can queue jobs for the same entity into
>>> one thread and avoid synchronizing on the entity.
>>> Thanks
>>> Raghu
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From raghuram.nidagal at gmail.com  Sat Feb 13 11:18:35 2010
From: raghuram.nidagal at gmail.com (raghuram nidagal)
Date: Sat, 13 Feb 2010 21:48:35 +0530
Subject: [concurrency-interest] Hash key based thread pool
In-Reply-To: <7c6512111002130233w25b3da76te5572e34680ed5ae@mail.gmail.com>
References: <7874b1f61002121838g1904f016ibe7a4750b4576241@mail.gmail.com>
	<9E1402B4-C6BE-46D7-8DB3-3D483AA04708@gmail.com>
	<7874b1f61002121921g7dc519a6sf0edfc5166836abb@mail.gmail.com>
	<7c6512111002130233w25b3da76te5572e34680ed5ae@mail.gmail.com>
Message-ID: <7874b1f61002130818h2dbbca31ycc589b1d18388dab@mail.gmail.com>

thanks..that is similar to the use case that i was thinking about..

On Sat, Feb 13, 2010 at 4:03 PM, Colin Fleming
<colin.mailinglist at gmail.com>wrote:

> We've used this approach, it worked well for us. We needed to
> distribute work but ensure that jobs were ordered for a particular
> entity, so we used an array of single threaded executors as Peter
> describes.
>
> Cheers,
> Colin
>
>  On 13 February 2010 04:21, raghuram nidagal <raghuram.nidagal at gmail.com>
> wrote:
> > thats right..i was more curious to know if this approach is used and if
> > people have had any experiences with this approach compared to some other
> > techniques
> >
> > On Sat, Feb 13, 2010 at 8:36 AM, Peter Veentjer <alarmnummer at gmail.com>
> > wrote:
> >>
> >> You can always use an array of single threaded threadpools and use a
> >> entity.hashcode % array.length to find the correct threadpool in the
> array
> >>
> >>
> >>
> >> On 13 feb 2010, at 03:38, raghuram nidagal <raghuram.nidagal at gmail.com>
> >> wrote:
> >>
> >>> Hi,
> >>> I wanted to know if anyone has used hashing to allocate jobs to a
> thread
> >>> pool. I see this being useful in systems like processing stocks etc
> where
> >>> instead of locking on the entity we can queue jobs for the same entity
> into
> >>> one thread and avoid synchronizing on the entity.
> >>> Thanks
> >>> Raghu
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100213/6edc9929/attachment.html>

From oleski at web.de  Mon Feb 15 14:33:58 2010
From: oleski at web.de (Peter Oleski)
Date: Mon, 15 Feb 2010 20:33:58 +0100 (CET)
Subject: [concurrency-interest] Question about comment 'Not quite a no-op;
 ensures volatile write semantics' in CopyOnWriteArrayList
Message-ID: <7861414.1161680.1266262438760.JavaMail.fmail@mwmweb018>

Hello

The source code of the CopyOnWriteArrayList has in the set method in line 399
a very interesting comment which is:
"// Not quite a no-op; ensures volatile write semantics"
This comment is part of an else case which sets the array although nothing got changed.
The central data structure is volatile and defined as:

private volatile transient Object[] array;

Why is it necessary to set the array when nothing has changed?

The Method addAllAbsent in line 717 only calls setArray if something got changed.
Can somebody explain this or is there an explanation already somewhere available which I didnt't find? 
I would really like to understand this.


Greetings
Peter Oleski

As a quick reference this is the source of the whole set method.

   /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     *
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public E set(int index, E element) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            E oldValue = get(elements, index);

            if (oldValue != element) {
                int len = elements.length;
                Object[] newElements = Arrays.copyOf(elements, len);
                newElements[index] = element;
                setArray(newElements);
            } else {
                // Not quite a no-op; ensures volatile write semantics
                setArray(elements);
            }
            return oldValue;
        } finally {
            lock.unlock();
        }
    }
___________________________________________________________
GRATIS f?r alle WEB.DE-Nutzer: Die maxdome Movie-FLAT!
Jetzt freischalten unter http://movieflat.web.de
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 1742 bytes
Desc: S/MIME Cryptographic Signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100215/3c3bd1a3/attachment.bin>

From jim.andreou at gmail.com  Mon Feb 15 15:12:16 2010
From: jim.andreou at gmail.com (Dimitris Andreou)
Date: Mon, 15 Feb 2010 22:12:16 +0200
Subject: [concurrency-interest] Question about comment 'Not quite a
	no-op; ensures volatile write semantics' in CopyOnWriteArrayList
In-Reply-To: <7861414.1161680.1266262438760.JavaMail.fmail@mwmweb018>
References: <7861414.1161680.1266262438760.JavaMail.fmail@mwmweb018>
Message-ID: <7d7138c11002151212g69459e98vb8b857b936d449dc@mail.gmail.com>

Hi,

I guess it is meant to introduce a happens-before relationships with
subsequent calls to this:

    public E get(int index) {
        return (E)(getArray()[index]);
    }

Because if a set() is invoked to the array (even a no-op), and then a
subsequent get() from another thread, it must be guaranteed (as documented)
that the second thread will see whatever writes the first thread did *prior*
to calling set(). Since get() involves a volatile read (of the array field),
a volatile write on set() (on the array field) is sufficient.

Dimitris

2010/2/15 Peter Oleski <oleski at web.de>

> Hello
>
> The source code of the CopyOnWriteArrayList has in the set method in line
> 399
> a very interesting comment which is:
> "// Not quite a no-op; ensures volatile write semantics"
> This comment is part of an else case which sets the array although nothing
> got changed.
> The central data structure is volatile and defined as:
>
> private volatile transient Object[] array;
>
> Why is it necessary to set the array when nothing has changed?
>
> The Method addAllAbsent in line 717 only calls setArray if something got
> changed.
> Can somebody explain this or is there an explanation already somewhere
> available which I didnt't find?
> I would really like to understand this.
>
>
> Greetings
> Peter Oleski
>
> As a quick reference this is the source of the whole set method.
>
>   /**
>     * Replaces the element at the specified position in this list with the
>     * specified element.
>     *
>     * @throws IndexOutOfBoundsException {@inheritDoc}
>     */
>    public E set(int index, E element) {
>        final ReentrantLock lock = this.lock;
>        lock.lock();
>        try {
>            Object[] elements = getArray();
>            E oldValue = get(elements, index);
>
>            if (oldValue != element) {
>                int len = elements.length;
>                Object[] newElements = Arrays.copyOf(elements, len);
>                newElements[index] = element;
>                setArray(newElements);
>            } else {
>                // Not quite a no-op; ensures volatile write semantics
>                setArray(elements);
>            }
>            return oldValue;
>        } finally {
>            lock.unlock();
>        }
>    }
> ___________________________________________________________
> GRATIS f?r alle WEB.DE-Nutzer: Die maxdome Movie-FLAT!
> Jetzt freischalten unter http://movieflat.web.de
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100215/7a42b7f8/attachment.html>

From karmazilla at gmail.com  Mon Feb 15 15:34:05 2010
From: karmazilla at gmail.com (Christian Vest Hansen)
Date: Mon, 15 Feb 2010 21:34:05 +0100
Subject: [concurrency-interest] Question about comment 'Not quite a
	no-op; ensures volatile write semantics' in CopyOnWriteArrayList
In-Reply-To: <7861414.1161680.1266262438760.JavaMail.fmail@mwmweb018>
References: <7861414.1161680.1266262438760.JavaMail.fmail@mwmweb018>
Message-ID: <90622e531002151234j7aea5acnfc9f28675bb5d58@mail.gmail.com>

This is my theory:

set() wants to guarantee safe publication. So if some unsynchronized
writes have been made to element prior to the call to set(), then we
ensure that those are ordered before any subsequent get()s.

addAllAbsent() probably does not want to make this guarantee if no
elements are absent.

On Mon, Feb 15, 2010 at 8:33 PM, Peter Oleski <oleski at web.de> wrote:
> Hello
>
> The source code of the CopyOnWriteArrayList has in the set method in line 399
> a very interesting comment which is:
> "// Not quite a no-op; ensures volatile write semantics"
> This comment is part of an else case which sets the array although nothing got changed.
> The central data structure is volatile and defined as:
>
> private volatile transient Object[] array;
>
> Why is it necessary to set the array when nothing has changed?
>
> The Method addAllAbsent in line 717 only calls setArray if something got changed.
> Can somebody explain this or is there an explanation already somewhere available which I didnt't find?
> I would really like to understand this.
>
>
> Greetings
> Peter Oleski
>
> As a quick reference this is the source of the whole set method.
>
> ? /**
> ? ? * Replaces the element at the specified position in this list with the
> ? ? * specified element.
> ? ? *
> ? ? * @throws IndexOutOfBoundsException {@inheritDoc}
> ? ? */
> ? ?public E set(int index, E element) {
> ? ? ? ?final ReentrantLock lock = this.lock;
> ? ? ? ?lock.lock();
> ? ? ? ?try {
> ? ? ? ? ? ?Object[] elements = getArray();
> ? ? ? ? ? ?E oldValue = get(elements, index);
>
> ? ? ? ? ? ?if (oldValue != element) {
> ? ? ? ? ? ? ? ?int len = elements.length;
> ? ? ? ? ? ? ? ?Object[] newElements = Arrays.copyOf(elements, len);
> ? ? ? ? ? ? ? ?newElements[index] = element;
> ? ? ? ? ? ? ? ?setArray(newElements);
> ? ? ? ? ? ?} else {
> ? ? ? ? ? ? ? ?// Not quite a no-op; ensures volatile write semantics
> ? ? ? ? ? ? ? ?setArray(elements);
> ? ? ? ? ? ?}
> ? ? ? ? ? ?return oldValue;
> ? ? ? ?} finally {
> ? ? ? ? ? ?lock.unlock();
> ? ? ? ?}
> ? ?}
> ___________________________________________________________
> GRATIS f?r alle WEB.DE-Nutzer: Die maxdome Movie-FLAT!
> Jetzt freischalten unter http://movieflat.web.de
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>



-- 
Venlig hilsen / Kind regards,
Christian Vest Hansen.


From jdmarshall at gmail.com  Wed Feb 17 19:59:42 2010
From: jdmarshall at gmail.com (jason marshall)
Date: Wed, 17 Feb 2010 16:59:42 -0800
Subject: [concurrency-interest] AutomicBoolean toggleAndGet()
In-Reply-To: <1ccfd1c11002121015r430cd475rdad81470ca0e20b8@mail.gmail.com>
References: <79be5fa31002120659k40e7ca80h18bc120aec6bf55e@mail.gmail.com>
	<1ccfd1c11002120819t6b4d84f1xbd29df0e68a1fbcd@mail.gmail.com>
	<79be5fa31002120834r66e26e08uc097de412f586918@mail.gmail.com>
	<4B758841.907@redhat.com>
	<1ccfd1c11002121015r430cd475rdad81470ca0e20b8@mail.gmail.com>
Message-ID: <3cf41bb91002171659s3d877f1dwa10815b996ed869f@mail.gmail.com>

It seems like the alternative to API explosion is optimistic locking with
the CAS operations:

    while (success == false)
    {
        int bits = atomicInt.get();
        int newBits = bits & 0x11;

        success = atomicInt.compareAndSet(bits, newBits);
        //TODO: Do something about contended writes here?
    }

If you're using a toggle field, and there's write contention, you still have
the missed update problem.  I know some workflows, like some of the ones you
mentioned, are okay with that, but in the Joe User circles I tend to travel
in, I've found just as often that they -think- they're okay with lost
updates, but once you draw them a diagram, they're not okay with it (or at
least their bosses/customers aren't).

In that case, an Atomic isn't really what my poor confused developer was
looking for.  For those situations, making the siren song more effective
(adding convenience methods) would not help anybody.

My favorite axiom for API/language design:  The expected use cases must be
simple, while the uncommon ones must be possible.  In this situation, I
would say the latter has been achieved.

On Fri, Feb 12, 2010 at 10:15 AM, Martin Buchholz <martinrb at google.com>wrote:

> On Fri, Feb 12, 2010 at 08:56, David M. Lloyd <david.lloyd at redhat.com>
> wrote:
> > There are several "missing" atomic operations and classes that I've
> wished
> > existed at one point or another - though many of these can be implemented
> in
> > terms of others of these:
> >
> > // replace int with long for AtomicLong* variants, add "int index" for
> > *Array variants
> > - int getAndSetBits(int original, int bits);    // value |= bits
> > - int getAndClearBits(int original, int bits);  // value &= bits or value
> &=
> > ~bits, either way
> > - int getAndToggleBits(int original, int bits); // value ^= bits
>
> These all seem like plausible additions.
> But there's no way to "complete" the API this way,
> since that would mean supporting all possible operations on ints.
>
> In a language with first class functions, we could have
>
> int applyAndGet(Function<int,int> operation)
>
> In any case, Doug is the person you will really need to convince.
>
> Martin
>
> > One could also add atomic shift & rotate as well, though I don't know of
> a
> > use case offhand for that.
> >
> > And it would be nice if there were an AtomicReferenceArrayFieldUpdater
> class
> > as well; that always seemed like an odd omission.
> >
> > - DML
> >
> > On 02/12/2010 10:34 AM, Guy Korland wrote:
> >>
> >> Leaving aside the fact that it completes the AtomicX API.
> >> toggleAndGet() is a more natural to concurrent algorithms that are based
> >> on a toggle bit. E.g. diffracting tree, counting network & etc.
> >>
> >> Regards,
> >> Guy Korland
> >> @g_korland
> >>
> >> On Fri, Feb 12, 2010 at 6:19 PM, Martin Buchholz <martinrb at google.com
> >> <mailto:martinrb at google.com>> wrote:
> >>
> >>    AtomicBoolean.toggleAndGet() does seem plausible,
> >>    although no obvious use case occurs to me.
> >>    But it doesn't buy you much.
> >>    Besides a cas loop on AtomicBoolean,
> >>    you could also use
> >>
> >>    (atomicInteger.incrementAndGet() & 0x1) == 0
> >>
> >>    so without more motivation
> >>    I'd be inclined to leave it out.
> >>
> >>    Martin
> >>
> >>    On Fri, Feb 12, 2010 at 06:59, Guy Korland <gkorland at gmail.com
> >>    <mailto:gkorland at gmail.com>> wrote:
> >>    >  Hi,
> >>    >  AtomicBoolean.toggleAndGet() and getAndToggle()
> >>    >  It seems like a very usable feature to add to AtomicBoolean and
> >>    something
> >>    >  that matchs the other AtomicX classes API (incrementAndGet).
> >>    >  Is there any reason why this class was discriminated?
> >>
> >>
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
- Jason
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100217/a4f6074a/attachment.html>

From martinrb at google.com  Wed Feb 17 20:32:00 2010
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 17 Feb 2010 17:32:00 -0800
Subject: [concurrency-interest] AutomicBoolean toggleAndGet()
In-Reply-To: <3cf41bb91002171659s3d877f1dwa10815b996ed869f@mail.gmail.com>
References: <79be5fa31002120659k40e7ca80h18bc120aec6bf55e@mail.gmail.com>
	<1ccfd1c11002120819t6b4d84f1xbd29df0e68a1fbcd@mail.gmail.com>
	<79be5fa31002120834r66e26e08uc097de412f586918@mail.gmail.com>
	<4B758841.907@redhat.com>
	<1ccfd1c11002121015r430cd475rdad81470ca0e20b8@mail.gmail.com>
	<3cf41bb91002171659s3d877f1dwa10815b996ed869f@mail.gmail.com>
Message-ID: <1ccfd1c11002171732t738acc1etb0cc49712b2c6144@mail.gmail.com>

If you are afraid of missed updates, use a (more expensive)
AtomicReference containing multiple fields instead of AtomicInteger.

Martin

On Wed, Feb 17, 2010 at 16:59, jason marshall <jdmarshall at gmail.com> wrote:
> It seems like the alternative to API explosion is optimistic locking with
> the CAS operations:
>
> ??? while (success == false)
> ??? {
> ??????? int bits = atomicInt.get();
> ? ?? ?? int newBits = bits & 0x11;
>
> ? ?? ?? success = atomicInt.compareAndSet(bits, newBits);
> ??????? //TODO: Do something about contended writes here?
> ??? }
>
> If you're using a toggle field, and there's write contention, you still have
> the missed update problem.? I know some workflows, like some of the ones you
> mentioned, are okay with that, but in the Joe User circles I tend to travel
> in, I've found just as often that they -think- they're okay with lost
> updates, but once you draw them a diagram, they're not okay with it (or at
> least their bosses/customers aren't).
>
> In that case, an Atomic isn't really what my poor confused developer was
> looking for.? For those situations, making the siren song more effective
> (adding convenience methods) would not help anybody.
>
> My favorite axiom for API/language design:? The expected use cases must be
> simple, while the uncommon ones must be possible.? In this situation, I
> would say the latter has been achieved.
>
> On Fri, Feb 12, 2010 at 10:15 AM, Martin Buchholz <martinrb at google.com>
> wrote:
>>
>> On Fri, Feb 12, 2010 at 08:56, David M. Lloyd <david.lloyd at redhat.com>
>> wrote:
>> > There are several "missing" atomic operations and classes that I've
>> > wished
>> > existed at one point or another - though many of these can be
>> > implemented in
>> > terms of others of these:
>> >
>> > // replace int with long for AtomicLong* variants, add "int index" for
>> > *Array variants
>> > - int getAndSetBits(int original, int bits); ? ?// value |= bits
>> > - int getAndClearBits(int original, int bits); ?// value &= bits or
>> > value &=
>> > ~bits, either way
>> > - int getAndToggleBits(int original, int bits); // value ^= bits
>>
>> These all seem like plausible additions.
>> But there's no way to "complete" the API this way,
>> since that would mean supporting all possible operations on ints.
>>
>> In a language with first class functions, we could have
>>
>> int applyAndGet(Function<int,int> operation)
>>
>> In any case, Doug is the person you will really need to convince.
>>
>> Martin
>>
>> > One could also add atomic shift & rotate as well, though I don't know of
>> > a
>> > use case offhand for that.
>> >
>> > And it would be nice if there were an AtomicReferenceArrayFieldUpdater
>> > class
>> > as well; that always seemed like an odd omission.
>> >
>> > - DML
>> >
>> > On 02/12/2010 10:34 AM, Guy Korland wrote:
>> >>
>> >> Leaving aside the fact that it completes the AtomicX API.
>> >> toggleAndGet() is a more natural to concurrent algorithms that are
>> >> based
>> >> on a toggle bit. E.g. diffracting tree, counting network & etc.
>> >>
>> >> Regards,
>> >> Guy Korland
>> >> @g_korland
>> >>
>> >> On Fri, Feb 12, 2010 at 6:19 PM, Martin Buchholz <martinrb at google.com
>> >> <mailto:martinrb at google.com>> wrote:
>> >>
>> >> ? ?AtomicBoolean.toggleAndGet() does seem plausible,
>> >> ? ?although no obvious use case occurs to me.
>> >> ? ?But it doesn't buy you much.
>> >> ? ?Besides a cas loop on AtomicBoolean,
>> >> ? ?you could also use
>> >>
>> >> ? ?(atomicInteger.incrementAndGet() & 0x1) == 0
>> >>
>> >> ? ?so without more motivation
>> >> ? ?I'd be inclined to leave it out.
>> >>
>> >> ? ?Martin
>> >>
>> >> ? ?On Fri, Feb 12, 2010 at 06:59, Guy Korland <gkorland at gmail.com
>> >> ? ?<mailto:gkorland at gmail.com>> wrote:
>> >> ? ?> ?Hi,
>> >> ? ?> ?AtomicBoolean.toggleAndGet() and getAndToggle()
>> >> ? ?> ?It seems like a very usable feature to add to AtomicBoolean and
>> >> ? ?something
>> >> ? ?> ?that matchs the other AtomicX classes API (incrementAndGet).
>> >> ? ?> ?Is there any reason why this class was discriminated?
>> >>
>> >>
>> >>
>> >>
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> --
> - Jason
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From kedar.mhaswade at gmail.com  Wed Feb 17 21:49:25 2010
From: kedar.mhaswade at gmail.com (kedar mhaswade)
Date: Wed, 17 Feb 2010 18:49:25 -0800
Subject: [concurrency-interest] Use of j.u.c. constructs in open source
	projects ...
Message-ID: <2aa2621c1002171849v2994370ai8d8a39240cbc446a@mail.gmail.com>

Someone asked me if I knew open source projects where j.u.c. constructs are
used heavily.
Her intent was to check out (study thoroughly) how these constructs are put
to (good) use.

Does anyone on the list have any recommendation for such a project (open
source)?

Thanks in advance,
Kedar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100217/a23fc0d0/attachment.html>

From karmazilla at gmail.com  Thu Feb 18 03:03:00 2010
From: karmazilla at gmail.com (Christian Vest Hansen)
Date: Thu, 18 Feb 2010 09:03:00 +0100
Subject: [concurrency-interest] Use of j.u.c. constructs in open source
	projects ...
In-Reply-To: <2aa2621c1002171849v2994370ai8d8a39240cbc446a@mail.gmail.com>
References: <2aa2621c1002171849v2994370ai8d8a39240cbc446a@mail.gmail.com>
Message-ID: <90622e531002180003n21ca3486s8a1bfeada56f0fb9@mail.gmail.com>

Theres the Multiverse STM: http://code.google.com/p/multiverse/ and
the Infinispan distributed cache: http://www.jboss.org/infinispan
There are also numerous uses in the Clojure source code: http://clojure.org/
I've also written a JDBC connection pool if you prefer a small code
base: http://github.com/karmazilla/nanopool

These all use j.u.c a lot, though I don't know if it fits your
definition of "good" use.

On Thu, Feb 18, 2010 at 3:49 AM, kedar mhaswade
<kedar.mhaswade at gmail.com> wrote:
> Someone asked me if I knew open source projects where j.u.c. constructs are
> used heavily.
> Her intent was to check out (study thoroughly) how these constructs are put
> to (good) use.
>
> Does anyone on the list have any recommendation for such a project (open
> source)?
>
> Thanks in advance,
> Kedar
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>



-- 
Venlig hilsen / Kind regards,
Christian Vest Hansen.

From jdmarshall at gmail.com  Thu Feb 18 14:05:30 2010
From: jdmarshall at gmail.com (J Marshall)
Date: Thu, 18 Feb 2010 11:05:30 -0800
Subject: [concurrency-interest] AutomicBoolean toggleAndGet()
In-Reply-To: <1ccfd1c11002171732t738acc1etb0cc49712b2c6144@mail.gmail.com>
References: <79be5fa31002120659k40e7ca80h18bc120aec6bf55e@mail.gmail.com>
	<1ccfd1c11002120819t6b4d84f1xbd29df0e68a1fbcd@mail.gmail.com>
	<79be5fa31002120834r66e26e08uc097de412f586918@mail.gmail.com>
	<4B758841.907@redhat.com>
	<1ccfd1c11002121015r430cd475rdad81470ca0e20b8@mail.gmail.com>
	<3cf41bb91002171659s3d877f1dwa10815b996ed869f@mail.gmail.com>
	<1ccfd1c11002171732t738acc1etb0cc49712b2c6144@mail.gmail.com>
Message-ID: <A8F18EB5-5D68-4BAA-8D70-514728657271@gmail.com>

This is exactly how those conversations tend to start.  Atomic* has no  
guarantees that you will see all updates.  It just guarantees you  
won't see imaginary states that never happened.





On Feb 17, 2010, at 5:32 PM, Martin Buchholz <martinrb at google.com>  
wrote:

> If you are afraid of missed updates, use a (more expensive)
> AtomicReference containing multiple fields instead of AtomicInteger.
>
> Martin
>
> On Wed, Feb 17, 2010 at 16:59, jason marshall <jdmarshall at gmail.com>  
> wrote:
>> It seems like the alternative to API explosion is optimistic  
>> locking with
>> the CAS operations:
>>
>>     while (success == false)
>>     {
>>         int bits = atomicInt.get();
>>         int newBits = bits & 0x11;
>>
>>         success = atomicInt.compareAndSet(bits, newBits);
>>         //TODO: Do something about contended writes here?
>>     }
>>
>> If you're using a toggle field, and there's write contention, you  
>> still have
>> the missed update problem.  I know some workflows, like some of the  
>> ones you
>> mentioned, are okay with that, but in the Joe User circles I tend  
>> to travel
>> in, I've found just as often that they -think- they're okay with lost
>> updates, but once you draw them a diagram, they're not okay with it  
>> (or at
>> least their bosses/customers aren't).
>>
>> In that case, an Atomic isn't really what my poor confused  
>> developer was
>> looking for.  For those situations, making the siren song more  
>> effective
>> (adding convenience methods) would not help anybody.
>>
>> My favorite axiom for API/language design:  The expected use cases  
>> must be
>> simple, while the uncommon ones must be possible.  In this  
>> situation, I
>> would say the latter has been achieved.
>>
>> On Fri, Feb 12, 2010 at 10:15 AM, Martin Buchholz <martinrb at google.com 
>> >
>> wrote:
>>>
>>> On Fri, Feb 12, 2010 at 08:56, David M. Lloyd <david.lloyd at redhat.com 
>>> >
>>> wrote:
>>>> There are several "missing" atomic operations and classes that I've
>>>> wished
>>>> existed at one point or another - though many of these can be
>>>> implemented in
>>>> terms of others of these:
>>>>
>>>> // replace int with long for AtomicLong* variants, add "int  
>>>> index" for
>>>> *Array variants
>>>> - int getAndSetBits(int original, int bits);    // value |= bits
>>>> - int getAndClearBits(int original, int bits);  // value &= bits or
>>>> value &=
>>>> ~bits, either way
>>>> - int getAndToggleBits(int original, int bits); // value ^= bits
>>>
>>> These all seem like plausible additions.
>>> But there's no way to "complete" the API this way,
>>> since that would mean supporting all possible operations on ints.
>>>
>>> In a language with first class functions, we could have
>>>
>>> int applyAndGet(Function<int,int> operation)
>>>
>>> In any case, Doug is the person you will really need to convince.
>>>
>>> Martin
>>>
>>>> One could also add atomic shift & rotate as well, though I don't  
>>>> know of
>>>> a
>>>> use case offhand for that.
>>>>
>>>> And it would be nice if there were an  
>>>> AtomicReferenceArrayFieldUpdater
>>>> class
>>>> as well; that always seemed like an odd omission.
>>>>
>>>> - DML
>>>>
>>>> On 02/12/2010 10:34 AM, Guy Korland wrote:
>>>>>
>>>>> Leaving aside the fact that it completes the AtomicX API.
>>>>> toggleAndGet() is a more natural to concurrent algorithms that are
>>>>> based
>>>>> on a toggle bit. E.g. diffracting tree, counting network & etc.
>>>>>
>>>>> Regards,
>>>>> Guy Korland
>>>>> @g_korland
>>>>>
>>>>> On Fri, Feb 12, 2010 at 6:19 PM, Martin Buchholz <martinrb at google.com
>>>>> <mailto:martinrb at google.com>> wrote:
>>>>>
>>>>>    AtomicBoolean.toggleAndGet() does seem plausible,
>>>>>    although no obvious use case occurs to me.
>>>>>    But it doesn't buy you much.
>>>>>    Besides a cas loop on AtomicBoolean,
>>>>>    you could also use
>>>>>
>>>>>    (atomicInteger.incrementAndGet() & 0x1) == 0
>>>>>
>>>>>    so without more motivation
>>>>>    I'd be inclined to leave it out.
>>>>>
>>>>>    Martin
>>>>>
>>>>>    On Fri, Feb 12, 2010 at 06:59, Guy Korland <gkorland at gmail.com
>>>>>    <mailto:gkorland at gmail.com>> wrote:
>>>>>    >  Hi,
>>>>>    >  AtomicBoolean.toggleAndGet() and getAndToggle()
>>>>>    >  It seems like a very usable feature to add to  
>>>>> AtomicBoolean and
>>>>>    something
>>>>>    >  that matchs the other AtomicX classes API (incrementAndGet).
>>>>>    >  Is there any reason why this class was discriminated?
>>>>>
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>> --
>> - Jason
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>

From kaykay.unique at gmail.com  Thu Feb 18 18:30:16 2010
From: kaykay.unique at gmail.com (Kay Kay)
Date: Thu, 18 Feb 2010 15:30:16 -0800
Subject: [concurrency-interest] Use of j.u.c. constructs in open source
 projects ...
In-Reply-To: <2aa2621c1002171849v2994370ai8d8a39240cbc446a@mail.gmail.com>
References: <2aa2621c1002171849v2994370ai8d8a39240cbc446a@mail.gmail.com>
Message-ID: <4B7DCD88.4070300@gmail.com>

It might be interesting to use - http://koders.com/ for this purpose as 
well,  that indexes quite a number of open source projects 
(sourceforge.net).


On 2/17/10 6:49 PM, kedar mhaswade wrote:
> Someone asked me if I knew open source projects where j.u.c. 
> constructs are used heavily.
> Her intent was to check out (study thoroughly) how these constructs 
> are put to (good) use.
>
> Does anyone on the list have any recommendation for such a project 
> (open source)?
>
> Thanks in advance,
> Kedar
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>    

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100218/31723f9c/attachment.html>

From david at walend.net  Fri Feb 19 23:20:28 2010
From: david at walend.net (David Walend)
Date: Fri, 19 Feb 2010 23:20:28 -0500
Subject: [concurrency-interest] Use of j.u.c. constructs in open source
	projects
In-Reply-To: <mailman.1.1266512400.17513.concurrency-interest@cs.oswego.edu>
References: <mailman.1.1266512400.17513.concurrency-interest@cs.oswego.edu>
Message-ID: <87E7DD0C-F2C6-488F-BA8A-F9F64C441B04@walend.net>

> From: kedar mhaswade <kedar.mhaswade at gmail.com>
>
> Someone asked me if I knew open source projects where j.u.c.  
> constructs are
> used heavily.
> Her intent was to check out (study thoroughly) how these constructs  
> are put
> to (good) use.
>
> Does anyone on the list have any recommendation for such a project  
> (open
> source)?
>

SomnifugiJMS makes heavy use of BlockingQueues, a few Locks and  
Conditions, and this diabolical use of AtomicMarkableReferences that  
Tim Peierls suggested -- it does JMS message selectors without a  
database. I'm not sure I'd call it "good," but the code has been  
kicked around for about ten years. New bug reports have gotten pretty  
rare.

https://somnifugijms.dev.java.net/

Hope that helps,

Dave


From peter.kovacs.1.0rc at gmail.com  Sat Feb 20 05:07:01 2010
From: peter.kovacs.1.0rc at gmail.com (=?UTF-8?B?UMOpdGVyIEtvdsOhY3M=?=)
Date: Sat, 20 Feb 2010 11:07:01 +0100
Subject: [concurrency-interest] question about AtomicReference
In-Reply-To: <63b4e4051001251402g7a1a061ey68598bb57d5de78e@mail.gmail.com>
References: <2655639a1001251254h440c9513jc3eaa7cfd04b160f@mail.gmail.com>
	<63b4e4051001251329o5f90c64ana5ff6c53ef88507b@mail.gmail.com>
	<4B5E1447.8040306@univ-mlv.fr>
	<63b4e4051001251402g7a1a061ey68598bb57d5de78e@mail.gmail.com>
Message-ID: <fdeb32eb1002200207p3f38f274u9a822fe35ea09f44@mail.gmail.com>

I find this overloaded use of the final keyword very unintuitive. (To be
honest, I find it plainly wrong.) I think that using a separate (more
expressive) directive would also have had the side effect of better driving
home the problem of safe publication itself. I am sure that most of us would
faster discover errors like this, if, instead of "final", we had a keyword
like "safetopublish" or similar in our mental checklist when reviewing a
code from a thread-safety perspective. "final" may be a perfectly suitable
term for this functionality to low-level thinking JVM architects, but much
less so for a high-level thinking user of the language.

Peter

On Mon, Jan 25, 2010 at 11:02 PM, Tim Peierls <tim at peierls.net> wrote:

> Ugh, I think we have an errata entry (pending) for that.
>
> But if a ConcurrentStack instance is published safely, then it's safe to
> use.
>
> --tim
>
>
> On Mon, Jan 25, 2010 at 4:59 PM, R?mi Forax <forax at univ-mlv.fr> wrote:
>
>>  BTW, I'm not sure that this code is thread-safe because top is not final,
>> so a NPE in push or pop (on top.get()) is possible.
>>
>> R?mi
>>
>> Le 25/01/2010 22:29, Tim Peierls a ?crit :
>>
>> No, it's not particularly intuitive, but it's true. Best not to think of
>> it as AtomicReference "protecting" Node.next, however. The phrase in the
>> package doc comment for j.u.c.atomic is "The memory effects for accesses
>> and updates of atomics generally follow the rules for volatiles", pointing
>> you to the JLS for further details:
>>
>>  http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.4
>>
>>  In the language of *happens-before* introduced in that section, the
>> write to newHead.next in the push() method *happens-before* a "volatile
>> write" (top.compareAndSet) and a "volatile read" (top.get) *
>> happens-before* the read of oldHead.next in the pop() method. So writes
>> to next in push() are seen by reads of next in pop().
>>
>>  --tim
>>
>>
>> On Mon, Jan 25, 2010 at 3:54 PM, JP Fournier <jape41 at gmail.com> wrote:
>>
>>> Hi All,
>>>
>>> I recently spent some long overdue time reading through JCIP.
>>>
>>> One thing that was non-intuitive to me was the idea that
>>> AtomicReference could protect more than the reference it contains.
>>> For example on page 331, in the ConcurrentStack example, Node.next
>>> looked unprotected to me:
>>>
>>> http://www.javaconcurrencyinpractice.com/listings/ConcurrentStack.java
>>>
>>> I'm assuming that Node.next must be protected by the CAS access to
>>> ConcurrentStack.top.
>>>
>>> If I were writing code like this I probably would have naively made
>>> Node.next an AtomicReference too.
>>>
>>> Assuming that Node.next is protected by the CAS access to
>>> ConcurrecntStack.top would this hold true if Node.next was something
>>> bigger than reference? Lets say Node.next was an arbitrarily large
>>> array that was mutated within the do loop in the push() method?
>>>
>>> Any thoughts appreciated.
>>>
>>> jp
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100220/ec08477f/attachment.html>

From mthornton at optrak.co.uk  Sat Feb 20 05:31:20 2010
From: mthornton at optrak.co.uk (Mark Thornton)
Date: Sat, 20 Feb 2010 10:31:20 +0000
Subject: [concurrency-interest] question about AtomicReference
In-Reply-To: <fdeb32eb1002200207p3f38f274u9a822fe35ea09f44@mail.gmail.com>
References: <2655639a1001251254h440c9513jc3eaa7cfd04b160f@mail.gmail.com>	<63b4e4051001251329o5f90c64ana5ff6c53ef88507b@mail.gmail.com>	<4B5E1447.8040306@univ-mlv.fr>	<63b4e4051001251402g7a1a061ey68598bb57d5de78e@mail.gmail.com>
	<fdeb32eb1002200207p3f38f274u9a822fe35ea09f44@mail.gmail.com>
Message-ID: <4B7FB9F8.4030701@optrak.co.uk>

P?ter Kov?cs wrote:
> I find this overloaded use of the final keyword very unintuitive. (To 
> be honest, I find it plainly wrong.) I think that using a separate 
> (more expressive) directive would also have had the side effect of 
> better driving home the problem of safe publication itself. I am sure 
> that most of us would faster discover errors like this, if,  instead 
> of "final", we had a keyword like "safetopublish" or similar in our 
> mental checklist when reviewing a code from a thread-safety 
> perspective. "final" may be a perfectly suitable term for this 
> functionality to low-level thinking JVM architects, but much less so 
> for a high-level thinking user of the language.
>
> Peter
I find 'final' in the sense safe to publish reasonably intuitive (as 
much as anything concurrent ever is). The wacky bit is when you discover 
that you can alter final fields via reflection. I have been writing an 
ORM for objects with solely final fields and functional style 
collections. I am using reflection to set the fields and I hope I am 
getting the publication correct. I found this section of the memory 
model a bit difficult to follow.

Mark Thornton


From peter.kovacs.1.0rc at gmail.com  Sat Feb 20 18:35:16 2010
From: peter.kovacs.1.0rc at gmail.com (=?UTF-8?B?UMOpdGVyIEtvdsOhY3M=?=)
Date: Sun, 21 Feb 2010 00:35:16 +0100
Subject: [concurrency-interest] question about AtomicReference
In-Reply-To: <4B7FB9F8.4030701@optrak.co.uk>
References: <2655639a1001251254h440c9513jc3eaa7cfd04b160f@mail.gmail.com>
	<63b4e4051001251329o5f90c64ana5ff6c53ef88507b@mail.gmail.com>
	<4B5E1447.8040306@univ-mlv.fr>
	<63b4e4051001251402g7a1a061ey68598bb57d5de78e@mail.gmail.com>
	<fdeb32eb1002200207p3f38f274u9a822fe35ea09f44@mail.gmail.com>
	<4B7FB9F8.4030701@optrak.co.uk>
Message-ID: <fdeb32eb1002201535l70e7bbfma66fe6acd987e7f3@mail.gmail.com>

Exactly! I am not saying that "final" is unintuitive to mean safe
publication *by itself*. My problem is that "final" already has a different
(and, by the way, much more general) meaning. I understand that "final" now
denotes two completely different things: (a) a very general compile time
check to prevent a second assignment; (b) runtime guarantee about a field's
visibility.

Or is it principally impossible to separate these two meanings? At first
glance, I don't see why there could not be a use case where the programmer
would want to have safe field publication (a behavior everyday programmers
intuitively expect anyway) without forgoing multiple assignments to the same
field (another widely held expectation).

Peter

2010/2/20 Mark Thornton <mthornton at optrak.co.uk>

> P?ter Kov?cs wrote:
>
>> I find this overloaded use of the final keyword very unintuitive. (To be
>> honest, I find it plainly wrong.) I think that using a separate (more
>> expressive) directive would also have had the side effect of better driving
>> home the problem of safe publication itself. I am sure that most of us would
>> faster discover errors like this, if,  instead of "final", we had a keyword
>> like "safetopublish" or similar in our mental checklist when reviewing a
>> code from a thread-safety perspective. "final" may be a perfectly suitable
>> term for this functionality to low-level thinking JVM architects, but much
>> less so for a high-level thinking user of the language.
>>
>> Peter
>>
> I find 'final' in the sense safe to publish reasonably intuitive (as much
> as anything concurrent ever is). The wacky bit is when you discover that you
> can alter final fields via reflection. I have been writing an ORM for
> objects with solely final fields and functional style collections. I am
> using reflection to set the fields and I hope I am getting the publication
> correct. I found this section of the memory model a bit difficult to follow.
>
> Mark Thornton
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100221/e20ada37/attachment.html>

From joe.bowbeer at gmail.com  Sat Feb 20 19:49:48 2010
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sat, 20 Feb 2010 16:49:48 -0800
Subject: [concurrency-interest] question about AtomicReference
In-Reply-To: <fdeb32eb1002201535l70e7bbfma66fe6acd987e7f3@mail.gmail.com>
References: <2655639a1001251254h440c9513jc3eaa7cfd04b160f@mail.gmail.com>
	<63b4e4051001251329o5f90c64ana5ff6c53ef88507b@mail.gmail.com>
	<4B5E1447.8040306@univ-mlv.fr>
	<63b4e4051001251402g7a1a061ey68598bb57d5de78e@mail.gmail.com>
	<fdeb32eb1002200207p3f38f274u9a822fe35ea09f44@mail.gmail.com>
	<4B7FB9F8.4030701@optrak.co.uk>
	<fdeb32eb1002201535l70e7bbfma66fe6acd987e7f3@mail.gmail.com>
Message-ID: <31f2a7bd1002201649p37a12e5cs70033ce0049be9f@mail.gmail.com>

I agree that "final" has ultimately taken on more that it originally
bargained for.  However, I think the term "volatile" is even less intuitive
and more overloaded.

Instead of "final", Scala uses the keyword "val" for single-assignment
(versus "var").  Is this better?

For safe publication, I like Oz's "dataflow" variables, that are initially
unbound and can be bound to only one value.

Joe

2010/2/20 P?ter Kov?cs

> Exactly! I am not saying that "final" is unintuitive to mean safe
> publication *by itself*. My problem is that "final" already has a
> different (and, by the way, much more general) meaning. I understand that
> "final" now denotes two completely different things: (a) a very general
> compile time check to prevent a second assignment; (b) runtime guarantee
> about a field's visibility.
>
> Or is it principally impossible to separate these two meanings? At first
> glance, I don't see why there could not be a use case where the programmer
> would want to have safe field publication (a behavior everyday programmers
> intuitively expect anyway) without forgoing multiple assignments to the same
> field (another widely held expectation).
>
> Peter
>
> 2010/2/20 Mark Thornton <mthornton at optrak.co.uk>
>
> P?ter Kov?cs wrote:
>>
>>> I find this overloaded use of the final keyword very unintuitive. (To be
>>> honest, I find it plainly wrong.) I think that using a separate (more
>>> expressive) directive would also have had the side effect of better driving
>>> home the problem of safe publication itself. I am sure that most of us would
>>> faster discover errors like this, if,  instead of "final", we had a keyword
>>> like "safetopublish" or similar in our mental checklist when reviewing a
>>> code from a thread-safety perspective. "final" may be a perfectly suitable
>>> term for this functionality to low-level thinking JVM architects, but much
>>> less so for a high-level thinking user of the language.
>>>
>>> Peter
>>>
>> I find 'final' in the sense safe to publish reasonably intuitive (as much
>> as anything concurrent ever is). The wacky bit is when you discover that you
>> can alter final fields via reflection. I have been writing an ORM for
>> objects with solely final fields and functional style collections. I am
>> using reflection to set the fields and I hope I am getting the publication
>> correct. I found this section of the memory model a bit difficult to follow.
>>
>> Mark Thornton
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100220/81bfb633/attachment.html>

From hans.boehm at hp.com  Sun Feb 21 00:09:51 2010
From: hans.boehm at hp.com (Boehm, Hans)
Date: Sun, 21 Feb 2010 05:09:51 +0000
Subject: [concurrency-interest] question about AtomicReference
In-Reply-To: <fdeb32eb1002201535l70e7bbfma66fe6acd987e7f3@mail.gmail.com>
References: <2655639a1001251254h440c9513jc3eaa7cfd04b160f@mail.gmail.com>
	<63b4e4051001251329o5f90c64ana5ff6c53ef88507b@mail.gmail.com>
	<4B5E1447.8040306@univ-mlv.fr>
	<63b4e4051001251402g7a1a061ey68598bb57d5de78e@mail.gmail.com>
	<fdeb32eb1002200207p3f38f274u9a822fe35ea09f44@mail.gmail.com>
	<4B7FB9F8.4030701@optrak.co.uk>
	<fdeb32eb1002201535l70e7bbfma66fe6acd987e7f3@mail.gmail.com>
Message-ID: <238A96A773B3934685A7269CC8A8D0425785042B0C@GVW0436EXB.americas.hpqcorp.net>

In my mind, they are closely connected, though it's not clear that they should always be 100% identical.  They're often both needed to construct truly immutable objects.

Safe publication doesn't matter unless you communicate the reference to another thread through a data race, and code should normally just avoid the data race.

The major case in which that doesn't work is a case in which I construct an object s (e.g. a string), and then pass s to untrusted code, or the untrusted code itself constructs s.  The untrusted code can't be prevented from passing x through a data race to another thread.  But I still have to prevent the untrusted code from abusing s, e.g. (recycling one of Bill Pugh's well-known examples) by using it as a string that, as a result of delayed visibility of its fields, changes between a security check and some critical call, so that the security check passes when it shouldn't.  Thus I need a way of constructing a reliably immutable object.  To do that, I often want final fields in the traditional sense, so that the untrusted code can't change them directly (though that's clearly not the only possible mechanism).  And I need a way to ensure that those fields don't appear to change due to cross-thread visibility issues.

The final field visibility rules were also fairly carefully designed to make it possible for the compiler to exploit the immutable nature of the field.  And by restricting some of the guarantees to final fields, compilers on certain, now rare, machines can avoid enforcing certain memory orderings for ordinary field references.  Separating the two aspects would certainly add further complications to an already over-complicated area.

Hans



  _____

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of P?ter Kov?cs
Sent: Saturday, February 20, 2010 3:35 PM
To: Mark Thornton
Cc: concurrency-interest at cs.oswego.edu; Tim Peierls
Subject: Re: [concurrency-interest] question about AtomicReference


Exactly! I am not saying that "final" is unintuitive to mean safe publication by itself. My problem is that "final" already has a different (and, by the way, much more general) meaning. I understand that "final" now denotes two completely different things: (a) a very general compile time check to prevent a second assignment; (b) runtime guarantee about a field's visibility.

Or is it principally impossible to separate these two meanings? At first glance, I don't see why there could not be a use case where the programmer would want to have safe field publication (a behavior everyday programmers intuitively expect anyway) without forgoing multiple assignments to the same field (another widely held expectation).

Peter

2010/2/20 Mark Thornton <mthornton at optrak.co.uk<mailto:mthornton at optrak.co.uk>>


P?ter Kov?cs wrote:


I find this overloaded use of the final keyword very unintuitive. (To be honest, I find it plainly wrong.) I think that using a separate (more expressive) directive would also have had the side effect of better driving home the problem of safe publication itself. I am sure that most of us would faster discover errors like this, if,  instead of "final", we had a keyword like "safetopublish" or similar in our mental checklist when reviewing a code from a thread-safety perspective. "final" may be a perfectly suitable term for this functionality to low-level thinking JVM architects, but much less so for a high-level thinking user of the language.

Peter


I find 'final' in the sense safe to publish reasonably intuitive (as much as anything concurrent ever is). The wacky bit is when you discover that you can alter final fields via reflection. I have been writing an ORM for objects with solely final fields and functional style collections. I am using reflection to set the fields and I hope I am getting the publication correct. I found this section of the memory model a bit difficult to follow.

Mark Thornton




-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100221/c155d7df/attachment-0001.html>

From peter.kovacs.1.0rc at gmail.com  Sat Feb 27 11:10:32 2010
From: peter.kovacs.1.0rc at gmail.com (=?UTF-8?B?UMOpdGVyIEtvdsOhY3M=?=)
Date: Sat, 27 Feb 2010 17:10:32 +0100
Subject: [concurrency-interest] question about AtomicReference
In-Reply-To: <238A96A773B3934685A7269CC8A8D0425785042B0C@GVW0436EXB.americas.hpqcorp.net>
References: <2655639a1001251254h440c9513jc3eaa7cfd04b160f@mail.gmail.com>
	<63b4e4051001251329o5f90c64ana5ff6c53ef88507b@mail.gmail.com>
	<4B5E1447.8040306@univ-mlv.fr>
	<63b4e4051001251402g7a1a061ey68598bb57d5de78e@mail.gmail.com>
	<fdeb32eb1002200207p3f38f274u9a822fe35ea09f44@mail.gmail.com>
	<4B7FB9F8.4030701@optrak.co.uk>
	<fdeb32eb1002201535l70e7bbfma66fe6acd987e7f3@mail.gmail.com>
	<238A96A773B3934685A7269CC8A8D0425785042B0C@GVW0436EXB.americas.hpqcorp.net>
Message-ID: <fdeb32eb1002270810g2d654977r12730e0b3e914e1c@mail.gmail.com>

Thank you,Hans, for these important bits I had been missing on the issue.
They will certainly help me exercise much more empathy regarding the
"overloading" of the *final* keyword. :-)

Peter

2010/2/21 Boehm, Hans <hans.boehm at hp.com>

>  In my mind, they are closely connected, though it's not clear that they
> should always be 100% identical.  They're often both needed to construct
> truly immutable objects.
>
> Safe publication doesn't matter unless you communicate the reference to
> another thread through a data race, and code should normally just avoid the
> data race.
>
> The major case in which that doesn't work is a case in which I construct an
> object s (e.g. a string), and then pass s to untrusted code, or the
> untrusted code itself constructs s.  The untrusted code can't be prevented
> from passing x through a data race to another thread.  But I still have to
> prevent the untrusted code from abusing s, e.g. (recycling one of Bill
> Pugh's well-known examples) by using it as a string that, as a result of
> delayed visibility of its fields, changes between a security check and some
> critical call, so that the security check passes when it shouldn't.  Thus I
> need a way of constructing a reliably immutable object.  To do that, I often
> want final fields in the traditional sense, so that the untrusted code can't
> change them directly (though that's clearly not the only possible
> mechanism).  And I need a way to ensure that those fields don't appear to
> change due to cross-thread visibility issues.
>
> The final field visibility rules were also fairly carefully designed to
> make it possible for the compiler to exploit the immutable nature of the
> field.  And by restricting some of the guarantees to final fields, compilers
> on certain, now rare, machines can avoid enforcing certain memory orderings
> for ordinary field references.  Separating the two aspects would certainly
> add further complications to an already over-complicated area.
>
> Hans
>
>
>  ------------------------------
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *P?ter Kov?cs
> *Sent:* Saturday, February 20, 2010 3:35 PM
> *To:* Mark Thornton
> *Cc:* concurrency-interest at cs.oswego.edu; Tim Peierls
>
> *Subject:* Re: [concurrency-interest] question about AtomicReference
>
>  Exactly! I am not saying that "final" is unintuitive to mean safe
> publication *by itself*. My problem is that "final" already has a
> different (and, by the way, much more general) meaning. I understand that
> "final" now denotes two completely different things: (a) a very general
> compile time check to prevent a second assignment; (b) runtime guarantee
> about a field's visibility.
>
>  Or is it principally impossible to separate these two meanings? At first
> glance, I don't see why there could not be a use case where the programmer
> would want to have safe field publication (a behavior everyday programmers
> intuitively expect anyway) without forgoing multiple assignments to the same
> field (another widely held expectation).
>
>  Peter
>
> 2010/2/20 Mark Thornton <mthornton at optrak.co.uk>
>
>> P?ter Kov?cs wrote:
>>
>>> I find this overloaded use of the final keyword very unintuitive. (To be
>>> honest, I find it plainly wrong.) I think that using a separate (more
>>> expressive) directive would also have had the side effect of better driving
>>> home the problem of safe publication itself. I am sure that most of us would
>>> faster discover errors like this, if,  instead of "final", we had a keyword
>>> like "safetopublish" or similar in our mental checklist when reviewing a
>>> code from a thread-safety perspective. "final" may be a perfectly suitable
>>> term for this functionality to low-level thinking JVM architects, but much
>>> less so for a high-level thinking user of the language.
>>>
>>> Peter
>>>
>>  I find 'final' in the sense safe to publish reasonably intuitive (as much
>> as anything concurrent ever is). The wacky bit is when you discover that you
>> can alter final fields via reflection. I have been writing an ORM for
>> objects with solely final fields and functional style collections. I am
>> using reflection to set the fields and I hope I am getting the publication
>> correct. I found this section of the memory model a bit difficult to follow.
>>
>> Mark Thornton
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20100227/176974b4/attachment.html>

