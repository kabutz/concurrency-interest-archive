From dl@cs.oswego.edu  Tue Dec  2 18:40:15 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Tue, 2 Dec 2003 13:40:15 -0500
Subject: [concurrency-interest] workshop announcement
Message-ID: <16332.56463.499274.989852@altair.cs.oswego.edu>

If you've been doing interesting things with new JSR166 features
consider submitting to the following workshop. (See
http://www.podc.org/podc2004/ for more details.) As it says, the main
goal is to get together people who have been researching the kinds of
concurrency and synchronization constructs Java will now support with
people trying to solve real problems.  We hope to see you there!



    Workshop on Concurrency and Synchronization in Java Programs

                  St John's, Newfoundland, Canada
 
                           24-25 July 2004
 

SCOPE

Synchronization is fast becoming  a major performance and design issue
for concurrent  programming on modern architectures.   With the advent
of  JSR166,  the  new  Java(TM)  Concurrency  Package,  new  low-level
synchronization  primitives   and  high-level  constructs   are  being
introduced  into the Java  language. In  light of  these developments,
there is a unique window of opportunity for the Java Community and the
PODC  community  to join  forces  in  evaluating  and planning  future
directions for synchronization in general, and Java synchronization in
particular.  The goal of this  workshop is to bring about a productive
interaction  between   members  of  the   two  communities,  targeting
interesting  synchronization problems, solutions,  constructs, models,
and other core aspects of synchronization in Java programs.


TOPICS

Contributions are solicited in all areas related to synchronization in
concurrent  Java  programs.   While  synchronization in  Java  Virtual
Machine  implementations directly related  to synchronization  in Java
programs  is   also  of  interest,  papers  whose   primary  focus  is
synchronization  in other  parts of  a  Java Virtual  Machine are  not
appropriate.

Specific topics of interest include, but are not limited to:

 - use of JSR166 (Java Concurrency Package) features
 - implementation of JSR166 features in JVMs
 - scalability
 - concurrent data structure implementations in Java programs
 - case studies
 - nonblocking synchronization
 - Java Memory Model
 - synchronization constructs, e.g., software transactional memory
 - language and semantics ("what if"s)
 - Java synchronization vs. synchronization in alternative environments
 - compiler transformations
 - effect of garbage collection on difficulty of synchronization
 - performance and scalability analysis techniques
 - performance and scalability studies of important applications
 - hard synchronization problems without adequate solutions


PAPER SUBMISSION 

Submitted papers should be  orginal, unpublished work.  The main focus
in selecting workshop contributions will be the intrinsic interest and
timeliness of the  work, so authors are encouraged  to submit polished
descriptions  of  work  in  progress  as  well  as  papers  describing
completed projects.

Accepted papers will be  included in an informal workshop proceedings,
and can subsequently be submitted to more formal publication venues if
this is allowed by the rules of those venues.  Papers can be submitted
to  both PODC  and the  workshop, and  if appropriate  submissions are
accepted to both, a special joint session will be included in the PODC
program.  Authors wishing  to have their papers considered  for such a
session  should submit  their paper  separately to  both PODC  and the
workshop,  indicating  on  the  cover  page  of  each  that  they  are
interested in the joint session.  Papers accepted to the joint session
will be  published in the PODC  proceedings as usual,  and in addition
will  have   their  abstracts  published  in   the  informal  workshop
proceedings.  A special journal  issue associated with the workshop is
being considered.

All submissions will  be handled electronically and must  be in PDF or
PostScript format. Papers must not  exceed 10 pages (US "Letter" size,
8.5 x 11 inches) including text, figures and references. The font size
must be at least 11 points.


ELECTRONIC SUBMISSIONS INSTRUCTIONS

  - to be announced


IMPORTANT DATES

  - Feb 15, 2004      Deadline for submission to PODC (and joint session)
  - April 4th, 2004   Deadline for submission to workshop
  - June 1st, 2004    Acceptance/rejection notifications
  - June 18th, 2004   Camera-ready papers due
  - July 24-25  2004  Workshop in Newfoundland


PROGRAM CO-CHAIRS:

Mark Moir          Nir Shavit
Mark.Moir@Sun.COM  Nir.Shavit@Sun.Com
Sun Microsystems Laboratories
1 Network Drive
Burlington, MA 01803
USA


PROGRAM COMMITTEE

David Bacon, IBM
Hans Boehm, HP
Josh Bloch, Sun
David Detlefs, Sun Labs
Tim Harris, Cambridge University
Maurice Herlihy, Brown University
David Holmes, DLTeCH Pty Ltd
Doug Lea, SUNY Oswego
Mark Moir, Sun Labs (Co-Chair)
Vivek Sarkar, IBM
Nir Shavit, Sun Labs (Co-Chair)
Martin Rinard, MIT
Jan Vitek, Purdue University

From eric.zoerner@gemstone.com  Thu Dec  4 02:20:05 2003
From: eric.zoerner@gemstone.com (Eric Zoerner)
Date: Wed, 03 Dec 2003 18:20:05 -0800
Subject: [concurrency-interest] ConcurrentMap.replace
In-Reply-To: <16329.15553.828211.230152@altair.cs.oswego.edu>
References: <16319.22801.18128.679982@altair.cs.oswego.edu>	<3FC240A4.5000608@gemstone.com>	<16322.44755.146905.552519@altair.cs.oswego.edu>	<3FC39563.2080904@gemstone.com> <16329.15553.828211.230152@altair.cs.oswego.edu>
Message-ID: <3FCE99D5.2060907@gemstone.com>

Doug, thanks for adding the two-arg replace method, and I agree with your 
analysis. However, I was expecting the two-arg replace method to return the 
oldValue, not a boolean. I don't have a use case for why it should return the 
oldValue, but it seems like it would provide more information than a boolean. If 
the return value is null, then we know the key didn't exist and the replace 
didn't happen (same as the current return of false). Otherwise we get the object 
that was replaced, similar to the return value from put and putIfAbsent. [Of 
course, if the Map supports null values then there is ambiguity, but that is 
also true of putIfAbsent].

- Eric



From dl@cs.oswego.edu  Fri Dec  5 15:03:26 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 5 Dec 2003 10:03:26 -0500
Subject: [concurrency-interest] Executor framework adjustments
Message-ID: <16336.40510.652534.642309@altair.cs.oswego.edu>

Just as official JCP public review period is coming to a close, we
made a few API adjustments in the Executor framework that were
primarily motivated by some very recent planned J2EE efforts -- the
proposed JSR-236 and JSR-237 -- but make good sense in other contexts
as well.

For background, see
  http://www.jcp.org/en/jsr/detail?id=236
  http://www.jcp.org/en/jsr/detail?id=237
And follow links near the bottom of each to see BEA and IBM's proposed
APIs.

The JSR-166 changes are both straightforward:
  * ScheduledExecutor has been made into an interface, not class,
    and the concrete version is renamed ScheduledThreadPoolExecutor
    (This better enables alternative implmentations of the schedule
    methods.)

  * The "Cancellable" and "Future" interfaces (along with default Task
    implementations) have been merged (as Future and FutureTask). The
    initial idea was to enable different implementations based on
    Runnables vs Callables.  But this provided no real value (and the
    performance differences are not noticeable) and unnecessarily
    complicates both usage and layered APis.

These changes should simplify J2EE adaptations and extensions.

Doing this also entailed a couple of other boring changes.

As always, reactions would be welcome.

These changes apparently won't make it into the first early-access or
beta releases of Sun J2SE1.5, but should make it in the following
versions. However, we've put instructions on how to cope at
  http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
where it now says:

  There is a lag between JSR166 spec changes and integration into Sun
  J2SE1.5. If you are running an early access or beta version of 1.5,
  you can make sure you are running the current versions listed in the
  javadocs on this site by getting the jar file at
  http://gee.cs.oswego.edu/dl/concurrent/dist/jsr166.jar, and run using:
    java -server -Xbootclasspath/p:/somepath/jsr166.jar Program
  (The "server" option is not strictly needed but is highly recommended
  for concurrent programs.)

-Doug


From eric.zoerner@gemstone.com  Fri Dec  5 18:38:13 2003
From: eric.zoerner@gemstone.com (Eric Zoerner)
Date: Fri, 05 Dec 2003 10:38:13 -0800
Subject: [concurrency-interest] ConcurrentMap.replace
In-Reply-To: <3FCE99D5.2060907@gemstone.com>
References: <16319.22801.18128.679982@altair.cs.oswego.edu>	<3FC240A4.5000608@gemstone.com>	<16322.44755.146905.552519@altair.cs.oswego.edu>	<3FC39563.2080904@gemstone.com> <16329.15553.828211.230152@altair.cs.oswego.edu> <3FCE99D5.2060907@gemstone.com>
Message-ID: <3FD0D095.1010104@gemstone.com>

Actually, I do have a use case for the replace method to return the old value. 
In cache eviction, you need to replace an existing value with a NullObject, but 
you need the previous value, if there is one, in order to 1) know if it had been 
already evicted, in which case you might do nothing else; and 2) put the old 
value into an event object that is passed to a listener that is interested in 
the cache eviction and may want to know what the old value was. In any case, 
getting the old value at the time of replace is impossible without race 
conditions unless the replace method returns the old value.

Eric Zoerner wrote:
> Doug, thanks for adding the two-arg replace method, and I agree with 
> your analysis. However, I was expecting the two-arg replace method to 
> return the oldValue, not a boolean. I don't have a use case for why it 
> should return the oldValue, but it seems like it would provide more 
> information than a boolean. If the return value is null, then we know 
> the key didn't exist and the replace didn't happen (same as the current 
> return of false). Otherwise we get the object that was replaced, similar 
> to the return value from put and putIfAbsent. [Of course, if the Map 
> supports null values then there is ambiguity, but that is also true of 
> putIfAbsent].
> 
> - Eric
> 



From jozart@blarg.net  Fri Dec  5 21:03:26 2003
From: jozart@blarg.net (Joseph Bowbeer)
Date: Fri, 5 Dec 2003 13:03:26 -0800
Subject: [concurrency-interest] ConcurrentMap.replace
References: <16319.22801.18128.679982@altair.cs.oswego.edu>	<3FC240A4.5000608@gemstone.com>	<16322.44755.146905.552519@altair.cs.oswego.edu>	<3FC39563.2080904@gemstone.com> <16329.15553.828211.230152@altair.cs.oswego.edu> <3FCE99D5.2060907@gemstone.com> <3FD0D095.1010104@gemstone.com>
Message-ID: <002b01c3bb73$3a3aa1a0$10987cce@REPLICANT2>

Eric Zoerner writes:

> In any case, getting the old value at the time of replace is
> impossible without race conditions unless the replace method
> returns the old value.

The old value is one of the parameters to the replace method, right?  So why
doesn't the following work?

  if (replace(key, oldValue, newValue)) {
    // do something with oldValue here
  }

This does raise questions about whether the value replacement test is equals
or ==; it is equals.


----- Original Message ----- 
From: "Eric Zoerner" <eric.zoerner@gemstone.com>
To: "Doug Lea" <dl@altair.cs.oswego.edu>
Cc: <concurrency-interest@altair.cs.oswego.edu>
Sent: Friday, December 05, 2003 10:38 AM
Subject: Re: [concurrency-interest] ConcurrentMap.replace


Actually, I do have a use case for the replace method to return the old
value.
In cache eviction, you need to replace an existing value with a NullObject,
but
you need the previous value, if there is one, in order to 1) know if it had
been
already evicted, in which case you might do nothing else; and 2) put the old
value into an event object that is passed to a listener that is interested
in
the cache eviction and may want to know what the old value was. In any case,
getting the old value at the time of replace is impossible without race
conditions unless the replace method returns the old value.

Eric Zoerner wrote:
> Doug, thanks for adding the two-arg replace method, and I agree with
> your analysis. However, I was expecting the two-arg replace method to
> return the oldValue, not a boolean. I don't have a use case for why it
> should return the oldValue, but it seems like it would provide more
> information than a boolean. If the return value is null, then we know
> the key didn't exist and the replace didn't happen (same as the current
> return of false). Otherwise we get the object that was replaced, similar
> to the return value from put and putIfAbsent. [Of course, if the Map
> supports null values then there is ambiguity, but that is also true of
> putIfAbsent].
>
> - Eric
>



From eric.zoerner@gemstone.com  Fri Dec  5 22:31:13 2003
From: eric.zoerner@gemstone.com (Eric Zoerner)
Date: Fri, 05 Dec 2003 14:31:13 -0800
Subject: [concurrency-interest] ConcurrentMap.replace
In-Reply-To: <002b01c3bb73$3a3aa1a0$10987cce@REPLICANT2>
References: <16319.22801.18128.679982@altair.cs.oswego.edu>	<3FC240A4.5000608@gemstone.com>	<16322.44755.146905.552519@altair.cs.oswego.edu>	<3FC39563.2080904@gemstone.com> <16329.15553.828211.230152@altair.cs.oswego.edu> <3FCE99D5.2060907@gemstone.com> <3FD0D095.1010104@gemstone.com> <002b01c3bb73$3a3aa1a0$10987cce@REPLICANT2>
Message-ID: <3FD10731.4000408@gemstone.com>

I was referring to the two-arg version of the replace method,

   boolean replace(K key, V newValue);

which replaces with the new value only if key exists, regardless of the oldValue 
  (and does not return the oldValue).


Joseph Bowbeer wrote:

> Eric Zoerner writes:
> 
> 
>>In any case, getting the old value at the time of replace is
>>impossible without race conditions unless the replace method
>>returns the old value.
> 
> 
> The old value is one of the parameters to the replace method, right?  So why
> doesn't the following work?
> 
>   if (replace(key, oldValue, newValue)) {
>     // do something with oldValue here
>   }
> 
> This does raise questions about whether the value replacement test is equals
> or ==; it is equals.
> 
> 
> ----- Original Message ----- 
> From: "Eric Zoerner" <eric.zoerner@gemstone.com>
> To: "Doug Lea" <dl@altair.cs.oswego.edu>
> Cc: <concurrency-interest@altair.cs.oswego.edu>
> Sent: Friday, December 05, 2003 10:38 AM
> Subject: Re: [concurrency-interest] ConcurrentMap.replace
> 
> 
> Actually, I do have a use case for the replace method to return the old
> value.
> In cache eviction, you need to replace an existing value with a NullObject,
> but
> you need the previous value, if there is one, in order to 1) know if it had
> been
> already evicted, in which case you might do nothing else; and 2) put the old
> value into an event object that is passed to a listener that is interested
> in
> the cache eviction and may want to know what the old value was. In any case,
> getting the old value at the time of replace is impossible without race
> conditions unless the replace method returns the old value.
> 
> Eric Zoerner wrote:
> 
>>Doug, thanks for adding the two-arg replace method, and I agree with
>>your analysis. However, I was expecting the two-arg replace method to
>>return the oldValue, not a boolean. I don't have a use case for why it
>>should return the oldValue, but it seems like it would provide more
>>information than a boolean. If the return value is null, then we know
>>the key didn't exist and the replace didn't happen (same as the current
>>return of false). Otherwise we get the object that was replaced, similar
>>to the return value from put and putIfAbsent. [Of course, if the Map
>>supports null values then there is ambiguity, but that is also true of
>>putIfAbsent].
>>
>>- Eric



From dl@cs.oswego.edu  Fri Dec  5 23:36:08 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 5 Dec 2003 18:36:08 -0500
Subject: [concurrency-interest] ConcurrentMap.replace
In-Reply-To: <3FD0D095.1010104@gemstone.com>
References: <16319.22801.18128.679982@altair.cs.oswego.edu>
 <3FC240A4.5000608@gemstone.com>
 <16322.44755.146905.552519@altair.cs.oswego.edu>
 <3FC39563.2080904@gemstone.com>
 <16329.15553.828211.230152@altair.cs.oswego.edu>
 <3FCE99D5.2060907@gemstone.com>
 <3FD0D095.1010104@gemstone.com>
Message-ID: <16337.5736.565417.886703@altair.cs.oswego.edu>

> Actually, I do have a use case for the replace method to return the old value.

Done. Sorry for the confusion and delay.

The now-to-be-usual caveats about this change not making beta1 apply.

-Doug

From dl@cs.oswego.edu  Wed Dec 10 13:36:59 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 10 Dec 2003 08:36:59 -0500
Subject: [concurrency-interest] Executor framework adjustments
In-Reply-To: <16336.40510.652534.642309@altair.cs.oswego.edu>
References: <16336.40510.652534.642309@altair.cs.oswego.edu>
Message-ID: <16343.8571.244668.568113@altair.cs.oswego.edu>

It took us a few days to realize that we had missed one (and we really
hope, last) impediment that might hinder J2EE extensions and
adaptations. The "Executors" class was the only vehicle for linking
together implementations of Executors and Futures (in the "invoke" and
"execute" methods), but it forced use of the default FutureTask
implementation. This would have required some extensions to create a
similar but different Executors-like class just for the sake of
breaking this link. The solution required a bit more refactoring:
These methods are now in the ExecutorService interface, with default
implementations (still using FutureTask) in new
AbstractExecutorService class. This also required renaming the
execute-and-return-Future methods to "submit" because they cannot be
legally overloaded vs the base "execute" method. The ScheduledExecutor
methods also work similarly.

With this change, we are becoming more confident that a viable J2EE
API could mainly consist of a way to create or access an
ExecutorService (and similarly ScheduledExecutor) implementation that
infused appropriate J2EE context in the tasks and/or executors.

People using the existing/beta1 versions may need to adjust their
code, although in easy ways-- mainly changes of the form:
  Future f = Executors.execute(exec, task) 
to 
  Future f = exec.submit(task)

Sorry for this churn, but it is far better to address these issues now
than for everyone to suffer the consequences of eventual forced
J2SE/J2EE inconsistencies.

As always, comments would be very welcome.

-Doug

From bjornoh@mi.uib.no  Wed Dec 10 13:55:29 2003
From: bjornoh@mi.uib.no (=?ISO-8859-1?Q?Bj=F8rn-Ove_Heimsund?=)
Date: Wed, 10 Dec 2003 14:55:29 +0100 (CET)
Subject: [concurrency-interest] LIFO queuing
In-Reply-To: <16343.8571.244668.568113@altair.cs.oswego.edu>
References: <16336.40510.652534.642309@altair.cs.oswego.edu>
 <16343.8571.244668.568113@altair.cs.oswego.edu>
Message-ID: <Pine.LNX.4.53.0312101445160.14992@matteus.mi.uib.no>

Hi,

I've been using the precursor to the java.util.concurrent package, which
includes the FJTasks. Using these, I could fill up an FJTaskRunnerGroup
with FJTasks to keep all CPUs busy.

However, each FJTask might spawn new FJTasks, and the parent would have to
wait for the children threads to finish before it could resume. The method

 FJTaskRunnerGroup.invoke(FJTask)

would then block (cyclic dependency), as it's a FIFO type queue. As an
alternative, I checked if the running thread is an FJTaskRunner, and if
so, new tasks would be put in front of the queue (LIFO style). This
avoided all issues, and performance was excellent. The code snippet is:

 if ((Runnable) Thread.currentThread() instanceof FJTaskRunner) {
   FJTask task = new FJTask(thread);
   task.fork(); // LIFO insertion
   task.join();
 }

Now, it is not clear to me how to do this in the upcomming
java.util.concurrent. How can I explicitly preempt a running thread in
favor of a given thread?

-- 
Bjørn-Ove Heimsund
Centre for Integrated Petroleum Research
University of Bergen, Norway

Bjorn-Ove.Heimsund@uib.no
(+47) 555 84962


From dholmes@dltech.com.au  Thu Dec 11 00:45:36 2003
From: dholmes@dltech.com.au (David Holmes)
Date: Thu, 11 Dec 2003 10:45:36 +1000
Subject: [concurrency-interest] LIFO queuing
In-Reply-To: <Pine.LNX.4.53.0312101445160.14992@matteus.mi.uib.no>
Message-ID: <NFBBKALFDCPFIDBNKAPCCENNDKAA.dholmes@dltech.com.au>

> Now, it is not clear to me how to do this in the upcomming
> java.util.concurrent. How can I explicitly preempt a
> running thread in favor of a given thread?

The FJTask framework is not part of the JSR-166 effort. Hence you'll
still need Doug's package for this in the future.

David Holmes


From dl@cs.oswego.edu  Fri Dec 12 01:03:07 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 11 Dec 2003 20:03:07 -0500
Subject: [concurrency-interest] Executors and J2EE Work frameworks
Message-ID: <16345.5067.353790.93240@altair.cs.oswego.edu>

We are still looking over integration issues with the proposed (but
not yet accepted) J2SEE Work and Timer JSRs. If you have actually used
the BEA or IBM precursors of these proposed APIs, and have any experiences
or observations you'd like to tell us about, we'd be very happy to
hear of them, the sooner the better.

Again, they are at:
  http://www.jcp.org/en/jsr/detail?id=236
  http://www.jcp.org/en/jsr/detail?id=237
Follow links near the bottom of each to see BEA and IBM's proposed
APIs.

Thanks!

-Doug

From david@coredevelopers.net  Fri Dec 12 20:39:40 2003
From: david@coredevelopers.net (David Jencks)
Date: Fri, 12 Dec 2003 12:39:40 -0800
Subject: FW: [concurrency-interest] Executors and J2EE Work frameworks
In-Reply-To: <NBBBJGEAGJAKLIDBKJOPOEECFPAB.noel@devtech.com>
Message-ID: <4F0B56EF-2CE3-11D8-A4A2-003065F4889C@coredevelopers.net>

I've just reviewed the J2ee Work specification proposal.  In my opinion 
it is a worthwhile effort and a good starting point, with the following 
reservations:

This proposal does not even mention two critical and essential aspects 
of any j2ee proposal, namely the relationship to security and 
transaction contexts.  In contrast to the J2ee Connector Architecture 
1.5 spec, where security context propagation issues are significant and 
totally ignored, inside an application server I don't see significant 
issues with propagating a security context between threads.  However, 
there are many obvious and major issues with propagating a transaction 
context between threads, ranging from in-vm synchronization/locking 
issues to indeterminate results if two threads access a single resource 
manager within the same transaction.  The Connector 1.5 spec deals with 
these by the simple expedient of prohibiting concurrent imports of the 
same transaction.  While this solution is obviously sufficient, I'm not 
convinced that it is the only workable solution.  Anything else will 
IMO require a lot of careful thought and several implementations to 
make sure it is actually workable.

This proposal points out that the Connector 1.5 WorkManager is not 
suitable for use from a j2ee application.  IMO it is also not usually 
suitable for use from anything such as a resource adapter that wishes 
to import transactions.  The Connector 1.5 ExecutionContext requires 
specification of the Xid for the transaction to import before the work 
is submitted (section 10.3.5).  This requires the submitting thread to 
interpret the incoming data to extract the Xid.  Since this could 
involve an arbitrarily large amount of work (for instance if the xid is 
hidden inside a very large message), extracting the xid could more 
scalably be done inside the worker thread.

I would like to see this specification develop to include discussion 
and resolution of fast, scalable security and transaction context 
propagation and provide a solution to the limitations of the Connector 
1.5 work model.

Many thanks,
/**********************************
* David Jencks
* Partner
* Core Developers Network
* http://www.coredevelopers.net
**********************************/

On Thursday, December 11, 2003, at 05:29 PM, Noel J. Bergman wrote:

> Since these two JSRs were discussed here recently, I thought that there
> might be some folks who would like to comment.
>
> Please comment directly to concurrency-interest@altair.cs.oswego.edu.
>
> 	--- Noel
>
> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu
> [mailto:concurrency-interest-admin@cs.oswego.edu]On Behalf Of Doug Lea
> Sent: Thursday, December 11, 2003 20:03
> To: concurrency-interest@altair.cs.oswego.edu
> Subject: [concurrency-interest] Executors and J2EE Work frameworks
>
>
>
> We are still looking over integration issues with the proposed (but
> not yet accepted) J2EE Work and Timer JSRs. If you have actually used
> the BEA or IBM precursors of these proposed APIs, and have any 
> experiences
> or observations you'd like to tell us about, we'd be very happy to
> hear of them, the sooner the better.
>
> Again, they are at:
>   http://www.jcp.org/en/jsr/detail?id=236
>   http://www.jcp.org/en/jsr/detail?id=237
> Follow links near the bottom of each to see BEA and IBM's proposed
> APIs.
>
> Thanks!
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From charlton_b@gmx.ch  Fri Dec 12 21:50:51 2003
From: charlton_b@gmx.ch (Charlton Barreto)
Date: Fri, 12 Dec 2003 13:50:51 -0800
Subject: [concurrency-interest] Executors and J2EE Work frameworks
Message-ID: <410AE244-2CED-11D8-BA14-000A95DA2F1E@gmx.ch>

Although at first I had my reservations about these specs, upon further 
review I believe they to be worthwhile efforts, and they should be 
carefully observed. I would like to see someone represent this 
community in either or both EGs, esp. the Work Manager group. With Work 
Management, a number of issues exist w.r.t. propagating transaction and 
security contexts between threads - managing run-as authentication and 
enabling concurrent propagation of a single transaction context 
immediately come to mind. With Timers, there are various issue with 
addressing timer thread management within a J2EE container in a general 
fashion. The spec proposals do not cover all of these, and if these 
specs can receive input and guidance from various experts, they can 
hopefully address thread and timer management within J2EE in a 
comprehensive manner.

On Thursday, December 11, 2003, at 05:29 PM, Noel J. Bergman wrote:

> Since these two JSRs were discussed here recently, I thought that there
> might be some folks who would like to comment.
>
> Please comment directly to concurrency-interest@altair.cs.oswego.edu.
>
> 	--- Noel
>
> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu
> [mailto:concurrency-interest-admin@cs.oswego.edu]On Behalf Of Doug Lea
> Sent: Thursday, December 11, 2003 20:03
> To: concurrency-interest@altair.cs.oswego.edu
> Subject: [concurrency-interest] Executors and J2EE Work frameworks
>
>
>
> We are still looking over integration issues with the proposed (but
> not yet accepted) J2EE Work and Timer JSRs. If you have actually used
> the BEA or IBM precursors of these proposed APIs, and have any 
> experiences
> or observations you'd like to tell us about, we'd be very happy to
> hear of them, the sooner the better.
>
> Again, they are at:
>   http://www.jcp.org/en/jsr/detail?id=236
>   http://www.jcp.org/en/jsr/detail?id=237
> Follow links near the bottom of each to see BEA and IBM's proposed
> APIs.
>
> Thanks!
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From charlton_b@gmx.ch  Fri Dec 12 22:37:57 2003
From: charlton_b@gmx.ch (Charlton Barreto)
Date: Fri, 12 Dec 2003 14:37:57 -0800
Subject: [concurrency-interest] Executors and J2EE Work frameworks
In-Reply-To: <C9C825FD-2CEE-11D8-A4A2-003065F4889C@coredevelopers.net>
References: <C9C825FD-2CEE-11D8-A4A2-003065F4889C@coredevelopers.net>
Message-ID: <D566BBC2-2CF3-11D8-BA14-000A95DA2F1E@gmx.ch>

On Dec 12, 2003, at 14:01, David Jencks wrote:

> I agree completely, and applied for the Work Management expert group.  
> We'll see what happens:-)

Great! I've applied for the Timers EG. Hopefully we'll both get in. :-)

> I applied as an individual.   If anyone thinks it would be better to 
> apply as a Geronimo or Apache representative please say so and explain 
> why: I thought it would add administrative complexity without adding 
> value.

I'd agree that it would for the most part only add administrative 
complexity. Applying as an Apache (or SUNY-Oswego) representative would 
only add flexibility in that the organization would 'own' the 
membership, so that if you needed to be 'offline' from the spec and 
wanted someone else in the project to be on the EG list, it would be 
relatively easy to do so. AFAIK Apache already is a JCP member so this 
shouldn't be a big deal.

> So far I haven't reviewed the timer spec.

I read through it and I feel that it would better serve J2EE for it to 
be abstracted somewhat, primarily to handle various timer mechanisms. 
The input spec is a pretty good start but to best satisfy timer 
requirements in the enterprise space, I think it needs a bit more, even 
if, say one vendor or another might not use all types of timers.

Cheers,

-Charlton.

> thanks
> david jencks
>
> On Friday, December 12, 2003, at 01:50 PM, Charlton Barreto wrote:
>
>> Although at first I had my reservations about these specs, upon 
>> further review I believe they to be worthwhile efforts, and they 
>> should be carefully observed. I would like to see someone represent 
>> this community in either or both EGs, esp. the Work Manager group. 
>> With Work Management, a number of issues exist w.r.t. propagating 
>> transaction and security contexts between threads - managing run-as 
>> authentication and enabling concurrent propagation of a single 
>> transaction context immediately come to mind. With Timers, there are 
>> various issue with addressing timer thread management within a J2EE 
>> container in a general fashion. The spec proposals do not cover all 
>> of these, and if these specs can receive input and guidance from 
>> various experts, they can hopefully address thread and timer 
>> management within J2EE in a comprehensive manner.
>>
>> On Thursday, December 11, 2003, at 05:29 PM, Noel J. Bergman wrote:
>>
>>> Since these two JSRs were discussed here recently, I thought that 
>>> there
>>> might be some folks who would like to comment.
>>>
>>> Please comment directly to concurrency-interest@altair.cs.oswego.edu.
>>>
>>> 	--- Noel
>>>
>>> -----Original Message-----
>>> From: concurrency-interest-admin@cs.oswego.edu
>>> [mailto:concurrency-interest-admin@cs.oswego.edu]On Behalf Of Doug 
>>> Lea
>>> Sent: Thursday, December 11, 2003 20:03
>>> To: concurrency-interest@altair.cs.oswego.edu
>>> Subject: [concurrency-interest] Executors and J2EE Work frameworks
>>>
>>>
>>>
>>> We are still looking over integration issues with the proposed (but
>>> not yet accepted) J2EE Work and Timer JSRs. If you have actually used
>>> the BEA or IBM precursors of these proposed APIs, and have any 
>>> experiences
>>> or observations you'd like to tell us about, we'd be very happy to
>>> hear of them, the sooner the better.
>>>
>>> Again, they are at:
>>>   http://www.jcp.org/en/jsr/detail?id=236
>>>   http://www.jcp.org/en/jsr/detail?id=237
>>> Follow links near the bottom of each to see BEA and IBM's proposed
>>> APIs.
>>>
>>> Thanks!
>>>
>>> -Doug
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest@altair.cs.oswego.edu
>>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>


From charlton_b@mac.com  Fri Dec 12 22:31:41 2003
From: charlton_b@mac.com (Charlton Barreto)
Date: Fri, 12 Dec 2003 14:31:41 -0800
Subject: [concurrency-interest] Executors and J2EE Work frameworks
In-Reply-To: <C9C825FD-2CEE-11D8-A4A2-003065F4889C@coredevelopers.net>
References: <C9C825FD-2CEE-11D8-A4A2-003065F4889C@coredevelopers.net>
Message-ID: <F52BE134-2CF2-11D8-BA14-000A95DA2F1E@mac.com>

On Dec 12, 2003, at 14:01, David Jencks wrote:

> I agree completely, and applied for the Work Management expert group.  
> We'll see what happens:-)

Great! I've applied for the Timers EG. Hopefully we'll both get in. :-)

> I applied as an individual.   If anyone thinks it would be better to 
> apply as a Geronimo or Apache representative please say so and explain 
> why: I thought it would add administrative complexity without adding 
> value.

I'd agree that it would for the most part only add administrative 
complexity. Applying as an Apache (or SUNY-Oswego) representative would 
only add flexibility in that the organization would 'own' the 
membership, so that if you needed to be 'offline' from the spec and 
wanted someone else in the project to be on the EG list, it would be 
relatively easy to do so. AFAIK Apache already is a JCP member so this 
shouldn't be a big deal.

> So far I haven't reviewed the timer spec.

I read through it and I feel that it would better serve J2EE for it to 
be abstracted somewhat, primarily to handle various timer mechanisms. 
The input spec is a pretty good start but to best satisfy timer 
requirements in the enterprise space, I think it needs a bit more, even 
if, say one vendor or another might not use all types of timers.

Cheers,

-Charlton.

> thanks
> david jencks
>
> On Friday, December 12, 2003, at 01:50 PM, Charlton Barreto wrote:
>
>> Although at first I had my reservations about these specs, upon 
>> further review I believe they to be worthwhile efforts, and they 
>> should be carefully observed. I would like to see someone represent 
>> this community in either or both EGs, esp. the Work Manager group. 
>> With Work Management, a number of issues exist w.r.t. propagating 
>> transaction and security contexts between threads - managing run-as 
>> authentication and enabling concurrent propagation of a single 
>> transaction context immediately come to mind. With Timers, there are 
>> various issue with addressing timer thread management within a J2EE 
>> container in a general fashion. The spec proposals do not cover all 
>> of these, and if these specs can receive input and guidance from 
>> various experts, they can hopefully address thread and timer 
>> management within J2EE in a comprehensive manner.
>>
>> On Thursday, December 11, 2003, at 05:29 PM, Noel J. Bergman wrote:
>>
>>> Since these two JSRs were discussed here recently, I thought that 
>>> there
>>> might be some folks who would like to comment.
>>>
>>> Please comment directly to concurrency-interest@altair.cs.oswego.edu.
>>>
>>> 	--- Noel
>>>
>>> -----Original Message-----
>>> From: concurrency-interest-admin@cs.oswego.edu
>>> [mailto:concurrency-interest-admin@cs.oswego.edu]On Behalf Of Doug 
>>> Lea
>>> Sent: Thursday, December 11, 2003 20:03
>>> To: concurrency-interest@altair.cs.oswego.edu
>>> Subject: [concurrency-interest] Executors and J2EE Work frameworks
>>>
>>>
>>>
>>> We are still looking over integration issues with the proposed (but
>>> not yet accepted) J2EE Work and Timer JSRs. If you have actually used
>>> the BEA or IBM precursors of these proposed APIs, and have any 
>>> experiences
>>> or observations you'd like to tell us about, we'd be very happy to
>>> hear of them, the sooner the better.
>>>
>>> Again, they are at:
>>>   http://www.jcp.org/en/jsr/detail?id=236
>>>   http://www.jcp.org/en/jsr/detail?id=237
>>> Follow links near the bottom of each to see BEA and IBM's proposed
>>> APIs.
>>>
>>> Thanks!
>>>
>>> -Doug
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest@altair.cs.oswego.edu
>>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>


From charlton_b@mac.com  Fri Dec 12 22:31:41 2003
From: charlton_b@mac.com (Charlton Barreto)
Date: Fri, 12 Dec 2003 14:31:41 -0800
Subject: [concurrency-interest] Executors and J2EE Work frameworks
Message-ID: <1F0AEDD4-2CF3-11D8-BA14-000A95DA2F1E@mac.com>

On Dec 12, 2003, at 14:01, David Jencks wrote:

> I agree completely, and applied for the Work Management expert group.  
> We'll see what happens:-)

Great! I've applied for the Timers EG. Hopefully we'll both get in. :-)

> I applied as an individual.   If anyone thinks it would be better to 
> apply as a Geronimo or Apache representative please say so and explain 
> why: I thought it would add administrative complexity without adding 
> value.

I'd agree that it would for the most part only add administrative 
complexity. Applying as an Apache (or SUNY-Oswego) representative would 
only add flexibility in that the organization would 'own' the 
membership, so that if you needed to be 'offline' from the spec and 
wanted someone else in the project to be on the EG list, it would be 
relatively easy to do so. AFAIK Apache already is a JCP member so this 
shouldn't be a big deal.

> So far I haven't reviewed the timer spec.

I read through it and I feel that it would better serve J2EE for it to 
be abstracted somewhat, primarily to handle various timer mechanisms. 
The input spec is a pretty good start but to best satisfy timer 
requirements in the enterprise space, I think it needs a bit more, even 
if, say one vendor or another might not use all types of timers.

Cheers,

-Charlton.

> thanks
> david jencks
>
> On Friday, December 12, 2003, at 01:50 PM, Charlton Barreto wrote:
>
>> Although at first I had my reservations about these specs, upon 
>> further review I believe they to be worthwhile efforts, and they 
>> should be carefully observed. I would like to see someone represent 
>> this community in either or both EGs, esp. the Work Manager group. 
>> With Work Management, a number of issues exist w.r.t. propagating 
>> transaction and security contexts between threads - managing run-as 
>> authentication and enabling concurrent propagation of a single 
>> transaction context immediately come to mind. With Timers, there are 
>> various issue with addressing timer thread management within a J2EE 
>> container in a general fashion. The spec proposals do not cover all 
>> of these, and if these specs can receive input and guidance from 
>> various experts, they can hopefully address thread and timer 
>> management within J2EE in a comprehensive manner.
>>
>> On Thursday, December 11, 2003, at 05:29 PM, Noel J. Bergman wrote:
>>
>>> Since these two JSRs were discussed here recently, I thought that 
>>> there
>>> might be some folks who would like to comment.
>>>
>>> Please comment directly to concurrency-interest@altair.cs.oswego.edu.
>>>
>>> 	--- Noel
>>>
>>> -----Original Message-----
>>> From: concurrency-interest-admin@cs.oswego.edu
>>> [mailto:concurrency-interest-admin@cs.oswego.edu]On Behalf Of Doug 
>>> Lea
>>> Sent: Thursday, December 11, 2003 20:03
>>> To: concurrency-interest@altair.cs.oswego.edu
>>> Subject: [concurrency-interest] Executors and J2EE Work frameworks
>>>
>>>
>>>
>>> We are still looking over integration issues with the proposed (but
>>> not yet accepted) J2EE Work and Timer JSRs. If you have actually used
>>> the BEA or IBM precursors of these proposed APIs, and have any 
>>> experiences
>>> or observations you'd like to tell us about, we'd be very happy to
>>> hear of them, the sooner the better.
>>>
>>> Again, they are at:
>>>   http://www.jcp.org/en/jsr/detail?id=236
>>>   http://www.jcp.org/en/jsr/detail?id=237
>>> Follow links near the bottom of each to see BEA and IBM's proposed
>>> APIs.
>>>
>>> Thanks!
>>>
>>> -Doug
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest@altair.cs.oswego.edu
>>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>


From dl@cs.oswego.edu  Sat Dec 13 00:21:32 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 12 Dec 2003 19:21:32 -0500
Subject: FW: [concurrency-interest] Executors and J2EE Work frameworks
In-Reply-To: <4F0B56EF-2CE3-11D8-A4A2-003065F4889C@coredevelopers.net>
References: <NBBBJGEAGJAKLIDBKJOPOEECFPAB.noel@devtech.com>
 <4F0B56EF-2CE3-11D8-A4A2-003065F4889C@coredevelopers.net>
Message-ID: <16346.23436.352042.985589@altair.cs.oswego.edu>

Nearly everyone agrees that it will be useful and important to have an
asynch execution framework available in J2EE as well as J2SE.  Among
the main goals at this point is to ensure that APIs are as consistent
as possible across J2SE and J2EE. (For those not familiar with J2EE:
they cannot be exactly the same because J2EE tasks must all run within
context (transaction, security etc) settings maintained by
containers. So both Executors managing threads and Futures maintaining
task context must be controlled by containers. And instead of making
concrete implementations available there must be some mechanism for
applications to ask containers to produce or access one.)

I volunteered today to serve on the JSR236/7 expert groups (assuming
they are accepted), and try to help ensure consistency etc.  The
ultimate APIs might look more like JSR166's than do those in the JSR
proposals. Or maybe not, if there turn out to be good reasons to make
them different.  In the mean time, if you are a J2EE user, you can
help by trying to find any obstacles that might be remaining in our
APIs before changes become impossible (very soon!)

-Doug




From dl@cs.oswego.edu  Mon Dec 15 16:56:14 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 15 Dec 2003 11:56:14 -0500
Subject: [concurrency-interest] new task coordination operations
Message-ID: <16349.59310.398192.663745@altair.cs.oswego.edu>

People who thought we (the JSR166 expert group) were too cowardly over
the past year in not taking a stance on providing APIs for managing
sets of asynch tasks can thank those J2EE JSR proposers for goading us
into yet further last-minute action. We now realize that without
these, we would have failed to provide a reasonable basis for this and
other other layered APIs.

We were still slightly indecisive about which of the paths to
take here, so we decided to support two styles.

The more general of these is the CompletionService interface and
ExecutorCompletionService class. This is a lightweight class that can
be attached to any Executor to manage completion queues, and
can be used to coordinate lots of common asynch task problems.

The second is to new methods invokeAny and invokeAll in
ExecutorService. These take lists of tasks, execute them all, and then
wait for at least one (invokeAny) or all (invokeAll) to complete.
While these can be implemented easily using a CompletionService, they
are common enough to expose separately, and also admit special-purpose
solutions that might be a bit more efficient in some ExecutorServices
than you could obtain yourself.

We are still in the midst of debating a few minor API issues surrounding
these, but the current versions are now out in the usual place:
  http://gee.cs.oswego.edu/dl/concurrent/dist/docs/index.html
And feedback will be most welcome.

Note that we are still too cowardly to establish particular callback
APIs though. Instead, as always, we support subclass hooks in concrete
Executor and Future classes so you can define them yourself.

-Doug

From eric.zoerner@gemstone.com  Mon Dec 15 17:35:11 2003
From: eric.zoerner@gemstone.com (Eric Zoerner)
Date: Mon, 15 Dec 2003 09:35:11 -0800
Subject: [concurrency-interest] Question about Java Memory Model
Message-ID: <3FDDF0CF.70001@gemstone.com>

We are seeing some bizarre behavior in the ConcurrentHashMap where one thread 
constructs an objects and puts it into a CHM and another thread gets the object 
and sees it as uninitialized. My question has to do with the Java Memory Model 
and volatile fields. It looks like the CHM attempts to protect against the 
scenario just described by writing to the count field of the segment, which is a 
volatile field. The intent seems to be that this will invoke a memory barrier 
which will flush _all_ pending writes in the thread working set to memory. Is 
this correct?

I could not find any information that would make that guarantee, however, either 
in the Java Language Spec or in Concurrent Programming in Java. Those references 
say that writing to a volatile field only flushes that one variable to memory, 
not all pending writes.

The object being constructed and then seen as  uninitialized is, by the way, 
another instance of ConcurrentHashMap.

How can this scenario occur?  Is synchronization necessary to make sure newly 
constructed objects put into a CHM are visible to other threads as fully 
initialized?

Eric Zoerner
GemStone Systems.
http://www.gemstone.com



From matthias.ernst@coremedia.com  Mon Dec 15 18:41:17 2003
From: matthias.ernst@coremedia.com (matthias.ernst@coremedia.com)
Date: Mon, 15 Dec 2003 19:41:17 +0100 (CET)
Subject: [concurrency-interest] Re: reordering around volatiles (fwd)
Message-ID: <Pine.LNX.4.33.0312151937130.1750-100000@bebop.coremedia.com>

I had a similar question a while ago and got an answer from Bill
Pugh. Reading/Writing volatiles does constitute a memory barrier in the
revised memory model. Please see below.

I actually remember that Hotspot 1.4.1 or 1.4.2 actually should already
implement this behaviour. I forgot the source. Your findings seem to
contradict.

Please see below.

-- 
Matthias Ernst
CoreMedia - Smart Content Technology

"Overall, JAXP is much like the rest of Java: a partial description
intended to assist developers in using a single implementation"

---------- Forwarded message ----------
Date: Tue, 19 Aug 2003 14:48:06 -0400
From: Bill Pugh <pugh@cs.umd.edu>
To: matthias.ernst@coremedia.com
Cc: jsr-133-eg@jcp.org
Subject: Re: reordering around volatiles

Matthias,
   Double-checked locking does indeed allow double-checked locking to work.

   If thread t1 writes to a volatile variable v, and thread t2 reads
that volatile and sees the value written by thread t1, it establishes
a happens-before relationship from t1 to t2. In particular, any
writes performed by t1 before it writes to the volatile are
guaranteed to be visible to any reads by thread t2 after it reads
that volatile.

The code you gave for currentCache works fine, although if multiple
threads are updating the cache without other synchronization, updates
could be lost. The other thing you should be aware of is that the new
JSR-166 concurrency libraries will contain a ConcurrentHashMap that
should suit your needs well. It doesn't require any locks for reading
(internally, it uses volatiles) and offers very high performance. See
the following javadoc for more information.
	http://gee.cs.oswego.edu/dl/concurrent/dist/docs/java/util/concurrent/ConcurrentHashMap.html

Bill Pugh

>Hi,
>
>the verdict on "Double-checked Locking"
>(http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)
>predicts DCL to be correct under the proposed model when using a volatile
>object reference (see bottom of page, "Under the proposed Java Memory
>Model / Fixing Double-Checked Locking using Volatile").
>
>I cannot seem to derive that from the review specification. Is it correct
>to use a volatile here ? Actually, I want to atomically exchange an object
>reference for another but that seems equivalent:
>
>volatile HashMap currentCache;
>
>read:
>   currentCache.get(key)
>   ...
>
>write:
>   HashMap newCurrentCache = new HashMap(currentCache).withNewValue()
>   currentCache = newCurrentCache
>
>
>
>Regards
>Matthias
>--
>Matthias Ernst
>Software Engineer


From David.Biesack@sas.com  Tue Dec 16 15:15:50 2003
From: David.Biesack@sas.com (David J. Biesack)
Date: Tue, 16 Dec 2003 10:15:50 -0500 (EST)
Subject: [concurrency-interest] Re: new task coordination operations (Doug Lea)
In-Reply-To: <20031215170001.13381.7051.Mailman@altair.cs.oswego.edu>
 (concurrency-interest-request@cs.oswego.edu)
References: <20031215170001.13381.7051.Mailman@altair.cs.oswego.edu>
Message-ID: <200312161515.hBGFFoJ12449@mozart.unx.sas.com>

 
> The second is to new methods invokeAny and invokeAll in
> ExecutorService. These take lists of tasks, execute them all, and then
> wait for at least one (invokeAny) or all (invokeAll) to complete.
> While these can be implemented easily using a CompletionService, they
> are common enough to expose separately, and also admit special-purpose
> solutions that might be a bit more efficient in some ExecutorServices
> than you could obtain yourself.

Whenever I see two (and only two) options in an API, I think "looks like
an opportunity for a strategy pattern". 

I know it's tempting/dangerous to overengineer, but is there some use in
a generic invoke() method which takes a completion strategy object as a
parameter? The two degenerate cases above (one completes, all completes)
can be implemented with specific completion strategy objects available
from a factory method.

Sorry, I don't have a specific use case from an actual system, but I can
imagine several: n worker classes and 1 'escape' task - complete when
the n workers finish, or when the escape task finishes. Or, perhaps
I complete when I've found a 'majority' answer to a predicate function.

-- 
David J. Biesack     SAS Institute Inc.
R&D Java Strategist  SAS Campus Drive Cary, NC 27513
(919) 531-7771       http://www.sas.com


From dl@cs.oswego.edu  Wed Dec 17 13:14:41 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 17 Dec 2003 08:14:41 -0500
Subject: [concurrency-interest] Re: new task coordination operations (Doug Lea)
In-Reply-To: <200312161515.hBGFFoJ12449@mozart.unx.sas.com>
References: <20031215170001.13381.7051.Mailman@altair.cs.oswego.edu>
 <200312161515.hBGFFoJ12449@mozart.unx.sas.com>
Message-ID: <16352.22209.161471.374225@altair.cs.oswego.edu>

> Whenever I see two (and only two) options in an API, I think "looks like
> an opportunity for a strategy pattern". 

Agreed, almost. While it might look like it, ExecutorCompletionService
exists so that you can apply your own strategies/policies across
different contexts cases while still using a common framework/pattern.

The reason for not using a single pluggable strategy object here is
that the policy variation can encompass not only how many results to
process, but also whether and how the results should be combined,
whether to ignore those tasks that enounter exceptions, and whether to
cancel unfinished tasks upon return. So the only reasonable option we
know is to allow people to write the code dealing with each of these,
as appropriate.

The invokeAny and invokeAll methods provide ready-made solutions using
the most common policy choices for the two most common cases.  Some
new usage examples in ExecutorCompletionService show some additional
variations. Pasting them in:


 Usage Examples.  Suppose you have a set of solvers for a certain problem, and would like to run them concurrently, using the results of each of them that return a non-null value. You could write this as:

    void solve(Executor e, Collection<Callable<Result>> solvers) 
        throws InterruptedException, ExecutionException {
        ExecutorCompletionService<Result> ecs = new
            ExecutorCompletionService<Result>(e);
        for (Callable<Result> s : solvers)
            ecs.submit(s);
        int n = solvers.size();
        for (int i = 0; i < n; ++i) {
            Result r = ecs.take().get();
            if (r != null) 
                use(r);
        }
    }
 

Suppose instead that you would like to use the first non-null result of a set of tasks, ignoring any of those that encounter exceptions and cancelling all of the other tasks when the first one is ready:

    void solve(Executor e, Collection<Callable<Result>> solvers) 
        throws InterruptedException {
        ExecutorCompletionService<Result> ecs = 
            new ExecutorCompletionService<Result>(e);
        int n = solvers.size();
        ArrayList<Future<Result>> futures = 
            new ArrayList<Future<Result>>(n);
        Result result = null;
        try {
            for (Callable<Result> s : solvers)
                futures.add(ecs.submit(s));
            for (int i = 0; i < n; ++i) {
                try {
                    Result r = ecs.take().get();
                    if (r != null) {
                        result = r;
                        break;
                    }
                } catch(ExecutionException ignore) {}
            }
        }
        finally {
            for (<Future<Result> f : futures)
                f.cancel(true);
        }

        if (result != null)
            use(result);
    }
 

From dl@cs.oswego.edu  Sun Dec 21 15:57:30 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Sun, 21 Dec 2003 10:57:30 -0500
Subject: [concurrency-interest] Changes since initial public review spec
Message-ID: <16357.49898.3976.139301@altair.cs.oswego.edu>

We just posted a summary of changes since the initial
public review version of spec (in September), linked from the usual place:
  http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
Also pasted in below.

As we head toward final spec, we just made a few sanity-check passes
through APIs, making sure that things we've added or changed have
consistent names and specs. This led to a few minor changes, only one
worth mentioning: We replaced class PriviligedFutureTask (added in
October) with factory method Executors.priviligedCallable. There was
no reason to combine access control mechanics with Future mechanics.
Now you can use a priviligedCallable as the basis for any Future
implementation, not just the particular FutureTask implementation we
provide.

If you notice any other issues along these lines, please let us know.

Some of the listed changes will NOT appear in the first early-access
and beta1 Tiger releases. See the directions on the above web page for
how to use current versions anyway using -Xbootclasspath.

,,,


JSR166 changes since public review

The JSR166 expert group made the following changes since the initial
JCP public review version of the specification. Most of these were
responses to requests and comments from members of the concurrency
interest list. Additionally, several APIs were refactored to better
accommodate further possible extensions and adaptations brought to our
attention, in particular, those expected for J2EE. Besides numerous
minor specification and implementation improvements, and some
renamings to improve API consistency, the changes include:


   1. Execution methods producing Futures that were previously in the
      Executors "toolkit" class were renamed as submit and moved to
      the ExecutorService interface, with default implementations in a
      new AbstractExecutorService class. This enables extended
      implementations of ExecutorService to override these methods.

   2. Declarations of scheduling methods were abstracted into the new
      ScheduledExecutorService interface, and the implementation class
      was renamed to ScheduledThreadPoolExecutor. This enables other
      implementations to share the same interface.

   3. Methods from the Cancellable interface were merged into the
      Future interface, and CancellableTask implementation merged into
      FutureTask. This eliminates the unhelpful distinction between
      cancellability and the ability to wait for termination, that
      complicated both usage and extensibility. (Previous uses of
      Cancellable can be rephrased as Future<?>.)

   4. Support was added for coordinating execution of multiple tasks:
      ExecutorService now contains methods invokeAll and invokeAny,
      which handle some very common cases. Interface CompletionService
      and concrete class ExecutorCompletionService provide a way to
      control processing of a set of submitted tasks. Together, these
      provide standardized APIs for dealing with common asynchronous
      programming problems that were previously lacking.

   5. The ExecutorService shutdown methods are more carefully
      specified (and implemented) to cleanly fail when invoked by
      callers that do not have permission to modify threads.

   6. The Executors class now exports its methods producing "wrappers"
      that hide configuration settings of concrete ExecutorServices,
      so the methods can be used with any other ExecutorService
      implementation.

   7. The Executors class now provides methods to convert various
      other common "closure" types to Callables so they can be more
      readily used in contexts producing Futures.

   8. The Executors class now provides a defaultThreadFactory that
      places new threads in known states with respect to priority,
      daemon status, etc.

   9. There is now better support for execution of tasks requiring
      special security settings. Method
      Executors.privilegedThreadFactory creates threads with the
      prevailing access control settings, and
      Executors.privilegedCallable and related methods create actions
      that run, if allowed, within the settings prevailing when the
      actions are created.

  10. New replace() methods were added to interface ConcurrentMap and
      implementation ConcurrentHashMap. These address some common use
      cases previously overlooked.

  11. Instrumentation methods were added to the reentrant lock
      classes, to enable monitoring for contention etc. The reentrant
      lock classes also underwent some internal refactoring visible
      only in that they now inherit from new AbstractReentrantLock
      class. (This class is exported for the sake of providing
      javadocs but is not currently designed for extension outside of
      the package.)

  12. Instrumentation methods and "protected" utility methods were
      added to Semaphore, and the "fair" variant is now selectable
      using a constructor argument rather than being a subclass. These
      broaden the range of usefulness of this class.

  13. BlockingQueue now supports method drainTo, a bulk-poll operation
      that extracts some or all queued elements.

From Michael.Mayr@web.de  Tue Dec 23 22:42:09 2003
From: Michael.Mayr@web.de (Michael Mayr)
Date: Tue, 23 Dec 2003 23:42:09 +0100
Subject: [concurrency-interest] java.lang.System.nanoTime and QueryPerformanceCounter-"Bug"
Message-ID: <200312232242.hBNMg9Q23811@mailgate5.cinetic.de>

Hi,

The last few days I have been investigating "exact" time measuring in Java. During my investigations I found your project. nanoTime() will surely be a very useful addition to the Java platform. During my investigations I also found out that on Windows platforms some chipsets cause leaps forward in time (up to a few seconds) when using the QueryPerformanceCounter-Call (which is -to my knowledge- the only way to measure in nanoseconds on Windows). This behavior is documented under:

http://support.microsoft.com/default.aspx?scid=KB;EN-US;Q274323&

I took a look at your viewcvs-webinterface but couldn't find any native code. So I couldn't check if you do take this fact into account. IMHO leaps should be detected and if they are detected nanoTime() should return a nonvalid time (e.g. a negative time). I think it is not useful having a wrong time with a leap for profiling or anything like this.

I hope I could help.  (Don't say you haven't been warned ;-) )

Greetings
Michael
______________________________________________________________________________
Nachrichten, Musik und Spiele schnell und einfach per Quickstart im 
WEB.DE Screensaver - Gratis downloaden: http://screensaver.web.de/?mc=021110


From dholmes@dltech.com.au  Tue Dec 23 23:32:58 2003
From: dholmes@dltech.com.au (David Holmes)
Date: Wed, 24 Dec 2003 09:32:58 +1000
Subject: [concurrency-interest] java.lang.System.nanoTime and QueryPerformanceCounter-"Bug"
In-Reply-To: <200312232242.hBNMg9Q23811@mailgate5.cinetic.de>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEIBDLAA.dholmes@dltech.com.au>

Michael Mayr wrote:

> During my investigations I also found
> out that on Windows platforms some chipsets cause leaps
> forward in time (up to a few seconds) when using the
> QueryPerformanceCounter-Call (which is -to my knowledge-
> the only way to measure in nanoseconds on Windows).

You can also use assembler code to read the timestamp counter directly
(RDTSC instruction) and perform a calibration to establish a time base
for the counter. However there are numerous problems trying to use the
TSC and various issues with TSC drift across different CPU's in a
system. This is non-trivial stuff for sure. I suspect
QueryPerformanceCounter tries to mask these issues to make it easier
to use.

> I took a look at your viewcvs-webinterface but couldn't
> find any native code. So I couldn't check if you do take
> this fact into account. IMHO leaps should be detected and
> if they are detected nanoTime() should return a nonvalid
> time (e.g. a negative time). I think it is not useful
> having a wrong time with a leap for profiling or anything like this.

There is no notion of an "invalid time" as negative values from
nanoTime are possible. The only use for the return value from nanoTime
is to compare it with another return value from nanoTime.

The implementation is responsible for using the most sensible timing
mechanism to provide nanoTime and to account for as many
idiosyncracies as possible.


David Holmes


From Michael.Mayr@web.de  Wed Dec 24 02:24:11 2003
From: Michael.Mayr@web.de (Michael Mayr)
Date: Wed, 24 Dec 2003 03:24:11 +0100
Subject: [concurrency-interest] java.lang.System.nanoTime and QueryPerformanceCounter-"Bug"
Message-ID: <200312240224.hBO2OBQ02281@mailgate5.cinetic.de>

Hi David,

David Holmes wrote:
"There is no notion of an "invalid time" as negative values from
nanoTime are possible. The only use for the return value from nanoTime
is to compare it with another return value from nanoTime.

The implementation is responsible for using the most sensible timing
mechanism to provide nanoTime and to account for as many
idiosyncracies as possible."

Ok, I understand. Then what do you think of the following strategies:

With every call to System.nanoTime() you compare its results with the results of millisecond-accurate Time (which has always been available on Windows - but still System.currentTimeMillis() is only accurate to 10 ms (Win2k/NT) or 50 ms (Win9x). 
See http://developer.java.sun.com/developer/bugParade/bugs/4423429.html   
But that is another story). 

This way you can determine if a leap has occured and in this case return the millisecond accurate time (which is IMHO better than to return the nanosecond accurate time plus leap seconds). But you should give the developer a hint that this result may have only one millisecond accuracy and not just silently provide him with a result with accuracy LessThanNano when he expects nano accuracy because of the name of the method. This way the developer can resort to other strategies if the accuracy is not sufficient. E. g.  he could then profile 1000 calls to a method and then divide the result by 1000.

I mean something like this:

public static TimeResult nanoTime();

with:

public class TimeResult {
  long counts;
  java.util.concurrent.TimeUnit units;
}

which is IMHO nicer than the other accurate solution:

public static long nanoTime() throws InvalidTimeException, NotSupportedOnThisPlatformException

I'd like to hear what you think. 
Merry christmas.

Michael


______________________________________________________________________________
Nachrichten, Musik und Spiele schnell und einfach per Quickstart im 
WEB.DE Screensaver - Gratis downloaden: http://screensaver.web.de/?mc=021110


From dholmes@dltech.com.au  Wed Dec 24 02:44:35 2003
From: dholmes@dltech.com.au (David Holmes)
Date: Wed, 24 Dec 2003 12:44:35 +1000
Subject: [concurrency-interest] java.lang.System.nanoTime and QueryPerformanceCounter-"Bug"
In-Reply-To: <200312240224.hBO2OBQ02281@mailgate5.cinetic.de>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEIFDLAA.dholmes@dltech.com.au>

Michael,

> With every call to System.nanoTime() you compare its
> results with the results of millisecond-accurate Time

If an implementation knew that there were problems using the
underlying platform timing facilities then it would indeed have to
resort to something like this. Hopefully use of the TSC will avoid
such problems.

> This way you can determine if a leap has occured and in this case
return the
> millisecond accurate time (which is IMHO better than to return the
nanosecond
> accurate time plus leap seconds). But you should give the developer
a hint
> that this result may have only one millisecond accuracy and not just
silently
> provide him with a result with accuracy LessThanNano when he expects
nano
> accuracy because of the name of the method.

System.nanoTime is not required to have nanosecond accuracy only
nanosecond precision. An implementation that returned
currentTimeMillis()*1000000 would be a correct though low-quality
implementation. An implementation should document the accuracy of
nanoTime.

David Holmes


From dl@cs.oswego.edu  Sat Dec 27 20:04:57 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Sat, 27 Dec 2003 15:04:57 -0500
Subject: [concurrency-interest] Better support for custom locks
Message-ID: <16365.58857.167356.188574@altair.cs.oswego.edu>

While improving implementations of locks and related classes we came
upon a nicer factoring that allows simpler user (that's you :-)
construction of other lock and synchronization classes, without
sacrificing the need to keep internals of our main exported classes
non-public (thus allowing replacement someday if necessary). The class
AbstractQueuedSynchronizer replaces the previous
AbstractReentrantLock, keeping the same functionality, but repackaging
it to be extensible outside of the locks subpackage.  Class
AbstractQueuedSynchronizer is not exactly trivial to extend and use
for custom synchronizers, but, we hope, much easier/better than
alternatives.  I think those of you who have complained about needing
to copy/paste/hack when making new sync classes can stop doing that
now. If you'd like to give a shot at using it and report back
experiences, we'd be grateful.

-- 
Doug Lea, Computer Science Department, SUNY Oswego, Oswego, NY 13126 USA
dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424 http://gee.cs.oswego.edu/  

From dl@cs.oswego.edu  Sat Dec 27 20:29:12 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Sat, 27 Dec 2003 15:29:12 -0500
Subject: [concurrency-interest] Early-access JDK1.5
Message-ID: <16365.60312.242807.656687@altair.cs.oswego.edu>

In case you didn't hear: You can now try out an early-access version of
JDK1.5 (aka Tiger) via JavaLobby (http://www.javalobby.org).  The
version of JSR166 APIs in this release dates from mid-november.  But,
as mentioned before, you can use the current versions by following the
instructions at http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
And appended below for convenience. 

-Doug

...

If you are running an early access or beta version of 1.5, you can
make sure you are running the current versions listed in the javadocs
on this site by getting the jar file at
http://gee.cs.oswego.edu/dl/concurrent/dist/jsr166.jar, and run using:
  java -server -Xbootclasspath/p:/somepath/jsr166.jar Program

(The "server" option is not strictly needed but is highly recommended
for concurrent programs.) And to compile code, use javac switches:
  javac -source 1.5 -Xbootclasspath/p:/somepath/jsr166.jar Program.java


From Michael.Mayr@web.de  Sat Dec 27 20:54:14 2003
From: Michael.Mayr@web.de (Michael Mayr)
Date: Sat, 27 Dec 2003 21:54:14 +0100
Subject: [concurrency-interest] Early-access JDK1.5
Message-ID: <200312272054.hBRKsEQ16190@mailgate5.cinetic.de>

Please let me add that you can access 

Early Access
Java[tm] 2 SDK, Standard Edition 1.5.0 Alpha

here: http://java.sun.com/developer/earlyAccess/j2sdk150_alpha/

This doesn't require a javalobby registration (but a free Sun JDC registration which most of the serious java developers already have, e. g. for viewing bug reports or reading articles).
______________________________________________________________________________
UNICEF bringt Kriegskinder in die Schule - helfen Sie mit! 
https://www.unicef.de/spe/spe_03.php


From dl@cs.oswego.edu  Tue Dec 30 16:55:24 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Tue, 30 Dec 2003 11:55:24 -0500
Subject: [concurrency-interest] Fun with AbstractQueuedSynchronizers
Message-ID: <16369.44540.794965.55675@altair.cs.oswego.edu>

We've been fine-tuning AbstractQueuedSynchronizer and checking out
whether it serves as a useful basis for various custom sync utilities
and locks that we don't otherwise provide.  An example of one of these
is below.  I couldn't figure out what to do with it after making it,
so decided to post it here.

It's an analog of a WIN32 "Consumable" Event, that can be done in only
a few lines of implementation code, plus declarations and relays to
tie these to public methods.  (We once contemplated providing
something like this class in j.u.c. The reason we don't is that there
are only rare occasions when you'd prefer to use this over a
Semaphore, which is normally a better choice because it doen't "lose"
signals.)

...
import java.util.concurrent.*;
import java.util.concurrent.locks.*;
import java.util.concurrent.atomic.*;

/**
 * A ConsumedIndicator usually represents the occurrence of some kind
 * of event, for example a state transition or a sensed physical
 * phenomenon. It's behavior is similar to that of WIN32 "Consumable
 * Events".  The <tt>set</tt> operation establishes the existence of
 * the event and signals a waiting thread; this is consumed by the
 * <tt>>poll</tt> and <tt>await</tt> methods. Unlike similar
 * constructs such as Semaphores, signals in an ConsumedIndicator do
 * not "accumulate". A <tt>ConsumedIndicator</tt> is either signalled
 * or not, and the signalled status is cleared upon a successful
 * <tt>poll</tt> or <tt>await</tt>. Because of this,
 * ConsumedIndicators are not appropriate when each signal must be
 * dealt with.
 * 
 * <p><b>Sample usage:</b> 
 * <pre>
 * class HouseOfTheFuture {
 *   ConsumedIndicator newspaperArrived = new ConsumedIndicator();
 *   class DoorStepSensor implements Runnable { // run in some thread
 *      public void run() {
 *        for (;;) {
 *           if (sensedNewspaper()) 
 *              newspaperArrived.set();
 *           // ...
 *        }
 *     }
 *   }
 *   class RoboticDog implements Runnable { // run in some thread
 *      public void run() {
 *        for (;;) {
 *           try {
 *              newspaperArrived.await();
 *              fetchNewspaper();
 *              // ...
 *            } catch (InterruptedException ie) { 
 *              return; 
 *            }
 *         }
 *      }
 *   }
 *   // ...
 * }
 * </pre>
 */

public class ConsumedIndicator {
    /**
     * Synchronization control for ConsumedIndicator.
     * Uses AQS state to represent firing: zero for clear, one for set.
     */
    private static final class Sync extends AbstractQueuedSynchronizer {
        public int acquireExclusiveState(boolean isQueued, int ignore) {
            return compareAndSet(1, 0)? 0 : -1;
        }

        public boolean releaseExclusiveState(int ignore) {
            return compareAndSet(0, 1);
        }
    }

    /** Performs all sync control */
    private final Sync sync = new Sync();

    /**
     * Constructs a <tt>ConsumedIndicator</tt> with initially clear status.
     */
    public ConsumedIndicator() { 
    }

    /**
     * Set the indicator, waking a thread that may be waiting for it
     */
    public void set() {
        sync.releaseExclusive(0);
    }

    /**
     * Wait, if necessary, until indicator has been set, and when it
     * does, clear it.
     * @throws InterruptedException if the current thread is interrupted
     * while waiting.
     */
    public void await() throws InterruptedException {
        sync.acquireExclusiveInterruptibly(0);
    }
  
    /**
     * Return whether the indicator has been set, if so, clearing it.
     * @return true if the indicator has been set
     */
    public boolean poll() {
        return sync.acquireExclusiveState(false, 0) >= 0;
    }

    /**
     * Return whether the indicator has been set in given time, if so clearing it.
     * @param timeout the maximum time to wait
     * @param unit the time unit of the <tt>timeout</tt> argument.
     * @return true if the indicator has been set in the given time
     * @throws InterruptedException if the current thread is interrupted
     * while waiting.
     */
    public boolean poll(long timeout, TimeUnit unit) throws InterruptedException {
        return sync.acquireExclusiveTimed(0, unit.toNanos(timeout));
    }
}

